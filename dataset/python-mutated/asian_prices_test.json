[
    {
        "func_name": "test_option_prices",
        "original": "def test_option_prices(self):\n    \"\"\"Tests for methods for the asian pricing module.\n\n    Results come from 'Implementing Derivatives Model' by Clewlow, Strickland\n    p.118-123, via the QuantLib test suite\n    \"\"\"\n    spots = np.array([100.0])\n    dividend_rates = np.array([0.03])\n    discount_rates = np.array([0.06])\n    volatilities = np.array([0.2])\n    strikes = np.array([100.0])\n    expiries = 1.0\n    sampling_times = np.linspace(0.1, 1, 10)[:, np.newaxis]\n    expected_price = np.array([5.3425606635])\n    computed_price = tff.black_scholes.asian_option_price(spots=spots, dividend_rates=dividend_rates, discount_rates=discount_rates, volatilities=volatilities, strikes=strikes, expiries=expiries, sampling_times=sampling_times)\n    self.assertAllClose(expected_price, computed_price, 1e-10)",
        "mutated": [
            "def test_option_prices(self):\n    if False:\n        i = 10\n    \"Tests for methods for the asian pricing module.\\n\\n    Results come from 'Implementing Derivatives Model' by Clewlow, Strickland\\n    p.118-123, via the QuantLib test suite\\n    \"\n    spots = np.array([100.0])\n    dividend_rates = np.array([0.03])\n    discount_rates = np.array([0.06])\n    volatilities = np.array([0.2])\n    strikes = np.array([100.0])\n    expiries = 1.0\n    sampling_times = np.linspace(0.1, 1, 10)[:, np.newaxis]\n    expected_price = np.array([5.3425606635])\n    computed_price = tff.black_scholes.asian_option_price(spots=spots, dividend_rates=dividend_rates, discount_rates=discount_rates, volatilities=volatilities, strikes=strikes, expiries=expiries, sampling_times=sampling_times)\n    self.assertAllClose(expected_price, computed_price, 1e-10)",
            "def test_option_prices(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Tests for methods for the asian pricing module.\\n\\n    Results come from 'Implementing Derivatives Model' by Clewlow, Strickland\\n    p.118-123, via the QuantLib test suite\\n    \"\n    spots = np.array([100.0])\n    dividend_rates = np.array([0.03])\n    discount_rates = np.array([0.06])\n    volatilities = np.array([0.2])\n    strikes = np.array([100.0])\n    expiries = 1.0\n    sampling_times = np.linspace(0.1, 1, 10)[:, np.newaxis]\n    expected_price = np.array([5.3425606635])\n    computed_price = tff.black_scholes.asian_option_price(spots=spots, dividend_rates=dividend_rates, discount_rates=discount_rates, volatilities=volatilities, strikes=strikes, expiries=expiries, sampling_times=sampling_times)\n    self.assertAllClose(expected_price, computed_price, 1e-10)",
            "def test_option_prices(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Tests for methods for the asian pricing module.\\n\\n    Results come from 'Implementing Derivatives Model' by Clewlow, Strickland\\n    p.118-123, via the QuantLib test suite\\n    \"\n    spots = np.array([100.0])\n    dividend_rates = np.array([0.03])\n    discount_rates = np.array([0.06])\n    volatilities = np.array([0.2])\n    strikes = np.array([100.0])\n    expiries = 1.0\n    sampling_times = np.linspace(0.1, 1, 10)[:, np.newaxis]\n    expected_price = np.array([5.3425606635])\n    computed_price = tff.black_scholes.asian_option_price(spots=spots, dividend_rates=dividend_rates, discount_rates=discount_rates, volatilities=volatilities, strikes=strikes, expiries=expiries, sampling_times=sampling_times)\n    self.assertAllClose(expected_price, computed_price, 1e-10)",
            "def test_option_prices(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Tests for methods for the asian pricing module.\\n\\n    Results come from 'Implementing Derivatives Model' by Clewlow, Strickland\\n    p.118-123, via the QuantLib test suite\\n    \"\n    spots = np.array([100.0])\n    dividend_rates = np.array([0.03])\n    discount_rates = np.array([0.06])\n    volatilities = np.array([0.2])\n    strikes = np.array([100.0])\n    expiries = 1.0\n    sampling_times = np.linspace(0.1, 1, 10)[:, np.newaxis]\n    expected_price = np.array([5.3425606635])\n    computed_price = tff.black_scholes.asian_option_price(spots=spots, dividend_rates=dividend_rates, discount_rates=discount_rates, volatilities=volatilities, strikes=strikes, expiries=expiries, sampling_times=sampling_times)\n    self.assertAllClose(expected_price, computed_price, 1e-10)",
            "def test_option_prices(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Tests for methods for the asian pricing module.\\n\\n    Results come from 'Implementing Derivatives Model' by Clewlow, Strickland\\n    p.118-123, via the QuantLib test suite\\n    \"\n    spots = np.array([100.0])\n    dividend_rates = np.array([0.03])\n    discount_rates = np.array([0.06])\n    volatilities = np.array([0.2])\n    strikes = np.array([100.0])\n    expiries = 1.0\n    sampling_times = np.linspace(0.1, 1, 10)[:, np.newaxis]\n    expected_price = np.array([5.3425606635])\n    computed_price = tff.black_scholes.asian_option_price(spots=spots, dividend_rates=dividend_rates, discount_rates=discount_rates, volatilities=volatilities, strikes=strikes, expiries=expiries, sampling_times=sampling_times)\n    self.assertAllClose(expected_price, computed_price, 1e-10)"
        ]
    },
    {
        "func_name": "test_option_prices_scalar_inputs",
        "original": "def test_option_prices_scalar_inputs(self):\n    \"\"\"Tests for methods for the asian pricing module using scalar inputs.\n\n    Results come from 'Implementing Derivatives Model' by Clewlow, Strickland\n    p.118-123, via the QuantLib test suite\n    \"\"\"\n    spots = 100.0\n    dividend_rates = 0.03\n    discount_rates = 0.06\n    volatilities = 0.2\n    strikes = 100.0\n    expiries = 1.0\n    sampling_times = np.linspace(0.1, 1, 10)[:, np.newaxis]\n    expected_price = np.array([5.3425606635])\n    computed_price = tff.black_scholes.asian_option_price(spots=spots, dividend_rates=dividend_rates, discount_rates=discount_rates, volatilities=volatilities, strikes=strikes, expiries=expiries, sampling_times=sampling_times, dtype=np.float64)\n    self.assertAllClose(expected_price, computed_price, 1e-10)",
        "mutated": [
            "def test_option_prices_scalar_inputs(self):\n    if False:\n        i = 10\n    \"Tests for methods for the asian pricing module using scalar inputs.\\n\\n    Results come from 'Implementing Derivatives Model' by Clewlow, Strickland\\n    p.118-123, via the QuantLib test suite\\n    \"\n    spots = 100.0\n    dividend_rates = 0.03\n    discount_rates = 0.06\n    volatilities = 0.2\n    strikes = 100.0\n    expiries = 1.0\n    sampling_times = np.linspace(0.1, 1, 10)[:, np.newaxis]\n    expected_price = np.array([5.3425606635])\n    computed_price = tff.black_scholes.asian_option_price(spots=spots, dividend_rates=dividend_rates, discount_rates=discount_rates, volatilities=volatilities, strikes=strikes, expiries=expiries, sampling_times=sampling_times, dtype=np.float64)\n    self.assertAllClose(expected_price, computed_price, 1e-10)",
            "def test_option_prices_scalar_inputs(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Tests for methods for the asian pricing module using scalar inputs.\\n\\n    Results come from 'Implementing Derivatives Model' by Clewlow, Strickland\\n    p.118-123, via the QuantLib test suite\\n    \"\n    spots = 100.0\n    dividend_rates = 0.03\n    discount_rates = 0.06\n    volatilities = 0.2\n    strikes = 100.0\n    expiries = 1.0\n    sampling_times = np.linspace(0.1, 1, 10)[:, np.newaxis]\n    expected_price = np.array([5.3425606635])\n    computed_price = tff.black_scholes.asian_option_price(spots=spots, dividend_rates=dividend_rates, discount_rates=discount_rates, volatilities=volatilities, strikes=strikes, expiries=expiries, sampling_times=sampling_times, dtype=np.float64)\n    self.assertAllClose(expected_price, computed_price, 1e-10)",
            "def test_option_prices_scalar_inputs(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Tests for methods for the asian pricing module using scalar inputs.\\n\\n    Results come from 'Implementing Derivatives Model' by Clewlow, Strickland\\n    p.118-123, via the QuantLib test suite\\n    \"\n    spots = 100.0\n    dividend_rates = 0.03\n    discount_rates = 0.06\n    volatilities = 0.2\n    strikes = 100.0\n    expiries = 1.0\n    sampling_times = np.linspace(0.1, 1, 10)[:, np.newaxis]\n    expected_price = np.array([5.3425606635])\n    computed_price = tff.black_scholes.asian_option_price(spots=spots, dividend_rates=dividend_rates, discount_rates=discount_rates, volatilities=volatilities, strikes=strikes, expiries=expiries, sampling_times=sampling_times, dtype=np.float64)\n    self.assertAllClose(expected_price, computed_price, 1e-10)",
            "def test_option_prices_scalar_inputs(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Tests for methods for the asian pricing module using scalar inputs.\\n\\n    Results come from 'Implementing Derivatives Model' by Clewlow, Strickland\\n    p.118-123, via the QuantLib test suite\\n    \"\n    spots = 100.0\n    dividend_rates = 0.03\n    discount_rates = 0.06\n    volatilities = 0.2\n    strikes = 100.0\n    expiries = 1.0\n    sampling_times = np.linspace(0.1, 1, 10)[:, np.newaxis]\n    expected_price = np.array([5.3425606635])\n    computed_price = tff.black_scholes.asian_option_price(spots=spots, dividend_rates=dividend_rates, discount_rates=discount_rates, volatilities=volatilities, strikes=strikes, expiries=expiries, sampling_times=sampling_times, dtype=np.float64)\n    self.assertAllClose(expected_price, computed_price, 1e-10)",
            "def test_option_prices_scalar_inputs(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Tests for methods for the asian pricing module using scalar inputs.\\n\\n    Results come from 'Implementing Derivatives Model' by Clewlow, Strickland\\n    p.118-123, via the QuantLib test suite\\n    \"\n    spots = 100.0\n    dividend_rates = 0.03\n    discount_rates = 0.06\n    volatilities = 0.2\n    strikes = 100.0\n    expiries = 1.0\n    sampling_times = np.linspace(0.1, 1, 10)[:, np.newaxis]\n    expected_price = np.array([5.3425606635])\n    computed_price = tff.black_scholes.asian_option_price(spots=spots, dividend_rates=dividend_rates, discount_rates=discount_rates, volatilities=volatilities, strikes=strikes, expiries=expiries, sampling_times=sampling_times, dtype=np.float64)\n    self.assertAllClose(expected_price, computed_price, 1e-10)"
        ]
    },
    {
        "func_name": "test_single_sample_asian_matches_vanilla",
        "original": "def test_single_sample_asian_matches_vanilla(self):\n    \"\"\"Tests that a single sampling asian replicates vanilla prices.\"\"\"\n    forwards = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n    strikes = np.array([3.0, 3.0, 3.0, 3.0, 3.0])\n    volatilities = np.array([0.0001, 102.0, 2.0, 0.1, 0.4])\n    expiries = 1.0\n    computed_price_vanillas = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards))\n    sampling_times = np.array([[1.0, 1.0, 1.0, 1.0, 1.0]])\n    computed_price_asians = self.evaluate(tff.black_scholes.asian_option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, sampling_times=sampling_times))\n    self.assertArrayNear(computed_price_vanillas, computed_price_asians, 1e-10)",
        "mutated": [
            "def test_single_sample_asian_matches_vanilla(self):\n    if False:\n        i = 10\n    'Tests that a single sampling asian replicates vanilla prices.'\n    forwards = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n    strikes = np.array([3.0, 3.0, 3.0, 3.0, 3.0])\n    volatilities = np.array([0.0001, 102.0, 2.0, 0.1, 0.4])\n    expiries = 1.0\n    computed_price_vanillas = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards))\n    sampling_times = np.array([[1.0, 1.0, 1.0, 1.0, 1.0]])\n    computed_price_asians = self.evaluate(tff.black_scholes.asian_option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, sampling_times=sampling_times))\n    self.assertArrayNear(computed_price_vanillas, computed_price_asians, 1e-10)",
            "def test_single_sample_asian_matches_vanilla(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests that a single sampling asian replicates vanilla prices.'\n    forwards = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n    strikes = np.array([3.0, 3.0, 3.0, 3.0, 3.0])\n    volatilities = np.array([0.0001, 102.0, 2.0, 0.1, 0.4])\n    expiries = 1.0\n    computed_price_vanillas = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards))\n    sampling_times = np.array([[1.0, 1.0, 1.0, 1.0, 1.0]])\n    computed_price_asians = self.evaluate(tff.black_scholes.asian_option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, sampling_times=sampling_times))\n    self.assertArrayNear(computed_price_vanillas, computed_price_asians, 1e-10)",
            "def test_single_sample_asian_matches_vanilla(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests that a single sampling asian replicates vanilla prices.'\n    forwards = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n    strikes = np.array([3.0, 3.0, 3.0, 3.0, 3.0])\n    volatilities = np.array([0.0001, 102.0, 2.0, 0.1, 0.4])\n    expiries = 1.0\n    computed_price_vanillas = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards))\n    sampling_times = np.array([[1.0, 1.0, 1.0, 1.0, 1.0]])\n    computed_price_asians = self.evaluate(tff.black_scholes.asian_option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, sampling_times=sampling_times))\n    self.assertArrayNear(computed_price_vanillas, computed_price_asians, 1e-10)",
            "def test_single_sample_asian_matches_vanilla(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests that a single sampling asian replicates vanilla prices.'\n    forwards = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n    strikes = np.array([3.0, 3.0, 3.0, 3.0, 3.0])\n    volatilities = np.array([0.0001, 102.0, 2.0, 0.1, 0.4])\n    expiries = 1.0\n    computed_price_vanillas = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards))\n    sampling_times = np.array([[1.0, 1.0, 1.0, 1.0, 1.0]])\n    computed_price_asians = self.evaluate(tff.black_scholes.asian_option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, sampling_times=sampling_times))\n    self.assertArrayNear(computed_price_vanillas, computed_price_asians, 1e-10)",
            "def test_single_sample_asian_matches_vanilla(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests that a single sampling asian replicates vanilla prices.'\n    forwards = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n    strikes = np.array([3.0, 3.0, 3.0, 3.0, 3.0])\n    volatilities = np.array([0.0001, 102.0, 2.0, 0.1, 0.4])\n    expiries = 1.0\n    computed_price_vanillas = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards))\n    sampling_times = np.array([[1.0, 1.0, 1.0, 1.0, 1.0]])\n    computed_price_asians = self.evaluate(tff.black_scholes.asian_option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, sampling_times=sampling_times))\n    self.assertArrayNear(computed_price_vanillas, computed_price_asians, 1e-10)"
        ]
    },
    {
        "func_name": "drift_fn",
        "original": "def drift_fn(t, x):\n    del t, x\n    return discount_rates - dividend_rates - 0.5 * sigma ** 2",
        "mutated": [
            "def drift_fn(t, x):\n    if False:\n        i = 10\n    del t, x\n    return discount_rates - dividend_rates - 0.5 * sigma ** 2",
            "def drift_fn(t, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    del t, x\n    return discount_rates - dividend_rates - 0.5 * sigma ** 2",
            "def drift_fn(t, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    del t, x\n    return discount_rates - dividend_rates - 0.5 * sigma ** 2",
            "def drift_fn(t, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    del t, x\n    return discount_rates - dividend_rates - 0.5 * sigma ** 2",
            "def drift_fn(t, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    del t, x\n    return discount_rates - dividend_rates - 0.5 * sigma ** 2"
        ]
    },
    {
        "func_name": "vol_fn",
        "original": "def vol_fn(t, x):\n    del t, x\n    return tf.reshape(sigma, [1, 1])",
        "mutated": [
            "def vol_fn(t, x):\n    if False:\n        i = 10\n    del t, x\n    return tf.reshape(sigma, [1, 1])",
            "def vol_fn(t, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    del t, x\n    return tf.reshape(sigma, [1, 1])",
            "def vol_fn(t, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    del t, x\n    return tf.reshape(sigma, [1, 1])",
            "def vol_fn(t, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    del t, x\n    return tf.reshape(sigma, [1, 1])",
            "def vol_fn(t, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    del t, x\n    return tf.reshape(sigma, [1, 1])"
        ]
    },
    {
        "func_name": "price_asian_options",
        "original": "def price_asian_options(strikes, spot, sigma):\n\n    def drift_fn(t, x):\n        del t, x\n        return discount_rates - dividend_rates - 0.5 * sigma ** 2\n\n    def vol_fn(t, x):\n        del t, x\n        return tf.reshape(sigma, [1, 1])\n    process = tff.models.GenericItoProcess(dim=1, drift_fn=drift_fn, volatility_fn=vol_fn, dtype=dtype)\n    log_spot = tf.math.log(tf.reduce_mean(spot))\n    if watch_params:\n        watch_params_list = [sigma]\n    else:\n        watch_params_list = None\n    paths = process.sample_paths(sampling_times, num_samples=num_samples, initial_state=log_spot, watch_params=watch_params_list, random_type=tff.math.random.RandomType.PSEUDO_ANTITHETIC, seed=43, time_step=dt)\n    prices = tf.exp(-tf.expand_dims(discount_rates * expiries, axis=-1)) * tf.reduce_mean(tf.nn.relu(tf.math.exp(tf.reduce_mean(paths, [1])) - strikes), [0])\n    return prices",
        "mutated": [
            "def price_asian_options(strikes, spot, sigma):\n    if False:\n        i = 10\n\n    def drift_fn(t, x):\n        del t, x\n        return discount_rates - dividend_rates - 0.5 * sigma ** 2\n\n    def vol_fn(t, x):\n        del t, x\n        return tf.reshape(sigma, [1, 1])\n    process = tff.models.GenericItoProcess(dim=1, drift_fn=drift_fn, volatility_fn=vol_fn, dtype=dtype)\n    log_spot = tf.math.log(tf.reduce_mean(spot))\n    if watch_params:\n        watch_params_list = [sigma]\n    else:\n        watch_params_list = None\n    paths = process.sample_paths(sampling_times, num_samples=num_samples, initial_state=log_spot, watch_params=watch_params_list, random_type=tff.math.random.RandomType.PSEUDO_ANTITHETIC, seed=43, time_step=dt)\n    prices = tf.exp(-tf.expand_dims(discount_rates * expiries, axis=-1)) * tf.reduce_mean(tf.nn.relu(tf.math.exp(tf.reduce_mean(paths, [1])) - strikes), [0])\n    return prices",
            "def price_asian_options(strikes, spot, sigma):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    def drift_fn(t, x):\n        del t, x\n        return discount_rates - dividend_rates - 0.5 * sigma ** 2\n\n    def vol_fn(t, x):\n        del t, x\n        return tf.reshape(sigma, [1, 1])\n    process = tff.models.GenericItoProcess(dim=1, drift_fn=drift_fn, volatility_fn=vol_fn, dtype=dtype)\n    log_spot = tf.math.log(tf.reduce_mean(spot))\n    if watch_params:\n        watch_params_list = [sigma]\n    else:\n        watch_params_list = None\n    paths = process.sample_paths(sampling_times, num_samples=num_samples, initial_state=log_spot, watch_params=watch_params_list, random_type=tff.math.random.RandomType.PSEUDO_ANTITHETIC, seed=43, time_step=dt)\n    prices = tf.exp(-tf.expand_dims(discount_rates * expiries, axis=-1)) * tf.reduce_mean(tf.nn.relu(tf.math.exp(tf.reduce_mean(paths, [1])) - strikes), [0])\n    return prices",
            "def price_asian_options(strikes, spot, sigma):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    def drift_fn(t, x):\n        del t, x\n        return discount_rates - dividend_rates - 0.5 * sigma ** 2\n\n    def vol_fn(t, x):\n        del t, x\n        return tf.reshape(sigma, [1, 1])\n    process = tff.models.GenericItoProcess(dim=1, drift_fn=drift_fn, volatility_fn=vol_fn, dtype=dtype)\n    log_spot = tf.math.log(tf.reduce_mean(spot))\n    if watch_params:\n        watch_params_list = [sigma]\n    else:\n        watch_params_list = None\n    paths = process.sample_paths(sampling_times, num_samples=num_samples, initial_state=log_spot, watch_params=watch_params_list, random_type=tff.math.random.RandomType.PSEUDO_ANTITHETIC, seed=43, time_step=dt)\n    prices = tf.exp(-tf.expand_dims(discount_rates * expiries, axis=-1)) * tf.reduce_mean(tf.nn.relu(tf.math.exp(tf.reduce_mean(paths, [1])) - strikes), [0])\n    return prices",
            "def price_asian_options(strikes, spot, sigma):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    def drift_fn(t, x):\n        del t, x\n        return discount_rates - dividend_rates - 0.5 * sigma ** 2\n\n    def vol_fn(t, x):\n        del t, x\n        return tf.reshape(sigma, [1, 1])\n    process = tff.models.GenericItoProcess(dim=1, drift_fn=drift_fn, volatility_fn=vol_fn, dtype=dtype)\n    log_spot = tf.math.log(tf.reduce_mean(spot))\n    if watch_params:\n        watch_params_list = [sigma]\n    else:\n        watch_params_list = None\n    paths = process.sample_paths(sampling_times, num_samples=num_samples, initial_state=log_spot, watch_params=watch_params_list, random_type=tff.math.random.RandomType.PSEUDO_ANTITHETIC, seed=43, time_step=dt)\n    prices = tf.exp(-tf.expand_dims(discount_rates * expiries, axis=-1)) * tf.reduce_mean(tf.nn.relu(tf.math.exp(tf.reduce_mean(paths, [1])) - strikes), [0])\n    return prices",
            "def price_asian_options(strikes, spot, sigma):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    def drift_fn(t, x):\n        del t, x\n        return discount_rates - dividend_rates - 0.5 * sigma ** 2\n\n    def vol_fn(t, x):\n        del t, x\n        return tf.reshape(sigma, [1, 1])\n    process = tff.models.GenericItoProcess(dim=1, drift_fn=drift_fn, volatility_fn=vol_fn, dtype=dtype)\n    log_spot = tf.math.log(tf.reduce_mean(spot))\n    if watch_params:\n        watch_params_list = [sigma]\n    else:\n        watch_params_list = None\n    paths = process.sample_paths(sampling_times, num_samples=num_samples, initial_state=log_spot, watch_params=watch_params_list, random_type=tff.math.random.RandomType.PSEUDO_ANTITHETIC, seed=43, time_step=dt)\n    prices = tf.exp(-tf.expand_dims(discount_rates * expiries, axis=-1)) * tf.reduce_mean(tf.nn.relu(tf.math.exp(tf.reduce_mean(paths, [1])) - strikes), [0])\n    return prices"
        ]
    },
    {
        "func_name": "set_up_pricer",
        "original": "def set_up_pricer(expiries, watch_params=False):\n\n    def price_asian_options(strikes, spot, sigma):\n\n        def drift_fn(t, x):\n            del t, x\n            return discount_rates - dividend_rates - 0.5 * sigma ** 2\n\n        def vol_fn(t, x):\n            del t, x\n            return tf.reshape(sigma, [1, 1])\n        process = tff.models.GenericItoProcess(dim=1, drift_fn=drift_fn, volatility_fn=vol_fn, dtype=dtype)\n        log_spot = tf.math.log(tf.reduce_mean(spot))\n        if watch_params:\n            watch_params_list = [sigma]\n        else:\n            watch_params_list = None\n        paths = process.sample_paths(sampling_times, num_samples=num_samples, initial_state=log_spot, watch_params=watch_params_list, random_type=tff.math.random.RandomType.PSEUDO_ANTITHETIC, seed=43, time_step=dt)\n        prices = tf.exp(-tf.expand_dims(discount_rates * expiries, axis=-1)) * tf.reduce_mean(tf.nn.relu(tf.math.exp(tf.reduce_mean(paths, [1])) - strikes), [0])\n        return prices\n    return price_asian_options",
        "mutated": [
            "def set_up_pricer(expiries, watch_params=False):\n    if False:\n        i = 10\n\n    def price_asian_options(strikes, spot, sigma):\n\n        def drift_fn(t, x):\n            del t, x\n            return discount_rates - dividend_rates - 0.5 * sigma ** 2\n\n        def vol_fn(t, x):\n            del t, x\n            return tf.reshape(sigma, [1, 1])\n        process = tff.models.GenericItoProcess(dim=1, drift_fn=drift_fn, volatility_fn=vol_fn, dtype=dtype)\n        log_spot = tf.math.log(tf.reduce_mean(spot))\n        if watch_params:\n            watch_params_list = [sigma]\n        else:\n            watch_params_list = None\n        paths = process.sample_paths(sampling_times, num_samples=num_samples, initial_state=log_spot, watch_params=watch_params_list, random_type=tff.math.random.RandomType.PSEUDO_ANTITHETIC, seed=43, time_step=dt)\n        prices = tf.exp(-tf.expand_dims(discount_rates * expiries, axis=-1)) * tf.reduce_mean(tf.nn.relu(tf.math.exp(tf.reduce_mean(paths, [1])) - strikes), [0])\n        return prices\n    return price_asian_options",
            "def set_up_pricer(expiries, watch_params=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    def price_asian_options(strikes, spot, sigma):\n\n        def drift_fn(t, x):\n            del t, x\n            return discount_rates - dividend_rates - 0.5 * sigma ** 2\n\n        def vol_fn(t, x):\n            del t, x\n            return tf.reshape(sigma, [1, 1])\n        process = tff.models.GenericItoProcess(dim=1, drift_fn=drift_fn, volatility_fn=vol_fn, dtype=dtype)\n        log_spot = tf.math.log(tf.reduce_mean(spot))\n        if watch_params:\n            watch_params_list = [sigma]\n        else:\n            watch_params_list = None\n        paths = process.sample_paths(sampling_times, num_samples=num_samples, initial_state=log_spot, watch_params=watch_params_list, random_type=tff.math.random.RandomType.PSEUDO_ANTITHETIC, seed=43, time_step=dt)\n        prices = tf.exp(-tf.expand_dims(discount_rates * expiries, axis=-1)) * tf.reduce_mean(tf.nn.relu(tf.math.exp(tf.reduce_mean(paths, [1])) - strikes), [0])\n        return prices\n    return price_asian_options",
            "def set_up_pricer(expiries, watch_params=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    def price_asian_options(strikes, spot, sigma):\n\n        def drift_fn(t, x):\n            del t, x\n            return discount_rates - dividend_rates - 0.5 * sigma ** 2\n\n        def vol_fn(t, x):\n            del t, x\n            return tf.reshape(sigma, [1, 1])\n        process = tff.models.GenericItoProcess(dim=1, drift_fn=drift_fn, volatility_fn=vol_fn, dtype=dtype)\n        log_spot = tf.math.log(tf.reduce_mean(spot))\n        if watch_params:\n            watch_params_list = [sigma]\n        else:\n            watch_params_list = None\n        paths = process.sample_paths(sampling_times, num_samples=num_samples, initial_state=log_spot, watch_params=watch_params_list, random_type=tff.math.random.RandomType.PSEUDO_ANTITHETIC, seed=43, time_step=dt)\n        prices = tf.exp(-tf.expand_dims(discount_rates * expiries, axis=-1)) * tf.reduce_mean(tf.nn.relu(tf.math.exp(tf.reduce_mean(paths, [1])) - strikes), [0])\n        return prices\n    return price_asian_options",
            "def set_up_pricer(expiries, watch_params=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    def price_asian_options(strikes, spot, sigma):\n\n        def drift_fn(t, x):\n            del t, x\n            return discount_rates - dividend_rates - 0.5 * sigma ** 2\n\n        def vol_fn(t, x):\n            del t, x\n            return tf.reshape(sigma, [1, 1])\n        process = tff.models.GenericItoProcess(dim=1, drift_fn=drift_fn, volatility_fn=vol_fn, dtype=dtype)\n        log_spot = tf.math.log(tf.reduce_mean(spot))\n        if watch_params:\n            watch_params_list = [sigma]\n        else:\n            watch_params_list = None\n        paths = process.sample_paths(sampling_times, num_samples=num_samples, initial_state=log_spot, watch_params=watch_params_list, random_type=tff.math.random.RandomType.PSEUDO_ANTITHETIC, seed=43, time_step=dt)\n        prices = tf.exp(-tf.expand_dims(discount_rates * expiries, axis=-1)) * tf.reduce_mean(tf.nn.relu(tf.math.exp(tf.reduce_mean(paths, [1])) - strikes), [0])\n        return prices\n    return price_asian_options",
            "def set_up_pricer(expiries, watch_params=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    def price_asian_options(strikes, spot, sigma):\n\n        def drift_fn(t, x):\n            del t, x\n            return discount_rates - dividend_rates - 0.5 * sigma ** 2\n\n        def vol_fn(t, x):\n            del t, x\n            return tf.reshape(sigma, [1, 1])\n        process = tff.models.GenericItoProcess(dim=1, drift_fn=drift_fn, volatility_fn=vol_fn, dtype=dtype)\n        log_spot = tf.math.log(tf.reduce_mean(spot))\n        if watch_params:\n            watch_params_list = [sigma]\n        else:\n            watch_params_list = None\n        paths = process.sample_paths(sampling_times, num_samples=num_samples, initial_state=log_spot, watch_params=watch_params_list, random_type=tff.math.random.RandomType.PSEUDO_ANTITHETIC, seed=43, time_step=dt)\n        prices = tf.exp(-tf.expand_dims(discount_rates * expiries, axis=-1)) * tf.reduce_mean(tf.nn.relu(tf.math.exp(tf.reduce_mean(paths, [1])) - strikes), [0])\n        return prices\n    return price_asian_options"
        ]
    },
    {
        "func_name": "test_analytic_pricer_vs_monte_carlo",
        "original": "def test_analytic_pricer_vs_monte_carlo(self):\n    \"\"\"Tests that analytic calculator and monte carlo match closely.\"\"\"\n    volatilities = np.array([0.1])\n    spots = np.array([650.0, 650.0, 650.0, 650.0, 650.0])\n    strikes = np.array([550.0, 600.0, 650.0, 680.0, 730.0])\n    expiries = np.array([1.0])\n    discount_rates = np.array([0.03])\n    dividend_rates = np.array([0.01])\n    sampling_times = np.array([[0.5, 0.5, 0.5, 0.5, 0.5], [1.0, 1.0, 1.0, 1.0, 1.0]])\n    computed_prices = tff.black_scholes.asian_option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, spots=spots, discount_rates=discount_rates, dividend_rates=dividend_rates, sampling_times=sampling_times)\n    dtype = np.float64\n    num_samples = 500000\n    num_timesteps = 100\n    dt = 1.0 / num_timesteps\n    sigma = tf.constant(volatilities[0], dtype=dtype)\n    spot = tf.constant(spots[0], dtype=dtype)\n    sampling_times = tf.constant([0.5, 1.0], dtype=dtype)\n    sampling_times = tf.constant([0.5, 1.0], dtype=dtype)\n\n    def set_up_pricer(expiries, watch_params=False):\n\n        def price_asian_options(strikes, spot, sigma):\n\n            def drift_fn(t, x):\n                del t, x\n                return discount_rates - dividend_rates - 0.5 * sigma ** 2\n\n            def vol_fn(t, x):\n                del t, x\n                return tf.reshape(sigma, [1, 1])\n            process = tff.models.GenericItoProcess(dim=1, drift_fn=drift_fn, volatility_fn=vol_fn, dtype=dtype)\n            log_spot = tf.math.log(tf.reduce_mean(spot))\n            if watch_params:\n                watch_params_list = [sigma]\n            else:\n                watch_params_list = None\n            paths = process.sample_paths(sampling_times, num_samples=num_samples, initial_state=log_spot, watch_params=watch_params_list, random_type=tff.math.random.RandomType.PSEUDO_ANTITHETIC, seed=43, time_step=dt)\n            prices = tf.exp(-tf.expand_dims(discount_rates * expiries, axis=-1)) * tf.reduce_mean(tf.nn.relu(tf.math.exp(tf.reduce_mean(paths, [1])) - strikes), [0])\n            return prices\n        return price_asian_options\n    price_asian_options = tf.function(set_up_pricer(expiries))\n    mc_prices = price_asian_options(strikes, spot, sigma)\n    self.assertAllClose(computed_prices, mc_prices[0], 0.01)",
        "mutated": [
            "def test_analytic_pricer_vs_monte_carlo(self):\n    if False:\n        i = 10\n    'Tests that analytic calculator and monte carlo match closely.'\n    volatilities = np.array([0.1])\n    spots = np.array([650.0, 650.0, 650.0, 650.0, 650.0])\n    strikes = np.array([550.0, 600.0, 650.0, 680.0, 730.0])\n    expiries = np.array([1.0])\n    discount_rates = np.array([0.03])\n    dividend_rates = np.array([0.01])\n    sampling_times = np.array([[0.5, 0.5, 0.5, 0.5, 0.5], [1.0, 1.0, 1.0, 1.0, 1.0]])\n    computed_prices = tff.black_scholes.asian_option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, spots=spots, discount_rates=discount_rates, dividend_rates=dividend_rates, sampling_times=sampling_times)\n    dtype = np.float64\n    num_samples = 500000\n    num_timesteps = 100\n    dt = 1.0 / num_timesteps\n    sigma = tf.constant(volatilities[0], dtype=dtype)\n    spot = tf.constant(spots[0], dtype=dtype)\n    sampling_times = tf.constant([0.5, 1.0], dtype=dtype)\n    sampling_times = tf.constant([0.5, 1.0], dtype=dtype)\n\n    def set_up_pricer(expiries, watch_params=False):\n\n        def price_asian_options(strikes, spot, sigma):\n\n            def drift_fn(t, x):\n                del t, x\n                return discount_rates - dividend_rates - 0.5 * sigma ** 2\n\n            def vol_fn(t, x):\n                del t, x\n                return tf.reshape(sigma, [1, 1])\n            process = tff.models.GenericItoProcess(dim=1, drift_fn=drift_fn, volatility_fn=vol_fn, dtype=dtype)\n            log_spot = tf.math.log(tf.reduce_mean(spot))\n            if watch_params:\n                watch_params_list = [sigma]\n            else:\n                watch_params_list = None\n            paths = process.sample_paths(sampling_times, num_samples=num_samples, initial_state=log_spot, watch_params=watch_params_list, random_type=tff.math.random.RandomType.PSEUDO_ANTITHETIC, seed=43, time_step=dt)\n            prices = tf.exp(-tf.expand_dims(discount_rates * expiries, axis=-1)) * tf.reduce_mean(tf.nn.relu(tf.math.exp(tf.reduce_mean(paths, [1])) - strikes), [0])\n            return prices\n        return price_asian_options\n    price_asian_options = tf.function(set_up_pricer(expiries))\n    mc_prices = price_asian_options(strikes, spot, sigma)\n    self.assertAllClose(computed_prices, mc_prices[0], 0.01)",
            "def test_analytic_pricer_vs_monte_carlo(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests that analytic calculator and monte carlo match closely.'\n    volatilities = np.array([0.1])\n    spots = np.array([650.0, 650.0, 650.0, 650.0, 650.0])\n    strikes = np.array([550.0, 600.0, 650.0, 680.0, 730.0])\n    expiries = np.array([1.0])\n    discount_rates = np.array([0.03])\n    dividend_rates = np.array([0.01])\n    sampling_times = np.array([[0.5, 0.5, 0.5, 0.5, 0.5], [1.0, 1.0, 1.0, 1.0, 1.0]])\n    computed_prices = tff.black_scholes.asian_option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, spots=spots, discount_rates=discount_rates, dividend_rates=dividend_rates, sampling_times=sampling_times)\n    dtype = np.float64\n    num_samples = 500000\n    num_timesteps = 100\n    dt = 1.0 / num_timesteps\n    sigma = tf.constant(volatilities[0], dtype=dtype)\n    spot = tf.constant(spots[0], dtype=dtype)\n    sampling_times = tf.constant([0.5, 1.0], dtype=dtype)\n    sampling_times = tf.constant([0.5, 1.0], dtype=dtype)\n\n    def set_up_pricer(expiries, watch_params=False):\n\n        def price_asian_options(strikes, spot, sigma):\n\n            def drift_fn(t, x):\n                del t, x\n                return discount_rates - dividend_rates - 0.5 * sigma ** 2\n\n            def vol_fn(t, x):\n                del t, x\n                return tf.reshape(sigma, [1, 1])\n            process = tff.models.GenericItoProcess(dim=1, drift_fn=drift_fn, volatility_fn=vol_fn, dtype=dtype)\n            log_spot = tf.math.log(tf.reduce_mean(spot))\n            if watch_params:\n                watch_params_list = [sigma]\n            else:\n                watch_params_list = None\n            paths = process.sample_paths(sampling_times, num_samples=num_samples, initial_state=log_spot, watch_params=watch_params_list, random_type=tff.math.random.RandomType.PSEUDO_ANTITHETIC, seed=43, time_step=dt)\n            prices = tf.exp(-tf.expand_dims(discount_rates * expiries, axis=-1)) * tf.reduce_mean(tf.nn.relu(tf.math.exp(tf.reduce_mean(paths, [1])) - strikes), [0])\n            return prices\n        return price_asian_options\n    price_asian_options = tf.function(set_up_pricer(expiries))\n    mc_prices = price_asian_options(strikes, spot, sigma)\n    self.assertAllClose(computed_prices, mc_prices[0], 0.01)",
            "def test_analytic_pricer_vs_monte_carlo(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests that analytic calculator and monte carlo match closely.'\n    volatilities = np.array([0.1])\n    spots = np.array([650.0, 650.0, 650.0, 650.0, 650.0])\n    strikes = np.array([550.0, 600.0, 650.0, 680.0, 730.0])\n    expiries = np.array([1.0])\n    discount_rates = np.array([0.03])\n    dividend_rates = np.array([0.01])\n    sampling_times = np.array([[0.5, 0.5, 0.5, 0.5, 0.5], [1.0, 1.0, 1.0, 1.0, 1.0]])\n    computed_prices = tff.black_scholes.asian_option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, spots=spots, discount_rates=discount_rates, dividend_rates=dividend_rates, sampling_times=sampling_times)\n    dtype = np.float64\n    num_samples = 500000\n    num_timesteps = 100\n    dt = 1.0 / num_timesteps\n    sigma = tf.constant(volatilities[0], dtype=dtype)\n    spot = tf.constant(spots[0], dtype=dtype)\n    sampling_times = tf.constant([0.5, 1.0], dtype=dtype)\n    sampling_times = tf.constant([0.5, 1.0], dtype=dtype)\n\n    def set_up_pricer(expiries, watch_params=False):\n\n        def price_asian_options(strikes, spot, sigma):\n\n            def drift_fn(t, x):\n                del t, x\n                return discount_rates - dividend_rates - 0.5 * sigma ** 2\n\n            def vol_fn(t, x):\n                del t, x\n                return tf.reshape(sigma, [1, 1])\n            process = tff.models.GenericItoProcess(dim=1, drift_fn=drift_fn, volatility_fn=vol_fn, dtype=dtype)\n            log_spot = tf.math.log(tf.reduce_mean(spot))\n            if watch_params:\n                watch_params_list = [sigma]\n            else:\n                watch_params_list = None\n            paths = process.sample_paths(sampling_times, num_samples=num_samples, initial_state=log_spot, watch_params=watch_params_list, random_type=tff.math.random.RandomType.PSEUDO_ANTITHETIC, seed=43, time_step=dt)\n            prices = tf.exp(-tf.expand_dims(discount_rates * expiries, axis=-1)) * tf.reduce_mean(tf.nn.relu(tf.math.exp(tf.reduce_mean(paths, [1])) - strikes), [0])\n            return prices\n        return price_asian_options\n    price_asian_options = tf.function(set_up_pricer(expiries))\n    mc_prices = price_asian_options(strikes, spot, sigma)\n    self.assertAllClose(computed_prices, mc_prices[0], 0.01)",
            "def test_analytic_pricer_vs_monte_carlo(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests that analytic calculator and monte carlo match closely.'\n    volatilities = np.array([0.1])\n    spots = np.array([650.0, 650.0, 650.0, 650.0, 650.0])\n    strikes = np.array([550.0, 600.0, 650.0, 680.0, 730.0])\n    expiries = np.array([1.0])\n    discount_rates = np.array([0.03])\n    dividend_rates = np.array([0.01])\n    sampling_times = np.array([[0.5, 0.5, 0.5, 0.5, 0.5], [1.0, 1.0, 1.0, 1.0, 1.0]])\n    computed_prices = tff.black_scholes.asian_option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, spots=spots, discount_rates=discount_rates, dividend_rates=dividend_rates, sampling_times=sampling_times)\n    dtype = np.float64\n    num_samples = 500000\n    num_timesteps = 100\n    dt = 1.0 / num_timesteps\n    sigma = tf.constant(volatilities[0], dtype=dtype)\n    spot = tf.constant(spots[0], dtype=dtype)\n    sampling_times = tf.constant([0.5, 1.0], dtype=dtype)\n    sampling_times = tf.constant([0.5, 1.0], dtype=dtype)\n\n    def set_up_pricer(expiries, watch_params=False):\n\n        def price_asian_options(strikes, spot, sigma):\n\n            def drift_fn(t, x):\n                del t, x\n                return discount_rates - dividend_rates - 0.5 * sigma ** 2\n\n            def vol_fn(t, x):\n                del t, x\n                return tf.reshape(sigma, [1, 1])\n            process = tff.models.GenericItoProcess(dim=1, drift_fn=drift_fn, volatility_fn=vol_fn, dtype=dtype)\n            log_spot = tf.math.log(tf.reduce_mean(spot))\n            if watch_params:\n                watch_params_list = [sigma]\n            else:\n                watch_params_list = None\n            paths = process.sample_paths(sampling_times, num_samples=num_samples, initial_state=log_spot, watch_params=watch_params_list, random_type=tff.math.random.RandomType.PSEUDO_ANTITHETIC, seed=43, time_step=dt)\n            prices = tf.exp(-tf.expand_dims(discount_rates * expiries, axis=-1)) * tf.reduce_mean(tf.nn.relu(tf.math.exp(tf.reduce_mean(paths, [1])) - strikes), [0])\n            return prices\n        return price_asian_options\n    price_asian_options = tf.function(set_up_pricer(expiries))\n    mc_prices = price_asian_options(strikes, spot, sigma)\n    self.assertAllClose(computed_prices, mc_prices[0], 0.01)",
            "def test_analytic_pricer_vs_monte_carlo(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests that analytic calculator and monte carlo match closely.'\n    volatilities = np.array([0.1])\n    spots = np.array([650.0, 650.0, 650.0, 650.0, 650.0])\n    strikes = np.array([550.0, 600.0, 650.0, 680.0, 730.0])\n    expiries = np.array([1.0])\n    discount_rates = np.array([0.03])\n    dividend_rates = np.array([0.01])\n    sampling_times = np.array([[0.5, 0.5, 0.5, 0.5, 0.5], [1.0, 1.0, 1.0, 1.0, 1.0]])\n    computed_prices = tff.black_scholes.asian_option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, spots=spots, discount_rates=discount_rates, dividend_rates=dividend_rates, sampling_times=sampling_times)\n    dtype = np.float64\n    num_samples = 500000\n    num_timesteps = 100\n    dt = 1.0 / num_timesteps\n    sigma = tf.constant(volatilities[0], dtype=dtype)\n    spot = tf.constant(spots[0], dtype=dtype)\n    sampling_times = tf.constant([0.5, 1.0], dtype=dtype)\n    sampling_times = tf.constant([0.5, 1.0], dtype=dtype)\n\n    def set_up_pricer(expiries, watch_params=False):\n\n        def price_asian_options(strikes, spot, sigma):\n\n            def drift_fn(t, x):\n                del t, x\n                return discount_rates - dividend_rates - 0.5 * sigma ** 2\n\n            def vol_fn(t, x):\n                del t, x\n                return tf.reshape(sigma, [1, 1])\n            process = tff.models.GenericItoProcess(dim=1, drift_fn=drift_fn, volatility_fn=vol_fn, dtype=dtype)\n            log_spot = tf.math.log(tf.reduce_mean(spot))\n            if watch_params:\n                watch_params_list = [sigma]\n            else:\n                watch_params_list = None\n            paths = process.sample_paths(sampling_times, num_samples=num_samples, initial_state=log_spot, watch_params=watch_params_list, random_type=tff.math.random.RandomType.PSEUDO_ANTITHETIC, seed=43, time_step=dt)\n            prices = tf.exp(-tf.expand_dims(discount_rates * expiries, axis=-1)) * tf.reduce_mean(tf.nn.relu(tf.math.exp(tf.reduce_mean(paths, [1])) - strikes), [0])\n            return prices\n        return price_asian_options\n    price_asian_options = tf.function(set_up_pricer(expiries))\n    mc_prices = price_asian_options(strikes, spot, sigma)\n    self.assertAllClose(computed_prices, mc_prices[0], 0.01)"
        ]
    }
]