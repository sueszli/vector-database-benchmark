[
    {
        "func_name": "encode_features",
        "original": "def encode_features(feature_matrix, features, top_n=DEFAULT_TOP_N, include_unknown=True, to_encode=None, inplace=False, drop_first=False, verbose=False):\n    \"\"\"Encode categorical features\n\n    Args:\n        feature_matrix (pd.DataFrame): Dataframe of features.\n        features (list[PrimitiveBase]): Feature definitions in feature_matrix.\n        top_n (int or dict[string -> int]): Number of top values to include.\n            If dict[string -> int] is used, key is feature name and value is\n            the number of top values to include for that feature.\n            If a feature's name is not in dictionary, a default value of 10 is used.\n        include_unknown (pd.DataFrame): Add feature encoding an unknown class.\n            defaults to True\n        to_encode (list[str]): List of feature names to encode.\n            features not in this list are unencoded in the output matrix\n            defaults to encode all necessary features.\n        inplace (bool): Encode feature_matrix in place. Defaults to False.\n        drop_first (bool): Whether to get k-1 dummies out of k categorical\n                levels by removing the first level.\n                defaults to False\n        verbose (str): Print progress info.\n\n    Returns:\n        (pd.Dataframe, list) : encoded feature_matrix, encoded features\n\n    Example:\n        .. ipython:: python\n            :suppress:\n\n            from featuretools.tests.testing_utils import make_ecommerce_entityset\n            import featuretools as ft\n            es = make_ecommerce_entityset()\n\n        .. ipython:: python\n\n            f1 = ft.Feature(es[\"log\"].ww[\"product_id\"])\n            f2 = ft.Feature(es[\"log\"].ww[\"purchased\"])\n            f3 = ft.Feature(es[\"log\"].ww[\"value\"])\n\n            features = [f1, f2, f3]\n            ids = [0, 1, 2, 3, 4, 5]\n            feature_matrix = ft.calculate_feature_matrix(features, es,\n                                                         instance_ids=ids)\n\n            fm_encoded, f_encoded = ft.encode_features(feature_matrix,\n                                                       features)\n            f_encoded\n\n            fm_encoded, f_encoded = ft.encode_features(feature_matrix,\n                                                       features, top_n=2)\n            f_encoded\n\n            fm_encoded, f_encoded = ft.encode_features(feature_matrix, features,\n                                                       include_unknown=False)\n            f_encoded\n\n            fm_encoded, f_encoded = ft.encode_features(feature_matrix, features,\n                                                       to_encode=['purchased'])\n            f_encoded\n\n            fm_encoded, f_encoded = ft.encode_features(feature_matrix, features,\n                                                       drop_first=True)\n            f_encoded\n    \"\"\"\n    if not isinstance(feature_matrix, pd.DataFrame):\n        msg = 'feature_matrix must be a Pandas DataFrame'\n        raise TypeError(msg)\n    if inplace:\n        X = feature_matrix\n    else:\n        X = feature_matrix.copy()\n    old_feature_names = set()\n    for feature in features:\n        for fname in feature.get_feature_names():\n            assert fname in X.columns, 'Feature %s not found in feature matrix' % fname\n            old_feature_names.add(fname)\n    pass_through = [col for col in X.columns if col not in old_feature_names]\n    if verbose:\n        iterator = make_tqdm_iterator(iterable=features, total=len(features), desc='Encoding pass 1', unit='feature')\n    else:\n        iterator = features\n    new_feature_list = []\n    kept_columns = []\n    encoded_columns = []\n    columns_info = feature_matrix.ww.columns\n    for f in iterator:\n        is_discrete = {'category', 'foreign_key'}.intersection(f.column_schema.semantic_tags)\n        if f.number_output_features > 1 or not is_discrete:\n            if f.number_output_features > 1:\n                logger.warning('Feature %s has multiple columns and will not be encoded.  This may result in a matrix with non-numeric values.' % f)\n            new_feature_list.append(f)\n            kept_columns.extend(f.get_feature_names())\n            continue\n        if to_encode is not None and f.get_name() not in to_encode:\n            new_feature_list.append(f)\n            kept_columns.extend(f.get_feature_names())\n            continue\n        val_counts = X[f.get_name()].value_counts()\n        val_counts = val_counts[val_counts > 0].to_frame()\n        index_name = val_counts.index.name\n        val_counts = val_counts.rename(columns={val_counts.columns[0]: 'count'})\n        if index_name is None:\n            if 'index' in val_counts.columns:\n                index_name = 'level_0'\n            else:\n                index_name = 'index'\n        val_counts.reset_index(inplace=True)\n        val_counts = val_counts.sort_values(['count', index_name], ascending=False)\n        val_counts.set_index(index_name, inplace=True)\n        select_n = top_n\n        if isinstance(top_n, dict):\n            select_n = top_n.get(f.get_name(), DEFAULT_TOP_N)\n        if drop_first:\n            select_n = min(len(val_counts), top_n)\n            select_n = max(select_n - 1, 1)\n        unique = val_counts.head(select_n).index.tolist()\n        for label in unique:\n            add = f == label\n            add_name = add.get_name()\n            new_feature_list.append(add)\n            new_col = X[f.get_name()] == label\n            new_col.rename(add_name, inplace=True)\n            encoded_columns.append(new_col)\n        if include_unknown:\n            unknown = f.isin(unique).NOT().rename(f.get_name() + ' is unknown')\n            unknown_name = unknown.get_name()\n            new_feature_list.append(unknown)\n            new_col = ~X[f.get_name()].isin(unique)\n            new_col.rename(unknown_name, inplace=True)\n            encoded_columns.append(new_col)\n        if inplace:\n            X.drop(f.get_name(), axis=1, inplace=True)\n    kept_columns.extend(pass_through)\n    if inplace:\n        for encoded_column in encoded_columns:\n            X[encoded_column.name] = encoded_column\n    else:\n        X = pd.concat([X[kept_columns]] + encoded_columns, axis=1)\n    entityset = new_feature_list[0].entityset\n    ww_init_kwargs = get_ww_types_from_features(new_feature_list, entityset)\n    for column in kept_columns:\n        ww_init_kwargs['logical_types'][column] = columns_info[column].logical_type\n        ww_init_kwargs['semantic_tags'][column] = columns_info[column].semantic_tags\n        ww_init_kwargs['column_origins'][column] = columns_info[column].origin\n    X.ww.init(**ww_init_kwargs)\n    return (X, new_feature_list)",
        "mutated": [
            "def encode_features(feature_matrix, features, top_n=DEFAULT_TOP_N, include_unknown=True, to_encode=None, inplace=False, drop_first=False, verbose=False):\n    if False:\n        i = 10\n    'Encode categorical features\\n\\n    Args:\\n        feature_matrix (pd.DataFrame): Dataframe of features.\\n        features (list[PrimitiveBase]): Feature definitions in feature_matrix.\\n        top_n (int or dict[string -> int]): Number of top values to include.\\n            If dict[string -> int] is used, key is feature name and value is\\n            the number of top values to include for that feature.\\n            If a feature\\'s name is not in dictionary, a default value of 10 is used.\\n        include_unknown (pd.DataFrame): Add feature encoding an unknown class.\\n            defaults to True\\n        to_encode (list[str]): List of feature names to encode.\\n            features not in this list are unencoded in the output matrix\\n            defaults to encode all necessary features.\\n        inplace (bool): Encode feature_matrix in place. Defaults to False.\\n        drop_first (bool): Whether to get k-1 dummies out of k categorical\\n                levels by removing the first level.\\n                defaults to False\\n        verbose (str): Print progress info.\\n\\n    Returns:\\n        (pd.Dataframe, list) : encoded feature_matrix, encoded features\\n\\n    Example:\\n        .. ipython:: python\\n            :suppress:\\n\\n            from featuretools.tests.testing_utils import make_ecommerce_entityset\\n            import featuretools as ft\\n            es = make_ecommerce_entityset()\\n\\n        .. ipython:: python\\n\\n            f1 = ft.Feature(es[\"log\"].ww[\"product_id\"])\\n            f2 = ft.Feature(es[\"log\"].ww[\"purchased\"])\\n            f3 = ft.Feature(es[\"log\"].ww[\"value\"])\\n\\n            features = [f1, f2, f3]\\n            ids = [0, 1, 2, 3, 4, 5]\\n            feature_matrix = ft.calculate_feature_matrix(features, es,\\n                                                         instance_ids=ids)\\n\\n            fm_encoded, f_encoded = ft.encode_features(feature_matrix,\\n                                                       features)\\n            f_encoded\\n\\n            fm_encoded, f_encoded = ft.encode_features(feature_matrix,\\n                                                       features, top_n=2)\\n            f_encoded\\n\\n            fm_encoded, f_encoded = ft.encode_features(feature_matrix, features,\\n                                                       include_unknown=False)\\n            f_encoded\\n\\n            fm_encoded, f_encoded = ft.encode_features(feature_matrix, features,\\n                                                       to_encode=[\\'purchased\\'])\\n            f_encoded\\n\\n            fm_encoded, f_encoded = ft.encode_features(feature_matrix, features,\\n                                                       drop_first=True)\\n            f_encoded\\n    '\n    if not isinstance(feature_matrix, pd.DataFrame):\n        msg = 'feature_matrix must be a Pandas DataFrame'\n        raise TypeError(msg)\n    if inplace:\n        X = feature_matrix\n    else:\n        X = feature_matrix.copy()\n    old_feature_names = set()\n    for feature in features:\n        for fname in feature.get_feature_names():\n            assert fname in X.columns, 'Feature %s not found in feature matrix' % fname\n            old_feature_names.add(fname)\n    pass_through = [col for col in X.columns if col not in old_feature_names]\n    if verbose:\n        iterator = make_tqdm_iterator(iterable=features, total=len(features), desc='Encoding pass 1', unit='feature')\n    else:\n        iterator = features\n    new_feature_list = []\n    kept_columns = []\n    encoded_columns = []\n    columns_info = feature_matrix.ww.columns\n    for f in iterator:\n        is_discrete = {'category', 'foreign_key'}.intersection(f.column_schema.semantic_tags)\n        if f.number_output_features > 1 or not is_discrete:\n            if f.number_output_features > 1:\n                logger.warning('Feature %s has multiple columns and will not be encoded.  This may result in a matrix with non-numeric values.' % f)\n            new_feature_list.append(f)\n            kept_columns.extend(f.get_feature_names())\n            continue\n        if to_encode is not None and f.get_name() not in to_encode:\n            new_feature_list.append(f)\n            kept_columns.extend(f.get_feature_names())\n            continue\n        val_counts = X[f.get_name()].value_counts()\n        val_counts = val_counts[val_counts > 0].to_frame()\n        index_name = val_counts.index.name\n        val_counts = val_counts.rename(columns={val_counts.columns[0]: 'count'})\n        if index_name is None:\n            if 'index' in val_counts.columns:\n                index_name = 'level_0'\n            else:\n                index_name = 'index'\n        val_counts.reset_index(inplace=True)\n        val_counts = val_counts.sort_values(['count', index_name], ascending=False)\n        val_counts.set_index(index_name, inplace=True)\n        select_n = top_n\n        if isinstance(top_n, dict):\n            select_n = top_n.get(f.get_name(), DEFAULT_TOP_N)\n        if drop_first:\n            select_n = min(len(val_counts), top_n)\n            select_n = max(select_n - 1, 1)\n        unique = val_counts.head(select_n).index.tolist()\n        for label in unique:\n            add = f == label\n            add_name = add.get_name()\n            new_feature_list.append(add)\n            new_col = X[f.get_name()] == label\n            new_col.rename(add_name, inplace=True)\n            encoded_columns.append(new_col)\n        if include_unknown:\n            unknown = f.isin(unique).NOT().rename(f.get_name() + ' is unknown')\n            unknown_name = unknown.get_name()\n            new_feature_list.append(unknown)\n            new_col = ~X[f.get_name()].isin(unique)\n            new_col.rename(unknown_name, inplace=True)\n            encoded_columns.append(new_col)\n        if inplace:\n            X.drop(f.get_name(), axis=1, inplace=True)\n    kept_columns.extend(pass_through)\n    if inplace:\n        for encoded_column in encoded_columns:\n            X[encoded_column.name] = encoded_column\n    else:\n        X = pd.concat([X[kept_columns]] + encoded_columns, axis=1)\n    entityset = new_feature_list[0].entityset\n    ww_init_kwargs = get_ww_types_from_features(new_feature_list, entityset)\n    for column in kept_columns:\n        ww_init_kwargs['logical_types'][column] = columns_info[column].logical_type\n        ww_init_kwargs['semantic_tags'][column] = columns_info[column].semantic_tags\n        ww_init_kwargs['column_origins'][column] = columns_info[column].origin\n    X.ww.init(**ww_init_kwargs)\n    return (X, new_feature_list)",
            "def encode_features(feature_matrix, features, top_n=DEFAULT_TOP_N, include_unknown=True, to_encode=None, inplace=False, drop_first=False, verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Encode categorical features\\n\\n    Args:\\n        feature_matrix (pd.DataFrame): Dataframe of features.\\n        features (list[PrimitiveBase]): Feature definitions in feature_matrix.\\n        top_n (int or dict[string -> int]): Number of top values to include.\\n            If dict[string -> int] is used, key is feature name and value is\\n            the number of top values to include for that feature.\\n            If a feature\\'s name is not in dictionary, a default value of 10 is used.\\n        include_unknown (pd.DataFrame): Add feature encoding an unknown class.\\n            defaults to True\\n        to_encode (list[str]): List of feature names to encode.\\n            features not in this list are unencoded in the output matrix\\n            defaults to encode all necessary features.\\n        inplace (bool): Encode feature_matrix in place. Defaults to False.\\n        drop_first (bool): Whether to get k-1 dummies out of k categorical\\n                levels by removing the first level.\\n                defaults to False\\n        verbose (str): Print progress info.\\n\\n    Returns:\\n        (pd.Dataframe, list) : encoded feature_matrix, encoded features\\n\\n    Example:\\n        .. ipython:: python\\n            :suppress:\\n\\n            from featuretools.tests.testing_utils import make_ecommerce_entityset\\n            import featuretools as ft\\n            es = make_ecommerce_entityset()\\n\\n        .. ipython:: python\\n\\n            f1 = ft.Feature(es[\"log\"].ww[\"product_id\"])\\n            f2 = ft.Feature(es[\"log\"].ww[\"purchased\"])\\n            f3 = ft.Feature(es[\"log\"].ww[\"value\"])\\n\\n            features = [f1, f2, f3]\\n            ids = [0, 1, 2, 3, 4, 5]\\n            feature_matrix = ft.calculate_feature_matrix(features, es,\\n                                                         instance_ids=ids)\\n\\n            fm_encoded, f_encoded = ft.encode_features(feature_matrix,\\n                                                       features)\\n            f_encoded\\n\\n            fm_encoded, f_encoded = ft.encode_features(feature_matrix,\\n                                                       features, top_n=2)\\n            f_encoded\\n\\n            fm_encoded, f_encoded = ft.encode_features(feature_matrix, features,\\n                                                       include_unknown=False)\\n            f_encoded\\n\\n            fm_encoded, f_encoded = ft.encode_features(feature_matrix, features,\\n                                                       to_encode=[\\'purchased\\'])\\n            f_encoded\\n\\n            fm_encoded, f_encoded = ft.encode_features(feature_matrix, features,\\n                                                       drop_first=True)\\n            f_encoded\\n    '\n    if not isinstance(feature_matrix, pd.DataFrame):\n        msg = 'feature_matrix must be a Pandas DataFrame'\n        raise TypeError(msg)\n    if inplace:\n        X = feature_matrix\n    else:\n        X = feature_matrix.copy()\n    old_feature_names = set()\n    for feature in features:\n        for fname in feature.get_feature_names():\n            assert fname in X.columns, 'Feature %s not found in feature matrix' % fname\n            old_feature_names.add(fname)\n    pass_through = [col for col in X.columns if col not in old_feature_names]\n    if verbose:\n        iterator = make_tqdm_iterator(iterable=features, total=len(features), desc='Encoding pass 1', unit='feature')\n    else:\n        iterator = features\n    new_feature_list = []\n    kept_columns = []\n    encoded_columns = []\n    columns_info = feature_matrix.ww.columns\n    for f in iterator:\n        is_discrete = {'category', 'foreign_key'}.intersection(f.column_schema.semantic_tags)\n        if f.number_output_features > 1 or not is_discrete:\n            if f.number_output_features > 1:\n                logger.warning('Feature %s has multiple columns and will not be encoded.  This may result in a matrix with non-numeric values.' % f)\n            new_feature_list.append(f)\n            kept_columns.extend(f.get_feature_names())\n            continue\n        if to_encode is not None and f.get_name() not in to_encode:\n            new_feature_list.append(f)\n            kept_columns.extend(f.get_feature_names())\n            continue\n        val_counts = X[f.get_name()].value_counts()\n        val_counts = val_counts[val_counts > 0].to_frame()\n        index_name = val_counts.index.name\n        val_counts = val_counts.rename(columns={val_counts.columns[0]: 'count'})\n        if index_name is None:\n            if 'index' in val_counts.columns:\n                index_name = 'level_0'\n            else:\n                index_name = 'index'\n        val_counts.reset_index(inplace=True)\n        val_counts = val_counts.sort_values(['count', index_name], ascending=False)\n        val_counts.set_index(index_name, inplace=True)\n        select_n = top_n\n        if isinstance(top_n, dict):\n            select_n = top_n.get(f.get_name(), DEFAULT_TOP_N)\n        if drop_first:\n            select_n = min(len(val_counts), top_n)\n            select_n = max(select_n - 1, 1)\n        unique = val_counts.head(select_n).index.tolist()\n        for label in unique:\n            add = f == label\n            add_name = add.get_name()\n            new_feature_list.append(add)\n            new_col = X[f.get_name()] == label\n            new_col.rename(add_name, inplace=True)\n            encoded_columns.append(new_col)\n        if include_unknown:\n            unknown = f.isin(unique).NOT().rename(f.get_name() + ' is unknown')\n            unknown_name = unknown.get_name()\n            new_feature_list.append(unknown)\n            new_col = ~X[f.get_name()].isin(unique)\n            new_col.rename(unknown_name, inplace=True)\n            encoded_columns.append(new_col)\n        if inplace:\n            X.drop(f.get_name(), axis=1, inplace=True)\n    kept_columns.extend(pass_through)\n    if inplace:\n        for encoded_column in encoded_columns:\n            X[encoded_column.name] = encoded_column\n    else:\n        X = pd.concat([X[kept_columns]] + encoded_columns, axis=1)\n    entityset = new_feature_list[0].entityset\n    ww_init_kwargs = get_ww_types_from_features(new_feature_list, entityset)\n    for column in kept_columns:\n        ww_init_kwargs['logical_types'][column] = columns_info[column].logical_type\n        ww_init_kwargs['semantic_tags'][column] = columns_info[column].semantic_tags\n        ww_init_kwargs['column_origins'][column] = columns_info[column].origin\n    X.ww.init(**ww_init_kwargs)\n    return (X, new_feature_list)",
            "def encode_features(feature_matrix, features, top_n=DEFAULT_TOP_N, include_unknown=True, to_encode=None, inplace=False, drop_first=False, verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Encode categorical features\\n\\n    Args:\\n        feature_matrix (pd.DataFrame): Dataframe of features.\\n        features (list[PrimitiveBase]): Feature definitions in feature_matrix.\\n        top_n (int or dict[string -> int]): Number of top values to include.\\n            If dict[string -> int] is used, key is feature name and value is\\n            the number of top values to include for that feature.\\n            If a feature\\'s name is not in dictionary, a default value of 10 is used.\\n        include_unknown (pd.DataFrame): Add feature encoding an unknown class.\\n            defaults to True\\n        to_encode (list[str]): List of feature names to encode.\\n            features not in this list are unencoded in the output matrix\\n            defaults to encode all necessary features.\\n        inplace (bool): Encode feature_matrix in place. Defaults to False.\\n        drop_first (bool): Whether to get k-1 dummies out of k categorical\\n                levels by removing the first level.\\n                defaults to False\\n        verbose (str): Print progress info.\\n\\n    Returns:\\n        (pd.Dataframe, list) : encoded feature_matrix, encoded features\\n\\n    Example:\\n        .. ipython:: python\\n            :suppress:\\n\\n            from featuretools.tests.testing_utils import make_ecommerce_entityset\\n            import featuretools as ft\\n            es = make_ecommerce_entityset()\\n\\n        .. ipython:: python\\n\\n            f1 = ft.Feature(es[\"log\"].ww[\"product_id\"])\\n            f2 = ft.Feature(es[\"log\"].ww[\"purchased\"])\\n            f3 = ft.Feature(es[\"log\"].ww[\"value\"])\\n\\n            features = [f1, f2, f3]\\n            ids = [0, 1, 2, 3, 4, 5]\\n            feature_matrix = ft.calculate_feature_matrix(features, es,\\n                                                         instance_ids=ids)\\n\\n            fm_encoded, f_encoded = ft.encode_features(feature_matrix,\\n                                                       features)\\n            f_encoded\\n\\n            fm_encoded, f_encoded = ft.encode_features(feature_matrix,\\n                                                       features, top_n=2)\\n            f_encoded\\n\\n            fm_encoded, f_encoded = ft.encode_features(feature_matrix, features,\\n                                                       include_unknown=False)\\n            f_encoded\\n\\n            fm_encoded, f_encoded = ft.encode_features(feature_matrix, features,\\n                                                       to_encode=[\\'purchased\\'])\\n            f_encoded\\n\\n            fm_encoded, f_encoded = ft.encode_features(feature_matrix, features,\\n                                                       drop_first=True)\\n            f_encoded\\n    '\n    if not isinstance(feature_matrix, pd.DataFrame):\n        msg = 'feature_matrix must be a Pandas DataFrame'\n        raise TypeError(msg)\n    if inplace:\n        X = feature_matrix\n    else:\n        X = feature_matrix.copy()\n    old_feature_names = set()\n    for feature in features:\n        for fname in feature.get_feature_names():\n            assert fname in X.columns, 'Feature %s not found in feature matrix' % fname\n            old_feature_names.add(fname)\n    pass_through = [col for col in X.columns if col not in old_feature_names]\n    if verbose:\n        iterator = make_tqdm_iterator(iterable=features, total=len(features), desc='Encoding pass 1', unit='feature')\n    else:\n        iterator = features\n    new_feature_list = []\n    kept_columns = []\n    encoded_columns = []\n    columns_info = feature_matrix.ww.columns\n    for f in iterator:\n        is_discrete = {'category', 'foreign_key'}.intersection(f.column_schema.semantic_tags)\n        if f.number_output_features > 1 or not is_discrete:\n            if f.number_output_features > 1:\n                logger.warning('Feature %s has multiple columns and will not be encoded.  This may result in a matrix with non-numeric values.' % f)\n            new_feature_list.append(f)\n            kept_columns.extend(f.get_feature_names())\n            continue\n        if to_encode is not None and f.get_name() not in to_encode:\n            new_feature_list.append(f)\n            kept_columns.extend(f.get_feature_names())\n            continue\n        val_counts = X[f.get_name()].value_counts()\n        val_counts = val_counts[val_counts > 0].to_frame()\n        index_name = val_counts.index.name\n        val_counts = val_counts.rename(columns={val_counts.columns[0]: 'count'})\n        if index_name is None:\n            if 'index' in val_counts.columns:\n                index_name = 'level_0'\n            else:\n                index_name = 'index'\n        val_counts.reset_index(inplace=True)\n        val_counts = val_counts.sort_values(['count', index_name], ascending=False)\n        val_counts.set_index(index_name, inplace=True)\n        select_n = top_n\n        if isinstance(top_n, dict):\n            select_n = top_n.get(f.get_name(), DEFAULT_TOP_N)\n        if drop_first:\n            select_n = min(len(val_counts), top_n)\n            select_n = max(select_n - 1, 1)\n        unique = val_counts.head(select_n).index.tolist()\n        for label in unique:\n            add = f == label\n            add_name = add.get_name()\n            new_feature_list.append(add)\n            new_col = X[f.get_name()] == label\n            new_col.rename(add_name, inplace=True)\n            encoded_columns.append(new_col)\n        if include_unknown:\n            unknown = f.isin(unique).NOT().rename(f.get_name() + ' is unknown')\n            unknown_name = unknown.get_name()\n            new_feature_list.append(unknown)\n            new_col = ~X[f.get_name()].isin(unique)\n            new_col.rename(unknown_name, inplace=True)\n            encoded_columns.append(new_col)\n        if inplace:\n            X.drop(f.get_name(), axis=1, inplace=True)\n    kept_columns.extend(pass_through)\n    if inplace:\n        for encoded_column in encoded_columns:\n            X[encoded_column.name] = encoded_column\n    else:\n        X = pd.concat([X[kept_columns]] + encoded_columns, axis=1)\n    entityset = new_feature_list[0].entityset\n    ww_init_kwargs = get_ww_types_from_features(new_feature_list, entityset)\n    for column in kept_columns:\n        ww_init_kwargs['logical_types'][column] = columns_info[column].logical_type\n        ww_init_kwargs['semantic_tags'][column] = columns_info[column].semantic_tags\n        ww_init_kwargs['column_origins'][column] = columns_info[column].origin\n    X.ww.init(**ww_init_kwargs)\n    return (X, new_feature_list)",
            "def encode_features(feature_matrix, features, top_n=DEFAULT_TOP_N, include_unknown=True, to_encode=None, inplace=False, drop_first=False, verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Encode categorical features\\n\\n    Args:\\n        feature_matrix (pd.DataFrame): Dataframe of features.\\n        features (list[PrimitiveBase]): Feature definitions in feature_matrix.\\n        top_n (int or dict[string -> int]): Number of top values to include.\\n            If dict[string -> int] is used, key is feature name and value is\\n            the number of top values to include for that feature.\\n            If a feature\\'s name is not in dictionary, a default value of 10 is used.\\n        include_unknown (pd.DataFrame): Add feature encoding an unknown class.\\n            defaults to True\\n        to_encode (list[str]): List of feature names to encode.\\n            features not in this list are unencoded in the output matrix\\n            defaults to encode all necessary features.\\n        inplace (bool): Encode feature_matrix in place. Defaults to False.\\n        drop_first (bool): Whether to get k-1 dummies out of k categorical\\n                levels by removing the first level.\\n                defaults to False\\n        verbose (str): Print progress info.\\n\\n    Returns:\\n        (pd.Dataframe, list) : encoded feature_matrix, encoded features\\n\\n    Example:\\n        .. ipython:: python\\n            :suppress:\\n\\n            from featuretools.tests.testing_utils import make_ecommerce_entityset\\n            import featuretools as ft\\n            es = make_ecommerce_entityset()\\n\\n        .. ipython:: python\\n\\n            f1 = ft.Feature(es[\"log\"].ww[\"product_id\"])\\n            f2 = ft.Feature(es[\"log\"].ww[\"purchased\"])\\n            f3 = ft.Feature(es[\"log\"].ww[\"value\"])\\n\\n            features = [f1, f2, f3]\\n            ids = [0, 1, 2, 3, 4, 5]\\n            feature_matrix = ft.calculate_feature_matrix(features, es,\\n                                                         instance_ids=ids)\\n\\n            fm_encoded, f_encoded = ft.encode_features(feature_matrix,\\n                                                       features)\\n            f_encoded\\n\\n            fm_encoded, f_encoded = ft.encode_features(feature_matrix,\\n                                                       features, top_n=2)\\n            f_encoded\\n\\n            fm_encoded, f_encoded = ft.encode_features(feature_matrix, features,\\n                                                       include_unknown=False)\\n            f_encoded\\n\\n            fm_encoded, f_encoded = ft.encode_features(feature_matrix, features,\\n                                                       to_encode=[\\'purchased\\'])\\n            f_encoded\\n\\n            fm_encoded, f_encoded = ft.encode_features(feature_matrix, features,\\n                                                       drop_first=True)\\n            f_encoded\\n    '\n    if not isinstance(feature_matrix, pd.DataFrame):\n        msg = 'feature_matrix must be a Pandas DataFrame'\n        raise TypeError(msg)\n    if inplace:\n        X = feature_matrix\n    else:\n        X = feature_matrix.copy()\n    old_feature_names = set()\n    for feature in features:\n        for fname in feature.get_feature_names():\n            assert fname in X.columns, 'Feature %s not found in feature matrix' % fname\n            old_feature_names.add(fname)\n    pass_through = [col for col in X.columns if col not in old_feature_names]\n    if verbose:\n        iterator = make_tqdm_iterator(iterable=features, total=len(features), desc='Encoding pass 1', unit='feature')\n    else:\n        iterator = features\n    new_feature_list = []\n    kept_columns = []\n    encoded_columns = []\n    columns_info = feature_matrix.ww.columns\n    for f in iterator:\n        is_discrete = {'category', 'foreign_key'}.intersection(f.column_schema.semantic_tags)\n        if f.number_output_features > 1 or not is_discrete:\n            if f.number_output_features > 1:\n                logger.warning('Feature %s has multiple columns and will not be encoded.  This may result in a matrix with non-numeric values.' % f)\n            new_feature_list.append(f)\n            kept_columns.extend(f.get_feature_names())\n            continue\n        if to_encode is not None and f.get_name() not in to_encode:\n            new_feature_list.append(f)\n            kept_columns.extend(f.get_feature_names())\n            continue\n        val_counts = X[f.get_name()].value_counts()\n        val_counts = val_counts[val_counts > 0].to_frame()\n        index_name = val_counts.index.name\n        val_counts = val_counts.rename(columns={val_counts.columns[0]: 'count'})\n        if index_name is None:\n            if 'index' in val_counts.columns:\n                index_name = 'level_0'\n            else:\n                index_name = 'index'\n        val_counts.reset_index(inplace=True)\n        val_counts = val_counts.sort_values(['count', index_name], ascending=False)\n        val_counts.set_index(index_name, inplace=True)\n        select_n = top_n\n        if isinstance(top_n, dict):\n            select_n = top_n.get(f.get_name(), DEFAULT_TOP_N)\n        if drop_first:\n            select_n = min(len(val_counts), top_n)\n            select_n = max(select_n - 1, 1)\n        unique = val_counts.head(select_n).index.tolist()\n        for label in unique:\n            add = f == label\n            add_name = add.get_name()\n            new_feature_list.append(add)\n            new_col = X[f.get_name()] == label\n            new_col.rename(add_name, inplace=True)\n            encoded_columns.append(new_col)\n        if include_unknown:\n            unknown = f.isin(unique).NOT().rename(f.get_name() + ' is unknown')\n            unknown_name = unknown.get_name()\n            new_feature_list.append(unknown)\n            new_col = ~X[f.get_name()].isin(unique)\n            new_col.rename(unknown_name, inplace=True)\n            encoded_columns.append(new_col)\n        if inplace:\n            X.drop(f.get_name(), axis=1, inplace=True)\n    kept_columns.extend(pass_through)\n    if inplace:\n        for encoded_column in encoded_columns:\n            X[encoded_column.name] = encoded_column\n    else:\n        X = pd.concat([X[kept_columns]] + encoded_columns, axis=1)\n    entityset = new_feature_list[0].entityset\n    ww_init_kwargs = get_ww_types_from_features(new_feature_list, entityset)\n    for column in kept_columns:\n        ww_init_kwargs['logical_types'][column] = columns_info[column].logical_type\n        ww_init_kwargs['semantic_tags'][column] = columns_info[column].semantic_tags\n        ww_init_kwargs['column_origins'][column] = columns_info[column].origin\n    X.ww.init(**ww_init_kwargs)\n    return (X, new_feature_list)",
            "def encode_features(feature_matrix, features, top_n=DEFAULT_TOP_N, include_unknown=True, to_encode=None, inplace=False, drop_first=False, verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Encode categorical features\\n\\n    Args:\\n        feature_matrix (pd.DataFrame): Dataframe of features.\\n        features (list[PrimitiveBase]): Feature definitions in feature_matrix.\\n        top_n (int or dict[string -> int]): Number of top values to include.\\n            If dict[string -> int] is used, key is feature name and value is\\n            the number of top values to include for that feature.\\n            If a feature\\'s name is not in dictionary, a default value of 10 is used.\\n        include_unknown (pd.DataFrame): Add feature encoding an unknown class.\\n            defaults to True\\n        to_encode (list[str]): List of feature names to encode.\\n            features not in this list are unencoded in the output matrix\\n            defaults to encode all necessary features.\\n        inplace (bool): Encode feature_matrix in place. Defaults to False.\\n        drop_first (bool): Whether to get k-1 dummies out of k categorical\\n                levels by removing the first level.\\n                defaults to False\\n        verbose (str): Print progress info.\\n\\n    Returns:\\n        (pd.Dataframe, list) : encoded feature_matrix, encoded features\\n\\n    Example:\\n        .. ipython:: python\\n            :suppress:\\n\\n            from featuretools.tests.testing_utils import make_ecommerce_entityset\\n            import featuretools as ft\\n            es = make_ecommerce_entityset()\\n\\n        .. ipython:: python\\n\\n            f1 = ft.Feature(es[\"log\"].ww[\"product_id\"])\\n            f2 = ft.Feature(es[\"log\"].ww[\"purchased\"])\\n            f3 = ft.Feature(es[\"log\"].ww[\"value\"])\\n\\n            features = [f1, f2, f3]\\n            ids = [0, 1, 2, 3, 4, 5]\\n            feature_matrix = ft.calculate_feature_matrix(features, es,\\n                                                         instance_ids=ids)\\n\\n            fm_encoded, f_encoded = ft.encode_features(feature_matrix,\\n                                                       features)\\n            f_encoded\\n\\n            fm_encoded, f_encoded = ft.encode_features(feature_matrix,\\n                                                       features, top_n=2)\\n            f_encoded\\n\\n            fm_encoded, f_encoded = ft.encode_features(feature_matrix, features,\\n                                                       include_unknown=False)\\n            f_encoded\\n\\n            fm_encoded, f_encoded = ft.encode_features(feature_matrix, features,\\n                                                       to_encode=[\\'purchased\\'])\\n            f_encoded\\n\\n            fm_encoded, f_encoded = ft.encode_features(feature_matrix, features,\\n                                                       drop_first=True)\\n            f_encoded\\n    '\n    if not isinstance(feature_matrix, pd.DataFrame):\n        msg = 'feature_matrix must be a Pandas DataFrame'\n        raise TypeError(msg)\n    if inplace:\n        X = feature_matrix\n    else:\n        X = feature_matrix.copy()\n    old_feature_names = set()\n    for feature in features:\n        for fname in feature.get_feature_names():\n            assert fname in X.columns, 'Feature %s not found in feature matrix' % fname\n            old_feature_names.add(fname)\n    pass_through = [col for col in X.columns if col not in old_feature_names]\n    if verbose:\n        iterator = make_tqdm_iterator(iterable=features, total=len(features), desc='Encoding pass 1', unit='feature')\n    else:\n        iterator = features\n    new_feature_list = []\n    kept_columns = []\n    encoded_columns = []\n    columns_info = feature_matrix.ww.columns\n    for f in iterator:\n        is_discrete = {'category', 'foreign_key'}.intersection(f.column_schema.semantic_tags)\n        if f.number_output_features > 1 or not is_discrete:\n            if f.number_output_features > 1:\n                logger.warning('Feature %s has multiple columns and will not be encoded.  This may result in a matrix with non-numeric values.' % f)\n            new_feature_list.append(f)\n            kept_columns.extend(f.get_feature_names())\n            continue\n        if to_encode is not None and f.get_name() not in to_encode:\n            new_feature_list.append(f)\n            kept_columns.extend(f.get_feature_names())\n            continue\n        val_counts = X[f.get_name()].value_counts()\n        val_counts = val_counts[val_counts > 0].to_frame()\n        index_name = val_counts.index.name\n        val_counts = val_counts.rename(columns={val_counts.columns[0]: 'count'})\n        if index_name is None:\n            if 'index' in val_counts.columns:\n                index_name = 'level_0'\n            else:\n                index_name = 'index'\n        val_counts.reset_index(inplace=True)\n        val_counts = val_counts.sort_values(['count', index_name], ascending=False)\n        val_counts.set_index(index_name, inplace=True)\n        select_n = top_n\n        if isinstance(top_n, dict):\n            select_n = top_n.get(f.get_name(), DEFAULT_TOP_N)\n        if drop_first:\n            select_n = min(len(val_counts), top_n)\n            select_n = max(select_n - 1, 1)\n        unique = val_counts.head(select_n).index.tolist()\n        for label in unique:\n            add = f == label\n            add_name = add.get_name()\n            new_feature_list.append(add)\n            new_col = X[f.get_name()] == label\n            new_col.rename(add_name, inplace=True)\n            encoded_columns.append(new_col)\n        if include_unknown:\n            unknown = f.isin(unique).NOT().rename(f.get_name() + ' is unknown')\n            unknown_name = unknown.get_name()\n            new_feature_list.append(unknown)\n            new_col = ~X[f.get_name()].isin(unique)\n            new_col.rename(unknown_name, inplace=True)\n            encoded_columns.append(new_col)\n        if inplace:\n            X.drop(f.get_name(), axis=1, inplace=True)\n    kept_columns.extend(pass_through)\n    if inplace:\n        for encoded_column in encoded_columns:\n            X[encoded_column.name] = encoded_column\n    else:\n        X = pd.concat([X[kept_columns]] + encoded_columns, axis=1)\n    entityset = new_feature_list[0].entityset\n    ww_init_kwargs = get_ww_types_from_features(new_feature_list, entityset)\n    for column in kept_columns:\n        ww_init_kwargs['logical_types'][column] = columns_info[column].logical_type\n        ww_init_kwargs['semantic_tags'][column] = columns_info[column].semantic_tags\n        ww_init_kwargs['column_origins'][column] = columns_info[column].origin\n    X.ww.init(**ww_init_kwargs)\n    return (X, new_feature_list)"
        ]
    }
]