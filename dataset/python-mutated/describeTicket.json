[
    {
        "func_name": "parse_ccache",
        "original": "def parse_ccache(args):\n    ccache = CCache.loadFile(args.ticket)\n    cred_number = 0\n    logging.info('Number of credentials in cache: %d' % len(ccache.credentials))\n    for creds in ccache.credentials:\n        logging.info('Parsing credential[%d]:' % cred_number)\n        rawTicket = creds.toTGS()\n        decodedTicket = decoder.decode(rawTicket['KDC_REP'], asn1Spec=TGS_REP())[0]\n        sessionKey = hexlify(rawTicket['sessionKey'].contents).decode('utf-8')\n        logging.info('%-30s: %s' % ('Ticket Session Key', sessionKey))\n        logging.info('%-30s: %s' % ('User Name', creds['client'].prettyPrint().split(b'@')[0].decode('utf-8')))\n        logging.info('%-30s: %s' % ('User Realm', creds['client'].prettyPrint().split(b'@')[1].decode('utf-8')))\n        spn = creds['server'].prettyPrint().split(b'@')[0].decode('utf-8')\n        logging.info('%-30s: %s' % ('Service Name', spn))\n        logging.info('%-30s: %s' % ('Service Realm', creds['server'].prettyPrint().split(b'@')[1].decode('utf-8')))\n        logging.info('%-30s: %s' % ('Start Time', datetime.datetime.fromtimestamp(creds['time']['starttime']).strftime('%d/%m/%Y %H:%M:%S %p')))\n        if datetime.datetime.fromtimestamp(creds['time']['endtime']) < datetime.datetime.now():\n            logging.info('%-30s: %s (expired)' % ('End Time', datetime.datetime.fromtimestamp(creds['time']['endtime']).strftime('%d/%m/%Y %H:%M:%S %p')))\n        else:\n            logging.info('%-30s: %s' % ('End Time', datetime.datetime.fromtimestamp(creds['time']['endtime']).strftime('%d/%m/%Y %H:%M:%S %p')))\n        if datetime.datetime.fromtimestamp(creds['time']['renew_till']) < datetime.datetime.now():\n            logging.info('%-30s: %s (expired)' % ('RenewTill', datetime.datetime.fromtimestamp(creds['time']['renew_till']).strftime('%d/%m/%Y %H:%M:%S %p')))\n        else:\n            logging.info('%-30s: %s' % ('RenewTill', datetime.datetime.fromtimestamp(creds['time']['renew_till']).strftime('%d/%m/%Y %H:%M:%S %p')))\n        flags = []\n        for k in constants.TicketFlags:\n            if creds['tktflags'] >> 31 - k.value & 1 == 1:\n                flags.append(constants.TicketFlags(k.value).name)\n        logging.info('%-30s: (0x%x) %s' % ('Flags', creds['tktflags'], ', '.join(flags)))\n        keyType = constants.EncryptionTypes(creds['key']['keytype']).name\n        logging.info('%-30s: %s' % ('KeyType', keyType))\n        logging.info('%-30s: %s' % ('Base64(key)', base64.b64encode(creds['key']['keyvalue']).decode('utf-8')))\n        if spn.split('/')[0] != 'krbtgt':\n            logging.debug('Attempting to create Kerberoast hash')\n            kerberoast_hash = None\n            if keyType != 'rc4_hmac' and keyType != 'aes256_cts_hmac_sha1_96':\n                logging.debug('Service ticket uses encryption key type %s, unable to extract hash and salt' % keyType)\n            elif keyType == 'rc4_hmac':\n                kerberoast_hash = kerberoast_from_ccache(decodedTGS=decodedTicket, spn=spn, username=args.user, domain=args.domain)\n            elif args.user:\n                if args.user.endswith('$'):\n                    user = 'host%s.%s' % (args.user.rstrip('$').lower(), args.domain.lower())\n                else:\n                    user = args.user\n                kerberoast_hash = kerberoast_from_ccache(decodedTGS=decodedTicket, spn=spn, username=user, domain=args.domain)\n            else:\n                logging.error(\"AES256 in use but no '-u/--user' passed, unable to generate crackable hash\")\n            if kerberoast_hash:\n                logging.info('%-30s: %s' % ('Kerberoast hash', kerberoast_hash))\n        logging.info('%-30s:' % \"Decoding unencrypted data in credential[%d]['ticket']\" % cred_number)\n        spn = '/'.join(list([str(sname_component) for sname_component in decodedTicket['ticket']['sname']['name-string']]))\n        etype = decodedTicket['ticket']['enc-part']['etype']\n        logging.info('  %-28s: %s' % ('Service Name', spn))\n        logging.info('  %-28s: %s' % ('Service Realm', decodedTicket['ticket']['realm']))\n        logging.info('  %-28s: %s (etype %d)' % ('Encryption type', constants.EncryptionTypes(etype).name, etype))\n        if not decodedTicket['ticket']['enc-part']['kvno'].isNoValue():\n            logging.debug('No kvno in ticket, skipping')\n            logging.info('  %-28s: %d' % ('Key version number (kvno)', decodedTicket['ticket']['enc-part']['kvno']))\n        logging.debug('Handling Kerberos keys')\n        ekeys = generate_kerberos_keys(args)\n        try:\n            logging.debug('Ticket is encrypted with %s (etype %d)' % (constants.EncryptionTypes(etype).name, etype))\n            key = ekeys[etype]\n            logging.debug('Using corresponding key: %s' % hexlify(key.contents).decode('utf-8'))\n        except KeyError:\n            if len(ekeys) > 0:\n                logging.error('Could not find the correct encryption key! Ticket is encrypted with %s (etype %d), but only keytype(s) %s were calculated/supplied', constants.EncryptionTypes(etype).name, etype, ', '.join([str(enctype) for enctype in ekeys.keys()]))\n            else:\n                logging.error('Could not find the correct encryption key! Ticket is encrypted with %s (etype %d), but no keys/creds were supplied', constants.EncryptionTypes(etype).name, etype)\n            return None\n        try:\n            cipherText = decodedTicket['ticket']['enc-part']['cipher']\n            newCipher = _enctype_table[int(etype)]\n            plainText = newCipher.decrypt(key, 2, cipherText)\n        except InvalidChecksum:\n            logging.error('Ciphertext integrity failed. Most likely the account password or AES key is incorrect')\n            if args.salt:\n                logging.info('Make sure the salt/username/domain are set and with the proper values. In case of a computer account, append a \"$\" to the name.')\n                logging.debug(\"Remember: the encrypted-part of the ticket is secured with one of the target service's Kerberos keys. The target service is the one who owns the 'Service Name' SPN printed above\")\n            return\n        logging.debug('Ticket successfully decrypted')\n        encTicketPart = decoder.decode(plainText, asn1Spec=EncTicketPart())[0]\n        sessionKey = Key(encTicketPart['key']['keytype'], bytes(encTicketPart['key']['keyvalue']))\n        adIfRelevant = decoder.decode(encTicketPart['authorization-data'][0]['ad-data'], asn1Spec=AD_IF_RELEVANT())[0]\n        pacType = pac.PACTYPE(adIfRelevant[0]['ad-data'].asOctets())\n        parsed_pac = parse_pac(pacType, args)\n        logging.info('%-30s:' % \"Decoding credential[%d]['ticket']['enc-part']\" % cred_number)\n        for element_type in parsed_pac:\n            element_type_name = list(element_type.keys())[0]\n            logging.info('  %-28s' % element_type_name)\n            for attribute in element_type[element_type_name]:\n                value = element_type[element_type_name][attribute]\n                if isinstance(value, Sequence) and (not isinstance(value, str)):\n                    if len(value) > 0:\n                        logging.info('    %-26s: %s' % (attribute, value[0]))\n                        for subvalue in value[1:]:\n                            logging.info(' ' * 32 + '%s' % subvalue)\n                    else:\n                        logging.info('    %-26s:' % attribute)\n                else:\n                    logging.info('    %-26s: %s' % (attribute, value))\n        cred_number += 1",
        "mutated": [
            "def parse_ccache(args):\n    if False:\n        i = 10\n    ccache = CCache.loadFile(args.ticket)\n    cred_number = 0\n    logging.info('Number of credentials in cache: %d' % len(ccache.credentials))\n    for creds in ccache.credentials:\n        logging.info('Parsing credential[%d]:' % cred_number)\n        rawTicket = creds.toTGS()\n        decodedTicket = decoder.decode(rawTicket['KDC_REP'], asn1Spec=TGS_REP())[0]\n        sessionKey = hexlify(rawTicket['sessionKey'].contents).decode('utf-8')\n        logging.info('%-30s: %s' % ('Ticket Session Key', sessionKey))\n        logging.info('%-30s: %s' % ('User Name', creds['client'].prettyPrint().split(b'@')[0].decode('utf-8')))\n        logging.info('%-30s: %s' % ('User Realm', creds['client'].prettyPrint().split(b'@')[1].decode('utf-8')))\n        spn = creds['server'].prettyPrint().split(b'@')[0].decode('utf-8')\n        logging.info('%-30s: %s' % ('Service Name', spn))\n        logging.info('%-30s: %s' % ('Service Realm', creds['server'].prettyPrint().split(b'@')[1].decode('utf-8')))\n        logging.info('%-30s: %s' % ('Start Time', datetime.datetime.fromtimestamp(creds['time']['starttime']).strftime('%d/%m/%Y %H:%M:%S %p')))\n        if datetime.datetime.fromtimestamp(creds['time']['endtime']) < datetime.datetime.now():\n            logging.info('%-30s: %s (expired)' % ('End Time', datetime.datetime.fromtimestamp(creds['time']['endtime']).strftime('%d/%m/%Y %H:%M:%S %p')))\n        else:\n            logging.info('%-30s: %s' % ('End Time', datetime.datetime.fromtimestamp(creds['time']['endtime']).strftime('%d/%m/%Y %H:%M:%S %p')))\n        if datetime.datetime.fromtimestamp(creds['time']['renew_till']) < datetime.datetime.now():\n            logging.info('%-30s: %s (expired)' % ('RenewTill', datetime.datetime.fromtimestamp(creds['time']['renew_till']).strftime('%d/%m/%Y %H:%M:%S %p')))\n        else:\n            logging.info('%-30s: %s' % ('RenewTill', datetime.datetime.fromtimestamp(creds['time']['renew_till']).strftime('%d/%m/%Y %H:%M:%S %p')))\n        flags = []\n        for k in constants.TicketFlags:\n            if creds['tktflags'] >> 31 - k.value & 1 == 1:\n                flags.append(constants.TicketFlags(k.value).name)\n        logging.info('%-30s: (0x%x) %s' % ('Flags', creds['tktflags'], ', '.join(flags)))\n        keyType = constants.EncryptionTypes(creds['key']['keytype']).name\n        logging.info('%-30s: %s' % ('KeyType', keyType))\n        logging.info('%-30s: %s' % ('Base64(key)', base64.b64encode(creds['key']['keyvalue']).decode('utf-8')))\n        if spn.split('/')[0] != 'krbtgt':\n            logging.debug('Attempting to create Kerberoast hash')\n            kerberoast_hash = None\n            if keyType != 'rc4_hmac' and keyType != 'aes256_cts_hmac_sha1_96':\n                logging.debug('Service ticket uses encryption key type %s, unable to extract hash and salt' % keyType)\n            elif keyType == 'rc4_hmac':\n                kerberoast_hash = kerberoast_from_ccache(decodedTGS=decodedTicket, spn=spn, username=args.user, domain=args.domain)\n            elif args.user:\n                if args.user.endswith('$'):\n                    user = 'host%s.%s' % (args.user.rstrip('$').lower(), args.domain.lower())\n                else:\n                    user = args.user\n                kerberoast_hash = kerberoast_from_ccache(decodedTGS=decodedTicket, spn=spn, username=user, domain=args.domain)\n            else:\n                logging.error(\"AES256 in use but no '-u/--user' passed, unable to generate crackable hash\")\n            if kerberoast_hash:\n                logging.info('%-30s: %s' % ('Kerberoast hash', kerberoast_hash))\n        logging.info('%-30s:' % \"Decoding unencrypted data in credential[%d]['ticket']\" % cred_number)\n        spn = '/'.join(list([str(sname_component) for sname_component in decodedTicket['ticket']['sname']['name-string']]))\n        etype = decodedTicket['ticket']['enc-part']['etype']\n        logging.info('  %-28s: %s' % ('Service Name', spn))\n        logging.info('  %-28s: %s' % ('Service Realm', decodedTicket['ticket']['realm']))\n        logging.info('  %-28s: %s (etype %d)' % ('Encryption type', constants.EncryptionTypes(etype).name, etype))\n        if not decodedTicket['ticket']['enc-part']['kvno'].isNoValue():\n            logging.debug('No kvno in ticket, skipping')\n            logging.info('  %-28s: %d' % ('Key version number (kvno)', decodedTicket['ticket']['enc-part']['kvno']))\n        logging.debug('Handling Kerberos keys')\n        ekeys = generate_kerberos_keys(args)\n        try:\n            logging.debug('Ticket is encrypted with %s (etype %d)' % (constants.EncryptionTypes(etype).name, etype))\n            key = ekeys[etype]\n            logging.debug('Using corresponding key: %s' % hexlify(key.contents).decode('utf-8'))\n        except KeyError:\n            if len(ekeys) > 0:\n                logging.error('Could not find the correct encryption key! Ticket is encrypted with %s (etype %d), but only keytype(s) %s were calculated/supplied', constants.EncryptionTypes(etype).name, etype, ', '.join([str(enctype) for enctype in ekeys.keys()]))\n            else:\n                logging.error('Could not find the correct encryption key! Ticket is encrypted with %s (etype %d), but no keys/creds were supplied', constants.EncryptionTypes(etype).name, etype)\n            return None\n        try:\n            cipherText = decodedTicket['ticket']['enc-part']['cipher']\n            newCipher = _enctype_table[int(etype)]\n            plainText = newCipher.decrypt(key, 2, cipherText)\n        except InvalidChecksum:\n            logging.error('Ciphertext integrity failed. Most likely the account password or AES key is incorrect')\n            if args.salt:\n                logging.info('Make sure the salt/username/domain are set and with the proper values. In case of a computer account, append a \"$\" to the name.')\n                logging.debug(\"Remember: the encrypted-part of the ticket is secured with one of the target service's Kerberos keys. The target service is the one who owns the 'Service Name' SPN printed above\")\n            return\n        logging.debug('Ticket successfully decrypted')\n        encTicketPart = decoder.decode(plainText, asn1Spec=EncTicketPart())[0]\n        sessionKey = Key(encTicketPart['key']['keytype'], bytes(encTicketPart['key']['keyvalue']))\n        adIfRelevant = decoder.decode(encTicketPart['authorization-data'][0]['ad-data'], asn1Spec=AD_IF_RELEVANT())[0]\n        pacType = pac.PACTYPE(adIfRelevant[0]['ad-data'].asOctets())\n        parsed_pac = parse_pac(pacType, args)\n        logging.info('%-30s:' % \"Decoding credential[%d]['ticket']['enc-part']\" % cred_number)\n        for element_type in parsed_pac:\n            element_type_name = list(element_type.keys())[0]\n            logging.info('  %-28s' % element_type_name)\n            for attribute in element_type[element_type_name]:\n                value = element_type[element_type_name][attribute]\n                if isinstance(value, Sequence) and (not isinstance(value, str)):\n                    if len(value) > 0:\n                        logging.info('    %-26s: %s' % (attribute, value[0]))\n                        for subvalue in value[1:]:\n                            logging.info(' ' * 32 + '%s' % subvalue)\n                    else:\n                        logging.info('    %-26s:' % attribute)\n                else:\n                    logging.info('    %-26s: %s' % (attribute, value))\n        cred_number += 1",
            "def parse_ccache(args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ccache = CCache.loadFile(args.ticket)\n    cred_number = 0\n    logging.info('Number of credentials in cache: %d' % len(ccache.credentials))\n    for creds in ccache.credentials:\n        logging.info('Parsing credential[%d]:' % cred_number)\n        rawTicket = creds.toTGS()\n        decodedTicket = decoder.decode(rawTicket['KDC_REP'], asn1Spec=TGS_REP())[0]\n        sessionKey = hexlify(rawTicket['sessionKey'].contents).decode('utf-8')\n        logging.info('%-30s: %s' % ('Ticket Session Key', sessionKey))\n        logging.info('%-30s: %s' % ('User Name', creds['client'].prettyPrint().split(b'@')[0].decode('utf-8')))\n        logging.info('%-30s: %s' % ('User Realm', creds['client'].prettyPrint().split(b'@')[1].decode('utf-8')))\n        spn = creds['server'].prettyPrint().split(b'@')[0].decode('utf-8')\n        logging.info('%-30s: %s' % ('Service Name', spn))\n        logging.info('%-30s: %s' % ('Service Realm', creds['server'].prettyPrint().split(b'@')[1].decode('utf-8')))\n        logging.info('%-30s: %s' % ('Start Time', datetime.datetime.fromtimestamp(creds['time']['starttime']).strftime('%d/%m/%Y %H:%M:%S %p')))\n        if datetime.datetime.fromtimestamp(creds['time']['endtime']) < datetime.datetime.now():\n            logging.info('%-30s: %s (expired)' % ('End Time', datetime.datetime.fromtimestamp(creds['time']['endtime']).strftime('%d/%m/%Y %H:%M:%S %p')))\n        else:\n            logging.info('%-30s: %s' % ('End Time', datetime.datetime.fromtimestamp(creds['time']['endtime']).strftime('%d/%m/%Y %H:%M:%S %p')))\n        if datetime.datetime.fromtimestamp(creds['time']['renew_till']) < datetime.datetime.now():\n            logging.info('%-30s: %s (expired)' % ('RenewTill', datetime.datetime.fromtimestamp(creds['time']['renew_till']).strftime('%d/%m/%Y %H:%M:%S %p')))\n        else:\n            logging.info('%-30s: %s' % ('RenewTill', datetime.datetime.fromtimestamp(creds['time']['renew_till']).strftime('%d/%m/%Y %H:%M:%S %p')))\n        flags = []\n        for k in constants.TicketFlags:\n            if creds['tktflags'] >> 31 - k.value & 1 == 1:\n                flags.append(constants.TicketFlags(k.value).name)\n        logging.info('%-30s: (0x%x) %s' % ('Flags', creds['tktflags'], ', '.join(flags)))\n        keyType = constants.EncryptionTypes(creds['key']['keytype']).name\n        logging.info('%-30s: %s' % ('KeyType', keyType))\n        logging.info('%-30s: %s' % ('Base64(key)', base64.b64encode(creds['key']['keyvalue']).decode('utf-8')))\n        if spn.split('/')[0] != 'krbtgt':\n            logging.debug('Attempting to create Kerberoast hash')\n            kerberoast_hash = None\n            if keyType != 'rc4_hmac' and keyType != 'aes256_cts_hmac_sha1_96':\n                logging.debug('Service ticket uses encryption key type %s, unable to extract hash and salt' % keyType)\n            elif keyType == 'rc4_hmac':\n                kerberoast_hash = kerberoast_from_ccache(decodedTGS=decodedTicket, spn=spn, username=args.user, domain=args.domain)\n            elif args.user:\n                if args.user.endswith('$'):\n                    user = 'host%s.%s' % (args.user.rstrip('$').lower(), args.domain.lower())\n                else:\n                    user = args.user\n                kerberoast_hash = kerberoast_from_ccache(decodedTGS=decodedTicket, spn=spn, username=user, domain=args.domain)\n            else:\n                logging.error(\"AES256 in use but no '-u/--user' passed, unable to generate crackable hash\")\n            if kerberoast_hash:\n                logging.info('%-30s: %s' % ('Kerberoast hash', kerberoast_hash))\n        logging.info('%-30s:' % \"Decoding unencrypted data in credential[%d]['ticket']\" % cred_number)\n        spn = '/'.join(list([str(sname_component) for sname_component in decodedTicket['ticket']['sname']['name-string']]))\n        etype = decodedTicket['ticket']['enc-part']['etype']\n        logging.info('  %-28s: %s' % ('Service Name', spn))\n        logging.info('  %-28s: %s' % ('Service Realm', decodedTicket['ticket']['realm']))\n        logging.info('  %-28s: %s (etype %d)' % ('Encryption type', constants.EncryptionTypes(etype).name, etype))\n        if not decodedTicket['ticket']['enc-part']['kvno'].isNoValue():\n            logging.debug('No kvno in ticket, skipping')\n            logging.info('  %-28s: %d' % ('Key version number (kvno)', decodedTicket['ticket']['enc-part']['kvno']))\n        logging.debug('Handling Kerberos keys')\n        ekeys = generate_kerberos_keys(args)\n        try:\n            logging.debug('Ticket is encrypted with %s (etype %d)' % (constants.EncryptionTypes(etype).name, etype))\n            key = ekeys[etype]\n            logging.debug('Using corresponding key: %s' % hexlify(key.contents).decode('utf-8'))\n        except KeyError:\n            if len(ekeys) > 0:\n                logging.error('Could not find the correct encryption key! Ticket is encrypted with %s (etype %d), but only keytype(s) %s were calculated/supplied', constants.EncryptionTypes(etype).name, etype, ', '.join([str(enctype) for enctype in ekeys.keys()]))\n            else:\n                logging.error('Could not find the correct encryption key! Ticket is encrypted with %s (etype %d), but no keys/creds were supplied', constants.EncryptionTypes(etype).name, etype)\n            return None\n        try:\n            cipherText = decodedTicket['ticket']['enc-part']['cipher']\n            newCipher = _enctype_table[int(etype)]\n            plainText = newCipher.decrypt(key, 2, cipherText)\n        except InvalidChecksum:\n            logging.error('Ciphertext integrity failed. Most likely the account password or AES key is incorrect')\n            if args.salt:\n                logging.info('Make sure the salt/username/domain are set and with the proper values. In case of a computer account, append a \"$\" to the name.')\n                logging.debug(\"Remember: the encrypted-part of the ticket is secured with one of the target service's Kerberos keys. The target service is the one who owns the 'Service Name' SPN printed above\")\n            return\n        logging.debug('Ticket successfully decrypted')\n        encTicketPart = decoder.decode(plainText, asn1Spec=EncTicketPart())[0]\n        sessionKey = Key(encTicketPart['key']['keytype'], bytes(encTicketPart['key']['keyvalue']))\n        adIfRelevant = decoder.decode(encTicketPart['authorization-data'][0]['ad-data'], asn1Spec=AD_IF_RELEVANT())[0]\n        pacType = pac.PACTYPE(adIfRelevant[0]['ad-data'].asOctets())\n        parsed_pac = parse_pac(pacType, args)\n        logging.info('%-30s:' % \"Decoding credential[%d]['ticket']['enc-part']\" % cred_number)\n        for element_type in parsed_pac:\n            element_type_name = list(element_type.keys())[0]\n            logging.info('  %-28s' % element_type_name)\n            for attribute in element_type[element_type_name]:\n                value = element_type[element_type_name][attribute]\n                if isinstance(value, Sequence) and (not isinstance(value, str)):\n                    if len(value) > 0:\n                        logging.info('    %-26s: %s' % (attribute, value[0]))\n                        for subvalue in value[1:]:\n                            logging.info(' ' * 32 + '%s' % subvalue)\n                    else:\n                        logging.info('    %-26s:' % attribute)\n                else:\n                    logging.info('    %-26s: %s' % (attribute, value))\n        cred_number += 1",
            "def parse_ccache(args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ccache = CCache.loadFile(args.ticket)\n    cred_number = 0\n    logging.info('Number of credentials in cache: %d' % len(ccache.credentials))\n    for creds in ccache.credentials:\n        logging.info('Parsing credential[%d]:' % cred_number)\n        rawTicket = creds.toTGS()\n        decodedTicket = decoder.decode(rawTicket['KDC_REP'], asn1Spec=TGS_REP())[0]\n        sessionKey = hexlify(rawTicket['sessionKey'].contents).decode('utf-8')\n        logging.info('%-30s: %s' % ('Ticket Session Key', sessionKey))\n        logging.info('%-30s: %s' % ('User Name', creds['client'].prettyPrint().split(b'@')[0].decode('utf-8')))\n        logging.info('%-30s: %s' % ('User Realm', creds['client'].prettyPrint().split(b'@')[1].decode('utf-8')))\n        spn = creds['server'].prettyPrint().split(b'@')[0].decode('utf-8')\n        logging.info('%-30s: %s' % ('Service Name', spn))\n        logging.info('%-30s: %s' % ('Service Realm', creds['server'].prettyPrint().split(b'@')[1].decode('utf-8')))\n        logging.info('%-30s: %s' % ('Start Time', datetime.datetime.fromtimestamp(creds['time']['starttime']).strftime('%d/%m/%Y %H:%M:%S %p')))\n        if datetime.datetime.fromtimestamp(creds['time']['endtime']) < datetime.datetime.now():\n            logging.info('%-30s: %s (expired)' % ('End Time', datetime.datetime.fromtimestamp(creds['time']['endtime']).strftime('%d/%m/%Y %H:%M:%S %p')))\n        else:\n            logging.info('%-30s: %s' % ('End Time', datetime.datetime.fromtimestamp(creds['time']['endtime']).strftime('%d/%m/%Y %H:%M:%S %p')))\n        if datetime.datetime.fromtimestamp(creds['time']['renew_till']) < datetime.datetime.now():\n            logging.info('%-30s: %s (expired)' % ('RenewTill', datetime.datetime.fromtimestamp(creds['time']['renew_till']).strftime('%d/%m/%Y %H:%M:%S %p')))\n        else:\n            logging.info('%-30s: %s' % ('RenewTill', datetime.datetime.fromtimestamp(creds['time']['renew_till']).strftime('%d/%m/%Y %H:%M:%S %p')))\n        flags = []\n        for k in constants.TicketFlags:\n            if creds['tktflags'] >> 31 - k.value & 1 == 1:\n                flags.append(constants.TicketFlags(k.value).name)\n        logging.info('%-30s: (0x%x) %s' % ('Flags', creds['tktflags'], ', '.join(flags)))\n        keyType = constants.EncryptionTypes(creds['key']['keytype']).name\n        logging.info('%-30s: %s' % ('KeyType', keyType))\n        logging.info('%-30s: %s' % ('Base64(key)', base64.b64encode(creds['key']['keyvalue']).decode('utf-8')))\n        if spn.split('/')[0] != 'krbtgt':\n            logging.debug('Attempting to create Kerberoast hash')\n            kerberoast_hash = None\n            if keyType != 'rc4_hmac' and keyType != 'aes256_cts_hmac_sha1_96':\n                logging.debug('Service ticket uses encryption key type %s, unable to extract hash and salt' % keyType)\n            elif keyType == 'rc4_hmac':\n                kerberoast_hash = kerberoast_from_ccache(decodedTGS=decodedTicket, spn=spn, username=args.user, domain=args.domain)\n            elif args.user:\n                if args.user.endswith('$'):\n                    user = 'host%s.%s' % (args.user.rstrip('$').lower(), args.domain.lower())\n                else:\n                    user = args.user\n                kerberoast_hash = kerberoast_from_ccache(decodedTGS=decodedTicket, spn=spn, username=user, domain=args.domain)\n            else:\n                logging.error(\"AES256 in use but no '-u/--user' passed, unable to generate crackable hash\")\n            if kerberoast_hash:\n                logging.info('%-30s: %s' % ('Kerberoast hash', kerberoast_hash))\n        logging.info('%-30s:' % \"Decoding unencrypted data in credential[%d]['ticket']\" % cred_number)\n        spn = '/'.join(list([str(sname_component) for sname_component in decodedTicket['ticket']['sname']['name-string']]))\n        etype = decodedTicket['ticket']['enc-part']['etype']\n        logging.info('  %-28s: %s' % ('Service Name', spn))\n        logging.info('  %-28s: %s' % ('Service Realm', decodedTicket['ticket']['realm']))\n        logging.info('  %-28s: %s (etype %d)' % ('Encryption type', constants.EncryptionTypes(etype).name, etype))\n        if not decodedTicket['ticket']['enc-part']['kvno'].isNoValue():\n            logging.debug('No kvno in ticket, skipping')\n            logging.info('  %-28s: %d' % ('Key version number (kvno)', decodedTicket['ticket']['enc-part']['kvno']))\n        logging.debug('Handling Kerberos keys')\n        ekeys = generate_kerberos_keys(args)\n        try:\n            logging.debug('Ticket is encrypted with %s (etype %d)' % (constants.EncryptionTypes(etype).name, etype))\n            key = ekeys[etype]\n            logging.debug('Using corresponding key: %s' % hexlify(key.contents).decode('utf-8'))\n        except KeyError:\n            if len(ekeys) > 0:\n                logging.error('Could not find the correct encryption key! Ticket is encrypted with %s (etype %d), but only keytype(s) %s were calculated/supplied', constants.EncryptionTypes(etype).name, etype, ', '.join([str(enctype) for enctype in ekeys.keys()]))\n            else:\n                logging.error('Could not find the correct encryption key! Ticket is encrypted with %s (etype %d), but no keys/creds were supplied', constants.EncryptionTypes(etype).name, etype)\n            return None\n        try:\n            cipherText = decodedTicket['ticket']['enc-part']['cipher']\n            newCipher = _enctype_table[int(etype)]\n            plainText = newCipher.decrypt(key, 2, cipherText)\n        except InvalidChecksum:\n            logging.error('Ciphertext integrity failed. Most likely the account password or AES key is incorrect')\n            if args.salt:\n                logging.info('Make sure the salt/username/domain are set and with the proper values. In case of a computer account, append a \"$\" to the name.')\n                logging.debug(\"Remember: the encrypted-part of the ticket is secured with one of the target service's Kerberos keys. The target service is the one who owns the 'Service Name' SPN printed above\")\n            return\n        logging.debug('Ticket successfully decrypted')\n        encTicketPart = decoder.decode(plainText, asn1Spec=EncTicketPart())[0]\n        sessionKey = Key(encTicketPart['key']['keytype'], bytes(encTicketPart['key']['keyvalue']))\n        adIfRelevant = decoder.decode(encTicketPart['authorization-data'][0]['ad-data'], asn1Spec=AD_IF_RELEVANT())[0]\n        pacType = pac.PACTYPE(adIfRelevant[0]['ad-data'].asOctets())\n        parsed_pac = parse_pac(pacType, args)\n        logging.info('%-30s:' % \"Decoding credential[%d]['ticket']['enc-part']\" % cred_number)\n        for element_type in parsed_pac:\n            element_type_name = list(element_type.keys())[0]\n            logging.info('  %-28s' % element_type_name)\n            for attribute in element_type[element_type_name]:\n                value = element_type[element_type_name][attribute]\n                if isinstance(value, Sequence) and (not isinstance(value, str)):\n                    if len(value) > 0:\n                        logging.info('    %-26s: %s' % (attribute, value[0]))\n                        for subvalue in value[1:]:\n                            logging.info(' ' * 32 + '%s' % subvalue)\n                    else:\n                        logging.info('    %-26s:' % attribute)\n                else:\n                    logging.info('    %-26s: %s' % (attribute, value))\n        cred_number += 1",
            "def parse_ccache(args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ccache = CCache.loadFile(args.ticket)\n    cred_number = 0\n    logging.info('Number of credentials in cache: %d' % len(ccache.credentials))\n    for creds in ccache.credentials:\n        logging.info('Parsing credential[%d]:' % cred_number)\n        rawTicket = creds.toTGS()\n        decodedTicket = decoder.decode(rawTicket['KDC_REP'], asn1Spec=TGS_REP())[0]\n        sessionKey = hexlify(rawTicket['sessionKey'].contents).decode('utf-8')\n        logging.info('%-30s: %s' % ('Ticket Session Key', sessionKey))\n        logging.info('%-30s: %s' % ('User Name', creds['client'].prettyPrint().split(b'@')[0].decode('utf-8')))\n        logging.info('%-30s: %s' % ('User Realm', creds['client'].prettyPrint().split(b'@')[1].decode('utf-8')))\n        spn = creds['server'].prettyPrint().split(b'@')[0].decode('utf-8')\n        logging.info('%-30s: %s' % ('Service Name', spn))\n        logging.info('%-30s: %s' % ('Service Realm', creds['server'].prettyPrint().split(b'@')[1].decode('utf-8')))\n        logging.info('%-30s: %s' % ('Start Time', datetime.datetime.fromtimestamp(creds['time']['starttime']).strftime('%d/%m/%Y %H:%M:%S %p')))\n        if datetime.datetime.fromtimestamp(creds['time']['endtime']) < datetime.datetime.now():\n            logging.info('%-30s: %s (expired)' % ('End Time', datetime.datetime.fromtimestamp(creds['time']['endtime']).strftime('%d/%m/%Y %H:%M:%S %p')))\n        else:\n            logging.info('%-30s: %s' % ('End Time', datetime.datetime.fromtimestamp(creds['time']['endtime']).strftime('%d/%m/%Y %H:%M:%S %p')))\n        if datetime.datetime.fromtimestamp(creds['time']['renew_till']) < datetime.datetime.now():\n            logging.info('%-30s: %s (expired)' % ('RenewTill', datetime.datetime.fromtimestamp(creds['time']['renew_till']).strftime('%d/%m/%Y %H:%M:%S %p')))\n        else:\n            logging.info('%-30s: %s' % ('RenewTill', datetime.datetime.fromtimestamp(creds['time']['renew_till']).strftime('%d/%m/%Y %H:%M:%S %p')))\n        flags = []\n        for k in constants.TicketFlags:\n            if creds['tktflags'] >> 31 - k.value & 1 == 1:\n                flags.append(constants.TicketFlags(k.value).name)\n        logging.info('%-30s: (0x%x) %s' % ('Flags', creds['tktflags'], ', '.join(flags)))\n        keyType = constants.EncryptionTypes(creds['key']['keytype']).name\n        logging.info('%-30s: %s' % ('KeyType', keyType))\n        logging.info('%-30s: %s' % ('Base64(key)', base64.b64encode(creds['key']['keyvalue']).decode('utf-8')))\n        if spn.split('/')[0] != 'krbtgt':\n            logging.debug('Attempting to create Kerberoast hash')\n            kerberoast_hash = None\n            if keyType != 'rc4_hmac' and keyType != 'aes256_cts_hmac_sha1_96':\n                logging.debug('Service ticket uses encryption key type %s, unable to extract hash and salt' % keyType)\n            elif keyType == 'rc4_hmac':\n                kerberoast_hash = kerberoast_from_ccache(decodedTGS=decodedTicket, spn=spn, username=args.user, domain=args.domain)\n            elif args.user:\n                if args.user.endswith('$'):\n                    user = 'host%s.%s' % (args.user.rstrip('$').lower(), args.domain.lower())\n                else:\n                    user = args.user\n                kerberoast_hash = kerberoast_from_ccache(decodedTGS=decodedTicket, spn=spn, username=user, domain=args.domain)\n            else:\n                logging.error(\"AES256 in use but no '-u/--user' passed, unable to generate crackable hash\")\n            if kerberoast_hash:\n                logging.info('%-30s: %s' % ('Kerberoast hash', kerberoast_hash))\n        logging.info('%-30s:' % \"Decoding unencrypted data in credential[%d]['ticket']\" % cred_number)\n        spn = '/'.join(list([str(sname_component) for sname_component in decodedTicket['ticket']['sname']['name-string']]))\n        etype = decodedTicket['ticket']['enc-part']['etype']\n        logging.info('  %-28s: %s' % ('Service Name', spn))\n        logging.info('  %-28s: %s' % ('Service Realm', decodedTicket['ticket']['realm']))\n        logging.info('  %-28s: %s (etype %d)' % ('Encryption type', constants.EncryptionTypes(etype).name, etype))\n        if not decodedTicket['ticket']['enc-part']['kvno'].isNoValue():\n            logging.debug('No kvno in ticket, skipping')\n            logging.info('  %-28s: %d' % ('Key version number (kvno)', decodedTicket['ticket']['enc-part']['kvno']))\n        logging.debug('Handling Kerberos keys')\n        ekeys = generate_kerberos_keys(args)\n        try:\n            logging.debug('Ticket is encrypted with %s (etype %d)' % (constants.EncryptionTypes(etype).name, etype))\n            key = ekeys[etype]\n            logging.debug('Using corresponding key: %s' % hexlify(key.contents).decode('utf-8'))\n        except KeyError:\n            if len(ekeys) > 0:\n                logging.error('Could not find the correct encryption key! Ticket is encrypted with %s (etype %d), but only keytype(s) %s were calculated/supplied', constants.EncryptionTypes(etype).name, etype, ', '.join([str(enctype) for enctype in ekeys.keys()]))\n            else:\n                logging.error('Could not find the correct encryption key! Ticket is encrypted with %s (etype %d), but no keys/creds were supplied', constants.EncryptionTypes(etype).name, etype)\n            return None\n        try:\n            cipherText = decodedTicket['ticket']['enc-part']['cipher']\n            newCipher = _enctype_table[int(etype)]\n            plainText = newCipher.decrypt(key, 2, cipherText)\n        except InvalidChecksum:\n            logging.error('Ciphertext integrity failed. Most likely the account password or AES key is incorrect')\n            if args.salt:\n                logging.info('Make sure the salt/username/domain are set and with the proper values. In case of a computer account, append a \"$\" to the name.')\n                logging.debug(\"Remember: the encrypted-part of the ticket is secured with one of the target service's Kerberos keys. The target service is the one who owns the 'Service Name' SPN printed above\")\n            return\n        logging.debug('Ticket successfully decrypted')\n        encTicketPart = decoder.decode(plainText, asn1Spec=EncTicketPart())[0]\n        sessionKey = Key(encTicketPart['key']['keytype'], bytes(encTicketPart['key']['keyvalue']))\n        adIfRelevant = decoder.decode(encTicketPart['authorization-data'][0]['ad-data'], asn1Spec=AD_IF_RELEVANT())[0]\n        pacType = pac.PACTYPE(adIfRelevant[0]['ad-data'].asOctets())\n        parsed_pac = parse_pac(pacType, args)\n        logging.info('%-30s:' % \"Decoding credential[%d]['ticket']['enc-part']\" % cred_number)\n        for element_type in parsed_pac:\n            element_type_name = list(element_type.keys())[0]\n            logging.info('  %-28s' % element_type_name)\n            for attribute in element_type[element_type_name]:\n                value = element_type[element_type_name][attribute]\n                if isinstance(value, Sequence) and (not isinstance(value, str)):\n                    if len(value) > 0:\n                        logging.info('    %-26s: %s' % (attribute, value[0]))\n                        for subvalue in value[1:]:\n                            logging.info(' ' * 32 + '%s' % subvalue)\n                    else:\n                        logging.info('    %-26s:' % attribute)\n                else:\n                    logging.info('    %-26s: %s' % (attribute, value))\n        cred_number += 1",
            "def parse_ccache(args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ccache = CCache.loadFile(args.ticket)\n    cred_number = 0\n    logging.info('Number of credentials in cache: %d' % len(ccache.credentials))\n    for creds in ccache.credentials:\n        logging.info('Parsing credential[%d]:' % cred_number)\n        rawTicket = creds.toTGS()\n        decodedTicket = decoder.decode(rawTicket['KDC_REP'], asn1Spec=TGS_REP())[0]\n        sessionKey = hexlify(rawTicket['sessionKey'].contents).decode('utf-8')\n        logging.info('%-30s: %s' % ('Ticket Session Key', sessionKey))\n        logging.info('%-30s: %s' % ('User Name', creds['client'].prettyPrint().split(b'@')[0].decode('utf-8')))\n        logging.info('%-30s: %s' % ('User Realm', creds['client'].prettyPrint().split(b'@')[1].decode('utf-8')))\n        spn = creds['server'].prettyPrint().split(b'@')[0].decode('utf-8')\n        logging.info('%-30s: %s' % ('Service Name', spn))\n        logging.info('%-30s: %s' % ('Service Realm', creds['server'].prettyPrint().split(b'@')[1].decode('utf-8')))\n        logging.info('%-30s: %s' % ('Start Time', datetime.datetime.fromtimestamp(creds['time']['starttime']).strftime('%d/%m/%Y %H:%M:%S %p')))\n        if datetime.datetime.fromtimestamp(creds['time']['endtime']) < datetime.datetime.now():\n            logging.info('%-30s: %s (expired)' % ('End Time', datetime.datetime.fromtimestamp(creds['time']['endtime']).strftime('%d/%m/%Y %H:%M:%S %p')))\n        else:\n            logging.info('%-30s: %s' % ('End Time', datetime.datetime.fromtimestamp(creds['time']['endtime']).strftime('%d/%m/%Y %H:%M:%S %p')))\n        if datetime.datetime.fromtimestamp(creds['time']['renew_till']) < datetime.datetime.now():\n            logging.info('%-30s: %s (expired)' % ('RenewTill', datetime.datetime.fromtimestamp(creds['time']['renew_till']).strftime('%d/%m/%Y %H:%M:%S %p')))\n        else:\n            logging.info('%-30s: %s' % ('RenewTill', datetime.datetime.fromtimestamp(creds['time']['renew_till']).strftime('%d/%m/%Y %H:%M:%S %p')))\n        flags = []\n        for k in constants.TicketFlags:\n            if creds['tktflags'] >> 31 - k.value & 1 == 1:\n                flags.append(constants.TicketFlags(k.value).name)\n        logging.info('%-30s: (0x%x) %s' % ('Flags', creds['tktflags'], ', '.join(flags)))\n        keyType = constants.EncryptionTypes(creds['key']['keytype']).name\n        logging.info('%-30s: %s' % ('KeyType', keyType))\n        logging.info('%-30s: %s' % ('Base64(key)', base64.b64encode(creds['key']['keyvalue']).decode('utf-8')))\n        if spn.split('/')[0] != 'krbtgt':\n            logging.debug('Attempting to create Kerberoast hash')\n            kerberoast_hash = None\n            if keyType != 'rc4_hmac' and keyType != 'aes256_cts_hmac_sha1_96':\n                logging.debug('Service ticket uses encryption key type %s, unable to extract hash and salt' % keyType)\n            elif keyType == 'rc4_hmac':\n                kerberoast_hash = kerberoast_from_ccache(decodedTGS=decodedTicket, spn=spn, username=args.user, domain=args.domain)\n            elif args.user:\n                if args.user.endswith('$'):\n                    user = 'host%s.%s' % (args.user.rstrip('$').lower(), args.domain.lower())\n                else:\n                    user = args.user\n                kerberoast_hash = kerberoast_from_ccache(decodedTGS=decodedTicket, spn=spn, username=user, domain=args.domain)\n            else:\n                logging.error(\"AES256 in use but no '-u/--user' passed, unable to generate crackable hash\")\n            if kerberoast_hash:\n                logging.info('%-30s: %s' % ('Kerberoast hash', kerberoast_hash))\n        logging.info('%-30s:' % \"Decoding unencrypted data in credential[%d]['ticket']\" % cred_number)\n        spn = '/'.join(list([str(sname_component) for sname_component in decodedTicket['ticket']['sname']['name-string']]))\n        etype = decodedTicket['ticket']['enc-part']['etype']\n        logging.info('  %-28s: %s' % ('Service Name', spn))\n        logging.info('  %-28s: %s' % ('Service Realm', decodedTicket['ticket']['realm']))\n        logging.info('  %-28s: %s (etype %d)' % ('Encryption type', constants.EncryptionTypes(etype).name, etype))\n        if not decodedTicket['ticket']['enc-part']['kvno'].isNoValue():\n            logging.debug('No kvno in ticket, skipping')\n            logging.info('  %-28s: %d' % ('Key version number (kvno)', decodedTicket['ticket']['enc-part']['kvno']))\n        logging.debug('Handling Kerberos keys')\n        ekeys = generate_kerberos_keys(args)\n        try:\n            logging.debug('Ticket is encrypted with %s (etype %d)' % (constants.EncryptionTypes(etype).name, etype))\n            key = ekeys[etype]\n            logging.debug('Using corresponding key: %s' % hexlify(key.contents).decode('utf-8'))\n        except KeyError:\n            if len(ekeys) > 0:\n                logging.error('Could not find the correct encryption key! Ticket is encrypted with %s (etype %d), but only keytype(s) %s were calculated/supplied', constants.EncryptionTypes(etype).name, etype, ', '.join([str(enctype) for enctype in ekeys.keys()]))\n            else:\n                logging.error('Could not find the correct encryption key! Ticket is encrypted with %s (etype %d), but no keys/creds were supplied', constants.EncryptionTypes(etype).name, etype)\n            return None\n        try:\n            cipherText = decodedTicket['ticket']['enc-part']['cipher']\n            newCipher = _enctype_table[int(etype)]\n            plainText = newCipher.decrypt(key, 2, cipherText)\n        except InvalidChecksum:\n            logging.error('Ciphertext integrity failed. Most likely the account password or AES key is incorrect')\n            if args.salt:\n                logging.info('Make sure the salt/username/domain are set and with the proper values. In case of a computer account, append a \"$\" to the name.')\n                logging.debug(\"Remember: the encrypted-part of the ticket is secured with one of the target service's Kerberos keys. The target service is the one who owns the 'Service Name' SPN printed above\")\n            return\n        logging.debug('Ticket successfully decrypted')\n        encTicketPart = decoder.decode(plainText, asn1Spec=EncTicketPart())[0]\n        sessionKey = Key(encTicketPart['key']['keytype'], bytes(encTicketPart['key']['keyvalue']))\n        adIfRelevant = decoder.decode(encTicketPart['authorization-data'][0]['ad-data'], asn1Spec=AD_IF_RELEVANT())[0]\n        pacType = pac.PACTYPE(adIfRelevant[0]['ad-data'].asOctets())\n        parsed_pac = parse_pac(pacType, args)\n        logging.info('%-30s:' % \"Decoding credential[%d]['ticket']['enc-part']\" % cred_number)\n        for element_type in parsed_pac:\n            element_type_name = list(element_type.keys())[0]\n            logging.info('  %-28s' % element_type_name)\n            for attribute in element_type[element_type_name]:\n                value = element_type[element_type_name][attribute]\n                if isinstance(value, Sequence) and (not isinstance(value, str)):\n                    if len(value) > 0:\n                        logging.info('    %-26s: %s' % (attribute, value[0]))\n                        for subvalue in value[1:]:\n                            logging.info(' ' * 32 + '%s' % subvalue)\n                    else:\n                        logging.info('    %-26s:' % attribute)\n                else:\n                    logging.info('    %-26s: %s' % (attribute, value))\n        cred_number += 1"
        ]
    },
    {
        "func_name": "PACparseFILETIME",
        "original": "def PACparseFILETIME(data):\n    dwLowDateTime = data['dwLowDateTime']\n    dwHighDateTime = data['dwHighDateTime']\n    v_FILETIME = 'Infinity (absolute time)'\n    if dwLowDateTime != 4294967295 and dwHighDateTime != 2147483647:\n        temp_time = dwHighDateTime\n        temp_time <<= 32\n        temp_time |= dwLowDateTime\n        if datetime.timedelta(microseconds=temp_time / 10).total_seconds() != 0:\n            v_FILETIME = (datetime.datetime(1601, 1, 1, 0, 0, 0) + datetime.timedelta(microseconds=temp_time / 10)).strftime('%d/%m/%Y %H:%M:%S %p')\n    return v_FILETIME",
        "mutated": [
            "def PACparseFILETIME(data):\n    if False:\n        i = 10\n    dwLowDateTime = data['dwLowDateTime']\n    dwHighDateTime = data['dwHighDateTime']\n    v_FILETIME = 'Infinity (absolute time)'\n    if dwLowDateTime != 4294967295 and dwHighDateTime != 2147483647:\n        temp_time = dwHighDateTime\n        temp_time <<= 32\n        temp_time |= dwLowDateTime\n        if datetime.timedelta(microseconds=temp_time / 10).total_seconds() != 0:\n            v_FILETIME = (datetime.datetime(1601, 1, 1, 0, 0, 0) + datetime.timedelta(microseconds=temp_time / 10)).strftime('%d/%m/%Y %H:%M:%S %p')\n    return v_FILETIME",
            "def PACparseFILETIME(data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    dwLowDateTime = data['dwLowDateTime']\n    dwHighDateTime = data['dwHighDateTime']\n    v_FILETIME = 'Infinity (absolute time)'\n    if dwLowDateTime != 4294967295 and dwHighDateTime != 2147483647:\n        temp_time = dwHighDateTime\n        temp_time <<= 32\n        temp_time |= dwLowDateTime\n        if datetime.timedelta(microseconds=temp_time / 10).total_seconds() != 0:\n            v_FILETIME = (datetime.datetime(1601, 1, 1, 0, 0, 0) + datetime.timedelta(microseconds=temp_time / 10)).strftime('%d/%m/%Y %H:%M:%S %p')\n    return v_FILETIME",
            "def PACparseFILETIME(data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    dwLowDateTime = data['dwLowDateTime']\n    dwHighDateTime = data['dwHighDateTime']\n    v_FILETIME = 'Infinity (absolute time)'\n    if dwLowDateTime != 4294967295 and dwHighDateTime != 2147483647:\n        temp_time = dwHighDateTime\n        temp_time <<= 32\n        temp_time |= dwLowDateTime\n        if datetime.timedelta(microseconds=temp_time / 10).total_seconds() != 0:\n            v_FILETIME = (datetime.datetime(1601, 1, 1, 0, 0, 0) + datetime.timedelta(microseconds=temp_time / 10)).strftime('%d/%m/%Y %H:%M:%S %p')\n    return v_FILETIME",
            "def PACparseFILETIME(data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    dwLowDateTime = data['dwLowDateTime']\n    dwHighDateTime = data['dwHighDateTime']\n    v_FILETIME = 'Infinity (absolute time)'\n    if dwLowDateTime != 4294967295 and dwHighDateTime != 2147483647:\n        temp_time = dwHighDateTime\n        temp_time <<= 32\n        temp_time |= dwLowDateTime\n        if datetime.timedelta(microseconds=temp_time / 10).total_seconds() != 0:\n            v_FILETIME = (datetime.datetime(1601, 1, 1, 0, 0, 0) + datetime.timedelta(microseconds=temp_time / 10)).strftime('%d/%m/%Y %H:%M:%S %p')\n    return v_FILETIME",
            "def PACparseFILETIME(data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    dwLowDateTime = data['dwLowDateTime']\n    dwHighDateTime = data['dwHighDateTime']\n    v_FILETIME = 'Infinity (absolute time)'\n    if dwLowDateTime != 4294967295 and dwHighDateTime != 2147483647:\n        temp_time = dwHighDateTime\n        temp_time <<= 32\n        temp_time |= dwLowDateTime\n        if datetime.timedelta(microseconds=temp_time / 10).total_seconds() != 0:\n            v_FILETIME = (datetime.datetime(1601, 1, 1, 0, 0, 0) + datetime.timedelta(microseconds=temp_time / 10)).strftime('%d/%m/%Y %H:%M:%S %p')\n    return v_FILETIME"
        ]
    },
    {
        "func_name": "PACparseGroupIds",
        "original": "def PACparseGroupIds(data):\n    groups = []\n    for group in data:\n        groupMembership = {}\n        groupMembership['RelativeId'] = group['RelativeId']\n        groupMembership['Attributes'] = group['Attributes']\n        groups.append(groupMembership)\n    return groups",
        "mutated": [
            "def PACparseGroupIds(data):\n    if False:\n        i = 10\n    groups = []\n    for group in data:\n        groupMembership = {}\n        groupMembership['RelativeId'] = group['RelativeId']\n        groupMembership['Attributes'] = group['Attributes']\n        groups.append(groupMembership)\n    return groups",
            "def PACparseGroupIds(data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    groups = []\n    for group in data:\n        groupMembership = {}\n        groupMembership['RelativeId'] = group['RelativeId']\n        groupMembership['Attributes'] = group['Attributes']\n        groups.append(groupMembership)\n    return groups",
            "def PACparseGroupIds(data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    groups = []\n    for group in data:\n        groupMembership = {}\n        groupMembership['RelativeId'] = group['RelativeId']\n        groupMembership['Attributes'] = group['Attributes']\n        groups.append(groupMembership)\n    return groups",
            "def PACparseGroupIds(data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    groups = []\n    for group in data:\n        groupMembership = {}\n        groupMembership['RelativeId'] = group['RelativeId']\n        groupMembership['Attributes'] = group['Attributes']\n        groups.append(groupMembership)\n    return groups",
            "def PACparseGroupIds(data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    groups = []\n    for group in data:\n        groupMembership = {}\n        groupMembership['RelativeId'] = group['RelativeId']\n        groupMembership['Attributes'] = group['Attributes']\n        groups.append(groupMembership)\n    return groups"
        ]
    },
    {
        "func_name": "parse_pac",
        "original": "def parse_pac(pacType, args):\n\n    def PACparseFILETIME(data):\n        dwLowDateTime = data['dwLowDateTime']\n        dwHighDateTime = data['dwHighDateTime']\n        v_FILETIME = 'Infinity (absolute time)'\n        if dwLowDateTime != 4294967295 and dwHighDateTime != 2147483647:\n            temp_time = dwHighDateTime\n            temp_time <<= 32\n            temp_time |= dwLowDateTime\n            if datetime.timedelta(microseconds=temp_time / 10).total_seconds() != 0:\n                v_FILETIME = (datetime.datetime(1601, 1, 1, 0, 0, 0) + datetime.timedelta(microseconds=temp_time / 10)).strftime('%d/%m/%Y %H:%M:%S %p')\n        return v_FILETIME\n\n    def PACparseGroupIds(data):\n        groups = []\n        for group in data:\n            groupMembership = {}\n            groupMembership['RelativeId'] = group['RelativeId']\n            groupMembership['Attributes'] = group['Attributes']\n            groups.append(groupMembership)\n        return groups\n    parsed_tuPAC = []\n    buff = pacType['Buffers']\n    for bufferN in range(pacType['cBuffers']):\n        infoBuffer = pac.PAC_INFO_BUFFER(buff)\n        data = pacType['Buffers'][infoBuffer['Offset'] - 8:][:infoBuffer['cbBufferSize']]\n        if infoBuffer['ulType'] == pac.PAC_LOGON_INFO:\n            type1 = TypeSerialization1(data)\n            newdata = data[len(type1) + 4:]\n            kerbdata = pac.KERB_VALIDATION_INFO()\n            kerbdata.fromString(newdata)\n            kerbdata.fromStringReferents(newdata[len(kerbdata.getData()):])\n            parsed_data = {}\n            parsed_data['Logon Time'] = PACparseFILETIME(kerbdata['LogonTime'])\n            parsed_data['Logoff Time'] = PACparseFILETIME(kerbdata['LogoffTime'])\n            parsed_data['Kickoff Time'] = PACparseFILETIME(kerbdata['KickOffTime'])\n            parsed_data['Password Last Set'] = PACparseFILETIME(kerbdata['PasswordLastSet'])\n            parsed_data['Password Can Change'] = PACparseFILETIME(kerbdata['PasswordCanChange'])\n            parsed_data['Password Must Change'] = PACparseFILETIME(kerbdata['PasswordMustChange'])\n            parsed_data['LastSuccessfulILogon'] = PACparseFILETIME(kerbdata['LastSuccessfulILogon'])\n            parsed_data['LastFailedILogon'] = PACparseFILETIME(kerbdata['LastFailedILogon'])\n            parsed_data['FailedILogonCount'] = kerbdata['FailedILogonCount']\n            parsed_data['Account Name'] = kerbdata['EffectiveName']\n            parsed_data['Full Name'] = kerbdata['FullName']\n            parsed_data['Logon Script'] = kerbdata['LogonScript']\n            parsed_data['Profile Path'] = kerbdata['ProfilePath']\n            parsed_data['Home Dir'] = kerbdata['HomeDirectory']\n            parsed_data['Dir Drive'] = kerbdata['HomeDirectoryDrive']\n            parsed_data['Logon Count'] = kerbdata['LogonCount']\n            parsed_data['Bad Password Count'] = kerbdata['BadPasswordCount']\n            parsed_data['User RID'] = kerbdata['UserId']\n            parsed_data['Group RID'] = kerbdata['PrimaryGroupId']\n            parsed_data['Group Count'] = kerbdata['GroupCount']\n            all_groups_id = [str(gid['RelativeId']) for gid in PACparseGroupIds(kerbdata['GroupIds'])]\n            parsed_data['Groups'] = ', '.join(all_groups_id)\n            groups = []\n            unknown_count = 0\n            for gid in all_groups_id:\n                group_name = MsBuiltInGroups.get(gid)\n                if group_name:\n                    groups.append(f'({gid}) {group_name}')\n                else:\n                    unknown_count += 1\n            if unknown_count > 0:\n                groups.append(f\"+{unknown_count} Unknown custom group{('s' if unknown_count > 1 else '')}\")\n            parsed_data['Groups (decoded)'] = groups\n            UserFlags = kerbdata['UserFlags']\n            User_Flags_Flags = []\n            for flag in User_Flags:\n                if UserFlags & flag.value:\n                    User_Flags_Flags.append(flag.name)\n            parsed_data['User Flags'] = '(%s) %s' % (UserFlags, ', '.join(User_Flags_Flags))\n            parsed_data['User Session Key'] = hexlify(kerbdata['UserSessionKey']).decode('utf-8')\n            parsed_data['Logon Server'] = kerbdata['LogonServer']\n            parsed_data['Logon Domain Name'] = kerbdata['LogonDomainName']\n            if kerbdata['LogonDomainId'] == b'':\n                parsed_data['Logon Domain SID'] = kerbdata['LogonDomainId']\n            else:\n                parsed_data['Logon Domain SID'] = kerbdata['LogonDomainId'].formatCanonical()\n            UAC = kerbdata['UserAccountControl']\n            UAC_Flags = []\n            for flag in USER_ACCOUNT_Codes:\n                if UAC & flag.value:\n                    UAC_Flags.append(flag.name)\n            parsed_data['User Account Control'] = '(%s) %s' % (UAC, ', '.join(UAC_Flags))\n            parsed_data['Extra SID Count'] = kerbdata['SidCount']\n            extraSids = []\n            for extraSid in kerbdata['ExtraSids']:\n                sid = extraSid['Sid'].formatCanonical()\n                attributes = extraSid['Attributes']\n                attributes_flags = []\n                for flag in SE_GROUP_Attributes:\n                    if attributes & flag.value:\n                        attributes_flags.append(flag.name)\n                group_name = MsBuiltInGroups.get(sid, '')\n                if not group_name and len(sid.split('-')) == 8:\n                    group_name = MsBuiltInGroups.get(sid.split('-')[-1], '')\n                if group_name:\n                    group_name = f' {group_name}'\n                extraSids.append('%s%s (%s)' % (sid, group_name, ', '.join(attributes_flags)))\n            parsed_data['Extra SIDs'] = extraSids\n            if kerbdata['ResourceGroupDomainSid'] == b'':\n                parsed_data['Resource Group Domain SID'] = kerbdata['ResourceGroupDomainSid']\n            else:\n                parsed_data['Resource Group Domain SID'] = kerbdata['ResourceGroupDomainSid'].formatCanonical()\n            parsed_data['Resource Group Count'] = kerbdata['ResourceGroupCount']\n            parsed_data['Resource Group Ids'] = ', '.join([str(gid['RelativeId']) for gid in PACparseGroupIds(kerbdata['ResourceGroupIds'])])\n            parsed_data['LMKey'] = hexlify(kerbdata['LMKey']).decode('utf-8')\n            parsed_data['SubAuthStatus'] = kerbdata['SubAuthStatus']\n            parsed_data['Reserved3'] = kerbdata['Reserved3']\n            parsed_tuPAC.append({'LoginInfo': parsed_data})\n        elif infoBuffer['ulType'] == pac.PAC_CLIENT_INFO_TYPE:\n            clientInfo = pac.PAC_CLIENT_INFO()\n            clientInfo.fromString(data)\n            parsed_data = {}\n            try:\n                parsed_data['Client Id'] = PACparseFILETIME(clientInfo['ClientId'])\n            except:\n                try:\n                    parsed_data['Client Id'] = PACparseFILETIME(FILETIME(data[:32]))\n                except Exception as e:\n                    logging.error(e)\n            parsed_data['Client Name'] = clientInfo['Name'].decode('utf-16-le')\n            parsed_tuPAC.append({'ClientName': parsed_data})\n        elif infoBuffer['ulType'] == pac.PAC_UPN_DNS_INFO:\n            upn = pac.UPN_DNS_INFO(data)\n            UpnLength = upn['UpnLength']\n            UpnOffset = upn['UpnOffset']\n            UpnName = data[UpnOffset:UpnOffset + UpnLength].decode('utf-16-le')\n            DnsDomainNameLength = upn['DnsDomainNameLength']\n            DnsDomainNameOffset = upn['DnsDomainNameOffset']\n            DnsName = data[DnsDomainNameOffset:DnsDomainNameOffset + DnsDomainNameLength].decode('utf-16-le')\n            flags = upn['Flags']\n            attr_flags = []\n            for flag_lib in Upn_Dns_Flags:\n                if flags & flag_lib.value:\n                    attr_flags.append(flag_lib.name)\n            parsed_data = {}\n            parsed_data['Flags'] = f\"({flags}) {', '.join(attr_flags)}\"\n            parsed_data['UPN'] = UpnName\n            parsed_data['DNS Domain Name'] = DnsName\n            if Upn_Dns_Flags.S_SidSamSupplied.name in attr_flags:\n                upn = pac.UPN_DNS_INFO_FULL(data)\n                SamNameLength = upn['SamNameLength']\n                SamNameOffset = upn['SamNameOffset']\n                SamName = data[SamNameOffset:SamNameOffset + SamNameLength].decode('utf-16-le')\n                SidLength = upn['SidLength']\n                SidOffset = upn['SidOffset']\n                Sid = LDAP_SID(data[SidOffset:SidOffset + SidLength])\n                parsed_data['SamAccountName'] = SamName\n                parsed_data['UserSid'] = Sid.formatCanonical()\n            parsed_tuPAC.append({'UpnDns': parsed_data})\n        elif infoBuffer['ulType'] == pac.PAC_SERVER_CHECKSUM:\n            signatureData = pac.PAC_SIGNATURE_DATA(data)\n            parsed_data = {}\n            parsed_data['Signature Type'] = ChecksumTypes(signatureData['SignatureType']).name\n            parsed_data['Signature'] = hexlify(signatureData['Signature']).decode('utf-8')\n            parsed_tuPAC.append({'ServerChecksum': parsed_data})\n        elif infoBuffer['ulType'] == pac.PAC_PRIVSVR_CHECKSUM:\n            signatureData = pac.PAC_SIGNATURE_DATA(data)\n            parsed_data = {}\n            parsed_data['Signature Type'] = ChecksumTypes(signatureData['SignatureType']).name\n            parsed_data['Signature'] = hexlify(signatureData['Signature']).decode('utf-8')\n            parsed_tuPAC.append({'KDCChecksum': parsed_data})\n        elif infoBuffer['ulType'] == pac.PAC_CREDENTIALS_INFO:\n            credential_info = pac.PAC_CREDENTIAL_INFO(data)\n            parsed_credential_info = {}\n            parsed_credential_info['Version'] = '(0x%x) %d' % (credential_info.fields['Version'], credential_info.fields['Version'])\n            credinfo_enctype = credential_info.fields['EncryptionType']\n            parsed_credential_info['Encryption Type'] = '(0x%x) %s' % (credinfo_enctype, constants.EncryptionTypes(credential_info.fields['EncryptionType']).name)\n            if not args.asrep_key:\n                parsed_credential_info['Encryption Type'] = '<Cannot decrypt, --asrep-key missing>'\n                logging.error('No ASREP key supplied, cannot decrypt PAC Credentials')\n                parsed_tuPAC.append({'Credential Info': parsed_credential_info})\n            else:\n                parsed_tuPAC.append({'Credential Info': parsed_credential_info})\n                newCipher = _enctype_table[credinfo_enctype]\n                key = Key(credinfo_enctype, unhexlify(args.asrep_key))\n                plain_credential_data = newCipher.decrypt(key, 16, credential_info.fields['SerializedData'])\n                type1 = TypeSerialization1(plain_credential_data)\n                newdata = plain_credential_data[len(type1) + 4:]\n                credential_data = pac.PAC_CREDENTIAL_DATA(newdata)\n                parsed_credential_data = {}\n                parsed_credential_data['  Credential Count'] = credential_data['CredentialCount']\n                parsed_tuPAC.append({'  Credential Data': parsed_credential_data})\n                for credential in credential_data['Credentials']:\n                    parsed_secpkg_supplemental_cred = {}\n                    parsed_secpkg_supplemental_cred['      Package Name'] = credential['PackageName']\n                    parsed_secpkg_supplemental_cred['      Credential Size'] = credential['CredentialSize']\n                    parsed_tuPAC.append({'      SecPkg Credentials': parsed_secpkg_supplemental_cred})\n                    ntlm_supplemental_cred = pac.NTLM_SUPPLEMENTAL_CREDENTIAL(b''.join(credential['Credentials']))\n                    parsed_ntlm_supplemental_cred = {}\n                    parsed_ntlm_supplemental_cred['        Version'] = ntlm_supplemental_cred['Version']\n                    parsed_ntlm_supplemental_cred['        Flags'] = ntlm_supplemental_cred['Flags']\n                    parsed_ntlm_supplemental_cred['        LmPasword'] = hexlify(ntlm_supplemental_cred['LmPassword']).decode('utf-8')\n                    parsed_ntlm_supplemental_cred['        NtPasword'] = hexlify(ntlm_supplemental_cred['NtPassword']).decode('utf-8')\n                    parsed_tuPAC.append({'        NTLM Credentials': parsed_ntlm_supplemental_cred})\n        elif infoBuffer['ulType'] == pac.PAC_DELEGATION_INFO:\n            delegationInfo = pac.S4U_DELEGATION_INFO(data)\n            parsed_data = {}\n            parsed_data['S4U2proxyTarget'] = delegationInfo['S4U2proxyTarget']\n            parsed_data['TransitedListSize'] = delegationInfo.fields['TransitedListSize'].fields['Data']\n            parsed_data['S4UTransitedServices'] = delegationInfo['S4UTransitedServices'].decode('utf-8')\n            parsed_tuPAC.append({'DelegationInfo': parsed_data})\n        elif infoBuffer['ulType'] == pac.PAC_ATTRIBUTES_INFO:\n            attributeInfo = pac.PAC_ATTRIBUTE_INFO(data)\n            flags = attributeInfo['Flags']\n            attr_flags = []\n            for flag_lib in Attributes_Flags:\n                if flags & flag_lib.value:\n                    attr_flags.append(flag_lib.name)\n            parsed_data = {'Flags': f\"({flags}) {', '.join(attr_flags)}\"}\n            parsed_tuPAC.append({'Attributes Info': parsed_data})\n        elif infoBuffer['ulType'] == pac.PAC_REQUESTOR_INFO:\n            requestorInfo = pac.PAC_REQUESTOR(data)\n            parsed_data = {'UserSid': requestorInfo['UserSid'].formatCanonical()}\n            parsed_tuPAC.append({'Requestor Info': parsed_data})\n        else:\n            logging.debug('Unsupported PAC structure: %s. Please raise an issue or PR' % infoBuffer['ulType'])\n        buff = buff[len(infoBuffer):]\n    return parsed_tuPAC",
        "mutated": [
            "def parse_pac(pacType, args):\n    if False:\n        i = 10\n\n    def PACparseFILETIME(data):\n        dwLowDateTime = data['dwLowDateTime']\n        dwHighDateTime = data['dwHighDateTime']\n        v_FILETIME = 'Infinity (absolute time)'\n        if dwLowDateTime != 4294967295 and dwHighDateTime != 2147483647:\n            temp_time = dwHighDateTime\n            temp_time <<= 32\n            temp_time |= dwLowDateTime\n            if datetime.timedelta(microseconds=temp_time / 10).total_seconds() != 0:\n                v_FILETIME = (datetime.datetime(1601, 1, 1, 0, 0, 0) + datetime.timedelta(microseconds=temp_time / 10)).strftime('%d/%m/%Y %H:%M:%S %p')\n        return v_FILETIME\n\n    def PACparseGroupIds(data):\n        groups = []\n        for group in data:\n            groupMembership = {}\n            groupMembership['RelativeId'] = group['RelativeId']\n            groupMembership['Attributes'] = group['Attributes']\n            groups.append(groupMembership)\n        return groups\n    parsed_tuPAC = []\n    buff = pacType['Buffers']\n    for bufferN in range(pacType['cBuffers']):\n        infoBuffer = pac.PAC_INFO_BUFFER(buff)\n        data = pacType['Buffers'][infoBuffer['Offset'] - 8:][:infoBuffer['cbBufferSize']]\n        if infoBuffer['ulType'] == pac.PAC_LOGON_INFO:\n            type1 = TypeSerialization1(data)\n            newdata = data[len(type1) + 4:]\n            kerbdata = pac.KERB_VALIDATION_INFO()\n            kerbdata.fromString(newdata)\n            kerbdata.fromStringReferents(newdata[len(kerbdata.getData()):])\n            parsed_data = {}\n            parsed_data['Logon Time'] = PACparseFILETIME(kerbdata['LogonTime'])\n            parsed_data['Logoff Time'] = PACparseFILETIME(kerbdata['LogoffTime'])\n            parsed_data['Kickoff Time'] = PACparseFILETIME(kerbdata['KickOffTime'])\n            parsed_data['Password Last Set'] = PACparseFILETIME(kerbdata['PasswordLastSet'])\n            parsed_data['Password Can Change'] = PACparseFILETIME(kerbdata['PasswordCanChange'])\n            parsed_data['Password Must Change'] = PACparseFILETIME(kerbdata['PasswordMustChange'])\n            parsed_data['LastSuccessfulILogon'] = PACparseFILETIME(kerbdata['LastSuccessfulILogon'])\n            parsed_data['LastFailedILogon'] = PACparseFILETIME(kerbdata['LastFailedILogon'])\n            parsed_data['FailedILogonCount'] = kerbdata['FailedILogonCount']\n            parsed_data['Account Name'] = kerbdata['EffectiveName']\n            parsed_data['Full Name'] = kerbdata['FullName']\n            parsed_data['Logon Script'] = kerbdata['LogonScript']\n            parsed_data['Profile Path'] = kerbdata['ProfilePath']\n            parsed_data['Home Dir'] = kerbdata['HomeDirectory']\n            parsed_data['Dir Drive'] = kerbdata['HomeDirectoryDrive']\n            parsed_data['Logon Count'] = kerbdata['LogonCount']\n            parsed_data['Bad Password Count'] = kerbdata['BadPasswordCount']\n            parsed_data['User RID'] = kerbdata['UserId']\n            parsed_data['Group RID'] = kerbdata['PrimaryGroupId']\n            parsed_data['Group Count'] = kerbdata['GroupCount']\n            all_groups_id = [str(gid['RelativeId']) for gid in PACparseGroupIds(kerbdata['GroupIds'])]\n            parsed_data['Groups'] = ', '.join(all_groups_id)\n            groups = []\n            unknown_count = 0\n            for gid in all_groups_id:\n                group_name = MsBuiltInGroups.get(gid)\n                if group_name:\n                    groups.append(f'({gid}) {group_name}')\n                else:\n                    unknown_count += 1\n            if unknown_count > 0:\n                groups.append(f\"+{unknown_count} Unknown custom group{('s' if unknown_count > 1 else '')}\")\n            parsed_data['Groups (decoded)'] = groups\n            UserFlags = kerbdata['UserFlags']\n            User_Flags_Flags = []\n            for flag in User_Flags:\n                if UserFlags & flag.value:\n                    User_Flags_Flags.append(flag.name)\n            parsed_data['User Flags'] = '(%s) %s' % (UserFlags, ', '.join(User_Flags_Flags))\n            parsed_data['User Session Key'] = hexlify(kerbdata['UserSessionKey']).decode('utf-8')\n            parsed_data['Logon Server'] = kerbdata['LogonServer']\n            parsed_data['Logon Domain Name'] = kerbdata['LogonDomainName']\n            if kerbdata['LogonDomainId'] == b'':\n                parsed_data['Logon Domain SID'] = kerbdata['LogonDomainId']\n            else:\n                parsed_data['Logon Domain SID'] = kerbdata['LogonDomainId'].formatCanonical()\n            UAC = kerbdata['UserAccountControl']\n            UAC_Flags = []\n            for flag in USER_ACCOUNT_Codes:\n                if UAC & flag.value:\n                    UAC_Flags.append(flag.name)\n            parsed_data['User Account Control'] = '(%s) %s' % (UAC, ', '.join(UAC_Flags))\n            parsed_data['Extra SID Count'] = kerbdata['SidCount']\n            extraSids = []\n            for extraSid in kerbdata['ExtraSids']:\n                sid = extraSid['Sid'].formatCanonical()\n                attributes = extraSid['Attributes']\n                attributes_flags = []\n                for flag in SE_GROUP_Attributes:\n                    if attributes & flag.value:\n                        attributes_flags.append(flag.name)\n                group_name = MsBuiltInGroups.get(sid, '')\n                if not group_name and len(sid.split('-')) == 8:\n                    group_name = MsBuiltInGroups.get(sid.split('-')[-1], '')\n                if group_name:\n                    group_name = f' {group_name}'\n                extraSids.append('%s%s (%s)' % (sid, group_name, ', '.join(attributes_flags)))\n            parsed_data['Extra SIDs'] = extraSids\n            if kerbdata['ResourceGroupDomainSid'] == b'':\n                parsed_data['Resource Group Domain SID'] = kerbdata['ResourceGroupDomainSid']\n            else:\n                parsed_data['Resource Group Domain SID'] = kerbdata['ResourceGroupDomainSid'].formatCanonical()\n            parsed_data['Resource Group Count'] = kerbdata['ResourceGroupCount']\n            parsed_data['Resource Group Ids'] = ', '.join([str(gid['RelativeId']) for gid in PACparseGroupIds(kerbdata['ResourceGroupIds'])])\n            parsed_data['LMKey'] = hexlify(kerbdata['LMKey']).decode('utf-8')\n            parsed_data['SubAuthStatus'] = kerbdata['SubAuthStatus']\n            parsed_data['Reserved3'] = kerbdata['Reserved3']\n            parsed_tuPAC.append({'LoginInfo': parsed_data})\n        elif infoBuffer['ulType'] == pac.PAC_CLIENT_INFO_TYPE:\n            clientInfo = pac.PAC_CLIENT_INFO()\n            clientInfo.fromString(data)\n            parsed_data = {}\n            try:\n                parsed_data['Client Id'] = PACparseFILETIME(clientInfo['ClientId'])\n            except:\n                try:\n                    parsed_data['Client Id'] = PACparseFILETIME(FILETIME(data[:32]))\n                except Exception as e:\n                    logging.error(e)\n            parsed_data['Client Name'] = clientInfo['Name'].decode('utf-16-le')\n            parsed_tuPAC.append({'ClientName': parsed_data})\n        elif infoBuffer['ulType'] == pac.PAC_UPN_DNS_INFO:\n            upn = pac.UPN_DNS_INFO(data)\n            UpnLength = upn['UpnLength']\n            UpnOffset = upn['UpnOffset']\n            UpnName = data[UpnOffset:UpnOffset + UpnLength].decode('utf-16-le')\n            DnsDomainNameLength = upn['DnsDomainNameLength']\n            DnsDomainNameOffset = upn['DnsDomainNameOffset']\n            DnsName = data[DnsDomainNameOffset:DnsDomainNameOffset + DnsDomainNameLength].decode('utf-16-le')\n            flags = upn['Flags']\n            attr_flags = []\n            for flag_lib in Upn_Dns_Flags:\n                if flags & flag_lib.value:\n                    attr_flags.append(flag_lib.name)\n            parsed_data = {}\n            parsed_data['Flags'] = f\"({flags}) {', '.join(attr_flags)}\"\n            parsed_data['UPN'] = UpnName\n            parsed_data['DNS Domain Name'] = DnsName\n            if Upn_Dns_Flags.S_SidSamSupplied.name in attr_flags:\n                upn = pac.UPN_DNS_INFO_FULL(data)\n                SamNameLength = upn['SamNameLength']\n                SamNameOffset = upn['SamNameOffset']\n                SamName = data[SamNameOffset:SamNameOffset + SamNameLength].decode('utf-16-le')\n                SidLength = upn['SidLength']\n                SidOffset = upn['SidOffset']\n                Sid = LDAP_SID(data[SidOffset:SidOffset + SidLength])\n                parsed_data['SamAccountName'] = SamName\n                parsed_data['UserSid'] = Sid.formatCanonical()\n            parsed_tuPAC.append({'UpnDns': parsed_data})\n        elif infoBuffer['ulType'] == pac.PAC_SERVER_CHECKSUM:\n            signatureData = pac.PAC_SIGNATURE_DATA(data)\n            parsed_data = {}\n            parsed_data['Signature Type'] = ChecksumTypes(signatureData['SignatureType']).name\n            parsed_data['Signature'] = hexlify(signatureData['Signature']).decode('utf-8')\n            parsed_tuPAC.append({'ServerChecksum': parsed_data})\n        elif infoBuffer['ulType'] == pac.PAC_PRIVSVR_CHECKSUM:\n            signatureData = pac.PAC_SIGNATURE_DATA(data)\n            parsed_data = {}\n            parsed_data['Signature Type'] = ChecksumTypes(signatureData['SignatureType']).name\n            parsed_data['Signature'] = hexlify(signatureData['Signature']).decode('utf-8')\n            parsed_tuPAC.append({'KDCChecksum': parsed_data})\n        elif infoBuffer['ulType'] == pac.PAC_CREDENTIALS_INFO:\n            credential_info = pac.PAC_CREDENTIAL_INFO(data)\n            parsed_credential_info = {}\n            parsed_credential_info['Version'] = '(0x%x) %d' % (credential_info.fields['Version'], credential_info.fields['Version'])\n            credinfo_enctype = credential_info.fields['EncryptionType']\n            parsed_credential_info['Encryption Type'] = '(0x%x) %s' % (credinfo_enctype, constants.EncryptionTypes(credential_info.fields['EncryptionType']).name)\n            if not args.asrep_key:\n                parsed_credential_info['Encryption Type'] = '<Cannot decrypt, --asrep-key missing>'\n                logging.error('No ASREP key supplied, cannot decrypt PAC Credentials')\n                parsed_tuPAC.append({'Credential Info': parsed_credential_info})\n            else:\n                parsed_tuPAC.append({'Credential Info': parsed_credential_info})\n                newCipher = _enctype_table[credinfo_enctype]\n                key = Key(credinfo_enctype, unhexlify(args.asrep_key))\n                plain_credential_data = newCipher.decrypt(key, 16, credential_info.fields['SerializedData'])\n                type1 = TypeSerialization1(plain_credential_data)\n                newdata = plain_credential_data[len(type1) + 4:]\n                credential_data = pac.PAC_CREDENTIAL_DATA(newdata)\n                parsed_credential_data = {}\n                parsed_credential_data['  Credential Count'] = credential_data['CredentialCount']\n                parsed_tuPAC.append({'  Credential Data': parsed_credential_data})\n                for credential in credential_data['Credentials']:\n                    parsed_secpkg_supplemental_cred = {}\n                    parsed_secpkg_supplemental_cred['      Package Name'] = credential['PackageName']\n                    parsed_secpkg_supplemental_cred['      Credential Size'] = credential['CredentialSize']\n                    parsed_tuPAC.append({'      SecPkg Credentials': parsed_secpkg_supplemental_cred})\n                    ntlm_supplemental_cred = pac.NTLM_SUPPLEMENTAL_CREDENTIAL(b''.join(credential['Credentials']))\n                    parsed_ntlm_supplemental_cred = {}\n                    parsed_ntlm_supplemental_cred['        Version'] = ntlm_supplemental_cred['Version']\n                    parsed_ntlm_supplemental_cred['        Flags'] = ntlm_supplemental_cred['Flags']\n                    parsed_ntlm_supplemental_cred['        LmPasword'] = hexlify(ntlm_supplemental_cred['LmPassword']).decode('utf-8')\n                    parsed_ntlm_supplemental_cred['        NtPasword'] = hexlify(ntlm_supplemental_cred['NtPassword']).decode('utf-8')\n                    parsed_tuPAC.append({'        NTLM Credentials': parsed_ntlm_supplemental_cred})\n        elif infoBuffer['ulType'] == pac.PAC_DELEGATION_INFO:\n            delegationInfo = pac.S4U_DELEGATION_INFO(data)\n            parsed_data = {}\n            parsed_data['S4U2proxyTarget'] = delegationInfo['S4U2proxyTarget']\n            parsed_data['TransitedListSize'] = delegationInfo.fields['TransitedListSize'].fields['Data']\n            parsed_data['S4UTransitedServices'] = delegationInfo['S4UTransitedServices'].decode('utf-8')\n            parsed_tuPAC.append({'DelegationInfo': parsed_data})\n        elif infoBuffer['ulType'] == pac.PAC_ATTRIBUTES_INFO:\n            attributeInfo = pac.PAC_ATTRIBUTE_INFO(data)\n            flags = attributeInfo['Flags']\n            attr_flags = []\n            for flag_lib in Attributes_Flags:\n                if flags & flag_lib.value:\n                    attr_flags.append(flag_lib.name)\n            parsed_data = {'Flags': f\"({flags}) {', '.join(attr_flags)}\"}\n            parsed_tuPAC.append({'Attributes Info': parsed_data})\n        elif infoBuffer['ulType'] == pac.PAC_REQUESTOR_INFO:\n            requestorInfo = pac.PAC_REQUESTOR(data)\n            parsed_data = {'UserSid': requestorInfo['UserSid'].formatCanonical()}\n            parsed_tuPAC.append({'Requestor Info': parsed_data})\n        else:\n            logging.debug('Unsupported PAC structure: %s. Please raise an issue or PR' % infoBuffer['ulType'])\n        buff = buff[len(infoBuffer):]\n    return parsed_tuPAC",
            "def parse_pac(pacType, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    def PACparseFILETIME(data):\n        dwLowDateTime = data['dwLowDateTime']\n        dwHighDateTime = data['dwHighDateTime']\n        v_FILETIME = 'Infinity (absolute time)'\n        if dwLowDateTime != 4294967295 and dwHighDateTime != 2147483647:\n            temp_time = dwHighDateTime\n            temp_time <<= 32\n            temp_time |= dwLowDateTime\n            if datetime.timedelta(microseconds=temp_time / 10).total_seconds() != 0:\n                v_FILETIME = (datetime.datetime(1601, 1, 1, 0, 0, 0) + datetime.timedelta(microseconds=temp_time / 10)).strftime('%d/%m/%Y %H:%M:%S %p')\n        return v_FILETIME\n\n    def PACparseGroupIds(data):\n        groups = []\n        for group in data:\n            groupMembership = {}\n            groupMembership['RelativeId'] = group['RelativeId']\n            groupMembership['Attributes'] = group['Attributes']\n            groups.append(groupMembership)\n        return groups\n    parsed_tuPAC = []\n    buff = pacType['Buffers']\n    for bufferN in range(pacType['cBuffers']):\n        infoBuffer = pac.PAC_INFO_BUFFER(buff)\n        data = pacType['Buffers'][infoBuffer['Offset'] - 8:][:infoBuffer['cbBufferSize']]\n        if infoBuffer['ulType'] == pac.PAC_LOGON_INFO:\n            type1 = TypeSerialization1(data)\n            newdata = data[len(type1) + 4:]\n            kerbdata = pac.KERB_VALIDATION_INFO()\n            kerbdata.fromString(newdata)\n            kerbdata.fromStringReferents(newdata[len(kerbdata.getData()):])\n            parsed_data = {}\n            parsed_data['Logon Time'] = PACparseFILETIME(kerbdata['LogonTime'])\n            parsed_data['Logoff Time'] = PACparseFILETIME(kerbdata['LogoffTime'])\n            parsed_data['Kickoff Time'] = PACparseFILETIME(kerbdata['KickOffTime'])\n            parsed_data['Password Last Set'] = PACparseFILETIME(kerbdata['PasswordLastSet'])\n            parsed_data['Password Can Change'] = PACparseFILETIME(kerbdata['PasswordCanChange'])\n            parsed_data['Password Must Change'] = PACparseFILETIME(kerbdata['PasswordMustChange'])\n            parsed_data['LastSuccessfulILogon'] = PACparseFILETIME(kerbdata['LastSuccessfulILogon'])\n            parsed_data['LastFailedILogon'] = PACparseFILETIME(kerbdata['LastFailedILogon'])\n            parsed_data['FailedILogonCount'] = kerbdata['FailedILogonCount']\n            parsed_data['Account Name'] = kerbdata['EffectiveName']\n            parsed_data['Full Name'] = kerbdata['FullName']\n            parsed_data['Logon Script'] = kerbdata['LogonScript']\n            parsed_data['Profile Path'] = kerbdata['ProfilePath']\n            parsed_data['Home Dir'] = kerbdata['HomeDirectory']\n            parsed_data['Dir Drive'] = kerbdata['HomeDirectoryDrive']\n            parsed_data['Logon Count'] = kerbdata['LogonCount']\n            parsed_data['Bad Password Count'] = kerbdata['BadPasswordCount']\n            parsed_data['User RID'] = kerbdata['UserId']\n            parsed_data['Group RID'] = kerbdata['PrimaryGroupId']\n            parsed_data['Group Count'] = kerbdata['GroupCount']\n            all_groups_id = [str(gid['RelativeId']) for gid in PACparseGroupIds(kerbdata['GroupIds'])]\n            parsed_data['Groups'] = ', '.join(all_groups_id)\n            groups = []\n            unknown_count = 0\n            for gid in all_groups_id:\n                group_name = MsBuiltInGroups.get(gid)\n                if group_name:\n                    groups.append(f'({gid}) {group_name}')\n                else:\n                    unknown_count += 1\n            if unknown_count > 0:\n                groups.append(f\"+{unknown_count} Unknown custom group{('s' if unknown_count > 1 else '')}\")\n            parsed_data['Groups (decoded)'] = groups\n            UserFlags = kerbdata['UserFlags']\n            User_Flags_Flags = []\n            for flag in User_Flags:\n                if UserFlags & flag.value:\n                    User_Flags_Flags.append(flag.name)\n            parsed_data['User Flags'] = '(%s) %s' % (UserFlags, ', '.join(User_Flags_Flags))\n            parsed_data['User Session Key'] = hexlify(kerbdata['UserSessionKey']).decode('utf-8')\n            parsed_data['Logon Server'] = kerbdata['LogonServer']\n            parsed_data['Logon Domain Name'] = kerbdata['LogonDomainName']\n            if kerbdata['LogonDomainId'] == b'':\n                parsed_data['Logon Domain SID'] = kerbdata['LogonDomainId']\n            else:\n                parsed_data['Logon Domain SID'] = kerbdata['LogonDomainId'].formatCanonical()\n            UAC = kerbdata['UserAccountControl']\n            UAC_Flags = []\n            for flag in USER_ACCOUNT_Codes:\n                if UAC & flag.value:\n                    UAC_Flags.append(flag.name)\n            parsed_data['User Account Control'] = '(%s) %s' % (UAC, ', '.join(UAC_Flags))\n            parsed_data['Extra SID Count'] = kerbdata['SidCount']\n            extraSids = []\n            for extraSid in kerbdata['ExtraSids']:\n                sid = extraSid['Sid'].formatCanonical()\n                attributes = extraSid['Attributes']\n                attributes_flags = []\n                for flag in SE_GROUP_Attributes:\n                    if attributes & flag.value:\n                        attributes_flags.append(flag.name)\n                group_name = MsBuiltInGroups.get(sid, '')\n                if not group_name and len(sid.split('-')) == 8:\n                    group_name = MsBuiltInGroups.get(sid.split('-')[-1], '')\n                if group_name:\n                    group_name = f' {group_name}'\n                extraSids.append('%s%s (%s)' % (sid, group_name, ', '.join(attributes_flags)))\n            parsed_data['Extra SIDs'] = extraSids\n            if kerbdata['ResourceGroupDomainSid'] == b'':\n                parsed_data['Resource Group Domain SID'] = kerbdata['ResourceGroupDomainSid']\n            else:\n                parsed_data['Resource Group Domain SID'] = kerbdata['ResourceGroupDomainSid'].formatCanonical()\n            parsed_data['Resource Group Count'] = kerbdata['ResourceGroupCount']\n            parsed_data['Resource Group Ids'] = ', '.join([str(gid['RelativeId']) for gid in PACparseGroupIds(kerbdata['ResourceGroupIds'])])\n            parsed_data['LMKey'] = hexlify(kerbdata['LMKey']).decode('utf-8')\n            parsed_data['SubAuthStatus'] = kerbdata['SubAuthStatus']\n            parsed_data['Reserved3'] = kerbdata['Reserved3']\n            parsed_tuPAC.append({'LoginInfo': parsed_data})\n        elif infoBuffer['ulType'] == pac.PAC_CLIENT_INFO_TYPE:\n            clientInfo = pac.PAC_CLIENT_INFO()\n            clientInfo.fromString(data)\n            parsed_data = {}\n            try:\n                parsed_data['Client Id'] = PACparseFILETIME(clientInfo['ClientId'])\n            except:\n                try:\n                    parsed_data['Client Id'] = PACparseFILETIME(FILETIME(data[:32]))\n                except Exception as e:\n                    logging.error(e)\n            parsed_data['Client Name'] = clientInfo['Name'].decode('utf-16-le')\n            parsed_tuPAC.append({'ClientName': parsed_data})\n        elif infoBuffer['ulType'] == pac.PAC_UPN_DNS_INFO:\n            upn = pac.UPN_DNS_INFO(data)\n            UpnLength = upn['UpnLength']\n            UpnOffset = upn['UpnOffset']\n            UpnName = data[UpnOffset:UpnOffset + UpnLength].decode('utf-16-le')\n            DnsDomainNameLength = upn['DnsDomainNameLength']\n            DnsDomainNameOffset = upn['DnsDomainNameOffset']\n            DnsName = data[DnsDomainNameOffset:DnsDomainNameOffset + DnsDomainNameLength].decode('utf-16-le')\n            flags = upn['Flags']\n            attr_flags = []\n            for flag_lib in Upn_Dns_Flags:\n                if flags & flag_lib.value:\n                    attr_flags.append(flag_lib.name)\n            parsed_data = {}\n            parsed_data['Flags'] = f\"({flags}) {', '.join(attr_flags)}\"\n            parsed_data['UPN'] = UpnName\n            parsed_data['DNS Domain Name'] = DnsName\n            if Upn_Dns_Flags.S_SidSamSupplied.name in attr_flags:\n                upn = pac.UPN_DNS_INFO_FULL(data)\n                SamNameLength = upn['SamNameLength']\n                SamNameOffset = upn['SamNameOffset']\n                SamName = data[SamNameOffset:SamNameOffset + SamNameLength].decode('utf-16-le')\n                SidLength = upn['SidLength']\n                SidOffset = upn['SidOffset']\n                Sid = LDAP_SID(data[SidOffset:SidOffset + SidLength])\n                parsed_data['SamAccountName'] = SamName\n                parsed_data['UserSid'] = Sid.formatCanonical()\n            parsed_tuPAC.append({'UpnDns': parsed_data})\n        elif infoBuffer['ulType'] == pac.PAC_SERVER_CHECKSUM:\n            signatureData = pac.PAC_SIGNATURE_DATA(data)\n            parsed_data = {}\n            parsed_data['Signature Type'] = ChecksumTypes(signatureData['SignatureType']).name\n            parsed_data['Signature'] = hexlify(signatureData['Signature']).decode('utf-8')\n            parsed_tuPAC.append({'ServerChecksum': parsed_data})\n        elif infoBuffer['ulType'] == pac.PAC_PRIVSVR_CHECKSUM:\n            signatureData = pac.PAC_SIGNATURE_DATA(data)\n            parsed_data = {}\n            parsed_data['Signature Type'] = ChecksumTypes(signatureData['SignatureType']).name\n            parsed_data['Signature'] = hexlify(signatureData['Signature']).decode('utf-8')\n            parsed_tuPAC.append({'KDCChecksum': parsed_data})\n        elif infoBuffer['ulType'] == pac.PAC_CREDENTIALS_INFO:\n            credential_info = pac.PAC_CREDENTIAL_INFO(data)\n            parsed_credential_info = {}\n            parsed_credential_info['Version'] = '(0x%x) %d' % (credential_info.fields['Version'], credential_info.fields['Version'])\n            credinfo_enctype = credential_info.fields['EncryptionType']\n            parsed_credential_info['Encryption Type'] = '(0x%x) %s' % (credinfo_enctype, constants.EncryptionTypes(credential_info.fields['EncryptionType']).name)\n            if not args.asrep_key:\n                parsed_credential_info['Encryption Type'] = '<Cannot decrypt, --asrep-key missing>'\n                logging.error('No ASREP key supplied, cannot decrypt PAC Credentials')\n                parsed_tuPAC.append({'Credential Info': parsed_credential_info})\n            else:\n                parsed_tuPAC.append({'Credential Info': parsed_credential_info})\n                newCipher = _enctype_table[credinfo_enctype]\n                key = Key(credinfo_enctype, unhexlify(args.asrep_key))\n                plain_credential_data = newCipher.decrypt(key, 16, credential_info.fields['SerializedData'])\n                type1 = TypeSerialization1(plain_credential_data)\n                newdata = plain_credential_data[len(type1) + 4:]\n                credential_data = pac.PAC_CREDENTIAL_DATA(newdata)\n                parsed_credential_data = {}\n                parsed_credential_data['  Credential Count'] = credential_data['CredentialCount']\n                parsed_tuPAC.append({'  Credential Data': parsed_credential_data})\n                for credential in credential_data['Credentials']:\n                    parsed_secpkg_supplemental_cred = {}\n                    parsed_secpkg_supplemental_cred['      Package Name'] = credential['PackageName']\n                    parsed_secpkg_supplemental_cred['      Credential Size'] = credential['CredentialSize']\n                    parsed_tuPAC.append({'      SecPkg Credentials': parsed_secpkg_supplemental_cred})\n                    ntlm_supplemental_cred = pac.NTLM_SUPPLEMENTAL_CREDENTIAL(b''.join(credential['Credentials']))\n                    parsed_ntlm_supplemental_cred = {}\n                    parsed_ntlm_supplemental_cred['        Version'] = ntlm_supplemental_cred['Version']\n                    parsed_ntlm_supplemental_cred['        Flags'] = ntlm_supplemental_cred['Flags']\n                    parsed_ntlm_supplemental_cred['        LmPasword'] = hexlify(ntlm_supplemental_cred['LmPassword']).decode('utf-8')\n                    parsed_ntlm_supplemental_cred['        NtPasword'] = hexlify(ntlm_supplemental_cred['NtPassword']).decode('utf-8')\n                    parsed_tuPAC.append({'        NTLM Credentials': parsed_ntlm_supplemental_cred})\n        elif infoBuffer['ulType'] == pac.PAC_DELEGATION_INFO:\n            delegationInfo = pac.S4U_DELEGATION_INFO(data)\n            parsed_data = {}\n            parsed_data['S4U2proxyTarget'] = delegationInfo['S4U2proxyTarget']\n            parsed_data['TransitedListSize'] = delegationInfo.fields['TransitedListSize'].fields['Data']\n            parsed_data['S4UTransitedServices'] = delegationInfo['S4UTransitedServices'].decode('utf-8')\n            parsed_tuPAC.append({'DelegationInfo': parsed_data})\n        elif infoBuffer['ulType'] == pac.PAC_ATTRIBUTES_INFO:\n            attributeInfo = pac.PAC_ATTRIBUTE_INFO(data)\n            flags = attributeInfo['Flags']\n            attr_flags = []\n            for flag_lib in Attributes_Flags:\n                if flags & flag_lib.value:\n                    attr_flags.append(flag_lib.name)\n            parsed_data = {'Flags': f\"({flags}) {', '.join(attr_flags)}\"}\n            parsed_tuPAC.append({'Attributes Info': parsed_data})\n        elif infoBuffer['ulType'] == pac.PAC_REQUESTOR_INFO:\n            requestorInfo = pac.PAC_REQUESTOR(data)\n            parsed_data = {'UserSid': requestorInfo['UserSid'].formatCanonical()}\n            parsed_tuPAC.append({'Requestor Info': parsed_data})\n        else:\n            logging.debug('Unsupported PAC structure: %s. Please raise an issue or PR' % infoBuffer['ulType'])\n        buff = buff[len(infoBuffer):]\n    return parsed_tuPAC",
            "def parse_pac(pacType, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    def PACparseFILETIME(data):\n        dwLowDateTime = data['dwLowDateTime']\n        dwHighDateTime = data['dwHighDateTime']\n        v_FILETIME = 'Infinity (absolute time)'\n        if dwLowDateTime != 4294967295 and dwHighDateTime != 2147483647:\n            temp_time = dwHighDateTime\n            temp_time <<= 32\n            temp_time |= dwLowDateTime\n            if datetime.timedelta(microseconds=temp_time / 10).total_seconds() != 0:\n                v_FILETIME = (datetime.datetime(1601, 1, 1, 0, 0, 0) + datetime.timedelta(microseconds=temp_time / 10)).strftime('%d/%m/%Y %H:%M:%S %p')\n        return v_FILETIME\n\n    def PACparseGroupIds(data):\n        groups = []\n        for group in data:\n            groupMembership = {}\n            groupMembership['RelativeId'] = group['RelativeId']\n            groupMembership['Attributes'] = group['Attributes']\n            groups.append(groupMembership)\n        return groups\n    parsed_tuPAC = []\n    buff = pacType['Buffers']\n    for bufferN in range(pacType['cBuffers']):\n        infoBuffer = pac.PAC_INFO_BUFFER(buff)\n        data = pacType['Buffers'][infoBuffer['Offset'] - 8:][:infoBuffer['cbBufferSize']]\n        if infoBuffer['ulType'] == pac.PAC_LOGON_INFO:\n            type1 = TypeSerialization1(data)\n            newdata = data[len(type1) + 4:]\n            kerbdata = pac.KERB_VALIDATION_INFO()\n            kerbdata.fromString(newdata)\n            kerbdata.fromStringReferents(newdata[len(kerbdata.getData()):])\n            parsed_data = {}\n            parsed_data['Logon Time'] = PACparseFILETIME(kerbdata['LogonTime'])\n            parsed_data['Logoff Time'] = PACparseFILETIME(kerbdata['LogoffTime'])\n            parsed_data['Kickoff Time'] = PACparseFILETIME(kerbdata['KickOffTime'])\n            parsed_data['Password Last Set'] = PACparseFILETIME(kerbdata['PasswordLastSet'])\n            parsed_data['Password Can Change'] = PACparseFILETIME(kerbdata['PasswordCanChange'])\n            parsed_data['Password Must Change'] = PACparseFILETIME(kerbdata['PasswordMustChange'])\n            parsed_data['LastSuccessfulILogon'] = PACparseFILETIME(kerbdata['LastSuccessfulILogon'])\n            parsed_data['LastFailedILogon'] = PACparseFILETIME(kerbdata['LastFailedILogon'])\n            parsed_data['FailedILogonCount'] = kerbdata['FailedILogonCount']\n            parsed_data['Account Name'] = kerbdata['EffectiveName']\n            parsed_data['Full Name'] = kerbdata['FullName']\n            parsed_data['Logon Script'] = kerbdata['LogonScript']\n            parsed_data['Profile Path'] = kerbdata['ProfilePath']\n            parsed_data['Home Dir'] = kerbdata['HomeDirectory']\n            parsed_data['Dir Drive'] = kerbdata['HomeDirectoryDrive']\n            parsed_data['Logon Count'] = kerbdata['LogonCount']\n            parsed_data['Bad Password Count'] = kerbdata['BadPasswordCount']\n            parsed_data['User RID'] = kerbdata['UserId']\n            parsed_data['Group RID'] = kerbdata['PrimaryGroupId']\n            parsed_data['Group Count'] = kerbdata['GroupCount']\n            all_groups_id = [str(gid['RelativeId']) for gid in PACparseGroupIds(kerbdata['GroupIds'])]\n            parsed_data['Groups'] = ', '.join(all_groups_id)\n            groups = []\n            unknown_count = 0\n            for gid in all_groups_id:\n                group_name = MsBuiltInGroups.get(gid)\n                if group_name:\n                    groups.append(f'({gid}) {group_name}')\n                else:\n                    unknown_count += 1\n            if unknown_count > 0:\n                groups.append(f\"+{unknown_count} Unknown custom group{('s' if unknown_count > 1 else '')}\")\n            parsed_data['Groups (decoded)'] = groups\n            UserFlags = kerbdata['UserFlags']\n            User_Flags_Flags = []\n            for flag in User_Flags:\n                if UserFlags & flag.value:\n                    User_Flags_Flags.append(flag.name)\n            parsed_data['User Flags'] = '(%s) %s' % (UserFlags, ', '.join(User_Flags_Flags))\n            parsed_data['User Session Key'] = hexlify(kerbdata['UserSessionKey']).decode('utf-8')\n            parsed_data['Logon Server'] = kerbdata['LogonServer']\n            parsed_data['Logon Domain Name'] = kerbdata['LogonDomainName']\n            if kerbdata['LogonDomainId'] == b'':\n                parsed_data['Logon Domain SID'] = kerbdata['LogonDomainId']\n            else:\n                parsed_data['Logon Domain SID'] = kerbdata['LogonDomainId'].formatCanonical()\n            UAC = kerbdata['UserAccountControl']\n            UAC_Flags = []\n            for flag in USER_ACCOUNT_Codes:\n                if UAC & flag.value:\n                    UAC_Flags.append(flag.name)\n            parsed_data['User Account Control'] = '(%s) %s' % (UAC, ', '.join(UAC_Flags))\n            parsed_data['Extra SID Count'] = kerbdata['SidCount']\n            extraSids = []\n            for extraSid in kerbdata['ExtraSids']:\n                sid = extraSid['Sid'].formatCanonical()\n                attributes = extraSid['Attributes']\n                attributes_flags = []\n                for flag in SE_GROUP_Attributes:\n                    if attributes & flag.value:\n                        attributes_flags.append(flag.name)\n                group_name = MsBuiltInGroups.get(sid, '')\n                if not group_name and len(sid.split('-')) == 8:\n                    group_name = MsBuiltInGroups.get(sid.split('-')[-1], '')\n                if group_name:\n                    group_name = f' {group_name}'\n                extraSids.append('%s%s (%s)' % (sid, group_name, ', '.join(attributes_flags)))\n            parsed_data['Extra SIDs'] = extraSids\n            if kerbdata['ResourceGroupDomainSid'] == b'':\n                parsed_data['Resource Group Domain SID'] = kerbdata['ResourceGroupDomainSid']\n            else:\n                parsed_data['Resource Group Domain SID'] = kerbdata['ResourceGroupDomainSid'].formatCanonical()\n            parsed_data['Resource Group Count'] = kerbdata['ResourceGroupCount']\n            parsed_data['Resource Group Ids'] = ', '.join([str(gid['RelativeId']) for gid in PACparseGroupIds(kerbdata['ResourceGroupIds'])])\n            parsed_data['LMKey'] = hexlify(kerbdata['LMKey']).decode('utf-8')\n            parsed_data['SubAuthStatus'] = kerbdata['SubAuthStatus']\n            parsed_data['Reserved3'] = kerbdata['Reserved3']\n            parsed_tuPAC.append({'LoginInfo': parsed_data})\n        elif infoBuffer['ulType'] == pac.PAC_CLIENT_INFO_TYPE:\n            clientInfo = pac.PAC_CLIENT_INFO()\n            clientInfo.fromString(data)\n            parsed_data = {}\n            try:\n                parsed_data['Client Id'] = PACparseFILETIME(clientInfo['ClientId'])\n            except:\n                try:\n                    parsed_data['Client Id'] = PACparseFILETIME(FILETIME(data[:32]))\n                except Exception as e:\n                    logging.error(e)\n            parsed_data['Client Name'] = clientInfo['Name'].decode('utf-16-le')\n            parsed_tuPAC.append({'ClientName': parsed_data})\n        elif infoBuffer['ulType'] == pac.PAC_UPN_DNS_INFO:\n            upn = pac.UPN_DNS_INFO(data)\n            UpnLength = upn['UpnLength']\n            UpnOffset = upn['UpnOffset']\n            UpnName = data[UpnOffset:UpnOffset + UpnLength].decode('utf-16-le')\n            DnsDomainNameLength = upn['DnsDomainNameLength']\n            DnsDomainNameOffset = upn['DnsDomainNameOffset']\n            DnsName = data[DnsDomainNameOffset:DnsDomainNameOffset + DnsDomainNameLength].decode('utf-16-le')\n            flags = upn['Flags']\n            attr_flags = []\n            for flag_lib in Upn_Dns_Flags:\n                if flags & flag_lib.value:\n                    attr_flags.append(flag_lib.name)\n            parsed_data = {}\n            parsed_data['Flags'] = f\"({flags}) {', '.join(attr_flags)}\"\n            parsed_data['UPN'] = UpnName\n            parsed_data['DNS Domain Name'] = DnsName\n            if Upn_Dns_Flags.S_SidSamSupplied.name in attr_flags:\n                upn = pac.UPN_DNS_INFO_FULL(data)\n                SamNameLength = upn['SamNameLength']\n                SamNameOffset = upn['SamNameOffset']\n                SamName = data[SamNameOffset:SamNameOffset + SamNameLength].decode('utf-16-le')\n                SidLength = upn['SidLength']\n                SidOffset = upn['SidOffset']\n                Sid = LDAP_SID(data[SidOffset:SidOffset + SidLength])\n                parsed_data['SamAccountName'] = SamName\n                parsed_data['UserSid'] = Sid.formatCanonical()\n            parsed_tuPAC.append({'UpnDns': parsed_data})\n        elif infoBuffer['ulType'] == pac.PAC_SERVER_CHECKSUM:\n            signatureData = pac.PAC_SIGNATURE_DATA(data)\n            parsed_data = {}\n            parsed_data['Signature Type'] = ChecksumTypes(signatureData['SignatureType']).name\n            parsed_data['Signature'] = hexlify(signatureData['Signature']).decode('utf-8')\n            parsed_tuPAC.append({'ServerChecksum': parsed_data})\n        elif infoBuffer['ulType'] == pac.PAC_PRIVSVR_CHECKSUM:\n            signatureData = pac.PAC_SIGNATURE_DATA(data)\n            parsed_data = {}\n            parsed_data['Signature Type'] = ChecksumTypes(signatureData['SignatureType']).name\n            parsed_data['Signature'] = hexlify(signatureData['Signature']).decode('utf-8')\n            parsed_tuPAC.append({'KDCChecksum': parsed_data})\n        elif infoBuffer['ulType'] == pac.PAC_CREDENTIALS_INFO:\n            credential_info = pac.PAC_CREDENTIAL_INFO(data)\n            parsed_credential_info = {}\n            parsed_credential_info['Version'] = '(0x%x) %d' % (credential_info.fields['Version'], credential_info.fields['Version'])\n            credinfo_enctype = credential_info.fields['EncryptionType']\n            parsed_credential_info['Encryption Type'] = '(0x%x) %s' % (credinfo_enctype, constants.EncryptionTypes(credential_info.fields['EncryptionType']).name)\n            if not args.asrep_key:\n                parsed_credential_info['Encryption Type'] = '<Cannot decrypt, --asrep-key missing>'\n                logging.error('No ASREP key supplied, cannot decrypt PAC Credentials')\n                parsed_tuPAC.append({'Credential Info': parsed_credential_info})\n            else:\n                parsed_tuPAC.append({'Credential Info': parsed_credential_info})\n                newCipher = _enctype_table[credinfo_enctype]\n                key = Key(credinfo_enctype, unhexlify(args.asrep_key))\n                plain_credential_data = newCipher.decrypt(key, 16, credential_info.fields['SerializedData'])\n                type1 = TypeSerialization1(plain_credential_data)\n                newdata = plain_credential_data[len(type1) + 4:]\n                credential_data = pac.PAC_CREDENTIAL_DATA(newdata)\n                parsed_credential_data = {}\n                parsed_credential_data['  Credential Count'] = credential_data['CredentialCount']\n                parsed_tuPAC.append({'  Credential Data': parsed_credential_data})\n                for credential in credential_data['Credentials']:\n                    parsed_secpkg_supplemental_cred = {}\n                    parsed_secpkg_supplemental_cred['      Package Name'] = credential['PackageName']\n                    parsed_secpkg_supplemental_cred['      Credential Size'] = credential['CredentialSize']\n                    parsed_tuPAC.append({'      SecPkg Credentials': parsed_secpkg_supplemental_cred})\n                    ntlm_supplemental_cred = pac.NTLM_SUPPLEMENTAL_CREDENTIAL(b''.join(credential['Credentials']))\n                    parsed_ntlm_supplemental_cred = {}\n                    parsed_ntlm_supplemental_cred['        Version'] = ntlm_supplemental_cred['Version']\n                    parsed_ntlm_supplemental_cred['        Flags'] = ntlm_supplemental_cred['Flags']\n                    parsed_ntlm_supplemental_cred['        LmPasword'] = hexlify(ntlm_supplemental_cred['LmPassword']).decode('utf-8')\n                    parsed_ntlm_supplemental_cred['        NtPasword'] = hexlify(ntlm_supplemental_cred['NtPassword']).decode('utf-8')\n                    parsed_tuPAC.append({'        NTLM Credentials': parsed_ntlm_supplemental_cred})\n        elif infoBuffer['ulType'] == pac.PAC_DELEGATION_INFO:\n            delegationInfo = pac.S4U_DELEGATION_INFO(data)\n            parsed_data = {}\n            parsed_data['S4U2proxyTarget'] = delegationInfo['S4U2proxyTarget']\n            parsed_data['TransitedListSize'] = delegationInfo.fields['TransitedListSize'].fields['Data']\n            parsed_data['S4UTransitedServices'] = delegationInfo['S4UTransitedServices'].decode('utf-8')\n            parsed_tuPAC.append({'DelegationInfo': parsed_data})\n        elif infoBuffer['ulType'] == pac.PAC_ATTRIBUTES_INFO:\n            attributeInfo = pac.PAC_ATTRIBUTE_INFO(data)\n            flags = attributeInfo['Flags']\n            attr_flags = []\n            for flag_lib in Attributes_Flags:\n                if flags & flag_lib.value:\n                    attr_flags.append(flag_lib.name)\n            parsed_data = {'Flags': f\"({flags}) {', '.join(attr_flags)}\"}\n            parsed_tuPAC.append({'Attributes Info': parsed_data})\n        elif infoBuffer['ulType'] == pac.PAC_REQUESTOR_INFO:\n            requestorInfo = pac.PAC_REQUESTOR(data)\n            parsed_data = {'UserSid': requestorInfo['UserSid'].formatCanonical()}\n            parsed_tuPAC.append({'Requestor Info': parsed_data})\n        else:\n            logging.debug('Unsupported PAC structure: %s. Please raise an issue or PR' % infoBuffer['ulType'])\n        buff = buff[len(infoBuffer):]\n    return parsed_tuPAC",
            "def parse_pac(pacType, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    def PACparseFILETIME(data):\n        dwLowDateTime = data['dwLowDateTime']\n        dwHighDateTime = data['dwHighDateTime']\n        v_FILETIME = 'Infinity (absolute time)'\n        if dwLowDateTime != 4294967295 and dwHighDateTime != 2147483647:\n            temp_time = dwHighDateTime\n            temp_time <<= 32\n            temp_time |= dwLowDateTime\n            if datetime.timedelta(microseconds=temp_time / 10).total_seconds() != 0:\n                v_FILETIME = (datetime.datetime(1601, 1, 1, 0, 0, 0) + datetime.timedelta(microseconds=temp_time / 10)).strftime('%d/%m/%Y %H:%M:%S %p')\n        return v_FILETIME\n\n    def PACparseGroupIds(data):\n        groups = []\n        for group in data:\n            groupMembership = {}\n            groupMembership['RelativeId'] = group['RelativeId']\n            groupMembership['Attributes'] = group['Attributes']\n            groups.append(groupMembership)\n        return groups\n    parsed_tuPAC = []\n    buff = pacType['Buffers']\n    for bufferN in range(pacType['cBuffers']):\n        infoBuffer = pac.PAC_INFO_BUFFER(buff)\n        data = pacType['Buffers'][infoBuffer['Offset'] - 8:][:infoBuffer['cbBufferSize']]\n        if infoBuffer['ulType'] == pac.PAC_LOGON_INFO:\n            type1 = TypeSerialization1(data)\n            newdata = data[len(type1) + 4:]\n            kerbdata = pac.KERB_VALIDATION_INFO()\n            kerbdata.fromString(newdata)\n            kerbdata.fromStringReferents(newdata[len(kerbdata.getData()):])\n            parsed_data = {}\n            parsed_data['Logon Time'] = PACparseFILETIME(kerbdata['LogonTime'])\n            parsed_data['Logoff Time'] = PACparseFILETIME(kerbdata['LogoffTime'])\n            parsed_data['Kickoff Time'] = PACparseFILETIME(kerbdata['KickOffTime'])\n            parsed_data['Password Last Set'] = PACparseFILETIME(kerbdata['PasswordLastSet'])\n            parsed_data['Password Can Change'] = PACparseFILETIME(kerbdata['PasswordCanChange'])\n            parsed_data['Password Must Change'] = PACparseFILETIME(kerbdata['PasswordMustChange'])\n            parsed_data['LastSuccessfulILogon'] = PACparseFILETIME(kerbdata['LastSuccessfulILogon'])\n            parsed_data['LastFailedILogon'] = PACparseFILETIME(kerbdata['LastFailedILogon'])\n            parsed_data['FailedILogonCount'] = kerbdata['FailedILogonCount']\n            parsed_data['Account Name'] = kerbdata['EffectiveName']\n            parsed_data['Full Name'] = kerbdata['FullName']\n            parsed_data['Logon Script'] = kerbdata['LogonScript']\n            parsed_data['Profile Path'] = kerbdata['ProfilePath']\n            parsed_data['Home Dir'] = kerbdata['HomeDirectory']\n            parsed_data['Dir Drive'] = kerbdata['HomeDirectoryDrive']\n            parsed_data['Logon Count'] = kerbdata['LogonCount']\n            parsed_data['Bad Password Count'] = kerbdata['BadPasswordCount']\n            parsed_data['User RID'] = kerbdata['UserId']\n            parsed_data['Group RID'] = kerbdata['PrimaryGroupId']\n            parsed_data['Group Count'] = kerbdata['GroupCount']\n            all_groups_id = [str(gid['RelativeId']) for gid in PACparseGroupIds(kerbdata['GroupIds'])]\n            parsed_data['Groups'] = ', '.join(all_groups_id)\n            groups = []\n            unknown_count = 0\n            for gid in all_groups_id:\n                group_name = MsBuiltInGroups.get(gid)\n                if group_name:\n                    groups.append(f'({gid}) {group_name}')\n                else:\n                    unknown_count += 1\n            if unknown_count > 0:\n                groups.append(f\"+{unknown_count} Unknown custom group{('s' if unknown_count > 1 else '')}\")\n            parsed_data['Groups (decoded)'] = groups\n            UserFlags = kerbdata['UserFlags']\n            User_Flags_Flags = []\n            for flag in User_Flags:\n                if UserFlags & flag.value:\n                    User_Flags_Flags.append(flag.name)\n            parsed_data['User Flags'] = '(%s) %s' % (UserFlags, ', '.join(User_Flags_Flags))\n            parsed_data['User Session Key'] = hexlify(kerbdata['UserSessionKey']).decode('utf-8')\n            parsed_data['Logon Server'] = kerbdata['LogonServer']\n            parsed_data['Logon Domain Name'] = kerbdata['LogonDomainName']\n            if kerbdata['LogonDomainId'] == b'':\n                parsed_data['Logon Domain SID'] = kerbdata['LogonDomainId']\n            else:\n                parsed_data['Logon Domain SID'] = kerbdata['LogonDomainId'].formatCanonical()\n            UAC = kerbdata['UserAccountControl']\n            UAC_Flags = []\n            for flag in USER_ACCOUNT_Codes:\n                if UAC & flag.value:\n                    UAC_Flags.append(flag.name)\n            parsed_data['User Account Control'] = '(%s) %s' % (UAC, ', '.join(UAC_Flags))\n            parsed_data['Extra SID Count'] = kerbdata['SidCount']\n            extraSids = []\n            for extraSid in kerbdata['ExtraSids']:\n                sid = extraSid['Sid'].formatCanonical()\n                attributes = extraSid['Attributes']\n                attributes_flags = []\n                for flag in SE_GROUP_Attributes:\n                    if attributes & flag.value:\n                        attributes_flags.append(flag.name)\n                group_name = MsBuiltInGroups.get(sid, '')\n                if not group_name and len(sid.split('-')) == 8:\n                    group_name = MsBuiltInGroups.get(sid.split('-')[-1], '')\n                if group_name:\n                    group_name = f' {group_name}'\n                extraSids.append('%s%s (%s)' % (sid, group_name, ', '.join(attributes_flags)))\n            parsed_data['Extra SIDs'] = extraSids\n            if kerbdata['ResourceGroupDomainSid'] == b'':\n                parsed_data['Resource Group Domain SID'] = kerbdata['ResourceGroupDomainSid']\n            else:\n                parsed_data['Resource Group Domain SID'] = kerbdata['ResourceGroupDomainSid'].formatCanonical()\n            parsed_data['Resource Group Count'] = kerbdata['ResourceGroupCount']\n            parsed_data['Resource Group Ids'] = ', '.join([str(gid['RelativeId']) for gid in PACparseGroupIds(kerbdata['ResourceGroupIds'])])\n            parsed_data['LMKey'] = hexlify(kerbdata['LMKey']).decode('utf-8')\n            parsed_data['SubAuthStatus'] = kerbdata['SubAuthStatus']\n            parsed_data['Reserved3'] = kerbdata['Reserved3']\n            parsed_tuPAC.append({'LoginInfo': parsed_data})\n        elif infoBuffer['ulType'] == pac.PAC_CLIENT_INFO_TYPE:\n            clientInfo = pac.PAC_CLIENT_INFO()\n            clientInfo.fromString(data)\n            parsed_data = {}\n            try:\n                parsed_data['Client Id'] = PACparseFILETIME(clientInfo['ClientId'])\n            except:\n                try:\n                    parsed_data['Client Id'] = PACparseFILETIME(FILETIME(data[:32]))\n                except Exception as e:\n                    logging.error(e)\n            parsed_data['Client Name'] = clientInfo['Name'].decode('utf-16-le')\n            parsed_tuPAC.append({'ClientName': parsed_data})\n        elif infoBuffer['ulType'] == pac.PAC_UPN_DNS_INFO:\n            upn = pac.UPN_DNS_INFO(data)\n            UpnLength = upn['UpnLength']\n            UpnOffset = upn['UpnOffset']\n            UpnName = data[UpnOffset:UpnOffset + UpnLength].decode('utf-16-le')\n            DnsDomainNameLength = upn['DnsDomainNameLength']\n            DnsDomainNameOffset = upn['DnsDomainNameOffset']\n            DnsName = data[DnsDomainNameOffset:DnsDomainNameOffset + DnsDomainNameLength].decode('utf-16-le')\n            flags = upn['Flags']\n            attr_flags = []\n            for flag_lib in Upn_Dns_Flags:\n                if flags & flag_lib.value:\n                    attr_flags.append(flag_lib.name)\n            parsed_data = {}\n            parsed_data['Flags'] = f\"({flags}) {', '.join(attr_flags)}\"\n            parsed_data['UPN'] = UpnName\n            parsed_data['DNS Domain Name'] = DnsName\n            if Upn_Dns_Flags.S_SidSamSupplied.name in attr_flags:\n                upn = pac.UPN_DNS_INFO_FULL(data)\n                SamNameLength = upn['SamNameLength']\n                SamNameOffset = upn['SamNameOffset']\n                SamName = data[SamNameOffset:SamNameOffset + SamNameLength].decode('utf-16-le')\n                SidLength = upn['SidLength']\n                SidOffset = upn['SidOffset']\n                Sid = LDAP_SID(data[SidOffset:SidOffset + SidLength])\n                parsed_data['SamAccountName'] = SamName\n                parsed_data['UserSid'] = Sid.formatCanonical()\n            parsed_tuPAC.append({'UpnDns': parsed_data})\n        elif infoBuffer['ulType'] == pac.PAC_SERVER_CHECKSUM:\n            signatureData = pac.PAC_SIGNATURE_DATA(data)\n            parsed_data = {}\n            parsed_data['Signature Type'] = ChecksumTypes(signatureData['SignatureType']).name\n            parsed_data['Signature'] = hexlify(signatureData['Signature']).decode('utf-8')\n            parsed_tuPAC.append({'ServerChecksum': parsed_data})\n        elif infoBuffer['ulType'] == pac.PAC_PRIVSVR_CHECKSUM:\n            signatureData = pac.PAC_SIGNATURE_DATA(data)\n            parsed_data = {}\n            parsed_data['Signature Type'] = ChecksumTypes(signatureData['SignatureType']).name\n            parsed_data['Signature'] = hexlify(signatureData['Signature']).decode('utf-8')\n            parsed_tuPAC.append({'KDCChecksum': parsed_data})\n        elif infoBuffer['ulType'] == pac.PAC_CREDENTIALS_INFO:\n            credential_info = pac.PAC_CREDENTIAL_INFO(data)\n            parsed_credential_info = {}\n            parsed_credential_info['Version'] = '(0x%x) %d' % (credential_info.fields['Version'], credential_info.fields['Version'])\n            credinfo_enctype = credential_info.fields['EncryptionType']\n            parsed_credential_info['Encryption Type'] = '(0x%x) %s' % (credinfo_enctype, constants.EncryptionTypes(credential_info.fields['EncryptionType']).name)\n            if not args.asrep_key:\n                parsed_credential_info['Encryption Type'] = '<Cannot decrypt, --asrep-key missing>'\n                logging.error('No ASREP key supplied, cannot decrypt PAC Credentials')\n                parsed_tuPAC.append({'Credential Info': parsed_credential_info})\n            else:\n                parsed_tuPAC.append({'Credential Info': parsed_credential_info})\n                newCipher = _enctype_table[credinfo_enctype]\n                key = Key(credinfo_enctype, unhexlify(args.asrep_key))\n                plain_credential_data = newCipher.decrypt(key, 16, credential_info.fields['SerializedData'])\n                type1 = TypeSerialization1(plain_credential_data)\n                newdata = plain_credential_data[len(type1) + 4:]\n                credential_data = pac.PAC_CREDENTIAL_DATA(newdata)\n                parsed_credential_data = {}\n                parsed_credential_data['  Credential Count'] = credential_data['CredentialCount']\n                parsed_tuPAC.append({'  Credential Data': parsed_credential_data})\n                for credential in credential_data['Credentials']:\n                    parsed_secpkg_supplemental_cred = {}\n                    parsed_secpkg_supplemental_cred['      Package Name'] = credential['PackageName']\n                    parsed_secpkg_supplemental_cred['      Credential Size'] = credential['CredentialSize']\n                    parsed_tuPAC.append({'      SecPkg Credentials': parsed_secpkg_supplemental_cred})\n                    ntlm_supplemental_cred = pac.NTLM_SUPPLEMENTAL_CREDENTIAL(b''.join(credential['Credentials']))\n                    parsed_ntlm_supplemental_cred = {}\n                    parsed_ntlm_supplemental_cred['        Version'] = ntlm_supplemental_cred['Version']\n                    parsed_ntlm_supplemental_cred['        Flags'] = ntlm_supplemental_cred['Flags']\n                    parsed_ntlm_supplemental_cred['        LmPasword'] = hexlify(ntlm_supplemental_cred['LmPassword']).decode('utf-8')\n                    parsed_ntlm_supplemental_cred['        NtPasword'] = hexlify(ntlm_supplemental_cred['NtPassword']).decode('utf-8')\n                    parsed_tuPAC.append({'        NTLM Credentials': parsed_ntlm_supplemental_cred})\n        elif infoBuffer['ulType'] == pac.PAC_DELEGATION_INFO:\n            delegationInfo = pac.S4U_DELEGATION_INFO(data)\n            parsed_data = {}\n            parsed_data['S4U2proxyTarget'] = delegationInfo['S4U2proxyTarget']\n            parsed_data['TransitedListSize'] = delegationInfo.fields['TransitedListSize'].fields['Data']\n            parsed_data['S4UTransitedServices'] = delegationInfo['S4UTransitedServices'].decode('utf-8')\n            parsed_tuPAC.append({'DelegationInfo': parsed_data})\n        elif infoBuffer['ulType'] == pac.PAC_ATTRIBUTES_INFO:\n            attributeInfo = pac.PAC_ATTRIBUTE_INFO(data)\n            flags = attributeInfo['Flags']\n            attr_flags = []\n            for flag_lib in Attributes_Flags:\n                if flags & flag_lib.value:\n                    attr_flags.append(flag_lib.name)\n            parsed_data = {'Flags': f\"({flags}) {', '.join(attr_flags)}\"}\n            parsed_tuPAC.append({'Attributes Info': parsed_data})\n        elif infoBuffer['ulType'] == pac.PAC_REQUESTOR_INFO:\n            requestorInfo = pac.PAC_REQUESTOR(data)\n            parsed_data = {'UserSid': requestorInfo['UserSid'].formatCanonical()}\n            parsed_tuPAC.append({'Requestor Info': parsed_data})\n        else:\n            logging.debug('Unsupported PAC structure: %s. Please raise an issue or PR' % infoBuffer['ulType'])\n        buff = buff[len(infoBuffer):]\n    return parsed_tuPAC",
            "def parse_pac(pacType, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    def PACparseFILETIME(data):\n        dwLowDateTime = data['dwLowDateTime']\n        dwHighDateTime = data['dwHighDateTime']\n        v_FILETIME = 'Infinity (absolute time)'\n        if dwLowDateTime != 4294967295 and dwHighDateTime != 2147483647:\n            temp_time = dwHighDateTime\n            temp_time <<= 32\n            temp_time |= dwLowDateTime\n            if datetime.timedelta(microseconds=temp_time / 10).total_seconds() != 0:\n                v_FILETIME = (datetime.datetime(1601, 1, 1, 0, 0, 0) + datetime.timedelta(microseconds=temp_time / 10)).strftime('%d/%m/%Y %H:%M:%S %p')\n        return v_FILETIME\n\n    def PACparseGroupIds(data):\n        groups = []\n        for group in data:\n            groupMembership = {}\n            groupMembership['RelativeId'] = group['RelativeId']\n            groupMembership['Attributes'] = group['Attributes']\n            groups.append(groupMembership)\n        return groups\n    parsed_tuPAC = []\n    buff = pacType['Buffers']\n    for bufferN in range(pacType['cBuffers']):\n        infoBuffer = pac.PAC_INFO_BUFFER(buff)\n        data = pacType['Buffers'][infoBuffer['Offset'] - 8:][:infoBuffer['cbBufferSize']]\n        if infoBuffer['ulType'] == pac.PAC_LOGON_INFO:\n            type1 = TypeSerialization1(data)\n            newdata = data[len(type1) + 4:]\n            kerbdata = pac.KERB_VALIDATION_INFO()\n            kerbdata.fromString(newdata)\n            kerbdata.fromStringReferents(newdata[len(kerbdata.getData()):])\n            parsed_data = {}\n            parsed_data['Logon Time'] = PACparseFILETIME(kerbdata['LogonTime'])\n            parsed_data['Logoff Time'] = PACparseFILETIME(kerbdata['LogoffTime'])\n            parsed_data['Kickoff Time'] = PACparseFILETIME(kerbdata['KickOffTime'])\n            parsed_data['Password Last Set'] = PACparseFILETIME(kerbdata['PasswordLastSet'])\n            parsed_data['Password Can Change'] = PACparseFILETIME(kerbdata['PasswordCanChange'])\n            parsed_data['Password Must Change'] = PACparseFILETIME(kerbdata['PasswordMustChange'])\n            parsed_data['LastSuccessfulILogon'] = PACparseFILETIME(kerbdata['LastSuccessfulILogon'])\n            parsed_data['LastFailedILogon'] = PACparseFILETIME(kerbdata['LastFailedILogon'])\n            parsed_data['FailedILogonCount'] = kerbdata['FailedILogonCount']\n            parsed_data['Account Name'] = kerbdata['EffectiveName']\n            parsed_data['Full Name'] = kerbdata['FullName']\n            parsed_data['Logon Script'] = kerbdata['LogonScript']\n            parsed_data['Profile Path'] = kerbdata['ProfilePath']\n            parsed_data['Home Dir'] = kerbdata['HomeDirectory']\n            parsed_data['Dir Drive'] = kerbdata['HomeDirectoryDrive']\n            parsed_data['Logon Count'] = kerbdata['LogonCount']\n            parsed_data['Bad Password Count'] = kerbdata['BadPasswordCount']\n            parsed_data['User RID'] = kerbdata['UserId']\n            parsed_data['Group RID'] = kerbdata['PrimaryGroupId']\n            parsed_data['Group Count'] = kerbdata['GroupCount']\n            all_groups_id = [str(gid['RelativeId']) for gid in PACparseGroupIds(kerbdata['GroupIds'])]\n            parsed_data['Groups'] = ', '.join(all_groups_id)\n            groups = []\n            unknown_count = 0\n            for gid in all_groups_id:\n                group_name = MsBuiltInGroups.get(gid)\n                if group_name:\n                    groups.append(f'({gid}) {group_name}')\n                else:\n                    unknown_count += 1\n            if unknown_count > 0:\n                groups.append(f\"+{unknown_count} Unknown custom group{('s' if unknown_count > 1 else '')}\")\n            parsed_data['Groups (decoded)'] = groups\n            UserFlags = kerbdata['UserFlags']\n            User_Flags_Flags = []\n            for flag in User_Flags:\n                if UserFlags & flag.value:\n                    User_Flags_Flags.append(flag.name)\n            parsed_data['User Flags'] = '(%s) %s' % (UserFlags, ', '.join(User_Flags_Flags))\n            parsed_data['User Session Key'] = hexlify(kerbdata['UserSessionKey']).decode('utf-8')\n            parsed_data['Logon Server'] = kerbdata['LogonServer']\n            parsed_data['Logon Domain Name'] = kerbdata['LogonDomainName']\n            if kerbdata['LogonDomainId'] == b'':\n                parsed_data['Logon Domain SID'] = kerbdata['LogonDomainId']\n            else:\n                parsed_data['Logon Domain SID'] = kerbdata['LogonDomainId'].formatCanonical()\n            UAC = kerbdata['UserAccountControl']\n            UAC_Flags = []\n            for flag in USER_ACCOUNT_Codes:\n                if UAC & flag.value:\n                    UAC_Flags.append(flag.name)\n            parsed_data['User Account Control'] = '(%s) %s' % (UAC, ', '.join(UAC_Flags))\n            parsed_data['Extra SID Count'] = kerbdata['SidCount']\n            extraSids = []\n            for extraSid in kerbdata['ExtraSids']:\n                sid = extraSid['Sid'].formatCanonical()\n                attributes = extraSid['Attributes']\n                attributes_flags = []\n                for flag in SE_GROUP_Attributes:\n                    if attributes & flag.value:\n                        attributes_flags.append(flag.name)\n                group_name = MsBuiltInGroups.get(sid, '')\n                if not group_name and len(sid.split('-')) == 8:\n                    group_name = MsBuiltInGroups.get(sid.split('-')[-1], '')\n                if group_name:\n                    group_name = f' {group_name}'\n                extraSids.append('%s%s (%s)' % (sid, group_name, ', '.join(attributes_flags)))\n            parsed_data['Extra SIDs'] = extraSids\n            if kerbdata['ResourceGroupDomainSid'] == b'':\n                parsed_data['Resource Group Domain SID'] = kerbdata['ResourceGroupDomainSid']\n            else:\n                parsed_data['Resource Group Domain SID'] = kerbdata['ResourceGroupDomainSid'].formatCanonical()\n            parsed_data['Resource Group Count'] = kerbdata['ResourceGroupCount']\n            parsed_data['Resource Group Ids'] = ', '.join([str(gid['RelativeId']) for gid in PACparseGroupIds(kerbdata['ResourceGroupIds'])])\n            parsed_data['LMKey'] = hexlify(kerbdata['LMKey']).decode('utf-8')\n            parsed_data['SubAuthStatus'] = kerbdata['SubAuthStatus']\n            parsed_data['Reserved3'] = kerbdata['Reserved3']\n            parsed_tuPAC.append({'LoginInfo': parsed_data})\n        elif infoBuffer['ulType'] == pac.PAC_CLIENT_INFO_TYPE:\n            clientInfo = pac.PAC_CLIENT_INFO()\n            clientInfo.fromString(data)\n            parsed_data = {}\n            try:\n                parsed_data['Client Id'] = PACparseFILETIME(clientInfo['ClientId'])\n            except:\n                try:\n                    parsed_data['Client Id'] = PACparseFILETIME(FILETIME(data[:32]))\n                except Exception as e:\n                    logging.error(e)\n            parsed_data['Client Name'] = clientInfo['Name'].decode('utf-16-le')\n            parsed_tuPAC.append({'ClientName': parsed_data})\n        elif infoBuffer['ulType'] == pac.PAC_UPN_DNS_INFO:\n            upn = pac.UPN_DNS_INFO(data)\n            UpnLength = upn['UpnLength']\n            UpnOffset = upn['UpnOffset']\n            UpnName = data[UpnOffset:UpnOffset + UpnLength].decode('utf-16-le')\n            DnsDomainNameLength = upn['DnsDomainNameLength']\n            DnsDomainNameOffset = upn['DnsDomainNameOffset']\n            DnsName = data[DnsDomainNameOffset:DnsDomainNameOffset + DnsDomainNameLength].decode('utf-16-le')\n            flags = upn['Flags']\n            attr_flags = []\n            for flag_lib in Upn_Dns_Flags:\n                if flags & flag_lib.value:\n                    attr_flags.append(flag_lib.name)\n            parsed_data = {}\n            parsed_data['Flags'] = f\"({flags}) {', '.join(attr_flags)}\"\n            parsed_data['UPN'] = UpnName\n            parsed_data['DNS Domain Name'] = DnsName\n            if Upn_Dns_Flags.S_SidSamSupplied.name in attr_flags:\n                upn = pac.UPN_DNS_INFO_FULL(data)\n                SamNameLength = upn['SamNameLength']\n                SamNameOffset = upn['SamNameOffset']\n                SamName = data[SamNameOffset:SamNameOffset + SamNameLength].decode('utf-16-le')\n                SidLength = upn['SidLength']\n                SidOffset = upn['SidOffset']\n                Sid = LDAP_SID(data[SidOffset:SidOffset + SidLength])\n                parsed_data['SamAccountName'] = SamName\n                parsed_data['UserSid'] = Sid.formatCanonical()\n            parsed_tuPAC.append({'UpnDns': parsed_data})\n        elif infoBuffer['ulType'] == pac.PAC_SERVER_CHECKSUM:\n            signatureData = pac.PAC_SIGNATURE_DATA(data)\n            parsed_data = {}\n            parsed_data['Signature Type'] = ChecksumTypes(signatureData['SignatureType']).name\n            parsed_data['Signature'] = hexlify(signatureData['Signature']).decode('utf-8')\n            parsed_tuPAC.append({'ServerChecksum': parsed_data})\n        elif infoBuffer['ulType'] == pac.PAC_PRIVSVR_CHECKSUM:\n            signatureData = pac.PAC_SIGNATURE_DATA(data)\n            parsed_data = {}\n            parsed_data['Signature Type'] = ChecksumTypes(signatureData['SignatureType']).name\n            parsed_data['Signature'] = hexlify(signatureData['Signature']).decode('utf-8')\n            parsed_tuPAC.append({'KDCChecksum': parsed_data})\n        elif infoBuffer['ulType'] == pac.PAC_CREDENTIALS_INFO:\n            credential_info = pac.PAC_CREDENTIAL_INFO(data)\n            parsed_credential_info = {}\n            parsed_credential_info['Version'] = '(0x%x) %d' % (credential_info.fields['Version'], credential_info.fields['Version'])\n            credinfo_enctype = credential_info.fields['EncryptionType']\n            parsed_credential_info['Encryption Type'] = '(0x%x) %s' % (credinfo_enctype, constants.EncryptionTypes(credential_info.fields['EncryptionType']).name)\n            if not args.asrep_key:\n                parsed_credential_info['Encryption Type'] = '<Cannot decrypt, --asrep-key missing>'\n                logging.error('No ASREP key supplied, cannot decrypt PAC Credentials')\n                parsed_tuPAC.append({'Credential Info': parsed_credential_info})\n            else:\n                parsed_tuPAC.append({'Credential Info': parsed_credential_info})\n                newCipher = _enctype_table[credinfo_enctype]\n                key = Key(credinfo_enctype, unhexlify(args.asrep_key))\n                plain_credential_data = newCipher.decrypt(key, 16, credential_info.fields['SerializedData'])\n                type1 = TypeSerialization1(plain_credential_data)\n                newdata = plain_credential_data[len(type1) + 4:]\n                credential_data = pac.PAC_CREDENTIAL_DATA(newdata)\n                parsed_credential_data = {}\n                parsed_credential_data['  Credential Count'] = credential_data['CredentialCount']\n                parsed_tuPAC.append({'  Credential Data': parsed_credential_data})\n                for credential in credential_data['Credentials']:\n                    parsed_secpkg_supplemental_cred = {}\n                    parsed_secpkg_supplemental_cred['      Package Name'] = credential['PackageName']\n                    parsed_secpkg_supplemental_cred['      Credential Size'] = credential['CredentialSize']\n                    parsed_tuPAC.append({'      SecPkg Credentials': parsed_secpkg_supplemental_cred})\n                    ntlm_supplemental_cred = pac.NTLM_SUPPLEMENTAL_CREDENTIAL(b''.join(credential['Credentials']))\n                    parsed_ntlm_supplemental_cred = {}\n                    parsed_ntlm_supplemental_cred['        Version'] = ntlm_supplemental_cred['Version']\n                    parsed_ntlm_supplemental_cred['        Flags'] = ntlm_supplemental_cred['Flags']\n                    parsed_ntlm_supplemental_cred['        LmPasword'] = hexlify(ntlm_supplemental_cred['LmPassword']).decode('utf-8')\n                    parsed_ntlm_supplemental_cred['        NtPasword'] = hexlify(ntlm_supplemental_cred['NtPassword']).decode('utf-8')\n                    parsed_tuPAC.append({'        NTLM Credentials': parsed_ntlm_supplemental_cred})\n        elif infoBuffer['ulType'] == pac.PAC_DELEGATION_INFO:\n            delegationInfo = pac.S4U_DELEGATION_INFO(data)\n            parsed_data = {}\n            parsed_data['S4U2proxyTarget'] = delegationInfo['S4U2proxyTarget']\n            parsed_data['TransitedListSize'] = delegationInfo.fields['TransitedListSize'].fields['Data']\n            parsed_data['S4UTransitedServices'] = delegationInfo['S4UTransitedServices'].decode('utf-8')\n            parsed_tuPAC.append({'DelegationInfo': parsed_data})\n        elif infoBuffer['ulType'] == pac.PAC_ATTRIBUTES_INFO:\n            attributeInfo = pac.PAC_ATTRIBUTE_INFO(data)\n            flags = attributeInfo['Flags']\n            attr_flags = []\n            for flag_lib in Attributes_Flags:\n                if flags & flag_lib.value:\n                    attr_flags.append(flag_lib.name)\n            parsed_data = {'Flags': f\"({flags}) {', '.join(attr_flags)}\"}\n            parsed_tuPAC.append({'Attributes Info': parsed_data})\n        elif infoBuffer['ulType'] == pac.PAC_REQUESTOR_INFO:\n            requestorInfo = pac.PAC_REQUESTOR(data)\n            parsed_data = {'UserSid': requestorInfo['UserSid'].formatCanonical()}\n            parsed_tuPAC.append({'Requestor Info': parsed_data})\n        else:\n            logging.debug('Unsupported PAC structure: %s. Please raise an issue or PR' % infoBuffer['ulType'])\n        buff = buff[len(infoBuffer):]\n    return parsed_tuPAC"
        ]
    },
    {
        "func_name": "generate_kerberos_keys",
        "original": "def generate_kerberos_keys(args):\n    keys = {}\n    if args.rc4:\n        keys[int(constants.EncryptionTypes.rc4_hmac.value)] = unhexlify(args.rc4)\n    if args.aes:\n        if len(args.aes) == 64:\n            keys[int(constants.EncryptionTypes.aes256_cts_hmac_sha1_96.value)] = unhexlify(args.aes)\n        else:\n            keys[int(constants.EncryptionTypes.aes128_cts_hmac_sha1_96.value)] = unhexlify(args.aes)\n    ekeys = {}\n    for (kt, key) in keys.items():\n        ekeys[kt] = Key(kt, key)\n    allciphers = [int(constants.EncryptionTypes.rc4_hmac.value), int(constants.EncryptionTypes.aes256_cts_hmac_sha1_96.value), int(constants.EncryptionTypes.aes128_cts_hmac_sha1_96.value)]\n    if args.password or args.hex_pass:\n        if not args.salt and args.user and args.domain:\n            if args.user.endswith('$'):\n                args.salt = '%shost%s.%s' % (args.domain.upper(), args.user.rstrip('$').lower(), args.domain.lower())\n            else:\n                args.salt = '%s%s' % (args.domain.upper(), args.user)\n        for cipher in allciphers:\n            if cipher == 23 and args.hex_pass:\n                md4 = MD4.new()\n                md4.update(unhexlify(args.hex_pass))\n                ekeys[cipher] = Key(cipher, md4.digest())\n                logging.debug('Calculated type %s (%d) Kerberos key: %s' % (constants.EncryptionTypes(cipher).name, cipher, hexlify(ekeys[cipher].contents).decode('utf-8')))\n            elif args.salt:\n                if args.hex_pass:\n                    rawsecret = unhexlify(args.hex_pass).decode('utf-16-le', 'replace').encode('utf-8', 'replace')\n                else:\n                    rawsecret = args.password\n                ekeys[cipher] = string_to_key(cipher, rawsecret, args.salt)\n                logging.debug('Calculated type %s (%d) Kerberos key: %s' % (constants.EncryptionTypes(cipher).name, cipher, hexlify(ekeys[cipher].contents).decode('utf-8')))\n            else:\n                logging.debug('Cannot calculate type %s (%d) Kerberos key: salt is None: Missing -s/--salt or (-u/--user and -d/--domain)' % (constants.EncryptionTypes(cipher).name, cipher))\n    else:\n        logging.debug('No password (-p/--password or -hp/--hex_pass supplied, skipping Kerberos keys calculation')\n    return ekeys",
        "mutated": [
            "def generate_kerberos_keys(args):\n    if False:\n        i = 10\n    keys = {}\n    if args.rc4:\n        keys[int(constants.EncryptionTypes.rc4_hmac.value)] = unhexlify(args.rc4)\n    if args.aes:\n        if len(args.aes) == 64:\n            keys[int(constants.EncryptionTypes.aes256_cts_hmac_sha1_96.value)] = unhexlify(args.aes)\n        else:\n            keys[int(constants.EncryptionTypes.aes128_cts_hmac_sha1_96.value)] = unhexlify(args.aes)\n    ekeys = {}\n    for (kt, key) in keys.items():\n        ekeys[kt] = Key(kt, key)\n    allciphers = [int(constants.EncryptionTypes.rc4_hmac.value), int(constants.EncryptionTypes.aes256_cts_hmac_sha1_96.value), int(constants.EncryptionTypes.aes128_cts_hmac_sha1_96.value)]\n    if args.password or args.hex_pass:\n        if not args.salt and args.user and args.domain:\n            if args.user.endswith('$'):\n                args.salt = '%shost%s.%s' % (args.domain.upper(), args.user.rstrip('$').lower(), args.domain.lower())\n            else:\n                args.salt = '%s%s' % (args.domain.upper(), args.user)\n        for cipher in allciphers:\n            if cipher == 23 and args.hex_pass:\n                md4 = MD4.new()\n                md4.update(unhexlify(args.hex_pass))\n                ekeys[cipher] = Key(cipher, md4.digest())\n                logging.debug('Calculated type %s (%d) Kerberos key: %s' % (constants.EncryptionTypes(cipher).name, cipher, hexlify(ekeys[cipher].contents).decode('utf-8')))\n            elif args.salt:\n                if args.hex_pass:\n                    rawsecret = unhexlify(args.hex_pass).decode('utf-16-le', 'replace').encode('utf-8', 'replace')\n                else:\n                    rawsecret = args.password\n                ekeys[cipher] = string_to_key(cipher, rawsecret, args.salt)\n                logging.debug('Calculated type %s (%d) Kerberos key: %s' % (constants.EncryptionTypes(cipher).name, cipher, hexlify(ekeys[cipher].contents).decode('utf-8')))\n            else:\n                logging.debug('Cannot calculate type %s (%d) Kerberos key: salt is None: Missing -s/--salt or (-u/--user and -d/--domain)' % (constants.EncryptionTypes(cipher).name, cipher))\n    else:\n        logging.debug('No password (-p/--password or -hp/--hex_pass supplied, skipping Kerberos keys calculation')\n    return ekeys",
            "def generate_kerberos_keys(args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    keys = {}\n    if args.rc4:\n        keys[int(constants.EncryptionTypes.rc4_hmac.value)] = unhexlify(args.rc4)\n    if args.aes:\n        if len(args.aes) == 64:\n            keys[int(constants.EncryptionTypes.aes256_cts_hmac_sha1_96.value)] = unhexlify(args.aes)\n        else:\n            keys[int(constants.EncryptionTypes.aes128_cts_hmac_sha1_96.value)] = unhexlify(args.aes)\n    ekeys = {}\n    for (kt, key) in keys.items():\n        ekeys[kt] = Key(kt, key)\n    allciphers = [int(constants.EncryptionTypes.rc4_hmac.value), int(constants.EncryptionTypes.aes256_cts_hmac_sha1_96.value), int(constants.EncryptionTypes.aes128_cts_hmac_sha1_96.value)]\n    if args.password or args.hex_pass:\n        if not args.salt and args.user and args.domain:\n            if args.user.endswith('$'):\n                args.salt = '%shost%s.%s' % (args.domain.upper(), args.user.rstrip('$').lower(), args.domain.lower())\n            else:\n                args.salt = '%s%s' % (args.domain.upper(), args.user)\n        for cipher in allciphers:\n            if cipher == 23 and args.hex_pass:\n                md4 = MD4.new()\n                md4.update(unhexlify(args.hex_pass))\n                ekeys[cipher] = Key(cipher, md4.digest())\n                logging.debug('Calculated type %s (%d) Kerberos key: %s' % (constants.EncryptionTypes(cipher).name, cipher, hexlify(ekeys[cipher].contents).decode('utf-8')))\n            elif args.salt:\n                if args.hex_pass:\n                    rawsecret = unhexlify(args.hex_pass).decode('utf-16-le', 'replace').encode('utf-8', 'replace')\n                else:\n                    rawsecret = args.password\n                ekeys[cipher] = string_to_key(cipher, rawsecret, args.salt)\n                logging.debug('Calculated type %s (%d) Kerberos key: %s' % (constants.EncryptionTypes(cipher).name, cipher, hexlify(ekeys[cipher].contents).decode('utf-8')))\n            else:\n                logging.debug('Cannot calculate type %s (%d) Kerberos key: salt is None: Missing -s/--salt or (-u/--user and -d/--domain)' % (constants.EncryptionTypes(cipher).name, cipher))\n    else:\n        logging.debug('No password (-p/--password or -hp/--hex_pass supplied, skipping Kerberos keys calculation')\n    return ekeys",
            "def generate_kerberos_keys(args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    keys = {}\n    if args.rc4:\n        keys[int(constants.EncryptionTypes.rc4_hmac.value)] = unhexlify(args.rc4)\n    if args.aes:\n        if len(args.aes) == 64:\n            keys[int(constants.EncryptionTypes.aes256_cts_hmac_sha1_96.value)] = unhexlify(args.aes)\n        else:\n            keys[int(constants.EncryptionTypes.aes128_cts_hmac_sha1_96.value)] = unhexlify(args.aes)\n    ekeys = {}\n    for (kt, key) in keys.items():\n        ekeys[kt] = Key(kt, key)\n    allciphers = [int(constants.EncryptionTypes.rc4_hmac.value), int(constants.EncryptionTypes.aes256_cts_hmac_sha1_96.value), int(constants.EncryptionTypes.aes128_cts_hmac_sha1_96.value)]\n    if args.password or args.hex_pass:\n        if not args.salt and args.user and args.domain:\n            if args.user.endswith('$'):\n                args.salt = '%shost%s.%s' % (args.domain.upper(), args.user.rstrip('$').lower(), args.domain.lower())\n            else:\n                args.salt = '%s%s' % (args.domain.upper(), args.user)\n        for cipher in allciphers:\n            if cipher == 23 and args.hex_pass:\n                md4 = MD4.new()\n                md4.update(unhexlify(args.hex_pass))\n                ekeys[cipher] = Key(cipher, md4.digest())\n                logging.debug('Calculated type %s (%d) Kerberos key: %s' % (constants.EncryptionTypes(cipher).name, cipher, hexlify(ekeys[cipher].contents).decode('utf-8')))\n            elif args.salt:\n                if args.hex_pass:\n                    rawsecret = unhexlify(args.hex_pass).decode('utf-16-le', 'replace').encode('utf-8', 'replace')\n                else:\n                    rawsecret = args.password\n                ekeys[cipher] = string_to_key(cipher, rawsecret, args.salt)\n                logging.debug('Calculated type %s (%d) Kerberos key: %s' % (constants.EncryptionTypes(cipher).name, cipher, hexlify(ekeys[cipher].contents).decode('utf-8')))\n            else:\n                logging.debug('Cannot calculate type %s (%d) Kerberos key: salt is None: Missing -s/--salt or (-u/--user and -d/--domain)' % (constants.EncryptionTypes(cipher).name, cipher))\n    else:\n        logging.debug('No password (-p/--password or -hp/--hex_pass supplied, skipping Kerberos keys calculation')\n    return ekeys",
            "def generate_kerberos_keys(args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    keys = {}\n    if args.rc4:\n        keys[int(constants.EncryptionTypes.rc4_hmac.value)] = unhexlify(args.rc4)\n    if args.aes:\n        if len(args.aes) == 64:\n            keys[int(constants.EncryptionTypes.aes256_cts_hmac_sha1_96.value)] = unhexlify(args.aes)\n        else:\n            keys[int(constants.EncryptionTypes.aes128_cts_hmac_sha1_96.value)] = unhexlify(args.aes)\n    ekeys = {}\n    for (kt, key) in keys.items():\n        ekeys[kt] = Key(kt, key)\n    allciphers = [int(constants.EncryptionTypes.rc4_hmac.value), int(constants.EncryptionTypes.aes256_cts_hmac_sha1_96.value), int(constants.EncryptionTypes.aes128_cts_hmac_sha1_96.value)]\n    if args.password or args.hex_pass:\n        if not args.salt and args.user and args.domain:\n            if args.user.endswith('$'):\n                args.salt = '%shost%s.%s' % (args.domain.upper(), args.user.rstrip('$').lower(), args.domain.lower())\n            else:\n                args.salt = '%s%s' % (args.domain.upper(), args.user)\n        for cipher in allciphers:\n            if cipher == 23 and args.hex_pass:\n                md4 = MD4.new()\n                md4.update(unhexlify(args.hex_pass))\n                ekeys[cipher] = Key(cipher, md4.digest())\n                logging.debug('Calculated type %s (%d) Kerberos key: %s' % (constants.EncryptionTypes(cipher).name, cipher, hexlify(ekeys[cipher].contents).decode('utf-8')))\n            elif args.salt:\n                if args.hex_pass:\n                    rawsecret = unhexlify(args.hex_pass).decode('utf-16-le', 'replace').encode('utf-8', 'replace')\n                else:\n                    rawsecret = args.password\n                ekeys[cipher] = string_to_key(cipher, rawsecret, args.salt)\n                logging.debug('Calculated type %s (%d) Kerberos key: %s' % (constants.EncryptionTypes(cipher).name, cipher, hexlify(ekeys[cipher].contents).decode('utf-8')))\n            else:\n                logging.debug('Cannot calculate type %s (%d) Kerberos key: salt is None: Missing -s/--salt or (-u/--user and -d/--domain)' % (constants.EncryptionTypes(cipher).name, cipher))\n    else:\n        logging.debug('No password (-p/--password or -hp/--hex_pass supplied, skipping Kerberos keys calculation')\n    return ekeys",
            "def generate_kerberos_keys(args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    keys = {}\n    if args.rc4:\n        keys[int(constants.EncryptionTypes.rc4_hmac.value)] = unhexlify(args.rc4)\n    if args.aes:\n        if len(args.aes) == 64:\n            keys[int(constants.EncryptionTypes.aes256_cts_hmac_sha1_96.value)] = unhexlify(args.aes)\n        else:\n            keys[int(constants.EncryptionTypes.aes128_cts_hmac_sha1_96.value)] = unhexlify(args.aes)\n    ekeys = {}\n    for (kt, key) in keys.items():\n        ekeys[kt] = Key(kt, key)\n    allciphers = [int(constants.EncryptionTypes.rc4_hmac.value), int(constants.EncryptionTypes.aes256_cts_hmac_sha1_96.value), int(constants.EncryptionTypes.aes128_cts_hmac_sha1_96.value)]\n    if args.password or args.hex_pass:\n        if not args.salt and args.user and args.domain:\n            if args.user.endswith('$'):\n                args.salt = '%shost%s.%s' % (args.domain.upper(), args.user.rstrip('$').lower(), args.domain.lower())\n            else:\n                args.salt = '%s%s' % (args.domain.upper(), args.user)\n        for cipher in allciphers:\n            if cipher == 23 and args.hex_pass:\n                md4 = MD4.new()\n                md4.update(unhexlify(args.hex_pass))\n                ekeys[cipher] = Key(cipher, md4.digest())\n                logging.debug('Calculated type %s (%d) Kerberos key: %s' % (constants.EncryptionTypes(cipher).name, cipher, hexlify(ekeys[cipher].contents).decode('utf-8')))\n            elif args.salt:\n                if args.hex_pass:\n                    rawsecret = unhexlify(args.hex_pass).decode('utf-16-le', 'replace').encode('utf-8', 'replace')\n                else:\n                    rawsecret = args.password\n                ekeys[cipher] = string_to_key(cipher, rawsecret, args.salt)\n                logging.debug('Calculated type %s (%d) Kerberos key: %s' % (constants.EncryptionTypes(cipher).name, cipher, hexlify(ekeys[cipher].contents).decode('utf-8')))\n            else:\n                logging.debug('Cannot calculate type %s (%d) Kerberos key: salt is None: Missing -s/--salt or (-u/--user and -d/--domain)' % (constants.EncryptionTypes(cipher).name, cipher))\n    else:\n        logging.debug('No password (-p/--password or -hp/--hex_pass supplied, skipping Kerberos keys calculation')\n    return ekeys"
        ]
    },
    {
        "func_name": "kerberoast_from_ccache",
        "original": "def kerberoast_from_ccache(decodedTGS, spn, username, domain):\n    try:\n        if not domain:\n            domain = decodedTGS['ticket']['realm']._value.upper()\n        else:\n            domain = domain.upper()\n        if not username:\n            username = 'USER'\n        username = username.rstrip('$')\n        if decodedTGS['ticket']['enc-part']['etype'] == constants.EncryptionTypes.rc4_hmac.value:\n            entry = '$krb5tgs$%d$*%s$%s$%s*$%s$%s' % (constants.EncryptionTypes.rc4_hmac.value, username, domain, spn.replace(':', '~'), hexlify(decodedTGS['ticket']['enc-part']['cipher'][:16].asOctets()).decode(), hexlify(decodedTGS['ticket']['enc-part']['cipher'][16:].asOctets()).decode())\n        elif decodedTGS['ticket']['enc-part']['etype'] == constants.EncryptionTypes.aes128_cts_hmac_sha1_96.value:\n            entry = '$krb5tgs$%d$%s$%s$*%s*$%s$%s' % (constants.EncryptionTypes.aes128_cts_hmac_sha1_96.value, username, domain, spn.replace(':', '~'), hexlify(decodedTGS['ticket']['enc-part']['cipher'][-12:].asOctets()).decode(), hexlify(decodedTGS['ticket']['enc-part']['cipher'][:-12].asOctets()).decode)\n        elif decodedTGS['ticket']['enc-part']['etype'] == constants.EncryptionTypes.aes256_cts_hmac_sha1_96.value:\n            entry = '$krb5tgs$%d$%s$%s$*%s*$%s$%s' % (constants.EncryptionTypes.aes256_cts_hmac_sha1_96.value, username, domain, spn.replace(':', '~'), hexlify(decodedTGS['ticket']['enc-part']['cipher'][-12:].asOctets()).decode(), hexlify(decodedTGS['ticket']['enc-part']['cipher'][:-12].asOctets()).decode())\n        elif decodedTGS['ticket']['enc-part']['etype'] == constants.EncryptionTypes.des_cbc_md5.value:\n            entry = '$krb5tgs$%d$*%s$%s$%s*$%s$%s' % (constants.EncryptionTypes.des_cbc_md5.value, username, domain, spn.replace(':', '~'), hexlify(decodedTGS['ticket']['enc-part']['cipher'][:16].asOctets()).decode(), hexlify(decodedTGS['ticket']['enc-part']['cipher'][16:].asOctets()).decode())\n        else:\n            logging.debug('Skipping %s/%s due to incompatible e-type %d' % (decodedTGS['ticket']['sname']['name-string'][0], decodedTGS['ticket']['sname']['name-string'][1], decodedTGS['ticket']['enc-part']['etype']))\n        return entry\n    except Exception as e:\n        raise\n        logging.debug('Not able to parse ticket: %s' % e)",
        "mutated": [
            "def kerberoast_from_ccache(decodedTGS, spn, username, domain):\n    if False:\n        i = 10\n    try:\n        if not domain:\n            domain = decodedTGS['ticket']['realm']._value.upper()\n        else:\n            domain = domain.upper()\n        if not username:\n            username = 'USER'\n        username = username.rstrip('$')\n        if decodedTGS['ticket']['enc-part']['etype'] == constants.EncryptionTypes.rc4_hmac.value:\n            entry = '$krb5tgs$%d$*%s$%s$%s*$%s$%s' % (constants.EncryptionTypes.rc4_hmac.value, username, domain, spn.replace(':', '~'), hexlify(decodedTGS['ticket']['enc-part']['cipher'][:16].asOctets()).decode(), hexlify(decodedTGS['ticket']['enc-part']['cipher'][16:].asOctets()).decode())\n        elif decodedTGS['ticket']['enc-part']['etype'] == constants.EncryptionTypes.aes128_cts_hmac_sha1_96.value:\n            entry = '$krb5tgs$%d$%s$%s$*%s*$%s$%s' % (constants.EncryptionTypes.aes128_cts_hmac_sha1_96.value, username, domain, spn.replace(':', '~'), hexlify(decodedTGS['ticket']['enc-part']['cipher'][-12:].asOctets()).decode(), hexlify(decodedTGS['ticket']['enc-part']['cipher'][:-12].asOctets()).decode)\n        elif decodedTGS['ticket']['enc-part']['etype'] == constants.EncryptionTypes.aes256_cts_hmac_sha1_96.value:\n            entry = '$krb5tgs$%d$%s$%s$*%s*$%s$%s' % (constants.EncryptionTypes.aes256_cts_hmac_sha1_96.value, username, domain, spn.replace(':', '~'), hexlify(decodedTGS['ticket']['enc-part']['cipher'][-12:].asOctets()).decode(), hexlify(decodedTGS['ticket']['enc-part']['cipher'][:-12].asOctets()).decode())\n        elif decodedTGS['ticket']['enc-part']['etype'] == constants.EncryptionTypes.des_cbc_md5.value:\n            entry = '$krb5tgs$%d$*%s$%s$%s*$%s$%s' % (constants.EncryptionTypes.des_cbc_md5.value, username, domain, spn.replace(':', '~'), hexlify(decodedTGS['ticket']['enc-part']['cipher'][:16].asOctets()).decode(), hexlify(decodedTGS['ticket']['enc-part']['cipher'][16:].asOctets()).decode())\n        else:\n            logging.debug('Skipping %s/%s due to incompatible e-type %d' % (decodedTGS['ticket']['sname']['name-string'][0], decodedTGS['ticket']['sname']['name-string'][1], decodedTGS['ticket']['enc-part']['etype']))\n        return entry\n    except Exception as e:\n        raise\n        logging.debug('Not able to parse ticket: %s' % e)",
            "def kerberoast_from_ccache(decodedTGS, spn, username, domain):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    try:\n        if not domain:\n            domain = decodedTGS['ticket']['realm']._value.upper()\n        else:\n            domain = domain.upper()\n        if not username:\n            username = 'USER'\n        username = username.rstrip('$')\n        if decodedTGS['ticket']['enc-part']['etype'] == constants.EncryptionTypes.rc4_hmac.value:\n            entry = '$krb5tgs$%d$*%s$%s$%s*$%s$%s' % (constants.EncryptionTypes.rc4_hmac.value, username, domain, spn.replace(':', '~'), hexlify(decodedTGS['ticket']['enc-part']['cipher'][:16].asOctets()).decode(), hexlify(decodedTGS['ticket']['enc-part']['cipher'][16:].asOctets()).decode())\n        elif decodedTGS['ticket']['enc-part']['etype'] == constants.EncryptionTypes.aes128_cts_hmac_sha1_96.value:\n            entry = '$krb5tgs$%d$%s$%s$*%s*$%s$%s' % (constants.EncryptionTypes.aes128_cts_hmac_sha1_96.value, username, domain, spn.replace(':', '~'), hexlify(decodedTGS['ticket']['enc-part']['cipher'][-12:].asOctets()).decode(), hexlify(decodedTGS['ticket']['enc-part']['cipher'][:-12].asOctets()).decode)\n        elif decodedTGS['ticket']['enc-part']['etype'] == constants.EncryptionTypes.aes256_cts_hmac_sha1_96.value:\n            entry = '$krb5tgs$%d$%s$%s$*%s*$%s$%s' % (constants.EncryptionTypes.aes256_cts_hmac_sha1_96.value, username, domain, spn.replace(':', '~'), hexlify(decodedTGS['ticket']['enc-part']['cipher'][-12:].asOctets()).decode(), hexlify(decodedTGS['ticket']['enc-part']['cipher'][:-12].asOctets()).decode())\n        elif decodedTGS['ticket']['enc-part']['etype'] == constants.EncryptionTypes.des_cbc_md5.value:\n            entry = '$krb5tgs$%d$*%s$%s$%s*$%s$%s' % (constants.EncryptionTypes.des_cbc_md5.value, username, domain, spn.replace(':', '~'), hexlify(decodedTGS['ticket']['enc-part']['cipher'][:16].asOctets()).decode(), hexlify(decodedTGS['ticket']['enc-part']['cipher'][16:].asOctets()).decode())\n        else:\n            logging.debug('Skipping %s/%s due to incompatible e-type %d' % (decodedTGS['ticket']['sname']['name-string'][0], decodedTGS['ticket']['sname']['name-string'][1], decodedTGS['ticket']['enc-part']['etype']))\n        return entry\n    except Exception as e:\n        raise\n        logging.debug('Not able to parse ticket: %s' % e)",
            "def kerberoast_from_ccache(decodedTGS, spn, username, domain):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    try:\n        if not domain:\n            domain = decodedTGS['ticket']['realm']._value.upper()\n        else:\n            domain = domain.upper()\n        if not username:\n            username = 'USER'\n        username = username.rstrip('$')\n        if decodedTGS['ticket']['enc-part']['etype'] == constants.EncryptionTypes.rc4_hmac.value:\n            entry = '$krb5tgs$%d$*%s$%s$%s*$%s$%s' % (constants.EncryptionTypes.rc4_hmac.value, username, domain, spn.replace(':', '~'), hexlify(decodedTGS['ticket']['enc-part']['cipher'][:16].asOctets()).decode(), hexlify(decodedTGS['ticket']['enc-part']['cipher'][16:].asOctets()).decode())\n        elif decodedTGS['ticket']['enc-part']['etype'] == constants.EncryptionTypes.aes128_cts_hmac_sha1_96.value:\n            entry = '$krb5tgs$%d$%s$%s$*%s*$%s$%s' % (constants.EncryptionTypes.aes128_cts_hmac_sha1_96.value, username, domain, spn.replace(':', '~'), hexlify(decodedTGS['ticket']['enc-part']['cipher'][-12:].asOctets()).decode(), hexlify(decodedTGS['ticket']['enc-part']['cipher'][:-12].asOctets()).decode)\n        elif decodedTGS['ticket']['enc-part']['etype'] == constants.EncryptionTypes.aes256_cts_hmac_sha1_96.value:\n            entry = '$krb5tgs$%d$%s$%s$*%s*$%s$%s' % (constants.EncryptionTypes.aes256_cts_hmac_sha1_96.value, username, domain, spn.replace(':', '~'), hexlify(decodedTGS['ticket']['enc-part']['cipher'][-12:].asOctets()).decode(), hexlify(decodedTGS['ticket']['enc-part']['cipher'][:-12].asOctets()).decode())\n        elif decodedTGS['ticket']['enc-part']['etype'] == constants.EncryptionTypes.des_cbc_md5.value:\n            entry = '$krb5tgs$%d$*%s$%s$%s*$%s$%s' % (constants.EncryptionTypes.des_cbc_md5.value, username, domain, spn.replace(':', '~'), hexlify(decodedTGS['ticket']['enc-part']['cipher'][:16].asOctets()).decode(), hexlify(decodedTGS['ticket']['enc-part']['cipher'][16:].asOctets()).decode())\n        else:\n            logging.debug('Skipping %s/%s due to incompatible e-type %d' % (decodedTGS['ticket']['sname']['name-string'][0], decodedTGS['ticket']['sname']['name-string'][1], decodedTGS['ticket']['enc-part']['etype']))\n        return entry\n    except Exception as e:\n        raise\n        logging.debug('Not able to parse ticket: %s' % e)",
            "def kerberoast_from_ccache(decodedTGS, spn, username, domain):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    try:\n        if not domain:\n            domain = decodedTGS['ticket']['realm']._value.upper()\n        else:\n            domain = domain.upper()\n        if not username:\n            username = 'USER'\n        username = username.rstrip('$')\n        if decodedTGS['ticket']['enc-part']['etype'] == constants.EncryptionTypes.rc4_hmac.value:\n            entry = '$krb5tgs$%d$*%s$%s$%s*$%s$%s' % (constants.EncryptionTypes.rc4_hmac.value, username, domain, spn.replace(':', '~'), hexlify(decodedTGS['ticket']['enc-part']['cipher'][:16].asOctets()).decode(), hexlify(decodedTGS['ticket']['enc-part']['cipher'][16:].asOctets()).decode())\n        elif decodedTGS['ticket']['enc-part']['etype'] == constants.EncryptionTypes.aes128_cts_hmac_sha1_96.value:\n            entry = '$krb5tgs$%d$%s$%s$*%s*$%s$%s' % (constants.EncryptionTypes.aes128_cts_hmac_sha1_96.value, username, domain, spn.replace(':', '~'), hexlify(decodedTGS['ticket']['enc-part']['cipher'][-12:].asOctets()).decode(), hexlify(decodedTGS['ticket']['enc-part']['cipher'][:-12].asOctets()).decode)\n        elif decodedTGS['ticket']['enc-part']['etype'] == constants.EncryptionTypes.aes256_cts_hmac_sha1_96.value:\n            entry = '$krb5tgs$%d$%s$%s$*%s*$%s$%s' % (constants.EncryptionTypes.aes256_cts_hmac_sha1_96.value, username, domain, spn.replace(':', '~'), hexlify(decodedTGS['ticket']['enc-part']['cipher'][-12:].asOctets()).decode(), hexlify(decodedTGS['ticket']['enc-part']['cipher'][:-12].asOctets()).decode())\n        elif decodedTGS['ticket']['enc-part']['etype'] == constants.EncryptionTypes.des_cbc_md5.value:\n            entry = '$krb5tgs$%d$*%s$%s$%s*$%s$%s' % (constants.EncryptionTypes.des_cbc_md5.value, username, domain, spn.replace(':', '~'), hexlify(decodedTGS['ticket']['enc-part']['cipher'][:16].asOctets()).decode(), hexlify(decodedTGS['ticket']['enc-part']['cipher'][16:].asOctets()).decode())\n        else:\n            logging.debug('Skipping %s/%s due to incompatible e-type %d' % (decodedTGS['ticket']['sname']['name-string'][0], decodedTGS['ticket']['sname']['name-string'][1], decodedTGS['ticket']['enc-part']['etype']))\n        return entry\n    except Exception as e:\n        raise\n        logging.debug('Not able to parse ticket: %s' % e)",
            "def kerberoast_from_ccache(decodedTGS, spn, username, domain):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    try:\n        if not domain:\n            domain = decodedTGS['ticket']['realm']._value.upper()\n        else:\n            domain = domain.upper()\n        if not username:\n            username = 'USER'\n        username = username.rstrip('$')\n        if decodedTGS['ticket']['enc-part']['etype'] == constants.EncryptionTypes.rc4_hmac.value:\n            entry = '$krb5tgs$%d$*%s$%s$%s*$%s$%s' % (constants.EncryptionTypes.rc4_hmac.value, username, domain, spn.replace(':', '~'), hexlify(decodedTGS['ticket']['enc-part']['cipher'][:16].asOctets()).decode(), hexlify(decodedTGS['ticket']['enc-part']['cipher'][16:].asOctets()).decode())\n        elif decodedTGS['ticket']['enc-part']['etype'] == constants.EncryptionTypes.aes128_cts_hmac_sha1_96.value:\n            entry = '$krb5tgs$%d$%s$%s$*%s*$%s$%s' % (constants.EncryptionTypes.aes128_cts_hmac_sha1_96.value, username, domain, spn.replace(':', '~'), hexlify(decodedTGS['ticket']['enc-part']['cipher'][-12:].asOctets()).decode(), hexlify(decodedTGS['ticket']['enc-part']['cipher'][:-12].asOctets()).decode)\n        elif decodedTGS['ticket']['enc-part']['etype'] == constants.EncryptionTypes.aes256_cts_hmac_sha1_96.value:\n            entry = '$krb5tgs$%d$%s$%s$*%s*$%s$%s' % (constants.EncryptionTypes.aes256_cts_hmac_sha1_96.value, username, domain, spn.replace(':', '~'), hexlify(decodedTGS['ticket']['enc-part']['cipher'][-12:].asOctets()).decode(), hexlify(decodedTGS['ticket']['enc-part']['cipher'][:-12].asOctets()).decode())\n        elif decodedTGS['ticket']['enc-part']['etype'] == constants.EncryptionTypes.des_cbc_md5.value:\n            entry = '$krb5tgs$%d$*%s$%s$%s*$%s$%s' % (constants.EncryptionTypes.des_cbc_md5.value, username, domain, spn.replace(':', '~'), hexlify(decodedTGS['ticket']['enc-part']['cipher'][:16].asOctets()).decode(), hexlify(decodedTGS['ticket']['enc-part']['cipher'][16:].asOctets()).decode())\n        else:\n            logging.debug('Skipping %s/%s due to incompatible e-type %d' % (decodedTGS['ticket']['sname']['name-string'][0], decodedTGS['ticket']['sname']['name-string'][1], decodedTGS['ticket']['enc-part']['etype']))\n        return entry\n    except Exception as e:\n        raise\n        logging.debug('Not able to parse ticket: %s' % e)"
        ]
    },
    {
        "func_name": "parse_args",
        "original": "def parse_args():\n    parser = argparse.ArgumentParser(add_help=True, description='Ticket describer. Parses ticket, decrypts the enc-part, and parses the PAC.')\n    parser.add_argument('ticket', action='store', help='Path to ticket.ccache')\n    parser.add_argument('-debug', action='store_true', help='Turn DEBUG output ON')\n    parser.add_argument('-ts', action='store_true', help='Adds timestamp to every logging output')\n    ticket_decryption = parser.add_argument_group()\n    ticket_decryption.title = 'Ticket decryption credentials (optional)'\n    ticket_decryption.description = 'Tickets carry a set of information encrypted by one of the target service account\\'s Kerberos keys.(example: if the ticket is for user:\"john\" for service:\"cifs/service.domain.local\", you need to supply credentials or keys of the service account who owns SPN \"cifs/service.domain.local\")'\n    ticket_decryption.add_argument('-p', '--password', action='store', metavar='PASSWORD', help='Cleartext password of the service account')\n    ticket_decryption.add_argument('-hp', '--hex-password', dest='hex_pass', action='store', metavar='HEXPASSWORD', help='Hex password of the service account')\n    ticket_decryption.add_argument('-u', '--user', action='store', metavar='USER', help='Name of the service account')\n    ticket_decryption.add_argument('-d', '--domain', action='store', metavar='DOMAIN', help='FQDN Domain')\n    ticket_decryption.add_argument('-s', '--salt', action='store', metavar='SALT', help='Salt for keys calculation (DOMAIN.LOCALSomeuser for users, DOMAIN.LOCALhostsomemachine.domain.local for machines)')\n    ticket_decryption.add_argument('--rc4', action='store', metavar='RC4', help='RC4 KEY (i.e. NT hash)')\n    ticket_decryption.add_argument('--aes', action='store', metavar='HEXKEY', help='AES128 or AES256 key')\n    credential_info = parser.add_argument_group()\n    credential_info.title = 'PAC Credentials decryption material'\n    credential_info.description = '[MS-PAC] section 2.6 (PAC Credentials) describes an element that is used to send credentials for alternate security protocols to the client during initial logon.This PAC credentials is typically used when PKINIT is conducted for pre-authentication. This structure contains LM and NT hashes.The information is encrypted using the AS reply key. Attack primitive known as UnPAC-the-Hash. (https://www.thehacker.recipes/ad/movement/kerberos/unpac-the-hash)'\n    credential_info.add_argument('--asrep-key', action='store', metavar='HEXKEY', help='AS reply key for PAC Credentials decryption')\n    if len(sys.argv) == 1:\n        parser.print_help()\n        sys.exit(1)\n    args = parser.parse_args()\n    if not args.salt:\n        if args.user and (not args.domain):\n            parser.error('without -s/--salt, and with -u/--user, argument -d/--domain is required to calculate the salt')\n        elif not args.user and args.domain:\n            parser.error('without -s/--salt, and with -d/--domain, argument -u/--user is required to calculate the salt')\n    if args.domain and (not '.' in args.domain):\n        parser.error('Domain supplied in -d/--domain should be FQDN')\n    return args",
        "mutated": [
            "def parse_args():\n    if False:\n        i = 10\n    parser = argparse.ArgumentParser(add_help=True, description='Ticket describer. Parses ticket, decrypts the enc-part, and parses the PAC.')\n    parser.add_argument('ticket', action='store', help='Path to ticket.ccache')\n    parser.add_argument('-debug', action='store_true', help='Turn DEBUG output ON')\n    parser.add_argument('-ts', action='store_true', help='Adds timestamp to every logging output')\n    ticket_decryption = parser.add_argument_group()\n    ticket_decryption.title = 'Ticket decryption credentials (optional)'\n    ticket_decryption.description = 'Tickets carry a set of information encrypted by one of the target service account\\'s Kerberos keys.(example: if the ticket is for user:\"john\" for service:\"cifs/service.domain.local\", you need to supply credentials or keys of the service account who owns SPN \"cifs/service.domain.local\")'\n    ticket_decryption.add_argument('-p', '--password', action='store', metavar='PASSWORD', help='Cleartext password of the service account')\n    ticket_decryption.add_argument('-hp', '--hex-password', dest='hex_pass', action='store', metavar='HEXPASSWORD', help='Hex password of the service account')\n    ticket_decryption.add_argument('-u', '--user', action='store', metavar='USER', help='Name of the service account')\n    ticket_decryption.add_argument('-d', '--domain', action='store', metavar='DOMAIN', help='FQDN Domain')\n    ticket_decryption.add_argument('-s', '--salt', action='store', metavar='SALT', help='Salt for keys calculation (DOMAIN.LOCALSomeuser for users, DOMAIN.LOCALhostsomemachine.domain.local for machines)')\n    ticket_decryption.add_argument('--rc4', action='store', metavar='RC4', help='RC4 KEY (i.e. NT hash)')\n    ticket_decryption.add_argument('--aes', action='store', metavar='HEXKEY', help='AES128 or AES256 key')\n    credential_info = parser.add_argument_group()\n    credential_info.title = 'PAC Credentials decryption material'\n    credential_info.description = '[MS-PAC] section 2.6 (PAC Credentials) describes an element that is used to send credentials for alternate security protocols to the client during initial logon.This PAC credentials is typically used when PKINIT is conducted for pre-authentication. This structure contains LM and NT hashes.The information is encrypted using the AS reply key. Attack primitive known as UnPAC-the-Hash. (https://www.thehacker.recipes/ad/movement/kerberos/unpac-the-hash)'\n    credential_info.add_argument('--asrep-key', action='store', metavar='HEXKEY', help='AS reply key for PAC Credentials decryption')\n    if len(sys.argv) == 1:\n        parser.print_help()\n        sys.exit(1)\n    args = parser.parse_args()\n    if not args.salt:\n        if args.user and (not args.domain):\n            parser.error('without -s/--salt, and with -u/--user, argument -d/--domain is required to calculate the salt')\n        elif not args.user and args.domain:\n            parser.error('without -s/--salt, and with -d/--domain, argument -u/--user is required to calculate the salt')\n    if args.domain and (not '.' in args.domain):\n        parser.error('Domain supplied in -d/--domain should be FQDN')\n    return args",
            "def parse_args():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    parser = argparse.ArgumentParser(add_help=True, description='Ticket describer. Parses ticket, decrypts the enc-part, and parses the PAC.')\n    parser.add_argument('ticket', action='store', help='Path to ticket.ccache')\n    parser.add_argument('-debug', action='store_true', help='Turn DEBUG output ON')\n    parser.add_argument('-ts', action='store_true', help='Adds timestamp to every logging output')\n    ticket_decryption = parser.add_argument_group()\n    ticket_decryption.title = 'Ticket decryption credentials (optional)'\n    ticket_decryption.description = 'Tickets carry a set of information encrypted by one of the target service account\\'s Kerberos keys.(example: if the ticket is for user:\"john\" for service:\"cifs/service.domain.local\", you need to supply credentials or keys of the service account who owns SPN \"cifs/service.domain.local\")'\n    ticket_decryption.add_argument('-p', '--password', action='store', metavar='PASSWORD', help='Cleartext password of the service account')\n    ticket_decryption.add_argument('-hp', '--hex-password', dest='hex_pass', action='store', metavar='HEXPASSWORD', help='Hex password of the service account')\n    ticket_decryption.add_argument('-u', '--user', action='store', metavar='USER', help='Name of the service account')\n    ticket_decryption.add_argument('-d', '--domain', action='store', metavar='DOMAIN', help='FQDN Domain')\n    ticket_decryption.add_argument('-s', '--salt', action='store', metavar='SALT', help='Salt for keys calculation (DOMAIN.LOCALSomeuser for users, DOMAIN.LOCALhostsomemachine.domain.local for machines)')\n    ticket_decryption.add_argument('--rc4', action='store', metavar='RC4', help='RC4 KEY (i.e. NT hash)')\n    ticket_decryption.add_argument('--aes', action='store', metavar='HEXKEY', help='AES128 or AES256 key')\n    credential_info = parser.add_argument_group()\n    credential_info.title = 'PAC Credentials decryption material'\n    credential_info.description = '[MS-PAC] section 2.6 (PAC Credentials) describes an element that is used to send credentials for alternate security protocols to the client during initial logon.This PAC credentials is typically used when PKINIT is conducted for pre-authentication. This structure contains LM and NT hashes.The information is encrypted using the AS reply key. Attack primitive known as UnPAC-the-Hash. (https://www.thehacker.recipes/ad/movement/kerberos/unpac-the-hash)'\n    credential_info.add_argument('--asrep-key', action='store', metavar='HEXKEY', help='AS reply key for PAC Credentials decryption')\n    if len(sys.argv) == 1:\n        parser.print_help()\n        sys.exit(1)\n    args = parser.parse_args()\n    if not args.salt:\n        if args.user and (not args.domain):\n            parser.error('without -s/--salt, and with -u/--user, argument -d/--domain is required to calculate the salt')\n        elif not args.user and args.domain:\n            parser.error('without -s/--salt, and with -d/--domain, argument -u/--user is required to calculate the salt')\n    if args.domain and (not '.' in args.domain):\n        parser.error('Domain supplied in -d/--domain should be FQDN')\n    return args",
            "def parse_args():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    parser = argparse.ArgumentParser(add_help=True, description='Ticket describer. Parses ticket, decrypts the enc-part, and parses the PAC.')\n    parser.add_argument('ticket', action='store', help='Path to ticket.ccache')\n    parser.add_argument('-debug', action='store_true', help='Turn DEBUG output ON')\n    parser.add_argument('-ts', action='store_true', help='Adds timestamp to every logging output')\n    ticket_decryption = parser.add_argument_group()\n    ticket_decryption.title = 'Ticket decryption credentials (optional)'\n    ticket_decryption.description = 'Tickets carry a set of information encrypted by one of the target service account\\'s Kerberos keys.(example: if the ticket is for user:\"john\" for service:\"cifs/service.domain.local\", you need to supply credentials or keys of the service account who owns SPN \"cifs/service.domain.local\")'\n    ticket_decryption.add_argument('-p', '--password', action='store', metavar='PASSWORD', help='Cleartext password of the service account')\n    ticket_decryption.add_argument('-hp', '--hex-password', dest='hex_pass', action='store', metavar='HEXPASSWORD', help='Hex password of the service account')\n    ticket_decryption.add_argument('-u', '--user', action='store', metavar='USER', help='Name of the service account')\n    ticket_decryption.add_argument('-d', '--domain', action='store', metavar='DOMAIN', help='FQDN Domain')\n    ticket_decryption.add_argument('-s', '--salt', action='store', metavar='SALT', help='Salt for keys calculation (DOMAIN.LOCALSomeuser for users, DOMAIN.LOCALhostsomemachine.domain.local for machines)')\n    ticket_decryption.add_argument('--rc4', action='store', metavar='RC4', help='RC4 KEY (i.e. NT hash)')\n    ticket_decryption.add_argument('--aes', action='store', metavar='HEXKEY', help='AES128 or AES256 key')\n    credential_info = parser.add_argument_group()\n    credential_info.title = 'PAC Credentials decryption material'\n    credential_info.description = '[MS-PAC] section 2.6 (PAC Credentials) describes an element that is used to send credentials for alternate security protocols to the client during initial logon.This PAC credentials is typically used when PKINIT is conducted for pre-authentication. This structure contains LM and NT hashes.The information is encrypted using the AS reply key. Attack primitive known as UnPAC-the-Hash. (https://www.thehacker.recipes/ad/movement/kerberos/unpac-the-hash)'\n    credential_info.add_argument('--asrep-key', action='store', metavar='HEXKEY', help='AS reply key for PAC Credentials decryption')\n    if len(sys.argv) == 1:\n        parser.print_help()\n        sys.exit(1)\n    args = parser.parse_args()\n    if not args.salt:\n        if args.user and (not args.domain):\n            parser.error('without -s/--salt, and with -u/--user, argument -d/--domain is required to calculate the salt')\n        elif not args.user and args.domain:\n            parser.error('without -s/--salt, and with -d/--domain, argument -u/--user is required to calculate the salt')\n    if args.domain and (not '.' in args.domain):\n        parser.error('Domain supplied in -d/--domain should be FQDN')\n    return args",
            "def parse_args():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    parser = argparse.ArgumentParser(add_help=True, description='Ticket describer. Parses ticket, decrypts the enc-part, and parses the PAC.')\n    parser.add_argument('ticket', action='store', help='Path to ticket.ccache')\n    parser.add_argument('-debug', action='store_true', help='Turn DEBUG output ON')\n    parser.add_argument('-ts', action='store_true', help='Adds timestamp to every logging output')\n    ticket_decryption = parser.add_argument_group()\n    ticket_decryption.title = 'Ticket decryption credentials (optional)'\n    ticket_decryption.description = 'Tickets carry a set of information encrypted by one of the target service account\\'s Kerberos keys.(example: if the ticket is for user:\"john\" for service:\"cifs/service.domain.local\", you need to supply credentials or keys of the service account who owns SPN \"cifs/service.domain.local\")'\n    ticket_decryption.add_argument('-p', '--password', action='store', metavar='PASSWORD', help='Cleartext password of the service account')\n    ticket_decryption.add_argument('-hp', '--hex-password', dest='hex_pass', action='store', metavar='HEXPASSWORD', help='Hex password of the service account')\n    ticket_decryption.add_argument('-u', '--user', action='store', metavar='USER', help='Name of the service account')\n    ticket_decryption.add_argument('-d', '--domain', action='store', metavar='DOMAIN', help='FQDN Domain')\n    ticket_decryption.add_argument('-s', '--salt', action='store', metavar='SALT', help='Salt for keys calculation (DOMAIN.LOCALSomeuser for users, DOMAIN.LOCALhostsomemachine.domain.local for machines)')\n    ticket_decryption.add_argument('--rc4', action='store', metavar='RC4', help='RC4 KEY (i.e. NT hash)')\n    ticket_decryption.add_argument('--aes', action='store', metavar='HEXKEY', help='AES128 or AES256 key')\n    credential_info = parser.add_argument_group()\n    credential_info.title = 'PAC Credentials decryption material'\n    credential_info.description = '[MS-PAC] section 2.6 (PAC Credentials) describes an element that is used to send credentials for alternate security protocols to the client during initial logon.This PAC credentials is typically used when PKINIT is conducted for pre-authentication. This structure contains LM and NT hashes.The information is encrypted using the AS reply key. Attack primitive known as UnPAC-the-Hash. (https://www.thehacker.recipes/ad/movement/kerberos/unpac-the-hash)'\n    credential_info.add_argument('--asrep-key', action='store', metavar='HEXKEY', help='AS reply key for PAC Credentials decryption')\n    if len(sys.argv) == 1:\n        parser.print_help()\n        sys.exit(1)\n    args = parser.parse_args()\n    if not args.salt:\n        if args.user and (not args.domain):\n            parser.error('without -s/--salt, and with -u/--user, argument -d/--domain is required to calculate the salt')\n        elif not args.user and args.domain:\n            parser.error('without -s/--salt, and with -d/--domain, argument -u/--user is required to calculate the salt')\n    if args.domain and (not '.' in args.domain):\n        parser.error('Domain supplied in -d/--domain should be FQDN')\n    return args",
            "def parse_args():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    parser = argparse.ArgumentParser(add_help=True, description='Ticket describer. Parses ticket, decrypts the enc-part, and parses the PAC.')\n    parser.add_argument('ticket', action='store', help='Path to ticket.ccache')\n    parser.add_argument('-debug', action='store_true', help='Turn DEBUG output ON')\n    parser.add_argument('-ts', action='store_true', help='Adds timestamp to every logging output')\n    ticket_decryption = parser.add_argument_group()\n    ticket_decryption.title = 'Ticket decryption credentials (optional)'\n    ticket_decryption.description = 'Tickets carry a set of information encrypted by one of the target service account\\'s Kerberos keys.(example: if the ticket is for user:\"john\" for service:\"cifs/service.domain.local\", you need to supply credentials or keys of the service account who owns SPN \"cifs/service.domain.local\")'\n    ticket_decryption.add_argument('-p', '--password', action='store', metavar='PASSWORD', help='Cleartext password of the service account')\n    ticket_decryption.add_argument('-hp', '--hex-password', dest='hex_pass', action='store', metavar='HEXPASSWORD', help='Hex password of the service account')\n    ticket_decryption.add_argument('-u', '--user', action='store', metavar='USER', help='Name of the service account')\n    ticket_decryption.add_argument('-d', '--domain', action='store', metavar='DOMAIN', help='FQDN Domain')\n    ticket_decryption.add_argument('-s', '--salt', action='store', metavar='SALT', help='Salt for keys calculation (DOMAIN.LOCALSomeuser for users, DOMAIN.LOCALhostsomemachine.domain.local for machines)')\n    ticket_decryption.add_argument('--rc4', action='store', metavar='RC4', help='RC4 KEY (i.e. NT hash)')\n    ticket_decryption.add_argument('--aes', action='store', metavar='HEXKEY', help='AES128 or AES256 key')\n    credential_info = parser.add_argument_group()\n    credential_info.title = 'PAC Credentials decryption material'\n    credential_info.description = '[MS-PAC] section 2.6 (PAC Credentials) describes an element that is used to send credentials for alternate security protocols to the client during initial logon.This PAC credentials is typically used when PKINIT is conducted for pre-authentication. This structure contains LM and NT hashes.The information is encrypted using the AS reply key. Attack primitive known as UnPAC-the-Hash. (https://www.thehacker.recipes/ad/movement/kerberos/unpac-the-hash)'\n    credential_info.add_argument('--asrep-key', action='store', metavar='HEXKEY', help='AS reply key for PAC Credentials decryption')\n    if len(sys.argv) == 1:\n        parser.print_help()\n        sys.exit(1)\n    args = parser.parse_args()\n    if not args.salt:\n        if args.user and (not args.domain):\n            parser.error('without -s/--salt, and with -u/--user, argument -d/--domain is required to calculate the salt')\n        elif not args.user and args.domain:\n            parser.error('without -s/--salt, and with -d/--domain, argument -u/--user is required to calculate the salt')\n    if args.domain and (not '.' in args.domain):\n        parser.error('Domain supplied in -d/--domain should be FQDN')\n    return args"
        ]
    },
    {
        "func_name": "init_logger",
        "original": "def init_logger(args):\n    logger.init(args.ts)\n    if args.debug is True:\n        logging.getLogger().setLevel(logging.DEBUG)\n        logging.debug(version.getInstallationPath())\n    else:\n        logging.getLogger().setLevel(logging.INFO)\n        logging.getLogger('impacket.smbserver').setLevel(logging.ERROR)",
        "mutated": [
            "def init_logger(args):\n    if False:\n        i = 10\n    logger.init(args.ts)\n    if args.debug is True:\n        logging.getLogger().setLevel(logging.DEBUG)\n        logging.debug(version.getInstallationPath())\n    else:\n        logging.getLogger().setLevel(logging.INFO)\n        logging.getLogger('impacket.smbserver').setLevel(logging.ERROR)",
            "def init_logger(args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    logger.init(args.ts)\n    if args.debug is True:\n        logging.getLogger().setLevel(logging.DEBUG)\n        logging.debug(version.getInstallationPath())\n    else:\n        logging.getLogger().setLevel(logging.INFO)\n        logging.getLogger('impacket.smbserver').setLevel(logging.ERROR)",
            "def init_logger(args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    logger.init(args.ts)\n    if args.debug is True:\n        logging.getLogger().setLevel(logging.DEBUG)\n        logging.debug(version.getInstallationPath())\n    else:\n        logging.getLogger().setLevel(logging.INFO)\n        logging.getLogger('impacket.smbserver').setLevel(logging.ERROR)",
            "def init_logger(args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    logger.init(args.ts)\n    if args.debug is True:\n        logging.getLogger().setLevel(logging.DEBUG)\n        logging.debug(version.getInstallationPath())\n    else:\n        logging.getLogger().setLevel(logging.INFO)\n        logging.getLogger('impacket.smbserver').setLevel(logging.ERROR)",
            "def init_logger(args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    logger.init(args.ts)\n    if args.debug is True:\n        logging.getLogger().setLevel(logging.DEBUG)\n        logging.debug(version.getInstallationPath())\n    else:\n        logging.getLogger().setLevel(logging.INFO)\n        logging.getLogger('impacket.smbserver').setLevel(logging.ERROR)"
        ]
    },
    {
        "func_name": "main",
        "original": "def main():\n    print(version.BANNER)\n    args = parse_args()\n    init_logger(args)\n    try:\n        parse_ccache(args)\n    except Exception as e:\n        if logging.getLogger().level == logging.DEBUG:\n            traceback.print_exc()\n        logging.error(str(e))",
        "mutated": [
            "def main():\n    if False:\n        i = 10\n    print(version.BANNER)\n    args = parse_args()\n    init_logger(args)\n    try:\n        parse_ccache(args)\n    except Exception as e:\n        if logging.getLogger().level == logging.DEBUG:\n            traceback.print_exc()\n        logging.error(str(e))",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    print(version.BANNER)\n    args = parse_args()\n    init_logger(args)\n    try:\n        parse_ccache(args)\n    except Exception as e:\n        if logging.getLogger().level == logging.DEBUG:\n            traceback.print_exc()\n        logging.error(str(e))",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    print(version.BANNER)\n    args = parse_args()\n    init_logger(args)\n    try:\n        parse_ccache(args)\n    except Exception as e:\n        if logging.getLogger().level == logging.DEBUG:\n            traceback.print_exc()\n        logging.error(str(e))",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    print(version.BANNER)\n    args = parse_args()\n    init_logger(args)\n    try:\n        parse_ccache(args)\n    except Exception as e:\n        if logging.getLogger().level == logging.DEBUG:\n            traceback.print_exc()\n        logging.error(str(e))",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    print(version.BANNER)\n    args = parse_args()\n    init_logger(args)\n    try:\n        parse_ccache(args)\n    except Exception as e:\n        if logging.getLogger().level == logging.DEBUG:\n            traceback.print_exc()\n        logging.error(str(e))"
        ]
    }
]