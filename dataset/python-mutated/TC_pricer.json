[
    {
        "func_name": "__init__",
        "original": "def __init__(self, Option_info, Process_info, cost_b=0, cost_s=0, gamma=0.001):\n    \"\"\"\n        Option_info:  of type Option_param. It contains (S0,K,T)\n        i.e. current price, strike, maturity in years\n\n        Process_info:  of type Diffusion_process.\n        It contains (r,mu, sig) i.e.  interest rate, drift coefficient, diffusion coeff\n        cost_b:  (lambda in the paper) BUY cost\n        cost_s: (mu in the paper)  SELL cost\n        gamma: risk avversion coefficient\n        \"\"\"\n    if Option_info.payoff == 'put':\n        raise ValueError('Not implemented for Put Options')\n    self.r = Process_info.r\n    self.mu = Process_info.mu\n    self.sig = Process_info.sig\n    self.S0 = Option_info.S0\n    self.K = Option_info.K\n    self.T = Option_info.T\n    self.cost_b = cost_b\n    self.cost_s = cost_s\n    self.gamma = gamma",
        "mutated": [
            "def __init__(self, Option_info, Process_info, cost_b=0, cost_s=0, gamma=0.001):\n    if False:\n        i = 10\n    '\\n        Option_info:  of type Option_param. It contains (S0,K,T)\\n        i.e. current price, strike, maturity in years\\n\\n        Process_info:  of type Diffusion_process.\\n        It contains (r,mu, sig) i.e.  interest rate, drift coefficient, diffusion coeff\\n        cost_b:  (lambda in the paper) BUY cost\\n        cost_s: (mu in the paper)  SELL cost\\n        gamma: risk avversion coefficient\\n        '\n    if Option_info.payoff == 'put':\n        raise ValueError('Not implemented for Put Options')\n    self.r = Process_info.r\n    self.mu = Process_info.mu\n    self.sig = Process_info.sig\n    self.S0 = Option_info.S0\n    self.K = Option_info.K\n    self.T = Option_info.T\n    self.cost_b = cost_b\n    self.cost_s = cost_s\n    self.gamma = gamma",
            "def __init__(self, Option_info, Process_info, cost_b=0, cost_s=0, gamma=0.001):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Option_info:  of type Option_param. It contains (S0,K,T)\\n        i.e. current price, strike, maturity in years\\n\\n        Process_info:  of type Diffusion_process.\\n        It contains (r,mu, sig) i.e.  interest rate, drift coefficient, diffusion coeff\\n        cost_b:  (lambda in the paper) BUY cost\\n        cost_s: (mu in the paper)  SELL cost\\n        gamma: risk avversion coefficient\\n        '\n    if Option_info.payoff == 'put':\n        raise ValueError('Not implemented for Put Options')\n    self.r = Process_info.r\n    self.mu = Process_info.mu\n    self.sig = Process_info.sig\n    self.S0 = Option_info.S0\n    self.K = Option_info.K\n    self.T = Option_info.T\n    self.cost_b = cost_b\n    self.cost_s = cost_s\n    self.gamma = gamma",
            "def __init__(self, Option_info, Process_info, cost_b=0, cost_s=0, gamma=0.001):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Option_info:  of type Option_param. It contains (S0,K,T)\\n        i.e. current price, strike, maturity in years\\n\\n        Process_info:  of type Diffusion_process.\\n        It contains (r,mu, sig) i.e.  interest rate, drift coefficient, diffusion coeff\\n        cost_b:  (lambda in the paper) BUY cost\\n        cost_s: (mu in the paper)  SELL cost\\n        gamma: risk avversion coefficient\\n        '\n    if Option_info.payoff == 'put':\n        raise ValueError('Not implemented for Put Options')\n    self.r = Process_info.r\n    self.mu = Process_info.mu\n    self.sig = Process_info.sig\n    self.S0 = Option_info.S0\n    self.K = Option_info.K\n    self.T = Option_info.T\n    self.cost_b = cost_b\n    self.cost_s = cost_s\n    self.gamma = gamma",
            "def __init__(self, Option_info, Process_info, cost_b=0, cost_s=0, gamma=0.001):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Option_info:  of type Option_param. It contains (S0,K,T)\\n        i.e. current price, strike, maturity in years\\n\\n        Process_info:  of type Diffusion_process.\\n        It contains (r,mu, sig) i.e.  interest rate, drift coefficient, diffusion coeff\\n        cost_b:  (lambda in the paper) BUY cost\\n        cost_s: (mu in the paper)  SELL cost\\n        gamma: risk avversion coefficient\\n        '\n    if Option_info.payoff == 'put':\n        raise ValueError('Not implemented for Put Options')\n    self.r = Process_info.r\n    self.mu = Process_info.mu\n    self.sig = Process_info.sig\n    self.S0 = Option_info.S0\n    self.K = Option_info.K\n    self.T = Option_info.T\n    self.cost_b = cost_b\n    self.cost_s = cost_s\n    self.gamma = gamma",
            "def __init__(self, Option_info, Process_info, cost_b=0, cost_s=0, gamma=0.001):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Option_info:  of type Option_param. It contains (S0,K,T)\\n        i.e. current price, strike, maturity in years\\n\\n        Process_info:  of type Diffusion_process.\\n        It contains (r,mu, sig) i.e.  interest rate, drift coefficient, diffusion coeff\\n        cost_b:  (lambda in the paper) BUY cost\\n        cost_s: (mu in the paper)  SELL cost\\n        gamma: risk avversion coefficient\\n        '\n    if Option_info.payoff == 'put':\n        raise ValueError('Not implemented for Put Options')\n    self.r = Process_info.r\n    self.mu = Process_info.mu\n    self.sig = Process_info.sig\n    self.S0 = Option_info.S0\n    self.K = Option_info.K\n    self.T = Option_info.T\n    self.cost_b = cost_b\n    self.cost_s = cost_s\n    self.gamma = gamma"
        ]
    },
    {
        "func_name": "F",
        "original": "def F(xx, ll, nn):\n    return np.exp(self.gamma * (1 + self.cost_b) * np.exp(xx) * ll / delta[nn])",
        "mutated": [
            "def F(xx, ll, nn):\n    if False:\n        i = 10\n    return np.exp(self.gamma * (1 + self.cost_b) * np.exp(xx) * ll / delta[nn])",
            "def F(xx, ll, nn):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return np.exp(self.gamma * (1 + self.cost_b) * np.exp(xx) * ll / delta[nn])",
            "def F(xx, ll, nn):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return np.exp(self.gamma * (1 + self.cost_b) * np.exp(xx) * ll / delta[nn])",
            "def F(xx, ll, nn):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return np.exp(self.gamma * (1 + self.cost_b) * np.exp(xx) * ll / delta[nn])",
            "def F(xx, ll, nn):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return np.exp(self.gamma * (1 + self.cost_b) * np.exp(xx) * ll / delta[nn])"
        ]
    },
    {
        "func_name": "G",
        "original": "def G(xx, mm, nn):\n    return np.exp(-self.gamma * (1 - self.cost_s) * np.exp(xx) * mm / delta[nn])",
        "mutated": [
            "def G(xx, mm, nn):\n    if False:\n        i = 10\n    return np.exp(-self.gamma * (1 - self.cost_s) * np.exp(xx) * mm / delta[nn])",
            "def G(xx, mm, nn):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return np.exp(-self.gamma * (1 - self.cost_s) * np.exp(xx) * mm / delta[nn])",
            "def G(xx, mm, nn):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return np.exp(-self.gamma * (1 - self.cost_s) * np.exp(xx) * mm / delta[nn])",
            "def G(xx, mm, nn):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return np.exp(-self.gamma * (1 - self.cost_s) * np.exp(xx) * mm / delta[nn])",
            "def G(xx, mm, nn):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return np.exp(-self.gamma * (1 - self.cost_s) * np.exp(xx) * mm / delta[nn])"
        ]
    },
    {
        "func_name": "price",
        "original": "def price(self, N=500, TYPE='writer', Time=False):\n    \"\"\"\n        N =  number of time steps\n        TYPE writer or buyer\n        Time: Boolean\n        \"\"\"\n    t = time()\n    np.seterr(all='ignore')\n    x0 = np.log(self.S0)\n    (T_vec, dt) = np.linspace(0, self.T, N + 1, retstep=True)\n    delta = np.exp(-self.r * (self.T - T_vec))\n    dx = self.sig * np.sqrt(dt)\n    dy = dx\n    M = int(np.floor(N / 2))\n    y = np.linspace(-M * dy, M * dy, 2 * M + 1)\n    N_y = len(y)\n    med = np.where(y == 0)[0].item()\n\n    def F(xx, ll, nn):\n        return np.exp(self.gamma * (1 + self.cost_b) * np.exp(xx) * ll / delta[nn])\n\n    def G(xx, mm, nn):\n        return np.exp(-self.gamma * (1 - self.cost_s) * np.exp(xx) * mm / delta[nn])\n    for portfolio in ['no_opt', TYPE]:\n        x = np.array([x0 + (self.mu - 0.5 * self.sig ** 2) * dt * N + (2 * i - N) * dx for i in range(N + 1)])\n        if portfolio == 'no_opt':\n            Q = np.exp(-self.gamma * cost.no_opt(x, y, self.cost_b, self.cost_s))\n        elif portfolio == 'writer':\n            Q = np.exp(-self.gamma * cost.writer(x, y, self.cost_b, self.cost_s, self.K))\n        elif portfolio == 'buyer':\n            Q = np.exp(-self.gamma * cost.buyer(x, y, self.cost_b, self.cost_s, self.K))\n        else:\n            raise ValueError('TYPE can be only writer or buyer')\n        for k in range(N - 1, -1, -1):\n            Q_new = (Q[:-1, :] + Q[1:, :]) / 2\n            x = np.array([x0 + (self.mu - 0.5 * self.sig ** 2) * dt * k + (2 * i - k) * dx for i in range(k + 1)])\n            Buy = np.copy(Q_new)\n            Buy[:, :-1] = np.matlib.repmat(F(x, dy, k), N_y - 1, 1).T * Q_new[:, 1:]\n            Sell = np.copy(Q_new)\n            Sell[:, 1:] = np.matlib.repmat(G(x, dy, k), N_y - 1, 1).T * Q_new[:, :-1]\n            Q = np.minimum(np.minimum(Buy, Sell), Q_new)\n        if portfolio == 'no_opt':\n            Q_no = Q[0, med]\n        else:\n            Q_yes = Q[0, med]\n    if TYPE == 'writer':\n        price = delta[0] / self.gamma * np.log(Q_yes / Q_no)\n    else:\n        price = delta[0] / self.gamma * np.log(Q_no / Q_yes)\n    if Time is True:\n        elapsed = time() - t\n        return (price, elapsed)\n    else:\n        return price",
        "mutated": [
            "def price(self, N=500, TYPE='writer', Time=False):\n    if False:\n        i = 10\n    '\\n        N =  number of time steps\\n        TYPE writer or buyer\\n        Time: Boolean\\n        '\n    t = time()\n    np.seterr(all='ignore')\n    x0 = np.log(self.S0)\n    (T_vec, dt) = np.linspace(0, self.T, N + 1, retstep=True)\n    delta = np.exp(-self.r * (self.T - T_vec))\n    dx = self.sig * np.sqrt(dt)\n    dy = dx\n    M = int(np.floor(N / 2))\n    y = np.linspace(-M * dy, M * dy, 2 * M + 1)\n    N_y = len(y)\n    med = np.where(y == 0)[0].item()\n\n    def F(xx, ll, nn):\n        return np.exp(self.gamma * (1 + self.cost_b) * np.exp(xx) * ll / delta[nn])\n\n    def G(xx, mm, nn):\n        return np.exp(-self.gamma * (1 - self.cost_s) * np.exp(xx) * mm / delta[nn])\n    for portfolio in ['no_opt', TYPE]:\n        x = np.array([x0 + (self.mu - 0.5 * self.sig ** 2) * dt * N + (2 * i - N) * dx for i in range(N + 1)])\n        if portfolio == 'no_opt':\n            Q = np.exp(-self.gamma * cost.no_opt(x, y, self.cost_b, self.cost_s))\n        elif portfolio == 'writer':\n            Q = np.exp(-self.gamma * cost.writer(x, y, self.cost_b, self.cost_s, self.K))\n        elif portfolio == 'buyer':\n            Q = np.exp(-self.gamma * cost.buyer(x, y, self.cost_b, self.cost_s, self.K))\n        else:\n            raise ValueError('TYPE can be only writer or buyer')\n        for k in range(N - 1, -1, -1):\n            Q_new = (Q[:-1, :] + Q[1:, :]) / 2\n            x = np.array([x0 + (self.mu - 0.5 * self.sig ** 2) * dt * k + (2 * i - k) * dx for i in range(k + 1)])\n            Buy = np.copy(Q_new)\n            Buy[:, :-1] = np.matlib.repmat(F(x, dy, k), N_y - 1, 1).T * Q_new[:, 1:]\n            Sell = np.copy(Q_new)\n            Sell[:, 1:] = np.matlib.repmat(G(x, dy, k), N_y - 1, 1).T * Q_new[:, :-1]\n            Q = np.minimum(np.minimum(Buy, Sell), Q_new)\n        if portfolio == 'no_opt':\n            Q_no = Q[0, med]\n        else:\n            Q_yes = Q[0, med]\n    if TYPE == 'writer':\n        price = delta[0] / self.gamma * np.log(Q_yes / Q_no)\n    else:\n        price = delta[0] / self.gamma * np.log(Q_no / Q_yes)\n    if Time is True:\n        elapsed = time() - t\n        return (price, elapsed)\n    else:\n        return price",
            "def price(self, N=500, TYPE='writer', Time=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        N =  number of time steps\\n        TYPE writer or buyer\\n        Time: Boolean\\n        '\n    t = time()\n    np.seterr(all='ignore')\n    x0 = np.log(self.S0)\n    (T_vec, dt) = np.linspace(0, self.T, N + 1, retstep=True)\n    delta = np.exp(-self.r * (self.T - T_vec))\n    dx = self.sig * np.sqrt(dt)\n    dy = dx\n    M = int(np.floor(N / 2))\n    y = np.linspace(-M * dy, M * dy, 2 * M + 1)\n    N_y = len(y)\n    med = np.where(y == 0)[0].item()\n\n    def F(xx, ll, nn):\n        return np.exp(self.gamma * (1 + self.cost_b) * np.exp(xx) * ll / delta[nn])\n\n    def G(xx, mm, nn):\n        return np.exp(-self.gamma * (1 - self.cost_s) * np.exp(xx) * mm / delta[nn])\n    for portfolio in ['no_opt', TYPE]:\n        x = np.array([x0 + (self.mu - 0.5 * self.sig ** 2) * dt * N + (2 * i - N) * dx for i in range(N + 1)])\n        if portfolio == 'no_opt':\n            Q = np.exp(-self.gamma * cost.no_opt(x, y, self.cost_b, self.cost_s))\n        elif portfolio == 'writer':\n            Q = np.exp(-self.gamma * cost.writer(x, y, self.cost_b, self.cost_s, self.K))\n        elif portfolio == 'buyer':\n            Q = np.exp(-self.gamma * cost.buyer(x, y, self.cost_b, self.cost_s, self.K))\n        else:\n            raise ValueError('TYPE can be only writer or buyer')\n        for k in range(N - 1, -1, -1):\n            Q_new = (Q[:-1, :] + Q[1:, :]) / 2\n            x = np.array([x0 + (self.mu - 0.5 * self.sig ** 2) * dt * k + (2 * i - k) * dx for i in range(k + 1)])\n            Buy = np.copy(Q_new)\n            Buy[:, :-1] = np.matlib.repmat(F(x, dy, k), N_y - 1, 1).T * Q_new[:, 1:]\n            Sell = np.copy(Q_new)\n            Sell[:, 1:] = np.matlib.repmat(G(x, dy, k), N_y - 1, 1).T * Q_new[:, :-1]\n            Q = np.minimum(np.minimum(Buy, Sell), Q_new)\n        if portfolio == 'no_opt':\n            Q_no = Q[0, med]\n        else:\n            Q_yes = Q[0, med]\n    if TYPE == 'writer':\n        price = delta[0] / self.gamma * np.log(Q_yes / Q_no)\n    else:\n        price = delta[0] / self.gamma * np.log(Q_no / Q_yes)\n    if Time is True:\n        elapsed = time() - t\n        return (price, elapsed)\n    else:\n        return price",
            "def price(self, N=500, TYPE='writer', Time=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        N =  number of time steps\\n        TYPE writer or buyer\\n        Time: Boolean\\n        '\n    t = time()\n    np.seterr(all='ignore')\n    x0 = np.log(self.S0)\n    (T_vec, dt) = np.linspace(0, self.T, N + 1, retstep=True)\n    delta = np.exp(-self.r * (self.T - T_vec))\n    dx = self.sig * np.sqrt(dt)\n    dy = dx\n    M = int(np.floor(N / 2))\n    y = np.linspace(-M * dy, M * dy, 2 * M + 1)\n    N_y = len(y)\n    med = np.where(y == 0)[0].item()\n\n    def F(xx, ll, nn):\n        return np.exp(self.gamma * (1 + self.cost_b) * np.exp(xx) * ll / delta[nn])\n\n    def G(xx, mm, nn):\n        return np.exp(-self.gamma * (1 - self.cost_s) * np.exp(xx) * mm / delta[nn])\n    for portfolio in ['no_opt', TYPE]:\n        x = np.array([x0 + (self.mu - 0.5 * self.sig ** 2) * dt * N + (2 * i - N) * dx for i in range(N + 1)])\n        if portfolio == 'no_opt':\n            Q = np.exp(-self.gamma * cost.no_opt(x, y, self.cost_b, self.cost_s))\n        elif portfolio == 'writer':\n            Q = np.exp(-self.gamma * cost.writer(x, y, self.cost_b, self.cost_s, self.K))\n        elif portfolio == 'buyer':\n            Q = np.exp(-self.gamma * cost.buyer(x, y, self.cost_b, self.cost_s, self.K))\n        else:\n            raise ValueError('TYPE can be only writer or buyer')\n        for k in range(N - 1, -1, -1):\n            Q_new = (Q[:-1, :] + Q[1:, :]) / 2\n            x = np.array([x0 + (self.mu - 0.5 * self.sig ** 2) * dt * k + (2 * i - k) * dx for i in range(k + 1)])\n            Buy = np.copy(Q_new)\n            Buy[:, :-1] = np.matlib.repmat(F(x, dy, k), N_y - 1, 1).T * Q_new[:, 1:]\n            Sell = np.copy(Q_new)\n            Sell[:, 1:] = np.matlib.repmat(G(x, dy, k), N_y - 1, 1).T * Q_new[:, :-1]\n            Q = np.minimum(np.minimum(Buy, Sell), Q_new)\n        if portfolio == 'no_opt':\n            Q_no = Q[0, med]\n        else:\n            Q_yes = Q[0, med]\n    if TYPE == 'writer':\n        price = delta[0] / self.gamma * np.log(Q_yes / Q_no)\n    else:\n        price = delta[0] / self.gamma * np.log(Q_no / Q_yes)\n    if Time is True:\n        elapsed = time() - t\n        return (price, elapsed)\n    else:\n        return price",
            "def price(self, N=500, TYPE='writer', Time=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        N =  number of time steps\\n        TYPE writer or buyer\\n        Time: Boolean\\n        '\n    t = time()\n    np.seterr(all='ignore')\n    x0 = np.log(self.S0)\n    (T_vec, dt) = np.linspace(0, self.T, N + 1, retstep=True)\n    delta = np.exp(-self.r * (self.T - T_vec))\n    dx = self.sig * np.sqrt(dt)\n    dy = dx\n    M = int(np.floor(N / 2))\n    y = np.linspace(-M * dy, M * dy, 2 * M + 1)\n    N_y = len(y)\n    med = np.where(y == 0)[0].item()\n\n    def F(xx, ll, nn):\n        return np.exp(self.gamma * (1 + self.cost_b) * np.exp(xx) * ll / delta[nn])\n\n    def G(xx, mm, nn):\n        return np.exp(-self.gamma * (1 - self.cost_s) * np.exp(xx) * mm / delta[nn])\n    for portfolio in ['no_opt', TYPE]:\n        x = np.array([x0 + (self.mu - 0.5 * self.sig ** 2) * dt * N + (2 * i - N) * dx for i in range(N + 1)])\n        if portfolio == 'no_opt':\n            Q = np.exp(-self.gamma * cost.no_opt(x, y, self.cost_b, self.cost_s))\n        elif portfolio == 'writer':\n            Q = np.exp(-self.gamma * cost.writer(x, y, self.cost_b, self.cost_s, self.K))\n        elif portfolio == 'buyer':\n            Q = np.exp(-self.gamma * cost.buyer(x, y, self.cost_b, self.cost_s, self.K))\n        else:\n            raise ValueError('TYPE can be only writer or buyer')\n        for k in range(N - 1, -1, -1):\n            Q_new = (Q[:-1, :] + Q[1:, :]) / 2\n            x = np.array([x0 + (self.mu - 0.5 * self.sig ** 2) * dt * k + (2 * i - k) * dx for i in range(k + 1)])\n            Buy = np.copy(Q_new)\n            Buy[:, :-1] = np.matlib.repmat(F(x, dy, k), N_y - 1, 1).T * Q_new[:, 1:]\n            Sell = np.copy(Q_new)\n            Sell[:, 1:] = np.matlib.repmat(G(x, dy, k), N_y - 1, 1).T * Q_new[:, :-1]\n            Q = np.minimum(np.minimum(Buy, Sell), Q_new)\n        if portfolio == 'no_opt':\n            Q_no = Q[0, med]\n        else:\n            Q_yes = Q[0, med]\n    if TYPE == 'writer':\n        price = delta[0] / self.gamma * np.log(Q_yes / Q_no)\n    else:\n        price = delta[0] / self.gamma * np.log(Q_no / Q_yes)\n    if Time is True:\n        elapsed = time() - t\n        return (price, elapsed)\n    else:\n        return price",
            "def price(self, N=500, TYPE='writer', Time=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        N =  number of time steps\\n        TYPE writer or buyer\\n        Time: Boolean\\n        '\n    t = time()\n    np.seterr(all='ignore')\n    x0 = np.log(self.S0)\n    (T_vec, dt) = np.linspace(0, self.T, N + 1, retstep=True)\n    delta = np.exp(-self.r * (self.T - T_vec))\n    dx = self.sig * np.sqrt(dt)\n    dy = dx\n    M = int(np.floor(N / 2))\n    y = np.linspace(-M * dy, M * dy, 2 * M + 1)\n    N_y = len(y)\n    med = np.where(y == 0)[0].item()\n\n    def F(xx, ll, nn):\n        return np.exp(self.gamma * (1 + self.cost_b) * np.exp(xx) * ll / delta[nn])\n\n    def G(xx, mm, nn):\n        return np.exp(-self.gamma * (1 - self.cost_s) * np.exp(xx) * mm / delta[nn])\n    for portfolio in ['no_opt', TYPE]:\n        x = np.array([x0 + (self.mu - 0.5 * self.sig ** 2) * dt * N + (2 * i - N) * dx for i in range(N + 1)])\n        if portfolio == 'no_opt':\n            Q = np.exp(-self.gamma * cost.no_opt(x, y, self.cost_b, self.cost_s))\n        elif portfolio == 'writer':\n            Q = np.exp(-self.gamma * cost.writer(x, y, self.cost_b, self.cost_s, self.K))\n        elif portfolio == 'buyer':\n            Q = np.exp(-self.gamma * cost.buyer(x, y, self.cost_b, self.cost_s, self.K))\n        else:\n            raise ValueError('TYPE can be only writer or buyer')\n        for k in range(N - 1, -1, -1):\n            Q_new = (Q[:-1, :] + Q[1:, :]) / 2\n            x = np.array([x0 + (self.mu - 0.5 * self.sig ** 2) * dt * k + (2 * i - k) * dx for i in range(k + 1)])\n            Buy = np.copy(Q_new)\n            Buy[:, :-1] = np.matlib.repmat(F(x, dy, k), N_y - 1, 1).T * Q_new[:, 1:]\n            Sell = np.copy(Q_new)\n            Sell[:, 1:] = np.matlib.repmat(G(x, dy, k), N_y - 1, 1).T * Q_new[:, :-1]\n            Q = np.minimum(np.minimum(Buy, Sell), Q_new)\n        if portfolio == 'no_opt':\n            Q_no = Q[0, med]\n        else:\n            Q_yes = Q[0, med]\n    if TYPE == 'writer':\n        price = delta[0] / self.gamma * np.log(Q_yes / Q_no)\n    else:\n        price = delta[0] / self.gamma * np.log(Q_no / Q_yes)\n    if Time is True:\n        elapsed = time() - t\n        return (price, elapsed)\n    else:\n        return price"
        ]
    }
]