rest_api_version = 3

def update_param(name, param):
    if False:
        while True:
            i = 10
    if name == 'algorithm_params':
        param['default_value'] = None
        return param
    return None
extensions = dict(required_params=['x', 'y', 'training_frame'], set_required_params='\n    parms$training_frame <- training_frame\n    args <- .verify_dataxy(training_frame, x, y)\n    if (missing(protected_columns)) { \n      # core infogram\n      if (!missing(safety_index_threshold)) {\n        warning("Should not set safety_index_threshold for Core Infogram runs. Set net_information_threshold instead.")\n      }\n      if (!missing(relevance_index_threshold)) {\n        warning("Should not set relevance_index_threshold for Core Infogram runs. Set total_information_threshold instead.")\n      }\n    } else { \n      # fair infogram\n      if (!missing(net_information_threshold)) {\n      warning("Should not set net_information_threshold for Fair Infogram runs, set safety_index_threshold instead.")\n      }\n      if (!missing(total_information_threshold)) {\n        warning("Should not set total_information_threshold for Fair Infogram runs, set relevance_index_threshold instead.")\n      }\n    }\n    \n    if (!missing(offset_column) && !is.null(offset_column))  args$x_ignore <- args$x_ignore[!( offset_column == args$x_ignore )]\n    if (!missing(weights_column) && !is.null(weights_column)) args$x_ignore <- args$x_ignore[!( weights_column == args$x_ignore )]\n    if (!missing(fold_column) && !is.null(fold_column)) args$x_ignore <- args$x_ignore[!( fold_column == args$x_ignore )]\n    parms$ignored_columns <- args$x_ignore\n    parms$response_column <- args$y\n    ', skip_default_set_params_for=['training_frame', 'ignored_columns', 'response_column', 'max_confusion_matrix_size', 'algorithm_params'], set_params='\nif (!missing(algorithm_params))\n    parms$algorithm_params <- as.character(toJSON(algorithm_params, pretty = TRUE))\n', with_model='\n# Convert algorithm_params back to list if not NULL, added after obtaining model\nif (!missing(algorithm_params)) {\n    model@parameters$algorithm_params <- list(fromJSON(model@parameters$algorithm_params))[[1]] #Need the `[[ ]]` to avoid a nested list\n}\n\ninfogram_model <- new("H2OInfogram", model_id=model@model_id)       \nmodel <- infogram_model                \n', module='\n#\' Plot an H2O Infogram\n#\'\n#\' Plots the Infogram for an H2OInfogram object.\n#\'\n#\' @param x A fitted \\linkS4class{H2OInfogram} object.\n#\' @param ... additional arguments to pass on.\n#\' @return A ggplot2 object.\n#\' @seealso \\code{\\link{h2o.infogram}}\n#\' @examples\n#\' \\dontrun{\n#\' h2o.init()\n#\' \n#\' # Convert iris dataset to an H2OFrame\n#\' train <- as.h2o(iris)\n#\' \n#\' # Create and plot infogram\n#\' ig <- h2o.infogram(y = "Species", training_frame = train)\n#\' plot(ig)\n#\' \n#\' }\n#\' @method plot H2OInfogram\n#\' @export\nplot.H2OInfogram <- function(x, ...) {\n  .check_for_ggplot2() # from explain.R\n  .data <- NULL\n  varargs <- list(...)\n  if ("title" %in% names(varargs)) {\n    title <- varargs$title\n  } else {\n    title <- "Infogram"\n  }\n  if ("total_information" %in% names(x@admissible_score)) {\n    # core infogram\n    xlab <- "Total Information"\n    ylab <- "Net Information"\n    xthresh <- x@total_information_threshold\n    ythresh <- x@net_information_threshold\n  } else {\n    # fair infogram\n    xlab <- "Relevance Index"\n    ylab <- "Safety Index"\n    xthresh <- x@relevance_index_threshold\n    ythresh <- x@safety_index_threshold\n  }\n  df <- as.data.frame(x@admissible_score)\n  # use generic names for x, y for easier ggplot code\n  names(df) <- c("column",\n                 "admissible",\n                 "admissible_index",\n                 "ig_x",\n                 "ig_y",\n                 "raw")\n  ggplot2::ggplot(data = df, ggplot2::aes_(~ig_x, ~ig_y)) +\n    ggplot2::geom_point() +\n    ggplot2::geom_polygon(ggplot2::aes(.data$x_coordinates, .data$y_coordinates), data = data.frame(\n      x_coordinates = c(xthresh, xthresh, -Inf, -Inf, Inf, Inf, xthresh),\n      y_coordinates = c(ythresh, Inf, Inf, -Inf, -Inf, ythresh, ythresh)\n    ), alpha = 0.1, fill = "#CC663E") +\n    ggplot2::geom_path(ggplot2::aes(.data$x_coordinates, .data$y_coordinates), data = data.frame(\n      x_coordinates = c(xthresh, xthresh, NA, xthresh, Inf),\n      y_coordinates = c(ythresh,     Inf, NA, ythresh, ythresh)\n    ), color = "red", linetype = "dashed") +\n    ggplot2::geom_text(ggplot2::aes_(~ig_x, ~ig_y, label = ~column),\n                       data = df[as.logical(df$admissible),], nudge_y = -0.0325,\n                       color = "blue", size = 2.5) +\n    ggplot2::xlab(xlab) +\n    ggplot2::ylab(ylab) +\n    ggplot2::coord_fixed(xlim = c(0, 1.1), ylim = c(0, 1.1), expand = FALSE) +\n    ggplot2::theme_bw() +\n    ggplot2::ggtitle(title) +\n    ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5))\n}\n')
doc = dict(preamble="\nH2O Infogram\n\nThe infogram is a graphical information-theoretic interpretability tool which allows the user to quickly spot the core, decision-making variables \nthat uniquely and safely drive the response, in supervised classification problems. The infogram can significantly cut down the number of predictors needed to build \na model by identifying only the most valuable, admissible features. When protected variables such as race or gender are present in the data, the admissibility \nof a variable is determined by a safety and relevancy index, and thus serves as a diagnostic tool for fairness. The safety of each feature can be quantified and \nvariables that are unsafe will be considered inadmissible. Models built using only admissible features will naturally be more interpretable, given the reduced \nfeature set.  Admissible models are also less susceptible to overfitting and train faster, while providing similar accuracy as models built using all available features.\n\nThe infogram allows the user to quickly spot the admissible decision-making variables that are driving the response.  \nThere are two types of infogram plots: Core and Fair Infogram.\n\nThe Core Infogram plots all the variables as points on two-dimensional grid of total vs net information.  The x-axis is total information, \na measure of how much the variable drives the response (the more predictive, the higher the total information). \nThe y-axis is net information, a measure of how unique the variable is.  The top right quadrant of the infogram plot is the admissible section; the variables\nlocated in this quadrant are the admissible features.  In the Core Infogram, the admissible features are the strongest, unique drivers of \nthe response.\n\nIf sensitive or protected variables are present in data, the user can specify which attributes should be protected while training using the \\code{protected_columns} \nargument. All non-protected predictor variables will be checked to make sure that there's no information pathway to the response through a protected feature, and \ndeemed inadmissible if they possess little or no informational value beyond their use as a dummy for protected attributes. The Fair Infogram plots all the features \nas points on two-dimensional grid of relevance vs safety.  The x-axis is relevance index, a measure of how much the variable drives the response (the more predictive, \nthe higher the relevance). The y-axis is safety index, a measure of how much extra information the variable has that is not acquired through the protected variables.  \nIn the Fair Infogram, the admissible features are the strongest, safest drivers of the response.\n    ", examples='\n    h2o.init()\n    \n    # Convert iris dataset to an H2OFrame    \n    df <- as.h2o(iris)\n    \n    # Infogram\n    ig <- h2o.infogram(y = "Species", training_frame = df) \n    plot(ig)\n    ')