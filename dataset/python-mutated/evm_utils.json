[
    {
        "func_name": "get_detectors_classes",
        "original": "def get_detectors_classes() -> List[Type[Detector]]:\n    return [DetectInvalid, DetectIntegerOverflow, DetectUninitializedStorage, DetectUninitializedMemory, DetectReentrancySimple, DetectReentrancyAdvanced, DetectUnusedRetVal, DetectSuicidal, DetectDelegatecall, DetectExternalCallAndLeak, DetectEnvInstruction, DetectManipulableBalance]",
        "mutated": [
            "def get_detectors_classes() -> List[Type[Detector]]:\n    if False:\n        i = 10\n    return [DetectInvalid, DetectIntegerOverflow, DetectUninitializedStorage, DetectUninitializedMemory, DetectReentrancySimple, DetectReentrancyAdvanced, DetectUnusedRetVal, DetectSuicidal, DetectDelegatecall, DetectExternalCallAndLeak, DetectEnvInstruction, DetectManipulableBalance]",
            "def get_detectors_classes() -> List[Type[Detector]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return [DetectInvalid, DetectIntegerOverflow, DetectUninitializedStorage, DetectUninitializedMemory, DetectReentrancySimple, DetectReentrancyAdvanced, DetectUnusedRetVal, DetectSuicidal, DetectDelegatecall, DetectExternalCallAndLeak, DetectEnvInstruction, DetectManipulableBalance]",
            "def get_detectors_classes() -> List[Type[Detector]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return [DetectInvalid, DetectIntegerOverflow, DetectUninitializedStorage, DetectUninitializedMemory, DetectReentrancySimple, DetectReentrancyAdvanced, DetectUnusedRetVal, DetectSuicidal, DetectDelegatecall, DetectExternalCallAndLeak, DetectEnvInstruction, DetectManipulableBalance]",
            "def get_detectors_classes() -> List[Type[Detector]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return [DetectInvalid, DetectIntegerOverflow, DetectUninitializedStorage, DetectUninitializedMemory, DetectReentrancySimple, DetectReentrancyAdvanced, DetectUnusedRetVal, DetectSuicidal, DetectDelegatecall, DetectExternalCallAndLeak, DetectEnvInstruction, DetectManipulableBalance]",
            "def get_detectors_classes() -> List[Type[Detector]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return [DetectInvalid, DetectIntegerOverflow, DetectUninitializedStorage, DetectUninitializedMemory, DetectReentrancySimple, DetectReentrancyAdvanced, DetectUnusedRetVal, DetectSuicidal, DetectDelegatecall, DetectExternalCallAndLeak, DetectEnvInstruction, DetectManipulableBalance]"
        ]
    },
    {
        "func_name": "parse_detectors",
        "original": "def parse_detectors(detectors_to_exclude: List[str]) -> List[Type[Detector]]:\n    \"\"\"returns a list of detectors that should be used\"\"\"\n    all_detector_classes = get_detectors_classes()\n    all_detector_args = map(lambda x: x.ARGUMENT, all_detector_classes)\n    for d in detectors_to_exclude:\n        if d not in all_detector_args:\n            raise Exception(f'{d} is not a detector name, must be one of {list(all_detector_args)}. See also `--list-detectors`.')\n    return [d for d in all_detector_classes if d.ARGUMENT not in detectors_to_exclude]",
        "mutated": [
            "def parse_detectors(detectors_to_exclude: List[str]) -> List[Type[Detector]]:\n    if False:\n        i = 10\n    'returns a list of detectors that should be used'\n    all_detector_classes = get_detectors_classes()\n    all_detector_args = map(lambda x: x.ARGUMENT, all_detector_classes)\n    for d in detectors_to_exclude:\n        if d not in all_detector_args:\n            raise Exception(f'{d} is not a detector name, must be one of {list(all_detector_args)}. See also `--list-detectors`.')\n    return [d for d in all_detector_classes if d.ARGUMENT not in detectors_to_exclude]",
            "def parse_detectors(detectors_to_exclude: List[str]) -> List[Type[Detector]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'returns a list of detectors that should be used'\n    all_detector_classes = get_detectors_classes()\n    all_detector_args = map(lambda x: x.ARGUMENT, all_detector_classes)\n    for d in detectors_to_exclude:\n        if d not in all_detector_args:\n            raise Exception(f'{d} is not a detector name, must be one of {list(all_detector_args)}. See also `--list-detectors`.')\n    return [d for d in all_detector_classes if d.ARGUMENT not in detectors_to_exclude]",
            "def parse_detectors(detectors_to_exclude: List[str]) -> List[Type[Detector]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'returns a list of detectors that should be used'\n    all_detector_classes = get_detectors_classes()\n    all_detector_args = map(lambda x: x.ARGUMENT, all_detector_classes)\n    for d in detectors_to_exclude:\n        if d not in all_detector_args:\n            raise Exception(f'{d} is not a detector name, must be one of {list(all_detector_args)}. See also `--list-detectors`.')\n    return [d for d in all_detector_classes if d.ARGUMENT not in detectors_to_exclude]",
            "def parse_detectors(detectors_to_exclude: List[str]) -> List[Type[Detector]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'returns a list of detectors that should be used'\n    all_detector_classes = get_detectors_classes()\n    all_detector_args = map(lambda x: x.ARGUMENT, all_detector_classes)\n    for d in detectors_to_exclude:\n        if d not in all_detector_args:\n            raise Exception(f'{d} is not a detector name, must be one of {list(all_detector_args)}. See also `--list-detectors`.')\n    return [d for d in all_detector_classes if d.ARGUMENT not in detectors_to_exclude]",
            "def parse_detectors(detectors_to_exclude: List[str]) -> List[Type[Detector]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'returns a list of detectors that should be used'\n    all_detector_classes = get_detectors_classes()\n    all_detector_args = map(lambda x: x.ARGUMENT, all_detector_classes)\n    for d in detectors_to_exclude:\n        if d not in all_detector_args:\n            raise Exception(f'{d} is not a detector name, must be one of {list(all_detector_args)}. See also `--list-detectors`.')\n    return [d for d in all_detector_classes if d.ARGUMENT not in detectors_to_exclude]"
        ]
    },
    {
        "func_name": "setup_detectors_flags",
        "original": "def setup_detectors_flags(detectors_to_exclude: List[str], additional_flags: str, m: ManticoreEVM) -> argparse.Namespace:\n    \"\"\"parse and apply additional arguments for manticore EVM execution, CLI-style\"\"\"\n    parser = argparse.ArgumentParser(description='Symbolic execution tool', prog='manticore', formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n    consts = config.get_group('main')\n    consts.add('profile', default=False, description='Enable worker profiling mode')\n    consts.add('explore_balance', default=False, description='Explore states in which only the balance was changed')\n    consts.add('skip_reverts', default=False, description='Simply avoid exploring basic blocks that end in a REVERT')\n    cryticparser.init(parser)\n    eth_flags = parser.add_argument_group('Ethereum flags')\n    eth_flags.add_argument('--verbose-trace', action='store_true', help='Dump an extra verbose trace for each state')\n    eth_flags.add_argument('--txnocoverage', action='store_true', help='Do not use coverage as stopping criteria')\n    eth_flags.add_argument('--txnoether', action='store_true', help='Do not attempt to send ether to contract')\n    eth_flags.add_argument('--txpreconstrain', action='store_true', help='Constrain human transactions to avoid exceptions in the contract function dispatcher')\n    eth_flags.add_argument('--avoid-constant', action='store_true', help='Avoid exploring constant functions for human transactions')\n    eth_flags.add_argument('--limit-loops', action='store_true', help='Limit loops depth')\n    eth_flags.add_argument('--no-testcases', action='store_true', help='Do not generate testcases for discovered states when analysis finishes')\n    eth_flags.add_argument('--only-alive-testcases', action='store_true', help='Do not generate testcases for invalid/throwing states when analysis finishes')\n    eth_flags.add_argument('--thorough-mode', action='store_true', help='Configure Manticore for more exhaustive exploration. Evaluate gas, generate testcases for dead states, explore constant functions, and run a small suite of detectors.')\n    config_flags = parser.add_argument_group('Constants')\n    config.add_config_vars_to_argparse(config_flags)\n    args = parser.parse_args(shlex.split(additional_flags))\n    config.process_config_values(parser, args)\n    if not args.thorough_mode:\n        args.avoid_constant = True\n        args.exclude_all = True\n        args.only_alive_testcases = True\n        consts_evm = config.get_group('evm')\n        consts_evm.oog = 'ignore'\n        consts.skip_reverts = True\n    if consts.skip_reverts:\n        m.register_plugin(SkipRevertBasicBlocks())\n    if consts.explore_balance:\n        m.register_plugin(KeepOnlyIfStorageChanges())\n    if args.verbose_trace:\n        m.register_plugin(VerboseTrace())\n    if args.limit_loops:\n        m.register_plugin(LoopDepthLimiter())\n    for detector in parse_detectors(detectors_to_exclude):\n        m.register_plugin(detector())\n    if consts.profile:\n        profiler = Profiler()\n        m.register_plugin(profiler)\n    if args.avoid_constant:\n        filter_nohuman_constants = FilterFunctions(regexp='.*', depth='human', mutability='constant', include=False)\n        m.register_plugin(filter_nohuman_constants)\n    if m.plugins:\n        logger.info(f\"Registered plugins: {', '.join((d.name for d in m.plugins.values()))}\")\n    return args",
        "mutated": [
            "def setup_detectors_flags(detectors_to_exclude: List[str], additional_flags: str, m: ManticoreEVM) -> argparse.Namespace:\n    if False:\n        i = 10\n    'parse and apply additional arguments for manticore EVM execution, CLI-style'\n    parser = argparse.ArgumentParser(description='Symbolic execution tool', prog='manticore', formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n    consts = config.get_group('main')\n    consts.add('profile', default=False, description='Enable worker profiling mode')\n    consts.add('explore_balance', default=False, description='Explore states in which only the balance was changed')\n    consts.add('skip_reverts', default=False, description='Simply avoid exploring basic blocks that end in a REVERT')\n    cryticparser.init(parser)\n    eth_flags = parser.add_argument_group('Ethereum flags')\n    eth_flags.add_argument('--verbose-trace', action='store_true', help='Dump an extra verbose trace for each state')\n    eth_flags.add_argument('--txnocoverage', action='store_true', help='Do not use coverage as stopping criteria')\n    eth_flags.add_argument('--txnoether', action='store_true', help='Do not attempt to send ether to contract')\n    eth_flags.add_argument('--txpreconstrain', action='store_true', help='Constrain human transactions to avoid exceptions in the contract function dispatcher')\n    eth_flags.add_argument('--avoid-constant', action='store_true', help='Avoid exploring constant functions for human transactions')\n    eth_flags.add_argument('--limit-loops', action='store_true', help='Limit loops depth')\n    eth_flags.add_argument('--no-testcases', action='store_true', help='Do not generate testcases for discovered states when analysis finishes')\n    eth_flags.add_argument('--only-alive-testcases', action='store_true', help='Do not generate testcases for invalid/throwing states when analysis finishes')\n    eth_flags.add_argument('--thorough-mode', action='store_true', help='Configure Manticore for more exhaustive exploration. Evaluate gas, generate testcases for dead states, explore constant functions, and run a small suite of detectors.')\n    config_flags = parser.add_argument_group('Constants')\n    config.add_config_vars_to_argparse(config_flags)\n    args = parser.parse_args(shlex.split(additional_flags))\n    config.process_config_values(parser, args)\n    if not args.thorough_mode:\n        args.avoid_constant = True\n        args.exclude_all = True\n        args.only_alive_testcases = True\n        consts_evm = config.get_group('evm')\n        consts_evm.oog = 'ignore'\n        consts.skip_reverts = True\n    if consts.skip_reverts:\n        m.register_plugin(SkipRevertBasicBlocks())\n    if consts.explore_balance:\n        m.register_plugin(KeepOnlyIfStorageChanges())\n    if args.verbose_trace:\n        m.register_plugin(VerboseTrace())\n    if args.limit_loops:\n        m.register_plugin(LoopDepthLimiter())\n    for detector in parse_detectors(detectors_to_exclude):\n        m.register_plugin(detector())\n    if consts.profile:\n        profiler = Profiler()\n        m.register_plugin(profiler)\n    if args.avoid_constant:\n        filter_nohuman_constants = FilterFunctions(regexp='.*', depth='human', mutability='constant', include=False)\n        m.register_plugin(filter_nohuman_constants)\n    if m.plugins:\n        logger.info(f\"Registered plugins: {', '.join((d.name for d in m.plugins.values()))}\")\n    return args",
            "def setup_detectors_flags(detectors_to_exclude: List[str], additional_flags: str, m: ManticoreEVM) -> argparse.Namespace:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'parse and apply additional arguments for manticore EVM execution, CLI-style'\n    parser = argparse.ArgumentParser(description='Symbolic execution tool', prog='manticore', formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n    consts = config.get_group('main')\n    consts.add('profile', default=False, description='Enable worker profiling mode')\n    consts.add('explore_balance', default=False, description='Explore states in which only the balance was changed')\n    consts.add('skip_reverts', default=False, description='Simply avoid exploring basic blocks that end in a REVERT')\n    cryticparser.init(parser)\n    eth_flags = parser.add_argument_group('Ethereum flags')\n    eth_flags.add_argument('--verbose-trace', action='store_true', help='Dump an extra verbose trace for each state')\n    eth_flags.add_argument('--txnocoverage', action='store_true', help='Do not use coverage as stopping criteria')\n    eth_flags.add_argument('--txnoether', action='store_true', help='Do not attempt to send ether to contract')\n    eth_flags.add_argument('--txpreconstrain', action='store_true', help='Constrain human transactions to avoid exceptions in the contract function dispatcher')\n    eth_flags.add_argument('--avoid-constant', action='store_true', help='Avoid exploring constant functions for human transactions')\n    eth_flags.add_argument('--limit-loops', action='store_true', help='Limit loops depth')\n    eth_flags.add_argument('--no-testcases', action='store_true', help='Do not generate testcases for discovered states when analysis finishes')\n    eth_flags.add_argument('--only-alive-testcases', action='store_true', help='Do not generate testcases for invalid/throwing states when analysis finishes')\n    eth_flags.add_argument('--thorough-mode', action='store_true', help='Configure Manticore for more exhaustive exploration. Evaluate gas, generate testcases for dead states, explore constant functions, and run a small suite of detectors.')\n    config_flags = parser.add_argument_group('Constants')\n    config.add_config_vars_to_argparse(config_flags)\n    args = parser.parse_args(shlex.split(additional_flags))\n    config.process_config_values(parser, args)\n    if not args.thorough_mode:\n        args.avoid_constant = True\n        args.exclude_all = True\n        args.only_alive_testcases = True\n        consts_evm = config.get_group('evm')\n        consts_evm.oog = 'ignore'\n        consts.skip_reverts = True\n    if consts.skip_reverts:\n        m.register_plugin(SkipRevertBasicBlocks())\n    if consts.explore_balance:\n        m.register_plugin(KeepOnlyIfStorageChanges())\n    if args.verbose_trace:\n        m.register_plugin(VerboseTrace())\n    if args.limit_loops:\n        m.register_plugin(LoopDepthLimiter())\n    for detector in parse_detectors(detectors_to_exclude):\n        m.register_plugin(detector())\n    if consts.profile:\n        profiler = Profiler()\n        m.register_plugin(profiler)\n    if args.avoid_constant:\n        filter_nohuman_constants = FilterFunctions(regexp='.*', depth='human', mutability='constant', include=False)\n        m.register_plugin(filter_nohuman_constants)\n    if m.plugins:\n        logger.info(f\"Registered plugins: {', '.join((d.name for d in m.plugins.values()))}\")\n    return args",
            "def setup_detectors_flags(detectors_to_exclude: List[str], additional_flags: str, m: ManticoreEVM) -> argparse.Namespace:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'parse and apply additional arguments for manticore EVM execution, CLI-style'\n    parser = argparse.ArgumentParser(description='Symbolic execution tool', prog='manticore', formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n    consts = config.get_group('main')\n    consts.add('profile', default=False, description='Enable worker profiling mode')\n    consts.add('explore_balance', default=False, description='Explore states in which only the balance was changed')\n    consts.add('skip_reverts', default=False, description='Simply avoid exploring basic blocks that end in a REVERT')\n    cryticparser.init(parser)\n    eth_flags = parser.add_argument_group('Ethereum flags')\n    eth_flags.add_argument('--verbose-trace', action='store_true', help='Dump an extra verbose trace for each state')\n    eth_flags.add_argument('--txnocoverage', action='store_true', help='Do not use coverage as stopping criteria')\n    eth_flags.add_argument('--txnoether', action='store_true', help='Do not attempt to send ether to contract')\n    eth_flags.add_argument('--txpreconstrain', action='store_true', help='Constrain human transactions to avoid exceptions in the contract function dispatcher')\n    eth_flags.add_argument('--avoid-constant', action='store_true', help='Avoid exploring constant functions for human transactions')\n    eth_flags.add_argument('--limit-loops', action='store_true', help='Limit loops depth')\n    eth_flags.add_argument('--no-testcases', action='store_true', help='Do not generate testcases for discovered states when analysis finishes')\n    eth_flags.add_argument('--only-alive-testcases', action='store_true', help='Do not generate testcases for invalid/throwing states when analysis finishes')\n    eth_flags.add_argument('--thorough-mode', action='store_true', help='Configure Manticore for more exhaustive exploration. Evaluate gas, generate testcases for dead states, explore constant functions, and run a small suite of detectors.')\n    config_flags = parser.add_argument_group('Constants')\n    config.add_config_vars_to_argparse(config_flags)\n    args = parser.parse_args(shlex.split(additional_flags))\n    config.process_config_values(parser, args)\n    if not args.thorough_mode:\n        args.avoid_constant = True\n        args.exclude_all = True\n        args.only_alive_testcases = True\n        consts_evm = config.get_group('evm')\n        consts_evm.oog = 'ignore'\n        consts.skip_reverts = True\n    if consts.skip_reverts:\n        m.register_plugin(SkipRevertBasicBlocks())\n    if consts.explore_balance:\n        m.register_plugin(KeepOnlyIfStorageChanges())\n    if args.verbose_trace:\n        m.register_plugin(VerboseTrace())\n    if args.limit_loops:\n        m.register_plugin(LoopDepthLimiter())\n    for detector in parse_detectors(detectors_to_exclude):\n        m.register_plugin(detector())\n    if consts.profile:\n        profiler = Profiler()\n        m.register_plugin(profiler)\n    if args.avoid_constant:\n        filter_nohuman_constants = FilterFunctions(regexp='.*', depth='human', mutability='constant', include=False)\n        m.register_plugin(filter_nohuman_constants)\n    if m.plugins:\n        logger.info(f\"Registered plugins: {', '.join((d.name for d in m.plugins.values()))}\")\n    return args",
            "def setup_detectors_flags(detectors_to_exclude: List[str], additional_flags: str, m: ManticoreEVM) -> argparse.Namespace:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'parse and apply additional arguments for manticore EVM execution, CLI-style'\n    parser = argparse.ArgumentParser(description='Symbolic execution tool', prog='manticore', formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n    consts = config.get_group('main')\n    consts.add('profile', default=False, description='Enable worker profiling mode')\n    consts.add('explore_balance', default=False, description='Explore states in which only the balance was changed')\n    consts.add('skip_reverts', default=False, description='Simply avoid exploring basic blocks that end in a REVERT')\n    cryticparser.init(parser)\n    eth_flags = parser.add_argument_group('Ethereum flags')\n    eth_flags.add_argument('--verbose-trace', action='store_true', help='Dump an extra verbose trace for each state')\n    eth_flags.add_argument('--txnocoverage', action='store_true', help='Do not use coverage as stopping criteria')\n    eth_flags.add_argument('--txnoether', action='store_true', help='Do not attempt to send ether to contract')\n    eth_flags.add_argument('--txpreconstrain', action='store_true', help='Constrain human transactions to avoid exceptions in the contract function dispatcher')\n    eth_flags.add_argument('--avoid-constant', action='store_true', help='Avoid exploring constant functions for human transactions')\n    eth_flags.add_argument('--limit-loops', action='store_true', help='Limit loops depth')\n    eth_flags.add_argument('--no-testcases', action='store_true', help='Do not generate testcases for discovered states when analysis finishes')\n    eth_flags.add_argument('--only-alive-testcases', action='store_true', help='Do not generate testcases for invalid/throwing states when analysis finishes')\n    eth_flags.add_argument('--thorough-mode', action='store_true', help='Configure Manticore for more exhaustive exploration. Evaluate gas, generate testcases for dead states, explore constant functions, and run a small suite of detectors.')\n    config_flags = parser.add_argument_group('Constants')\n    config.add_config_vars_to_argparse(config_flags)\n    args = parser.parse_args(shlex.split(additional_flags))\n    config.process_config_values(parser, args)\n    if not args.thorough_mode:\n        args.avoid_constant = True\n        args.exclude_all = True\n        args.only_alive_testcases = True\n        consts_evm = config.get_group('evm')\n        consts_evm.oog = 'ignore'\n        consts.skip_reverts = True\n    if consts.skip_reverts:\n        m.register_plugin(SkipRevertBasicBlocks())\n    if consts.explore_balance:\n        m.register_plugin(KeepOnlyIfStorageChanges())\n    if args.verbose_trace:\n        m.register_plugin(VerboseTrace())\n    if args.limit_loops:\n        m.register_plugin(LoopDepthLimiter())\n    for detector in parse_detectors(detectors_to_exclude):\n        m.register_plugin(detector())\n    if consts.profile:\n        profiler = Profiler()\n        m.register_plugin(profiler)\n    if args.avoid_constant:\n        filter_nohuman_constants = FilterFunctions(regexp='.*', depth='human', mutability='constant', include=False)\n        m.register_plugin(filter_nohuman_constants)\n    if m.plugins:\n        logger.info(f\"Registered plugins: {', '.join((d.name for d in m.plugins.values()))}\")\n    return args",
            "def setup_detectors_flags(detectors_to_exclude: List[str], additional_flags: str, m: ManticoreEVM) -> argparse.Namespace:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'parse and apply additional arguments for manticore EVM execution, CLI-style'\n    parser = argparse.ArgumentParser(description='Symbolic execution tool', prog='manticore', formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n    consts = config.get_group('main')\n    consts.add('profile', default=False, description='Enable worker profiling mode')\n    consts.add('explore_balance', default=False, description='Explore states in which only the balance was changed')\n    consts.add('skip_reverts', default=False, description='Simply avoid exploring basic blocks that end in a REVERT')\n    cryticparser.init(parser)\n    eth_flags = parser.add_argument_group('Ethereum flags')\n    eth_flags.add_argument('--verbose-trace', action='store_true', help='Dump an extra verbose trace for each state')\n    eth_flags.add_argument('--txnocoverage', action='store_true', help='Do not use coverage as stopping criteria')\n    eth_flags.add_argument('--txnoether', action='store_true', help='Do not attempt to send ether to contract')\n    eth_flags.add_argument('--txpreconstrain', action='store_true', help='Constrain human transactions to avoid exceptions in the contract function dispatcher')\n    eth_flags.add_argument('--avoid-constant', action='store_true', help='Avoid exploring constant functions for human transactions')\n    eth_flags.add_argument('--limit-loops', action='store_true', help='Limit loops depth')\n    eth_flags.add_argument('--no-testcases', action='store_true', help='Do not generate testcases for discovered states when analysis finishes')\n    eth_flags.add_argument('--only-alive-testcases', action='store_true', help='Do not generate testcases for invalid/throwing states when analysis finishes')\n    eth_flags.add_argument('--thorough-mode', action='store_true', help='Configure Manticore for more exhaustive exploration. Evaluate gas, generate testcases for dead states, explore constant functions, and run a small suite of detectors.')\n    config_flags = parser.add_argument_group('Constants')\n    config.add_config_vars_to_argparse(config_flags)\n    args = parser.parse_args(shlex.split(additional_flags))\n    config.process_config_values(parser, args)\n    if not args.thorough_mode:\n        args.avoid_constant = True\n        args.exclude_all = True\n        args.only_alive_testcases = True\n        consts_evm = config.get_group('evm')\n        consts_evm.oog = 'ignore'\n        consts.skip_reverts = True\n    if consts.skip_reverts:\n        m.register_plugin(SkipRevertBasicBlocks())\n    if consts.explore_balance:\n        m.register_plugin(KeepOnlyIfStorageChanges())\n    if args.verbose_trace:\n        m.register_plugin(VerboseTrace())\n    if args.limit_loops:\n        m.register_plugin(LoopDepthLimiter())\n    for detector in parse_detectors(detectors_to_exclude):\n        m.register_plugin(detector())\n    if consts.profile:\n        profiler = Profiler()\n        m.register_plugin(profiler)\n    if args.avoid_constant:\n        filter_nohuman_constants = FilterFunctions(regexp='.*', depth='human', mutability='constant', include=False)\n        m.register_plugin(filter_nohuman_constants)\n    if m.plugins:\n        logger.info(f\"Registered plugins: {', '.join((d.name for d in m.plugins.values()))}\")\n    return args"
        ]
    }
]