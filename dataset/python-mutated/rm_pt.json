[
    {
        "func_name": "parse_checkpoints",
        "original": "def parse_checkpoints(files):\n    entries = []\n    for f in files:\n        m = pt_regexp_epoch_based.fullmatch(f)\n        if m is not None:\n            entries.append((int(m.group(1)), m.group(0)))\n        else:\n            m = pt_regexp_update_based.fullmatch(f)\n            if m is not None:\n                entries.append((int(m.group(1)), m.group(0)))\n    return entries",
        "mutated": [
            "def parse_checkpoints(files):\n    if False:\n        i = 10\n    entries = []\n    for f in files:\n        m = pt_regexp_epoch_based.fullmatch(f)\n        if m is not None:\n            entries.append((int(m.group(1)), m.group(0)))\n        else:\n            m = pt_regexp_update_based.fullmatch(f)\n            if m is not None:\n                entries.append((int(m.group(1)), m.group(0)))\n    return entries",
            "def parse_checkpoints(files):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    entries = []\n    for f in files:\n        m = pt_regexp_epoch_based.fullmatch(f)\n        if m is not None:\n            entries.append((int(m.group(1)), m.group(0)))\n        else:\n            m = pt_regexp_update_based.fullmatch(f)\n            if m is not None:\n                entries.append((int(m.group(1)), m.group(0)))\n    return entries",
            "def parse_checkpoints(files):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    entries = []\n    for f in files:\n        m = pt_regexp_epoch_based.fullmatch(f)\n        if m is not None:\n            entries.append((int(m.group(1)), m.group(0)))\n        else:\n            m = pt_regexp_update_based.fullmatch(f)\n            if m is not None:\n                entries.append((int(m.group(1)), m.group(0)))\n    return entries",
            "def parse_checkpoints(files):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    entries = []\n    for f in files:\n        m = pt_regexp_epoch_based.fullmatch(f)\n        if m is not None:\n            entries.append((int(m.group(1)), m.group(0)))\n        else:\n            m = pt_regexp_update_based.fullmatch(f)\n            if m is not None:\n                entries.append((int(m.group(1)), m.group(0)))\n    return entries",
            "def parse_checkpoints(files):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    entries = []\n    for f in files:\n        m = pt_regexp_epoch_based.fullmatch(f)\n        if m is not None:\n            entries.append((int(m.group(1)), m.group(0)))\n        else:\n            m = pt_regexp_update_based.fullmatch(f)\n            if m is not None:\n                entries.append((int(m.group(1)), m.group(0)))\n    return entries"
        ]
    },
    {
        "func_name": "last_n_checkpoints",
        "original": "def last_n_checkpoints(files, n):\n    entries = parse_checkpoints(files)\n    return [x[1] for x in sorted(entries, reverse=True)[:n]]",
        "mutated": [
            "def last_n_checkpoints(files, n):\n    if False:\n        i = 10\n    entries = parse_checkpoints(files)\n    return [x[1] for x in sorted(entries, reverse=True)[:n]]",
            "def last_n_checkpoints(files, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    entries = parse_checkpoints(files)\n    return [x[1] for x in sorted(entries, reverse=True)[:n]]",
            "def last_n_checkpoints(files, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    entries = parse_checkpoints(files)\n    return [x[1] for x in sorted(entries, reverse=True)[:n]]",
            "def last_n_checkpoints(files, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    entries = parse_checkpoints(files)\n    return [x[1] for x in sorted(entries, reverse=True)[:n]]",
            "def last_n_checkpoints(files, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    entries = parse_checkpoints(files)\n    return [x[1] for x in sorted(entries, reverse=True)[:n]]"
        ]
    },
    {
        "func_name": "every_n_checkpoints",
        "original": "def every_n_checkpoints(files, n):\n    entries = parse_checkpoints(files)\n    return [x[1] for x in sorted(sorted(entries)[::-n])]",
        "mutated": [
            "def every_n_checkpoints(files, n):\n    if False:\n        i = 10\n    entries = parse_checkpoints(files)\n    return [x[1] for x in sorted(sorted(entries)[::-n])]",
            "def every_n_checkpoints(files, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    entries = parse_checkpoints(files)\n    return [x[1] for x in sorted(sorted(entries)[::-n])]",
            "def every_n_checkpoints(files, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    entries = parse_checkpoints(files)\n    return [x[1] for x in sorted(sorted(entries)[::-n])]",
            "def every_n_checkpoints(files, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    entries = parse_checkpoints(files)\n    return [x[1] for x in sorted(sorted(entries)[::-n])]",
            "def every_n_checkpoints(files, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    entries = parse_checkpoints(files)\n    return [x[1] for x in sorted(sorted(entries)[::-n])]"
        ]
    },
    {
        "func_name": "main",
        "original": "def main():\n    parser = argparse.ArgumentParser(description='Recursively delete checkpoint files from `root_dir`, but preserve checkpoint_best.pt and checkpoint_last.pt')\n    parser.add_argument('root_dirs', nargs='*')\n    parser.add_argument('--save-last', type=int, default=0, help='number of last checkpoints to save')\n    parser.add_argument('--save-every', type=int, default=0, help='interval of checkpoints to save')\n    parser.add_argument('--preserve-test', action='store_true', help='preserve checkpoints in dirs that start with test_ prefix (default: delete them)')\n    parser.add_argument('--delete-best', action='store_true', help='delete checkpoint_best.pt')\n    parser.add_argument('--delete-last', action='store_true', help='delete checkpoint_last.pt')\n    parser.add_argument('--no-dereference', action='store_true', help=\"don't dereference symlinks\")\n    args = parser.parse_args()\n    files_to_desymlink = []\n    files_to_preserve = []\n    files_to_delete = []\n    for root_dir in args.root_dirs:\n        for (root, _subdirs, files) in os.walk(root_dir):\n            if args.save_last > 0:\n                to_save = last_n_checkpoints(files, args.save_last)\n            else:\n                to_save = []\n            if args.save_every > 0:\n                to_save += every_n_checkpoints(files, args.save_every)\n            for file in files:\n                if not pt_regexp.fullmatch(file):\n                    continue\n                full_path = os.path.join(root, file)\n                if (not os.path.basename(root).startswith('test_') or args.preserve_test) and (file == 'checkpoint_last.pt' and (not args.delete_last) or (file == 'checkpoint_best.pt' and (not args.delete_best)) or file in to_save):\n                    if os.path.islink(full_path) and (not args.no_dereference):\n                        files_to_desymlink.append(full_path)\n                    else:\n                        files_to_preserve.append(full_path)\n                else:\n                    files_to_delete.append(full_path)\n    if len(files_to_desymlink) == 0 and len(files_to_delete) == 0:\n        print('Nothing to do.')\n        sys.exit(0)\n    files_to_desymlink = sorted(files_to_desymlink)\n    files_to_preserve = sorted(files_to_preserve)\n    files_to_delete = sorted(files_to_delete)\n    print('Operations to perform (in order):')\n    if len(files_to_desymlink) > 0:\n        for file in files_to_desymlink:\n            print(' - preserve (and dereference symlink): ' + file)\n    if len(files_to_preserve) > 0:\n        for file in files_to_preserve:\n            print(' - preserve: ' + file)\n    if len(files_to_delete) > 0:\n        for file in files_to_delete:\n            print(' - delete: ' + file)\n    while True:\n        resp = input('Continue? (Y/N): ')\n        if resp.strip().lower() == 'y':\n            break\n        elif resp.strip().lower() == 'n':\n            sys.exit(0)\n    print('Executing...')\n    if len(files_to_desymlink) > 0:\n        for file in files_to_desymlink:\n            realpath = os.path.realpath(file)\n            print('rm ' + file)\n            os.remove(file)\n            print('cp {} {}'.format(realpath, file))\n            shutil.copyfile(realpath, file)\n    if len(files_to_delete) > 0:\n        for file in files_to_delete:\n            print('rm ' + file)\n            os.remove(file)",
        "mutated": [
            "def main():\n    if False:\n        i = 10\n    parser = argparse.ArgumentParser(description='Recursively delete checkpoint files from `root_dir`, but preserve checkpoint_best.pt and checkpoint_last.pt')\n    parser.add_argument('root_dirs', nargs='*')\n    parser.add_argument('--save-last', type=int, default=0, help='number of last checkpoints to save')\n    parser.add_argument('--save-every', type=int, default=0, help='interval of checkpoints to save')\n    parser.add_argument('--preserve-test', action='store_true', help='preserve checkpoints in dirs that start with test_ prefix (default: delete them)')\n    parser.add_argument('--delete-best', action='store_true', help='delete checkpoint_best.pt')\n    parser.add_argument('--delete-last', action='store_true', help='delete checkpoint_last.pt')\n    parser.add_argument('--no-dereference', action='store_true', help=\"don't dereference symlinks\")\n    args = parser.parse_args()\n    files_to_desymlink = []\n    files_to_preserve = []\n    files_to_delete = []\n    for root_dir in args.root_dirs:\n        for (root, _subdirs, files) in os.walk(root_dir):\n            if args.save_last > 0:\n                to_save = last_n_checkpoints(files, args.save_last)\n            else:\n                to_save = []\n            if args.save_every > 0:\n                to_save += every_n_checkpoints(files, args.save_every)\n            for file in files:\n                if not pt_regexp.fullmatch(file):\n                    continue\n                full_path = os.path.join(root, file)\n                if (not os.path.basename(root).startswith('test_') or args.preserve_test) and (file == 'checkpoint_last.pt' and (not args.delete_last) or (file == 'checkpoint_best.pt' and (not args.delete_best)) or file in to_save):\n                    if os.path.islink(full_path) and (not args.no_dereference):\n                        files_to_desymlink.append(full_path)\n                    else:\n                        files_to_preserve.append(full_path)\n                else:\n                    files_to_delete.append(full_path)\n    if len(files_to_desymlink) == 0 and len(files_to_delete) == 0:\n        print('Nothing to do.')\n        sys.exit(0)\n    files_to_desymlink = sorted(files_to_desymlink)\n    files_to_preserve = sorted(files_to_preserve)\n    files_to_delete = sorted(files_to_delete)\n    print('Operations to perform (in order):')\n    if len(files_to_desymlink) > 0:\n        for file in files_to_desymlink:\n            print(' - preserve (and dereference symlink): ' + file)\n    if len(files_to_preserve) > 0:\n        for file in files_to_preserve:\n            print(' - preserve: ' + file)\n    if len(files_to_delete) > 0:\n        for file in files_to_delete:\n            print(' - delete: ' + file)\n    while True:\n        resp = input('Continue? (Y/N): ')\n        if resp.strip().lower() == 'y':\n            break\n        elif resp.strip().lower() == 'n':\n            sys.exit(0)\n    print('Executing...')\n    if len(files_to_desymlink) > 0:\n        for file in files_to_desymlink:\n            realpath = os.path.realpath(file)\n            print('rm ' + file)\n            os.remove(file)\n            print('cp {} {}'.format(realpath, file))\n            shutil.copyfile(realpath, file)\n    if len(files_to_delete) > 0:\n        for file in files_to_delete:\n            print('rm ' + file)\n            os.remove(file)",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    parser = argparse.ArgumentParser(description='Recursively delete checkpoint files from `root_dir`, but preserve checkpoint_best.pt and checkpoint_last.pt')\n    parser.add_argument('root_dirs', nargs='*')\n    parser.add_argument('--save-last', type=int, default=0, help='number of last checkpoints to save')\n    parser.add_argument('--save-every', type=int, default=0, help='interval of checkpoints to save')\n    parser.add_argument('--preserve-test', action='store_true', help='preserve checkpoints in dirs that start with test_ prefix (default: delete them)')\n    parser.add_argument('--delete-best', action='store_true', help='delete checkpoint_best.pt')\n    parser.add_argument('--delete-last', action='store_true', help='delete checkpoint_last.pt')\n    parser.add_argument('--no-dereference', action='store_true', help=\"don't dereference symlinks\")\n    args = parser.parse_args()\n    files_to_desymlink = []\n    files_to_preserve = []\n    files_to_delete = []\n    for root_dir in args.root_dirs:\n        for (root, _subdirs, files) in os.walk(root_dir):\n            if args.save_last > 0:\n                to_save = last_n_checkpoints(files, args.save_last)\n            else:\n                to_save = []\n            if args.save_every > 0:\n                to_save += every_n_checkpoints(files, args.save_every)\n            for file in files:\n                if not pt_regexp.fullmatch(file):\n                    continue\n                full_path = os.path.join(root, file)\n                if (not os.path.basename(root).startswith('test_') or args.preserve_test) and (file == 'checkpoint_last.pt' and (not args.delete_last) or (file == 'checkpoint_best.pt' and (not args.delete_best)) or file in to_save):\n                    if os.path.islink(full_path) and (not args.no_dereference):\n                        files_to_desymlink.append(full_path)\n                    else:\n                        files_to_preserve.append(full_path)\n                else:\n                    files_to_delete.append(full_path)\n    if len(files_to_desymlink) == 0 and len(files_to_delete) == 0:\n        print('Nothing to do.')\n        sys.exit(0)\n    files_to_desymlink = sorted(files_to_desymlink)\n    files_to_preserve = sorted(files_to_preserve)\n    files_to_delete = sorted(files_to_delete)\n    print('Operations to perform (in order):')\n    if len(files_to_desymlink) > 0:\n        for file in files_to_desymlink:\n            print(' - preserve (and dereference symlink): ' + file)\n    if len(files_to_preserve) > 0:\n        for file in files_to_preserve:\n            print(' - preserve: ' + file)\n    if len(files_to_delete) > 0:\n        for file in files_to_delete:\n            print(' - delete: ' + file)\n    while True:\n        resp = input('Continue? (Y/N): ')\n        if resp.strip().lower() == 'y':\n            break\n        elif resp.strip().lower() == 'n':\n            sys.exit(0)\n    print('Executing...')\n    if len(files_to_desymlink) > 0:\n        for file in files_to_desymlink:\n            realpath = os.path.realpath(file)\n            print('rm ' + file)\n            os.remove(file)\n            print('cp {} {}'.format(realpath, file))\n            shutil.copyfile(realpath, file)\n    if len(files_to_delete) > 0:\n        for file in files_to_delete:\n            print('rm ' + file)\n            os.remove(file)",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    parser = argparse.ArgumentParser(description='Recursively delete checkpoint files from `root_dir`, but preserve checkpoint_best.pt and checkpoint_last.pt')\n    parser.add_argument('root_dirs', nargs='*')\n    parser.add_argument('--save-last', type=int, default=0, help='number of last checkpoints to save')\n    parser.add_argument('--save-every', type=int, default=0, help='interval of checkpoints to save')\n    parser.add_argument('--preserve-test', action='store_true', help='preserve checkpoints in dirs that start with test_ prefix (default: delete them)')\n    parser.add_argument('--delete-best', action='store_true', help='delete checkpoint_best.pt')\n    parser.add_argument('--delete-last', action='store_true', help='delete checkpoint_last.pt')\n    parser.add_argument('--no-dereference', action='store_true', help=\"don't dereference symlinks\")\n    args = parser.parse_args()\n    files_to_desymlink = []\n    files_to_preserve = []\n    files_to_delete = []\n    for root_dir in args.root_dirs:\n        for (root, _subdirs, files) in os.walk(root_dir):\n            if args.save_last > 0:\n                to_save = last_n_checkpoints(files, args.save_last)\n            else:\n                to_save = []\n            if args.save_every > 0:\n                to_save += every_n_checkpoints(files, args.save_every)\n            for file in files:\n                if not pt_regexp.fullmatch(file):\n                    continue\n                full_path = os.path.join(root, file)\n                if (not os.path.basename(root).startswith('test_') or args.preserve_test) and (file == 'checkpoint_last.pt' and (not args.delete_last) or (file == 'checkpoint_best.pt' and (not args.delete_best)) or file in to_save):\n                    if os.path.islink(full_path) and (not args.no_dereference):\n                        files_to_desymlink.append(full_path)\n                    else:\n                        files_to_preserve.append(full_path)\n                else:\n                    files_to_delete.append(full_path)\n    if len(files_to_desymlink) == 0 and len(files_to_delete) == 0:\n        print('Nothing to do.')\n        sys.exit(0)\n    files_to_desymlink = sorted(files_to_desymlink)\n    files_to_preserve = sorted(files_to_preserve)\n    files_to_delete = sorted(files_to_delete)\n    print('Operations to perform (in order):')\n    if len(files_to_desymlink) > 0:\n        for file in files_to_desymlink:\n            print(' - preserve (and dereference symlink): ' + file)\n    if len(files_to_preserve) > 0:\n        for file in files_to_preserve:\n            print(' - preserve: ' + file)\n    if len(files_to_delete) > 0:\n        for file in files_to_delete:\n            print(' - delete: ' + file)\n    while True:\n        resp = input('Continue? (Y/N): ')\n        if resp.strip().lower() == 'y':\n            break\n        elif resp.strip().lower() == 'n':\n            sys.exit(0)\n    print('Executing...')\n    if len(files_to_desymlink) > 0:\n        for file in files_to_desymlink:\n            realpath = os.path.realpath(file)\n            print('rm ' + file)\n            os.remove(file)\n            print('cp {} {}'.format(realpath, file))\n            shutil.copyfile(realpath, file)\n    if len(files_to_delete) > 0:\n        for file in files_to_delete:\n            print('rm ' + file)\n            os.remove(file)",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    parser = argparse.ArgumentParser(description='Recursively delete checkpoint files from `root_dir`, but preserve checkpoint_best.pt and checkpoint_last.pt')\n    parser.add_argument('root_dirs', nargs='*')\n    parser.add_argument('--save-last', type=int, default=0, help='number of last checkpoints to save')\n    parser.add_argument('--save-every', type=int, default=0, help='interval of checkpoints to save')\n    parser.add_argument('--preserve-test', action='store_true', help='preserve checkpoints in dirs that start with test_ prefix (default: delete them)')\n    parser.add_argument('--delete-best', action='store_true', help='delete checkpoint_best.pt')\n    parser.add_argument('--delete-last', action='store_true', help='delete checkpoint_last.pt')\n    parser.add_argument('--no-dereference', action='store_true', help=\"don't dereference symlinks\")\n    args = parser.parse_args()\n    files_to_desymlink = []\n    files_to_preserve = []\n    files_to_delete = []\n    for root_dir in args.root_dirs:\n        for (root, _subdirs, files) in os.walk(root_dir):\n            if args.save_last > 0:\n                to_save = last_n_checkpoints(files, args.save_last)\n            else:\n                to_save = []\n            if args.save_every > 0:\n                to_save += every_n_checkpoints(files, args.save_every)\n            for file in files:\n                if not pt_regexp.fullmatch(file):\n                    continue\n                full_path = os.path.join(root, file)\n                if (not os.path.basename(root).startswith('test_') or args.preserve_test) and (file == 'checkpoint_last.pt' and (not args.delete_last) or (file == 'checkpoint_best.pt' and (not args.delete_best)) or file in to_save):\n                    if os.path.islink(full_path) and (not args.no_dereference):\n                        files_to_desymlink.append(full_path)\n                    else:\n                        files_to_preserve.append(full_path)\n                else:\n                    files_to_delete.append(full_path)\n    if len(files_to_desymlink) == 0 and len(files_to_delete) == 0:\n        print('Nothing to do.')\n        sys.exit(0)\n    files_to_desymlink = sorted(files_to_desymlink)\n    files_to_preserve = sorted(files_to_preserve)\n    files_to_delete = sorted(files_to_delete)\n    print('Operations to perform (in order):')\n    if len(files_to_desymlink) > 0:\n        for file in files_to_desymlink:\n            print(' - preserve (and dereference symlink): ' + file)\n    if len(files_to_preserve) > 0:\n        for file in files_to_preserve:\n            print(' - preserve: ' + file)\n    if len(files_to_delete) > 0:\n        for file in files_to_delete:\n            print(' - delete: ' + file)\n    while True:\n        resp = input('Continue? (Y/N): ')\n        if resp.strip().lower() == 'y':\n            break\n        elif resp.strip().lower() == 'n':\n            sys.exit(0)\n    print('Executing...')\n    if len(files_to_desymlink) > 0:\n        for file in files_to_desymlink:\n            realpath = os.path.realpath(file)\n            print('rm ' + file)\n            os.remove(file)\n            print('cp {} {}'.format(realpath, file))\n            shutil.copyfile(realpath, file)\n    if len(files_to_delete) > 0:\n        for file in files_to_delete:\n            print('rm ' + file)\n            os.remove(file)",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    parser = argparse.ArgumentParser(description='Recursively delete checkpoint files from `root_dir`, but preserve checkpoint_best.pt and checkpoint_last.pt')\n    parser.add_argument('root_dirs', nargs='*')\n    parser.add_argument('--save-last', type=int, default=0, help='number of last checkpoints to save')\n    parser.add_argument('--save-every', type=int, default=0, help='interval of checkpoints to save')\n    parser.add_argument('--preserve-test', action='store_true', help='preserve checkpoints in dirs that start with test_ prefix (default: delete them)')\n    parser.add_argument('--delete-best', action='store_true', help='delete checkpoint_best.pt')\n    parser.add_argument('--delete-last', action='store_true', help='delete checkpoint_last.pt')\n    parser.add_argument('--no-dereference', action='store_true', help=\"don't dereference symlinks\")\n    args = parser.parse_args()\n    files_to_desymlink = []\n    files_to_preserve = []\n    files_to_delete = []\n    for root_dir in args.root_dirs:\n        for (root, _subdirs, files) in os.walk(root_dir):\n            if args.save_last > 0:\n                to_save = last_n_checkpoints(files, args.save_last)\n            else:\n                to_save = []\n            if args.save_every > 0:\n                to_save += every_n_checkpoints(files, args.save_every)\n            for file in files:\n                if not pt_regexp.fullmatch(file):\n                    continue\n                full_path = os.path.join(root, file)\n                if (not os.path.basename(root).startswith('test_') or args.preserve_test) and (file == 'checkpoint_last.pt' and (not args.delete_last) or (file == 'checkpoint_best.pt' and (not args.delete_best)) or file in to_save):\n                    if os.path.islink(full_path) and (not args.no_dereference):\n                        files_to_desymlink.append(full_path)\n                    else:\n                        files_to_preserve.append(full_path)\n                else:\n                    files_to_delete.append(full_path)\n    if len(files_to_desymlink) == 0 and len(files_to_delete) == 0:\n        print('Nothing to do.')\n        sys.exit(0)\n    files_to_desymlink = sorted(files_to_desymlink)\n    files_to_preserve = sorted(files_to_preserve)\n    files_to_delete = sorted(files_to_delete)\n    print('Operations to perform (in order):')\n    if len(files_to_desymlink) > 0:\n        for file in files_to_desymlink:\n            print(' - preserve (and dereference symlink): ' + file)\n    if len(files_to_preserve) > 0:\n        for file in files_to_preserve:\n            print(' - preserve: ' + file)\n    if len(files_to_delete) > 0:\n        for file in files_to_delete:\n            print(' - delete: ' + file)\n    while True:\n        resp = input('Continue? (Y/N): ')\n        if resp.strip().lower() == 'y':\n            break\n        elif resp.strip().lower() == 'n':\n            sys.exit(0)\n    print('Executing...')\n    if len(files_to_desymlink) > 0:\n        for file in files_to_desymlink:\n            realpath = os.path.realpath(file)\n            print('rm ' + file)\n            os.remove(file)\n            print('cp {} {}'.format(realpath, file))\n            shutil.copyfile(realpath, file)\n    if len(files_to_delete) > 0:\n        for file in files_to_delete:\n            print('rm ' + file)\n            os.remove(file)"
        ]
    }
]