[
    {
        "func_name": "merge_aug_bboxes_3d",
        "original": "def merge_aug_bboxes_3d(aug_results, img_metas, test_cfg):\n    \"\"\"Merge augmented detection 3D bboxes and scores.\n\n    Args:\n        aug_results (list[dict]): The dict of detection results.\n            The dict contains the following keys\n\n            - boxes_3d (:obj:`BaseInstance3DBoxes`): Detection bbox.\n            - scores_3d (torch.Tensor): Detection scores.\n            - labels_3d (torch.Tensor): Predicted box labels.\n        img_metas (list[dict]): Meta information of each sample.\n        test_cfg (dict): Test config.\n\n    Returns:\n        dict: Bounding boxes results in cpu mode, containing merged results.\n\n            - boxes_3d (:obj:`BaseInstance3DBoxes`): Merged detection bbox.\n            - scores_3d (torch.Tensor): Merged detection scores.\n            - labels_3d (torch.Tensor): Merged predicted box labels.\n    \"\"\"\n    assert len(aug_results) == len(img_metas), f'\"aug_results\" should have the same length as \"img_metas\", got len(aug_results)={len(aug_results)} and len(img_metas)={len(img_metas)}'\n    recovered_bboxes = []\n    recovered_scores = []\n    recovered_labels = []\n    for (bboxes, img_info) in zip(aug_results, img_metas):\n        scale_factor = img_info[0]['pcd_scale_factor']\n        pcd_horizontal_flip = img_info[0]['pcd_horizontal_flip']\n        pcd_vertical_flip = img_info[0]['pcd_vertical_flip']\n        recovered_scores.append(bboxes['scores_3d'])\n        recovered_labels.append(bboxes['labels_3d'])\n        bboxes = bbox3d_mapping_back(bboxes['boxes_3d'], scale_factor, pcd_horizontal_flip, pcd_vertical_flip)\n        recovered_bboxes.append(bboxes)\n    aug_bboxes = recovered_bboxes[0].cat(recovered_bboxes)\n    aug_bboxes_for_nms = xywhr2xyxyr(aug_bboxes.bev)\n    aug_scores = torch.cat(recovered_scores, dim=0)\n    aug_labels = torch.cat(recovered_labels, dim=0)\n    if test_cfg.use_rotate_nms:\n        nms_func = nms_bev\n    else:\n        nms_func = nms_normal_bev\n    merged_bboxes = []\n    merged_scores = []\n    merged_labels = []\n    if len(aug_labels) == 0:\n        return bbox3d2result(aug_bboxes, aug_scores, aug_labels)\n    for class_id in range(torch.max(aug_labels).item() + 1):\n        class_inds = aug_labels == class_id\n        bboxes_i = aug_bboxes[class_inds]\n        bboxes_nms_i = aug_bboxes_for_nms[class_inds, :]\n        scores_i = aug_scores[class_inds]\n        labels_i = aug_labels[class_inds]\n        if len(bboxes_nms_i) == 0:\n            continue\n        selected = nms_func(bboxes_nms_i, scores_i, test_cfg.nms_thr)\n        merged_bboxes.append(bboxes_i[selected, :])\n        merged_scores.append(scores_i[selected])\n        merged_labels.append(labels_i[selected])\n    merged_bboxes = merged_bboxes[0].cat(merged_bboxes)\n    merged_scores = torch.cat(merged_scores, dim=0)\n    merged_labels = torch.cat(merged_labels, dim=0)\n    (_, order) = merged_scores.sort(0, descending=True)\n    num = min(test_cfg.max_num, len(aug_bboxes))\n    order = order[:num]\n    merged_bboxes = merged_bboxes[order]\n    merged_scores = merged_scores[order]\n    merged_labels = merged_labels[order]\n    return bbox3d2result(merged_bboxes, merged_scores, merged_labels)",
        "mutated": [
            "def merge_aug_bboxes_3d(aug_results, img_metas, test_cfg):\n    if False:\n        i = 10\n    'Merge augmented detection 3D bboxes and scores.\\n\\n    Args:\\n        aug_results (list[dict]): The dict of detection results.\\n            The dict contains the following keys\\n\\n            - boxes_3d (:obj:`BaseInstance3DBoxes`): Detection bbox.\\n            - scores_3d (torch.Tensor): Detection scores.\\n            - labels_3d (torch.Tensor): Predicted box labels.\\n        img_metas (list[dict]): Meta information of each sample.\\n        test_cfg (dict): Test config.\\n\\n    Returns:\\n        dict: Bounding boxes results in cpu mode, containing merged results.\\n\\n            - boxes_3d (:obj:`BaseInstance3DBoxes`): Merged detection bbox.\\n            - scores_3d (torch.Tensor): Merged detection scores.\\n            - labels_3d (torch.Tensor): Merged predicted box labels.\\n    '\n    assert len(aug_results) == len(img_metas), f'\"aug_results\" should have the same length as \"img_metas\", got len(aug_results)={len(aug_results)} and len(img_metas)={len(img_metas)}'\n    recovered_bboxes = []\n    recovered_scores = []\n    recovered_labels = []\n    for (bboxes, img_info) in zip(aug_results, img_metas):\n        scale_factor = img_info[0]['pcd_scale_factor']\n        pcd_horizontal_flip = img_info[0]['pcd_horizontal_flip']\n        pcd_vertical_flip = img_info[0]['pcd_vertical_flip']\n        recovered_scores.append(bboxes['scores_3d'])\n        recovered_labels.append(bboxes['labels_3d'])\n        bboxes = bbox3d_mapping_back(bboxes['boxes_3d'], scale_factor, pcd_horizontal_flip, pcd_vertical_flip)\n        recovered_bboxes.append(bboxes)\n    aug_bboxes = recovered_bboxes[0].cat(recovered_bboxes)\n    aug_bboxes_for_nms = xywhr2xyxyr(aug_bboxes.bev)\n    aug_scores = torch.cat(recovered_scores, dim=0)\n    aug_labels = torch.cat(recovered_labels, dim=0)\n    if test_cfg.use_rotate_nms:\n        nms_func = nms_bev\n    else:\n        nms_func = nms_normal_bev\n    merged_bboxes = []\n    merged_scores = []\n    merged_labels = []\n    if len(aug_labels) == 0:\n        return bbox3d2result(aug_bboxes, aug_scores, aug_labels)\n    for class_id in range(torch.max(aug_labels).item() + 1):\n        class_inds = aug_labels == class_id\n        bboxes_i = aug_bboxes[class_inds]\n        bboxes_nms_i = aug_bboxes_for_nms[class_inds, :]\n        scores_i = aug_scores[class_inds]\n        labels_i = aug_labels[class_inds]\n        if len(bboxes_nms_i) == 0:\n            continue\n        selected = nms_func(bboxes_nms_i, scores_i, test_cfg.nms_thr)\n        merged_bboxes.append(bboxes_i[selected, :])\n        merged_scores.append(scores_i[selected])\n        merged_labels.append(labels_i[selected])\n    merged_bboxes = merged_bboxes[0].cat(merged_bboxes)\n    merged_scores = torch.cat(merged_scores, dim=0)\n    merged_labels = torch.cat(merged_labels, dim=0)\n    (_, order) = merged_scores.sort(0, descending=True)\n    num = min(test_cfg.max_num, len(aug_bboxes))\n    order = order[:num]\n    merged_bboxes = merged_bboxes[order]\n    merged_scores = merged_scores[order]\n    merged_labels = merged_labels[order]\n    return bbox3d2result(merged_bboxes, merged_scores, merged_labels)",
            "def merge_aug_bboxes_3d(aug_results, img_metas, test_cfg):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Merge augmented detection 3D bboxes and scores.\\n\\n    Args:\\n        aug_results (list[dict]): The dict of detection results.\\n            The dict contains the following keys\\n\\n            - boxes_3d (:obj:`BaseInstance3DBoxes`): Detection bbox.\\n            - scores_3d (torch.Tensor): Detection scores.\\n            - labels_3d (torch.Tensor): Predicted box labels.\\n        img_metas (list[dict]): Meta information of each sample.\\n        test_cfg (dict): Test config.\\n\\n    Returns:\\n        dict: Bounding boxes results in cpu mode, containing merged results.\\n\\n            - boxes_3d (:obj:`BaseInstance3DBoxes`): Merged detection bbox.\\n            - scores_3d (torch.Tensor): Merged detection scores.\\n            - labels_3d (torch.Tensor): Merged predicted box labels.\\n    '\n    assert len(aug_results) == len(img_metas), f'\"aug_results\" should have the same length as \"img_metas\", got len(aug_results)={len(aug_results)} and len(img_metas)={len(img_metas)}'\n    recovered_bboxes = []\n    recovered_scores = []\n    recovered_labels = []\n    for (bboxes, img_info) in zip(aug_results, img_metas):\n        scale_factor = img_info[0]['pcd_scale_factor']\n        pcd_horizontal_flip = img_info[0]['pcd_horizontal_flip']\n        pcd_vertical_flip = img_info[0]['pcd_vertical_flip']\n        recovered_scores.append(bboxes['scores_3d'])\n        recovered_labels.append(bboxes['labels_3d'])\n        bboxes = bbox3d_mapping_back(bboxes['boxes_3d'], scale_factor, pcd_horizontal_flip, pcd_vertical_flip)\n        recovered_bboxes.append(bboxes)\n    aug_bboxes = recovered_bboxes[0].cat(recovered_bboxes)\n    aug_bboxes_for_nms = xywhr2xyxyr(aug_bboxes.bev)\n    aug_scores = torch.cat(recovered_scores, dim=0)\n    aug_labels = torch.cat(recovered_labels, dim=0)\n    if test_cfg.use_rotate_nms:\n        nms_func = nms_bev\n    else:\n        nms_func = nms_normal_bev\n    merged_bboxes = []\n    merged_scores = []\n    merged_labels = []\n    if len(aug_labels) == 0:\n        return bbox3d2result(aug_bboxes, aug_scores, aug_labels)\n    for class_id in range(torch.max(aug_labels).item() + 1):\n        class_inds = aug_labels == class_id\n        bboxes_i = aug_bboxes[class_inds]\n        bboxes_nms_i = aug_bboxes_for_nms[class_inds, :]\n        scores_i = aug_scores[class_inds]\n        labels_i = aug_labels[class_inds]\n        if len(bboxes_nms_i) == 0:\n            continue\n        selected = nms_func(bboxes_nms_i, scores_i, test_cfg.nms_thr)\n        merged_bboxes.append(bboxes_i[selected, :])\n        merged_scores.append(scores_i[selected])\n        merged_labels.append(labels_i[selected])\n    merged_bboxes = merged_bboxes[0].cat(merged_bboxes)\n    merged_scores = torch.cat(merged_scores, dim=0)\n    merged_labels = torch.cat(merged_labels, dim=0)\n    (_, order) = merged_scores.sort(0, descending=True)\n    num = min(test_cfg.max_num, len(aug_bboxes))\n    order = order[:num]\n    merged_bboxes = merged_bboxes[order]\n    merged_scores = merged_scores[order]\n    merged_labels = merged_labels[order]\n    return bbox3d2result(merged_bboxes, merged_scores, merged_labels)",
            "def merge_aug_bboxes_3d(aug_results, img_metas, test_cfg):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Merge augmented detection 3D bboxes and scores.\\n\\n    Args:\\n        aug_results (list[dict]): The dict of detection results.\\n            The dict contains the following keys\\n\\n            - boxes_3d (:obj:`BaseInstance3DBoxes`): Detection bbox.\\n            - scores_3d (torch.Tensor): Detection scores.\\n            - labels_3d (torch.Tensor): Predicted box labels.\\n        img_metas (list[dict]): Meta information of each sample.\\n        test_cfg (dict): Test config.\\n\\n    Returns:\\n        dict: Bounding boxes results in cpu mode, containing merged results.\\n\\n            - boxes_3d (:obj:`BaseInstance3DBoxes`): Merged detection bbox.\\n            - scores_3d (torch.Tensor): Merged detection scores.\\n            - labels_3d (torch.Tensor): Merged predicted box labels.\\n    '\n    assert len(aug_results) == len(img_metas), f'\"aug_results\" should have the same length as \"img_metas\", got len(aug_results)={len(aug_results)} and len(img_metas)={len(img_metas)}'\n    recovered_bboxes = []\n    recovered_scores = []\n    recovered_labels = []\n    for (bboxes, img_info) in zip(aug_results, img_metas):\n        scale_factor = img_info[0]['pcd_scale_factor']\n        pcd_horizontal_flip = img_info[0]['pcd_horizontal_flip']\n        pcd_vertical_flip = img_info[0]['pcd_vertical_flip']\n        recovered_scores.append(bboxes['scores_3d'])\n        recovered_labels.append(bboxes['labels_3d'])\n        bboxes = bbox3d_mapping_back(bboxes['boxes_3d'], scale_factor, pcd_horizontal_flip, pcd_vertical_flip)\n        recovered_bboxes.append(bboxes)\n    aug_bboxes = recovered_bboxes[0].cat(recovered_bboxes)\n    aug_bboxes_for_nms = xywhr2xyxyr(aug_bboxes.bev)\n    aug_scores = torch.cat(recovered_scores, dim=0)\n    aug_labels = torch.cat(recovered_labels, dim=0)\n    if test_cfg.use_rotate_nms:\n        nms_func = nms_bev\n    else:\n        nms_func = nms_normal_bev\n    merged_bboxes = []\n    merged_scores = []\n    merged_labels = []\n    if len(aug_labels) == 0:\n        return bbox3d2result(aug_bboxes, aug_scores, aug_labels)\n    for class_id in range(torch.max(aug_labels).item() + 1):\n        class_inds = aug_labels == class_id\n        bboxes_i = aug_bboxes[class_inds]\n        bboxes_nms_i = aug_bboxes_for_nms[class_inds, :]\n        scores_i = aug_scores[class_inds]\n        labels_i = aug_labels[class_inds]\n        if len(bboxes_nms_i) == 0:\n            continue\n        selected = nms_func(bboxes_nms_i, scores_i, test_cfg.nms_thr)\n        merged_bboxes.append(bboxes_i[selected, :])\n        merged_scores.append(scores_i[selected])\n        merged_labels.append(labels_i[selected])\n    merged_bboxes = merged_bboxes[0].cat(merged_bboxes)\n    merged_scores = torch.cat(merged_scores, dim=0)\n    merged_labels = torch.cat(merged_labels, dim=0)\n    (_, order) = merged_scores.sort(0, descending=True)\n    num = min(test_cfg.max_num, len(aug_bboxes))\n    order = order[:num]\n    merged_bboxes = merged_bboxes[order]\n    merged_scores = merged_scores[order]\n    merged_labels = merged_labels[order]\n    return bbox3d2result(merged_bboxes, merged_scores, merged_labels)",
            "def merge_aug_bboxes_3d(aug_results, img_metas, test_cfg):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Merge augmented detection 3D bboxes and scores.\\n\\n    Args:\\n        aug_results (list[dict]): The dict of detection results.\\n            The dict contains the following keys\\n\\n            - boxes_3d (:obj:`BaseInstance3DBoxes`): Detection bbox.\\n            - scores_3d (torch.Tensor): Detection scores.\\n            - labels_3d (torch.Tensor): Predicted box labels.\\n        img_metas (list[dict]): Meta information of each sample.\\n        test_cfg (dict): Test config.\\n\\n    Returns:\\n        dict: Bounding boxes results in cpu mode, containing merged results.\\n\\n            - boxes_3d (:obj:`BaseInstance3DBoxes`): Merged detection bbox.\\n            - scores_3d (torch.Tensor): Merged detection scores.\\n            - labels_3d (torch.Tensor): Merged predicted box labels.\\n    '\n    assert len(aug_results) == len(img_metas), f'\"aug_results\" should have the same length as \"img_metas\", got len(aug_results)={len(aug_results)} and len(img_metas)={len(img_metas)}'\n    recovered_bboxes = []\n    recovered_scores = []\n    recovered_labels = []\n    for (bboxes, img_info) in zip(aug_results, img_metas):\n        scale_factor = img_info[0]['pcd_scale_factor']\n        pcd_horizontal_flip = img_info[0]['pcd_horizontal_flip']\n        pcd_vertical_flip = img_info[0]['pcd_vertical_flip']\n        recovered_scores.append(bboxes['scores_3d'])\n        recovered_labels.append(bboxes['labels_3d'])\n        bboxes = bbox3d_mapping_back(bboxes['boxes_3d'], scale_factor, pcd_horizontal_flip, pcd_vertical_flip)\n        recovered_bboxes.append(bboxes)\n    aug_bboxes = recovered_bboxes[0].cat(recovered_bboxes)\n    aug_bboxes_for_nms = xywhr2xyxyr(aug_bboxes.bev)\n    aug_scores = torch.cat(recovered_scores, dim=0)\n    aug_labels = torch.cat(recovered_labels, dim=0)\n    if test_cfg.use_rotate_nms:\n        nms_func = nms_bev\n    else:\n        nms_func = nms_normal_bev\n    merged_bboxes = []\n    merged_scores = []\n    merged_labels = []\n    if len(aug_labels) == 0:\n        return bbox3d2result(aug_bboxes, aug_scores, aug_labels)\n    for class_id in range(torch.max(aug_labels).item() + 1):\n        class_inds = aug_labels == class_id\n        bboxes_i = aug_bboxes[class_inds]\n        bboxes_nms_i = aug_bboxes_for_nms[class_inds, :]\n        scores_i = aug_scores[class_inds]\n        labels_i = aug_labels[class_inds]\n        if len(bboxes_nms_i) == 0:\n            continue\n        selected = nms_func(bboxes_nms_i, scores_i, test_cfg.nms_thr)\n        merged_bboxes.append(bboxes_i[selected, :])\n        merged_scores.append(scores_i[selected])\n        merged_labels.append(labels_i[selected])\n    merged_bboxes = merged_bboxes[0].cat(merged_bboxes)\n    merged_scores = torch.cat(merged_scores, dim=0)\n    merged_labels = torch.cat(merged_labels, dim=0)\n    (_, order) = merged_scores.sort(0, descending=True)\n    num = min(test_cfg.max_num, len(aug_bboxes))\n    order = order[:num]\n    merged_bboxes = merged_bboxes[order]\n    merged_scores = merged_scores[order]\n    merged_labels = merged_labels[order]\n    return bbox3d2result(merged_bboxes, merged_scores, merged_labels)",
            "def merge_aug_bboxes_3d(aug_results, img_metas, test_cfg):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Merge augmented detection 3D bboxes and scores.\\n\\n    Args:\\n        aug_results (list[dict]): The dict of detection results.\\n            The dict contains the following keys\\n\\n            - boxes_3d (:obj:`BaseInstance3DBoxes`): Detection bbox.\\n            - scores_3d (torch.Tensor): Detection scores.\\n            - labels_3d (torch.Tensor): Predicted box labels.\\n        img_metas (list[dict]): Meta information of each sample.\\n        test_cfg (dict): Test config.\\n\\n    Returns:\\n        dict: Bounding boxes results in cpu mode, containing merged results.\\n\\n            - boxes_3d (:obj:`BaseInstance3DBoxes`): Merged detection bbox.\\n            - scores_3d (torch.Tensor): Merged detection scores.\\n            - labels_3d (torch.Tensor): Merged predicted box labels.\\n    '\n    assert len(aug_results) == len(img_metas), f'\"aug_results\" should have the same length as \"img_metas\", got len(aug_results)={len(aug_results)} and len(img_metas)={len(img_metas)}'\n    recovered_bboxes = []\n    recovered_scores = []\n    recovered_labels = []\n    for (bboxes, img_info) in zip(aug_results, img_metas):\n        scale_factor = img_info[0]['pcd_scale_factor']\n        pcd_horizontal_flip = img_info[0]['pcd_horizontal_flip']\n        pcd_vertical_flip = img_info[0]['pcd_vertical_flip']\n        recovered_scores.append(bboxes['scores_3d'])\n        recovered_labels.append(bboxes['labels_3d'])\n        bboxes = bbox3d_mapping_back(bboxes['boxes_3d'], scale_factor, pcd_horizontal_flip, pcd_vertical_flip)\n        recovered_bboxes.append(bboxes)\n    aug_bboxes = recovered_bboxes[0].cat(recovered_bboxes)\n    aug_bboxes_for_nms = xywhr2xyxyr(aug_bboxes.bev)\n    aug_scores = torch.cat(recovered_scores, dim=0)\n    aug_labels = torch.cat(recovered_labels, dim=0)\n    if test_cfg.use_rotate_nms:\n        nms_func = nms_bev\n    else:\n        nms_func = nms_normal_bev\n    merged_bboxes = []\n    merged_scores = []\n    merged_labels = []\n    if len(aug_labels) == 0:\n        return bbox3d2result(aug_bboxes, aug_scores, aug_labels)\n    for class_id in range(torch.max(aug_labels).item() + 1):\n        class_inds = aug_labels == class_id\n        bboxes_i = aug_bboxes[class_inds]\n        bboxes_nms_i = aug_bboxes_for_nms[class_inds, :]\n        scores_i = aug_scores[class_inds]\n        labels_i = aug_labels[class_inds]\n        if len(bboxes_nms_i) == 0:\n            continue\n        selected = nms_func(bboxes_nms_i, scores_i, test_cfg.nms_thr)\n        merged_bboxes.append(bboxes_i[selected, :])\n        merged_scores.append(scores_i[selected])\n        merged_labels.append(labels_i[selected])\n    merged_bboxes = merged_bboxes[0].cat(merged_bboxes)\n    merged_scores = torch.cat(merged_scores, dim=0)\n    merged_labels = torch.cat(merged_labels, dim=0)\n    (_, order) = merged_scores.sort(0, descending=True)\n    num = min(test_cfg.max_num, len(aug_bboxes))\n    order = order[:num]\n    merged_bboxes = merged_bboxes[order]\n    merged_scores = merged_scores[order]\n    merged_labels = merged_labels[order]\n    return bbox3d2result(merged_bboxes, merged_scores, merged_labels)"
        ]
    }
]