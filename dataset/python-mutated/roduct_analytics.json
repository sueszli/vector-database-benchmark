[
    {
        "func_name": "__transform_journey",
        "original": "def __transform_journey(rows, reverse_path=False):\n    total_100p = 0\n    number_of_step1 = 0\n    for r in rows:\n        if r['event_number_in_session'] > 1:\n            break\n        number_of_step1 += 1\n        total_100p += r['sessions_count']\n    for i in range(len(rows)):\n        rows[i]['value'] = rows[i]['sessions_count'] * 100 / total_100p\n    nodes = []\n    nodes_values = []\n    links = []\n    for r in rows:\n        source = f\"{r['event_number_in_session']}_{r['event_type']}_{r['e_value']}\"\n        if source not in nodes:\n            nodes.append(source)\n            nodes_values.append({'name': r['e_value'], 'eventType': r['event_type'], 'avgTimeFromPrevious': 0, 'sessionsCount': 0})\n        if r['next_value']:\n            target = f\"{r['event_number_in_session'] + 1}_{r['next_type']}_{r['next_value']}\"\n            if target not in nodes:\n                nodes.append(target)\n                nodes_values.append({'name': r['next_value'], 'eventType': r['next_type'], 'avgTimeFromPrevious': 0, 'sessionsCount': 0})\n            sr_idx = nodes.index(source)\n            tg_idx = nodes.index(target)\n            if r['avg_time_from_previous'] is not None:\n                nodes_values[tg_idx]['avgTimeFromPrevious'] += r['avg_time_from_previous'] * r['sessions_count']\n                nodes_values[tg_idx]['sessionsCount'] += r['sessions_count']\n            link = {'eventType': r['event_type'], 'sessionsCount': r['sessions_count'], 'value': r['value'], 'avgTimeFromPrevious': r['avg_time_from_previous']}\n            if not reverse_path:\n                link['source'] = sr_idx\n                link['target'] = tg_idx\n            else:\n                link['source'] = tg_idx\n                link['target'] = sr_idx\n            links.append(link)\n    for n in nodes_values:\n        if n['sessionsCount'] > 0:\n            n['avgTimeFromPrevious'] = n['avgTimeFromPrevious'] / n['sessionsCount']\n        else:\n            n['avgTimeFromPrevious'] = None\n        n.pop('sessionsCount')\n    return {'nodes': nodes_values, 'links': sorted(links, key=lambda x: (x['source'], x['target']), reverse=False)}",
        "mutated": [
            "def __transform_journey(rows, reverse_path=False):\n    if False:\n        i = 10\n    total_100p = 0\n    number_of_step1 = 0\n    for r in rows:\n        if r['event_number_in_session'] > 1:\n            break\n        number_of_step1 += 1\n        total_100p += r['sessions_count']\n    for i in range(len(rows)):\n        rows[i]['value'] = rows[i]['sessions_count'] * 100 / total_100p\n    nodes = []\n    nodes_values = []\n    links = []\n    for r in rows:\n        source = f\"{r['event_number_in_session']}_{r['event_type']}_{r['e_value']}\"\n        if source not in nodes:\n            nodes.append(source)\n            nodes_values.append({'name': r['e_value'], 'eventType': r['event_type'], 'avgTimeFromPrevious': 0, 'sessionsCount': 0})\n        if r['next_value']:\n            target = f\"{r['event_number_in_session'] + 1}_{r['next_type']}_{r['next_value']}\"\n            if target not in nodes:\n                nodes.append(target)\n                nodes_values.append({'name': r['next_value'], 'eventType': r['next_type'], 'avgTimeFromPrevious': 0, 'sessionsCount': 0})\n            sr_idx = nodes.index(source)\n            tg_idx = nodes.index(target)\n            if r['avg_time_from_previous'] is not None:\n                nodes_values[tg_idx]['avgTimeFromPrevious'] += r['avg_time_from_previous'] * r['sessions_count']\n                nodes_values[tg_idx]['sessionsCount'] += r['sessions_count']\n            link = {'eventType': r['event_type'], 'sessionsCount': r['sessions_count'], 'value': r['value'], 'avgTimeFromPrevious': r['avg_time_from_previous']}\n            if not reverse_path:\n                link['source'] = sr_idx\n                link['target'] = tg_idx\n            else:\n                link['source'] = tg_idx\n                link['target'] = sr_idx\n            links.append(link)\n    for n in nodes_values:\n        if n['sessionsCount'] > 0:\n            n['avgTimeFromPrevious'] = n['avgTimeFromPrevious'] / n['sessionsCount']\n        else:\n            n['avgTimeFromPrevious'] = None\n        n.pop('sessionsCount')\n    return {'nodes': nodes_values, 'links': sorted(links, key=lambda x: (x['source'], x['target']), reverse=False)}",
            "def __transform_journey(rows, reverse_path=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    total_100p = 0\n    number_of_step1 = 0\n    for r in rows:\n        if r['event_number_in_session'] > 1:\n            break\n        number_of_step1 += 1\n        total_100p += r['sessions_count']\n    for i in range(len(rows)):\n        rows[i]['value'] = rows[i]['sessions_count'] * 100 / total_100p\n    nodes = []\n    nodes_values = []\n    links = []\n    for r in rows:\n        source = f\"{r['event_number_in_session']}_{r['event_type']}_{r['e_value']}\"\n        if source not in nodes:\n            nodes.append(source)\n            nodes_values.append({'name': r['e_value'], 'eventType': r['event_type'], 'avgTimeFromPrevious': 0, 'sessionsCount': 0})\n        if r['next_value']:\n            target = f\"{r['event_number_in_session'] + 1}_{r['next_type']}_{r['next_value']}\"\n            if target not in nodes:\n                nodes.append(target)\n                nodes_values.append({'name': r['next_value'], 'eventType': r['next_type'], 'avgTimeFromPrevious': 0, 'sessionsCount': 0})\n            sr_idx = nodes.index(source)\n            tg_idx = nodes.index(target)\n            if r['avg_time_from_previous'] is not None:\n                nodes_values[tg_idx]['avgTimeFromPrevious'] += r['avg_time_from_previous'] * r['sessions_count']\n                nodes_values[tg_idx]['sessionsCount'] += r['sessions_count']\n            link = {'eventType': r['event_type'], 'sessionsCount': r['sessions_count'], 'value': r['value'], 'avgTimeFromPrevious': r['avg_time_from_previous']}\n            if not reverse_path:\n                link['source'] = sr_idx\n                link['target'] = tg_idx\n            else:\n                link['source'] = tg_idx\n                link['target'] = sr_idx\n            links.append(link)\n    for n in nodes_values:\n        if n['sessionsCount'] > 0:\n            n['avgTimeFromPrevious'] = n['avgTimeFromPrevious'] / n['sessionsCount']\n        else:\n            n['avgTimeFromPrevious'] = None\n        n.pop('sessionsCount')\n    return {'nodes': nodes_values, 'links': sorted(links, key=lambda x: (x['source'], x['target']), reverse=False)}",
            "def __transform_journey(rows, reverse_path=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    total_100p = 0\n    number_of_step1 = 0\n    for r in rows:\n        if r['event_number_in_session'] > 1:\n            break\n        number_of_step1 += 1\n        total_100p += r['sessions_count']\n    for i in range(len(rows)):\n        rows[i]['value'] = rows[i]['sessions_count'] * 100 / total_100p\n    nodes = []\n    nodes_values = []\n    links = []\n    for r in rows:\n        source = f\"{r['event_number_in_session']}_{r['event_type']}_{r['e_value']}\"\n        if source not in nodes:\n            nodes.append(source)\n            nodes_values.append({'name': r['e_value'], 'eventType': r['event_type'], 'avgTimeFromPrevious': 0, 'sessionsCount': 0})\n        if r['next_value']:\n            target = f\"{r['event_number_in_session'] + 1}_{r['next_type']}_{r['next_value']}\"\n            if target not in nodes:\n                nodes.append(target)\n                nodes_values.append({'name': r['next_value'], 'eventType': r['next_type'], 'avgTimeFromPrevious': 0, 'sessionsCount': 0})\n            sr_idx = nodes.index(source)\n            tg_idx = nodes.index(target)\n            if r['avg_time_from_previous'] is not None:\n                nodes_values[tg_idx]['avgTimeFromPrevious'] += r['avg_time_from_previous'] * r['sessions_count']\n                nodes_values[tg_idx]['sessionsCount'] += r['sessions_count']\n            link = {'eventType': r['event_type'], 'sessionsCount': r['sessions_count'], 'value': r['value'], 'avgTimeFromPrevious': r['avg_time_from_previous']}\n            if not reverse_path:\n                link['source'] = sr_idx\n                link['target'] = tg_idx\n            else:\n                link['source'] = tg_idx\n                link['target'] = sr_idx\n            links.append(link)\n    for n in nodes_values:\n        if n['sessionsCount'] > 0:\n            n['avgTimeFromPrevious'] = n['avgTimeFromPrevious'] / n['sessionsCount']\n        else:\n            n['avgTimeFromPrevious'] = None\n        n.pop('sessionsCount')\n    return {'nodes': nodes_values, 'links': sorted(links, key=lambda x: (x['source'], x['target']), reverse=False)}",
            "def __transform_journey(rows, reverse_path=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    total_100p = 0\n    number_of_step1 = 0\n    for r in rows:\n        if r['event_number_in_session'] > 1:\n            break\n        number_of_step1 += 1\n        total_100p += r['sessions_count']\n    for i in range(len(rows)):\n        rows[i]['value'] = rows[i]['sessions_count'] * 100 / total_100p\n    nodes = []\n    nodes_values = []\n    links = []\n    for r in rows:\n        source = f\"{r['event_number_in_session']}_{r['event_type']}_{r['e_value']}\"\n        if source not in nodes:\n            nodes.append(source)\n            nodes_values.append({'name': r['e_value'], 'eventType': r['event_type'], 'avgTimeFromPrevious': 0, 'sessionsCount': 0})\n        if r['next_value']:\n            target = f\"{r['event_number_in_session'] + 1}_{r['next_type']}_{r['next_value']}\"\n            if target not in nodes:\n                nodes.append(target)\n                nodes_values.append({'name': r['next_value'], 'eventType': r['next_type'], 'avgTimeFromPrevious': 0, 'sessionsCount': 0})\n            sr_idx = nodes.index(source)\n            tg_idx = nodes.index(target)\n            if r['avg_time_from_previous'] is not None:\n                nodes_values[tg_idx]['avgTimeFromPrevious'] += r['avg_time_from_previous'] * r['sessions_count']\n                nodes_values[tg_idx]['sessionsCount'] += r['sessions_count']\n            link = {'eventType': r['event_type'], 'sessionsCount': r['sessions_count'], 'value': r['value'], 'avgTimeFromPrevious': r['avg_time_from_previous']}\n            if not reverse_path:\n                link['source'] = sr_idx\n                link['target'] = tg_idx\n            else:\n                link['source'] = tg_idx\n                link['target'] = sr_idx\n            links.append(link)\n    for n in nodes_values:\n        if n['sessionsCount'] > 0:\n            n['avgTimeFromPrevious'] = n['avgTimeFromPrevious'] / n['sessionsCount']\n        else:\n            n['avgTimeFromPrevious'] = None\n        n.pop('sessionsCount')\n    return {'nodes': nodes_values, 'links': sorted(links, key=lambda x: (x['source'], x['target']), reverse=False)}",
            "def __transform_journey(rows, reverse_path=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    total_100p = 0\n    number_of_step1 = 0\n    for r in rows:\n        if r['event_number_in_session'] > 1:\n            break\n        number_of_step1 += 1\n        total_100p += r['sessions_count']\n    for i in range(len(rows)):\n        rows[i]['value'] = rows[i]['sessions_count'] * 100 / total_100p\n    nodes = []\n    nodes_values = []\n    links = []\n    for r in rows:\n        source = f\"{r['event_number_in_session']}_{r['event_type']}_{r['e_value']}\"\n        if source not in nodes:\n            nodes.append(source)\n            nodes_values.append({'name': r['e_value'], 'eventType': r['event_type'], 'avgTimeFromPrevious': 0, 'sessionsCount': 0})\n        if r['next_value']:\n            target = f\"{r['event_number_in_session'] + 1}_{r['next_type']}_{r['next_value']}\"\n            if target not in nodes:\n                nodes.append(target)\n                nodes_values.append({'name': r['next_value'], 'eventType': r['next_type'], 'avgTimeFromPrevious': 0, 'sessionsCount': 0})\n            sr_idx = nodes.index(source)\n            tg_idx = nodes.index(target)\n            if r['avg_time_from_previous'] is not None:\n                nodes_values[tg_idx]['avgTimeFromPrevious'] += r['avg_time_from_previous'] * r['sessions_count']\n                nodes_values[tg_idx]['sessionsCount'] += r['sessions_count']\n            link = {'eventType': r['event_type'], 'sessionsCount': r['sessions_count'], 'value': r['value'], 'avgTimeFromPrevious': r['avg_time_from_previous']}\n            if not reverse_path:\n                link['source'] = sr_idx\n                link['target'] = tg_idx\n            else:\n                link['source'] = tg_idx\n                link['target'] = sr_idx\n            links.append(link)\n    for n in nodes_values:\n        if n['sessionsCount'] > 0:\n            n['avgTimeFromPrevious'] = n['avgTimeFromPrevious'] / n['sessionsCount']\n        else:\n            n['avgTimeFromPrevious'] = None\n        n.pop('sessionsCount')\n    return {'nodes': nodes_values, 'links': sorted(links, key=lambda x: (x['source'], x['target']), reverse=False)}"
        ]
    },
    {
        "func_name": "path_analysis",
        "original": "def path_analysis(project_id: int, data: schemas.CardPathAnalysis):\n    sub_events = []\n    start_points_from = 'pre_ranked_events'\n    sub_sessions_extra_projection = ''\n    start_points_conditions = []\n    sessions_conditions = ['start_ts>=%(startTimestamp)s', 'start_ts<%(endTimestamp)s', 'project_id=%(project_id)s', 'events_count > 1', 'duration>0']\n    if len(data.metric_value) == 0:\n        data.metric_value.append(schemas.ProductAnalyticsSelectedEventType.location)\n        sub_events.append({'table': JOURNEY_TYPES[schemas.ProductAnalyticsSelectedEventType.location]['table'], 'column': JOURNEY_TYPES[schemas.ProductAnalyticsSelectedEventType.location]['column'], 'eventType': schemas.ProductAnalyticsSelectedEventType.location.value})\n    else:\n        for v in data.metric_value:\n            if JOURNEY_TYPES.get(v):\n                sub_events.append({'table': JOURNEY_TYPES[v]['table'], 'column': JOURNEY_TYPES[v]['column'], 'eventType': v})\n    extra_values = {}\n    start_join = []\n    reverse = data.start_type == 'end'\n    for (i, sf) in enumerate(data.start_point):\n        f_k = f'start_point_{i}'\n        op = sh.get_sql_operator(sf.operator)\n        sf.value = helper.values_for_operator(value=sf.value, op=sf.operator)\n        is_not = sh.is_negation_operator(sf.operator)\n        extra_values = {**extra_values, **sh.multi_values(sf.value, value_key=f_k)}\n        start_points_conditions.append(f\"(event_type='{sf.type}' AND \" + sh.multi_conditions(f'e_value {op} %({f_k})s', sf.value, is_not=is_not, value_key=f_k) + ')')\n        main_column = JOURNEY_TYPES[sf.type]['column']\n        sessions_conditions.append(sh.multi_conditions(f'{main_column} {op} %({f_k})s', sf.value, is_not=is_not, value_key=f_k))\n        sessions_conditions += ['timestamp>=%(startTimestamp)s', 'timestamp<%(endTimestamp)s']\n        start_join.append(f\"INNER JOIN {JOURNEY_TYPES[sf.type]['table']} USING (session_id)\")\n    exclusions = {}\n    for (i, ef) in enumerate(data.excludes):\n        if len(ef.value) == 0:\n            continue\n        if ef.type in data.metric_value:\n            f_k = f'exclude_{i}'\n            extra_values = {**extra_values, **sh.multi_values(ef.value, value_key=f_k)}\n            exclusions[ef.type] = [sh.multi_conditions(f\"{JOURNEY_TYPES[ef.type]['column']} != %({f_k})s\", ef.value, is_not=True, value_key=f_k)]\n    meta_keys = None\n    for (i, f) in enumerate(data.series[0].filter.filters):\n        op = sh.get_sql_operator(f.operator)\n        is_any = sh.isAny_opreator(f.operator)\n        is_not = sh.is_negation_operator(f.operator)\n        is_undefined = sh.isUndefined_operator(f.operator)\n        f_k = f'f_value_{i}'\n        extra_values = {**extra_values, **sh.multi_values(f.value, value_key=f_k)}\n        if not is_any and len(f.value) == 0:\n            continue\n        if f.type == schemas.FilterType.user_browser:\n            if is_any:\n                sessions_conditions.append('user_browser IS NOT NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'user_browser {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.user_os]:\n            if is_any:\n                sessions_conditions.append('user_os IS NOT NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'user_os {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.user_device]:\n            if is_any:\n                sessions_conditions.append('user_device IS NOT NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'user_device {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.user_country]:\n            if is_any:\n                sessions_conditions.append('user_country IS NOT NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'user_country {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n        elif f.type == schemas.FilterType.user_city:\n            if is_any:\n                sessions_conditions.append('user_city IS NOT NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'user_city {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n        elif f.type == schemas.FilterType.user_state:\n            if is_any:\n                sessions_conditions.append('user_state IS NOT NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'user_state {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.utm_source]:\n            if is_any:\n                sessions_conditions.append('utm_source IS NOT NULL')\n            elif is_undefined:\n                sessions_conditions.append('utm_source IS NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'utm_source {op} %({f_k})s::text', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.utm_medium]:\n            if is_any:\n                sessions_conditions.append('utm_medium IS NOT NULL')\n            elif is_undefined:\n                sessions_conditions.append('utm_medium IS NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'utm_medium {op} %({f_k})s::text', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.utm_campaign]:\n            if is_any:\n                sessions_conditions.append('utm_campaign IS NOT NULL')\n            elif is_undefined:\n                sessions_conditions.append('utm_campaign IS NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'utm_campaign {op} %({f_k})s::text', f.value, is_not=is_not, value_key=f_k))\n        elif f.type == schemas.FilterType.duration:\n            if len(f.value) > 0 and f.value[0] is not None:\n                sessions_conditions.append('duration >= %(minDuration)s')\n                extra_values['minDuration'] = f.value[0]\n            if len(f.value) > 1 and f.value[1] is not None and (int(f.value[1]) > 0):\n                sessions_conditions.append('duration <= %(maxDuration)s')\n                extra_values['maxDuration'] = f.value[1]\n        elif f.type == schemas.FilterType.referrer:\n            if is_any:\n                sessions_conditions.append('base_referrer IS NOT NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'base_referrer {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n        elif f.type == schemas.FilterType.metadata:\n            if meta_keys is None:\n                meta_keys = metadata.get(project_id=project_id)\n                meta_keys = {m['key']: m['index'] for m in meta_keys}\n            if f.source in meta_keys.keys():\n                if is_any:\n                    sessions_conditions.append(f'{metadata.index_to_colname(meta_keys[f.source])} IS NOT NULL')\n                elif is_undefined:\n                    sessions_conditions.append(f'{metadata.index_to_colname(meta_keys[f.source])} IS NULL')\n                else:\n                    sessions_conditions.append(sh.multi_conditions(f'{metadata.index_to_colname(meta_keys[f.source])} {op} %({f_k})s::text', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.user_id, schemas.FilterType.user_id_ios]:\n            if is_any:\n                sessions_conditions.append('user_id IS NOT NULL')\n            elif is_undefined:\n                sessions_conditions.append('user_id IS NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f's.user_id {op} %({f_k})s::text', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.user_anonymous_id, schemas.FilterType.user_anonymous_id_ios]:\n            if is_any:\n                sessions_conditions.append('user_anonymous_id IS NOT NULL')\n            elif is_undefined:\n                sessions_conditions.append('user_anonymous_id IS NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'user_anonymous_id {op} %({f_k})s::text', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.rev_id, schemas.FilterType.rev_id_ios]:\n            if is_any:\n                sessions_conditions.append('rev_id IS NOT NULL')\n            elif is_undefined:\n                sessions_conditions.append('rev_id IS NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'rev_id {op} %({f_k})s::text', f.value, is_not=is_not, value_key=f_k))\n        elif f.type == schemas.FilterType.platform:\n            sessions_conditions.append(sh.multi_conditions(f'user_device_type {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n        elif f.type == schemas.FilterType.issue:\n            if is_any:\n                sessions_conditions.append('array_length(issue_types, 1) > 0')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'%({f_k})s {op} ANY (issue_types)', f.value, is_not=is_not, value_key=f_k))\n        elif f.type == schemas.FilterType.events_count:\n            sessions_conditions.append(sh.multi_conditions(f'events_count {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n    events_subquery = []\n    for t in sub_events:\n        sub_events_conditions = ['e.timestamp >= %(startTimestamp)s', 'e.timestamp < %(endTimestamp)s'] + exclusions.get(t['eventType'], [])\n        if len(start_points_conditions) > 0:\n            sub_events_conditions.append('e.timestamp >= sub_sessions.start_event_timestamp')\n        events_subquery.append(f\"                   SELECT session_id, {t['column']} AS e_value, timestamp, '{t['eventType']}' AS event_type\\n                   FROM {t['table']} AS e INNER JOIN sub_sessions USING (session_id)\\n                   WHERE {' AND '.join(sub_events_conditions)}\")\n    events_subquery = '\\n UNION ALL \\n'.join(events_subquery)\n    if reverse:\n        path_direction = 'DESC'\n    else:\n        path_direction = ''\n    if len(start_points_conditions) == 0:\n        start_points_from = '(SELECT event_type, e_value\\n                                FROM pre_ranked_events\\n                                WHERE event_number_in_session = 1\\n                                GROUP BY event_type, e_value\\n                                ORDER BY count(1) DESC\\n                                LIMIT 1) AS top_start_events\\n                                   INNER JOIN pre_ranked_events\\n                                              USING (event_type, e_value)'\n    else:\n        sub_sessions_extra_projection = ', MIN(timestamp) AS start_event_timestamp'\n        start_points_conditions = ['(' + ' OR '.join(start_points_conditions) + ')']\n    start_points_conditions.append('event_number_in_session = 1')\n    steps_query = ['n1 AS (SELECT event_number_in_session,\\n                                    event_type,\\n                                    e_value,\\n                                    next_type,\\n                                    next_value,\\n                                    AVG(time_from_previous) AS avg_time_from_previous,\\n                                    COUNT(1) AS sessions_count\\n                             FROM ranked_events INNER JOIN start_points USING (session_id)\\n                             WHERE event_number_in_session = 1 \\n                                AND next_value IS NOT NULL\\n                             GROUP BY event_number_in_session, event_type, e_value, next_type, next_value\\n                             ORDER BY sessions_count DESC\\n                             LIMIT %(eventThresholdNumberInGroup)s)']\n    projection_query = ['(SELECT event_number_in_session,\\n                                   event_type,\\n                                   e_value,\\n                                   next_type,\\n                                   next_value,\\n                                   sessions_count,\\n                                   avg_time_from_previous\\n                           FROM n1)']\n    for i in range(2, data.density + 1):\n        steps_query.append(f'n{i} AS (SELECT *\\n                                      FROM (SELECT re.event_number_in_session,\\n                                                   re.event_type,\\n                                                   re.e_value,\\n                                                   re.next_type,\\n                                                   re.next_value,\\n                                                   AVG(re.time_from_previous) AS avg_time_from_previous,\\n                                                   COUNT(1) AS sessions_count\\n                                            FROM ranked_events AS re\\n                                                     INNER JOIN n{i - 1} ON (n{i - 1}.next_value = re.e_value)\\n                                            WHERE re.event_number_in_session = {i}\\n                                            GROUP BY re.event_number_in_session, re.event_type, re.e_value, re.next_type, re.next_value) AS sub_level\\n                                      ORDER BY sessions_count DESC\\n                                      LIMIT %(eventThresholdNumberInGroup)s)')\n        projection_query.append(f'(SELECT event_number_in_session,\\n                                            event_type,\\n                                            e_value,\\n                                            next_type,\\n                                            next_value,\\n                                            sessions_count,\\n                                            avg_time_from_previous\\n                                     FROM n{i})')\n    with pg_client.PostgresClient() as cur:\n        pg_query = f\"WITH sub_sessions AS (SELECT session_id {sub_sessions_extra_projection}\\n                      FROM public.sessions {' '.join(start_join)}\\n                      WHERE {' AND '.join(sessions_conditions)}\\n                      {('GROUP BY session_id' if len(start_points_conditions) > 0 else '')}),\\n     sub_events AS ({events_subquery}),\\n     pre_ranked_events AS (SELECT *\\n                           FROM (SELECT session_id,\\n                                        event_type,\\n                                        e_value,\\n                                        timestamp,\\n                                        row_number() OVER (PARTITION BY session_id ORDER BY timestamp {path_direction}) AS event_number_in_session\\n                                 FROM sub_events\\n                                 ORDER BY session_id) AS full_ranked_events\\n                           WHERE event_number_in_session <= %(density)s),\\n     start_points AS (SELECT session_id\\n                      FROM {start_points_from}\\n                      WHERE {' AND '.join(start_points_conditions)}),\\n     ranked_events AS (SELECT *,\\n                              LEAD(e_value, 1) OVER (PARTITION BY session_id ORDER BY timestamp {path_direction})    AS next_value,\\n                              LEAD(event_type, 1) OVER (PARTITION BY session_id ORDER BY timestamp {path_direction}) AS next_type,\\n                              abs(LAG(timestamp, 1) OVER (PARTITION BY session_id ORDER BY timestamp {path_direction}) -\\n                                  timestamp)                                                         AS time_from_previous\\n                       FROM pre_ranked_events INNER JOIN start_points USING (session_id)),\\n     {','.join(steps_query)}\\n{'UNION ALL'.join(projection_query)};\"\n        params = {'project_id': project_id, 'startTimestamp': data.startTimestamp, 'endTimestamp': data.endTimestamp, 'density': data.density, 'eventThresholdNumberInGroup': 4 if data.hide_excess else 8, **extra_values}\n        query = cur.mogrify(pg_query, params)\n        _now = time()\n        cur.execute(query)\n        if time() - _now > 2:\n            logger.warning(f'>>>>>>>>>PathAnalysis long query ({int(time() - _now)}s)<<<<<<<<<')\n            logger.warning('----------------------')\n            logger.warning(query)\n            logger.warning('----------------------')\n        rows = cur.fetchall()\n    return __transform_journey(rows=rows, reverse_path=reverse)",
        "mutated": [
            "def path_analysis(project_id: int, data: schemas.CardPathAnalysis):\n    if False:\n        i = 10\n    sub_events = []\n    start_points_from = 'pre_ranked_events'\n    sub_sessions_extra_projection = ''\n    start_points_conditions = []\n    sessions_conditions = ['start_ts>=%(startTimestamp)s', 'start_ts<%(endTimestamp)s', 'project_id=%(project_id)s', 'events_count > 1', 'duration>0']\n    if len(data.metric_value) == 0:\n        data.metric_value.append(schemas.ProductAnalyticsSelectedEventType.location)\n        sub_events.append({'table': JOURNEY_TYPES[schemas.ProductAnalyticsSelectedEventType.location]['table'], 'column': JOURNEY_TYPES[schemas.ProductAnalyticsSelectedEventType.location]['column'], 'eventType': schemas.ProductAnalyticsSelectedEventType.location.value})\n    else:\n        for v in data.metric_value:\n            if JOURNEY_TYPES.get(v):\n                sub_events.append({'table': JOURNEY_TYPES[v]['table'], 'column': JOURNEY_TYPES[v]['column'], 'eventType': v})\n    extra_values = {}\n    start_join = []\n    reverse = data.start_type == 'end'\n    for (i, sf) in enumerate(data.start_point):\n        f_k = f'start_point_{i}'\n        op = sh.get_sql_operator(sf.operator)\n        sf.value = helper.values_for_operator(value=sf.value, op=sf.operator)\n        is_not = sh.is_negation_operator(sf.operator)\n        extra_values = {**extra_values, **sh.multi_values(sf.value, value_key=f_k)}\n        start_points_conditions.append(f\"(event_type='{sf.type}' AND \" + sh.multi_conditions(f'e_value {op} %({f_k})s', sf.value, is_not=is_not, value_key=f_k) + ')')\n        main_column = JOURNEY_TYPES[sf.type]['column']\n        sessions_conditions.append(sh.multi_conditions(f'{main_column} {op} %({f_k})s', sf.value, is_not=is_not, value_key=f_k))\n        sessions_conditions += ['timestamp>=%(startTimestamp)s', 'timestamp<%(endTimestamp)s']\n        start_join.append(f\"INNER JOIN {JOURNEY_TYPES[sf.type]['table']} USING (session_id)\")\n    exclusions = {}\n    for (i, ef) in enumerate(data.excludes):\n        if len(ef.value) == 0:\n            continue\n        if ef.type in data.metric_value:\n            f_k = f'exclude_{i}'\n            extra_values = {**extra_values, **sh.multi_values(ef.value, value_key=f_k)}\n            exclusions[ef.type] = [sh.multi_conditions(f\"{JOURNEY_TYPES[ef.type]['column']} != %({f_k})s\", ef.value, is_not=True, value_key=f_k)]\n    meta_keys = None\n    for (i, f) in enumerate(data.series[0].filter.filters):\n        op = sh.get_sql_operator(f.operator)\n        is_any = sh.isAny_opreator(f.operator)\n        is_not = sh.is_negation_operator(f.operator)\n        is_undefined = sh.isUndefined_operator(f.operator)\n        f_k = f'f_value_{i}'\n        extra_values = {**extra_values, **sh.multi_values(f.value, value_key=f_k)}\n        if not is_any and len(f.value) == 0:\n            continue\n        if f.type == schemas.FilterType.user_browser:\n            if is_any:\n                sessions_conditions.append('user_browser IS NOT NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'user_browser {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.user_os]:\n            if is_any:\n                sessions_conditions.append('user_os IS NOT NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'user_os {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.user_device]:\n            if is_any:\n                sessions_conditions.append('user_device IS NOT NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'user_device {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.user_country]:\n            if is_any:\n                sessions_conditions.append('user_country IS NOT NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'user_country {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n        elif f.type == schemas.FilterType.user_city:\n            if is_any:\n                sessions_conditions.append('user_city IS NOT NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'user_city {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n        elif f.type == schemas.FilterType.user_state:\n            if is_any:\n                sessions_conditions.append('user_state IS NOT NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'user_state {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.utm_source]:\n            if is_any:\n                sessions_conditions.append('utm_source IS NOT NULL')\n            elif is_undefined:\n                sessions_conditions.append('utm_source IS NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'utm_source {op} %({f_k})s::text', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.utm_medium]:\n            if is_any:\n                sessions_conditions.append('utm_medium IS NOT NULL')\n            elif is_undefined:\n                sessions_conditions.append('utm_medium IS NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'utm_medium {op} %({f_k})s::text', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.utm_campaign]:\n            if is_any:\n                sessions_conditions.append('utm_campaign IS NOT NULL')\n            elif is_undefined:\n                sessions_conditions.append('utm_campaign IS NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'utm_campaign {op} %({f_k})s::text', f.value, is_not=is_not, value_key=f_k))\n        elif f.type == schemas.FilterType.duration:\n            if len(f.value) > 0 and f.value[0] is not None:\n                sessions_conditions.append('duration >= %(minDuration)s')\n                extra_values['minDuration'] = f.value[0]\n            if len(f.value) > 1 and f.value[1] is not None and (int(f.value[1]) > 0):\n                sessions_conditions.append('duration <= %(maxDuration)s')\n                extra_values['maxDuration'] = f.value[1]\n        elif f.type == schemas.FilterType.referrer:\n            if is_any:\n                sessions_conditions.append('base_referrer IS NOT NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'base_referrer {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n        elif f.type == schemas.FilterType.metadata:\n            if meta_keys is None:\n                meta_keys = metadata.get(project_id=project_id)\n                meta_keys = {m['key']: m['index'] for m in meta_keys}\n            if f.source in meta_keys.keys():\n                if is_any:\n                    sessions_conditions.append(f'{metadata.index_to_colname(meta_keys[f.source])} IS NOT NULL')\n                elif is_undefined:\n                    sessions_conditions.append(f'{metadata.index_to_colname(meta_keys[f.source])} IS NULL')\n                else:\n                    sessions_conditions.append(sh.multi_conditions(f'{metadata.index_to_colname(meta_keys[f.source])} {op} %({f_k})s::text', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.user_id, schemas.FilterType.user_id_ios]:\n            if is_any:\n                sessions_conditions.append('user_id IS NOT NULL')\n            elif is_undefined:\n                sessions_conditions.append('user_id IS NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f's.user_id {op} %({f_k})s::text', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.user_anonymous_id, schemas.FilterType.user_anonymous_id_ios]:\n            if is_any:\n                sessions_conditions.append('user_anonymous_id IS NOT NULL')\n            elif is_undefined:\n                sessions_conditions.append('user_anonymous_id IS NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'user_anonymous_id {op} %({f_k})s::text', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.rev_id, schemas.FilterType.rev_id_ios]:\n            if is_any:\n                sessions_conditions.append('rev_id IS NOT NULL')\n            elif is_undefined:\n                sessions_conditions.append('rev_id IS NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'rev_id {op} %({f_k})s::text', f.value, is_not=is_not, value_key=f_k))\n        elif f.type == schemas.FilterType.platform:\n            sessions_conditions.append(sh.multi_conditions(f'user_device_type {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n        elif f.type == schemas.FilterType.issue:\n            if is_any:\n                sessions_conditions.append('array_length(issue_types, 1) > 0')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'%({f_k})s {op} ANY (issue_types)', f.value, is_not=is_not, value_key=f_k))\n        elif f.type == schemas.FilterType.events_count:\n            sessions_conditions.append(sh.multi_conditions(f'events_count {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n    events_subquery = []\n    for t in sub_events:\n        sub_events_conditions = ['e.timestamp >= %(startTimestamp)s', 'e.timestamp < %(endTimestamp)s'] + exclusions.get(t['eventType'], [])\n        if len(start_points_conditions) > 0:\n            sub_events_conditions.append('e.timestamp >= sub_sessions.start_event_timestamp')\n        events_subquery.append(f\"                   SELECT session_id, {t['column']} AS e_value, timestamp, '{t['eventType']}' AS event_type\\n                   FROM {t['table']} AS e INNER JOIN sub_sessions USING (session_id)\\n                   WHERE {' AND '.join(sub_events_conditions)}\")\n    events_subquery = '\\n UNION ALL \\n'.join(events_subquery)\n    if reverse:\n        path_direction = 'DESC'\n    else:\n        path_direction = ''\n    if len(start_points_conditions) == 0:\n        start_points_from = '(SELECT event_type, e_value\\n                                FROM pre_ranked_events\\n                                WHERE event_number_in_session = 1\\n                                GROUP BY event_type, e_value\\n                                ORDER BY count(1) DESC\\n                                LIMIT 1) AS top_start_events\\n                                   INNER JOIN pre_ranked_events\\n                                              USING (event_type, e_value)'\n    else:\n        sub_sessions_extra_projection = ', MIN(timestamp) AS start_event_timestamp'\n        start_points_conditions = ['(' + ' OR '.join(start_points_conditions) + ')']\n    start_points_conditions.append('event_number_in_session = 1')\n    steps_query = ['n1 AS (SELECT event_number_in_session,\\n                                    event_type,\\n                                    e_value,\\n                                    next_type,\\n                                    next_value,\\n                                    AVG(time_from_previous) AS avg_time_from_previous,\\n                                    COUNT(1) AS sessions_count\\n                             FROM ranked_events INNER JOIN start_points USING (session_id)\\n                             WHERE event_number_in_session = 1 \\n                                AND next_value IS NOT NULL\\n                             GROUP BY event_number_in_session, event_type, e_value, next_type, next_value\\n                             ORDER BY sessions_count DESC\\n                             LIMIT %(eventThresholdNumberInGroup)s)']\n    projection_query = ['(SELECT event_number_in_session,\\n                                   event_type,\\n                                   e_value,\\n                                   next_type,\\n                                   next_value,\\n                                   sessions_count,\\n                                   avg_time_from_previous\\n                           FROM n1)']\n    for i in range(2, data.density + 1):\n        steps_query.append(f'n{i} AS (SELECT *\\n                                      FROM (SELECT re.event_number_in_session,\\n                                                   re.event_type,\\n                                                   re.e_value,\\n                                                   re.next_type,\\n                                                   re.next_value,\\n                                                   AVG(re.time_from_previous) AS avg_time_from_previous,\\n                                                   COUNT(1) AS sessions_count\\n                                            FROM ranked_events AS re\\n                                                     INNER JOIN n{i - 1} ON (n{i - 1}.next_value = re.e_value)\\n                                            WHERE re.event_number_in_session = {i}\\n                                            GROUP BY re.event_number_in_session, re.event_type, re.e_value, re.next_type, re.next_value) AS sub_level\\n                                      ORDER BY sessions_count DESC\\n                                      LIMIT %(eventThresholdNumberInGroup)s)')\n        projection_query.append(f'(SELECT event_number_in_session,\\n                                            event_type,\\n                                            e_value,\\n                                            next_type,\\n                                            next_value,\\n                                            sessions_count,\\n                                            avg_time_from_previous\\n                                     FROM n{i})')\n    with pg_client.PostgresClient() as cur:\n        pg_query = f\"WITH sub_sessions AS (SELECT session_id {sub_sessions_extra_projection}\\n                      FROM public.sessions {' '.join(start_join)}\\n                      WHERE {' AND '.join(sessions_conditions)}\\n                      {('GROUP BY session_id' if len(start_points_conditions) > 0 else '')}),\\n     sub_events AS ({events_subquery}),\\n     pre_ranked_events AS (SELECT *\\n                           FROM (SELECT session_id,\\n                                        event_type,\\n                                        e_value,\\n                                        timestamp,\\n                                        row_number() OVER (PARTITION BY session_id ORDER BY timestamp {path_direction}) AS event_number_in_session\\n                                 FROM sub_events\\n                                 ORDER BY session_id) AS full_ranked_events\\n                           WHERE event_number_in_session <= %(density)s),\\n     start_points AS (SELECT session_id\\n                      FROM {start_points_from}\\n                      WHERE {' AND '.join(start_points_conditions)}),\\n     ranked_events AS (SELECT *,\\n                              LEAD(e_value, 1) OVER (PARTITION BY session_id ORDER BY timestamp {path_direction})    AS next_value,\\n                              LEAD(event_type, 1) OVER (PARTITION BY session_id ORDER BY timestamp {path_direction}) AS next_type,\\n                              abs(LAG(timestamp, 1) OVER (PARTITION BY session_id ORDER BY timestamp {path_direction}) -\\n                                  timestamp)                                                         AS time_from_previous\\n                       FROM pre_ranked_events INNER JOIN start_points USING (session_id)),\\n     {','.join(steps_query)}\\n{'UNION ALL'.join(projection_query)};\"\n        params = {'project_id': project_id, 'startTimestamp': data.startTimestamp, 'endTimestamp': data.endTimestamp, 'density': data.density, 'eventThresholdNumberInGroup': 4 if data.hide_excess else 8, **extra_values}\n        query = cur.mogrify(pg_query, params)\n        _now = time()\n        cur.execute(query)\n        if time() - _now > 2:\n            logger.warning(f'>>>>>>>>>PathAnalysis long query ({int(time() - _now)}s)<<<<<<<<<')\n            logger.warning('----------------------')\n            logger.warning(query)\n            logger.warning('----------------------')\n        rows = cur.fetchall()\n    return __transform_journey(rows=rows, reverse_path=reverse)",
            "def path_analysis(project_id: int, data: schemas.CardPathAnalysis):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    sub_events = []\n    start_points_from = 'pre_ranked_events'\n    sub_sessions_extra_projection = ''\n    start_points_conditions = []\n    sessions_conditions = ['start_ts>=%(startTimestamp)s', 'start_ts<%(endTimestamp)s', 'project_id=%(project_id)s', 'events_count > 1', 'duration>0']\n    if len(data.metric_value) == 0:\n        data.metric_value.append(schemas.ProductAnalyticsSelectedEventType.location)\n        sub_events.append({'table': JOURNEY_TYPES[schemas.ProductAnalyticsSelectedEventType.location]['table'], 'column': JOURNEY_TYPES[schemas.ProductAnalyticsSelectedEventType.location]['column'], 'eventType': schemas.ProductAnalyticsSelectedEventType.location.value})\n    else:\n        for v in data.metric_value:\n            if JOURNEY_TYPES.get(v):\n                sub_events.append({'table': JOURNEY_TYPES[v]['table'], 'column': JOURNEY_TYPES[v]['column'], 'eventType': v})\n    extra_values = {}\n    start_join = []\n    reverse = data.start_type == 'end'\n    for (i, sf) in enumerate(data.start_point):\n        f_k = f'start_point_{i}'\n        op = sh.get_sql_operator(sf.operator)\n        sf.value = helper.values_for_operator(value=sf.value, op=sf.operator)\n        is_not = sh.is_negation_operator(sf.operator)\n        extra_values = {**extra_values, **sh.multi_values(sf.value, value_key=f_k)}\n        start_points_conditions.append(f\"(event_type='{sf.type}' AND \" + sh.multi_conditions(f'e_value {op} %({f_k})s', sf.value, is_not=is_not, value_key=f_k) + ')')\n        main_column = JOURNEY_TYPES[sf.type]['column']\n        sessions_conditions.append(sh.multi_conditions(f'{main_column} {op} %({f_k})s', sf.value, is_not=is_not, value_key=f_k))\n        sessions_conditions += ['timestamp>=%(startTimestamp)s', 'timestamp<%(endTimestamp)s']\n        start_join.append(f\"INNER JOIN {JOURNEY_TYPES[sf.type]['table']} USING (session_id)\")\n    exclusions = {}\n    for (i, ef) in enumerate(data.excludes):\n        if len(ef.value) == 0:\n            continue\n        if ef.type in data.metric_value:\n            f_k = f'exclude_{i}'\n            extra_values = {**extra_values, **sh.multi_values(ef.value, value_key=f_k)}\n            exclusions[ef.type] = [sh.multi_conditions(f\"{JOURNEY_TYPES[ef.type]['column']} != %({f_k})s\", ef.value, is_not=True, value_key=f_k)]\n    meta_keys = None\n    for (i, f) in enumerate(data.series[0].filter.filters):\n        op = sh.get_sql_operator(f.operator)\n        is_any = sh.isAny_opreator(f.operator)\n        is_not = sh.is_negation_operator(f.operator)\n        is_undefined = sh.isUndefined_operator(f.operator)\n        f_k = f'f_value_{i}'\n        extra_values = {**extra_values, **sh.multi_values(f.value, value_key=f_k)}\n        if not is_any and len(f.value) == 0:\n            continue\n        if f.type == schemas.FilterType.user_browser:\n            if is_any:\n                sessions_conditions.append('user_browser IS NOT NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'user_browser {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.user_os]:\n            if is_any:\n                sessions_conditions.append('user_os IS NOT NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'user_os {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.user_device]:\n            if is_any:\n                sessions_conditions.append('user_device IS NOT NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'user_device {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.user_country]:\n            if is_any:\n                sessions_conditions.append('user_country IS NOT NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'user_country {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n        elif f.type == schemas.FilterType.user_city:\n            if is_any:\n                sessions_conditions.append('user_city IS NOT NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'user_city {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n        elif f.type == schemas.FilterType.user_state:\n            if is_any:\n                sessions_conditions.append('user_state IS NOT NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'user_state {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.utm_source]:\n            if is_any:\n                sessions_conditions.append('utm_source IS NOT NULL')\n            elif is_undefined:\n                sessions_conditions.append('utm_source IS NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'utm_source {op} %({f_k})s::text', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.utm_medium]:\n            if is_any:\n                sessions_conditions.append('utm_medium IS NOT NULL')\n            elif is_undefined:\n                sessions_conditions.append('utm_medium IS NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'utm_medium {op} %({f_k})s::text', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.utm_campaign]:\n            if is_any:\n                sessions_conditions.append('utm_campaign IS NOT NULL')\n            elif is_undefined:\n                sessions_conditions.append('utm_campaign IS NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'utm_campaign {op} %({f_k})s::text', f.value, is_not=is_not, value_key=f_k))\n        elif f.type == schemas.FilterType.duration:\n            if len(f.value) > 0 and f.value[0] is not None:\n                sessions_conditions.append('duration >= %(minDuration)s')\n                extra_values['minDuration'] = f.value[0]\n            if len(f.value) > 1 and f.value[1] is not None and (int(f.value[1]) > 0):\n                sessions_conditions.append('duration <= %(maxDuration)s')\n                extra_values['maxDuration'] = f.value[1]\n        elif f.type == schemas.FilterType.referrer:\n            if is_any:\n                sessions_conditions.append('base_referrer IS NOT NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'base_referrer {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n        elif f.type == schemas.FilterType.metadata:\n            if meta_keys is None:\n                meta_keys = metadata.get(project_id=project_id)\n                meta_keys = {m['key']: m['index'] for m in meta_keys}\n            if f.source in meta_keys.keys():\n                if is_any:\n                    sessions_conditions.append(f'{metadata.index_to_colname(meta_keys[f.source])} IS NOT NULL')\n                elif is_undefined:\n                    sessions_conditions.append(f'{metadata.index_to_colname(meta_keys[f.source])} IS NULL')\n                else:\n                    sessions_conditions.append(sh.multi_conditions(f'{metadata.index_to_colname(meta_keys[f.source])} {op} %({f_k})s::text', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.user_id, schemas.FilterType.user_id_ios]:\n            if is_any:\n                sessions_conditions.append('user_id IS NOT NULL')\n            elif is_undefined:\n                sessions_conditions.append('user_id IS NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f's.user_id {op} %({f_k})s::text', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.user_anonymous_id, schemas.FilterType.user_anonymous_id_ios]:\n            if is_any:\n                sessions_conditions.append('user_anonymous_id IS NOT NULL')\n            elif is_undefined:\n                sessions_conditions.append('user_anonymous_id IS NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'user_anonymous_id {op} %({f_k})s::text', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.rev_id, schemas.FilterType.rev_id_ios]:\n            if is_any:\n                sessions_conditions.append('rev_id IS NOT NULL')\n            elif is_undefined:\n                sessions_conditions.append('rev_id IS NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'rev_id {op} %({f_k})s::text', f.value, is_not=is_not, value_key=f_k))\n        elif f.type == schemas.FilterType.platform:\n            sessions_conditions.append(sh.multi_conditions(f'user_device_type {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n        elif f.type == schemas.FilterType.issue:\n            if is_any:\n                sessions_conditions.append('array_length(issue_types, 1) > 0')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'%({f_k})s {op} ANY (issue_types)', f.value, is_not=is_not, value_key=f_k))\n        elif f.type == schemas.FilterType.events_count:\n            sessions_conditions.append(sh.multi_conditions(f'events_count {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n    events_subquery = []\n    for t in sub_events:\n        sub_events_conditions = ['e.timestamp >= %(startTimestamp)s', 'e.timestamp < %(endTimestamp)s'] + exclusions.get(t['eventType'], [])\n        if len(start_points_conditions) > 0:\n            sub_events_conditions.append('e.timestamp >= sub_sessions.start_event_timestamp')\n        events_subquery.append(f\"                   SELECT session_id, {t['column']} AS e_value, timestamp, '{t['eventType']}' AS event_type\\n                   FROM {t['table']} AS e INNER JOIN sub_sessions USING (session_id)\\n                   WHERE {' AND '.join(sub_events_conditions)}\")\n    events_subquery = '\\n UNION ALL \\n'.join(events_subquery)\n    if reverse:\n        path_direction = 'DESC'\n    else:\n        path_direction = ''\n    if len(start_points_conditions) == 0:\n        start_points_from = '(SELECT event_type, e_value\\n                                FROM pre_ranked_events\\n                                WHERE event_number_in_session = 1\\n                                GROUP BY event_type, e_value\\n                                ORDER BY count(1) DESC\\n                                LIMIT 1) AS top_start_events\\n                                   INNER JOIN pre_ranked_events\\n                                              USING (event_type, e_value)'\n    else:\n        sub_sessions_extra_projection = ', MIN(timestamp) AS start_event_timestamp'\n        start_points_conditions = ['(' + ' OR '.join(start_points_conditions) + ')']\n    start_points_conditions.append('event_number_in_session = 1')\n    steps_query = ['n1 AS (SELECT event_number_in_session,\\n                                    event_type,\\n                                    e_value,\\n                                    next_type,\\n                                    next_value,\\n                                    AVG(time_from_previous) AS avg_time_from_previous,\\n                                    COUNT(1) AS sessions_count\\n                             FROM ranked_events INNER JOIN start_points USING (session_id)\\n                             WHERE event_number_in_session = 1 \\n                                AND next_value IS NOT NULL\\n                             GROUP BY event_number_in_session, event_type, e_value, next_type, next_value\\n                             ORDER BY sessions_count DESC\\n                             LIMIT %(eventThresholdNumberInGroup)s)']\n    projection_query = ['(SELECT event_number_in_session,\\n                                   event_type,\\n                                   e_value,\\n                                   next_type,\\n                                   next_value,\\n                                   sessions_count,\\n                                   avg_time_from_previous\\n                           FROM n1)']\n    for i in range(2, data.density + 1):\n        steps_query.append(f'n{i} AS (SELECT *\\n                                      FROM (SELECT re.event_number_in_session,\\n                                                   re.event_type,\\n                                                   re.e_value,\\n                                                   re.next_type,\\n                                                   re.next_value,\\n                                                   AVG(re.time_from_previous) AS avg_time_from_previous,\\n                                                   COUNT(1) AS sessions_count\\n                                            FROM ranked_events AS re\\n                                                     INNER JOIN n{i - 1} ON (n{i - 1}.next_value = re.e_value)\\n                                            WHERE re.event_number_in_session = {i}\\n                                            GROUP BY re.event_number_in_session, re.event_type, re.e_value, re.next_type, re.next_value) AS sub_level\\n                                      ORDER BY sessions_count DESC\\n                                      LIMIT %(eventThresholdNumberInGroup)s)')\n        projection_query.append(f'(SELECT event_number_in_session,\\n                                            event_type,\\n                                            e_value,\\n                                            next_type,\\n                                            next_value,\\n                                            sessions_count,\\n                                            avg_time_from_previous\\n                                     FROM n{i})')\n    with pg_client.PostgresClient() as cur:\n        pg_query = f\"WITH sub_sessions AS (SELECT session_id {sub_sessions_extra_projection}\\n                      FROM public.sessions {' '.join(start_join)}\\n                      WHERE {' AND '.join(sessions_conditions)}\\n                      {('GROUP BY session_id' if len(start_points_conditions) > 0 else '')}),\\n     sub_events AS ({events_subquery}),\\n     pre_ranked_events AS (SELECT *\\n                           FROM (SELECT session_id,\\n                                        event_type,\\n                                        e_value,\\n                                        timestamp,\\n                                        row_number() OVER (PARTITION BY session_id ORDER BY timestamp {path_direction}) AS event_number_in_session\\n                                 FROM sub_events\\n                                 ORDER BY session_id) AS full_ranked_events\\n                           WHERE event_number_in_session <= %(density)s),\\n     start_points AS (SELECT session_id\\n                      FROM {start_points_from}\\n                      WHERE {' AND '.join(start_points_conditions)}),\\n     ranked_events AS (SELECT *,\\n                              LEAD(e_value, 1) OVER (PARTITION BY session_id ORDER BY timestamp {path_direction})    AS next_value,\\n                              LEAD(event_type, 1) OVER (PARTITION BY session_id ORDER BY timestamp {path_direction}) AS next_type,\\n                              abs(LAG(timestamp, 1) OVER (PARTITION BY session_id ORDER BY timestamp {path_direction}) -\\n                                  timestamp)                                                         AS time_from_previous\\n                       FROM pre_ranked_events INNER JOIN start_points USING (session_id)),\\n     {','.join(steps_query)}\\n{'UNION ALL'.join(projection_query)};\"\n        params = {'project_id': project_id, 'startTimestamp': data.startTimestamp, 'endTimestamp': data.endTimestamp, 'density': data.density, 'eventThresholdNumberInGroup': 4 if data.hide_excess else 8, **extra_values}\n        query = cur.mogrify(pg_query, params)\n        _now = time()\n        cur.execute(query)\n        if time() - _now > 2:\n            logger.warning(f'>>>>>>>>>PathAnalysis long query ({int(time() - _now)}s)<<<<<<<<<')\n            logger.warning('----------------------')\n            logger.warning(query)\n            logger.warning('----------------------')\n        rows = cur.fetchall()\n    return __transform_journey(rows=rows, reverse_path=reverse)",
            "def path_analysis(project_id: int, data: schemas.CardPathAnalysis):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    sub_events = []\n    start_points_from = 'pre_ranked_events'\n    sub_sessions_extra_projection = ''\n    start_points_conditions = []\n    sessions_conditions = ['start_ts>=%(startTimestamp)s', 'start_ts<%(endTimestamp)s', 'project_id=%(project_id)s', 'events_count > 1', 'duration>0']\n    if len(data.metric_value) == 0:\n        data.metric_value.append(schemas.ProductAnalyticsSelectedEventType.location)\n        sub_events.append({'table': JOURNEY_TYPES[schemas.ProductAnalyticsSelectedEventType.location]['table'], 'column': JOURNEY_TYPES[schemas.ProductAnalyticsSelectedEventType.location]['column'], 'eventType': schemas.ProductAnalyticsSelectedEventType.location.value})\n    else:\n        for v in data.metric_value:\n            if JOURNEY_TYPES.get(v):\n                sub_events.append({'table': JOURNEY_TYPES[v]['table'], 'column': JOURNEY_TYPES[v]['column'], 'eventType': v})\n    extra_values = {}\n    start_join = []\n    reverse = data.start_type == 'end'\n    for (i, sf) in enumerate(data.start_point):\n        f_k = f'start_point_{i}'\n        op = sh.get_sql_operator(sf.operator)\n        sf.value = helper.values_for_operator(value=sf.value, op=sf.operator)\n        is_not = sh.is_negation_operator(sf.operator)\n        extra_values = {**extra_values, **sh.multi_values(sf.value, value_key=f_k)}\n        start_points_conditions.append(f\"(event_type='{sf.type}' AND \" + sh.multi_conditions(f'e_value {op} %({f_k})s', sf.value, is_not=is_not, value_key=f_k) + ')')\n        main_column = JOURNEY_TYPES[sf.type]['column']\n        sessions_conditions.append(sh.multi_conditions(f'{main_column} {op} %({f_k})s', sf.value, is_not=is_not, value_key=f_k))\n        sessions_conditions += ['timestamp>=%(startTimestamp)s', 'timestamp<%(endTimestamp)s']\n        start_join.append(f\"INNER JOIN {JOURNEY_TYPES[sf.type]['table']} USING (session_id)\")\n    exclusions = {}\n    for (i, ef) in enumerate(data.excludes):\n        if len(ef.value) == 0:\n            continue\n        if ef.type in data.metric_value:\n            f_k = f'exclude_{i}'\n            extra_values = {**extra_values, **sh.multi_values(ef.value, value_key=f_k)}\n            exclusions[ef.type] = [sh.multi_conditions(f\"{JOURNEY_TYPES[ef.type]['column']} != %({f_k})s\", ef.value, is_not=True, value_key=f_k)]\n    meta_keys = None\n    for (i, f) in enumerate(data.series[0].filter.filters):\n        op = sh.get_sql_operator(f.operator)\n        is_any = sh.isAny_opreator(f.operator)\n        is_not = sh.is_negation_operator(f.operator)\n        is_undefined = sh.isUndefined_operator(f.operator)\n        f_k = f'f_value_{i}'\n        extra_values = {**extra_values, **sh.multi_values(f.value, value_key=f_k)}\n        if not is_any and len(f.value) == 0:\n            continue\n        if f.type == schemas.FilterType.user_browser:\n            if is_any:\n                sessions_conditions.append('user_browser IS NOT NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'user_browser {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.user_os]:\n            if is_any:\n                sessions_conditions.append('user_os IS NOT NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'user_os {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.user_device]:\n            if is_any:\n                sessions_conditions.append('user_device IS NOT NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'user_device {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.user_country]:\n            if is_any:\n                sessions_conditions.append('user_country IS NOT NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'user_country {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n        elif f.type == schemas.FilterType.user_city:\n            if is_any:\n                sessions_conditions.append('user_city IS NOT NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'user_city {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n        elif f.type == schemas.FilterType.user_state:\n            if is_any:\n                sessions_conditions.append('user_state IS NOT NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'user_state {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.utm_source]:\n            if is_any:\n                sessions_conditions.append('utm_source IS NOT NULL')\n            elif is_undefined:\n                sessions_conditions.append('utm_source IS NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'utm_source {op} %({f_k})s::text', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.utm_medium]:\n            if is_any:\n                sessions_conditions.append('utm_medium IS NOT NULL')\n            elif is_undefined:\n                sessions_conditions.append('utm_medium IS NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'utm_medium {op} %({f_k})s::text', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.utm_campaign]:\n            if is_any:\n                sessions_conditions.append('utm_campaign IS NOT NULL')\n            elif is_undefined:\n                sessions_conditions.append('utm_campaign IS NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'utm_campaign {op} %({f_k})s::text', f.value, is_not=is_not, value_key=f_k))\n        elif f.type == schemas.FilterType.duration:\n            if len(f.value) > 0 and f.value[0] is not None:\n                sessions_conditions.append('duration >= %(minDuration)s')\n                extra_values['minDuration'] = f.value[0]\n            if len(f.value) > 1 and f.value[1] is not None and (int(f.value[1]) > 0):\n                sessions_conditions.append('duration <= %(maxDuration)s')\n                extra_values['maxDuration'] = f.value[1]\n        elif f.type == schemas.FilterType.referrer:\n            if is_any:\n                sessions_conditions.append('base_referrer IS NOT NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'base_referrer {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n        elif f.type == schemas.FilterType.metadata:\n            if meta_keys is None:\n                meta_keys = metadata.get(project_id=project_id)\n                meta_keys = {m['key']: m['index'] for m in meta_keys}\n            if f.source in meta_keys.keys():\n                if is_any:\n                    sessions_conditions.append(f'{metadata.index_to_colname(meta_keys[f.source])} IS NOT NULL')\n                elif is_undefined:\n                    sessions_conditions.append(f'{metadata.index_to_colname(meta_keys[f.source])} IS NULL')\n                else:\n                    sessions_conditions.append(sh.multi_conditions(f'{metadata.index_to_colname(meta_keys[f.source])} {op} %({f_k})s::text', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.user_id, schemas.FilterType.user_id_ios]:\n            if is_any:\n                sessions_conditions.append('user_id IS NOT NULL')\n            elif is_undefined:\n                sessions_conditions.append('user_id IS NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f's.user_id {op} %({f_k})s::text', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.user_anonymous_id, schemas.FilterType.user_anonymous_id_ios]:\n            if is_any:\n                sessions_conditions.append('user_anonymous_id IS NOT NULL')\n            elif is_undefined:\n                sessions_conditions.append('user_anonymous_id IS NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'user_anonymous_id {op} %({f_k})s::text', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.rev_id, schemas.FilterType.rev_id_ios]:\n            if is_any:\n                sessions_conditions.append('rev_id IS NOT NULL')\n            elif is_undefined:\n                sessions_conditions.append('rev_id IS NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'rev_id {op} %({f_k})s::text', f.value, is_not=is_not, value_key=f_k))\n        elif f.type == schemas.FilterType.platform:\n            sessions_conditions.append(sh.multi_conditions(f'user_device_type {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n        elif f.type == schemas.FilterType.issue:\n            if is_any:\n                sessions_conditions.append('array_length(issue_types, 1) > 0')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'%({f_k})s {op} ANY (issue_types)', f.value, is_not=is_not, value_key=f_k))\n        elif f.type == schemas.FilterType.events_count:\n            sessions_conditions.append(sh.multi_conditions(f'events_count {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n    events_subquery = []\n    for t in sub_events:\n        sub_events_conditions = ['e.timestamp >= %(startTimestamp)s', 'e.timestamp < %(endTimestamp)s'] + exclusions.get(t['eventType'], [])\n        if len(start_points_conditions) > 0:\n            sub_events_conditions.append('e.timestamp >= sub_sessions.start_event_timestamp')\n        events_subquery.append(f\"                   SELECT session_id, {t['column']} AS e_value, timestamp, '{t['eventType']}' AS event_type\\n                   FROM {t['table']} AS e INNER JOIN sub_sessions USING (session_id)\\n                   WHERE {' AND '.join(sub_events_conditions)}\")\n    events_subquery = '\\n UNION ALL \\n'.join(events_subquery)\n    if reverse:\n        path_direction = 'DESC'\n    else:\n        path_direction = ''\n    if len(start_points_conditions) == 0:\n        start_points_from = '(SELECT event_type, e_value\\n                                FROM pre_ranked_events\\n                                WHERE event_number_in_session = 1\\n                                GROUP BY event_type, e_value\\n                                ORDER BY count(1) DESC\\n                                LIMIT 1) AS top_start_events\\n                                   INNER JOIN pre_ranked_events\\n                                              USING (event_type, e_value)'\n    else:\n        sub_sessions_extra_projection = ', MIN(timestamp) AS start_event_timestamp'\n        start_points_conditions = ['(' + ' OR '.join(start_points_conditions) + ')']\n    start_points_conditions.append('event_number_in_session = 1')\n    steps_query = ['n1 AS (SELECT event_number_in_session,\\n                                    event_type,\\n                                    e_value,\\n                                    next_type,\\n                                    next_value,\\n                                    AVG(time_from_previous) AS avg_time_from_previous,\\n                                    COUNT(1) AS sessions_count\\n                             FROM ranked_events INNER JOIN start_points USING (session_id)\\n                             WHERE event_number_in_session = 1 \\n                                AND next_value IS NOT NULL\\n                             GROUP BY event_number_in_session, event_type, e_value, next_type, next_value\\n                             ORDER BY sessions_count DESC\\n                             LIMIT %(eventThresholdNumberInGroup)s)']\n    projection_query = ['(SELECT event_number_in_session,\\n                                   event_type,\\n                                   e_value,\\n                                   next_type,\\n                                   next_value,\\n                                   sessions_count,\\n                                   avg_time_from_previous\\n                           FROM n1)']\n    for i in range(2, data.density + 1):\n        steps_query.append(f'n{i} AS (SELECT *\\n                                      FROM (SELECT re.event_number_in_session,\\n                                                   re.event_type,\\n                                                   re.e_value,\\n                                                   re.next_type,\\n                                                   re.next_value,\\n                                                   AVG(re.time_from_previous) AS avg_time_from_previous,\\n                                                   COUNT(1) AS sessions_count\\n                                            FROM ranked_events AS re\\n                                                     INNER JOIN n{i - 1} ON (n{i - 1}.next_value = re.e_value)\\n                                            WHERE re.event_number_in_session = {i}\\n                                            GROUP BY re.event_number_in_session, re.event_type, re.e_value, re.next_type, re.next_value) AS sub_level\\n                                      ORDER BY sessions_count DESC\\n                                      LIMIT %(eventThresholdNumberInGroup)s)')\n        projection_query.append(f'(SELECT event_number_in_session,\\n                                            event_type,\\n                                            e_value,\\n                                            next_type,\\n                                            next_value,\\n                                            sessions_count,\\n                                            avg_time_from_previous\\n                                     FROM n{i})')\n    with pg_client.PostgresClient() as cur:\n        pg_query = f\"WITH sub_sessions AS (SELECT session_id {sub_sessions_extra_projection}\\n                      FROM public.sessions {' '.join(start_join)}\\n                      WHERE {' AND '.join(sessions_conditions)}\\n                      {('GROUP BY session_id' if len(start_points_conditions) > 0 else '')}),\\n     sub_events AS ({events_subquery}),\\n     pre_ranked_events AS (SELECT *\\n                           FROM (SELECT session_id,\\n                                        event_type,\\n                                        e_value,\\n                                        timestamp,\\n                                        row_number() OVER (PARTITION BY session_id ORDER BY timestamp {path_direction}) AS event_number_in_session\\n                                 FROM sub_events\\n                                 ORDER BY session_id) AS full_ranked_events\\n                           WHERE event_number_in_session <= %(density)s),\\n     start_points AS (SELECT session_id\\n                      FROM {start_points_from}\\n                      WHERE {' AND '.join(start_points_conditions)}),\\n     ranked_events AS (SELECT *,\\n                              LEAD(e_value, 1) OVER (PARTITION BY session_id ORDER BY timestamp {path_direction})    AS next_value,\\n                              LEAD(event_type, 1) OVER (PARTITION BY session_id ORDER BY timestamp {path_direction}) AS next_type,\\n                              abs(LAG(timestamp, 1) OVER (PARTITION BY session_id ORDER BY timestamp {path_direction}) -\\n                                  timestamp)                                                         AS time_from_previous\\n                       FROM pre_ranked_events INNER JOIN start_points USING (session_id)),\\n     {','.join(steps_query)}\\n{'UNION ALL'.join(projection_query)};\"\n        params = {'project_id': project_id, 'startTimestamp': data.startTimestamp, 'endTimestamp': data.endTimestamp, 'density': data.density, 'eventThresholdNumberInGroup': 4 if data.hide_excess else 8, **extra_values}\n        query = cur.mogrify(pg_query, params)\n        _now = time()\n        cur.execute(query)\n        if time() - _now > 2:\n            logger.warning(f'>>>>>>>>>PathAnalysis long query ({int(time() - _now)}s)<<<<<<<<<')\n            logger.warning('----------------------')\n            logger.warning(query)\n            logger.warning('----------------------')\n        rows = cur.fetchall()\n    return __transform_journey(rows=rows, reverse_path=reverse)",
            "def path_analysis(project_id: int, data: schemas.CardPathAnalysis):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    sub_events = []\n    start_points_from = 'pre_ranked_events'\n    sub_sessions_extra_projection = ''\n    start_points_conditions = []\n    sessions_conditions = ['start_ts>=%(startTimestamp)s', 'start_ts<%(endTimestamp)s', 'project_id=%(project_id)s', 'events_count > 1', 'duration>0']\n    if len(data.metric_value) == 0:\n        data.metric_value.append(schemas.ProductAnalyticsSelectedEventType.location)\n        sub_events.append({'table': JOURNEY_TYPES[schemas.ProductAnalyticsSelectedEventType.location]['table'], 'column': JOURNEY_TYPES[schemas.ProductAnalyticsSelectedEventType.location]['column'], 'eventType': schemas.ProductAnalyticsSelectedEventType.location.value})\n    else:\n        for v in data.metric_value:\n            if JOURNEY_TYPES.get(v):\n                sub_events.append({'table': JOURNEY_TYPES[v]['table'], 'column': JOURNEY_TYPES[v]['column'], 'eventType': v})\n    extra_values = {}\n    start_join = []\n    reverse = data.start_type == 'end'\n    for (i, sf) in enumerate(data.start_point):\n        f_k = f'start_point_{i}'\n        op = sh.get_sql_operator(sf.operator)\n        sf.value = helper.values_for_operator(value=sf.value, op=sf.operator)\n        is_not = sh.is_negation_operator(sf.operator)\n        extra_values = {**extra_values, **sh.multi_values(sf.value, value_key=f_k)}\n        start_points_conditions.append(f\"(event_type='{sf.type}' AND \" + sh.multi_conditions(f'e_value {op} %({f_k})s', sf.value, is_not=is_not, value_key=f_k) + ')')\n        main_column = JOURNEY_TYPES[sf.type]['column']\n        sessions_conditions.append(sh.multi_conditions(f'{main_column} {op} %({f_k})s', sf.value, is_not=is_not, value_key=f_k))\n        sessions_conditions += ['timestamp>=%(startTimestamp)s', 'timestamp<%(endTimestamp)s']\n        start_join.append(f\"INNER JOIN {JOURNEY_TYPES[sf.type]['table']} USING (session_id)\")\n    exclusions = {}\n    for (i, ef) in enumerate(data.excludes):\n        if len(ef.value) == 0:\n            continue\n        if ef.type in data.metric_value:\n            f_k = f'exclude_{i}'\n            extra_values = {**extra_values, **sh.multi_values(ef.value, value_key=f_k)}\n            exclusions[ef.type] = [sh.multi_conditions(f\"{JOURNEY_TYPES[ef.type]['column']} != %({f_k})s\", ef.value, is_not=True, value_key=f_k)]\n    meta_keys = None\n    for (i, f) in enumerate(data.series[0].filter.filters):\n        op = sh.get_sql_operator(f.operator)\n        is_any = sh.isAny_opreator(f.operator)\n        is_not = sh.is_negation_operator(f.operator)\n        is_undefined = sh.isUndefined_operator(f.operator)\n        f_k = f'f_value_{i}'\n        extra_values = {**extra_values, **sh.multi_values(f.value, value_key=f_k)}\n        if not is_any and len(f.value) == 0:\n            continue\n        if f.type == schemas.FilterType.user_browser:\n            if is_any:\n                sessions_conditions.append('user_browser IS NOT NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'user_browser {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.user_os]:\n            if is_any:\n                sessions_conditions.append('user_os IS NOT NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'user_os {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.user_device]:\n            if is_any:\n                sessions_conditions.append('user_device IS NOT NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'user_device {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.user_country]:\n            if is_any:\n                sessions_conditions.append('user_country IS NOT NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'user_country {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n        elif f.type == schemas.FilterType.user_city:\n            if is_any:\n                sessions_conditions.append('user_city IS NOT NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'user_city {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n        elif f.type == schemas.FilterType.user_state:\n            if is_any:\n                sessions_conditions.append('user_state IS NOT NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'user_state {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.utm_source]:\n            if is_any:\n                sessions_conditions.append('utm_source IS NOT NULL')\n            elif is_undefined:\n                sessions_conditions.append('utm_source IS NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'utm_source {op} %({f_k})s::text', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.utm_medium]:\n            if is_any:\n                sessions_conditions.append('utm_medium IS NOT NULL')\n            elif is_undefined:\n                sessions_conditions.append('utm_medium IS NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'utm_medium {op} %({f_k})s::text', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.utm_campaign]:\n            if is_any:\n                sessions_conditions.append('utm_campaign IS NOT NULL')\n            elif is_undefined:\n                sessions_conditions.append('utm_campaign IS NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'utm_campaign {op} %({f_k})s::text', f.value, is_not=is_not, value_key=f_k))\n        elif f.type == schemas.FilterType.duration:\n            if len(f.value) > 0 and f.value[0] is not None:\n                sessions_conditions.append('duration >= %(minDuration)s')\n                extra_values['minDuration'] = f.value[0]\n            if len(f.value) > 1 and f.value[1] is not None and (int(f.value[1]) > 0):\n                sessions_conditions.append('duration <= %(maxDuration)s')\n                extra_values['maxDuration'] = f.value[1]\n        elif f.type == schemas.FilterType.referrer:\n            if is_any:\n                sessions_conditions.append('base_referrer IS NOT NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'base_referrer {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n        elif f.type == schemas.FilterType.metadata:\n            if meta_keys is None:\n                meta_keys = metadata.get(project_id=project_id)\n                meta_keys = {m['key']: m['index'] for m in meta_keys}\n            if f.source in meta_keys.keys():\n                if is_any:\n                    sessions_conditions.append(f'{metadata.index_to_colname(meta_keys[f.source])} IS NOT NULL')\n                elif is_undefined:\n                    sessions_conditions.append(f'{metadata.index_to_colname(meta_keys[f.source])} IS NULL')\n                else:\n                    sessions_conditions.append(sh.multi_conditions(f'{metadata.index_to_colname(meta_keys[f.source])} {op} %({f_k})s::text', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.user_id, schemas.FilterType.user_id_ios]:\n            if is_any:\n                sessions_conditions.append('user_id IS NOT NULL')\n            elif is_undefined:\n                sessions_conditions.append('user_id IS NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f's.user_id {op} %({f_k})s::text', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.user_anonymous_id, schemas.FilterType.user_anonymous_id_ios]:\n            if is_any:\n                sessions_conditions.append('user_anonymous_id IS NOT NULL')\n            elif is_undefined:\n                sessions_conditions.append('user_anonymous_id IS NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'user_anonymous_id {op} %({f_k})s::text', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.rev_id, schemas.FilterType.rev_id_ios]:\n            if is_any:\n                sessions_conditions.append('rev_id IS NOT NULL')\n            elif is_undefined:\n                sessions_conditions.append('rev_id IS NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'rev_id {op} %({f_k})s::text', f.value, is_not=is_not, value_key=f_k))\n        elif f.type == schemas.FilterType.platform:\n            sessions_conditions.append(sh.multi_conditions(f'user_device_type {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n        elif f.type == schemas.FilterType.issue:\n            if is_any:\n                sessions_conditions.append('array_length(issue_types, 1) > 0')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'%({f_k})s {op} ANY (issue_types)', f.value, is_not=is_not, value_key=f_k))\n        elif f.type == schemas.FilterType.events_count:\n            sessions_conditions.append(sh.multi_conditions(f'events_count {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n    events_subquery = []\n    for t in sub_events:\n        sub_events_conditions = ['e.timestamp >= %(startTimestamp)s', 'e.timestamp < %(endTimestamp)s'] + exclusions.get(t['eventType'], [])\n        if len(start_points_conditions) > 0:\n            sub_events_conditions.append('e.timestamp >= sub_sessions.start_event_timestamp')\n        events_subquery.append(f\"                   SELECT session_id, {t['column']} AS e_value, timestamp, '{t['eventType']}' AS event_type\\n                   FROM {t['table']} AS e INNER JOIN sub_sessions USING (session_id)\\n                   WHERE {' AND '.join(sub_events_conditions)}\")\n    events_subquery = '\\n UNION ALL \\n'.join(events_subquery)\n    if reverse:\n        path_direction = 'DESC'\n    else:\n        path_direction = ''\n    if len(start_points_conditions) == 0:\n        start_points_from = '(SELECT event_type, e_value\\n                                FROM pre_ranked_events\\n                                WHERE event_number_in_session = 1\\n                                GROUP BY event_type, e_value\\n                                ORDER BY count(1) DESC\\n                                LIMIT 1) AS top_start_events\\n                                   INNER JOIN pre_ranked_events\\n                                              USING (event_type, e_value)'\n    else:\n        sub_sessions_extra_projection = ', MIN(timestamp) AS start_event_timestamp'\n        start_points_conditions = ['(' + ' OR '.join(start_points_conditions) + ')']\n    start_points_conditions.append('event_number_in_session = 1')\n    steps_query = ['n1 AS (SELECT event_number_in_session,\\n                                    event_type,\\n                                    e_value,\\n                                    next_type,\\n                                    next_value,\\n                                    AVG(time_from_previous) AS avg_time_from_previous,\\n                                    COUNT(1) AS sessions_count\\n                             FROM ranked_events INNER JOIN start_points USING (session_id)\\n                             WHERE event_number_in_session = 1 \\n                                AND next_value IS NOT NULL\\n                             GROUP BY event_number_in_session, event_type, e_value, next_type, next_value\\n                             ORDER BY sessions_count DESC\\n                             LIMIT %(eventThresholdNumberInGroup)s)']\n    projection_query = ['(SELECT event_number_in_session,\\n                                   event_type,\\n                                   e_value,\\n                                   next_type,\\n                                   next_value,\\n                                   sessions_count,\\n                                   avg_time_from_previous\\n                           FROM n1)']\n    for i in range(2, data.density + 1):\n        steps_query.append(f'n{i} AS (SELECT *\\n                                      FROM (SELECT re.event_number_in_session,\\n                                                   re.event_type,\\n                                                   re.e_value,\\n                                                   re.next_type,\\n                                                   re.next_value,\\n                                                   AVG(re.time_from_previous) AS avg_time_from_previous,\\n                                                   COUNT(1) AS sessions_count\\n                                            FROM ranked_events AS re\\n                                                     INNER JOIN n{i - 1} ON (n{i - 1}.next_value = re.e_value)\\n                                            WHERE re.event_number_in_session = {i}\\n                                            GROUP BY re.event_number_in_session, re.event_type, re.e_value, re.next_type, re.next_value) AS sub_level\\n                                      ORDER BY sessions_count DESC\\n                                      LIMIT %(eventThresholdNumberInGroup)s)')\n        projection_query.append(f'(SELECT event_number_in_session,\\n                                            event_type,\\n                                            e_value,\\n                                            next_type,\\n                                            next_value,\\n                                            sessions_count,\\n                                            avg_time_from_previous\\n                                     FROM n{i})')\n    with pg_client.PostgresClient() as cur:\n        pg_query = f\"WITH sub_sessions AS (SELECT session_id {sub_sessions_extra_projection}\\n                      FROM public.sessions {' '.join(start_join)}\\n                      WHERE {' AND '.join(sessions_conditions)}\\n                      {('GROUP BY session_id' if len(start_points_conditions) > 0 else '')}),\\n     sub_events AS ({events_subquery}),\\n     pre_ranked_events AS (SELECT *\\n                           FROM (SELECT session_id,\\n                                        event_type,\\n                                        e_value,\\n                                        timestamp,\\n                                        row_number() OVER (PARTITION BY session_id ORDER BY timestamp {path_direction}) AS event_number_in_session\\n                                 FROM sub_events\\n                                 ORDER BY session_id) AS full_ranked_events\\n                           WHERE event_number_in_session <= %(density)s),\\n     start_points AS (SELECT session_id\\n                      FROM {start_points_from}\\n                      WHERE {' AND '.join(start_points_conditions)}),\\n     ranked_events AS (SELECT *,\\n                              LEAD(e_value, 1) OVER (PARTITION BY session_id ORDER BY timestamp {path_direction})    AS next_value,\\n                              LEAD(event_type, 1) OVER (PARTITION BY session_id ORDER BY timestamp {path_direction}) AS next_type,\\n                              abs(LAG(timestamp, 1) OVER (PARTITION BY session_id ORDER BY timestamp {path_direction}) -\\n                                  timestamp)                                                         AS time_from_previous\\n                       FROM pre_ranked_events INNER JOIN start_points USING (session_id)),\\n     {','.join(steps_query)}\\n{'UNION ALL'.join(projection_query)};\"\n        params = {'project_id': project_id, 'startTimestamp': data.startTimestamp, 'endTimestamp': data.endTimestamp, 'density': data.density, 'eventThresholdNumberInGroup': 4 if data.hide_excess else 8, **extra_values}\n        query = cur.mogrify(pg_query, params)\n        _now = time()\n        cur.execute(query)\n        if time() - _now > 2:\n            logger.warning(f'>>>>>>>>>PathAnalysis long query ({int(time() - _now)}s)<<<<<<<<<')\n            logger.warning('----------------------')\n            logger.warning(query)\n            logger.warning('----------------------')\n        rows = cur.fetchall()\n    return __transform_journey(rows=rows, reverse_path=reverse)",
            "def path_analysis(project_id: int, data: schemas.CardPathAnalysis):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    sub_events = []\n    start_points_from = 'pre_ranked_events'\n    sub_sessions_extra_projection = ''\n    start_points_conditions = []\n    sessions_conditions = ['start_ts>=%(startTimestamp)s', 'start_ts<%(endTimestamp)s', 'project_id=%(project_id)s', 'events_count > 1', 'duration>0']\n    if len(data.metric_value) == 0:\n        data.metric_value.append(schemas.ProductAnalyticsSelectedEventType.location)\n        sub_events.append({'table': JOURNEY_TYPES[schemas.ProductAnalyticsSelectedEventType.location]['table'], 'column': JOURNEY_TYPES[schemas.ProductAnalyticsSelectedEventType.location]['column'], 'eventType': schemas.ProductAnalyticsSelectedEventType.location.value})\n    else:\n        for v in data.metric_value:\n            if JOURNEY_TYPES.get(v):\n                sub_events.append({'table': JOURNEY_TYPES[v]['table'], 'column': JOURNEY_TYPES[v]['column'], 'eventType': v})\n    extra_values = {}\n    start_join = []\n    reverse = data.start_type == 'end'\n    for (i, sf) in enumerate(data.start_point):\n        f_k = f'start_point_{i}'\n        op = sh.get_sql_operator(sf.operator)\n        sf.value = helper.values_for_operator(value=sf.value, op=sf.operator)\n        is_not = sh.is_negation_operator(sf.operator)\n        extra_values = {**extra_values, **sh.multi_values(sf.value, value_key=f_k)}\n        start_points_conditions.append(f\"(event_type='{sf.type}' AND \" + sh.multi_conditions(f'e_value {op} %({f_k})s', sf.value, is_not=is_not, value_key=f_k) + ')')\n        main_column = JOURNEY_TYPES[sf.type]['column']\n        sessions_conditions.append(sh.multi_conditions(f'{main_column} {op} %({f_k})s', sf.value, is_not=is_not, value_key=f_k))\n        sessions_conditions += ['timestamp>=%(startTimestamp)s', 'timestamp<%(endTimestamp)s']\n        start_join.append(f\"INNER JOIN {JOURNEY_TYPES[sf.type]['table']} USING (session_id)\")\n    exclusions = {}\n    for (i, ef) in enumerate(data.excludes):\n        if len(ef.value) == 0:\n            continue\n        if ef.type in data.metric_value:\n            f_k = f'exclude_{i}'\n            extra_values = {**extra_values, **sh.multi_values(ef.value, value_key=f_k)}\n            exclusions[ef.type] = [sh.multi_conditions(f\"{JOURNEY_TYPES[ef.type]['column']} != %({f_k})s\", ef.value, is_not=True, value_key=f_k)]\n    meta_keys = None\n    for (i, f) in enumerate(data.series[0].filter.filters):\n        op = sh.get_sql_operator(f.operator)\n        is_any = sh.isAny_opreator(f.operator)\n        is_not = sh.is_negation_operator(f.operator)\n        is_undefined = sh.isUndefined_operator(f.operator)\n        f_k = f'f_value_{i}'\n        extra_values = {**extra_values, **sh.multi_values(f.value, value_key=f_k)}\n        if not is_any and len(f.value) == 0:\n            continue\n        if f.type == schemas.FilterType.user_browser:\n            if is_any:\n                sessions_conditions.append('user_browser IS NOT NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'user_browser {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.user_os]:\n            if is_any:\n                sessions_conditions.append('user_os IS NOT NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'user_os {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.user_device]:\n            if is_any:\n                sessions_conditions.append('user_device IS NOT NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'user_device {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.user_country]:\n            if is_any:\n                sessions_conditions.append('user_country IS NOT NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'user_country {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n        elif f.type == schemas.FilterType.user_city:\n            if is_any:\n                sessions_conditions.append('user_city IS NOT NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'user_city {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n        elif f.type == schemas.FilterType.user_state:\n            if is_any:\n                sessions_conditions.append('user_state IS NOT NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'user_state {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.utm_source]:\n            if is_any:\n                sessions_conditions.append('utm_source IS NOT NULL')\n            elif is_undefined:\n                sessions_conditions.append('utm_source IS NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'utm_source {op} %({f_k})s::text', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.utm_medium]:\n            if is_any:\n                sessions_conditions.append('utm_medium IS NOT NULL')\n            elif is_undefined:\n                sessions_conditions.append('utm_medium IS NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'utm_medium {op} %({f_k})s::text', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.utm_campaign]:\n            if is_any:\n                sessions_conditions.append('utm_campaign IS NOT NULL')\n            elif is_undefined:\n                sessions_conditions.append('utm_campaign IS NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'utm_campaign {op} %({f_k})s::text', f.value, is_not=is_not, value_key=f_k))\n        elif f.type == schemas.FilterType.duration:\n            if len(f.value) > 0 and f.value[0] is not None:\n                sessions_conditions.append('duration >= %(minDuration)s')\n                extra_values['minDuration'] = f.value[0]\n            if len(f.value) > 1 and f.value[1] is not None and (int(f.value[1]) > 0):\n                sessions_conditions.append('duration <= %(maxDuration)s')\n                extra_values['maxDuration'] = f.value[1]\n        elif f.type == schemas.FilterType.referrer:\n            if is_any:\n                sessions_conditions.append('base_referrer IS NOT NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'base_referrer {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n        elif f.type == schemas.FilterType.metadata:\n            if meta_keys is None:\n                meta_keys = metadata.get(project_id=project_id)\n                meta_keys = {m['key']: m['index'] for m in meta_keys}\n            if f.source in meta_keys.keys():\n                if is_any:\n                    sessions_conditions.append(f'{metadata.index_to_colname(meta_keys[f.source])} IS NOT NULL')\n                elif is_undefined:\n                    sessions_conditions.append(f'{metadata.index_to_colname(meta_keys[f.source])} IS NULL')\n                else:\n                    sessions_conditions.append(sh.multi_conditions(f'{metadata.index_to_colname(meta_keys[f.source])} {op} %({f_k})s::text', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.user_id, schemas.FilterType.user_id_ios]:\n            if is_any:\n                sessions_conditions.append('user_id IS NOT NULL')\n            elif is_undefined:\n                sessions_conditions.append('user_id IS NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f's.user_id {op} %({f_k})s::text', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.user_anonymous_id, schemas.FilterType.user_anonymous_id_ios]:\n            if is_any:\n                sessions_conditions.append('user_anonymous_id IS NOT NULL')\n            elif is_undefined:\n                sessions_conditions.append('user_anonymous_id IS NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'user_anonymous_id {op} %({f_k})s::text', f.value, is_not=is_not, value_key=f_k))\n        elif f.type in [schemas.FilterType.rev_id, schemas.FilterType.rev_id_ios]:\n            if is_any:\n                sessions_conditions.append('rev_id IS NOT NULL')\n            elif is_undefined:\n                sessions_conditions.append('rev_id IS NULL')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'rev_id {op} %({f_k})s::text', f.value, is_not=is_not, value_key=f_k))\n        elif f.type == schemas.FilterType.platform:\n            sessions_conditions.append(sh.multi_conditions(f'user_device_type {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n        elif f.type == schemas.FilterType.issue:\n            if is_any:\n                sessions_conditions.append('array_length(issue_types, 1) > 0')\n            else:\n                sessions_conditions.append(sh.multi_conditions(f'%({f_k})s {op} ANY (issue_types)', f.value, is_not=is_not, value_key=f_k))\n        elif f.type == schemas.FilterType.events_count:\n            sessions_conditions.append(sh.multi_conditions(f'events_count {op} %({f_k})s', f.value, is_not=is_not, value_key=f_k))\n    events_subquery = []\n    for t in sub_events:\n        sub_events_conditions = ['e.timestamp >= %(startTimestamp)s', 'e.timestamp < %(endTimestamp)s'] + exclusions.get(t['eventType'], [])\n        if len(start_points_conditions) > 0:\n            sub_events_conditions.append('e.timestamp >= sub_sessions.start_event_timestamp')\n        events_subquery.append(f\"                   SELECT session_id, {t['column']} AS e_value, timestamp, '{t['eventType']}' AS event_type\\n                   FROM {t['table']} AS e INNER JOIN sub_sessions USING (session_id)\\n                   WHERE {' AND '.join(sub_events_conditions)}\")\n    events_subquery = '\\n UNION ALL \\n'.join(events_subquery)\n    if reverse:\n        path_direction = 'DESC'\n    else:\n        path_direction = ''\n    if len(start_points_conditions) == 0:\n        start_points_from = '(SELECT event_type, e_value\\n                                FROM pre_ranked_events\\n                                WHERE event_number_in_session = 1\\n                                GROUP BY event_type, e_value\\n                                ORDER BY count(1) DESC\\n                                LIMIT 1) AS top_start_events\\n                                   INNER JOIN pre_ranked_events\\n                                              USING (event_type, e_value)'\n    else:\n        sub_sessions_extra_projection = ', MIN(timestamp) AS start_event_timestamp'\n        start_points_conditions = ['(' + ' OR '.join(start_points_conditions) + ')']\n    start_points_conditions.append('event_number_in_session = 1')\n    steps_query = ['n1 AS (SELECT event_number_in_session,\\n                                    event_type,\\n                                    e_value,\\n                                    next_type,\\n                                    next_value,\\n                                    AVG(time_from_previous) AS avg_time_from_previous,\\n                                    COUNT(1) AS sessions_count\\n                             FROM ranked_events INNER JOIN start_points USING (session_id)\\n                             WHERE event_number_in_session = 1 \\n                                AND next_value IS NOT NULL\\n                             GROUP BY event_number_in_session, event_type, e_value, next_type, next_value\\n                             ORDER BY sessions_count DESC\\n                             LIMIT %(eventThresholdNumberInGroup)s)']\n    projection_query = ['(SELECT event_number_in_session,\\n                                   event_type,\\n                                   e_value,\\n                                   next_type,\\n                                   next_value,\\n                                   sessions_count,\\n                                   avg_time_from_previous\\n                           FROM n1)']\n    for i in range(2, data.density + 1):\n        steps_query.append(f'n{i} AS (SELECT *\\n                                      FROM (SELECT re.event_number_in_session,\\n                                                   re.event_type,\\n                                                   re.e_value,\\n                                                   re.next_type,\\n                                                   re.next_value,\\n                                                   AVG(re.time_from_previous) AS avg_time_from_previous,\\n                                                   COUNT(1) AS sessions_count\\n                                            FROM ranked_events AS re\\n                                                     INNER JOIN n{i - 1} ON (n{i - 1}.next_value = re.e_value)\\n                                            WHERE re.event_number_in_session = {i}\\n                                            GROUP BY re.event_number_in_session, re.event_type, re.e_value, re.next_type, re.next_value) AS sub_level\\n                                      ORDER BY sessions_count DESC\\n                                      LIMIT %(eventThresholdNumberInGroup)s)')\n        projection_query.append(f'(SELECT event_number_in_session,\\n                                            event_type,\\n                                            e_value,\\n                                            next_type,\\n                                            next_value,\\n                                            sessions_count,\\n                                            avg_time_from_previous\\n                                     FROM n{i})')\n    with pg_client.PostgresClient() as cur:\n        pg_query = f\"WITH sub_sessions AS (SELECT session_id {sub_sessions_extra_projection}\\n                      FROM public.sessions {' '.join(start_join)}\\n                      WHERE {' AND '.join(sessions_conditions)}\\n                      {('GROUP BY session_id' if len(start_points_conditions) > 0 else '')}),\\n     sub_events AS ({events_subquery}),\\n     pre_ranked_events AS (SELECT *\\n                           FROM (SELECT session_id,\\n                                        event_type,\\n                                        e_value,\\n                                        timestamp,\\n                                        row_number() OVER (PARTITION BY session_id ORDER BY timestamp {path_direction}) AS event_number_in_session\\n                                 FROM sub_events\\n                                 ORDER BY session_id) AS full_ranked_events\\n                           WHERE event_number_in_session <= %(density)s),\\n     start_points AS (SELECT session_id\\n                      FROM {start_points_from}\\n                      WHERE {' AND '.join(start_points_conditions)}),\\n     ranked_events AS (SELECT *,\\n                              LEAD(e_value, 1) OVER (PARTITION BY session_id ORDER BY timestamp {path_direction})    AS next_value,\\n                              LEAD(event_type, 1) OVER (PARTITION BY session_id ORDER BY timestamp {path_direction}) AS next_type,\\n                              abs(LAG(timestamp, 1) OVER (PARTITION BY session_id ORDER BY timestamp {path_direction}) -\\n                                  timestamp)                                                         AS time_from_previous\\n                       FROM pre_ranked_events INNER JOIN start_points USING (session_id)),\\n     {','.join(steps_query)}\\n{'UNION ALL'.join(projection_query)};\"\n        params = {'project_id': project_id, 'startTimestamp': data.startTimestamp, 'endTimestamp': data.endTimestamp, 'density': data.density, 'eventThresholdNumberInGroup': 4 if data.hide_excess else 8, **extra_values}\n        query = cur.mogrify(pg_query, params)\n        _now = time()\n        cur.execute(query)\n        if time() - _now > 2:\n            logger.warning(f'>>>>>>>>>PathAnalysis long query ({int(time() - _now)}s)<<<<<<<<<')\n            logger.warning('----------------------')\n            logger.warning(query)\n            logger.warning('----------------------')\n        rows = cur.fetchall()\n    return __transform_journey(rows=rows, reverse_path=reverse)"
        ]
    }
]