[
    {
        "func_name": "csvdir_equities",
        "original": "def csvdir_equities(tframes=None, csvdir=None):\n    \"\"\"\n    Generate an ingest function for custom data bundle\n    This function can be used in ~/.zipline/extension.py\n    to register bundle with custom parameters, e.g. with\n    a custom trading calendar.\n\n    Parameters\n    ----------\n    tframes: tuple, optional\n        The data time frames, supported timeframes: 'daily' and 'minute'\n    csvdir : string, optional, default: CSVDIR environment variable\n        The path to the directory of this structure:\n        <directory>/<timeframe1>/<symbol1>.csv\n        <directory>/<timeframe1>/<symbol2>.csv\n        <directory>/<timeframe1>/<symbol3>.csv\n        <directory>/<timeframe2>/<symbol1>.csv\n        <directory>/<timeframe2>/<symbol2>.csv\n        <directory>/<timeframe2>/<symbol3>.csv\n\n    Returns\n    -------\n    ingest : callable\n        The bundle ingest function\n\n    Examples\n    --------\n    This code should be added to ~/.zipline/extension.py\n    .. code-block:: python\n       from zipline.data.bundles import csvdir_equities, register\n       register('custom-csvdir-bundle',\n                csvdir_equities([\"daily\", \"minute\"],\n                '/full/path/to/the/csvdir/directory'))\n    \"\"\"\n    return CSVDIRBundle(tframes, csvdir).ingest",
        "mutated": [
            "def csvdir_equities(tframes=None, csvdir=None):\n    if False:\n        i = 10\n    '\\n    Generate an ingest function for custom data bundle\\n    This function can be used in ~/.zipline/extension.py\\n    to register bundle with custom parameters, e.g. with\\n    a custom trading calendar.\\n\\n    Parameters\\n    ----------\\n    tframes: tuple, optional\\n        The data time frames, supported timeframes: \\'daily\\' and \\'minute\\'\\n    csvdir : string, optional, default: CSVDIR environment variable\\n        The path to the directory of this structure:\\n        <directory>/<timeframe1>/<symbol1>.csv\\n        <directory>/<timeframe1>/<symbol2>.csv\\n        <directory>/<timeframe1>/<symbol3>.csv\\n        <directory>/<timeframe2>/<symbol1>.csv\\n        <directory>/<timeframe2>/<symbol2>.csv\\n        <directory>/<timeframe2>/<symbol3>.csv\\n\\n    Returns\\n    -------\\n    ingest : callable\\n        The bundle ingest function\\n\\n    Examples\\n    --------\\n    This code should be added to ~/.zipline/extension.py\\n    .. code-block:: python\\n       from zipline.data.bundles import csvdir_equities, register\\n       register(\\'custom-csvdir-bundle\\',\\n                csvdir_equities([\"daily\", \"minute\"],\\n                \\'/full/path/to/the/csvdir/directory\\'))\\n    '\n    return CSVDIRBundle(tframes, csvdir).ingest",
            "def csvdir_equities(tframes=None, csvdir=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Generate an ingest function for custom data bundle\\n    This function can be used in ~/.zipline/extension.py\\n    to register bundle with custom parameters, e.g. with\\n    a custom trading calendar.\\n\\n    Parameters\\n    ----------\\n    tframes: tuple, optional\\n        The data time frames, supported timeframes: \\'daily\\' and \\'minute\\'\\n    csvdir : string, optional, default: CSVDIR environment variable\\n        The path to the directory of this structure:\\n        <directory>/<timeframe1>/<symbol1>.csv\\n        <directory>/<timeframe1>/<symbol2>.csv\\n        <directory>/<timeframe1>/<symbol3>.csv\\n        <directory>/<timeframe2>/<symbol1>.csv\\n        <directory>/<timeframe2>/<symbol2>.csv\\n        <directory>/<timeframe2>/<symbol3>.csv\\n\\n    Returns\\n    -------\\n    ingest : callable\\n        The bundle ingest function\\n\\n    Examples\\n    --------\\n    This code should be added to ~/.zipline/extension.py\\n    .. code-block:: python\\n       from zipline.data.bundles import csvdir_equities, register\\n       register(\\'custom-csvdir-bundle\\',\\n                csvdir_equities([\"daily\", \"minute\"],\\n                \\'/full/path/to/the/csvdir/directory\\'))\\n    '\n    return CSVDIRBundle(tframes, csvdir).ingest",
            "def csvdir_equities(tframes=None, csvdir=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Generate an ingest function for custom data bundle\\n    This function can be used in ~/.zipline/extension.py\\n    to register bundle with custom parameters, e.g. with\\n    a custom trading calendar.\\n\\n    Parameters\\n    ----------\\n    tframes: tuple, optional\\n        The data time frames, supported timeframes: \\'daily\\' and \\'minute\\'\\n    csvdir : string, optional, default: CSVDIR environment variable\\n        The path to the directory of this structure:\\n        <directory>/<timeframe1>/<symbol1>.csv\\n        <directory>/<timeframe1>/<symbol2>.csv\\n        <directory>/<timeframe1>/<symbol3>.csv\\n        <directory>/<timeframe2>/<symbol1>.csv\\n        <directory>/<timeframe2>/<symbol2>.csv\\n        <directory>/<timeframe2>/<symbol3>.csv\\n\\n    Returns\\n    -------\\n    ingest : callable\\n        The bundle ingest function\\n\\n    Examples\\n    --------\\n    This code should be added to ~/.zipline/extension.py\\n    .. code-block:: python\\n       from zipline.data.bundles import csvdir_equities, register\\n       register(\\'custom-csvdir-bundle\\',\\n                csvdir_equities([\"daily\", \"minute\"],\\n                \\'/full/path/to/the/csvdir/directory\\'))\\n    '\n    return CSVDIRBundle(tframes, csvdir).ingest",
            "def csvdir_equities(tframes=None, csvdir=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Generate an ingest function for custom data bundle\\n    This function can be used in ~/.zipline/extension.py\\n    to register bundle with custom parameters, e.g. with\\n    a custom trading calendar.\\n\\n    Parameters\\n    ----------\\n    tframes: tuple, optional\\n        The data time frames, supported timeframes: \\'daily\\' and \\'minute\\'\\n    csvdir : string, optional, default: CSVDIR environment variable\\n        The path to the directory of this structure:\\n        <directory>/<timeframe1>/<symbol1>.csv\\n        <directory>/<timeframe1>/<symbol2>.csv\\n        <directory>/<timeframe1>/<symbol3>.csv\\n        <directory>/<timeframe2>/<symbol1>.csv\\n        <directory>/<timeframe2>/<symbol2>.csv\\n        <directory>/<timeframe2>/<symbol3>.csv\\n\\n    Returns\\n    -------\\n    ingest : callable\\n        The bundle ingest function\\n\\n    Examples\\n    --------\\n    This code should be added to ~/.zipline/extension.py\\n    .. code-block:: python\\n       from zipline.data.bundles import csvdir_equities, register\\n       register(\\'custom-csvdir-bundle\\',\\n                csvdir_equities([\"daily\", \"minute\"],\\n                \\'/full/path/to/the/csvdir/directory\\'))\\n    '\n    return CSVDIRBundle(tframes, csvdir).ingest",
            "def csvdir_equities(tframes=None, csvdir=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Generate an ingest function for custom data bundle\\n    This function can be used in ~/.zipline/extension.py\\n    to register bundle with custom parameters, e.g. with\\n    a custom trading calendar.\\n\\n    Parameters\\n    ----------\\n    tframes: tuple, optional\\n        The data time frames, supported timeframes: \\'daily\\' and \\'minute\\'\\n    csvdir : string, optional, default: CSVDIR environment variable\\n        The path to the directory of this structure:\\n        <directory>/<timeframe1>/<symbol1>.csv\\n        <directory>/<timeframe1>/<symbol2>.csv\\n        <directory>/<timeframe1>/<symbol3>.csv\\n        <directory>/<timeframe2>/<symbol1>.csv\\n        <directory>/<timeframe2>/<symbol2>.csv\\n        <directory>/<timeframe2>/<symbol3>.csv\\n\\n    Returns\\n    -------\\n    ingest : callable\\n        The bundle ingest function\\n\\n    Examples\\n    --------\\n    This code should be added to ~/.zipline/extension.py\\n    .. code-block:: python\\n       from zipline.data.bundles import csvdir_equities, register\\n       register(\\'custom-csvdir-bundle\\',\\n                csvdir_equities([\"daily\", \"minute\"],\\n                \\'/full/path/to/the/csvdir/directory\\'))\\n    '\n    return CSVDIRBundle(tframes, csvdir).ingest"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, tframes=None, csvdir=None):\n    self.tframes = tframes\n    self.csvdir = csvdir",
        "mutated": [
            "def __init__(self, tframes=None, csvdir=None):\n    if False:\n        i = 10\n    self.tframes = tframes\n    self.csvdir = csvdir",
            "def __init__(self, tframes=None, csvdir=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.tframes = tframes\n    self.csvdir = csvdir",
            "def __init__(self, tframes=None, csvdir=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.tframes = tframes\n    self.csvdir = csvdir",
            "def __init__(self, tframes=None, csvdir=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.tframes = tframes\n    self.csvdir = csvdir",
            "def __init__(self, tframes=None, csvdir=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.tframes = tframes\n    self.csvdir = csvdir"
        ]
    },
    {
        "func_name": "ingest",
        "original": "def ingest(self, environ, asset_db_writer, minute_bar_writer, daily_bar_writer, adjustment_writer, calendar, start_session, end_session, cache, show_progress, output_dir):\n    csvdir_bundle(environ, asset_db_writer, minute_bar_writer, daily_bar_writer, adjustment_writer, calendar, start_session, end_session, cache, show_progress, output_dir, self.tframes, self.csvdir)",
        "mutated": [
            "def ingest(self, environ, asset_db_writer, minute_bar_writer, daily_bar_writer, adjustment_writer, calendar, start_session, end_session, cache, show_progress, output_dir):\n    if False:\n        i = 10\n    csvdir_bundle(environ, asset_db_writer, minute_bar_writer, daily_bar_writer, adjustment_writer, calendar, start_session, end_session, cache, show_progress, output_dir, self.tframes, self.csvdir)",
            "def ingest(self, environ, asset_db_writer, minute_bar_writer, daily_bar_writer, adjustment_writer, calendar, start_session, end_session, cache, show_progress, output_dir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    csvdir_bundle(environ, asset_db_writer, minute_bar_writer, daily_bar_writer, adjustment_writer, calendar, start_session, end_session, cache, show_progress, output_dir, self.tframes, self.csvdir)",
            "def ingest(self, environ, asset_db_writer, minute_bar_writer, daily_bar_writer, adjustment_writer, calendar, start_session, end_session, cache, show_progress, output_dir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    csvdir_bundle(environ, asset_db_writer, minute_bar_writer, daily_bar_writer, adjustment_writer, calendar, start_session, end_session, cache, show_progress, output_dir, self.tframes, self.csvdir)",
            "def ingest(self, environ, asset_db_writer, minute_bar_writer, daily_bar_writer, adjustment_writer, calendar, start_session, end_session, cache, show_progress, output_dir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    csvdir_bundle(environ, asset_db_writer, minute_bar_writer, daily_bar_writer, adjustment_writer, calendar, start_session, end_session, cache, show_progress, output_dir, self.tframes, self.csvdir)",
            "def ingest(self, environ, asset_db_writer, minute_bar_writer, daily_bar_writer, adjustment_writer, calendar, start_session, end_session, cache, show_progress, output_dir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    csvdir_bundle(environ, asset_db_writer, minute_bar_writer, daily_bar_writer, adjustment_writer, calendar, start_session, end_session, cache, show_progress, output_dir, self.tframes, self.csvdir)"
        ]
    },
    {
        "func_name": "csvdir_bundle",
        "original": "@bundles.register('csvdir')\ndef csvdir_bundle(environ, asset_db_writer, minute_bar_writer, daily_bar_writer, adjustment_writer, calendar, start_session, end_session, cache, show_progress, output_dir, tframes=None, csvdir=None):\n    \"\"\"\n    Build a zipline data bundle from the directory with csv files.\n    \"\"\"\n    if not csvdir:\n        csvdir = environ.get('CSVDIR')\n        if not csvdir:\n            raise ValueError('CSVDIR environment variable is not set')\n    if not os.path.isdir(csvdir):\n        raise ValueError('%s is not a directory' % csvdir)\n    if not tframes:\n        tframes = set(['daily', 'minute']).intersection(os.listdir(csvdir))\n        if not tframes:\n            raise ValueError(\"'daily' and 'minute' directories not found in '%s'\" % csvdir)\n    divs_splits = {'divs': DataFrame(columns=['sid', 'amount', 'ex_date', 'record_date', 'declared_date', 'pay_date']), 'splits': DataFrame(columns=['sid', 'ratio', 'effective_date'])}\n    for tframe in tframes:\n        ddir = os.path.join(csvdir, tframe)\n        symbols = sorted((item.split('.csv')[0] for item in os.listdir(ddir) if '.csv' in item))\n        if not symbols:\n            raise ValueError('no <symbol>.csv* files found in %s' % ddir)\n        dtype = [('start_date', 'datetime64[ns]'), ('end_date', 'datetime64[ns]'), ('auto_close_date', 'datetime64[ns]'), ('symbol', 'object')]\n        metadata = DataFrame(empty(len(symbols), dtype=dtype))\n        if tframe == 'minute':\n            writer = minute_bar_writer\n        else:\n            writer = daily_bar_writer\n        writer.write(_pricing_iter(ddir, symbols, metadata, divs_splits, show_progress), show_progress=show_progress)\n        metadata['exchange'] = 'CSVDIR'\n        asset_db_writer.write(equities=metadata)\n        divs_splits['divs']['sid'] = divs_splits['divs']['sid'].astype(int)\n        divs_splits['splits']['sid'] = divs_splits['splits']['sid'].astype(int)\n        adjustment_writer.write(splits=divs_splits['splits'], dividends=divs_splits['divs'])",
        "mutated": [
            "@bundles.register('csvdir')\ndef csvdir_bundle(environ, asset_db_writer, minute_bar_writer, daily_bar_writer, adjustment_writer, calendar, start_session, end_session, cache, show_progress, output_dir, tframes=None, csvdir=None):\n    if False:\n        i = 10\n    '\\n    Build a zipline data bundle from the directory with csv files.\\n    '\n    if not csvdir:\n        csvdir = environ.get('CSVDIR')\n        if not csvdir:\n            raise ValueError('CSVDIR environment variable is not set')\n    if not os.path.isdir(csvdir):\n        raise ValueError('%s is not a directory' % csvdir)\n    if not tframes:\n        tframes = set(['daily', 'minute']).intersection(os.listdir(csvdir))\n        if not tframes:\n            raise ValueError(\"'daily' and 'minute' directories not found in '%s'\" % csvdir)\n    divs_splits = {'divs': DataFrame(columns=['sid', 'amount', 'ex_date', 'record_date', 'declared_date', 'pay_date']), 'splits': DataFrame(columns=['sid', 'ratio', 'effective_date'])}\n    for tframe in tframes:\n        ddir = os.path.join(csvdir, tframe)\n        symbols = sorted((item.split('.csv')[0] for item in os.listdir(ddir) if '.csv' in item))\n        if not symbols:\n            raise ValueError('no <symbol>.csv* files found in %s' % ddir)\n        dtype = [('start_date', 'datetime64[ns]'), ('end_date', 'datetime64[ns]'), ('auto_close_date', 'datetime64[ns]'), ('symbol', 'object')]\n        metadata = DataFrame(empty(len(symbols), dtype=dtype))\n        if tframe == 'minute':\n            writer = minute_bar_writer\n        else:\n            writer = daily_bar_writer\n        writer.write(_pricing_iter(ddir, symbols, metadata, divs_splits, show_progress), show_progress=show_progress)\n        metadata['exchange'] = 'CSVDIR'\n        asset_db_writer.write(equities=metadata)\n        divs_splits['divs']['sid'] = divs_splits['divs']['sid'].astype(int)\n        divs_splits['splits']['sid'] = divs_splits['splits']['sid'].astype(int)\n        adjustment_writer.write(splits=divs_splits['splits'], dividends=divs_splits['divs'])",
            "@bundles.register('csvdir')\ndef csvdir_bundle(environ, asset_db_writer, minute_bar_writer, daily_bar_writer, adjustment_writer, calendar, start_session, end_session, cache, show_progress, output_dir, tframes=None, csvdir=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Build a zipline data bundle from the directory with csv files.\\n    '\n    if not csvdir:\n        csvdir = environ.get('CSVDIR')\n        if not csvdir:\n            raise ValueError('CSVDIR environment variable is not set')\n    if not os.path.isdir(csvdir):\n        raise ValueError('%s is not a directory' % csvdir)\n    if not tframes:\n        tframes = set(['daily', 'minute']).intersection(os.listdir(csvdir))\n        if not tframes:\n            raise ValueError(\"'daily' and 'minute' directories not found in '%s'\" % csvdir)\n    divs_splits = {'divs': DataFrame(columns=['sid', 'amount', 'ex_date', 'record_date', 'declared_date', 'pay_date']), 'splits': DataFrame(columns=['sid', 'ratio', 'effective_date'])}\n    for tframe in tframes:\n        ddir = os.path.join(csvdir, tframe)\n        symbols = sorted((item.split('.csv')[0] for item in os.listdir(ddir) if '.csv' in item))\n        if not symbols:\n            raise ValueError('no <symbol>.csv* files found in %s' % ddir)\n        dtype = [('start_date', 'datetime64[ns]'), ('end_date', 'datetime64[ns]'), ('auto_close_date', 'datetime64[ns]'), ('symbol', 'object')]\n        metadata = DataFrame(empty(len(symbols), dtype=dtype))\n        if tframe == 'minute':\n            writer = minute_bar_writer\n        else:\n            writer = daily_bar_writer\n        writer.write(_pricing_iter(ddir, symbols, metadata, divs_splits, show_progress), show_progress=show_progress)\n        metadata['exchange'] = 'CSVDIR'\n        asset_db_writer.write(equities=metadata)\n        divs_splits['divs']['sid'] = divs_splits['divs']['sid'].astype(int)\n        divs_splits['splits']['sid'] = divs_splits['splits']['sid'].astype(int)\n        adjustment_writer.write(splits=divs_splits['splits'], dividends=divs_splits['divs'])",
            "@bundles.register('csvdir')\ndef csvdir_bundle(environ, asset_db_writer, minute_bar_writer, daily_bar_writer, adjustment_writer, calendar, start_session, end_session, cache, show_progress, output_dir, tframes=None, csvdir=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Build a zipline data bundle from the directory with csv files.\\n    '\n    if not csvdir:\n        csvdir = environ.get('CSVDIR')\n        if not csvdir:\n            raise ValueError('CSVDIR environment variable is not set')\n    if not os.path.isdir(csvdir):\n        raise ValueError('%s is not a directory' % csvdir)\n    if not tframes:\n        tframes = set(['daily', 'minute']).intersection(os.listdir(csvdir))\n        if not tframes:\n            raise ValueError(\"'daily' and 'minute' directories not found in '%s'\" % csvdir)\n    divs_splits = {'divs': DataFrame(columns=['sid', 'amount', 'ex_date', 'record_date', 'declared_date', 'pay_date']), 'splits': DataFrame(columns=['sid', 'ratio', 'effective_date'])}\n    for tframe in tframes:\n        ddir = os.path.join(csvdir, tframe)\n        symbols = sorted((item.split('.csv')[0] for item in os.listdir(ddir) if '.csv' in item))\n        if not symbols:\n            raise ValueError('no <symbol>.csv* files found in %s' % ddir)\n        dtype = [('start_date', 'datetime64[ns]'), ('end_date', 'datetime64[ns]'), ('auto_close_date', 'datetime64[ns]'), ('symbol', 'object')]\n        metadata = DataFrame(empty(len(symbols), dtype=dtype))\n        if tframe == 'minute':\n            writer = minute_bar_writer\n        else:\n            writer = daily_bar_writer\n        writer.write(_pricing_iter(ddir, symbols, metadata, divs_splits, show_progress), show_progress=show_progress)\n        metadata['exchange'] = 'CSVDIR'\n        asset_db_writer.write(equities=metadata)\n        divs_splits['divs']['sid'] = divs_splits['divs']['sid'].astype(int)\n        divs_splits['splits']['sid'] = divs_splits['splits']['sid'].astype(int)\n        adjustment_writer.write(splits=divs_splits['splits'], dividends=divs_splits['divs'])",
            "@bundles.register('csvdir')\ndef csvdir_bundle(environ, asset_db_writer, minute_bar_writer, daily_bar_writer, adjustment_writer, calendar, start_session, end_session, cache, show_progress, output_dir, tframes=None, csvdir=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Build a zipline data bundle from the directory with csv files.\\n    '\n    if not csvdir:\n        csvdir = environ.get('CSVDIR')\n        if not csvdir:\n            raise ValueError('CSVDIR environment variable is not set')\n    if not os.path.isdir(csvdir):\n        raise ValueError('%s is not a directory' % csvdir)\n    if not tframes:\n        tframes = set(['daily', 'minute']).intersection(os.listdir(csvdir))\n        if not tframes:\n            raise ValueError(\"'daily' and 'minute' directories not found in '%s'\" % csvdir)\n    divs_splits = {'divs': DataFrame(columns=['sid', 'amount', 'ex_date', 'record_date', 'declared_date', 'pay_date']), 'splits': DataFrame(columns=['sid', 'ratio', 'effective_date'])}\n    for tframe in tframes:\n        ddir = os.path.join(csvdir, tframe)\n        symbols = sorted((item.split('.csv')[0] for item in os.listdir(ddir) if '.csv' in item))\n        if not symbols:\n            raise ValueError('no <symbol>.csv* files found in %s' % ddir)\n        dtype = [('start_date', 'datetime64[ns]'), ('end_date', 'datetime64[ns]'), ('auto_close_date', 'datetime64[ns]'), ('symbol', 'object')]\n        metadata = DataFrame(empty(len(symbols), dtype=dtype))\n        if tframe == 'minute':\n            writer = minute_bar_writer\n        else:\n            writer = daily_bar_writer\n        writer.write(_pricing_iter(ddir, symbols, metadata, divs_splits, show_progress), show_progress=show_progress)\n        metadata['exchange'] = 'CSVDIR'\n        asset_db_writer.write(equities=metadata)\n        divs_splits['divs']['sid'] = divs_splits['divs']['sid'].astype(int)\n        divs_splits['splits']['sid'] = divs_splits['splits']['sid'].astype(int)\n        adjustment_writer.write(splits=divs_splits['splits'], dividends=divs_splits['divs'])",
            "@bundles.register('csvdir')\ndef csvdir_bundle(environ, asset_db_writer, minute_bar_writer, daily_bar_writer, adjustment_writer, calendar, start_session, end_session, cache, show_progress, output_dir, tframes=None, csvdir=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Build a zipline data bundle from the directory with csv files.\\n    '\n    if not csvdir:\n        csvdir = environ.get('CSVDIR')\n        if not csvdir:\n            raise ValueError('CSVDIR environment variable is not set')\n    if not os.path.isdir(csvdir):\n        raise ValueError('%s is not a directory' % csvdir)\n    if not tframes:\n        tframes = set(['daily', 'minute']).intersection(os.listdir(csvdir))\n        if not tframes:\n            raise ValueError(\"'daily' and 'minute' directories not found in '%s'\" % csvdir)\n    divs_splits = {'divs': DataFrame(columns=['sid', 'amount', 'ex_date', 'record_date', 'declared_date', 'pay_date']), 'splits': DataFrame(columns=['sid', 'ratio', 'effective_date'])}\n    for tframe in tframes:\n        ddir = os.path.join(csvdir, tframe)\n        symbols = sorted((item.split('.csv')[0] for item in os.listdir(ddir) if '.csv' in item))\n        if not symbols:\n            raise ValueError('no <symbol>.csv* files found in %s' % ddir)\n        dtype = [('start_date', 'datetime64[ns]'), ('end_date', 'datetime64[ns]'), ('auto_close_date', 'datetime64[ns]'), ('symbol', 'object')]\n        metadata = DataFrame(empty(len(symbols), dtype=dtype))\n        if tframe == 'minute':\n            writer = minute_bar_writer\n        else:\n            writer = daily_bar_writer\n        writer.write(_pricing_iter(ddir, symbols, metadata, divs_splits, show_progress), show_progress=show_progress)\n        metadata['exchange'] = 'CSVDIR'\n        asset_db_writer.write(equities=metadata)\n        divs_splits['divs']['sid'] = divs_splits['divs']['sid'].astype(int)\n        divs_splits['splits']['sid'] = divs_splits['splits']['sid'].astype(int)\n        adjustment_writer.write(splits=divs_splits['splits'], dividends=divs_splits['divs'])"
        ]
    },
    {
        "func_name": "_pricing_iter",
        "original": "def _pricing_iter(csvdir, symbols, metadata, divs_splits, show_progress):\n    with maybe_show_progress(symbols, show_progress, label='Loading custom pricing data: ') as it:\n        files = os.listdir(csvdir)\n        for (sid, symbol) in enumerate(it):\n            logger.debug('%s: sid %s' % (symbol, sid))\n            try:\n                fname = [fname for fname in files if '%s.csv' % symbol in fname][0]\n            except IndexError:\n                raise ValueError('%s.csv file is not in %s' % (symbol, csvdir))\n            dfr = read_csv(os.path.join(csvdir, fname), parse_dates=[0], infer_datetime_format=True, index_col=0).sort_index()\n            start_date = dfr.index[0]\n            end_date = dfr.index[-1]\n            ac_date = end_date + Timedelta(days=1)\n            metadata.iloc[sid] = (start_date, end_date, ac_date, symbol)\n            if 'split' in dfr.columns:\n                tmp = 1.0 / dfr[dfr['split'] != 1.0]['split']\n                split = DataFrame(data=tmp.index.tolist(), columns=['effective_date'])\n                split['ratio'] = tmp.tolist()\n                split['sid'] = sid\n                splits = divs_splits['splits']\n                index = Index(range(splits.shape[0], splits.shape[0] + split.shape[0]))\n                split.set_index(index, inplace=True)\n                divs_splits['splits'] = splits.append(split)\n            if 'dividend' in dfr.columns:\n                tmp = dfr[dfr['dividend'] != 0.0]['dividend']\n                div = DataFrame(data=tmp.index.tolist(), columns=['ex_date'])\n                div['record_date'] = NaT\n                div['declared_date'] = NaT\n                div['pay_date'] = NaT\n                div['amount'] = tmp.tolist()\n                div['sid'] = sid\n                divs = divs_splits['divs']\n                ind = Index(range(divs.shape[0], divs.shape[0] + div.shape[0]))\n                div.set_index(ind, inplace=True)\n                divs_splits['divs'] = divs.append(div)\n            yield (sid, dfr)",
        "mutated": [
            "def _pricing_iter(csvdir, symbols, metadata, divs_splits, show_progress):\n    if False:\n        i = 10\n    with maybe_show_progress(symbols, show_progress, label='Loading custom pricing data: ') as it:\n        files = os.listdir(csvdir)\n        for (sid, symbol) in enumerate(it):\n            logger.debug('%s: sid %s' % (symbol, sid))\n            try:\n                fname = [fname for fname in files if '%s.csv' % symbol in fname][0]\n            except IndexError:\n                raise ValueError('%s.csv file is not in %s' % (symbol, csvdir))\n            dfr = read_csv(os.path.join(csvdir, fname), parse_dates=[0], infer_datetime_format=True, index_col=0).sort_index()\n            start_date = dfr.index[0]\n            end_date = dfr.index[-1]\n            ac_date = end_date + Timedelta(days=1)\n            metadata.iloc[sid] = (start_date, end_date, ac_date, symbol)\n            if 'split' in dfr.columns:\n                tmp = 1.0 / dfr[dfr['split'] != 1.0]['split']\n                split = DataFrame(data=tmp.index.tolist(), columns=['effective_date'])\n                split['ratio'] = tmp.tolist()\n                split['sid'] = sid\n                splits = divs_splits['splits']\n                index = Index(range(splits.shape[0], splits.shape[0] + split.shape[0]))\n                split.set_index(index, inplace=True)\n                divs_splits['splits'] = splits.append(split)\n            if 'dividend' in dfr.columns:\n                tmp = dfr[dfr['dividend'] != 0.0]['dividend']\n                div = DataFrame(data=tmp.index.tolist(), columns=['ex_date'])\n                div['record_date'] = NaT\n                div['declared_date'] = NaT\n                div['pay_date'] = NaT\n                div['amount'] = tmp.tolist()\n                div['sid'] = sid\n                divs = divs_splits['divs']\n                ind = Index(range(divs.shape[0], divs.shape[0] + div.shape[0]))\n                div.set_index(ind, inplace=True)\n                divs_splits['divs'] = divs.append(div)\n            yield (sid, dfr)",
            "def _pricing_iter(csvdir, symbols, metadata, divs_splits, show_progress):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    with maybe_show_progress(symbols, show_progress, label='Loading custom pricing data: ') as it:\n        files = os.listdir(csvdir)\n        for (sid, symbol) in enumerate(it):\n            logger.debug('%s: sid %s' % (symbol, sid))\n            try:\n                fname = [fname for fname in files if '%s.csv' % symbol in fname][0]\n            except IndexError:\n                raise ValueError('%s.csv file is not in %s' % (symbol, csvdir))\n            dfr = read_csv(os.path.join(csvdir, fname), parse_dates=[0], infer_datetime_format=True, index_col=0).sort_index()\n            start_date = dfr.index[0]\n            end_date = dfr.index[-1]\n            ac_date = end_date + Timedelta(days=1)\n            metadata.iloc[sid] = (start_date, end_date, ac_date, symbol)\n            if 'split' in dfr.columns:\n                tmp = 1.0 / dfr[dfr['split'] != 1.0]['split']\n                split = DataFrame(data=tmp.index.tolist(), columns=['effective_date'])\n                split['ratio'] = tmp.tolist()\n                split['sid'] = sid\n                splits = divs_splits['splits']\n                index = Index(range(splits.shape[0], splits.shape[0] + split.shape[0]))\n                split.set_index(index, inplace=True)\n                divs_splits['splits'] = splits.append(split)\n            if 'dividend' in dfr.columns:\n                tmp = dfr[dfr['dividend'] != 0.0]['dividend']\n                div = DataFrame(data=tmp.index.tolist(), columns=['ex_date'])\n                div['record_date'] = NaT\n                div['declared_date'] = NaT\n                div['pay_date'] = NaT\n                div['amount'] = tmp.tolist()\n                div['sid'] = sid\n                divs = divs_splits['divs']\n                ind = Index(range(divs.shape[0], divs.shape[0] + div.shape[0]))\n                div.set_index(ind, inplace=True)\n                divs_splits['divs'] = divs.append(div)\n            yield (sid, dfr)",
            "def _pricing_iter(csvdir, symbols, metadata, divs_splits, show_progress):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    with maybe_show_progress(symbols, show_progress, label='Loading custom pricing data: ') as it:\n        files = os.listdir(csvdir)\n        for (sid, symbol) in enumerate(it):\n            logger.debug('%s: sid %s' % (symbol, sid))\n            try:\n                fname = [fname for fname in files if '%s.csv' % symbol in fname][0]\n            except IndexError:\n                raise ValueError('%s.csv file is not in %s' % (symbol, csvdir))\n            dfr = read_csv(os.path.join(csvdir, fname), parse_dates=[0], infer_datetime_format=True, index_col=0).sort_index()\n            start_date = dfr.index[0]\n            end_date = dfr.index[-1]\n            ac_date = end_date + Timedelta(days=1)\n            metadata.iloc[sid] = (start_date, end_date, ac_date, symbol)\n            if 'split' in dfr.columns:\n                tmp = 1.0 / dfr[dfr['split'] != 1.0]['split']\n                split = DataFrame(data=tmp.index.tolist(), columns=['effective_date'])\n                split['ratio'] = tmp.tolist()\n                split['sid'] = sid\n                splits = divs_splits['splits']\n                index = Index(range(splits.shape[0], splits.shape[0] + split.shape[0]))\n                split.set_index(index, inplace=True)\n                divs_splits['splits'] = splits.append(split)\n            if 'dividend' in dfr.columns:\n                tmp = dfr[dfr['dividend'] != 0.0]['dividend']\n                div = DataFrame(data=tmp.index.tolist(), columns=['ex_date'])\n                div['record_date'] = NaT\n                div['declared_date'] = NaT\n                div['pay_date'] = NaT\n                div['amount'] = tmp.tolist()\n                div['sid'] = sid\n                divs = divs_splits['divs']\n                ind = Index(range(divs.shape[0], divs.shape[0] + div.shape[0]))\n                div.set_index(ind, inplace=True)\n                divs_splits['divs'] = divs.append(div)\n            yield (sid, dfr)",
            "def _pricing_iter(csvdir, symbols, metadata, divs_splits, show_progress):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    with maybe_show_progress(symbols, show_progress, label='Loading custom pricing data: ') as it:\n        files = os.listdir(csvdir)\n        for (sid, symbol) in enumerate(it):\n            logger.debug('%s: sid %s' % (symbol, sid))\n            try:\n                fname = [fname for fname in files if '%s.csv' % symbol in fname][0]\n            except IndexError:\n                raise ValueError('%s.csv file is not in %s' % (symbol, csvdir))\n            dfr = read_csv(os.path.join(csvdir, fname), parse_dates=[0], infer_datetime_format=True, index_col=0).sort_index()\n            start_date = dfr.index[0]\n            end_date = dfr.index[-1]\n            ac_date = end_date + Timedelta(days=1)\n            metadata.iloc[sid] = (start_date, end_date, ac_date, symbol)\n            if 'split' in dfr.columns:\n                tmp = 1.0 / dfr[dfr['split'] != 1.0]['split']\n                split = DataFrame(data=tmp.index.tolist(), columns=['effective_date'])\n                split['ratio'] = tmp.tolist()\n                split['sid'] = sid\n                splits = divs_splits['splits']\n                index = Index(range(splits.shape[0], splits.shape[0] + split.shape[0]))\n                split.set_index(index, inplace=True)\n                divs_splits['splits'] = splits.append(split)\n            if 'dividend' in dfr.columns:\n                tmp = dfr[dfr['dividend'] != 0.0]['dividend']\n                div = DataFrame(data=tmp.index.tolist(), columns=['ex_date'])\n                div['record_date'] = NaT\n                div['declared_date'] = NaT\n                div['pay_date'] = NaT\n                div['amount'] = tmp.tolist()\n                div['sid'] = sid\n                divs = divs_splits['divs']\n                ind = Index(range(divs.shape[0], divs.shape[0] + div.shape[0]))\n                div.set_index(ind, inplace=True)\n                divs_splits['divs'] = divs.append(div)\n            yield (sid, dfr)",
            "def _pricing_iter(csvdir, symbols, metadata, divs_splits, show_progress):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    with maybe_show_progress(symbols, show_progress, label='Loading custom pricing data: ') as it:\n        files = os.listdir(csvdir)\n        for (sid, symbol) in enumerate(it):\n            logger.debug('%s: sid %s' % (symbol, sid))\n            try:\n                fname = [fname for fname in files if '%s.csv' % symbol in fname][0]\n            except IndexError:\n                raise ValueError('%s.csv file is not in %s' % (symbol, csvdir))\n            dfr = read_csv(os.path.join(csvdir, fname), parse_dates=[0], infer_datetime_format=True, index_col=0).sort_index()\n            start_date = dfr.index[0]\n            end_date = dfr.index[-1]\n            ac_date = end_date + Timedelta(days=1)\n            metadata.iloc[sid] = (start_date, end_date, ac_date, symbol)\n            if 'split' in dfr.columns:\n                tmp = 1.0 / dfr[dfr['split'] != 1.0]['split']\n                split = DataFrame(data=tmp.index.tolist(), columns=['effective_date'])\n                split['ratio'] = tmp.tolist()\n                split['sid'] = sid\n                splits = divs_splits['splits']\n                index = Index(range(splits.shape[0], splits.shape[0] + split.shape[0]))\n                split.set_index(index, inplace=True)\n                divs_splits['splits'] = splits.append(split)\n            if 'dividend' in dfr.columns:\n                tmp = dfr[dfr['dividend'] != 0.0]['dividend']\n                div = DataFrame(data=tmp.index.tolist(), columns=['ex_date'])\n                div['record_date'] = NaT\n                div['declared_date'] = NaT\n                div['pay_date'] = NaT\n                div['amount'] = tmp.tolist()\n                div['sid'] = sid\n                divs = divs_splits['divs']\n                ind = Index(range(divs.shape[0], divs.shape[0] + div.shape[0]))\n                div.set_index(ind, inplace=True)\n                divs_splits['divs'] = divs.append(div)\n            yield (sid, dfr)"
        ]
    }
]