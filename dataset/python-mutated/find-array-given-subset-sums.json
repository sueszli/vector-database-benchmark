[
    {
        "func_name": "recoverArray",
        "original": "def recoverArray(self, n, sums):\n    \"\"\"\n        :type n: int\n        :type sums: List[int]\n        :rtype: List[int]\n        \"\"\"\n    sums.sort()\n    (shift, l) = (0, len(sums))\n    result = []\n    for _ in xrange(n):\n        new_shift = sums[0] - sums[1]\n        assert new_shift <= 0\n        (has_zero, j, k) = (False, 0, 0)\n        for i in xrange(l):\n            if k < j and sums[k] == sums[i]:\n                k += 1\n            else:\n                if shift == sums[i] - new_shift:\n                    has_zero = True\n                sums[j] = sums[i] - new_shift\n                j += 1\n        if has_zero:\n            result.append(new_shift)\n        else:\n            result.append(-new_shift)\n            shift -= new_shift\n        l //= 2\n    return result",
        "mutated": [
            "def recoverArray(self, n, sums):\n    if False:\n        i = 10\n    '\\n        :type n: int\\n        :type sums: List[int]\\n        :rtype: List[int]\\n        '\n    sums.sort()\n    (shift, l) = (0, len(sums))\n    result = []\n    for _ in xrange(n):\n        new_shift = sums[0] - sums[1]\n        assert new_shift <= 0\n        (has_zero, j, k) = (False, 0, 0)\n        for i in xrange(l):\n            if k < j and sums[k] == sums[i]:\n                k += 1\n            else:\n                if shift == sums[i] - new_shift:\n                    has_zero = True\n                sums[j] = sums[i] - new_shift\n                j += 1\n        if has_zero:\n            result.append(new_shift)\n        else:\n            result.append(-new_shift)\n            shift -= new_shift\n        l //= 2\n    return result",
            "def recoverArray(self, n, sums):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :type n: int\\n        :type sums: List[int]\\n        :rtype: List[int]\\n        '\n    sums.sort()\n    (shift, l) = (0, len(sums))\n    result = []\n    for _ in xrange(n):\n        new_shift = sums[0] - sums[1]\n        assert new_shift <= 0\n        (has_zero, j, k) = (False, 0, 0)\n        for i in xrange(l):\n            if k < j and sums[k] == sums[i]:\n                k += 1\n            else:\n                if shift == sums[i] - new_shift:\n                    has_zero = True\n                sums[j] = sums[i] - new_shift\n                j += 1\n        if has_zero:\n            result.append(new_shift)\n        else:\n            result.append(-new_shift)\n            shift -= new_shift\n        l //= 2\n    return result",
            "def recoverArray(self, n, sums):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :type n: int\\n        :type sums: List[int]\\n        :rtype: List[int]\\n        '\n    sums.sort()\n    (shift, l) = (0, len(sums))\n    result = []\n    for _ in xrange(n):\n        new_shift = sums[0] - sums[1]\n        assert new_shift <= 0\n        (has_zero, j, k) = (False, 0, 0)\n        for i in xrange(l):\n            if k < j and sums[k] == sums[i]:\n                k += 1\n            else:\n                if shift == sums[i] - new_shift:\n                    has_zero = True\n                sums[j] = sums[i] - new_shift\n                j += 1\n        if has_zero:\n            result.append(new_shift)\n        else:\n            result.append(-new_shift)\n            shift -= new_shift\n        l //= 2\n    return result",
            "def recoverArray(self, n, sums):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :type n: int\\n        :type sums: List[int]\\n        :rtype: List[int]\\n        '\n    sums.sort()\n    (shift, l) = (0, len(sums))\n    result = []\n    for _ in xrange(n):\n        new_shift = sums[0] - sums[1]\n        assert new_shift <= 0\n        (has_zero, j, k) = (False, 0, 0)\n        for i in xrange(l):\n            if k < j and sums[k] == sums[i]:\n                k += 1\n            else:\n                if shift == sums[i] - new_shift:\n                    has_zero = True\n                sums[j] = sums[i] - new_shift\n                j += 1\n        if has_zero:\n            result.append(new_shift)\n        else:\n            result.append(-new_shift)\n            shift -= new_shift\n        l //= 2\n    return result",
            "def recoverArray(self, n, sums):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :type n: int\\n        :type sums: List[int]\\n        :rtype: List[int]\\n        '\n    sums.sort()\n    (shift, l) = (0, len(sums))\n    result = []\n    for _ in xrange(n):\n        new_shift = sums[0] - sums[1]\n        assert new_shift <= 0\n        (has_zero, j, k) = (False, 0, 0)\n        for i in xrange(l):\n            if k < j and sums[k] == sums[i]:\n                k += 1\n            else:\n                if shift == sums[i] - new_shift:\n                    has_zero = True\n                sums[j] = sums[i] - new_shift\n                j += 1\n        if has_zero:\n            result.append(new_shift)\n        else:\n            result.append(-new_shift)\n            shift -= new_shift\n        l //= 2\n    return result"
        ]
    },
    {
        "func_name": "recoverArray",
        "original": "def recoverArray(self, n, sums):\n    \"\"\"\n        :type n: int\n        :type sums: List[int]\n        :rtype: List[int]\n        \"\"\"\n    (min_sum, max_sum) = (min(sums), max(sums))\n    dp = [0] * (max_sum - min_sum + 1)\n    for x in sums:\n        dp[x - min_sum] += 1\n    sorted_sums = [x for x in xrange(min_sum, max_sum + 1) if dp[x - min_sum]]\n    shift = 0\n    result = []\n    for _ in xrange(n):\n        new_dp = [0] * (max_sum - min_sum + 1)\n        new_sorted_sums = []\n        new_shift = sorted_sums[0] - sorted_sums[1] if dp[sorted_sums[0] - min_sum] == 1 else 0\n        assert new_shift <= 0\n        for x in sorted_sums:\n            if not dp[x - min_sum]:\n                continue\n            dp[x - new_shift - min_sum] -= dp[x - min_sum] if new_shift else dp[x - min_sum] // 2\n            new_dp[x - new_shift - min_sum] = dp[x - min_sum]\n            new_sorted_sums.append(x - new_shift)\n        dp = new_dp\n        sorted_sums = new_sorted_sums\n        if dp[shift - min_sum]:\n            result.append(new_shift)\n        else:\n            result.append(-new_shift)\n            shift -= new_shift\n    return result",
        "mutated": [
            "def recoverArray(self, n, sums):\n    if False:\n        i = 10\n    '\\n        :type n: int\\n        :type sums: List[int]\\n        :rtype: List[int]\\n        '\n    (min_sum, max_sum) = (min(sums), max(sums))\n    dp = [0] * (max_sum - min_sum + 1)\n    for x in sums:\n        dp[x - min_sum] += 1\n    sorted_sums = [x for x in xrange(min_sum, max_sum + 1) if dp[x - min_sum]]\n    shift = 0\n    result = []\n    for _ in xrange(n):\n        new_dp = [0] * (max_sum - min_sum + 1)\n        new_sorted_sums = []\n        new_shift = sorted_sums[0] - sorted_sums[1] if dp[sorted_sums[0] - min_sum] == 1 else 0\n        assert new_shift <= 0\n        for x in sorted_sums:\n            if not dp[x - min_sum]:\n                continue\n            dp[x - new_shift - min_sum] -= dp[x - min_sum] if new_shift else dp[x - min_sum] // 2\n            new_dp[x - new_shift - min_sum] = dp[x - min_sum]\n            new_sorted_sums.append(x - new_shift)\n        dp = new_dp\n        sorted_sums = new_sorted_sums\n        if dp[shift - min_sum]:\n            result.append(new_shift)\n        else:\n            result.append(-new_shift)\n            shift -= new_shift\n    return result",
            "def recoverArray(self, n, sums):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :type n: int\\n        :type sums: List[int]\\n        :rtype: List[int]\\n        '\n    (min_sum, max_sum) = (min(sums), max(sums))\n    dp = [0] * (max_sum - min_sum + 1)\n    for x in sums:\n        dp[x - min_sum] += 1\n    sorted_sums = [x for x in xrange(min_sum, max_sum + 1) if dp[x - min_sum]]\n    shift = 0\n    result = []\n    for _ in xrange(n):\n        new_dp = [0] * (max_sum - min_sum + 1)\n        new_sorted_sums = []\n        new_shift = sorted_sums[0] - sorted_sums[1] if dp[sorted_sums[0] - min_sum] == 1 else 0\n        assert new_shift <= 0\n        for x in sorted_sums:\n            if not dp[x - min_sum]:\n                continue\n            dp[x - new_shift - min_sum] -= dp[x - min_sum] if new_shift else dp[x - min_sum] // 2\n            new_dp[x - new_shift - min_sum] = dp[x - min_sum]\n            new_sorted_sums.append(x - new_shift)\n        dp = new_dp\n        sorted_sums = new_sorted_sums\n        if dp[shift - min_sum]:\n            result.append(new_shift)\n        else:\n            result.append(-new_shift)\n            shift -= new_shift\n    return result",
            "def recoverArray(self, n, sums):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :type n: int\\n        :type sums: List[int]\\n        :rtype: List[int]\\n        '\n    (min_sum, max_sum) = (min(sums), max(sums))\n    dp = [0] * (max_sum - min_sum + 1)\n    for x in sums:\n        dp[x - min_sum] += 1\n    sorted_sums = [x for x in xrange(min_sum, max_sum + 1) if dp[x - min_sum]]\n    shift = 0\n    result = []\n    for _ in xrange(n):\n        new_dp = [0] * (max_sum - min_sum + 1)\n        new_sorted_sums = []\n        new_shift = sorted_sums[0] - sorted_sums[1] if dp[sorted_sums[0] - min_sum] == 1 else 0\n        assert new_shift <= 0\n        for x in sorted_sums:\n            if not dp[x - min_sum]:\n                continue\n            dp[x - new_shift - min_sum] -= dp[x - min_sum] if new_shift else dp[x - min_sum] // 2\n            new_dp[x - new_shift - min_sum] = dp[x - min_sum]\n            new_sorted_sums.append(x - new_shift)\n        dp = new_dp\n        sorted_sums = new_sorted_sums\n        if dp[shift - min_sum]:\n            result.append(new_shift)\n        else:\n            result.append(-new_shift)\n            shift -= new_shift\n    return result",
            "def recoverArray(self, n, sums):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :type n: int\\n        :type sums: List[int]\\n        :rtype: List[int]\\n        '\n    (min_sum, max_sum) = (min(sums), max(sums))\n    dp = [0] * (max_sum - min_sum + 1)\n    for x in sums:\n        dp[x - min_sum] += 1\n    sorted_sums = [x for x in xrange(min_sum, max_sum + 1) if dp[x - min_sum]]\n    shift = 0\n    result = []\n    for _ in xrange(n):\n        new_dp = [0] * (max_sum - min_sum + 1)\n        new_sorted_sums = []\n        new_shift = sorted_sums[0] - sorted_sums[1] if dp[sorted_sums[0] - min_sum] == 1 else 0\n        assert new_shift <= 0\n        for x in sorted_sums:\n            if not dp[x - min_sum]:\n                continue\n            dp[x - new_shift - min_sum] -= dp[x - min_sum] if new_shift else dp[x - min_sum] // 2\n            new_dp[x - new_shift - min_sum] = dp[x - min_sum]\n            new_sorted_sums.append(x - new_shift)\n        dp = new_dp\n        sorted_sums = new_sorted_sums\n        if dp[shift - min_sum]:\n            result.append(new_shift)\n        else:\n            result.append(-new_shift)\n            shift -= new_shift\n    return result",
            "def recoverArray(self, n, sums):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :type n: int\\n        :type sums: List[int]\\n        :rtype: List[int]\\n        '\n    (min_sum, max_sum) = (min(sums), max(sums))\n    dp = [0] * (max_sum - min_sum + 1)\n    for x in sums:\n        dp[x - min_sum] += 1\n    sorted_sums = [x for x in xrange(min_sum, max_sum + 1) if dp[x - min_sum]]\n    shift = 0\n    result = []\n    for _ in xrange(n):\n        new_dp = [0] * (max_sum - min_sum + 1)\n        new_sorted_sums = []\n        new_shift = sorted_sums[0] - sorted_sums[1] if dp[sorted_sums[0] - min_sum] == 1 else 0\n        assert new_shift <= 0\n        for x in sorted_sums:\n            if not dp[x - min_sum]:\n                continue\n            dp[x - new_shift - min_sum] -= dp[x - min_sum] if new_shift else dp[x - min_sum] // 2\n            new_dp[x - new_shift - min_sum] = dp[x - min_sum]\n            new_sorted_sums.append(x - new_shift)\n        dp = new_dp\n        sorted_sums = new_sorted_sums\n        if dp[shift - min_sum]:\n            result.append(new_shift)\n        else:\n            result.append(-new_shift)\n            shift -= new_shift\n    return result"
        ]
    },
    {
        "func_name": "recoverArray",
        "original": "def recoverArray(self, n, sums):\n    \"\"\"\n        :type n: int\n        :type sums: List[int]\n        :rtype: List[int]\n        \"\"\"\n    dp = {k: v for (k, v) in collections.Counter(sums).iteritems()}\n    total = reduce(operator.ior, dp.itervalues(), 0)\n    basis = total & -total\n    if basis > 1:\n        for k in dp.iterkeys():\n            dp[k] //= basis\n    sorted_sums = sorted(dp.iterkeys())\n    shift = 0\n    result = [0] * (basis.bit_length() - 1)\n    for _ in xrange(n - len(result)):\n        new_dp = {}\n        new_sorted_sums = []\n        new_shift = sorted_sums[0] - sorted_sums[1]\n        assert new_shift < 0\n        for x in sorted_sums:\n            if not dp[x]:\n                continue\n            dp[x - new_shift] -= dp[x]\n            new_dp[x - new_shift] = dp[x]\n            new_sorted_sums.append(x - new_shift)\n        dp = new_dp\n        sorted_sums = new_sorted_sums\n        if shift in dp:\n            result.append(new_shift)\n        else:\n            result.append(-new_shift)\n            shift -= new_shift\n    return result",
        "mutated": [
            "def recoverArray(self, n, sums):\n    if False:\n        i = 10\n    '\\n        :type n: int\\n        :type sums: List[int]\\n        :rtype: List[int]\\n        '\n    dp = {k: v for (k, v) in collections.Counter(sums).iteritems()}\n    total = reduce(operator.ior, dp.itervalues(), 0)\n    basis = total & -total\n    if basis > 1:\n        for k in dp.iterkeys():\n            dp[k] //= basis\n    sorted_sums = sorted(dp.iterkeys())\n    shift = 0\n    result = [0] * (basis.bit_length() - 1)\n    for _ in xrange(n - len(result)):\n        new_dp = {}\n        new_sorted_sums = []\n        new_shift = sorted_sums[0] - sorted_sums[1]\n        assert new_shift < 0\n        for x in sorted_sums:\n            if not dp[x]:\n                continue\n            dp[x - new_shift] -= dp[x]\n            new_dp[x - new_shift] = dp[x]\n            new_sorted_sums.append(x - new_shift)\n        dp = new_dp\n        sorted_sums = new_sorted_sums\n        if shift in dp:\n            result.append(new_shift)\n        else:\n            result.append(-new_shift)\n            shift -= new_shift\n    return result",
            "def recoverArray(self, n, sums):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :type n: int\\n        :type sums: List[int]\\n        :rtype: List[int]\\n        '\n    dp = {k: v for (k, v) in collections.Counter(sums).iteritems()}\n    total = reduce(operator.ior, dp.itervalues(), 0)\n    basis = total & -total\n    if basis > 1:\n        for k in dp.iterkeys():\n            dp[k] //= basis\n    sorted_sums = sorted(dp.iterkeys())\n    shift = 0\n    result = [0] * (basis.bit_length() - 1)\n    for _ in xrange(n - len(result)):\n        new_dp = {}\n        new_sorted_sums = []\n        new_shift = sorted_sums[0] - sorted_sums[1]\n        assert new_shift < 0\n        for x in sorted_sums:\n            if not dp[x]:\n                continue\n            dp[x - new_shift] -= dp[x]\n            new_dp[x - new_shift] = dp[x]\n            new_sorted_sums.append(x - new_shift)\n        dp = new_dp\n        sorted_sums = new_sorted_sums\n        if shift in dp:\n            result.append(new_shift)\n        else:\n            result.append(-new_shift)\n            shift -= new_shift\n    return result",
            "def recoverArray(self, n, sums):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :type n: int\\n        :type sums: List[int]\\n        :rtype: List[int]\\n        '\n    dp = {k: v for (k, v) in collections.Counter(sums).iteritems()}\n    total = reduce(operator.ior, dp.itervalues(), 0)\n    basis = total & -total\n    if basis > 1:\n        for k in dp.iterkeys():\n            dp[k] //= basis\n    sorted_sums = sorted(dp.iterkeys())\n    shift = 0\n    result = [0] * (basis.bit_length() - 1)\n    for _ in xrange(n - len(result)):\n        new_dp = {}\n        new_sorted_sums = []\n        new_shift = sorted_sums[0] - sorted_sums[1]\n        assert new_shift < 0\n        for x in sorted_sums:\n            if not dp[x]:\n                continue\n            dp[x - new_shift] -= dp[x]\n            new_dp[x - new_shift] = dp[x]\n            new_sorted_sums.append(x - new_shift)\n        dp = new_dp\n        sorted_sums = new_sorted_sums\n        if shift in dp:\n            result.append(new_shift)\n        else:\n            result.append(-new_shift)\n            shift -= new_shift\n    return result",
            "def recoverArray(self, n, sums):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :type n: int\\n        :type sums: List[int]\\n        :rtype: List[int]\\n        '\n    dp = {k: v for (k, v) in collections.Counter(sums).iteritems()}\n    total = reduce(operator.ior, dp.itervalues(), 0)\n    basis = total & -total\n    if basis > 1:\n        for k in dp.iterkeys():\n            dp[k] //= basis\n    sorted_sums = sorted(dp.iterkeys())\n    shift = 0\n    result = [0] * (basis.bit_length() - 1)\n    for _ in xrange(n - len(result)):\n        new_dp = {}\n        new_sorted_sums = []\n        new_shift = sorted_sums[0] - sorted_sums[1]\n        assert new_shift < 0\n        for x in sorted_sums:\n            if not dp[x]:\n                continue\n            dp[x - new_shift] -= dp[x]\n            new_dp[x - new_shift] = dp[x]\n            new_sorted_sums.append(x - new_shift)\n        dp = new_dp\n        sorted_sums = new_sorted_sums\n        if shift in dp:\n            result.append(new_shift)\n        else:\n            result.append(-new_shift)\n            shift -= new_shift\n    return result",
            "def recoverArray(self, n, sums):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :type n: int\\n        :type sums: List[int]\\n        :rtype: List[int]\\n        '\n    dp = {k: v for (k, v) in collections.Counter(sums).iteritems()}\n    total = reduce(operator.ior, dp.itervalues(), 0)\n    basis = total & -total\n    if basis > 1:\n        for k in dp.iterkeys():\n            dp[k] //= basis\n    sorted_sums = sorted(dp.iterkeys())\n    shift = 0\n    result = [0] * (basis.bit_length() - 1)\n    for _ in xrange(n - len(result)):\n        new_dp = {}\n        new_sorted_sums = []\n        new_shift = sorted_sums[0] - sorted_sums[1]\n        assert new_shift < 0\n        for x in sorted_sums:\n            if not dp[x]:\n                continue\n            dp[x - new_shift] -= dp[x]\n            new_dp[x - new_shift] = dp[x]\n            new_sorted_sums.append(x - new_shift)\n        dp = new_dp\n        sorted_sums = new_sorted_sums\n        if shift in dp:\n            result.append(new_shift)\n        else:\n            result.append(-new_shift)\n            shift -= new_shift\n    return result"
        ]
    },
    {
        "func_name": "recoverArray",
        "original": "def recoverArray(self, n, sums):\n    \"\"\"\n        :type n: int\n        :type sums: List[int]\n        :rtype: List[int]\n        \"\"\"\n    dp = {k: v for (k, v) in collections.Counter(sums).iteritems()}\n    sorted_sums = sorted(dp.iterkeys())\n    shift = 0\n    result = []\n    for _ in xrange(n):\n        new_dp = {}\n        new_sorted_sums = []\n        new_shift = sorted_sums[0] - sorted_sums[1] if dp[sorted_sums[0]] == 1 else 0\n        assert new_shift <= 0\n        for x in sorted_sums:\n            if not dp[x]:\n                continue\n            dp[x - new_shift] -= dp[x] if new_shift else dp[x] // 2\n            new_dp[x - new_shift] = dp[x]\n            new_sorted_sums.append(x - new_shift)\n        dp = new_dp\n        sorted_sums = new_sorted_sums\n        if shift in dp:\n            result.append(new_shift)\n        else:\n            result.append(-new_shift)\n            shift -= new_shift\n    return result",
        "mutated": [
            "def recoverArray(self, n, sums):\n    if False:\n        i = 10\n    '\\n        :type n: int\\n        :type sums: List[int]\\n        :rtype: List[int]\\n        '\n    dp = {k: v for (k, v) in collections.Counter(sums).iteritems()}\n    sorted_sums = sorted(dp.iterkeys())\n    shift = 0\n    result = []\n    for _ in xrange(n):\n        new_dp = {}\n        new_sorted_sums = []\n        new_shift = sorted_sums[0] - sorted_sums[1] if dp[sorted_sums[0]] == 1 else 0\n        assert new_shift <= 0\n        for x in sorted_sums:\n            if not dp[x]:\n                continue\n            dp[x - new_shift] -= dp[x] if new_shift else dp[x] // 2\n            new_dp[x - new_shift] = dp[x]\n            new_sorted_sums.append(x - new_shift)\n        dp = new_dp\n        sorted_sums = new_sorted_sums\n        if shift in dp:\n            result.append(new_shift)\n        else:\n            result.append(-new_shift)\n            shift -= new_shift\n    return result",
            "def recoverArray(self, n, sums):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :type n: int\\n        :type sums: List[int]\\n        :rtype: List[int]\\n        '\n    dp = {k: v for (k, v) in collections.Counter(sums).iteritems()}\n    sorted_sums = sorted(dp.iterkeys())\n    shift = 0\n    result = []\n    for _ in xrange(n):\n        new_dp = {}\n        new_sorted_sums = []\n        new_shift = sorted_sums[0] - sorted_sums[1] if dp[sorted_sums[0]] == 1 else 0\n        assert new_shift <= 0\n        for x in sorted_sums:\n            if not dp[x]:\n                continue\n            dp[x - new_shift] -= dp[x] if new_shift else dp[x] // 2\n            new_dp[x - new_shift] = dp[x]\n            new_sorted_sums.append(x - new_shift)\n        dp = new_dp\n        sorted_sums = new_sorted_sums\n        if shift in dp:\n            result.append(new_shift)\n        else:\n            result.append(-new_shift)\n            shift -= new_shift\n    return result",
            "def recoverArray(self, n, sums):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :type n: int\\n        :type sums: List[int]\\n        :rtype: List[int]\\n        '\n    dp = {k: v for (k, v) in collections.Counter(sums).iteritems()}\n    sorted_sums = sorted(dp.iterkeys())\n    shift = 0\n    result = []\n    for _ in xrange(n):\n        new_dp = {}\n        new_sorted_sums = []\n        new_shift = sorted_sums[0] - sorted_sums[1] if dp[sorted_sums[0]] == 1 else 0\n        assert new_shift <= 0\n        for x in sorted_sums:\n            if not dp[x]:\n                continue\n            dp[x - new_shift] -= dp[x] if new_shift else dp[x] // 2\n            new_dp[x - new_shift] = dp[x]\n            new_sorted_sums.append(x - new_shift)\n        dp = new_dp\n        sorted_sums = new_sorted_sums\n        if shift in dp:\n            result.append(new_shift)\n        else:\n            result.append(-new_shift)\n            shift -= new_shift\n    return result",
            "def recoverArray(self, n, sums):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :type n: int\\n        :type sums: List[int]\\n        :rtype: List[int]\\n        '\n    dp = {k: v for (k, v) in collections.Counter(sums).iteritems()}\n    sorted_sums = sorted(dp.iterkeys())\n    shift = 0\n    result = []\n    for _ in xrange(n):\n        new_dp = {}\n        new_sorted_sums = []\n        new_shift = sorted_sums[0] - sorted_sums[1] if dp[sorted_sums[0]] == 1 else 0\n        assert new_shift <= 0\n        for x in sorted_sums:\n            if not dp[x]:\n                continue\n            dp[x - new_shift] -= dp[x] if new_shift else dp[x] // 2\n            new_dp[x - new_shift] = dp[x]\n            new_sorted_sums.append(x - new_shift)\n        dp = new_dp\n        sorted_sums = new_sorted_sums\n        if shift in dp:\n            result.append(new_shift)\n        else:\n            result.append(-new_shift)\n            shift -= new_shift\n    return result",
            "def recoverArray(self, n, sums):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :type n: int\\n        :type sums: List[int]\\n        :rtype: List[int]\\n        '\n    dp = {k: v for (k, v) in collections.Counter(sums).iteritems()}\n    sorted_sums = sorted(dp.iterkeys())\n    shift = 0\n    result = []\n    for _ in xrange(n):\n        new_dp = {}\n        new_sorted_sums = []\n        new_shift = sorted_sums[0] - sorted_sums[1] if dp[sorted_sums[0]] == 1 else 0\n        assert new_shift <= 0\n        for x in sorted_sums:\n            if not dp[x]:\n                continue\n            dp[x - new_shift] -= dp[x] if new_shift else dp[x] // 2\n            new_dp[x - new_shift] = dp[x]\n            new_sorted_sums.append(x - new_shift)\n        dp = new_dp\n        sorted_sums = new_sorted_sums\n        if shift in dp:\n            result.append(new_shift)\n        else:\n            result.append(-new_shift)\n            shift -= new_shift\n    return result"
        ]
    },
    {
        "func_name": "recoverArray",
        "original": "def recoverArray(self, n, sums):\n    \"\"\"\n        :type n: int\n        :type sums: List[int]\n        :rtype: List[int]\n        \"\"\"\n    dp = OrderedDict(sorted(collections.Counter(sums).iteritems()))\n    shift = 0\n    result = []\n    for _ in xrange(n):\n        new_dp = OrderedDict()\n        it = iter(dp)\n        min_sum = next(it)\n        new_shift = min_sum - next(it) if dp[min_sum] == 1 else 0\n        assert new_shift <= 0\n        for x in dp.iterkeys():\n            if not dp[x]:\n                continue\n            dp[x - new_shift] -= dp[x] if new_shift else dp[x] // 2\n            new_dp[x - new_shift] = dp[x]\n        dp = new_dp\n        if shift in dp:\n            result.append(new_shift)\n        else:\n            result.append(-new_shift)\n            shift -= new_shift\n    return result",
        "mutated": [
            "def recoverArray(self, n, sums):\n    if False:\n        i = 10\n    '\\n        :type n: int\\n        :type sums: List[int]\\n        :rtype: List[int]\\n        '\n    dp = OrderedDict(sorted(collections.Counter(sums).iteritems()))\n    shift = 0\n    result = []\n    for _ in xrange(n):\n        new_dp = OrderedDict()\n        it = iter(dp)\n        min_sum = next(it)\n        new_shift = min_sum - next(it) if dp[min_sum] == 1 else 0\n        assert new_shift <= 0\n        for x in dp.iterkeys():\n            if not dp[x]:\n                continue\n            dp[x - new_shift] -= dp[x] if new_shift else dp[x] // 2\n            new_dp[x - new_shift] = dp[x]\n        dp = new_dp\n        if shift in dp:\n            result.append(new_shift)\n        else:\n            result.append(-new_shift)\n            shift -= new_shift\n    return result",
            "def recoverArray(self, n, sums):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :type n: int\\n        :type sums: List[int]\\n        :rtype: List[int]\\n        '\n    dp = OrderedDict(sorted(collections.Counter(sums).iteritems()))\n    shift = 0\n    result = []\n    for _ in xrange(n):\n        new_dp = OrderedDict()\n        it = iter(dp)\n        min_sum = next(it)\n        new_shift = min_sum - next(it) if dp[min_sum] == 1 else 0\n        assert new_shift <= 0\n        for x in dp.iterkeys():\n            if not dp[x]:\n                continue\n            dp[x - new_shift] -= dp[x] if new_shift else dp[x] // 2\n            new_dp[x - new_shift] = dp[x]\n        dp = new_dp\n        if shift in dp:\n            result.append(new_shift)\n        else:\n            result.append(-new_shift)\n            shift -= new_shift\n    return result",
            "def recoverArray(self, n, sums):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :type n: int\\n        :type sums: List[int]\\n        :rtype: List[int]\\n        '\n    dp = OrderedDict(sorted(collections.Counter(sums).iteritems()))\n    shift = 0\n    result = []\n    for _ in xrange(n):\n        new_dp = OrderedDict()\n        it = iter(dp)\n        min_sum = next(it)\n        new_shift = min_sum - next(it) if dp[min_sum] == 1 else 0\n        assert new_shift <= 0\n        for x in dp.iterkeys():\n            if not dp[x]:\n                continue\n            dp[x - new_shift] -= dp[x] if new_shift else dp[x] // 2\n            new_dp[x - new_shift] = dp[x]\n        dp = new_dp\n        if shift in dp:\n            result.append(new_shift)\n        else:\n            result.append(-new_shift)\n            shift -= new_shift\n    return result",
            "def recoverArray(self, n, sums):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :type n: int\\n        :type sums: List[int]\\n        :rtype: List[int]\\n        '\n    dp = OrderedDict(sorted(collections.Counter(sums).iteritems()))\n    shift = 0\n    result = []\n    for _ in xrange(n):\n        new_dp = OrderedDict()\n        it = iter(dp)\n        min_sum = next(it)\n        new_shift = min_sum - next(it) if dp[min_sum] == 1 else 0\n        assert new_shift <= 0\n        for x in dp.iterkeys():\n            if not dp[x]:\n                continue\n            dp[x - new_shift] -= dp[x] if new_shift else dp[x] // 2\n            new_dp[x - new_shift] = dp[x]\n        dp = new_dp\n        if shift in dp:\n            result.append(new_shift)\n        else:\n            result.append(-new_shift)\n            shift -= new_shift\n    return result",
            "def recoverArray(self, n, sums):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :type n: int\\n        :type sums: List[int]\\n        :rtype: List[int]\\n        '\n    dp = OrderedDict(sorted(collections.Counter(sums).iteritems()))\n    shift = 0\n    result = []\n    for _ in xrange(n):\n        new_dp = OrderedDict()\n        it = iter(dp)\n        min_sum = next(it)\n        new_shift = min_sum - next(it) if dp[min_sum] == 1 else 0\n        assert new_shift <= 0\n        for x in dp.iterkeys():\n            if not dp[x]:\n                continue\n            dp[x - new_shift] -= dp[x] if new_shift else dp[x] // 2\n            new_dp[x - new_shift] = dp[x]\n        dp = new_dp\n        if shift in dp:\n            result.append(new_shift)\n        else:\n            result.append(-new_shift)\n            shift -= new_shift\n    return result"
        ]
    }
]