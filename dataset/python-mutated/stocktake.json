[
    {
        "func_name": "perform_stocktake",
        "original": "def perform_stocktake(target: part.models.Part, user: User, note: str='', commit=True, **kwargs):\n    \"\"\"Perform stocktake action on a single part.\n\n    arguments:\n        target: A single Part model instance\n        commit: If True (default) save the result to the database\n        user: User who requested this stocktake\n\n    kwargs:\n        exclude_external: If True, exclude stock items in external locations (default = False)\n        location: Optional StockLocation to filter results for generated report\n\n    Returns:\n        PartStocktake: A new PartStocktake model instance (for the specified Part)\n\n    Note that while we record a *total stocktake* for the Part instance which gets saved to the database,\n    the user may have requested a stocktake limited to a particular location.\n\n    In this case, the stocktake *report* will be limited to the specified location.\n    \"\"\"\n    location = kwargs.get('location', None)\n    locations = location.get_descendants(include_self=True) if location else []\n    stock_entries = target.stock_entries(in_stock=True, include_variants=False)\n    exclude_external = kwargs.get('exclude_external', False)\n    if exclude_external:\n        stock_entries = stock_entries.exclude(location__external=True)\n    pricing = target.pricing\n    if not pricing.is_valid:\n        logger.info('Pricing not valid for %s - updating', target)\n        pricing.update_pricing(cascade=False)\n        pricing.refresh_from_db()\n    base_currency = common.settings.currency_code_default()\n    total_quantity = 0\n    total_cost_min = Money(0, base_currency)\n    total_cost_max = Money(0, base_currency)\n    location_item_count = 0\n    location_quantity = 0\n    location_cost_min = Money(0, base_currency)\n    location_cost_max = Money(0, base_currency)\n    for entry in stock_entries:\n        entry_cost_min = None\n        entry_cost_max = None\n        if entry.purchase_price:\n            entry_cost_min = entry.purchase_price\n            entry_cost_max = entry.purchase_price\n        else:\n            entry_cost_min = pricing.overall_min or pricing.overall_max\n            entry_cost_max = pricing.overall_max or pricing.overall_min\n        try:\n            entry_cost_min = convert_money(entry_cost_min, base_currency) * entry.quantity\n            entry_cost_max = convert_money(entry_cost_max, base_currency) * entry.quantity\n        except Exception:\n            entry_cost_min = Money(0, base_currency)\n            entry_cost_max = Money(0, base_currency)\n        total_quantity += entry.quantity\n        total_cost_min += entry_cost_min\n        total_cost_max += entry_cost_max\n        if location and entry.location not in locations:\n            continue\n        location_item_count += 1\n        location_quantity += entry.quantity\n        location_cost_min += entry_cost_min\n        location_cost_max += entry_cost_max\n    instance = part.models.PartStocktake(part=target, item_count=stock_entries.count(), quantity=total_quantity, cost_min=total_cost_min, cost_max=total_cost_max, note=note, user=user)\n    if commit:\n        instance.save()\n    instance.location_item_count = location_item_count\n    instance.location_quantity = location_quantity\n    instance.location_cost_min = location_cost_min\n    instance.location_cost_max = location_cost_max\n    return instance",
        "mutated": [
            "def perform_stocktake(target: part.models.Part, user: User, note: str='', commit=True, **kwargs):\n    if False:\n        i = 10\n    'Perform stocktake action on a single part.\\n\\n    arguments:\\n        target: A single Part model instance\\n        commit: If True (default) save the result to the database\\n        user: User who requested this stocktake\\n\\n    kwargs:\\n        exclude_external: If True, exclude stock items in external locations (default = False)\\n        location: Optional StockLocation to filter results for generated report\\n\\n    Returns:\\n        PartStocktake: A new PartStocktake model instance (for the specified Part)\\n\\n    Note that while we record a *total stocktake* for the Part instance which gets saved to the database,\\n    the user may have requested a stocktake limited to a particular location.\\n\\n    In this case, the stocktake *report* will be limited to the specified location.\\n    '\n    location = kwargs.get('location', None)\n    locations = location.get_descendants(include_self=True) if location else []\n    stock_entries = target.stock_entries(in_stock=True, include_variants=False)\n    exclude_external = kwargs.get('exclude_external', False)\n    if exclude_external:\n        stock_entries = stock_entries.exclude(location__external=True)\n    pricing = target.pricing\n    if not pricing.is_valid:\n        logger.info('Pricing not valid for %s - updating', target)\n        pricing.update_pricing(cascade=False)\n        pricing.refresh_from_db()\n    base_currency = common.settings.currency_code_default()\n    total_quantity = 0\n    total_cost_min = Money(0, base_currency)\n    total_cost_max = Money(0, base_currency)\n    location_item_count = 0\n    location_quantity = 0\n    location_cost_min = Money(0, base_currency)\n    location_cost_max = Money(0, base_currency)\n    for entry in stock_entries:\n        entry_cost_min = None\n        entry_cost_max = None\n        if entry.purchase_price:\n            entry_cost_min = entry.purchase_price\n            entry_cost_max = entry.purchase_price\n        else:\n            entry_cost_min = pricing.overall_min or pricing.overall_max\n            entry_cost_max = pricing.overall_max or pricing.overall_min\n        try:\n            entry_cost_min = convert_money(entry_cost_min, base_currency) * entry.quantity\n            entry_cost_max = convert_money(entry_cost_max, base_currency) * entry.quantity\n        except Exception:\n            entry_cost_min = Money(0, base_currency)\n            entry_cost_max = Money(0, base_currency)\n        total_quantity += entry.quantity\n        total_cost_min += entry_cost_min\n        total_cost_max += entry_cost_max\n        if location and entry.location not in locations:\n            continue\n        location_item_count += 1\n        location_quantity += entry.quantity\n        location_cost_min += entry_cost_min\n        location_cost_max += entry_cost_max\n    instance = part.models.PartStocktake(part=target, item_count=stock_entries.count(), quantity=total_quantity, cost_min=total_cost_min, cost_max=total_cost_max, note=note, user=user)\n    if commit:\n        instance.save()\n    instance.location_item_count = location_item_count\n    instance.location_quantity = location_quantity\n    instance.location_cost_min = location_cost_min\n    instance.location_cost_max = location_cost_max\n    return instance",
            "def perform_stocktake(target: part.models.Part, user: User, note: str='', commit=True, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Perform stocktake action on a single part.\\n\\n    arguments:\\n        target: A single Part model instance\\n        commit: If True (default) save the result to the database\\n        user: User who requested this stocktake\\n\\n    kwargs:\\n        exclude_external: If True, exclude stock items in external locations (default = False)\\n        location: Optional StockLocation to filter results for generated report\\n\\n    Returns:\\n        PartStocktake: A new PartStocktake model instance (for the specified Part)\\n\\n    Note that while we record a *total stocktake* for the Part instance which gets saved to the database,\\n    the user may have requested a stocktake limited to a particular location.\\n\\n    In this case, the stocktake *report* will be limited to the specified location.\\n    '\n    location = kwargs.get('location', None)\n    locations = location.get_descendants(include_self=True) if location else []\n    stock_entries = target.stock_entries(in_stock=True, include_variants=False)\n    exclude_external = kwargs.get('exclude_external', False)\n    if exclude_external:\n        stock_entries = stock_entries.exclude(location__external=True)\n    pricing = target.pricing\n    if not pricing.is_valid:\n        logger.info('Pricing not valid for %s - updating', target)\n        pricing.update_pricing(cascade=False)\n        pricing.refresh_from_db()\n    base_currency = common.settings.currency_code_default()\n    total_quantity = 0\n    total_cost_min = Money(0, base_currency)\n    total_cost_max = Money(0, base_currency)\n    location_item_count = 0\n    location_quantity = 0\n    location_cost_min = Money(0, base_currency)\n    location_cost_max = Money(0, base_currency)\n    for entry in stock_entries:\n        entry_cost_min = None\n        entry_cost_max = None\n        if entry.purchase_price:\n            entry_cost_min = entry.purchase_price\n            entry_cost_max = entry.purchase_price\n        else:\n            entry_cost_min = pricing.overall_min or pricing.overall_max\n            entry_cost_max = pricing.overall_max or pricing.overall_min\n        try:\n            entry_cost_min = convert_money(entry_cost_min, base_currency) * entry.quantity\n            entry_cost_max = convert_money(entry_cost_max, base_currency) * entry.quantity\n        except Exception:\n            entry_cost_min = Money(0, base_currency)\n            entry_cost_max = Money(0, base_currency)\n        total_quantity += entry.quantity\n        total_cost_min += entry_cost_min\n        total_cost_max += entry_cost_max\n        if location and entry.location not in locations:\n            continue\n        location_item_count += 1\n        location_quantity += entry.quantity\n        location_cost_min += entry_cost_min\n        location_cost_max += entry_cost_max\n    instance = part.models.PartStocktake(part=target, item_count=stock_entries.count(), quantity=total_quantity, cost_min=total_cost_min, cost_max=total_cost_max, note=note, user=user)\n    if commit:\n        instance.save()\n    instance.location_item_count = location_item_count\n    instance.location_quantity = location_quantity\n    instance.location_cost_min = location_cost_min\n    instance.location_cost_max = location_cost_max\n    return instance",
            "def perform_stocktake(target: part.models.Part, user: User, note: str='', commit=True, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Perform stocktake action on a single part.\\n\\n    arguments:\\n        target: A single Part model instance\\n        commit: If True (default) save the result to the database\\n        user: User who requested this stocktake\\n\\n    kwargs:\\n        exclude_external: If True, exclude stock items in external locations (default = False)\\n        location: Optional StockLocation to filter results for generated report\\n\\n    Returns:\\n        PartStocktake: A new PartStocktake model instance (for the specified Part)\\n\\n    Note that while we record a *total stocktake* for the Part instance which gets saved to the database,\\n    the user may have requested a stocktake limited to a particular location.\\n\\n    In this case, the stocktake *report* will be limited to the specified location.\\n    '\n    location = kwargs.get('location', None)\n    locations = location.get_descendants(include_self=True) if location else []\n    stock_entries = target.stock_entries(in_stock=True, include_variants=False)\n    exclude_external = kwargs.get('exclude_external', False)\n    if exclude_external:\n        stock_entries = stock_entries.exclude(location__external=True)\n    pricing = target.pricing\n    if not pricing.is_valid:\n        logger.info('Pricing not valid for %s - updating', target)\n        pricing.update_pricing(cascade=False)\n        pricing.refresh_from_db()\n    base_currency = common.settings.currency_code_default()\n    total_quantity = 0\n    total_cost_min = Money(0, base_currency)\n    total_cost_max = Money(0, base_currency)\n    location_item_count = 0\n    location_quantity = 0\n    location_cost_min = Money(0, base_currency)\n    location_cost_max = Money(0, base_currency)\n    for entry in stock_entries:\n        entry_cost_min = None\n        entry_cost_max = None\n        if entry.purchase_price:\n            entry_cost_min = entry.purchase_price\n            entry_cost_max = entry.purchase_price\n        else:\n            entry_cost_min = pricing.overall_min or pricing.overall_max\n            entry_cost_max = pricing.overall_max or pricing.overall_min\n        try:\n            entry_cost_min = convert_money(entry_cost_min, base_currency) * entry.quantity\n            entry_cost_max = convert_money(entry_cost_max, base_currency) * entry.quantity\n        except Exception:\n            entry_cost_min = Money(0, base_currency)\n            entry_cost_max = Money(0, base_currency)\n        total_quantity += entry.quantity\n        total_cost_min += entry_cost_min\n        total_cost_max += entry_cost_max\n        if location and entry.location not in locations:\n            continue\n        location_item_count += 1\n        location_quantity += entry.quantity\n        location_cost_min += entry_cost_min\n        location_cost_max += entry_cost_max\n    instance = part.models.PartStocktake(part=target, item_count=stock_entries.count(), quantity=total_quantity, cost_min=total_cost_min, cost_max=total_cost_max, note=note, user=user)\n    if commit:\n        instance.save()\n    instance.location_item_count = location_item_count\n    instance.location_quantity = location_quantity\n    instance.location_cost_min = location_cost_min\n    instance.location_cost_max = location_cost_max\n    return instance",
            "def perform_stocktake(target: part.models.Part, user: User, note: str='', commit=True, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Perform stocktake action on a single part.\\n\\n    arguments:\\n        target: A single Part model instance\\n        commit: If True (default) save the result to the database\\n        user: User who requested this stocktake\\n\\n    kwargs:\\n        exclude_external: If True, exclude stock items in external locations (default = False)\\n        location: Optional StockLocation to filter results for generated report\\n\\n    Returns:\\n        PartStocktake: A new PartStocktake model instance (for the specified Part)\\n\\n    Note that while we record a *total stocktake* for the Part instance which gets saved to the database,\\n    the user may have requested a stocktake limited to a particular location.\\n\\n    In this case, the stocktake *report* will be limited to the specified location.\\n    '\n    location = kwargs.get('location', None)\n    locations = location.get_descendants(include_self=True) if location else []\n    stock_entries = target.stock_entries(in_stock=True, include_variants=False)\n    exclude_external = kwargs.get('exclude_external', False)\n    if exclude_external:\n        stock_entries = stock_entries.exclude(location__external=True)\n    pricing = target.pricing\n    if not pricing.is_valid:\n        logger.info('Pricing not valid for %s - updating', target)\n        pricing.update_pricing(cascade=False)\n        pricing.refresh_from_db()\n    base_currency = common.settings.currency_code_default()\n    total_quantity = 0\n    total_cost_min = Money(0, base_currency)\n    total_cost_max = Money(0, base_currency)\n    location_item_count = 0\n    location_quantity = 0\n    location_cost_min = Money(0, base_currency)\n    location_cost_max = Money(0, base_currency)\n    for entry in stock_entries:\n        entry_cost_min = None\n        entry_cost_max = None\n        if entry.purchase_price:\n            entry_cost_min = entry.purchase_price\n            entry_cost_max = entry.purchase_price\n        else:\n            entry_cost_min = pricing.overall_min or pricing.overall_max\n            entry_cost_max = pricing.overall_max or pricing.overall_min\n        try:\n            entry_cost_min = convert_money(entry_cost_min, base_currency) * entry.quantity\n            entry_cost_max = convert_money(entry_cost_max, base_currency) * entry.quantity\n        except Exception:\n            entry_cost_min = Money(0, base_currency)\n            entry_cost_max = Money(0, base_currency)\n        total_quantity += entry.quantity\n        total_cost_min += entry_cost_min\n        total_cost_max += entry_cost_max\n        if location and entry.location not in locations:\n            continue\n        location_item_count += 1\n        location_quantity += entry.quantity\n        location_cost_min += entry_cost_min\n        location_cost_max += entry_cost_max\n    instance = part.models.PartStocktake(part=target, item_count=stock_entries.count(), quantity=total_quantity, cost_min=total_cost_min, cost_max=total_cost_max, note=note, user=user)\n    if commit:\n        instance.save()\n    instance.location_item_count = location_item_count\n    instance.location_quantity = location_quantity\n    instance.location_cost_min = location_cost_min\n    instance.location_cost_max = location_cost_max\n    return instance",
            "def perform_stocktake(target: part.models.Part, user: User, note: str='', commit=True, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Perform stocktake action on a single part.\\n\\n    arguments:\\n        target: A single Part model instance\\n        commit: If True (default) save the result to the database\\n        user: User who requested this stocktake\\n\\n    kwargs:\\n        exclude_external: If True, exclude stock items in external locations (default = False)\\n        location: Optional StockLocation to filter results for generated report\\n\\n    Returns:\\n        PartStocktake: A new PartStocktake model instance (for the specified Part)\\n\\n    Note that while we record a *total stocktake* for the Part instance which gets saved to the database,\\n    the user may have requested a stocktake limited to a particular location.\\n\\n    In this case, the stocktake *report* will be limited to the specified location.\\n    '\n    location = kwargs.get('location', None)\n    locations = location.get_descendants(include_self=True) if location else []\n    stock_entries = target.stock_entries(in_stock=True, include_variants=False)\n    exclude_external = kwargs.get('exclude_external', False)\n    if exclude_external:\n        stock_entries = stock_entries.exclude(location__external=True)\n    pricing = target.pricing\n    if not pricing.is_valid:\n        logger.info('Pricing not valid for %s - updating', target)\n        pricing.update_pricing(cascade=False)\n        pricing.refresh_from_db()\n    base_currency = common.settings.currency_code_default()\n    total_quantity = 0\n    total_cost_min = Money(0, base_currency)\n    total_cost_max = Money(0, base_currency)\n    location_item_count = 0\n    location_quantity = 0\n    location_cost_min = Money(0, base_currency)\n    location_cost_max = Money(0, base_currency)\n    for entry in stock_entries:\n        entry_cost_min = None\n        entry_cost_max = None\n        if entry.purchase_price:\n            entry_cost_min = entry.purchase_price\n            entry_cost_max = entry.purchase_price\n        else:\n            entry_cost_min = pricing.overall_min or pricing.overall_max\n            entry_cost_max = pricing.overall_max or pricing.overall_min\n        try:\n            entry_cost_min = convert_money(entry_cost_min, base_currency) * entry.quantity\n            entry_cost_max = convert_money(entry_cost_max, base_currency) * entry.quantity\n        except Exception:\n            entry_cost_min = Money(0, base_currency)\n            entry_cost_max = Money(0, base_currency)\n        total_quantity += entry.quantity\n        total_cost_min += entry_cost_min\n        total_cost_max += entry_cost_max\n        if location and entry.location not in locations:\n            continue\n        location_item_count += 1\n        location_quantity += entry.quantity\n        location_cost_min += entry_cost_min\n        location_cost_max += entry_cost_max\n    instance = part.models.PartStocktake(part=target, item_count=stock_entries.count(), quantity=total_quantity, cost_min=total_cost_min, cost_max=total_cost_max, note=note, user=user)\n    if commit:\n        instance.save()\n    instance.location_item_count = location_item_count\n    instance.location_quantity = location_quantity\n    instance.location_cost_min = location_cost_min\n    instance.location_cost_max = location_cost_max\n    return instance"
        ]
    },
    {
        "func_name": "generate_stocktake_report",
        "original": "def generate_stocktake_report(**kwargs):\n    \"\"\"Generated a new stocktake report.\n\n    Note that this method should be called only by the background worker process!\n\n    Unless otherwise specified, the stocktake report is generated for *all* Part instances.\n    Optional filters can by supplied via the kwargs\n\n    kwargs:\n        user: The user who requested this stocktake (set to None for automated stocktake)\n        part: Optional Part instance to filter by (including variant parts)\n        category: Optional PartCategory to filter results\n        location: Optional StockLocation to filter results\n        exclude_external: If True, exclude stock items in external locations (default = False)\n        generate_report: If True, generate a stocktake report from the calculated data (default=True)\n        update_parts: If True, save stocktake information against each filtered Part (default = True)\n    \"\"\"\n    exclude_external = kwargs.get('exclude_exernal', common.models.InvenTreeSetting.get_setting('STOCKTAKE_EXCLUDE_EXTERNAL', False))\n    parts = part.models.Part.objects.all()\n    user = kwargs.get('user', None)\n    generate_report = kwargs.get('generate_report', True)\n    update_parts = kwargs.get('update_parts', True)\n    if (p := kwargs.get('part', None)):\n        variants = p.get_descendants(include_self=True)\n        parts = parts.filter(pk__in=[v.pk for v in variants])\n    if (category := kwargs.get('category', None)):\n        categories = category.get_descendants(include_self=True)\n        parts = parts.filter(category__in=categories)\n    if (location := kwargs.get('location', None)):\n        locations = list(location.get_descendants(include_self=True))\n        items = stock.models.StockItem.objects.filter(location__in=locations)\n        if exclude_external:\n            items = items.exclude(location__external=True)\n        unique_parts = items.order_by().values('part').distinct()\n        parts = parts.filter(pk__in=[result['part'] for result in unique_parts])\n    n_parts = parts.count()\n    if n_parts == 0:\n        logger.info('No parts selected for stocktake report - exiting')\n        return\n    logger.info('Generating new stocktake report for %s parts', n_parts)\n    base_currency = common.settings.currency_code_default()\n    dataset = tablib.Dataset(headers=[_('Part ID'), _('Part Name'), _('Part Description'), _('Category ID'), _('Category Name'), _('Stock Items'), _('Total Quantity'), _('Total Cost Min') + f' ({base_currency})', _('Total Cost Max') + f' ({base_currency})'])\n    parts = parts.prefetch_related('category', 'stock_items')\n    t_start = time.time()\n    stocktake_instances = []\n    total_parts = 0\n    for p in parts:\n        stocktake = perform_stocktake(p, user, commit=False, exclude_external=exclude_external, location=location)\n        total_parts += 1\n        stocktake_instances.append(stocktake)\n        dataset.append([p.pk, p.full_name, p.description, p.category.pk if p.category else '', p.category.name if p.category else '', stocktake.location_item_count, stocktake.location_quantity, InvenTree.helpers.normalize(stocktake.location_cost_min.amount), InvenTree.helpers.normalize(stocktake.location_cost_max.amount)])\n    buffer = io.StringIO()\n    buffer.write(dataset.export('csv'))\n    today = datetime.now().date().isoformat()\n    filename = f'InvenTree_Stocktake_{today}.csv'\n    report_file = ContentFile(buffer.getvalue(), name=filename)\n    if generate_report:\n        report_instance = part.models.PartStocktakeReport.objects.create(report=report_file, part_count=total_parts, user=user)\n        if user:\n            common.notifications.trigger_notification(report_instance, category='generate_stocktake_report', context={'name': _('Stocktake Report Available'), 'message': _('A new stocktake report is available for download')}, targets=[user])\n    if update_parts:\n        part.models.PartStocktake.objects.bulk_create(stocktake_instances, batch_size=500)\n    t_stocktake = time.time() - t_start\n    logger.info('Generated stocktake report for %s parts in %ss', total_parts, round(t_stocktake, 2))",
        "mutated": [
            "def generate_stocktake_report(**kwargs):\n    if False:\n        i = 10\n    'Generated a new stocktake report.\\n\\n    Note that this method should be called only by the background worker process!\\n\\n    Unless otherwise specified, the stocktake report is generated for *all* Part instances.\\n    Optional filters can by supplied via the kwargs\\n\\n    kwargs:\\n        user: The user who requested this stocktake (set to None for automated stocktake)\\n        part: Optional Part instance to filter by (including variant parts)\\n        category: Optional PartCategory to filter results\\n        location: Optional StockLocation to filter results\\n        exclude_external: If True, exclude stock items in external locations (default = False)\\n        generate_report: If True, generate a stocktake report from the calculated data (default=True)\\n        update_parts: If True, save stocktake information against each filtered Part (default = True)\\n    '\n    exclude_external = kwargs.get('exclude_exernal', common.models.InvenTreeSetting.get_setting('STOCKTAKE_EXCLUDE_EXTERNAL', False))\n    parts = part.models.Part.objects.all()\n    user = kwargs.get('user', None)\n    generate_report = kwargs.get('generate_report', True)\n    update_parts = kwargs.get('update_parts', True)\n    if (p := kwargs.get('part', None)):\n        variants = p.get_descendants(include_self=True)\n        parts = parts.filter(pk__in=[v.pk for v in variants])\n    if (category := kwargs.get('category', None)):\n        categories = category.get_descendants(include_self=True)\n        parts = parts.filter(category__in=categories)\n    if (location := kwargs.get('location', None)):\n        locations = list(location.get_descendants(include_self=True))\n        items = stock.models.StockItem.objects.filter(location__in=locations)\n        if exclude_external:\n            items = items.exclude(location__external=True)\n        unique_parts = items.order_by().values('part').distinct()\n        parts = parts.filter(pk__in=[result['part'] for result in unique_parts])\n    n_parts = parts.count()\n    if n_parts == 0:\n        logger.info('No parts selected for stocktake report - exiting')\n        return\n    logger.info('Generating new stocktake report for %s parts', n_parts)\n    base_currency = common.settings.currency_code_default()\n    dataset = tablib.Dataset(headers=[_('Part ID'), _('Part Name'), _('Part Description'), _('Category ID'), _('Category Name'), _('Stock Items'), _('Total Quantity'), _('Total Cost Min') + f' ({base_currency})', _('Total Cost Max') + f' ({base_currency})'])\n    parts = parts.prefetch_related('category', 'stock_items')\n    t_start = time.time()\n    stocktake_instances = []\n    total_parts = 0\n    for p in parts:\n        stocktake = perform_stocktake(p, user, commit=False, exclude_external=exclude_external, location=location)\n        total_parts += 1\n        stocktake_instances.append(stocktake)\n        dataset.append([p.pk, p.full_name, p.description, p.category.pk if p.category else '', p.category.name if p.category else '', stocktake.location_item_count, stocktake.location_quantity, InvenTree.helpers.normalize(stocktake.location_cost_min.amount), InvenTree.helpers.normalize(stocktake.location_cost_max.amount)])\n    buffer = io.StringIO()\n    buffer.write(dataset.export('csv'))\n    today = datetime.now().date().isoformat()\n    filename = f'InvenTree_Stocktake_{today}.csv'\n    report_file = ContentFile(buffer.getvalue(), name=filename)\n    if generate_report:\n        report_instance = part.models.PartStocktakeReport.objects.create(report=report_file, part_count=total_parts, user=user)\n        if user:\n            common.notifications.trigger_notification(report_instance, category='generate_stocktake_report', context={'name': _('Stocktake Report Available'), 'message': _('A new stocktake report is available for download')}, targets=[user])\n    if update_parts:\n        part.models.PartStocktake.objects.bulk_create(stocktake_instances, batch_size=500)\n    t_stocktake = time.time() - t_start\n    logger.info('Generated stocktake report for %s parts in %ss', total_parts, round(t_stocktake, 2))",
            "def generate_stocktake_report(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Generated a new stocktake report.\\n\\n    Note that this method should be called only by the background worker process!\\n\\n    Unless otherwise specified, the stocktake report is generated for *all* Part instances.\\n    Optional filters can by supplied via the kwargs\\n\\n    kwargs:\\n        user: The user who requested this stocktake (set to None for automated stocktake)\\n        part: Optional Part instance to filter by (including variant parts)\\n        category: Optional PartCategory to filter results\\n        location: Optional StockLocation to filter results\\n        exclude_external: If True, exclude stock items in external locations (default = False)\\n        generate_report: If True, generate a stocktake report from the calculated data (default=True)\\n        update_parts: If True, save stocktake information against each filtered Part (default = True)\\n    '\n    exclude_external = kwargs.get('exclude_exernal', common.models.InvenTreeSetting.get_setting('STOCKTAKE_EXCLUDE_EXTERNAL', False))\n    parts = part.models.Part.objects.all()\n    user = kwargs.get('user', None)\n    generate_report = kwargs.get('generate_report', True)\n    update_parts = kwargs.get('update_parts', True)\n    if (p := kwargs.get('part', None)):\n        variants = p.get_descendants(include_self=True)\n        parts = parts.filter(pk__in=[v.pk for v in variants])\n    if (category := kwargs.get('category', None)):\n        categories = category.get_descendants(include_self=True)\n        parts = parts.filter(category__in=categories)\n    if (location := kwargs.get('location', None)):\n        locations = list(location.get_descendants(include_self=True))\n        items = stock.models.StockItem.objects.filter(location__in=locations)\n        if exclude_external:\n            items = items.exclude(location__external=True)\n        unique_parts = items.order_by().values('part').distinct()\n        parts = parts.filter(pk__in=[result['part'] for result in unique_parts])\n    n_parts = parts.count()\n    if n_parts == 0:\n        logger.info('No parts selected for stocktake report - exiting')\n        return\n    logger.info('Generating new stocktake report for %s parts', n_parts)\n    base_currency = common.settings.currency_code_default()\n    dataset = tablib.Dataset(headers=[_('Part ID'), _('Part Name'), _('Part Description'), _('Category ID'), _('Category Name'), _('Stock Items'), _('Total Quantity'), _('Total Cost Min') + f' ({base_currency})', _('Total Cost Max') + f' ({base_currency})'])\n    parts = parts.prefetch_related('category', 'stock_items')\n    t_start = time.time()\n    stocktake_instances = []\n    total_parts = 0\n    for p in parts:\n        stocktake = perform_stocktake(p, user, commit=False, exclude_external=exclude_external, location=location)\n        total_parts += 1\n        stocktake_instances.append(stocktake)\n        dataset.append([p.pk, p.full_name, p.description, p.category.pk if p.category else '', p.category.name if p.category else '', stocktake.location_item_count, stocktake.location_quantity, InvenTree.helpers.normalize(stocktake.location_cost_min.amount), InvenTree.helpers.normalize(stocktake.location_cost_max.amount)])\n    buffer = io.StringIO()\n    buffer.write(dataset.export('csv'))\n    today = datetime.now().date().isoformat()\n    filename = f'InvenTree_Stocktake_{today}.csv'\n    report_file = ContentFile(buffer.getvalue(), name=filename)\n    if generate_report:\n        report_instance = part.models.PartStocktakeReport.objects.create(report=report_file, part_count=total_parts, user=user)\n        if user:\n            common.notifications.trigger_notification(report_instance, category='generate_stocktake_report', context={'name': _('Stocktake Report Available'), 'message': _('A new stocktake report is available for download')}, targets=[user])\n    if update_parts:\n        part.models.PartStocktake.objects.bulk_create(stocktake_instances, batch_size=500)\n    t_stocktake = time.time() - t_start\n    logger.info('Generated stocktake report for %s parts in %ss', total_parts, round(t_stocktake, 2))",
            "def generate_stocktake_report(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Generated a new stocktake report.\\n\\n    Note that this method should be called only by the background worker process!\\n\\n    Unless otherwise specified, the stocktake report is generated for *all* Part instances.\\n    Optional filters can by supplied via the kwargs\\n\\n    kwargs:\\n        user: The user who requested this stocktake (set to None for automated stocktake)\\n        part: Optional Part instance to filter by (including variant parts)\\n        category: Optional PartCategory to filter results\\n        location: Optional StockLocation to filter results\\n        exclude_external: If True, exclude stock items in external locations (default = False)\\n        generate_report: If True, generate a stocktake report from the calculated data (default=True)\\n        update_parts: If True, save stocktake information against each filtered Part (default = True)\\n    '\n    exclude_external = kwargs.get('exclude_exernal', common.models.InvenTreeSetting.get_setting('STOCKTAKE_EXCLUDE_EXTERNAL', False))\n    parts = part.models.Part.objects.all()\n    user = kwargs.get('user', None)\n    generate_report = kwargs.get('generate_report', True)\n    update_parts = kwargs.get('update_parts', True)\n    if (p := kwargs.get('part', None)):\n        variants = p.get_descendants(include_self=True)\n        parts = parts.filter(pk__in=[v.pk for v in variants])\n    if (category := kwargs.get('category', None)):\n        categories = category.get_descendants(include_self=True)\n        parts = parts.filter(category__in=categories)\n    if (location := kwargs.get('location', None)):\n        locations = list(location.get_descendants(include_self=True))\n        items = stock.models.StockItem.objects.filter(location__in=locations)\n        if exclude_external:\n            items = items.exclude(location__external=True)\n        unique_parts = items.order_by().values('part').distinct()\n        parts = parts.filter(pk__in=[result['part'] for result in unique_parts])\n    n_parts = parts.count()\n    if n_parts == 0:\n        logger.info('No parts selected for stocktake report - exiting')\n        return\n    logger.info('Generating new stocktake report for %s parts', n_parts)\n    base_currency = common.settings.currency_code_default()\n    dataset = tablib.Dataset(headers=[_('Part ID'), _('Part Name'), _('Part Description'), _('Category ID'), _('Category Name'), _('Stock Items'), _('Total Quantity'), _('Total Cost Min') + f' ({base_currency})', _('Total Cost Max') + f' ({base_currency})'])\n    parts = parts.prefetch_related('category', 'stock_items')\n    t_start = time.time()\n    stocktake_instances = []\n    total_parts = 0\n    for p in parts:\n        stocktake = perform_stocktake(p, user, commit=False, exclude_external=exclude_external, location=location)\n        total_parts += 1\n        stocktake_instances.append(stocktake)\n        dataset.append([p.pk, p.full_name, p.description, p.category.pk if p.category else '', p.category.name if p.category else '', stocktake.location_item_count, stocktake.location_quantity, InvenTree.helpers.normalize(stocktake.location_cost_min.amount), InvenTree.helpers.normalize(stocktake.location_cost_max.amount)])\n    buffer = io.StringIO()\n    buffer.write(dataset.export('csv'))\n    today = datetime.now().date().isoformat()\n    filename = f'InvenTree_Stocktake_{today}.csv'\n    report_file = ContentFile(buffer.getvalue(), name=filename)\n    if generate_report:\n        report_instance = part.models.PartStocktakeReport.objects.create(report=report_file, part_count=total_parts, user=user)\n        if user:\n            common.notifications.trigger_notification(report_instance, category='generate_stocktake_report', context={'name': _('Stocktake Report Available'), 'message': _('A new stocktake report is available for download')}, targets=[user])\n    if update_parts:\n        part.models.PartStocktake.objects.bulk_create(stocktake_instances, batch_size=500)\n    t_stocktake = time.time() - t_start\n    logger.info('Generated stocktake report for %s parts in %ss', total_parts, round(t_stocktake, 2))",
            "def generate_stocktake_report(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Generated a new stocktake report.\\n\\n    Note that this method should be called only by the background worker process!\\n\\n    Unless otherwise specified, the stocktake report is generated for *all* Part instances.\\n    Optional filters can by supplied via the kwargs\\n\\n    kwargs:\\n        user: The user who requested this stocktake (set to None for automated stocktake)\\n        part: Optional Part instance to filter by (including variant parts)\\n        category: Optional PartCategory to filter results\\n        location: Optional StockLocation to filter results\\n        exclude_external: If True, exclude stock items in external locations (default = False)\\n        generate_report: If True, generate a stocktake report from the calculated data (default=True)\\n        update_parts: If True, save stocktake information against each filtered Part (default = True)\\n    '\n    exclude_external = kwargs.get('exclude_exernal', common.models.InvenTreeSetting.get_setting('STOCKTAKE_EXCLUDE_EXTERNAL', False))\n    parts = part.models.Part.objects.all()\n    user = kwargs.get('user', None)\n    generate_report = kwargs.get('generate_report', True)\n    update_parts = kwargs.get('update_parts', True)\n    if (p := kwargs.get('part', None)):\n        variants = p.get_descendants(include_self=True)\n        parts = parts.filter(pk__in=[v.pk for v in variants])\n    if (category := kwargs.get('category', None)):\n        categories = category.get_descendants(include_self=True)\n        parts = parts.filter(category__in=categories)\n    if (location := kwargs.get('location', None)):\n        locations = list(location.get_descendants(include_self=True))\n        items = stock.models.StockItem.objects.filter(location__in=locations)\n        if exclude_external:\n            items = items.exclude(location__external=True)\n        unique_parts = items.order_by().values('part').distinct()\n        parts = parts.filter(pk__in=[result['part'] for result in unique_parts])\n    n_parts = parts.count()\n    if n_parts == 0:\n        logger.info('No parts selected for stocktake report - exiting')\n        return\n    logger.info('Generating new stocktake report for %s parts', n_parts)\n    base_currency = common.settings.currency_code_default()\n    dataset = tablib.Dataset(headers=[_('Part ID'), _('Part Name'), _('Part Description'), _('Category ID'), _('Category Name'), _('Stock Items'), _('Total Quantity'), _('Total Cost Min') + f' ({base_currency})', _('Total Cost Max') + f' ({base_currency})'])\n    parts = parts.prefetch_related('category', 'stock_items')\n    t_start = time.time()\n    stocktake_instances = []\n    total_parts = 0\n    for p in parts:\n        stocktake = perform_stocktake(p, user, commit=False, exclude_external=exclude_external, location=location)\n        total_parts += 1\n        stocktake_instances.append(stocktake)\n        dataset.append([p.pk, p.full_name, p.description, p.category.pk if p.category else '', p.category.name if p.category else '', stocktake.location_item_count, stocktake.location_quantity, InvenTree.helpers.normalize(stocktake.location_cost_min.amount), InvenTree.helpers.normalize(stocktake.location_cost_max.amount)])\n    buffer = io.StringIO()\n    buffer.write(dataset.export('csv'))\n    today = datetime.now().date().isoformat()\n    filename = f'InvenTree_Stocktake_{today}.csv'\n    report_file = ContentFile(buffer.getvalue(), name=filename)\n    if generate_report:\n        report_instance = part.models.PartStocktakeReport.objects.create(report=report_file, part_count=total_parts, user=user)\n        if user:\n            common.notifications.trigger_notification(report_instance, category='generate_stocktake_report', context={'name': _('Stocktake Report Available'), 'message': _('A new stocktake report is available for download')}, targets=[user])\n    if update_parts:\n        part.models.PartStocktake.objects.bulk_create(stocktake_instances, batch_size=500)\n    t_stocktake = time.time() - t_start\n    logger.info('Generated stocktake report for %s parts in %ss', total_parts, round(t_stocktake, 2))",
            "def generate_stocktake_report(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Generated a new stocktake report.\\n\\n    Note that this method should be called only by the background worker process!\\n\\n    Unless otherwise specified, the stocktake report is generated for *all* Part instances.\\n    Optional filters can by supplied via the kwargs\\n\\n    kwargs:\\n        user: The user who requested this stocktake (set to None for automated stocktake)\\n        part: Optional Part instance to filter by (including variant parts)\\n        category: Optional PartCategory to filter results\\n        location: Optional StockLocation to filter results\\n        exclude_external: If True, exclude stock items in external locations (default = False)\\n        generate_report: If True, generate a stocktake report from the calculated data (default=True)\\n        update_parts: If True, save stocktake information against each filtered Part (default = True)\\n    '\n    exclude_external = kwargs.get('exclude_exernal', common.models.InvenTreeSetting.get_setting('STOCKTAKE_EXCLUDE_EXTERNAL', False))\n    parts = part.models.Part.objects.all()\n    user = kwargs.get('user', None)\n    generate_report = kwargs.get('generate_report', True)\n    update_parts = kwargs.get('update_parts', True)\n    if (p := kwargs.get('part', None)):\n        variants = p.get_descendants(include_self=True)\n        parts = parts.filter(pk__in=[v.pk for v in variants])\n    if (category := kwargs.get('category', None)):\n        categories = category.get_descendants(include_self=True)\n        parts = parts.filter(category__in=categories)\n    if (location := kwargs.get('location', None)):\n        locations = list(location.get_descendants(include_self=True))\n        items = stock.models.StockItem.objects.filter(location__in=locations)\n        if exclude_external:\n            items = items.exclude(location__external=True)\n        unique_parts = items.order_by().values('part').distinct()\n        parts = parts.filter(pk__in=[result['part'] for result in unique_parts])\n    n_parts = parts.count()\n    if n_parts == 0:\n        logger.info('No parts selected for stocktake report - exiting')\n        return\n    logger.info('Generating new stocktake report for %s parts', n_parts)\n    base_currency = common.settings.currency_code_default()\n    dataset = tablib.Dataset(headers=[_('Part ID'), _('Part Name'), _('Part Description'), _('Category ID'), _('Category Name'), _('Stock Items'), _('Total Quantity'), _('Total Cost Min') + f' ({base_currency})', _('Total Cost Max') + f' ({base_currency})'])\n    parts = parts.prefetch_related('category', 'stock_items')\n    t_start = time.time()\n    stocktake_instances = []\n    total_parts = 0\n    for p in parts:\n        stocktake = perform_stocktake(p, user, commit=False, exclude_external=exclude_external, location=location)\n        total_parts += 1\n        stocktake_instances.append(stocktake)\n        dataset.append([p.pk, p.full_name, p.description, p.category.pk if p.category else '', p.category.name if p.category else '', stocktake.location_item_count, stocktake.location_quantity, InvenTree.helpers.normalize(stocktake.location_cost_min.amount), InvenTree.helpers.normalize(stocktake.location_cost_max.amount)])\n    buffer = io.StringIO()\n    buffer.write(dataset.export('csv'))\n    today = datetime.now().date().isoformat()\n    filename = f'InvenTree_Stocktake_{today}.csv'\n    report_file = ContentFile(buffer.getvalue(), name=filename)\n    if generate_report:\n        report_instance = part.models.PartStocktakeReport.objects.create(report=report_file, part_count=total_parts, user=user)\n        if user:\n            common.notifications.trigger_notification(report_instance, category='generate_stocktake_report', context={'name': _('Stocktake Report Available'), 'message': _('A new stocktake report is available for download')}, targets=[user])\n    if update_parts:\n        part.models.PartStocktake.objects.bulk_create(stocktake_instances, batch_size=500)\n    t_stocktake = time.time() - t_start\n    logger.info('Generated stocktake report for %s parts in %ss', total_parts, round(t_stocktake, 2))"
        ]
    }
]