[
    {
        "func_name": "extra_significant_check",
        "original": "@callback\ndef extra_significant_check(hass: HomeAssistant, old_state: str, old_attrs: dict, old_extra_arg: dict, new_state: str, new_attrs: dict, new_extra_arg: dict):\n    \"\"\"Check if the serialized data has changed.\"\"\"\n    return old_extra_arg != new_extra_arg",
        "mutated": [
            "@callback\ndef extra_significant_check(hass: HomeAssistant, old_state: str, old_attrs: dict, old_extra_arg: dict, new_state: str, new_attrs: dict, new_extra_arg: dict):\n    if False:\n        i = 10\n    'Check if the serialized data has changed.'\n    return old_extra_arg != new_extra_arg",
            "@callback\ndef extra_significant_check(hass: HomeAssistant, old_state: str, old_attrs: dict, old_extra_arg: dict, new_state: str, new_attrs: dict, new_extra_arg: dict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Check if the serialized data has changed.'\n    return old_extra_arg != new_extra_arg",
            "@callback\ndef extra_significant_check(hass: HomeAssistant, old_state: str, old_attrs: dict, old_extra_arg: dict, new_state: str, new_attrs: dict, new_extra_arg: dict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Check if the serialized data has changed.'\n    return old_extra_arg != new_extra_arg",
            "@callback\ndef extra_significant_check(hass: HomeAssistant, old_state: str, old_attrs: dict, old_extra_arg: dict, new_state: str, new_attrs: dict, new_extra_arg: dict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Check if the serialized data has changed.'\n    return old_extra_arg != new_extra_arg",
            "@callback\ndef extra_significant_check(hass: HomeAssistant, old_state: str, old_attrs: dict, old_extra_arg: dict, new_state: str, new_attrs: dict, new_extra_arg: dict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Check if the serialized data has changed.'\n    return old_extra_arg != new_extra_arg"
        ]
    },
    {
        "func_name": "unsub_all",
        "original": "@callback\ndef unsub_all():\n    unsub()\n    if unsub_pending:\n        unsub_pending()",
        "mutated": [
            "@callback\ndef unsub_all():\n    if False:\n        i = 10\n    unsub()\n    if unsub_pending:\n        unsub_pending()",
            "@callback\ndef unsub_all():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    unsub()\n    if unsub_pending:\n        unsub_pending()",
            "@callback\ndef unsub_all():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    unsub()\n    if unsub_pending:\n        unsub_pending()",
            "@callback\ndef unsub_all():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    unsub()\n    if unsub_pending:\n        unsub_pending()",
            "@callback\ndef unsub_all():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    unsub()\n    if unsub_pending:\n        unsub_pending()"
        ]
    },
    {
        "func_name": "async_enable_report_state",
        "original": "@callback\ndef async_enable_report_state(hass: HomeAssistant, google_config: AbstractConfig):\n    \"\"\"Enable state and notification reporting.\"\"\"\n    checker = None\n    unsub_pending: CALLBACK_TYPE | None = None\n    pending: deque[dict[str, Any]] = deque([{}])\n\n    async def report_states(now=None):\n        \"\"\"Report the states.\"\"\"\n        nonlocal pending\n        nonlocal unsub_pending\n        pending.append({})\n        while len(pending) > 1:\n            await google_config.async_report_state_all({'devices': {'states': pending.popleft()}})\n        if pending[0]:\n            unsub_pending = async_call_later(hass, REPORT_STATE_WINDOW, report_states_job)\n        else:\n            unsub_pending = None\n    report_states_job = HassJob(report_states)\n\n    async def async_entity_state_listener(changed_entity: str, old_state: State | None, new_state: State | None) -> None:\n        nonlocal unsub_pending, checker\n        if not hass.is_running:\n            return\n        if not new_state:\n            return\n        if not google_config.should_expose(new_state):\n            return\n        if not (entity := async_get_google_entity_if_supported_cached(hass, google_config, new_state)):\n            return\n        if old_state and old_state.state != new_state.state and ((notifications := entity.notifications_serialize()) is not None):\n            event_id = uuid4().hex\n            payload = {'devices': {'notifications': {entity.state.entity_id: notifications}}}\n            _LOGGER.info('Sending event notification for entity %s', entity.state.entity_id)\n            result = await google_config.async_sync_notification_all(event_id, payload)\n            if result != 200:\n                _LOGGER.error('Unable to send notification with result code: %s, check log for more info', result)\n        try:\n            entity_data = entity.query_serialize()\n        except SmartHomeError as err:\n            _LOGGER.debug('Not reporting state for %s: %s', changed_entity, err.code)\n            return\n        assert checker is not None\n        if not checker.async_is_significant_change(new_state, extra_arg=entity_data):\n            return\n        _LOGGER.debug('Scheduling report state for %s: %s', changed_entity, entity_data)\n        if changed_entity in pending[-1]:\n            pending.append({})\n        pending[-1][changed_entity] = entity_data\n        if unsub_pending is None:\n            unsub_pending = async_call_later(hass, REPORT_STATE_WINDOW, report_states_job)\n\n    @callback\n    def extra_significant_check(hass: HomeAssistant, old_state: str, old_attrs: dict, old_extra_arg: dict, new_state: str, new_attrs: dict, new_extra_arg: dict):\n        \"\"\"Check if the serialized data has changed.\"\"\"\n        return old_extra_arg != new_extra_arg\n\n    async def initial_report(_now):\n        \"\"\"Report initially all states.\"\"\"\n        nonlocal unsub, checker\n        entities = {}\n        checker = await create_checker(hass, DOMAIN, extra_significant_check)\n        for entity in async_get_entities(hass, google_config):\n            if not entity.should_expose():\n                continue\n            try:\n                entity_data = entity.query_serialize()\n            except SmartHomeError:\n                continue\n            if not checker.async_is_significant_change(entity.state, extra_arg=entity_data):\n                continue\n            entities[entity.entity_id] = entity_data\n        if not entities:\n            return\n        await google_config.async_report_state_all({'devices': {'states': entities}})\n        unsub = async_track_state_change(hass, MATCH_ALL, async_entity_state_listener)\n    unsub = async_call_later(hass, INITIAL_REPORT_DELAY, HassJob(initial_report, cancel_on_shutdown=True))\n\n    @callback\n    def unsub_all():\n        unsub()\n        if unsub_pending:\n            unsub_pending()\n    return unsub_all",
        "mutated": [
            "@callback\ndef async_enable_report_state(hass: HomeAssistant, google_config: AbstractConfig):\n    if False:\n        i = 10\n    'Enable state and notification reporting.'\n    checker = None\n    unsub_pending: CALLBACK_TYPE | None = None\n    pending: deque[dict[str, Any]] = deque([{}])\n\n    async def report_states(now=None):\n        \"\"\"Report the states.\"\"\"\n        nonlocal pending\n        nonlocal unsub_pending\n        pending.append({})\n        while len(pending) > 1:\n            await google_config.async_report_state_all({'devices': {'states': pending.popleft()}})\n        if pending[0]:\n            unsub_pending = async_call_later(hass, REPORT_STATE_WINDOW, report_states_job)\n        else:\n            unsub_pending = None\n    report_states_job = HassJob(report_states)\n\n    async def async_entity_state_listener(changed_entity: str, old_state: State | None, new_state: State | None) -> None:\n        nonlocal unsub_pending, checker\n        if not hass.is_running:\n            return\n        if not new_state:\n            return\n        if not google_config.should_expose(new_state):\n            return\n        if not (entity := async_get_google_entity_if_supported_cached(hass, google_config, new_state)):\n            return\n        if old_state and old_state.state != new_state.state and ((notifications := entity.notifications_serialize()) is not None):\n            event_id = uuid4().hex\n            payload = {'devices': {'notifications': {entity.state.entity_id: notifications}}}\n            _LOGGER.info('Sending event notification for entity %s', entity.state.entity_id)\n            result = await google_config.async_sync_notification_all(event_id, payload)\n            if result != 200:\n                _LOGGER.error('Unable to send notification with result code: %s, check log for more info', result)\n        try:\n            entity_data = entity.query_serialize()\n        except SmartHomeError as err:\n            _LOGGER.debug('Not reporting state for %s: %s', changed_entity, err.code)\n            return\n        assert checker is not None\n        if not checker.async_is_significant_change(new_state, extra_arg=entity_data):\n            return\n        _LOGGER.debug('Scheduling report state for %s: %s', changed_entity, entity_data)\n        if changed_entity in pending[-1]:\n            pending.append({})\n        pending[-1][changed_entity] = entity_data\n        if unsub_pending is None:\n            unsub_pending = async_call_later(hass, REPORT_STATE_WINDOW, report_states_job)\n\n    @callback\n    def extra_significant_check(hass: HomeAssistant, old_state: str, old_attrs: dict, old_extra_arg: dict, new_state: str, new_attrs: dict, new_extra_arg: dict):\n        \"\"\"Check if the serialized data has changed.\"\"\"\n        return old_extra_arg != new_extra_arg\n\n    async def initial_report(_now):\n        \"\"\"Report initially all states.\"\"\"\n        nonlocal unsub, checker\n        entities = {}\n        checker = await create_checker(hass, DOMAIN, extra_significant_check)\n        for entity in async_get_entities(hass, google_config):\n            if not entity.should_expose():\n                continue\n            try:\n                entity_data = entity.query_serialize()\n            except SmartHomeError:\n                continue\n            if not checker.async_is_significant_change(entity.state, extra_arg=entity_data):\n                continue\n            entities[entity.entity_id] = entity_data\n        if not entities:\n            return\n        await google_config.async_report_state_all({'devices': {'states': entities}})\n        unsub = async_track_state_change(hass, MATCH_ALL, async_entity_state_listener)\n    unsub = async_call_later(hass, INITIAL_REPORT_DELAY, HassJob(initial_report, cancel_on_shutdown=True))\n\n    @callback\n    def unsub_all():\n        unsub()\n        if unsub_pending:\n            unsub_pending()\n    return unsub_all",
            "@callback\ndef async_enable_report_state(hass: HomeAssistant, google_config: AbstractConfig):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Enable state and notification reporting.'\n    checker = None\n    unsub_pending: CALLBACK_TYPE | None = None\n    pending: deque[dict[str, Any]] = deque([{}])\n\n    async def report_states(now=None):\n        \"\"\"Report the states.\"\"\"\n        nonlocal pending\n        nonlocal unsub_pending\n        pending.append({})\n        while len(pending) > 1:\n            await google_config.async_report_state_all({'devices': {'states': pending.popleft()}})\n        if pending[0]:\n            unsub_pending = async_call_later(hass, REPORT_STATE_WINDOW, report_states_job)\n        else:\n            unsub_pending = None\n    report_states_job = HassJob(report_states)\n\n    async def async_entity_state_listener(changed_entity: str, old_state: State | None, new_state: State | None) -> None:\n        nonlocal unsub_pending, checker\n        if not hass.is_running:\n            return\n        if not new_state:\n            return\n        if not google_config.should_expose(new_state):\n            return\n        if not (entity := async_get_google_entity_if_supported_cached(hass, google_config, new_state)):\n            return\n        if old_state and old_state.state != new_state.state and ((notifications := entity.notifications_serialize()) is not None):\n            event_id = uuid4().hex\n            payload = {'devices': {'notifications': {entity.state.entity_id: notifications}}}\n            _LOGGER.info('Sending event notification for entity %s', entity.state.entity_id)\n            result = await google_config.async_sync_notification_all(event_id, payload)\n            if result != 200:\n                _LOGGER.error('Unable to send notification with result code: %s, check log for more info', result)\n        try:\n            entity_data = entity.query_serialize()\n        except SmartHomeError as err:\n            _LOGGER.debug('Not reporting state for %s: %s', changed_entity, err.code)\n            return\n        assert checker is not None\n        if not checker.async_is_significant_change(new_state, extra_arg=entity_data):\n            return\n        _LOGGER.debug('Scheduling report state for %s: %s', changed_entity, entity_data)\n        if changed_entity in pending[-1]:\n            pending.append({})\n        pending[-1][changed_entity] = entity_data\n        if unsub_pending is None:\n            unsub_pending = async_call_later(hass, REPORT_STATE_WINDOW, report_states_job)\n\n    @callback\n    def extra_significant_check(hass: HomeAssistant, old_state: str, old_attrs: dict, old_extra_arg: dict, new_state: str, new_attrs: dict, new_extra_arg: dict):\n        \"\"\"Check if the serialized data has changed.\"\"\"\n        return old_extra_arg != new_extra_arg\n\n    async def initial_report(_now):\n        \"\"\"Report initially all states.\"\"\"\n        nonlocal unsub, checker\n        entities = {}\n        checker = await create_checker(hass, DOMAIN, extra_significant_check)\n        for entity in async_get_entities(hass, google_config):\n            if not entity.should_expose():\n                continue\n            try:\n                entity_data = entity.query_serialize()\n            except SmartHomeError:\n                continue\n            if not checker.async_is_significant_change(entity.state, extra_arg=entity_data):\n                continue\n            entities[entity.entity_id] = entity_data\n        if not entities:\n            return\n        await google_config.async_report_state_all({'devices': {'states': entities}})\n        unsub = async_track_state_change(hass, MATCH_ALL, async_entity_state_listener)\n    unsub = async_call_later(hass, INITIAL_REPORT_DELAY, HassJob(initial_report, cancel_on_shutdown=True))\n\n    @callback\n    def unsub_all():\n        unsub()\n        if unsub_pending:\n            unsub_pending()\n    return unsub_all",
            "@callback\ndef async_enable_report_state(hass: HomeAssistant, google_config: AbstractConfig):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Enable state and notification reporting.'\n    checker = None\n    unsub_pending: CALLBACK_TYPE | None = None\n    pending: deque[dict[str, Any]] = deque([{}])\n\n    async def report_states(now=None):\n        \"\"\"Report the states.\"\"\"\n        nonlocal pending\n        nonlocal unsub_pending\n        pending.append({})\n        while len(pending) > 1:\n            await google_config.async_report_state_all({'devices': {'states': pending.popleft()}})\n        if pending[0]:\n            unsub_pending = async_call_later(hass, REPORT_STATE_WINDOW, report_states_job)\n        else:\n            unsub_pending = None\n    report_states_job = HassJob(report_states)\n\n    async def async_entity_state_listener(changed_entity: str, old_state: State | None, new_state: State | None) -> None:\n        nonlocal unsub_pending, checker\n        if not hass.is_running:\n            return\n        if not new_state:\n            return\n        if not google_config.should_expose(new_state):\n            return\n        if not (entity := async_get_google_entity_if_supported_cached(hass, google_config, new_state)):\n            return\n        if old_state and old_state.state != new_state.state and ((notifications := entity.notifications_serialize()) is not None):\n            event_id = uuid4().hex\n            payload = {'devices': {'notifications': {entity.state.entity_id: notifications}}}\n            _LOGGER.info('Sending event notification for entity %s', entity.state.entity_id)\n            result = await google_config.async_sync_notification_all(event_id, payload)\n            if result != 200:\n                _LOGGER.error('Unable to send notification with result code: %s, check log for more info', result)\n        try:\n            entity_data = entity.query_serialize()\n        except SmartHomeError as err:\n            _LOGGER.debug('Not reporting state for %s: %s', changed_entity, err.code)\n            return\n        assert checker is not None\n        if not checker.async_is_significant_change(new_state, extra_arg=entity_data):\n            return\n        _LOGGER.debug('Scheduling report state for %s: %s', changed_entity, entity_data)\n        if changed_entity in pending[-1]:\n            pending.append({})\n        pending[-1][changed_entity] = entity_data\n        if unsub_pending is None:\n            unsub_pending = async_call_later(hass, REPORT_STATE_WINDOW, report_states_job)\n\n    @callback\n    def extra_significant_check(hass: HomeAssistant, old_state: str, old_attrs: dict, old_extra_arg: dict, new_state: str, new_attrs: dict, new_extra_arg: dict):\n        \"\"\"Check if the serialized data has changed.\"\"\"\n        return old_extra_arg != new_extra_arg\n\n    async def initial_report(_now):\n        \"\"\"Report initially all states.\"\"\"\n        nonlocal unsub, checker\n        entities = {}\n        checker = await create_checker(hass, DOMAIN, extra_significant_check)\n        for entity in async_get_entities(hass, google_config):\n            if not entity.should_expose():\n                continue\n            try:\n                entity_data = entity.query_serialize()\n            except SmartHomeError:\n                continue\n            if not checker.async_is_significant_change(entity.state, extra_arg=entity_data):\n                continue\n            entities[entity.entity_id] = entity_data\n        if not entities:\n            return\n        await google_config.async_report_state_all({'devices': {'states': entities}})\n        unsub = async_track_state_change(hass, MATCH_ALL, async_entity_state_listener)\n    unsub = async_call_later(hass, INITIAL_REPORT_DELAY, HassJob(initial_report, cancel_on_shutdown=True))\n\n    @callback\n    def unsub_all():\n        unsub()\n        if unsub_pending:\n            unsub_pending()\n    return unsub_all",
            "@callback\ndef async_enable_report_state(hass: HomeAssistant, google_config: AbstractConfig):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Enable state and notification reporting.'\n    checker = None\n    unsub_pending: CALLBACK_TYPE | None = None\n    pending: deque[dict[str, Any]] = deque([{}])\n\n    async def report_states(now=None):\n        \"\"\"Report the states.\"\"\"\n        nonlocal pending\n        nonlocal unsub_pending\n        pending.append({})\n        while len(pending) > 1:\n            await google_config.async_report_state_all({'devices': {'states': pending.popleft()}})\n        if pending[0]:\n            unsub_pending = async_call_later(hass, REPORT_STATE_WINDOW, report_states_job)\n        else:\n            unsub_pending = None\n    report_states_job = HassJob(report_states)\n\n    async def async_entity_state_listener(changed_entity: str, old_state: State | None, new_state: State | None) -> None:\n        nonlocal unsub_pending, checker\n        if not hass.is_running:\n            return\n        if not new_state:\n            return\n        if not google_config.should_expose(new_state):\n            return\n        if not (entity := async_get_google_entity_if_supported_cached(hass, google_config, new_state)):\n            return\n        if old_state and old_state.state != new_state.state and ((notifications := entity.notifications_serialize()) is not None):\n            event_id = uuid4().hex\n            payload = {'devices': {'notifications': {entity.state.entity_id: notifications}}}\n            _LOGGER.info('Sending event notification for entity %s', entity.state.entity_id)\n            result = await google_config.async_sync_notification_all(event_id, payload)\n            if result != 200:\n                _LOGGER.error('Unable to send notification with result code: %s, check log for more info', result)\n        try:\n            entity_data = entity.query_serialize()\n        except SmartHomeError as err:\n            _LOGGER.debug('Not reporting state for %s: %s', changed_entity, err.code)\n            return\n        assert checker is not None\n        if not checker.async_is_significant_change(new_state, extra_arg=entity_data):\n            return\n        _LOGGER.debug('Scheduling report state for %s: %s', changed_entity, entity_data)\n        if changed_entity in pending[-1]:\n            pending.append({})\n        pending[-1][changed_entity] = entity_data\n        if unsub_pending is None:\n            unsub_pending = async_call_later(hass, REPORT_STATE_WINDOW, report_states_job)\n\n    @callback\n    def extra_significant_check(hass: HomeAssistant, old_state: str, old_attrs: dict, old_extra_arg: dict, new_state: str, new_attrs: dict, new_extra_arg: dict):\n        \"\"\"Check if the serialized data has changed.\"\"\"\n        return old_extra_arg != new_extra_arg\n\n    async def initial_report(_now):\n        \"\"\"Report initially all states.\"\"\"\n        nonlocal unsub, checker\n        entities = {}\n        checker = await create_checker(hass, DOMAIN, extra_significant_check)\n        for entity in async_get_entities(hass, google_config):\n            if not entity.should_expose():\n                continue\n            try:\n                entity_data = entity.query_serialize()\n            except SmartHomeError:\n                continue\n            if not checker.async_is_significant_change(entity.state, extra_arg=entity_data):\n                continue\n            entities[entity.entity_id] = entity_data\n        if not entities:\n            return\n        await google_config.async_report_state_all({'devices': {'states': entities}})\n        unsub = async_track_state_change(hass, MATCH_ALL, async_entity_state_listener)\n    unsub = async_call_later(hass, INITIAL_REPORT_DELAY, HassJob(initial_report, cancel_on_shutdown=True))\n\n    @callback\n    def unsub_all():\n        unsub()\n        if unsub_pending:\n            unsub_pending()\n    return unsub_all",
            "@callback\ndef async_enable_report_state(hass: HomeAssistant, google_config: AbstractConfig):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Enable state and notification reporting.'\n    checker = None\n    unsub_pending: CALLBACK_TYPE | None = None\n    pending: deque[dict[str, Any]] = deque([{}])\n\n    async def report_states(now=None):\n        \"\"\"Report the states.\"\"\"\n        nonlocal pending\n        nonlocal unsub_pending\n        pending.append({})\n        while len(pending) > 1:\n            await google_config.async_report_state_all({'devices': {'states': pending.popleft()}})\n        if pending[0]:\n            unsub_pending = async_call_later(hass, REPORT_STATE_WINDOW, report_states_job)\n        else:\n            unsub_pending = None\n    report_states_job = HassJob(report_states)\n\n    async def async_entity_state_listener(changed_entity: str, old_state: State | None, new_state: State | None) -> None:\n        nonlocal unsub_pending, checker\n        if not hass.is_running:\n            return\n        if not new_state:\n            return\n        if not google_config.should_expose(new_state):\n            return\n        if not (entity := async_get_google_entity_if_supported_cached(hass, google_config, new_state)):\n            return\n        if old_state and old_state.state != new_state.state and ((notifications := entity.notifications_serialize()) is not None):\n            event_id = uuid4().hex\n            payload = {'devices': {'notifications': {entity.state.entity_id: notifications}}}\n            _LOGGER.info('Sending event notification for entity %s', entity.state.entity_id)\n            result = await google_config.async_sync_notification_all(event_id, payload)\n            if result != 200:\n                _LOGGER.error('Unable to send notification with result code: %s, check log for more info', result)\n        try:\n            entity_data = entity.query_serialize()\n        except SmartHomeError as err:\n            _LOGGER.debug('Not reporting state for %s: %s', changed_entity, err.code)\n            return\n        assert checker is not None\n        if not checker.async_is_significant_change(new_state, extra_arg=entity_data):\n            return\n        _LOGGER.debug('Scheduling report state for %s: %s', changed_entity, entity_data)\n        if changed_entity in pending[-1]:\n            pending.append({})\n        pending[-1][changed_entity] = entity_data\n        if unsub_pending is None:\n            unsub_pending = async_call_later(hass, REPORT_STATE_WINDOW, report_states_job)\n\n    @callback\n    def extra_significant_check(hass: HomeAssistant, old_state: str, old_attrs: dict, old_extra_arg: dict, new_state: str, new_attrs: dict, new_extra_arg: dict):\n        \"\"\"Check if the serialized data has changed.\"\"\"\n        return old_extra_arg != new_extra_arg\n\n    async def initial_report(_now):\n        \"\"\"Report initially all states.\"\"\"\n        nonlocal unsub, checker\n        entities = {}\n        checker = await create_checker(hass, DOMAIN, extra_significant_check)\n        for entity in async_get_entities(hass, google_config):\n            if not entity.should_expose():\n                continue\n            try:\n                entity_data = entity.query_serialize()\n            except SmartHomeError:\n                continue\n            if not checker.async_is_significant_change(entity.state, extra_arg=entity_data):\n                continue\n            entities[entity.entity_id] = entity_data\n        if not entities:\n            return\n        await google_config.async_report_state_all({'devices': {'states': entities}})\n        unsub = async_track_state_change(hass, MATCH_ALL, async_entity_state_listener)\n    unsub = async_call_later(hass, INITIAL_REPORT_DELAY, HassJob(initial_report, cancel_on_shutdown=True))\n\n    @callback\n    def unsub_all():\n        unsub()\n        if unsub_pending:\n            unsub_pending()\n    return unsub_all"
        ]
    }
]