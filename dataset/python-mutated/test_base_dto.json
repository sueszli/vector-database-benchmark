[
    {
        "func_name": "get_backend",
        "original": "def get_backend(dto_type: type[DataclassDTO[Any]]) -> DTOBackend:\n    value = next(iter(dto_type._dto_backends.values()))\n    return value['data_backend']",
        "mutated": [
            "def get_backend(dto_type: type[DataclassDTO[Any]]) -> DTOBackend:\n    if False:\n        i = 10\n    value = next(iter(dto_type._dto_backends.values()))\n    return value['data_backend']",
            "def get_backend(dto_type: type[DataclassDTO[Any]]) -> DTOBackend:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    value = next(iter(dto_type._dto_backends.values()))\n    return value['data_backend']",
            "def get_backend(dto_type: type[DataclassDTO[Any]]) -> DTOBackend:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    value = next(iter(dto_type._dto_backends.values()))\n    return value['data_backend']",
            "def get_backend(dto_type: type[DataclassDTO[Any]]) -> DTOBackend:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    value = next(iter(dto_type._dto_backends.values()))\n    return value['data_backend']",
            "def get_backend(dto_type: type[DataclassDTO[Any]]) -> DTOBackend:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    value = next(iter(dto_type._dto_backends.values()))\n    return value['data_backend']"
        ]
    },
    {
        "func_name": "test_forward_referenced_type_argument_raises_exception",
        "original": "def test_forward_referenced_type_argument_raises_exception() -> None:\n    with pytest.raises(InvalidAnnotationException):\n        DataclassDTO['Model']",
        "mutated": [
            "def test_forward_referenced_type_argument_raises_exception() -> None:\n    if False:\n        i = 10\n    with pytest.raises(InvalidAnnotationException):\n        DataclassDTO['Model']",
            "def test_forward_referenced_type_argument_raises_exception() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    with pytest.raises(InvalidAnnotationException):\n        DataclassDTO['Model']",
            "def test_forward_referenced_type_argument_raises_exception() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    with pytest.raises(InvalidAnnotationException):\n        DataclassDTO['Model']",
            "def test_forward_referenced_type_argument_raises_exception() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    with pytest.raises(InvalidAnnotationException):\n        DataclassDTO['Model']",
            "def test_forward_referenced_type_argument_raises_exception() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    with pytest.raises(InvalidAnnotationException):\n        DataclassDTO['Model']"
        ]
    },
    {
        "func_name": "test_union_type_argument_raises_exception",
        "original": "def test_union_type_argument_raises_exception() -> None:\n\n    class ModelB(Model):\n        ...\n    with pytest.raises(InvalidAnnotationException):\n        DataclassDTO[Union[Model, ModelB]]",
        "mutated": [
            "def test_union_type_argument_raises_exception() -> None:\n    if False:\n        i = 10\n\n    class ModelB(Model):\n        ...\n    with pytest.raises(InvalidAnnotationException):\n        DataclassDTO[Union[Model, ModelB]]",
            "def test_union_type_argument_raises_exception() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    class ModelB(Model):\n        ...\n    with pytest.raises(InvalidAnnotationException):\n        DataclassDTO[Union[Model, ModelB]]",
            "def test_union_type_argument_raises_exception() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    class ModelB(Model):\n        ...\n    with pytest.raises(InvalidAnnotationException):\n        DataclassDTO[Union[Model, ModelB]]",
            "def test_union_type_argument_raises_exception() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    class ModelB(Model):\n        ...\n    with pytest.raises(InvalidAnnotationException):\n        DataclassDTO[Union[Model, ModelB]]",
            "def test_union_type_argument_raises_exception() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    class ModelB(Model):\n        ...\n    with pytest.raises(InvalidAnnotationException):\n        DataclassDTO[Union[Model, ModelB]]"
        ]
    },
    {
        "func_name": "test_type_narrowing_with_scalar_type_arg",
        "original": "def test_type_narrowing_with_scalar_type_arg() -> None:\n    dto = DataclassDTO[Model]\n    assert dto.config == DTOConfig()\n    assert dto.model_type is Model",
        "mutated": [
            "def test_type_narrowing_with_scalar_type_arg() -> None:\n    if False:\n        i = 10\n    dto = DataclassDTO[Model]\n    assert dto.config == DTOConfig()\n    assert dto.model_type is Model",
            "def test_type_narrowing_with_scalar_type_arg() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    dto = DataclassDTO[Model]\n    assert dto.config == DTOConfig()\n    assert dto.model_type is Model",
            "def test_type_narrowing_with_scalar_type_arg() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    dto = DataclassDTO[Model]\n    assert dto.config == DTOConfig()\n    assert dto.model_type is Model",
            "def test_type_narrowing_with_scalar_type_arg() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    dto = DataclassDTO[Model]\n    assert dto.config == DTOConfig()\n    assert dto.model_type is Model",
            "def test_type_narrowing_with_scalar_type_arg() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    dto = DataclassDTO[Model]\n    assert dto.config == DTOConfig()\n    assert dto.model_type is Model"
        ]
    },
    {
        "func_name": "test_type_narrowing_with_annotated_scalar_type_arg",
        "original": "def test_type_narrowing_with_annotated_scalar_type_arg() -> None:\n    config = DTOConfig()\n    dto = DataclassDTO[Annotated[Model, config]]\n    assert dto.config is config\n    assert dto.model_type is Model",
        "mutated": [
            "def test_type_narrowing_with_annotated_scalar_type_arg() -> None:\n    if False:\n        i = 10\n    config = DTOConfig()\n    dto = DataclassDTO[Annotated[Model, config]]\n    assert dto.config is config\n    assert dto.model_type is Model",
            "def test_type_narrowing_with_annotated_scalar_type_arg() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    config = DTOConfig()\n    dto = DataclassDTO[Annotated[Model, config]]\n    assert dto.config is config\n    assert dto.model_type is Model",
            "def test_type_narrowing_with_annotated_scalar_type_arg() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    config = DTOConfig()\n    dto = DataclassDTO[Annotated[Model, config]]\n    assert dto.config is config\n    assert dto.model_type is Model",
            "def test_type_narrowing_with_annotated_scalar_type_arg() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    config = DTOConfig()\n    dto = DataclassDTO[Annotated[Model, config]]\n    assert dto.config is config\n    assert dto.model_type is Model",
            "def test_type_narrowing_with_annotated_scalar_type_arg() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    config = DTOConfig()\n    dto = DataclassDTO[Annotated[Model, config]]\n    assert dto.config is config\n    assert dto.model_type is Model"
        ]
    },
    {
        "func_name": "test_type_narrowing_with_only_type_var",
        "original": "def test_type_narrowing_with_only_type_var() -> None:\n    t = TypeVar('t', bound=Model)\n    generic_dto = DataclassDTO[t]\n    assert generic_dto is DataclassDTO",
        "mutated": [
            "def test_type_narrowing_with_only_type_var() -> None:\n    if False:\n        i = 10\n    t = TypeVar('t', bound=Model)\n    generic_dto = DataclassDTO[t]\n    assert generic_dto is DataclassDTO",
            "def test_type_narrowing_with_only_type_var() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    t = TypeVar('t', bound=Model)\n    generic_dto = DataclassDTO[t]\n    assert generic_dto is DataclassDTO",
            "def test_type_narrowing_with_only_type_var() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    t = TypeVar('t', bound=Model)\n    generic_dto = DataclassDTO[t]\n    assert generic_dto is DataclassDTO",
            "def test_type_narrowing_with_only_type_var() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    t = TypeVar('t', bound=Model)\n    generic_dto = DataclassDTO[t]\n    assert generic_dto is DataclassDTO",
            "def test_type_narrowing_with_only_type_var() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    t = TypeVar('t', bound=Model)\n    generic_dto = DataclassDTO[t]\n    assert generic_dto is DataclassDTO"
        ]
    },
    {
        "func_name": "test_type_narrowing_with_annotated_type_var",
        "original": "def test_type_narrowing_with_annotated_type_var() -> None:\n    config = DTOConfig()\n    t = TypeVar('t', bound=Model)\n    generic_dto = DataclassDTO[Annotated[t, config]]\n    assert generic_dto is not DataclassDTO\n    assert issubclass(generic_dto, DataclassDTO)\n    assert generic_dto.config is config\n    assert not hasattr(generic_dto, 'model_type')",
        "mutated": [
            "def test_type_narrowing_with_annotated_type_var() -> None:\n    if False:\n        i = 10\n    config = DTOConfig()\n    t = TypeVar('t', bound=Model)\n    generic_dto = DataclassDTO[Annotated[t, config]]\n    assert generic_dto is not DataclassDTO\n    assert issubclass(generic_dto, DataclassDTO)\n    assert generic_dto.config is config\n    assert not hasattr(generic_dto, 'model_type')",
            "def test_type_narrowing_with_annotated_type_var() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    config = DTOConfig()\n    t = TypeVar('t', bound=Model)\n    generic_dto = DataclassDTO[Annotated[t, config]]\n    assert generic_dto is not DataclassDTO\n    assert issubclass(generic_dto, DataclassDTO)\n    assert generic_dto.config is config\n    assert not hasattr(generic_dto, 'model_type')",
            "def test_type_narrowing_with_annotated_type_var() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    config = DTOConfig()\n    t = TypeVar('t', bound=Model)\n    generic_dto = DataclassDTO[Annotated[t, config]]\n    assert generic_dto is not DataclassDTO\n    assert issubclass(generic_dto, DataclassDTO)\n    assert generic_dto.config is config\n    assert not hasattr(generic_dto, 'model_type')",
            "def test_type_narrowing_with_annotated_type_var() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    config = DTOConfig()\n    t = TypeVar('t', bound=Model)\n    generic_dto = DataclassDTO[Annotated[t, config]]\n    assert generic_dto is not DataclassDTO\n    assert issubclass(generic_dto, DataclassDTO)\n    assert generic_dto.config is config\n    assert not hasattr(generic_dto, 'model_type')",
            "def test_type_narrowing_with_annotated_type_var() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    config = DTOConfig()\n    t = TypeVar('t', bound=Model)\n    generic_dto = DataclassDTO[Annotated[t, config]]\n    assert generic_dto is not DataclassDTO\n    assert issubclass(generic_dto, DataclassDTO)\n    assert generic_dto.config is config\n    assert not hasattr(generic_dto, 'model_type')"
        ]
    },
    {
        "func_name": "test_extra_annotated_metadata_ignored",
        "original": "def test_extra_annotated_metadata_ignored() -> None:\n    config = DTOConfig()\n    dto = DataclassDTO[Annotated[Model, config, 'a']]\n    assert dto.config is config",
        "mutated": [
            "def test_extra_annotated_metadata_ignored() -> None:\n    if False:\n        i = 10\n    config = DTOConfig()\n    dto = DataclassDTO[Annotated[Model, config, 'a']]\n    assert dto.config is config",
            "def test_extra_annotated_metadata_ignored() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    config = DTOConfig()\n    dto = DataclassDTO[Annotated[Model, config, 'a']]\n    assert dto.config is config",
            "def test_extra_annotated_metadata_ignored() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    config = DTOConfig()\n    dto = DataclassDTO[Annotated[Model, config, 'a']]\n    assert dto.config is config",
            "def test_extra_annotated_metadata_ignored() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    config = DTOConfig()\n    dto = DataclassDTO[Annotated[Model, config, 'a']]\n    assert dto.config is config",
            "def test_extra_annotated_metadata_ignored() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    config = DTOConfig()\n    dto = DataclassDTO[Annotated[Model, config, 'a']]\n    assert dto.config is config"
        ]
    },
    {
        "func_name": "test_overwrite_config",
        "original": "def test_overwrite_config() -> None:\n    first = DTOConfig(exclude={'a'})\n    generic_dto = DataclassDTO[Annotated[T, first]]\n    second = DTOConfig(exclude={'b'})\n    dto = generic_dto[Annotated[Model, second]]\n    assert dto.config is second",
        "mutated": [
            "def test_overwrite_config() -> None:\n    if False:\n        i = 10\n    first = DTOConfig(exclude={'a'})\n    generic_dto = DataclassDTO[Annotated[T, first]]\n    second = DTOConfig(exclude={'b'})\n    dto = generic_dto[Annotated[Model, second]]\n    assert dto.config is second",
            "def test_overwrite_config() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    first = DTOConfig(exclude={'a'})\n    generic_dto = DataclassDTO[Annotated[T, first]]\n    second = DTOConfig(exclude={'b'})\n    dto = generic_dto[Annotated[Model, second]]\n    assert dto.config is second",
            "def test_overwrite_config() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    first = DTOConfig(exclude={'a'})\n    generic_dto = DataclassDTO[Annotated[T, first]]\n    second = DTOConfig(exclude={'b'})\n    dto = generic_dto[Annotated[Model, second]]\n    assert dto.config is second",
            "def test_overwrite_config() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    first = DTOConfig(exclude={'a'})\n    generic_dto = DataclassDTO[Annotated[T, first]]\n    second = DTOConfig(exclude={'b'})\n    dto = generic_dto[Annotated[Model, second]]\n    assert dto.config is second",
            "def test_overwrite_config() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    first = DTOConfig(exclude={'a'})\n    generic_dto = DataclassDTO[Annotated[T, first]]\n    second = DTOConfig(exclude={'b'})\n    dto = generic_dto[Annotated[Model, second]]\n    assert dto.config is second"
        ]
    },
    {
        "func_name": "test_existing_config_not_overwritten",
        "original": "def test_existing_config_not_overwritten() -> None:\n    assert getattr(DataclassDTO, '_config', None) is None\n    first = DTOConfig(exclude={'a'})\n    generic_dto = DataclassDTO[Annotated[T, first]]\n    dto = generic_dto[Model]\n    assert dto.config is first",
        "mutated": [
            "def test_existing_config_not_overwritten() -> None:\n    if False:\n        i = 10\n    assert getattr(DataclassDTO, '_config', None) is None\n    first = DTOConfig(exclude={'a'})\n    generic_dto = DataclassDTO[Annotated[T, first]]\n    dto = generic_dto[Model]\n    assert dto.config is first",
            "def test_existing_config_not_overwritten() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    assert getattr(DataclassDTO, '_config', None) is None\n    first = DTOConfig(exclude={'a'})\n    generic_dto = DataclassDTO[Annotated[T, first]]\n    dto = generic_dto[Model]\n    assert dto.config is first",
            "def test_existing_config_not_overwritten() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    assert getattr(DataclassDTO, '_config', None) is None\n    first = DTOConfig(exclude={'a'})\n    generic_dto = DataclassDTO[Annotated[T, first]]\n    dto = generic_dto[Model]\n    assert dto.config is first",
            "def test_existing_config_not_overwritten() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    assert getattr(DataclassDTO, '_config', None) is None\n    first = DTOConfig(exclude={'a'})\n    generic_dto = DataclassDTO[Annotated[T, first]]\n    dto = generic_dto[Model]\n    assert dto.config is first",
            "def test_existing_config_not_overwritten() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    assert getattr(DataclassDTO, '_config', None) is None\n    first = DTOConfig(exclude={'a'})\n    generic_dto = DataclassDTO[Annotated[T, first]]\n    dto = generic_dto[Model]\n    assert dto.config is first"
        ]
    },
    {
        "func_name": "test_config_assigned_via_subclassing",
        "original": "def test_config_assigned_via_subclassing() -> None:\n\n    class CustomGenericDTO(DataclassDTO[T]):\n        config = DTOConfig(exclude={'a'})\n    concrete_dto = CustomGenericDTO[Model]\n    assert concrete_dto.config.exclude == {'a'}",
        "mutated": [
            "def test_config_assigned_via_subclassing() -> None:\n    if False:\n        i = 10\n\n    class CustomGenericDTO(DataclassDTO[T]):\n        config = DTOConfig(exclude={'a'})\n    concrete_dto = CustomGenericDTO[Model]\n    assert concrete_dto.config.exclude == {'a'}",
            "def test_config_assigned_via_subclassing() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    class CustomGenericDTO(DataclassDTO[T]):\n        config = DTOConfig(exclude={'a'})\n    concrete_dto = CustomGenericDTO[Model]\n    assert concrete_dto.config.exclude == {'a'}",
            "def test_config_assigned_via_subclassing() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    class CustomGenericDTO(DataclassDTO[T]):\n        config = DTOConfig(exclude={'a'})\n    concrete_dto = CustomGenericDTO[Model]\n    assert concrete_dto.config.exclude == {'a'}",
            "def test_config_assigned_via_subclassing() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    class CustomGenericDTO(DataclassDTO[T]):\n        config = DTOConfig(exclude={'a'})\n    concrete_dto = CustomGenericDTO[Model]\n    assert concrete_dto.config.exclude == {'a'}",
            "def test_config_assigned_via_subclassing() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    class CustomGenericDTO(DataclassDTO[T]):\n        config = DTOConfig(exclude={'a'})\n    concrete_dto = CustomGenericDTO[Model]\n    assert concrete_dto.config.exclude == {'a'}"
        ]
    },
    {
        "func_name": "test_config_field_rename",
        "original": "def test_config_field_rename(asgi_connection: Request[Any, Any, Any]) -> None:\n    config = DTOConfig(rename_fields={'a': 'z'})\n    DataclassDTO._dto_backends = {}\n    dto_type = DataclassDTO[Annotated[Model, config]]\n    dto_type.create_for_field_definition(FieldDefinition.from_kwarg(Model, name='data'), handler_id='handler_id')\n    field_definitions = dto_type._dto_backends['handler_id']['data_backend'].parsed_field_definitions\n    assert field_definitions[0].serialization_name == 'z'",
        "mutated": [
            "def test_config_field_rename(asgi_connection: Request[Any, Any, Any]) -> None:\n    if False:\n        i = 10\n    config = DTOConfig(rename_fields={'a': 'z'})\n    DataclassDTO._dto_backends = {}\n    dto_type = DataclassDTO[Annotated[Model, config]]\n    dto_type.create_for_field_definition(FieldDefinition.from_kwarg(Model, name='data'), handler_id='handler_id')\n    field_definitions = dto_type._dto_backends['handler_id']['data_backend'].parsed_field_definitions\n    assert field_definitions[0].serialization_name == 'z'",
            "def test_config_field_rename(asgi_connection: Request[Any, Any, Any]) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    config = DTOConfig(rename_fields={'a': 'z'})\n    DataclassDTO._dto_backends = {}\n    dto_type = DataclassDTO[Annotated[Model, config]]\n    dto_type.create_for_field_definition(FieldDefinition.from_kwarg(Model, name='data'), handler_id='handler_id')\n    field_definitions = dto_type._dto_backends['handler_id']['data_backend'].parsed_field_definitions\n    assert field_definitions[0].serialization_name == 'z'",
            "def test_config_field_rename(asgi_connection: Request[Any, Any, Any]) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    config = DTOConfig(rename_fields={'a': 'z'})\n    DataclassDTO._dto_backends = {}\n    dto_type = DataclassDTO[Annotated[Model, config]]\n    dto_type.create_for_field_definition(FieldDefinition.from_kwarg(Model, name='data'), handler_id='handler_id')\n    field_definitions = dto_type._dto_backends['handler_id']['data_backend'].parsed_field_definitions\n    assert field_definitions[0].serialization_name == 'z'",
            "def test_config_field_rename(asgi_connection: Request[Any, Any, Any]) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    config = DTOConfig(rename_fields={'a': 'z'})\n    DataclassDTO._dto_backends = {}\n    dto_type = DataclassDTO[Annotated[Model, config]]\n    dto_type.create_for_field_definition(FieldDefinition.from_kwarg(Model, name='data'), handler_id='handler_id')\n    field_definitions = dto_type._dto_backends['handler_id']['data_backend'].parsed_field_definitions\n    assert field_definitions[0].serialization_name == 'z'",
            "def test_config_field_rename(asgi_connection: Request[Any, Any, Any]) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    config = DTOConfig(rename_fields={'a': 'z'})\n    DataclassDTO._dto_backends = {}\n    dto_type = DataclassDTO[Annotated[Model, config]]\n    dto_type.create_for_field_definition(FieldDefinition.from_kwarg(Model, name='data'), handler_id='handler_id')\n    field_definitions = dto_type._dto_backends['handler_id']['data_backend'].parsed_field_definitions\n    assert field_definitions[0].serialization_name == 'z'"
        ]
    },
    {
        "func_name": "test_type_narrowing_with_multiple_configs",
        "original": "def test_type_narrowing_with_multiple_configs() -> None:\n    config_1 = DTOConfig()\n    config_2 = DTOConfig()\n    dto = DataclassDTO[Annotated[Model, config_1, config_2]]\n    assert dto.config is config_1",
        "mutated": [
            "def test_type_narrowing_with_multiple_configs() -> None:\n    if False:\n        i = 10\n    config_1 = DTOConfig()\n    config_2 = DTOConfig()\n    dto = DataclassDTO[Annotated[Model, config_1, config_2]]\n    assert dto.config is config_1",
            "def test_type_narrowing_with_multiple_configs() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    config_1 = DTOConfig()\n    config_2 = DTOConfig()\n    dto = DataclassDTO[Annotated[Model, config_1, config_2]]\n    assert dto.config is config_1",
            "def test_type_narrowing_with_multiple_configs() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    config_1 = DTOConfig()\n    config_2 = DTOConfig()\n    dto = DataclassDTO[Annotated[Model, config_1, config_2]]\n    assert dto.config is config_1",
            "def test_type_narrowing_with_multiple_configs() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    config_1 = DTOConfig()\n    config_2 = DTOConfig()\n    dto = DataclassDTO[Annotated[Model, config_1, config_2]]\n    assert dto.config is config_1",
            "def test_type_narrowing_with_multiple_configs() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    config_1 = DTOConfig()\n    config_2 = DTOConfig()\n    dto = DataclassDTO[Annotated[Model, config_1, config_2]]\n    assert dto.config is config_1"
        ]
    },
    {
        "func_name": "test_raises_invalid_annotation_for_non_homogenous_collection_types",
        "original": "def test_raises_invalid_annotation_for_non_homogenous_collection_types() -> None:\n    dto_type = DataclassDTO[Model]\n    with pytest.raises(InvalidAnnotationException):\n        dto_type.create_for_field_definition(handler_id='handler', field_definition=FieldDefinition.from_annotation(Tuple[Model, str]))",
        "mutated": [
            "def test_raises_invalid_annotation_for_non_homogenous_collection_types() -> None:\n    if False:\n        i = 10\n    dto_type = DataclassDTO[Model]\n    with pytest.raises(InvalidAnnotationException):\n        dto_type.create_for_field_definition(handler_id='handler', field_definition=FieldDefinition.from_annotation(Tuple[Model, str]))",
            "def test_raises_invalid_annotation_for_non_homogenous_collection_types() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    dto_type = DataclassDTO[Model]\n    with pytest.raises(InvalidAnnotationException):\n        dto_type.create_for_field_definition(handler_id='handler', field_definition=FieldDefinition.from_annotation(Tuple[Model, str]))",
            "def test_raises_invalid_annotation_for_non_homogenous_collection_types() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    dto_type = DataclassDTO[Model]\n    with pytest.raises(InvalidAnnotationException):\n        dto_type.create_for_field_definition(handler_id='handler', field_definition=FieldDefinition.from_annotation(Tuple[Model, str]))",
            "def test_raises_invalid_annotation_for_non_homogenous_collection_types() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    dto_type = DataclassDTO[Model]\n    with pytest.raises(InvalidAnnotationException):\n        dto_type.create_for_field_definition(handler_id='handler', field_definition=FieldDefinition.from_annotation(Tuple[Model, str]))",
            "def test_raises_invalid_annotation_for_non_homogenous_collection_types() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    dto_type = DataclassDTO[Model]\n    with pytest.raises(InvalidAnnotationException):\n        dto_type.create_for_field_definition(handler_id='handler', field_definition=FieldDefinition.from_annotation(Tuple[Model, str]))"
        ]
    },
    {
        "func_name": "test_raises_invalid_annotation_for_mismatched_types",
        "original": "def test_raises_invalid_annotation_for_mismatched_types() -> None:\n    dto_type = DataclassDTO[Model]\n\n    @dataclass\n    class OtherModel:\n        a: int\n    with pytest.raises(InvalidAnnotationException):\n        dto_type.create_for_field_definition(handler_id='handler', field_definition=FieldDefinition.from_annotation(OtherModel))",
        "mutated": [
            "def test_raises_invalid_annotation_for_mismatched_types() -> None:\n    if False:\n        i = 10\n    dto_type = DataclassDTO[Model]\n\n    @dataclass\n    class OtherModel:\n        a: int\n    with pytest.raises(InvalidAnnotationException):\n        dto_type.create_for_field_definition(handler_id='handler', field_definition=FieldDefinition.from_annotation(OtherModel))",
            "def test_raises_invalid_annotation_for_mismatched_types() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    dto_type = DataclassDTO[Model]\n\n    @dataclass\n    class OtherModel:\n        a: int\n    with pytest.raises(InvalidAnnotationException):\n        dto_type.create_for_field_definition(handler_id='handler', field_definition=FieldDefinition.from_annotation(OtherModel))",
            "def test_raises_invalid_annotation_for_mismatched_types() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    dto_type = DataclassDTO[Model]\n\n    @dataclass\n    class OtherModel:\n        a: int\n    with pytest.raises(InvalidAnnotationException):\n        dto_type.create_for_field_definition(handler_id='handler', field_definition=FieldDefinition.from_annotation(OtherModel))",
            "def test_raises_invalid_annotation_for_mismatched_types() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    dto_type = DataclassDTO[Model]\n\n    @dataclass\n    class OtherModel:\n        a: int\n    with pytest.raises(InvalidAnnotationException):\n        dto_type.create_for_field_definition(handler_id='handler', field_definition=FieldDefinition.from_annotation(OtherModel))",
            "def test_raises_invalid_annotation_for_mismatched_types() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    dto_type = DataclassDTO[Model]\n\n    @dataclass\n    class OtherModel:\n        a: int\n    with pytest.raises(InvalidAnnotationException):\n        dto_type.create_for_field_definition(handler_id='handler', field_definition=FieldDefinition.from_annotation(OtherModel))"
        ]
    },
    {
        "func_name": "test_sub_types_supported",
        "original": "def test_sub_types_supported() -> None:\n    DataclassDTO._dto_backends = {}\n    dto_type = DataclassDTO[Model]\n\n    @dataclass\n    class SubType(Model):\n        c: int\n    dto_type.create_for_field_definition(handler_id='handler_id', field_definition=FieldDefinition.from_kwarg(SubType, name='data'))\n    assert dto_type._dto_backends['handler_id']['data_backend'].parsed_field_definitions[-1].name == 'c'",
        "mutated": [
            "def test_sub_types_supported() -> None:\n    if False:\n        i = 10\n    DataclassDTO._dto_backends = {}\n    dto_type = DataclassDTO[Model]\n\n    @dataclass\n    class SubType(Model):\n        c: int\n    dto_type.create_for_field_definition(handler_id='handler_id', field_definition=FieldDefinition.from_kwarg(SubType, name='data'))\n    assert dto_type._dto_backends['handler_id']['data_backend'].parsed_field_definitions[-1].name == 'c'",
            "def test_sub_types_supported() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    DataclassDTO._dto_backends = {}\n    dto_type = DataclassDTO[Model]\n\n    @dataclass\n    class SubType(Model):\n        c: int\n    dto_type.create_for_field_definition(handler_id='handler_id', field_definition=FieldDefinition.from_kwarg(SubType, name='data'))\n    assert dto_type._dto_backends['handler_id']['data_backend'].parsed_field_definitions[-1].name == 'c'",
            "def test_sub_types_supported() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    DataclassDTO._dto_backends = {}\n    dto_type = DataclassDTO[Model]\n\n    @dataclass\n    class SubType(Model):\n        c: int\n    dto_type.create_for_field_definition(handler_id='handler_id', field_definition=FieldDefinition.from_kwarg(SubType, name='data'))\n    assert dto_type._dto_backends['handler_id']['data_backend'].parsed_field_definitions[-1].name == 'c'",
            "def test_sub_types_supported() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    DataclassDTO._dto_backends = {}\n    dto_type = DataclassDTO[Model]\n\n    @dataclass\n    class SubType(Model):\n        c: int\n    dto_type.create_for_field_definition(handler_id='handler_id', field_definition=FieldDefinition.from_kwarg(SubType, name='data'))\n    assert dto_type._dto_backends['handler_id']['data_backend'].parsed_field_definitions[-1].name == 'c'",
            "def test_sub_types_supported() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    DataclassDTO._dto_backends = {}\n    dto_type = DataclassDTO[Model]\n\n    @dataclass\n    class SubType(Model):\n        c: int\n    dto_type.create_for_field_definition(handler_id='handler_id', field_definition=FieldDefinition.from_kwarg(SubType, name='data'))\n    assert dto_type._dto_backends['handler_id']['data_backend'].parsed_field_definitions[-1].name == 'c'"
        ]
    }
]