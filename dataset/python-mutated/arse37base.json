[
    {
        "func_name": "__init__",
        "original": "def __init__(self, debug_parser=PARSER_DEFAULT_DEBUG):\n    self.added_rules = set()\n    super(Python37BaseParser, self).__init__(SyntaxTree, 'stmts', debug=debug_parser)\n    self.new_rules = set()",
        "mutated": [
            "def __init__(self, debug_parser=PARSER_DEFAULT_DEBUG):\n    if False:\n        i = 10\n    self.added_rules = set()\n    super(Python37BaseParser, self).__init__(SyntaxTree, 'stmts', debug=debug_parser)\n    self.new_rules = set()",
            "def __init__(self, debug_parser=PARSER_DEFAULT_DEBUG):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.added_rules = set()\n    super(Python37BaseParser, self).__init__(SyntaxTree, 'stmts', debug=debug_parser)\n    self.new_rules = set()",
            "def __init__(self, debug_parser=PARSER_DEFAULT_DEBUG):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.added_rules = set()\n    super(Python37BaseParser, self).__init__(SyntaxTree, 'stmts', debug=debug_parser)\n    self.new_rules = set()",
            "def __init__(self, debug_parser=PARSER_DEFAULT_DEBUG):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.added_rules = set()\n    super(Python37BaseParser, self).__init__(SyntaxTree, 'stmts', debug=debug_parser)\n    self.new_rules = set()",
            "def __init__(self, debug_parser=PARSER_DEFAULT_DEBUG):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.added_rules = set()\n    super(Python37BaseParser, self).__init__(SyntaxTree, 'stmts', debug=debug_parser)\n    self.new_rules = set()"
        ]
    },
    {
        "func_name": "call_fn_name",
        "original": "@staticmethod\ndef call_fn_name(token):\n    \"\"\"Customize CALL_FUNCTION to add the number of positional arguments\"\"\"\n    if token.attr is not None:\n        return '%s_%i' % (token.kind, token.attr)\n    else:\n        return '%s_0' % token.kind",
        "mutated": [
            "@staticmethod\ndef call_fn_name(token):\n    if False:\n        i = 10\n    'Customize CALL_FUNCTION to add the number of positional arguments'\n    if token.attr is not None:\n        return '%s_%i' % (token.kind, token.attr)\n    else:\n        return '%s_0' % token.kind",
            "@staticmethod\ndef call_fn_name(token):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Customize CALL_FUNCTION to add the number of positional arguments'\n    if token.attr is not None:\n        return '%s_%i' % (token.kind, token.attr)\n    else:\n        return '%s_0' % token.kind",
            "@staticmethod\ndef call_fn_name(token):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Customize CALL_FUNCTION to add the number of positional arguments'\n    if token.attr is not None:\n        return '%s_%i' % (token.kind, token.attr)\n    else:\n        return '%s_0' % token.kind",
            "@staticmethod\ndef call_fn_name(token):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Customize CALL_FUNCTION to add the number of positional arguments'\n    if token.attr is not None:\n        return '%s_%i' % (token.kind, token.attr)\n    else:\n        return '%s_0' % token.kind",
            "@staticmethod\ndef call_fn_name(token):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Customize CALL_FUNCTION to add the number of positional arguments'\n    if token.attr is not None:\n        return '%s_%i' % (token.kind, token.attr)\n    else:\n        return '%s_0' % token.kind"
        ]
    },
    {
        "func_name": "add_make_function_rule",
        "original": "def add_make_function_rule(self, rule, opname, attr, customize):\n    \"\"\"Python 3.3 added a an addtional LOAD_STR before MAKE_FUNCTION and\n        this has an effect on many rules.\n        \"\"\"\n    new_rule = rule % 'LOAD_STR '\n    self.add_unique_rule(new_rule, opname, attr, customize)",
        "mutated": [
            "def add_make_function_rule(self, rule, opname, attr, customize):\n    if False:\n        i = 10\n    'Python 3.3 added a an addtional LOAD_STR before MAKE_FUNCTION and\\n        this has an effect on many rules.\\n        '\n    new_rule = rule % 'LOAD_STR '\n    self.add_unique_rule(new_rule, opname, attr, customize)",
            "def add_make_function_rule(self, rule, opname, attr, customize):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Python 3.3 added a an addtional LOAD_STR before MAKE_FUNCTION and\\n        this has an effect on many rules.\\n        '\n    new_rule = rule % 'LOAD_STR '\n    self.add_unique_rule(new_rule, opname, attr, customize)",
            "def add_make_function_rule(self, rule, opname, attr, customize):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Python 3.3 added a an addtional LOAD_STR before MAKE_FUNCTION and\\n        this has an effect on many rules.\\n        '\n    new_rule = rule % 'LOAD_STR '\n    self.add_unique_rule(new_rule, opname, attr, customize)",
            "def add_make_function_rule(self, rule, opname, attr, customize):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Python 3.3 added a an addtional LOAD_STR before MAKE_FUNCTION and\\n        this has an effect on many rules.\\n        '\n    new_rule = rule % 'LOAD_STR '\n    self.add_unique_rule(new_rule, opname, attr, customize)",
            "def add_make_function_rule(self, rule, opname, attr, customize):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Python 3.3 added a an addtional LOAD_STR before MAKE_FUNCTION and\\n        this has an effect on many rules.\\n        '\n    new_rule = rule % 'LOAD_STR '\n    self.add_unique_rule(new_rule, opname, attr, customize)"
        ]
    },
    {
        "func_name": "custom_build_class_rule",
        "original": "def custom_build_class_rule(self, opname, i, token, tokens, customize):\n    \"\"\"\n        # Should the first rule be somehow folded into the 2nd one?\n        build_class ::= LOAD_BUILD_CLASS mkfunc\n                        LOAD_CLASSNAME {expr}^n-1 CALL_FUNCTION_n\n                        LOAD_CONST CALL_FUNCTION_n\n        build_class ::= LOAD_BUILD_CLASS mkfunc\n                        expr\n                        call\n                        CALL_FUNCTION_3\n         \"\"\"\n    for i in range(i + 1, len(tokens)):\n        if tokens[i].kind.startswith('MAKE_FUNCTION'):\n            break\n        elif tokens[i].kind.startswith('MAKE_CLOSURE'):\n            break\n        pass\n    assert i < len(tokens), 'build_class needs to find MAKE_FUNCTION or MAKE_CLOSURE'\n    assert tokens[i + 1].kind == 'LOAD_STR', 'build_class expecting CONST after MAKE_FUNCTION/MAKE_CLOSURE'\n    call_fn_tok = None\n    for i in range(i, len(tokens)):\n        if tokens[i].kind.startswith('CALL_FUNCTION'):\n            call_fn_tok = tokens[i]\n            break\n    if not call_fn_tok:\n        raise RuntimeError('build_class custom rule for %s needs to find CALL_FUNCTION' % opname)\n    call_function = call_fn_tok.kind\n    if call_function.startswith('CALL_FUNCTION_KW'):\n        self.addRule('classdef ::= build_class_kw store', nop_func)\n        rule = 'build_class_kw ::= LOAD_BUILD_CLASS mkfunc %sLOAD_CONST %s' % ('expr ' * (call_fn_tok.attr - 1), call_function)\n    else:\n        call_function = self.call_fn_name(call_fn_tok)\n        rule = 'build_class ::= LOAD_BUILD_CLASS mkfunc %s%s' % ('expr ' * (call_fn_tok.attr - 1), call_function)\n    self.addRule(rule, nop_func)\n    return",
        "mutated": [
            "def custom_build_class_rule(self, opname, i, token, tokens, customize):\n    if False:\n        i = 10\n    '\\n        # Should the first rule be somehow folded into the 2nd one?\\n        build_class ::= LOAD_BUILD_CLASS mkfunc\\n                        LOAD_CLASSNAME {expr}^n-1 CALL_FUNCTION_n\\n                        LOAD_CONST CALL_FUNCTION_n\\n        build_class ::= LOAD_BUILD_CLASS mkfunc\\n                        expr\\n                        call\\n                        CALL_FUNCTION_3\\n         '\n    for i in range(i + 1, len(tokens)):\n        if tokens[i].kind.startswith('MAKE_FUNCTION'):\n            break\n        elif tokens[i].kind.startswith('MAKE_CLOSURE'):\n            break\n        pass\n    assert i < len(tokens), 'build_class needs to find MAKE_FUNCTION or MAKE_CLOSURE'\n    assert tokens[i + 1].kind == 'LOAD_STR', 'build_class expecting CONST after MAKE_FUNCTION/MAKE_CLOSURE'\n    call_fn_tok = None\n    for i in range(i, len(tokens)):\n        if tokens[i].kind.startswith('CALL_FUNCTION'):\n            call_fn_tok = tokens[i]\n            break\n    if not call_fn_tok:\n        raise RuntimeError('build_class custom rule for %s needs to find CALL_FUNCTION' % opname)\n    call_function = call_fn_tok.kind\n    if call_function.startswith('CALL_FUNCTION_KW'):\n        self.addRule('classdef ::= build_class_kw store', nop_func)\n        rule = 'build_class_kw ::= LOAD_BUILD_CLASS mkfunc %sLOAD_CONST %s' % ('expr ' * (call_fn_tok.attr - 1), call_function)\n    else:\n        call_function = self.call_fn_name(call_fn_tok)\n        rule = 'build_class ::= LOAD_BUILD_CLASS mkfunc %s%s' % ('expr ' * (call_fn_tok.attr - 1), call_function)\n    self.addRule(rule, nop_func)\n    return",
            "def custom_build_class_rule(self, opname, i, token, tokens, customize):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        # Should the first rule be somehow folded into the 2nd one?\\n        build_class ::= LOAD_BUILD_CLASS mkfunc\\n                        LOAD_CLASSNAME {expr}^n-1 CALL_FUNCTION_n\\n                        LOAD_CONST CALL_FUNCTION_n\\n        build_class ::= LOAD_BUILD_CLASS mkfunc\\n                        expr\\n                        call\\n                        CALL_FUNCTION_3\\n         '\n    for i in range(i + 1, len(tokens)):\n        if tokens[i].kind.startswith('MAKE_FUNCTION'):\n            break\n        elif tokens[i].kind.startswith('MAKE_CLOSURE'):\n            break\n        pass\n    assert i < len(tokens), 'build_class needs to find MAKE_FUNCTION or MAKE_CLOSURE'\n    assert tokens[i + 1].kind == 'LOAD_STR', 'build_class expecting CONST after MAKE_FUNCTION/MAKE_CLOSURE'\n    call_fn_tok = None\n    for i in range(i, len(tokens)):\n        if tokens[i].kind.startswith('CALL_FUNCTION'):\n            call_fn_tok = tokens[i]\n            break\n    if not call_fn_tok:\n        raise RuntimeError('build_class custom rule for %s needs to find CALL_FUNCTION' % opname)\n    call_function = call_fn_tok.kind\n    if call_function.startswith('CALL_FUNCTION_KW'):\n        self.addRule('classdef ::= build_class_kw store', nop_func)\n        rule = 'build_class_kw ::= LOAD_BUILD_CLASS mkfunc %sLOAD_CONST %s' % ('expr ' * (call_fn_tok.attr - 1), call_function)\n    else:\n        call_function = self.call_fn_name(call_fn_tok)\n        rule = 'build_class ::= LOAD_BUILD_CLASS mkfunc %s%s' % ('expr ' * (call_fn_tok.attr - 1), call_function)\n    self.addRule(rule, nop_func)\n    return",
            "def custom_build_class_rule(self, opname, i, token, tokens, customize):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        # Should the first rule be somehow folded into the 2nd one?\\n        build_class ::= LOAD_BUILD_CLASS mkfunc\\n                        LOAD_CLASSNAME {expr}^n-1 CALL_FUNCTION_n\\n                        LOAD_CONST CALL_FUNCTION_n\\n        build_class ::= LOAD_BUILD_CLASS mkfunc\\n                        expr\\n                        call\\n                        CALL_FUNCTION_3\\n         '\n    for i in range(i + 1, len(tokens)):\n        if tokens[i].kind.startswith('MAKE_FUNCTION'):\n            break\n        elif tokens[i].kind.startswith('MAKE_CLOSURE'):\n            break\n        pass\n    assert i < len(tokens), 'build_class needs to find MAKE_FUNCTION or MAKE_CLOSURE'\n    assert tokens[i + 1].kind == 'LOAD_STR', 'build_class expecting CONST after MAKE_FUNCTION/MAKE_CLOSURE'\n    call_fn_tok = None\n    for i in range(i, len(tokens)):\n        if tokens[i].kind.startswith('CALL_FUNCTION'):\n            call_fn_tok = tokens[i]\n            break\n    if not call_fn_tok:\n        raise RuntimeError('build_class custom rule for %s needs to find CALL_FUNCTION' % opname)\n    call_function = call_fn_tok.kind\n    if call_function.startswith('CALL_FUNCTION_KW'):\n        self.addRule('classdef ::= build_class_kw store', nop_func)\n        rule = 'build_class_kw ::= LOAD_BUILD_CLASS mkfunc %sLOAD_CONST %s' % ('expr ' * (call_fn_tok.attr - 1), call_function)\n    else:\n        call_function = self.call_fn_name(call_fn_tok)\n        rule = 'build_class ::= LOAD_BUILD_CLASS mkfunc %s%s' % ('expr ' * (call_fn_tok.attr - 1), call_function)\n    self.addRule(rule, nop_func)\n    return",
            "def custom_build_class_rule(self, opname, i, token, tokens, customize):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        # Should the first rule be somehow folded into the 2nd one?\\n        build_class ::= LOAD_BUILD_CLASS mkfunc\\n                        LOAD_CLASSNAME {expr}^n-1 CALL_FUNCTION_n\\n                        LOAD_CONST CALL_FUNCTION_n\\n        build_class ::= LOAD_BUILD_CLASS mkfunc\\n                        expr\\n                        call\\n                        CALL_FUNCTION_3\\n         '\n    for i in range(i + 1, len(tokens)):\n        if tokens[i].kind.startswith('MAKE_FUNCTION'):\n            break\n        elif tokens[i].kind.startswith('MAKE_CLOSURE'):\n            break\n        pass\n    assert i < len(tokens), 'build_class needs to find MAKE_FUNCTION or MAKE_CLOSURE'\n    assert tokens[i + 1].kind == 'LOAD_STR', 'build_class expecting CONST after MAKE_FUNCTION/MAKE_CLOSURE'\n    call_fn_tok = None\n    for i in range(i, len(tokens)):\n        if tokens[i].kind.startswith('CALL_FUNCTION'):\n            call_fn_tok = tokens[i]\n            break\n    if not call_fn_tok:\n        raise RuntimeError('build_class custom rule for %s needs to find CALL_FUNCTION' % opname)\n    call_function = call_fn_tok.kind\n    if call_function.startswith('CALL_FUNCTION_KW'):\n        self.addRule('classdef ::= build_class_kw store', nop_func)\n        rule = 'build_class_kw ::= LOAD_BUILD_CLASS mkfunc %sLOAD_CONST %s' % ('expr ' * (call_fn_tok.attr - 1), call_function)\n    else:\n        call_function = self.call_fn_name(call_fn_tok)\n        rule = 'build_class ::= LOAD_BUILD_CLASS mkfunc %s%s' % ('expr ' * (call_fn_tok.attr - 1), call_function)\n    self.addRule(rule, nop_func)\n    return",
            "def custom_build_class_rule(self, opname, i, token, tokens, customize):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        # Should the first rule be somehow folded into the 2nd one?\\n        build_class ::= LOAD_BUILD_CLASS mkfunc\\n                        LOAD_CLASSNAME {expr}^n-1 CALL_FUNCTION_n\\n                        LOAD_CONST CALL_FUNCTION_n\\n        build_class ::= LOAD_BUILD_CLASS mkfunc\\n                        expr\\n                        call\\n                        CALL_FUNCTION_3\\n         '\n    for i in range(i + 1, len(tokens)):\n        if tokens[i].kind.startswith('MAKE_FUNCTION'):\n            break\n        elif tokens[i].kind.startswith('MAKE_CLOSURE'):\n            break\n        pass\n    assert i < len(tokens), 'build_class needs to find MAKE_FUNCTION or MAKE_CLOSURE'\n    assert tokens[i + 1].kind == 'LOAD_STR', 'build_class expecting CONST after MAKE_FUNCTION/MAKE_CLOSURE'\n    call_fn_tok = None\n    for i in range(i, len(tokens)):\n        if tokens[i].kind.startswith('CALL_FUNCTION'):\n            call_fn_tok = tokens[i]\n            break\n    if not call_fn_tok:\n        raise RuntimeError('build_class custom rule for %s needs to find CALL_FUNCTION' % opname)\n    call_function = call_fn_tok.kind\n    if call_function.startswith('CALL_FUNCTION_KW'):\n        self.addRule('classdef ::= build_class_kw store', nop_func)\n        rule = 'build_class_kw ::= LOAD_BUILD_CLASS mkfunc %sLOAD_CONST %s' % ('expr ' * (call_fn_tok.attr - 1), call_function)\n    else:\n        call_function = self.call_fn_name(call_fn_tok)\n        rule = 'build_class ::= LOAD_BUILD_CLASS mkfunc %s%s' % ('expr ' * (call_fn_tok.attr - 1), call_function)\n    self.addRule(rule, nop_func)\n    return"
        ]
    },
    {
        "func_name": "customize_grammar_rules",
        "original": "def customize_grammar_rules(self, tokens, customize):\n    is_pypy = False\n    customize_instruction_basenames = frozenset(('BEFORE', 'BUILD', 'CALL', 'CONTINUE', 'DELETE', 'FORMAT', 'GET', 'JUMP', 'LOAD', 'LOOKUP', 'MAKE', 'RETURN', 'RAISE', 'SETUP', 'UNPACK', 'WITH'))\n    custom_ops_processed = set(('BUILD_TUPLE_UNPACK_WITH_CALL',))\n    self.seen_ops = frozenset([t.kind for t in tokens])\n    self.seen_op_basenames = frozenset([opname[:opname.rfind('_')] for opname in self.seen_ops])\n    if 'PyPy' in customize:\n        is_pypy = True\n        self.addRule('\\n              stmt ::= assign3_pypy\\n              stmt ::= assign2_pypy\\n              assign3_pypy       ::= expr expr expr store store store\\n              assign2_pypy       ::= expr expr store store\\n              stmt               ::= if_exp_lambda\\n              stmt               ::= if_exp_not_lambda\\n              if_exp_lambda      ::= expr jmp_false expr return_if_lambda\\n                                     return_expr_lambda LAMBDA_MARKER\\n              if_exp_not_lambda  ::= expr jmp_true expr return_if_lambda\\n                                     return_expr_lambda LAMBDA_MARKER\\n              ', nop_func)\n    n = len(tokens)\n    has_get_iter_call_function1 = False\n    for (i, token) in enumerate(tokens):\n        if token == 'GET_ITER' and i < n - 2 and (self.call_fn_name(tokens[i + 1]) == 'CALL_FUNCTION_1'):\n            has_get_iter_call_function1 = True\n    for (i, token) in enumerate(tokens):\n        opname = token.kind\n        if opname[:opname.find('_')] not in customize_instruction_basenames or opname in custom_ops_processed:\n            continue\n        opname_base = opname[:opname.rfind('_')]\n        if opname == 'LOAD_ASSERT' and 'PyPy' in customize:\n            rules_str = '\\n                stmt ::= JUMP_IF_NOT_DEBUG stmts COME_FROM\\n                '\n            self.add_unique_doc_rules(rules_str, customize)\n        elif opname == 'BEFORE_ASYNC_WITH':\n            rules_str = '\\n                   stmt            ::= async_with_stmt\\n                   stmt            ::= async_with_as_stmt\\n                '\n            if self.version < (3, 8):\n                rules_str += '\\n                      stmt                 ::= async_with_stmt SETUP_ASYNC_WITH\\n                      c_stmt               ::= c_async_with_stmt SETUP_ASYNC_WITH\\n                      async_with_stmt      ::= expr\\n                                               async_with_pre\\n                                               POP_TOP\\n                                               suite_stmts_opt\\n                                               POP_BLOCK LOAD_CONST\\n                                               async_with_post\\n                      c_async_with_stmt    ::= expr\\n                                               async_with_pre\\n                                               POP_TOP\\n                                               c_suite_stmts_opt\\n                                               POP_BLOCK LOAD_CONST\\n                                               async_with_post\\n                      async_with_stmt      ::= expr\\n                                               async_with_pre\\n                                               POP_TOP\\n                                               suite_stmts_opt\\n                                               async_with_post\\n                      c_async_with_stmt    ::= expr\\n                                               async_with_pre\\n                                               POP_TOP\\n                                               c_suite_stmts_opt\\n                                               async_with_post\\n                      async_with_as_stmt   ::= expr\\n                                               async_with_pre\\n                                               store\\n                                               suite_stmts_opt\\n                                               POP_BLOCK LOAD_CONST\\n                                               async_with_post\\n                      c_async_with_as_stmt ::= expr\\n                                              async_with_pre\\n                                              store\\n                                              c_suite_stmts_opt\\n                                              POP_BLOCK LOAD_CONST\\n                                              async_with_post\\n                      async_with_as_stmt   ::= expr\\n                                              async_with_pre\\n                                              store\\n                                              suite_stmts_opt\\n                                              async_with_post\\n                      c_async_with_as_stmt ::= expr\\n                                              async_with_pre\\n                                              store\\n                                              suite_stmts_opt\\n                                              async_with_post\\n                    '\n            else:\n                rules_str += '\\n                      async_with_pre       ::= BEFORE_ASYNC_WITH GET_AWAITABLE LOAD_CONST YIELD_FROM SETUP_ASYNC_WITH\\n                      async_with_post      ::= BEGIN_FINALLY COME_FROM_ASYNC_WITH\\n                                               WITH_CLEANUP_START GET_AWAITABLE LOAD_CONST YIELD_FROM\\n                                               WITH_CLEANUP_FINISH END_FINALLY\\n                      async_with_stmt      ::= expr\\n                                               async_with_pre\\n                                               POP_TOP\\n                                               suite_stmts\\n                                               POP_TOP POP_BLOCK\\n                                               async_with_post\\n                      c_async_with_stmt    ::= expr\\n                                               async_with_pre\\n                                               POP_TOP\\n                                               c_suite_stmts\\n                                               POP_TOP POP_BLOCK\\n                                               async_with_post\\n                      async_with_stmt      ::= expr\\n                                               async_with_pre\\n                                               POP_TOP\\n                                               suite_stmts\\n                                               POP_BLOCK\\n                                               BEGIN_FINALLY\\n                                               WITH_CLEANUP_START GET_AWAITABLE LOAD_CONST YIELD_FROM\\n                                               WITH_CLEANUP_FINISH POP_FINALLY LOAD_CONST RETURN_VALUE\\n                                               COME_FROM_ASYNC_WITH\\n                                               WITH_CLEANUP_START GET_AWAITABLE LOAD_CONST YIELD_FROM\\n                                               WITH_CLEANUP_FINISH END_FINALLY\\n                      c_async_with_stmt   ::= expr\\n                                              async_with_pre\\n                                              POP_TOP\\n                                              c_suite_stmts\\n                                              POP_BLOCK\\n                                              BEGIN_FINALLY\\n                                              WITH_CLEANUP_START GET_AWAITABLE LOAD_CONST YIELD_FROM\\n                                              WITH_CLEANUP_FINISH POP_FINALLY LOAD_CONST RETURN_VALUE\\n                                              COME_FROM_ASYNC_WITH\\n                                              WITH_CLEANUP_START GET_AWAITABLE LOAD_CONST YIELD_FROM\\n                                              WITH_CLEANUP_FINISH END_FINALLY\\n                      async_with_as_stmt   ::= expr\\n                                               async_with_pre\\n                                               store suite_stmts\\n                                               POP_TOP POP_BLOCK\\n                                               async_with_post\\n                      c_async_with_as_stmt ::= expr\\n                                               async_with_pre\\n                                               store suite_stmts\\n                                               POP_TOP POP_BLOCK\\n                                               async_with_post\\n                      async_with_as_stmt   ::= expr\\n                                               async_with_pre\\n                                               store suite_stmts\\n                                               POP_BLOCK async_with_post\\n                      c_async_with_as_stmt ::= expr\\n                                               async_with_pre\\n                                               store suite_stmts\\n                                               POP_BLOCK async_with_post\\n                    '\n            self.addRule(rules_str, nop_func)\n        elif opname in ('BUILD_CONST_LIST', 'BUILD_CONST_DICT', 'BUILD_CONST_SET'):\n            if opname == 'BUILD_CONST_DICT':\n                rule = f'\\n                            add_consts          ::= ADD_VALUE*\\n                            const_list          ::= COLLECTION_START add_consts {opname}\\n                            dict                ::= const_list\\n                            expr                ::= dict\\n                        '\n            else:\n                rule = f'\\n                            add_consts          ::= ADD_VALUE*\\n                            const_list          ::= COLLECTION_START add_consts {opname}\\n                            expr                ::= const_list\\n                        '\n            self.addRule(rule, nop_func)\n        elif opname_base == 'BUILD_CONST_KEY_MAP':\n            kvlist_n = 'expr ' * token.attr\n            rule = 'dict ::= %sLOAD_CONST %s' % (kvlist_n, opname)\n            self.addRule(rule, nop_func)\n        elif opname.startswith('BUILD_LIST_UNPACK'):\n            v = token.attr\n            rule = 'build_list_unpack ::= %s%s' % ('expr ' * v, opname)\n            self.addRule(rule, nop_func)\n            rule = 'expr ::= build_list_unpack'\n            self.addRule(rule, nop_func)\n        elif opname_base in ('BUILD_MAP', 'BUILD_MAP_UNPACK'):\n            if opname == 'BUILD_MAP_UNPACK':\n                self.addRule('\\n                        expr        ::= dict_unpack\\n                        dict_unpack ::= dict_comp BUILD_MAP_UNPACK\\n                        ', nop_func)\n                pass\n            elif opname.startswith('BUILD_MAP_UNPACK_WITH_CALL'):\n                v = token.attr\n                rule = 'build_map_unpack_with_call ::= %s%s' % ('expr ' * v, opname)\n                self.addRule(rule, nop_func)\n            kvlist_n = 'kvlist_%s' % token.attr\n            if opname == 'BUILD_MAP_n':\n                rule = 'dict_comp_func ::= BUILD_MAP_n LOAD_ARG for_iter store comp_iter JUMP_BACK RETURN_VALUE RETURN_LAST'\n                self.add_unique_rule(rule, 'dict_comp_func', 1, customize)\n                kvlist_n = 'kvlist_n'\n                rule = 'kvlist_n ::=  kvlist_n kv3'\n                self.add_unique_rule(rule, 'kvlist_n', 0, customize)\n                rule = 'kvlist_n ::='\n                self.add_unique_rule(rule, 'kvlist_n', 1, customize)\n                rule = 'dict ::=  BUILD_MAP_n kvlist_n'\n            if not opname.startswith('BUILD_MAP_WITH_CALL'):\n                if opname.startswith('BUILD_MAP_UNPACK'):\n                    if 'LOAD_DICTCOMP' in self.seen_ops:\n                        rule = 'dict ::= %s%s' % ('dict_comp ' * token.attr, opname)\n                        self.addRule(rule, nop_func)\n                    rule = '\\n                         expr        ::= dict_unpack\\n                         dict_unpack ::= %s%s\\n                         ' % ('expr ' * token.attr, opname)\n                else:\n                    rule = '%s ::= %s %s' % (kvlist_n, 'expr ' * (token.attr * 2), opname)\n                    self.add_unique_rule(rule, opname, token.attr, customize)\n                    rule = 'dict ::=  %s' % kvlist_n\n            self.add_unique_rule(rule, opname, token.attr, customize)\n        elif opname.startswith('BUILD_MAP_UNPACK_WITH_CALL'):\n            v = token.attr\n            rule = 'build_map_unpack_with_call ::= %s%s' % ('expr ' * v, opname)\n            self.addRule(rule, nop_func)\n        elif opname.startswith('BUILD_TUPLE_UNPACK_WITH_CALL'):\n            v = token.attr\n            rule = 'build_tuple_unpack_with_call ::= ' + 'expr1024 ' * int(v // 1024) + 'expr32 ' * int(v // 32 % 32) + 'expr ' * (v % 32) + opname\n            self.addRule(rule, nop_func)\n            rule = 'starred ::= %s %s' % ('expr ' * v, opname)\n            self.addRule(rule, nop_func)\n        elif opname_base in ('BUILD_LIST', 'BUILD_SET', 'BUILD_TUPLE', 'BUILD_TUPLE_UNPACK'):\n            collection_size = token.attr\n            is_LOAD_CLOSURE = False\n            if opname_base == 'BUILD_TUPLE':\n                is_LOAD_CLOSURE = True\n                for j in range(collection_size):\n                    if tokens[i - j - 1].kind != 'LOAD_CLOSURE':\n                        is_LOAD_CLOSURE = False\n                        break\n                if is_LOAD_CLOSURE:\n                    rule = 'load_closure ::= %s%s' % ('LOAD_CLOSURE ' * collection_size, opname)\n                    self.add_unique_rule(rule, opname, token.attr, customize)\n            if not is_LOAD_CLOSURE or collection_size == 0:\n                thousands = collection_size // 1024\n                thirty32s = collection_size // 32 % 32\n                if thirty32s > 0:\n                    rule = 'expr32 ::=%s' % (' expr' * 32)\n                    self.add_unique_rule(rule, opname_base, collection_size, customize)\n                    pass\n                if thousands > 0:\n                    self.add_unique_rule('expr1024 ::=%s' % (' expr32' * 32), opname_base, collection_size, customize)\n                    pass\n                collection = opname_base[opname_base.find('_') + 1:].lower()\n                rule = '%s ::= ' % collection + 'expr1024 ' * thousands + 'expr32 ' * thirty32s + 'expr ' * (collection_size % 32) + opname\n                self.add_unique_rules(['expr ::= %s' % collection, rule], customize)\n                continue\n            continue\n        elif opname_base == 'BUILD_SLICE':\n            if token.attr == 2:\n                self.add_unique_rules(['expr ::= slice2', 'slice2 ::= expr expr BUILD_SLICE_2'], customize)\n            else:\n                assert token.attr == 3, 'BUILD_SLICE value must be 2 or 3; is %s' % token.attr\n                self.add_unique_rules(['expr   ::= slice3', 'slice3 ::= expr expr expr BUILD_SLICE_3'], customize)\n        elif opname.startswith('BUILD_STRING'):\n            v = token.attr\n            rules_str = '\\n                    expr                 ::= joined_str\\n                    joined_str           ::= %sBUILD_STRING_%d\\n                ' % ('expr ' * v, v)\n            self.add_unique_doc_rules(rules_str, customize)\n            if 'FORMAT_VALUE_ATTR' in self.seen_ops:\n                rules_str = '\\n                      formatted_value_attr ::= expr expr FORMAT_VALUE_ATTR expr BUILD_STRING\\n                      expr                 ::= formatted_value_attr\\n                    '\n                self.add_unique_doc_rules(rules_str, customize)\n        elif opname in frozenset(('CALL_FUNCTION', 'CALL_FUNCTION_EX', 'CALL_FUNCTION_EX_KW', 'CALL_FUNCTION_VAR', 'CALL_FUNCTION_VAR_KW')) or opname.startswith('CALL_FUNCTION_KW'):\n            if opname == 'CALL_FUNCTION' and token.attr == 1:\n                rule = '\\n                     expr         ::= dict_comp\\n                     dict_comp    ::= LOAD_DICTCOMP LOAD_STR MAKE_FUNCTION_0 expr\\n                                      GET_ITER CALL_FUNCTION_1\\n                    classdefdeco1 ::= expr classdefdeco2 CALL_FUNCTION_1\\n                    classdefdeco1 ::= expr classdefdeco1 CALL_FUNCTION_1\\n                    '\n                self.addRule(rule, nop_func)\n            self.custom_classfunc_rule(opname, token, customize, tokens[i + 1])\n        elif opname_base == 'CALL_METHOD':\n            (args_pos, args_kw) = self.get_pos_kw(token)\n            if opname == 'CALL_METHOD_KW':\n                args_kw = token.attr\n                rules_str = '\\n                         expr ::= call_kw_pypy37\\n                         pypy_kw_keys ::= LOAD_CONST\\n                    '\n                self.add_unique_doc_rules(rules_str, customize)\n                rule = 'call_kw_pypy37 ::= expr ' + 'expr ' * args_kw + ' pypy_kw_keys ' + opname\n            else:\n                (args_pos, args_kw) = self.get_pos_kw(token)\n                nak = (len(opname_base) - len('CALL_METHOD')) // 3\n                rule = 'call ::= expr ' + 'pos_arg ' * args_pos + 'kwarg ' * args_kw + 'expr ' * nak + opname\n            self.add_unique_rule(rule, opname, token.attr, customize)\n        elif opname == 'CONTINUE':\n            self.addRule('continue ::= CONTINUE', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'CONTINUE_LOOP':\n            self.addRule('continue ::= CONTINUE_LOOP', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'DELETE_ATTR':\n            self.addRule('delete ::= expr DELETE_ATTR', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'DELETE_DEREF':\n            self.addRule('\\n                   stmt           ::= del_deref_stmt\\n                   del_deref_stmt ::= DELETE_DEREF\\n                   ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'DELETE_SUBSCR':\n            self.addRule('\\n                    delete ::= delete_subscript\\n                    delete_subscript ::= expr expr DELETE_SUBSCR\\n                   ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'FORMAT_VALUE':\n            rules_str = '\\n                    expr              ::= formatted_value1\\n                    formatted_value1  ::= expr FORMAT_VALUE\\n                '\n            self.add_unique_doc_rules(rules_str, customize)\n        elif opname == 'GET_ANEXT':\n            self.addRule('\\n                    func_async_prefix   ::= _come_froms SETUP_FINALLY GET_ANEXT LOAD_CONST YIELD_FROM POP_BLOCK\\n                    func_async_middle   ::= JUMP_FORWARD COME_FROM_EXCEPT\\n                                            DUP_TOP LOAD_GLOBAL COMPARE_OP POP_JUMP_IF_TRUE\\n                    list_afor2          ::= func_async_prefix\\n                                            store list_iter\\n                                            JUMP_BACK COME_FROM_FINALLY\\n                                            END_ASYNC_FOR\\n                   ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'FORMAT_VALUE_ATTR':\n            rules_str = '\\n                expr              ::= formatted_value2\\n                formatted_value2  ::= expr expr FORMAT_VALUE_ATTR\\n                '\n            self.add_unique_doc_rules(rules_str, customize)\n        elif opname == 'GET_ITER':\n            self.addRule('\\n                    expr      ::= get_iter\\n                    get_iter  ::= expr GET_ITER\\n                    ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'GET_AITER':\n            self.addRule('\\n                    expr                ::= generator_exp_async\\n                    generator_exp_async ::= load_genexpr LOAD_STR MAKE_FUNCTION_0 expr\\n                                            GET_AITER CALL_FUNCTION_1\\n\\n                    stmt                ::= genexpr_func_async\\n\\n                    func_async_prefix   ::= _come_froms SETUP_EXCEPT GET_ANEXT LOAD_CONST YIELD_FROM\\n                    func_async_middle   ::= POP_BLOCK JUMP_FORWARD COME_FROM_EXCEPT\\n                                            DUP_TOP LOAD_GLOBAL COMPARE_OP POP_JUMP_IF_TRUE\\n                                            END_FINALLY COME_FROM\\n                    genexpr_func_async  ::= LOAD_ARG func_async_prefix\\n                                            store func_async_middle comp_iter\\n                                            JUMP_BACK COME_FROM\\n                                            POP_TOP POP_TOP POP_TOP POP_EXCEPT POP_TOP\\n\\n                    expr                ::= list_comp_async\\n                    list_comp_async     ::= LOAD_LISTCOMP LOAD_STR MAKE_FUNCTION_0\\n                                            expr GET_AITER CALL_FUNCTION_1\\n                                            GET_AWAITABLE LOAD_CONST\\n                                            YIELD_FROM\\n\\n                    expr                ::= list_comp_async\\n                    list_afor2          ::= func_async_prefix\\n                                            store func_async_middle list_iter\\n                                            JUMP_BACK COME_FROM\\n                                            POP_TOP POP_TOP POP_TOP POP_EXCEPT POP_TOP\\n                    list_comp_async     ::= BUILD_LIST_0 LOAD_ARG list_afor2\\n                    get_aiter           ::= expr GET_AITER\\n                    list_afor           ::= get_aiter list_afor2\\n                    list_iter           ::= list_afor\\n                   ', nop_func)\n        elif opname == 'JUMP_IF_NOT_DEBUG':\n            v = token.attr\n            self.addRule('\\n                    stmt        ::= assert_pypy\\n                    stmt        ::= assert2_pypy\", nop_func)\\n                    assert_pypy ::=  JUMP_IF_NOT_DEBUG expr jmp_true\\n                                     LOAD_ASSERT RAISE_VARARGS_1 COME_FROM\\n                    assert2_pypy ::= JUMP_IF_NOT_DEBUG assert_expr jmp_true\\n                                     LOAD_ASSERT expr CALL_FUNCTION_1\\n                                     RAISE_VARARGS_1 COME_FROM\\n                    assert2_pypy ::= JUMP_IF_NOT_DEBUG expr jmp_true\\n                                     LOAD_ASSERT expr CALL_FUNCTION_1\\n                                     RAISE_VARARGS_1 COME_FROM,\\n                    ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'LOAD_BUILD_CLASS':\n            self.custom_build_class_rule(opname, i, token, tokens, customize)\n        elif opname == 'LOAD_CLASSDEREF':\n            self.addRule('expr ::= LOAD_CLASSDEREF', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'LOAD_CLASSNAME':\n            self.addRule('expr ::= LOAD_CLASSNAME', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'LOAD_DICTCOMP':\n            if has_get_iter_call_function1:\n                rule_pat = 'dict_comp ::= LOAD_DICTCOMP %sMAKE_FUNCTION_0 expr GET_ITER CALL_FUNCTION_1'\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                pass\n            custom_ops_processed.add(opname)\n        elif opname == 'LOAD_ATTR':\n            self.addRule('\\n                  expr      ::= attribute\\n                  attribute ::= expr LOAD_ATTR\\n                  ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'LOAD_LISTCOMP':\n            self.add_unique_rule('expr ::= listcomp', opname, token.attr, customize)\n            custom_ops_processed.add(opname)\n        elif opname == 'LOAD_NAME':\n            if token.attr == '__annotations__' and 'SETUP_ANNOTATIONS' in self.seen_ops:\n                token.kind = 'LOAD_ANNOTATION'\n                self.addRule('\\n                        stmt       ::= SETUP_ANNOTATIONS\\n                        stmt       ::= ann_assign\\n                        ann_assign ::= expr LOAD_ANNOTATION LOAD_STR STORE_SUBSCR\\n                        ', nop_func)\n                pass\n        elif opname == 'LOAD_SETCOMP':\n            if has_get_iter_call_function1:\n                self.addRule('expr ::= set_comp', nop_func)\n                rule_pat = 'set_comp ::= LOAD_SETCOMP %sMAKE_FUNCTION_0 expr GET_ITER CALL_FUNCTION_1'\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                pass\n            custom_ops_processed.add(opname)\n        elif opname == 'LOOKUP_METHOD':\n            self.addRule('\\n                             expr      ::= attribute\\n                             attribute ::= expr LOOKUP_METHOD\\n                             ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname.startswith('MAKE_CLOSURE'):\n            if opname == 'MAKE_CLOSURE_0' and 'LOAD_DICTCOMP' in self.seen_ops:\n                rule = '\\n                        dict_comp ::= load_closure LOAD_DICTCOMP LOAD_STR\\n                                      MAKE_CLOSURE_0 expr\\n                                      GET_ITER CALL_FUNCTION_1\\n                    '\n                self.addRule(rule, nop_func)\n            (args_pos, args_kw, annotate_args) = token.attr\n            j = 2\n            if is_pypy or (i >= j and tokens[i - j] == 'LOAD_LAMBDA'):\n                rule_pat = 'lambda_body ::= %sload_closure LOAD_LAMBDA %%s%s' % ('pos_arg ' * args_pos, opname)\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n            if has_get_iter_call_function1:\n                rule_pat = 'generator_exp ::= %sload_closure load_genexpr %%s%s expr GET_ITER CALL_FUNCTION_1' % ('pos_arg ' * args_pos, opname)\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                if has_get_iter_call_function1:\n                    if is_pypy or (i >= j and tokens[i - j] == 'LOAD_LISTCOMP'):\n                        rule_pat = 'listcomp ::= %sload_closure LOAD_LISTCOMP %%s%s expr GET_ITER CALL_FUNCTION_1' % ('pos_arg ' * args_pos, opname)\n                        self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                    if is_pypy or (i >= j and tokens[i - j] == 'LOAD_SETCOMP'):\n                        rule_pat = 'set_comp ::= %sload_closure LOAD_SETCOMP %%s%s expr GET_ITER CALL_FUNCTION_1' % ('pos_arg ' * args_pos, opname)\n                        self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                    if is_pypy or (i >= j and tokens[i - j] == 'LOAD_DICTCOMP'):\n                        self.add_unique_rule('dict_comp ::= %sload_closure LOAD_DICTCOMP %s expr GET_ITER CALL_FUNCTION_1' % ('pos_arg ' * args_pos, opname), opname, token.attr, customize)\n            if args_kw > 0:\n                kwargs_str = 'kwargs '\n            else:\n                kwargs_str = ''\n            rule = 'mkfunc ::= %s%s%s load_closure LOAD_CODE LOAD_STR %s' % ('expr ' * args_pos, kwargs_str, 'expr ' * annotate_args, opname)\n            self.add_unique_rule(rule, opname, token.attr, customize)\n            if args_kw == 0:\n                rule = 'mkfunc ::= %sload_closure load_genexpr %s' % ('pos_arg ' * args_pos, opname)\n                self.add_unique_rule(rule, opname, token.attr, customize)\n            pass\n        elif opname_base.startswith('MAKE_FUNCTION'):\n            (args_pos, args_kw, annotate_args, closure) = token.attr\n            stack_count = args_pos + args_kw + annotate_args\n            if closure:\n                if args_pos:\n                    rule = 'lambda_body ::= %s%s%s%s' % ('expr ' * stack_count, 'load_closure ' * closure, 'BUILD_TUPLE_1 LOAD_LAMBDA LOAD_STR ', opname)\n                else:\n                    rule = 'lambda_body ::= %s%s%s' % ('load_closure ' * closure, 'LOAD_LAMBDA LOAD_STR ', opname)\n                self.add_unique_rule(rule, opname, token.attr, customize)\n            else:\n                rule = 'lambda_body ::= %sLOAD_LAMBDA LOAD_STR %s' % ('expr ' * stack_count, opname)\n                self.add_unique_rule(rule, opname, token.attr, customize)\n            rule = 'mkfunc ::= %s%s%s%s' % ('expr ' * stack_count, 'load_closure ' * closure, 'LOAD_CODE LOAD_STR ', opname)\n            self.add_unique_rule(rule, opname, token.attr, customize)\n            if has_get_iter_call_function1:\n                rule_pat = 'generator_exp ::= %sload_genexpr %%s%s expr GET_ITER CALL_FUNCTION_1' % ('pos_arg ' * args_pos, opname)\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                rule_pat = 'generator_exp ::= %sload_closure load_genexpr %%s%s expr GET_ITER CALL_FUNCTION_1' % ('pos_arg ' * args_pos, opname)\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                if is_pypy or (i >= 2 and tokens[i - 2] == 'LOAD_LISTCOMP'):\n                    rule_pat = 'listcomp ::= load_closure LOAD_LISTCOMP %%s%s expr GET_ITER CALL_FUNCTION_1' % (opname,)\n                    self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                    rule_pat = 'listcomp ::= %sLOAD_LISTCOMP %%s%s expr GET_ITER CALL_FUNCTION_1' % ('expr ' * args_pos, opname)\n                    self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n            if is_pypy or (i >= 2 and tokens[i - 2] == 'LOAD_LAMBDA'):\n                rule_pat = 'lambda_body ::= %s%sLOAD_LAMBDA %%s%s' % ('pos_arg ' * args_pos, 'kwarg ' * args_kw, opname)\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n            continue\n            (args_pos, args_kw, annotate_args, closure) = token.attr\n            j = 2\n            if has_get_iter_call_function1:\n                rule_pat = 'generator_exp ::= %sload_genexpr %%s%s expr GET_ITER CALL_FUNCTION_1' % ('pos_arg ' * args_pos, opname)\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                if is_pypy or (i >= j and tokens[i - j] == 'LOAD_LISTCOMP'):\n                    rule_pat = 'listcomp ::= %sLOAD_LISTCOMP %%s%s expr GET_ITER CALL_FUNCTION_1' % ('expr ' * args_pos, opname)\n                    self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n            if is_pypy or (i >= j and tokens[i - j] == 'LOAD_LAMBDA'):\n                rule_pat = 'lambda_body ::= %s%sLOAD_LAMBDA %%s%s' % ('pos_arg ' * args_pos, 'kwarg ' * args_kw, opname)\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n            if args_kw == 0:\n                kwargs = 'no_kwargs'\n                self.add_unique_rule('no_kwargs ::=', opname, token.attr, customize)\n            else:\n                kwargs = 'kwargs'\n            rule = 'mkfunc ::= %s%s %s%s' % ('pos_arg ' * args_pos, kwargs, 'LOAD_CODE LOAD_STR ', opname)\n            self.add_unique_rule(rule, opname, token.attr, customize)\n        elif opname == 'MAKE_FUNCTION_CLOSURE':\n            if 'LOAD_DICTCOMP' in self.seen_ops:\n                rule = '\\n                       dict_comp ::= load_closure LOAD_DICTCOMP LOAD_STR\\n                                     MAKE_FUNCTION_CLOSURE expr\\n                                     GET_ITER CALL_FUNCTION_1\\n                       '\n                self.addRule(rule, nop_func)\n            elif 'LOAD_SETCOMP' in self.seen_ops:\n                rule = '\\n                       set_comp ::= load_closure LOAD_SETCOMP LOAD_STR\\n                                    MAKE_FUNCTION_CLOSURE expr\\n                                    GET_ITER CALL_FUNCTION_1\\n                       '\n                self.addRule(rule, nop_func)\n        elif opname == 'RETURN_VALUE_LAMBDA':\n            self.addRule('\\n                    return_expr_lambda ::= return_expr RETURN_VALUE_LAMBDA\\n                    ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'RAISE_VARARGS_0':\n            self.addRule('\\n                    stmt        ::= raise_stmt0\\n                    raise_stmt0 ::= RAISE_VARARGS_0\\n                    ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'RAISE_VARARGS_1':\n            self.addRule('\\n                    stmt        ::= raise_stmt1\\n                    raise_stmt1 ::= expr RAISE_VARARGS_1\\n                    ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'RAISE_VARARGS_2':\n            self.addRule('\\n                    stmt        ::= raise_stmt2\\n                    raise_stmt2 ::= expr expr RAISE_VARARGS_2\\n                    ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'SETUP_EXCEPT':\n            self.addRule('\\n                    try_except     ::= SETUP_EXCEPT suite_stmts_opt POP_BLOCK\\n                                       except_handler opt_come_from_except\\n\\n                    tryelsestmt    ::= SETUP_EXCEPT suite_stmts_opt POP_BLOCK\\n                                       except_handler else_suite come_from_except_clauses\\n\\n                    tryelsestmt    ::= SETUP_EXCEPT suite_stmts_opt POP_BLOCK\\n                                       except_handler else_suite come_froms\\n\\n                    tryelsestmtl   ::= SETUP_EXCEPT suite_stmts_opt POP_BLOCK\\n                                       except_handler else_suitel come_from_except_clauses\\n\\n                    stmt             ::= tryelsestmtl3\\n                    tryelsestmtl3    ::= SETUP_EXCEPT suite_stmts_opt POP_BLOCK\\n                                         except_handler COME_FROM else_suitel\\n                                         opt_come_from_except\\n                    ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'WITH_CLEANUP_START':\n            rules_str = '\\n                  stmt        ::= with_null\\n                  with_null   ::= with_suffix\\n                  with_suffix ::= WITH_CLEANUP_START WITH_CLEANUP_FINISH END_FINALLY\\n                '\n            self.addRule(rules_str, nop_func)\n        elif opname == 'SETUP_WITH':\n            rules_str = '\\n                  stmt       ::= with\\n                  stmt       ::= withasstmt\\n\\n                  with       ::= expr\\n                                 SETUP_WITH POP_TOP\\n                                 suite_stmts_opt\\n                                 COME_FROM_WITH\\n                                 with_suffix\\n                  withasstmt ::= expr SETUP_WITH store suite_stmts_opt COME_FROM_WITH\\n                                 with_suffix\\n\\n                  with       ::= expr\\n                                 SETUP_WITH POP_TOP\\n                                 suite_stmts_opt\\n                                 POP_BLOCK LOAD_CONST COME_FROM_WITH\\n                                 with_suffix\\n\\n                  withasstmt ::= expr\\n                                 SETUP_WITH store suite_stmts_opt\\n                                 POP_BLOCK LOAD_CONST COME_FROM_WITH\\n                                 with_suffix\\n\\n                  with       ::= expr\\n                                 SETUP_WITH POP_TOP suite_stmts_opt\\n                                 POP_BLOCK LOAD_CONST COME_FROM_WITH\\n                                 with_suffix\\n                  withasstmt ::= expr\\n                                 SETUP_WITH store suite_stmts_opt\\n                                 POP_BLOCK LOAD_CONST COME_FROM_WITH\\n                                 with_suffix\\n                '\n            if self.version < (3, 8):\n                rules_str += '\\n                    with     ::= expr SETUP_WITH POP_TOP suite_stmts_opt POP_BLOCK\\n                                   LOAD_CONST\\n                                   with_suffix\\n                    '\n            else:\n                rules_str += '\\n                      with       ::= expr\\n                                     SETUP_WITH POP_TOP suite_stmts_opt\\n                                     POP_BLOCK LOAD_CONST COME_FROM_WITH\\n                                     with_suffix\\n\\n                      withasstmt ::= expr\\n                                     SETUP_WITH store suite_stmts_opt\\n                                     POP_BLOCK LOAD_CONST COME_FROM_WITH\\n\\n                      withasstmt ::= expr\\n                                     SETUP_WITH store suite_stmts\\n                                     POP_BLOCK BEGIN_FINALLY COME_FROM_WITH with_suffix\\n\\n                      with       ::= expr SETUP_WITH POP_TOP suite_stmts_opt POP_BLOCK\\n                                     BEGIN_FINALLY COME_FROM_WITH\\n                                     with_suffix\\n                    '\n            self.addRule(rules_str, nop_func)\n        elif opname_base in ('UNPACK_EX',):\n            (before_count, after_count) = token.attr\n            rule = 'unpack ::= ' + opname + ' store' * (before_count + after_count + 1)\n            self.addRule(rule, nop_func)\n        elif opname_base in ('UNPACK_TUPLE', 'UNPACK_SEQUENCE'):\n            rule = 'unpack ::= ' + opname + ' store' * token.attr\n            self.addRule(rule, nop_func)\n        elif opname_base == 'UNPACK_LIST':\n            rule = 'unpack_list ::= ' + opname + ' store' * token.attr\n            self.addRule(rule, nop_func)\n            custom_ops_processed.add(opname)\n            pass\n        pass\n    self.reduce_check_table = {'_ifstmts_jump': ifstmts_jump, 'and': and_invalid, 'ifelsestmt': ifelsestmt, 'ifelsestmtl': ifelsestmt, 'iflaststmt': iflaststmt, 'iflaststmtl': iflaststmt, 'ifstmt': ifstmt, 'ifstmtl': ifstmt, 'or': or_check, 'testtrue': testtrue, 'testfalsel': testtrue, 'while1elsestmt': while1elsestmt, 'while1stmt': while1stmt, 'try_elsestmtl38': tryelsestmtl3}\n    self.check_reduce['and'] = 'AST'\n    self.check_reduce['annotate_tuple'] = 'noAST'\n    self.check_reduce['aug_assign1'] = 'AST'\n    self.check_reduce['aug_assign2'] = 'AST'\n    self.check_reduce['while1stmt'] = 'noAST'\n    self.check_reduce['while1elsestmt'] = 'noAST'\n    self.check_reduce['_ifstmts_jump'] = 'AST'\n    self.check_reduce['import_as37'] = 'tokens'\n    self.check_reduce['import_from_as37'] = 'tokens'\n    self.check_reduce['import_from_as37'] = 'tokens'\n    self.check_reduce['ifelsestmt'] = 'AST'\n    self.check_reduce['ifelsestmtl'] = 'AST'\n    self.check_reduce['iflaststmt'] = 'AST'\n    self.check_reduce['iflaststmtl'] = 'AST'\n    self.check_reduce['ifstmt'] = 'AST'\n    self.check_reduce['ifstmtl'] = 'AST'\n    self.check_reduce['import_from37'] = 'AST'\n    self.check_reduce['or'] = 'AST'\n    self.check_reduce['testtrue'] = 'tokens'\n    self.check_reduce['testfalsel'] = 'tokens'\n    return",
        "mutated": [
            "def customize_grammar_rules(self, tokens, customize):\n    if False:\n        i = 10\n    is_pypy = False\n    customize_instruction_basenames = frozenset(('BEFORE', 'BUILD', 'CALL', 'CONTINUE', 'DELETE', 'FORMAT', 'GET', 'JUMP', 'LOAD', 'LOOKUP', 'MAKE', 'RETURN', 'RAISE', 'SETUP', 'UNPACK', 'WITH'))\n    custom_ops_processed = set(('BUILD_TUPLE_UNPACK_WITH_CALL',))\n    self.seen_ops = frozenset([t.kind for t in tokens])\n    self.seen_op_basenames = frozenset([opname[:opname.rfind('_')] for opname in self.seen_ops])\n    if 'PyPy' in customize:\n        is_pypy = True\n        self.addRule('\\n              stmt ::= assign3_pypy\\n              stmt ::= assign2_pypy\\n              assign3_pypy       ::= expr expr expr store store store\\n              assign2_pypy       ::= expr expr store store\\n              stmt               ::= if_exp_lambda\\n              stmt               ::= if_exp_not_lambda\\n              if_exp_lambda      ::= expr jmp_false expr return_if_lambda\\n                                     return_expr_lambda LAMBDA_MARKER\\n              if_exp_not_lambda  ::= expr jmp_true expr return_if_lambda\\n                                     return_expr_lambda LAMBDA_MARKER\\n              ', nop_func)\n    n = len(tokens)\n    has_get_iter_call_function1 = False\n    for (i, token) in enumerate(tokens):\n        if token == 'GET_ITER' and i < n - 2 and (self.call_fn_name(tokens[i + 1]) == 'CALL_FUNCTION_1'):\n            has_get_iter_call_function1 = True\n    for (i, token) in enumerate(tokens):\n        opname = token.kind\n        if opname[:opname.find('_')] not in customize_instruction_basenames or opname in custom_ops_processed:\n            continue\n        opname_base = opname[:opname.rfind('_')]\n        if opname == 'LOAD_ASSERT' and 'PyPy' in customize:\n            rules_str = '\\n                stmt ::= JUMP_IF_NOT_DEBUG stmts COME_FROM\\n                '\n            self.add_unique_doc_rules(rules_str, customize)\n        elif opname == 'BEFORE_ASYNC_WITH':\n            rules_str = '\\n                   stmt            ::= async_with_stmt\\n                   stmt            ::= async_with_as_stmt\\n                '\n            if self.version < (3, 8):\n                rules_str += '\\n                      stmt                 ::= async_with_stmt SETUP_ASYNC_WITH\\n                      c_stmt               ::= c_async_with_stmt SETUP_ASYNC_WITH\\n                      async_with_stmt      ::= expr\\n                                               async_with_pre\\n                                               POP_TOP\\n                                               suite_stmts_opt\\n                                               POP_BLOCK LOAD_CONST\\n                                               async_with_post\\n                      c_async_with_stmt    ::= expr\\n                                               async_with_pre\\n                                               POP_TOP\\n                                               c_suite_stmts_opt\\n                                               POP_BLOCK LOAD_CONST\\n                                               async_with_post\\n                      async_with_stmt      ::= expr\\n                                               async_with_pre\\n                                               POP_TOP\\n                                               suite_stmts_opt\\n                                               async_with_post\\n                      c_async_with_stmt    ::= expr\\n                                               async_with_pre\\n                                               POP_TOP\\n                                               c_suite_stmts_opt\\n                                               async_with_post\\n                      async_with_as_stmt   ::= expr\\n                                               async_with_pre\\n                                               store\\n                                               suite_stmts_opt\\n                                               POP_BLOCK LOAD_CONST\\n                                               async_with_post\\n                      c_async_with_as_stmt ::= expr\\n                                              async_with_pre\\n                                              store\\n                                              c_suite_stmts_opt\\n                                              POP_BLOCK LOAD_CONST\\n                                              async_with_post\\n                      async_with_as_stmt   ::= expr\\n                                              async_with_pre\\n                                              store\\n                                              suite_stmts_opt\\n                                              async_with_post\\n                      c_async_with_as_stmt ::= expr\\n                                              async_with_pre\\n                                              store\\n                                              suite_stmts_opt\\n                                              async_with_post\\n                    '\n            else:\n                rules_str += '\\n                      async_with_pre       ::= BEFORE_ASYNC_WITH GET_AWAITABLE LOAD_CONST YIELD_FROM SETUP_ASYNC_WITH\\n                      async_with_post      ::= BEGIN_FINALLY COME_FROM_ASYNC_WITH\\n                                               WITH_CLEANUP_START GET_AWAITABLE LOAD_CONST YIELD_FROM\\n                                               WITH_CLEANUP_FINISH END_FINALLY\\n                      async_with_stmt      ::= expr\\n                                               async_with_pre\\n                                               POP_TOP\\n                                               suite_stmts\\n                                               POP_TOP POP_BLOCK\\n                                               async_with_post\\n                      c_async_with_stmt    ::= expr\\n                                               async_with_pre\\n                                               POP_TOP\\n                                               c_suite_stmts\\n                                               POP_TOP POP_BLOCK\\n                                               async_with_post\\n                      async_with_stmt      ::= expr\\n                                               async_with_pre\\n                                               POP_TOP\\n                                               suite_stmts\\n                                               POP_BLOCK\\n                                               BEGIN_FINALLY\\n                                               WITH_CLEANUP_START GET_AWAITABLE LOAD_CONST YIELD_FROM\\n                                               WITH_CLEANUP_FINISH POP_FINALLY LOAD_CONST RETURN_VALUE\\n                                               COME_FROM_ASYNC_WITH\\n                                               WITH_CLEANUP_START GET_AWAITABLE LOAD_CONST YIELD_FROM\\n                                               WITH_CLEANUP_FINISH END_FINALLY\\n                      c_async_with_stmt   ::= expr\\n                                              async_with_pre\\n                                              POP_TOP\\n                                              c_suite_stmts\\n                                              POP_BLOCK\\n                                              BEGIN_FINALLY\\n                                              WITH_CLEANUP_START GET_AWAITABLE LOAD_CONST YIELD_FROM\\n                                              WITH_CLEANUP_FINISH POP_FINALLY LOAD_CONST RETURN_VALUE\\n                                              COME_FROM_ASYNC_WITH\\n                                              WITH_CLEANUP_START GET_AWAITABLE LOAD_CONST YIELD_FROM\\n                                              WITH_CLEANUP_FINISH END_FINALLY\\n                      async_with_as_stmt   ::= expr\\n                                               async_with_pre\\n                                               store suite_stmts\\n                                               POP_TOP POP_BLOCK\\n                                               async_with_post\\n                      c_async_with_as_stmt ::= expr\\n                                               async_with_pre\\n                                               store suite_stmts\\n                                               POP_TOP POP_BLOCK\\n                                               async_with_post\\n                      async_with_as_stmt   ::= expr\\n                                               async_with_pre\\n                                               store suite_stmts\\n                                               POP_BLOCK async_with_post\\n                      c_async_with_as_stmt ::= expr\\n                                               async_with_pre\\n                                               store suite_stmts\\n                                               POP_BLOCK async_with_post\\n                    '\n            self.addRule(rules_str, nop_func)\n        elif opname in ('BUILD_CONST_LIST', 'BUILD_CONST_DICT', 'BUILD_CONST_SET'):\n            if opname == 'BUILD_CONST_DICT':\n                rule = f'\\n                            add_consts          ::= ADD_VALUE*\\n                            const_list          ::= COLLECTION_START add_consts {opname}\\n                            dict                ::= const_list\\n                            expr                ::= dict\\n                        '\n            else:\n                rule = f'\\n                            add_consts          ::= ADD_VALUE*\\n                            const_list          ::= COLLECTION_START add_consts {opname}\\n                            expr                ::= const_list\\n                        '\n            self.addRule(rule, nop_func)\n        elif opname_base == 'BUILD_CONST_KEY_MAP':\n            kvlist_n = 'expr ' * token.attr\n            rule = 'dict ::= %sLOAD_CONST %s' % (kvlist_n, opname)\n            self.addRule(rule, nop_func)\n        elif opname.startswith('BUILD_LIST_UNPACK'):\n            v = token.attr\n            rule = 'build_list_unpack ::= %s%s' % ('expr ' * v, opname)\n            self.addRule(rule, nop_func)\n            rule = 'expr ::= build_list_unpack'\n            self.addRule(rule, nop_func)\n        elif opname_base in ('BUILD_MAP', 'BUILD_MAP_UNPACK'):\n            if opname == 'BUILD_MAP_UNPACK':\n                self.addRule('\\n                        expr        ::= dict_unpack\\n                        dict_unpack ::= dict_comp BUILD_MAP_UNPACK\\n                        ', nop_func)\n                pass\n            elif opname.startswith('BUILD_MAP_UNPACK_WITH_CALL'):\n                v = token.attr\n                rule = 'build_map_unpack_with_call ::= %s%s' % ('expr ' * v, opname)\n                self.addRule(rule, nop_func)\n            kvlist_n = 'kvlist_%s' % token.attr\n            if opname == 'BUILD_MAP_n':\n                rule = 'dict_comp_func ::= BUILD_MAP_n LOAD_ARG for_iter store comp_iter JUMP_BACK RETURN_VALUE RETURN_LAST'\n                self.add_unique_rule(rule, 'dict_comp_func', 1, customize)\n                kvlist_n = 'kvlist_n'\n                rule = 'kvlist_n ::=  kvlist_n kv3'\n                self.add_unique_rule(rule, 'kvlist_n', 0, customize)\n                rule = 'kvlist_n ::='\n                self.add_unique_rule(rule, 'kvlist_n', 1, customize)\n                rule = 'dict ::=  BUILD_MAP_n kvlist_n'\n            if not opname.startswith('BUILD_MAP_WITH_CALL'):\n                if opname.startswith('BUILD_MAP_UNPACK'):\n                    if 'LOAD_DICTCOMP' in self.seen_ops:\n                        rule = 'dict ::= %s%s' % ('dict_comp ' * token.attr, opname)\n                        self.addRule(rule, nop_func)\n                    rule = '\\n                         expr        ::= dict_unpack\\n                         dict_unpack ::= %s%s\\n                         ' % ('expr ' * token.attr, opname)\n                else:\n                    rule = '%s ::= %s %s' % (kvlist_n, 'expr ' * (token.attr * 2), opname)\n                    self.add_unique_rule(rule, opname, token.attr, customize)\n                    rule = 'dict ::=  %s' % kvlist_n\n            self.add_unique_rule(rule, opname, token.attr, customize)\n        elif opname.startswith('BUILD_MAP_UNPACK_WITH_CALL'):\n            v = token.attr\n            rule = 'build_map_unpack_with_call ::= %s%s' % ('expr ' * v, opname)\n            self.addRule(rule, nop_func)\n        elif opname.startswith('BUILD_TUPLE_UNPACK_WITH_CALL'):\n            v = token.attr\n            rule = 'build_tuple_unpack_with_call ::= ' + 'expr1024 ' * int(v // 1024) + 'expr32 ' * int(v // 32 % 32) + 'expr ' * (v % 32) + opname\n            self.addRule(rule, nop_func)\n            rule = 'starred ::= %s %s' % ('expr ' * v, opname)\n            self.addRule(rule, nop_func)\n        elif opname_base in ('BUILD_LIST', 'BUILD_SET', 'BUILD_TUPLE', 'BUILD_TUPLE_UNPACK'):\n            collection_size = token.attr\n            is_LOAD_CLOSURE = False\n            if opname_base == 'BUILD_TUPLE':\n                is_LOAD_CLOSURE = True\n                for j in range(collection_size):\n                    if tokens[i - j - 1].kind != 'LOAD_CLOSURE':\n                        is_LOAD_CLOSURE = False\n                        break\n                if is_LOAD_CLOSURE:\n                    rule = 'load_closure ::= %s%s' % ('LOAD_CLOSURE ' * collection_size, opname)\n                    self.add_unique_rule(rule, opname, token.attr, customize)\n            if not is_LOAD_CLOSURE or collection_size == 0:\n                thousands = collection_size // 1024\n                thirty32s = collection_size // 32 % 32\n                if thirty32s > 0:\n                    rule = 'expr32 ::=%s' % (' expr' * 32)\n                    self.add_unique_rule(rule, opname_base, collection_size, customize)\n                    pass\n                if thousands > 0:\n                    self.add_unique_rule('expr1024 ::=%s' % (' expr32' * 32), opname_base, collection_size, customize)\n                    pass\n                collection = opname_base[opname_base.find('_') + 1:].lower()\n                rule = '%s ::= ' % collection + 'expr1024 ' * thousands + 'expr32 ' * thirty32s + 'expr ' * (collection_size % 32) + opname\n                self.add_unique_rules(['expr ::= %s' % collection, rule], customize)\n                continue\n            continue\n        elif opname_base == 'BUILD_SLICE':\n            if token.attr == 2:\n                self.add_unique_rules(['expr ::= slice2', 'slice2 ::= expr expr BUILD_SLICE_2'], customize)\n            else:\n                assert token.attr == 3, 'BUILD_SLICE value must be 2 or 3; is %s' % token.attr\n                self.add_unique_rules(['expr   ::= slice3', 'slice3 ::= expr expr expr BUILD_SLICE_3'], customize)\n        elif opname.startswith('BUILD_STRING'):\n            v = token.attr\n            rules_str = '\\n                    expr                 ::= joined_str\\n                    joined_str           ::= %sBUILD_STRING_%d\\n                ' % ('expr ' * v, v)\n            self.add_unique_doc_rules(rules_str, customize)\n            if 'FORMAT_VALUE_ATTR' in self.seen_ops:\n                rules_str = '\\n                      formatted_value_attr ::= expr expr FORMAT_VALUE_ATTR expr BUILD_STRING\\n                      expr                 ::= formatted_value_attr\\n                    '\n                self.add_unique_doc_rules(rules_str, customize)\n        elif opname in frozenset(('CALL_FUNCTION', 'CALL_FUNCTION_EX', 'CALL_FUNCTION_EX_KW', 'CALL_FUNCTION_VAR', 'CALL_FUNCTION_VAR_KW')) or opname.startswith('CALL_FUNCTION_KW'):\n            if opname == 'CALL_FUNCTION' and token.attr == 1:\n                rule = '\\n                     expr         ::= dict_comp\\n                     dict_comp    ::= LOAD_DICTCOMP LOAD_STR MAKE_FUNCTION_0 expr\\n                                      GET_ITER CALL_FUNCTION_1\\n                    classdefdeco1 ::= expr classdefdeco2 CALL_FUNCTION_1\\n                    classdefdeco1 ::= expr classdefdeco1 CALL_FUNCTION_1\\n                    '\n                self.addRule(rule, nop_func)\n            self.custom_classfunc_rule(opname, token, customize, tokens[i + 1])\n        elif opname_base == 'CALL_METHOD':\n            (args_pos, args_kw) = self.get_pos_kw(token)\n            if opname == 'CALL_METHOD_KW':\n                args_kw = token.attr\n                rules_str = '\\n                         expr ::= call_kw_pypy37\\n                         pypy_kw_keys ::= LOAD_CONST\\n                    '\n                self.add_unique_doc_rules(rules_str, customize)\n                rule = 'call_kw_pypy37 ::= expr ' + 'expr ' * args_kw + ' pypy_kw_keys ' + opname\n            else:\n                (args_pos, args_kw) = self.get_pos_kw(token)\n                nak = (len(opname_base) - len('CALL_METHOD')) // 3\n                rule = 'call ::= expr ' + 'pos_arg ' * args_pos + 'kwarg ' * args_kw + 'expr ' * nak + opname\n            self.add_unique_rule(rule, opname, token.attr, customize)\n        elif opname == 'CONTINUE':\n            self.addRule('continue ::= CONTINUE', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'CONTINUE_LOOP':\n            self.addRule('continue ::= CONTINUE_LOOP', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'DELETE_ATTR':\n            self.addRule('delete ::= expr DELETE_ATTR', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'DELETE_DEREF':\n            self.addRule('\\n                   stmt           ::= del_deref_stmt\\n                   del_deref_stmt ::= DELETE_DEREF\\n                   ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'DELETE_SUBSCR':\n            self.addRule('\\n                    delete ::= delete_subscript\\n                    delete_subscript ::= expr expr DELETE_SUBSCR\\n                   ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'FORMAT_VALUE':\n            rules_str = '\\n                    expr              ::= formatted_value1\\n                    formatted_value1  ::= expr FORMAT_VALUE\\n                '\n            self.add_unique_doc_rules(rules_str, customize)\n        elif opname == 'GET_ANEXT':\n            self.addRule('\\n                    func_async_prefix   ::= _come_froms SETUP_FINALLY GET_ANEXT LOAD_CONST YIELD_FROM POP_BLOCK\\n                    func_async_middle   ::= JUMP_FORWARD COME_FROM_EXCEPT\\n                                            DUP_TOP LOAD_GLOBAL COMPARE_OP POP_JUMP_IF_TRUE\\n                    list_afor2          ::= func_async_prefix\\n                                            store list_iter\\n                                            JUMP_BACK COME_FROM_FINALLY\\n                                            END_ASYNC_FOR\\n                   ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'FORMAT_VALUE_ATTR':\n            rules_str = '\\n                expr              ::= formatted_value2\\n                formatted_value2  ::= expr expr FORMAT_VALUE_ATTR\\n                '\n            self.add_unique_doc_rules(rules_str, customize)\n        elif opname == 'GET_ITER':\n            self.addRule('\\n                    expr      ::= get_iter\\n                    get_iter  ::= expr GET_ITER\\n                    ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'GET_AITER':\n            self.addRule('\\n                    expr                ::= generator_exp_async\\n                    generator_exp_async ::= load_genexpr LOAD_STR MAKE_FUNCTION_0 expr\\n                                            GET_AITER CALL_FUNCTION_1\\n\\n                    stmt                ::= genexpr_func_async\\n\\n                    func_async_prefix   ::= _come_froms SETUP_EXCEPT GET_ANEXT LOAD_CONST YIELD_FROM\\n                    func_async_middle   ::= POP_BLOCK JUMP_FORWARD COME_FROM_EXCEPT\\n                                            DUP_TOP LOAD_GLOBAL COMPARE_OP POP_JUMP_IF_TRUE\\n                                            END_FINALLY COME_FROM\\n                    genexpr_func_async  ::= LOAD_ARG func_async_prefix\\n                                            store func_async_middle comp_iter\\n                                            JUMP_BACK COME_FROM\\n                                            POP_TOP POP_TOP POP_TOP POP_EXCEPT POP_TOP\\n\\n                    expr                ::= list_comp_async\\n                    list_comp_async     ::= LOAD_LISTCOMP LOAD_STR MAKE_FUNCTION_0\\n                                            expr GET_AITER CALL_FUNCTION_1\\n                                            GET_AWAITABLE LOAD_CONST\\n                                            YIELD_FROM\\n\\n                    expr                ::= list_comp_async\\n                    list_afor2          ::= func_async_prefix\\n                                            store func_async_middle list_iter\\n                                            JUMP_BACK COME_FROM\\n                                            POP_TOP POP_TOP POP_TOP POP_EXCEPT POP_TOP\\n                    list_comp_async     ::= BUILD_LIST_0 LOAD_ARG list_afor2\\n                    get_aiter           ::= expr GET_AITER\\n                    list_afor           ::= get_aiter list_afor2\\n                    list_iter           ::= list_afor\\n                   ', nop_func)\n        elif opname == 'JUMP_IF_NOT_DEBUG':\n            v = token.attr\n            self.addRule('\\n                    stmt        ::= assert_pypy\\n                    stmt        ::= assert2_pypy\", nop_func)\\n                    assert_pypy ::=  JUMP_IF_NOT_DEBUG expr jmp_true\\n                                     LOAD_ASSERT RAISE_VARARGS_1 COME_FROM\\n                    assert2_pypy ::= JUMP_IF_NOT_DEBUG assert_expr jmp_true\\n                                     LOAD_ASSERT expr CALL_FUNCTION_1\\n                                     RAISE_VARARGS_1 COME_FROM\\n                    assert2_pypy ::= JUMP_IF_NOT_DEBUG expr jmp_true\\n                                     LOAD_ASSERT expr CALL_FUNCTION_1\\n                                     RAISE_VARARGS_1 COME_FROM,\\n                    ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'LOAD_BUILD_CLASS':\n            self.custom_build_class_rule(opname, i, token, tokens, customize)\n        elif opname == 'LOAD_CLASSDEREF':\n            self.addRule('expr ::= LOAD_CLASSDEREF', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'LOAD_CLASSNAME':\n            self.addRule('expr ::= LOAD_CLASSNAME', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'LOAD_DICTCOMP':\n            if has_get_iter_call_function1:\n                rule_pat = 'dict_comp ::= LOAD_DICTCOMP %sMAKE_FUNCTION_0 expr GET_ITER CALL_FUNCTION_1'\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                pass\n            custom_ops_processed.add(opname)\n        elif opname == 'LOAD_ATTR':\n            self.addRule('\\n                  expr      ::= attribute\\n                  attribute ::= expr LOAD_ATTR\\n                  ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'LOAD_LISTCOMP':\n            self.add_unique_rule('expr ::= listcomp', opname, token.attr, customize)\n            custom_ops_processed.add(opname)\n        elif opname == 'LOAD_NAME':\n            if token.attr == '__annotations__' and 'SETUP_ANNOTATIONS' in self.seen_ops:\n                token.kind = 'LOAD_ANNOTATION'\n                self.addRule('\\n                        stmt       ::= SETUP_ANNOTATIONS\\n                        stmt       ::= ann_assign\\n                        ann_assign ::= expr LOAD_ANNOTATION LOAD_STR STORE_SUBSCR\\n                        ', nop_func)\n                pass\n        elif opname == 'LOAD_SETCOMP':\n            if has_get_iter_call_function1:\n                self.addRule('expr ::= set_comp', nop_func)\n                rule_pat = 'set_comp ::= LOAD_SETCOMP %sMAKE_FUNCTION_0 expr GET_ITER CALL_FUNCTION_1'\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                pass\n            custom_ops_processed.add(opname)\n        elif opname == 'LOOKUP_METHOD':\n            self.addRule('\\n                             expr      ::= attribute\\n                             attribute ::= expr LOOKUP_METHOD\\n                             ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname.startswith('MAKE_CLOSURE'):\n            if opname == 'MAKE_CLOSURE_0' and 'LOAD_DICTCOMP' in self.seen_ops:\n                rule = '\\n                        dict_comp ::= load_closure LOAD_DICTCOMP LOAD_STR\\n                                      MAKE_CLOSURE_0 expr\\n                                      GET_ITER CALL_FUNCTION_1\\n                    '\n                self.addRule(rule, nop_func)\n            (args_pos, args_kw, annotate_args) = token.attr\n            j = 2\n            if is_pypy or (i >= j and tokens[i - j] == 'LOAD_LAMBDA'):\n                rule_pat = 'lambda_body ::= %sload_closure LOAD_LAMBDA %%s%s' % ('pos_arg ' * args_pos, opname)\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n            if has_get_iter_call_function1:\n                rule_pat = 'generator_exp ::= %sload_closure load_genexpr %%s%s expr GET_ITER CALL_FUNCTION_1' % ('pos_arg ' * args_pos, opname)\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                if has_get_iter_call_function1:\n                    if is_pypy or (i >= j and tokens[i - j] == 'LOAD_LISTCOMP'):\n                        rule_pat = 'listcomp ::= %sload_closure LOAD_LISTCOMP %%s%s expr GET_ITER CALL_FUNCTION_1' % ('pos_arg ' * args_pos, opname)\n                        self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                    if is_pypy or (i >= j and tokens[i - j] == 'LOAD_SETCOMP'):\n                        rule_pat = 'set_comp ::= %sload_closure LOAD_SETCOMP %%s%s expr GET_ITER CALL_FUNCTION_1' % ('pos_arg ' * args_pos, opname)\n                        self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                    if is_pypy or (i >= j and tokens[i - j] == 'LOAD_DICTCOMP'):\n                        self.add_unique_rule('dict_comp ::= %sload_closure LOAD_DICTCOMP %s expr GET_ITER CALL_FUNCTION_1' % ('pos_arg ' * args_pos, opname), opname, token.attr, customize)\n            if args_kw > 0:\n                kwargs_str = 'kwargs '\n            else:\n                kwargs_str = ''\n            rule = 'mkfunc ::= %s%s%s load_closure LOAD_CODE LOAD_STR %s' % ('expr ' * args_pos, kwargs_str, 'expr ' * annotate_args, opname)\n            self.add_unique_rule(rule, opname, token.attr, customize)\n            if args_kw == 0:\n                rule = 'mkfunc ::= %sload_closure load_genexpr %s' % ('pos_arg ' * args_pos, opname)\n                self.add_unique_rule(rule, opname, token.attr, customize)\n            pass\n        elif opname_base.startswith('MAKE_FUNCTION'):\n            (args_pos, args_kw, annotate_args, closure) = token.attr\n            stack_count = args_pos + args_kw + annotate_args\n            if closure:\n                if args_pos:\n                    rule = 'lambda_body ::= %s%s%s%s' % ('expr ' * stack_count, 'load_closure ' * closure, 'BUILD_TUPLE_1 LOAD_LAMBDA LOAD_STR ', opname)\n                else:\n                    rule = 'lambda_body ::= %s%s%s' % ('load_closure ' * closure, 'LOAD_LAMBDA LOAD_STR ', opname)\n                self.add_unique_rule(rule, opname, token.attr, customize)\n            else:\n                rule = 'lambda_body ::= %sLOAD_LAMBDA LOAD_STR %s' % ('expr ' * stack_count, opname)\n                self.add_unique_rule(rule, opname, token.attr, customize)\n            rule = 'mkfunc ::= %s%s%s%s' % ('expr ' * stack_count, 'load_closure ' * closure, 'LOAD_CODE LOAD_STR ', opname)\n            self.add_unique_rule(rule, opname, token.attr, customize)\n            if has_get_iter_call_function1:\n                rule_pat = 'generator_exp ::= %sload_genexpr %%s%s expr GET_ITER CALL_FUNCTION_1' % ('pos_arg ' * args_pos, opname)\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                rule_pat = 'generator_exp ::= %sload_closure load_genexpr %%s%s expr GET_ITER CALL_FUNCTION_1' % ('pos_arg ' * args_pos, opname)\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                if is_pypy or (i >= 2 and tokens[i - 2] == 'LOAD_LISTCOMP'):\n                    rule_pat = 'listcomp ::= load_closure LOAD_LISTCOMP %%s%s expr GET_ITER CALL_FUNCTION_1' % (opname,)\n                    self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                    rule_pat = 'listcomp ::= %sLOAD_LISTCOMP %%s%s expr GET_ITER CALL_FUNCTION_1' % ('expr ' * args_pos, opname)\n                    self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n            if is_pypy or (i >= 2 and tokens[i - 2] == 'LOAD_LAMBDA'):\n                rule_pat = 'lambda_body ::= %s%sLOAD_LAMBDA %%s%s' % ('pos_arg ' * args_pos, 'kwarg ' * args_kw, opname)\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n            continue\n            (args_pos, args_kw, annotate_args, closure) = token.attr\n            j = 2\n            if has_get_iter_call_function1:\n                rule_pat = 'generator_exp ::= %sload_genexpr %%s%s expr GET_ITER CALL_FUNCTION_1' % ('pos_arg ' * args_pos, opname)\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                if is_pypy or (i >= j and tokens[i - j] == 'LOAD_LISTCOMP'):\n                    rule_pat = 'listcomp ::= %sLOAD_LISTCOMP %%s%s expr GET_ITER CALL_FUNCTION_1' % ('expr ' * args_pos, opname)\n                    self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n            if is_pypy or (i >= j and tokens[i - j] == 'LOAD_LAMBDA'):\n                rule_pat = 'lambda_body ::= %s%sLOAD_LAMBDA %%s%s' % ('pos_arg ' * args_pos, 'kwarg ' * args_kw, opname)\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n            if args_kw == 0:\n                kwargs = 'no_kwargs'\n                self.add_unique_rule('no_kwargs ::=', opname, token.attr, customize)\n            else:\n                kwargs = 'kwargs'\n            rule = 'mkfunc ::= %s%s %s%s' % ('pos_arg ' * args_pos, kwargs, 'LOAD_CODE LOAD_STR ', opname)\n            self.add_unique_rule(rule, opname, token.attr, customize)\n        elif opname == 'MAKE_FUNCTION_CLOSURE':\n            if 'LOAD_DICTCOMP' in self.seen_ops:\n                rule = '\\n                       dict_comp ::= load_closure LOAD_DICTCOMP LOAD_STR\\n                                     MAKE_FUNCTION_CLOSURE expr\\n                                     GET_ITER CALL_FUNCTION_1\\n                       '\n                self.addRule(rule, nop_func)\n            elif 'LOAD_SETCOMP' in self.seen_ops:\n                rule = '\\n                       set_comp ::= load_closure LOAD_SETCOMP LOAD_STR\\n                                    MAKE_FUNCTION_CLOSURE expr\\n                                    GET_ITER CALL_FUNCTION_1\\n                       '\n                self.addRule(rule, nop_func)\n        elif opname == 'RETURN_VALUE_LAMBDA':\n            self.addRule('\\n                    return_expr_lambda ::= return_expr RETURN_VALUE_LAMBDA\\n                    ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'RAISE_VARARGS_0':\n            self.addRule('\\n                    stmt        ::= raise_stmt0\\n                    raise_stmt0 ::= RAISE_VARARGS_0\\n                    ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'RAISE_VARARGS_1':\n            self.addRule('\\n                    stmt        ::= raise_stmt1\\n                    raise_stmt1 ::= expr RAISE_VARARGS_1\\n                    ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'RAISE_VARARGS_2':\n            self.addRule('\\n                    stmt        ::= raise_stmt2\\n                    raise_stmt2 ::= expr expr RAISE_VARARGS_2\\n                    ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'SETUP_EXCEPT':\n            self.addRule('\\n                    try_except     ::= SETUP_EXCEPT suite_stmts_opt POP_BLOCK\\n                                       except_handler opt_come_from_except\\n\\n                    tryelsestmt    ::= SETUP_EXCEPT suite_stmts_opt POP_BLOCK\\n                                       except_handler else_suite come_from_except_clauses\\n\\n                    tryelsestmt    ::= SETUP_EXCEPT suite_stmts_opt POP_BLOCK\\n                                       except_handler else_suite come_froms\\n\\n                    tryelsestmtl   ::= SETUP_EXCEPT suite_stmts_opt POP_BLOCK\\n                                       except_handler else_suitel come_from_except_clauses\\n\\n                    stmt             ::= tryelsestmtl3\\n                    tryelsestmtl3    ::= SETUP_EXCEPT suite_stmts_opt POP_BLOCK\\n                                         except_handler COME_FROM else_suitel\\n                                         opt_come_from_except\\n                    ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'WITH_CLEANUP_START':\n            rules_str = '\\n                  stmt        ::= with_null\\n                  with_null   ::= with_suffix\\n                  with_suffix ::= WITH_CLEANUP_START WITH_CLEANUP_FINISH END_FINALLY\\n                '\n            self.addRule(rules_str, nop_func)\n        elif opname == 'SETUP_WITH':\n            rules_str = '\\n                  stmt       ::= with\\n                  stmt       ::= withasstmt\\n\\n                  with       ::= expr\\n                                 SETUP_WITH POP_TOP\\n                                 suite_stmts_opt\\n                                 COME_FROM_WITH\\n                                 with_suffix\\n                  withasstmt ::= expr SETUP_WITH store suite_stmts_opt COME_FROM_WITH\\n                                 with_suffix\\n\\n                  with       ::= expr\\n                                 SETUP_WITH POP_TOP\\n                                 suite_stmts_opt\\n                                 POP_BLOCK LOAD_CONST COME_FROM_WITH\\n                                 with_suffix\\n\\n                  withasstmt ::= expr\\n                                 SETUP_WITH store suite_stmts_opt\\n                                 POP_BLOCK LOAD_CONST COME_FROM_WITH\\n                                 with_suffix\\n\\n                  with       ::= expr\\n                                 SETUP_WITH POP_TOP suite_stmts_opt\\n                                 POP_BLOCK LOAD_CONST COME_FROM_WITH\\n                                 with_suffix\\n                  withasstmt ::= expr\\n                                 SETUP_WITH store suite_stmts_opt\\n                                 POP_BLOCK LOAD_CONST COME_FROM_WITH\\n                                 with_suffix\\n                '\n            if self.version < (3, 8):\n                rules_str += '\\n                    with     ::= expr SETUP_WITH POP_TOP suite_stmts_opt POP_BLOCK\\n                                   LOAD_CONST\\n                                   with_suffix\\n                    '\n            else:\n                rules_str += '\\n                      with       ::= expr\\n                                     SETUP_WITH POP_TOP suite_stmts_opt\\n                                     POP_BLOCK LOAD_CONST COME_FROM_WITH\\n                                     with_suffix\\n\\n                      withasstmt ::= expr\\n                                     SETUP_WITH store suite_stmts_opt\\n                                     POP_BLOCK LOAD_CONST COME_FROM_WITH\\n\\n                      withasstmt ::= expr\\n                                     SETUP_WITH store suite_stmts\\n                                     POP_BLOCK BEGIN_FINALLY COME_FROM_WITH with_suffix\\n\\n                      with       ::= expr SETUP_WITH POP_TOP suite_stmts_opt POP_BLOCK\\n                                     BEGIN_FINALLY COME_FROM_WITH\\n                                     with_suffix\\n                    '\n            self.addRule(rules_str, nop_func)\n        elif opname_base in ('UNPACK_EX',):\n            (before_count, after_count) = token.attr\n            rule = 'unpack ::= ' + opname + ' store' * (before_count + after_count + 1)\n            self.addRule(rule, nop_func)\n        elif opname_base in ('UNPACK_TUPLE', 'UNPACK_SEQUENCE'):\n            rule = 'unpack ::= ' + opname + ' store' * token.attr\n            self.addRule(rule, nop_func)\n        elif opname_base == 'UNPACK_LIST':\n            rule = 'unpack_list ::= ' + opname + ' store' * token.attr\n            self.addRule(rule, nop_func)\n            custom_ops_processed.add(opname)\n            pass\n        pass\n    self.reduce_check_table = {'_ifstmts_jump': ifstmts_jump, 'and': and_invalid, 'ifelsestmt': ifelsestmt, 'ifelsestmtl': ifelsestmt, 'iflaststmt': iflaststmt, 'iflaststmtl': iflaststmt, 'ifstmt': ifstmt, 'ifstmtl': ifstmt, 'or': or_check, 'testtrue': testtrue, 'testfalsel': testtrue, 'while1elsestmt': while1elsestmt, 'while1stmt': while1stmt, 'try_elsestmtl38': tryelsestmtl3}\n    self.check_reduce['and'] = 'AST'\n    self.check_reduce['annotate_tuple'] = 'noAST'\n    self.check_reduce['aug_assign1'] = 'AST'\n    self.check_reduce['aug_assign2'] = 'AST'\n    self.check_reduce['while1stmt'] = 'noAST'\n    self.check_reduce['while1elsestmt'] = 'noAST'\n    self.check_reduce['_ifstmts_jump'] = 'AST'\n    self.check_reduce['import_as37'] = 'tokens'\n    self.check_reduce['import_from_as37'] = 'tokens'\n    self.check_reduce['import_from_as37'] = 'tokens'\n    self.check_reduce['ifelsestmt'] = 'AST'\n    self.check_reduce['ifelsestmtl'] = 'AST'\n    self.check_reduce['iflaststmt'] = 'AST'\n    self.check_reduce['iflaststmtl'] = 'AST'\n    self.check_reduce['ifstmt'] = 'AST'\n    self.check_reduce['ifstmtl'] = 'AST'\n    self.check_reduce['import_from37'] = 'AST'\n    self.check_reduce['or'] = 'AST'\n    self.check_reduce['testtrue'] = 'tokens'\n    self.check_reduce['testfalsel'] = 'tokens'\n    return",
            "def customize_grammar_rules(self, tokens, customize):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    is_pypy = False\n    customize_instruction_basenames = frozenset(('BEFORE', 'BUILD', 'CALL', 'CONTINUE', 'DELETE', 'FORMAT', 'GET', 'JUMP', 'LOAD', 'LOOKUP', 'MAKE', 'RETURN', 'RAISE', 'SETUP', 'UNPACK', 'WITH'))\n    custom_ops_processed = set(('BUILD_TUPLE_UNPACK_WITH_CALL',))\n    self.seen_ops = frozenset([t.kind for t in tokens])\n    self.seen_op_basenames = frozenset([opname[:opname.rfind('_')] for opname in self.seen_ops])\n    if 'PyPy' in customize:\n        is_pypy = True\n        self.addRule('\\n              stmt ::= assign3_pypy\\n              stmt ::= assign2_pypy\\n              assign3_pypy       ::= expr expr expr store store store\\n              assign2_pypy       ::= expr expr store store\\n              stmt               ::= if_exp_lambda\\n              stmt               ::= if_exp_not_lambda\\n              if_exp_lambda      ::= expr jmp_false expr return_if_lambda\\n                                     return_expr_lambda LAMBDA_MARKER\\n              if_exp_not_lambda  ::= expr jmp_true expr return_if_lambda\\n                                     return_expr_lambda LAMBDA_MARKER\\n              ', nop_func)\n    n = len(tokens)\n    has_get_iter_call_function1 = False\n    for (i, token) in enumerate(tokens):\n        if token == 'GET_ITER' and i < n - 2 and (self.call_fn_name(tokens[i + 1]) == 'CALL_FUNCTION_1'):\n            has_get_iter_call_function1 = True\n    for (i, token) in enumerate(tokens):\n        opname = token.kind\n        if opname[:opname.find('_')] not in customize_instruction_basenames or opname in custom_ops_processed:\n            continue\n        opname_base = opname[:opname.rfind('_')]\n        if opname == 'LOAD_ASSERT' and 'PyPy' in customize:\n            rules_str = '\\n                stmt ::= JUMP_IF_NOT_DEBUG stmts COME_FROM\\n                '\n            self.add_unique_doc_rules(rules_str, customize)\n        elif opname == 'BEFORE_ASYNC_WITH':\n            rules_str = '\\n                   stmt            ::= async_with_stmt\\n                   stmt            ::= async_with_as_stmt\\n                '\n            if self.version < (3, 8):\n                rules_str += '\\n                      stmt                 ::= async_with_stmt SETUP_ASYNC_WITH\\n                      c_stmt               ::= c_async_with_stmt SETUP_ASYNC_WITH\\n                      async_with_stmt      ::= expr\\n                                               async_with_pre\\n                                               POP_TOP\\n                                               suite_stmts_opt\\n                                               POP_BLOCK LOAD_CONST\\n                                               async_with_post\\n                      c_async_with_stmt    ::= expr\\n                                               async_with_pre\\n                                               POP_TOP\\n                                               c_suite_stmts_opt\\n                                               POP_BLOCK LOAD_CONST\\n                                               async_with_post\\n                      async_with_stmt      ::= expr\\n                                               async_with_pre\\n                                               POP_TOP\\n                                               suite_stmts_opt\\n                                               async_with_post\\n                      c_async_with_stmt    ::= expr\\n                                               async_with_pre\\n                                               POP_TOP\\n                                               c_suite_stmts_opt\\n                                               async_with_post\\n                      async_with_as_stmt   ::= expr\\n                                               async_with_pre\\n                                               store\\n                                               suite_stmts_opt\\n                                               POP_BLOCK LOAD_CONST\\n                                               async_with_post\\n                      c_async_with_as_stmt ::= expr\\n                                              async_with_pre\\n                                              store\\n                                              c_suite_stmts_opt\\n                                              POP_BLOCK LOAD_CONST\\n                                              async_with_post\\n                      async_with_as_stmt   ::= expr\\n                                              async_with_pre\\n                                              store\\n                                              suite_stmts_opt\\n                                              async_with_post\\n                      c_async_with_as_stmt ::= expr\\n                                              async_with_pre\\n                                              store\\n                                              suite_stmts_opt\\n                                              async_with_post\\n                    '\n            else:\n                rules_str += '\\n                      async_with_pre       ::= BEFORE_ASYNC_WITH GET_AWAITABLE LOAD_CONST YIELD_FROM SETUP_ASYNC_WITH\\n                      async_with_post      ::= BEGIN_FINALLY COME_FROM_ASYNC_WITH\\n                                               WITH_CLEANUP_START GET_AWAITABLE LOAD_CONST YIELD_FROM\\n                                               WITH_CLEANUP_FINISH END_FINALLY\\n                      async_with_stmt      ::= expr\\n                                               async_with_pre\\n                                               POP_TOP\\n                                               suite_stmts\\n                                               POP_TOP POP_BLOCK\\n                                               async_with_post\\n                      c_async_with_stmt    ::= expr\\n                                               async_with_pre\\n                                               POP_TOP\\n                                               c_suite_stmts\\n                                               POP_TOP POP_BLOCK\\n                                               async_with_post\\n                      async_with_stmt      ::= expr\\n                                               async_with_pre\\n                                               POP_TOP\\n                                               suite_stmts\\n                                               POP_BLOCK\\n                                               BEGIN_FINALLY\\n                                               WITH_CLEANUP_START GET_AWAITABLE LOAD_CONST YIELD_FROM\\n                                               WITH_CLEANUP_FINISH POP_FINALLY LOAD_CONST RETURN_VALUE\\n                                               COME_FROM_ASYNC_WITH\\n                                               WITH_CLEANUP_START GET_AWAITABLE LOAD_CONST YIELD_FROM\\n                                               WITH_CLEANUP_FINISH END_FINALLY\\n                      c_async_with_stmt   ::= expr\\n                                              async_with_pre\\n                                              POP_TOP\\n                                              c_suite_stmts\\n                                              POP_BLOCK\\n                                              BEGIN_FINALLY\\n                                              WITH_CLEANUP_START GET_AWAITABLE LOAD_CONST YIELD_FROM\\n                                              WITH_CLEANUP_FINISH POP_FINALLY LOAD_CONST RETURN_VALUE\\n                                              COME_FROM_ASYNC_WITH\\n                                              WITH_CLEANUP_START GET_AWAITABLE LOAD_CONST YIELD_FROM\\n                                              WITH_CLEANUP_FINISH END_FINALLY\\n                      async_with_as_stmt   ::= expr\\n                                               async_with_pre\\n                                               store suite_stmts\\n                                               POP_TOP POP_BLOCK\\n                                               async_with_post\\n                      c_async_with_as_stmt ::= expr\\n                                               async_with_pre\\n                                               store suite_stmts\\n                                               POP_TOP POP_BLOCK\\n                                               async_with_post\\n                      async_with_as_stmt   ::= expr\\n                                               async_with_pre\\n                                               store suite_stmts\\n                                               POP_BLOCK async_with_post\\n                      c_async_with_as_stmt ::= expr\\n                                               async_with_pre\\n                                               store suite_stmts\\n                                               POP_BLOCK async_with_post\\n                    '\n            self.addRule(rules_str, nop_func)\n        elif opname in ('BUILD_CONST_LIST', 'BUILD_CONST_DICT', 'BUILD_CONST_SET'):\n            if opname == 'BUILD_CONST_DICT':\n                rule = f'\\n                            add_consts          ::= ADD_VALUE*\\n                            const_list          ::= COLLECTION_START add_consts {opname}\\n                            dict                ::= const_list\\n                            expr                ::= dict\\n                        '\n            else:\n                rule = f'\\n                            add_consts          ::= ADD_VALUE*\\n                            const_list          ::= COLLECTION_START add_consts {opname}\\n                            expr                ::= const_list\\n                        '\n            self.addRule(rule, nop_func)\n        elif opname_base == 'BUILD_CONST_KEY_MAP':\n            kvlist_n = 'expr ' * token.attr\n            rule = 'dict ::= %sLOAD_CONST %s' % (kvlist_n, opname)\n            self.addRule(rule, nop_func)\n        elif opname.startswith('BUILD_LIST_UNPACK'):\n            v = token.attr\n            rule = 'build_list_unpack ::= %s%s' % ('expr ' * v, opname)\n            self.addRule(rule, nop_func)\n            rule = 'expr ::= build_list_unpack'\n            self.addRule(rule, nop_func)\n        elif opname_base in ('BUILD_MAP', 'BUILD_MAP_UNPACK'):\n            if opname == 'BUILD_MAP_UNPACK':\n                self.addRule('\\n                        expr        ::= dict_unpack\\n                        dict_unpack ::= dict_comp BUILD_MAP_UNPACK\\n                        ', nop_func)\n                pass\n            elif opname.startswith('BUILD_MAP_UNPACK_WITH_CALL'):\n                v = token.attr\n                rule = 'build_map_unpack_with_call ::= %s%s' % ('expr ' * v, opname)\n                self.addRule(rule, nop_func)\n            kvlist_n = 'kvlist_%s' % token.attr\n            if opname == 'BUILD_MAP_n':\n                rule = 'dict_comp_func ::= BUILD_MAP_n LOAD_ARG for_iter store comp_iter JUMP_BACK RETURN_VALUE RETURN_LAST'\n                self.add_unique_rule(rule, 'dict_comp_func', 1, customize)\n                kvlist_n = 'kvlist_n'\n                rule = 'kvlist_n ::=  kvlist_n kv3'\n                self.add_unique_rule(rule, 'kvlist_n', 0, customize)\n                rule = 'kvlist_n ::='\n                self.add_unique_rule(rule, 'kvlist_n', 1, customize)\n                rule = 'dict ::=  BUILD_MAP_n kvlist_n'\n            if not opname.startswith('BUILD_MAP_WITH_CALL'):\n                if opname.startswith('BUILD_MAP_UNPACK'):\n                    if 'LOAD_DICTCOMP' in self.seen_ops:\n                        rule = 'dict ::= %s%s' % ('dict_comp ' * token.attr, opname)\n                        self.addRule(rule, nop_func)\n                    rule = '\\n                         expr        ::= dict_unpack\\n                         dict_unpack ::= %s%s\\n                         ' % ('expr ' * token.attr, opname)\n                else:\n                    rule = '%s ::= %s %s' % (kvlist_n, 'expr ' * (token.attr * 2), opname)\n                    self.add_unique_rule(rule, opname, token.attr, customize)\n                    rule = 'dict ::=  %s' % kvlist_n\n            self.add_unique_rule(rule, opname, token.attr, customize)\n        elif opname.startswith('BUILD_MAP_UNPACK_WITH_CALL'):\n            v = token.attr\n            rule = 'build_map_unpack_with_call ::= %s%s' % ('expr ' * v, opname)\n            self.addRule(rule, nop_func)\n        elif opname.startswith('BUILD_TUPLE_UNPACK_WITH_CALL'):\n            v = token.attr\n            rule = 'build_tuple_unpack_with_call ::= ' + 'expr1024 ' * int(v // 1024) + 'expr32 ' * int(v // 32 % 32) + 'expr ' * (v % 32) + opname\n            self.addRule(rule, nop_func)\n            rule = 'starred ::= %s %s' % ('expr ' * v, opname)\n            self.addRule(rule, nop_func)\n        elif opname_base in ('BUILD_LIST', 'BUILD_SET', 'BUILD_TUPLE', 'BUILD_TUPLE_UNPACK'):\n            collection_size = token.attr\n            is_LOAD_CLOSURE = False\n            if opname_base == 'BUILD_TUPLE':\n                is_LOAD_CLOSURE = True\n                for j in range(collection_size):\n                    if tokens[i - j - 1].kind != 'LOAD_CLOSURE':\n                        is_LOAD_CLOSURE = False\n                        break\n                if is_LOAD_CLOSURE:\n                    rule = 'load_closure ::= %s%s' % ('LOAD_CLOSURE ' * collection_size, opname)\n                    self.add_unique_rule(rule, opname, token.attr, customize)\n            if not is_LOAD_CLOSURE or collection_size == 0:\n                thousands = collection_size // 1024\n                thirty32s = collection_size // 32 % 32\n                if thirty32s > 0:\n                    rule = 'expr32 ::=%s' % (' expr' * 32)\n                    self.add_unique_rule(rule, opname_base, collection_size, customize)\n                    pass\n                if thousands > 0:\n                    self.add_unique_rule('expr1024 ::=%s' % (' expr32' * 32), opname_base, collection_size, customize)\n                    pass\n                collection = opname_base[opname_base.find('_') + 1:].lower()\n                rule = '%s ::= ' % collection + 'expr1024 ' * thousands + 'expr32 ' * thirty32s + 'expr ' * (collection_size % 32) + opname\n                self.add_unique_rules(['expr ::= %s' % collection, rule], customize)\n                continue\n            continue\n        elif opname_base == 'BUILD_SLICE':\n            if token.attr == 2:\n                self.add_unique_rules(['expr ::= slice2', 'slice2 ::= expr expr BUILD_SLICE_2'], customize)\n            else:\n                assert token.attr == 3, 'BUILD_SLICE value must be 2 or 3; is %s' % token.attr\n                self.add_unique_rules(['expr   ::= slice3', 'slice3 ::= expr expr expr BUILD_SLICE_3'], customize)\n        elif opname.startswith('BUILD_STRING'):\n            v = token.attr\n            rules_str = '\\n                    expr                 ::= joined_str\\n                    joined_str           ::= %sBUILD_STRING_%d\\n                ' % ('expr ' * v, v)\n            self.add_unique_doc_rules(rules_str, customize)\n            if 'FORMAT_VALUE_ATTR' in self.seen_ops:\n                rules_str = '\\n                      formatted_value_attr ::= expr expr FORMAT_VALUE_ATTR expr BUILD_STRING\\n                      expr                 ::= formatted_value_attr\\n                    '\n                self.add_unique_doc_rules(rules_str, customize)\n        elif opname in frozenset(('CALL_FUNCTION', 'CALL_FUNCTION_EX', 'CALL_FUNCTION_EX_KW', 'CALL_FUNCTION_VAR', 'CALL_FUNCTION_VAR_KW')) or opname.startswith('CALL_FUNCTION_KW'):\n            if opname == 'CALL_FUNCTION' and token.attr == 1:\n                rule = '\\n                     expr         ::= dict_comp\\n                     dict_comp    ::= LOAD_DICTCOMP LOAD_STR MAKE_FUNCTION_0 expr\\n                                      GET_ITER CALL_FUNCTION_1\\n                    classdefdeco1 ::= expr classdefdeco2 CALL_FUNCTION_1\\n                    classdefdeco1 ::= expr classdefdeco1 CALL_FUNCTION_1\\n                    '\n                self.addRule(rule, nop_func)\n            self.custom_classfunc_rule(opname, token, customize, tokens[i + 1])\n        elif opname_base == 'CALL_METHOD':\n            (args_pos, args_kw) = self.get_pos_kw(token)\n            if opname == 'CALL_METHOD_KW':\n                args_kw = token.attr\n                rules_str = '\\n                         expr ::= call_kw_pypy37\\n                         pypy_kw_keys ::= LOAD_CONST\\n                    '\n                self.add_unique_doc_rules(rules_str, customize)\n                rule = 'call_kw_pypy37 ::= expr ' + 'expr ' * args_kw + ' pypy_kw_keys ' + opname\n            else:\n                (args_pos, args_kw) = self.get_pos_kw(token)\n                nak = (len(opname_base) - len('CALL_METHOD')) // 3\n                rule = 'call ::= expr ' + 'pos_arg ' * args_pos + 'kwarg ' * args_kw + 'expr ' * nak + opname\n            self.add_unique_rule(rule, opname, token.attr, customize)\n        elif opname == 'CONTINUE':\n            self.addRule('continue ::= CONTINUE', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'CONTINUE_LOOP':\n            self.addRule('continue ::= CONTINUE_LOOP', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'DELETE_ATTR':\n            self.addRule('delete ::= expr DELETE_ATTR', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'DELETE_DEREF':\n            self.addRule('\\n                   stmt           ::= del_deref_stmt\\n                   del_deref_stmt ::= DELETE_DEREF\\n                   ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'DELETE_SUBSCR':\n            self.addRule('\\n                    delete ::= delete_subscript\\n                    delete_subscript ::= expr expr DELETE_SUBSCR\\n                   ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'FORMAT_VALUE':\n            rules_str = '\\n                    expr              ::= formatted_value1\\n                    formatted_value1  ::= expr FORMAT_VALUE\\n                '\n            self.add_unique_doc_rules(rules_str, customize)\n        elif opname == 'GET_ANEXT':\n            self.addRule('\\n                    func_async_prefix   ::= _come_froms SETUP_FINALLY GET_ANEXT LOAD_CONST YIELD_FROM POP_BLOCK\\n                    func_async_middle   ::= JUMP_FORWARD COME_FROM_EXCEPT\\n                                            DUP_TOP LOAD_GLOBAL COMPARE_OP POP_JUMP_IF_TRUE\\n                    list_afor2          ::= func_async_prefix\\n                                            store list_iter\\n                                            JUMP_BACK COME_FROM_FINALLY\\n                                            END_ASYNC_FOR\\n                   ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'FORMAT_VALUE_ATTR':\n            rules_str = '\\n                expr              ::= formatted_value2\\n                formatted_value2  ::= expr expr FORMAT_VALUE_ATTR\\n                '\n            self.add_unique_doc_rules(rules_str, customize)\n        elif opname == 'GET_ITER':\n            self.addRule('\\n                    expr      ::= get_iter\\n                    get_iter  ::= expr GET_ITER\\n                    ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'GET_AITER':\n            self.addRule('\\n                    expr                ::= generator_exp_async\\n                    generator_exp_async ::= load_genexpr LOAD_STR MAKE_FUNCTION_0 expr\\n                                            GET_AITER CALL_FUNCTION_1\\n\\n                    stmt                ::= genexpr_func_async\\n\\n                    func_async_prefix   ::= _come_froms SETUP_EXCEPT GET_ANEXT LOAD_CONST YIELD_FROM\\n                    func_async_middle   ::= POP_BLOCK JUMP_FORWARD COME_FROM_EXCEPT\\n                                            DUP_TOP LOAD_GLOBAL COMPARE_OP POP_JUMP_IF_TRUE\\n                                            END_FINALLY COME_FROM\\n                    genexpr_func_async  ::= LOAD_ARG func_async_prefix\\n                                            store func_async_middle comp_iter\\n                                            JUMP_BACK COME_FROM\\n                                            POP_TOP POP_TOP POP_TOP POP_EXCEPT POP_TOP\\n\\n                    expr                ::= list_comp_async\\n                    list_comp_async     ::= LOAD_LISTCOMP LOAD_STR MAKE_FUNCTION_0\\n                                            expr GET_AITER CALL_FUNCTION_1\\n                                            GET_AWAITABLE LOAD_CONST\\n                                            YIELD_FROM\\n\\n                    expr                ::= list_comp_async\\n                    list_afor2          ::= func_async_prefix\\n                                            store func_async_middle list_iter\\n                                            JUMP_BACK COME_FROM\\n                                            POP_TOP POP_TOP POP_TOP POP_EXCEPT POP_TOP\\n                    list_comp_async     ::= BUILD_LIST_0 LOAD_ARG list_afor2\\n                    get_aiter           ::= expr GET_AITER\\n                    list_afor           ::= get_aiter list_afor2\\n                    list_iter           ::= list_afor\\n                   ', nop_func)\n        elif opname == 'JUMP_IF_NOT_DEBUG':\n            v = token.attr\n            self.addRule('\\n                    stmt        ::= assert_pypy\\n                    stmt        ::= assert2_pypy\", nop_func)\\n                    assert_pypy ::=  JUMP_IF_NOT_DEBUG expr jmp_true\\n                                     LOAD_ASSERT RAISE_VARARGS_1 COME_FROM\\n                    assert2_pypy ::= JUMP_IF_NOT_DEBUG assert_expr jmp_true\\n                                     LOAD_ASSERT expr CALL_FUNCTION_1\\n                                     RAISE_VARARGS_1 COME_FROM\\n                    assert2_pypy ::= JUMP_IF_NOT_DEBUG expr jmp_true\\n                                     LOAD_ASSERT expr CALL_FUNCTION_1\\n                                     RAISE_VARARGS_1 COME_FROM,\\n                    ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'LOAD_BUILD_CLASS':\n            self.custom_build_class_rule(opname, i, token, tokens, customize)\n        elif opname == 'LOAD_CLASSDEREF':\n            self.addRule('expr ::= LOAD_CLASSDEREF', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'LOAD_CLASSNAME':\n            self.addRule('expr ::= LOAD_CLASSNAME', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'LOAD_DICTCOMP':\n            if has_get_iter_call_function1:\n                rule_pat = 'dict_comp ::= LOAD_DICTCOMP %sMAKE_FUNCTION_0 expr GET_ITER CALL_FUNCTION_1'\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                pass\n            custom_ops_processed.add(opname)\n        elif opname == 'LOAD_ATTR':\n            self.addRule('\\n                  expr      ::= attribute\\n                  attribute ::= expr LOAD_ATTR\\n                  ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'LOAD_LISTCOMP':\n            self.add_unique_rule('expr ::= listcomp', opname, token.attr, customize)\n            custom_ops_processed.add(opname)\n        elif opname == 'LOAD_NAME':\n            if token.attr == '__annotations__' and 'SETUP_ANNOTATIONS' in self.seen_ops:\n                token.kind = 'LOAD_ANNOTATION'\n                self.addRule('\\n                        stmt       ::= SETUP_ANNOTATIONS\\n                        stmt       ::= ann_assign\\n                        ann_assign ::= expr LOAD_ANNOTATION LOAD_STR STORE_SUBSCR\\n                        ', nop_func)\n                pass\n        elif opname == 'LOAD_SETCOMP':\n            if has_get_iter_call_function1:\n                self.addRule('expr ::= set_comp', nop_func)\n                rule_pat = 'set_comp ::= LOAD_SETCOMP %sMAKE_FUNCTION_0 expr GET_ITER CALL_FUNCTION_1'\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                pass\n            custom_ops_processed.add(opname)\n        elif opname == 'LOOKUP_METHOD':\n            self.addRule('\\n                             expr      ::= attribute\\n                             attribute ::= expr LOOKUP_METHOD\\n                             ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname.startswith('MAKE_CLOSURE'):\n            if opname == 'MAKE_CLOSURE_0' and 'LOAD_DICTCOMP' in self.seen_ops:\n                rule = '\\n                        dict_comp ::= load_closure LOAD_DICTCOMP LOAD_STR\\n                                      MAKE_CLOSURE_0 expr\\n                                      GET_ITER CALL_FUNCTION_1\\n                    '\n                self.addRule(rule, nop_func)\n            (args_pos, args_kw, annotate_args) = token.attr\n            j = 2\n            if is_pypy or (i >= j and tokens[i - j] == 'LOAD_LAMBDA'):\n                rule_pat = 'lambda_body ::= %sload_closure LOAD_LAMBDA %%s%s' % ('pos_arg ' * args_pos, opname)\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n            if has_get_iter_call_function1:\n                rule_pat = 'generator_exp ::= %sload_closure load_genexpr %%s%s expr GET_ITER CALL_FUNCTION_1' % ('pos_arg ' * args_pos, opname)\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                if has_get_iter_call_function1:\n                    if is_pypy or (i >= j and tokens[i - j] == 'LOAD_LISTCOMP'):\n                        rule_pat = 'listcomp ::= %sload_closure LOAD_LISTCOMP %%s%s expr GET_ITER CALL_FUNCTION_1' % ('pos_arg ' * args_pos, opname)\n                        self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                    if is_pypy or (i >= j and tokens[i - j] == 'LOAD_SETCOMP'):\n                        rule_pat = 'set_comp ::= %sload_closure LOAD_SETCOMP %%s%s expr GET_ITER CALL_FUNCTION_1' % ('pos_arg ' * args_pos, opname)\n                        self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                    if is_pypy or (i >= j and tokens[i - j] == 'LOAD_DICTCOMP'):\n                        self.add_unique_rule('dict_comp ::= %sload_closure LOAD_DICTCOMP %s expr GET_ITER CALL_FUNCTION_1' % ('pos_arg ' * args_pos, opname), opname, token.attr, customize)\n            if args_kw > 0:\n                kwargs_str = 'kwargs '\n            else:\n                kwargs_str = ''\n            rule = 'mkfunc ::= %s%s%s load_closure LOAD_CODE LOAD_STR %s' % ('expr ' * args_pos, kwargs_str, 'expr ' * annotate_args, opname)\n            self.add_unique_rule(rule, opname, token.attr, customize)\n            if args_kw == 0:\n                rule = 'mkfunc ::= %sload_closure load_genexpr %s' % ('pos_arg ' * args_pos, opname)\n                self.add_unique_rule(rule, opname, token.attr, customize)\n            pass\n        elif opname_base.startswith('MAKE_FUNCTION'):\n            (args_pos, args_kw, annotate_args, closure) = token.attr\n            stack_count = args_pos + args_kw + annotate_args\n            if closure:\n                if args_pos:\n                    rule = 'lambda_body ::= %s%s%s%s' % ('expr ' * stack_count, 'load_closure ' * closure, 'BUILD_TUPLE_1 LOAD_LAMBDA LOAD_STR ', opname)\n                else:\n                    rule = 'lambda_body ::= %s%s%s' % ('load_closure ' * closure, 'LOAD_LAMBDA LOAD_STR ', opname)\n                self.add_unique_rule(rule, opname, token.attr, customize)\n            else:\n                rule = 'lambda_body ::= %sLOAD_LAMBDA LOAD_STR %s' % ('expr ' * stack_count, opname)\n                self.add_unique_rule(rule, opname, token.attr, customize)\n            rule = 'mkfunc ::= %s%s%s%s' % ('expr ' * stack_count, 'load_closure ' * closure, 'LOAD_CODE LOAD_STR ', opname)\n            self.add_unique_rule(rule, opname, token.attr, customize)\n            if has_get_iter_call_function1:\n                rule_pat = 'generator_exp ::= %sload_genexpr %%s%s expr GET_ITER CALL_FUNCTION_1' % ('pos_arg ' * args_pos, opname)\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                rule_pat = 'generator_exp ::= %sload_closure load_genexpr %%s%s expr GET_ITER CALL_FUNCTION_1' % ('pos_arg ' * args_pos, opname)\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                if is_pypy or (i >= 2 and tokens[i - 2] == 'LOAD_LISTCOMP'):\n                    rule_pat = 'listcomp ::= load_closure LOAD_LISTCOMP %%s%s expr GET_ITER CALL_FUNCTION_1' % (opname,)\n                    self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                    rule_pat = 'listcomp ::= %sLOAD_LISTCOMP %%s%s expr GET_ITER CALL_FUNCTION_1' % ('expr ' * args_pos, opname)\n                    self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n            if is_pypy or (i >= 2 and tokens[i - 2] == 'LOAD_LAMBDA'):\n                rule_pat = 'lambda_body ::= %s%sLOAD_LAMBDA %%s%s' % ('pos_arg ' * args_pos, 'kwarg ' * args_kw, opname)\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n            continue\n            (args_pos, args_kw, annotate_args, closure) = token.attr\n            j = 2\n            if has_get_iter_call_function1:\n                rule_pat = 'generator_exp ::= %sload_genexpr %%s%s expr GET_ITER CALL_FUNCTION_1' % ('pos_arg ' * args_pos, opname)\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                if is_pypy or (i >= j and tokens[i - j] == 'LOAD_LISTCOMP'):\n                    rule_pat = 'listcomp ::= %sLOAD_LISTCOMP %%s%s expr GET_ITER CALL_FUNCTION_1' % ('expr ' * args_pos, opname)\n                    self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n            if is_pypy or (i >= j and tokens[i - j] == 'LOAD_LAMBDA'):\n                rule_pat = 'lambda_body ::= %s%sLOAD_LAMBDA %%s%s' % ('pos_arg ' * args_pos, 'kwarg ' * args_kw, opname)\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n            if args_kw == 0:\n                kwargs = 'no_kwargs'\n                self.add_unique_rule('no_kwargs ::=', opname, token.attr, customize)\n            else:\n                kwargs = 'kwargs'\n            rule = 'mkfunc ::= %s%s %s%s' % ('pos_arg ' * args_pos, kwargs, 'LOAD_CODE LOAD_STR ', opname)\n            self.add_unique_rule(rule, opname, token.attr, customize)\n        elif opname == 'MAKE_FUNCTION_CLOSURE':\n            if 'LOAD_DICTCOMP' in self.seen_ops:\n                rule = '\\n                       dict_comp ::= load_closure LOAD_DICTCOMP LOAD_STR\\n                                     MAKE_FUNCTION_CLOSURE expr\\n                                     GET_ITER CALL_FUNCTION_1\\n                       '\n                self.addRule(rule, nop_func)\n            elif 'LOAD_SETCOMP' in self.seen_ops:\n                rule = '\\n                       set_comp ::= load_closure LOAD_SETCOMP LOAD_STR\\n                                    MAKE_FUNCTION_CLOSURE expr\\n                                    GET_ITER CALL_FUNCTION_1\\n                       '\n                self.addRule(rule, nop_func)\n        elif opname == 'RETURN_VALUE_LAMBDA':\n            self.addRule('\\n                    return_expr_lambda ::= return_expr RETURN_VALUE_LAMBDA\\n                    ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'RAISE_VARARGS_0':\n            self.addRule('\\n                    stmt        ::= raise_stmt0\\n                    raise_stmt0 ::= RAISE_VARARGS_0\\n                    ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'RAISE_VARARGS_1':\n            self.addRule('\\n                    stmt        ::= raise_stmt1\\n                    raise_stmt1 ::= expr RAISE_VARARGS_1\\n                    ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'RAISE_VARARGS_2':\n            self.addRule('\\n                    stmt        ::= raise_stmt2\\n                    raise_stmt2 ::= expr expr RAISE_VARARGS_2\\n                    ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'SETUP_EXCEPT':\n            self.addRule('\\n                    try_except     ::= SETUP_EXCEPT suite_stmts_opt POP_BLOCK\\n                                       except_handler opt_come_from_except\\n\\n                    tryelsestmt    ::= SETUP_EXCEPT suite_stmts_opt POP_BLOCK\\n                                       except_handler else_suite come_from_except_clauses\\n\\n                    tryelsestmt    ::= SETUP_EXCEPT suite_stmts_opt POP_BLOCK\\n                                       except_handler else_suite come_froms\\n\\n                    tryelsestmtl   ::= SETUP_EXCEPT suite_stmts_opt POP_BLOCK\\n                                       except_handler else_suitel come_from_except_clauses\\n\\n                    stmt             ::= tryelsestmtl3\\n                    tryelsestmtl3    ::= SETUP_EXCEPT suite_stmts_opt POP_BLOCK\\n                                         except_handler COME_FROM else_suitel\\n                                         opt_come_from_except\\n                    ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'WITH_CLEANUP_START':\n            rules_str = '\\n                  stmt        ::= with_null\\n                  with_null   ::= with_suffix\\n                  with_suffix ::= WITH_CLEANUP_START WITH_CLEANUP_FINISH END_FINALLY\\n                '\n            self.addRule(rules_str, nop_func)\n        elif opname == 'SETUP_WITH':\n            rules_str = '\\n                  stmt       ::= with\\n                  stmt       ::= withasstmt\\n\\n                  with       ::= expr\\n                                 SETUP_WITH POP_TOP\\n                                 suite_stmts_opt\\n                                 COME_FROM_WITH\\n                                 with_suffix\\n                  withasstmt ::= expr SETUP_WITH store suite_stmts_opt COME_FROM_WITH\\n                                 with_suffix\\n\\n                  with       ::= expr\\n                                 SETUP_WITH POP_TOP\\n                                 suite_stmts_opt\\n                                 POP_BLOCK LOAD_CONST COME_FROM_WITH\\n                                 with_suffix\\n\\n                  withasstmt ::= expr\\n                                 SETUP_WITH store suite_stmts_opt\\n                                 POP_BLOCK LOAD_CONST COME_FROM_WITH\\n                                 with_suffix\\n\\n                  with       ::= expr\\n                                 SETUP_WITH POP_TOP suite_stmts_opt\\n                                 POP_BLOCK LOAD_CONST COME_FROM_WITH\\n                                 with_suffix\\n                  withasstmt ::= expr\\n                                 SETUP_WITH store suite_stmts_opt\\n                                 POP_BLOCK LOAD_CONST COME_FROM_WITH\\n                                 with_suffix\\n                '\n            if self.version < (3, 8):\n                rules_str += '\\n                    with     ::= expr SETUP_WITH POP_TOP suite_stmts_opt POP_BLOCK\\n                                   LOAD_CONST\\n                                   with_suffix\\n                    '\n            else:\n                rules_str += '\\n                      with       ::= expr\\n                                     SETUP_WITH POP_TOP suite_stmts_opt\\n                                     POP_BLOCK LOAD_CONST COME_FROM_WITH\\n                                     with_suffix\\n\\n                      withasstmt ::= expr\\n                                     SETUP_WITH store suite_stmts_opt\\n                                     POP_BLOCK LOAD_CONST COME_FROM_WITH\\n\\n                      withasstmt ::= expr\\n                                     SETUP_WITH store suite_stmts\\n                                     POP_BLOCK BEGIN_FINALLY COME_FROM_WITH with_suffix\\n\\n                      with       ::= expr SETUP_WITH POP_TOP suite_stmts_opt POP_BLOCK\\n                                     BEGIN_FINALLY COME_FROM_WITH\\n                                     with_suffix\\n                    '\n            self.addRule(rules_str, nop_func)\n        elif opname_base in ('UNPACK_EX',):\n            (before_count, after_count) = token.attr\n            rule = 'unpack ::= ' + opname + ' store' * (before_count + after_count + 1)\n            self.addRule(rule, nop_func)\n        elif opname_base in ('UNPACK_TUPLE', 'UNPACK_SEQUENCE'):\n            rule = 'unpack ::= ' + opname + ' store' * token.attr\n            self.addRule(rule, nop_func)\n        elif opname_base == 'UNPACK_LIST':\n            rule = 'unpack_list ::= ' + opname + ' store' * token.attr\n            self.addRule(rule, nop_func)\n            custom_ops_processed.add(opname)\n            pass\n        pass\n    self.reduce_check_table = {'_ifstmts_jump': ifstmts_jump, 'and': and_invalid, 'ifelsestmt': ifelsestmt, 'ifelsestmtl': ifelsestmt, 'iflaststmt': iflaststmt, 'iflaststmtl': iflaststmt, 'ifstmt': ifstmt, 'ifstmtl': ifstmt, 'or': or_check, 'testtrue': testtrue, 'testfalsel': testtrue, 'while1elsestmt': while1elsestmt, 'while1stmt': while1stmt, 'try_elsestmtl38': tryelsestmtl3}\n    self.check_reduce['and'] = 'AST'\n    self.check_reduce['annotate_tuple'] = 'noAST'\n    self.check_reduce['aug_assign1'] = 'AST'\n    self.check_reduce['aug_assign2'] = 'AST'\n    self.check_reduce['while1stmt'] = 'noAST'\n    self.check_reduce['while1elsestmt'] = 'noAST'\n    self.check_reduce['_ifstmts_jump'] = 'AST'\n    self.check_reduce['import_as37'] = 'tokens'\n    self.check_reduce['import_from_as37'] = 'tokens'\n    self.check_reduce['import_from_as37'] = 'tokens'\n    self.check_reduce['ifelsestmt'] = 'AST'\n    self.check_reduce['ifelsestmtl'] = 'AST'\n    self.check_reduce['iflaststmt'] = 'AST'\n    self.check_reduce['iflaststmtl'] = 'AST'\n    self.check_reduce['ifstmt'] = 'AST'\n    self.check_reduce['ifstmtl'] = 'AST'\n    self.check_reduce['import_from37'] = 'AST'\n    self.check_reduce['or'] = 'AST'\n    self.check_reduce['testtrue'] = 'tokens'\n    self.check_reduce['testfalsel'] = 'tokens'\n    return",
            "def customize_grammar_rules(self, tokens, customize):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    is_pypy = False\n    customize_instruction_basenames = frozenset(('BEFORE', 'BUILD', 'CALL', 'CONTINUE', 'DELETE', 'FORMAT', 'GET', 'JUMP', 'LOAD', 'LOOKUP', 'MAKE', 'RETURN', 'RAISE', 'SETUP', 'UNPACK', 'WITH'))\n    custom_ops_processed = set(('BUILD_TUPLE_UNPACK_WITH_CALL',))\n    self.seen_ops = frozenset([t.kind for t in tokens])\n    self.seen_op_basenames = frozenset([opname[:opname.rfind('_')] for opname in self.seen_ops])\n    if 'PyPy' in customize:\n        is_pypy = True\n        self.addRule('\\n              stmt ::= assign3_pypy\\n              stmt ::= assign2_pypy\\n              assign3_pypy       ::= expr expr expr store store store\\n              assign2_pypy       ::= expr expr store store\\n              stmt               ::= if_exp_lambda\\n              stmt               ::= if_exp_not_lambda\\n              if_exp_lambda      ::= expr jmp_false expr return_if_lambda\\n                                     return_expr_lambda LAMBDA_MARKER\\n              if_exp_not_lambda  ::= expr jmp_true expr return_if_lambda\\n                                     return_expr_lambda LAMBDA_MARKER\\n              ', nop_func)\n    n = len(tokens)\n    has_get_iter_call_function1 = False\n    for (i, token) in enumerate(tokens):\n        if token == 'GET_ITER' and i < n - 2 and (self.call_fn_name(tokens[i + 1]) == 'CALL_FUNCTION_1'):\n            has_get_iter_call_function1 = True\n    for (i, token) in enumerate(tokens):\n        opname = token.kind\n        if opname[:opname.find('_')] not in customize_instruction_basenames or opname in custom_ops_processed:\n            continue\n        opname_base = opname[:opname.rfind('_')]\n        if opname == 'LOAD_ASSERT' and 'PyPy' in customize:\n            rules_str = '\\n                stmt ::= JUMP_IF_NOT_DEBUG stmts COME_FROM\\n                '\n            self.add_unique_doc_rules(rules_str, customize)\n        elif opname == 'BEFORE_ASYNC_WITH':\n            rules_str = '\\n                   stmt            ::= async_with_stmt\\n                   stmt            ::= async_with_as_stmt\\n                '\n            if self.version < (3, 8):\n                rules_str += '\\n                      stmt                 ::= async_with_stmt SETUP_ASYNC_WITH\\n                      c_stmt               ::= c_async_with_stmt SETUP_ASYNC_WITH\\n                      async_with_stmt      ::= expr\\n                                               async_with_pre\\n                                               POP_TOP\\n                                               suite_stmts_opt\\n                                               POP_BLOCK LOAD_CONST\\n                                               async_with_post\\n                      c_async_with_stmt    ::= expr\\n                                               async_with_pre\\n                                               POP_TOP\\n                                               c_suite_stmts_opt\\n                                               POP_BLOCK LOAD_CONST\\n                                               async_with_post\\n                      async_with_stmt      ::= expr\\n                                               async_with_pre\\n                                               POP_TOP\\n                                               suite_stmts_opt\\n                                               async_with_post\\n                      c_async_with_stmt    ::= expr\\n                                               async_with_pre\\n                                               POP_TOP\\n                                               c_suite_stmts_opt\\n                                               async_with_post\\n                      async_with_as_stmt   ::= expr\\n                                               async_with_pre\\n                                               store\\n                                               suite_stmts_opt\\n                                               POP_BLOCK LOAD_CONST\\n                                               async_with_post\\n                      c_async_with_as_stmt ::= expr\\n                                              async_with_pre\\n                                              store\\n                                              c_suite_stmts_opt\\n                                              POP_BLOCK LOAD_CONST\\n                                              async_with_post\\n                      async_with_as_stmt   ::= expr\\n                                              async_with_pre\\n                                              store\\n                                              suite_stmts_opt\\n                                              async_with_post\\n                      c_async_with_as_stmt ::= expr\\n                                              async_with_pre\\n                                              store\\n                                              suite_stmts_opt\\n                                              async_with_post\\n                    '\n            else:\n                rules_str += '\\n                      async_with_pre       ::= BEFORE_ASYNC_WITH GET_AWAITABLE LOAD_CONST YIELD_FROM SETUP_ASYNC_WITH\\n                      async_with_post      ::= BEGIN_FINALLY COME_FROM_ASYNC_WITH\\n                                               WITH_CLEANUP_START GET_AWAITABLE LOAD_CONST YIELD_FROM\\n                                               WITH_CLEANUP_FINISH END_FINALLY\\n                      async_with_stmt      ::= expr\\n                                               async_with_pre\\n                                               POP_TOP\\n                                               suite_stmts\\n                                               POP_TOP POP_BLOCK\\n                                               async_with_post\\n                      c_async_with_stmt    ::= expr\\n                                               async_with_pre\\n                                               POP_TOP\\n                                               c_suite_stmts\\n                                               POP_TOP POP_BLOCK\\n                                               async_with_post\\n                      async_with_stmt      ::= expr\\n                                               async_with_pre\\n                                               POP_TOP\\n                                               suite_stmts\\n                                               POP_BLOCK\\n                                               BEGIN_FINALLY\\n                                               WITH_CLEANUP_START GET_AWAITABLE LOAD_CONST YIELD_FROM\\n                                               WITH_CLEANUP_FINISH POP_FINALLY LOAD_CONST RETURN_VALUE\\n                                               COME_FROM_ASYNC_WITH\\n                                               WITH_CLEANUP_START GET_AWAITABLE LOAD_CONST YIELD_FROM\\n                                               WITH_CLEANUP_FINISH END_FINALLY\\n                      c_async_with_stmt   ::= expr\\n                                              async_with_pre\\n                                              POP_TOP\\n                                              c_suite_stmts\\n                                              POP_BLOCK\\n                                              BEGIN_FINALLY\\n                                              WITH_CLEANUP_START GET_AWAITABLE LOAD_CONST YIELD_FROM\\n                                              WITH_CLEANUP_FINISH POP_FINALLY LOAD_CONST RETURN_VALUE\\n                                              COME_FROM_ASYNC_WITH\\n                                              WITH_CLEANUP_START GET_AWAITABLE LOAD_CONST YIELD_FROM\\n                                              WITH_CLEANUP_FINISH END_FINALLY\\n                      async_with_as_stmt   ::= expr\\n                                               async_with_pre\\n                                               store suite_stmts\\n                                               POP_TOP POP_BLOCK\\n                                               async_with_post\\n                      c_async_with_as_stmt ::= expr\\n                                               async_with_pre\\n                                               store suite_stmts\\n                                               POP_TOP POP_BLOCK\\n                                               async_with_post\\n                      async_with_as_stmt   ::= expr\\n                                               async_with_pre\\n                                               store suite_stmts\\n                                               POP_BLOCK async_with_post\\n                      c_async_with_as_stmt ::= expr\\n                                               async_with_pre\\n                                               store suite_stmts\\n                                               POP_BLOCK async_with_post\\n                    '\n            self.addRule(rules_str, nop_func)\n        elif opname in ('BUILD_CONST_LIST', 'BUILD_CONST_DICT', 'BUILD_CONST_SET'):\n            if opname == 'BUILD_CONST_DICT':\n                rule = f'\\n                            add_consts          ::= ADD_VALUE*\\n                            const_list          ::= COLLECTION_START add_consts {opname}\\n                            dict                ::= const_list\\n                            expr                ::= dict\\n                        '\n            else:\n                rule = f'\\n                            add_consts          ::= ADD_VALUE*\\n                            const_list          ::= COLLECTION_START add_consts {opname}\\n                            expr                ::= const_list\\n                        '\n            self.addRule(rule, nop_func)\n        elif opname_base == 'BUILD_CONST_KEY_MAP':\n            kvlist_n = 'expr ' * token.attr\n            rule = 'dict ::= %sLOAD_CONST %s' % (kvlist_n, opname)\n            self.addRule(rule, nop_func)\n        elif opname.startswith('BUILD_LIST_UNPACK'):\n            v = token.attr\n            rule = 'build_list_unpack ::= %s%s' % ('expr ' * v, opname)\n            self.addRule(rule, nop_func)\n            rule = 'expr ::= build_list_unpack'\n            self.addRule(rule, nop_func)\n        elif opname_base in ('BUILD_MAP', 'BUILD_MAP_UNPACK'):\n            if opname == 'BUILD_MAP_UNPACK':\n                self.addRule('\\n                        expr        ::= dict_unpack\\n                        dict_unpack ::= dict_comp BUILD_MAP_UNPACK\\n                        ', nop_func)\n                pass\n            elif opname.startswith('BUILD_MAP_UNPACK_WITH_CALL'):\n                v = token.attr\n                rule = 'build_map_unpack_with_call ::= %s%s' % ('expr ' * v, opname)\n                self.addRule(rule, nop_func)\n            kvlist_n = 'kvlist_%s' % token.attr\n            if opname == 'BUILD_MAP_n':\n                rule = 'dict_comp_func ::= BUILD_MAP_n LOAD_ARG for_iter store comp_iter JUMP_BACK RETURN_VALUE RETURN_LAST'\n                self.add_unique_rule(rule, 'dict_comp_func', 1, customize)\n                kvlist_n = 'kvlist_n'\n                rule = 'kvlist_n ::=  kvlist_n kv3'\n                self.add_unique_rule(rule, 'kvlist_n', 0, customize)\n                rule = 'kvlist_n ::='\n                self.add_unique_rule(rule, 'kvlist_n', 1, customize)\n                rule = 'dict ::=  BUILD_MAP_n kvlist_n'\n            if not opname.startswith('BUILD_MAP_WITH_CALL'):\n                if opname.startswith('BUILD_MAP_UNPACK'):\n                    if 'LOAD_DICTCOMP' in self.seen_ops:\n                        rule = 'dict ::= %s%s' % ('dict_comp ' * token.attr, opname)\n                        self.addRule(rule, nop_func)\n                    rule = '\\n                         expr        ::= dict_unpack\\n                         dict_unpack ::= %s%s\\n                         ' % ('expr ' * token.attr, opname)\n                else:\n                    rule = '%s ::= %s %s' % (kvlist_n, 'expr ' * (token.attr * 2), opname)\n                    self.add_unique_rule(rule, opname, token.attr, customize)\n                    rule = 'dict ::=  %s' % kvlist_n\n            self.add_unique_rule(rule, opname, token.attr, customize)\n        elif opname.startswith('BUILD_MAP_UNPACK_WITH_CALL'):\n            v = token.attr\n            rule = 'build_map_unpack_with_call ::= %s%s' % ('expr ' * v, opname)\n            self.addRule(rule, nop_func)\n        elif opname.startswith('BUILD_TUPLE_UNPACK_WITH_CALL'):\n            v = token.attr\n            rule = 'build_tuple_unpack_with_call ::= ' + 'expr1024 ' * int(v // 1024) + 'expr32 ' * int(v // 32 % 32) + 'expr ' * (v % 32) + opname\n            self.addRule(rule, nop_func)\n            rule = 'starred ::= %s %s' % ('expr ' * v, opname)\n            self.addRule(rule, nop_func)\n        elif opname_base in ('BUILD_LIST', 'BUILD_SET', 'BUILD_TUPLE', 'BUILD_TUPLE_UNPACK'):\n            collection_size = token.attr\n            is_LOAD_CLOSURE = False\n            if opname_base == 'BUILD_TUPLE':\n                is_LOAD_CLOSURE = True\n                for j in range(collection_size):\n                    if tokens[i - j - 1].kind != 'LOAD_CLOSURE':\n                        is_LOAD_CLOSURE = False\n                        break\n                if is_LOAD_CLOSURE:\n                    rule = 'load_closure ::= %s%s' % ('LOAD_CLOSURE ' * collection_size, opname)\n                    self.add_unique_rule(rule, opname, token.attr, customize)\n            if not is_LOAD_CLOSURE or collection_size == 0:\n                thousands = collection_size // 1024\n                thirty32s = collection_size // 32 % 32\n                if thirty32s > 0:\n                    rule = 'expr32 ::=%s' % (' expr' * 32)\n                    self.add_unique_rule(rule, opname_base, collection_size, customize)\n                    pass\n                if thousands > 0:\n                    self.add_unique_rule('expr1024 ::=%s' % (' expr32' * 32), opname_base, collection_size, customize)\n                    pass\n                collection = opname_base[opname_base.find('_') + 1:].lower()\n                rule = '%s ::= ' % collection + 'expr1024 ' * thousands + 'expr32 ' * thirty32s + 'expr ' * (collection_size % 32) + opname\n                self.add_unique_rules(['expr ::= %s' % collection, rule], customize)\n                continue\n            continue\n        elif opname_base == 'BUILD_SLICE':\n            if token.attr == 2:\n                self.add_unique_rules(['expr ::= slice2', 'slice2 ::= expr expr BUILD_SLICE_2'], customize)\n            else:\n                assert token.attr == 3, 'BUILD_SLICE value must be 2 or 3; is %s' % token.attr\n                self.add_unique_rules(['expr   ::= slice3', 'slice3 ::= expr expr expr BUILD_SLICE_3'], customize)\n        elif opname.startswith('BUILD_STRING'):\n            v = token.attr\n            rules_str = '\\n                    expr                 ::= joined_str\\n                    joined_str           ::= %sBUILD_STRING_%d\\n                ' % ('expr ' * v, v)\n            self.add_unique_doc_rules(rules_str, customize)\n            if 'FORMAT_VALUE_ATTR' in self.seen_ops:\n                rules_str = '\\n                      formatted_value_attr ::= expr expr FORMAT_VALUE_ATTR expr BUILD_STRING\\n                      expr                 ::= formatted_value_attr\\n                    '\n                self.add_unique_doc_rules(rules_str, customize)\n        elif opname in frozenset(('CALL_FUNCTION', 'CALL_FUNCTION_EX', 'CALL_FUNCTION_EX_KW', 'CALL_FUNCTION_VAR', 'CALL_FUNCTION_VAR_KW')) or opname.startswith('CALL_FUNCTION_KW'):\n            if opname == 'CALL_FUNCTION' and token.attr == 1:\n                rule = '\\n                     expr         ::= dict_comp\\n                     dict_comp    ::= LOAD_DICTCOMP LOAD_STR MAKE_FUNCTION_0 expr\\n                                      GET_ITER CALL_FUNCTION_1\\n                    classdefdeco1 ::= expr classdefdeco2 CALL_FUNCTION_1\\n                    classdefdeco1 ::= expr classdefdeco1 CALL_FUNCTION_1\\n                    '\n                self.addRule(rule, nop_func)\n            self.custom_classfunc_rule(opname, token, customize, tokens[i + 1])\n        elif opname_base == 'CALL_METHOD':\n            (args_pos, args_kw) = self.get_pos_kw(token)\n            if opname == 'CALL_METHOD_KW':\n                args_kw = token.attr\n                rules_str = '\\n                         expr ::= call_kw_pypy37\\n                         pypy_kw_keys ::= LOAD_CONST\\n                    '\n                self.add_unique_doc_rules(rules_str, customize)\n                rule = 'call_kw_pypy37 ::= expr ' + 'expr ' * args_kw + ' pypy_kw_keys ' + opname\n            else:\n                (args_pos, args_kw) = self.get_pos_kw(token)\n                nak = (len(opname_base) - len('CALL_METHOD')) // 3\n                rule = 'call ::= expr ' + 'pos_arg ' * args_pos + 'kwarg ' * args_kw + 'expr ' * nak + opname\n            self.add_unique_rule(rule, opname, token.attr, customize)\n        elif opname == 'CONTINUE':\n            self.addRule('continue ::= CONTINUE', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'CONTINUE_LOOP':\n            self.addRule('continue ::= CONTINUE_LOOP', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'DELETE_ATTR':\n            self.addRule('delete ::= expr DELETE_ATTR', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'DELETE_DEREF':\n            self.addRule('\\n                   stmt           ::= del_deref_stmt\\n                   del_deref_stmt ::= DELETE_DEREF\\n                   ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'DELETE_SUBSCR':\n            self.addRule('\\n                    delete ::= delete_subscript\\n                    delete_subscript ::= expr expr DELETE_SUBSCR\\n                   ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'FORMAT_VALUE':\n            rules_str = '\\n                    expr              ::= formatted_value1\\n                    formatted_value1  ::= expr FORMAT_VALUE\\n                '\n            self.add_unique_doc_rules(rules_str, customize)\n        elif opname == 'GET_ANEXT':\n            self.addRule('\\n                    func_async_prefix   ::= _come_froms SETUP_FINALLY GET_ANEXT LOAD_CONST YIELD_FROM POP_BLOCK\\n                    func_async_middle   ::= JUMP_FORWARD COME_FROM_EXCEPT\\n                                            DUP_TOP LOAD_GLOBAL COMPARE_OP POP_JUMP_IF_TRUE\\n                    list_afor2          ::= func_async_prefix\\n                                            store list_iter\\n                                            JUMP_BACK COME_FROM_FINALLY\\n                                            END_ASYNC_FOR\\n                   ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'FORMAT_VALUE_ATTR':\n            rules_str = '\\n                expr              ::= formatted_value2\\n                formatted_value2  ::= expr expr FORMAT_VALUE_ATTR\\n                '\n            self.add_unique_doc_rules(rules_str, customize)\n        elif opname == 'GET_ITER':\n            self.addRule('\\n                    expr      ::= get_iter\\n                    get_iter  ::= expr GET_ITER\\n                    ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'GET_AITER':\n            self.addRule('\\n                    expr                ::= generator_exp_async\\n                    generator_exp_async ::= load_genexpr LOAD_STR MAKE_FUNCTION_0 expr\\n                                            GET_AITER CALL_FUNCTION_1\\n\\n                    stmt                ::= genexpr_func_async\\n\\n                    func_async_prefix   ::= _come_froms SETUP_EXCEPT GET_ANEXT LOAD_CONST YIELD_FROM\\n                    func_async_middle   ::= POP_BLOCK JUMP_FORWARD COME_FROM_EXCEPT\\n                                            DUP_TOP LOAD_GLOBAL COMPARE_OP POP_JUMP_IF_TRUE\\n                                            END_FINALLY COME_FROM\\n                    genexpr_func_async  ::= LOAD_ARG func_async_prefix\\n                                            store func_async_middle comp_iter\\n                                            JUMP_BACK COME_FROM\\n                                            POP_TOP POP_TOP POP_TOP POP_EXCEPT POP_TOP\\n\\n                    expr                ::= list_comp_async\\n                    list_comp_async     ::= LOAD_LISTCOMP LOAD_STR MAKE_FUNCTION_0\\n                                            expr GET_AITER CALL_FUNCTION_1\\n                                            GET_AWAITABLE LOAD_CONST\\n                                            YIELD_FROM\\n\\n                    expr                ::= list_comp_async\\n                    list_afor2          ::= func_async_prefix\\n                                            store func_async_middle list_iter\\n                                            JUMP_BACK COME_FROM\\n                                            POP_TOP POP_TOP POP_TOP POP_EXCEPT POP_TOP\\n                    list_comp_async     ::= BUILD_LIST_0 LOAD_ARG list_afor2\\n                    get_aiter           ::= expr GET_AITER\\n                    list_afor           ::= get_aiter list_afor2\\n                    list_iter           ::= list_afor\\n                   ', nop_func)\n        elif opname == 'JUMP_IF_NOT_DEBUG':\n            v = token.attr\n            self.addRule('\\n                    stmt        ::= assert_pypy\\n                    stmt        ::= assert2_pypy\", nop_func)\\n                    assert_pypy ::=  JUMP_IF_NOT_DEBUG expr jmp_true\\n                                     LOAD_ASSERT RAISE_VARARGS_1 COME_FROM\\n                    assert2_pypy ::= JUMP_IF_NOT_DEBUG assert_expr jmp_true\\n                                     LOAD_ASSERT expr CALL_FUNCTION_1\\n                                     RAISE_VARARGS_1 COME_FROM\\n                    assert2_pypy ::= JUMP_IF_NOT_DEBUG expr jmp_true\\n                                     LOAD_ASSERT expr CALL_FUNCTION_1\\n                                     RAISE_VARARGS_1 COME_FROM,\\n                    ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'LOAD_BUILD_CLASS':\n            self.custom_build_class_rule(opname, i, token, tokens, customize)\n        elif opname == 'LOAD_CLASSDEREF':\n            self.addRule('expr ::= LOAD_CLASSDEREF', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'LOAD_CLASSNAME':\n            self.addRule('expr ::= LOAD_CLASSNAME', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'LOAD_DICTCOMP':\n            if has_get_iter_call_function1:\n                rule_pat = 'dict_comp ::= LOAD_DICTCOMP %sMAKE_FUNCTION_0 expr GET_ITER CALL_FUNCTION_1'\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                pass\n            custom_ops_processed.add(opname)\n        elif opname == 'LOAD_ATTR':\n            self.addRule('\\n                  expr      ::= attribute\\n                  attribute ::= expr LOAD_ATTR\\n                  ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'LOAD_LISTCOMP':\n            self.add_unique_rule('expr ::= listcomp', opname, token.attr, customize)\n            custom_ops_processed.add(opname)\n        elif opname == 'LOAD_NAME':\n            if token.attr == '__annotations__' and 'SETUP_ANNOTATIONS' in self.seen_ops:\n                token.kind = 'LOAD_ANNOTATION'\n                self.addRule('\\n                        stmt       ::= SETUP_ANNOTATIONS\\n                        stmt       ::= ann_assign\\n                        ann_assign ::= expr LOAD_ANNOTATION LOAD_STR STORE_SUBSCR\\n                        ', nop_func)\n                pass\n        elif opname == 'LOAD_SETCOMP':\n            if has_get_iter_call_function1:\n                self.addRule('expr ::= set_comp', nop_func)\n                rule_pat = 'set_comp ::= LOAD_SETCOMP %sMAKE_FUNCTION_0 expr GET_ITER CALL_FUNCTION_1'\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                pass\n            custom_ops_processed.add(opname)\n        elif opname == 'LOOKUP_METHOD':\n            self.addRule('\\n                             expr      ::= attribute\\n                             attribute ::= expr LOOKUP_METHOD\\n                             ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname.startswith('MAKE_CLOSURE'):\n            if opname == 'MAKE_CLOSURE_0' and 'LOAD_DICTCOMP' in self.seen_ops:\n                rule = '\\n                        dict_comp ::= load_closure LOAD_DICTCOMP LOAD_STR\\n                                      MAKE_CLOSURE_0 expr\\n                                      GET_ITER CALL_FUNCTION_1\\n                    '\n                self.addRule(rule, nop_func)\n            (args_pos, args_kw, annotate_args) = token.attr\n            j = 2\n            if is_pypy or (i >= j and tokens[i - j] == 'LOAD_LAMBDA'):\n                rule_pat = 'lambda_body ::= %sload_closure LOAD_LAMBDA %%s%s' % ('pos_arg ' * args_pos, opname)\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n            if has_get_iter_call_function1:\n                rule_pat = 'generator_exp ::= %sload_closure load_genexpr %%s%s expr GET_ITER CALL_FUNCTION_1' % ('pos_arg ' * args_pos, opname)\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                if has_get_iter_call_function1:\n                    if is_pypy or (i >= j and tokens[i - j] == 'LOAD_LISTCOMP'):\n                        rule_pat = 'listcomp ::= %sload_closure LOAD_LISTCOMP %%s%s expr GET_ITER CALL_FUNCTION_1' % ('pos_arg ' * args_pos, opname)\n                        self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                    if is_pypy or (i >= j and tokens[i - j] == 'LOAD_SETCOMP'):\n                        rule_pat = 'set_comp ::= %sload_closure LOAD_SETCOMP %%s%s expr GET_ITER CALL_FUNCTION_1' % ('pos_arg ' * args_pos, opname)\n                        self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                    if is_pypy or (i >= j and tokens[i - j] == 'LOAD_DICTCOMP'):\n                        self.add_unique_rule('dict_comp ::= %sload_closure LOAD_DICTCOMP %s expr GET_ITER CALL_FUNCTION_1' % ('pos_arg ' * args_pos, opname), opname, token.attr, customize)\n            if args_kw > 0:\n                kwargs_str = 'kwargs '\n            else:\n                kwargs_str = ''\n            rule = 'mkfunc ::= %s%s%s load_closure LOAD_CODE LOAD_STR %s' % ('expr ' * args_pos, kwargs_str, 'expr ' * annotate_args, opname)\n            self.add_unique_rule(rule, opname, token.attr, customize)\n            if args_kw == 0:\n                rule = 'mkfunc ::= %sload_closure load_genexpr %s' % ('pos_arg ' * args_pos, opname)\n                self.add_unique_rule(rule, opname, token.attr, customize)\n            pass\n        elif opname_base.startswith('MAKE_FUNCTION'):\n            (args_pos, args_kw, annotate_args, closure) = token.attr\n            stack_count = args_pos + args_kw + annotate_args\n            if closure:\n                if args_pos:\n                    rule = 'lambda_body ::= %s%s%s%s' % ('expr ' * stack_count, 'load_closure ' * closure, 'BUILD_TUPLE_1 LOAD_LAMBDA LOAD_STR ', opname)\n                else:\n                    rule = 'lambda_body ::= %s%s%s' % ('load_closure ' * closure, 'LOAD_LAMBDA LOAD_STR ', opname)\n                self.add_unique_rule(rule, opname, token.attr, customize)\n            else:\n                rule = 'lambda_body ::= %sLOAD_LAMBDA LOAD_STR %s' % ('expr ' * stack_count, opname)\n                self.add_unique_rule(rule, opname, token.attr, customize)\n            rule = 'mkfunc ::= %s%s%s%s' % ('expr ' * stack_count, 'load_closure ' * closure, 'LOAD_CODE LOAD_STR ', opname)\n            self.add_unique_rule(rule, opname, token.attr, customize)\n            if has_get_iter_call_function1:\n                rule_pat = 'generator_exp ::= %sload_genexpr %%s%s expr GET_ITER CALL_FUNCTION_1' % ('pos_arg ' * args_pos, opname)\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                rule_pat = 'generator_exp ::= %sload_closure load_genexpr %%s%s expr GET_ITER CALL_FUNCTION_1' % ('pos_arg ' * args_pos, opname)\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                if is_pypy or (i >= 2 and tokens[i - 2] == 'LOAD_LISTCOMP'):\n                    rule_pat = 'listcomp ::= load_closure LOAD_LISTCOMP %%s%s expr GET_ITER CALL_FUNCTION_1' % (opname,)\n                    self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                    rule_pat = 'listcomp ::= %sLOAD_LISTCOMP %%s%s expr GET_ITER CALL_FUNCTION_1' % ('expr ' * args_pos, opname)\n                    self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n            if is_pypy or (i >= 2 and tokens[i - 2] == 'LOAD_LAMBDA'):\n                rule_pat = 'lambda_body ::= %s%sLOAD_LAMBDA %%s%s' % ('pos_arg ' * args_pos, 'kwarg ' * args_kw, opname)\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n            continue\n            (args_pos, args_kw, annotate_args, closure) = token.attr\n            j = 2\n            if has_get_iter_call_function1:\n                rule_pat = 'generator_exp ::= %sload_genexpr %%s%s expr GET_ITER CALL_FUNCTION_1' % ('pos_arg ' * args_pos, opname)\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                if is_pypy or (i >= j and tokens[i - j] == 'LOAD_LISTCOMP'):\n                    rule_pat = 'listcomp ::= %sLOAD_LISTCOMP %%s%s expr GET_ITER CALL_FUNCTION_1' % ('expr ' * args_pos, opname)\n                    self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n            if is_pypy or (i >= j and tokens[i - j] == 'LOAD_LAMBDA'):\n                rule_pat = 'lambda_body ::= %s%sLOAD_LAMBDA %%s%s' % ('pos_arg ' * args_pos, 'kwarg ' * args_kw, opname)\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n            if args_kw == 0:\n                kwargs = 'no_kwargs'\n                self.add_unique_rule('no_kwargs ::=', opname, token.attr, customize)\n            else:\n                kwargs = 'kwargs'\n            rule = 'mkfunc ::= %s%s %s%s' % ('pos_arg ' * args_pos, kwargs, 'LOAD_CODE LOAD_STR ', opname)\n            self.add_unique_rule(rule, opname, token.attr, customize)\n        elif opname == 'MAKE_FUNCTION_CLOSURE':\n            if 'LOAD_DICTCOMP' in self.seen_ops:\n                rule = '\\n                       dict_comp ::= load_closure LOAD_DICTCOMP LOAD_STR\\n                                     MAKE_FUNCTION_CLOSURE expr\\n                                     GET_ITER CALL_FUNCTION_1\\n                       '\n                self.addRule(rule, nop_func)\n            elif 'LOAD_SETCOMP' in self.seen_ops:\n                rule = '\\n                       set_comp ::= load_closure LOAD_SETCOMP LOAD_STR\\n                                    MAKE_FUNCTION_CLOSURE expr\\n                                    GET_ITER CALL_FUNCTION_1\\n                       '\n                self.addRule(rule, nop_func)\n        elif opname == 'RETURN_VALUE_LAMBDA':\n            self.addRule('\\n                    return_expr_lambda ::= return_expr RETURN_VALUE_LAMBDA\\n                    ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'RAISE_VARARGS_0':\n            self.addRule('\\n                    stmt        ::= raise_stmt0\\n                    raise_stmt0 ::= RAISE_VARARGS_0\\n                    ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'RAISE_VARARGS_1':\n            self.addRule('\\n                    stmt        ::= raise_stmt1\\n                    raise_stmt1 ::= expr RAISE_VARARGS_1\\n                    ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'RAISE_VARARGS_2':\n            self.addRule('\\n                    stmt        ::= raise_stmt2\\n                    raise_stmt2 ::= expr expr RAISE_VARARGS_2\\n                    ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'SETUP_EXCEPT':\n            self.addRule('\\n                    try_except     ::= SETUP_EXCEPT suite_stmts_opt POP_BLOCK\\n                                       except_handler opt_come_from_except\\n\\n                    tryelsestmt    ::= SETUP_EXCEPT suite_stmts_opt POP_BLOCK\\n                                       except_handler else_suite come_from_except_clauses\\n\\n                    tryelsestmt    ::= SETUP_EXCEPT suite_stmts_opt POP_BLOCK\\n                                       except_handler else_suite come_froms\\n\\n                    tryelsestmtl   ::= SETUP_EXCEPT suite_stmts_opt POP_BLOCK\\n                                       except_handler else_suitel come_from_except_clauses\\n\\n                    stmt             ::= tryelsestmtl3\\n                    tryelsestmtl3    ::= SETUP_EXCEPT suite_stmts_opt POP_BLOCK\\n                                         except_handler COME_FROM else_suitel\\n                                         opt_come_from_except\\n                    ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'WITH_CLEANUP_START':\n            rules_str = '\\n                  stmt        ::= with_null\\n                  with_null   ::= with_suffix\\n                  with_suffix ::= WITH_CLEANUP_START WITH_CLEANUP_FINISH END_FINALLY\\n                '\n            self.addRule(rules_str, nop_func)\n        elif opname == 'SETUP_WITH':\n            rules_str = '\\n                  stmt       ::= with\\n                  stmt       ::= withasstmt\\n\\n                  with       ::= expr\\n                                 SETUP_WITH POP_TOP\\n                                 suite_stmts_opt\\n                                 COME_FROM_WITH\\n                                 with_suffix\\n                  withasstmt ::= expr SETUP_WITH store suite_stmts_opt COME_FROM_WITH\\n                                 with_suffix\\n\\n                  with       ::= expr\\n                                 SETUP_WITH POP_TOP\\n                                 suite_stmts_opt\\n                                 POP_BLOCK LOAD_CONST COME_FROM_WITH\\n                                 with_suffix\\n\\n                  withasstmt ::= expr\\n                                 SETUP_WITH store suite_stmts_opt\\n                                 POP_BLOCK LOAD_CONST COME_FROM_WITH\\n                                 with_suffix\\n\\n                  with       ::= expr\\n                                 SETUP_WITH POP_TOP suite_stmts_opt\\n                                 POP_BLOCK LOAD_CONST COME_FROM_WITH\\n                                 with_suffix\\n                  withasstmt ::= expr\\n                                 SETUP_WITH store suite_stmts_opt\\n                                 POP_BLOCK LOAD_CONST COME_FROM_WITH\\n                                 with_suffix\\n                '\n            if self.version < (3, 8):\n                rules_str += '\\n                    with     ::= expr SETUP_WITH POP_TOP suite_stmts_opt POP_BLOCK\\n                                   LOAD_CONST\\n                                   with_suffix\\n                    '\n            else:\n                rules_str += '\\n                      with       ::= expr\\n                                     SETUP_WITH POP_TOP suite_stmts_opt\\n                                     POP_BLOCK LOAD_CONST COME_FROM_WITH\\n                                     with_suffix\\n\\n                      withasstmt ::= expr\\n                                     SETUP_WITH store suite_stmts_opt\\n                                     POP_BLOCK LOAD_CONST COME_FROM_WITH\\n\\n                      withasstmt ::= expr\\n                                     SETUP_WITH store suite_stmts\\n                                     POP_BLOCK BEGIN_FINALLY COME_FROM_WITH with_suffix\\n\\n                      with       ::= expr SETUP_WITH POP_TOP suite_stmts_opt POP_BLOCK\\n                                     BEGIN_FINALLY COME_FROM_WITH\\n                                     with_suffix\\n                    '\n            self.addRule(rules_str, nop_func)\n        elif opname_base in ('UNPACK_EX',):\n            (before_count, after_count) = token.attr\n            rule = 'unpack ::= ' + opname + ' store' * (before_count + after_count + 1)\n            self.addRule(rule, nop_func)\n        elif opname_base in ('UNPACK_TUPLE', 'UNPACK_SEQUENCE'):\n            rule = 'unpack ::= ' + opname + ' store' * token.attr\n            self.addRule(rule, nop_func)\n        elif opname_base == 'UNPACK_LIST':\n            rule = 'unpack_list ::= ' + opname + ' store' * token.attr\n            self.addRule(rule, nop_func)\n            custom_ops_processed.add(opname)\n            pass\n        pass\n    self.reduce_check_table = {'_ifstmts_jump': ifstmts_jump, 'and': and_invalid, 'ifelsestmt': ifelsestmt, 'ifelsestmtl': ifelsestmt, 'iflaststmt': iflaststmt, 'iflaststmtl': iflaststmt, 'ifstmt': ifstmt, 'ifstmtl': ifstmt, 'or': or_check, 'testtrue': testtrue, 'testfalsel': testtrue, 'while1elsestmt': while1elsestmt, 'while1stmt': while1stmt, 'try_elsestmtl38': tryelsestmtl3}\n    self.check_reduce['and'] = 'AST'\n    self.check_reduce['annotate_tuple'] = 'noAST'\n    self.check_reduce['aug_assign1'] = 'AST'\n    self.check_reduce['aug_assign2'] = 'AST'\n    self.check_reduce['while1stmt'] = 'noAST'\n    self.check_reduce['while1elsestmt'] = 'noAST'\n    self.check_reduce['_ifstmts_jump'] = 'AST'\n    self.check_reduce['import_as37'] = 'tokens'\n    self.check_reduce['import_from_as37'] = 'tokens'\n    self.check_reduce['import_from_as37'] = 'tokens'\n    self.check_reduce['ifelsestmt'] = 'AST'\n    self.check_reduce['ifelsestmtl'] = 'AST'\n    self.check_reduce['iflaststmt'] = 'AST'\n    self.check_reduce['iflaststmtl'] = 'AST'\n    self.check_reduce['ifstmt'] = 'AST'\n    self.check_reduce['ifstmtl'] = 'AST'\n    self.check_reduce['import_from37'] = 'AST'\n    self.check_reduce['or'] = 'AST'\n    self.check_reduce['testtrue'] = 'tokens'\n    self.check_reduce['testfalsel'] = 'tokens'\n    return",
            "def customize_grammar_rules(self, tokens, customize):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    is_pypy = False\n    customize_instruction_basenames = frozenset(('BEFORE', 'BUILD', 'CALL', 'CONTINUE', 'DELETE', 'FORMAT', 'GET', 'JUMP', 'LOAD', 'LOOKUP', 'MAKE', 'RETURN', 'RAISE', 'SETUP', 'UNPACK', 'WITH'))\n    custom_ops_processed = set(('BUILD_TUPLE_UNPACK_WITH_CALL',))\n    self.seen_ops = frozenset([t.kind for t in tokens])\n    self.seen_op_basenames = frozenset([opname[:opname.rfind('_')] for opname in self.seen_ops])\n    if 'PyPy' in customize:\n        is_pypy = True\n        self.addRule('\\n              stmt ::= assign3_pypy\\n              stmt ::= assign2_pypy\\n              assign3_pypy       ::= expr expr expr store store store\\n              assign2_pypy       ::= expr expr store store\\n              stmt               ::= if_exp_lambda\\n              stmt               ::= if_exp_not_lambda\\n              if_exp_lambda      ::= expr jmp_false expr return_if_lambda\\n                                     return_expr_lambda LAMBDA_MARKER\\n              if_exp_not_lambda  ::= expr jmp_true expr return_if_lambda\\n                                     return_expr_lambda LAMBDA_MARKER\\n              ', nop_func)\n    n = len(tokens)\n    has_get_iter_call_function1 = False\n    for (i, token) in enumerate(tokens):\n        if token == 'GET_ITER' and i < n - 2 and (self.call_fn_name(tokens[i + 1]) == 'CALL_FUNCTION_1'):\n            has_get_iter_call_function1 = True\n    for (i, token) in enumerate(tokens):\n        opname = token.kind\n        if opname[:opname.find('_')] not in customize_instruction_basenames or opname in custom_ops_processed:\n            continue\n        opname_base = opname[:opname.rfind('_')]\n        if opname == 'LOAD_ASSERT' and 'PyPy' in customize:\n            rules_str = '\\n                stmt ::= JUMP_IF_NOT_DEBUG stmts COME_FROM\\n                '\n            self.add_unique_doc_rules(rules_str, customize)\n        elif opname == 'BEFORE_ASYNC_WITH':\n            rules_str = '\\n                   stmt            ::= async_with_stmt\\n                   stmt            ::= async_with_as_stmt\\n                '\n            if self.version < (3, 8):\n                rules_str += '\\n                      stmt                 ::= async_with_stmt SETUP_ASYNC_WITH\\n                      c_stmt               ::= c_async_with_stmt SETUP_ASYNC_WITH\\n                      async_with_stmt      ::= expr\\n                                               async_with_pre\\n                                               POP_TOP\\n                                               suite_stmts_opt\\n                                               POP_BLOCK LOAD_CONST\\n                                               async_with_post\\n                      c_async_with_stmt    ::= expr\\n                                               async_with_pre\\n                                               POP_TOP\\n                                               c_suite_stmts_opt\\n                                               POP_BLOCK LOAD_CONST\\n                                               async_with_post\\n                      async_with_stmt      ::= expr\\n                                               async_with_pre\\n                                               POP_TOP\\n                                               suite_stmts_opt\\n                                               async_with_post\\n                      c_async_with_stmt    ::= expr\\n                                               async_with_pre\\n                                               POP_TOP\\n                                               c_suite_stmts_opt\\n                                               async_with_post\\n                      async_with_as_stmt   ::= expr\\n                                               async_with_pre\\n                                               store\\n                                               suite_stmts_opt\\n                                               POP_BLOCK LOAD_CONST\\n                                               async_with_post\\n                      c_async_with_as_stmt ::= expr\\n                                              async_with_pre\\n                                              store\\n                                              c_suite_stmts_opt\\n                                              POP_BLOCK LOAD_CONST\\n                                              async_with_post\\n                      async_with_as_stmt   ::= expr\\n                                              async_with_pre\\n                                              store\\n                                              suite_stmts_opt\\n                                              async_with_post\\n                      c_async_with_as_stmt ::= expr\\n                                              async_with_pre\\n                                              store\\n                                              suite_stmts_opt\\n                                              async_with_post\\n                    '\n            else:\n                rules_str += '\\n                      async_with_pre       ::= BEFORE_ASYNC_WITH GET_AWAITABLE LOAD_CONST YIELD_FROM SETUP_ASYNC_WITH\\n                      async_with_post      ::= BEGIN_FINALLY COME_FROM_ASYNC_WITH\\n                                               WITH_CLEANUP_START GET_AWAITABLE LOAD_CONST YIELD_FROM\\n                                               WITH_CLEANUP_FINISH END_FINALLY\\n                      async_with_stmt      ::= expr\\n                                               async_with_pre\\n                                               POP_TOP\\n                                               suite_stmts\\n                                               POP_TOP POP_BLOCK\\n                                               async_with_post\\n                      c_async_with_stmt    ::= expr\\n                                               async_with_pre\\n                                               POP_TOP\\n                                               c_suite_stmts\\n                                               POP_TOP POP_BLOCK\\n                                               async_with_post\\n                      async_with_stmt      ::= expr\\n                                               async_with_pre\\n                                               POP_TOP\\n                                               suite_stmts\\n                                               POP_BLOCK\\n                                               BEGIN_FINALLY\\n                                               WITH_CLEANUP_START GET_AWAITABLE LOAD_CONST YIELD_FROM\\n                                               WITH_CLEANUP_FINISH POP_FINALLY LOAD_CONST RETURN_VALUE\\n                                               COME_FROM_ASYNC_WITH\\n                                               WITH_CLEANUP_START GET_AWAITABLE LOAD_CONST YIELD_FROM\\n                                               WITH_CLEANUP_FINISH END_FINALLY\\n                      c_async_with_stmt   ::= expr\\n                                              async_with_pre\\n                                              POP_TOP\\n                                              c_suite_stmts\\n                                              POP_BLOCK\\n                                              BEGIN_FINALLY\\n                                              WITH_CLEANUP_START GET_AWAITABLE LOAD_CONST YIELD_FROM\\n                                              WITH_CLEANUP_FINISH POP_FINALLY LOAD_CONST RETURN_VALUE\\n                                              COME_FROM_ASYNC_WITH\\n                                              WITH_CLEANUP_START GET_AWAITABLE LOAD_CONST YIELD_FROM\\n                                              WITH_CLEANUP_FINISH END_FINALLY\\n                      async_with_as_stmt   ::= expr\\n                                               async_with_pre\\n                                               store suite_stmts\\n                                               POP_TOP POP_BLOCK\\n                                               async_with_post\\n                      c_async_with_as_stmt ::= expr\\n                                               async_with_pre\\n                                               store suite_stmts\\n                                               POP_TOP POP_BLOCK\\n                                               async_with_post\\n                      async_with_as_stmt   ::= expr\\n                                               async_with_pre\\n                                               store suite_stmts\\n                                               POP_BLOCK async_with_post\\n                      c_async_with_as_stmt ::= expr\\n                                               async_with_pre\\n                                               store suite_stmts\\n                                               POP_BLOCK async_with_post\\n                    '\n            self.addRule(rules_str, nop_func)\n        elif opname in ('BUILD_CONST_LIST', 'BUILD_CONST_DICT', 'BUILD_CONST_SET'):\n            if opname == 'BUILD_CONST_DICT':\n                rule = f'\\n                            add_consts          ::= ADD_VALUE*\\n                            const_list          ::= COLLECTION_START add_consts {opname}\\n                            dict                ::= const_list\\n                            expr                ::= dict\\n                        '\n            else:\n                rule = f'\\n                            add_consts          ::= ADD_VALUE*\\n                            const_list          ::= COLLECTION_START add_consts {opname}\\n                            expr                ::= const_list\\n                        '\n            self.addRule(rule, nop_func)\n        elif opname_base == 'BUILD_CONST_KEY_MAP':\n            kvlist_n = 'expr ' * token.attr\n            rule = 'dict ::= %sLOAD_CONST %s' % (kvlist_n, opname)\n            self.addRule(rule, nop_func)\n        elif opname.startswith('BUILD_LIST_UNPACK'):\n            v = token.attr\n            rule = 'build_list_unpack ::= %s%s' % ('expr ' * v, opname)\n            self.addRule(rule, nop_func)\n            rule = 'expr ::= build_list_unpack'\n            self.addRule(rule, nop_func)\n        elif opname_base in ('BUILD_MAP', 'BUILD_MAP_UNPACK'):\n            if opname == 'BUILD_MAP_UNPACK':\n                self.addRule('\\n                        expr        ::= dict_unpack\\n                        dict_unpack ::= dict_comp BUILD_MAP_UNPACK\\n                        ', nop_func)\n                pass\n            elif opname.startswith('BUILD_MAP_UNPACK_WITH_CALL'):\n                v = token.attr\n                rule = 'build_map_unpack_with_call ::= %s%s' % ('expr ' * v, opname)\n                self.addRule(rule, nop_func)\n            kvlist_n = 'kvlist_%s' % token.attr\n            if opname == 'BUILD_MAP_n':\n                rule = 'dict_comp_func ::= BUILD_MAP_n LOAD_ARG for_iter store comp_iter JUMP_BACK RETURN_VALUE RETURN_LAST'\n                self.add_unique_rule(rule, 'dict_comp_func', 1, customize)\n                kvlist_n = 'kvlist_n'\n                rule = 'kvlist_n ::=  kvlist_n kv3'\n                self.add_unique_rule(rule, 'kvlist_n', 0, customize)\n                rule = 'kvlist_n ::='\n                self.add_unique_rule(rule, 'kvlist_n', 1, customize)\n                rule = 'dict ::=  BUILD_MAP_n kvlist_n'\n            if not opname.startswith('BUILD_MAP_WITH_CALL'):\n                if opname.startswith('BUILD_MAP_UNPACK'):\n                    if 'LOAD_DICTCOMP' in self.seen_ops:\n                        rule = 'dict ::= %s%s' % ('dict_comp ' * token.attr, opname)\n                        self.addRule(rule, nop_func)\n                    rule = '\\n                         expr        ::= dict_unpack\\n                         dict_unpack ::= %s%s\\n                         ' % ('expr ' * token.attr, opname)\n                else:\n                    rule = '%s ::= %s %s' % (kvlist_n, 'expr ' * (token.attr * 2), opname)\n                    self.add_unique_rule(rule, opname, token.attr, customize)\n                    rule = 'dict ::=  %s' % kvlist_n\n            self.add_unique_rule(rule, opname, token.attr, customize)\n        elif opname.startswith('BUILD_MAP_UNPACK_WITH_CALL'):\n            v = token.attr\n            rule = 'build_map_unpack_with_call ::= %s%s' % ('expr ' * v, opname)\n            self.addRule(rule, nop_func)\n        elif opname.startswith('BUILD_TUPLE_UNPACK_WITH_CALL'):\n            v = token.attr\n            rule = 'build_tuple_unpack_with_call ::= ' + 'expr1024 ' * int(v // 1024) + 'expr32 ' * int(v // 32 % 32) + 'expr ' * (v % 32) + opname\n            self.addRule(rule, nop_func)\n            rule = 'starred ::= %s %s' % ('expr ' * v, opname)\n            self.addRule(rule, nop_func)\n        elif opname_base in ('BUILD_LIST', 'BUILD_SET', 'BUILD_TUPLE', 'BUILD_TUPLE_UNPACK'):\n            collection_size = token.attr\n            is_LOAD_CLOSURE = False\n            if opname_base == 'BUILD_TUPLE':\n                is_LOAD_CLOSURE = True\n                for j in range(collection_size):\n                    if tokens[i - j - 1].kind != 'LOAD_CLOSURE':\n                        is_LOAD_CLOSURE = False\n                        break\n                if is_LOAD_CLOSURE:\n                    rule = 'load_closure ::= %s%s' % ('LOAD_CLOSURE ' * collection_size, opname)\n                    self.add_unique_rule(rule, opname, token.attr, customize)\n            if not is_LOAD_CLOSURE or collection_size == 0:\n                thousands = collection_size // 1024\n                thirty32s = collection_size // 32 % 32\n                if thirty32s > 0:\n                    rule = 'expr32 ::=%s' % (' expr' * 32)\n                    self.add_unique_rule(rule, opname_base, collection_size, customize)\n                    pass\n                if thousands > 0:\n                    self.add_unique_rule('expr1024 ::=%s' % (' expr32' * 32), opname_base, collection_size, customize)\n                    pass\n                collection = opname_base[opname_base.find('_') + 1:].lower()\n                rule = '%s ::= ' % collection + 'expr1024 ' * thousands + 'expr32 ' * thirty32s + 'expr ' * (collection_size % 32) + opname\n                self.add_unique_rules(['expr ::= %s' % collection, rule], customize)\n                continue\n            continue\n        elif opname_base == 'BUILD_SLICE':\n            if token.attr == 2:\n                self.add_unique_rules(['expr ::= slice2', 'slice2 ::= expr expr BUILD_SLICE_2'], customize)\n            else:\n                assert token.attr == 3, 'BUILD_SLICE value must be 2 or 3; is %s' % token.attr\n                self.add_unique_rules(['expr   ::= slice3', 'slice3 ::= expr expr expr BUILD_SLICE_3'], customize)\n        elif opname.startswith('BUILD_STRING'):\n            v = token.attr\n            rules_str = '\\n                    expr                 ::= joined_str\\n                    joined_str           ::= %sBUILD_STRING_%d\\n                ' % ('expr ' * v, v)\n            self.add_unique_doc_rules(rules_str, customize)\n            if 'FORMAT_VALUE_ATTR' in self.seen_ops:\n                rules_str = '\\n                      formatted_value_attr ::= expr expr FORMAT_VALUE_ATTR expr BUILD_STRING\\n                      expr                 ::= formatted_value_attr\\n                    '\n                self.add_unique_doc_rules(rules_str, customize)\n        elif opname in frozenset(('CALL_FUNCTION', 'CALL_FUNCTION_EX', 'CALL_FUNCTION_EX_KW', 'CALL_FUNCTION_VAR', 'CALL_FUNCTION_VAR_KW')) or opname.startswith('CALL_FUNCTION_KW'):\n            if opname == 'CALL_FUNCTION' and token.attr == 1:\n                rule = '\\n                     expr         ::= dict_comp\\n                     dict_comp    ::= LOAD_DICTCOMP LOAD_STR MAKE_FUNCTION_0 expr\\n                                      GET_ITER CALL_FUNCTION_1\\n                    classdefdeco1 ::= expr classdefdeco2 CALL_FUNCTION_1\\n                    classdefdeco1 ::= expr classdefdeco1 CALL_FUNCTION_1\\n                    '\n                self.addRule(rule, nop_func)\n            self.custom_classfunc_rule(opname, token, customize, tokens[i + 1])\n        elif opname_base == 'CALL_METHOD':\n            (args_pos, args_kw) = self.get_pos_kw(token)\n            if opname == 'CALL_METHOD_KW':\n                args_kw = token.attr\n                rules_str = '\\n                         expr ::= call_kw_pypy37\\n                         pypy_kw_keys ::= LOAD_CONST\\n                    '\n                self.add_unique_doc_rules(rules_str, customize)\n                rule = 'call_kw_pypy37 ::= expr ' + 'expr ' * args_kw + ' pypy_kw_keys ' + opname\n            else:\n                (args_pos, args_kw) = self.get_pos_kw(token)\n                nak = (len(opname_base) - len('CALL_METHOD')) // 3\n                rule = 'call ::= expr ' + 'pos_arg ' * args_pos + 'kwarg ' * args_kw + 'expr ' * nak + opname\n            self.add_unique_rule(rule, opname, token.attr, customize)\n        elif opname == 'CONTINUE':\n            self.addRule('continue ::= CONTINUE', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'CONTINUE_LOOP':\n            self.addRule('continue ::= CONTINUE_LOOP', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'DELETE_ATTR':\n            self.addRule('delete ::= expr DELETE_ATTR', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'DELETE_DEREF':\n            self.addRule('\\n                   stmt           ::= del_deref_stmt\\n                   del_deref_stmt ::= DELETE_DEREF\\n                   ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'DELETE_SUBSCR':\n            self.addRule('\\n                    delete ::= delete_subscript\\n                    delete_subscript ::= expr expr DELETE_SUBSCR\\n                   ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'FORMAT_VALUE':\n            rules_str = '\\n                    expr              ::= formatted_value1\\n                    formatted_value1  ::= expr FORMAT_VALUE\\n                '\n            self.add_unique_doc_rules(rules_str, customize)\n        elif opname == 'GET_ANEXT':\n            self.addRule('\\n                    func_async_prefix   ::= _come_froms SETUP_FINALLY GET_ANEXT LOAD_CONST YIELD_FROM POP_BLOCK\\n                    func_async_middle   ::= JUMP_FORWARD COME_FROM_EXCEPT\\n                                            DUP_TOP LOAD_GLOBAL COMPARE_OP POP_JUMP_IF_TRUE\\n                    list_afor2          ::= func_async_prefix\\n                                            store list_iter\\n                                            JUMP_BACK COME_FROM_FINALLY\\n                                            END_ASYNC_FOR\\n                   ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'FORMAT_VALUE_ATTR':\n            rules_str = '\\n                expr              ::= formatted_value2\\n                formatted_value2  ::= expr expr FORMAT_VALUE_ATTR\\n                '\n            self.add_unique_doc_rules(rules_str, customize)\n        elif opname == 'GET_ITER':\n            self.addRule('\\n                    expr      ::= get_iter\\n                    get_iter  ::= expr GET_ITER\\n                    ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'GET_AITER':\n            self.addRule('\\n                    expr                ::= generator_exp_async\\n                    generator_exp_async ::= load_genexpr LOAD_STR MAKE_FUNCTION_0 expr\\n                                            GET_AITER CALL_FUNCTION_1\\n\\n                    stmt                ::= genexpr_func_async\\n\\n                    func_async_prefix   ::= _come_froms SETUP_EXCEPT GET_ANEXT LOAD_CONST YIELD_FROM\\n                    func_async_middle   ::= POP_BLOCK JUMP_FORWARD COME_FROM_EXCEPT\\n                                            DUP_TOP LOAD_GLOBAL COMPARE_OP POP_JUMP_IF_TRUE\\n                                            END_FINALLY COME_FROM\\n                    genexpr_func_async  ::= LOAD_ARG func_async_prefix\\n                                            store func_async_middle comp_iter\\n                                            JUMP_BACK COME_FROM\\n                                            POP_TOP POP_TOP POP_TOP POP_EXCEPT POP_TOP\\n\\n                    expr                ::= list_comp_async\\n                    list_comp_async     ::= LOAD_LISTCOMP LOAD_STR MAKE_FUNCTION_0\\n                                            expr GET_AITER CALL_FUNCTION_1\\n                                            GET_AWAITABLE LOAD_CONST\\n                                            YIELD_FROM\\n\\n                    expr                ::= list_comp_async\\n                    list_afor2          ::= func_async_prefix\\n                                            store func_async_middle list_iter\\n                                            JUMP_BACK COME_FROM\\n                                            POP_TOP POP_TOP POP_TOP POP_EXCEPT POP_TOP\\n                    list_comp_async     ::= BUILD_LIST_0 LOAD_ARG list_afor2\\n                    get_aiter           ::= expr GET_AITER\\n                    list_afor           ::= get_aiter list_afor2\\n                    list_iter           ::= list_afor\\n                   ', nop_func)\n        elif opname == 'JUMP_IF_NOT_DEBUG':\n            v = token.attr\n            self.addRule('\\n                    stmt        ::= assert_pypy\\n                    stmt        ::= assert2_pypy\", nop_func)\\n                    assert_pypy ::=  JUMP_IF_NOT_DEBUG expr jmp_true\\n                                     LOAD_ASSERT RAISE_VARARGS_1 COME_FROM\\n                    assert2_pypy ::= JUMP_IF_NOT_DEBUG assert_expr jmp_true\\n                                     LOAD_ASSERT expr CALL_FUNCTION_1\\n                                     RAISE_VARARGS_1 COME_FROM\\n                    assert2_pypy ::= JUMP_IF_NOT_DEBUG expr jmp_true\\n                                     LOAD_ASSERT expr CALL_FUNCTION_1\\n                                     RAISE_VARARGS_1 COME_FROM,\\n                    ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'LOAD_BUILD_CLASS':\n            self.custom_build_class_rule(opname, i, token, tokens, customize)\n        elif opname == 'LOAD_CLASSDEREF':\n            self.addRule('expr ::= LOAD_CLASSDEREF', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'LOAD_CLASSNAME':\n            self.addRule('expr ::= LOAD_CLASSNAME', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'LOAD_DICTCOMP':\n            if has_get_iter_call_function1:\n                rule_pat = 'dict_comp ::= LOAD_DICTCOMP %sMAKE_FUNCTION_0 expr GET_ITER CALL_FUNCTION_1'\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                pass\n            custom_ops_processed.add(opname)\n        elif opname == 'LOAD_ATTR':\n            self.addRule('\\n                  expr      ::= attribute\\n                  attribute ::= expr LOAD_ATTR\\n                  ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'LOAD_LISTCOMP':\n            self.add_unique_rule('expr ::= listcomp', opname, token.attr, customize)\n            custom_ops_processed.add(opname)\n        elif opname == 'LOAD_NAME':\n            if token.attr == '__annotations__' and 'SETUP_ANNOTATIONS' in self.seen_ops:\n                token.kind = 'LOAD_ANNOTATION'\n                self.addRule('\\n                        stmt       ::= SETUP_ANNOTATIONS\\n                        stmt       ::= ann_assign\\n                        ann_assign ::= expr LOAD_ANNOTATION LOAD_STR STORE_SUBSCR\\n                        ', nop_func)\n                pass\n        elif opname == 'LOAD_SETCOMP':\n            if has_get_iter_call_function1:\n                self.addRule('expr ::= set_comp', nop_func)\n                rule_pat = 'set_comp ::= LOAD_SETCOMP %sMAKE_FUNCTION_0 expr GET_ITER CALL_FUNCTION_1'\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                pass\n            custom_ops_processed.add(opname)\n        elif opname == 'LOOKUP_METHOD':\n            self.addRule('\\n                             expr      ::= attribute\\n                             attribute ::= expr LOOKUP_METHOD\\n                             ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname.startswith('MAKE_CLOSURE'):\n            if opname == 'MAKE_CLOSURE_0' and 'LOAD_DICTCOMP' in self.seen_ops:\n                rule = '\\n                        dict_comp ::= load_closure LOAD_DICTCOMP LOAD_STR\\n                                      MAKE_CLOSURE_0 expr\\n                                      GET_ITER CALL_FUNCTION_1\\n                    '\n                self.addRule(rule, nop_func)\n            (args_pos, args_kw, annotate_args) = token.attr\n            j = 2\n            if is_pypy or (i >= j and tokens[i - j] == 'LOAD_LAMBDA'):\n                rule_pat = 'lambda_body ::= %sload_closure LOAD_LAMBDA %%s%s' % ('pos_arg ' * args_pos, opname)\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n            if has_get_iter_call_function1:\n                rule_pat = 'generator_exp ::= %sload_closure load_genexpr %%s%s expr GET_ITER CALL_FUNCTION_1' % ('pos_arg ' * args_pos, opname)\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                if has_get_iter_call_function1:\n                    if is_pypy or (i >= j and tokens[i - j] == 'LOAD_LISTCOMP'):\n                        rule_pat = 'listcomp ::= %sload_closure LOAD_LISTCOMP %%s%s expr GET_ITER CALL_FUNCTION_1' % ('pos_arg ' * args_pos, opname)\n                        self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                    if is_pypy or (i >= j and tokens[i - j] == 'LOAD_SETCOMP'):\n                        rule_pat = 'set_comp ::= %sload_closure LOAD_SETCOMP %%s%s expr GET_ITER CALL_FUNCTION_1' % ('pos_arg ' * args_pos, opname)\n                        self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                    if is_pypy or (i >= j and tokens[i - j] == 'LOAD_DICTCOMP'):\n                        self.add_unique_rule('dict_comp ::= %sload_closure LOAD_DICTCOMP %s expr GET_ITER CALL_FUNCTION_1' % ('pos_arg ' * args_pos, opname), opname, token.attr, customize)\n            if args_kw > 0:\n                kwargs_str = 'kwargs '\n            else:\n                kwargs_str = ''\n            rule = 'mkfunc ::= %s%s%s load_closure LOAD_CODE LOAD_STR %s' % ('expr ' * args_pos, kwargs_str, 'expr ' * annotate_args, opname)\n            self.add_unique_rule(rule, opname, token.attr, customize)\n            if args_kw == 0:\n                rule = 'mkfunc ::= %sload_closure load_genexpr %s' % ('pos_arg ' * args_pos, opname)\n                self.add_unique_rule(rule, opname, token.attr, customize)\n            pass\n        elif opname_base.startswith('MAKE_FUNCTION'):\n            (args_pos, args_kw, annotate_args, closure) = token.attr\n            stack_count = args_pos + args_kw + annotate_args\n            if closure:\n                if args_pos:\n                    rule = 'lambda_body ::= %s%s%s%s' % ('expr ' * stack_count, 'load_closure ' * closure, 'BUILD_TUPLE_1 LOAD_LAMBDA LOAD_STR ', opname)\n                else:\n                    rule = 'lambda_body ::= %s%s%s' % ('load_closure ' * closure, 'LOAD_LAMBDA LOAD_STR ', opname)\n                self.add_unique_rule(rule, opname, token.attr, customize)\n            else:\n                rule = 'lambda_body ::= %sLOAD_LAMBDA LOAD_STR %s' % ('expr ' * stack_count, opname)\n                self.add_unique_rule(rule, opname, token.attr, customize)\n            rule = 'mkfunc ::= %s%s%s%s' % ('expr ' * stack_count, 'load_closure ' * closure, 'LOAD_CODE LOAD_STR ', opname)\n            self.add_unique_rule(rule, opname, token.attr, customize)\n            if has_get_iter_call_function1:\n                rule_pat = 'generator_exp ::= %sload_genexpr %%s%s expr GET_ITER CALL_FUNCTION_1' % ('pos_arg ' * args_pos, opname)\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                rule_pat = 'generator_exp ::= %sload_closure load_genexpr %%s%s expr GET_ITER CALL_FUNCTION_1' % ('pos_arg ' * args_pos, opname)\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                if is_pypy or (i >= 2 and tokens[i - 2] == 'LOAD_LISTCOMP'):\n                    rule_pat = 'listcomp ::= load_closure LOAD_LISTCOMP %%s%s expr GET_ITER CALL_FUNCTION_1' % (opname,)\n                    self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                    rule_pat = 'listcomp ::= %sLOAD_LISTCOMP %%s%s expr GET_ITER CALL_FUNCTION_1' % ('expr ' * args_pos, opname)\n                    self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n            if is_pypy or (i >= 2 and tokens[i - 2] == 'LOAD_LAMBDA'):\n                rule_pat = 'lambda_body ::= %s%sLOAD_LAMBDA %%s%s' % ('pos_arg ' * args_pos, 'kwarg ' * args_kw, opname)\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n            continue\n            (args_pos, args_kw, annotate_args, closure) = token.attr\n            j = 2\n            if has_get_iter_call_function1:\n                rule_pat = 'generator_exp ::= %sload_genexpr %%s%s expr GET_ITER CALL_FUNCTION_1' % ('pos_arg ' * args_pos, opname)\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                if is_pypy or (i >= j and tokens[i - j] == 'LOAD_LISTCOMP'):\n                    rule_pat = 'listcomp ::= %sLOAD_LISTCOMP %%s%s expr GET_ITER CALL_FUNCTION_1' % ('expr ' * args_pos, opname)\n                    self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n            if is_pypy or (i >= j and tokens[i - j] == 'LOAD_LAMBDA'):\n                rule_pat = 'lambda_body ::= %s%sLOAD_LAMBDA %%s%s' % ('pos_arg ' * args_pos, 'kwarg ' * args_kw, opname)\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n            if args_kw == 0:\n                kwargs = 'no_kwargs'\n                self.add_unique_rule('no_kwargs ::=', opname, token.attr, customize)\n            else:\n                kwargs = 'kwargs'\n            rule = 'mkfunc ::= %s%s %s%s' % ('pos_arg ' * args_pos, kwargs, 'LOAD_CODE LOAD_STR ', opname)\n            self.add_unique_rule(rule, opname, token.attr, customize)\n        elif opname == 'MAKE_FUNCTION_CLOSURE':\n            if 'LOAD_DICTCOMP' in self.seen_ops:\n                rule = '\\n                       dict_comp ::= load_closure LOAD_DICTCOMP LOAD_STR\\n                                     MAKE_FUNCTION_CLOSURE expr\\n                                     GET_ITER CALL_FUNCTION_1\\n                       '\n                self.addRule(rule, nop_func)\n            elif 'LOAD_SETCOMP' in self.seen_ops:\n                rule = '\\n                       set_comp ::= load_closure LOAD_SETCOMP LOAD_STR\\n                                    MAKE_FUNCTION_CLOSURE expr\\n                                    GET_ITER CALL_FUNCTION_1\\n                       '\n                self.addRule(rule, nop_func)\n        elif opname == 'RETURN_VALUE_LAMBDA':\n            self.addRule('\\n                    return_expr_lambda ::= return_expr RETURN_VALUE_LAMBDA\\n                    ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'RAISE_VARARGS_0':\n            self.addRule('\\n                    stmt        ::= raise_stmt0\\n                    raise_stmt0 ::= RAISE_VARARGS_0\\n                    ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'RAISE_VARARGS_1':\n            self.addRule('\\n                    stmt        ::= raise_stmt1\\n                    raise_stmt1 ::= expr RAISE_VARARGS_1\\n                    ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'RAISE_VARARGS_2':\n            self.addRule('\\n                    stmt        ::= raise_stmt2\\n                    raise_stmt2 ::= expr expr RAISE_VARARGS_2\\n                    ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'SETUP_EXCEPT':\n            self.addRule('\\n                    try_except     ::= SETUP_EXCEPT suite_stmts_opt POP_BLOCK\\n                                       except_handler opt_come_from_except\\n\\n                    tryelsestmt    ::= SETUP_EXCEPT suite_stmts_opt POP_BLOCK\\n                                       except_handler else_suite come_from_except_clauses\\n\\n                    tryelsestmt    ::= SETUP_EXCEPT suite_stmts_opt POP_BLOCK\\n                                       except_handler else_suite come_froms\\n\\n                    tryelsestmtl   ::= SETUP_EXCEPT suite_stmts_opt POP_BLOCK\\n                                       except_handler else_suitel come_from_except_clauses\\n\\n                    stmt             ::= tryelsestmtl3\\n                    tryelsestmtl3    ::= SETUP_EXCEPT suite_stmts_opt POP_BLOCK\\n                                         except_handler COME_FROM else_suitel\\n                                         opt_come_from_except\\n                    ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'WITH_CLEANUP_START':\n            rules_str = '\\n                  stmt        ::= with_null\\n                  with_null   ::= with_suffix\\n                  with_suffix ::= WITH_CLEANUP_START WITH_CLEANUP_FINISH END_FINALLY\\n                '\n            self.addRule(rules_str, nop_func)\n        elif opname == 'SETUP_WITH':\n            rules_str = '\\n                  stmt       ::= with\\n                  stmt       ::= withasstmt\\n\\n                  with       ::= expr\\n                                 SETUP_WITH POP_TOP\\n                                 suite_stmts_opt\\n                                 COME_FROM_WITH\\n                                 with_suffix\\n                  withasstmt ::= expr SETUP_WITH store suite_stmts_opt COME_FROM_WITH\\n                                 with_suffix\\n\\n                  with       ::= expr\\n                                 SETUP_WITH POP_TOP\\n                                 suite_stmts_opt\\n                                 POP_BLOCK LOAD_CONST COME_FROM_WITH\\n                                 with_suffix\\n\\n                  withasstmt ::= expr\\n                                 SETUP_WITH store suite_stmts_opt\\n                                 POP_BLOCK LOAD_CONST COME_FROM_WITH\\n                                 with_suffix\\n\\n                  with       ::= expr\\n                                 SETUP_WITH POP_TOP suite_stmts_opt\\n                                 POP_BLOCK LOAD_CONST COME_FROM_WITH\\n                                 with_suffix\\n                  withasstmt ::= expr\\n                                 SETUP_WITH store suite_stmts_opt\\n                                 POP_BLOCK LOAD_CONST COME_FROM_WITH\\n                                 with_suffix\\n                '\n            if self.version < (3, 8):\n                rules_str += '\\n                    with     ::= expr SETUP_WITH POP_TOP suite_stmts_opt POP_BLOCK\\n                                   LOAD_CONST\\n                                   with_suffix\\n                    '\n            else:\n                rules_str += '\\n                      with       ::= expr\\n                                     SETUP_WITH POP_TOP suite_stmts_opt\\n                                     POP_BLOCK LOAD_CONST COME_FROM_WITH\\n                                     with_suffix\\n\\n                      withasstmt ::= expr\\n                                     SETUP_WITH store suite_stmts_opt\\n                                     POP_BLOCK LOAD_CONST COME_FROM_WITH\\n\\n                      withasstmt ::= expr\\n                                     SETUP_WITH store suite_stmts\\n                                     POP_BLOCK BEGIN_FINALLY COME_FROM_WITH with_suffix\\n\\n                      with       ::= expr SETUP_WITH POP_TOP suite_stmts_opt POP_BLOCK\\n                                     BEGIN_FINALLY COME_FROM_WITH\\n                                     with_suffix\\n                    '\n            self.addRule(rules_str, nop_func)\n        elif opname_base in ('UNPACK_EX',):\n            (before_count, after_count) = token.attr\n            rule = 'unpack ::= ' + opname + ' store' * (before_count + after_count + 1)\n            self.addRule(rule, nop_func)\n        elif opname_base in ('UNPACK_TUPLE', 'UNPACK_SEQUENCE'):\n            rule = 'unpack ::= ' + opname + ' store' * token.attr\n            self.addRule(rule, nop_func)\n        elif opname_base == 'UNPACK_LIST':\n            rule = 'unpack_list ::= ' + opname + ' store' * token.attr\n            self.addRule(rule, nop_func)\n            custom_ops_processed.add(opname)\n            pass\n        pass\n    self.reduce_check_table = {'_ifstmts_jump': ifstmts_jump, 'and': and_invalid, 'ifelsestmt': ifelsestmt, 'ifelsestmtl': ifelsestmt, 'iflaststmt': iflaststmt, 'iflaststmtl': iflaststmt, 'ifstmt': ifstmt, 'ifstmtl': ifstmt, 'or': or_check, 'testtrue': testtrue, 'testfalsel': testtrue, 'while1elsestmt': while1elsestmt, 'while1stmt': while1stmt, 'try_elsestmtl38': tryelsestmtl3}\n    self.check_reduce['and'] = 'AST'\n    self.check_reduce['annotate_tuple'] = 'noAST'\n    self.check_reduce['aug_assign1'] = 'AST'\n    self.check_reduce['aug_assign2'] = 'AST'\n    self.check_reduce['while1stmt'] = 'noAST'\n    self.check_reduce['while1elsestmt'] = 'noAST'\n    self.check_reduce['_ifstmts_jump'] = 'AST'\n    self.check_reduce['import_as37'] = 'tokens'\n    self.check_reduce['import_from_as37'] = 'tokens'\n    self.check_reduce['import_from_as37'] = 'tokens'\n    self.check_reduce['ifelsestmt'] = 'AST'\n    self.check_reduce['ifelsestmtl'] = 'AST'\n    self.check_reduce['iflaststmt'] = 'AST'\n    self.check_reduce['iflaststmtl'] = 'AST'\n    self.check_reduce['ifstmt'] = 'AST'\n    self.check_reduce['ifstmtl'] = 'AST'\n    self.check_reduce['import_from37'] = 'AST'\n    self.check_reduce['or'] = 'AST'\n    self.check_reduce['testtrue'] = 'tokens'\n    self.check_reduce['testfalsel'] = 'tokens'\n    return",
            "def customize_grammar_rules(self, tokens, customize):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    is_pypy = False\n    customize_instruction_basenames = frozenset(('BEFORE', 'BUILD', 'CALL', 'CONTINUE', 'DELETE', 'FORMAT', 'GET', 'JUMP', 'LOAD', 'LOOKUP', 'MAKE', 'RETURN', 'RAISE', 'SETUP', 'UNPACK', 'WITH'))\n    custom_ops_processed = set(('BUILD_TUPLE_UNPACK_WITH_CALL',))\n    self.seen_ops = frozenset([t.kind for t in tokens])\n    self.seen_op_basenames = frozenset([opname[:opname.rfind('_')] for opname in self.seen_ops])\n    if 'PyPy' in customize:\n        is_pypy = True\n        self.addRule('\\n              stmt ::= assign3_pypy\\n              stmt ::= assign2_pypy\\n              assign3_pypy       ::= expr expr expr store store store\\n              assign2_pypy       ::= expr expr store store\\n              stmt               ::= if_exp_lambda\\n              stmt               ::= if_exp_not_lambda\\n              if_exp_lambda      ::= expr jmp_false expr return_if_lambda\\n                                     return_expr_lambda LAMBDA_MARKER\\n              if_exp_not_lambda  ::= expr jmp_true expr return_if_lambda\\n                                     return_expr_lambda LAMBDA_MARKER\\n              ', nop_func)\n    n = len(tokens)\n    has_get_iter_call_function1 = False\n    for (i, token) in enumerate(tokens):\n        if token == 'GET_ITER' and i < n - 2 and (self.call_fn_name(tokens[i + 1]) == 'CALL_FUNCTION_1'):\n            has_get_iter_call_function1 = True\n    for (i, token) in enumerate(tokens):\n        opname = token.kind\n        if opname[:opname.find('_')] not in customize_instruction_basenames or opname in custom_ops_processed:\n            continue\n        opname_base = opname[:opname.rfind('_')]\n        if opname == 'LOAD_ASSERT' and 'PyPy' in customize:\n            rules_str = '\\n                stmt ::= JUMP_IF_NOT_DEBUG stmts COME_FROM\\n                '\n            self.add_unique_doc_rules(rules_str, customize)\n        elif opname == 'BEFORE_ASYNC_WITH':\n            rules_str = '\\n                   stmt            ::= async_with_stmt\\n                   stmt            ::= async_with_as_stmt\\n                '\n            if self.version < (3, 8):\n                rules_str += '\\n                      stmt                 ::= async_with_stmt SETUP_ASYNC_WITH\\n                      c_stmt               ::= c_async_with_stmt SETUP_ASYNC_WITH\\n                      async_with_stmt      ::= expr\\n                                               async_with_pre\\n                                               POP_TOP\\n                                               suite_stmts_opt\\n                                               POP_BLOCK LOAD_CONST\\n                                               async_with_post\\n                      c_async_with_stmt    ::= expr\\n                                               async_with_pre\\n                                               POP_TOP\\n                                               c_suite_stmts_opt\\n                                               POP_BLOCK LOAD_CONST\\n                                               async_with_post\\n                      async_with_stmt      ::= expr\\n                                               async_with_pre\\n                                               POP_TOP\\n                                               suite_stmts_opt\\n                                               async_with_post\\n                      c_async_with_stmt    ::= expr\\n                                               async_with_pre\\n                                               POP_TOP\\n                                               c_suite_stmts_opt\\n                                               async_with_post\\n                      async_with_as_stmt   ::= expr\\n                                               async_with_pre\\n                                               store\\n                                               suite_stmts_opt\\n                                               POP_BLOCK LOAD_CONST\\n                                               async_with_post\\n                      c_async_with_as_stmt ::= expr\\n                                              async_with_pre\\n                                              store\\n                                              c_suite_stmts_opt\\n                                              POP_BLOCK LOAD_CONST\\n                                              async_with_post\\n                      async_with_as_stmt   ::= expr\\n                                              async_with_pre\\n                                              store\\n                                              suite_stmts_opt\\n                                              async_with_post\\n                      c_async_with_as_stmt ::= expr\\n                                              async_with_pre\\n                                              store\\n                                              suite_stmts_opt\\n                                              async_with_post\\n                    '\n            else:\n                rules_str += '\\n                      async_with_pre       ::= BEFORE_ASYNC_WITH GET_AWAITABLE LOAD_CONST YIELD_FROM SETUP_ASYNC_WITH\\n                      async_with_post      ::= BEGIN_FINALLY COME_FROM_ASYNC_WITH\\n                                               WITH_CLEANUP_START GET_AWAITABLE LOAD_CONST YIELD_FROM\\n                                               WITH_CLEANUP_FINISH END_FINALLY\\n                      async_with_stmt      ::= expr\\n                                               async_with_pre\\n                                               POP_TOP\\n                                               suite_stmts\\n                                               POP_TOP POP_BLOCK\\n                                               async_with_post\\n                      c_async_with_stmt    ::= expr\\n                                               async_with_pre\\n                                               POP_TOP\\n                                               c_suite_stmts\\n                                               POP_TOP POP_BLOCK\\n                                               async_with_post\\n                      async_with_stmt      ::= expr\\n                                               async_with_pre\\n                                               POP_TOP\\n                                               suite_stmts\\n                                               POP_BLOCK\\n                                               BEGIN_FINALLY\\n                                               WITH_CLEANUP_START GET_AWAITABLE LOAD_CONST YIELD_FROM\\n                                               WITH_CLEANUP_FINISH POP_FINALLY LOAD_CONST RETURN_VALUE\\n                                               COME_FROM_ASYNC_WITH\\n                                               WITH_CLEANUP_START GET_AWAITABLE LOAD_CONST YIELD_FROM\\n                                               WITH_CLEANUP_FINISH END_FINALLY\\n                      c_async_with_stmt   ::= expr\\n                                              async_with_pre\\n                                              POP_TOP\\n                                              c_suite_stmts\\n                                              POP_BLOCK\\n                                              BEGIN_FINALLY\\n                                              WITH_CLEANUP_START GET_AWAITABLE LOAD_CONST YIELD_FROM\\n                                              WITH_CLEANUP_FINISH POP_FINALLY LOAD_CONST RETURN_VALUE\\n                                              COME_FROM_ASYNC_WITH\\n                                              WITH_CLEANUP_START GET_AWAITABLE LOAD_CONST YIELD_FROM\\n                                              WITH_CLEANUP_FINISH END_FINALLY\\n                      async_with_as_stmt   ::= expr\\n                                               async_with_pre\\n                                               store suite_stmts\\n                                               POP_TOP POP_BLOCK\\n                                               async_with_post\\n                      c_async_with_as_stmt ::= expr\\n                                               async_with_pre\\n                                               store suite_stmts\\n                                               POP_TOP POP_BLOCK\\n                                               async_with_post\\n                      async_with_as_stmt   ::= expr\\n                                               async_with_pre\\n                                               store suite_stmts\\n                                               POP_BLOCK async_with_post\\n                      c_async_with_as_stmt ::= expr\\n                                               async_with_pre\\n                                               store suite_stmts\\n                                               POP_BLOCK async_with_post\\n                    '\n            self.addRule(rules_str, nop_func)\n        elif opname in ('BUILD_CONST_LIST', 'BUILD_CONST_DICT', 'BUILD_CONST_SET'):\n            if opname == 'BUILD_CONST_DICT':\n                rule = f'\\n                            add_consts          ::= ADD_VALUE*\\n                            const_list          ::= COLLECTION_START add_consts {opname}\\n                            dict                ::= const_list\\n                            expr                ::= dict\\n                        '\n            else:\n                rule = f'\\n                            add_consts          ::= ADD_VALUE*\\n                            const_list          ::= COLLECTION_START add_consts {opname}\\n                            expr                ::= const_list\\n                        '\n            self.addRule(rule, nop_func)\n        elif opname_base == 'BUILD_CONST_KEY_MAP':\n            kvlist_n = 'expr ' * token.attr\n            rule = 'dict ::= %sLOAD_CONST %s' % (kvlist_n, opname)\n            self.addRule(rule, nop_func)\n        elif opname.startswith('BUILD_LIST_UNPACK'):\n            v = token.attr\n            rule = 'build_list_unpack ::= %s%s' % ('expr ' * v, opname)\n            self.addRule(rule, nop_func)\n            rule = 'expr ::= build_list_unpack'\n            self.addRule(rule, nop_func)\n        elif opname_base in ('BUILD_MAP', 'BUILD_MAP_UNPACK'):\n            if opname == 'BUILD_MAP_UNPACK':\n                self.addRule('\\n                        expr        ::= dict_unpack\\n                        dict_unpack ::= dict_comp BUILD_MAP_UNPACK\\n                        ', nop_func)\n                pass\n            elif opname.startswith('BUILD_MAP_UNPACK_WITH_CALL'):\n                v = token.attr\n                rule = 'build_map_unpack_with_call ::= %s%s' % ('expr ' * v, opname)\n                self.addRule(rule, nop_func)\n            kvlist_n = 'kvlist_%s' % token.attr\n            if opname == 'BUILD_MAP_n':\n                rule = 'dict_comp_func ::= BUILD_MAP_n LOAD_ARG for_iter store comp_iter JUMP_BACK RETURN_VALUE RETURN_LAST'\n                self.add_unique_rule(rule, 'dict_comp_func', 1, customize)\n                kvlist_n = 'kvlist_n'\n                rule = 'kvlist_n ::=  kvlist_n kv3'\n                self.add_unique_rule(rule, 'kvlist_n', 0, customize)\n                rule = 'kvlist_n ::='\n                self.add_unique_rule(rule, 'kvlist_n', 1, customize)\n                rule = 'dict ::=  BUILD_MAP_n kvlist_n'\n            if not opname.startswith('BUILD_MAP_WITH_CALL'):\n                if opname.startswith('BUILD_MAP_UNPACK'):\n                    if 'LOAD_DICTCOMP' in self.seen_ops:\n                        rule = 'dict ::= %s%s' % ('dict_comp ' * token.attr, opname)\n                        self.addRule(rule, nop_func)\n                    rule = '\\n                         expr        ::= dict_unpack\\n                         dict_unpack ::= %s%s\\n                         ' % ('expr ' * token.attr, opname)\n                else:\n                    rule = '%s ::= %s %s' % (kvlist_n, 'expr ' * (token.attr * 2), opname)\n                    self.add_unique_rule(rule, opname, token.attr, customize)\n                    rule = 'dict ::=  %s' % kvlist_n\n            self.add_unique_rule(rule, opname, token.attr, customize)\n        elif opname.startswith('BUILD_MAP_UNPACK_WITH_CALL'):\n            v = token.attr\n            rule = 'build_map_unpack_with_call ::= %s%s' % ('expr ' * v, opname)\n            self.addRule(rule, nop_func)\n        elif opname.startswith('BUILD_TUPLE_UNPACK_WITH_CALL'):\n            v = token.attr\n            rule = 'build_tuple_unpack_with_call ::= ' + 'expr1024 ' * int(v // 1024) + 'expr32 ' * int(v // 32 % 32) + 'expr ' * (v % 32) + opname\n            self.addRule(rule, nop_func)\n            rule = 'starred ::= %s %s' % ('expr ' * v, opname)\n            self.addRule(rule, nop_func)\n        elif opname_base in ('BUILD_LIST', 'BUILD_SET', 'BUILD_TUPLE', 'BUILD_TUPLE_UNPACK'):\n            collection_size = token.attr\n            is_LOAD_CLOSURE = False\n            if opname_base == 'BUILD_TUPLE':\n                is_LOAD_CLOSURE = True\n                for j in range(collection_size):\n                    if tokens[i - j - 1].kind != 'LOAD_CLOSURE':\n                        is_LOAD_CLOSURE = False\n                        break\n                if is_LOAD_CLOSURE:\n                    rule = 'load_closure ::= %s%s' % ('LOAD_CLOSURE ' * collection_size, opname)\n                    self.add_unique_rule(rule, opname, token.attr, customize)\n            if not is_LOAD_CLOSURE or collection_size == 0:\n                thousands = collection_size // 1024\n                thirty32s = collection_size // 32 % 32\n                if thirty32s > 0:\n                    rule = 'expr32 ::=%s' % (' expr' * 32)\n                    self.add_unique_rule(rule, opname_base, collection_size, customize)\n                    pass\n                if thousands > 0:\n                    self.add_unique_rule('expr1024 ::=%s' % (' expr32' * 32), opname_base, collection_size, customize)\n                    pass\n                collection = opname_base[opname_base.find('_') + 1:].lower()\n                rule = '%s ::= ' % collection + 'expr1024 ' * thousands + 'expr32 ' * thirty32s + 'expr ' * (collection_size % 32) + opname\n                self.add_unique_rules(['expr ::= %s' % collection, rule], customize)\n                continue\n            continue\n        elif opname_base == 'BUILD_SLICE':\n            if token.attr == 2:\n                self.add_unique_rules(['expr ::= slice2', 'slice2 ::= expr expr BUILD_SLICE_2'], customize)\n            else:\n                assert token.attr == 3, 'BUILD_SLICE value must be 2 or 3; is %s' % token.attr\n                self.add_unique_rules(['expr   ::= slice3', 'slice3 ::= expr expr expr BUILD_SLICE_3'], customize)\n        elif opname.startswith('BUILD_STRING'):\n            v = token.attr\n            rules_str = '\\n                    expr                 ::= joined_str\\n                    joined_str           ::= %sBUILD_STRING_%d\\n                ' % ('expr ' * v, v)\n            self.add_unique_doc_rules(rules_str, customize)\n            if 'FORMAT_VALUE_ATTR' in self.seen_ops:\n                rules_str = '\\n                      formatted_value_attr ::= expr expr FORMAT_VALUE_ATTR expr BUILD_STRING\\n                      expr                 ::= formatted_value_attr\\n                    '\n                self.add_unique_doc_rules(rules_str, customize)\n        elif opname in frozenset(('CALL_FUNCTION', 'CALL_FUNCTION_EX', 'CALL_FUNCTION_EX_KW', 'CALL_FUNCTION_VAR', 'CALL_FUNCTION_VAR_KW')) or opname.startswith('CALL_FUNCTION_KW'):\n            if opname == 'CALL_FUNCTION' and token.attr == 1:\n                rule = '\\n                     expr         ::= dict_comp\\n                     dict_comp    ::= LOAD_DICTCOMP LOAD_STR MAKE_FUNCTION_0 expr\\n                                      GET_ITER CALL_FUNCTION_1\\n                    classdefdeco1 ::= expr classdefdeco2 CALL_FUNCTION_1\\n                    classdefdeco1 ::= expr classdefdeco1 CALL_FUNCTION_1\\n                    '\n                self.addRule(rule, nop_func)\n            self.custom_classfunc_rule(opname, token, customize, tokens[i + 1])\n        elif opname_base == 'CALL_METHOD':\n            (args_pos, args_kw) = self.get_pos_kw(token)\n            if opname == 'CALL_METHOD_KW':\n                args_kw = token.attr\n                rules_str = '\\n                         expr ::= call_kw_pypy37\\n                         pypy_kw_keys ::= LOAD_CONST\\n                    '\n                self.add_unique_doc_rules(rules_str, customize)\n                rule = 'call_kw_pypy37 ::= expr ' + 'expr ' * args_kw + ' pypy_kw_keys ' + opname\n            else:\n                (args_pos, args_kw) = self.get_pos_kw(token)\n                nak = (len(opname_base) - len('CALL_METHOD')) // 3\n                rule = 'call ::= expr ' + 'pos_arg ' * args_pos + 'kwarg ' * args_kw + 'expr ' * nak + opname\n            self.add_unique_rule(rule, opname, token.attr, customize)\n        elif opname == 'CONTINUE':\n            self.addRule('continue ::= CONTINUE', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'CONTINUE_LOOP':\n            self.addRule('continue ::= CONTINUE_LOOP', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'DELETE_ATTR':\n            self.addRule('delete ::= expr DELETE_ATTR', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'DELETE_DEREF':\n            self.addRule('\\n                   stmt           ::= del_deref_stmt\\n                   del_deref_stmt ::= DELETE_DEREF\\n                   ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'DELETE_SUBSCR':\n            self.addRule('\\n                    delete ::= delete_subscript\\n                    delete_subscript ::= expr expr DELETE_SUBSCR\\n                   ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'FORMAT_VALUE':\n            rules_str = '\\n                    expr              ::= formatted_value1\\n                    formatted_value1  ::= expr FORMAT_VALUE\\n                '\n            self.add_unique_doc_rules(rules_str, customize)\n        elif opname == 'GET_ANEXT':\n            self.addRule('\\n                    func_async_prefix   ::= _come_froms SETUP_FINALLY GET_ANEXT LOAD_CONST YIELD_FROM POP_BLOCK\\n                    func_async_middle   ::= JUMP_FORWARD COME_FROM_EXCEPT\\n                                            DUP_TOP LOAD_GLOBAL COMPARE_OP POP_JUMP_IF_TRUE\\n                    list_afor2          ::= func_async_prefix\\n                                            store list_iter\\n                                            JUMP_BACK COME_FROM_FINALLY\\n                                            END_ASYNC_FOR\\n                   ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'FORMAT_VALUE_ATTR':\n            rules_str = '\\n                expr              ::= formatted_value2\\n                formatted_value2  ::= expr expr FORMAT_VALUE_ATTR\\n                '\n            self.add_unique_doc_rules(rules_str, customize)\n        elif opname == 'GET_ITER':\n            self.addRule('\\n                    expr      ::= get_iter\\n                    get_iter  ::= expr GET_ITER\\n                    ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'GET_AITER':\n            self.addRule('\\n                    expr                ::= generator_exp_async\\n                    generator_exp_async ::= load_genexpr LOAD_STR MAKE_FUNCTION_0 expr\\n                                            GET_AITER CALL_FUNCTION_1\\n\\n                    stmt                ::= genexpr_func_async\\n\\n                    func_async_prefix   ::= _come_froms SETUP_EXCEPT GET_ANEXT LOAD_CONST YIELD_FROM\\n                    func_async_middle   ::= POP_BLOCK JUMP_FORWARD COME_FROM_EXCEPT\\n                                            DUP_TOP LOAD_GLOBAL COMPARE_OP POP_JUMP_IF_TRUE\\n                                            END_FINALLY COME_FROM\\n                    genexpr_func_async  ::= LOAD_ARG func_async_prefix\\n                                            store func_async_middle comp_iter\\n                                            JUMP_BACK COME_FROM\\n                                            POP_TOP POP_TOP POP_TOP POP_EXCEPT POP_TOP\\n\\n                    expr                ::= list_comp_async\\n                    list_comp_async     ::= LOAD_LISTCOMP LOAD_STR MAKE_FUNCTION_0\\n                                            expr GET_AITER CALL_FUNCTION_1\\n                                            GET_AWAITABLE LOAD_CONST\\n                                            YIELD_FROM\\n\\n                    expr                ::= list_comp_async\\n                    list_afor2          ::= func_async_prefix\\n                                            store func_async_middle list_iter\\n                                            JUMP_BACK COME_FROM\\n                                            POP_TOP POP_TOP POP_TOP POP_EXCEPT POP_TOP\\n                    list_comp_async     ::= BUILD_LIST_0 LOAD_ARG list_afor2\\n                    get_aiter           ::= expr GET_AITER\\n                    list_afor           ::= get_aiter list_afor2\\n                    list_iter           ::= list_afor\\n                   ', nop_func)\n        elif opname == 'JUMP_IF_NOT_DEBUG':\n            v = token.attr\n            self.addRule('\\n                    stmt        ::= assert_pypy\\n                    stmt        ::= assert2_pypy\", nop_func)\\n                    assert_pypy ::=  JUMP_IF_NOT_DEBUG expr jmp_true\\n                                     LOAD_ASSERT RAISE_VARARGS_1 COME_FROM\\n                    assert2_pypy ::= JUMP_IF_NOT_DEBUG assert_expr jmp_true\\n                                     LOAD_ASSERT expr CALL_FUNCTION_1\\n                                     RAISE_VARARGS_1 COME_FROM\\n                    assert2_pypy ::= JUMP_IF_NOT_DEBUG expr jmp_true\\n                                     LOAD_ASSERT expr CALL_FUNCTION_1\\n                                     RAISE_VARARGS_1 COME_FROM,\\n                    ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'LOAD_BUILD_CLASS':\n            self.custom_build_class_rule(opname, i, token, tokens, customize)\n        elif opname == 'LOAD_CLASSDEREF':\n            self.addRule('expr ::= LOAD_CLASSDEREF', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'LOAD_CLASSNAME':\n            self.addRule('expr ::= LOAD_CLASSNAME', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'LOAD_DICTCOMP':\n            if has_get_iter_call_function1:\n                rule_pat = 'dict_comp ::= LOAD_DICTCOMP %sMAKE_FUNCTION_0 expr GET_ITER CALL_FUNCTION_1'\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                pass\n            custom_ops_processed.add(opname)\n        elif opname == 'LOAD_ATTR':\n            self.addRule('\\n                  expr      ::= attribute\\n                  attribute ::= expr LOAD_ATTR\\n                  ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'LOAD_LISTCOMP':\n            self.add_unique_rule('expr ::= listcomp', opname, token.attr, customize)\n            custom_ops_processed.add(opname)\n        elif opname == 'LOAD_NAME':\n            if token.attr == '__annotations__' and 'SETUP_ANNOTATIONS' in self.seen_ops:\n                token.kind = 'LOAD_ANNOTATION'\n                self.addRule('\\n                        stmt       ::= SETUP_ANNOTATIONS\\n                        stmt       ::= ann_assign\\n                        ann_assign ::= expr LOAD_ANNOTATION LOAD_STR STORE_SUBSCR\\n                        ', nop_func)\n                pass\n        elif opname == 'LOAD_SETCOMP':\n            if has_get_iter_call_function1:\n                self.addRule('expr ::= set_comp', nop_func)\n                rule_pat = 'set_comp ::= LOAD_SETCOMP %sMAKE_FUNCTION_0 expr GET_ITER CALL_FUNCTION_1'\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                pass\n            custom_ops_processed.add(opname)\n        elif opname == 'LOOKUP_METHOD':\n            self.addRule('\\n                             expr      ::= attribute\\n                             attribute ::= expr LOOKUP_METHOD\\n                             ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname.startswith('MAKE_CLOSURE'):\n            if opname == 'MAKE_CLOSURE_0' and 'LOAD_DICTCOMP' in self.seen_ops:\n                rule = '\\n                        dict_comp ::= load_closure LOAD_DICTCOMP LOAD_STR\\n                                      MAKE_CLOSURE_0 expr\\n                                      GET_ITER CALL_FUNCTION_1\\n                    '\n                self.addRule(rule, nop_func)\n            (args_pos, args_kw, annotate_args) = token.attr\n            j = 2\n            if is_pypy or (i >= j and tokens[i - j] == 'LOAD_LAMBDA'):\n                rule_pat = 'lambda_body ::= %sload_closure LOAD_LAMBDA %%s%s' % ('pos_arg ' * args_pos, opname)\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n            if has_get_iter_call_function1:\n                rule_pat = 'generator_exp ::= %sload_closure load_genexpr %%s%s expr GET_ITER CALL_FUNCTION_1' % ('pos_arg ' * args_pos, opname)\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                if has_get_iter_call_function1:\n                    if is_pypy or (i >= j and tokens[i - j] == 'LOAD_LISTCOMP'):\n                        rule_pat = 'listcomp ::= %sload_closure LOAD_LISTCOMP %%s%s expr GET_ITER CALL_FUNCTION_1' % ('pos_arg ' * args_pos, opname)\n                        self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                    if is_pypy or (i >= j and tokens[i - j] == 'LOAD_SETCOMP'):\n                        rule_pat = 'set_comp ::= %sload_closure LOAD_SETCOMP %%s%s expr GET_ITER CALL_FUNCTION_1' % ('pos_arg ' * args_pos, opname)\n                        self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                    if is_pypy or (i >= j and tokens[i - j] == 'LOAD_DICTCOMP'):\n                        self.add_unique_rule('dict_comp ::= %sload_closure LOAD_DICTCOMP %s expr GET_ITER CALL_FUNCTION_1' % ('pos_arg ' * args_pos, opname), opname, token.attr, customize)\n            if args_kw > 0:\n                kwargs_str = 'kwargs '\n            else:\n                kwargs_str = ''\n            rule = 'mkfunc ::= %s%s%s load_closure LOAD_CODE LOAD_STR %s' % ('expr ' * args_pos, kwargs_str, 'expr ' * annotate_args, opname)\n            self.add_unique_rule(rule, opname, token.attr, customize)\n            if args_kw == 0:\n                rule = 'mkfunc ::= %sload_closure load_genexpr %s' % ('pos_arg ' * args_pos, opname)\n                self.add_unique_rule(rule, opname, token.attr, customize)\n            pass\n        elif opname_base.startswith('MAKE_FUNCTION'):\n            (args_pos, args_kw, annotate_args, closure) = token.attr\n            stack_count = args_pos + args_kw + annotate_args\n            if closure:\n                if args_pos:\n                    rule = 'lambda_body ::= %s%s%s%s' % ('expr ' * stack_count, 'load_closure ' * closure, 'BUILD_TUPLE_1 LOAD_LAMBDA LOAD_STR ', opname)\n                else:\n                    rule = 'lambda_body ::= %s%s%s' % ('load_closure ' * closure, 'LOAD_LAMBDA LOAD_STR ', opname)\n                self.add_unique_rule(rule, opname, token.attr, customize)\n            else:\n                rule = 'lambda_body ::= %sLOAD_LAMBDA LOAD_STR %s' % ('expr ' * stack_count, opname)\n                self.add_unique_rule(rule, opname, token.attr, customize)\n            rule = 'mkfunc ::= %s%s%s%s' % ('expr ' * stack_count, 'load_closure ' * closure, 'LOAD_CODE LOAD_STR ', opname)\n            self.add_unique_rule(rule, opname, token.attr, customize)\n            if has_get_iter_call_function1:\n                rule_pat = 'generator_exp ::= %sload_genexpr %%s%s expr GET_ITER CALL_FUNCTION_1' % ('pos_arg ' * args_pos, opname)\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                rule_pat = 'generator_exp ::= %sload_closure load_genexpr %%s%s expr GET_ITER CALL_FUNCTION_1' % ('pos_arg ' * args_pos, opname)\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                if is_pypy or (i >= 2 and tokens[i - 2] == 'LOAD_LISTCOMP'):\n                    rule_pat = 'listcomp ::= load_closure LOAD_LISTCOMP %%s%s expr GET_ITER CALL_FUNCTION_1' % (opname,)\n                    self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                    rule_pat = 'listcomp ::= %sLOAD_LISTCOMP %%s%s expr GET_ITER CALL_FUNCTION_1' % ('expr ' * args_pos, opname)\n                    self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n            if is_pypy or (i >= 2 and tokens[i - 2] == 'LOAD_LAMBDA'):\n                rule_pat = 'lambda_body ::= %s%sLOAD_LAMBDA %%s%s' % ('pos_arg ' * args_pos, 'kwarg ' * args_kw, opname)\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n            continue\n            (args_pos, args_kw, annotate_args, closure) = token.attr\n            j = 2\n            if has_get_iter_call_function1:\n                rule_pat = 'generator_exp ::= %sload_genexpr %%s%s expr GET_ITER CALL_FUNCTION_1' % ('pos_arg ' * args_pos, opname)\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n                if is_pypy or (i >= j and tokens[i - j] == 'LOAD_LISTCOMP'):\n                    rule_pat = 'listcomp ::= %sLOAD_LISTCOMP %%s%s expr GET_ITER CALL_FUNCTION_1' % ('expr ' * args_pos, opname)\n                    self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n            if is_pypy or (i >= j and tokens[i - j] == 'LOAD_LAMBDA'):\n                rule_pat = 'lambda_body ::= %s%sLOAD_LAMBDA %%s%s' % ('pos_arg ' * args_pos, 'kwarg ' * args_kw, opname)\n                self.add_make_function_rule(rule_pat, opname, token.attr, customize)\n            if args_kw == 0:\n                kwargs = 'no_kwargs'\n                self.add_unique_rule('no_kwargs ::=', opname, token.attr, customize)\n            else:\n                kwargs = 'kwargs'\n            rule = 'mkfunc ::= %s%s %s%s' % ('pos_arg ' * args_pos, kwargs, 'LOAD_CODE LOAD_STR ', opname)\n            self.add_unique_rule(rule, opname, token.attr, customize)\n        elif opname == 'MAKE_FUNCTION_CLOSURE':\n            if 'LOAD_DICTCOMP' in self.seen_ops:\n                rule = '\\n                       dict_comp ::= load_closure LOAD_DICTCOMP LOAD_STR\\n                                     MAKE_FUNCTION_CLOSURE expr\\n                                     GET_ITER CALL_FUNCTION_1\\n                       '\n                self.addRule(rule, nop_func)\n            elif 'LOAD_SETCOMP' in self.seen_ops:\n                rule = '\\n                       set_comp ::= load_closure LOAD_SETCOMP LOAD_STR\\n                                    MAKE_FUNCTION_CLOSURE expr\\n                                    GET_ITER CALL_FUNCTION_1\\n                       '\n                self.addRule(rule, nop_func)\n        elif opname == 'RETURN_VALUE_LAMBDA':\n            self.addRule('\\n                    return_expr_lambda ::= return_expr RETURN_VALUE_LAMBDA\\n                    ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'RAISE_VARARGS_0':\n            self.addRule('\\n                    stmt        ::= raise_stmt0\\n                    raise_stmt0 ::= RAISE_VARARGS_0\\n                    ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'RAISE_VARARGS_1':\n            self.addRule('\\n                    stmt        ::= raise_stmt1\\n                    raise_stmt1 ::= expr RAISE_VARARGS_1\\n                    ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'RAISE_VARARGS_2':\n            self.addRule('\\n                    stmt        ::= raise_stmt2\\n                    raise_stmt2 ::= expr expr RAISE_VARARGS_2\\n                    ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'SETUP_EXCEPT':\n            self.addRule('\\n                    try_except     ::= SETUP_EXCEPT suite_stmts_opt POP_BLOCK\\n                                       except_handler opt_come_from_except\\n\\n                    tryelsestmt    ::= SETUP_EXCEPT suite_stmts_opt POP_BLOCK\\n                                       except_handler else_suite come_from_except_clauses\\n\\n                    tryelsestmt    ::= SETUP_EXCEPT suite_stmts_opt POP_BLOCK\\n                                       except_handler else_suite come_froms\\n\\n                    tryelsestmtl   ::= SETUP_EXCEPT suite_stmts_opt POP_BLOCK\\n                                       except_handler else_suitel come_from_except_clauses\\n\\n                    stmt             ::= tryelsestmtl3\\n                    tryelsestmtl3    ::= SETUP_EXCEPT suite_stmts_opt POP_BLOCK\\n                                         except_handler COME_FROM else_suitel\\n                                         opt_come_from_except\\n                    ', nop_func)\n            custom_ops_processed.add(opname)\n        elif opname == 'WITH_CLEANUP_START':\n            rules_str = '\\n                  stmt        ::= with_null\\n                  with_null   ::= with_suffix\\n                  with_suffix ::= WITH_CLEANUP_START WITH_CLEANUP_FINISH END_FINALLY\\n                '\n            self.addRule(rules_str, nop_func)\n        elif opname == 'SETUP_WITH':\n            rules_str = '\\n                  stmt       ::= with\\n                  stmt       ::= withasstmt\\n\\n                  with       ::= expr\\n                                 SETUP_WITH POP_TOP\\n                                 suite_stmts_opt\\n                                 COME_FROM_WITH\\n                                 with_suffix\\n                  withasstmt ::= expr SETUP_WITH store suite_stmts_opt COME_FROM_WITH\\n                                 with_suffix\\n\\n                  with       ::= expr\\n                                 SETUP_WITH POP_TOP\\n                                 suite_stmts_opt\\n                                 POP_BLOCK LOAD_CONST COME_FROM_WITH\\n                                 with_suffix\\n\\n                  withasstmt ::= expr\\n                                 SETUP_WITH store suite_stmts_opt\\n                                 POP_BLOCK LOAD_CONST COME_FROM_WITH\\n                                 with_suffix\\n\\n                  with       ::= expr\\n                                 SETUP_WITH POP_TOP suite_stmts_opt\\n                                 POP_BLOCK LOAD_CONST COME_FROM_WITH\\n                                 with_suffix\\n                  withasstmt ::= expr\\n                                 SETUP_WITH store suite_stmts_opt\\n                                 POP_BLOCK LOAD_CONST COME_FROM_WITH\\n                                 with_suffix\\n                '\n            if self.version < (3, 8):\n                rules_str += '\\n                    with     ::= expr SETUP_WITH POP_TOP suite_stmts_opt POP_BLOCK\\n                                   LOAD_CONST\\n                                   with_suffix\\n                    '\n            else:\n                rules_str += '\\n                      with       ::= expr\\n                                     SETUP_WITH POP_TOP suite_stmts_opt\\n                                     POP_BLOCK LOAD_CONST COME_FROM_WITH\\n                                     with_suffix\\n\\n                      withasstmt ::= expr\\n                                     SETUP_WITH store suite_stmts_opt\\n                                     POP_BLOCK LOAD_CONST COME_FROM_WITH\\n\\n                      withasstmt ::= expr\\n                                     SETUP_WITH store suite_stmts\\n                                     POP_BLOCK BEGIN_FINALLY COME_FROM_WITH with_suffix\\n\\n                      with       ::= expr SETUP_WITH POP_TOP suite_stmts_opt POP_BLOCK\\n                                     BEGIN_FINALLY COME_FROM_WITH\\n                                     with_suffix\\n                    '\n            self.addRule(rules_str, nop_func)\n        elif opname_base in ('UNPACK_EX',):\n            (before_count, after_count) = token.attr\n            rule = 'unpack ::= ' + opname + ' store' * (before_count + after_count + 1)\n            self.addRule(rule, nop_func)\n        elif opname_base in ('UNPACK_TUPLE', 'UNPACK_SEQUENCE'):\n            rule = 'unpack ::= ' + opname + ' store' * token.attr\n            self.addRule(rule, nop_func)\n        elif opname_base == 'UNPACK_LIST':\n            rule = 'unpack_list ::= ' + opname + ' store' * token.attr\n            self.addRule(rule, nop_func)\n            custom_ops_processed.add(opname)\n            pass\n        pass\n    self.reduce_check_table = {'_ifstmts_jump': ifstmts_jump, 'and': and_invalid, 'ifelsestmt': ifelsestmt, 'ifelsestmtl': ifelsestmt, 'iflaststmt': iflaststmt, 'iflaststmtl': iflaststmt, 'ifstmt': ifstmt, 'ifstmtl': ifstmt, 'or': or_check, 'testtrue': testtrue, 'testfalsel': testtrue, 'while1elsestmt': while1elsestmt, 'while1stmt': while1stmt, 'try_elsestmtl38': tryelsestmtl3}\n    self.check_reduce['and'] = 'AST'\n    self.check_reduce['annotate_tuple'] = 'noAST'\n    self.check_reduce['aug_assign1'] = 'AST'\n    self.check_reduce['aug_assign2'] = 'AST'\n    self.check_reduce['while1stmt'] = 'noAST'\n    self.check_reduce['while1elsestmt'] = 'noAST'\n    self.check_reduce['_ifstmts_jump'] = 'AST'\n    self.check_reduce['import_as37'] = 'tokens'\n    self.check_reduce['import_from_as37'] = 'tokens'\n    self.check_reduce['import_from_as37'] = 'tokens'\n    self.check_reduce['ifelsestmt'] = 'AST'\n    self.check_reduce['ifelsestmtl'] = 'AST'\n    self.check_reduce['iflaststmt'] = 'AST'\n    self.check_reduce['iflaststmtl'] = 'AST'\n    self.check_reduce['ifstmt'] = 'AST'\n    self.check_reduce['ifstmtl'] = 'AST'\n    self.check_reduce['import_from37'] = 'AST'\n    self.check_reduce['or'] = 'AST'\n    self.check_reduce['testtrue'] = 'tokens'\n    self.check_reduce['testfalsel'] = 'tokens'\n    return"
        ]
    },
    {
        "func_name": "custom_classfunc_rule",
        "original": "def custom_classfunc_rule(self, opname, token, customize, next_token):\n    \"\"\"\n        call ::= expr {expr}^n CALL_FUNCTION_n\n        call ::= expr {expr}^n CALL_FUNCTION_VAR_n\n        call ::= expr {expr}^n CALL_FUNCTION_VAR_KW_n\n        call ::= expr {expr}^n CALL_FUNCTION_KW_n\n\n        classdefdeco2 ::= LOAD_BUILD_CLASS mkfunc {expr}^n-1 CALL_FUNCTION_n\n        \"\"\"\n    (args_pos, args_kw) = self.get_pos_kw(token)\n    nak = (len(opname) - len('CALL_FUNCTION')) // 3\n    uniq_param = args_kw + args_pos\n    if frozenset(('GET_AWAITABLE', 'YIELD_FROM')).issubset(self.seen_ops):\n        rule = 'async_call ::= expr ' + 'pos_arg ' * args_pos + 'kwarg ' * args_kw + 'expr ' * nak + token.kind + ' GET_AWAITABLE LOAD_CONST YIELD_FROM'\n        self.add_unique_rule(rule, token.kind, uniq_param, customize)\n        self.add_unique_rule('expr ::= async_call', token.kind, uniq_param, customize)\n    if opname.startswith('CALL_FUNCTION_VAR'):\n        token.kind = self.call_fn_name(token)\n        if opname.endswith('KW'):\n            kw = 'expr '\n        else:\n            kw = ''\n        rule = 'call ::= expr expr ' + 'pos_arg ' * args_pos + 'kwarg ' * args_kw + kw + token.kind\n        self.add_unique_rule(rule, token.kind, args_pos, customize)\n    else:\n        token.kind = self.call_fn_name(token)\n        uniq_param = args_kw + args_pos\n        rule = 'call ::= expr ' + 'pos_arg ' * args_pos + 'kwarg ' * args_kw + 'expr ' * nak + token.kind\n        self.add_unique_rule(rule, token.kind, uniq_param, customize)\n        if 'LOAD_BUILD_CLASS' in self.seen_ops:\n            if next_token == 'CALL_FUNCTION' and next_token.attr == 1 and (args_pos > 1):\n                rule = 'classdefdeco2 ::= LOAD_BUILD_CLASS mkfunc %s%s_%d' % ('expr ' * (args_pos - 1), opname, args_pos)\n                self.add_unique_rule(rule, token.kind, uniq_param, customize)",
        "mutated": [
            "def custom_classfunc_rule(self, opname, token, customize, next_token):\n    if False:\n        i = 10\n    '\\n        call ::= expr {expr}^n CALL_FUNCTION_n\\n        call ::= expr {expr}^n CALL_FUNCTION_VAR_n\\n        call ::= expr {expr}^n CALL_FUNCTION_VAR_KW_n\\n        call ::= expr {expr}^n CALL_FUNCTION_KW_n\\n\\n        classdefdeco2 ::= LOAD_BUILD_CLASS mkfunc {expr}^n-1 CALL_FUNCTION_n\\n        '\n    (args_pos, args_kw) = self.get_pos_kw(token)\n    nak = (len(opname) - len('CALL_FUNCTION')) // 3\n    uniq_param = args_kw + args_pos\n    if frozenset(('GET_AWAITABLE', 'YIELD_FROM')).issubset(self.seen_ops):\n        rule = 'async_call ::= expr ' + 'pos_arg ' * args_pos + 'kwarg ' * args_kw + 'expr ' * nak + token.kind + ' GET_AWAITABLE LOAD_CONST YIELD_FROM'\n        self.add_unique_rule(rule, token.kind, uniq_param, customize)\n        self.add_unique_rule('expr ::= async_call', token.kind, uniq_param, customize)\n    if opname.startswith('CALL_FUNCTION_VAR'):\n        token.kind = self.call_fn_name(token)\n        if opname.endswith('KW'):\n            kw = 'expr '\n        else:\n            kw = ''\n        rule = 'call ::= expr expr ' + 'pos_arg ' * args_pos + 'kwarg ' * args_kw + kw + token.kind\n        self.add_unique_rule(rule, token.kind, args_pos, customize)\n    else:\n        token.kind = self.call_fn_name(token)\n        uniq_param = args_kw + args_pos\n        rule = 'call ::= expr ' + 'pos_arg ' * args_pos + 'kwarg ' * args_kw + 'expr ' * nak + token.kind\n        self.add_unique_rule(rule, token.kind, uniq_param, customize)\n        if 'LOAD_BUILD_CLASS' in self.seen_ops:\n            if next_token == 'CALL_FUNCTION' and next_token.attr == 1 and (args_pos > 1):\n                rule = 'classdefdeco2 ::= LOAD_BUILD_CLASS mkfunc %s%s_%d' % ('expr ' * (args_pos - 1), opname, args_pos)\n                self.add_unique_rule(rule, token.kind, uniq_param, customize)",
            "def custom_classfunc_rule(self, opname, token, customize, next_token):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        call ::= expr {expr}^n CALL_FUNCTION_n\\n        call ::= expr {expr}^n CALL_FUNCTION_VAR_n\\n        call ::= expr {expr}^n CALL_FUNCTION_VAR_KW_n\\n        call ::= expr {expr}^n CALL_FUNCTION_KW_n\\n\\n        classdefdeco2 ::= LOAD_BUILD_CLASS mkfunc {expr}^n-1 CALL_FUNCTION_n\\n        '\n    (args_pos, args_kw) = self.get_pos_kw(token)\n    nak = (len(opname) - len('CALL_FUNCTION')) // 3\n    uniq_param = args_kw + args_pos\n    if frozenset(('GET_AWAITABLE', 'YIELD_FROM')).issubset(self.seen_ops):\n        rule = 'async_call ::= expr ' + 'pos_arg ' * args_pos + 'kwarg ' * args_kw + 'expr ' * nak + token.kind + ' GET_AWAITABLE LOAD_CONST YIELD_FROM'\n        self.add_unique_rule(rule, token.kind, uniq_param, customize)\n        self.add_unique_rule('expr ::= async_call', token.kind, uniq_param, customize)\n    if opname.startswith('CALL_FUNCTION_VAR'):\n        token.kind = self.call_fn_name(token)\n        if opname.endswith('KW'):\n            kw = 'expr '\n        else:\n            kw = ''\n        rule = 'call ::= expr expr ' + 'pos_arg ' * args_pos + 'kwarg ' * args_kw + kw + token.kind\n        self.add_unique_rule(rule, token.kind, args_pos, customize)\n    else:\n        token.kind = self.call_fn_name(token)\n        uniq_param = args_kw + args_pos\n        rule = 'call ::= expr ' + 'pos_arg ' * args_pos + 'kwarg ' * args_kw + 'expr ' * nak + token.kind\n        self.add_unique_rule(rule, token.kind, uniq_param, customize)\n        if 'LOAD_BUILD_CLASS' in self.seen_ops:\n            if next_token == 'CALL_FUNCTION' and next_token.attr == 1 and (args_pos > 1):\n                rule = 'classdefdeco2 ::= LOAD_BUILD_CLASS mkfunc %s%s_%d' % ('expr ' * (args_pos - 1), opname, args_pos)\n                self.add_unique_rule(rule, token.kind, uniq_param, customize)",
            "def custom_classfunc_rule(self, opname, token, customize, next_token):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        call ::= expr {expr}^n CALL_FUNCTION_n\\n        call ::= expr {expr}^n CALL_FUNCTION_VAR_n\\n        call ::= expr {expr}^n CALL_FUNCTION_VAR_KW_n\\n        call ::= expr {expr}^n CALL_FUNCTION_KW_n\\n\\n        classdefdeco2 ::= LOAD_BUILD_CLASS mkfunc {expr}^n-1 CALL_FUNCTION_n\\n        '\n    (args_pos, args_kw) = self.get_pos_kw(token)\n    nak = (len(opname) - len('CALL_FUNCTION')) // 3\n    uniq_param = args_kw + args_pos\n    if frozenset(('GET_AWAITABLE', 'YIELD_FROM')).issubset(self.seen_ops):\n        rule = 'async_call ::= expr ' + 'pos_arg ' * args_pos + 'kwarg ' * args_kw + 'expr ' * nak + token.kind + ' GET_AWAITABLE LOAD_CONST YIELD_FROM'\n        self.add_unique_rule(rule, token.kind, uniq_param, customize)\n        self.add_unique_rule('expr ::= async_call', token.kind, uniq_param, customize)\n    if opname.startswith('CALL_FUNCTION_VAR'):\n        token.kind = self.call_fn_name(token)\n        if opname.endswith('KW'):\n            kw = 'expr '\n        else:\n            kw = ''\n        rule = 'call ::= expr expr ' + 'pos_arg ' * args_pos + 'kwarg ' * args_kw + kw + token.kind\n        self.add_unique_rule(rule, token.kind, args_pos, customize)\n    else:\n        token.kind = self.call_fn_name(token)\n        uniq_param = args_kw + args_pos\n        rule = 'call ::= expr ' + 'pos_arg ' * args_pos + 'kwarg ' * args_kw + 'expr ' * nak + token.kind\n        self.add_unique_rule(rule, token.kind, uniq_param, customize)\n        if 'LOAD_BUILD_CLASS' in self.seen_ops:\n            if next_token == 'CALL_FUNCTION' and next_token.attr == 1 and (args_pos > 1):\n                rule = 'classdefdeco2 ::= LOAD_BUILD_CLASS mkfunc %s%s_%d' % ('expr ' * (args_pos - 1), opname, args_pos)\n                self.add_unique_rule(rule, token.kind, uniq_param, customize)",
            "def custom_classfunc_rule(self, opname, token, customize, next_token):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        call ::= expr {expr}^n CALL_FUNCTION_n\\n        call ::= expr {expr}^n CALL_FUNCTION_VAR_n\\n        call ::= expr {expr}^n CALL_FUNCTION_VAR_KW_n\\n        call ::= expr {expr}^n CALL_FUNCTION_KW_n\\n\\n        classdefdeco2 ::= LOAD_BUILD_CLASS mkfunc {expr}^n-1 CALL_FUNCTION_n\\n        '\n    (args_pos, args_kw) = self.get_pos_kw(token)\n    nak = (len(opname) - len('CALL_FUNCTION')) // 3\n    uniq_param = args_kw + args_pos\n    if frozenset(('GET_AWAITABLE', 'YIELD_FROM')).issubset(self.seen_ops):\n        rule = 'async_call ::= expr ' + 'pos_arg ' * args_pos + 'kwarg ' * args_kw + 'expr ' * nak + token.kind + ' GET_AWAITABLE LOAD_CONST YIELD_FROM'\n        self.add_unique_rule(rule, token.kind, uniq_param, customize)\n        self.add_unique_rule('expr ::= async_call', token.kind, uniq_param, customize)\n    if opname.startswith('CALL_FUNCTION_VAR'):\n        token.kind = self.call_fn_name(token)\n        if opname.endswith('KW'):\n            kw = 'expr '\n        else:\n            kw = ''\n        rule = 'call ::= expr expr ' + 'pos_arg ' * args_pos + 'kwarg ' * args_kw + kw + token.kind\n        self.add_unique_rule(rule, token.kind, args_pos, customize)\n    else:\n        token.kind = self.call_fn_name(token)\n        uniq_param = args_kw + args_pos\n        rule = 'call ::= expr ' + 'pos_arg ' * args_pos + 'kwarg ' * args_kw + 'expr ' * nak + token.kind\n        self.add_unique_rule(rule, token.kind, uniq_param, customize)\n        if 'LOAD_BUILD_CLASS' in self.seen_ops:\n            if next_token == 'CALL_FUNCTION' and next_token.attr == 1 and (args_pos > 1):\n                rule = 'classdefdeco2 ::= LOAD_BUILD_CLASS mkfunc %s%s_%d' % ('expr ' * (args_pos - 1), opname, args_pos)\n                self.add_unique_rule(rule, token.kind, uniq_param, customize)",
            "def custom_classfunc_rule(self, opname, token, customize, next_token):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        call ::= expr {expr}^n CALL_FUNCTION_n\\n        call ::= expr {expr}^n CALL_FUNCTION_VAR_n\\n        call ::= expr {expr}^n CALL_FUNCTION_VAR_KW_n\\n        call ::= expr {expr}^n CALL_FUNCTION_KW_n\\n\\n        classdefdeco2 ::= LOAD_BUILD_CLASS mkfunc {expr}^n-1 CALL_FUNCTION_n\\n        '\n    (args_pos, args_kw) = self.get_pos_kw(token)\n    nak = (len(opname) - len('CALL_FUNCTION')) // 3\n    uniq_param = args_kw + args_pos\n    if frozenset(('GET_AWAITABLE', 'YIELD_FROM')).issubset(self.seen_ops):\n        rule = 'async_call ::= expr ' + 'pos_arg ' * args_pos + 'kwarg ' * args_kw + 'expr ' * nak + token.kind + ' GET_AWAITABLE LOAD_CONST YIELD_FROM'\n        self.add_unique_rule(rule, token.kind, uniq_param, customize)\n        self.add_unique_rule('expr ::= async_call', token.kind, uniq_param, customize)\n    if opname.startswith('CALL_FUNCTION_VAR'):\n        token.kind = self.call_fn_name(token)\n        if opname.endswith('KW'):\n            kw = 'expr '\n        else:\n            kw = ''\n        rule = 'call ::= expr expr ' + 'pos_arg ' * args_pos + 'kwarg ' * args_kw + kw + token.kind\n        self.add_unique_rule(rule, token.kind, args_pos, customize)\n    else:\n        token.kind = self.call_fn_name(token)\n        uniq_param = args_kw + args_pos\n        rule = 'call ::= expr ' + 'pos_arg ' * args_pos + 'kwarg ' * args_kw + 'expr ' * nak + token.kind\n        self.add_unique_rule(rule, token.kind, uniq_param, customize)\n        if 'LOAD_BUILD_CLASS' in self.seen_ops:\n            if next_token == 'CALL_FUNCTION' and next_token.attr == 1 and (args_pos > 1):\n                rule = 'classdefdeco2 ::= LOAD_BUILD_CLASS mkfunc %s%s_%d' % ('expr ' * (args_pos - 1), opname, args_pos)\n                self.add_unique_rule(rule, token.kind, uniq_param, customize)"
        ]
    },
    {
        "func_name": "reduce_is_invalid",
        "original": "def reduce_is_invalid(self, rule, ast, tokens, first, last):\n    lhs = rule[0]\n    n = len(tokens)\n    last = min(last, n - 1)\n    fn = self.reduce_check_table.get(lhs, None)\n    try:\n        if fn:\n            return fn(self, lhs, n, rule, ast, tokens, first, last)\n    except Exception:\n        import sys, traceback\n        print(f'Exception in {fn.__name__} {sys.exc_info()[1]}\\n' + f'rule: {rule2str(rule)}\\n' + f'offsets {tokens[first].offset} .. {tokens[last].offset}')\n        print(traceback.print_tb(sys.exc_info()[2], -1))\n        raise ParserError(tokens[last], tokens[last].off2int(), self.debug['rules'])\n    if lhs in ('aug_assign1', 'aug_assign2') and ast[0][0] == 'and':\n        return True\n    elif lhs == 'annotate_tuple':\n        return not isinstance(tokens[first].attr, tuple)\n    elif lhs == 'import_from37':\n        importlist37 = ast[3]\n        alias37 = importlist37[0]\n        if importlist37 == 'importlist37' and alias37 == 'alias37':\n            store = alias37[1]\n            assert store == 'store'\n            return alias37[0].attr != store[0].attr\n        return False\n    elif lhs == 'import_as37':\n        return tokens[first + 1].pattr is not None\n    elif lhs == 'import_from_as37':\n        return tokens[first + 1].pattr is None\n    return False",
        "mutated": [
            "def reduce_is_invalid(self, rule, ast, tokens, first, last):\n    if False:\n        i = 10\n    lhs = rule[0]\n    n = len(tokens)\n    last = min(last, n - 1)\n    fn = self.reduce_check_table.get(lhs, None)\n    try:\n        if fn:\n            return fn(self, lhs, n, rule, ast, tokens, first, last)\n    except Exception:\n        import sys, traceback\n        print(f'Exception in {fn.__name__} {sys.exc_info()[1]}\\n' + f'rule: {rule2str(rule)}\\n' + f'offsets {tokens[first].offset} .. {tokens[last].offset}')\n        print(traceback.print_tb(sys.exc_info()[2], -1))\n        raise ParserError(tokens[last], tokens[last].off2int(), self.debug['rules'])\n    if lhs in ('aug_assign1', 'aug_assign2') and ast[0][0] == 'and':\n        return True\n    elif lhs == 'annotate_tuple':\n        return not isinstance(tokens[first].attr, tuple)\n    elif lhs == 'import_from37':\n        importlist37 = ast[3]\n        alias37 = importlist37[0]\n        if importlist37 == 'importlist37' and alias37 == 'alias37':\n            store = alias37[1]\n            assert store == 'store'\n            return alias37[0].attr != store[0].attr\n        return False\n    elif lhs == 'import_as37':\n        return tokens[first + 1].pattr is not None\n    elif lhs == 'import_from_as37':\n        return tokens[first + 1].pattr is None\n    return False",
            "def reduce_is_invalid(self, rule, ast, tokens, first, last):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    lhs = rule[0]\n    n = len(tokens)\n    last = min(last, n - 1)\n    fn = self.reduce_check_table.get(lhs, None)\n    try:\n        if fn:\n            return fn(self, lhs, n, rule, ast, tokens, first, last)\n    except Exception:\n        import sys, traceback\n        print(f'Exception in {fn.__name__} {sys.exc_info()[1]}\\n' + f'rule: {rule2str(rule)}\\n' + f'offsets {tokens[first].offset} .. {tokens[last].offset}')\n        print(traceback.print_tb(sys.exc_info()[2], -1))\n        raise ParserError(tokens[last], tokens[last].off2int(), self.debug['rules'])\n    if lhs in ('aug_assign1', 'aug_assign2') and ast[0][0] == 'and':\n        return True\n    elif lhs == 'annotate_tuple':\n        return not isinstance(tokens[first].attr, tuple)\n    elif lhs == 'import_from37':\n        importlist37 = ast[3]\n        alias37 = importlist37[0]\n        if importlist37 == 'importlist37' and alias37 == 'alias37':\n            store = alias37[1]\n            assert store == 'store'\n            return alias37[0].attr != store[0].attr\n        return False\n    elif lhs == 'import_as37':\n        return tokens[first + 1].pattr is not None\n    elif lhs == 'import_from_as37':\n        return tokens[first + 1].pattr is None\n    return False",
            "def reduce_is_invalid(self, rule, ast, tokens, first, last):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    lhs = rule[0]\n    n = len(tokens)\n    last = min(last, n - 1)\n    fn = self.reduce_check_table.get(lhs, None)\n    try:\n        if fn:\n            return fn(self, lhs, n, rule, ast, tokens, first, last)\n    except Exception:\n        import sys, traceback\n        print(f'Exception in {fn.__name__} {sys.exc_info()[1]}\\n' + f'rule: {rule2str(rule)}\\n' + f'offsets {tokens[first].offset} .. {tokens[last].offset}')\n        print(traceback.print_tb(sys.exc_info()[2], -1))\n        raise ParserError(tokens[last], tokens[last].off2int(), self.debug['rules'])\n    if lhs in ('aug_assign1', 'aug_assign2') and ast[0][0] == 'and':\n        return True\n    elif lhs == 'annotate_tuple':\n        return not isinstance(tokens[first].attr, tuple)\n    elif lhs == 'import_from37':\n        importlist37 = ast[3]\n        alias37 = importlist37[0]\n        if importlist37 == 'importlist37' and alias37 == 'alias37':\n            store = alias37[1]\n            assert store == 'store'\n            return alias37[0].attr != store[0].attr\n        return False\n    elif lhs == 'import_as37':\n        return tokens[first + 1].pattr is not None\n    elif lhs == 'import_from_as37':\n        return tokens[first + 1].pattr is None\n    return False",
            "def reduce_is_invalid(self, rule, ast, tokens, first, last):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    lhs = rule[0]\n    n = len(tokens)\n    last = min(last, n - 1)\n    fn = self.reduce_check_table.get(lhs, None)\n    try:\n        if fn:\n            return fn(self, lhs, n, rule, ast, tokens, first, last)\n    except Exception:\n        import sys, traceback\n        print(f'Exception in {fn.__name__} {sys.exc_info()[1]}\\n' + f'rule: {rule2str(rule)}\\n' + f'offsets {tokens[first].offset} .. {tokens[last].offset}')\n        print(traceback.print_tb(sys.exc_info()[2], -1))\n        raise ParserError(tokens[last], tokens[last].off2int(), self.debug['rules'])\n    if lhs in ('aug_assign1', 'aug_assign2') and ast[0][0] == 'and':\n        return True\n    elif lhs == 'annotate_tuple':\n        return not isinstance(tokens[first].attr, tuple)\n    elif lhs == 'import_from37':\n        importlist37 = ast[3]\n        alias37 = importlist37[0]\n        if importlist37 == 'importlist37' and alias37 == 'alias37':\n            store = alias37[1]\n            assert store == 'store'\n            return alias37[0].attr != store[0].attr\n        return False\n    elif lhs == 'import_as37':\n        return tokens[first + 1].pattr is not None\n    elif lhs == 'import_from_as37':\n        return tokens[first + 1].pattr is None\n    return False",
            "def reduce_is_invalid(self, rule, ast, tokens, first, last):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    lhs = rule[0]\n    n = len(tokens)\n    last = min(last, n - 1)\n    fn = self.reduce_check_table.get(lhs, None)\n    try:\n        if fn:\n            return fn(self, lhs, n, rule, ast, tokens, first, last)\n    except Exception:\n        import sys, traceback\n        print(f'Exception in {fn.__name__} {sys.exc_info()[1]}\\n' + f'rule: {rule2str(rule)}\\n' + f'offsets {tokens[first].offset} .. {tokens[last].offset}')\n        print(traceback.print_tb(sys.exc_info()[2], -1))\n        raise ParserError(tokens[last], tokens[last].off2int(), self.debug['rules'])\n    if lhs in ('aug_assign1', 'aug_assign2') and ast[0][0] == 'and':\n        return True\n    elif lhs == 'annotate_tuple':\n        return not isinstance(tokens[first].attr, tuple)\n    elif lhs == 'import_from37':\n        importlist37 = ast[3]\n        alias37 = importlist37[0]\n        if importlist37 == 'importlist37' and alias37 == 'alias37':\n            store = alias37[1]\n            assert store == 'store'\n            return alias37[0].attr != store[0].attr\n        return False\n    elif lhs == 'import_as37':\n        return tokens[first + 1].pattr is not None\n    elif lhs == 'import_from_as37':\n        return tokens[first + 1].pattr is None\n    return False"
        ]
    }
]