[
    {
        "func_name": "enc",
        "original": "def enc(x):\n    \"\"\"Big endian k-bit encoding of x\"\"\"\n    return [1 if x & 1 << k - 1 - i else 0 for i in range(k)]",
        "mutated": [
            "def enc(x):\n    if False:\n        i = 10\n    'Big endian k-bit encoding of x'\n    return [1 if x & 1 << k - 1 - i else 0 for i in range(k)]",
            "def enc(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Big endian k-bit encoding of x'\n    return [1 if x & 1 << k - 1 - i else 0 for i in range(k)]",
            "def enc(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Big endian k-bit encoding of x'\n    return [1 if x & 1 << k - 1 - i else 0 for i in range(k)]",
            "def enc(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Big endian k-bit encoding of x'\n    return [1 if x & 1 << k - 1 - i else 0 for i in range(k)]",
            "def enc(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Big endian k-bit encoding of x'\n    return [1 if x & 1 << k - 1 - i else 0 for i in range(k)]"
        ]
    },
    {
        "func_name": "_generate_sparse6_bytes",
        "original": "def _generate_sparse6_bytes(G, nodes, header):\n    \"\"\"Yield bytes in the sparse6 encoding of a graph.\n\n    `G` is an undirected simple graph. `nodes` is the list of nodes for\n    which the node-induced subgraph will be encoded; if `nodes` is the\n    list of all nodes in the graph, the entire graph will be\n    encoded. `header` is a Boolean that specifies whether to generate\n    the header ``b'>>sparse6<<'`` before the remaining data.\n\n    This function generates `bytes` objects in the following order:\n\n    1. the header (if requested),\n    2. the encoding of the number of nodes,\n    3. each character, one-at-a-time, in the encoding of the requested\n       node-induced subgraph,\n    4. a newline character.\n\n    This function raises :exc:`ValueError` if the graph is too large for\n    the graph6 format (that is, greater than ``2 ** 36`` nodes).\n\n    \"\"\"\n    n = len(G)\n    if n >= 2 ** 36:\n        raise ValueError('sparse6 is only defined if number of nodes is less than 2 ** 36')\n    if header:\n        yield b'>>sparse6<<'\n    yield b':'\n    for d in n_to_data(n):\n        yield str.encode(chr(d + 63))\n    k = 1\n    while 1 << k < n:\n        k += 1\n\n    def enc(x):\n        \"\"\"Big endian k-bit encoding of x\"\"\"\n        return [1 if x & 1 << k - 1 - i else 0 for i in range(k)]\n    edges = sorted(((max(u, v), min(u, v)) for (u, v) in G.edges()))\n    bits = []\n    curv = 0\n    for (v, u) in edges:\n        if v == curv:\n            bits.append(0)\n            bits.extend(enc(u))\n        elif v == curv + 1:\n            curv += 1\n            bits.append(1)\n            bits.extend(enc(u))\n        else:\n            curv = v\n            bits.append(1)\n            bits.extend(enc(v))\n            bits.append(0)\n            bits.extend(enc(u))\n    if k < 6 and n == 1 << k and (-len(bits) % 6 >= k) and (curv < n - 1):\n        bits.append(0)\n        bits.extend([1] * (-len(bits) % 6))\n    else:\n        bits.extend([1] * (-len(bits) % 6))\n    data = [(bits[i + 0] << 5) + (bits[i + 1] << 4) + (bits[i + 2] << 3) + (bits[i + 3] << 2) + (bits[i + 4] << 1) + (bits[i + 5] << 0) for i in range(0, len(bits), 6)]\n    for d in data:\n        yield str.encode(chr(d + 63))\n    yield b'\\n'",
        "mutated": [
            "def _generate_sparse6_bytes(G, nodes, header):\n    if False:\n        i = 10\n    \"Yield bytes in the sparse6 encoding of a graph.\\n\\n    `G` is an undirected simple graph. `nodes` is the list of nodes for\\n    which the node-induced subgraph will be encoded; if `nodes` is the\\n    list of all nodes in the graph, the entire graph will be\\n    encoded. `header` is a Boolean that specifies whether to generate\\n    the header ``b'>>sparse6<<'`` before the remaining data.\\n\\n    This function generates `bytes` objects in the following order:\\n\\n    1. the header (if requested),\\n    2. the encoding of the number of nodes,\\n    3. each character, one-at-a-time, in the encoding of the requested\\n       node-induced subgraph,\\n    4. a newline character.\\n\\n    This function raises :exc:`ValueError` if the graph is too large for\\n    the graph6 format (that is, greater than ``2 ** 36`` nodes).\\n\\n    \"\n    n = len(G)\n    if n >= 2 ** 36:\n        raise ValueError('sparse6 is only defined if number of nodes is less than 2 ** 36')\n    if header:\n        yield b'>>sparse6<<'\n    yield b':'\n    for d in n_to_data(n):\n        yield str.encode(chr(d + 63))\n    k = 1\n    while 1 << k < n:\n        k += 1\n\n    def enc(x):\n        \"\"\"Big endian k-bit encoding of x\"\"\"\n        return [1 if x & 1 << k - 1 - i else 0 for i in range(k)]\n    edges = sorted(((max(u, v), min(u, v)) for (u, v) in G.edges()))\n    bits = []\n    curv = 0\n    for (v, u) in edges:\n        if v == curv:\n            bits.append(0)\n            bits.extend(enc(u))\n        elif v == curv + 1:\n            curv += 1\n            bits.append(1)\n            bits.extend(enc(u))\n        else:\n            curv = v\n            bits.append(1)\n            bits.extend(enc(v))\n            bits.append(0)\n            bits.extend(enc(u))\n    if k < 6 and n == 1 << k and (-len(bits) % 6 >= k) and (curv < n - 1):\n        bits.append(0)\n        bits.extend([1] * (-len(bits) % 6))\n    else:\n        bits.extend([1] * (-len(bits) % 6))\n    data = [(bits[i + 0] << 5) + (bits[i + 1] << 4) + (bits[i + 2] << 3) + (bits[i + 3] << 2) + (bits[i + 4] << 1) + (bits[i + 5] << 0) for i in range(0, len(bits), 6)]\n    for d in data:\n        yield str.encode(chr(d + 63))\n    yield b'\\n'",
            "def _generate_sparse6_bytes(G, nodes, header):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Yield bytes in the sparse6 encoding of a graph.\\n\\n    `G` is an undirected simple graph. `nodes` is the list of nodes for\\n    which the node-induced subgraph will be encoded; if `nodes` is the\\n    list of all nodes in the graph, the entire graph will be\\n    encoded. `header` is a Boolean that specifies whether to generate\\n    the header ``b'>>sparse6<<'`` before the remaining data.\\n\\n    This function generates `bytes` objects in the following order:\\n\\n    1. the header (if requested),\\n    2. the encoding of the number of nodes,\\n    3. each character, one-at-a-time, in the encoding of the requested\\n       node-induced subgraph,\\n    4. a newline character.\\n\\n    This function raises :exc:`ValueError` if the graph is too large for\\n    the graph6 format (that is, greater than ``2 ** 36`` nodes).\\n\\n    \"\n    n = len(G)\n    if n >= 2 ** 36:\n        raise ValueError('sparse6 is only defined if number of nodes is less than 2 ** 36')\n    if header:\n        yield b'>>sparse6<<'\n    yield b':'\n    for d in n_to_data(n):\n        yield str.encode(chr(d + 63))\n    k = 1\n    while 1 << k < n:\n        k += 1\n\n    def enc(x):\n        \"\"\"Big endian k-bit encoding of x\"\"\"\n        return [1 if x & 1 << k - 1 - i else 0 for i in range(k)]\n    edges = sorted(((max(u, v), min(u, v)) for (u, v) in G.edges()))\n    bits = []\n    curv = 0\n    for (v, u) in edges:\n        if v == curv:\n            bits.append(0)\n            bits.extend(enc(u))\n        elif v == curv + 1:\n            curv += 1\n            bits.append(1)\n            bits.extend(enc(u))\n        else:\n            curv = v\n            bits.append(1)\n            bits.extend(enc(v))\n            bits.append(0)\n            bits.extend(enc(u))\n    if k < 6 and n == 1 << k and (-len(bits) % 6 >= k) and (curv < n - 1):\n        bits.append(0)\n        bits.extend([1] * (-len(bits) % 6))\n    else:\n        bits.extend([1] * (-len(bits) % 6))\n    data = [(bits[i + 0] << 5) + (bits[i + 1] << 4) + (bits[i + 2] << 3) + (bits[i + 3] << 2) + (bits[i + 4] << 1) + (bits[i + 5] << 0) for i in range(0, len(bits), 6)]\n    for d in data:\n        yield str.encode(chr(d + 63))\n    yield b'\\n'",
            "def _generate_sparse6_bytes(G, nodes, header):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Yield bytes in the sparse6 encoding of a graph.\\n\\n    `G` is an undirected simple graph. `nodes` is the list of nodes for\\n    which the node-induced subgraph will be encoded; if `nodes` is the\\n    list of all nodes in the graph, the entire graph will be\\n    encoded. `header` is a Boolean that specifies whether to generate\\n    the header ``b'>>sparse6<<'`` before the remaining data.\\n\\n    This function generates `bytes` objects in the following order:\\n\\n    1. the header (if requested),\\n    2. the encoding of the number of nodes,\\n    3. each character, one-at-a-time, in the encoding of the requested\\n       node-induced subgraph,\\n    4. a newline character.\\n\\n    This function raises :exc:`ValueError` if the graph is too large for\\n    the graph6 format (that is, greater than ``2 ** 36`` nodes).\\n\\n    \"\n    n = len(G)\n    if n >= 2 ** 36:\n        raise ValueError('sparse6 is only defined if number of nodes is less than 2 ** 36')\n    if header:\n        yield b'>>sparse6<<'\n    yield b':'\n    for d in n_to_data(n):\n        yield str.encode(chr(d + 63))\n    k = 1\n    while 1 << k < n:\n        k += 1\n\n    def enc(x):\n        \"\"\"Big endian k-bit encoding of x\"\"\"\n        return [1 if x & 1 << k - 1 - i else 0 for i in range(k)]\n    edges = sorted(((max(u, v), min(u, v)) for (u, v) in G.edges()))\n    bits = []\n    curv = 0\n    for (v, u) in edges:\n        if v == curv:\n            bits.append(0)\n            bits.extend(enc(u))\n        elif v == curv + 1:\n            curv += 1\n            bits.append(1)\n            bits.extend(enc(u))\n        else:\n            curv = v\n            bits.append(1)\n            bits.extend(enc(v))\n            bits.append(0)\n            bits.extend(enc(u))\n    if k < 6 and n == 1 << k and (-len(bits) % 6 >= k) and (curv < n - 1):\n        bits.append(0)\n        bits.extend([1] * (-len(bits) % 6))\n    else:\n        bits.extend([1] * (-len(bits) % 6))\n    data = [(bits[i + 0] << 5) + (bits[i + 1] << 4) + (bits[i + 2] << 3) + (bits[i + 3] << 2) + (bits[i + 4] << 1) + (bits[i + 5] << 0) for i in range(0, len(bits), 6)]\n    for d in data:\n        yield str.encode(chr(d + 63))\n    yield b'\\n'",
            "def _generate_sparse6_bytes(G, nodes, header):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Yield bytes in the sparse6 encoding of a graph.\\n\\n    `G` is an undirected simple graph. `nodes` is the list of nodes for\\n    which the node-induced subgraph will be encoded; if `nodes` is the\\n    list of all nodes in the graph, the entire graph will be\\n    encoded. `header` is a Boolean that specifies whether to generate\\n    the header ``b'>>sparse6<<'`` before the remaining data.\\n\\n    This function generates `bytes` objects in the following order:\\n\\n    1. the header (if requested),\\n    2. the encoding of the number of nodes,\\n    3. each character, one-at-a-time, in the encoding of the requested\\n       node-induced subgraph,\\n    4. a newline character.\\n\\n    This function raises :exc:`ValueError` if the graph is too large for\\n    the graph6 format (that is, greater than ``2 ** 36`` nodes).\\n\\n    \"\n    n = len(G)\n    if n >= 2 ** 36:\n        raise ValueError('sparse6 is only defined if number of nodes is less than 2 ** 36')\n    if header:\n        yield b'>>sparse6<<'\n    yield b':'\n    for d in n_to_data(n):\n        yield str.encode(chr(d + 63))\n    k = 1\n    while 1 << k < n:\n        k += 1\n\n    def enc(x):\n        \"\"\"Big endian k-bit encoding of x\"\"\"\n        return [1 if x & 1 << k - 1 - i else 0 for i in range(k)]\n    edges = sorted(((max(u, v), min(u, v)) for (u, v) in G.edges()))\n    bits = []\n    curv = 0\n    for (v, u) in edges:\n        if v == curv:\n            bits.append(0)\n            bits.extend(enc(u))\n        elif v == curv + 1:\n            curv += 1\n            bits.append(1)\n            bits.extend(enc(u))\n        else:\n            curv = v\n            bits.append(1)\n            bits.extend(enc(v))\n            bits.append(0)\n            bits.extend(enc(u))\n    if k < 6 and n == 1 << k and (-len(bits) % 6 >= k) and (curv < n - 1):\n        bits.append(0)\n        bits.extend([1] * (-len(bits) % 6))\n    else:\n        bits.extend([1] * (-len(bits) % 6))\n    data = [(bits[i + 0] << 5) + (bits[i + 1] << 4) + (bits[i + 2] << 3) + (bits[i + 3] << 2) + (bits[i + 4] << 1) + (bits[i + 5] << 0) for i in range(0, len(bits), 6)]\n    for d in data:\n        yield str.encode(chr(d + 63))\n    yield b'\\n'",
            "def _generate_sparse6_bytes(G, nodes, header):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Yield bytes in the sparse6 encoding of a graph.\\n\\n    `G` is an undirected simple graph. `nodes` is the list of nodes for\\n    which the node-induced subgraph will be encoded; if `nodes` is the\\n    list of all nodes in the graph, the entire graph will be\\n    encoded. `header` is a Boolean that specifies whether to generate\\n    the header ``b'>>sparse6<<'`` before the remaining data.\\n\\n    This function generates `bytes` objects in the following order:\\n\\n    1. the header (if requested),\\n    2. the encoding of the number of nodes,\\n    3. each character, one-at-a-time, in the encoding of the requested\\n       node-induced subgraph,\\n    4. a newline character.\\n\\n    This function raises :exc:`ValueError` if the graph is too large for\\n    the graph6 format (that is, greater than ``2 ** 36`` nodes).\\n\\n    \"\n    n = len(G)\n    if n >= 2 ** 36:\n        raise ValueError('sparse6 is only defined if number of nodes is less than 2 ** 36')\n    if header:\n        yield b'>>sparse6<<'\n    yield b':'\n    for d in n_to_data(n):\n        yield str.encode(chr(d + 63))\n    k = 1\n    while 1 << k < n:\n        k += 1\n\n    def enc(x):\n        \"\"\"Big endian k-bit encoding of x\"\"\"\n        return [1 if x & 1 << k - 1 - i else 0 for i in range(k)]\n    edges = sorted(((max(u, v), min(u, v)) for (u, v) in G.edges()))\n    bits = []\n    curv = 0\n    for (v, u) in edges:\n        if v == curv:\n            bits.append(0)\n            bits.extend(enc(u))\n        elif v == curv + 1:\n            curv += 1\n            bits.append(1)\n            bits.extend(enc(u))\n        else:\n            curv = v\n            bits.append(1)\n            bits.extend(enc(v))\n            bits.append(0)\n            bits.extend(enc(u))\n    if k < 6 and n == 1 << k and (-len(bits) % 6 >= k) and (curv < n - 1):\n        bits.append(0)\n        bits.extend([1] * (-len(bits) % 6))\n    else:\n        bits.extend([1] * (-len(bits) % 6))\n    data = [(bits[i + 0] << 5) + (bits[i + 1] << 4) + (bits[i + 2] << 3) + (bits[i + 3] << 2) + (bits[i + 4] << 1) + (bits[i + 5] << 0) for i in range(0, len(bits), 6)]\n    for d in data:\n        yield str.encode(chr(d + 63))\n    yield b'\\n'"
        ]
    },
    {
        "func_name": "parseData",
        "original": "def parseData():\n    \"\"\"Returns stream of pairs b[i], x[i] for sparse6 format.\"\"\"\n    chunks = iter(data)\n    d = None\n    dLen = 0\n    while 1:\n        if dLen < 1:\n            try:\n                d = next(chunks)\n            except StopIteration:\n                return\n            dLen = 6\n        dLen -= 1\n        b = d >> dLen & 1\n        x = d & (1 << dLen) - 1\n        xLen = dLen\n        while xLen < k:\n            try:\n                d = next(chunks)\n            except StopIteration:\n                return\n            dLen = 6\n            x = (x << 6) + d\n            xLen += 6\n        x = x >> xLen - k\n        dLen = xLen - k\n        yield (b, x)",
        "mutated": [
            "def parseData():\n    if False:\n        i = 10\n    'Returns stream of pairs b[i], x[i] for sparse6 format.'\n    chunks = iter(data)\n    d = None\n    dLen = 0\n    while 1:\n        if dLen < 1:\n            try:\n                d = next(chunks)\n            except StopIteration:\n                return\n            dLen = 6\n        dLen -= 1\n        b = d >> dLen & 1\n        x = d & (1 << dLen) - 1\n        xLen = dLen\n        while xLen < k:\n            try:\n                d = next(chunks)\n            except StopIteration:\n                return\n            dLen = 6\n            x = (x << 6) + d\n            xLen += 6\n        x = x >> xLen - k\n        dLen = xLen - k\n        yield (b, x)",
            "def parseData():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns stream of pairs b[i], x[i] for sparse6 format.'\n    chunks = iter(data)\n    d = None\n    dLen = 0\n    while 1:\n        if dLen < 1:\n            try:\n                d = next(chunks)\n            except StopIteration:\n                return\n            dLen = 6\n        dLen -= 1\n        b = d >> dLen & 1\n        x = d & (1 << dLen) - 1\n        xLen = dLen\n        while xLen < k:\n            try:\n                d = next(chunks)\n            except StopIteration:\n                return\n            dLen = 6\n            x = (x << 6) + d\n            xLen += 6\n        x = x >> xLen - k\n        dLen = xLen - k\n        yield (b, x)",
            "def parseData():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns stream of pairs b[i], x[i] for sparse6 format.'\n    chunks = iter(data)\n    d = None\n    dLen = 0\n    while 1:\n        if dLen < 1:\n            try:\n                d = next(chunks)\n            except StopIteration:\n                return\n            dLen = 6\n        dLen -= 1\n        b = d >> dLen & 1\n        x = d & (1 << dLen) - 1\n        xLen = dLen\n        while xLen < k:\n            try:\n                d = next(chunks)\n            except StopIteration:\n                return\n            dLen = 6\n            x = (x << 6) + d\n            xLen += 6\n        x = x >> xLen - k\n        dLen = xLen - k\n        yield (b, x)",
            "def parseData():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns stream of pairs b[i], x[i] for sparse6 format.'\n    chunks = iter(data)\n    d = None\n    dLen = 0\n    while 1:\n        if dLen < 1:\n            try:\n                d = next(chunks)\n            except StopIteration:\n                return\n            dLen = 6\n        dLen -= 1\n        b = d >> dLen & 1\n        x = d & (1 << dLen) - 1\n        xLen = dLen\n        while xLen < k:\n            try:\n                d = next(chunks)\n            except StopIteration:\n                return\n            dLen = 6\n            x = (x << 6) + d\n            xLen += 6\n        x = x >> xLen - k\n        dLen = xLen - k\n        yield (b, x)",
            "def parseData():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns stream of pairs b[i], x[i] for sparse6 format.'\n    chunks = iter(data)\n    d = None\n    dLen = 0\n    while 1:\n        if dLen < 1:\n            try:\n                d = next(chunks)\n            except StopIteration:\n                return\n            dLen = 6\n        dLen -= 1\n        b = d >> dLen & 1\n        x = d & (1 << dLen) - 1\n        xLen = dLen\n        while xLen < k:\n            try:\n                d = next(chunks)\n            except StopIteration:\n                return\n            dLen = 6\n            x = (x << 6) + d\n            xLen += 6\n        x = x >> xLen - k\n        dLen = xLen - k\n        yield (b, x)"
        ]
    },
    {
        "func_name": "from_sparse6_bytes",
        "original": "@nx._dispatch(graphs=None)\ndef from_sparse6_bytes(string):\n    \"\"\"Read an undirected graph in sparse6 format from string.\n\n    Parameters\n    ----------\n    string : string\n       Data in sparse6 format\n\n    Returns\n    -------\n    G : Graph\n\n    Raises\n    ------\n    NetworkXError\n        If the string is unable to be parsed in sparse6 format\n\n    Examples\n    --------\n    >>> G = nx.from_sparse6_bytes(b\":A_\")\n    >>> sorted(G.edges())\n    [(0, 1), (0, 1), (0, 1)]\n\n    See Also\n    --------\n    read_sparse6, write_sparse6\n\n    References\n    ----------\n    .. [1] Sparse6 specification\n           <https://users.cecs.anu.edu.au/~bdm/data/formats.html>\n\n    \"\"\"\n    if string.startswith(b'>>sparse6<<'):\n        string = string[11:]\n    if not string.startswith(b':'):\n        raise NetworkXError('Expected leading colon in sparse6')\n    chars = [c - 63 for c in string[1:]]\n    (n, data) = data_to_n(chars)\n    k = 1\n    while 1 << k < n:\n        k += 1\n\n    def parseData():\n        \"\"\"Returns stream of pairs b[i], x[i] for sparse6 format.\"\"\"\n        chunks = iter(data)\n        d = None\n        dLen = 0\n        while 1:\n            if dLen < 1:\n                try:\n                    d = next(chunks)\n                except StopIteration:\n                    return\n                dLen = 6\n            dLen -= 1\n            b = d >> dLen & 1\n            x = d & (1 << dLen) - 1\n            xLen = dLen\n            while xLen < k:\n                try:\n                    d = next(chunks)\n                except StopIteration:\n                    return\n                dLen = 6\n                x = (x << 6) + d\n                xLen += 6\n            x = x >> xLen - k\n            dLen = xLen - k\n            yield (b, x)\n    v = 0\n    G = nx.MultiGraph()\n    G.add_nodes_from(range(n))\n    multigraph = False\n    for (b, x) in parseData():\n        if b == 1:\n            v += 1\n        if x >= n or v >= n:\n            break\n        elif x > v:\n            v = x\n        else:\n            if G.has_edge(x, v):\n                multigraph = True\n            G.add_edge(x, v)\n    if not multigraph:\n        G = nx.Graph(G)\n    return G",
        "mutated": [
            "@nx._dispatch(graphs=None)\ndef from_sparse6_bytes(string):\n    if False:\n        i = 10\n    'Read an undirected graph in sparse6 format from string.\\n\\n    Parameters\\n    ----------\\n    string : string\\n       Data in sparse6 format\\n\\n    Returns\\n    -------\\n    G : Graph\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the string is unable to be parsed in sparse6 format\\n\\n    Examples\\n    --------\\n    >>> G = nx.from_sparse6_bytes(b\":A_\")\\n    >>> sorted(G.edges())\\n    [(0, 1), (0, 1), (0, 1)]\\n\\n    See Also\\n    --------\\n    read_sparse6, write_sparse6\\n\\n    References\\n    ----------\\n    .. [1] Sparse6 specification\\n           <https://users.cecs.anu.edu.au/~bdm/data/formats.html>\\n\\n    '\n    if string.startswith(b'>>sparse6<<'):\n        string = string[11:]\n    if not string.startswith(b':'):\n        raise NetworkXError('Expected leading colon in sparse6')\n    chars = [c - 63 for c in string[1:]]\n    (n, data) = data_to_n(chars)\n    k = 1\n    while 1 << k < n:\n        k += 1\n\n    def parseData():\n        \"\"\"Returns stream of pairs b[i], x[i] for sparse6 format.\"\"\"\n        chunks = iter(data)\n        d = None\n        dLen = 0\n        while 1:\n            if dLen < 1:\n                try:\n                    d = next(chunks)\n                except StopIteration:\n                    return\n                dLen = 6\n            dLen -= 1\n            b = d >> dLen & 1\n            x = d & (1 << dLen) - 1\n            xLen = dLen\n            while xLen < k:\n                try:\n                    d = next(chunks)\n                except StopIteration:\n                    return\n                dLen = 6\n                x = (x << 6) + d\n                xLen += 6\n            x = x >> xLen - k\n            dLen = xLen - k\n            yield (b, x)\n    v = 0\n    G = nx.MultiGraph()\n    G.add_nodes_from(range(n))\n    multigraph = False\n    for (b, x) in parseData():\n        if b == 1:\n            v += 1\n        if x >= n or v >= n:\n            break\n        elif x > v:\n            v = x\n        else:\n            if G.has_edge(x, v):\n                multigraph = True\n            G.add_edge(x, v)\n    if not multigraph:\n        G = nx.Graph(G)\n    return G",
            "@nx._dispatch(graphs=None)\ndef from_sparse6_bytes(string):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Read an undirected graph in sparse6 format from string.\\n\\n    Parameters\\n    ----------\\n    string : string\\n       Data in sparse6 format\\n\\n    Returns\\n    -------\\n    G : Graph\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the string is unable to be parsed in sparse6 format\\n\\n    Examples\\n    --------\\n    >>> G = nx.from_sparse6_bytes(b\":A_\")\\n    >>> sorted(G.edges())\\n    [(0, 1), (0, 1), (0, 1)]\\n\\n    See Also\\n    --------\\n    read_sparse6, write_sparse6\\n\\n    References\\n    ----------\\n    .. [1] Sparse6 specification\\n           <https://users.cecs.anu.edu.au/~bdm/data/formats.html>\\n\\n    '\n    if string.startswith(b'>>sparse6<<'):\n        string = string[11:]\n    if not string.startswith(b':'):\n        raise NetworkXError('Expected leading colon in sparse6')\n    chars = [c - 63 for c in string[1:]]\n    (n, data) = data_to_n(chars)\n    k = 1\n    while 1 << k < n:\n        k += 1\n\n    def parseData():\n        \"\"\"Returns stream of pairs b[i], x[i] for sparse6 format.\"\"\"\n        chunks = iter(data)\n        d = None\n        dLen = 0\n        while 1:\n            if dLen < 1:\n                try:\n                    d = next(chunks)\n                except StopIteration:\n                    return\n                dLen = 6\n            dLen -= 1\n            b = d >> dLen & 1\n            x = d & (1 << dLen) - 1\n            xLen = dLen\n            while xLen < k:\n                try:\n                    d = next(chunks)\n                except StopIteration:\n                    return\n                dLen = 6\n                x = (x << 6) + d\n                xLen += 6\n            x = x >> xLen - k\n            dLen = xLen - k\n            yield (b, x)\n    v = 0\n    G = nx.MultiGraph()\n    G.add_nodes_from(range(n))\n    multigraph = False\n    for (b, x) in parseData():\n        if b == 1:\n            v += 1\n        if x >= n or v >= n:\n            break\n        elif x > v:\n            v = x\n        else:\n            if G.has_edge(x, v):\n                multigraph = True\n            G.add_edge(x, v)\n    if not multigraph:\n        G = nx.Graph(G)\n    return G",
            "@nx._dispatch(graphs=None)\ndef from_sparse6_bytes(string):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Read an undirected graph in sparse6 format from string.\\n\\n    Parameters\\n    ----------\\n    string : string\\n       Data in sparse6 format\\n\\n    Returns\\n    -------\\n    G : Graph\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the string is unable to be parsed in sparse6 format\\n\\n    Examples\\n    --------\\n    >>> G = nx.from_sparse6_bytes(b\":A_\")\\n    >>> sorted(G.edges())\\n    [(0, 1), (0, 1), (0, 1)]\\n\\n    See Also\\n    --------\\n    read_sparse6, write_sparse6\\n\\n    References\\n    ----------\\n    .. [1] Sparse6 specification\\n           <https://users.cecs.anu.edu.au/~bdm/data/formats.html>\\n\\n    '\n    if string.startswith(b'>>sparse6<<'):\n        string = string[11:]\n    if not string.startswith(b':'):\n        raise NetworkXError('Expected leading colon in sparse6')\n    chars = [c - 63 for c in string[1:]]\n    (n, data) = data_to_n(chars)\n    k = 1\n    while 1 << k < n:\n        k += 1\n\n    def parseData():\n        \"\"\"Returns stream of pairs b[i], x[i] for sparse6 format.\"\"\"\n        chunks = iter(data)\n        d = None\n        dLen = 0\n        while 1:\n            if dLen < 1:\n                try:\n                    d = next(chunks)\n                except StopIteration:\n                    return\n                dLen = 6\n            dLen -= 1\n            b = d >> dLen & 1\n            x = d & (1 << dLen) - 1\n            xLen = dLen\n            while xLen < k:\n                try:\n                    d = next(chunks)\n                except StopIteration:\n                    return\n                dLen = 6\n                x = (x << 6) + d\n                xLen += 6\n            x = x >> xLen - k\n            dLen = xLen - k\n            yield (b, x)\n    v = 0\n    G = nx.MultiGraph()\n    G.add_nodes_from(range(n))\n    multigraph = False\n    for (b, x) in parseData():\n        if b == 1:\n            v += 1\n        if x >= n or v >= n:\n            break\n        elif x > v:\n            v = x\n        else:\n            if G.has_edge(x, v):\n                multigraph = True\n            G.add_edge(x, v)\n    if not multigraph:\n        G = nx.Graph(G)\n    return G",
            "@nx._dispatch(graphs=None)\ndef from_sparse6_bytes(string):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Read an undirected graph in sparse6 format from string.\\n\\n    Parameters\\n    ----------\\n    string : string\\n       Data in sparse6 format\\n\\n    Returns\\n    -------\\n    G : Graph\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the string is unable to be parsed in sparse6 format\\n\\n    Examples\\n    --------\\n    >>> G = nx.from_sparse6_bytes(b\":A_\")\\n    >>> sorted(G.edges())\\n    [(0, 1), (0, 1), (0, 1)]\\n\\n    See Also\\n    --------\\n    read_sparse6, write_sparse6\\n\\n    References\\n    ----------\\n    .. [1] Sparse6 specification\\n           <https://users.cecs.anu.edu.au/~bdm/data/formats.html>\\n\\n    '\n    if string.startswith(b'>>sparse6<<'):\n        string = string[11:]\n    if not string.startswith(b':'):\n        raise NetworkXError('Expected leading colon in sparse6')\n    chars = [c - 63 for c in string[1:]]\n    (n, data) = data_to_n(chars)\n    k = 1\n    while 1 << k < n:\n        k += 1\n\n    def parseData():\n        \"\"\"Returns stream of pairs b[i], x[i] for sparse6 format.\"\"\"\n        chunks = iter(data)\n        d = None\n        dLen = 0\n        while 1:\n            if dLen < 1:\n                try:\n                    d = next(chunks)\n                except StopIteration:\n                    return\n                dLen = 6\n            dLen -= 1\n            b = d >> dLen & 1\n            x = d & (1 << dLen) - 1\n            xLen = dLen\n            while xLen < k:\n                try:\n                    d = next(chunks)\n                except StopIteration:\n                    return\n                dLen = 6\n                x = (x << 6) + d\n                xLen += 6\n            x = x >> xLen - k\n            dLen = xLen - k\n            yield (b, x)\n    v = 0\n    G = nx.MultiGraph()\n    G.add_nodes_from(range(n))\n    multigraph = False\n    for (b, x) in parseData():\n        if b == 1:\n            v += 1\n        if x >= n or v >= n:\n            break\n        elif x > v:\n            v = x\n        else:\n            if G.has_edge(x, v):\n                multigraph = True\n            G.add_edge(x, v)\n    if not multigraph:\n        G = nx.Graph(G)\n    return G",
            "@nx._dispatch(graphs=None)\ndef from_sparse6_bytes(string):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Read an undirected graph in sparse6 format from string.\\n\\n    Parameters\\n    ----------\\n    string : string\\n       Data in sparse6 format\\n\\n    Returns\\n    -------\\n    G : Graph\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the string is unable to be parsed in sparse6 format\\n\\n    Examples\\n    --------\\n    >>> G = nx.from_sparse6_bytes(b\":A_\")\\n    >>> sorted(G.edges())\\n    [(0, 1), (0, 1), (0, 1)]\\n\\n    See Also\\n    --------\\n    read_sparse6, write_sparse6\\n\\n    References\\n    ----------\\n    .. [1] Sparse6 specification\\n           <https://users.cecs.anu.edu.au/~bdm/data/formats.html>\\n\\n    '\n    if string.startswith(b'>>sparse6<<'):\n        string = string[11:]\n    if not string.startswith(b':'):\n        raise NetworkXError('Expected leading colon in sparse6')\n    chars = [c - 63 for c in string[1:]]\n    (n, data) = data_to_n(chars)\n    k = 1\n    while 1 << k < n:\n        k += 1\n\n    def parseData():\n        \"\"\"Returns stream of pairs b[i], x[i] for sparse6 format.\"\"\"\n        chunks = iter(data)\n        d = None\n        dLen = 0\n        while 1:\n            if dLen < 1:\n                try:\n                    d = next(chunks)\n                except StopIteration:\n                    return\n                dLen = 6\n            dLen -= 1\n            b = d >> dLen & 1\n            x = d & (1 << dLen) - 1\n            xLen = dLen\n            while xLen < k:\n                try:\n                    d = next(chunks)\n                except StopIteration:\n                    return\n                dLen = 6\n                x = (x << 6) + d\n                xLen += 6\n            x = x >> xLen - k\n            dLen = xLen - k\n            yield (b, x)\n    v = 0\n    G = nx.MultiGraph()\n    G.add_nodes_from(range(n))\n    multigraph = False\n    for (b, x) in parseData():\n        if b == 1:\n            v += 1\n        if x >= n or v >= n:\n            break\n        elif x > v:\n            v = x\n        else:\n            if G.has_edge(x, v):\n                multigraph = True\n            G.add_edge(x, v)\n    if not multigraph:\n        G = nx.Graph(G)\n    return G"
        ]
    },
    {
        "func_name": "to_sparse6_bytes",
        "original": "def to_sparse6_bytes(G, nodes=None, header=True):\n    \"\"\"Convert an undirected graph to bytes in sparse6 format.\n\n    Parameters\n    ----------\n    G : Graph (undirected)\n\n    nodes: list or iterable\n       Nodes are labeled 0...n-1 in the order provided.  If None the ordering\n       given by ``G.nodes()`` is used.\n\n    header: bool\n       If True add '>>sparse6<<' bytes to head of data.\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        If the graph is directed.\n\n    ValueError\n        If the graph has at least ``2 ** 36`` nodes; the sparse6 format\n        is only defined for graphs of order less than ``2 ** 36``.\n\n    Examples\n    --------\n    >>> nx.to_sparse6_bytes(nx.path_graph(2))\n    b'>>sparse6<<:An\\\\n'\n\n    See Also\n    --------\n    to_sparse6_bytes, read_sparse6, write_sparse6_bytes\n\n    Notes\n    -----\n    The returned bytes end with a newline character.\n\n    The format does not support edge or node labels.\n\n    References\n    ----------\n    .. [1] Graph6 specification\n           <https://users.cecs.anu.edu.au/~bdm/data/formats.html>\n\n    \"\"\"\n    if nodes is not None:\n        G = G.subgraph(nodes)\n    G = nx.convert_node_labels_to_integers(G, ordering='sorted')\n    return b''.join(_generate_sparse6_bytes(G, nodes, header))",
        "mutated": [
            "def to_sparse6_bytes(G, nodes=None, header=True):\n    if False:\n        i = 10\n    \"Convert an undirected graph to bytes in sparse6 format.\\n\\n    Parameters\\n    ----------\\n    G : Graph (undirected)\\n\\n    nodes: list or iterable\\n       Nodes are labeled 0...n-1 in the order provided.  If None the ordering\\n       given by ``G.nodes()`` is used.\\n\\n    header: bool\\n       If True add '>>sparse6<<' bytes to head of data.\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        If the graph is directed.\\n\\n    ValueError\\n        If the graph has at least ``2 ** 36`` nodes; the sparse6 format\\n        is only defined for graphs of order less than ``2 ** 36``.\\n\\n    Examples\\n    --------\\n    >>> nx.to_sparse6_bytes(nx.path_graph(2))\\n    b'>>sparse6<<:An\\\\n'\\n\\n    See Also\\n    --------\\n    to_sparse6_bytes, read_sparse6, write_sparse6_bytes\\n\\n    Notes\\n    -----\\n    The returned bytes end with a newline character.\\n\\n    The format does not support edge or node labels.\\n\\n    References\\n    ----------\\n    .. [1] Graph6 specification\\n           <https://users.cecs.anu.edu.au/~bdm/data/formats.html>\\n\\n    \"\n    if nodes is not None:\n        G = G.subgraph(nodes)\n    G = nx.convert_node_labels_to_integers(G, ordering='sorted')\n    return b''.join(_generate_sparse6_bytes(G, nodes, header))",
            "def to_sparse6_bytes(G, nodes=None, header=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Convert an undirected graph to bytes in sparse6 format.\\n\\n    Parameters\\n    ----------\\n    G : Graph (undirected)\\n\\n    nodes: list or iterable\\n       Nodes are labeled 0...n-1 in the order provided.  If None the ordering\\n       given by ``G.nodes()`` is used.\\n\\n    header: bool\\n       If True add '>>sparse6<<' bytes to head of data.\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        If the graph is directed.\\n\\n    ValueError\\n        If the graph has at least ``2 ** 36`` nodes; the sparse6 format\\n        is only defined for graphs of order less than ``2 ** 36``.\\n\\n    Examples\\n    --------\\n    >>> nx.to_sparse6_bytes(nx.path_graph(2))\\n    b'>>sparse6<<:An\\\\n'\\n\\n    See Also\\n    --------\\n    to_sparse6_bytes, read_sparse6, write_sparse6_bytes\\n\\n    Notes\\n    -----\\n    The returned bytes end with a newline character.\\n\\n    The format does not support edge or node labels.\\n\\n    References\\n    ----------\\n    .. [1] Graph6 specification\\n           <https://users.cecs.anu.edu.au/~bdm/data/formats.html>\\n\\n    \"\n    if nodes is not None:\n        G = G.subgraph(nodes)\n    G = nx.convert_node_labels_to_integers(G, ordering='sorted')\n    return b''.join(_generate_sparse6_bytes(G, nodes, header))",
            "def to_sparse6_bytes(G, nodes=None, header=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Convert an undirected graph to bytes in sparse6 format.\\n\\n    Parameters\\n    ----------\\n    G : Graph (undirected)\\n\\n    nodes: list or iterable\\n       Nodes are labeled 0...n-1 in the order provided.  If None the ordering\\n       given by ``G.nodes()`` is used.\\n\\n    header: bool\\n       If True add '>>sparse6<<' bytes to head of data.\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        If the graph is directed.\\n\\n    ValueError\\n        If the graph has at least ``2 ** 36`` nodes; the sparse6 format\\n        is only defined for graphs of order less than ``2 ** 36``.\\n\\n    Examples\\n    --------\\n    >>> nx.to_sparse6_bytes(nx.path_graph(2))\\n    b'>>sparse6<<:An\\\\n'\\n\\n    See Also\\n    --------\\n    to_sparse6_bytes, read_sparse6, write_sparse6_bytes\\n\\n    Notes\\n    -----\\n    The returned bytes end with a newline character.\\n\\n    The format does not support edge or node labels.\\n\\n    References\\n    ----------\\n    .. [1] Graph6 specification\\n           <https://users.cecs.anu.edu.au/~bdm/data/formats.html>\\n\\n    \"\n    if nodes is not None:\n        G = G.subgraph(nodes)\n    G = nx.convert_node_labels_to_integers(G, ordering='sorted')\n    return b''.join(_generate_sparse6_bytes(G, nodes, header))",
            "def to_sparse6_bytes(G, nodes=None, header=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Convert an undirected graph to bytes in sparse6 format.\\n\\n    Parameters\\n    ----------\\n    G : Graph (undirected)\\n\\n    nodes: list or iterable\\n       Nodes are labeled 0...n-1 in the order provided.  If None the ordering\\n       given by ``G.nodes()`` is used.\\n\\n    header: bool\\n       If True add '>>sparse6<<' bytes to head of data.\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        If the graph is directed.\\n\\n    ValueError\\n        If the graph has at least ``2 ** 36`` nodes; the sparse6 format\\n        is only defined for graphs of order less than ``2 ** 36``.\\n\\n    Examples\\n    --------\\n    >>> nx.to_sparse6_bytes(nx.path_graph(2))\\n    b'>>sparse6<<:An\\\\n'\\n\\n    See Also\\n    --------\\n    to_sparse6_bytes, read_sparse6, write_sparse6_bytes\\n\\n    Notes\\n    -----\\n    The returned bytes end with a newline character.\\n\\n    The format does not support edge or node labels.\\n\\n    References\\n    ----------\\n    .. [1] Graph6 specification\\n           <https://users.cecs.anu.edu.au/~bdm/data/formats.html>\\n\\n    \"\n    if nodes is not None:\n        G = G.subgraph(nodes)\n    G = nx.convert_node_labels_to_integers(G, ordering='sorted')\n    return b''.join(_generate_sparse6_bytes(G, nodes, header))",
            "def to_sparse6_bytes(G, nodes=None, header=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Convert an undirected graph to bytes in sparse6 format.\\n\\n    Parameters\\n    ----------\\n    G : Graph (undirected)\\n\\n    nodes: list or iterable\\n       Nodes are labeled 0...n-1 in the order provided.  If None the ordering\\n       given by ``G.nodes()`` is used.\\n\\n    header: bool\\n       If True add '>>sparse6<<' bytes to head of data.\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        If the graph is directed.\\n\\n    ValueError\\n        If the graph has at least ``2 ** 36`` nodes; the sparse6 format\\n        is only defined for graphs of order less than ``2 ** 36``.\\n\\n    Examples\\n    --------\\n    >>> nx.to_sparse6_bytes(nx.path_graph(2))\\n    b'>>sparse6<<:An\\\\n'\\n\\n    See Also\\n    --------\\n    to_sparse6_bytes, read_sparse6, write_sparse6_bytes\\n\\n    Notes\\n    -----\\n    The returned bytes end with a newline character.\\n\\n    The format does not support edge or node labels.\\n\\n    References\\n    ----------\\n    .. [1] Graph6 specification\\n           <https://users.cecs.anu.edu.au/~bdm/data/formats.html>\\n\\n    \"\n    if nodes is not None:\n        G = G.subgraph(nodes)\n    G = nx.convert_node_labels_to_integers(G, ordering='sorted')\n    return b''.join(_generate_sparse6_bytes(G, nodes, header))"
        ]
    },
    {
        "func_name": "read_sparse6",
        "original": "@open_file(0, mode='rb')\n@nx._dispatch(graphs=None)\ndef read_sparse6(path):\n    \"\"\"Read an undirected graph in sparse6 format from path.\n\n    Parameters\n    ----------\n    path : file or string\n       File or filename to write.\n\n    Returns\n    -------\n    G : Graph/Multigraph or list of Graphs/MultiGraphs\n       If the file contains multiple lines then a list of graphs is returned\n\n    Raises\n    ------\n    NetworkXError\n        If the string is unable to be parsed in sparse6 format\n\n    Examples\n    --------\n    You can read a sparse6 file by giving the path to the file::\n\n        >>> import tempfile\n        >>> with tempfile.NamedTemporaryFile(delete=False) as f:\n        ...     _ = f.write(b\">>sparse6<<:An\\\\n\")\n        ...     _ = f.seek(0)\n        ...     G = nx.read_sparse6(f.name)\n        >>> list(G.edges())\n        [(0, 1)]\n\n    You can also read a sparse6 file by giving an open file-like object::\n\n        >>> import tempfile\n        >>> with tempfile.NamedTemporaryFile() as f:\n        ...     _ = f.write(b\">>sparse6<<:An\\\\n\")\n        ...     _ = f.seek(0)\n        ...     G = nx.read_sparse6(f)\n        >>> list(G.edges())\n        [(0, 1)]\n\n    See Also\n    --------\n    read_sparse6, from_sparse6_bytes\n\n    References\n    ----------\n    .. [1] Sparse6 specification\n           <https://users.cecs.anu.edu.au/~bdm/data/formats.html>\n\n    \"\"\"\n    glist = []\n    for line in path:\n        line = line.strip()\n        if not len(line):\n            continue\n        glist.append(from_sparse6_bytes(line))\n    if len(glist) == 1:\n        return glist[0]\n    else:\n        return glist",
        "mutated": [
            "@open_file(0, mode='rb')\n@nx._dispatch(graphs=None)\ndef read_sparse6(path):\n    if False:\n        i = 10\n    'Read an undirected graph in sparse6 format from path.\\n\\n    Parameters\\n    ----------\\n    path : file or string\\n       File or filename to write.\\n\\n    Returns\\n    -------\\n    G : Graph/Multigraph or list of Graphs/MultiGraphs\\n       If the file contains multiple lines then a list of graphs is returned\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the string is unable to be parsed in sparse6 format\\n\\n    Examples\\n    --------\\n    You can read a sparse6 file by giving the path to the file::\\n\\n        >>> import tempfile\\n        >>> with tempfile.NamedTemporaryFile(delete=False) as f:\\n        ...     _ = f.write(b\">>sparse6<<:An\\\\n\")\\n        ...     _ = f.seek(0)\\n        ...     G = nx.read_sparse6(f.name)\\n        >>> list(G.edges())\\n        [(0, 1)]\\n\\n    You can also read a sparse6 file by giving an open file-like object::\\n\\n        >>> import tempfile\\n        >>> with tempfile.NamedTemporaryFile() as f:\\n        ...     _ = f.write(b\">>sparse6<<:An\\\\n\")\\n        ...     _ = f.seek(0)\\n        ...     G = nx.read_sparse6(f)\\n        >>> list(G.edges())\\n        [(0, 1)]\\n\\n    See Also\\n    --------\\n    read_sparse6, from_sparse6_bytes\\n\\n    References\\n    ----------\\n    .. [1] Sparse6 specification\\n           <https://users.cecs.anu.edu.au/~bdm/data/formats.html>\\n\\n    '\n    glist = []\n    for line in path:\n        line = line.strip()\n        if not len(line):\n            continue\n        glist.append(from_sparse6_bytes(line))\n    if len(glist) == 1:\n        return glist[0]\n    else:\n        return glist",
            "@open_file(0, mode='rb')\n@nx._dispatch(graphs=None)\ndef read_sparse6(path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Read an undirected graph in sparse6 format from path.\\n\\n    Parameters\\n    ----------\\n    path : file or string\\n       File or filename to write.\\n\\n    Returns\\n    -------\\n    G : Graph/Multigraph or list of Graphs/MultiGraphs\\n       If the file contains multiple lines then a list of graphs is returned\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the string is unable to be parsed in sparse6 format\\n\\n    Examples\\n    --------\\n    You can read a sparse6 file by giving the path to the file::\\n\\n        >>> import tempfile\\n        >>> with tempfile.NamedTemporaryFile(delete=False) as f:\\n        ...     _ = f.write(b\">>sparse6<<:An\\\\n\")\\n        ...     _ = f.seek(0)\\n        ...     G = nx.read_sparse6(f.name)\\n        >>> list(G.edges())\\n        [(0, 1)]\\n\\n    You can also read a sparse6 file by giving an open file-like object::\\n\\n        >>> import tempfile\\n        >>> with tempfile.NamedTemporaryFile() as f:\\n        ...     _ = f.write(b\">>sparse6<<:An\\\\n\")\\n        ...     _ = f.seek(0)\\n        ...     G = nx.read_sparse6(f)\\n        >>> list(G.edges())\\n        [(0, 1)]\\n\\n    See Also\\n    --------\\n    read_sparse6, from_sparse6_bytes\\n\\n    References\\n    ----------\\n    .. [1] Sparse6 specification\\n           <https://users.cecs.anu.edu.au/~bdm/data/formats.html>\\n\\n    '\n    glist = []\n    for line in path:\n        line = line.strip()\n        if not len(line):\n            continue\n        glist.append(from_sparse6_bytes(line))\n    if len(glist) == 1:\n        return glist[0]\n    else:\n        return glist",
            "@open_file(0, mode='rb')\n@nx._dispatch(graphs=None)\ndef read_sparse6(path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Read an undirected graph in sparse6 format from path.\\n\\n    Parameters\\n    ----------\\n    path : file or string\\n       File or filename to write.\\n\\n    Returns\\n    -------\\n    G : Graph/Multigraph or list of Graphs/MultiGraphs\\n       If the file contains multiple lines then a list of graphs is returned\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the string is unable to be parsed in sparse6 format\\n\\n    Examples\\n    --------\\n    You can read a sparse6 file by giving the path to the file::\\n\\n        >>> import tempfile\\n        >>> with tempfile.NamedTemporaryFile(delete=False) as f:\\n        ...     _ = f.write(b\">>sparse6<<:An\\\\n\")\\n        ...     _ = f.seek(0)\\n        ...     G = nx.read_sparse6(f.name)\\n        >>> list(G.edges())\\n        [(0, 1)]\\n\\n    You can also read a sparse6 file by giving an open file-like object::\\n\\n        >>> import tempfile\\n        >>> with tempfile.NamedTemporaryFile() as f:\\n        ...     _ = f.write(b\">>sparse6<<:An\\\\n\")\\n        ...     _ = f.seek(0)\\n        ...     G = nx.read_sparse6(f)\\n        >>> list(G.edges())\\n        [(0, 1)]\\n\\n    See Also\\n    --------\\n    read_sparse6, from_sparse6_bytes\\n\\n    References\\n    ----------\\n    .. [1] Sparse6 specification\\n           <https://users.cecs.anu.edu.au/~bdm/data/formats.html>\\n\\n    '\n    glist = []\n    for line in path:\n        line = line.strip()\n        if not len(line):\n            continue\n        glist.append(from_sparse6_bytes(line))\n    if len(glist) == 1:\n        return glist[0]\n    else:\n        return glist",
            "@open_file(0, mode='rb')\n@nx._dispatch(graphs=None)\ndef read_sparse6(path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Read an undirected graph in sparse6 format from path.\\n\\n    Parameters\\n    ----------\\n    path : file or string\\n       File or filename to write.\\n\\n    Returns\\n    -------\\n    G : Graph/Multigraph or list of Graphs/MultiGraphs\\n       If the file contains multiple lines then a list of graphs is returned\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the string is unable to be parsed in sparse6 format\\n\\n    Examples\\n    --------\\n    You can read a sparse6 file by giving the path to the file::\\n\\n        >>> import tempfile\\n        >>> with tempfile.NamedTemporaryFile(delete=False) as f:\\n        ...     _ = f.write(b\">>sparse6<<:An\\\\n\")\\n        ...     _ = f.seek(0)\\n        ...     G = nx.read_sparse6(f.name)\\n        >>> list(G.edges())\\n        [(0, 1)]\\n\\n    You can also read a sparse6 file by giving an open file-like object::\\n\\n        >>> import tempfile\\n        >>> with tempfile.NamedTemporaryFile() as f:\\n        ...     _ = f.write(b\">>sparse6<<:An\\\\n\")\\n        ...     _ = f.seek(0)\\n        ...     G = nx.read_sparse6(f)\\n        >>> list(G.edges())\\n        [(0, 1)]\\n\\n    See Also\\n    --------\\n    read_sparse6, from_sparse6_bytes\\n\\n    References\\n    ----------\\n    .. [1] Sparse6 specification\\n           <https://users.cecs.anu.edu.au/~bdm/data/formats.html>\\n\\n    '\n    glist = []\n    for line in path:\n        line = line.strip()\n        if not len(line):\n            continue\n        glist.append(from_sparse6_bytes(line))\n    if len(glist) == 1:\n        return glist[0]\n    else:\n        return glist",
            "@open_file(0, mode='rb')\n@nx._dispatch(graphs=None)\ndef read_sparse6(path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Read an undirected graph in sparse6 format from path.\\n\\n    Parameters\\n    ----------\\n    path : file or string\\n       File or filename to write.\\n\\n    Returns\\n    -------\\n    G : Graph/Multigraph or list of Graphs/MultiGraphs\\n       If the file contains multiple lines then a list of graphs is returned\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the string is unable to be parsed in sparse6 format\\n\\n    Examples\\n    --------\\n    You can read a sparse6 file by giving the path to the file::\\n\\n        >>> import tempfile\\n        >>> with tempfile.NamedTemporaryFile(delete=False) as f:\\n        ...     _ = f.write(b\">>sparse6<<:An\\\\n\")\\n        ...     _ = f.seek(0)\\n        ...     G = nx.read_sparse6(f.name)\\n        >>> list(G.edges())\\n        [(0, 1)]\\n\\n    You can also read a sparse6 file by giving an open file-like object::\\n\\n        >>> import tempfile\\n        >>> with tempfile.NamedTemporaryFile() as f:\\n        ...     _ = f.write(b\">>sparse6<<:An\\\\n\")\\n        ...     _ = f.seek(0)\\n        ...     G = nx.read_sparse6(f)\\n        >>> list(G.edges())\\n        [(0, 1)]\\n\\n    See Also\\n    --------\\n    read_sparse6, from_sparse6_bytes\\n\\n    References\\n    ----------\\n    .. [1] Sparse6 specification\\n           <https://users.cecs.anu.edu.au/~bdm/data/formats.html>\\n\\n    '\n    glist = []\n    for line in path:\n        line = line.strip()\n        if not len(line):\n            continue\n        glist.append(from_sparse6_bytes(line))\n    if len(glist) == 1:\n        return glist[0]\n    else:\n        return glist"
        ]
    },
    {
        "func_name": "write_sparse6",
        "original": "@not_implemented_for('directed')\n@open_file(1, mode='wb')\ndef write_sparse6(G, path, nodes=None, header=True):\n    \"\"\"Write graph G to given path in sparse6 format.\n\n    Parameters\n    ----------\n    G : Graph (undirected)\n\n    path : file or string\n       File or filename to write\n\n    nodes: list or iterable\n       Nodes are labeled 0...n-1 in the order provided.  If None the ordering\n       given by G.nodes() is used.\n\n    header: bool\n       If True add '>>sparse6<<' string to head of data\n\n    Raises\n    ------\n    NetworkXError\n        If the graph is directed\n\n    Examples\n    --------\n    You can write a sparse6 file by giving the path to the file::\n\n        >>> import tempfile\n        >>> with tempfile.NamedTemporaryFile(delete=False) as f:\n        ...     nx.write_sparse6(nx.path_graph(2), f.name)\n        ...     print(f.read())\n        b'>>sparse6<<:An\\\\n'\n\n    You can also write a sparse6 file by giving an open file-like object::\n\n        >>> with tempfile.NamedTemporaryFile() as f:\n        ...     nx.write_sparse6(nx.path_graph(2), f)\n        ...     _ = f.seek(0)\n        ...     print(f.read())\n        b'>>sparse6<<:An\\\\n'\n\n    See Also\n    --------\n    read_sparse6, from_sparse6_bytes\n\n    Notes\n    -----\n    The format does not support edge or node labels.\n\n    References\n    ----------\n    .. [1] Sparse6 specification\n           <https://users.cecs.anu.edu.au/~bdm/data/formats.html>\n\n    \"\"\"\n    if nodes is not None:\n        G = G.subgraph(nodes)\n    G = nx.convert_node_labels_to_integers(G, ordering='sorted')\n    for b in _generate_sparse6_bytes(G, nodes, header):\n        path.write(b)",
        "mutated": [
            "@not_implemented_for('directed')\n@open_file(1, mode='wb')\ndef write_sparse6(G, path, nodes=None, header=True):\n    if False:\n        i = 10\n    \"Write graph G to given path in sparse6 format.\\n\\n    Parameters\\n    ----------\\n    G : Graph (undirected)\\n\\n    path : file or string\\n       File or filename to write\\n\\n    nodes: list or iterable\\n       Nodes are labeled 0...n-1 in the order provided.  If None the ordering\\n       given by G.nodes() is used.\\n\\n    header: bool\\n       If True add '>>sparse6<<' string to head of data\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the graph is directed\\n\\n    Examples\\n    --------\\n    You can write a sparse6 file by giving the path to the file::\\n\\n        >>> import tempfile\\n        >>> with tempfile.NamedTemporaryFile(delete=False) as f:\\n        ...     nx.write_sparse6(nx.path_graph(2), f.name)\\n        ...     print(f.read())\\n        b'>>sparse6<<:An\\\\n'\\n\\n    You can also write a sparse6 file by giving an open file-like object::\\n\\n        >>> with tempfile.NamedTemporaryFile() as f:\\n        ...     nx.write_sparse6(nx.path_graph(2), f)\\n        ...     _ = f.seek(0)\\n        ...     print(f.read())\\n        b'>>sparse6<<:An\\\\n'\\n\\n    See Also\\n    --------\\n    read_sparse6, from_sparse6_bytes\\n\\n    Notes\\n    -----\\n    The format does not support edge or node labels.\\n\\n    References\\n    ----------\\n    .. [1] Sparse6 specification\\n           <https://users.cecs.anu.edu.au/~bdm/data/formats.html>\\n\\n    \"\n    if nodes is not None:\n        G = G.subgraph(nodes)\n    G = nx.convert_node_labels_to_integers(G, ordering='sorted')\n    for b in _generate_sparse6_bytes(G, nodes, header):\n        path.write(b)",
            "@not_implemented_for('directed')\n@open_file(1, mode='wb')\ndef write_sparse6(G, path, nodes=None, header=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Write graph G to given path in sparse6 format.\\n\\n    Parameters\\n    ----------\\n    G : Graph (undirected)\\n\\n    path : file or string\\n       File or filename to write\\n\\n    nodes: list or iterable\\n       Nodes are labeled 0...n-1 in the order provided.  If None the ordering\\n       given by G.nodes() is used.\\n\\n    header: bool\\n       If True add '>>sparse6<<' string to head of data\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the graph is directed\\n\\n    Examples\\n    --------\\n    You can write a sparse6 file by giving the path to the file::\\n\\n        >>> import tempfile\\n        >>> with tempfile.NamedTemporaryFile(delete=False) as f:\\n        ...     nx.write_sparse6(nx.path_graph(2), f.name)\\n        ...     print(f.read())\\n        b'>>sparse6<<:An\\\\n'\\n\\n    You can also write a sparse6 file by giving an open file-like object::\\n\\n        >>> with tempfile.NamedTemporaryFile() as f:\\n        ...     nx.write_sparse6(nx.path_graph(2), f)\\n        ...     _ = f.seek(0)\\n        ...     print(f.read())\\n        b'>>sparse6<<:An\\\\n'\\n\\n    See Also\\n    --------\\n    read_sparse6, from_sparse6_bytes\\n\\n    Notes\\n    -----\\n    The format does not support edge or node labels.\\n\\n    References\\n    ----------\\n    .. [1] Sparse6 specification\\n           <https://users.cecs.anu.edu.au/~bdm/data/formats.html>\\n\\n    \"\n    if nodes is not None:\n        G = G.subgraph(nodes)\n    G = nx.convert_node_labels_to_integers(G, ordering='sorted')\n    for b in _generate_sparse6_bytes(G, nodes, header):\n        path.write(b)",
            "@not_implemented_for('directed')\n@open_file(1, mode='wb')\ndef write_sparse6(G, path, nodes=None, header=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Write graph G to given path in sparse6 format.\\n\\n    Parameters\\n    ----------\\n    G : Graph (undirected)\\n\\n    path : file or string\\n       File or filename to write\\n\\n    nodes: list or iterable\\n       Nodes are labeled 0...n-1 in the order provided.  If None the ordering\\n       given by G.nodes() is used.\\n\\n    header: bool\\n       If True add '>>sparse6<<' string to head of data\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the graph is directed\\n\\n    Examples\\n    --------\\n    You can write a sparse6 file by giving the path to the file::\\n\\n        >>> import tempfile\\n        >>> with tempfile.NamedTemporaryFile(delete=False) as f:\\n        ...     nx.write_sparse6(nx.path_graph(2), f.name)\\n        ...     print(f.read())\\n        b'>>sparse6<<:An\\\\n'\\n\\n    You can also write a sparse6 file by giving an open file-like object::\\n\\n        >>> with tempfile.NamedTemporaryFile() as f:\\n        ...     nx.write_sparse6(nx.path_graph(2), f)\\n        ...     _ = f.seek(0)\\n        ...     print(f.read())\\n        b'>>sparse6<<:An\\\\n'\\n\\n    See Also\\n    --------\\n    read_sparse6, from_sparse6_bytes\\n\\n    Notes\\n    -----\\n    The format does not support edge or node labels.\\n\\n    References\\n    ----------\\n    .. [1] Sparse6 specification\\n           <https://users.cecs.anu.edu.au/~bdm/data/formats.html>\\n\\n    \"\n    if nodes is not None:\n        G = G.subgraph(nodes)\n    G = nx.convert_node_labels_to_integers(G, ordering='sorted')\n    for b in _generate_sparse6_bytes(G, nodes, header):\n        path.write(b)",
            "@not_implemented_for('directed')\n@open_file(1, mode='wb')\ndef write_sparse6(G, path, nodes=None, header=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Write graph G to given path in sparse6 format.\\n\\n    Parameters\\n    ----------\\n    G : Graph (undirected)\\n\\n    path : file or string\\n       File or filename to write\\n\\n    nodes: list or iterable\\n       Nodes are labeled 0...n-1 in the order provided.  If None the ordering\\n       given by G.nodes() is used.\\n\\n    header: bool\\n       If True add '>>sparse6<<' string to head of data\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the graph is directed\\n\\n    Examples\\n    --------\\n    You can write a sparse6 file by giving the path to the file::\\n\\n        >>> import tempfile\\n        >>> with tempfile.NamedTemporaryFile(delete=False) as f:\\n        ...     nx.write_sparse6(nx.path_graph(2), f.name)\\n        ...     print(f.read())\\n        b'>>sparse6<<:An\\\\n'\\n\\n    You can also write a sparse6 file by giving an open file-like object::\\n\\n        >>> with tempfile.NamedTemporaryFile() as f:\\n        ...     nx.write_sparse6(nx.path_graph(2), f)\\n        ...     _ = f.seek(0)\\n        ...     print(f.read())\\n        b'>>sparse6<<:An\\\\n'\\n\\n    See Also\\n    --------\\n    read_sparse6, from_sparse6_bytes\\n\\n    Notes\\n    -----\\n    The format does not support edge or node labels.\\n\\n    References\\n    ----------\\n    .. [1] Sparse6 specification\\n           <https://users.cecs.anu.edu.au/~bdm/data/formats.html>\\n\\n    \"\n    if nodes is not None:\n        G = G.subgraph(nodes)\n    G = nx.convert_node_labels_to_integers(G, ordering='sorted')\n    for b in _generate_sparse6_bytes(G, nodes, header):\n        path.write(b)",
            "@not_implemented_for('directed')\n@open_file(1, mode='wb')\ndef write_sparse6(G, path, nodes=None, header=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Write graph G to given path in sparse6 format.\\n\\n    Parameters\\n    ----------\\n    G : Graph (undirected)\\n\\n    path : file or string\\n       File or filename to write\\n\\n    nodes: list or iterable\\n       Nodes are labeled 0...n-1 in the order provided.  If None the ordering\\n       given by G.nodes() is used.\\n\\n    header: bool\\n       If True add '>>sparse6<<' string to head of data\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If the graph is directed\\n\\n    Examples\\n    --------\\n    You can write a sparse6 file by giving the path to the file::\\n\\n        >>> import tempfile\\n        >>> with tempfile.NamedTemporaryFile(delete=False) as f:\\n        ...     nx.write_sparse6(nx.path_graph(2), f.name)\\n        ...     print(f.read())\\n        b'>>sparse6<<:An\\\\n'\\n\\n    You can also write a sparse6 file by giving an open file-like object::\\n\\n        >>> with tempfile.NamedTemporaryFile() as f:\\n        ...     nx.write_sparse6(nx.path_graph(2), f)\\n        ...     _ = f.seek(0)\\n        ...     print(f.read())\\n        b'>>sparse6<<:An\\\\n'\\n\\n    See Also\\n    --------\\n    read_sparse6, from_sparse6_bytes\\n\\n    Notes\\n    -----\\n    The format does not support edge or node labels.\\n\\n    References\\n    ----------\\n    .. [1] Sparse6 specification\\n           <https://users.cecs.anu.edu.au/~bdm/data/formats.html>\\n\\n    \"\n    if nodes is not None:\n        G = G.subgraph(nodes)\n    G = nx.convert_node_labels_to_integers(G, ordering='sorted')\n    for b in _generate_sparse6_bytes(G, nodes, header):\n        path.write(b)"
        ]
    }
]