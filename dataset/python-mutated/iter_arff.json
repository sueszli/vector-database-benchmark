[
    {
        "func_name": "iter_arff",
        "original": "def iter_arff(filepath_or_buffer, target: str | list[str] | None=None, compression='infer', sparse=False) -> base.typing.Stream:\n    \"\"\"Iterates over rows from an ARFF file.\n\n    Parameters\n    ----------\n    filepath_or_buffer\n        Either a string indicating the location of a file, or a buffer object that has a\n        `read` method.\n    target\n        Name(s) of the target field. If `None`, then the target field is ignored. If a list of\n        names is passed, then a dictionary is returned instead of a single value.\n    compression\n        For on-the-fly decompression of on-disk data. If this is set to 'infer' and\n        `filepath_or_buffer` is a path, then the decompression method is inferred for the\n        following extensions: '.gz', '.zip'.\n    sparse\n        Whether the data is sparse or not.\n\n    Examples\n    --------\n\n    >>> cars = '''\n    ... @relation CarData\n    ... @attribute make {Toyota, Honda, Ford, Chevrolet}\n    ... @attribute model string\n    ... @attribute year numeric\n    ... @attribute price numeric\n    ... @attribute mpg numeric\n    ... @data\n    ... Toyota, Corolla, 2018, 15000, 30.5\n    ... Honda, Civic, 2019, 16000, 32.2\n    ... Ford, Mustang, 2020, 25000, 25.0\n    ... Chevrolet, Malibu, 2017, 18000, 28.9\n    ... Toyota, Camry, 2019, 22000, 29.8\n    ... '''\n    >>> with open('cars.arff', mode='w') as f:\n    ...     _ = f.write(cars)\n\n    >>> from river import stream\n\n    >>> for x, y in stream.iter_arff('cars.arff', target='price'):\n    ...     print(x, y)\n    {'make': 'Toyota', 'model': ' Corolla', 'year': 2018.0, 'mpg': 30.5} 15000.0\n    {'make': 'Honda', 'model': ' Civic', 'year': 2019.0, 'mpg': 32.2} 16000.0\n    {'make': 'Ford', 'model': ' Mustang', 'year': 2020.0, 'mpg': 25.0} 25000.0\n    {'make': 'Chevrolet', 'model': ' Malibu', 'year': 2017.0, 'mpg': 28.9} 18000.0\n    {'make': 'Toyota', 'model': ' Camry', 'year': 2019.0, 'mpg': 29.8} 22000.0\n\n    Finally, let's delete the example file.\n\n    >>> import os; os.remove('cars.arff')\n\n    ARFF files support sparse data. Let's create a sparse ARFF file.\n\n    >>> sparse = '''\n    ... % traindata\n    ... @RELATION \"traindata: -C 6\"\n    ... @ATTRIBUTE y0 {0, 1}\n    ... @ATTRIBUTE y1 {0, 1}\n    ... @ATTRIBUTE y2 {0, 1}\n    ... @ATTRIBUTE y3 {0, 1}\n    ... @ATTRIBUTE y4 {0, 1}\n    ... @ATTRIBUTE y5 {0, 1}\n    ... @ATTRIBUTE X0 NUMERIC\n    ... @ATTRIBUTE X1 NUMERIC\n    ... @ATTRIBUTE X2 NUMERIC\n    ... @DATA\n    ... { 3 1,6 0.863382,8 0.820094 }\n    ... { 2 1,6 0.659761 }\n    ... { 0 1,3 1,6 0.437881,8 0.818882 }\n    ... { 2 1,6 0.676477,7 0.724635,8 0.755123 }\n    ... '''\n\n    >>> with open('sparse.arff', mode='w') as f:\n    ...     _ = f.write(sparse)\n\n    In addition, we'll specify that there are several target fields.\n\n    >>> arff_stream = stream.iter_arff(\n    ...     'sparse.arff',\n    ...     target=['y0', 'y1', 'y2', 'y3', 'y4', 'y5'],\n    ...     sparse=True\n    ... )\n\n    >>> for x, y in arff_stream:\n    ...     print(x)\n    ...     print(y)\n    {'X0': '0.863382', 'X2': '0.820094'}\n    {'y0': 0, 'y1': 0, 'y2': 0, 'y3': '1', 'y4': 0, 'y5': 0}\n    {'X0': '0.659761'}\n    {'y0': 0, 'y1': 0, 'y2': '1', 'y3': 0, 'y4': 0, 'y5': 0}\n    {'X0': '0.437881', 'X2': '0.818882'}\n    {'y0': '1', 'y1': 0, 'y2': 0, 'y3': '1', 'y4': 0, 'y5': 0}\n    {'X0': '0.676477', 'X1': '0.724635', 'X2': '0.755123'}\n    {'y0': 0, 'y1': 0, 'y2': '1', 'y3': 0, 'y4': 0, 'y5': 0}\n\n    This function can also deal with missing features in non-sparse data. These are indicated with\n    a question mark.\n\n    >>> data = '''\n    ... @relation giveMeLoan-weka.filters.unsupervised.attribute.Remove-R1\n    ... @attribute RevolvingUtilizationOfUnsecuredLines numeric\n    ... @attribute age numeric\n    ... @attribute NumberOfTime30-59DaysPastDueNotWorse numeric\n    ... @attribute DebtRatio numeric\n    ... @attribute MonthlyIncome numeric\n    ... @attribute NumberOfOpenCreditLinesAndLoans numeric\n    ... @attribute NumberOfTimes90DaysLate numeric\n    ... @attribute NumberRealEstateLoansOrLines numeric\n    ... @attribute NumberOfTime60-89DaysPastDueNotWorse numeric\n    ... @attribute NumberOfDependents numeric\n    ... @attribute isFraud {0,1}\n    ... @data\n    ... 0.213179,74,0,0.375607,3500,3,0,1,0,1,0\n    ... 0.305682,57,0,5710,?,8,0,3,0,0,0\n    ... 0.754464,39,0,0.20994,3500,8,0,0,0,0,0\n    ... 0.116951,27,0,46,?,2,0,0,0,0,0\n    ... 0.189169,57,0,0.606291,23684,9,0,4,0,2,0\n    ... '''\n\n    >>> with open('data.arff', mode='w') as f:\n    ...     _ = f.write(data)\n\n    >>> for x, y in stream.iter_arff('data.arff', target='isFraud'):\n    ...     print(len(x))\n    10\n    9\n    10\n    9\n    10\n\n    References\n    ----------\n    [^1]: [ARFF format description from Weka](https://waikato.github.io/weka-wiki/formats_and_processing/arff_stable/)\n\n    \"\"\"\n    buffer = filepath_or_buffer\n    if not hasattr(buffer, 'read'):\n        buffer = utils.open_filepath(buffer, compression)\n    try:\n        (rel, attrs) = read_header(buffer)\n    except ValueError as e:\n        msg = f'Error while parsing header, error was: {e}'\n        raise scipy.io.arff.ParseArffError(msg)\n    names = [attr.name for attr in attrs]\n    casts = [float if attr.__class__.__name__ == 'NumericAttribute' else None for attr in attrs]\n    for r in buffer:\n        if len(r) == 0:\n            continue\n        if sparse:\n            x = {}\n            for s in r.rstrip()[1:-1].strip().split(','):\n                (name_index, val) = s.split(' ', 1)\n                x[names[int(name_index)]] = val\n        else:\n            x = {name: cast(val) if cast else val for (name, cast, val) in zip(names, casts, r.rstrip().split(',')) if val != '?'}\n        y = None\n        if target is not None:\n            if isinstance(target, list):\n                y = {name: x.pop(name, 0) for name in target}\n            else:\n                y = x.pop(target) if target else None\n        yield (x, y)\n    if buffer is not filepath_or_buffer:\n        buffer.close()",
        "mutated": [
            "def iter_arff(filepath_or_buffer, target: str | list[str] | None=None, compression='infer', sparse=False) -> base.typing.Stream:\n    if False:\n        i = 10\n    'Iterates over rows from an ARFF file.\\n\\n    Parameters\\n    ----------\\n    filepath_or_buffer\\n        Either a string indicating the location of a file, or a buffer object that has a\\n        `read` method.\\n    target\\n        Name(s) of the target field. If `None`, then the target field is ignored. If a list of\\n        names is passed, then a dictionary is returned instead of a single value.\\n    compression\\n        For on-the-fly decompression of on-disk data. If this is set to \\'infer\\' and\\n        `filepath_or_buffer` is a path, then the decompression method is inferred for the\\n        following extensions: \\'.gz\\', \\'.zip\\'.\\n    sparse\\n        Whether the data is sparse or not.\\n\\n    Examples\\n    --------\\n\\n    >>> cars = \\'\\'\\'\\n    ... @relation CarData\\n    ... @attribute make {Toyota, Honda, Ford, Chevrolet}\\n    ... @attribute model string\\n    ... @attribute year numeric\\n    ... @attribute price numeric\\n    ... @attribute mpg numeric\\n    ... @data\\n    ... Toyota, Corolla, 2018, 15000, 30.5\\n    ... Honda, Civic, 2019, 16000, 32.2\\n    ... Ford, Mustang, 2020, 25000, 25.0\\n    ... Chevrolet, Malibu, 2017, 18000, 28.9\\n    ... Toyota, Camry, 2019, 22000, 29.8\\n    ... \\'\\'\\'\\n    >>> with open(\\'cars.arff\\', mode=\\'w\\') as f:\\n    ...     _ = f.write(cars)\\n\\n    >>> from river import stream\\n\\n    >>> for x, y in stream.iter_arff(\\'cars.arff\\', target=\\'price\\'):\\n    ...     print(x, y)\\n    {\\'make\\': \\'Toyota\\', \\'model\\': \\' Corolla\\', \\'year\\': 2018.0, \\'mpg\\': 30.5} 15000.0\\n    {\\'make\\': \\'Honda\\', \\'model\\': \\' Civic\\', \\'year\\': 2019.0, \\'mpg\\': 32.2} 16000.0\\n    {\\'make\\': \\'Ford\\', \\'model\\': \\' Mustang\\', \\'year\\': 2020.0, \\'mpg\\': 25.0} 25000.0\\n    {\\'make\\': \\'Chevrolet\\', \\'model\\': \\' Malibu\\', \\'year\\': 2017.0, \\'mpg\\': 28.9} 18000.0\\n    {\\'make\\': \\'Toyota\\', \\'model\\': \\' Camry\\', \\'year\\': 2019.0, \\'mpg\\': 29.8} 22000.0\\n\\n    Finally, let\\'s delete the example file.\\n\\n    >>> import os; os.remove(\\'cars.arff\\')\\n\\n    ARFF files support sparse data. Let\\'s create a sparse ARFF file.\\n\\n    >>> sparse = \\'\\'\\'\\n    ... % traindata\\n    ... @RELATION \"traindata: -C 6\"\\n    ... @ATTRIBUTE y0 {0, 1}\\n    ... @ATTRIBUTE y1 {0, 1}\\n    ... @ATTRIBUTE y2 {0, 1}\\n    ... @ATTRIBUTE y3 {0, 1}\\n    ... @ATTRIBUTE y4 {0, 1}\\n    ... @ATTRIBUTE y5 {0, 1}\\n    ... @ATTRIBUTE X0 NUMERIC\\n    ... @ATTRIBUTE X1 NUMERIC\\n    ... @ATTRIBUTE X2 NUMERIC\\n    ... @DATA\\n    ... { 3 1,6 0.863382,8 0.820094 }\\n    ... { 2 1,6 0.659761 }\\n    ... { 0 1,3 1,6 0.437881,8 0.818882 }\\n    ... { 2 1,6 0.676477,7 0.724635,8 0.755123 }\\n    ... \\'\\'\\'\\n\\n    >>> with open(\\'sparse.arff\\', mode=\\'w\\') as f:\\n    ...     _ = f.write(sparse)\\n\\n    In addition, we\\'ll specify that there are several target fields.\\n\\n    >>> arff_stream = stream.iter_arff(\\n    ...     \\'sparse.arff\\',\\n    ...     target=[\\'y0\\', \\'y1\\', \\'y2\\', \\'y3\\', \\'y4\\', \\'y5\\'],\\n    ...     sparse=True\\n    ... )\\n\\n    >>> for x, y in arff_stream:\\n    ...     print(x)\\n    ...     print(y)\\n    {\\'X0\\': \\'0.863382\\', \\'X2\\': \\'0.820094\\'}\\n    {\\'y0\\': 0, \\'y1\\': 0, \\'y2\\': 0, \\'y3\\': \\'1\\', \\'y4\\': 0, \\'y5\\': 0}\\n    {\\'X0\\': \\'0.659761\\'}\\n    {\\'y0\\': 0, \\'y1\\': 0, \\'y2\\': \\'1\\', \\'y3\\': 0, \\'y4\\': 0, \\'y5\\': 0}\\n    {\\'X0\\': \\'0.437881\\', \\'X2\\': \\'0.818882\\'}\\n    {\\'y0\\': \\'1\\', \\'y1\\': 0, \\'y2\\': 0, \\'y3\\': \\'1\\', \\'y4\\': 0, \\'y5\\': 0}\\n    {\\'X0\\': \\'0.676477\\', \\'X1\\': \\'0.724635\\', \\'X2\\': \\'0.755123\\'}\\n    {\\'y0\\': 0, \\'y1\\': 0, \\'y2\\': \\'1\\', \\'y3\\': 0, \\'y4\\': 0, \\'y5\\': 0}\\n\\n    This function can also deal with missing features in non-sparse data. These are indicated with\\n    a question mark.\\n\\n    >>> data = \\'\\'\\'\\n    ... @relation giveMeLoan-weka.filters.unsupervised.attribute.Remove-R1\\n    ... @attribute RevolvingUtilizationOfUnsecuredLines numeric\\n    ... @attribute age numeric\\n    ... @attribute NumberOfTime30-59DaysPastDueNotWorse numeric\\n    ... @attribute DebtRatio numeric\\n    ... @attribute MonthlyIncome numeric\\n    ... @attribute NumberOfOpenCreditLinesAndLoans numeric\\n    ... @attribute NumberOfTimes90DaysLate numeric\\n    ... @attribute NumberRealEstateLoansOrLines numeric\\n    ... @attribute NumberOfTime60-89DaysPastDueNotWorse numeric\\n    ... @attribute NumberOfDependents numeric\\n    ... @attribute isFraud {0,1}\\n    ... @data\\n    ... 0.213179,74,0,0.375607,3500,3,0,1,0,1,0\\n    ... 0.305682,57,0,5710,?,8,0,3,0,0,0\\n    ... 0.754464,39,0,0.20994,3500,8,0,0,0,0,0\\n    ... 0.116951,27,0,46,?,2,0,0,0,0,0\\n    ... 0.189169,57,0,0.606291,23684,9,0,4,0,2,0\\n    ... \\'\\'\\'\\n\\n    >>> with open(\\'data.arff\\', mode=\\'w\\') as f:\\n    ...     _ = f.write(data)\\n\\n    >>> for x, y in stream.iter_arff(\\'data.arff\\', target=\\'isFraud\\'):\\n    ...     print(len(x))\\n    10\\n    9\\n    10\\n    9\\n    10\\n\\n    References\\n    ----------\\n    [^1]: [ARFF format description from Weka](https://waikato.github.io/weka-wiki/formats_and_processing/arff_stable/)\\n\\n    '\n    buffer = filepath_or_buffer\n    if not hasattr(buffer, 'read'):\n        buffer = utils.open_filepath(buffer, compression)\n    try:\n        (rel, attrs) = read_header(buffer)\n    except ValueError as e:\n        msg = f'Error while parsing header, error was: {e}'\n        raise scipy.io.arff.ParseArffError(msg)\n    names = [attr.name for attr in attrs]\n    casts = [float if attr.__class__.__name__ == 'NumericAttribute' else None for attr in attrs]\n    for r in buffer:\n        if len(r) == 0:\n            continue\n        if sparse:\n            x = {}\n            for s in r.rstrip()[1:-1].strip().split(','):\n                (name_index, val) = s.split(' ', 1)\n                x[names[int(name_index)]] = val\n        else:\n            x = {name: cast(val) if cast else val for (name, cast, val) in zip(names, casts, r.rstrip().split(',')) if val != '?'}\n        y = None\n        if target is not None:\n            if isinstance(target, list):\n                y = {name: x.pop(name, 0) for name in target}\n            else:\n                y = x.pop(target) if target else None\n        yield (x, y)\n    if buffer is not filepath_or_buffer:\n        buffer.close()",
            "def iter_arff(filepath_or_buffer, target: str | list[str] | None=None, compression='infer', sparse=False) -> base.typing.Stream:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Iterates over rows from an ARFF file.\\n\\n    Parameters\\n    ----------\\n    filepath_or_buffer\\n        Either a string indicating the location of a file, or a buffer object that has a\\n        `read` method.\\n    target\\n        Name(s) of the target field. If `None`, then the target field is ignored. If a list of\\n        names is passed, then a dictionary is returned instead of a single value.\\n    compression\\n        For on-the-fly decompression of on-disk data. If this is set to \\'infer\\' and\\n        `filepath_or_buffer` is a path, then the decompression method is inferred for the\\n        following extensions: \\'.gz\\', \\'.zip\\'.\\n    sparse\\n        Whether the data is sparse or not.\\n\\n    Examples\\n    --------\\n\\n    >>> cars = \\'\\'\\'\\n    ... @relation CarData\\n    ... @attribute make {Toyota, Honda, Ford, Chevrolet}\\n    ... @attribute model string\\n    ... @attribute year numeric\\n    ... @attribute price numeric\\n    ... @attribute mpg numeric\\n    ... @data\\n    ... Toyota, Corolla, 2018, 15000, 30.5\\n    ... Honda, Civic, 2019, 16000, 32.2\\n    ... Ford, Mustang, 2020, 25000, 25.0\\n    ... Chevrolet, Malibu, 2017, 18000, 28.9\\n    ... Toyota, Camry, 2019, 22000, 29.8\\n    ... \\'\\'\\'\\n    >>> with open(\\'cars.arff\\', mode=\\'w\\') as f:\\n    ...     _ = f.write(cars)\\n\\n    >>> from river import stream\\n\\n    >>> for x, y in stream.iter_arff(\\'cars.arff\\', target=\\'price\\'):\\n    ...     print(x, y)\\n    {\\'make\\': \\'Toyota\\', \\'model\\': \\' Corolla\\', \\'year\\': 2018.0, \\'mpg\\': 30.5} 15000.0\\n    {\\'make\\': \\'Honda\\', \\'model\\': \\' Civic\\', \\'year\\': 2019.0, \\'mpg\\': 32.2} 16000.0\\n    {\\'make\\': \\'Ford\\', \\'model\\': \\' Mustang\\', \\'year\\': 2020.0, \\'mpg\\': 25.0} 25000.0\\n    {\\'make\\': \\'Chevrolet\\', \\'model\\': \\' Malibu\\', \\'year\\': 2017.0, \\'mpg\\': 28.9} 18000.0\\n    {\\'make\\': \\'Toyota\\', \\'model\\': \\' Camry\\', \\'year\\': 2019.0, \\'mpg\\': 29.8} 22000.0\\n\\n    Finally, let\\'s delete the example file.\\n\\n    >>> import os; os.remove(\\'cars.arff\\')\\n\\n    ARFF files support sparse data. Let\\'s create a sparse ARFF file.\\n\\n    >>> sparse = \\'\\'\\'\\n    ... % traindata\\n    ... @RELATION \"traindata: -C 6\"\\n    ... @ATTRIBUTE y0 {0, 1}\\n    ... @ATTRIBUTE y1 {0, 1}\\n    ... @ATTRIBUTE y2 {0, 1}\\n    ... @ATTRIBUTE y3 {0, 1}\\n    ... @ATTRIBUTE y4 {0, 1}\\n    ... @ATTRIBUTE y5 {0, 1}\\n    ... @ATTRIBUTE X0 NUMERIC\\n    ... @ATTRIBUTE X1 NUMERIC\\n    ... @ATTRIBUTE X2 NUMERIC\\n    ... @DATA\\n    ... { 3 1,6 0.863382,8 0.820094 }\\n    ... { 2 1,6 0.659761 }\\n    ... { 0 1,3 1,6 0.437881,8 0.818882 }\\n    ... { 2 1,6 0.676477,7 0.724635,8 0.755123 }\\n    ... \\'\\'\\'\\n\\n    >>> with open(\\'sparse.arff\\', mode=\\'w\\') as f:\\n    ...     _ = f.write(sparse)\\n\\n    In addition, we\\'ll specify that there are several target fields.\\n\\n    >>> arff_stream = stream.iter_arff(\\n    ...     \\'sparse.arff\\',\\n    ...     target=[\\'y0\\', \\'y1\\', \\'y2\\', \\'y3\\', \\'y4\\', \\'y5\\'],\\n    ...     sparse=True\\n    ... )\\n\\n    >>> for x, y in arff_stream:\\n    ...     print(x)\\n    ...     print(y)\\n    {\\'X0\\': \\'0.863382\\', \\'X2\\': \\'0.820094\\'}\\n    {\\'y0\\': 0, \\'y1\\': 0, \\'y2\\': 0, \\'y3\\': \\'1\\', \\'y4\\': 0, \\'y5\\': 0}\\n    {\\'X0\\': \\'0.659761\\'}\\n    {\\'y0\\': 0, \\'y1\\': 0, \\'y2\\': \\'1\\', \\'y3\\': 0, \\'y4\\': 0, \\'y5\\': 0}\\n    {\\'X0\\': \\'0.437881\\', \\'X2\\': \\'0.818882\\'}\\n    {\\'y0\\': \\'1\\', \\'y1\\': 0, \\'y2\\': 0, \\'y3\\': \\'1\\', \\'y4\\': 0, \\'y5\\': 0}\\n    {\\'X0\\': \\'0.676477\\', \\'X1\\': \\'0.724635\\', \\'X2\\': \\'0.755123\\'}\\n    {\\'y0\\': 0, \\'y1\\': 0, \\'y2\\': \\'1\\', \\'y3\\': 0, \\'y4\\': 0, \\'y5\\': 0}\\n\\n    This function can also deal with missing features in non-sparse data. These are indicated with\\n    a question mark.\\n\\n    >>> data = \\'\\'\\'\\n    ... @relation giveMeLoan-weka.filters.unsupervised.attribute.Remove-R1\\n    ... @attribute RevolvingUtilizationOfUnsecuredLines numeric\\n    ... @attribute age numeric\\n    ... @attribute NumberOfTime30-59DaysPastDueNotWorse numeric\\n    ... @attribute DebtRatio numeric\\n    ... @attribute MonthlyIncome numeric\\n    ... @attribute NumberOfOpenCreditLinesAndLoans numeric\\n    ... @attribute NumberOfTimes90DaysLate numeric\\n    ... @attribute NumberRealEstateLoansOrLines numeric\\n    ... @attribute NumberOfTime60-89DaysPastDueNotWorse numeric\\n    ... @attribute NumberOfDependents numeric\\n    ... @attribute isFraud {0,1}\\n    ... @data\\n    ... 0.213179,74,0,0.375607,3500,3,0,1,0,1,0\\n    ... 0.305682,57,0,5710,?,8,0,3,0,0,0\\n    ... 0.754464,39,0,0.20994,3500,8,0,0,0,0,0\\n    ... 0.116951,27,0,46,?,2,0,0,0,0,0\\n    ... 0.189169,57,0,0.606291,23684,9,0,4,0,2,0\\n    ... \\'\\'\\'\\n\\n    >>> with open(\\'data.arff\\', mode=\\'w\\') as f:\\n    ...     _ = f.write(data)\\n\\n    >>> for x, y in stream.iter_arff(\\'data.arff\\', target=\\'isFraud\\'):\\n    ...     print(len(x))\\n    10\\n    9\\n    10\\n    9\\n    10\\n\\n    References\\n    ----------\\n    [^1]: [ARFF format description from Weka](https://waikato.github.io/weka-wiki/formats_and_processing/arff_stable/)\\n\\n    '\n    buffer = filepath_or_buffer\n    if not hasattr(buffer, 'read'):\n        buffer = utils.open_filepath(buffer, compression)\n    try:\n        (rel, attrs) = read_header(buffer)\n    except ValueError as e:\n        msg = f'Error while parsing header, error was: {e}'\n        raise scipy.io.arff.ParseArffError(msg)\n    names = [attr.name for attr in attrs]\n    casts = [float if attr.__class__.__name__ == 'NumericAttribute' else None for attr in attrs]\n    for r in buffer:\n        if len(r) == 0:\n            continue\n        if sparse:\n            x = {}\n            for s in r.rstrip()[1:-1].strip().split(','):\n                (name_index, val) = s.split(' ', 1)\n                x[names[int(name_index)]] = val\n        else:\n            x = {name: cast(val) if cast else val for (name, cast, val) in zip(names, casts, r.rstrip().split(',')) if val != '?'}\n        y = None\n        if target is not None:\n            if isinstance(target, list):\n                y = {name: x.pop(name, 0) for name in target}\n            else:\n                y = x.pop(target) if target else None\n        yield (x, y)\n    if buffer is not filepath_or_buffer:\n        buffer.close()",
            "def iter_arff(filepath_or_buffer, target: str | list[str] | None=None, compression='infer', sparse=False) -> base.typing.Stream:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Iterates over rows from an ARFF file.\\n\\n    Parameters\\n    ----------\\n    filepath_or_buffer\\n        Either a string indicating the location of a file, or a buffer object that has a\\n        `read` method.\\n    target\\n        Name(s) of the target field. If `None`, then the target field is ignored. If a list of\\n        names is passed, then a dictionary is returned instead of a single value.\\n    compression\\n        For on-the-fly decompression of on-disk data. If this is set to \\'infer\\' and\\n        `filepath_or_buffer` is a path, then the decompression method is inferred for the\\n        following extensions: \\'.gz\\', \\'.zip\\'.\\n    sparse\\n        Whether the data is sparse or not.\\n\\n    Examples\\n    --------\\n\\n    >>> cars = \\'\\'\\'\\n    ... @relation CarData\\n    ... @attribute make {Toyota, Honda, Ford, Chevrolet}\\n    ... @attribute model string\\n    ... @attribute year numeric\\n    ... @attribute price numeric\\n    ... @attribute mpg numeric\\n    ... @data\\n    ... Toyota, Corolla, 2018, 15000, 30.5\\n    ... Honda, Civic, 2019, 16000, 32.2\\n    ... Ford, Mustang, 2020, 25000, 25.0\\n    ... Chevrolet, Malibu, 2017, 18000, 28.9\\n    ... Toyota, Camry, 2019, 22000, 29.8\\n    ... \\'\\'\\'\\n    >>> with open(\\'cars.arff\\', mode=\\'w\\') as f:\\n    ...     _ = f.write(cars)\\n\\n    >>> from river import stream\\n\\n    >>> for x, y in stream.iter_arff(\\'cars.arff\\', target=\\'price\\'):\\n    ...     print(x, y)\\n    {\\'make\\': \\'Toyota\\', \\'model\\': \\' Corolla\\', \\'year\\': 2018.0, \\'mpg\\': 30.5} 15000.0\\n    {\\'make\\': \\'Honda\\', \\'model\\': \\' Civic\\', \\'year\\': 2019.0, \\'mpg\\': 32.2} 16000.0\\n    {\\'make\\': \\'Ford\\', \\'model\\': \\' Mustang\\', \\'year\\': 2020.0, \\'mpg\\': 25.0} 25000.0\\n    {\\'make\\': \\'Chevrolet\\', \\'model\\': \\' Malibu\\', \\'year\\': 2017.0, \\'mpg\\': 28.9} 18000.0\\n    {\\'make\\': \\'Toyota\\', \\'model\\': \\' Camry\\', \\'year\\': 2019.0, \\'mpg\\': 29.8} 22000.0\\n\\n    Finally, let\\'s delete the example file.\\n\\n    >>> import os; os.remove(\\'cars.arff\\')\\n\\n    ARFF files support sparse data. Let\\'s create a sparse ARFF file.\\n\\n    >>> sparse = \\'\\'\\'\\n    ... % traindata\\n    ... @RELATION \"traindata: -C 6\"\\n    ... @ATTRIBUTE y0 {0, 1}\\n    ... @ATTRIBUTE y1 {0, 1}\\n    ... @ATTRIBUTE y2 {0, 1}\\n    ... @ATTRIBUTE y3 {0, 1}\\n    ... @ATTRIBUTE y4 {0, 1}\\n    ... @ATTRIBUTE y5 {0, 1}\\n    ... @ATTRIBUTE X0 NUMERIC\\n    ... @ATTRIBUTE X1 NUMERIC\\n    ... @ATTRIBUTE X2 NUMERIC\\n    ... @DATA\\n    ... { 3 1,6 0.863382,8 0.820094 }\\n    ... { 2 1,6 0.659761 }\\n    ... { 0 1,3 1,6 0.437881,8 0.818882 }\\n    ... { 2 1,6 0.676477,7 0.724635,8 0.755123 }\\n    ... \\'\\'\\'\\n\\n    >>> with open(\\'sparse.arff\\', mode=\\'w\\') as f:\\n    ...     _ = f.write(sparse)\\n\\n    In addition, we\\'ll specify that there are several target fields.\\n\\n    >>> arff_stream = stream.iter_arff(\\n    ...     \\'sparse.arff\\',\\n    ...     target=[\\'y0\\', \\'y1\\', \\'y2\\', \\'y3\\', \\'y4\\', \\'y5\\'],\\n    ...     sparse=True\\n    ... )\\n\\n    >>> for x, y in arff_stream:\\n    ...     print(x)\\n    ...     print(y)\\n    {\\'X0\\': \\'0.863382\\', \\'X2\\': \\'0.820094\\'}\\n    {\\'y0\\': 0, \\'y1\\': 0, \\'y2\\': 0, \\'y3\\': \\'1\\', \\'y4\\': 0, \\'y5\\': 0}\\n    {\\'X0\\': \\'0.659761\\'}\\n    {\\'y0\\': 0, \\'y1\\': 0, \\'y2\\': \\'1\\', \\'y3\\': 0, \\'y4\\': 0, \\'y5\\': 0}\\n    {\\'X0\\': \\'0.437881\\', \\'X2\\': \\'0.818882\\'}\\n    {\\'y0\\': \\'1\\', \\'y1\\': 0, \\'y2\\': 0, \\'y3\\': \\'1\\', \\'y4\\': 0, \\'y5\\': 0}\\n    {\\'X0\\': \\'0.676477\\', \\'X1\\': \\'0.724635\\', \\'X2\\': \\'0.755123\\'}\\n    {\\'y0\\': 0, \\'y1\\': 0, \\'y2\\': \\'1\\', \\'y3\\': 0, \\'y4\\': 0, \\'y5\\': 0}\\n\\n    This function can also deal with missing features in non-sparse data. These are indicated with\\n    a question mark.\\n\\n    >>> data = \\'\\'\\'\\n    ... @relation giveMeLoan-weka.filters.unsupervised.attribute.Remove-R1\\n    ... @attribute RevolvingUtilizationOfUnsecuredLines numeric\\n    ... @attribute age numeric\\n    ... @attribute NumberOfTime30-59DaysPastDueNotWorse numeric\\n    ... @attribute DebtRatio numeric\\n    ... @attribute MonthlyIncome numeric\\n    ... @attribute NumberOfOpenCreditLinesAndLoans numeric\\n    ... @attribute NumberOfTimes90DaysLate numeric\\n    ... @attribute NumberRealEstateLoansOrLines numeric\\n    ... @attribute NumberOfTime60-89DaysPastDueNotWorse numeric\\n    ... @attribute NumberOfDependents numeric\\n    ... @attribute isFraud {0,1}\\n    ... @data\\n    ... 0.213179,74,0,0.375607,3500,3,0,1,0,1,0\\n    ... 0.305682,57,0,5710,?,8,0,3,0,0,0\\n    ... 0.754464,39,0,0.20994,3500,8,0,0,0,0,0\\n    ... 0.116951,27,0,46,?,2,0,0,0,0,0\\n    ... 0.189169,57,0,0.606291,23684,9,0,4,0,2,0\\n    ... \\'\\'\\'\\n\\n    >>> with open(\\'data.arff\\', mode=\\'w\\') as f:\\n    ...     _ = f.write(data)\\n\\n    >>> for x, y in stream.iter_arff(\\'data.arff\\', target=\\'isFraud\\'):\\n    ...     print(len(x))\\n    10\\n    9\\n    10\\n    9\\n    10\\n\\n    References\\n    ----------\\n    [^1]: [ARFF format description from Weka](https://waikato.github.io/weka-wiki/formats_and_processing/arff_stable/)\\n\\n    '\n    buffer = filepath_or_buffer\n    if not hasattr(buffer, 'read'):\n        buffer = utils.open_filepath(buffer, compression)\n    try:\n        (rel, attrs) = read_header(buffer)\n    except ValueError as e:\n        msg = f'Error while parsing header, error was: {e}'\n        raise scipy.io.arff.ParseArffError(msg)\n    names = [attr.name for attr in attrs]\n    casts = [float if attr.__class__.__name__ == 'NumericAttribute' else None for attr in attrs]\n    for r in buffer:\n        if len(r) == 0:\n            continue\n        if sparse:\n            x = {}\n            for s in r.rstrip()[1:-1].strip().split(','):\n                (name_index, val) = s.split(' ', 1)\n                x[names[int(name_index)]] = val\n        else:\n            x = {name: cast(val) if cast else val for (name, cast, val) in zip(names, casts, r.rstrip().split(',')) if val != '?'}\n        y = None\n        if target is not None:\n            if isinstance(target, list):\n                y = {name: x.pop(name, 0) for name in target}\n            else:\n                y = x.pop(target) if target else None\n        yield (x, y)\n    if buffer is not filepath_or_buffer:\n        buffer.close()",
            "def iter_arff(filepath_or_buffer, target: str | list[str] | None=None, compression='infer', sparse=False) -> base.typing.Stream:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Iterates over rows from an ARFF file.\\n\\n    Parameters\\n    ----------\\n    filepath_or_buffer\\n        Either a string indicating the location of a file, or a buffer object that has a\\n        `read` method.\\n    target\\n        Name(s) of the target field. If `None`, then the target field is ignored. If a list of\\n        names is passed, then a dictionary is returned instead of a single value.\\n    compression\\n        For on-the-fly decompression of on-disk data. If this is set to \\'infer\\' and\\n        `filepath_or_buffer` is a path, then the decompression method is inferred for the\\n        following extensions: \\'.gz\\', \\'.zip\\'.\\n    sparse\\n        Whether the data is sparse or not.\\n\\n    Examples\\n    --------\\n\\n    >>> cars = \\'\\'\\'\\n    ... @relation CarData\\n    ... @attribute make {Toyota, Honda, Ford, Chevrolet}\\n    ... @attribute model string\\n    ... @attribute year numeric\\n    ... @attribute price numeric\\n    ... @attribute mpg numeric\\n    ... @data\\n    ... Toyota, Corolla, 2018, 15000, 30.5\\n    ... Honda, Civic, 2019, 16000, 32.2\\n    ... Ford, Mustang, 2020, 25000, 25.0\\n    ... Chevrolet, Malibu, 2017, 18000, 28.9\\n    ... Toyota, Camry, 2019, 22000, 29.8\\n    ... \\'\\'\\'\\n    >>> with open(\\'cars.arff\\', mode=\\'w\\') as f:\\n    ...     _ = f.write(cars)\\n\\n    >>> from river import stream\\n\\n    >>> for x, y in stream.iter_arff(\\'cars.arff\\', target=\\'price\\'):\\n    ...     print(x, y)\\n    {\\'make\\': \\'Toyota\\', \\'model\\': \\' Corolla\\', \\'year\\': 2018.0, \\'mpg\\': 30.5} 15000.0\\n    {\\'make\\': \\'Honda\\', \\'model\\': \\' Civic\\', \\'year\\': 2019.0, \\'mpg\\': 32.2} 16000.0\\n    {\\'make\\': \\'Ford\\', \\'model\\': \\' Mustang\\', \\'year\\': 2020.0, \\'mpg\\': 25.0} 25000.0\\n    {\\'make\\': \\'Chevrolet\\', \\'model\\': \\' Malibu\\', \\'year\\': 2017.0, \\'mpg\\': 28.9} 18000.0\\n    {\\'make\\': \\'Toyota\\', \\'model\\': \\' Camry\\', \\'year\\': 2019.0, \\'mpg\\': 29.8} 22000.0\\n\\n    Finally, let\\'s delete the example file.\\n\\n    >>> import os; os.remove(\\'cars.arff\\')\\n\\n    ARFF files support sparse data. Let\\'s create a sparse ARFF file.\\n\\n    >>> sparse = \\'\\'\\'\\n    ... % traindata\\n    ... @RELATION \"traindata: -C 6\"\\n    ... @ATTRIBUTE y0 {0, 1}\\n    ... @ATTRIBUTE y1 {0, 1}\\n    ... @ATTRIBUTE y2 {0, 1}\\n    ... @ATTRIBUTE y3 {0, 1}\\n    ... @ATTRIBUTE y4 {0, 1}\\n    ... @ATTRIBUTE y5 {0, 1}\\n    ... @ATTRIBUTE X0 NUMERIC\\n    ... @ATTRIBUTE X1 NUMERIC\\n    ... @ATTRIBUTE X2 NUMERIC\\n    ... @DATA\\n    ... { 3 1,6 0.863382,8 0.820094 }\\n    ... { 2 1,6 0.659761 }\\n    ... { 0 1,3 1,6 0.437881,8 0.818882 }\\n    ... { 2 1,6 0.676477,7 0.724635,8 0.755123 }\\n    ... \\'\\'\\'\\n\\n    >>> with open(\\'sparse.arff\\', mode=\\'w\\') as f:\\n    ...     _ = f.write(sparse)\\n\\n    In addition, we\\'ll specify that there are several target fields.\\n\\n    >>> arff_stream = stream.iter_arff(\\n    ...     \\'sparse.arff\\',\\n    ...     target=[\\'y0\\', \\'y1\\', \\'y2\\', \\'y3\\', \\'y4\\', \\'y5\\'],\\n    ...     sparse=True\\n    ... )\\n\\n    >>> for x, y in arff_stream:\\n    ...     print(x)\\n    ...     print(y)\\n    {\\'X0\\': \\'0.863382\\', \\'X2\\': \\'0.820094\\'}\\n    {\\'y0\\': 0, \\'y1\\': 0, \\'y2\\': 0, \\'y3\\': \\'1\\', \\'y4\\': 0, \\'y5\\': 0}\\n    {\\'X0\\': \\'0.659761\\'}\\n    {\\'y0\\': 0, \\'y1\\': 0, \\'y2\\': \\'1\\', \\'y3\\': 0, \\'y4\\': 0, \\'y5\\': 0}\\n    {\\'X0\\': \\'0.437881\\', \\'X2\\': \\'0.818882\\'}\\n    {\\'y0\\': \\'1\\', \\'y1\\': 0, \\'y2\\': 0, \\'y3\\': \\'1\\', \\'y4\\': 0, \\'y5\\': 0}\\n    {\\'X0\\': \\'0.676477\\', \\'X1\\': \\'0.724635\\', \\'X2\\': \\'0.755123\\'}\\n    {\\'y0\\': 0, \\'y1\\': 0, \\'y2\\': \\'1\\', \\'y3\\': 0, \\'y4\\': 0, \\'y5\\': 0}\\n\\n    This function can also deal with missing features in non-sparse data. These are indicated with\\n    a question mark.\\n\\n    >>> data = \\'\\'\\'\\n    ... @relation giveMeLoan-weka.filters.unsupervised.attribute.Remove-R1\\n    ... @attribute RevolvingUtilizationOfUnsecuredLines numeric\\n    ... @attribute age numeric\\n    ... @attribute NumberOfTime30-59DaysPastDueNotWorse numeric\\n    ... @attribute DebtRatio numeric\\n    ... @attribute MonthlyIncome numeric\\n    ... @attribute NumberOfOpenCreditLinesAndLoans numeric\\n    ... @attribute NumberOfTimes90DaysLate numeric\\n    ... @attribute NumberRealEstateLoansOrLines numeric\\n    ... @attribute NumberOfTime60-89DaysPastDueNotWorse numeric\\n    ... @attribute NumberOfDependents numeric\\n    ... @attribute isFraud {0,1}\\n    ... @data\\n    ... 0.213179,74,0,0.375607,3500,3,0,1,0,1,0\\n    ... 0.305682,57,0,5710,?,8,0,3,0,0,0\\n    ... 0.754464,39,0,0.20994,3500,8,0,0,0,0,0\\n    ... 0.116951,27,0,46,?,2,0,0,0,0,0\\n    ... 0.189169,57,0,0.606291,23684,9,0,4,0,2,0\\n    ... \\'\\'\\'\\n\\n    >>> with open(\\'data.arff\\', mode=\\'w\\') as f:\\n    ...     _ = f.write(data)\\n\\n    >>> for x, y in stream.iter_arff(\\'data.arff\\', target=\\'isFraud\\'):\\n    ...     print(len(x))\\n    10\\n    9\\n    10\\n    9\\n    10\\n\\n    References\\n    ----------\\n    [^1]: [ARFF format description from Weka](https://waikato.github.io/weka-wiki/formats_and_processing/arff_stable/)\\n\\n    '\n    buffer = filepath_or_buffer\n    if not hasattr(buffer, 'read'):\n        buffer = utils.open_filepath(buffer, compression)\n    try:\n        (rel, attrs) = read_header(buffer)\n    except ValueError as e:\n        msg = f'Error while parsing header, error was: {e}'\n        raise scipy.io.arff.ParseArffError(msg)\n    names = [attr.name for attr in attrs]\n    casts = [float if attr.__class__.__name__ == 'NumericAttribute' else None for attr in attrs]\n    for r in buffer:\n        if len(r) == 0:\n            continue\n        if sparse:\n            x = {}\n            for s in r.rstrip()[1:-1].strip().split(','):\n                (name_index, val) = s.split(' ', 1)\n                x[names[int(name_index)]] = val\n        else:\n            x = {name: cast(val) if cast else val for (name, cast, val) in zip(names, casts, r.rstrip().split(',')) if val != '?'}\n        y = None\n        if target is not None:\n            if isinstance(target, list):\n                y = {name: x.pop(name, 0) for name in target}\n            else:\n                y = x.pop(target) if target else None\n        yield (x, y)\n    if buffer is not filepath_or_buffer:\n        buffer.close()",
            "def iter_arff(filepath_or_buffer, target: str | list[str] | None=None, compression='infer', sparse=False) -> base.typing.Stream:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Iterates over rows from an ARFF file.\\n\\n    Parameters\\n    ----------\\n    filepath_or_buffer\\n        Either a string indicating the location of a file, or a buffer object that has a\\n        `read` method.\\n    target\\n        Name(s) of the target field. If `None`, then the target field is ignored. If a list of\\n        names is passed, then a dictionary is returned instead of a single value.\\n    compression\\n        For on-the-fly decompression of on-disk data. If this is set to \\'infer\\' and\\n        `filepath_or_buffer` is a path, then the decompression method is inferred for the\\n        following extensions: \\'.gz\\', \\'.zip\\'.\\n    sparse\\n        Whether the data is sparse or not.\\n\\n    Examples\\n    --------\\n\\n    >>> cars = \\'\\'\\'\\n    ... @relation CarData\\n    ... @attribute make {Toyota, Honda, Ford, Chevrolet}\\n    ... @attribute model string\\n    ... @attribute year numeric\\n    ... @attribute price numeric\\n    ... @attribute mpg numeric\\n    ... @data\\n    ... Toyota, Corolla, 2018, 15000, 30.5\\n    ... Honda, Civic, 2019, 16000, 32.2\\n    ... Ford, Mustang, 2020, 25000, 25.0\\n    ... Chevrolet, Malibu, 2017, 18000, 28.9\\n    ... Toyota, Camry, 2019, 22000, 29.8\\n    ... \\'\\'\\'\\n    >>> with open(\\'cars.arff\\', mode=\\'w\\') as f:\\n    ...     _ = f.write(cars)\\n\\n    >>> from river import stream\\n\\n    >>> for x, y in stream.iter_arff(\\'cars.arff\\', target=\\'price\\'):\\n    ...     print(x, y)\\n    {\\'make\\': \\'Toyota\\', \\'model\\': \\' Corolla\\', \\'year\\': 2018.0, \\'mpg\\': 30.5} 15000.0\\n    {\\'make\\': \\'Honda\\', \\'model\\': \\' Civic\\', \\'year\\': 2019.0, \\'mpg\\': 32.2} 16000.0\\n    {\\'make\\': \\'Ford\\', \\'model\\': \\' Mustang\\', \\'year\\': 2020.0, \\'mpg\\': 25.0} 25000.0\\n    {\\'make\\': \\'Chevrolet\\', \\'model\\': \\' Malibu\\', \\'year\\': 2017.0, \\'mpg\\': 28.9} 18000.0\\n    {\\'make\\': \\'Toyota\\', \\'model\\': \\' Camry\\', \\'year\\': 2019.0, \\'mpg\\': 29.8} 22000.0\\n\\n    Finally, let\\'s delete the example file.\\n\\n    >>> import os; os.remove(\\'cars.arff\\')\\n\\n    ARFF files support sparse data. Let\\'s create a sparse ARFF file.\\n\\n    >>> sparse = \\'\\'\\'\\n    ... % traindata\\n    ... @RELATION \"traindata: -C 6\"\\n    ... @ATTRIBUTE y0 {0, 1}\\n    ... @ATTRIBUTE y1 {0, 1}\\n    ... @ATTRIBUTE y2 {0, 1}\\n    ... @ATTRIBUTE y3 {0, 1}\\n    ... @ATTRIBUTE y4 {0, 1}\\n    ... @ATTRIBUTE y5 {0, 1}\\n    ... @ATTRIBUTE X0 NUMERIC\\n    ... @ATTRIBUTE X1 NUMERIC\\n    ... @ATTRIBUTE X2 NUMERIC\\n    ... @DATA\\n    ... { 3 1,6 0.863382,8 0.820094 }\\n    ... { 2 1,6 0.659761 }\\n    ... { 0 1,3 1,6 0.437881,8 0.818882 }\\n    ... { 2 1,6 0.676477,7 0.724635,8 0.755123 }\\n    ... \\'\\'\\'\\n\\n    >>> with open(\\'sparse.arff\\', mode=\\'w\\') as f:\\n    ...     _ = f.write(sparse)\\n\\n    In addition, we\\'ll specify that there are several target fields.\\n\\n    >>> arff_stream = stream.iter_arff(\\n    ...     \\'sparse.arff\\',\\n    ...     target=[\\'y0\\', \\'y1\\', \\'y2\\', \\'y3\\', \\'y4\\', \\'y5\\'],\\n    ...     sparse=True\\n    ... )\\n\\n    >>> for x, y in arff_stream:\\n    ...     print(x)\\n    ...     print(y)\\n    {\\'X0\\': \\'0.863382\\', \\'X2\\': \\'0.820094\\'}\\n    {\\'y0\\': 0, \\'y1\\': 0, \\'y2\\': 0, \\'y3\\': \\'1\\', \\'y4\\': 0, \\'y5\\': 0}\\n    {\\'X0\\': \\'0.659761\\'}\\n    {\\'y0\\': 0, \\'y1\\': 0, \\'y2\\': \\'1\\', \\'y3\\': 0, \\'y4\\': 0, \\'y5\\': 0}\\n    {\\'X0\\': \\'0.437881\\', \\'X2\\': \\'0.818882\\'}\\n    {\\'y0\\': \\'1\\', \\'y1\\': 0, \\'y2\\': 0, \\'y3\\': \\'1\\', \\'y4\\': 0, \\'y5\\': 0}\\n    {\\'X0\\': \\'0.676477\\', \\'X1\\': \\'0.724635\\', \\'X2\\': \\'0.755123\\'}\\n    {\\'y0\\': 0, \\'y1\\': 0, \\'y2\\': \\'1\\', \\'y3\\': 0, \\'y4\\': 0, \\'y5\\': 0}\\n\\n    This function can also deal with missing features in non-sparse data. These are indicated with\\n    a question mark.\\n\\n    >>> data = \\'\\'\\'\\n    ... @relation giveMeLoan-weka.filters.unsupervised.attribute.Remove-R1\\n    ... @attribute RevolvingUtilizationOfUnsecuredLines numeric\\n    ... @attribute age numeric\\n    ... @attribute NumberOfTime30-59DaysPastDueNotWorse numeric\\n    ... @attribute DebtRatio numeric\\n    ... @attribute MonthlyIncome numeric\\n    ... @attribute NumberOfOpenCreditLinesAndLoans numeric\\n    ... @attribute NumberOfTimes90DaysLate numeric\\n    ... @attribute NumberRealEstateLoansOrLines numeric\\n    ... @attribute NumberOfTime60-89DaysPastDueNotWorse numeric\\n    ... @attribute NumberOfDependents numeric\\n    ... @attribute isFraud {0,1}\\n    ... @data\\n    ... 0.213179,74,0,0.375607,3500,3,0,1,0,1,0\\n    ... 0.305682,57,0,5710,?,8,0,3,0,0,0\\n    ... 0.754464,39,0,0.20994,3500,8,0,0,0,0,0\\n    ... 0.116951,27,0,46,?,2,0,0,0,0,0\\n    ... 0.189169,57,0,0.606291,23684,9,0,4,0,2,0\\n    ... \\'\\'\\'\\n\\n    >>> with open(\\'data.arff\\', mode=\\'w\\') as f:\\n    ...     _ = f.write(data)\\n\\n    >>> for x, y in stream.iter_arff(\\'data.arff\\', target=\\'isFraud\\'):\\n    ...     print(len(x))\\n    10\\n    9\\n    10\\n    9\\n    10\\n\\n    References\\n    ----------\\n    [^1]: [ARFF format description from Weka](https://waikato.github.io/weka-wiki/formats_and_processing/arff_stable/)\\n\\n    '\n    buffer = filepath_or_buffer\n    if not hasattr(buffer, 'read'):\n        buffer = utils.open_filepath(buffer, compression)\n    try:\n        (rel, attrs) = read_header(buffer)\n    except ValueError as e:\n        msg = f'Error while parsing header, error was: {e}'\n        raise scipy.io.arff.ParseArffError(msg)\n    names = [attr.name for attr in attrs]\n    casts = [float if attr.__class__.__name__ == 'NumericAttribute' else None for attr in attrs]\n    for r in buffer:\n        if len(r) == 0:\n            continue\n        if sparse:\n            x = {}\n            for s in r.rstrip()[1:-1].strip().split(','):\n                (name_index, val) = s.split(' ', 1)\n                x[names[int(name_index)]] = val\n        else:\n            x = {name: cast(val) if cast else val for (name, cast, val) in zip(names, casts, r.rstrip().split(',')) if val != '?'}\n        y = None\n        if target is not None:\n            if isinstance(target, list):\n                y = {name: x.pop(name, 0) for name in target}\n            else:\n                y = x.pop(target) if target else None\n        yield (x, y)\n    if buffer is not filepath_or_buffer:\n        buffer.close()"
        ]
    }
]