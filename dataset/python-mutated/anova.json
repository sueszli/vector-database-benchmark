[
    {
        "func_name": "_get_covariance",
        "original": "def _get_covariance(model, robust):\n    if robust is None:\n        return model.cov_params()\n    elif robust == 'hc0':\n        return model.cov_HC0\n    elif robust == 'hc1':\n        return model.cov_HC1\n    elif robust == 'hc2':\n        return model.cov_HC2\n    elif robust == 'hc3':\n        return model.cov_HC3\n    else:\n        raise ValueError('robust options %s not understood' % robust)",
        "mutated": [
            "def _get_covariance(model, robust):\n    if False:\n        i = 10\n    if robust is None:\n        return model.cov_params()\n    elif robust == 'hc0':\n        return model.cov_HC0\n    elif robust == 'hc1':\n        return model.cov_HC1\n    elif robust == 'hc2':\n        return model.cov_HC2\n    elif robust == 'hc3':\n        return model.cov_HC3\n    else:\n        raise ValueError('robust options %s not understood' % robust)",
            "def _get_covariance(model, robust):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if robust is None:\n        return model.cov_params()\n    elif robust == 'hc0':\n        return model.cov_HC0\n    elif robust == 'hc1':\n        return model.cov_HC1\n    elif robust == 'hc2':\n        return model.cov_HC2\n    elif robust == 'hc3':\n        return model.cov_HC3\n    else:\n        raise ValueError('robust options %s not understood' % robust)",
            "def _get_covariance(model, robust):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if robust is None:\n        return model.cov_params()\n    elif robust == 'hc0':\n        return model.cov_HC0\n    elif robust == 'hc1':\n        return model.cov_HC1\n    elif robust == 'hc2':\n        return model.cov_HC2\n    elif robust == 'hc3':\n        return model.cov_HC3\n    else:\n        raise ValueError('robust options %s not understood' % robust)",
            "def _get_covariance(model, robust):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if robust is None:\n        return model.cov_params()\n    elif robust == 'hc0':\n        return model.cov_HC0\n    elif robust == 'hc1':\n        return model.cov_HC1\n    elif robust == 'hc2':\n        return model.cov_HC2\n    elif robust == 'hc3':\n        return model.cov_HC3\n    else:\n        raise ValueError('robust options %s not understood' % robust)",
            "def _get_covariance(model, robust):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if robust is None:\n        return model.cov_params()\n    elif robust == 'hc0':\n        return model.cov_HC0\n    elif robust == 'hc1':\n        return model.cov_HC1\n    elif robust == 'hc2':\n        return model.cov_HC2\n    elif robust == 'hc3':\n        return model.cov_HC3\n    else:\n        raise ValueError('robust options %s not understood' % robust)"
        ]
    },
    {
        "func_name": "anova_single",
        "original": "def anova_single(model, **kwargs):\n    \"\"\"\n    Anova table for one fitted linear model.\n\n    Parameters\n    ----------\n    model : fitted linear model results instance\n        A fitted linear model\n    typ : int or str {1,2,3} or {\"I\",\"II\",\"III\"}\n        Type of sum of squares to use.\n\n    **kwargs**\n\n    scale : float\n        Estimate of variance, If None, will be estimated from the largest\n    model. Default is None.\n        test : str {\"F\", \"Chisq\", \"Cp\"} or None\n        Test statistics to provide. Default is \"F\".\n\n    Notes\n    -----\n    Use of this function is discouraged. Use anova_lm instead.\n    \"\"\"\n    test = kwargs.get('test', 'F')\n    scale = kwargs.get('scale', None)\n    typ = kwargs.get('typ', 1)\n    robust = kwargs.get('robust', None)\n    if robust:\n        robust = robust.lower()\n    endog = model.model.endog\n    exog = model.model.exog\n    nobs = exog.shape[0]\n    response_name = model.model.endog_names\n    design_info = model.model.data.design_info\n    exog_names = model.model.exog_names\n    n_rows = len(design_info.terms) - _has_intercept(design_info) + 1\n    pr_test = 'PR(>%s)' % test\n    names = ['df', 'sum_sq', 'mean_sq', test, pr_test]\n    table = DataFrame(np.zeros((n_rows, 5)), columns=names)\n    if typ in [1, 'I']:\n        return anova1_lm_single(model, endog, exog, nobs, design_info, table, n_rows, test, pr_test, robust)\n    elif typ in [2, 'II']:\n        return anova2_lm_single(model, design_info, n_rows, test, pr_test, robust)\n    elif typ in [3, 'III']:\n        return anova3_lm_single(model, design_info, n_rows, test, pr_test, robust)\n    elif typ in [4, 'IV']:\n        raise NotImplementedError('Type IV not yet implemented')\n    else:\n        raise ValueError('Type %s not understood' % str(typ))",
        "mutated": [
            "def anova_single(model, **kwargs):\n    if False:\n        i = 10\n    '\\n    Anova table for one fitted linear model.\\n\\n    Parameters\\n    ----------\\n    model : fitted linear model results instance\\n        A fitted linear model\\n    typ : int or str {1,2,3} or {\"I\",\"II\",\"III\"}\\n        Type of sum of squares to use.\\n\\n    **kwargs**\\n\\n    scale : float\\n        Estimate of variance, If None, will be estimated from the largest\\n    model. Default is None.\\n        test : str {\"F\", \"Chisq\", \"Cp\"} or None\\n        Test statistics to provide. Default is \"F\".\\n\\n    Notes\\n    -----\\n    Use of this function is discouraged. Use anova_lm instead.\\n    '\n    test = kwargs.get('test', 'F')\n    scale = kwargs.get('scale', None)\n    typ = kwargs.get('typ', 1)\n    robust = kwargs.get('robust', None)\n    if robust:\n        robust = robust.lower()\n    endog = model.model.endog\n    exog = model.model.exog\n    nobs = exog.shape[0]\n    response_name = model.model.endog_names\n    design_info = model.model.data.design_info\n    exog_names = model.model.exog_names\n    n_rows = len(design_info.terms) - _has_intercept(design_info) + 1\n    pr_test = 'PR(>%s)' % test\n    names = ['df', 'sum_sq', 'mean_sq', test, pr_test]\n    table = DataFrame(np.zeros((n_rows, 5)), columns=names)\n    if typ in [1, 'I']:\n        return anova1_lm_single(model, endog, exog, nobs, design_info, table, n_rows, test, pr_test, robust)\n    elif typ in [2, 'II']:\n        return anova2_lm_single(model, design_info, n_rows, test, pr_test, robust)\n    elif typ in [3, 'III']:\n        return anova3_lm_single(model, design_info, n_rows, test, pr_test, robust)\n    elif typ in [4, 'IV']:\n        raise NotImplementedError('Type IV not yet implemented')\n    else:\n        raise ValueError('Type %s not understood' % str(typ))",
            "def anova_single(model, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Anova table for one fitted linear model.\\n\\n    Parameters\\n    ----------\\n    model : fitted linear model results instance\\n        A fitted linear model\\n    typ : int or str {1,2,3} or {\"I\",\"II\",\"III\"}\\n        Type of sum of squares to use.\\n\\n    **kwargs**\\n\\n    scale : float\\n        Estimate of variance, If None, will be estimated from the largest\\n    model. Default is None.\\n        test : str {\"F\", \"Chisq\", \"Cp\"} or None\\n        Test statistics to provide. Default is \"F\".\\n\\n    Notes\\n    -----\\n    Use of this function is discouraged. Use anova_lm instead.\\n    '\n    test = kwargs.get('test', 'F')\n    scale = kwargs.get('scale', None)\n    typ = kwargs.get('typ', 1)\n    robust = kwargs.get('robust', None)\n    if robust:\n        robust = robust.lower()\n    endog = model.model.endog\n    exog = model.model.exog\n    nobs = exog.shape[0]\n    response_name = model.model.endog_names\n    design_info = model.model.data.design_info\n    exog_names = model.model.exog_names\n    n_rows = len(design_info.terms) - _has_intercept(design_info) + 1\n    pr_test = 'PR(>%s)' % test\n    names = ['df', 'sum_sq', 'mean_sq', test, pr_test]\n    table = DataFrame(np.zeros((n_rows, 5)), columns=names)\n    if typ in [1, 'I']:\n        return anova1_lm_single(model, endog, exog, nobs, design_info, table, n_rows, test, pr_test, robust)\n    elif typ in [2, 'II']:\n        return anova2_lm_single(model, design_info, n_rows, test, pr_test, robust)\n    elif typ in [3, 'III']:\n        return anova3_lm_single(model, design_info, n_rows, test, pr_test, robust)\n    elif typ in [4, 'IV']:\n        raise NotImplementedError('Type IV not yet implemented')\n    else:\n        raise ValueError('Type %s not understood' % str(typ))",
            "def anova_single(model, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Anova table for one fitted linear model.\\n\\n    Parameters\\n    ----------\\n    model : fitted linear model results instance\\n        A fitted linear model\\n    typ : int or str {1,2,3} or {\"I\",\"II\",\"III\"}\\n        Type of sum of squares to use.\\n\\n    **kwargs**\\n\\n    scale : float\\n        Estimate of variance, If None, will be estimated from the largest\\n    model. Default is None.\\n        test : str {\"F\", \"Chisq\", \"Cp\"} or None\\n        Test statistics to provide. Default is \"F\".\\n\\n    Notes\\n    -----\\n    Use of this function is discouraged. Use anova_lm instead.\\n    '\n    test = kwargs.get('test', 'F')\n    scale = kwargs.get('scale', None)\n    typ = kwargs.get('typ', 1)\n    robust = kwargs.get('robust', None)\n    if robust:\n        robust = robust.lower()\n    endog = model.model.endog\n    exog = model.model.exog\n    nobs = exog.shape[0]\n    response_name = model.model.endog_names\n    design_info = model.model.data.design_info\n    exog_names = model.model.exog_names\n    n_rows = len(design_info.terms) - _has_intercept(design_info) + 1\n    pr_test = 'PR(>%s)' % test\n    names = ['df', 'sum_sq', 'mean_sq', test, pr_test]\n    table = DataFrame(np.zeros((n_rows, 5)), columns=names)\n    if typ in [1, 'I']:\n        return anova1_lm_single(model, endog, exog, nobs, design_info, table, n_rows, test, pr_test, robust)\n    elif typ in [2, 'II']:\n        return anova2_lm_single(model, design_info, n_rows, test, pr_test, robust)\n    elif typ in [3, 'III']:\n        return anova3_lm_single(model, design_info, n_rows, test, pr_test, robust)\n    elif typ in [4, 'IV']:\n        raise NotImplementedError('Type IV not yet implemented')\n    else:\n        raise ValueError('Type %s not understood' % str(typ))",
            "def anova_single(model, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Anova table for one fitted linear model.\\n\\n    Parameters\\n    ----------\\n    model : fitted linear model results instance\\n        A fitted linear model\\n    typ : int or str {1,2,3} or {\"I\",\"II\",\"III\"}\\n        Type of sum of squares to use.\\n\\n    **kwargs**\\n\\n    scale : float\\n        Estimate of variance, If None, will be estimated from the largest\\n    model. Default is None.\\n        test : str {\"F\", \"Chisq\", \"Cp\"} or None\\n        Test statistics to provide. Default is \"F\".\\n\\n    Notes\\n    -----\\n    Use of this function is discouraged. Use anova_lm instead.\\n    '\n    test = kwargs.get('test', 'F')\n    scale = kwargs.get('scale', None)\n    typ = kwargs.get('typ', 1)\n    robust = kwargs.get('robust', None)\n    if robust:\n        robust = robust.lower()\n    endog = model.model.endog\n    exog = model.model.exog\n    nobs = exog.shape[0]\n    response_name = model.model.endog_names\n    design_info = model.model.data.design_info\n    exog_names = model.model.exog_names\n    n_rows = len(design_info.terms) - _has_intercept(design_info) + 1\n    pr_test = 'PR(>%s)' % test\n    names = ['df', 'sum_sq', 'mean_sq', test, pr_test]\n    table = DataFrame(np.zeros((n_rows, 5)), columns=names)\n    if typ in [1, 'I']:\n        return anova1_lm_single(model, endog, exog, nobs, design_info, table, n_rows, test, pr_test, robust)\n    elif typ in [2, 'II']:\n        return anova2_lm_single(model, design_info, n_rows, test, pr_test, robust)\n    elif typ in [3, 'III']:\n        return anova3_lm_single(model, design_info, n_rows, test, pr_test, robust)\n    elif typ in [4, 'IV']:\n        raise NotImplementedError('Type IV not yet implemented')\n    else:\n        raise ValueError('Type %s not understood' % str(typ))",
            "def anova_single(model, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Anova table for one fitted linear model.\\n\\n    Parameters\\n    ----------\\n    model : fitted linear model results instance\\n        A fitted linear model\\n    typ : int or str {1,2,3} or {\"I\",\"II\",\"III\"}\\n        Type of sum of squares to use.\\n\\n    **kwargs**\\n\\n    scale : float\\n        Estimate of variance, If None, will be estimated from the largest\\n    model. Default is None.\\n        test : str {\"F\", \"Chisq\", \"Cp\"} or None\\n        Test statistics to provide. Default is \"F\".\\n\\n    Notes\\n    -----\\n    Use of this function is discouraged. Use anova_lm instead.\\n    '\n    test = kwargs.get('test', 'F')\n    scale = kwargs.get('scale', None)\n    typ = kwargs.get('typ', 1)\n    robust = kwargs.get('robust', None)\n    if robust:\n        robust = robust.lower()\n    endog = model.model.endog\n    exog = model.model.exog\n    nobs = exog.shape[0]\n    response_name = model.model.endog_names\n    design_info = model.model.data.design_info\n    exog_names = model.model.exog_names\n    n_rows = len(design_info.terms) - _has_intercept(design_info) + 1\n    pr_test = 'PR(>%s)' % test\n    names = ['df', 'sum_sq', 'mean_sq', test, pr_test]\n    table = DataFrame(np.zeros((n_rows, 5)), columns=names)\n    if typ in [1, 'I']:\n        return anova1_lm_single(model, endog, exog, nobs, design_info, table, n_rows, test, pr_test, robust)\n    elif typ in [2, 'II']:\n        return anova2_lm_single(model, design_info, n_rows, test, pr_test, robust)\n    elif typ in [3, 'III']:\n        return anova3_lm_single(model, design_info, n_rows, test, pr_test, robust)\n    elif typ in [4, 'IV']:\n        raise NotImplementedError('Type IV not yet implemented')\n    else:\n        raise ValueError('Type %s not understood' % str(typ))"
        ]
    },
    {
        "func_name": "anova1_lm_single",
        "original": "def anova1_lm_single(model, endog, exog, nobs, design_info, table, n_rows, test, pr_test, robust):\n    \"\"\"\n    Anova table for one fitted linear model.\n\n    Parameters\n    ----------\n    model : fitted linear model results instance\n        A fitted linear model\n\n    **kwargs**\n\n    scale : float\n        Estimate of variance, If None, will be estimated from the largest\n    model. Default is None.\n        test : str {\"F\", \"Chisq\", \"Cp\"} or None\n        Test statistics to provide. Default is \"F\".\n\n    Notes\n    -----\n    Use of this function is discouraged. Use anova_lm instead.\n    \"\"\"\n    effects = getattr(model, 'effects', None)\n    if effects is None:\n        (q, r) = np.linalg.qr(exog)\n        effects = np.dot(q.T, endog)\n    arr = np.zeros((len(design_info.terms), len(design_info.column_names)))\n    slices = [design_info.slice(name) for name in design_info.term_names]\n    for (i, slice_) in enumerate(slices):\n        arr[i, slice_] = 1\n    sum_sq = np.dot(arr, effects ** 2)\n    idx = _intercept_idx(design_info)\n    sum_sq = sum_sq[~idx]\n    term_names = np.array(design_info.term_names)\n    term_names = term_names[~idx]\n    index = term_names.tolist()\n    table.index = Index(index + ['Residual'])\n    table.loc[index, ['df', 'sum_sq']] = np.c_[arr[~idx].sum(1), sum_sq]\n    table.loc['Residual', ['sum_sq', 'df']] = (model.ssr, model.df_resid)\n    if test == 'F':\n        table[test] = table['sum_sq'] / table['df'] / (model.ssr / model.df_resid)\n        table[pr_test] = stats.f.sf(table['F'], table['df'], model.df_resid)\n        table.loc['Residual', [test, pr_test]] = (np.nan, np.nan)\n    table['mean_sq'] = table['sum_sq'] / table['df']\n    return table",
        "mutated": [
            "def anova1_lm_single(model, endog, exog, nobs, design_info, table, n_rows, test, pr_test, robust):\n    if False:\n        i = 10\n    '\\n    Anova table for one fitted linear model.\\n\\n    Parameters\\n    ----------\\n    model : fitted linear model results instance\\n        A fitted linear model\\n\\n    **kwargs**\\n\\n    scale : float\\n        Estimate of variance, If None, will be estimated from the largest\\n    model. Default is None.\\n        test : str {\"F\", \"Chisq\", \"Cp\"} or None\\n        Test statistics to provide. Default is \"F\".\\n\\n    Notes\\n    -----\\n    Use of this function is discouraged. Use anova_lm instead.\\n    '\n    effects = getattr(model, 'effects', None)\n    if effects is None:\n        (q, r) = np.linalg.qr(exog)\n        effects = np.dot(q.T, endog)\n    arr = np.zeros((len(design_info.terms), len(design_info.column_names)))\n    slices = [design_info.slice(name) for name in design_info.term_names]\n    for (i, slice_) in enumerate(slices):\n        arr[i, slice_] = 1\n    sum_sq = np.dot(arr, effects ** 2)\n    idx = _intercept_idx(design_info)\n    sum_sq = sum_sq[~idx]\n    term_names = np.array(design_info.term_names)\n    term_names = term_names[~idx]\n    index = term_names.tolist()\n    table.index = Index(index + ['Residual'])\n    table.loc[index, ['df', 'sum_sq']] = np.c_[arr[~idx].sum(1), sum_sq]\n    table.loc['Residual', ['sum_sq', 'df']] = (model.ssr, model.df_resid)\n    if test == 'F':\n        table[test] = table['sum_sq'] / table['df'] / (model.ssr / model.df_resid)\n        table[pr_test] = stats.f.sf(table['F'], table['df'], model.df_resid)\n        table.loc['Residual', [test, pr_test]] = (np.nan, np.nan)\n    table['mean_sq'] = table['sum_sq'] / table['df']\n    return table",
            "def anova1_lm_single(model, endog, exog, nobs, design_info, table, n_rows, test, pr_test, robust):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Anova table for one fitted linear model.\\n\\n    Parameters\\n    ----------\\n    model : fitted linear model results instance\\n        A fitted linear model\\n\\n    **kwargs**\\n\\n    scale : float\\n        Estimate of variance, If None, will be estimated from the largest\\n    model. Default is None.\\n        test : str {\"F\", \"Chisq\", \"Cp\"} or None\\n        Test statistics to provide. Default is \"F\".\\n\\n    Notes\\n    -----\\n    Use of this function is discouraged. Use anova_lm instead.\\n    '\n    effects = getattr(model, 'effects', None)\n    if effects is None:\n        (q, r) = np.linalg.qr(exog)\n        effects = np.dot(q.T, endog)\n    arr = np.zeros((len(design_info.terms), len(design_info.column_names)))\n    slices = [design_info.slice(name) for name in design_info.term_names]\n    for (i, slice_) in enumerate(slices):\n        arr[i, slice_] = 1\n    sum_sq = np.dot(arr, effects ** 2)\n    idx = _intercept_idx(design_info)\n    sum_sq = sum_sq[~idx]\n    term_names = np.array(design_info.term_names)\n    term_names = term_names[~idx]\n    index = term_names.tolist()\n    table.index = Index(index + ['Residual'])\n    table.loc[index, ['df', 'sum_sq']] = np.c_[arr[~idx].sum(1), sum_sq]\n    table.loc['Residual', ['sum_sq', 'df']] = (model.ssr, model.df_resid)\n    if test == 'F':\n        table[test] = table['sum_sq'] / table['df'] / (model.ssr / model.df_resid)\n        table[pr_test] = stats.f.sf(table['F'], table['df'], model.df_resid)\n        table.loc['Residual', [test, pr_test]] = (np.nan, np.nan)\n    table['mean_sq'] = table['sum_sq'] / table['df']\n    return table",
            "def anova1_lm_single(model, endog, exog, nobs, design_info, table, n_rows, test, pr_test, robust):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Anova table for one fitted linear model.\\n\\n    Parameters\\n    ----------\\n    model : fitted linear model results instance\\n        A fitted linear model\\n\\n    **kwargs**\\n\\n    scale : float\\n        Estimate of variance, If None, will be estimated from the largest\\n    model. Default is None.\\n        test : str {\"F\", \"Chisq\", \"Cp\"} or None\\n        Test statistics to provide. Default is \"F\".\\n\\n    Notes\\n    -----\\n    Use of this function is discouraged. Use anova_lm instead.\\n    '\n    effects = getattr(model, 'effects', None)\n    if effects is None:\n        (q, r) = np.linalg.qr(exog)\n        effects = np.dot(q.T, endog)\n    arr = np.zeros((len(design_info.terms), len(design_info.column_names)))\n    slices = [design_info.slice(name) for name in design_info.term_names]\n    for (i, slice_) in enumerate(slices):\n        arr[i, slice_] = 1\n    sum_sq = np.dot(arr, effects ** 2)\n    idx = _intercept_idx(design_info)\n    sum_sq = sum_sq[~idx]\n    term_names = np.array(design_info.term_names)\n    term_names = term_names[~idx]\n    index = term_names.tolist()\n    table.index = Index(index + ['Residual'])\n    table.loc[index, ['df', 'sum_sq']] = np.c_[arr[~idx].sum(1), sum_sq]\n    table.loc['Residual', ['sum_sq', 'df']] = (model.ssr, model.df_resid)\n    if test == 'F':\n        table[test] = table['sum_sq'] / table['df'] / (model.ssr / model.df_resid)\n        table[pr_test] = stats.f.sf(table['F'], table['df'], model.df_resid)\n        table.loc['Residual', [test, pr_test]] = (np.nan, np.nan)\n    table['mean_sq'] = table['sum_sq'] / table['df']\n    return table",
            "def anova1_lm_single(model, endog, exog, nobs, design_info, table, n_rows, test, pr_test, robust):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Anova table for one fitted linear model.\\n\\n    Parameters\\n    ----------\\n    model : fitted linear model results instance\\n        A fitted linear model\\n\\n    **kwargs**\\n\\n    scale : float\\n        Estimate of variance, If None, will be estimated from the largest\\n    model. Default is None.\\n        test : str {\"F\", \"Chisq\", \"Cp\"} or None\\n        Test statistics to provide. Default is \"F\".\\n\\n    Notes\\n    -----\\n    Use of this function is discouraged. Use anova_lm instead.\\n    '\n    effects = getattr(model, 'effects', None)\n    if effects is None:\n        (q, r) = np.linalg.qr(exog)\n        effects = np.dot(q.T, endog)\n    arr = np.zeros((len(design_info.terms), len(design_info.column_names)))\n    slices = [design_info.slice(name) for name in design_info.term_names]\n    for (i, slice_) in enumerate(slices):\n        arr[i, slice_] = 1\n    sum_sq = np.dot(arr, effects ** 2)\n    idx = _intercept_idx(design_info)\n    sum_sq = sum_sq[~idx]\n    term_names = np.array(design_info.term_names)\n    term_names = term_names[~idx]\n    index = term_names.tolist()\n    table.index = Index(index + ['Residual'])\n    table.loc[index, ['df', 'sum_sq']] = np.c_[arr[~idx].sum(1), sum_sq]\n    table.loc['Residual', ['sum_sq', 'df']] = (model.ssr, model.df_resid)\n    if test == 'F':\n        table[test] = table['sum_sq'] / table['df'] / (model.ssr / model.df_resid)\n        table[pr_test] = stats.f.sf(table['F'], table['df'], model.df_resid)\n        table.loc['Residual', [test, pr_test]] = (np.nan, np.nan)\n    table['mean_sq'] = table['sum_sq'] / table['df']\n    return table",
            "def anova1_lm_single(model, endog, exog, nobs, design_info, table, n_rows, test, pr_test, robust):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Anova table for one fitted linear model.\\n\\n    Parameters\\n    ----------\\n    model : fitted linear model results instance\\n        A fitted linear model\\n\\n    **kwargs**\\n\\n    scale : float\\n        Estimate of variance, If None, will be estimated from the largest\\n    model. Default is None.\\n        test : str {\"F\", \"Chisq\", \"Cp\"} or None\\n        Test statistics to provide. Default is \"F\".\\n\\n    Notes\\n    -----\\n    Use of this function is discouraged. Use anova_lm instead.\\n    '\n    effects = getattr(model, 'effects', None)\n    if effects is None:\n        (q, r) = np.linalg.qr(exog)\n        effects = np.dot(q.T, endog)\n    arr = np.zeros((len(design_info.terms), len(design_info.column_names)))\n    slices = [design_info.slice(name) for name in design_info.term_names]\n    for (i, slice_) in enumerate(slices):\n        arr[i, slice_] = 1\n    sum_sq = np.dot(arr, effects ** 2)\n    idx = _intercept_idx(design_info)\n    sum_sq = sum_sq[~idx]\n    term_names = np.array(design_info.term_names)\n    term_names = term_names[~idx]\n    index = term_names.tolist()\n    table.index = Index(index + ['Residual'])\n    table.loc[index, ['df', 'sum_sq']] = np.c_[arr[~idx].sum(1), sum_sq]\n    table.loc['Residual', ['sum_sq', 'df']] = (model.ssr, model.df_resid)\n    if test == 'F':\n        table[test] = table['sum_sq'] / table['df'] / (model.ssr / model.df_resid)\n        table[pr_test] = stats.f.sf(table['F'], table['df'], model.df_resid)\n        table.loc['Residual', [test, pr_test]] = (np.nan, np.nan)\n    table['mean_sq'] = table['sum_sq'] / table['df']\n    return table"
        ]
    },
    {
        "func_name": "anova2_lm_single",
        "original": "def anova2_lm_single(model, design_info, n_rows, test, pr_test, robust):\n    \"\"\"\n    Anova type II table for one fitted linear model.\n\n    Parameters\n    ----------\n    model : fitted linear model results instance\n        A fitted linear model\n\n    **kwargs**\n\n    scale : float\n        Estimate of variance, If None, will be estimated from the largest\n    model. Default is None.\n        test : str {\"F\", \"Chisq\", \"Cp\"} or None\n        Test statistics to provide. Default is \"F\".\n\n    Notes\n    -----\n    Use of this function is discouraged. Use anova_lm instead.\n\n    Type II\n    Sum of Squares compares marginal contribution of terms. Thus, it is\n    not particularly useful for models with significant interaction terms.\n    \"\"\"\n    terms_info = design_info.terms[:]\n    terms_info = _remove_intercept_patsy(terms_info)\n    names = ['sum_sq', 'df', test, pr_test]\n    table = DataFrame(np.zeros((n_rows, 4)), columns=names)\n    cov = _get_covariance(model, None)\n    robust_cov = _get_covariance(model, robust)\n    col_order = []\n    index = []\n    for (i, term) in enumerate(terms_info):\n        cols = design_info.slice(term)\n        L1 = lrange(cols.start, cols.stop)\n        L2 = []\n        term_set = set(term.factors)\n        for t in terms_info:\n            other_set = set(t.factors)\n            if term_set.issubset(other_set) and (not term_set == other_set):\n                col = design_info.slice(t)\n                L1.extend(lrange(col.start, col.stop))\n                L2.extend(lrange(col.start, col.stop))\n        L1 = np.eye(model.model.exog.shape[1])[L1]\n        L2 = np.eye(model.model.exog.shape[1])[L2]\n        if L2.size:\n            LVL = np.dot(np.dot(L1, robust_cov), L2.T)\n            from scipy import linalg\n            (orth_compl, _) = linalg.qr(LVL)\n            r = L1.shape[0] - L2.shape[0]\n            L12 = np.dot(orth_compl[:, -r:].T, L1)\n        else:\n            L12 = L1\n            r = L1.shape[0]\n        if test == 'F':\n            f = model.f_test(L12, cov_p=robust_cov)\n            table.loc[table.index[i], test] = test_value = f.fvalue\n            table.loc[table.index[i], pr_test] = f.pvalue\n        table.loc[table.index[i], 'df'] = r\n        col_order.append(cols.start)\n        index.append(term.name())\n    table.index = Index(index + ['Residual'])\n    table = table.iloc[np.argsort(col_order + [model.model.exog.shape[1] + 1])]\n    ssr = table[test] * table['df'] * model.ssr / model.df_resid\n    table['sum_sq'] = ssr\n    table.loc['Residual', ['sum_sq', 'df', test, pr_test]] = (model.ssr, model.df_resid, np.nan, np.nan)\n    return table",
        "mutated": [
            "def anova2_lm_single(model, design_info, n_rows, test, pr_test, robust):\n    if False:\n        i = 10\n    '\\n    Anova type II table for one fitted linear model.\\n\\n    Parameters\\n    ----------\\n    model : fitted linear model results instance\\n        A fitted linear model\\n\\n    **kwargs**\\n\\n    scale : float\\n        Estimate of variance, If None, will be estimated from the largest\\n    model. Default is None.\\n        test : str {\"F\", \"Chisq\", \"Cp\"} or None\\n        Test statistics to provide. Default is \"F\".\\n\\n    Notes\\n    -----\\n    Use of this function is discouraged. Use anova_lm instead.\\n\\n    Type II\\n    Sum of Squares compares marginal contribution of terms. Thus, it is\\n    not particularly useful for models with significant interaction terms.\\n    '\n    terms_info = design_info.terms[:]\n    terms_info = _remove_intercept_patsy(terms_info)\n    names = ['sum_sq', 'df', test, pr_test]\n    table = DataFrame(np.zeros((n_rows, 4)), columns=names)\n    cov = _get_covariance(model, None)\n    robust_cov = _get_covariance(model, robust)\n    col_order = []\n    index = []\n    for (i, term) in enumerate(terms_info):\n        cols = design_info.slice(term)\n        L1 = lrange(cols.start, cols.stop)\n        L2 = []\n        term_set = set(term.factors)\n        for t in terms_info:\n            other_set = set(t.factors)\n            if term_set.issubset(other_set) and (not term_set == other_set):\n                col = design_info.slice(t)\n                L1.extend(lrange(col.start, col.stop))\n                L2.extend(lrange(col.start, col.stop))\n        L1 = np.eye(model.model.exog.shape[1])[L1]\n        L2 = np.eye(model.model.exog.shape[1])[L2]\n        if L2.size:\n            LVL = np.dot(np.dot(L1, robust_cov), L2.T)\n            from scipy import linalg\n            (orth_compl, _) = linalg.qr(LVL)\n            r = L1.shape[0] - L2.shape[0]\n            L12 = np.dot(orth_compl[:, -r:].T, L1)\n        else:\n            L12 = L1\n            r = L1.shape[0]\n        if test == 'F':\n            f = model.f_test(L12, cov_p=robust_cov)\n            table.loc[table.index[i], test] = test_value = f.fvalue\n            table.loc[table.index[i], pr_test] = f.pvalue\n        table.loc[table.index[i], 'df'] = r\n        col_order.append(cols.start)\n        index.append(term.name())\n    table.index = Index(index + ['Residual'])\n    table = table.iloc[np.argsort(col_order + [model.model.exog.shape[1] + 1])]\n    ssr = table[test] * table['df'] * model.ssr / model.df_resid\n    table['sum_sq'] = ssr\n    table.loc['Residual', ['sum_sq', 'df', test, pr_test]] = (model.ssr, model.df_resid, np.nan, np.nan)\n    return table",
            "def anova2_lm_single(model, design_info, n_rows, test, pr_test, robust):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Anova type II table for one fitted linear model.\\n\\n    Parameters\\n    ----------\\n    model : fitted linear model results instance\\n        A fitted linear model\\n\\n    **kwargs**\\n\\n    scale : float\\n        Estimate of variance, If None, will be estimated from the largest\\n    model. Default is None.\\n        test : str {\"F\", \"Chisq\", \"Cp\"} or None\\n        Test statistics to provide. Default is \"F\".\\n\\n    Notes\\n    -----\\n    Use of this function is discouraged. Use anova_lm instead.\\n\\n    Type II\\n    Sum of Squares compares marginal contribution of terms. Thus, it is\\n    not particularly useful for models with significant interaction terms.\\n    '\n    terms_info = design_info.terms[:]\n    terms_info = _remove_intercept_patsy(terms_info)\n    names = ['sum_sq', 'df', test, pr_test]\n    table = DataFrame(np.zeros((n_rows, 4)), columns=names)\n    cov = _get_covariance(model, None)\n    robust_cov = _get_covariance(model, robust)\n    col_order = []\n    index = []\n    for (i, term) in enumerate(terms_info):\n        cols = design_info.slice(term)\n        L1 = lrange(cols.start, cols.stop)\n        L2 = []\n        term_set = set(term.factors)\n        for t in terms_info:\n            other_set = set(t.factors)\n            if term_set.issubset(other_set) and (not term_set == other_set):\n                col = design_info.slice(t)\n                L1.extend(lrange(col.start, col.stop))\n                L2.extend(lrange(col.start, col.stop))\n        L1 = np.eye(model.model.exog.shape[1])[L1]\n        L2 = np.eye(model.model.exog.shape[1])[L2]\n        if L2.size:\n            LVL = np.dot(np.dot(L1, robust_cov), L2.T)\n            from scipy import linalg\n            (orth_compl, _) = linalg.qr(LVL)\n            r = L1.shape[0] - L2.shape[0]\n            L12 = np.dot(orth_compl[:, -r:].T, L1)\n        else:\n            L12 = L1\n            r = L1.shape[0]\n        if test == 'F':\n            f = model.f_test(L12, cov_p=robust_cov)\n            table.loc[table.index[i], test] = test_value = f.fvalue\n            table.loc[table.index[i], pr_test] = f.pvalue\n        table.loc[table.index[i], 'df'] = r\n        col_order.append(cols.start)\n        index.append(term.name())\n    table.index = Index(index + ['Residual'])\n    table = table.iloc[np.argsort(col_order + [model.model.exog.shape[1] + 1])]\n    ssr = table[test] * table['df'] * model.ssr / model.df_resid\n    table['sum_sq'] = ssr\n    table.loc['Residual', ['sum_sq', 'df', test, pr_test]] = (model.ssr, model.df_resid, np.nan, np.nan)\n    return table",
            "def anova2_lm_single(model, design_info, n_rows, test, pr_test, robust):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Anova type II table for one fitted linear model.\\n\\n    Parameters\\n    ----------\\n    model : fitted linear model results instance\\n        A fitted linear model\\n\\n    **kwargs**\\n\\n    scale : float\\n        Estimate of variance, If None, will be estimated from the largest\\n    model. Default is None.\\n        test : str {\"F\", \"Chisq\", \"Cp\"} or None\\n        Test statistics to provide. Default is \"F\".\\n\\n    Notes\\n    -----\\n    Use of this function is discouraged. Use anova_lm instead.\\n\\n    Type II\\n    Sum of Squares compares marginal contribution of terms. Thus, it is\\n    not particularly useful for models with significant interaction terms.\\n    '\n    terms_info = design_info.terms[:]\n    terms_info = _remove_intercept_patsy(terms_info)\n    names = ['sum_sq', 'df', test, pr_test]\n    table = DataFrame(np.zeros((n_rows, 4)), columns=names)\n    cov = _get_covariance(model, None)\n    robust_cov = _get_covariance(model, robust)\n    col_order = []\n    index = []\n    for (i, term) in enumerate(terms_info):\n        cols = design_info.slice(term)\n        L1 = lrange(cols.start, cols.stop)\n        L2 = []\n        term_set = set(term.factors)\n        for t in terms_info:\n            other_set = set(t.factors)\n            if term_set.issubset(other_set) and (not term_set == other_set):\n                col = design_info.slice(t)\n                L1.extend(lrange(col.start, col.stop))\n                L2.extend(lrange(col.start, col.stop))\n        L1 = np.eye(model.model.exog.shape[1])[L1]\n        L2 = np.eye(model.model.exog.shape[1])[L2]\n        if L2.size:\n            LVL = np.dot(np.dot(L1, robust_cov), L2.T)\n            from scipy import linalg\n            (orth_compl, _) = linalg.qr(LVL)\n            r = L1.shape[0] - L2.shape[0]\n            L12 = np.dot(orth_compl[:, -r:].T, L1)\n        else:\n            L12 = L1\n            r = L1.shape[0]\n        if test == 'F':\n            f = model.f_test(L12, cov_p=robust_cov)\n            table.loc[table.index[i], test] = test_value = f.fvalue\n            table.loc[table.index[i], pr_test] = f.pvalue\n        table.loc[table.index[i], 'df'] = r\n        col_order.append(cols.start)\n        index.append(term.name())\n    table.index = Index(index + ['Residual'])\n    table = table.iloc[np.argsort(col_order + [model.model.exog.shape[1] + 1])]\n    ssr = table[test] * table['df'] * model.ssr / model.df_resid\n    table['sum_sq'] = ssr\n    table.loc['Residual', ['sum_sq', 'df', test, pr_test]] = (model.ssr, model.df_resid, np.nan, np.nan)\n    return table",
            "def anova2_lm_single(model, design_info, n_rows, test, pr_test, robust):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Anova type II table for one fitted linear model.\\n\\n    Parameters\\n    ----------\\n    model : fitted linear model results instance\\n        A fitted linear model\\n\\n    **kwargs**\\n\\n    scale : float\\n        Estimate of variance, If None, will be estimated from the largest\\n    model. Default is None.\\n        test : str {\"F\", \"Chisq\", \"Cp\"} or None\\n        Test statistics to provide. Default is \"F\".\\n\\n    Notes\\n    -----\\n    Use of this function is discouraged. Use anova_lm instead.\\n\\n    Type II\\n    Sum of Squares compares marginal contribution of terms. Thus, it is\\n    not particularly useful for models with significant interaction terms.\\n    '\n    terms_info = design_info.terms[:]\n    terms_info = _remove_intercept_patsy(terms_info)\n    names = ['sum_sq', 'df', test, pr_test]\n    table = DataFrame(np.zeros((n_rows, 4)), columns=names)\n    cov = _get_covariance(model, None)\n    robust_cov = _get_covariance(model, robust)\n    col_order = []\n    index = []\n    for (i, term) in enumerate(terms_info):\n        cols = design_info.slice(term)\n        L1 = lrange(cols.start, cols.stop)\n        L2 = []\n        term_set = set(term.factors)\n        for t in terms_info:\n            other_set = set(t.factors)\n            if term_set.issubset(other_set) and (not term_set == other_set):\n                col = design_info.slice(t)\n                L1.extend(lrange(col.start, col.stop))\n                L2.extend(lrange(col.start, col.stop))\n        L1 = np.eye(model.model.exog.shape[1])[L1]\n        L2 = np.eye(model.model.exog.shape[1])[L2]\n        if L2.size:\n            LVL = np.dot(np.dot(L1, robust_cov), L2.T)\n            from scipy import linalg\n            (orth_compl, _) = linalg.qr(LVL)\n            r = L1.shape[0] - L2.shape[0]\n            L12 = np.dot(orth_compl[:, -r:].T, L1)\n        else:\n            L12 = L1\n            r = L1.shape[0]\n        if test == 'F':\n            f = model.f_test(L12, cov_p=robust_cov)\n            table.loc[table.index[i], test] = test_value = f.fvalue\n            table.loc[table.index[i], pr_test] = f.pvalue\n        table.loc[table.index[i], 'df'] = r\n        col_order.append(cols.start)\n        index.append(term.name())\n    table.index = Index(index + ['Residual'])\n    table = table.iloc[np.argsort(col_order + [model.model.exog.shape[1] + 1])]\n    ssr = table[test] * table['df'] * model.ssr / model.df_resid\n    table['sum_sq'] = ssr\n    table.loc['Residual', ['sum_sq', 'df', test, pr_test]] = (model.ssr, model.df_resid, np.nan, np.nan)\n    return table",
            "def anova2_lm_single(model, design_info, n_rows, test, pr_test, robust):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Anova type II table for one fitted linear model.\\n\\n    Parameters\\n    ----------\\n    model : fitted linear model results instance\\n        A fitted linear model\\n\\n    **kwargs**\\n\\n    scale : float\\n        Estimate of variance, If None, will be estimated from the largest\\n    model. Default is None.\\n        test : str {\"F\", \"Chisq\", \"Cp\"} or None\\n        Test statistics to provide. Default is \"F\".\\n\\n    Notes\\n    -----\\n    Use of this function is discouraged. Use anova_lm instead.\\n\\n    Type II\\n    Sum of Squares compares marginal contribution of terms. Thus, it is\\n    not particularly useful for models with significant interaction terms.\\n    '\n    terms_info = design_info.terms[:]\n    terms_info = _remove_intercept_patsy(terms_info)\n    names = ['sum_sq', 'df', test, pr_test]\n    table = DataFrame(np.zeros((n_rows, 4)), columns=names)\n    cov = _get_covariance(model, None)\n    robust_cov = _get_covariance(model, robust)\n    col_order = []\n    index = []\n    for (i, term) in enumerate(terms_info):\n        cols = design_info.slice(term)\n        L1 = lrange(cols.start, cols.stop)\n        L2 = []\n        term_set = set(term.factors)\n        for t in terms_info:\n            other_set = set(t.factors)\n            if term_set.issubset(other_set) and (not term_set == other_set):\n                col = design_info.slice(t)\n                L1.extend(lrange(col.start, col.stop))\n                L2.extend(lrange(col.start, col.stop))\n        L1 = np.eye(model.model.exog.shape[1])[L1]\n        L2 = np.eye(model.model.exog.shape[1])[L2]\n        if L2.size:\n            LVL = np.dot(np.dot(L1, robust_cov), L2.T)\n            from scipy import linalg\n            (orth_compl, _) = linalg.qr(LVL)\n            r = L1.shape[0] - L2.shape[0]\n            L12 = np.dot(orth_compl[:, -r:].T, L1)\n        else:\n            L12 = L1\n            r = L1.shape[0]\n        if test == 'F':\n            f = model.f_test(L12, cov_p=robust_cov)\n            table.loc[table.index[i], test] = test_value = f.fvalue\n            table.loc[table.index[i], pr_test] = f.pvalue\n        table.loc[table.index[i], 'df'] = r\n        col_order.append(cols.start)\n        index.append(term.name())\n    table.index = Index(index + ['Residual'])\n    table = table.iloc[np.argsort(col_order + [model.model.exog.shape[1] + 1])]\n    ssr = table[test] * table['df'] * model.ssr / model.df_resid\n    table['sum_sq'] = ssr\n    table.loc['Residual', ['sum_sq', 'df', test, pr_test]] = (model.ssr, model.df_resid, np.nan, np.nan)\n    return table"
        ]
    },
    {
        "func_name": "anova3_lm_single",
        "original": "def anova3_lm_single(model, design_info, n_rows, test, pr_test, robust):\n    n_rows += _has_intercept(design_info)\n    terms_info = design_info.terms\n    names = ['sum_sq', 'df', test, pr_test]\n    table = DataFrame(np.zeros((n_rows, 4)), columns=names)\n    cov = _get_covariance(model, robust)\n    col_order = []\n    index = []\n    for (i, term) in enumerate(terms_info):\n        cols = design_info.slice(term)\n        L1 = np.eye(model.model.exog.shape[1])[cols]\n        L12 = L1\n        r = L1.shape[0]\n        if test == 'F':\n            f = model.f_test(L12, cov_p=cov)\n            table.loc[table.index[i], test] = test_value = f.fvalue\n            table.loc[table.index[i], pr_test] = f.pvalue\n        table.loc[table.index[i], 'df'] = r\n        index.append(term.name())\n    table.index = Index(index + ['Residual'])\n    ssr = table[test] * table['df'] * model.ssr / model.df_resid\n    table['sum_sq'] = ssr\n    table.loc['Residual', ['sum_sq', 'df', test, pr_test]] = (model.ssr, model.df_resid, np.nan, np.nan)\n    return table",
        "mutated": [
            "def anova3_lm_single(model, design_info, n_rows, test, pr_test, robust):\n    if False:\n        i = 10\n    n_rows += _has_intercept(design_info)\n    terms_info = design_info.terms\n    names = ['sum_sq', 'df', test, pr_test]\n    table = DataFrame(np.zeros((n_rows, 4)), columns=names)\n    cov = _get_covariance(model, robust)\n    col_order = []\n    index = []\n    for (i, term) in enumerate(terms_info):\n        cols = design_info.slice(term)\n        L1 = np.eye(model.model.exog.shape[1])[cols]\n        L12 = L1\n        r = L1.shape[0]\n        if test == 'F':\n            f = model.f_test(L12, cov_p=cov)\n            table.loc[table.index[i], test] = test_value = f.fvalue\n            table.loc[table.index[i], pr_test] = f.pvalue\n        table.loc[table.index[i], 'df'] = r\n        index.append(term.name())\n    table.index = Index(index + ['Residual'])\n    ssr = table[test] * table['df'] * model.ssr / model.df_resid\n    table['sum_sq'] = ssr\n    table.loc['Residual', ['sum_sq', 'df', test, pr_test]] = (model.ssr, model.df_resid, np.nan, np.nan)\n    return table",
            "def anova3_lm_single(model, design_info, n_rows, test, pr_test, robust):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    n_rows += _has_intercept(design_info)\n    terms_info = design_info.terms\n    names = ['sum_sq', 'df', test, pr_test]\n    table = DataFrame(np.zeros((n_rows, 4)), columns=names)\n    cov = _get_covariance(model, robust)\n    col_order = []\n    index = []\n    for (i, term) in enumerate(terms_info):\n        cols = design_info.slice(term)\n        L1 = np.eye(model.model.exog.shape[1])[cols]\n        L12 = L1\n        r = L1.shape[0]\n        if test == 'F':\n            f = model.f_test(L12, cov_p=cov)\n            table.loc[table.index[i], test] = test_value = f.fvalue\n            table.loc[table.index[i], pr_test] = f.pvalue\n        table.loc[table.index[i], 'df'] = r\n        index.append(term.name())\n    table.index = Index(index + ['Residual'])\n    ssr = table[test] * table['df'] * model.ssr / model.df_resid\n    table['sum_sq'] = ssr\n    table.loc['Residual', ['sum_sq', 'df', test, pr_test]] = (model.ssr, model.df_resid, np.nan, np.nan)\n    return table",
            "def anova3_lm_single(model, design_info, n_rows, test, pr_test, robust):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    n_rows += _has_intercept(design_info)\n    terms_info = design_info.terms\n    names = ['sum_sq', 'df', test, pr_test]\n    table = DataFrame(np.zeros((n_rows, 4)), columns=names)\n    cov = _get_covariance(model, robust)\n    col_order = []\n    index = []\n    for (i, term) in enumerate(terms_info):\n        cols = design_info.slice(term)\n        L1 = np.eye(model.model.exog.shape[1])[cols]\n        L12 = L1\n        r = L1.shape[0]\n        if test == 'F':\n            f = model.f_test(L12, cov_p=cov)\n            table.loc[table.index[i], test] = test_value = f.fvalue\n            table.loc[table.index[i], pr_test] = f.pvalue\n        table.loc[table.index[i], 'df'] = r\n        index.append(term.name())\n    table.index = Index(index + ['Residual'])\n    ssr = table[test] * table['df'] * model.ssr / model.df_resid\n    table['sum_sq'] = ssr\n    table.loc['Residual', ['sum_sq', 'df', test, pr_test]] = (model.ssr, model.df_resid, np.nan, np.nan)\n    return table",
            "def anova3_lm_single(model, design_info, n_rows, test, pr_test, robust):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    n_rows += _has_intercept(design_info)\n    terms_info = design_info.terms\n    names = ['sum_sq', 'df', test, pr_test]\n    table = DataFrame(np.zeros((n_rows, 4)), columns=names)\n    cov = _get_covariance(model, robust)\n    col_order = []\n    index = []\n    for (i, term) in enumerate(terms_info):\n        cols = design_info.slice(term)\n        L1 = np.eye(model.model.exog.shape[1])[cols]\n        L12 = L1\n        r = L1.shape[0]\n        if test == 'F':\n            f = model.f_test(L12, cov_p=cov)\n            table.loc[table.index[i], test] = test_value = f.fvalue\n            table.loc[table.index[i], pr_test] = f.pvalue\n        table.loc[table.index[i], 'df'] = r\n        index.append(term.name())\n    table.index = Index(index + ['Residual'])\n    ssr = table[test] * table['df'] * model.ssr / model.df_resid\n    table['sum_sq'] = ssr\n    table.loc['Residual', ['sum_sq', 'df', test, pr_test]] = (model.ssr, model.df_resid, np.nan, np.nan)\n    return table",
            "def anova3_lm_single(model, design_info, n_rows, test, pr_test, robust):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    n_rows += _has_intercept(design_info)\n    terms_info = design_info.terms\n    names = ['sum_sq', 'df', test, pr_test]\n    table = DataFrame(np.zeros((n_rows, 4)), columns=names)\n    cov = _get_covariance(model, robust)\n    col_order = []\n    index = []\n    for (i, term) in enumerate(terms_info):\n        cols = design_info.slice(term)\n        L1 = np.eye(model.model.exog.shape[1])[cols]\n        L12 = L1\n        r = L1.shape[0]\n        if test == 'F':\n            f = model.f_test(L12, cov_p=cov)\n            table.loc[table.index[i], test] = test_value = f.fvalue\n            table.loc[table.index[i], pr_test] = f.pvalue\n        table.loc[table.index[i], 'df'] = r\n        index.append(term.name())\n    table.index = Index(index + ['Residual'])\n    ssr = table[test] * table['df'] * model.ssr / model.df_resid\n    table['sum_sq'] = ssr\n    table.loc['Residual', ['sum_sq', 'df', test, pr_test]] = (model.ssr, model.df_resid, np.nan, np.nan)\n    return table"
        ]
    },
    {
        "func_name": "anova_lm",
        "original": "def anova_lm(*args, **kwargs):\n    \"\"\"\n    Anova table for one or more fitted linear models.\n\n    Parameters\n    ----------\n    args : fitted linear model results instance\n        One or more fitted linear models\n    scale : float\n        Estimate of variance, If None, will be estimated from the largest\n        model. Default is None.\n    test : str {\"F\", \"Chisq\", \"Cp\"} or None\n        Test statistics to provide. Default is \"F\".\n    typ : str or int {\"I\",\"II\",\"III\"} or {1,2,3}\n        The type of Anova test to perform. See notes.\n    robust : {None, \"hc0\", \"hc1\", \"hc2\", \"hc3\"}\n        Use heteroscedasticity-corrected coefficient covariance matrix.\n        If robust covariance is desired, it is recommended to use `hc3`.\n\n    Returns\n    -------\n    anova : DataFrame\n        When args is a single model, return is DataFrame with columns:\n\n        sum_sq : float64\n            Sum of squares for model terms.\n        df : float64\n            Degrees of freedom for model terms.\n        F : float64\n            F statistic value for significance of adding model terms.\n        PR(>F) : float64\n            P-value for significance of adding model terms.\n\n        When args is multiple models, return is DataFrame with columns:\n\n        df_resid : float64\n            Degrees of freedom of residuals in models.\n        ssr : float64\n            Sum of squares of residuals in models.\n        df_diff : float64\n            Degrees of freedom difference from previous model in args\n        ss_dff : float64\n            Difference in ssr from previous model in args\n        F : float64\n            F statistic comparing to previous model in args\n        PR(>F): float64\n            P-value for significance comparing to previous model in args\n\n    Notes\n    -----\n    Model statistics are given in the order of args. Models must have been fit\n    using the formula api.\n\n    See Also\n    --------\n    model_results.compare_f_test, model_results.compare_lm_test\n\n    Examples\n    --------\n    >>> import statsmodels.api as sm\n    >>> from statsmodels.formula.api import ols\n    >>> moore = sm.datasets.get_rdataset(\"Moore\", \"carData\", cache=True) # load\n    >>> data = moore.data\n    >>> data = data.rename(columns={\"partner.status\" :\n    ...                             \"partner_status\"}) # make name pythonic\n    >>> moore_lm = ols('conformity ~ C(fcategory, Sum)*C(partner_status, Sum)',\n    ...                 data=data).fit()\n    >>> table = sm.stats.anova_lm(moore_lm, typ=2) # Type 2 Anova DataFrame\n    >>> print(table)\n    \"\"\"\n    typ = kwargs.get('typ', 1)\n    if len(args) == 1:\n        model = args[0]\n        return anova_single(model, **kwargs)\n    if typ not in [1, 'I']:\n        raise ValueError('Multiple models only supported for type I. Got type %s' % str(typ))\n    test = kwargs.get('test', 'F')\n    scale = kwargs.get('scale', None)\n    n_models = len(args)\n    pr_test = 'Pr(>%s)' % test\n    names = ['df_resid', 'ssr', 'df_diff', 'ss_diff', test, pr_test]\n    table = DataFrame(np.zeros((n_models, 6)), columns=names)\n    if not scale:\n        scale = args[-1].scale\n    table['ssr'] = [mdl.ssr for mdl in args]\n    table['df_resid'] = [mdl.df_resid for mdl in args]\n    table.loc[table.index[1:], 'df_diff'] = -np.diff(table['df_resid'].values)\n    table['ss_diff'] = -table['ssr'].diff()\n    if test == 'F':\n        table['F'] = table['ss_diff'] / table['df_diff'] / scale\n        table[pr_test] = stats.f.sf(table['F'], table['df_diff'], table['df_resid'])\n        table.loc[table['F'].isnull(), pr_test] = np.nan\n    return table",
        "mutated": [
            "def anova_lm(*args, **kwargs):\n    if False:\n        i = 10\n    '\\n    Anova table for one or more fitted linear models.\\n\\n    Parameters\\n    ----------\\n    args : fitted linear model results instance\\n        One or more fitted linear models\\n    scale : float\\n        Estimate of variance, If None, will be estimated from the largest\\n        model. Default is None.\\n    test : str {\"F\", \"Chisq\", \"Cp\"} or None\\n        Test statistics to provide. Default is \"F\".\\n    typ : str or int {\"I\",\"II\",\"III\"} or {1,2,3}\\n        The type of Anova test to perform. See notes.\\n    robust : {None, \"hc0\", \"hc1\", \"hc2\", \"hc3\"}\\n        Use heteroscedasticity-corrected coefficient covariance matrix.\\n        If robust covariance is desired, it is recommended to use `hc3`.\\n\\n    Returns\\n    -------\\n    anova : DataFrame\\n        When args is a single model, return is DataFrame with columns:\\n\\n        sum_sq : float64\\n            Sum of squares for model terms.\\n        df : float64\\n            Degrees of freedom for model terms.\\n        F : float64\\n            F statistic value for significance of adding model terms.\\n        PR(>F) : float64\\n            P-value for significance of adding model terms.\\n\\n        When args is multiple models, return is DataFrame with columns:\\n\\n        df_resid : float64\\n            Degrees of freedom of residuals in models.\\n        ssr : float64\\n            Sum of squares of residuals in models.\\n        df_diff : float64\\n            Degrees of freedom difference from previous model in args\\n        ss_dff : float64\\n            Difference in ssr from previous model in args\\n        F : float64\\n            F statistic comparing to previous model in args\\n        PR(>F): float64\\n            P-value for significance comparing to previous model in args\\n\\n    Notes\\n    -----\\n    Model statistics are given in the order of args. Models must have been fit\\n    using the formula api.\\n\\n    See Also\\n    --------\\n    model_results.compare_f_test, model_results.compare_lm_test\\n\\n    Examples\\n    --------\\n    >>> import statsmodels.api as sm\\n    >>> from statsmodels.formula.api import ols\\n    >>> moore = sm.datasets.get_rdataset(\"Moore\", \"carData\", cache=True) # load\\n    >>> data = moore.data\\n    >>> data = data.rename(columns={\"partner.status\" :\\n    ...                             \"partner_status\"}) # make name pythonic\\n    >>> moore_lm = ols(\\'conformity ~ C(fcategory, Sum)*C(partner_status, Sum)\\',\\n    ...                 data=data).fit()\\n    >>> table = sm.stats.anova_lm(moore_lm, typ=2) # Type 2 Anova DataFrame\\n    >>> print(table)\\n    '\n    typ = kwargs.get('typ', 1)\n    if len(args) == 1:\n        model = args[0]\n        return anova_single(model, **kwargs)\n    if typ not in [1, 'I']:\n        raise ValueError('Multiple models only supported for type I. Got type %s' % str(typ))\n    test = kwargs.get('test', 'F')\n    scale = kwargs.get('scale', None)\n    n_models = len(args)\n    pr_test = 'Pr(>%s)' % test\n    names = ['df_resid', 'ssr', 'df_diff', 'ss_diff', test, pr_test]\n    table = DataFrame(np.zeros((n_models, 6)), columns=names)\n    if not scale:\n        scale = args[-1].scale\n    table['ssr'] = [mdl.ssr for mdl in args]\n    table['df_resid'] = [mdl.df_resid for mdl in args]\n    table.loc[table.index[1:], 'df_diff'] = -np.diff(table['df_resid'].values)\n    table['ss_diff'] = -table['ssr'].diff()\n    if test == 'F':\n        table['F'] = table['ss_diff'] / table['df_diff'] / scale\n        table[pr_test] = stats.f.sf(table['F'], table['df_diff'], table['df_resid'])\n        table.loc[table['F'].isnull(), pr_test] = np.nan\n    return table",
            "def anova_lm(*args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Anova table for one or more fitted linear models.\\n\\n    Parameters\\n    ----------\\n    args : fitted linear model results instance\\n        One or more fitted linear models\\n    scale : float\\n        Estimate of variance, If None, will be estimated from the largest\\n        model. Default is None.\\n    test : str {\"F\", \"Chisq\", \"Cp\"} or None\\n        Test statistics to provide. Default is \"F\".\\n    typ : str or int {\"I\",\"II\",\"III\"} or {1,2,3}\\n        The type of Anova test to perform. See notes.\\n    robust : {None, \"hc0\", \"hc1\", \"hc2\", \"hc3\"}\\n        Use heteroscedasticity-corrected coefficient covariance matrix.\\n        If robust covariance is desired, it is recommended to use `hc3`.\\n\\n    Returns\\n    -------\\n    anova : DataFrame\\n        When args is a single model, return is DataFrame with columns:\\n\\n        sum_sq : float64\\n            Sum of squares for model terms.\\n        df : float64\\n            Degrees of freedom for model terms.\\n        F : float64\\n            F statistic value for significance of adding model terms.\\n        PR(>F) : float64\\n            P-value for significance of adding model terms.\\n\\n        When args is multiple models, return is DataFrame with columns:\\n\\n        df_resid : float64\\n            Degrees of freedom of residuals in models.\\n        ssr : float64\\n            Sum of squares of residuals in models.\\n        df_diff : float64\\n            Degrees of freedom difference from previous model in args\\n        ss_dff : float64\\n            Difference in ssr from previous model in args\\n        F : float64\\n            F statistic comparing to previous model in args\\n        PR(>F): float64\\n            P-value for significance comparing to previous model in args\\n\\n    Notes\\n    -----\\n    Model statistics are given in the order of args. Models must have been fit\\n    using the formula api.\\n\\n    See Also\\n    --------\\n    model_results.compare_f_test, model_results.compare_lm_test\\n\\n    Examples\\n    --------\\n    >>> import statsmodels.api as sm\\n    >>> from statsmodels.formula.api import ols\\n    >>> moore = sm.datasets.get_rdataset(\"Moore\", \"carData\", cache=True) # load\\n    >>> data = moore.data\\n    >>> data = data.rename(columns={\"partner.status\" :\\n    ...                             \"partner_status\"}) # make name pythonic\\n    >>> moore_lm = ols(\\'conformity ~ C(fcategory, Sum)*C(partner_status, Sum)\\',\\n    ...                 data=data).fit()\\n    >>> table = sm.stats.anova_lm(moore_lm, typ=2) # Type 2 Anova DataFrame\\n    >>> print(table)\\n    '\n    typ = kwargs.get('typ', 1)\n    if len(args) == 1:\n        model = args[0]\n        return anova_single(model, **kwargs)\n    if typ not in [1, 'I']:\n        raise ValueError('Multiple models only supported for type I. Got type %s' % str(typ))\n    test = kwargs.get('test', 'F')\n    scale = kwargs.get('scale', None)\n    n_models = len(args)\n    pr_test = 'Pr(>%s)' % test\n    names = ['df_resid', 'ssr', 'df_diff', 'ss_diff', test, pr_test]\n    table = DataFrame(np.zeros((n_models, 6)), columns=names)\n    if not scale:\n        scale = args[-1].scale\n    table['ssr'] = [mdl.ssr for mdl in args]\n    table['df_resid'] = [mdl.df_resid for mdl in args]\n    table.loc[table.index[1:], 'df_diff'] = -np.diff(table['df_resid'].values)\n    table['ss_diff'] = -table['ssr'].diff()\n    if test == 'F':\n        table['F'] = table['ss_diff'] / table['df_diff'] / scale\n        table[pr_test] = stats.f.sf(table['F'], table['df_diff'], table['df_resid'])\n        table.loc[table['F'].isnull(), pr_test] = np.nan\n    return table",
            "def anova_lm(*args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Anova table for one or more fitted linear models.\\n\\n    Parameters\\n    ----------\\n    args : fitted linear model results instance\\n        One or more fitted linear models\\n    scale : float\\n        Estimate of variance, If None, will be estimated from the largest\\n        model. Default is None.\\n    test : str {\"F\", \"Chisq\", \"Cp\"} or None\\n        Test statistics to provide. Default is \"F\".\\n    typ : str or int {\"I\",\"II\",\"III\"} or {1,2,3}\\n        The type of Anova test to perform. See notes.\\n    robust : {None, \"hc0\", \"hc1\", \"hc2\", \"hc3\"}\\n        Use heteroscedasticity-corrected coefficient covariance matrix.\\n        If robust covariance is desired, it is recommended to use `hc3`.\\n\\n    Returns\\n    -------\\n    anova : DataFrame\\n        When args is a single model, return is DataFrame with columns:\\n\\n        sum_sq : float64\\n            Sum of squares for model terms.\\n        df : float64\\n            Degrees of freedom for model terms.\\n        F : float64\\n            F statistic value for significance of adding model terms.\\n        PR(>F) : float64\\n            P-value for significance of adding model terms.\\n\\n        When args is multiple models, return is DataFrame with columns:\\n\\n        df_resid : float64\\n            Degrees of freedom of residuals in models.\\n        ssr : float64\\n            Sum of squares of residuals in models.\\n        df_diff : float64\\n            Degrees of freedom difference from previous model in args\\n        ss_dff : float64\\n            Difference in ssr from previous model in args\\n        F : float64\\n            F statistic comparing to previous model in args\\n        PR(>F): float64\\n            P-value for significance comparing to previous model in args\\n\\n    Notes\\n    -----\\n    Model statistics are given in the order of args. Models must have been fit\\n    using the formula api.\\n\\n    See Also\\n    --------\\n    model_results.compare_f_test, model_results.compare_lm_test\\n\\n    Examples\\n    --------\\n    >>> import statsmodels.api as sm\\n    >>> from statsmodels.formula.api import ols\\n    >>> moore = sm.datasets.get_rdataset(\"Moore\", \"carData\", cache=True) # load\\n    >>> data = moore.data\\n    >>> data = data.rename(columns={\"partner.status\" :\\n    ...                             \"partner_status\"}) # make name pythonic\\n    >>> moore_lm = ols(\\'conformity ~ C(fcategory, Sum)*C(partner_status, Sum)\\',\\n    ...                 data=data).fit()\\n    >>> table = sm.stats.anova_lm(moore_lm, typ=2) # Type 2 Anova DataFrame\\n    >>> print(table)\\n    '\n    typ = kwargs.get('typ', 1)\n    if len(args) == 1:\n        model = args[0]\n        return anova_single(model, **kwargs)\n    if typ not in [1, 'I']:\n        raise ValueError('Multiple models only supported for type I. Got type %s' % str(typ))\n    test = kwargs.get('test', 'F')\n    scale = kwargs.get('scale', None)\n    n_models = len(args)\n    pr_test = 'Pr(>%s)' % test\n    names = ['df_resid', 'ssr', 'df_diff', 'ss_diff', test, pr_test]\n    table = DataFrame(np.zeros((n_models, 6)), columns=names)\n    if not scale:\n        scale = args[-1].scale\n    table['ssr'] = [mdl.ssr for mdl in args]\n    table['df_resid'] = [mdl.df_resid for mdl in args]\n    table.loc[table.index[1:], 'df_diff'] = -np.diff(table['df_resid'].values)\n    table['ss_diff'] = -table['ssr'].diff()\n    if test == 'F':\n        table['F'] = table['ss_diff'] / table['df_diff'] / scale\n        table[pr_test] = stats.f.sf(table['F'], table['df_diff'], table['df_resid'])\n        table.loc[table['F'].isnull(), pr_test] = np.nan\n    return table",
            "def anova_lm(*args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Anova table for one or more fitted linear models.\\n\\n    Parameters\\n    ----------\\n    args : fitted linear model results instance\\n        One or more fitted linear models\\n    scale : float\\n        Estimate of variance, If None, will be estimated from the largest\\n        model. Default is None.\\n    test : str {\"F\", \"Chisq\", \"Cp\"} or None\\n        Test statistics to provide. Default is \"F\".\\n    typ : str or int {\"I\",\"II\",\"III\"} or {1,2,3}\\n        The type of Anova test to perform. See notes.\\n    robust : {None, \"hc0\", \"hc1\", \"hc2\", \"hc3\"}\\n        Use heteroscedasticity-corrected coefficient covariance matrix.\\n        If robust covariance is desired, it is recommended to use `hc3`.\\n\\n    Returns\\n    -------\\n    anova : DataFrame\\n        When args is a single model, return is DataFrame with columns:\\n\\n        sum_sq : float64\\n            Sum of squares for model terms.\\n        df : float64\\n            Degrees of freedom for model terms.\\n        F : float64\\n            F statistic value for significance of adding model terms.\\n        PR(>F) : float64\\n            P-value for significance of adding model terms.\\n\\n        When args is multiple models, return is DataFrame with columns:\\n\\n        df_resid : float64\\n            Degrees of freedom of residuals in models.\\n        ssr : float64\\n            Sum of squares of residuals in models.\\n        df_diff : float64\\n            Degrees of freedom difference from previous model in args\\n        ss_dff : float64\\n            Difference in ssr from previous model in args\\n        F : float64\\n            F statistic comparing to previous model in args\\n        PR(>F): float64\\n            P-value for significance comparing to previous model in args\\n\\n    Notes\\n    -----\\n    Model statistics are given in the order of args. Models must have been fit\\n    using the formula api.\\n\\n    See Also\\n    --------\\n    model_results.compare_f_test, model_results.compare_lm_test\\n\\n    Examples\\n    --------\\n    >>> import statsmodels.api as sm\\n    >>> from statsmodels.formula.api import ols\\n    >>> moore = sm.datasets.get_rdataset(\"Moore\", \"carData\", cache=True) # load\\n    >>> data = moore.data\\n    >>> data = data.rename(columns={\"partner.status\" :\\n    ...                             \"partner_status\"}) # make name pythonic\\n    >>> moore_lm = ols(\\'conformity ~ C(fcategory, Sum)*C(partner_status, Sum)\\',\\n    ...                 data=data).fit()\\n    >>> table = sm.stats.anova_lm(moore_lm, typ=2) # Type 2 Anova DataFrame\\n    >>> print(table)\\n    '\n    typ = kwargs.get('typ', 1)\n    if len(args) == 1:\n        model = args[0]\n        return anova_single(model, **kwargs)\n    if typ not in [1, 'I']:\n        raise ValueError('Multiple models only supported for type I. Got type %s' % str(typ))\n    test = kwargs.get('test', 'F')\n    scale = kwargs.get('scale', None)\n    n_models = len(args)\n    pr_test = 'Pr(>%s)' % test\n    names = ['df_resid', 'ssr', 'df_diff', 'ss_diff', test, pr_test]\n    table = DataFrame(np.zeros((n_models, 6)), columns=names)\n    if not scale:\n        scale = args[-1].scale\n    table['ssr'] = [mdl.ssr for mdl in args]\n    table['df_resid'] = [mdl.df_resid for mdl in args]\n    table.loc[table.index[1:], 'df_diff'] = -np.diff(table['df_resid'].values)\n    table['ss_diff'] = -table['ssr'].diff()\n    if test == 'F':\n        table['F'] = table['ss_diff'] / table['df_diff'] / scale\n        table[pr_test] = stats.f.sf(table['F'], table['df_diff'], table['df_resid'])\n        table.loc[table['F'].isnull(), pr_test] = np.nan\n    return table",
            "def anova_lm(*args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Anova table for one or more fitted linear models.\\n\\n    Parameters\\n    ----------\\n    args : fitted linear model results instance\\n        One or more fitted linear models\\n    scale : float\\n        Estimate of variance, If None, will be estimated from the largest\\n        model. Default is None.\\n    test : str {\"F\", \"Chisq\", \"Cp\"} or None\\n        Test statistics to provide. Default is \"F\".\\n    typ : str or int {\"I\",\"II\",\"III\"} or {1,2,3}\\n        The type of Anova test to perform. See notes.\\n    robust : {None, \"hc0\", \"hc1\", \"hc2\", \"hc3\"}\\n        Use heteroscedasticity-corrected coefficient covariance matrix.\\n        If robust covariance is desired, it is recommended to use `hc3`.\\n\\n    Returns\\n    -------\\n    anova : DataFrame\\n        When args is a single model, return is DataFrame with columns:\\n\\n        sum_sq : float64\\n            Sum of squares for model terms.\\n        df : float64\\n            Degrees of freedom for model terms.\\n        F : float64\\n            F statistic value for significance of adding model terms.\\n        PR(>F) : float64\\n            P-value for significance of adding model terms.\\n\\n        When args is multiple models, return is DataFrame with columns:\\n\\n        df_resid : float64\\n            Degrees of freedom of residuals in models.\\n        ssr : float64\\n            Sum of squares of residuals in models.\\n        df_diff : float64\\n            Degrees of freedom difference from previous model in args\\n        ss_dff : float64\\n            Difference in ssr from previous model in args\\n        F : float64\\n            F statistic comparing to previous model in args\\n        PR(>F): float64\\n            P-value for significance comparing to previous model in args\\n\\n    Notes\\n    -----\\n    Model statistics are given in the order of args. Models must have been fit\\n    using the formula api.\\n\\n    See Also\\n    --------\\n    model_results.compare_f_test, model_results.compare_lm_test\\n\\n    Examples\\n    --------\\n    >>> import statsmodels.api as sm\\n    >>> from statsmodels.formula.api import ols\\n    >>> moore = sm.datasets.get_rdataset(\"Moore\", \"carData\", cache=True) # load\\n    >>> data = moore.data\\n    >>> data = data.rename(columns={\"partner.status\" :\\n    ...                             \"partner_status\"}) # make name pythonic\\n    >>> moore_lm = ols(\\'conformity ~ C(fcategory, Sum)*C(partner_status, Sum)\\',\\n    ...                 data=data).fit()\\n    >>> table = sm.stats.anova_lm(moore_lm, typ=2) # Type 2 Anova DataFrame\\n    >>> print(table)\\n    '\n    typ = kwargs.get('typ', 1)\n    if len(args) == 1:\n        model = args[0]\n        return anova_single(model, **kwargs)\n    if typ not in [1, 'I']:\n        raise ValueError('Multiple models only supported for type I. Got type %s' % str(typ))\n    test = kwargs.get('test', 'F')\n    scale = kwargs.get('scale', None)\n    n_models = len(args)\n    pr_test = 'Pr(>%s)' % test\n    names = ['df_resid', 'ssr', 'df_diff', 'ss_diff', test, pr_test]\n    table = DataFrame(np.zeros((n_models, 6)), columns=names)\n    if not scale:\n        scale = args[-1].scale\n    table['ssr'] = [mdl.ssr for mdl in args]\n    table['df_resid'] = [mdl.df_resid for mdl in args]\n    table.loc[table.index[1:], 'df_diff'] = -np.diff(table['df_resid'].values)\n    table['ss_diff'] = -table['ssr'].diff()\n    if test == 'F':\n        table['F'] = table['ss_diff'] / table['df_diff'] / scale\n        table[pr_test] = stats.f.sf(table['F'], table['df_diff'], table['df_resid'])\n        table.loc[table['F'].isnull(), pr_test] = np.nan\n    return table"
        ]
    },
    {
        "func_name": "_not_slice",
        "original": "def _not_slice(slices, slices_to_exclude, n):\n    ind = np.array([True] * n)\n    for term in slices_to_exclude:\n        s = slices[term]\n        ind[s] = False\n    return ind",
        "mutated": [
            "def _not_slice(slices, slices_to_exclude, n):\n    if False:\n        i = 10\n    ind = np.array([True] * n)\n    for term in slices_to_exclude:\n        s = slices[term]\n        ind[s] = False\n    return ind",
            "def _not_slice(slices, slices_to_exclude, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ind = np.array([True] * n)\n    for term in slices_to_exclude:\n        s = slices[term]\n        ind[s] = False\n    return ind",
            "def _not_slice(slices, slices_to_exclude, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ind = np.array([True] * n)\n    for term in slices_to_exclude:\n        s = slices[term]\n        ind[s] = False\n    return ind",
            "def _not_slice(slices, slices_to_exclude, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ind = np.array([True] * n)\n    for term in slices_to_exclude:\n        s = slices[term]\n        ind[s] = False\n    return ind",
            "def _not_slice(slices, slices_to_exclude, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ind = np.array([True] * n)\n    for term in slices_to_exclude:\n        s = slices[term]\n        ind[s] = False\n    return ind"
        ]
    },
    {
        "func_name": "_ssr_reduced_model",
        "original": "def _ssr_reduced_model(y, x, term_slices, params, keys):\n    \"\"\"\n    Residual sum of squares of OLS model excluding factors in `keys`\n    Assumes x matrix is orthogonal\n\n    Parameters\n    ----------\n    y : array_like\n        dependent variable\n    x : array_like\n        independent variables\n    term_slices : a dict of slices\n        term_slices[key] is a boolean array specifies the parameters\n        associated with the factor `key`\n    params : ndarray\n        OLS solution of y = x * params\n    keys : keys for term_slices\n        factors to be excluded\n\n    Returns\n    -------\n    rss : float\n        residual sum of squares\n    df : int\n        degrees of freedom\n    \"\"\"\n    ind = _not_slice(term_slices, keys, x.shape[1])\n    params1 = params[ind]\n    ssr = np.subtract(y, x[:, ind].dot(params1))\n    ssr = ssr.T.dot(ssr)\n    df_resid = len(y) - len(params1)\n    return (ssr, df_resid)",
        "mutated": [
            "def _ssr_reduced_model(y, x, term_slices, params, keys):\n    if False:\n        i = 10\n    '\\n    Residual sum of squares of OLS model excluding factors in `keys`\\n    Assumes x matrix is orthogonal\\n\\n    Parameters\\n    ----------\\n    y : array_like\\n        dependent variable\\n    x : array_like\\n        independent variables\\n    term_slices : a dict of slices\\n        term_slices[key] is a boolean array specifies the parameters\\n        associated with the factor `key`\\n    params : ndarray\\n        OLS solution of y = x * params\\n    keys : keys for term_slices\\n        factors to be excluded\\n\\n    Returns\\n    -------\\n    rss : float\\n        residual sum of squares\\n    df : int\\n        degrees of freedom\\n    '\n    ind = _not_slice(term_slices, keys, x.shape[1])\n    params1 = params[ind]\n    ssr = np.subtract(y, x[:, ind].dot(params1))\n    ssr = ssr.T.dot(ssr)\n    df_resid = len(y) - len(params1)\n    return (ssr, df_resid)",
            "def _ssr_reduced_model(y, x, term_slices, params, keys):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Residual sum of squares of OLS model excluding factors in `keys`\\n    Assumes x matrix is orthogonal\\n\\n    Parameters\\n    ----------\\n    y : array_like\\n        dependent variable\\n    x : array_like\\n        independent variables\\n    term_slices : a dict of slices\\n        term_slices[key] is a boolean array specifies the parameters\\n        associated with the factor `key`\\n    params : ndarray\\n        OLS solution of y = x * params\\n    keys : keys for term_slices\\n        factors to be excluded\\n\\n    Returns\\n    -------\\n    rss : float\\n        residual sum of squares\\n    df : int\\n        degrees of freedom\\n    '\n    ind = _not_slice(term_slices, keys, x.shape[1])\n    params1 = params[ind]\n    ssr = np.subtract(y, x[:, ind].dot(params1))\n    ssr = ssr.T.dot(ssr)\n    df_resid = len(y) - len(params1)\n    return (ssr, df_resid)",
            "def _ssr_reduced_model(y, x, term_slices, params, keys):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Residual sum of squares of OLS model excluding factors in `keys`\\n    Assumes x matrix is orthogonal\\n\\n    Parameters\\n    ----------\\n    y : array_like\\n        dependent variable\\n    x : array_like\\n        independent variables\\n    term_slices : a dict of slices\\n        term_slices[key] is a boolean array specifies the parameters\\n        associated with the factor `key`\\n    params : ndarray\\n        OLS solution of y = x * params\\n    keys : keys for term_slices\\n        factors to be excluded\\n\\n    Returns\\n    -------\\n    rss : float\\n        residual sum of squares\\n    df : int\\n        degrees of freedom\\n    '\n    ind = _not_slice(term_slices, keys, x.shape[1])\n    params1 = params[ind]\n    ssr = np.subtract(y, x[:, ind].dot(params1))\n    ssr = ssr.T.dot(ssr)\n    df_resid = len(y) - len(params1)\n    return (ssr, df_resid)",
            "def _ssr_reduced_model(y, x, term_slices, params, keys):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Residual sum of squares of OLS model excluding factors in `keys`\\n    Assumes x matrix is orthogonal\\n\\n    Parameters\\n    ----------\\n    y : array_like\\n        dependent variable\\n    x : array_like\\n        independent variables\\n    term_slices : a dict of slices\\n        term_slices[key] is a boolean array specifies the parameters\\n        associated with the factor `key`\\n    params : ndarray\\n        OLS solution of y = x * params\\n    keys : keys for term_slices\\n        factors to be excluded\\n\\n    Returns\\n    -------\\n    rss : float\\n        residual sum of squares\\n    df : int\\n        degrees of freedom\\n    '\n    ind = _not_slice(term_slices, keys, x.shape[1])\n    params1 = params[ind]\n    ssr = np.subtract(y, x[:, ind].dot(params1))\n    ssr = ssr.T.dot(ssr)\n    df_resid = len(y) - len(params1)\n    return (ssr, df_resid)",
            "def _ssr_reduced_model(y, x, term_slices, params, keys):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Residual sum of squares of OLS model excluding factors in `keys`\\n    Assumes x matrix is orthogonal\\n\\n    Parameters\\n    ----------\\n    y : array_like\\n        dependent variable\\n    x : array_like\\n        independent variables\\n    term_slices : a dict of slices\\n        term_slices[key] is a boolean array specifies the parameters\\n        associated with the factor `key`\\n    params : ndarray\\n        OLS solution of y = x * params\\n    keys : keys for term_slices\\n        factors to be excluded\\n\\n    Returns\\n    -------\\n    rss : float\\n        residual sum of squares\\n    df : int\\n        degrees of freedom\\n    '\n    ind = _not_slice(term_slices, keys, x.shape[1])\n    params1 = params[ind]\n    ssr = np.subtract(y, x[:, ind].dot(params1))\n    ssr = ssr.T.dot(ssr)\n    df_resid = len(y) - len(params1)\n    return (ssr, df_resid)"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, data, depvar, subject, within=None, between=None, aggregate_func=None):\n    self.data = data\n    self.depvar = depvar\n    self.within = within\n    if 'C' in within:\n        raise ValueError(\"Factor name cannot be 'C'! This is in conflict with patsy's contrast function name.\")\n    self.between = between\n    if between is not None:\n        raise NotImplementedError('Between subject effect not yet supported!')\n    self.subject = subject\n    if aggregate_func == 'mean':\n        self.aggregate_func = np.mean\n    else:\n        self.aggregate_func = aggregate_func\n    if not data.equals(data.drop_duplicates(subset=[subject] + within)):\n        if self.aggregate_func is not None:\n            self._aggregate()\n        else:\n            msg = 'The data set contains more than one observation per subject and cell. Either aggregate the data manually, or pass the `aggregate_func` parameter.'\n            raise ValueError(msg)\n    self._check_data_balanced()",
        "mutated": [
            "def __init__(self, data, depvar, subject, within=None, between=None, aggregate_func=None):\n    if False:\n        i = 10\n    self.data = data\n    self.depvar = depvar\n    self.within = within\n    if 'C' in within:\n        raise ValueError(\"Factor name cannot be 'C'! This is in conflict with patsy's contrast function name.\")\n    self.between = between\n    if between is not None:\n        raise NotImplementedError('Between subject effect not yet supported!')\n    self.subject = subject\n    if aggregate_func == 'mean':\n        self.aggregate_func = np.mean\n    else:\n        self.aggregate_func = aggregate_func\n    if not data.equals(data.drop_duplicates(subset=[subject] + within)):\n        if self.aggregate_func is not None:\n            self._aggregate()\n        else:\n            msg = 'The data set contains more than one observation per subject and cell. Either aggregate the data manually, or pass the `aggregate_func` parameter.'\n            raise ValueError(msg)\n    self._check_data_balanced()",
            "def __init__(self, data, depvar, subject, within=None, between=None, aggregate_func=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.data = data\n    self.depvar = depvar\n    self.within = within\n    if 'C' in within:\n        raise ValueError(\"Factor name cannot be 'C'! This is in conflict with patsy's contrast function name.\")\n    self.between = between\n    if between is not None:\n        raise NotImplementedError('Between subject effect not yet supported!')\n    self.subject = subject\n    if aggregate_func == 'mean':\n        self.aggregate_func = np.mean\n    else:\n        self.aggregate_func = aggregate_func\n    if not data.equals(data.drop_duplicates(subset=[subject] + within)):\n        if self.aggregate_func is not None:\n            self._aggregate()\n        else:\n            msg = 'The data set contains more than one observation per subject and cell. Either aggregate the data manually, or pass the `aggregate_func` parameter.'\n            raise ValueError(msg)\n    self._check_data_balanced()",
            "def __init__(self, data, depvar, subject, within=None, between=None, aggregate_func=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.data = data\n    self.depvar = depvar\n    self.within = within\n    if 'C' in within:\n        raise ValueError(\"Factor name cannot be 'C'! This is in conflict with patsy's contrast function name.\")\n    self.between = between\n    if between is not None:\n        raise NotImplementedError('Between subject effect not yet supported!')\n    self.subject = subject\n    if aggregate_func == 'mean':\n        self.aggregate_func = np.mean\n    else:\n        self.aggregate_func = aggregate_func\n    if not data.equals(data.drop_duplicates(subset=[subject] + within)):\n        if self.aggregate_func is not None:\n            self._aggregate()\n        else:\n            msg = 'The data set contains more than one observation per subject and cell. Either aggregate the data manually, or pass the `aggregate_func` parameter.'\n            raise ValueError(msg)\n    self._check_data_balanced()",
            "def __init__(self, data, depvar, subject, within=None, between=None, aggregate_func=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.data = data\n    self.depvar = depvar\n    self.within = within\n    if 'C' in within:\n        raise ValueError(\"Factor name cannot be 'C'! This is in conflict with patsy's contrast function name.\")\n    self.between = between\n    if between is not None:\n        raise NotImplementedError('Between subject effect not yet supported!')\n    self.subject = subject\n    if aggregate_func == 'mean':\n        self.aggregate_func = np.mean\n    else:\n        self.aggregate_func = aggregate_func\n    if not data.equals(data.drop_duplicates(subset=[subject] + within)):\n        if self.aggregate_func is not None:\n            self._aggregate()\n        else:\n            msg = 'The data set contains more than one observation per subject and cell. Either aggregate the data manually, or pass the `aggregate_func` parameter.'\n            raise ValueError(msg)\n    self._check_data_balanced()",
            "def __init__(self, data, depvar, subject, within=None, between=None, aggregate_func=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.data = data\n    self.depvar = depvar\n    self.within = within\n    if 'C' in within:\n        raise ValueError(\"Factor name cannot be 'C'! This is in conflict with patsy's contrast function name.\")\n    self.between = between\n    if between is not None:\n        raise NotImplementedError('Between subject effect not yet supported!')\n    self.subject = subject\n    if aggregate_func == 'mean':\n        self.aggregate_func = np.mean\n    else:\n        self.aggregate_func = aggregate_func\n    if not data.equals(data.drop_duplicates(subset=[subject] + within)):\n        if self.aggregate_func is not None:\n            self._aggregate()\n        else:\n            msg = 'The data set contains more than one observation per subject and cell. Either aggregate the data manually, or pass the `aggregate_func` parameter.'\n            raise ValueError(msg)\n    self._check_data_balanced()"
        ]
    },
    {
        "func_name": "_aggregate",
        "original": "def _aggregate(self):\n    self.data = self.data.groupby([self.subject] + self.within, as_index=False)[self.depvar].agg(self.aggregate_func)",
        "mutated": [
            "def _aggregate(self):\n    if False:\n        i = 10\n    self.data = self.data.groupby([self.subject] + self.within, as_index=False)[self.depvar].agg(self.aggregate_func)",
            "def _aggregate(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.data = self.data.groupby([self.subject] + self.within, as_index=False)[self.depvar].agg(self.aggregate_func)",
            "def _aggregate(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.data = self.data.groupby([self.subject] + self.within, as_index=False)[self.depvar].agg(self.aggregate_func)",
            "def _aggregate(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.data = self.data.groupby([self.subject] + self.within, as_index=False)[self.depvar].agg(self.aggregate_func)",
            "def _aggregate(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.data = self.data.groupby([self.subject] + self.within, as_index=False)[self.depvar].agg(self.aggregate_func)"
        ]
    },
    {
        "func_name": "_check_data_balanced",
        "original": "def _check_data_balanced(self):\n    \"\"\"raise if data is not balanced\n\n        This raises a ValueError if the data is not balanced, and\n        returns None if it is balance\n\n        Return might change\n        \"\"\"\n    factor_levels = 1\n    for wi in self.within:\n        factor_levels *= len(self.data[wi].unique())\n    cell_count = {}\n    for index in range(self.data.shape[0]):\n        key = []\n        for col in self.within:\n            key.append(self.data[col].iloc[index])\n        key = tuple(key)\n        if key in cell_count:\n            cell_count[key] = cell_count[key] + 1\n        else:\n            cell_count[key] = 1\n    error_message = 'Data is unbalanced.'\n    if len(cell_count) != factor_levels:\n        raise ValueError(error_message)\n    count = cell_count[key]\n    for key in cell_count:\n        if count != cell_count[key]:\n            raise ValueError(error_message)\n    if self.data.shape[0] > count * factor_levels:\n        raise ValueError('There are more than 1 element in a cell! Missing factors?')",
        "mutated": [
            "def _check_data_balanced(self):\n    if False:\n        i = 10\n    'raise if data is not balanced\\n\\n        This raises a ValueError if the data is not balanced, and\\n        returns None if it is balance\\n\\n        Return might change\\n        '\n    factor_levels = 1\n    for wi in self.within:\n        factor_levels *= len(self.data[wi].unique())\n    cell_count = {}\n    for index in range(self.data.shape[0]):\n        key = []\n        for col in self.within:\n            key.append(self.data[col].iloc[index])\n        key = tuple(key)\n        if key in cell_count:\n            cell_count[key] = cell_count[key] + 1\n        else:\n            cell_count[key] = 1\n    error_message = 'Data is unbalanced.'\n    if len(cell_count) != factor_levels:\n        raise ValueError(error_message)\n    count = cell_count[key]\n    for key in cell_count:\n        if count != cell_count[key]:\n            raise ValueError(error_message)\n    if self.data.shape[0] > count * factor_levels:\n        raise ValueError('There are more than 1 element in a cell! Missing factors?')",
            "def _check_data_balanced(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'raise if data is not balanced\\n\\n        This raises a ValueError if the data is not balanced, and\\n        returns None if it is balance\\n\\n        Return might change\\n        '\n    factor_levels = 1\n    for wi in self.within:\n        factor_levels *= len(self.data[wi].unique())\n    cell_count = {}\n    for index in range(self.data.shape[0]):\n        key = []\n        for col in self.within:\n            key.append(self.data[col].iloc[index])\n        key = tuple(key)\n        if key in cell_count:\n            cell_count[key] = cell_count[key] + 1\n        else:\n            cell_count[key] = 1\n    error_message = 'Data is unbalanced.'\n    if len(cell_count) != factor_levels:\n        raise ValueError(error_message)\n    count = cell_count[key]\n    for key in cell_count:\n        if count != cell_count[key]:\n            raise ValueError(error_message)\n    if self.data.shape[0] > count * factor_levels:\n        raise ValueError('There are more than 1 element in a cell! Missing factors?')",
            "def _check_data_balanced(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'raise if data is not balanced\\n\\n        This raises a ValueError if the data is not balanced, and\\n        returns None if it is balance\\n\\n        Return might change\\n        '\n    factor_levels = 1\n    for wi in self.within:\n        factor_levels *= len(self.data[wi].unique())\n    cell_count = {}\n    for index in range(self.data.shape[0]):\n        key = []\n        for col in self.within:\n            key.append(self.data[col].iloc[index])\n        key = tuple(key)\n        if key in cell_count:\n            cell_count[key] = cell_count[key] + 1\n        else:\n            cell_count[key] = 1\n    error_message = 'Data is unbalanced.'\n    if len(cell_count) != factor_levels:\n        raise ValueError(error_message)\n    count = cell_count[key]\n    for key in cell_count:\n        if count != cell_count[key]:\n            raise ValueError(error_message)\n    if self.data.shape[0] > count * factor_levels:\n        raise ValueError('There are more than 1 element in a cell! Missing factors?')",
            "def _check_data_balanced(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'raise if data is not balanced\\n\\n        This raises a ValueError if the data is not balanced, and\\n        returns None if it is balance\\n\\n        Return might change\\n        '\n    factor_levels = 1\n    for wi in self.within:\n        factor_levels *= len(self.data[wi].unique())\n    cell_count = {}\n    for index in range(self.data.shape[0]):\n        key = []\n        for col in self.within:\n            key.append(self.data[col].iloc[index])\n        key = tuple(key)\n        if key in cell_count:\n            cell_count[key] = cell_count[key] + 1\n        else:\n            cell_count[key] = 1\n    error_message = 'Data is unbalanced.'\n    if len(cell_count) != factor_levels:\n        raise ValueError(error_message)\n    count = cell_count[key]\n    for key in cell_count:\n        if count != cell_count[key]:\n            raise ValueError(error_message)\n    if self.data.shape[0] > count * factor_levels:\n        raise ValueError('There are more than 1 element in a cell! Missing factors?')",
            "def _check_data_balanced(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'raise if data is not balanced\\n\\n        This raises a ValueError if the data is not balanced, and\\n        returns None if it is balance\\n\\n        Return might change\\n        '\n    factor_levels = 1\n    for wi in self.within:\n        factor_levels *= len(self.data[wi].unique())\n    cell_count = {}\n    for index in range(self.data.shape[0]):\n        key = []\n        for col in self.within:\n            key.append(self.data[col].iloc[index])\n        key = tuple(key)\n        if key in cell_count:\n            cell_count[key] = cell_count[key] + 1\n        else:\n            cell_count[key] = 1\n    error_message = 'Data is unbalanced.'\n    if len(cell_count) != factor_levels:\n        raise ValueError(error_message)\n    count = cell_count[key]\n    for key in cell_count:\n        if count != cell_count[key]:\n            raise ValueError(error_message)\n    if self.data.shape[0] > count * factor_levels:\n        raise ValueError('There are more than 1 element in a cell! Missing factors?')"
        ]
    },
    {
        "func_name": "fit",
        "original": "def fit(self):\n    \"\"\"estimate the model and compute the Anova table\n\n        Returns\n        -------\n        AnovaResults instance\n        \"\"\"\n    y = self.data[self.depvar].values\n    within = ['C(%s, Sum)' % i for i in self.within]\n    subject = 'C(%s, Sum)' % self.subject\n    factors = within + [subject]\n    x = patsy.dmatrix('*'.join(factors), data=self.data)\n    term_slices = x.design_info.term_name_slices\n    for key in term_slices:\n        ind = np.array([False] * x.shape[1])\n        ind[term_slices[key]] = True\n        term_slices[key] = np.array(ind)\n    term_exclude = [':'.join(factors)]\n    ind = _not_slice(term_slices, term_exclude, x.shape[1])\n    x = x[:, ind]\n    model = OLS(y, x)\n    results = model.fit()\n    if model.rank < x.shape[1]:\n        raise ValueError('Independent variables are collinear.')\n    for i in term_exclude:\n        term_slices.pop(i)\n    for key in term_slices:\n        term_slices[key] = term_slices[key][ind]\n    params = results.params\n    df_resid = results.df_resid\n    ssr = results.ssr\n    columns = ['F Value', 'Num DF', 'Den DF', 'Pr > F']\n    anova_table = pd.DataFrame(np.zeros((0, 4)), columns=columns)\n    for key in term_slices:\n        if self.subject not in key and key != 'Intercept':\n            (ssr1, df_resid1) = _ssr_reduced_model(y, x, term_slices, params, [key])\n            df1 = df_resid1 - df_resid\n            msm = (ssr1 - ssr) / df1\n            if key == ':'.join(factors[:-1]) or key + ':' + subject not in term_slices:\n                mse = ssr / df_resid\n                df2 = df_resid\n            else:\n                (ssr1, df_resid1) = _ssr_reduced_model(y, x, term_slices, params, [key + ':' + subject])\n                df2 = df_resid1 - df_resid\n                mse = (ssr1 - ssr) / df2\n            F = msm / mse\n            p = stats.f.sf(F, df1, df2)\n            term = key.replace('C(', '').replace(', Sum)', '')\n            anova_table.loc[term, 'F Value'] = F\n            anova_table.loc[term, 'Num DF'] = df1\n            anova_table.loc[term, 'Den DF'] = df2\n            anova_table.loc[term, 'Pr > F'] = p\n    return AnovaResults(anova_table)",
        "mutated": [
            "def fit(self):\n    if False:\n        i = 10\n    'estimate the model and compute the Anova table\\n\\n        Returns\\n        -------\\n        AnovaResults instance\\n        '\n    y = self.data[self.depvar].values\n    within = ['C(%s, Sum)' % i for i in self.within]\n    subject = 'C(%s, Sum)' % self.subject\n    factors = within + [subject]\n    x = patsy.dmatrix('*'.join(factors), data=self.data)\n    term_slices = x.design_info.term_name_slices\n    for key in term_slices:\n        ind = np.array([False] * x.shape[1])\n        ind[term_slices[key]] = True\n        term_slices[key] = np.array(ind)\n    term_exclude = [':'.join(factors)]\n    ind = _not_slice(term_slices, term_exclude, x.shape[1])\n    x = x[:, ind]\n    model = OLS(y, x)\n    results = model.fit()\n    if model.rank < x.shape[1]:\n        raise ValueError('Independent variables are collinear.')\n    for i in term_exclude:\n        term_slices.pop(i)\n    for key in term_slices:\n        term_slices[key] = term_slices[key][ind]\n    params = results.params\n    df_resid = results.df_resid\n    ssr = results.ssr\n    columns = ['F Value', 'Num DF', 'Den DF', 'Pr > F']\n    anova_table = pd.DataFrame(np.zeros((0, 4)), columns=columns)\n    for key in term_slices:\n        if self.subject not in key and key != 'Intercept':\n            (ssr1, df_resid1) = _ssr_reduced_model(y, x, term_slices, params, [key])\n            df1 = df_resid1 - df_resid\n            msm = (ssr1 - ssr) / df1\n            if key == ':'.join(factors[:-1]) or key + ':' + subject not in term_slices:\n                mse = ssr / df_resid\n                df2 = df_resid\n            else:\n                (ssr1, df_resid1) = _ssr_reduced_model(y, x, term_slices, params, [key + ':' + subject])\n                df2 = df_resid1 - df_resid\n                mse = (ssr1 - ssr) / df2\n            F = msm / mse\n            p = stats.f.sf(F, df1, df2)\n            term = key.replace('C(', '').replace(', Sum)', '')\n            anova_table.loc[term, 'F Value'] = F\n            anova_table.loc[term, 'Num DF'] = df1\n            anova_table.loc[term, 'Den DF'] = df2\n            anova_table.loc[term, 'Pr > F'] = p\n    return AnovaResults(anova_table)",
            "def fit(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'estimate the model and compute the Anova table\\n\\n        Returns\\n        -------\\n        AnovaResults instance\\n        '\n    y = self.data[self.depvar].values\n    within = ['C(%s, Sum)' % i for i in self.within]\n    subject = 'C(%s, Sum)' % self.subject\n    factors = within + [subject]\n    x = patsy.dmatrix('*'.join(factors), data=self.data)\n    term_slices = x.design_info.term_name_slices\n    for key in term_slices:\n        ind = np.array([False] * x.shape[1])\n        ind[term_slices[key]] = True\n        term_slices[key] = np.array(ind)\n    term_exclude = [':'.join(factors)]\n    ind = _not_slice(term_slices, term_exclude, x.shape[1])\n    x = x[:, ind]\n    model = OLS(y, x)\n    results = model.fit()\n    if model.rank < x.shape[1]:\n        raise ValueError('Independent variables are collinear.')\n    for i in term_exclude:\n        term_slices.pop(i)\n    for key in term_slices:\n        term_slices[key] = term_slices[key][ind]\n    params = results.params\n    df_resid = results.df_resid\n    ssr = results.ssr\n    columns = ['F Value', 'Num DF', 'Den DF', 'Pr > F']\n    anova_table = pd.DataFrame(np.zeros((0, 4)), columns=columns)\n    for key in term_slices:\n        if self.subject not in key and key != 'Intercept':\n            (ssr1, df_resid1) = _ssr_reduced_model(y, x, term_slices, params, [key])\n            df1 = df_resid1 - df_resid\n            msm = (ssr1 - ssr) / df1\n            if key == ':'.join(factors[:-1]) or key + ':' + subject not in term_slices:\n                mse = ssr / df_resid\n                df2 = df_resid\n            else:\n                (ssr1, df_resid1) = _ssr_reduced_model(y, x, term_slices, params, [key + ':' + subject])\n                df2 = df_resid1 - df_resid\n                mse = (ssr1 - ssr) / df2\n            F = msm / mse\n            p = stats.f.sf(F, df1, df2)\n            term = key.replace('C(', '').replace(', Sum)', '')\n            anova_table.loc[term, 'F Value'] = F\n            anova_table.loc[term, 'Num DF'] = df1\n            anova_table.loc[term, 'Den DF'] = df2\n            anova_table.loc[term, 'Pr > F'] = p\n    return AnovaResults(anova_table)",
            "def fit(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'estimate the model and compute the Anova table\\n\\n        Returns\\n        -------\\n        AnovaResults instance\\n        '\n    y = self.data[self.depvar].values\n    within = ['C(%s, Sum)' % i for i in self.within]\n    subject = 'C(%s, Sum)' % self.subject\n    factors = within + [subject]\n    x = patsy.dmatrix('*'.join(factors), data=self.data)\n    term_slices = x.design_info.term_name_slices\n    for key in term_slices:\n        ind = np.array([False] * x.shape[1])\n        ind[term_slices[key]] = True\n        term_slices[key] = np.array(ind)\n    term_exclude = [':'.join(factors)]\n    ind = _not_slice(term_slices, term_exclude, x.shape[1])\n    x = x[:, ind]\n    model = OLS(y, x)\n    results = model.fit()\n    if model.rank < x.shape[1]:\n        raise ValueError('Independent variables are collinear.')\n    for i in term_exclude:\n        term_slices.pop(i)\n    for key in term_slices:\n        term_slices[key] = term_slices[key][ind]\n    params = results.params\n    df_resid = results.df_resid\n    ssr = results.ssr\n    columns = ['F Value', 'Num DF', 'Den DF', 'Pr > F']\n    anova_table = pd.DataFrame(np.zeros((0, 4)), columns=columns)\n    for key in term_slices:\n        if self.subject not in key and key != 'Intercept':\n            (ssr1, df_resid1) = _ssr_reduced_model(y, x, term_slices, params, [key])\n            df1 = df_resid1 - df_resid\n            msm = (ssr1 - ssr) / df1\n            if key == ':'.join(factors[:-1]) or key + ':' + subject not in term_slices:\n                mse = ssr / df_resid\n                df2 = df_resid\n            else:\n                (ssr1, df_resid1) = _ssr_reduced_model(y, x, term_slices, params, [key + ':' + subject])\n                df2 = df_resid1 - df_resid\n                mse = (ssr1 - ssr) / df2\n            F = msm / mse\n            p = stats.f.sf(F, df1, df2)\n            term = key.replace('C(', '').replace(', Sum)', '')\n            anova_table.loc[term, 'F Value'] = F\n            anova_table.loc[term, 'Num DF'] = df1\n            anova_table.loc[term, 'Den DF'] = df2\n            anova_table.loc[term, 'Pr > F'] = p\n    return AnovaResults(anova_table)",
            "def fit(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'estimate the model and compute the Anova table\\n\\n        Returns\\n        -------\\n        AnovaResults instance\\n        '\n    y = self.data[self.depvar].values\n    within = ['C(%s, Sum)' % i for i in self.within]\n    subject = 'C(%s, Sum)' % self.subject\n    factors = within + [subject]\n    x = patsy.dmatrix('*'.join(factors), data=self.data)\n    term_slices = x.design_info.term_name_slices\n    for key in term_slices:\n        ind = np.array([False] * x.shape[1])\n        ind[term_slices[key]] = True\n        term_slices[key] = np.array(ind)\n    term_exclude = [':'.join(factors)]\n    ind = _not_slice(term_slices, term_exclude, x.shape[1])\n    x = x[:, ind]\n    model = OLS(y, x)\n    results = model.fit()\n    if model.rank < x.shape[1]:\n        raise ValueError('Independent variables are collinear.')\n    for i in term_exclude:\n        term_slices.pop(i)\n    for key in term_slices:\n        term_slices[key] = term_slices[key][ind]\n    params = results.params\n    df_resid = results.df_resid\n    ssr = results.ssr\n    columns = ['F Value', 'Num DF', 'Den DF', 'Pr > F']\n    anova_table = pd.DataFrame(np.zeros((0, 4)), columns=columns)\n    for key in term_slices:\n        if self.subject not in key and key != 'Intercept':\n            (ssr1, df_resid1) = _ssr_reduced_model(y, x, term_slices, params, [key])\n            df1 = df_resid1 - df_resid\n            msm = (ssr1 - ssr) / df1\n            if key == ':'.join(factors[:-1]) or key + ':' + subject not in term_slices:\n                mse = ssr / df_resid\n                df2 = df_resid\n            else:\n                (ssr1, df_resid1) = _ssr_reduced_model(y, x, term_slices, params, [key + ':' + subject])\n                df2 = df_resid1 - df_resid\n                mse = (ssr1 - ssr) / df2\n            F = msm / mse\n            p = stats.f.sf(F, df1, df2)\n            term = key.replace('C(', '').replace(', Sum)', '')\n            anova_table.loc[term, 'F Value'] = F\n            anova_table.loc[term, 'Num DF'] = df1\n            anova_table.loc[term, 'Den DF'] = df2\n            anova_table.loc[term, 'Pr > F'] = p\n    return AnovaResults(anova_table)",
            "def fit(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'estimate the model and compute the Anova table\\n\\n        Returns\\n        -------\\n        AnovaResults instance\\n        '\n    y = self.data[self.depvar].values\n    within = ['C(%s, Sum)' % i for i in self.within]\n    subject = 'C(%s, Sum)' % self.subject\n    factors = within + [subject]\n    x = patsy.dmatrix('*'.join(factors), data=self.data)\n    term_slices = x.design_info.term_name_slices\n    for key in term_slices:\n        ind = np.array([False] * x.shape[1])\n        ind[term_slices[key]] = True\n        term_slices[key] = np.array(ind)\n    term_exclude = [':'.join(factors)]\n    ind = _not_slice(term_slices, term_exclude, x.shape[1])\n    x = x[:, ind]\n    model = OLS(y, x)\n    results = model.fit()\n    if model.rank < x.shape[1]:\n        raise ValueError('Independent variables are collinear.')\n    for i in term_exclude:\n        term_slices.pop(i)\n    for key in term_slices:\n        term_slices[key] = term_slices[key][ind]\n    params = results.params\n    df_resid = results.df_resid\n    ssr = results.ssr\n    columns = ['F Value', 'Num DF', 'Den DF', 'Pr > F']\n    anova_table = pd.DataFrame(np.zeros((0, 4)), columns=columns)\n    for key in term_slices:\n        if self.subject not in key and key != 'Intercept':\n            (ssr1, df_resid1) = _ssr_reduced_model(y, x, term_slices, params, [key])\n            df1 = df_resid1 - df_resid\n            msm = (ssr1 - ssr) / df1\n            if key == ':'.join(factors[:-1]) or key + ':' + subject not in term_slices:\n                mse = ssr / df_resid\n                df2 = df_resid\n            else:\n                (ssr1, df_resid1) = _ssr_reduced_model(y, x, term_slices, params, [key + ':' + subject])\n                df2 = df_resid1 - df_resid\n                mse = (ssr1 - ssr) / df2\n            F = msm / mse\n            p = stats.f.sf(F, df1, df2)\n            term = key.replace('C(', '').replace(', Sum)', '')\n            anova_table.loc[term, 'F Value'] = F\n            anova_table.loc[term, 'Num DF'] = df1\n            anova_table.loc[term, 'Den DF'] = df2\n            anova_table.loc[term, 'Pr > F'] = p\n    return AnovaResults(anova_table)"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, anova_table):\n    self.anova_table = anova_table",
        "mutated": [
            "def __init__(self, anova_table):\n    if False:\n        i = 10\n    self.anova_table = anova_table",
            "def __init__(self, anova_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.anova_table = anova_table",
            "def __init__(self, anova_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.anova_table = anova_table",
            "def __init__(self, anova_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.anova_table = anova_table",
            "def __init__(self, anova_table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.anova_table = anova_table"
        ]
    },
    {
        "func_name": "__str__",
        "original": "def __str__(self):\n    return self.summary().__str__()",
        "mutated": [
            "def __str__(self):\n    if False:\n        i = 10\n    return self.summary().__str__()",
            "def __str__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return self.summary().__str__()",
            "def __str__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return self.summary().__str__()",
            "def __str__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return self.summary().__str__()",
            "def __str__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return self.summary().__str__()"
        ]
    },
    {
        "func_name": "summary",
        "original": "def summary(self):\n    \"\"\"create summary results\n\n        Returns\n        -------\n        summary : summary2.Summary instance\n        \"\"\"\n    summ = summary2.Summary()\n    summ.add_title('Anova')\n    summ.add_df(self.anova_table)\n    return summ",
        "mutated": [
            "def summary(self):\n    if False:\n        i = 10\n    'create summary results\\n\\n        Returns\\n        -------\\n        summary : summary2.Summary instance\\n        '\n    summ = summary2.Summary()\n    summ.add_title('Anova')\n    summ.add_df(self.anova_table)\n    return summ",
            "def summary(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'create summary results\\n\\n        Returns\\n        -------\\n        summary : summary2.Summary instance\\n        '\n    summ = summary2.Summary()\n    summ.add_title('Anova')\n    summ.add_df(self.anova_table)\n    return summ",
            "def summary(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'create summary results\\n\\n        Returns\\n        -------\\n        summary : summary2.Summary instance\\n        '\n    summ = summary2.Summary()\n    summ.add_title('Anova')\n    summ.add_df(self.anova_table)\n    return summ",
            "def summary(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'create summary results\\n\\n        Returns\\n        -------\\n        summary : summary2.Summary instance\\n        '\n    summ = summary2.Summary()\n    summ.add_title('Anova')\n    summ.add_df(self.anova_table)\n    return summ",
            "def summary(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'create summary results\\n\\n        Returns\\n        -------\\n        summary : summary2.Summary instance\\n        '\n    summ = summary2.Summary()\n    summ.add_title('Anova')\n    summ.add_df(self.anova_table)\n    return summ"
        ]
    }
]