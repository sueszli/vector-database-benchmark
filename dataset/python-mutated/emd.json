[
    {
        "func_name": "execute",
        "original": "def execute(self, pc1, pc2, reduction='mean', dims='BNC'):\n    assert dims in ['BNC', 'BCN']\n    if dims == 'BCN':\n        (pc1, pc2) = (pc1.permute(0, 2, 1), pc2.permute(0, 2, 1))\n    (batch_size_1, N, _) = pc1.shape\n    (batch_size_2, M, _) = pc2.shape\n    assert batch_size_1 == batch_size_2\n    batch_size = batch_size_1\n    temp = jt.zeros([batch_size, (N + M) * 2], pc1.dtype)\n    match = jt.code(shape=[batch_size, M, N], dtype=pc1.dtype, inputs=[pc1, pc2, temp], cuda_header=EMD_gpu_header, cuda_src=approxmatch_gpu_src)\n    emd = jt.code(shape=[batch_size], dtype=pc1.dtype, inputs=[pc1, pc2, match], cuda_header=EMD_gpu_header, cuda_src=matchcost_gpu_src)\n    self.saved_vars = (pc1, pc2, match, reduction)\n    if reduction is None:\n        return emd\n    elif reduction == 'sum':\n        return emd.sum()\n    elif reduction == 'mean':\n        return emd.mean()",
        "mutated": [
            "def execute(self, pc1, pc2, reduction='mean', dims='BNC'):\n    if False:\n        i = 10\n    assert dims in ['BNC', 'BCN']\n    if dims == 'BCN':\n        (pc1, pc2) = (pc1.permute(0, 2, 1), pc2.permute(0, 2, 1))\n    (batch_size_1, N, _) = pc1.shape\n    (batch_size_2, M, _) = pc2.shape\n    assert batch_size_1 == batch_size_2\n    batch_size = batch_size_1\n    temp = jt.zeros([batch_size, (N + M) * 2], pc1.dtype)\n    match = jt.code(shape=[batch_size, M, N], dtype=pc1.dtype, inputs=[pc1, pc2, temp], cuda_header=EMD_gpu_header, cuda_src=approxmatch_gpu_src)\n    emd = jt.code(shape=[batch_size], dtype=pc1.dtype, inputs=[pc1, pc2, match], cuda_header=EMD_gpu_header, cuda_src=matchcost_gpu_src)\n    self.saved_vars = (pc1, pc2, match, reduction)\n    if reduction is None:\n        return emd\n    elif reduction == 'sum':\n        return emd.sum()\n    elif reduction == 'mean':\n        return emd.mean()",
            "def execute(self, pc1, pc2, reduction='mean', dims='BNC'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    assert dims in ['BNC', 'BCN']\n    if dims == 'BCN':\n        (pc1, pc2) = (pc1.permute(0, 2, 1), pc2.permute(0, 2, 1))\n    (batch_size_1, N, _) = pc1.shape\n    (batch_size_2, M, _) = pc2.shape\n    assert batch_size_1 == batch_size_2\n    batch_size = batch_size_1\n    temp = jt.zeros([batch_size, (N + M) * 2], pc1.dtype)\n    match = jt.code(shape=[batch_size, M, N], dtype=pc1.dtype, inputs=[pc1, pc2, temp], cuda_header=EMD_gpu_header, cuda_src=approxmatch_gpu_src)\n    emd = jt.code(shape=[batch_size], dtype=pc1.dtype, inputs=[pc1, pc2, match], cuda_header=EMD_gpu_header, cuda_src=matchcost_gpu_src)\n    self.saved_vars = (pc1, pc2, match, reduction)\n    if reduction is None:\n        return emd\n    elif reduction == 'sum':\n        return emd.sum()\n    elif reduction == 'mean':\n        return emd.mean()",
            "def execute(self, pc1, pc2, reduction='mean', dims='BNC'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    assert dims in ['BNC', 'BCN']\n    if dims == 'BCN':\n        (pc1, pc2) = (pc1.permute(0, 2, 1), pc2.permute(0, 2, 1))\n    (batch_size_1, N, _) = pc1.shape\n    (batch_size_2, M, _) = pc2.shape\n    assert batch_size_1 == batch_size_2\n    batch_size = batch_size_1\n    temp = jt.zeros([batch_size, (N + M) * 2], pc1.dtype)\n    match = jt.code(shape=[batch_size, M, N], dtype=pc1.dtype, inputs=[pc1, pc2, temp], cuda_header=EMD_gpu_header, cuda_src=approxmatch_gpu_src)\n    emd = jt.code(shape=[batch_size], dtype=pc1.dtype, inputs=[pc1, pc2, match], cuda_header=EMD_gpu_header, cuda_src=matchcost_gpu_src)\n    self.saved_vars = (pc1, pc2, match, reduction)\n    if reduction is None:\n        return emd\n    elif reduction == 'sum':\n        return emd.sum()\n    elif reduction == 'mean':\n        return emd.mean()",
            "def execute(self, pc1, pc2, reduction='mean', dims='BNC'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    assert dims in ['BNC', 'BCN']\n    if dims == 'BCN':\n        (pc1, pc2) = (pc1.permute(0, 2, 1), pc2.permute(0, 2, 1))\n    (batch_size_1, N, _) = pc1.shape\n    (batch_size_2, M, _) = pc2.shape\n    assert batch_size_1 == batch_size_2\n    batch_size = batch_size_1\n    temp = jt.zeros([batch_size, (N + M) * 2], pc1.dtype)\n    match = jt.code(shape=[batch_size, M, N], dtype=pc1.dtype, inputs=[pc1, pc2, temp], cuda_header=EMD_gpu_header, cuda_src=approxmatch_gpu_src)\n    emd = jt.code(shape=[batch_size], dtype=pc1.dtype, inputs=[pc1, pc2, match], cuda_header=EMD_gpu_header, cuda_src=matchcost_gpu_src)\n    self.saved_vars = (pc1, pc2, match, reduction)\n    if reduction is None:\n        return emd\n    elif reduction == 'sum':\n        return emd.sum()\n    elif reduction == 'mean':\n        return emd.mean()",
            "def execute(self, pc1, pc2, reduction='mean', dims='BNC'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    assert dims in ['BNC', 'BCN']\n    if dims == 'BCN':\n        (pc1, pc2) = (pc1.permute(0, 2, 1), pc2.permute(0, 2, 1))\n    (batch_size_1, N, _) = pc1.shape\n    (batch_size_2, M, _) = pc2.shape\n    assert batch_size_1 == batch_size_2\n    batch_size = batch_size_1\n    temp = jt.zeros([batch_size, (N + M) * 2], pc1.dtype)\n    match = jt.code(shape=[batch_size, M, N], dtype=pc1.dtype, inputs=[pc1, pc2, temp], cuda_header=EMD_gpu_header, cuda_src=approxmatch_gpu_src)\n    emd = jt.code(shape=[batch_size], dtype=pc1.dtype, inputs=[pc1, pc2, match], cuda_header=EMD_gpu_header, cuda_src=matchcost_gpu_src)\n    self.saved_vars = (pc1, pc2, match, reduction)\n    if reduction is None:\n        return emd\n    elif reduction == 'sum':\n        return emd.sum()\n    elif reduction == 'mean':\n        return emd.mean()"
        ]
    },
    {
        "func_name": "grad",
        "original": "def grad(self, grad):\n    (pc1, pc2, match, reduction) = self.saved_vars\n    if reduction == 'sum':\n        grad = jt.ones([pc1.shape[0]]) * grad\n    elif reduction == 'mean':\n        grad = jt.ones([pc1.shape[0]]) * grad / pc1.shape[0]\n    grad_pc1 = jt.code(shape=pc1.shape, dtype=pc1.dtype, inputs=[grad, pc1, pc2, match], cuda_src=matchcost_grad1_gpu_src)\n    grad_pc2 = jt.code(shape=pc2.shape, dtype=pc2.dtype, inputs=[grad, pc1, pc2, match], cuda_src=matchcost_grad2_gpu_src)\n    return (grad_pc1, grad_pc2)",
        "mutated": [
            "def grad(self, grad):\n    if False:\n        i = 10\n    (pc1, pc2, match, reduction) = self.saved_vars\n    if reduction == 'sum':\n        grad = jt.ones([pc1.shape[0]]) * grad\n    elif reduction == 'mean':\n        grad = jt.ones([pc1.shape[0]]) * grad / pc1.shape[0]\n    grad_pc1 = jt.code(shape=pc1.shape, dtype=pc1.dtype, inputs=[grad, pc1, pc2, match], cuda_src=matchcost_grad1_gpu_src)\n    grad_pc2 = jt.code(shape=pc2.shape, dtype=pc2.dtype, inputs=[grad, pc1, pc2, match], cuda_src=matchcost_grad2_gpu_src)\n    return (grad_pc1, grad_pc2)",
            "def grad(self, grad):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (pc1, pc2, match, reduction) = self.saved_vars\n    if reduction == 'sum':\n        grad = jt.ones([pc1.shape[0]]) * grad\n    elif reduction == 'mean':\n        grad = jt.ones([pc1.shape[0]]) * grad / pc1.shape[0]\n    grad_pc1 = jt.code(shape=pc1.shape, dtype=pc1.dtype, inputs=[grad, pc1, pc2, match], cuda_src=matchcost_grad1_gpu_src)\n    grad_pc2 = jt.code(shape=pc2.shape, dtype=pc2.dtype, inputs=[grad, pc1, pc2, match], cuda_src=matchcost_grad2_gpu_src)\n    return (grad_pc1, grad_pc2)",
            "def grad(self, grad):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (pc1, pc2, match, reduction) = self.saved_vars\n    if reduction == 'sum':\n        grad = jt.ones([pc1.shape[0]]) * grad\n    elif reduction == 'mean':\n        grad = jt.ones([pc1.shape[0]]) * grad / pc1.shape[0]\n    grad_pc1 = jt.code(shape=pc1.shape, dtype=pc1.dtype, inputs=[grad, pc1, pc2, match], cuda_src=matchcost_grad1_gpu_src)\n    grad_pc2 = jt.code(shape=pc2.shape, dtype=pc2.dtype, inputs=[grad, pc1, pc2, match], cuda_src=matchcost_grad2_gpu_src)\n    return (grad_pc1, grad_pc2)",
            "def grad(self, grad):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (pc1, pc2, match, reduction) = self.saved_vars\n    if reduction == 'sum':\n        grad = jt.ones([pc1.shape[0]]) * grad\n    elif reduction == 'mean':\n        grad = jt.ones([pc1.shape[0]]) * grad / pc1.shape[0]\n    grad_pc1 = jt.code(shape=pc1.shape, dtype=pc1.dtype, inputs=[grad, pc1, pc2, match], cuda_src=matchcost_grad1_gpu_src)\n    grad_pc2 = jt.code(shape=pc2.shape, dtype=pc2.dtype, inputs=[grad, pc1, pc2, match], cuda_src=matchcost_grad2_gpu_src)\n    return (grad_pc1, grad_pc2)",
            "def grad(self, grad):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (pc1, pc2, match, reduction) = self.saved_vars\n    if reduction == 'sum':\n        grad = jt.ones([pc1.shape[0]]) * grad\n    elif reduction == 'mean':\n        grad = jt.ones([pc1.shape[0]]) * grad / pc1.shape[0]\n    grad_pc1 = jt.code(shape=pc1.shape, dtype=pc1.dtype, inputs=[grad, pc1, pc2, match], cuda_src=matchcost_grad1_gpu_src)\n    grad_pc2 = jt.code(shape=pc2.shape, dtype=pc2.dtype, inputs=[grad, pc1, pc2, match], cuda_src=matchcost_grad2_gpu_src)\n    return (grad_pc1, grad_pc2)"
        ]
    },
    {
        "func_name": "earth_mover_distance",
        "original": "def earth_mover_distance(pc1, pc2, reduction='mean', dims='BNC'):\n    \"\"\" Earth Mover's distance from pc1 to pc2. Only supports GPU.\n\n    :param pc1:  input point cloud\n    :type pc1: jittor array\n\n    :param pc2:  input point cloud\n    :type pc2: jittor array\n\n    :param reduction: reduction method in batches, can be 'mean', 'sum', or None. Default: 'mean'.\n    :type reduction: str, optional\n            \n    :param dims: a string that represents each dimension, can be\n            '[BNC]' ([batch, number of points, xyz]), or\n            '[BCN]' ([batch, xyz, number of points]). Default: 'BNC'.\n    :type dims: str, optional\n\n\n    Example:\n\n    >>> import jittor as jt\n    >>> from jittor.loss3d import earth_mover_distance\n    >>> jt.flags.use_cuda = True\n    >>> pc1 = jt.rand([10, 100, 3], dtype=jt.float32)\n    >>> pc2 = jt.rand([10, 100, 3], dtype=jt.float32)\n    >>> emd = earth_mover_distance(pc1, pc2, dims='BNC')\n    >>> print('EMD =', emd.item())\n    \"\"\"\n    return EarthMoverDistance.apply(pc1, pc2, reduction, dims)",
        "mutated": [
            "def earth_mover_distance(pc1, pc2, reduction='mean', dims='BNC'):\n    if False:\n        i = 10\n    \" Earth Mover's distance from pc1 to pc2. Only supports GPU.\\n\\n    :param pc1:  input point cloud\\n    :type pc1: jittor array\\n\\n    :param pc2:  input point cloud\\n    :type pc2: jittor array\\n\\n    :param reduction: reduction method in batches, can be 'mean', 'sum', or None. Default: 'mean'.\\n    :type reduction: str, optional\\n            \\n    :param dims: a string that represents each dimension, can be\\n            '[BNC]' ([batch, number of points, xyz]), or\\n            '[BCN]' ([batch, xyz, number of points]). Default: 'BNC'.\\n    :type dims: str, optional\\n\\n\\n    Example:\\n\\n    >>> import jittor as jt\\n    >>> from jittor.loss3d import earth_mover_distance\\n    >>> jt.flags.use_cuda = True\\n    >>> pc1 = jt.rand([10, 100, 3], dtype=jt.float32)\\n    >>> pc2 = jt.rand([10, 100, 3], dtype=jt.float32)\\n    >>> emd = earth_mover_distance(pc1, pc2, dims='BNC')\\n    >>> print('EMD =', emd.item())\\n    \"\n    return EarthMoverDistance.apply(pc1, pc2, reduction, dims)",
            "def earth_mover_distance(pc1, pc2, reduction='mean', dims='BNC'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \" Earth Mover's distance from pc1 to pc2. Only supports GPU.\\n\\n    :param pc1:  input point cloud\\n    :type pc1: jittor array\\n\\n    :param pc2:  input point cloud\\n    :type pc2: jittor array\\n\\n    :param reduction: reduction method in batches, can be 'mean', 'sum', or None. Default: 'mean'.\\n    :type reduction: str, optional\\n            \\n    :param dims: a string that represents each dimension, can be\\n            '[BNC]' ([batch, number of points, xyz]), or\\n            '[BCN]' ([batch, xyz, number of points]). Default: 'BNC'.\\n    :type dims: str, optional\\n\\n\\n    Example:\\n\\n    >>> import jittor as jt\\n    >>> from jittor.loss3d import earth_mover_distance\\n    >>> jt.flags.use_cuda = True\\n    >>> pc1 = jt.rand([10, 100, 3], dtype=jt.float32)\\n    >>> pc2 = jt.rand([10, 100, 3], dtype=jt.float32)\\n    >>> emd = earth_mover_distance(pc1, pc2, dims='BNC')\\n    >>> print('EMD =', emd.item())\\n    \"\n    return EarthMoverDistance.apply(pc1, pc2, reduction, dims)",
            "def earth_mover_distance(pc1, pc2, reduction='mean', dims='BNC'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \" Earth Mover's distance from pc1 to pc2. Only supports GPU.\\n\\n    :param pc1:  input point cloud\\n    :type pc1: jittor array\\n\\n    :param pc2:  input point cloud\\n    :type pc2: jittor array\\n\\n    :param reduction: reduction method in batches, can be 'mean', 'sum', or None. Default: 'mean'.\\n    :type reduction: str, optional\\n            \\n    :param dims: a string that represents each dimension, can be\\n            '[BNC]' ([batch, number of points, xyz]), or\\n            '[BCN]' ([batch, xyz, number of points]). Default: 'BNC'.\\n    :type dims: str, optional\\n\\n\\n    Example:\\n\\n    >>> import jittor as jt\\n    >>> from jittor.loss3d import earth_mover_distance\\n    >>> jt.flags.use_cuda = True\\n    >>> pc1 = jt.rand([10, 100, 3], dtype=jt.float32)\\n    >>> pc2 = jt.rand([10, 100, 3], dtype=jt.float32)\\n    >>> emd = earth_mover_distance(pc1, pc2, dims='BNC')\\n    >>> print('EMD =', emd.item())\\n    \"\n    return EarthMoverDistance.apply(pc1, pc2, reduction, dims)",
            "def earth_mover_distance(pc1, pc2, reduction='mean', dims='BNC'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \" Earth Mover's distance from pc1 to pc2. Only supports GPU.\\n\\n    :param pc1:  input point cloud\\n    :type pc1: jittor array\\n\\n    :param pc2:  input point cloud\\n    :type pc2: jittor array\\n\\n    :param reduction: reduction method in batches, can be 'mean', 'sum', or None. Default: 'mean'.\\n    :type reduction: str, optional\\n            \\n    :param dims: a string that represents each dimension, can be\\n            '[BNC]' ([batch, number of points, xyz]), or\\n            '[BCN]' ([batch, xyz, number of points]). Default: 'BNC'.\\n    :type dims: str, optional\\n\\n\\n    Example:\\n\\n    >>> import jittor as jt\\n    >>> from jittor.loss3d import earth_mover_distance\\n    >>> jt.flags.use_cuda = True\\n    >>> pc1 = jt.rand([10, 100, 3], dtype=jt.float32)\\n    >>> pc2 = jt.rand([10, 100, 3], dtype=jt.float32)\\n    >>> emd = earth_mover_distance(pc1, pc2, dims='BNC')\\n    >>> print('EMD =', emd.item())\\n    \"\n    return EarthMoverDistance.apply(pc1, pc2, reduction, dims)",
            "def earth_mover_distance(pc1, pc2, reduction='mean', dims='BNC'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \" Earth Mover's distance from pc1 to pc2. Only supports GPU.\\n\\n    :param pc1:  input point cloud\\n    :type pc1: jittor array\\n\\n    :param pc2:  input point cloud\\n    :type pc2: jittor array\\n\\n    :param reduction: reduction method in batches, can be 'mean', 'sum', or None. Default: 'mean'.\\n    :type reduction: str, optional\\n            \\n    :param dims: a string that represents each dimension, can be\\n            '[BNC]' ([batch, number of points, xyz]), or\\n            '[BCN]' ([batch, xyz, number of points]). Default: 'BNC'.\\n    :type dims: str, optional\\n\\n\\n    Example:\\n\\n    >>> import jittor as jt\\n    >>> from jittor.loss3d import earth_mover_distance\\n    >>> jt.flags.use_cuda = True\\n    >>> pc1 = jt.rand([10, 100, 3], dtype=jt.float32)\\n    >>> pc2 = jt.rand([10, 100, 3], dtype=jt.float32)\\n    >>> emd = earth_mover_distance(pc1, pc2, dims='BNC')\\n    >>> print('EMD =', emd.item())\\n    \"\n    return EarthMoverDistance.apply(pc1, pc2, reduction, dims)"
        ]
    }
]