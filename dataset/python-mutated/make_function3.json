[
    {
        "func_name": "build_param",
        "original": "def build_param(ast, name, default):\n    \"\"\"build parameters:\n            - handle defaults\n            - handle format tuple parameters\n        \"\"\"\n    if default:\n        value = self.traverse(default, indent='')\n        maybe_show_tree_param_default(self, name, value)\n        result = '%s=%s' % (name, value)\n        if result[-2:] == '= ':\n            result += 'None'\n        return result\n    else:\n        return name",
        "mutated": [
            "def build_param(ast, name, default):\n    if False:\n        i = 10\n    'build parameters:\\n            - handle defaults\\n            - handle format tuple parameters\\n        '\n    if default:\n        value = self.traverse(default, indent='')\n        maybe_show_tree_param_default(self, name, value)\n        result = '%s=%s' % (name, value)\n        if result[-2:] == '= ':\n            result += 'None'\n        return result\n    else:\n        return name",
            "def build_param(ast, name, default):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'build parameters:\\n            - handle defaults\\n            - handle format tuple parameters\\n        '\n    if default:\n        value = self.traverse(default, indent='')\n        maybe_show_tree_param_default(self, name, value)\n        result = '%s=%s' % (name, value)\n        if result[-2:] == '= ':\n            result += 'None'\n        return result\n    else:\n        return name",
            "def build_param(ast, name, default):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'build parameters:\\n            - handle defaults\\n            - handle format tuple parameters\\n        '\n    if default:\n        value = self.traverse(default, indent='')\n        maybe_show_tree_param_default(self, name, value)\n        result = '%s=%s' % (name, value)\n        if result[-2:] == '= ':\n            result += 'None'\n        return result\n    else:\n        return name",
            "def build_param(ast, name, default):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'build parameters:\\n            - handle defaults\\n            - handle format tuple parameters\\n        '\n    if default:\n        value = self.traverse(default, indent='')\n        maybe_show_tree_param_default(self, name, value)\n        result = '%s=%s' % (name, value)\n        if result[-2:] == '= ':\n            result += 'None'\n        return result\n    else:\n        return name",
            "def build_param(ast, name, default):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'build parameters:\\n            - handle defaults\\n            - handle format tuple parameters\\n        '\n    if default:\n        value = self.traverse(default, indent='')\n        maybe_show_tree_param_default(self, name, value)\n        result = '%s=%s' % (name, value)\n        if result[-2:] == '= ':\n            result += 'None'\n        return result\n    else:\n        return name"
        ]
    },
    {
        "func_name": "make_function3_annotate",
        "original": "def make_function3_annotate(self, node, is_lambda, nested=1, code_node=None, annotate_last=-1):\n    \"\"\"\n    Dump function defintion, doc string, and function\n    body. This code is specialized for Python 3\"\"\"\n\n    def build_param(ast, name, default):\n        \"\"\"build parameters:\n            - handle defaults\n            - handle format tuple parameters\n        \"\"\"\n        if default:\n            value = self.traverse(default, indent='')\n            maybe_show_tree_param_default(self, name, value)\n            result = '%s=%s' % (name, value)\n            if result[-2:] == '= ':\n                result += 'None'\n            return result\n        else:\n            return name\n    assert node[-1].kind.startswith('MAKE_')\n    annotate_tuple = None\n    for annotate_last in range(len(node) - 1, -1, -1):\n        if node[annotate_last] == 'annotate_tuple':\n            annotate_tuple = node[annotate_last]\n            break\n    annotate_args = {}\n    if annotate_tuple == 'annotate_tuple' and annotate_tuple[0] in ('LOAD_CONST', 'LOAD_NAME') and isinstance(annotate_tuple[0].attr, tuple):\n        annotate_tup = annotate_tuple[0].attr\n        i = -1\n        j = annotate_last - 1\n        l = -len(node)\n        while j >= l and node[j].kind in ('annotate_arg', 'annotate_tuple'):\n            annotate_args[annotate_tup[i]] = node[j][0]\n            i -= 1\n            j -= 1\n    args_node = node[-1]\n    if isinstance(args_node.attr, tuple):\n        defparams = node[:args_node.attr[0]]\n        (pos_args, kw_args, annotate_argc) = args_node.attr\n    else:\n        defparams = node[:args_node.attr]\n        kw_args = 0\n        pass\n    annotate_dict = {}\n    for name in annotate_args.keys():\n        n = self.traverse(annotate_args[name], indent='')\n        annotate_dict[name] = n\n    if (3, 0) <= self.version < (3, 3):\n        lambda_index = -2\n    elif self.version < (3, 4):\n        lambda_index = -3\n    else:\n        lambda_index = None\n    if lambda_index and is_lambda and iscode(node[lambda_index].attr):\n        assert node[lambda_index].kind == 'LOAD_LAMBDA'\n        code = node[lambda_index].attr\n    else:\n        code = code_node.attr\n    assert iscode(code)\n    code = Code(code, self.scanner, self.currentclass)\n    argc = code.co_argcount\n    kwonlyargcount = code.co_kwonlyargcount\n    paramnames = list(code.co_varnames[:argc])\n    if kwonlyargcount > 0:\n        kwargs = list(code.co_varnames[argc:argc + kwonlyargcount])\n    try:\n        ast = self.build_ast(code._tokens, code._customize, code, is_lambda=is_lambda, noneInNames='None' in code.co_names)\n    except (ParserError, ParserError2) as p:\n        self.write(str(p))\n        if not self.tolerate_errors:\n            self.ERROR = p\n        return\n    indent = self.indent\n    if is_lambda:\n        self.write('lambda ')\n    else:\n        self.write('(')\n    last_line = self.f.getvalue().split('\\n')[-1]\n    l = len(last_line)\n    indent = ' ' * l\n    line_number = self.line_number\n    i = len(paramnames) - len(defparams)\n    suffix = ''\n    for param in paramnames[:i]:\n        self.write(suffix, param)\n        suffix = ', '\n        if param in annotate_dict:\n            self.write(': %s' % annotate_dict[param])\n            if line_number != self.line_number:\n                suffix = ',\\n' + indent\n                line_number = self.line_number\n    suffix = ', ' if i > 0 else ''\n    for n in node:\n        if n == 'pos_arg':\n            self.write(suffix)\n            param = paramnames[i]\n            self.write(param)\n            if param in annotate_args:\n                aa = annotate_args[param]\n                if isinstance(aa, tuple):\n                    aa = aa[0]\n                    self.write(': \"%s\"' % aa)\n                elif isinstance(aa, SyntaxTree):\n                    self.write(': ')\n                    self.preorder(aa)\n            self.write('=')\n            i += 1\n            self.preorder(n)\n            if line_number != self.line_number:\n                suffix = ',\\n' + indent\n                line_number = self.line_number\n            else:\n                suffix = ', '\n    if code_has_star_arg(code):\n        star_arg = code.co_varnames[argc + kwonlyargcount]\n        if annotate_dict and star_arg in annotate_dict:\n            self.write(suffix, '*%s: %s' % (star_arg, annotate_dict[star_arg]))\n        else:\n            self.write(suffix, '*%s' % star_arg)\n        argc += 1\n    ends_in_comma = False\n    if kwonlyargcount > 0:\n        if not code_has_star_arg(code):\n            if argc > 0:\n                self.write(', *, ')\n            else:\n                self.write('*, ')\n            pass\n            ends_in_comma = True\n        elif argc > 0:\n            self.write(', ')\n            ends_in_comma = True\n        kw_args = [None] * kwonlyargcount\n        for n in node:\n            if n == 'kwargs':\n                n = n[0]\n            if n == 'kwarg':\n                name = eval(n[0].pattr)\n                idx = kwargs.index(name)\n                default = self.traverse(n[1], indent='')\n                if annotate_dict and name in annotate_dict:\n                    kw_args[idx] = '%s: %s=%s' % (name, annotate_dict[name], default)\n                else:\n                    kw_args[idx] = '%s=%s' % (name, default)\n                pass\n            pass\n        other_kw = [c == None for c in kw_args]\n        for (i, flag) in enumerate(other_kw):\n            if flag:\n                n = kwargs[i]\n                if n in annotate_dict:\n                    kw_args[i] = '%s: %s' % (n, annotate_dict[n])\n                else:\n                    kw_args[i] = '%s' % n\n        self.write(', '.join(kw_args))\n        ends_in_comma = False\n    elif argc == 0:\n        ends_in_comma = True\n    if code_has_star_star_arg(code):\n        if not ends_in_comma:\n            self.write(', ')\n        star_star_arg = code.co_varnames[argc + kwonlyargcount]\n        if annotate_dict and star_star_arg in annotate_dict:\n            self.write('**%s: %s' % (star_star_arg, annotate_dict[star_star_arg]))\n        else:\n            self.write('**%s' % star_star_arg)\n    if is_lambda:\n        self.write(': ')\n    else:\n        self.write(')')\n        if 'return' in annotate_tuple[0].attr:\n            if line_number != self.line_number and (not no_paramnames):\n                self.write('\\n' + indent)\n                line_number = self.line_number\n            self.write(' -> ')\n            if 'return' in annotate_dict:\n                self.write(annotate_dict['return'])\n            else:\n                self.preorder(node[annotate_last - 1])\n        self.println(':')\n    if len(code.co_consts) > 0 and code.co_consts[0] is not None and (not is_lambda):\n        print_docstring(self, self.indent, code.co_consts[0])\n    code._tokens = None\n    assert ast == 'stmts'\n    all_globals = find_all_globals(ast, set())\n    (globals, nonlocals) = find_globals_and_nonlocals(ast, set(), set(), code, self.version)\n    for g in sorted(all_globals & self.mod_globs | globals):\n        self.println(self.indent, 'global ', g)\n    for nl in sorted(nonlocals):\n        self.println(self.indent, 'nonlocal ', nl)\n    self.mod_globs -= all_globals\n    has_none = 'None' in code.co_names\n    rn = has_none and (not find_none(ast))\n    self.gen_source(ast, code.co_name, code._customize, is_lambda=is_lambda, returnNone=rn)\n    code._tokens = code._customize = None",
        "mutated": [
            "def make_function3_annotate(self, node, is_lambda, nested=1, code_node=None, annotate_last=-1):\n    if False:\n        i = 10\n    '\\n    Dump function defintion, doc string, and function\\n    body. This code is specialized for Python 3'\n\n    def build_param(ast, name, default):\n        \"\"\"build parameters:\n            - handle defaults\n            - handle format tuple parameters\n        \"\"\"\n        if default:\n            value = self.traverse(default, indent='')\n            maybe_show_tree_param_default(self, name, value)\n            result = '%s=%s' % (name, value)\n            if result[-2:] == '= ':\n                result += 'None'\n            return result\n        else:\n            return name\n    assert node[-1].kind.startswith('MAKE_')\n    annotate_tuple = None\n    for annotate_last in range(len(node) - 1, -1, -1):\n        if node[annotate_last] == 'annotate_tuple':\n            annotate_tuple = node[annotate_last]\n            break\n    annotate_args = {}\n    if annotate_tuple == 'annotate_tuple' and annotate_tuple[0] in ('LOAD_CONST', 'LOAD_NAME') and isinstance(annotate_tuple[0].attr, tuple):\n        annotate_tup = annotate_tuple[0].attr\n        i = -1\n        j = annotate_last - 1\n        l = -len(node)\n        while j >= l and node[j].kind in ('annotate_arg', 'annotate_tuple'):\n            annotate_args[annotate_tup[i]] = node[j][0]\n            i -= 1\n            j -= 1\n    args_node = node[-1]\n    if isinstance(args_node.attr, tuple):\n        defparams = node[:args_node.attr[0]]\n        (pos_args, kw_args, annotate_argc) = args_node.attr\n    else:\n        defparams = node[:args_node.attr]\n        kw_args = 0\n        pass\n    annotate_dict = {}\n    for name in annotate_args.keys():\n        n = self.traverse(annotate_args[name], indent='')\n        annotate_dict[name] = n\n    if (3, 0) <= self.version < (3, 3):\n        lambda_index = -2\n    elif self.version < (3, 4):\n        lambda_index = -3\n    else:\n        lambda_index = None\n    if lambda_index and is_lambda and iscode(node[lambda_index].attr):\n        assert node[lambda_index].kind == 'LOAD_LAMBDA'\n        code = node[lambda_index].attr\n    else:\n        code = code_node.attr\n    assert iscode(code)\n    code = Code(code, self.scanner, self.currentclass)\n    argc = code.co_argcount\n    kwonlyargcount = code.co_kwonlyargcount\n    paramnames = list(code.co_varnames[:argc])\n    if kwonlyargcount > 0:\n        kwargs = list(code.co_varnames[argc:argc + kwonlyargcount])\n    try:\n        ast = self.build_ast(code._tokens, code._customize, code, is_lambda=is_lambda, noneInNames='None' in code.co_names)\n    except (ParserError, ParserError2) as p:\n        self.write(str(p))\n        if not self.tolerate_errors:\n            self.ERROR = p\n        return\n    indent = self.indent\n    if is_lambda:\n        self.write('lambda ')\n    else:\n        self.write('(')\n    last_line = self.f.getvalue().split('\\n')[-1]\n    l = len(last_line)\n    indent = ' ' * l\n    line_number = self.line_number\n    i = len(paramnames) - len(defparams)\n    suffix = ''\n    for param in paramnames[:i]:\n        self.write(suffix, param)\n        suffix = ', '\n        if param in annotate_dict:\n            self.write(': %s' % annotate_dict[param])\n            if line_number != self.line_number:\n                suffix = ',\\n' + indent\n                line_number = self.line_number\n    suffix = ', ' if i > 0 else ''\n    for n in node:\n        if n == 'pos_arg':\n            self.write(suffix)\n            param = paramnames[i]\n            self.write(param)\n            if param in annotate_args:\n                aa = annotate_args[param]\n                if isinstance(aa, tuple):\n                    aa = aa[0]\n                    self.write(': \"%s\"' % aa)\n                elif isinstance(aa, SyntaxTree):\n                    self.write(': ')\n                    self.preorder(aa)\n            self.write('=')\n            i += 1\n            self.preorder(n)\n            if line_number != self.line_number:\n                suffix = ',\\n' + indent\n                line_number = self.line_number\n            else:\n                suffix = ', '\n    if code_has_star_arg(code):\n        star_arg = code.co_varnames[argc + kwonlyargcount]\n        if annotate_dict and star_arg in annotate_dict:\n            self.write(suffix, '*%s: %s' % (star_arg, annotate_dict[star_arg]))\n        else:\n            self.write(suffix, '*%s' % star_arg)\n        argc += 1\n    ends_in_comma = False\n    if kwonlyargcount > 0:\n        if not code_has_star_arg(code):\n            if argc > 0:\n                self.write(', *, ')\n            else:\n                self.write('*, ')\n            pass\n            ends_in_comma = True\n        elif argc > 0:\n            self.write(', ')\n            ends_in_comma = True\n        kw_args = [None] * kwonlyargcount\n        for n in node:\n            if n == 'kwargs':\n                n = n[0]\n            if n == 'kwarg':\n                name = eval(n[0].pattr)\n                idx = kwargs.index(name)\n                default = self.traverse(n[1], indent='')\n                if annotate_dict and name in annotate_dict:\n                    kw_args[idx] = '%s: %s=%s' % (name, annotate_dict[name], default)\n                else:\n                    kw_args[idx] = '%s=%s' % (name, default)\n                pass\n            pass\n        other_kw = [c == None for c in kw_args]\n        for (i, flag) in enumerate(other_kw):\n            if flag:\n                n = kwargs[i]\n                if n in annotate_dict:\n                    kw_args[i] = '%s: %s' % (n, annotate_dict[n])\n                else:\n                    kw_args[i] = '%s' % n\n        self.write(', '.join(kw_args))\n        ends_in_comma = False\n    elif argc == 0:\n        ends_in_comma = True\n    if code_has_star_star_arg(code):\n        if not ends_in_comma:\n            self.write(', ')\n        star_star_arg = code.co_varnames[argc + kwonlyargcount]\n        if annotate_dict and star_star_arg in annotate_dict:\n            self.write('**%s: %s' % (star_star_arg, annotate_dict[star_star_arg]))\n        else:\n            self.write('**%s' % star_star_arg)\n    if is_lambda:\n        self.write(': ')\n    else:\n        self.write(')')\n        if 'return' in annotate_tuple[0].attr:\n            if line_number != self.line_number and (not no_paramnames):\n                self.write('\\n' + indent)\n                line_number = self.line_number\n            self.write(' -> ')\n            if 'return' in annotate_dict:\n                self.write(annotate_dict['return'])\n            else:\n                self.preorder(node[annotate_last - 1])\n        self.println(':')\n    if len(code.co_consts) > 0 and code.co_consts[0] is not None and (not is_lambda):\n        print_docstring(self, self.indent, code.co_consts[0])\n    code._tokens = None\n    assert ast == 'stmts'\n    all_globals = find_all_globals(ast, set())\n    (globals, nonlocals) = find_globals_and_nonlocals(ast, set(), set(), code, self.version)\n    for g in sorted(all_globals & self.mod_globs | globals):\n        self.println(self.indent, 'global ', g)\n    for nl in sorted(nonlocals):\n        self.println(self.indent, 'nonlocal ', nl)\n    self.mod_globs -= all_globals\n    has_none = 'None' in code.co_names\n    rn = has_none and (not find_none(ast))\n    self.gen_source(ast, code.co_name, code._customize, is_lambda=is_lambda, returnNone=rn)\n    code._tokens = code._customize = None",
            "def make_function3_annotate(self, node, is_lambda, nested=1, code_node=None, annotate_last=-1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Dump function defintion, doc string, and function\\n    body. This code is specialized for Python 3'\n\n    def build_param(ast, name, default):\n        \"\"\"build parameters:\n            - handle defaults\n            - handle format tuple parameters\n        \"\"\"\n        if default:\n            value = self.traverse(default, indent='')\n            maybe_show_tree_param_default(self, name, value)\n            result = '%s=%s' % (name, value)\n            if result[-2:] == '= ':\n                result += 'None'\n            return result\n        else:\n            return name\n    assert node[-1].kind.startswith('MAKE_')\n    annotate_tuple = None\n    for annotate_last in range(len(node) - 1, -1, -1):\n        if node[annotate_last] == 'annotate_tuple':\n            annotate_tuple = node[annotate_last]\n            break\n    annotate_args = {}\n    if annotate_tuple == 'annotate_tuple' and annotate_tuple[0] in ('LOAD_CONST', 'LOAD_NAME') and isinstance(annotate_tuple[0].attr, tuple):\n        annotate_tup = annotate_tuple[0].attr\n        i = -1\n        j = annotate_last - 1\n        l = -len(node)\n        while j >= l and node[j].kind in ('annotate_arg', 'annotate_tuple'):\n            annotate_args[annotate_tup[i]] = node[j][0]\n            i -= 1\n            j -= 1\n    args_node = node[-1]\n    if isinstance(args_node.attr, tuple):\n        defparams = node[:args_node.attr[0]]\n        (pos_args, kw_args, annotate_argc) = args_node.attr\n    else:\n        defparams = node[:args_node.attr]\n        kw_args = 0\n        pass\n    annotate_dict = {}\n    for name in annotate_args.keys():\n        n = self.traverse(annotate_args[name], indent='')\n        annotate_dict[name] = n\n    if (3, 0) <= self.version < (3, 3):\n        lambda_index = -2\n    elif self.version < (3, 4):\n        lambda_index = -3\n    else:\n        lambda_index = None\n    if lambda_index and is_lambda and iscode(node[lambda_index].attr):\n        assert node[lambda_index].kind == 'LOAD_LAMBDA'\n        code = node[lambda_index].attr\n    else:\n        code = code_node.attr\n    assert iscode(code)\n    code = Code(code, self.scanner, self.currentclass)\n    argc = code.co_argcount\n    kwonlyargcount = code.co_kwonlyargcount\n    paramnames = list(code.co_varnames[:argc])\n    if kwonlyargcount > 0:\n        kwargs = list(code.co_varnames[argc:argc + kwonlyargcount])\n    try:\n        ast = self.build_ast(code._tokens, code._customize, code, is_lambda=is_lambda, noneInNames='None' in code.co_names)\n    except (ParserError, ParserError2) as p:\n        self.write(str(p))\n        if not self.tolerate_errors:\n            self.ERROR = p\n        return\n    indent = self.indent\n    if is_lambda:\n        self.write('lambda ')\n    else:\n        self.write('(')\n    last_line = self.f.getvalue().split('\\n')[-1]\n    l = len(last_line)\n    indent = ' ' * l\n    line_number = self.line_number\n    i = len(paramnames) - len(defparams)\n    suffix = ''\n    for param in paramnames[:i]:\n        self.write(suffix, param)\n        suffix = ', '\n        if param in annotate_dict:\n            self.write(': %s' % annotate_dict[param])\n            if line_number != self.line_number:\n                suffix = ',\\n' + indent\n                line_number = self.line_number\n    suffix = ', ' if i > 0 else ''\n    for n in node:\n        if n == 'pos_arg':\n            self.write(suffix)\n            param = paramnames[i]\n            self.write(param)\n            if param in annotate_args:\n                aa = annotate_args[param]\n                if isinstance(aa, tuple):\n                    aa = aa[0]\n                    self.write(': \"%s\"' % aa)\n                elif isinstance(aa, SyntaxTree):\n                    self.write(': ')\n                    self.preorder(aa)\n            self.write('=')\n            i += 1\n            self.preorder(n)\n            if line_number != self.line_number:\n                suffix = ',\\n' + indent\n                line_number = self.line_number\n            else:\n                suffix = ', '\n    if code_has_star_arg(code):\n        star_arg = code.co_varnames[argc + kwonlyargcount]\n        if annotate_dict and star_arg in annotate_dict:\n            self.write(suffix, '*%s: %s' % (star_arg, annotate_dict[star_arg]))\n        else:\n            self.write(suffix, '*%s' % star_arg)\n        argc += 1\n    ends_in_comma = False\n    if kwonlyargcount > 0:\n        if not code_has_star_arg(code):\n            if argc > 0:\n                self.write(', *, ')\n            else:\n                self.write('*, ')\n            pass\n            ends_in_comma = True\n        elif argc > 0:\n            self.write(', ')\n            ends_in_comma = True\n        kw_args = [None] * kwonlyargcount\n        for n in node:\n            if n == 'kwargs':\n                n = n[0]\n            if n == 'kwarg':\n                name = eval(n[0].pattr)\n                idx = kwargs.index(name)\n                default = self.traverse(n[1], indent='')\n                if annotate_dict and name in annotate_dict:\n                    kw_args[idx] = '%s: %s=%s' % (name, annotate_dict[name], default)\n                else:\n                    kw_args[idx] = '%s=%s' % (name, default)\n                pass\n            pass\n        other_kw = [c == None for c in kw_args]\n        for (i, flag) in enumerate(other_kw):\n            if flag:\n                n = kwargs[i]\n                if n in annotate_dict:\n                    kw_args[i] = '%s: %s' % (n, annotate_dict[n])\n                else:\n                    kw_args[i] = '%s' % n\n        self.write(', '.join(kw_args))\n        ends_in_comma = False\n    elif argc == 0:\n        ends_in_comma = True\n    if code_has_star_star_arg(code):\n        if not ends_in_comma:\n            self.write(', ')\n        star_star_arg = code.co_varnames[argc + kwonlyargcount]\n        if annotate_dict and star_star_arg in annotate_dict:\n            self.write('**%s: %s' % (star_star_arg, annotate_dict[star_star_arg]))\n        else:\n            self.write('**%s' % star_star_arg)\n    if is_lambda:\n        self.write(': ')\n    else:\n        self.write(')')\n        if 'return' in annotate_tuple[0].attr:\n            if line_number != self.line_number and (not no_paramnames):\n                self.write('\\n' + indent)\n                line_number = self.line_number\n            self.write(' -> ')\n            if 'return' in annotate_dict:\n                self.write(annotate_dict['return'])\n            else:\n                self.preorder(node[annotate_last - 1])\n        self.println(':')\n    if len(code.co_consts) > 0 and code.co_consts[0] is not None and (not is_lambda):\n        print_docstring(self, self.indent, code.co_consts[0])\n    code._tokens = None\n    assert ast == 'stmts'\n    all_globals = find_all_globals(ast, set())\n    (globals, nonlocals) = find_globals_and_nonlocals(ast, set(), set(), code, self.version)\n    for g in sorted(all_globals & self.mod_globs | globals):\n        self.println(self.indent, 'global ', g)\n    for nl in sorted(nonlocals):\n        self.println(self.indent, 'nonlocal ', nl)\n    self.mod_globs -= all_globals\n    has_none = 'None' in code.co_names\n    rn = has_none and (not find_none(ast))\n    self.gen_source(ast, code.co_name, code._customize, is_lambda=is_lambda, returnNone=rn)\n    code._tokens = code._customize = None",
            "def make_function3_annotate(self, node, is_lambda, nested=1, code_node=None, annotate_last=-1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Dump function defintion, doc string, and function\\n    body. This code is specialized for Python 3'\n\n    def build_param(ast, name, default):\n        \"\"\"build parameters:\n            - handle defaults\n            - handle format tuple parameters\n        \"\"\"\n        if default:\n            value = self.traverse(default, indent='')\n            maybe_show_tree_param_default(self, name, value)\n            result = '%s=%s' % (name, value)\n            if result[-2:] == '= ':\n                result += 'None'\n            return result\n        else:\n            return name\n    assert node[-1].kind.startswith('MAKE_')\n    annotate_tuple = None\n    for annotate_last in range(len(node) - 1, -1, -1):\n        if node[annotate_last] == 'annotate_tuple':\n            annotate_tuple = node[annotate_last]\n            break\n    annotate_args = {}\n    if annotate_tuple == 'annotate_tuple' and annotate_tuple[0] in ('LOAD_CONST', 'LOAD_NAME') and isinstance(annotate_tuple[0].attr, tuple):\n        annotate_tup = annotate_tuple[0].attr\n        i = -1\n        j = annotate_last - 1\n        l = -len(node)\n        while j >= l and node[j].kind in ('annotate_arg', 'annotate_tuple'):\n            annotate_args[annotate_tup[i]] = node[j][0]\n            i -= 1\n            j -= 1\n    args_node = node[-1]\n    if isinstance(args_node.attr, tuple):\n        defparams = node[:args_node.attr[0]]\n        (pos_args, kw_args, annotate_argc) = args_node.attr\n    else:\n        defparams = node[:args_node.attr]\n        kw_args = 0\n        pass\n    annotate_dict = {}\n    for name in annotate_args.keys():\n        n = self.traverse(annotate_args[name], indent='')\n        annotate_dict[name] = n\n    if (3, 0) <= self.version < (3, 3):\n        lambda_index = -2\n    elif self.version < (3, 4):\n        lambda_index = -3\n    else:\n        lambda_index = None\n    if lambda_index and is_lambda and iscode(node[lambda_index].attr):\n        assert node[lambda_index].kind == 'LOAD_LAMBDA'\n        code = node[lambda_index].attr\n    else:\n        code = code_node.attr\n    assert iscode(code)\n    code = Code(code, self.scanner, self.currentclass)\n    argc = code.co_argcount\n    kwonlyargcount = code.co_kwonlyargcount\n    paramnames = list(code.co_varnames[:argc])\n    if kwonlyargcount > 0:\n        kwargs = list(code.co_varnames[argc:argc + kwonlyargcount])\n    try:\n        ast = self.build_ast(code._tokens, code._customize, code, is_lambda=is_lambda, noneInNames='None' in code.co_names)\n    except (ParserError, ParserError2) as p:\n        self.write(str(p))\n        if not self.tolerate_errors:\n            self.ERROR = p\n        return\n    indent = self.indent\n    if is_lambda:\n        self.write('lambda ')\n    else:\n        self.write('(')\n    last_line = self.f.getvalue().split('\\n')[-1]\n    l = len(last_line)\n    indent = ' ' * l\n    line_number = self.line_number\n    i = len(paramnames) - len(defparams)\n    suffix = ''\n    for param in paramnames[:i]:\n        self.write(suffix, param)\n        suffix = ', '\n        if param in annotate_dict:\n            self.write(': %s' % annotate_dict[param])\n            if line_number != self.line_number:\n                suffix = ',\\n' + indent\n                line_number = self.line_number\n    suffix = ', ' if i > 0 else ''\n    for n in node:\n        if n == 'pos_arg':\n            self.write(suffix)\n            param = paramnames[i]\n            self.write(param)\n            if param in annotate_args:\n                aa = annotate_args[param]\n                if isinstance(aa, tuple):\n                    aa = aa[0]\n                    self.write(': \"%s\"' % aa)\n                elif isinstance(aa, SyntaxTree):\n                    self.write(': ')\n                    self.preorder(aa)\n            self.write('=')\n            i += 1\n            self.preorder(n)\n            if line_number != self.line_number:\n                suffix = ',\\n' + indent\n                line_number = self.line_number\n            else:\n                suffix = ', '\n    if code_has_star_arg(code):\n        star_arg = code.co_varnames[argc + kwonlyargcount]\n        if annotate_dict and star_arg in annotate_dict:\n            self.write(suffix, '*%s: %s' % (star_arg, annotate_dict[star_arg]))\n        else:\n            self.write(suffix, '*%s' % star_arg)\n        argc += 1\n    ends_in_comma = False\n    if kwonlyargcount > 0:\n        if not code_has_star_arg(code):\n            if argc > 0:\n                self.write(', *, ')\n            else:\n                self.write('*, ')\n            pass\n            ends_in_comma = True\n        elif argc > 0:\n            self.write(', ')\n            ends_in_comma = True\n        kw_args = [None] * kwonlyargcount\n        for n in node:\n            if n == 'kwargs':\n                n = n[0]\n            if n == 'kwarg':\n                name = eval(n[0].pattr)\n                idx = kwargs.index(name)\n                default = self.traverse(n[1], indent='')\n                if annotate_dict and name in annotate_dict:\n                    kw_args[idx] = '%s: %s=%s' % (name, annotate_dict[name], default)\n                else:\n                    kw_args[idx] = '%s=%s' % (name, default)\n                pass\n            pass\n        other_kw = [c == None for c in kw_args]\n        for (i, flag) in enumerate(other_kw):\n            if flag:\n                n = kwargs[i]\n                if n in annotate_dict:\n                    kw_args[i] = '%s: %s' % (n, annotate_dict[n])\n                else:\n                    kw_args[i] = '%s' % n\n        self.write(', '.join(kw_args))\n        ends_in_comma = False\n    elif argc == 0:\n        ends_in_comma = True\n    if code_has_star_star_arg(code):\n        if not ends_in_comma:\n            self.write(', ')\n        star_star_arg = code.co_varnames[argc + kwonlyargcount]\n        if annotate_dict and star_star_arg in annotate_dict:\n            self.write('**%s: %s' % (star_star_arg, annotate_dict[star_star_arg]))\n        else:\n            self.write('**%s' % star_star_arg)\n    if is_lambda:\n        self.write(': ')\n    else:\n        self.write(')')\n        if 'return' in annotate_tuple[0].attr:\n            if line_number != self.line_number and (not no_paramnames):\n                self.write('\\n' + indent)\n                line_number = self.line_number\n            self.write(' -> ')\n            if 'return' in annotate_dict:\n                self.write(annotate_dict['return'])\n            else:\n                self.preorder(node[annotate_last - 1])\n        self.println(':')\n    if len(code.co_consts) > 0 and code.co_consts[0] is not None and (not is_lambda):\n        print_docstring(self, self.indent, code.co_consts[0])\n    code._tokens = None\n    assert ast == 'stmts'\n    all_globals = find_all_globals(ast, set())\n    (globals, nonlocals) = find_globals_and_nonlocals(ast, set(), set(), code, self.version)\n    for g in sorted(all_globals & self.mod_globs | globals):\n        self.println(self.indent, 'global ', g)\n    for nl in sorted(nonlocals):\n        self.println(self.indent, 'nonlocal ', nl)\n    self.mod_globs -= all_globals\n    has_none = 'None' in code.co_names\n    rn = has_none and (not find_none(ast))\n    self.gen_source(ast, code.co_name, code._customize, is_lambda=is_lambda, returnNone=rn)\n    code._tokens = code._customize = None",
            "def make_function3_annotate(self, node, is_lambda, nested=1, code_node=None, annotate_last=-1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Dump function defintion, doc string, and function\\n    body. This code is specialized for Python 3'\n\n    def build_param(ast, name, default):\n        \"\"\"build parameters:\n            - handle defaults\n            - handle format tuple parameters\n        \"\"\"\n        if default:\n            value = self.traverse(default, indent='')\n            maybe_show_tree_param_default(self, name, value)\n            result = '%s=%s' % (name, value)\n            if result[-2:] == '= ':\n                result += 'None'\n            return result\n        else:\n            return name\n    assert node[-1].kind.startswith('MAKE_')\n    annotate_tuple = None\n    for annotate_last in range(len(node) - 1, -1, -1):\n        if node[annotate_last] == 'annotate_tuple':\n            annotate_tuple = node[annotate_last]\n            break\n    annotate_args = {}\n    if annotate_tuple == 'annotate_tuple' and annotate_tuple[0] in ('LOAD_CONST', 'LOAD_NAME') and isinstance(annotate_tuple[0].attr, tuple):\n        annotate_tup = annotate_tuple[0].attr\n        i = -1\n        j = annotate_last - 1\n        l = -len(node)\n        while j >= l and node[j].kind in ('annotate_arg', 'annotate_tuple'):\n            annotate_args[annotate_tup[i]] = node[j][0]\n            i -= 1\n            j -= 1\n    args_node = node[-1]\n    if isinstance(args_node.attr, tuple):\n        defparams = node[:args_node.attr[0]]\n        (pos_args, kw_args, annotate_argc) = args_node.attr\n    else:\n        defparams = node[:args_node.attr]\n        kw_args = 0\n        pass\n    annotate_dict = {}\n    for name in annotate_args.keys():\n        n = self.traverse(annotate_args[name], indent='')\n        annotate_dict[name] = n\n    if (3, 0) <= self.version < (3, 3):\n        lambda_index = -2\n    elif self.version < (3, 4):\n        lambda_index = -3\n    else:\n        lambda_index = None\n    if lambda_index and is_lambda and iscode(node[lambda_index].attr):\n        assert node[lambda_index].kind == 'LOAD_LAMBDA'\n        code = node[lambda_index].attr\n    else:\n        code = code_node.attr\n    assert iscode(code)\n    code = Code(code, self.scanner, self.currentclass)\n    argc = code.co_argcount\n    kwonlyargcount = code.co_kwonlyargcount\n    paramnames = list(code.co_varnames[:argc])\n    if kwonlyargcount > 0:\n        kwargs = list(code.co_varnames[argc:argc + kwonlyargcount])\n    try:\n        ast = self.build_ast(code._tokens, code._customize, code, is_lambda=is_lambda, noneInNames='None' in code.co_names)\n    except (ParserError, ParserError2) as p:\n        self.write(str(p))\n        if not self.tolerate_errors:\n            self.ERROR = p\n        return\n    indent = self.indent\n    if is_lambda:\n        self.write('lambda ')\n    else:\n        self.write('(')\n    last_line = self.f.getvalue().split('\\n')[-1]\n    l = len(last_line)\n    indent = ' ' * l\n    line_number = self.line_number\n    i = len(paramnames) - len(defparams)\n    suffix = ''\n    for param in paramnames[:i]:\n        self.write(suffix, param)\n        suffix = ', '\n        if param in annotate_dict:\n            self.write(': %s' % annotate_dict[param])\n            if line_number != self.line_number:\n                suffix = ',\\n' + indent\n                line_number = self.line_number\n    suffix = ', ' if i > 0 else ''\n    for n in node:\n        if n == 'pos_arg':\n            self.write(suffix)\n            param = paramnames[i]\n            self.write(param)\n            if param in annotate_args:\n                aa = annotate_args[param]\n                if isinstance(aa, tuple):\n                    aa = aa[0]\n                    self.write(': \"%s\"' % aa)\n                elif isinstance(aa, SyntaxTree):\n                    self.write(': ')\n                    self.preorder(aa)\n            self.write('=')\n            i += 1\n            self.preorder(n)\n            if line_number != self.line_number:\n                suffix = ',\\n' + indent\n                line_number = self.line_number\n            else:\n                suffix = ', '\n    if code_has_star_arg(code):\n        star_arg = code.co_varnames[argc + kwonlyargcount]\n        if annotate_dict and star_arg in annotate_dict:\n            self.write(suffix, '*%s: %s' % (star_arg, annotate_dict[star_arg]))\n        else:\n            self.write(suffix, '*%s' % star_arg)\n        argc += 1\n    ends_in_comma = False\n    if kwonlyargcount > 0:\n        if not code_has_star_arg(code):\n            if argc > 0:\n                self.write(', *, ')\n            else:\n                self.write('*, ')\n            pass\n            ends_in_comma = True\n        elif argc > 0:\n            self.write(', ')\n            ends_in_comma = True\n        kw_args = [None] * kwonlyargcount\n        for n in node:\n            if n == 'kwargs':\n                n = n[0]\n            if n == 'kwarg':\n                name = eval(n[0].pattr)\n                idx = kwargs.index(name)\n                default = self.traverse(n[1], indent='')\n                if annotate_dict and name in annotate_dict:\n                    kw_args[idx] = '%s: %s=%s' % (name, annotate_dict[name], default)\n                else:\n                    kw_args[idx] = '%s=%s' % (name, default)\n                pass\n            pass\n        other_kw = [c == None for c in kw_args]\n        for (i, flag) in enumerate(other_kw):\n            if flag:\n                n = kwargs[i]\n                if n in annotate_dict:\n                    kw_args[i] = '%s: %s' % (n, annotate_dict[n])\n                else:\n                    kw_args[i] = '%s' % n\n        self.write(', '.join(kw_args))\n        ends_in_comma = False\n    elif argc == 0:\n        ends_in_comma = True\n    if code_has_star_star_arg(code):\n        if not ends_in_comma:\n            self.write(', ')\n        star_star_arg = code.co_varnames[argc + kwonlyargcount]\n        if annotate_dict and star_star_arg in annotate_dict:\n            self.write('**%s: %s' % (star_star_arg, annotate_dict[star_star_arg]))\n        else:\n            self.write('**%s' % star_star_arg)\n    if is_lambda:\n        self.write(': ')\n    else:\n        self.write(')')\n        if 'return' in annotate_tuple[0].attr:\n            if line_number != self.line_number and (not no_paramnames):\n                self.write('\\n' + indent)\n                line_number = self.line_number\n            self.write(' -> ')\n            if 'return' in annotate_dict:\n                self.write(annotate_dict['return'])\n            else:\n                self.preorder(node[annotate_last - 1])\n        self.println(':')\n    if len(code.co_consts) > 0 and code.co_consts[0] is not None and (not is_lambda):\n        print_docstring(self, self.indent, code.co_consts[0])\n    code._tokens = None\n    assert ast == 'stmts'\n    all_globals = find_all_globals(ast, set())\n    (globals, nonlocals) = find_globals_and_nonlocals(ast, set(), set(), code, self.version)\n    for g in sorted(all_globals & self.mod_globs | globals):\n        self.println(self.indent, 'global ', g)\n    for nl in sorted(nonlocals):\n        self.println(self.indent, 'nonlocal ', nl)\n    self.mod_globs -= all_globals\n    has_none = 'None' in code.co_names\n    rn = has_none and (not find_none(ast))\n    self.gen_source(ast, code.co_name, code._customize, is_lambda=is_lambda, returnNone=rn)\n    code._tokens = code._customize = None",
            "def make_function3_annotate(self, node, is_lambda, nested=1, code_node=None, annotate_last=-1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Dump function defintion, doc string, and function\\n    body. This code is specialized for Python 3'\n\n    def build_param(ast, name, default):\n        \"\"\"build parameters:\n            - handle defaults\n            - handle format tuple parameters\n        \"\"\"\n        if default:\n            value = self.traverse(default, indent='')\n            maybe_show_tree_param_default(self, name, value)\n            result = '%s=%s' % (name, value)\n            if result[-2:] == '= ':\n                result += 'None'\n            return result\n        else:\n            return name\n    assert node[-1].kind.startswith('MAKE_')\n    annotate_tuple = None\n    for annotate_last in range(len(node) - 1, -1, -1):\n        if node[annotate_last] == 'annotate_tuple':\n            annotate_tuple = node[annotate_last]\n            break\n    annotate_args = {}\n    if annotate_tuple == 'annotate_tuple' and annotate_tuple[0] in ('LOAD_CONST', 'LOAD_NAME') and isinstance(annotate_tuple[0].attr, tuple):\n        annotate_tup = annotate_tuple[0].attr\n        i = -1\n        j = annotate_last - 1\n        l = -len(node)\n        while j >= l and node[j].kind in ('annotate_arg', 'annotate_tuple'):\n            annotate_args[annotate_tup[i]] = node[j][0]\n            i -= 1\n            j -= 1\n    args_node = node[-1]\n    if isinstance(args_node.attr, tuple):\n        defparams = node[:args_node.attr[0]]\n        (pos_args, kw_args, annotate_argc) = args_node.attr\n    else:\n        defparams = node[:args_node.attr]\n        kw_args = 0\n        pass\n    annotate_dict = {}\n    for name in annotate_args.keys():\n        n = self.traverse(annotate_args[name], indent='')\n        annotate_dict[name] = n\n    if (3, 0) <= self.version < (3, 3):\n        lambda_index = -2\n    elif self.version < (3, 4):\n        lambda_index = -3\n    else:\n        lambda_index = None\n    if lambda_index and is_lambda and iscode(node[lambda_index].attr):\n        assert node[lambda_index].kind == 'LOAD_LAMBDA'\n        code = node[lambda_index].attr\n    else:\n        code = code_node.attr\n    assert iscode(code)\n    code = Code(code, self.scanner, self.currentclass)\n    argc = code.co_argcount\n    kwonlyargcount = code.co_kwonlyargcount\n    paramnames = list(code.co_varnames[:argc])\n    if kwonlyargcount > 0:\n        kwargs = list(code.co_varnames[argc:argc + kwonlyargcount])\n    try:\n        ast = self.build_ast(code._tokens, code._customize, code, is_lambda=is_lambda, noneInNames='None' in code.co_names)\n    except (ParserError, ParserError2) as p:\n        self.write(str(p))\n        if not self.tolerate_errors:\n            self.ERROR = p\n        return\n    indent = self.indent\n    if is_lambda:\n        self.write('lambda ')\n    else:\n        self.write('(')\n    last_line = self.f.getvalue().split('\\n')[-1]\n    l = len(last_line)\n    indent = ' ' * l\n    line_number = self.line_number\n    i = len(paramnames) - len(defparams)\n    suffix = ''\n    for param in paramnames[:i]:\n        self.write(suffix, param)\n        suffix = ', '\n        if param in annotate_dict:\n            self.write(': %s' % annotate_dict[param])\n            if line_number != self.line_number:\n                suffix = ',\\n' + indent\n                line_number = self.line_number\n    suffix = ', ' if i > 0 else ''\n    for n in node:\n        if n == 'pos_arg':\n            self.write(suffix)\n            param = paramnames[i]\n            self.write(param)\n            if param in annotate_args:\n                aa = annotate_args[param]\n                if isinstance(aa, tuple):\n                    aa = aa[0]\n                    self.write(': \"%s\"' % aa)\n                elif isinstance(aa, SyntaxTree):\n                    self.write(': ')\n                    self.preorder(aa)\n            self.write('=')\n            i += 1\n            self.preorder(n)\n            if line_number != self.line_number:\n                suffix = ',\\n' + indent\n                line_number = self.line_number\n            else:\n                suffix = ', '\n    if code_has_star_arg(code):\n        star_arg = code.co_varnames[argc + kwonlyargcount]\n        if annotate_dict and star_arg in annotate_dict:\n            self.write(suffix, '*%s: %s' % (star_arg, annotate_dict[star_arg]))\n        else:\n            self.write(suffix, '*%s' % star_arg)\n        argc += 1\n    ends_in_comma = False\n    if kwonlyargcount > 0:\n        if not code_has_star_arg(code):\n            if argc > 0:\n                self.write(', *, ')\n            else:\n                self.write('*, ')\n            pass\n            ends_in_comma = True\n        elif argc > 0:\n            self.write(', ')\n            ends_in_comma = True\n        kw_args = [None] * kwonlyargcount\n        for n in node:\n            if n == 'kwargs':\n                n = n[0]\n            if n == 'kwarg':\n                name = eval(n[0].pattr)\n                idx = kwargs.index(name)\n                default = self.traverse(n[1], indent='')\n                if annotate_dict and name in annotate_dict:\n                    kw_args[idx] = '%s: %s=%s' % (name, annotate_dict[name], default)\n                else:\n                    kw_args[idx] = '%s=%s' % (name, default)\n                pass\n            pass\n        other_kw = [c == None for c in kw_args]\n        for (i, flag) in enumerate(other_kw):\n            if flag:\n                n = kwargs[i]\n                if n in annotate_dict:\n                    kw_args[i] = '%s: %s' % (n, annotate_dict[n])\n                else:\n                    kw_args[i] = '%s' % n\n        self.write(', '.join(kw_args))\n        ends_in_comma = False\n    elif argc == 0:\n        ends_in_comma = True\n    if code_has_star_star_arg(code):\n        if not ends_in_comma:\n            self.write(', ')\n        star_star_arg = code.co_varnames[argc + kwonlyargcount]\n        if annotate_dict and star_star_arg in annotate_dict:\n            self.write('**%s: %s' % (star_star_arg, annotate_dict[star_star_arg]))\n        else:\n            self.write('**%s' % star_star_arg)\n    if is_lambda:\n        self.write(': ')\n    else:\n        self.write(')')\n        if 'return' in annotate_tuple[0].attr:\n            if line_number != self.line_number and (not no_paramnames):\n                self.write('\\n' + indent)\n                line_number = self.line_number\n            self.write(' -> ')\n            if 'return' in annotate_dict:\n                self.write(annotate_dict['return'])\n            else:\n                self.preorder(node[annotate_last - 1])\n        self.println(':')\n    if len(code.co_consts) > 0 and code.co_consts[0] is not None and (not is_lambda):\n        print_docstring(self, self.indent, code.co_consts[0])\n    code._tokens = None\n    assert ast == 'stmts'\n    all_globals = find_all_globals(ast, set())\n    (globals, nonlocals) = find_globals_and_nonlocals(ast, set(), set(), code, self.version)\n    for g in sorted(all_globals & self.mod_globs | globals):\n        self.println(self.indent, 'global ', g)\n    for nl in sorted(nonlocals):\n        self.println(self.indent, 'nonlocal ', nl)\n    self.mod_globs -= all_globals\n    has_none = 'None' in code.co_names\n    rn = has_none and (not find_none(ast))\n    self.gen_source(ast, code.co_name, code._customize, is_lambda=is_lambda, returnNone=rn)\n    code._tokens = code._customize = None"
        ]
    },
    {
        "func_name": "build_param",
        "original": "def build_param(ast, name, default, annotation=None):\n    \"\"\"build parameters:\n            - handle defaults\n            - handle format tuple parameters\n        \"\"\"\n    value = self.traverse(default, indent='')\n    maybe_show_tree_param_default(self.showast, name, value)\n    if annotation:\n        result = '%s: %s=%s' % (name, annotation, value)\n    else:\n        result = '%s=%s' % (name, value)\n    if result[-2:] == '= ':\n        result += 'None'\n    return result",
        "mutated": [
            "def build_param(ast, name, default, annotation=None):\n    if False:\n        i = 10\n    'build parameters:\\n            - handle defaults\\n            - handle format tuple parameters\\n        '\n    value = self.traverse(default, indent='')\n    maybe_show_tree_param_default(self.showast, name, value)\n    if annotation:\n        result = '%s: %s=%s' % (name, annotation, value)\n    else:\n        result = '%s=%s' % (name, value)\n    if result[-2:] == '= ':\n        result += 'None'\n    return result",
            "def build_param(ast, name, default, annotation=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'build parameters:\\n            - handle defaults\\n            - handle format tuple parameters\\n        '\n    value = self.traverse(default, indent='')\n    maybe_show_tree_param_default(self.showast, name, value)\n    if annotation:\n        result = '%s: %s=%s' % (name, annotation, value)\n    else:\n        result = '%s=%s' % (name, value)\n    if result[-2:] == '= ':\n        result += 'None'\n    return result",
            "def build_param(ast, name, default, annotation=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'build parameters:\\n            - handle defaults\\n            - handle format tuple parameters\\n        '\n    value = self.traverse(default, indent='')\n    maybe_show_tree_param_default(self.showast, name, value)\n    if annotation:\n        result = '%s: %s=%s' % (name, annotation, value)\n    else:\n        result = '%s=%s' % (name, value)\n    if result[-2:] == '= ':\n        result += 'None'\n    return result",
            "def build_param(ast, name, default, annotation=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'build parameters:\\n            - handle defaults\\n            - handle format tuple parameters\\n        '\n    value = self.traverse(default, indent='')\n    maybe_show_tree_param_default(self.showast, name, value)\n    if annotation:\n        result = '%s: %s=%s' % (name, annotation, value)\n    else:\n        result = '%s=%s' % (name, value)\n    if result[-2:] == '= ':\n        result += 'None'\n    return result",
            "def build_param(ast, name, default, annotation=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'build parameters:\\n            - handle defaults\\n            - handle format tuple parameters\\n        '\n    value = self.traverse(default, indent='')\n    maybe_show_tree_param_default(self.showast, name, value)\n    if annotation:\n        result = '%s: %s=%s' % (name, annotation, value)\n    else:\n        result = '%s=%s' % (name, value)\n    if result[-2:] == '= ':\n        result += 'None'\n    return result"
        ]
    },
    {
        "func_name": "make_function3",
        "original": "def make_function3(self, node, is_lambda, nested=1, code_node=None):\n    \"\"\"Dump function definition, doc string, and function body in\n      Python version 3.0 and above\n    \"\"\"\n\n    def build_param(ast, name, default, annotation=None):\n        \"\"\"build parameters:\n            - handle defaults\n            - handle format tuple parameters\n        \"\"\"\n        value = self.traverse(default, indent='')\n        maybe_show_tree_param_default(self.showast, name, value)\n        if annotation:\n            result = '%s: %s=%s' % (name, annotation, value)\n        else:\n            result = '%s=%s' % (name, value)\n        if result[-2:] == '= ':\n            result += 'None'\n        return result\n    assert node[-1].kind.startswith('MAKE_')\n    if (3, 0) <= self.version <= (3, 2):\n        lambda_index = -2\n    elif (3, 3) <= self.version:\n        lambda_index = -3\n    else:\n        lambda_index = None\n    args_node = node[-1]\n    annotate_dict = {}\n    args_attr = args_node.attr\n    if isinstance(args_attr, tuple):\n        if len(args_attr) == 3:\n            (pos_args, kw_args, annotate_argc) = args_attr\n        else:\n            (pos_args, kw_args, annotate_argc, closure) = args_attr\n            i = -4\n            kw_pairs = 0\n            if closure:\n                i -= 1\n            if annotate_argc:\n                annotate_node = node[i]\n                if annotate_node == 'expr':\n                    annotate_node = annotate_node[0]\n                    annotate_name_node = annotate_node[-1]\n                    if annotate_node == 'dict' and annotate_name_node.kind.startswith('BUILD_CONST_KEY_MAP'):\n                        types = [self.traverse(n, indent='') for n in annotate_node[:-2]]\n                        names = annotate_node[-2].attr\n                        l = len(types)\n                        assert l == len(names)\n                        for i in range(l):\n                            annotate_dict[names[i]] = types[i]\n                        pass\n                    pass\n                i -= 1\n            if kw_args:\n                kw_node = node[i]\n                if kw_node == 'expr':\n                    kw_node = kw_node[0]\n                if kw_node == 'dict':\n                    kw_pairs = kw_node[-1].attr\n        have_kwargs = node[0].kind.startswith('kwarg') or node[0] == 'no_kwargs'\n        if len(node) >= 4:\n            lc_index = -4\n        else:\n            lc_index = -3\n            pass\n        if len(node) > 2 and (have_kwargs or node[lc_index].kind != 'load_closure'):\n            default_values_start = 0\n            if node[0] == 'no_kwargs':\n                default_values_start += 1\n            if node[default_values_start] == 'kwarg':\n                assert node[lambda_index] == 'LOAD_LAMBDA'\n                i = default_values_start\n                defparams = []\n                while node[i] == 'kwarg':\n                    defparams.append(node[i][1])\n                    i += 1\n            else:\n                if node[default_values_start] == 'kwargs':\n                    default_values_start += 1\n                defparams = node[default_values_start:default_values_start + args_node.attr[0]]\n        else:\n            defparams = node[:args_node.attr[0]]\n            kw_args = 0\n    else:\n        defparams = node[:args_node.attr]\n        kw_args = 0\n        pass\n    if lambda_index and is_lambda and iscode(node[lambda_index].attr):\n        assert node[lambda_index].kind == 'LOAD_LAMBDA'\n        code = node[lambda_index].attr\n    else:\n        code = code_node.attr\n    assert iscode(code)\n    scanner_code = Code(code, self.scanner, self.currentclass)\n    argc = code.co_argcount\n    kwonlyargcount = code.co_kwonlyargcount\n    paramnames = list(scanner_code.co_varnames[:argc])\n    if kwonlyargcount > 0:\n        if is_lambda:\n            kwargs = []\n            for i in range(kwonlyargcount):\n                paramnames.append(scanner_code.co_varnames[argc + i])\n            pass\n        else:\n            kwargs = list(scanner_code.co_varnames[argc:argc + kwonlyargcount])\n    paramnames.reverse()\n    defparams.reverse()\n    try:\n        ast = self.build_ast(scanner_code._tokens, scanner_code._customize, scanner_code, is_lambda=is_lambda, noneInNames='None' in code.co_names)\n    except (ParserError, ParserError2) as p:\n        self.write(str(p))\n        if not self.tolerate_errors:\n            self.ERROR = p\n        return\n    kw_pairs = 0\n    i = len(paramnames) - len(defparams)\n    params = []\n    if defparams:\n        for (i, defparam) in enumerate(defparams):\n            params.append(build_param(ast, paramnames[i], defparam, annotate_dict.get(paramnames[i])))\n        for param in paramnames[i + 1:]:\n            if param in annotate_dict:\n                params.append('%s: %s' % (param, annotate_dict[param]))\n            else:\n                params.append(param)\n    else:\n        for param in paramnames:\n            if param in annotate_dict:\n                params.append('%s: %s' % (param, annotate_dict[param]))\n            else:\n                params.append(param)\n    params.reverse()\n    if code_has_star_arg(code):\n        star_arg = code.co_varnames[argc + kwonlyargcount]\n        if annotate_dict and star_arg in annotate_dict:\n            params.append('*%s: %s' % (star_arg, annotate_dict[star_arg]))\n        else:\n            params.append('*%s' % star_arg)\n            pass\n        if is_lambda:\n            params.reverse()\n        if not is_lambda:\n            argc += 1\n        pass\n    elif is_lambda and kwonlyargcount > 0:\n        params.insert(0, '*')\n        kwonlyargcount = 0\n    if is_lambda:\n        self.write('lambda ', ', '.join(params))\n        if len(ast) > 1 and self.traverse(ast[-1]) == 'None' and self.traverse(ast[-2]).strip().startswith('yield'):\n            del ast[-1]\n            ast_expr = ast[-1]\n            while ast_expr.kind != 'expr':\n                ast_expr = ast_expr[0]\n            ast[-1] = ast_expr\n            pass\n    else:\n        self.write('(', ', '.join(params))\n    ends_in_comma = False\n    if kwonlyargcount > 0:\n        if not 4 & code.co_flags:\n            if argc > 0:\n                self.write(', *, ')\n            else:\n                self.write('*, ')\n            pass\n            ends_in_comma = True\n        elif argc > 0 and node[0] != 'kwarg':\n            self.write(', ')\n            ends_in_comma = True\n        kw_args = [None] * kwonlyargcount\n        if self.version <= (3, 3):\n            kw_nodes = node[0]\n        else:\n            kw_nodes = node[args_node.attr[0]]\n        if kw_nodes == 'kwargs':\n            for n in kw_nodes:\n                name = eval(n[0].pattr)\n                default = self.traverse(n[1], indent='')\n                idx = kwargs.index(name)\n                kw_args[idx] = '%s=%s' % (name, default)\n                pass\n            pass\n        if kw_nodes != 'kwarg' or self.version == 3.5:\n            other_kw = [c == None for c in kw_args]\n            for (i, flag) in enumerate(other_kw):\n                if flag:\n                    if i < len(kwargs):\n                        kw_args[i] = '%s' % kwargs[i]\n                    else:\n                        del kw_args[i]\n                    pass\n            self.write(', '.join(kw_args))\n            ends_in_comma = False\n            pass\n        pass\n    elif argc == 0:\n        ends_in_comma = True\n    if code_has_star_star_arg(code):\n        if not ends_in_comma:\n            self.write(', ')\n        star_star_arg = code.co_varnames[argc + kwonlyargcount]\n        if annotate_dict and star_star_arg in annotate_dict:\n            self.write('**%s: %s' % (star_star_arg, annotate_dict[star_star_arg]))\n        else:\n            self.write('**%s' % star_star_arg)\n    if is_lambda:\n        self.write(': ')\n    else:\n        self.write(')')\n        if annotate_dict and 'return' in annotate_dict:\n            self.write(' -> %s' % annotate_dict['return'])\n        self.println(':')\n    if len(code.co_consts) > 0 and code.co_consts[0] is not None and (not is_lambda):\n        print_docstring(self, self.indent, code.co_consts[0])\n    assert ast == 'stmts'\n    all_globals = find_all_globals(ast, set())\n    (globals, nonlocals) = find_globals_and_nonlocals(ast, set(), set(), code, self.version)\n    for g in sorted(all_globals & self.mod_globs | globals):\n        self.println(self.indent, 'global ', g)\n    for nl in sorted(nonlocals):\n        self.println(self.indent, 'nonlocal ', nl)\n    self.mod_globs -= all_globals\n    has_none = 'None' in code.co_names\n    rn = has_none and (not find_none(ast))\n    self.gen_source(ast, code.co_name, scanner_code._customize, is_lambda=is_lambda, returnNone=rn, debug_opts=self.debug_opts)\n    if not is_lambda and code.co_flags & CO_GENERATOR:\n        need_bogus_yield = True\n        for token in scanner_code._tokens:\n            if token in ('YIELD_VALUE', 'YIELD_FROM'):\n                need_bogus_yield = False\n                break\n            pass\n        if need_bogus_yield:\n            self.template_engine(('%|if False:\\n%+%|yield None%-',), node)\n    scanner_code._tokens = None\n    scanner_code._customize = None",
        "mutated": [
            "def make_function3(self, node, is_lambda, nested=1, code_node=None):\n    if False:\n        i = 10\n    'Dump function definition, doc string, and function body in\\n      Python version 3.0 and above\\n    '\n\n    def build_param(ast, name, default, annotation=None):\n        \"\"\"build parameters:\n            - handle defaults\n            - handle format tuple parameters\n        \"\"\"\n        value = self.traverse(default, indent='')\n        maybe_show_tree_param_default(self.showast, name, value)\n        if annotation:\n            result = '%s: %s=%s' % (name, annotation, value)\n        else:\n            result = '%s=%s' % (name, value)\n        if result[-2:] == '= ':\n            result += 'None'\n        return result\n    assert node[-1].kind.startswith('MAKE_')\n    if (3, 0) <= self.version <= (3, 2):\n        lambda_index = -2\n    elif (3, 3) <= self.version:\n        lambda_index = -3\n    else:\n        lambda_index = None\n    args_node = node[-1]\n    annotate_dict = {}\n    args_attr = args_node.attr\n    if isinstance(args_attr, tuple):\n        if len(args_attr) == 3:\n            (pos_args, kw_args, annotate_argc) = args_attr\n        else:\n            (pos_args, kw_args, annotate_argc, closure) = args_attr\n            i = -4\n            kw_pairs = 0\n            if closure:\n                i -= 1\n            if annotate_argc:\n                annotate_node = node[i]\n                if annotate_node == 'expr':\n                    annotate_node = annotate_node[0]\n                    annotate_name_node = annotate_node[-1]\n                    if annotate_node == 'dict' and annotate_name_node.kind.startswith('BUILD_CONST_KEY_MAP'):\n                        types = [self.traverse(n, indent='') for n in annotate_node[:-2]]\n                        names = annotate_node[-2].attr\n                        l = len(types)\n                        assert l == len(names)\n                        for i in range(l):\n                            annotate_dict[names[i]] = types[i]\n                        pass\n                    pass\n                i -= 1\n            if kw_args:\n                kw_node = node[i]\n                if kw_node == 'expr':\n                    kw_node = kw_node[0]\n                if kw_node == 'dict':\n                    kw_pairs = kw_node[-1].attr\n        have_kwargs = node[0].kind.startswith('kwarg') or node[0] == 'no_kwargs'\n        if len(node) >= 4:\n            lc_index = -4\n        else:\n            lc_index = -3\n            pass\n        if len(node) > 2 and (have_kwargs or node[lc_index].kind != 'load_closure'):\n            default_values_start = 0\n            if node[0] == 'no_kwargs':\n                default_values_start += 1\n            if node[default_values_start] == 'kwarg':\n                assert node[lambda_index] == 'LOAD_LAMBDA'\n                i = default_values_start\n                defparams = []\n                while node[i] == 'kwarg':\n                    defparams.append(node[i][1])\n                    i += 1\n            else:\n                if node[default_values_start] == 'kwargs':\n                    default_values_start += 1\n                defparams = node[default_values_start:default_values_start + args_node.attr[0]]\n        else:\n            defparams = node[:args_node.attr[0]]\n            kw_args = 0\n    else:\n        defparams = node[:args_node.attr]\n        kw_args = 0\n        pass\n    if lambda_index and is_lambda and iscode(node[lambda_index].attr):\n        assert node[lambda_index].kind == 'LOAD_LAMBDA'\n        code = node[lambda_index].attr\n    else:\n        code = code_node.attr\n    assert iscode(code)\n    scanner_code = Code(code, self.scanner, self.currentclass)\n    argc = code.co_argcount\n    kwonlyargcount = code.co_kwonlyargcount\n    paramnames = list(scanner_code.co_varnames[:argc])\n    if kwonlyargcount > 0:\n        if is_lambda:\n            kwargs = []\n            for i in range(kwonlyargcount):\n                paramnames.append(scanner_code.co_varnames[argc + i])\n            pass\n        else:\n            kwargs = list(scanner_code.co_varnames[argc:argc + kwonlyargcount])\n    paramnames.reverse()\n    defparams.reverse()\n    try:\n        ast = self.build_ast(scanner_code._tokens, scanner_code._customize, scanner_code, is_lambda=is_lambda, noneInNames='None' in code.co_names)\n    except (ParserError, ParserError2) as p:\n        self.write(str(p))\n        if not self.tolerate_errors:\n            self.ERROR = p\n        return\n    kw_pairs = 0\n    i = len(paramnames) - len(defparams)\n    params = []\n    if defparams:\n        for (i, defparam) in enumerate(defparams):\n            params.append(build_param(ast, paramnames[i], defparam, annotate_dict.get(paramnames[i])))\n        for param in paramnames[i + 1:]:\n            if param in annotate_dict:\n                params.append('%s: %s' % (param, annotate_dict[param]))\n            else:\n                params.append(param)\n    else:\n        for param in paramnames:\n            if param in annotate_dict:\n                params.append('%s: %s' % (param, annotate_dict[param]))\n            else:\n                params.append(param)\n    params.reverse()\n    if code_has_star_arg(code):\n        star_arg = code.co_varnames[argc + kwonlyargcount]\n        if annotate_dict and star_arg in annotate_dict:\n            params.append('*%s: %s' % (star_arg, annotate_dict[star_arg]))\n        else:\n            params.append('*%s' % star_arg)\n            pass\n        if is_lambda:\n            params.reverse()\n        if not is_lambda:\n            argc += 1\n        pass\n    elif is_lambda and kwonlyargcount > 0:\n        params.insert(0, '*')\n        kwonlyargcount = 0\n    if is_lambda:\n        self.write('lambda ', ', '.join(params))\n        if len(ast) > 1 and self.traverse(ast[-1]) == 'None' and self.traverse(ast[-2]).strip().startswith('yield'):\n            del ast[-1]\n            ast_expr = ast[-1]\n            while ast_expr.kind != 'expr':\n                ast_expr = ast_expr[0]\n            ast[-1] = ast_expr\n            pass\n    else:\n        self.write('(', ', '.join(params))\n    ends_in_comma = False\n    if kwonlyargcount > 0:\n        if not 4 & code.co_flags:\n            if argc > 0:\n                self.write(', *, ')\n            else:\n                self.write('*, ')\n            pass\n            ends_in_comma = True\n        elif argc > 0 and node[0] != 'kwarg':\n            self.write(', ')\n            ends_in_comma = True\n        kw_args = [None] * kwonlyargcount\n        if self.version <= (3, 3):\n            kw_nodes = node[0]\n        else:\n            kw_nodes = node[args_node.attr[0]]\n        if kw_nodes == 'kwargs':\n            for n in kw_nodes:\n                name = eval(n[0].pattr)\n                default = self.traverse(n[1], indent='')\n                idx = kwargs.index(name)\n                kw_args[idx] = '%s=%s' % (name, default)\n                pass\n            pass\n        if kw_nodes != 'kwarg' or self.version == 3.5:\n            other_kw = [c == None for c in kw_args]\n            for (i, flag) in enumerate(other_kw):\n                if flag:\n                    if i < len(kwargs):\n                        kw_args[i] = '%s' % kwargs[i]\n                    else:\n                        del kw_args[i]\n                    pass\n            self.write(', '.join(kw_args))\n            ends_in_comma = False\n            pass\n        pass\n    elif argc == 0:\n        ends_in_comma = True\n    if code_has_star_star_arg(code):\n        if not ends_in_comma:\n            self.write(', ')\n        star_star_arg = code.co_varnames[argc + kwonlyargcount]\n        if annotate_dict and star_star_arg in annotate_dict:\n            self.write('**%s: %s' % (star_star_arg, annotate_dict[star_star_arg]))\n        else:\n            self.write('**%s' % star_star_arg)\n    if is_lambda:\n        self.write(': ')\n    else:\n        self.write(')')\n        if annotate_dict and 'return' in annotate_dict:\n            self.write(' -> %s' % annotate_dict['return'])\n        self.println(':')\n    if len(code.co_consts) > 0 and code.co_consts[0] is not None and (not is_lambda):\n        print_docstring(self, self.indent, code.co_consts[0])\n    assert ast == 'stmts'\n    all_globals = find_all_globals(ast, set())\n    (globals, nonlocals) = find_globals_and_nonlocals(ast, set(), set(), code, self.version)\n    for g in sorted(all_globals & self.mod_globs | globals):\n        self.println(self.indent, 'global ', g)\n    for nl in sorted(nonlocals):\n        self.println(self.indent, 'nonlocal ', nl)\n    self.mod_globs -= all_globals\n    has_none = 'None' in code.co_names\n    rn = has_none and (not find_none(ast))\n    self.gen_source(ast, code.co_name, scanner_code._customize, is_lambda=is_lambda, returnNone=rn, debug_opts=self.debug_opts)\n    if not is_lambda and code.co_flags & CO_GENERATOR:\n        need_bogus_yield = True\n        for token in scanner_code._tokens:\n            if token in ('YIELD_VALUE', 'YIELD_FROM'):\n                need_bogus_yield = False\n                break\n            pass\n        if need_bogus_yield:\n            self.template_engine(('%|if False:\\n%+%|yield None%-',), node)\n    scanner_code._tokens = None\n    scanner_code._customize = None",
            "def make_function3(self, node, is_lambda, nested=1, code_node=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Dump function definition, doc string, and function body in\\n      Python version 3.0 and above\\n    '\n\n    def build_param(ast, name, default, annotation=None):\n        \"\"\"build parameters:\n            - handle defaults\n            - handle format tuple parameters\n        \"\"\"\n        value = self.traverse(default, indent='')\n        maybe_show_tree_param_default(self.showast, name, value)\n        if annotation:\n            result = '%s: %s=%s' % (name, annotation, value)\n        else:\n            result = '%s=%s' % (name, value)\n        if result[-2:] == '= ':\n            result += 'None'\n        return result\n    assert node[-1].kind.startswith('MAKE_')\n    if (3, 0) <= self.version <= (3, 2):\n        lambda_index = -2\n    elif (3, 3) <= self.version:\n        lambda_index = -3\n    else:\n        lambda_index = None\n    args_node = node[-1]\n    annotate_dict = {}\n    args_attr = args_node.attr\n    if isinstance(args_attr, tuple):\n        if len(args_attr) == 3:\n            (pos_args, kw_args, annotate_argc) = args_attr\n        else:\n            (pos_args, kw_args, annotate_argc, closure) = args_attr\n            i = -4\n            kw_pairs = 0\n            if closure:\n                i -= 1\n            if annotate_argc:\n                annotate_node = node[i]\n                if annotate_node == 'expr':\n                    annotate_node = annotate_node[0]\n                    annotate_name_node = annotate_node[-1]\n                    if annotate_node == 'dict' and annotate_name_node.kind.startswith('BUILD_CONST_KEY_MAP'):\n                        types = [self.traverse(n, indent='') for n in annotate_node[:-2]]\n                        names = annotate_node[-2].attr\n                        l = len(types)\n                        assert l == len(names)\n                        for i in range(l):\n                            annotate_dict[names[i]] = types[i]\n                        pass\n                    pass\n                i -= 1\n            if kw_args:\n                kw_node = node[i]\n                if kw_node == 'expr':\n                    kw_node = kw_node[0]\n                if kw_node == 'dict':\n                    kw_pairs = kw_node[-1].attr\n        have_kwargs = node[0].kind.startswith('kwarg') or node[0] == 'no_kwargs'\n        if len(node) >= 4:\n            lc_index = -4\n        else:\n            lc_index = -3\n            pass\n        if len(node) > 2 and (have_kwargs or node[lc_index].kind != 'load_closure'):\n            default_values_start = 0\n            if node[0] == 'no_kwargs':\n                default_values_start += 1\n            if node[default_values_start] == 'kwarg':\n                assert node[lambda_index] == 'LOAD_LAMBDA'\n                i = default_values_start\n                defparams = []\n                while node[i] == 'kwarg':\n                    defparams.append(node[i][1])\n                    i += 1\n            else:\n                if node[default_values_start] == 'kwargs':\n                    default_values_start += 1\n                defparams = node[default_values_start:default_values_start + args_node.attr[0]]\n        else:\n            defparams = node[:args_node.attr[0]]\n            kw_args = 0\n    else:\n        defparams = node[:args_node.attr]\n        kw_args = 0\n        pass\n    if lambda_index and is_lambda and iscode(node[lambda_index].attr):\n        assert node[lambda_index].kind == 'LOAD_LAMBDA'\n        code = node[lambda_index].attr\n    else:\n        code = code_node.attr\n    assert iscode(code)\n    scanner_code = Code(code, self.scanner, self.currentclass)\n    argc = code.co_argcount\n    kwonlyargcount = code.co_kwonlyargcount\n    paramnames = list(scanner_code.co_varnames[:argc])\n    if kwonlyargcount > 0:\n        if is_lambda:\n            kwargs = []\n            for i in range(kwonlyargcount):\n                paramnames.append(scanner_code.co_varnames[argc + i])\n            pass\n        else:\n            kwargs = list(scanner_code.co_varnames[argc:argc + kwonlyargcount])\n    paramnames.reverse()\n    defparams.reverse()\n    try:\n        ast = self.build_ast(scanner_code._tokens, scanner_code._customize, scanner_code, is_lambda=is_lambda, noneInNames='None' in code.co_names)\n    except (ParserError, ParserError2) as p:\n        self.write(str(p))\n        if not self.tolerate_errors:\n            self.ERROR = p\n        return\n    kw_pairs = 0\n    i = len(paramnames) - len(defparams)\n    params = []\n    if defparams:\n        for (i, defparam) in enumerate(defparams):\n            params.append(build_param(ast, paramnames[i], defparam, annotate_dict.get(paramnames[i])))\n        for param in paramnames[i + 1:]:\n            if param in annotate_dict:\n                params.append('%s: %s' % (param, annotate_dict[param]))\n            else:\n                params.append(param)\n    else:\n        for param in paramnames:\n            if param in annotate_dict:\n                params.append('%s: %s' % (param, annotate_dict[param]))\n            else:\n                params.append(param)\n    params.reverse()\n    if code_has_star_arg(code):\n        star_arg = code.co_varnames[argc + kwonlyargcount]\n        if annotate_dict and star_arg in annotate_dict:\n            params.append('*%s: %s' % (star_arg, annotate_dict[star_arg]))\n        else:\n            params.append('*%s' % star_arg)\n            pass\n        if is_lambda:\n            params.reverse()\n        if not is_lambda:\n            argc += 1\n        pass\n    elif is_lambda and kwonlyargcount > 0:\n        params.insert(0, '*')\n        kwonlyargcount = 0\n    if is_lambda:\n        self.write('lambda ', ', '.join(params))\n        if len(ast) > 1 and self.traverse(ast[-1]) == 'None' and self.traverse(ast[-2]).strip().startswith('yield'):\n            del ast[-1]\n            ast_expr = ast[-1]\n            while ast_expr.kind != 'expr':\n                ast_expr = ast_expr[0]\n            ast[-1] = ast_expr\n            pass\n    else:\n        self.write('(', ', '.join(params))\n    ends_in_comma = False\n    if kwonlyargcount > 0:\n        if not 4 & code.co_flags:\n            if argc > 0:\n                self.write(', *, ')\n            else:\n                self.write('*, ')\n            pass\n            ends_in_comma = True\n        elif argc > 0 and node[0] != 'kwarg':\n            self.write(', ')\n            ends_in_comma = True\n        kw_args = [None] * kwonlyargcount\n        if self.version <= (3, 3):\n            kw_nodes = node[0]\n        else:\n            kw_nodes = node[args_node.attr[0]]\n        if kw_nodes == 'kwargs':\n            for n in kw_nodes:\n                name = eval(n[0].pattr)\n                default = self.traverse(n[1], indent='')\n                idx = kwargs.index(name)\n                kw_args[idx] = '%s=%s' % (name, default)\n                pass\n            pass\n        if kw_nodes != 'kwarg' or self.version == 3.5:\n            other_kw = [c == None for c in kw_args]\n            for (i, flag) in enumerate(other_kw):\n                if flag:\n                    if i < len(kwargs):\n                        kw_args[i] = '%s' % kwargs[i]\n                    else:\n                        del kw_args[i]\n                    pass\n            self.write(', '.join(kw_args))\n            ends_in_comma = False\n            pass\n        pass\n    elif argc == 0:\n        ends_in_comma = True\n    if code_has_star_star_arg(code):\n        if not ends_in_comma:\n            self.write(', ')\n        star_star_arg = code.co_varnames[argc + kwonlyargcount]\n        if annotate_dict and star_star_arg in annotate_dict:\n            self.write('**%s: %s' % (star_star_arg, annotate_dict[star_star_arg]))\n        else:\n            self.write('**%s' % star_star_arg)\n    if is_lambda:\n        self.write(': ')\n    else:\n        self.write(')')\n        if annotate_dict and 'return' in annotate_dict:\n            self.write(' -> %s' % annotate_dict['return'])\n        self.println(':')\n    if len(code.co_consts) > 0 and code.co_consts[0] is not None and (not is_lambda):\n        print_docstring(self, self.indent, code.co_consts[0])\n    assert ast == 'stmts'\n    all_globals = find_all_globals(ast, set())\n    (globals, nonlocals) = find_globals_and_nonlocals(ast, set(), set(), code, self.version)\n    for g in sorted(all_globals & self.mod_globs | globals):\n        self.println(self.indent, 'global ', g)\n    for nl in sorted(nonlocals):\n        self.println(self.indent, 'nonlocal ', nl)\n    self.mod_globs -= all_globals\n    has_none = 'None' in code.co_names\n    rn = has_none and (not find_none(ast))\n    self.gen_source(ast, code.co_name, scanner_code._customize, is_lambda=is_lambda, returnNone=rn, debug_opts=self.debug_opts)\n    if not is_lambda and code.co_flags & CO_GENERATOR:\n        need_bogus_yield = True\n        for token in scanner_code._tokens:\n            if token in ('YIELD_VALUE', 'YIELD_FROM'):\n                need_bogus_yield = False\n                break\n            pass\n        if need_bogus_yield:\n            self.template_engine(('%|if False:\\n%+%|yield None%-',), node)\n    scanner_code._tokens = None\n    scanner_code._customize = None",
            "def make_function3(self, node, is_lambda, nested=1, code_node=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Dump function definition, doc string, and function body in\\n      Python version 3.0 and above\\n    '\n\n    def build_param(ast, name, default, annotation=None):\n        \"\"\"build parameters:\n            - handle defaults\n            - handle format tuple parameters\n        \"\"\"\n        value = self.traverse(default, indent='')\n        maybe_show_tree_param_default(self.showast, name, value)\n        if annotation:\n            result = '%s: %s=%s' % (name, annotation, value)\n        else:\n            result = '%s=%s' % (name, value)\n        if result[-2:] == '= ':\n            result += 'None'\n        return result\n    assert node[-1].kind.startswith('MAKE_')\n    if (3, 0) <= self.version <= (3, 2):\n        lambda_index = -2\n    elif (3, 3) <= self.version:\n        lambda_index = -3\n    else:\n        lambda_index = None\n    args_node = node[-1]\n    annotate_dict = {}\n    args_attr = args_node.attr\n    if isinstance(args_attr, tuple):\n        if len(args_attr) == 3:\n            (pos_args, kw_args, annotate_argc) = args_attr\n        else:\n            (pos_args, kw_args, annotate_argc, closure) = args_attr\n            i = -4\n            kw_pairs = 0\n            if closure:\n                i -= 1\n            if annotate_argc:\n                annotate_node = node[i]\n                if annotate_node == 'expr':\n                    annotate_node = annotate_node[0]\n                    annotate_name_node = annotate_node[-1]\n                    if annotate_node == 'dict' and annotate_name_node.kind.startswith('BUILD_CONST_KEY_MAP'):\n                        types = [self.traverse(n, indent='') for n in annotate_node[:-2]]\n                        names = annotate_node[-2].attr\n                        l = len(types)\n                        assert l == len(names)\n                        for i in range(l):\n                            annotate_dict[names[i]] = types[i]\n                        pass\n                    pass\n                i -= 1\n            if kw_args:\n                kw_node = node[i]\n                if kw_node == 'expr':\n                    kw_node = kw_node[0]\n                if kw_node == 'dict':\n                    kw_pairs = kw_node[-1].attr\n        have_kwargs = node[0].kind.startswith('kwarg') or node[0] == 'no_kwargs'\n        if len(node) >= 4:\n            lc_index = -4\n        else:\n            lc_index = -3\n            pass\n        if len(node) > 2 and (have_kwargs or node[lc_index].kind != 'load_closure'):\n            default_values_start = 0\n            if node[0] == 'no_kwargs':\n                default_values_start += 1\n            if node[default_values_start] == 'kwarg':\n                assert node[lambda_index] == 'LOAD_LAMBDA'\n                i = default_values_start\n                defparams = []\n                while node[i] == 'kwarg':\n                    defparams.append(node[i][1])\n                    i += 1\n            else:\n                if node[default_values_start] == 'kwargs':\n                    default_values_start += 1\n                defparams = node[default_values_start:default_values_start + args_node.attr[0]]\n        else:\n            defparams = node[:args_node.attr[0]]\n            kw_args = 0\n    else:\n        defparams = node[:args_node.attr]\n        kw_args = 0\n        pass\n    if lambda_index and is_lambda and iscode(node[lambda_index].attr):\n        assert node[lambda_index].kind == 'LOAD_LAMBDA'\n        code = node[lambda_index].attr\n    else:\n        code = code_node.attr\n    assert iscode(code)\n    scanner_code = Code(code, self.scanner, self.currentclass)\n    argc = code.co_argcount\n    kwonlyargcount = code.co_kwonlyargcount\n    paramnames = list(scanner_code.co_varnames[:argc])\n    if kwonlyargcount > 0:\n        if is_lambda:\n            kwargs = []\n            for i in range(kwonlyargcount):\n                paramnames.append(scanner_code.co_varnames[argc + i])\n            pass\n        else:\n            kwargs = list(scanner_code.co_varnames[argc:argc + kwonlyargcount])\n    paramnames.reverse()\n    defparams.reverse()\n    try:\n        ast = self.build_ast(scanner_code._tokens, scanner_code._customize, scanner_code, is_lambda=is_lambda, noneInNames='None' in code.co_names)\n    except (ParserError, ParserError2) as p:\n        self.write(str(p))\n        if not self.tolerate_errors:\n            self.ERROR = p\n        return\n    kw_pairs = 0\n    i = len(paramnames) - len(defparams)\n    params = []\n    if defparams:\n        for (i, defparam) in enumerate(defparams):\n            params.append(build_param(ast, paramnames[i], defparam, annotate_dict.get(paramnames[i])))\n        for param in paramnames[i + 1:]:\n            if param in annotate_dict:\n                params.append('%s: %s' % (param, annotate_dict[param]))\n            else:\n                params.append(param)\n    else:\n        for param in paramnames:\n            if param in annotate_dict:\n                params.append('%s: %s' % (param, annotate_dict[param]))\n            else:\n                params.append(param)\n    params.reverse()\n    if code_has_star_arg(code):\n        star_arg = code.co_varnames[argc + kwonlyargcount]\n        if annotate_dict and star_arg in annotate_dict:\n            params.append('*%s: %s' % (star_arg, annotate_dict[star_arg]))\n        else:\n            params.append('*%s' % star_arg)\n            pass\n        if is_lambda:\n            params.reverse()\n        if not is_lambda:\n            argc += 1\n        pass\n    elif is_lambda and kwonlyargcount > 0:\n        params.insert(0, '*')\n        kwonlyargcount = 0\n    if is_lambda:\n        self.write('lambda ', ', '.join(params))\n        if len(ast) > 1 and self.traverse(ast[-1]) == 'None' and self.traverse(ast[-2]).strip().startswith('yield'):\n            del ast[-1]\n            ast_expr = ast[-1]\n            while ast_expr.kind != 'expr':\n                ast_expr = ast_expr[0]\n            ast[-1] = ast_expr\n            pass\n    else:\n        self.write('(', ', '.join(params))\n    ends_in_comma = False\n    if kwonlyargcount > 0:\n        if not 4 & code.co_flags:\n            if argc > 0:\n                self.write(', *, ')\n            else:\n                self.write('*, ')\n            pass\n            ends_in_comma = True\n        elif argc > 0 and node[0] != 'kwarg':\n            self.write(', ')\n            ends_in_comma = True\n        kw_args = [None] * kwonlyargcount\n        if self.version <= (3, 3):\n            kw_nodes = node[0]\n        else:\n            kw_nodes = node[args_node.attr[0]]\n        if kw_nodes == 'kwargs':\n            for n in kw_nodes:\n                name = eval(n[0].pattr)\n                default = self.traverse(n[1], indent='')\n                idx = kwargs.index(name)\n                kw_args[idx] = '%s=%s' % (name, default)\n                pass\n            pass\n        if kw_nodes != 'kwarg' or self.version == 3.5:\n            other_kw = [c == None for c in kw_args]\n            for (i, flag) in enumerate(other_kw):\n                if flag:\n                    if i < len(kwargs):\n                        kw_args[i] = '%s' % kwargs[i]\n                    else:\n                        del kw_args[i]\n                    pass\n            self.write(', '.join(kw_args))\n            ends_in_comma = False\n            pass\n        pass\n    elif argc == 0:\n        ends_in_comma = True\n    if code_has_star_star_arg(code):\n        if not ends_in_comma:\n            self.write(', ')\n        star_star_arg = code.co_varnames[argc + kwonlyargcount]\n        if annotate_dict and star_star_arg in annotate_dict:\n            self.write('**%s: %s' % (star_star_arg, annotate_dict[star_star_arg]))\n        else:\n            self.write('**%s' % star_star_arg)\n    if is_lambda:\n        self.write(': ')\n    else:\n        self.write(')')\n        if annotate_dict and 'return' in annotate_dict:\n            self.write(' -> %s' % annotate_dict['return'])\n        self.println(':')\n    if len(code.co_consts) > 0 and code.co_consts[0] is not None and (not is_lambda):\n        print_docstring(self, self.indent, code.co_consts[0])\n    assert ast == 'stmts'\n    all_globals = find_all_globals(ast, set())\n    (globals, nonlocals) = find_globals_and_nonlocals(ast, set(), set(), code, self.version)\n    for g in sorted(all_globals & self.mod_globs | globals):\n        self.println(self.indent, 'global ', g)\n    for nl in sorted(nonlocals):\n        self.println(self.indent, 'nonlocal ', nl)\n    self.mod_globs -= all_globals\n    has_none = 'None' in code.co_names\n    rn = has_none and (not find_none(ast))\n    self.gen_source(ast, code.co_name, scanner_code._customize, is_lambda=is_lambda, returnNone=rn, debug_opts=self.debug_opts)\n    if not is_lambda and code.co_flags & CO_GENERATOR:\n        need_bogus_yield = True\n        for token in scanner_code._tokens:\n            if token in ('YIELD_VALUE', 'YIELD_FROM'):\n                need_bogus_yield = False\n                break\n            pass\n        if need_bogus_yield:\n            self.template_engine(('%|if False:\\n%+%|yield None%-',), node)\n    scanner_code._tokens = None\n    scanner_code._customize = None",
            "def make_function3(self, node, is_lambda, nested=1, code_node=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Dump function definition, doc string, and function body in\\n      Python version 3.0 and above\\n    '\n\n    def build_param(ast, name, default, annotation=None):\n        \"\"\"build parameters:\n            - handle defaults\n            - handle format tuple parameters\n        \"\"\"\n        value = self.traverse(default, indent='')\n        maybe_show_tree_param_default(self.showast, name, value)\n        if annotation:\n            result = '%s: %s=%s' % (name, annotation, value)\n        else:\n            result = '%s=%s' % (name, value)\n        if result[-2:] == '= ':\n            result += 'None'\n        return result\n    assert node[-1].kind.startswith('MAKE_')\n    if (3, 0) <= self.version <= (3, 2):\n        lambda_index = -2\n    elif (3, 3) <= self.version:\n        lambda_index = -3\n    else:\n        lambda_index = None\n    args_node = node[-1]\n    annotate_dict = {}\n    args_attr = args_node.attr\n    if isinstance(args_attr, tuple):\n        if len(args_attr) == 3:\n            (pos_args, kw_args, annotate_argc) = args_attr\n        else:\n            (pos_args, kw_args, annotate_argc, closure) = args_attr\n            i = -4\n            kw_pairs = 0\n            if closure:\n                i -= 1\n            if annotate_argc:\n                annotate_node = node[i]\n                if annotate_node == 'expr':\n                    annotate_node = annotate_node[0]\n                    annotate_name_node = annotate_node[-1]\n                    if annotate_node == 'dict' and annotate_name_node.kind.startswith('BUILD_CONST_KEY_MAP'):\n                        types = [self.traverse(n, indent='') for n in annotate_node[:-2]]\n                        names = annotate_node[-2].attr\n                        l = len(types)\n                        assert l == len(names)\n                        for i in range(l):\n                            annotate_dict[names[i]] = types[i]\n                        pass\n                    pass\n                i -= 1\n            if kw_args:\n                kw_node = node[i]\n                if kw_node == 'expr':\n                    kw_node = kw_node[0]\n                if kw_node == 'dict':\n                    kw_pairs = kw_node[-1].attr\n        have_kwargs = node[0].kind.startswith('kwarg') or node[0] == 'no_kwargs'\n        if len(node) >= 4:\n            lc_index = -4\n        else:\n            lc_index = -3\n            pass\n        if len(node) > 2 and (have_kwargs or node[lc_index].kind != 'load_closure'):\n            default_values_start = 0\n            if node[0] == 'no_kwargs':\n                default_values_start += 1\n            if node[default_values_start] == 'kwarg':\n                assert node[lambda_index] == 'LOAD_LAMBDA'\n                i = default_values_start\n                defparams = []\n                while node[i] == 'kwarg':\n                    defparams.append(node[i][1])\n                    i += 1\n            else:\n                if node[default_values_start] == 'kwargs':\n                    default_values_start += 1\n                defparams = node[default_values_start:default_values_start + args_node.attr[0]]\n        else:\n            defparams = node[:args_node.attr[0]]\n            kw_args = 0\n    else:\n        defparams = node[:args_node.attr]\n        kw_args = 0\n        pass\n    if lambda_index and is_lambda and iscode(node[lambda_index].attr):\n        assert node[lambda_index].kind == 'LOAD_LAMBDA'\n        code = node[lambda_index].attr\n    else:\n        code = code_node.attr\n    assert iscode(code)\n    scanner_code = Code(code, self.scanner, self.currentclass)\n    argc = code.co_argcount\n    kwonlyargcount = code.co_kwonlyargcount\n    paramnames = list(scanner_code.co_varnames[:argc])\n    if kwonlyargcount > 0:\n        if is_lambda:\n            kwargs = []\n            for i in range(kwonlyargcount):\n                paramnames.append(scanner_code.co_varnames[argc + i])\n            pass\n        else:\n            kwargs = list(scanner_code.co_varnames[argc:argc + kwonlyargcount])\n    paramnames.reverse()\n    defparams.reverse()\n    try:\n        ast = self.build_ast(scanner_code._tokens, scanner_code._customize, scanner_code, is_lambda=is_lambda, noneInNames='None' in code.co_names)\n    except (ParserError, ParserError2) as p:\n        self.write(str(p))\n        if not self.tolerate_errors:\n            self.ERROR = p\n        return\n    kw_pairs = 0\n    i = len(paramnames) - len(defparams)\n    params = []\n    if defparams:\n        for (i, defparam) in enumerate(defparams):\n            params.append(build_param(ast, paramnames[i], defparam, annotate_dict.get(paramnames[i])))\n        for param in paramnames[i + 1:]:\n            if param in annotate_dict:\n                params.append('%s: %s' % (param, annotate_dict[param]))\n            else:\n                params.append(param)\n    else:\n        for param in paramnames:\n            if param in annotate_dict:\n                params.append('%s: %s' % (param, annotate_dict[param]))\n            else:\n                params.append(param)\n    params.reverse()\n    if code_has_star_arg(code):\n        star_arg = code.co_varnames[argc + kwonlyargcount]\n        if annotate_dict and star_arg in annotate_dict:\n            params.append('*%s: %s' % (star_arg, annotate_dict[star_arg]))\n        else:\n            params.append('*%s' % star_arg)\n            pass\n        if is_lambda:\n            params.reverse()\n        if not is_lambda:\n            argc += 1\n        pass\n    elif is_lambda and kwonlyargcount > 0:\n        params.insert(0, '*')\n        kwonlyargcount = 0\n    if is_lambda:\n        self.write('lambda ', ', '.join(params))\n        if len(ast) > 1 and self.traverse(ast[-1]) == 'None' and self.traverse(ast[-2]).strip().startswith('yield'):\n            del ast[-1]\n            ast_expr = ast[-1]\n            while ast_expr.kind != 'expr':\n                ast_expr = ast_expr[0]\n            ast[-1] = ast_expr\n            pass\n    else:\n        self.write('(', ', '.join(params))\n    ends_in_comma = False\n    if kwonlyargcount > 0:\n        if not 4 & code.co_flags:\n            if argc > 0:\n                self.write(', *, ')\n            else:\n                self.write('*, ')\n            pass\n            ends_in_comma = True\n        elif argc > 0 and node[0] != 'kwarg':\n            self.write(', ')\n            ends_in_comma = True\n        kw_args = [None] * kwonlyargcount\n        if self.version <= (3, 3):\n            kw_nodes = node[0]\n        else:\n            kw_nodes = node[args_node.attr[0]]\n        if kw_nodes == 'kwargs':\n            for n in kw_nodes:\n                name = eval(n[0].pattr)\n                default = self.traverse(n[1], indent='')\n                idx = kwargs.index(name)\n                kw_args[idx] = '%s=%s' % (name, default)\n                pass\n            pass\n        if kw_nodes != 'kwarg' or self.version == 3.5:\n            other_kw = [c == None for c in kw_args]\n            for (i, flag) in enumerate(other_kw):\n                if flag:\n                    if i < len(kwargs):\n                        kw_args[i] = '%s' % kwargs[i]\n                    else:\n                        del kw_args[i]\n                    pass\n            self.write(', '.join(kw_args))\n            ends_in_comma = False\n            pass\n        pass\n    elif argc == 0:\n        ends_in_comma = True\n    if code_has_star_star_arg(code):\n        if not ends_in_comma:\n            self.write(', ')\n        star_star_arg = code.co_varnames[argc + kwonlyargcount]\n        if annotate_dict and star_star_arg in annotate_dict:\n            self.write('**%s: %s' % (star_star_arg, annotate_dict[star_star_arg]))\n        else:\n            self.write('**%s' % star_star_arg)\n    if is_lambda:\n        self.write(': ')\n    else:\n        self.write(')')\n        if annotate_dict and 'return' in annotate_dict:\n            self.write(' -> %s' % annotate_dict['return'])\n        self.println(':')\n    if len(code.co_consts) > 0 and code.co_consts[0] is not None and (not is_lambda):\n        print_docstring(self, self.indent, code.co_consts[0])\n    assert ast == 'stmts'\n    all_globals = find_all_globals(ast, set())\n    (globals, nonlocals) = find_globals_and_nonlocals(ast, set(), set(), code, self.version)\n    for g in sorted(all_globals & self.mod_globs | globals):\n        self.println(self.indent, 'global ', g)\n    for nl in sorted(nonlocals):\n        self.println(self.indent, 'nonlocal ', nl)\n    self.mod_globs -= all_globals\n    has_none = 'None' in code.co_names\n    rn = has_none and (not find_none(ast))\n    self.gen_source(ast, code.co_name, scanner_code._customize, is_lambda=is_lambda, returnNone=rn, debug_opts=self.debug_opts)\n    if not is_lambda and code.co_flags & CO_GENERATOR:\n        need_bogus_yield = True\n        for token in scanner_code._tokens:\n            if token in ('YIELD_VALUE', 'YIELD_FROM'):\n                need_bogus_yield = False\n                break\n            pass\n        if need_bogus_yield:\n            self.template_engine(('%|if False:\\n%+%|yield None%-',), node)\n    scanner_code._tokens = None\n    scanner_code._customize = None",
            "def make_function3(self, node, is_lambda, nested=1, code_node=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Dump function definition, doc string, and function body in\\n      Python version 3.0 and above\\n    '\n\n    def build_param(ast, name, default, annotation=None):\n        \"\"\"build parameters:\n            - handle defaults\n            - handle format tuple parameters\n        \"\"\"\n        value = self.traverse(default, indent='')\n        maybe_show_tree_param_default(self.showast, name, value)\n        if annotation:\n            result = '%s: %s=%s' % (name, annotation, value)\n        else:\n            result = '%s=%s' % (name, value)\n        if result[-2:] == '= ':\n            result += 'None'\n        return result\n    assert node[-1].kind.startswith('MAKE_')\n    if (3, 0) <= self.version <= (3, 2):\n        lambda_index = -2\n    elif (3, 3) <= self.version:\n        lambda_index = -3\n    else:\n        lambda_index = None\n    args_node = node[-1]\n    annotate_dict = {}\n    args_attr = args_node.attr\n    if isinstance(args_attr, tuple):\n        if len(args_attr) == 3:\n            (pos_args, kw_args, annotate_argc) = args_attr\n        else:\n            (pos_args, kw_args, annotate_argc, closure) = args_attr\n            i = -4\n            kw_pairs = 0\n            if closure:\n                i -= 1\n            if annotate_argc:\n                annotate_node = node[i]\n                if annotate_node == 'expr':\n                    annotate_node = annotate_node[0]\n                    annotate_name_node = annotate_node[-1]\n                    if annotate_node == 'dict' and annotate_name_node.kind.startswith('BUILD_CONST_KEY_MAP'):\n                        types = [self.traverse(n, indent='') for n in annotate_node[:-2]]\n                        names = annotate_node[-2].attr\n                        l = len(types)\n                        assert l == len(names)\n                        for i in range(l):\n                            annotate_dict[names[i]] = types[i]\n                        pass\n                    pass\n                i -= 1\n            if kw_args:\n                kw_node = node[i]\n                if kw_node == 'expr':\n                    kw_node = kw_node[0]\n                if kw_node == 'dict':\n                    kw_pairs = kw_node[-1].attr\n        have_kwargs = node[0].kind.startswith('kwarg') or node[0] == 'no_kwargs'\n        if len(node) >= 4:\n            lc_index = -4\n        else:\n            lc_index = -3\n            pass\n        if len(node) > 2 and (have_kwargs or node[lc_index].kind != 'load_closure'):\n            default_values_start = 0\n            if node[0] == 'no_kwargs':\n                default_values_start += 1\n            if node[default_values_start] == 'kwarg':\n                assert node[lambda_index] == 'LOAD_LAMBDA'\n                i = default_values_start\n                defparams = []\n                while node[i] == 'kwarg':\n                    defparams.append(node[i][1])\n                    i += 1\n            else:\n                if node[default_values_start] == 'kwargs':\n                    default_values_start += 1\n                defparams = node[default_values_start:default_values_start + args_node.attr[0]]\n        else:\n            defparams = node[:args_node.attr[0]]\n            kw_args = 0\n    else:\n        defparams = node[:args_node.attr]\n        kw_args = 0\n        pass\n    if lambda_index and is_lambda and iscode(node[lambda_index].attr):\n        assert node[lambda_index].kind == 'LOAD_LAMBDA'\n        code = node[lambda_index].attr\n    else:\n        code = code_node.attr\n    assert iscode(code)\n    scanner_code = Code(code, self.scanner, self.currentclass)\n    argc = code.co_argcount\n    kwonlyargcount = code.co_kwonlyargcount\n    paramnames = list(scanner_code.co_varnames[:argc])\n    if kwonlyargcount > 0:\n        if is_lambda:\n            kwargs = []\n            for i in range(kwonlyargcount):\n                paramnames.append(scanner_code.co_varnames[argc + i])\n            pass\n        else:\n            kwargs = list(scanner_code.co_varnames[argc:argc + kwonlyargcount])\n    paramnames.reverse()\n    defparams.reverse()\n    try:\n        ast = self.build_ast(scanner_code._tokens, scanner_code._customize, scanner_code, is_lambda=is_lambda, noneInNames='None' in code.co_names)\n    except (ParserError, ParserError2) as p:\n        self.write(str(p))\n        if not self.tolerate_errors:\n            self.ERROR = p\n        return\n    kw_pairs = 0\n    i = len(paramnames) - len(defparams)\n    params = []\n    if defparams:\n        for (i, defparam) in enumerate(defparams):\n            params.append(build_param(ast, paramnames[i], defparam, annotate_dict.get(paramnames[i])))\n        for param in paramnames[i + 1:]:\n            if param in annotate_dict:\n                params.append('%s: %s' % (param, annotate_dict[param]))\n            else:\n                params.append(param)\n    else:\n        for param in paramnames:\n            if param in annotate_dict:\n                params.append('%s: %s' % (param, annotate_dict[param]))\n            else:\n                params.append(param)\n    params.reverse()\n    if code_has_star_arg(code):\n        star_arg = code.co_varnames[argc + kwonlyargcount]\n        if annotate_dict and star_arg in annotate_dict:\n            params.append('*%s: %s' % (star_arg, annotate_dict[star_arg]))\n        else:\n            params.append('*%s' % star_arg)\n            pass\n        if is_lambda:\n            params.reverse()\n        if not is_lambda:\n            argc += 1\n        pass\n    elif is_lambda and kwonlyargcount > 0:\n        params.insert(0, '*')\n        kwonlyargcount = 0\n    if is_lambda:\n        self.write('lambda ', ', '.join(params))\n        if len(ast) > 1 and self.traverse(ast[-1]) == 'None' and self.traverse(ast[-2]).strip().startswith('yield'):\n            del ast[-1]\n            ast_expr = ast[-1]\n            while ast_expr.kind != 'expr':\n                ast_expr = ast_expr[0]\n            ast[-1] = ast_expr\n            pass\n    else:\n        self.write('(', ', '.join(params))\n    ends_in_comma = False\n    if kwonlyargcount > 0:\n        if not 4 & code.co_flags:\n            if argc > 0:\n                self.write(', *, ')\n            else:\n                self.write('*, ')\n            pass\n            ends_in_comma = True\n        elif argc > 0 and node[0] != 'kwarg':\n            self.write(', ')\n            ends_in_comma = True\n        kw_args = [None] * kwonlyargcount\n        if self.version <= (3, 3):\n            kw_nodes = node[0]\n        else:\n            kw_nodes = node[args_node.attr[0]]\n        if kw_nodes == 'kwargs':\n            for n in kw_nodes:\n                name = eval(n[0].pattr)\n                default = self.traverse(n[1], indent='')\n                idx = kwargs.index(name)\n                kw_args[idx] = '%s=%s' % (name, default)\n                pass\n            pass\n        if kw_nodes != 'kwarg' or self.version == 3.5:\n            other_kw = [c == None for c in kw_args]\n            for (i, flag) in enumerate(other_kw):\n                if flag:\n                    if i < len(kwargs):\n                        kw_args[i] = '%s' % kwargs[i]\n                    else:\n                        del kw_args[i]\n                    pass\n            self.write(', '.join(kw_args))\n            ends_in_comma = False\n            pass\n        pass\n    elif argc == 0:\n        ends_in_comma = True\n    if code_has_star_star_arg(code):\n        if not ends_in_comma:\n            self.write(', ')\n        star_star_arg = code.co_varnames[argc + kwonlyargcount]\n        if annotate_dict and star_star_arg in annotate_dict:\n            self.write('**%s: %s' % (star_star_arg, annotate_dict[star_star_arg]))\n        else:\n            self.write('**%s' % star_star_arg)\n    if is_lambda:\n        self.write(': ')\n    else:\n        self.write(')')\n        if annotate_dict and 'return' in annotate_dict:\n            self.write(' -> %s' % annotate_dict['return'])\n        self.println(':')\n    if len(code.co_consts) > 0 and code.co_consts[0] is not None and (not is_lambda):\n        print_docstring(self, self.indent, code.co_consts[0])\n    assert ast == 'stmts'\n    all_globals = find_all_globals(ast, set())\n    (globals, nonlocals) = find_globals_and_nonlocals(ast, set(), set(), code, self.version)\n    for g in sorted(all_globals & self.mod_globs | globals):\n        self.println(self.indent, 'global ', g)\n    for nl in sorted(nonlocals):\n        self.println(self.indent, 'nonlocal ', nl)\n    self.mod_globs -= all_globals\n    has_none = 'None' in code.co_names\n    rn = has_none and (not find_none(ast))\n    self.gen_source(ast, code.co_name, scanner_code._customize, is_lambda=is_lambda, returnNone=rn, debug_opts=self.debug_opts)\n    if not is_lambda and code.co_flags & CO_GENERATOR:\n        need_bogus_yield = True\n        for token in scanner_code._tokens:\n            if token in ('YIELD_VALUE', 'YIELD_FROM'):\n                need_bogus_yield = False\n                break\n            pass\n        if need_bogus_yield:\n            self.template_engine(('%|if False:\\n%+%|yield None%-',), node)\n    scanner_code._tokens = None\n    scanner_code._customize = None"
        ]
    }
]