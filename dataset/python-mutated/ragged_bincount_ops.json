[
    {
        "func_name": "bincount",
        "original": "@dispatch.dispatch_for_api(bincount_ops.bincount)\ndef bincount(arr: ragged_tensor.RaggedTensor, weights=None, minlength=None, maxlength=None, dtype=dtypes.int32, name=None, axis=None, binary_output=False):\n    \"\"\"Counts the number of occurrences of each value in an integer array.\n\n  If `minlength` and `maxlength` are not given, returns a vector with length\n  `tf.reduce_max(arr) + 1` if `arr` is non-empty, and length 0 otherwise.\n\n  >>> data = tf.ragged.constant([[1, 1], [2, 3, 2, 4, 4, 5]])\n  >>> tf.math.bincount(data)\n  <tf.Tensor: ... numpy=array([0, 2, 2, 1, 2, 1], dtype=int32)>\n\n  Vector length = Maximum element in vector `values` is 5. Adding 1, which is 6\n                  will be the vector length.\n\n  Each bin value in the output indicates number of occurrences of the particular\n  index. Here, index 1 in output has a value 2. This indicates value 1 occurs\n  two times in `values`.\n\n  **Bin-counting with weights**\n\n  >>> data = tf.ragged.constant([[1, 1], [2, 3, 2, 4, 4, 5]])\n  >>> weights = tf.ragged.constant([[1, 5], [0, 1, 0, 5, 4, 5]])\n  >>> tf.math.bincount(data, weights=weights)\n  <tf.Tensor: ... numpy=array([0, 6, 0, 1, 9, 5], dtype=int32)>\n\n  When `weights` is specified, bins will be incremented by the corresponding\n  weight instead of 1. Here, index 1 in output has a value 6. This is the\n  summation of `weights` corresponding to the value in `arr` (i.e. for index\n  1, the first two values `arr` are 1 so the first two weights, 1 and 5, are\n  summed).\n\n  There is an equivilance between bin-counting with weights and\n  `unsorted_segement_sum` where `data` is the weights and `segment_ids` are the\n  values.\n\n  >>> data = tf.ragged.constant([[1, 1], [2, 3, 2, 4, 4, 5]])\n  >>> weights = tf.ragged.constant([[1, 5], [0, 1, 0, 5, 4, 5]])\n  >>> tf.math.unsorted_segment_sum(weights, data, num_segments=6).numpy()\n  array([0, 6, 0, 1, 9, 5], dtype=int32)\n\n  On GPU, `bincount` with weights is only supported when XLA is enabled\n  (typically when a function decorated with `@tf.function(jit_compile=True)`).\n  `unsorted_segment_sum` can be used as a workaround for the non-XLA case on\n  GPU.\n\n  **Bin-counting matrix rows independently**\n\n  This example uses `axis=-1` with a 2 dimensional input and returns a\n  `Tensor` with bincounting where axis 0 is **not** flattened, i.e. an\n  independent bincount for each matrix row.\n\n  >>> data = tf.ragged.constant([[1, 2], [3, 0, 0, 0, 1, 2]], dtype=np.int32)\n  >>> tf.math.bincount(data, axis=-1)\n  <tf.Tensor: shape=(2, 4), dtype=int32, numpy=\n    array([[0, 1, 1, 0],\n           [3, 1, 1, 1]], dtype=int32)>\n\n  **Bin-counting with binary_output**\n\n  This example gives binary output instead of counting the occurrence.\n\n  >>> data = tf.ragged.constant([[1, 2], [3, 0, 0, 0, 1, 2]], dtype=np.int32)\n  >>> tf.math.bincount(data, axis=-1, binary_output=True)\n  <tf.Tensor: shape=(2, 4), dtype=int32, numpy=\n    array([[0, 1, 1, 0],\n           [1, 1, 1, 1]], dtype=int32)>\n\n  Args:\n    arr: A RaggedTensor whose values should be counted.\n      These tensors must have a rank of 2 if `axis=-1`.\n    weights: If non-None, must be a RaggedTensor with the same row splits as\n      `arr`. For each value in `arr`, the bin will be incremented by the\n      corresponding weight instead of 1. If non-None, `binary_output` must be\n      False.\n    minlength: If given, ensures the output has length at least `minlength`,\n      padding with zeros at the end if necessary.\n    maxlength: If given, skips values in `arr` that are equal or greater than\n      `maxlength`, ensuring that the output has length at most `maxlength`.\n    dtype: If `weights` is None, determines the type of the output bins.\n    name: A name scope for the associated operations (optional).\n    axis: The axis to slice over. Axes at and below `axis` will be flattened\n      before bin counting. Currently, only `0`, and `-1` are supported. If None,\n      all axes will be flattened (identical to passing `0`).\n    binary_output: If True, this op will output 1 instead of the number of times\n      a token appears (equivalent to one_hot + reduce_any instead of one_hot +\n      reduce_add). Defaults to False.\n\n  Returns:\n    A vector with the same dtype as `weights` or the given `dtype` containing\n    the bincount values.\n\n  Raises:\n    `InvalidArgumentError` if negative values are provided as an input.\n\n  \"\"\"\n    name = 'bincount' if name is None else name\n    with ops.name_scope(name):\n        arr = ragged_tensor.convert_to_tensor_or_ragged_tensor(arr, name='arr')\n        if weights is not None:\n            if not isinstance(weights, sparse_tensor.SparseTensor):\n                weights = ragged_tensor.convert_to_tensor_or_ragged_tensor(weights, name='weights')\n        if weights is not None and binary_output:\n            raise ValueError('Arguments `binary_output` and `weights` are mutually exclusive. Please specify only one.')\n        if not arr.dtype.is_integer:\n            arr = math_ops.cast(arr, dtypes.int32)\n        if axis is None:\n            axis = 0\n        if axis not in [0, -1]:\n            raise ValueError(f'Unsupported value for argument axis={axis}. Only 0 and -1 are currently supported.')\n        array_is_nonempty = array_ops.size(arr) > 0\n        output_size = math_ops.cast(array_is_nonempty, arr.dtype) * (math_ops.reduce_max(arr) + 1)\n        if minlength is not None:\n            minlength = ops.convert_to_tensor(minlength, name='minlength', dtype=arr.dtype)\n            output_size = gen_math_ops.maximum(minlength, output_size)\n        if maxlength is not None:\n            maxlength = ops.convert_to_tensor(maxlength, name='maxlength', dtype=arr.dtype)\n            output_size = gen_math_ops.minimum(maxlength, output_size)\n        if axis == 0:\n            while isinstance(arr, ragged_tensor.RaggedTensor):\n                if weights is not None:\n                    weights = validate_ragged_weights(arr, weights, dtype)\n                arr = arr.values\n        if isinstance(arr, ragged_tensor.RaggedTensor):\n            weights = validate_ragged_weights(arr, weights, dtype)\n            return gen_math_ops.ragged_bincount(splits=arr.row_splits, values=arr.values, size=output_size, weights=weights, binary_output=binary_output)\n        else:\n            weights = bincount_ops.validate_dense_weights(arr, weights, dtype)\n            return gen_math_ops.dense_bincount(input=arr, size=output_size, weights=weights, binary_output=binary_output)",
        "mutated": [
            "@dispatch.dispatch_for_api(bincount_ops.bincount)\ndef bincount(arr: ragged_tensor.RaggedTensor, weights=None, minlength=None, maxlength=None, dtype=dtypes.int32, name=None, axis=None, binary_output=False):\n    if False:\n        i = 10\n    'Counts the number of occurrences of each value in an integer array.\\n\\n  If `minlength` and `maxlength` are not given, returns a vector with length\\n  `tf.reduce_max(arr) + 1` if `arr` is non-empty, and length 0 otherwise.\\n\\n  >>> data = tf.ragged.constant([[1, 1], [2, 3, 2, 4, 4, 5]])\\n  >>> tf.math.bincount(data)\\n  <tf.Tensor: ... numpy=array([0, 2, 2, 1, 2, 1], dtype=int32)>\\n\\n  Vector length = Maximum element in vector `values` is 5. Adding 1, which is 6\\n                  will be the vector length.\\n\\n  Each bin value in the output indicates number of occurrences of the particular\\n  index. Here, index 1 in output has a value 2. This indicates value 1 occurs\\n  two times in `values`.\\n\\n  **Bin-counting with weights**\\n\\n  >>> data = tf.ragged.constant([[1, 1], [2, 3, 2, 4, 4, 5]])\\n  >>> weights = tf.ragged.constant([[1, 5], [0, 1, 0, 5, 4, 5]])\\n  >>> tf.math.bincount(data, weights=weights)\\n  <tf.Tensor: ... numpy=array([0, 6, 0, 1, 9, 5], dtype=int32)>\\n\\n  When `weights` is specified, bins will be incremented by the corresponding\\n  weight instead of 1. Here, index 1 in output has a value 6. This is the\\n  summation of `weights` corresponding to the value in `arr` (i.e. for index\\n  1, the first two values `arr` are 1 so the first two weights, 1 and 5, are\\n  summed).\\n\\n  There is an equivilance between bin-counting with weights and\\n  `unsorted_segement_sum` where `data` is the weights and `segment_ids` are the\\n  values.\\n\\n  >>> data = tf.ragged.constant([[1, 1], [2, 3, 2, 4, 4, 5]])\\n  >>> weights = tf.ragged.constant([[1, 5], [0, 1, 0, 5, 4, 5]])\\n  >>> tf.math.unsorted_segment_sum(weights, data, num_segments=6).numpy()\\n  array([0, 6, 0, 1, 9, 5], dtype=int32)\\n\\n  On GPU, `bincount` with weights is only supported when XLA is enabled\\n  (typically when a function decorated with `@tf.function(jit_compile=True)`).\\n  `unsorted_segment_sum` can be used as a workaround for the non-XLA case on\\n  GPU.\\n\\n  **Bin-counting matrix rows independently**\\n\\n  This example uses `axis=-1` with a 2 dimensional input and returns a\\n  `Tensor` with bincounting where axis 0 is **not** flattened, i.e. an\\n  independent bincount for each matrix row.\\n\\n  >>> data = tf.ragged.constant([[1, 2], [3, 0, 0, 0, 1, 2]], dtype=np.int32)\\n  >>> tf.math.bincount(data, axis=-1)\\n  <tf.Tensor: shape=(2, 4), dtype=int32, numpy=\\n    array([[0, 1, 1, 0],\\n           [3, 1, 1, 1]], dtype=int32)>\\n\\n  **Bin-counting with binary_output**\\n\\n  This example gives binary output instead of counting the occurrence.\\n\\n  >>> data = tf.ragged.constant([[1, 2], [3, 0, 0, 0, 1, 2]], dtype=np.int32)\\n  >>> tf.math.bincount(data, axis=-1, binary_output=True)\\n  <tf.Tensor: shape=(2, 4), dtype=int32, numpy=\\n    array([[0, 1, 1, 0],\\n           [1, 1, 1, 1]], dtype=int32)>\\n\\n  Args:\\n    arr: A RaggedTensor whose values should be counted.\\n      These tensors must have a rank of 2 if `axis=-1`.\\n    weights: If non-None, must be a RaggedTensor with the same row splits as\\n      `arr`. For each value in `arr`, the bin will be incremented by the\\n      corresponding weight instead of 1. If non-None, `binary_output` must be\\n      False.\\n    minlength: If given, ensures the output has length at least `minlength`,\\n      padding with zeros at the end if necessary.\\n    maxlength: If given, skips values in `arr` that are equal or greater than\\n      `maxlength`, ensuring that the output has length at most `maxlength`.\\n    dtype: If `weights` is None, determines the type of the output bins.\\n    name: A name scope for the associated operations (optional).\\n    axis: The axis to slice over. Axes at and below `axis` will be flattened\\n      before bin counting. Currently, only `0`, and `-1` are supported. If None,\\n      all axes will be flattened (identical to passing `0`).\\n    binary_output: If True, this op will output 1 instead of the number of times\\n      a token appears (equivalent to one_hot + reduce_any instead of one_hot +\\n      reduce_add). Defaults to False.\\n\\n  Returns:\\n    A vector with the same dtype as `weights` or the given `dtype` containing\\n    the bincount values.\\n\\n  Raises:\\n    `InvalidArgumentError` if negative values are provided as an input.\\n\\n  '\n    name = 'bincount' if name is None else name\n    with ops.name_scope(name):\n        arr = ragged_tensor.convert_to_tensor_or_ragged_tensor(arr, name='arr')\n        if weights is not None:\n            if not isinstance(weights, sparse_tensor.SparseTensor):\n                weights = ragged_tensor.convert_to_tensor_or_ragged_tensor(weights, name='weights')\n        if weights is not None and binary_output:\n            raise ValueError('Arguments `binary_output` and `weights` are mutually exclusive. Please specify only one.')\n        if not arr.dtype.is_integer:\n            arr = math_ops.cast(arr, dtypes.int32)\n        if axis is None:\n            axis = 0\n        if axis not in [0, -1]:\n            raise ValueError(f'Unsupported value for argument axis={axis}. Only 0 and -1 are currently supported.')\n        array_is_nonempty = array_ops.size(arr) > 0\n        output_size = math_ops.cast(array_is_nonempty, arr.dtype) * (math_ops.reduce_max(arr) + 1)\n        if minlength is not None:\n            minlength = ops.convert_to_tensor(minlength, name='minlength', dtype=arr.dtype)\n            output_size = gen_math_ops.maximum(minlength, output_size)\n        if maxlength is not None:\n            maxlength = ops.convert_to_tensor(maxlength, name='maxlength', dtype=arr.dtype)\n            output_size = gen_math_ops.minimum(maxlength, output_size)\n        if axis == 0:\n            while isinstance(arr, ragged_tensor.RaggedTensor):\n                if weights is not None:\n                    weights = validate_ragged_weights(arr, weights, dtype)\n                arr = arr.values\n        if isinstance(arr, ragged_tensor.RaggedTensor):\n            weights = validate_ragged_weights(arr, weights, dtype)\n            return gen_math_ops.ragged_bincount(splits=arr.row_splits, values=arr.values, size=output_size, weights=weights, binary_output=binary_output)\n        else:\n            weights = bincount_ops.validate_dense_weights(arr, weights, dtype)\n            return gen_math_ops.dense_bincount(input=arr, size=output_size, weights=weights, binary_output=binary_output)",
            "@dispatch.dispatch_for_api(bincount_ops.bincount)\ndef bincount(arr: ragged_tensor.RaggedTensor, weights=None, minlength=None, maxlength=None, dtype=dtypes.int32, name=None, axis=None, binary_output=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Counts the number of occurrences of each value in an integer array.\\n\\n  If `minlength` and `maxlength` are not given, returns a vector with length\\n  `tf.reduce_max(arr) + 1` if `arr` is non-empty, and length 0 otherwise.\\n\\n  >>> data = tf.ragged.constant([[1, 1], [2, 3, 2, 4, 4, 5]])\\n  >>> tf.math.bincount(data)\\n  <tf.Tensor: ... numpy=array([0, 2, 2, 1, 2, 1], dtype=int32)>\\n\\n  Vector length = Maximum element in vector `values` is 5. Adding 1, which is 6\\n                  will be the vector length.\\n\\n  Each bin value in the output indicates number of occurrences of the particular\\n  index. Here, index 1 in output has a value 2. This indicates value 1 occurs\\n  two times in `values`.\\n\\n  **Bin-counting with weights**\\n\\n  >>> data = tf.ragged.constant([[1, 1], [2, 3, 2, 4, 4, 5]])\\n  >>> weights = tf.ragged.constant([[1, 5], [0, 1, 0, 5, 4, 5]])\\n  >>> tf.math.bincount(data, weights=weights)\\n  <tf.Tensor: ... numpy=array([0, 6, 0, 1, 9, 5], dtype=int32)>\\n\\n  When `weights` is specified, bins will be incremented by the corresponding\\n  weight instead of 1. Here, index 1 in output has a value 6. This is the\\n  summation of `weights` corresponding to the value in `arr` (i.e. for index\\n  1, the first two values `arr` are 1 so the first two weights, 1 and 5, are\\n  summed).\\n\\n  There is an equivilance between bin-counting with weights and\\n  `unsorted_segement_sum` where `data` is the weights and `segment_ids` are the\\n  values.\\n\\n  >>> data = tf.ragged.constant([[1, 1], [2, 3, 2, 4, 4, 5]])\\n  >>> weights = tf.ragged.constant([[1, 5], [0, 1, 0, 5, 4, 5]])\\n  >>> tf.math.unsorted_segment_sum(weights, data, num_segments=6).numpy()\\n  array([0, 6, 0, 1, 9, 5], dtype=int32)\\n\\n  On GPU, `bincount` with weights is only supported when XLA is enabled\\n  (typically when a function decorated with `@tf.function(jit_compile=True)`).\\n  `unsorted_segment_sum` can be used as a workaround for the non-XLA case on\\n  GPU.\\n\\n  **Bin-counting matrix rows independently**\\n\\n  This example uses `axis=-1` with a 2 dimensional input and returns a\\n  `Tensor` with bincounting where axis 0 is **not** flattened, i.e. an\\n  independent bincount for each matrix row.\\n\\n  >>> data = tf.ragged.constant([[1, 2], [3, 0, 0, 0, 1, 2]], dtype=np.int32)\\n  >>> tf.math.bincount(data, axis=-1)\\n  <tf.Tensor: shape=(2, 4), dtype=int32, numpy=\\n    array([[0, 1, 1, 0],\\n           [3, 1, 1, 1]], dtype=int32)>\\n\\n  **Bin-counting with binary_output**\\n\\n  This example gives binary output instead of counting the occurrence.\\n\\n  >>> data = tf.ragged.constant([[1, 2], [3, 0, 0, 0, 1, 2]], dtype=np.int32)\\n  >>> tf.math.bincount(data, axis=-1, binary_output=True)\\n  <tf.Tensor: shape=(2, 4), dtype=int32, numpy=\\n    array([[0, 1, 1, 0],\\n           [1, 1, 1, 1]], dtype=int32)>\\n\\n  Args:\\n    arr: A RaggedTensor whose values should be counted.\\n      These tensors must have a rank of 2 if `axis=-1`.\\n    weights: If non-None, must be a RaggedTensor with the same row splits as\\n      `arr`. For each value in `arr`, the bin will be incremented by the\\n      corresponding weight instead of 1. If non-None, `binary_output` must be\\n      False.\\n    minlength: If given, ensures the output has length at least `minlength`,\\n      padding with zeros at the end if necessary.\\n    maxlength: If given, skips values in `arr` that are equal or greater than\\n      `maxlength`, ensuring that the output has length at most `maxlength`.\\n    dtype: If `weights` is None, determines the type of the output bins.\\n    name: A name scope for the associated operations (optional).\\n    axis: The axis to slice over. Axes at and below `axis` will be flattened\\n      before bin counting. Currently, only `0`, and `-1` are supported. If None,\\n      all axes will be flattened (identical to passing `0`).\\n    binary_output: If True, this op will output 1 instead of the number of times\\n      a token appears (equivalent to one_hot + reduce_any instead of one_hot +\\n      reduce_add). Defaults to False.\\n\\n  Returns:\\n    A vector with the same dtype as `weights` or the given `dtype` containing\\n    the bincount values.\\n\\n  Raises:\\n    `InvalidArgumentError` if negative values are provided as an input.\\n\\n  '\n    name = 'bincount' if name is None else name\n    with ops.name_scope(name):\n        arr = ragged_tensor.convert_to_tensor_or_ragged_tensor(arr, name='arr')\n        if weights is not None:\n            if not isinstance(weights, sparse_tensor.SparseTensor):\n                weights = ragged_tensor.convert_to_tensor_or_ragged_tensor(weights, name='weights')\n        if weights is not None and binary_output:\n            raise ValueError('Arguments `binary_output` and `weights` are mutually exclusive. Please specify only one.')\n        if not arr.dtype.is_integer:\n            arr = math_ops.cast(arr, dtypes.int32)\n        if axis is None:\n            axis = 0\n        if axis not in [0, -1]:\n            raise ValueError(f'Unsupported value for argument axis={axis}. Only 0 and -1 are currently supported.')\n        array_is_nonempty = array_ops.size(arr) > 0\n        output_size = math_ops.cast(array_is_nonempty, arr.dtype) * (math_ops.reduce_max(arr) + 1)\n        if minlength is not None:\n            minlength = ops.convert_to_tensor(minlength, name='minlength', dtype=arr.dtype)\n            output_size = gen_math_ops.maximum(minlength, output_size)\n        if maxlength is not None:\n            maxlength = ops.convert_to_tensor(maxlength, name='maxlength', dtype=arr.dtype)\n            output_size = gen_math_ops.minimum(maxlength, output_size)\n        if axis == 0:\n            while isinstance(arr, ragged_tensor.RaggedTensor):\n                if weights is not None:\n                    weights = validate_ragged_weights(arr, weights, dtype)\n                arr = arr.values\n        if isinstance(arr, ragged_tensor.RaggedTensor):\n            weights = validate_ragged_weights(arr, weights, dtype)\n            return gen_math_ops.ragged_bincount(splits=arr.row_splits, values=arr.values, size=output_size, weights=weights, binary_output=binary_output)\n        else:\n            weights = bincount_ops.validate_dense_weights(arr, weights, dtype)\n            return gen_math_ops.dense_bincount(input=arr, size=output_size, weights=weights, binary_output=binary_output)",
            "@dispatch.dispatch_for_api(bincount_ops.bincount)\ndef bincount(arr: ragged_tensor.RaggedTensor, weights=None, minlength=None, maxlength=None, dtype=dtypes.int32, name=None, axis=None, binary_output=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Counts the number of occurrences of each value in an integer array.\\n\\n  If `minlength` and `maxlength` are not given, returns a vector with length\\n  `tf.reduce_max(arr) + 1` if `arr` is non-empty, and length 0 otherwise.\\n\\n  >>> data = tf.ragged.constant([[1, 1], [2, 3, 2, 4, 4, 5]])\\n  >>> tf.math.bincount(data)\\n  <tf.Tensor: ... numpy=array([0, 2, 2, 1, 2, 1], dtype=int32)>\\n\\n  Vector length = Maximum element in vector `values` is 5. Adding 1, which is 6\\n                  will be the vector length.\\n\\n  Each bin value in the output indicates number of occurrences of the particular\\n  index. Here, index 1 in output has a value 2. This indicates value 1 occurs\\n  two times in `values`.\\n\\n  **Bin-counting with weights**\\n\\n  >>> data = tf.ragged.constant([[1, 1], [2, 3, 2, 4, 4, 5]])\\n  >>> weights = tf.ragged.constant([[1, 5], [0, 1, 0, 5, 4, 5]])\\n  >>> tf.math.bincount(data, weights=weights)\\n  <tf.Tensor: ... numpy=array([0, 6, 0, 1, 9, 5], dtype=int32)>\\n\\n  When `weights` is specified, bins will be incremented by the corresponding\\n  weight instead of 1. Here, index 1 in output has a value 6. This is the\\n  summation of `weights` corresponding to the value in `arr` (i.e. for index\\n  1, the first two values `arr` are 1 so the first two weights, 1 and 5, are\\n  summed).\\n\\n  There is an equivilance between bin-counting with weights and\\n  `unsorted_segement_sum` where `data` is the weights and `segment_ids` are the\\n  values.\\n\\n  >>> data = tf.ragged.constant([[1, 1], [2, 3, 2, 4, 4, 5]])\\n  >>> weights = tf.ragged.constant([[1, 5], [0, 1, 0, 5, 4, 5]])\\n  >>> tf.math.unsorted_segment_sum(weights, data, num_segments=6).numpy()\\n  array([0, 6, 0, 1, 9, 5], dtype=int32)\\n\\n  On GPU, `bincount` with weights is only supported when XLA is enabled\\n  (typically when a function decorated with `@tf.function(jit_compile=True)`).\\n  `unsorted_segment_sum` can be used as a workaround for the non-XLA case on\\n  GPU.\\n\\n  **Bin-counting matrix rows independently**\\n\\n  This example uses `axis=-1` with a 2 dimensional input and returns a\\n  `Tensor` with bincounting where axis 0 is **not** flattened, i.e. an\\n  independent bincount for each matrix row.\\n\\n  >>> data = tf.ragged.constant([[1, 2], [3, 0, 0, 0, 1, 2]], dtype=np.int32)\\n  >>> tf.math.bincount(data, axis=-1)\\n  <tf.Tensor: shape=(2, 4), dtype=int32, numpy=\\n    array([[0, 1, 1, 0],\\n           [3, 1, 1, 1]], dtype=int32)>\\n\\n  **Bin-counting with binary_output**\\n\\n  This example gives binary output instead of counting the occurrence.\\n\\n  >>> data = tf.ragged.constant([[1, 2], [3, 0, 0, 0, 1, 2]], dtype=np.int32)\\n  >>> tf.math.bincount(data, axis=-1, binary_output=True)\\n  <tf.Tensor: shape=(2, 4), dtype=int32, numpy=\\n    array([[0, 1, 1, 0],\\n           [1, 1, 1, 1]], dtype=int32)>\\n\\n  Args:\\n    arr: A RaggedTensor whose values should be counted.\\n      These tensors must have a rank of 2 if `axis=-1`.\\n    weights: If non-None, must be a RaggedTensor with the same row splits as\\n      `arr`. For each value in `arr`, the bin will be incremented by the\\n      corresponding weight instead of 1. If non-None, `binary_output` must be\\n      False.\\n    minlength: If given, ensures the output has length at least `minlength`,\\n      padding with zeros at the end if necessary.\\n    maxlength: If given, skips values in `arr` that are equal or greater than\\n      `maxlength`, ensuring that the output has length at most `maxlength`.\\n    dtype: If `weights` is None, determines the type of the output bins.\\n    name: A name scope for the associated operations (optional).\\n    axis: The axis to slice over. Axes at and below `axis` will be flattened\\n      before bin counting. Currently, only `0`, and `-1` are supported. If None,\\n      all axes will be flattened (identical to passing `0`).\\n    binary_output: If True, this op will output 1 instead of the number of times\\n      a token appears (equivalent to one_hot + reduce_any instead of one_hot +\\n      reduce_add). Defaults to False.\\n\\n  Returns:\\n    A vector with the same dtype as `weights` or the given `dtype` containing\\n    the bincount values.\\n\\n  Raises:\\n    `InvalidArgumentError` if negative values are provided as an input.\\n\\n  '\n    name = 'bincount' if name is None else name\n    with ops.name_scope(name):\n        arr = ragged_tensor.convert_to_tensor_or_ragged_tensor(arr, name='arr')\n        if weights is not None:\n            if not isinstance(weights, sparse_tensor.SparseTensor):\n                weights = ragged_tensor.convert_to_tensor_or_ragged_tensor(weights, name='weights')\n        if weights is not None and binary_output:\n            raise ValueError('Arguments `binary_output` and `weights` are mutually exclusive. Please specify only one.')\n        if not arr.dtype.is_integer:\n            arr = math_ops.cast(arr, dtypes.int32)\n        if axis is None:\n            axis = 0\n        if axis not in [0, -1]:\n            raise ValueError(f'Unsupported value for argument axis={axis}. Only 0 and -1 are currently supported.')\n        array_is_nonempty = array_ops.size(arr) > 0\n        output_size = math_ops.cast(array_is_nonempty, arr.dtype) * (math_ops.reduce_max(arr) + 1)\n        if minlength is not None:\n            minlength = ops.convert_to_tensor(minlength, name='minlength', dtype=arr.dtype)\n            output_size = gen_math_ops.maximum(minlength, output_size)\n        if maxlength is not None:\n            maxlength = ops.convert_to_tensor(maxlength, name='maxlength', dtype=arr.dtype)\n            output_size = gen_math_ops.minimum(maxlength, output_size)\n        if axis == 0:\n            while isinstance(arr, ragged_tensor.RaggedTensor):\n                if weights is not None:\n                    weights = validate_ragged_weights(arr, weights, dtype)\n                arr = arr.values\n        if isinstance(arr, ragged_tensor.RaggedTensor):\n            weights = validate_ragged_weights(arr, weights, dtype)\n            return gen_math_ops.ragged_bincount(splits=arr.row_splits, values=arr.values, size=output_size, weights=weights, binary_output=binary_output)\n        else:\n            weights = bincount_ops.validate_dense_weights(arr, weights, dtype)\n            return gen_math_ops.dense_bincount(input=arr, size=output_size, weights=weights, binary_output=binary_output)",
            "@dispatch.dispatch_for_api(bincount_ops.bincount)\ndef bincount(arr: ragged_tensor.RaggedTensor, weights=None, minlength=None, maxlength=None, dtype=dtypes.int32, name=None, axis=None, binary_output=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Counts the number of occurrences of each value in an integer array.\\n\\n  If `minlength` and `maxlength` are not given, returns a vector with length\\n  `tf.reduce_max(arr) + 1` if `arr` is non-empty, and length 0 otherwise.\\n\\n  >>> data = tf.ragged.constant([[1, 1], [2, 3, 2, 4, 4, 5]])\\n  >>> tf.math.bincount(data)\\n  <tf.Tensor: ... numpy=array([0, 2, 2, 1, 2, 1], dtype=int32)>\\n\\n  Vector length = Maximum element in vector `values` is 5. Adding 1, which is 6\\n                  will be the vector length.\\n\\n  Each bin value in the output indicates number of occurrences of the particular\\n  index. Here, index 1 in output has a value 2. This indicates value 1 occurs\\n  two times in `values`.\\n\\n  **Bin-counting with weights**\\n\\n  >>> data = tf.ragged.constant([[1, 1], [2, 3, 2, 4, 4, 5]])\\n  >>> weights = tf.ragged.constant([[1, 5], [0, 1, 0, 5, 4, 5]])\\n  >>> tf.math.bincount(data, weights=weights)\\n  <tf.Tensor: ... numpy=array([0, 6, 0, 1, 9, 5], dtype=int32)>\\n\\n  When `weights` is specified, bins will be incremented by the corresponding\\n  weight instead of 1. Here, index 1 in output has a value 6. This is the\\n  summation of `weights` corresponding to the value in `arr` (i.e. for index\\n  1, the first two values `arr` are 1 so the first two weights, 1 and 5, are\\n  summed).\\n\\n  There is an equivilance between bin-counting with weights and\\n  `unsorted_segement_sum` where `data` is the weights and `segment_ids` are the\\n  values.\\n\\n  >>> data = tf.ragged.constant([[1, 1], [2, 3, 2, 4, 4, 5]])\\n  >>> weights = tf.ragged.constant([[1, 5], [0, 1, 0, 5, 4, 5]])\\n  >>> tf.math.unsorted_segment_sum(weights, data, num_segments=6).numpy()\\n  array([0, 6, 0, 1, 9, 5], dtype=int32)\\n\\n  On GPU, `bincount` with weights is only supported when XLA is enabled\\n  (typically when a function decorated with `@tf.function(jit_compile=True)`).\\n  `unsorted_segment_sum` can be used as a workaround for the non-XLA case on\\n  GPU.\\n\\n  **Bin-counting matrix rows independently**\\n\\n  This example uses `axis=-1` with a 2 dimensional input and returns a\\n  `Tensor` with bincounting where axis 0 is **not** flattened, i.e. an\\n  independent bincount for each matrix row.\\n\\n  >>> data = tf.ragged.constant([[1, 2], [3, 0, 0, 0, 1, 2]], dtype=np.int32)\\n  >>> tf.math.bincount(data, axis=-1)\\n  <tf.Tensor: shape=(2, 4), dtype=int32, numpy=\\n    array([[0, 1, 1, 0],\\n           [3, 1, 1, 1]], dtype=int32)>\\n\\n  **Bin-counting with binary_output**\\n\\n  This example gives binary output instead of counting the occurrence.\\n\\n  >>> data = tf.ragged.constant([[1, 2], [3, 0, 0, 0, 1, 2]], dtype=np.int32)\\n  >>> tf.math.bincount(data, axis=-1, binary_output=True)\\n  <tf.Tensor: shape=(2, 4), dtype=int32, numpy=\\n    array([[0, 1, 1, 0],\\n           [1, 1, 1, 1]], dtype=int32)>\\n\\n  Args:\\n    arr: A RaggedTensor whose values should be counted.\\n      These tensors must have a rank of 2 if `axis=-1`.\\n    weights: If non-None, must be a RaggedTensor with the same row splits as\\n      `arr`. For each value in `arr`, the bin will be incremented by the\\n      corresponding weight instead of 1. If non-None, `binary_output` must be\\n      False.\\n    minlength: If given, ensures the output has length at least `minlength`,\\n      padding with zeros at the end if necessary.\\n    maxlength: If given, skips values in `arr` that are equal or greater than\\n      `maxlength`, ensuring that the output has length at most `maxlength`.\\n    dtype: If `weights` is None, determines the type of the output bins.\\n    name: A name scope for the associated operations (optional).\\n    axis: The axis to slice over. Axes at and below `axis` will be flattened\\n      before bin counting. Currently, only `0`, and `-1` are supported. If None,\\n      all axes will be flattened (identical to passing `0`).\\n    binary_output: If True, this op will output 1 instead of the number of times\\n      a token appears (equivalent to one_hot + reduce_any instead of one_hot +\\n      reduce_add). Defaults to False.\\n\\n  Returns:\\n    A vector with the same dtype as `weights` or the given `dtype` containing\\n    the bincount values.\\n\\n  Raises:\\n    `InvalidArgumentError` if negative values are provided as an input.\\n\\n  '\n    name = 'bincount' if name is None else name\n    with ops.name_scope(name):\n        arr = ragged_tensor.convert_to_tensor_or_ragged_tensor(arr, name='arr')\n        if weights is not None:\n            if not isinstance(weights, sparse_tensor.SparseTensor):\n                weights = ragged_tensor.convert_to_tensor_or_ragged_tensor(weights, name='weights')\n        if weights is not None and binary_output:\n            raise ValueError('Arguments `binary_output` and `weights` are mutually exclusive. Please specify only one.')\n        if not arr.dtype.is_integer:\n            arr = math_ops.cast(arr, dtypes.int32)\n        if axis is None:\n            axis = 0\n        if axis not in [0, -1]:\n            raise ValueError(f'Unsupported value for argument axis={axis}. Only 0 and -1 are currently supported.')\n        array_is_nonempty = array_ops.size(arr) > 0\n        output_size = math_ops.cast(array_is_nonempty, arr.dtype) * (math_ops.reduce_max(arr) + 1)\n        if minlength is not None:\n            minlength = ops.convert_to_tensor(minlength, name='minlength', dtype=arr.dtype)\n            output_size = gen_math_ops.maximum(minlength, output_size)\n        if maxlength is not None:\n            maxlength = ops.convert_to_tensor(maxlength, name='maxlength', dtype=arr.dtype)\n            output_size = gen_math_ops.minimum(maxlength, output_size)\n        if axis == 0:\n            while isinstance(arr, ragged_tensor.RaggedTensor):\n                if weights is not None:\n                    weights = validate_ragged_weights(arr, weights, dtype)\n                arr = arr.values\n        if isinstance(arr, ragged_tensor.RaggedTensor):\n            weights = validate_ragged_weights(arr, weights, dtype)\n            return gen_math_ops.ragged_bincount(splits=arr.row_splits, values=arr.values, size=output_size, weights=weights, binary_output=binary_output)\n        else:\n            weights = bincount_ops.validate_dense_weights(arr, weights, dtype)\n            return gen_math_ops.dense_bincount(input=arr, size=output_size, weights=weights, binary_output=binary_output)",
            "@dispatch.dispatch_for_api(bincount_ops.bincount)\ndef bincount(arr: ragged_tensor.RaggedTensor, weights=None, minlength=None, maxlength=None, dtype=dtypes.int32, name=None, axis=None, binary_output=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Counts the number of occurrences of each value in an integer array.\\n\\n  If `minlength` and `maxlength` are not given, returns a vector with length\\n  `tf.reduce_max(arr) + 1` if `arr` is non-empty, and length 0 otherwise.\\n\\n  >>> data = tf.ragged.constant([[1, 1], [2, 3, 2, 4, 4, 5]])\\n  >>> tf.math.bincount(data)\\n  <tf.Tensor: ... numpy=array([0, 2, 2, 1, 2, 1], dtype=int32)>\\n\\n  Vector length = Maximum element in vector `values` is 5. Adding 1, which is 6\\n                  will be the vector length.\\n\\n  Each bin value in the output indicates number of occurrences of the particular\\n  index. Here, index 1 in output has a value 2. This indicates value 1 occurs\\n  two times in `values`.\\n\\n  **Bin-counting with weights**\\n\\n  >>> data = tf.ragged.constant([[1, 1], [2, 3, 2, 4, 4, 5]])\\n  >>> weights = tf.ragged.constant([[1, 5], [0, 1, 0, 5, 4, 5]])\\n  >>> tf.math.bincount(data, weights=weights)\\n  <tf.Tensor: ... numpy=array([0, 6, 0, 1, 9, 5], dtype=int32)>\\n\\n  When `weights` is specified, bins will be incremented by the corresponding\\n  weight instead of 1. Here, index 1 in output has a value 6. This is the\\n  summation of `weights` corresponding to the value in `arr` (i.e. for index\\n  1, the first two values `arr` are 1 so the first two weights, 1 and 5, are\\n  summed).\\n\\n  There is an equivilance between bin-counting with weights and\\n  `unsorted_segement_sum` where `data` is the weights and `segment_ids` are the\\n  values.\\n\\n  >>> data = tf.ragged.constant([[1, 1], [2, 3, 2, 4, 4, 5]])\\n  >>> weights = tf.ragged.constant([[1, 5], [0, 1, 0, 5, 4, 5]])\\n  >>> tf.math.unsorted_segment_sum(weights, data, num_segments=6).numpy()\\n  array([0, 6, 0, 1, 9, 5], dtype=int32)\\n\\n  On GPU, `bincount` with weights is only supported when XLA is enabled\\n  (typically when a function decorated with `@tf.function(jit_compile=True)`).\\n  `unsorted_segment_sum` can be used as a workaround for the non-XLA case on\\n  GPU.\\n\\n  **Bin-counting matrix rows independently**\\n\\n  This example uses `axis=-1` with a 2 dimensional input and returns a\\n  `Tensor` with bincounting where axis 0 is **not** flattened, i.e. an\\n  independent bincount for each matrix row.\\n\\n  >>> data = tf.ragged.constant([[1, 2], [3, 0, 0, 0, 1, 2]], dtype=np.int32)\\n  >>> tf.math.bincount(data, axis=-1)\\n  <tf.Tensor: shape=(2, 4), dtype=int32, numpy=\\n    array([[0, 1, 1, 0],\\n           [3, 1, 1, 1]], dtype=int32)>\\n\\n  **Bin-counting with binary_output**\\n\\n  This example gives binary output instead of counting the occurrence.\\n\\n  >>> data = tf.ragged.constant([[1, 2], [3, 0, 0, 0, 1, 2]], dtype=np.int32)\\n  >>> tf.math.bincount(data, axis=-1, binary_output=True)\\n  <tf.Tensor: shape=(2, 4), dtype=int32, numpy=\\n    array([[0, 1, 1, 0],\\n           [1, 1, 1, 1]], dtype=int32)>\\n\\n  Args:\\n    arr: A RaggedTensor whose values should be counted.\\n      These tensors must have a rank of 2 if `axis=-1`.\\n    weights: If non-None, must be a RaggedTensor with the same row splits as\\n      `arr`. For each value in `arr`, the bin will be incremented by the\\n      corresponding weight instead of 1. If non-None, `binary_output` must be\\n      False.\\n    minlength: If given, ensures the output has length at least `minlength`,\\n      padding with zeros at the end if necessary.\\n    maxlength: If given, skips values in `arr` that are equal or greater than\\n      `maxlength`, ensuring that the output has length at most `maxlength`.\\n    dtype: If `weights` is None, determines the type of the output bins.\\n    name: A name scope for the associated operations (optional).\\n    axis: The axis to slice over. Axes at and below `axis` will be flattened\\n      before bin counting. Currently, only `0`, and `-1` are supported. If None,\\n      all axes will be flattened (identical to passing `0`).\\n    binary_output: If True, this op will output 1 instead of the number of times\\n      a token appears (equivalent to one_hot + reduce_any instead of one_hot +\\n      reduce_add). Defaults to False.\\n\\n  Returns:\\n    A vector with the same dtype as `weights` or the given `dtype` containing\\n    the bincount values.\\n\\n  Raises:\\n    `InvalidArgumentError` if negative values are provided as an input.\\n\\n  '\n    name = 'bincount' if name is None else name\n    with ops.name_scope(name):\n        arr = ragged_tensor.convert_to_tensor_or_ragged_tensor(arr, name='arr')\n        if weights is not None:\n            if not isinstance(weights, sparse_tensor.SparseTensor):\n                weights = ragged_tensor.convert_to_tensor_or_ragged_tensor(weights, name='weights')\n        if weights is not None and binary_output:\n            raise ValueError('Arguments `binary_output` and `weights` are mutually exclusive. Please specify only one.')\n        if not arr.dtype.is_integer:\n            arr = math_ops.cast(arr, dtypes.int32)\n        if axis is None:\n            axis = 0\n        if axis not in [0, -1]:\n            raise ValueError(f'Unsupported value for argument axis={axis}. Only 0 and -1 are currently supported.')\n        array_is_nonempty = array_ops.size(arr) > 0\n        output_size = math_ops.cast(array_is_nonempty, arr.dtype) * (math_ops.reduce_max(arr) + 1)\n        if minlength is not None:\n            minlength = ops.convert_to_tensor(minlength, name='minlength', dtype=arr.dtype)\n            output_size = gen_math_ops.maximum(minlength, output_size)\n        if maxlength is not None:\n            maxlength = ops.convert_to_tensor(maxlength, name='maxlength', dtype=arr.dtype)\n            output_size = gen_math_ops.minimum(maxlength, output_size)\n        if axis == 0:\n            while isinstance(arr, ragged_tensor.RaggedTensor):\n                if weights is not None:\n                    weights = validate_ragged_weights(arr, weights, dtype)\n                arr = arr.values\n        if isinstance(arr, ragged_tensor.RaggedTensor):\n            weights = validate_ragged_weights(arr, weights, dtype)\n            return gen_math_ops.ragged_bincount(splits=arr.row_splits, values=arr.values, size=output_size, weights=weights, binary_output=binary_output)\n        else:\n            weights = bincount_ops.validate_dense_weights(arr, weights, dtype)\n            return gen_math_ops.dense_bincount(input=arr, size=output_size, weights=weights, binary_output=binary_output)"
        ]
    },
    {
        "func_name": "sparse_bincount",
        "original": "@dispatch.dispatch_for_api(sparse_ops.sparse_bincount)\ndef sparse_bincount(values: ragged_tensor.RaggedTensor, weights=None, axis=0, minlength=None, maxlength=None, binary_output=False, name=None):\n    \"\"\"Count the number of times an integer value appears in a tensor.\n\n  This op takes an N-dimensional `Tensor`, `RaggedTensor`, or `SparseTensor`,\n  and returns an N-dimensional int64 SparseTensor where element\n  `[i0...i[axis], j]` contains the number of times the value `j` appears in\n  slice `[i0...i[axis], :]` of the input tensor.  Currently, only N=0 and\n  N=-1 are supported.\n\n  Args:\n    values: A RaggedTensor whose values should be\n      counted. These tensors must have a rank of 2 if `axis=-1`.\n    weights: If non-None, must be a RaggedTensor with the same row splits as\n      `values`. For each value in `value`, the bin will be incremented by the\n      corresponding weight instead of 1.\n    axis: The axis to slice over. Axes at and below `axis` will be flattened\n      before bin counting. Currently, only `0`, and `-1` are supported. If None,\n      all axes will be flattened (identical to passing `0`).\n    minlength: If given, ensures the output has length at least `minlength`,\n      padding with zeros at the end if necessary.\n    maxlength: If given, skips values in `values` that are equal or greater than\n      `maxlength`, ensuring that the output has length at most `maxlength`.\n    binary_output: If True, this op will output 1 instead of the number of times\n      a token appears (equivalent to one_hot + reduce_any instead of one_hot +\n      reduce_add). Defaults to False.\n    name: A name for this op.\n\n  Returns:\n    A SparseTensor with `output.shape = values.shape[:axis] + [N]`, where `N` is\n      * `maxlength` (if set);\n      * `minlength` (if set, and `minlength > reduce_max(values)`);\n      * `0` (if `values` is empty);\n      * `reduce_max(values) + 1` otherwise.\n\n  Raises:\n    `InvalidArgumentError` if negative values are provided as an input.\n\n  Examples:\n\n  **Bin-counting every item in individual batches**\n\n  This example takes an input (which could be a Tensor, RaggedTensor, or\n  SparseTensor) and returns a SparseTensor where the value of (i,j) is the\n  number of times value j appears in batch i.\n\n  >>> data = tf.ragged.constant(\n  ...     [[10, 20], [30, 20, 11, 101, 11, 10001]], dtype=np.int64)\n  >>> tf.sparse.bincount(data, axis=-1)\n  SparseTensor(indices=tf.Tensor(\n    [[    0    10]\n     [    0    20]\n     [    1    11]\n     [    1    20]\n     [    1    30]\n     [    1   101]\n     [    1 10001]], shape=(7, 2), dtype=int64),\n     values=tf.Tensor([1 1 2 1 1 1 1], shape=(7,), dtype=int64),\n     dense_shape=tf.Tensor([    2 10002], shape=(2,), dtype=int64))\n\n  **Bin-counting with defined output shape**\n\n  This example takes an input (which could be a Tensor, RaggedTensor, or\n  SparseTensor) and returns a SparseTensor where the value of (i,j) is the\n  number of times value j appears in batch i. However, all values of j\n  above 'maxlength' are ignored. The dense_shape of the output sparse tensor\n  is set to 'minlength'. Note that, while the input is identical to the\n  example above, the value '10001' in batch item 2 is dropped, and the\n  dense shape is [2, 500] instead of [2,10002] or [2, 102].\n\n  >>> minlength = maxlength = 500\n  >>> data = tf.ragged.constant(\n  ...     [[10, 20], [30, 20, 11, 101, 11, 10001]], dtype=np.int64)\n  >>> tf.sparse.bincount(\n  ...    data, axis=-1, minlength=minlength, maxlength=maxlength)\n  SparseTensor(indices=tf.Tensor(\n  [[  0  10]\n   [  0  20]\n   [  1  11]\n   [  1  20]\n   [  1  30]\n   [  1 101]], shape=(6, 2), dtype=int64),\n   values=tf.Tensor([1 1 2 1 1 1], shape=(6,), dtype=int64),\n   dense_shape=tf.Tensor([  2 500], shape=(2,), dtype=int64))\n\n  **Binary bin-counting**\n\n  This example takes an input (which could be a Tensor, RaggedTensor, or\n  SparseTensor) and returns a SparseTensor where (i,j) is 1 if the value j\n  appears in batch i at least once and is 0 otherwise. Note that, even though\n  some values (like 20 in batch 1 and 11 in batch 2) appear more than once,\n  the 'values' tensor is all 1s.\n\n  >>> data = tf.ragged.constant(\n  ...     [[10, 20], [30, 20, 11, 101, 11, 10001]], dtype=np.int64)\n  >>> tf.sparse.bincount(data, binary_output=True, axis=-1)\n  SparseTensor(indices=tf.Tensor(\n  [[  0  10]\n   [  0  20]\n   [  1  11]\n   [  1  20]\n   [  1  30]\n   [  1 101]\n   [  1 10001]], shape=(7, 2), dtype=int64),\n   values=tf.Tensor([1 1 1 1 1 1 1], shape=(7,), dtype=int64),\n   dense_shape=tf.Tensor([  2 10002], shape=(2,), dtype=int64))\n\n  **Weighted bin-counting**\n\n  This example takes two inputs - a values tensor and a weights tensor. These\n  tensors must be identically shaped, and have the same row splits or indices\n  in the case of RaggedTensors or SparseTensors. When performing a weighted\n  count, the op will output a SparseTensor where the value of (i, j) is the\n  sum of the values in the weight tensor's batch i in the locations where\n  the values tensor has the value j. In this case, the output dtype is the\n  same as the dtype of the weights tensor.\n\n  >>> data = tf.ragged.constant(\n  ...    [[10, 20], [30, 20, 11, 101, 11, 10001]], dtype=np.int64)\n  >>> weights = tf.ragged.constant(\n  ...    [[2, 0.25], [15, 0.5, 2, 17, 3, 0.9]])\n  >>> tf.sparse.bincount(data, weights=weights, axis=-1)\n  SparseTensor(indices=tf.Tensor(\n  [[    0    10]\n   [    0    20]\n   [    1    11]\n   [    1    20]\n   [    1    30]\n   [    1   101]\n   [    1 10001]], shape=(7, 2), dtype=int64),\n   values=tf.Tensor([ 2. 0.25  5. 0.5 15. 17. 0.9 ], shape=(7,), dtype=float32),\n   dense_shape=tf.Tensor([    2 10002], shape=(2,), dtype=int64))\n\n  \"\"\"\n    with ops.name_scope(name, 'count', [values, weights]):\n        values = ragged_tensor.convert_to_tensor_or_ragged_tensor(values, name='values')\n        if weights is not None:\n            if not isinstance(weights, sparse_tensor.SparseTensor):\n                weights = ragged_tensor.convert_to_tensor_or_ragged_tensor(weights, name='weights')\n        if weights is not None and binary_output:\n            raise ValueError('Arguments `binary_output` and `weights` are mutually exclusive. Please specify only one.')\n        if axis is None:\n            axis = 0\n        if axis not in [0, -1]:\n            raise ValueError(f'Unsupported value for argument axis={axis}. Only 0 and -1 are currently supported.')\n        minlength_value = minlength if minlength is not None else -1\n        maxlength_value = maxlength if maxlength is not None else -1\n        if axis == 0:\n            if weights is not None:\n                weights = validate_ragged_weights(values, weights)\n            values = values.values\n        if isinstance(values, ragged_tensor.RaggedTensor):\n            weights = validate_ragged_weights(values, weights)\n            (c_ind, c_val, c_shape) = gen_count_ops.ragged_count_sparse_output(values.row_splits, values.values, weights, minlength=minlength_value, maxlength=maxlength_value, binary_output=binary_output)\n        else:\n            weights = bincount_ops.validate_dense_weights(values, weights)\n            (c_ind, c_val, c_shape) = gen_count_ops.dense_count_sparse_output(values, weights=weights, minlength=minlength_value, maxlength=maxlength_value, binary_output=binary_output)\n        return sparse_tensor.SparseTensor(c_ind, c_val, c_shape)",
        "mutated": [
            "@dispatch.dispatch_for_api(sparse_ops.sparse_bincount)\ndef sparse_bincount(values: ragged_tensor.RaggedTensor, weights=None, axis=0, minlength=None, maxlength=None, binary_output=False, name=None):\n    if False:\n        i = 10\n    \"Count the number of times an integer value appears in a tensor.\\n\\n  This op takes an N-dimensional `Tensor`, `RaggedTensor`, or `SparseTensor`,\\n  and returns an N-dimensional int64 SparseTensor where element\\n  `[i0...i[axis], j]` contains the number of times the value `j` appears in\\n  slice `[i0...i[axis], :]` of the input tensor.  Currently, only N=0 and\\n  N=-1 are supported.\\n\\n  Args:\\n    values: A RaggedTensor whose values should be\\n      counted. These tensors must have a rank of 2 if `axis=-1`.\\n    weights: If non-None, must be a RaggedTensor with the same row splits as\\n      `values`. For each value in `value`, the bin will be incremented by the\\n      corresponding weight instead of 1.\\n    axis: The axis to slice over. Axes at and below `axis` will be flattened\\n      before bin counting. Currently, only `0`, and `-1` are supported. If None,\\n      all axes will be flattened (identical to passing `0`).\\n    minlength: If given, ensures the output has length at least `minlength`,\\n      padding with zeros at the end if necessary.\\n    maxlength: If given, skips values in `values` that are equal or greater than\\n      `maxlength`, ensuring that the output has length at most `maxlength`.\\n    binary_output: If True, this op will output 1 instead of the number of times\\n      a token appears (equivalent to one_hot + reduce_any instead of one_hot +\\n      reduce_add). Defaults to False.\\n    name: A name for this op.\\n\\n  Returns:\\n    A SparseTensor with `output.shape = values.shape[:axis] + [N]`, where `N` is\\n      * `maxlength` (if set);\\n      * `minlength` (if set, and `minlength > reduce_max(values)`);\\n      * `0` (if `values` is empty);\\n      * `reduce_max(values) + 1` otherwise.\\n\\n  Raises:\\n    `InvalidArgumentError` if negative values are provided as an input.\\n\\n  Examples:\\n\\n  **Bin-counting every item in individual batches**\\n\\n  This example takes an input (which could be a Tensor, RaggedTensor, or\\n  SparseTensor) and returns a SparseTensor where the value of (i,j) is the\\n  number of times value j appears in batch i.\\n\\n  >>> data = tf.ragged.constant(\\n  ...     [[10, 20], [30, 20, 11, 101, 11, 10001]], dtype=np.int64)\\n  >>> tf.sparse.bincount(data, axis=-1)\\n  SparseTensor(indices=tf.Tensor(\\n    [[    0    10]\\n     [    0    20]\\n     [    1    11]\\n     [    1    20]\\n     [    1    30]\\n     [    1   101]\\n     [    1 10001]], shape=(7, 2), dtype=int64),\\n     values=tf.Tensor([1 1 2 1 1 1 1], shape=(7,), dtype=int64),\\n     dense_shape=tf.Tensor([    2 10002], shape=(2,), dtype=int64))\\n\\n  **Bin-counting with defined output shape**\\n\\n  This example takes an input (which could be a Tensor, RaggedTensor, or\\n  SparseTensor) and returns a SparseTensor where the value of (i,j) is the\\n  number of times value j appears in batch i. However, all values of j\\n  above 'maxlength' are ignored. The dense_shape of the output sparse tensor\\n  is set to 'minlength'. Note that, while the input is identical to the\\n  example above, the value '10001' in batch item 2 is dropped, and the\\n  dense shape is [2, 500] instead of [2,10002] or [2, 102].\\n\\n  >>> minlength = maxlength = 500\\n  >>> data = tf.ragged.constant(\\n  ...     [[10, 20], [30, 20, 11, 101, 11, 10001]], dtype=np.int64)\\n  >>> tf.sparse.bincount(\\n  ...    data, axis=-1, minlength=minlength, maxlength=maxlength)\\n  SparseTensor(indices=tf.Tensor(\\n  [[  0  10]\\n   [  0  20]\\n   [  1  11]\\n   [  1  20]\\n   [  1  30]\\n   [  1 101]], shape=(6, 2), dtype=int64),\\n   values=tf.Tensor([1 1 2 1 1 1], shape=(6,), dtype=int64),\\n   dense_shape=tf.Tensor([  2 500], shape=(2,), dtype=int64))\\n\\n  **Binary bin-counting**\\n\\n  This example takes an input (which could be a Tensor, RaggedTensor, or\\n  SparseTensor) and returns a SparseTensor where (i,j) is 1 if the value j\\n  appears in batch i at least once and is 0 otherwise. Note that, even though\\n  some values (like 20 in batch 1 and 11 in batch 2) appear more than once,\\n  the 'values' tensor is all 1s.\\n\\n  >>> data = tf.ragged.constant(\\n  ...     [[10, 20], [30, 20, 11, 101, 11, 10001]], dtype=np.int64)\\n  >>> tf.sparse.bincount(data, binary_output=True, axis=-1)\\n  SparseTensor(indices=tf.Tensor(\\n  [[  0  10]\\n   [  0  20]\\n   [  1  11]\\n   [  1  20]\\n   [  1  30]\\n   [  1 101]\\n   [  1 10001]], shape=(7, 2), dtype=int64),\\n   values=tf.Tensor([1 1 1 1 1 1 1], shape=(7,), dtype=int64),\\n   dense_shape=tf.Tensor([  2 10002], shape=(2,), dtype=int64))\\n\\n  **Weighted bin-counting**\\n\\n  This example takes two inputs - a values tensor and a weights tensor. These\\n  tensors must be identically shaped, and have the same row splits or indices\\n  in the case of RaggedTensors or SparseTensors. When performing a weighted\\n  count, the op will output a SparseTensor where the value of (i, j) is the\\n  sum of the values in the weight tensor's batch i in the locations where\\n  the values tensor has the value j. In this case, the output dtype is the\\n  same as the dtype of the weights tensor.\\n\\n  >>> data = tf.ragged.constant(\\n  ...    [[10, 20], [30, 20, 11, 101, 11, 10001]], dtype=np.int64)\\n  >>> weights = tf.ragged.constant(\\n  ...    [[2, 0.25], [15, 0.5, 2, 17, 3, 0.9]])\\n  >>> tf.sparse.bincount(data, weights=weights, axis=-1)\\n  SparseTensor(indices=tf.Tensor(\\n  [[    0    10]\\n   [    0    20]\\n   [    1    11]\\n   [    1    20]\\n   [    1    30]\\n   [    1   101]\\n   [    1 10001]], shape=(7, 2), dtype=int64),\\n   values=tf.Tensor([ 2. 0.25  5. 0.5 15. 17. 0.9 ], shape=(7,), dtype=float32),\\n   dense_shape=tf.Tensor([    2 10002], shape=(2,), dtype=int64))\\n\\n  \"\n    with ops.name_scope(name, 'count', [values, weights]):\n        values = ragged_tensor.convert_to_tensor_or_ragged_tensor(values, name='values')\n        if weights is not None:\n            if not isinstance(weights, sparse_tensor.SparseTensor):\n                weights = ragged_tensor.convert_to_tensor_or_ragged_tensor(weights, name='weights')\n        if weights is not None and binary_output:\n            raise ValueError('Arguments `binary_output` and `weights` are mutually exclusive. Please specify only one.')\n        if axis is None:\n            axis = 0\n        if axis not in [0, -1]:\n            raise ValueError(f'Unsupported value for argument axis={axis}. Only 0 and -1 are currently supported.')\n        minlength_value = minlength if minlength is not None else -1\n        maxlength_value = maxlength if maxlength is not None else -1\n        if axis == 0:\n            if weights is not None:\n                weights = validate_ragged_weights(values, weights)\n            values = values.values\n        if isinstance(values, ragged_tensor.RaggedTensor):\n            weights = validate_ragged_weights(values, weights)\n            (c_ind, c_val, c_shape) = gen_count_ops.ragged_count_sparse_output(values.row_splits, values.values, weights, minlength=minlength_value, maxlength=maxlength_value, binary_output=binary_output)\n        else:\n            weights = bincount_ops.validate_dense_weights(values, weights)\n            (c_ind, c_val, c_shape) = gen_count_ops.dense_count_sparse_output(values, weights=weights, minlength=minlength_value, maxlength=maxlength_value, binary_output=binary_output)\n        return sparse_tensor.SparseTensor(c_ind, c_val, c_shape)",
            "@dispatch.dispatch_for_api(sparse_ops.sparse_bincount)\ndef sparse_bincount(values: ragged_tensor.RaggedTensor, weights=None, axis=0, minlength=None, maxlength=None, binary_output=False, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Count the number of times an integer value appears in a tensor.\\n\\n  This op takes an N-dimensional `Tensor`, `RaggedTensor`, or `SparseTensor`,\\n  and returns an N-dimensional int64 SparseTensor where element\\n  `[i0...i[axis], j]` contains the number of times the value `j` appears in\\n  slice `[i0...i[axis], :]` of the input tensor.  Currently, only N=0 and\\n  N=-1 are supported.\\n\\n  Args:\\n    values: A RaggedTensor whose values should be\\n      counted. These tensors must have a rank of 2 if `axis=-1`.\\n    weights: If non-None, must be a RaggedTensor with the same row splits as\\n      `values`. For each value in `value`, the bin will be incremented by the\\n      corresponding weight instead of 1.\\n    axis: The axis to slice over. Axes at and below `axis` will be flattened\\n      before bin counting. Currently, only `0`, and `-1` are supported. If None,\\n      all axes will be flattened (identical to passing `0`).\\n    minlength: If given, ensures the output has length at least `minlength`,\\n      padding with zeros at the end if necessary.\\n    maxlength: If given, skips values in `values` that are equal or greater than\\n      `maxlength`, ensuring that the output has length at most `maxlength`.\\n    binary_output: If True, this op will output 1 instead of the number of times\\n      a token appears (equivalent to one_hot + reduce_any instead of one_hot +\\n      reduce_add). Defaults to False.\\n    name: A name for this op.\\n\\n  Returns:\\n    A SparseTensor with `output.shape = values.shape[:axis] + [N]`, where `N` is\\n      * `maxlength` (if set);\\n      * `minlength` (if set, and `minlength > reduce_max(values)`);\\n      * `0` (if `values` is empty);\\n      * `reduce_max(values) + 1` otherwise.\\n\\n  Raises:\\n    `InvalidArgumentError` if negative values are provided as an input.\\n\\n  Examples:\\n\\n  **Bin-counting every item in individual batches**\\n\\n  This example takes an input (which could be a Tensor, RaggedTensor, or\\n  SparseTensor) and returns a SparseTensor where the value of (i,j) is the\\n  number of times value j appears in batch i.\\n\\n  >>> data = tf.ragged.constant(\\n  ...     [[10, 20], [30, 20, 11, 101, 11, 10001]], dtype=np.int64)\\n  >>> tf.sparse.bincount(data, axis=-1)\\n  SparseTensor(indices=tf.Tensor(\\n    [[    0    10]\\n     [    0    20]\\n     [    1    11]\\n     [    1    20]\\n     [    1    30]\\n     [    1   101]\\n     [    1 10001]], shape=(7, 2), dtype=int64),\\n     values=tf.Tensor([1 1 2 1 1 1 1], shape=(7,), dtype=int64),\\n     dense_shape=tf.Tensor([    2 10002], shape=(2,), dtype=int64))\\n\\n  **Bin-counting with defined output shape**\\n\\n  This example takes an input (which could be a Tensor, RaggedTensor, or\\n  SparseTensor) and returns a SparseTensor where the value of (i,j) is the\\n  number of times value j appears in batch i. However, all values of j\\n  above 'maxlength' are ignored. The dense_shape of the output sparse tensor\\n  is set to 'minlength'. Note that, while the input is identical to the\\n  example above, the value '10001' in batch item 2 is dropped, and the\\n  dense shape is [2, 500] instead of [2,10002] or [2, 102].\\n\\n  >>> minlength = maxlength = 500\\n  >>> data = tf.ragged.constant(\\n  ...     [[10, 20], [30, 20, 11, 101, 11, 10001]], dtype=np.int64)\\n  >>> tf.sparse.bincount(\\n  ...    data, axis=-1, minlength=minlength, maxlength=maxlength)\\n  SparseTensor(indices=tf.Tensor(\\n  [[  0  10]\\n   [  0  20]\\n   [  1  11]\\n   [  1  20]\\n   [  1  30]\\n   [  1 101]], shape=(6, 2), dtype=int64),\\n   values=tf.Tensor([1 1 2 1 1 1], shape=(6,), dtype=int64),\\n   dense_shape=tf.Tensor([  2 500], shape=(2,), dtype=int64))\\n\\n  **Binary bin-counting**\\n\\n  This example takes an input (which could be a Tensor, RaggedTensor, or\\n  SparseTensor) and returns a SparseTensor where (i,j) is 1 if the value j\\n  appears in batch i at least once and is 0 otherwise. Note that, even though\\n  some values (like 20 in batch 1 and 11 in batch 2) appear more than once,\\n  the 'values' tensor is all 1s.\\n\\n  >>> data = tf.ragged.constant(\\n  ...     [[10, 20], [30, 20, 11, 101, 11, 10001]], dtype=np.int64)\\n  >>> tf.sparse.bincount(data, binary_output=True, axis=-1)\\n  SparseTensor(indices=tf.Tensor(\\n  [[  0  10]\\n   [  0  20]\\n   [  1  11]\\n   [  1  20]\\n   [  1  30]\\n   [  1 101]\\n   [  1 10001]], shape=(7, 2), dtype=int64),\\n   values=tf.Tensor([1 1 1 1 1 1 1], shape=(7,), dtype=int64),\\n   dense_shape=tf.Tensor([  2 10002], shape=(2,), dtype=int64))\\n\\n  **Weighted bin-counting**\\n\\n  This example takes two inputs - a values tensor and a weights tensor. These\\n  tensors must be identically shaped, and have the same row splits or indices\\n  in the case of RaggedTensors or SparseTensors. When performing a weighted\\n  count, the op will output a SparseTensor where the value of (i, j) is the\\n  sum of the values in the weight tensor's batch i in the locations where\\n  the values tensor has the value j. In this case, the output dtype is the\\n  same as the dtype of the weights tensor.\\n\\n  >>> data = tf.ragged.constant(\\n  ...    [[10, 20], [30, 20, 11, 101, 11, 10001]], dtype=np.int64)\\n  >>> weights = tf.ragged.constant(\\n  ...    [[2, 0.25], [15, 0.5, 2, 17, 3, 0.9]])\\n  >>> tf.sparse.bincount(data, weights=weights, axis=-1)\\n  SparseTensor(indices=tf.Tensor(\\n  [[    0    10]\\n   [    0    20]\\n   [    1    11]\\n   [    1    20]\\n   [    1    30]\\n   [    1   101]\\n   [    1 10001]], shape=(7, 2), dtype=int64),\\n   values=tf.Tensor([ 2. 0.25  5. 0.5 15. 17. 0.9 ], shape=(7,), dtype=float32),\\n   dense_shape=tf.Tensor([    2 10002], shape=(2,), dtype=int64))\\n\\n  \"\n    with ops.name_scope(name, 'count', [values, weights]):\n        values = ragged_tensor.convert_to_tensor_or_ragged_tensor(values, name='values')\n        if weights is not None:\n            if not isinstance(weights, sparse_tensor.SparseTensor):\n                weights = ragged_tensor.convert_to_tensor_or_ragged_tensor(weights, name='weights')\n        if weights is not None and binary_output:\n            raise ValueError('Arguments `binary_output` and `weights` are mutually exclusive. Please specify only one.')\n        if axis is None:\n            axis = 0\n        if axis not in [0, -1]:\n            raise ValueError(f'Unsupported value for argument axis={axis}. Only 0 and -1 are currently supported.')\n        minlength_value = minlength if minlength is not None else -1\n        maxlength_value = maxlength if maxlength is not None else -1\n        if axis == 0:\n            if weights is not None:\n                weights = validate_ragged_weights(values, weights)\n            values = values.values\n        if isinstance(values, ragged_tensor.RaggedTensor):\n            weights = validate_ragged_weights(values, weights)\n            (c_ind, c_val, c_shape) = gen_count_ops.ragged_count_sparse_output(values.row_splits, values.values, weights, minlength=minlength_value, maxlength=maxlength_value, binary_output=binary_output)\n        else:\n            weights = bincount_ops.validate_dense_weights(values, weights)\n            (c_ind, c_val, c_shape) = gen_count_ops.dense_count_sparse_output(values, weights=weights, minlength=minlength_value, maxlength=maxlength_value, binary_output=binary_output)\n        return sparse_tensor.SparseTensor(c_ind, c_val, c_shape)",
            "@dispatch.dispatch_for_api(sparse_ops.sparse_bincount)\ndef sparse_bincount(values: ragged_tensor.RaggedTensor, weights=None, axis=0, minlength=None, maxlength=None, binary_output=False, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Count the number of times an integer value appears in a tensor.\\n\\n  This op takes an N-dimensional `Tensor`, `RaggedTensor`, or `SparseTensor`,\\n  and returns an N-dimensional int64 SparseTensor where element\\n  `[i0...i[axis], j]` contains the number of times the value `j` appears in\\n  slice `[i0...i[axis], :]` of the input tensor.  Currently, only N=0 and\\n  N=-1 are supported.\\n\\n  Args:\\n    values: A RaggedTensor whose values should be\\n      counted. These tensors must have a rank of 2 if `axis=-1`.\\n    weights: If non-None, must be a RaggedTensor with the same row splits as\\n      `values`. For each value in `value`, the bin will be incremented by the\\n      corresponding weight instead of 1.\\n    axis: The axis to slice over. Axes at and below `axis` will be flattened\\n      before bin counting. Currently, only `0`, and `-1` are supported. If None,\\n      all axes will be flattened (identical to passing `0`).\\n    minlength: If given, ensures the output has length at least `minlength`,\\n      padding with zeros at the end if necessary.\\n    maxlength: If given, skips values in `values` that are equal or greater than\\n      `maxlength`, ensuring that the output has length at most `maxlength`.\\n    binary_output: If True, this op will output 1 instead of the number of times\\n      a token appears (equivalent to one_hot + reduce_any instead of one_hot +\\n      reduce_add). Defaults to False.\\n    name: A name for this op.\\n\\n  Returns:\\n    A SparseTensor with `output.shape = values.shape[:axis] + [N]`, where `N` is\\n      * `maxlength` (if set);\\n      * `minlength` (if set, and `minlength > reduce_max(values)`);\\n      * `0` (if `values` is empty);\\n      * `reduce_max(values) + 1` otherwise.\\n\\n  Raises:\\n    `InvalidArgumentError` if negative values are provided as an input.\\n\\n  Examples:\\n\\n  **Bin-counting every item in individual batches**\\n\\n  This example takes an input (which could be a Tensor, RaggedTensor, or\\n  SparseTensor) and returns a SparseTensor where the value of (i,j) is the\\n  number of times value j appears in batch i.\\n\\n  >>> data = tf.ragged.constant(\\n  ...     [[10, 20], [30, 20, 11, 101, 11, 10001]], dtype=np.int64)\\n  >>> tf.sparse.bincount(data, axis=-1)\\n  SparseTensor(indices=tf.Tensor(\\n    [[    0    10]\\n     [    0    20]\\n     [    1    11]\\n     [    1    20]\\n     [    1    30]\\n     [    1   101]\\n     [    1 10001]], shape=(7, 2), dtype=int64),\\n     values=tf.Tensor([1 1 2 1 1 1 1], shape=(7,), dtype=int64),\\n     dense_shape=tf.Tensor([    2 10002], shape=(2,), dtype=int64))\\n\\n  **Bin-counting with defined output shape**\\n\\n  This example takes an input (which could be a Tensor, RaggedTensor, or\\n  SparseTensor) and returns a SparseTensor where the value of (i,j) is the\\n  number of times value j appears in batch i. However, all values of j\\n  above 'maxlength' are ignored. The dense_shape of the output sparse tensor\\n  is set to 'minlength'. Note that, while the input is identical to the\\n  example above, the value '10001' in batch item 2 is dropped, and the\\n  dense shape is [2, 500] instead of [2,10002] or [2, 102].\\n\\n  >>> minlength = maxlength = 500\\n  >>> data = tf.ragged.constant(\\n  ...     [[10, 20], [30, 20, 11, 101, 11, 10001]], dtype=np.int64)\\n  >>> tf.sparse.bincount(\\n  ...    data, axis=-1, minlength=minlength, maxlength=maxlength)\\n  SparseTensor(indices=tf.Tensor(\\n  [[  0  10]\\n   [  0  20]\\n   [  1  11]\\n   [  1  20]\\n   [  1  30]\\n   [  1 101]], shape=(6, 2), dtype=int64),\\n   values=tf.Tensor([1 1 2 1 1 1], shape=(6,), dtype=int64),\\n   dense_shape=tf.Tensor([  2 500], shape=(2,), dtype=int64))\\n\\n  **Binary bin-counting**\\n\\n  This example takes an input (which could be a Tensor, RaggedTensor, or\\n  SparseTensor) and returns a SparseTensor where (i,j) is 1 if the value j\\n  appears in batch i at least once and is 0 otherwise. Note that, even though\\n  some values (like 20 in batch 1 and 11 in batch 2) appear more than once,\\n  the 'values' tensor is all 1s.\\n\\n  >>> data = tf.ragged.constant(\\n  ...     [[10, 20], [30, 20, 11, 101, 11, 10001]], dtype=np.int64)\\n  >>> tf.sparse.bincount(data, binary_output=True, axis=-1)\\n  SparseTensor(indices=tf.Tensor(\\n  [[  0  10]\\n   [  0  20]\\n   [  1  11]\\n   [  1  20]\\n   [  1  30]\\n   [  1 101]\\n   [  1 10001]], shape=(7, 2), dtype=int64),\\n   values=tf.Tensor([1 1 1 1 1 1 1], shape=(7,), dtype=int64),\\n   dense_shape=tf.Tensor([  2 10002], shape=(2,), dtype=int64))\\n\\n  **Weighted bin-counting**\\n\\n  This example takes two inputs - a values tensor and a weights tensor. These\\n  tensors must be identically shaped, and have the same row splits or indices\\n  in the case of RaggedTensors or SparseTensors. When performing a weighted\\n  count, the op will output a SparseTensor where the value of (i, j) is the\\n  sum of the values in the weight tensor's batch i in the locations where\\n  the values tensor has the value j. In this case, the output dtype is the\\n  same as the dtype of the weights tensor.\\n\\n  >>> data = tf.ragged.constant(\\n  ...    [[10, 20], [30, 20, 11, 101, 11, 10001]], dtype=np.int64)\\n  >>> weights = tf.ragged.constant(\\n  ...    [[2, 0.25], [15, 0.5, 2, 17, 3, 0.9]])\\n  >>> tf.sparse.bincount(data, weights=weights, axis=-1)\\n  SparseTensor(indices=tf.Tensor(\\n  [[    0    10]\\n   [    0    20]\\n   [    1    11]\\n   [    1    20]\\n   [    1    30]\\n   [    1   101]\\n   [    1 10001]], shape=(7, 2), dtype=int64),\\n   values=tf.Tensor([ 2. 0.25  5. 0.5 15. 17. 0.9 ], shape=(7,), dtype=float32),\\n   dense_shape=tf.Tensor([    2 10002], shape=(2,), dtype=int64))\\n\\n  \"\n    with ops.name_scope(name, 'count', [values, weights]):\n        values = ragged_tensor.convert_to_tensor_or_ragged_tensor(values, name='values')\n        if weights is not None:\n            if not isinstance(weights, sparse_tensor.SparseTensor):\n                weights = ragged_tensor.convert_to_tensor_or_ragged_tensor(weights, name='weights')\n        if weights is not None and binary_output:\n            raise ValueError('Arguments `binary_output` and `weights` are mutually exclusive. Please specify only one.')\n        if axis is None:\n            axis = 0\n        if axis not in [0, -1]:\n            raise ValueError(f'Unsupported value for argument axis={axis}. Only 0 and -1 are currently supported.')\n        minlength_value = minlength if minlength is not None else -1\n        maxlength_value = maxlength if maxlength is not None else -1\n        if axis == 0:\n            if weights is not None:\n                weights = validate_ragged_weights(values, weights)\n            values = values.values\n        if isinstance(values, ragged_tensor.RaggedTensor):\n            weights = validate_ragged_weights(values, weights)\n            (c_ind, c_val, c_shape) = gen_count_ops.ragged_count_sparse_output(values.row_splits, values.values, weights, minlength=minlength_value, maxlength=maxlength_value, binary_output=binary_output)\n        else:\n            weights = bincount_ops.validate_dense_weights(values, weights)\n            (c_ind, c_val, c_shape) = gen_count_ops.dense_count_sparse_output(values, weights=weights, minlength=minlength_value, maxlength=maxlength_value, binary_output=binary_output)\n        return sparse_tensor.SparseTensor(c_ind, c_val, c_shape)",
            "@dispatch.dispatch_for_api(sparse_ops.sparse_bincount)\ndef sparse_bincount(values: ragged_tensor.RaggedTensor, weights=None, axis=0, minlength=None, maxlength=None, binary_output=False, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Count the number of times an integer value appears in a tensor.\\n\\n  This op takes an N-dimensional `Tensor`, `RaggedTensor`, or `SparseTensor`,\\n  and returns an N-dimensional int64 SparseTensor where element\\n  `[i0...i[axis], j]` contains the number of times the value `j` appears in\\n  slice `[i0...i[axis], :]` of the input tensor.  Currently, only N=0 and\\n  N=-1 are supported.\\n\\n  Args:\\n    values: A RaggedTensor whose values should be\\n      counted. These tensors must have a rank of 2 if `axis=-1`.\\n    weights: If non-None, must be a RaggedTensor with the same row splits as\\n      `values`. For each value in `value`, the bin will be incremented by the\\n      corresponding weight instead of 1.\\n    axis: The axis to slice over. Axes at and below `axis` will be flattened\\n      before bin counting. Currently, only `0`, and `-1` are supported. If None,\\n      all axes will be flattened (identical to passing `0`).\\n    minlength: If given, ensures the output has length at least `minlength`,\\n      padding with zeros at the end if necessary.\\n    maxlength: If given, skips values in `values` that are equal or greater than\\n      `maxlength`, ensuring that the output has length at most `maxlength`.\\n    binary_output: If True, this op will output 1 instead of the number of times\\n      a token appears (equivalent to one_hot + reduce_any instead of one_hot +\\n      reduce_add). Defaults to False.\\n    name: A name for this op.\\n\\n  Returns:\\n    A SparseTensor with `output.shape = values.shape[:axis] + [N]`, where `N` is\\n      * `maxlength` (if set);\\n      * `minlength` (if set, and `minlength > reduce_max(values)`);\\n      * `0` (if `values` is empty);\\n      * `reduce_max(values) + 1` otherwise.\\n\\n  Raises:\\n    `InvalidArgumentError` if negative values are provided as an input.\\n\\n  Examples:\\n\\n  **Bin-counting every item in individual batches**\\n\\n  This example takes an input (which could be a Tensor, RaggedTensor, or\\n  SparseTensor) and returns a SparseTensor where the value of (i,j) is the\\n  number of times value j appears in batch i.\\n\\n  >>> data = tf.ragged.constant(\\n  ...     [[10, 20], [30, 20, 11, 101, 11, 10001]], dtype=np.int64)\\n  >>> tf.sparse.bincount(data, axis=-1)\\n  SparseTensor(indices=tf.Tensor(\\n    [[    0    10]\\n     [    0    20]\\n     [    1    11]\\n     [    1    20]\\n     [    1    30]\\n     [    1   101]\\n     [    1 10001]], shape=(7, 2), dtype=int64),\\n     values=tf.Tensor([1 1 2 1 1 1 1], shape=(7,), dtype=int64),\\n     dense_shape=tf.Tensor([    2 10002], shape=(2,), dtype=int64))\\n\\n  **Bin-counting with defined output shape**\\n\\n  This example takes an input (which could be a Tensor, RaggedTensor, or\\n  SparseTensor) and returns a SparseTensor where the value of (i,j) is the\\n  number of times value j appears in batch i. However, all values of j\\n  above 'maxlength' are ignored. The dense_shape of the output sparse tensor\\n  is set to 'minlength'. Note that, while the input is identical to the\\n  example above, the value '10001' in batch item 2 is dropped, and the\\n  dense shape is [2, 500] instead of [2,10002] or [2, 102].\\n\\n  >>> minlength = maxlength = 500\\n  >>> data = tf.ragged.constant(\\n  ...     [[10, 20], [30, 20, 11, 101, 11, 10001]], dtype=np.int64)\\n  >>> tf.sparse.bincount(\\n  ...    data, axis=-1, minlength=minlength, maxlength=maxlength)\\n  SparseTensor(indices=tf.Tensor(\\n  [[  0  10]\\n   [  0  20]\\n   [  1  11]\\n   [  1  20]\\n   [  1  30]\\n   [  1 101]], shape=(6, 2), dtype=int64),\\n   values=tf.Tensor([1 1 2 1 1 1], shape=(6,), dtype=int64),\\n   dense_shape=tf.Tensor([  2 500], shape=(2,), dtype=int64))\\n\\n  **Binary bin-counting**\\n\\n  This example takes an input (which could be a Tensor, RaggedTensor, or\\n  SparseTensor) and returns a SparseTensor where (i,j) is 1 if the value j\\n  appears in batch i at least once and is 0 otherwise. Note that, even though\\n  some values (like 20 in batch 1 and 11 in batch 2) appear more than once,\\n  the 'values' tensor is all 1s.\\n\\n  >>> data = tf.ragged.constant(\\n  ...     [[10, 20], [30, 20, 11, 101, 11, 10001]], dtype=np.int64)\\n  >>> tf.sparse.bincount(data, binary_output=True, axis=-1)\\n  SparseTensor(indices=tf.Tensor(\\n  [[  0  10]\\n   [  0  20]\\n   [  1  11]\\n   [  1  20]\\n   [  1  30]\\n   [  1 101]\\n   [  1 10001]], shape=(7, 2), dtype=int64),\\n   values=tf.Tensor([1 1 1 1 1 1 1], shape=(7,), dtype=int64),\\n   dense_shape=tf.Tensor([  2 10002], shape=(2,), dtype=int64))\\n\\n  **Weighted bin-counting**\\n\\n  This example takes two inputs - a values tensor and a weights tensor. These\\n  tensors must be identically shaped, and have the same row splits or indices\\n  in the case of RaggedTensors or SparseTensors. When performing a weighted\\n  count, the op will output a SparseTensor where the value of (i, j) is the\\n  sum of the values in the weight tensor's batch i in the locations where\\n  the values tensor has the value j. In this case, the output dtype is the\\n  same as the dtype of the weights tensor.\\n\\n  >>> data = tf.ragged.constant(\\n  ...    [[10, 20], [30, 20, 11, 101, 11, 10001]], dtype=np.int64)\\n  >>> weights = tf.ragged.constant(\\n  ...    [[2, 0.25], [15, 0.5, 2, 17, 3, 0.9]])\\n  >>> tf.sparse.bincount(data, weights=weights, axis=-1)\\n  SparseTensor(indices=tf.Tensor(\\n  [[    0    10]\\n   [    0    20]\\n   [    1    11]\\n   [    1    20]\\n   [    1    30]\\n   [    1   101]\\n   [    1 10001]], shape=(7, 2), dtype=int64),\\n   values=tf.Tensor([ 2. 0.25  5. 0.5 15. 17. 0.9 ], shape=(7,), dtype=float32),\\n   dense_shape=tf.Tensor([    2 10002], shape=(2,), dtype=int64))\\n\\n  \"\n    with ops.name_scope(name, 'count', [values, weights]):\n        values = ragged_tensor.convert_to_tensor_or_ragged_tensor(values, name='values')\n        if weights is not None:\n            if not isinstance(weights, sparse_tensor.SparseTensor):\n                weights = ragged_tensor.convert_to_tensor_or_ragged_tensor(weights, name='weights')\n        if weights is not None and binary_output:\n            raise ValueError('Arguments `binary_output` and `weights` are mutually exclusive. Please specify only one.')\n        if axis is None:\n            axis = 0\n        if axis not in [0, -1]:\n            raise ValueError(f'Unsupported value for argument axis={axis}. Only 0 and -1 are currently supported.')\n        minlength_value = minlength if minlength is not None else -1\n        maxlength_value = maxlength if maxlength is not None else -1\n        if axis == 0:\n            if weights is not None:\n                weights = validate_ragged_weights(values, weights)\n            values = values.values\n        if isinstance(values, ragged_tensor.RaggedTensor):\n            weights = validate_ragged_weights(values, weights)\n            (c_ind, c_val, c_shape) = gen_count_ops.ragged_count_sparse_output(values.row_splits, values.values, weights, minlength=minlength_value, maxlength=maxlength_value, binary_output=binary_output)\n        else:\n            weights = bincount_ops.validate_dense_weights(values, weights)\n            (c_ind, c_val, c_shape) = gen_count_ops.dense_count_sparse_output(values, weights=weights, minlength=minlength_value, maxlength=maxlength_value, binary_output=binary_output)\n        return sparse_tensor.SparseTensor(c_ind, c_val, c_shape)",
            "@dispatch.dispatch_for_api(sparse_ops.sparse_bincount)\ndef sparse_bincount(values: ragged_tensor.RaggedTensor, weights=None, axis=0, minlength=None, maxlength=None, binary_output=False, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Count the number of times an integer value appears in a tensor.\\n\\n  This op takes an N-dimensional `Tensor`, `RaggedTensor`, or `SparseTensor`,\\n  and returns an N-dimensional int64 SparseTensor where element\\n  `[i0...i[axis], j]` contains the number of times the value `j` appears in\\n  slice `[i0...i[axis], :]` of the input tensor.  Currently, only N=0 and\\n  N=-1 are supported.\\n\\n  Args:\\n    values: A RaggedTensor whose values should be\\n      counted. These tensors must have a rank of 2 if `axis=-1`.\\n    weights: If non-None, must be a RaggedTensor with the same row splits as\\n      `values`. For each value in `value`, the bin will be incremented by the\\n      corresponding weight instead of 1.\\n    axis: The axis to slice over. Axes at and below `axis` will be flattened\\n      before bin counting. Currently, only `0`, and `-1` are supported. If None,\\n      all axes will be flattened (identical to passing `0`).\\n    minlength: If given, ensures the output has length at least `minlength`,\\n      padding with zeros at the end if necessary.\\n    maxlength: If given, skips values in `values` that are equal or greater than\\n      `maxlength`, ensuring that the output has length at most `maxlength`.\\n    binary_output: If True, this op will output 1 instead of the number of times\\n      a token appears (equivalent to one_hot + reduce_any instead of one_hot +\\n      reduce_add). Defaults to False.\\n    name: A name for this op.\\n\\n  Returns:\\n    A SparseTensor with `output.shape = values.shape[:axis] + [N]`, where `N` is\\n      * `maxlength` (if set);\\n      * `minlength` (if set, and `minlength > reduce_max(values)`);\\n      * `0` (if `values` is empty);\\n      * `reduce_max(values) + 1` otherwise.\\n\\n  Raises:\\n    `InvalidArgumentError` if negative values are provided as an input.\\n\\n  Examples:\\n\\n  **Bin-counting every item in individual batches**\\n\\n  This example takes an input (which could be a Tensor, RaggedTensor, or\\n  SparseTensor) and returns a SparseTensor where the value of (i,j) is the\\n  number of times value j appears in batch i.\\n\\n  >>> data = tf.ragged.constant(\\n  ...     [[10, 20], [30, 20, 11, 101, 11, 10001]], dtype=np.int64)\\n  >>> tf.sparse.bincount(data, axis=-1)\\n  SparseTensor(indices=tf.Tensor(\\n    [[    0    10]\\n     [    0    20]\\n     [    1    11]\\n     [    1    20]\\n     [    1    30]\\n     [    1   101]\\n     [    1 10001]], shape=(7, 2), dtype=int64),\\n     values=tf.Tensor([1 1 2 1 1 1 1], shape=(7,), dtype=int64),\\n     dense_shape=tf.Tensor([    2 10002], shape=(2,), dtype=int64))\\n\\n  **Bin-counting with defined output shape**\\n\\n  This example takes an input (which could be a Tensor, RaggedTensor, or\\n  SparseTensor) and returns a SparseTensor where the value of (i,j) is the\\n  number of times value j appears in batch i. However, all values of j\\n  above 'maxlength' are ignored. The dense_shape of the output sparse tensor\\n  is set to 'minlength'. Note that, while the input is identical to the\\n  example above, the value '10001' in batch item 2 is dropped, and the\\n  dense shape is [2, 500] instead of [2,10002] or [2, 102].\\n\\n  >>> minlength = maxlength = 500\\n  >>> data = tf.ragged.constant(\\n  ...     [[10, 20], [30, 20, 11, 101, 11, 10001]], dtype=np.int64)\\n  >>> tf.sparse.bincount(\\n  ...    data, axis=-1, minlength=minlength, maxlength=maxlength)\\n  SparseTensor(indices=tf.Tensor(\\n  [[  0  10]\\n   [  0  20]\\n   [  1  11]\\n   [  1  20]\\n   [  1  30]\\n   [  1 101]], shape=(6, 2), dtype=int64),\\n   values=tf.Tensor([1 1 2 1 1 1], shape=(6,), dtype=int64),\\n   dense_shape=tf.Tensor([  2 500], shape=(2,), dtype=int64))\\n\\n  **Binary bin-counting**\\n\\n  This example takes an input (which could be a Tensor, RaggedTensor, or\\n  SparseTensor) and returns a SparseTensor where (i,j) is 1 if the value j\\n  appears in batch i at least once and is 0 otherwise. Note that, even though\\n  some values (like 20 in batch 1 and 11 in batch 2) appear more than once,\\n  the 'values' tensor is all 1s.\\n\\n  >>> data = tf.ragged.constant(\\n  ...     [[10, 20], [30, 20, 11, 101, 11, 10001]], dtype=np.int64)\\n  >>> tf.sparse.bincount(data, binary_output=True, axis=-1)\\n  SparseTensor(indices=tf.Tensor(\\n  [[  0  10]\\n   [  0  20]\\n   [  1  11]\\n   [  1  20]\\n   [  1  30]\\n   [  1 101]\\n   [  1 10001]], shape=(7, 2), dtype=int64),\\n   values=tf.Tensor([1 1 1 1 1 1 1], shape=(7,), dtype=int64),\\n   dense_shape=tf.Tensor([  2 10002], shape=(2,), dtype=int64))\\n\\n  **Weighted bin-counting**\\n\\n  This example takes two inputs - a values tensor and a weights tensor. These\\n  tensors must be identically shaped, and have the same row splits or indices\\n  in the case of RaggedTensors or SparseTensors. When performing a weighted\\n  count, the op will output a SparseTensor where the value of (i, j) is the\\n  sum of the values in the weight tensor's batch i in the locations where\\n  the values tensor has the value j. In this case, the output dtype is the\\n  same as the dtype of the weights tensor.\\n\\n  >>> data = tf.ragged.constant(\\n  ...    [[10, 20], [30, 20, 11, 101, 11, 10001]], dtype=np.int64)\\n  >>> weights = tf.ragged.constant(\\n  ...    [[2, 0.25], [15, 0.5, 2, 17, 3, 0.9]])\\n  >>> tf.sparse.bincount(data, weights=weights, axis=-1)\\n  SparseTensor(indices=tf.Tensor(\\n  [[    0    10]\\n   [    0    20]\\n   [    1    11]\\n   [    1    20]\\n   [    1    30]\\n   [    1   101]\\n   [    1 10001]], shape=(7, 2), dtype=int64),\\n   values=tf.Tensor([ 2. 0.25  5. 0.5 15. 17. 0.9 ], shape=(7,), dtype=float32),\\n   dense_shape=tf.Tensor([    2 10002], shape=(2,), dtype=int64))\\n\\n  \"\n    with ops.name_scope(name, 'count', [values, weights]):\n        values = ragged_tensor.convert_to_tensor_or_ragged_tensor(values, name='values')\n        if weights is not None:\n            if not isinstance(weights, sparse_tensor.SparseTensor):\n                weights = ragged_tensor.convert_to_tensor_or_ragged_tensor(weights, name='weights')\n        if weights is not None and binary_output:\n            raise ValueError('Arguments `binary_output` and `weights` are mutually exclusive. Please specify only one.')\n        if axis is None:\n            axis = 0\n        if axis not in [0, -1]:\n            raise ValueError(f'Unsupported value for argument axis={axis}. Only 0 and -1 are currently supported.')\n        minlength_value = minlength if minlength is not None else -1\n        maxlength_value = maxlength if maxlength is not None else -1\n        if axis == 0:\n            if weights is not None:\n                weights = validate_ragged_weights(values, weights)\n            values = values.values\n        if isinstance(values, ragged_tensor.RaggedTensor):\n            weights = validate_ragged_weights(values, weights)\n            (c_ind, c_val, c_shape) = gen_count_ops.ragged_count_sparse_output(values.row_splits, values.values, weights, minlength=minlength_value, maxlength=maxlength_value, binary_output=binary_output)\n        else:\n            weights = bincount_ops.validate_dense_weights(values, weights)\n            (c_ind, c_val, c_shape) = gen_count_ops.dense_count_sparse_output(values, weights=weights, minlength=minlength_value, maxlength=maxlength_value, binary_output=binary_output)\n        return sparse_tensor.SparseTensor(c_ind, c_val, c_shape)"
        ]
    },
    {
        "func_name": "validate_ragged_weights",
        "original": "def validate_ragged_weights(values, weights, dtype=None):\n    \"\"\"Validates the passed weight tensor or creates an empty one.\"\"\"\n    if weights is None:\n        if dtype:\n            return array_ops.constant([], dtype=dtype)\n        return array_ops.constant([], dtype=values.values.dtype)\n    if not isinstance(weights, ragged_tensor.RaggedTensor):\n        raise ValueError(f'`weights` must be a RaggedTensor if `values` is a RaggedTensor. Received argument weights={weights} of type: {type(weights).__name__}.')\n    checks = []\n    if weights.row_splits is not values.row_splits:\n        checks.append(check_ops.assert_equal(weights.row_splits, values.row_splits, message=\"'weights' and 'values' must have the same row splits.\"))\n    if checks:\n        with ops.control_dependencies(checks):\n            weights = array_ops.identity(weights.values)\n    else:\n        weights = weights.values\n    return weights",
        "mutated": [
            "def validate_ragged_weights(values, weights, dtype=None):\n    if False:\n        i = 10\n    'Validates the passed weight tensor or creates an empty one.'\n    if weights is None:\n        if dtype:\n            return array_ops.constant([], dtype=dtype)\n        return array_ops.constant([], dtype=values.values.dtype)\n    if not isinstance(weights, ragged_tensor.RaggedTensor):\n        raise ValueError(f'`weights` must be a RaggedTensor if `values` is a RaggedTensor. Received argument weights={weights} of type: {type(weights).__name__}.')\n    checks = []\n    if weights.row_splits is not values.row_splits:\n        checks.append(check_ops.assert_equal(weights.row_splits, values.row_splits, message=\"'weights' and 'values' must have the same row splits.\"))\n    if checks:\n        with ops.control_dependencies(checks):\n            weights = array_ops.identity(weights.values)\n    else:\n        weights = weights.values\n    return weights",
            "def validate_ragged_weights(values, weights, dtype=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Validates the passed weight tensor or creates an empty one.'\n    if weights is None:\n        if dtype:\n            return array_ops.constant([], dtype=dtype)\n        return array_ops.constant([], dtype=values.values.dtype)\n    if not isinstance(weights, ragged_tensor.RaggedTensor):\n        raise ValueError(f'`weights` must be a RaggedTensor if `values` is a RaggedTensor. Received argument weights={weights} of type: {type(weights).__name__}.')\n    checks = []\n    if weights.row_splits is not values.row_splits:\n        checks.append(check_ops.assert_equal(weights.row_splits, values.row_splits, message=\"'weights' and 'values' must have the same row splits.\"))\n    if checks:\n        with ops.control_dependencies(checks):\n            weights = array_ops.identity(weights.values)\n    else:\n        weights = weights.values\n    return weights",
            "def validate_ragged_weights(values, weights, dtype=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Validates the passed weight tensor or creates an empty one.'\n    if weights is None:\n        if dtype:\n            return array_ops.constant([], dtype=dtype)\n        return array_ops.constant([], dtype=values.values.dtype)\n    if not isinstance(weights, ragged_tensor.RaggedTensor):\n        raise ValueError(f'`weights` must be a RaggedTensor if `values` is a RaggedTensor. Received argument weights={weights} of type: {type(weights).__name__}.')\n    checks = []\n    if weights.row_splits is not values.row_splits:\n        checks.append(check_ops.assert_equal(weights.row_splits, values.row_splits, message=\"'weights' and 'values' must have the same row splits.\"))\n    if checks:\n        with ops.control_dependencies(checks):\n            weights = array_ops.identity(weights.values)\n    else:\n        weights = weights.values\n    return weights",
            "def validate_ragged_weights(values, weights, dtype=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Validates the passed weight tensor or creates an empty one.'\n    if weights is None:\n        if dtype:\n            return array_ops.constant([], dtype=dtype)\n        return array_ops.constant([], dtype=values.values.dtype)\n    if not isinstance(weights, ragged_tensor.RaggedTensor):\n        raise ValueError(f'`weights` must be a RaggedTensor if `values` is a RaggedTensor. Received argument weights={weights} of type: {type(weights).__name__}.')\n    checks = []\n    if weights.row_splits is not values.row_splits:\n        checks.append(check_ops.assert_equal(weights.row_splits, values.row_splits, message=\"'weights' and 'values' must have the same row splits.\"))\n    if checks:\n        with ops.control_dependencies(checks):\n            weights = array_ops.identity(weights.values)\n    else:\n        weights = weights.values\n    return weights",
            "def validate_ragged_weights(values, weights, dtype=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Validates the passed weight tensor or creates an empty one.'\n    if weights is None:\n        if dtype:\n            return array_ops.constant([], dtype=dtype)\n        return array_ops.constant([], dtype=values.values.dtype)\n    if not isinstance(weights, ragged_tensor.RaggedTensor):\n        raise ValueError(f'`weights` must be a RaggedTensor if `values` is a RaggedTensor. Received argument weights={weights} of type: {type(weights).__name__}.')\n    checks = []\n    if weights.row_splits is not values.row_splits:\n        checks.append(check_ops.assert_equal(weights.row_splits, values.row_splits, message=\"'weights' and 'values' must have the same row splits.\"))\n    if checks:\n        with ops.control_dependencies(checks):\n            weights = array_ops.identity(weights.values)\n    else:\n        weights = weights.values\n    return weights"
        ]
    }
]