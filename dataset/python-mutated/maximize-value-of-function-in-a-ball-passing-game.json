[
    {
        "func_name": "find_cycles",
        "original": "def find_cycles(adj):\n    result = []\n    lookup = [0] * len(adj)\n    idx = 0\n    for u in xrange(len(adj)):\n        prev = idx\n        while not lookup[u]:\n            idx += 1\n            lookup[u] = idx\n            u = adj[u]\n        if lookup[u] > prev:\n            result.append((u, idx - lookup[u] + 1))\n    return result",
        "mutated": [
            "def find_cycles(adj):\n    if False:\n        i = 10\n    result = []\n    lookup = [0] * len(adj)\n    idx = 0\n    for u in xrange(len(adj)):\n        prev = idx\n        while not lookup[u]:\n            idx += 1\n            lookup[u] = idx\n            u = adj[u]\n        if lookup[u] > prev:\n            result.append((u, idx - lookup[u] + 1))\n    return result",
            "def find_cycles(adj):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    result = []\n    lookup = [0] * len(adj)\n    idx = 0\n    for u in xrange(len(adj)):\n        prev = idx\n        while not lookup[u]:\n            idx += 1\n            lookup[u] = idx\n            u = adj[u]\n        if lookup[u] > prev:\n            result.append((u, idx - lookup[u] + 1))\n    return result",
            "def find_cycles(adj):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    result = []\n    lookup = [0] * len(adj)\n    idx = 0\n    for u in xrange(len(adj)):\n        prev = idx\n        while not lookup[u]:\n            idx += 1\n            lookup[u] = idx\n            u = adj[u]\n        if lookup[u] > prev:\n            result.append((u, idx - lookup[u] + 1))\n    return result",
            "def find_cycles(adj):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    result = []\n    lookup = [0] * len(adj)\n    idx = 0\n    for u in xrange(len(adj)):\n        prev = idx\n        while not lookup[u]:\n            idx += 1\n            lookup[u] = idx\n            u = adj[u]\n        if lookup[u] > prev:\n            result.append((u, idx - lookup[u] + 1))\n    return result",
            "def find_cycles(adj):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    result = []\n    lookup = [0] * len(adj)\n    idx = 0\n    for u in xrange(len(adj)):\n        prev = idx\n        while not lookup[u]:\n            idx += 1\n            lookup[u] = idx\n            u = adj[u]\n        if lookup[u] > prev:\n            result.append((u, idx - lookup[u] + 1))\n    return result"
        ]
    },
    {
        "func_name": "find_prefixes",
        "original": "def find_prefixes():\n    lookup = [(-1, -1)] * len(receiver)\n    prefixes = [[0] for _ in xrange(len(cycles))]\n    for (idx, (u, l)) in enumerate(cycles):\n        for i in xrange(l):\n            lookup[u] = (idx, i)\n            prefixes[idx].append(prefixes[idx][i] + u)\n            u = receiver[u]\n    return (lookup, prefixes)",
        "mutated": [
            "def find_prefixes():\n    if False:\n        i = 10\n    lookup = [(-1, -1)] * len(receiver)\n    prefixes = [[0] for _ in xrange(len(cycles))]\n    for (idx, (u, l)) in enumerate(cycles):\n        for i in xrange(l):\n            lookup[u] = (idx, i)\n            prefixes[idx].append(prefixes[idx][i] + u)\n            u = receiver[u]\n    return (lookup, prefixes)",
            "def find_prefixes():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    lookup = [(-1, -1)] * len(receiver)\n    prefixes = [[0] for _ in xrange(len(cycles))]\n    for (idx, (u, l)) in enumerate(cycles):\n        for i in xrange(l):\n            lookup[u] = (idx, i)\n            prefixes[idx].append(prefixes[idx][i] + u)\n            u = receiver[u]\n    return (lookup, prefixes)",
            "def find_prefixes():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    lookup = [(-1, -1)] * len(receiver)\n    prefixes = [[0] for _ in xrange(len(cycles))]\n    for (idx, (u, l)) in enumerate(cycles):\n        for i in xrange(l):\n            lookup[u] = (idx, i)\n            prefixes[idx].append(prefixes[idx][i] + u)\n            u = receiver[u]\n    return (lookup, prefixes)",
            "def find_prefixes():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    lookup = [(-1, -1)] * len(receiver)\n    prefixes = [[0] for _ in xrange(len(cycles))]\n    for (idx, (u, l)) in enumerate(cycles):\n        for i in xrange(l):\n            lookup[u] = (idx, i)\n            prefixes[idx].append(prefixes[idx][i] + u)\n            u = receiver[u]\n    return (lookup, prefixes)",
            "def find_prefixes():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    lookup = [(-1, -1)] * len(receiver)\n    prefixes = [[0] for _ in xrange(len(cycles))]\n    for (idx, (u, l)) in enumerate(cycles):\n        for i in xrange(l):\n            lookup[u] = (idx, i)\n            prefixes[idx].append(prefixes[idx][i] + u)\n            u = receiver[u]\n    return (lookup, prefixes)"
        ]
    },
    {
        "func_name": "get_sum",
        "original": "def get_sum(prefix, i, cnt):\n    l = len(prefix) - 1\n    (q, r) = divmod(cnt, l)\n    return q * prefix[-1] + (prefix[min(i + r, l)] - prefix[i]) + (prefix[max((i + r - l, 0))] - prefix[0])",
        "mutated": [
            "def get_sum(prefix, i, cnt):\n    if False:\n        i = 10\n    l = len(prefix) - 1\n    (q, r) = divmod(cnt, l)\n    return q * prefix[-1] + (prefix[min(i + r, l)] - prefix[i]) + (prefix[max((i + r - l, 0))] - prefix[0])",
            "def get_sum(prefix, i, cnt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    l = len(prefix) - 1\n    (q, r) = divmod(cnt, l)\n    return q * prefix[-1] + (prefix[min(i + r, l)] - prefix[i]) + (prefix[max((i + r - l, 0))] - prefix[0])",
            "def get_sum(prefix, i, cnt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    l = len(prefix) - 1\n    (q, r) = divmod(cnt, l)\n    return q * prefix[-1] + (prefix[min(i + r, l)] - prefix[i]) + (prefix[max((i + r - l, 0))] - prefix[0])",
            "def get_sum(prefix, i, cnt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    l = len(prefix) - 1\n    (q, r) = divmod(cnt, l)\n    return q * prefix[-1] + (prefix[min(i + r, l)] - prefix[i]) + (prefix[max((i + r - l, 0))] - prefix[0])",
            "def get_sum(prefix, i, cnt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    l = len(prefix) - 1\n    (q, r) = divmod(cnt, l)\n    return q * prefix[-1] + (prefix[min(i + r, l)] - prefix[i]) + (prefix[max((i + r - l, 0))] - prefix[0])"
        ]
    },
    {
        "func_name": "start_inside_cycle",
        "original": "def start_inside_cycle():\n    result = 0\n    for (u, l) in cycles:\n        for _ in xrange(l):\n            (idx, i) = lookup[u]\n            result = max(result, get_sum(prefixes[idx], i, k + 1))\n            u = receiver[u]\n    return result",
        "mutated": [
            "def start_inside_cycle():\n    if False:\n        i = 10\n    result = 0\n    for (u, l) in cycles:\n        for _ in xrange(l):\n            (idx, i) = lookup[u]\n            result = max(result, get_sum(prefixes[idx], i, k + 1))\n            u = receiver[u]\n    return result",
            "def start_inside_cycle():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    result = 0\n    for (u, l) in cycles:\n        for _ in xrange(l):\n            (idx, i) = lookup[u]\n            result = max(result, get_sum(prefixes[idx], i, k + 1))\n            u = receiver[u]\n    return result",
            "def start_inside_cycle():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    result = 0\n    for (u, l) in cycles:\n        for _ in xrange(l):\n            (idx, i) = lookup[u]\n            result = max(result, get_sum(prefixes[idx], i, k + 1))\n            u = receiver[u]\n    return result",
            "def start_inside_cycle():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    result = 0\n    for (u, l) in cycles:\n        for _ in xrange(l):\n            (idx, i) = lookup[u]\n            result = max(result, get_sum(prefixes[idx], i, k + 1))\n            u = receiver[u]\n    return result",
            "def start_inside_cycle():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    result = 0\n    for (u, l) in cycles:\n        for _ in xrange(l):\n            (idx, i) = lookup[u]\n            result = max(result, get_sum(prefixes[idx], i, k + 1))\n            u = receiver[u]\n    return result"
        ]
    },
    {
        "func_name": "start_outside_cycle",
        "original": "def start_outside_cycle():\n    result = 0\n    degree = [0] * len(receiver)\n    for x in receiver:\n        degree[x] += 1\n    for u in xrange(len(receiver)):\n        if degree[u]:\n            continue\n        curr = 0\n        dq = collections.deque()\n        while lookup[u][0] == -1:\n            curr += u\n            dq.append(u)\n            if len(dq) == k + 1:\n                result = max(result, curr)\n                curr -= dq.popleft()\n            u = receiver[u]\n        (idx, i) = lookup[u]\n        while dq:\n            result = max(result, curr + get_sum(prefixes[idx], i, k + 1 - len(dq)))\n            curr -= dq.popleft()\n    return result",
        "mutated": [
            "def start_outside_cycle():\n    if False:\n        i = 10\n    result = 0\n    degree = [0] * len(receiver)\n    for x in receiver:\n        degree[x] += 1\n    for u in xrange(len(receiver)):\n        if degree[u]:\n            continue\n        curr = 0\n        dq = collections.deque()\n        while lookup[u][0] == -1:\n            curr += u\n            dq.append(u)\n            if len(dq) == k + 1:\n                result = max(result, curr)\n                curr -= dq.popleft()\n            u = receiver[u]\n        (idx, i) = lookup[u]\n        while dq:\n            result = max(result, curr + get_sum(prefixes[idx], i, k + 1 - len(dq)))\n            curr -= dq.popleft()\n    return result",
            "def start_outside_cycle():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    result = 0\n    degree = [0] * len(receiver)\n    for x in receiver:\n        degree[x] += 1\n    for u in xrange(len(receiver)):\n        if degree[u]:\n            continue\n        curr = 0\n        dq = collections.deque()\n        while lookup[u][0] == -1:\n            curr += u\n            dq.append(u)\n            if len(dq) == k + 1:\n                result = max(result, curr)\n                curr -= dq.popleft()\n            u = receiver[u]\n        (idx, i) = lookup[u]\n        while dq:\n            result = max(result, curr + get_sum(prefixes[idx], i, k + 1 - len(dq)))\n            curr -= dq.popleft()\n    return result",
            "def start_outside_cycle():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    result = 0\n    degree = [0] * len(receiver)\n    for x in receiver:\n        degree[x] += 1\n    for u in xrange(len(receiver)):\n        if degree[u]:\n            continue\n        curr = 0\n        dq = collections.deque()\n        while lookup[u][0] == -1:\n            curr += u\n            dq.append(u)\n            if len(dq) == k + 1:\n                result = max(result, curr)\n                curr -= dq.popleft()\n            u = receiver[u]\n        (idx, i) = lookup[u]\n        while dq:\n            result = max(result, curr + get_sum(prefixes[idx], i, k + 1 - len(dq)))\n            curr -= dq.popleft()\n    return result",
            "def start_outside_cycle():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    result = 0\n    degree = [0] * len(receiver)\n    for x in receiver:\n        degree[x] += 1\n    for u in xrange(len(receiver)):\n        if degree[u]:\n            continue\n        curr = 0\n        dq = collections.deque()\n        while lookup[u][0] == -1:\n            curr += u\n            dq.append(u)\n            if len(dq) == k + 1:\n                result = max(result, curr)\n                curr -= dq.popleft()\n            u = receiver[u]\n        (idx, i) = lookup[u]\n        while dq:\n            result = max(result, curr + get_sum(prefixes[idx], i, k + 1 - len(dq)))\n            curr -= dq.popleft()\n    return result",
            "def start_outside_cycle():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    result = 0\n    degree = [0] * len(receiver)\n    for x in receiver:\n        degree[x] += 1\n    for u in xrange(len(receiver)):\n        if degree[u]:\n            continue\n        curr = 0\n        dq = collections.deque()\n        while lookup[u][0] == -1:\n            curr += u\n            dq.append(u)\n            if len(dq) == k + 1:\n                result = max(result, curr)\n                curr -= dq.popleft()\n            u = receiver[u]\n        (idx, i) = lookup[u]\n        while dq:\n            result = max(result, curr + get_sum(prefixes[idx], i, k + 1 - len(dq)))\n            curr -= dq.popleft()\n    return result"
        ]
    },
    {
        "func_name": "getMaxFunctionValue",
        "original": "def getMaxFunctionValue(self, receiver, k):\n    \"\"\"\n        :type receiver: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n\n    def find_cycles(adj):\n        result = []\n        lookup = [0] * len(adj)\n        idx = 0\n        for u in xrange(len(adj)):\n            prev = idx\n            while not lookup[u]:\n                idx += 1\n                lookup[u] = idx\n                u = adj[u]\n            if lookup[u] > prev:\n                result.append((u, idx - lookup[u] + 1))\n        return result\n\n    def find_prefixes():\n        lookup = [(-1, -1)] * len(receiver)\n        prefixes = [[0] for _ in xrange(len(cycles))]\n        for (idx, (u, l)) in enumerate(cycles):\n            for i in xrange(l):\n                lookup[u] = (idx, i)\n                prefixes[idx].append(prefixes[idx][i] + u)\n                u = receiver[u]\n        return (lookup, prefixes)\n\n    def get_sum(prefix, i, cnt):\n        l = len(prefix) - 1\n        (q, r) = divmod(cnt, l)\n        return q * prefix[-1] + (prefix[min(i + r, l)] - prefix[i]) + (prefix[max((i + r - l, 0))] - prefix[0])\n\n    def start_inside_cycle():\n        result = 0\n        for (u, l) in cycles:\n            for _ in xrange(l):\n                (idx, i) = lookup[u]\n                result = max(result, get_sum(prefixes[idx], i, k + 1))\n                u = receiver[u]\n        return result\n\n    def start_outside_cycle():\n        result = 0\n        degree = [0] * len(receiver)\n        for x in receiver:\n            degree[x] += 1\n        for u in xrange(len(receiver)):\n            if degree[u]:\n                continue\n            curr = 0\n            dq = collections.deque()\n            while lookup[u][0] == -1:\n                curr += u\n                dq.append(u)\n                if len(dq) == k + 1:\n                    result = max(result, curr)\n                    curr -= dq.popleft()\n                u = receiver[u]\n            (idx, i) = lookup[u]\n            while dq:\n                result = max(result, curr + get_sum(prefixes[idx], i, k + 1 - len(dq)))\n                curr -= dq.popleft()\n        return result\n    cycles = find_cycles(receiver)\n    (lookup, prefixes) = find_prefixes()\n    return max(start_inside_cycle(), start_outside_cycle())",
        "mutated": [
            "def getMaxFunctionValue(self, receiver, k):\n    if False:\n        i = 10\n    '\\n        :type receiver: List[int]\\n        :type k: int\\n        :rtype: int\\n        '\n\n    def find_cycles(adj):\n        result = []\n        lookup = [0] * len(adj)\n        idx = 0\n        for u in xrange(len(adj)):\n            prev = idx\n            while not lookup[u]:\n                idx += 1\n                lookup[u] = idx\n                u = adj[u]\n            if lookup[u] > prev:\n                result.append((u, idx - lookup[u] + 1))\n        return result\n\n    def find_prefixes():\n        lookup = [(-1, -1)] * len(receiver)\n        prefixes = [[0] for _ in xrange(len(cycles))]\n        for (idx, (u, l)) in enumerate(cycles):\n            for i in xrange(l):\n                lookup[u] = (idx, i)\n                prefixes[idx].append(prefixes[idx][i] + u)\n                u = receiver[u]\n        return (lookup, prefixes)\n\n    def get_sum(prefix, i, cnt):\n        l = len(prefix) - 1\n        (q, r) = divmod(cnt, l)\n        return q * prefix[-1] + (prefix[min(i + r, l)] - prefix[i]) + (prefix[max((i + r - l, 0))] - prefix[0])\n\n    def start_inside_cycle():\n        result = 0\n        for (u, l) in cycles:\n            for _ in xrange(l):\n                (idx, i) = lookup[u]\n                result = max(result, get_sum(prefixes[idx], i, k + 1))\n                u = receiver[u]\n        return result\n\n    def start_outside_cycle():\n        result = 0\n        degree = [0] * len(receiver)\n        for x in receiver:\n            degree[x] += 1\n        for u in xrange(len(receiver)):\n            if degree[u]:\n                continue\n            curr = 0\n            dq = collections.deque()\n            while lookup[u][0] == -1:\n                curr += u\n                dq.append(u)\n                if len(dq) == k + 1:\n                    result = max(result, curr)\n                    curr -= dq.popleft()\n                u = receiver[u]\n            (idx, i) = lookup[u]\n            while dq:\n                result = max(result, curr + get_sum(prefixes[idx], i, k + 1 - len(dq)))\n                curr -= dq.popleft()\n        return result\n    cycles = find_cycles(receiver)\n    (lookup, prefixes) = find_prefixes()\n    return max(start_inside_cycle(), start_outside_cycle())",
            "def getMaxFunctionValue(self, receiver, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :type receiver: List[int]\\n        :type k: int\\n        :rtype: int\\n        '\n\n    def find_cycles(adj):\n        result = []\n        lookup = [0] * len(adj)\n        idx = 0\n        for u in xrange(len(adj)):\n            prev = idx\n            while not lookup[u]:\n                idx += 1\n                lookup[u] = idx\n                u = adj[u]\n            if lookup[u] > prev:\n                result.append((u, idx - lookup[u] + 1))\n        return result\n\n    def find_prefixes():\n        lookup = [(-1, -1)] * len(receiver)\n        prefixes = [[0] for _ in xrange(len(cycles))]\n        for (idx, (u, l)) in enumerate(cycles):\n            for i in xrange(l):\n                lookup[u] = (idx, i)\n                prefixes[idx].append(prefixes[idx][i] + u)\n                u = receiver[u]\n        return (lookup, prefixes)\n\n    def get_sum(prefix, i, cnt):\n        l = len(prefix) - 1\n        (q, r) = divmod(cnt, l)\n        return q * prefix[-1] + (prefix[min(i + r, l)] - prefix[i]) + (prefix[max((i + r - l, 0))] - prefix[0])\n\n    def start_inside_cycle():\n        result = 0\n        for (u, l) in cycles:\n            for _ in xrange(l):\n                (idx, i) = lookup[u]\n                result = max(result, get_sum(prefixes[idx], i, k + 1))\n                u = receiver[u]\n        return result\n\n    def start_outside_cycle():\n        result = 0\n        degree = [0] * len(receiver)\n        for x in receiver:\n            degree[x] += 1\n        for u in xrange(len(receiver)):\n            if degree[u]:\n                continue\n            curr = 0\n            dq = collections.deque()\n            while lookup[u][0] == -1:\n                curr += u\n                dq.append(u)\n                if len(dq) == k + 1:\n                    result = max(result, curr)\n                    curr -= dq.popleft()\n                u = receiver[u]\n            (idx, i) = lookup[u]\n            while dq:\n                result = max(result, curr + get_sum(prefixes[idx], i, k + 1 - len(dq)))\n                curr -= dq.popleft()\n        return result\n    cycles = find_cycles(receiver)\n    (lookup, prefixes) = find_prefixes()\n    return max(start_inside_cycle(), start_outside_cycle())",
            "def getMaxFunctionValue(self, receiver, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :type receiver: List[int]\\n        :type k: int\\n        :rtype: int\\n        '\n\n    def find_cycles(adj):\n        result = []\n        lookup = [0] * len(adj)\n        idx = 0\n        for u in xrange(len(adj)):\n            prev = idx\n            while not lookup[u]:\n                idx += 1\n                lookup[u] = idx\n                u = adj[u]\n            if lookup[u] > prev:\n                result.append((u, idx - lookup[u] + 1))\n        return result\n\n    def find_prefixes():\n        lookup = [(-1, -1)] * len(receiver)\n        prefixes = [[0] for _ in xrange(len(cycles))]\n        for (idx, (u, l)) in enumerate(cycles):\n            for i in xrange(l):\n                lookup[u] = (idx, i)\n                prefixes[idx].append(prefixes[idx][i] + u)\n                u = receiver[u]\n        return (lookup, prefixes)\n\n    def get_sum(prefix, i, cnt):\n        l = len(prefix) - 1\n        (q, r) = divmod(cnt, l)\n        return q * prefix[-1] + (prefix[min(i + r, l)] - prefix[i]) + (prefix[max((i + r - l, 0))] - prefix[0])\n\n    def start_inside_cycle():\n        result = 0\n        for (u, l) in cycles:\n            for _ in xrange(l):\n                (idx, i) = lookup[u]\n                result = max(result, get_sum(prefixes[idx], i, k + 1))\n                u = receiver[u]\n        return result\n\n    def start_outside_cycle():\n        result = 0\n        degree = [0] * len(receiver)\n        for x in receiver:\n            degree[x] += 1\n        for u in xrange(len(receiver)):\n            if degree[u]:\n                continue\n            curr = 0\n            dq = collections.deque()\n            while lookup[u][0] == -1:\n                curr += u\n                dq.append(u)\n                if len(dq) == k + 1:\n                    result = max(result, curr)\n                    curr -= dq.popleft()\n                u = receiver[u]\n            (idx, i) = lookup[u]\n            while dq:\n                result = max(result, curr + get_sum(prefixes[idx], i, k + 1 - len(dq)))\n                curr -= dq.popleft()\n        return result\n    cycles = find_cycles(receiver)\n    (lookup, prefixes) = find_prefixes()\n    return max(start_inside_cycle(), start_outside_cycle())",
            "def getMaxFunctionValue(self, receiver, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :type receiver: List[int]\\n        :type k: int\\n        :rtype: int\\n        '\n\n    def find_cycles(adj):\n        result = []\n        lookup = [0] * len(adj)\n        idx = 0\n        for u in xrange(len(adj)):\n            prev = idx\n            while not lookup[u]:\n                idx += 1\n                lookup[u] = idx\n                u = adj[u]\n            if lookup[u] > prev:\n                result.append((u, idx - lookup[u] + 1))\n        return result\n\n    def find_prefixes():\n        lookup = [(-1, -1)] * len(receiver)\n        prefixes = [[0] for _ in xrange(len(cycles))]\n        for (idx, (u, l)) in enumerate(cycles):\n            for i in xrange(l):\n                lookup[u] = (idx, i)\n                prefixes[idx].append(prefixes[idx][i] + u)\n                u = receiver[u]\n        return (lookup, prefixes)\n\n    def get_sum(prefix, i, cnt):\n        l = len(prefix) - 1\n        (q, r) = divmod(cnt, l)\n        return q * prefix[-1] + (prefix[min(i + r, l)] - prefix[i]) + (prefix[max((i + r - l, 0))] - prefix[0])\n\n    def start_inside_cycle():\n        result = 0\n        for (u, l) in cycles:\n            for _ in xrange(l):\n                (idx, i) = lookup[u]\n                result = max(result, get_sum(prefixes[idx], i, k + 1))\n                u = receiver[u]\n        return result\n\n    def start_outside_cycle():\n        result = 0\n        degree = [0] * len(receiver)\n        for x in receiver:\n            degree[x] += 1\n        for u in xrange(len(receiver)):\n            if degree[u]:\n                continue\n            curr = 0\n            dq = collections.deque()\n            while lookup[u][0] == -1:\n                curr += u\n                dq.append(u)\n                if len(dq) == k + 1:\n                    result = max(result, curr)\n                    curr -= dq.popleft()\n                u = receiver[u]\n            (idx, i) = lookup[u]\n            while dq:\n                result = max(result, curr + get_sum(prefixes[idx], i, k + 1 - len(dq)))\n                curr -= dq.popleft()\n        return result\n    cycles = find_cycles(receiver)\n    (lookup, prefixes) = find_prefixes()\n    return max(start_inside_cycle(), start_outside_cycle())",
            "def getMaxFunctionValue(self, receiver, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :type receiver: List[int]\\n        :type k: int\\n        :rtype: int\\n        '\n\n    def find_cycles(adj):\n        result = []\n        lookup = [0] * len(adj)\n        idx = 0\n        for u in xrange(len(adj)):\n            prev = idx\n            while not lookup[u]:\n                idx += 1\n                lookup[u] = idx\n                u = adj[u]\n            if lookup[u] > prev:\n                result.append((u, idx - lookup[u] + 1))\n        return result\n\n    def find_prefixes():\n        lookup = [(-1, -1)] * len(receiver)\n        prefixes = [[0] for _ in xrange(len(cycles))]\n        for (idx, (u, l)) in enumerate(cycles):\n            for i in xrange(l):\n                lookup[u] = (idx, i)\n                prefixes[idx].append(prefixes[idx][i] + u)\n                u = receiver[u]\n        return (lookup, prefixes)\n\n    def get_sum(prefix, i, cnt):\n        l = len(prefix) - 1\n        (q, r) = divmod(cnt, l)\n        return q * prefix[-1] + (prefix[min(i + r, l)] - prefix[i]) + (prefix[max((i + r - l, 0))] - prefix[0])\n\n    def start_inside_cycle():\n        result = 0\n        for (u, l) in cycles:\n            for _ in xrange(l):\n                (idx, i) = lookup[u]\n                result = max(result, get_sum(prefixes[idx], i, k + 1))\n                u = receiver[u]\n        return result\n\n    def start_outside_cycle():\n        result = 0\n        degree = [0] * len(receiver)\n        for x in receiver:\n            degree[x] += 1\n        for u in xrange(len(receiver)):\n            if degree[u]:\n                continue\n            curr = 0\n            dq = collections.deque()\n            while lookup[u][0] == -1:\n                curr += u\n                dq.append(u)\n                if len(dq) == k + 1:\n                    result = max(result, curr)\n                    curr -= dq.popleft()\n                u = receiver[u]\n            (idx, i) = lookup[u]\n            while dq:\n                result = max(result, curr + get_sum(prefixes[idx], i, k + 1 - len(dq)))\n                curr -= dq.popleft()\n        return result\n    cycles = find_cycles(receiver)\n    (lookup, prefixes) = find_prefixes()\n    return max(start_inside_cycle(), start_outside_cycle())"
        ]
    },
    {
        "func_name": "getMaxFunctionValue",
        "original": "def getMaxFunctionValue(self, receiver, k):\n    \"\"\"\n        :type receiver: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n    l = (k + 1).bit_length()\n    P = [receiver[:] for _ in xrange(l)]\n    S = [range(len(receiver)) for _ in xrange(l)]\n    for i in xrange(1, len(P)):\n        for u in xrange(len(receiver)):\n            P[i][u] = P[i - 1][P[i - 1][u]]\n            S[i][u] = S[i - 1][u] + S[i - 1][P[i - 1][u]]\n    result = 0\n    for u in xrange(len(receiver)):\n        curr = 0\n        for i in xrange(l):\n            if k + 1 & 1 << i:\n                curr += S[i][u]\n                u = P[i][u]\n        result = max(result, curr)\n    return result",
        "mutated": [
            "def getMaxFunctionValue(self, receiver, k):\n    if False:\n        i = 10\n    '\\n        :type receiver: List[int]\\n        :type k: int\\n        :rtype: int\\n        '\n    l = (k + 1).bit_length()\n    P = [receiver[:] for _ in xrange(l)]\n    S = [range(len(receiver)) for _ in xrange(l)]\n    for i in xrange(1, len(P)):\n        for u in xrange(len(receiver)):\n            P[i][u] = P[i - 1][P[i - 1][u]]\n            S[i][u] = S[i - 1][u] + S[i - 1][P[i - 1][u]]\n    result = 0\n    for u in xrange(len(receiver)):\n        curr = 0\n        for i in xrange(l):\n            if k + 1 & 1 << i:\n                curr += S[i][u]\n                u = P[i][u]\n        result = max(result, curr)\n    return result",
            "def getMaxFunctionValue(self, receiver, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :type receiver: List[int]\\n        :type k: int\\n        :rtype: int\\n        '\n    l = (k + 1).bit_length()\n    P = [receiver[:] for _ in xrange(l)]\n    S = [range(len(receiver)) for _ in xrange(l)]\n    for i in xrange(1, len(P)):\n        for u in xrange(len(receiver)):\n            P[i][u] = P[i - 1][P[i - 1][u]]\n            S[i][u] = S[i - 1][u] + S[i - 1][P[i - 1][u]]\n    result = 0\n    for u in xrange(len(receiver)):\n        curr = 0\n        for i in xrange(l):\n            if k + 1 & 1 << i:\n                curr += S[i][u]\n                u = P[i][u]\n        result = max(result, curr)\n    return result",
            "def getMaxFunctionValue(self, receiver, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :type receiver: List[int]\\n        :type k: int\\n        :rtype: int\\n        '\n    l = (k + 1).bit_length()\n    P = [receiver[:] for _ in xrange(l)]\n    S = [range(len(receiver)) for _ in xrange(l)]\n    for i in xrange(1, len(P)):\n        for u in xrange(len(receiver)):\n            P[i][u] = P[i - 1][P[i - 1][u]]\n            S[i][u] = S[i - 1][u] + S[i - 1][P[i - 1][u]]\n    result = 0\n    for u in xrange(len(receiver)):\n        curr = 0\n        for i in xrange(l):\n            if k + 1 & 1 << i:\n                curr += S[i][u]\n                u = P[i][u]\n        result = max(result, curr)\n    return result",
            "def getMaxFunctionValue(self, receiver, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :type receiver: List[int]\\n        :type k: int\\n        :rtype: int\\n        '\n    l = (k + 1).bit_length()\n    P = [receiver[:] for _ in xrange(l)]\n    S = [range(len(receiver)) for _ in xrange(l)]\n    for i in xrange(1, len(P)):\n        for u in xrange(len(receiver)):\n            P[i][u] = P[i - 1][P[i - 1][u]]\n            S[i][u] = S[i - 1][u] + S[i - 1][P[i - 1][u]]\n    result = 0\n    for u in xrange(len(receiver)):\n        curr = 0\n        for i in xrange(l):\n            if k + 1 & 1 << i:\n                curr += S[i][u]\n                u = P[i][u]\n        result = max(result, curr)\n    return result",
            "def getMaxFunctionValue(self, receiver, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :type receiver: List[int]\\n        :type k: int\\n        :rtype: int\\n        '\n    l = (k + 1).bit_length()\n    P = [receiver[:] for _ in xrange(l)]\n    S = [range(len(receiver)) for _ in xrange(l)]\n    for i in xrange(1, len(P)):\n        for u in xrange(len(receiver)):\n            P[i][u] = P[i - 1][P[i - 1][u]]\n            S[i][u] = S[i - 1][u] + S[i - 1][P[i - 1][u]]\n    result = 0\n    for u in xrange(len(receiver)):\n        curr = 0\n        for i in xrange(l):\n            if k + 1 & 1 << i:\n                curr += S[i][u]\n                u = P[i][u]\n        result = max(result, curr)\n    return result"
        ]
    }
]