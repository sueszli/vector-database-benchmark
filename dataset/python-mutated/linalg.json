[
    {
        "func_name": "orth",
        "original": "def orth(V, tol=1e-12):\n    \"\"\"Return a matrix whose columns are an orthonormal basis for range(V)\"\"\"\n    (Q, R, p) = la.qr(V, mode='economic', pivoting=True)\n    rank = np.count_nonzero(np.sum(np.abs(R) > tol, axis=1))\n    Q = Q[:, :rank].reshape((V.shape[0], rank))\n    return Q",
        "mutated": [
            "def orth(V, tol=1e-12):\n    if False:\n        i = 10\n    'Return a matrix whose columns are an orthonormal basis for range(V)'\n    (Q, R, p) = la.qr(V, mode='economic', pivoting=True)\n    rank = np.count_nonzero(np.sum(np.abs(R) > tol, axis=1))\n    Q = Q[:, :rank].reshape((V.shape[0], rank))\n    return Q",
            "def orth(V, tol=1e-12):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Return a matrix whose columns are an orthonormal basis for range(V)'\n    (Q, R, p) = la.qr(V, mode='economic', pivoting=True)\n    rank = np.count_nonzero(np.sum(np.abs(R) > tol, axis=1))\n    Q = Q[:, :rank].reshape((V.shape[0], rank))\n    return Q",
            "def orth(V, tol=1e-12):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Return a matrix whose columns are an orthonormal basis for range(V)'\n    (Q, R, p) = la.qr(V, mode='economic', pivoting=True)\n    rank = np.count_nonzero(np.sum(np.abs(R) > tol, axis=1))\n    Q = Q[:, :rank].reshape((V.shape[0], rank))\n    return Q",
            "def orth(V, tol=1e-12):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Return a matrix whose columns are an orthonormal basis for range(V)'\n    (Q, R, p) = la.qr(V, mode='economic', pivoting=True)\n    rank = np.count_nonzero(np.sum(np.abs(R) > tol, axis=1))\n    Q = Q[:, :rank].reshape((V.shape[0], rank))\n    return Q",
            "def orth(V, tol=1e-12):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Return a matrix whose columns are an orthonormal basis for range(V)'\n    (Q, R, p) = la.qr(V, mode='economic', pivoting=True)\n    rank = np.count_nonzero(np.sum(np.abs(R) > tol, axis=1))\n    Q = Q[:, :rank].reshape((V.shape[0], rank))\n    return Q"
        ]
    },
    {
        "func_name": "onb_for_orthogonal_complement",
        "original": "def onb_for_orthogonal_complement(V):\n    \"\"\"\n    Let U = the orthogonal complement of range(V).\n\n    This function returns an array Q whose columns are\n    an orthonormal basis for U. It requires that dim(U) > 0.\n    \"\"\"\n    n = V.shape[0]\n    Q1 = orth(V)\n    rank = Q1.shape[1]\n    assert n > rank\n    if np.iscomplexobj(V):\n        P = np.eye(n) - Q1 @ Q1.conj().T\n    else:\n        P = np.eye(n) - Q1 @ Q1.T\n    Q2 = orth(P)\n    return Q2",
        "mutated": [
            "def onb_for_orthogonal_complement(V):\n    if False:\n        i = 10\n    '\\n    Let U = the orthogonal complement of range(V).\\n\\n    This function returns an array Q whose columns are\\n    an orthonormal basis for U. It requires that dim(U) > 0.\\n    '\n    n = V.shape[0]\n    Q1 = orth(V)\n    rank = Q1.shape[1]\n    assert n > rank\n    if np.iscomplexobj(V):\n        P = np.eye(n) - Q1 @ Q1.conj().T\n    else:\n        P = np.eye(n) - Q1 @ Q1.T\n    Q2 = orth(P)\n    return Q2",
            "def onb_for_orthogonal_complement(V):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Let U = the orthogonal complement of range(V).\\n\\n    This function returns an array Q whose columns are\\n    an orthonormal basis for U. It requires that dim(U) > 0.\\n    '\n    n = V.shape[0]\n    Q1 = orth(V)\n    rank = Q1.shape[1]\n    assert n > rank\n    if np.iscomplexobj(V):\n        P = np.eye(n) - Q1 @ Q1.conj().T\n    else:\n        P = np.eye(n) - Q1 @ Q1.T\n    Q2 = orth(P)\n    return Q2",
            "def onb_for_orthogonal_complement(V):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Let U = the orthogonal complement of range(V).\\n\\n    This function returns an array Q whose columns are\\n    an orthonormal basis for U. It requires that dim(U) > 0.\\n    '\n    n = V.shape[0]\n    Q1 = orth(V)\n    rank = Q1.shape[1]\n    assert n > rank\n    if np.iscomplexobj(V):\n        P = np.eye(n) - Q1 @ Q1.conj().T\n    else:\n        P = np.eye(n) - Q1 @ Q1.T\n    Q2 = orth(P)\n    return Q2",
            "def onb_for_orthogonal_complement(V):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Let U = the orthogonal complement of range(V).\\n\\n    This function returns an array Q whose columns are\\n    an orthonormal basis for U. It requires that dim(U) > 0.\\n    '\n    n = V.shape[0]\n    Q1 = orth(V)\n    rank = Q1.shape[1]\n    assert n > rank\n    if np.iscomplexobj(V):\n        P = np.eye(n) - Q1 @ Q1.conj().T\n    else:\n        P = np.eye(n) - Q1 @ Q1.T\n    Q2 = orth(P)\n    return Q2",
            "def onb_for_orthogonal_complement(V):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Let U = the orthogonal complement of range(V).\\n\\n    This function returns an array Q whose columns are\\n    an orthonormal basis for U. It requires that dim(U) > 0.\\n    '\n    n = V.shape[0]\n    Q1 = orth(V)\n    rank = Q1.shape[1]\n    assert n > rank\n    if np.iscomplexobj(V):\n        P = np.eye(n) - Q1 @ Q1.conj().T\n    else:\n        P = np.eye(n) - Q1 @ Q1.T\n    Q2 = orth(P)\n    return Q2"
        ]
    },
    {
        "func_name": "is_diagonal",
        "original": "def is_diagonal(A):\n    if isinstance(A, spar.spmatrix):\n        off_diagonal_elements = A - spar.diags(A.diagonal())\n        off_diagonal_elements = off_diagonal_elements.toarray()\n    elif isinstance(A, np.ndarray):\n        off_diagonal_elements = A - np.diag(np.diag(A))\n    else:\n        raise ValueError('Unsupported matrix type.')\n    return np.allclose(off_diagonal_elements, 0)",
        "mutated": [
            "def is_diagonal(A):\n    if False:\n        i = 10\n    if isinstance(A, spar.spmatrix):\n        off_diagonal_elements = A - spar.diags(A.diagonal())\n        off_diagonal_elements = off_diagonal_elements.toarray()\n    elif isinstance(A, np.ndarray):\n        off_diagonal_elements = A - np.diag(np.diag(A))\n    else:\n        raise ValueError('Unsupported matrix type.')\n    return np.allclose(off_diagonal_elements, 0)",
            "def is_diagonal(A):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if isinstance(A, spar.spmatrix):\n        off_diagonal_elements = A - spar.diags(A.diagonal())\n        off_diagonal_elements = off_diagonal_elements.toarray()\n    elif isinstance(A, np.ndarray):\n        off_diagonal_elements = A - np.diag(np.diag(A))\n    else:\n        raise ValueError('Unsupported matrix type.')\n    return np.allclose(off_diagonal_elements, 0)",
            "def is_diagonal(A):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if isinstance(A, spar.spmatrix):\n        off_diagonal_elements = A - spar.diags(A.diagonal())\n        off_diagonal_elements = off_diagonal_elements.toarray()\n    elif isinstance(A, np.ndarray):\n        off_diagonal_elements = A - np.diag(np.diag(A))\n    else:\n        raise ValueError('Unsupported matrix type.')\n    return np.allclose(off_diagonal_elements, 0)",
            "def is_diagonal(A):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if isinstance(A, spar.spmatrix):\n        off_diagonal_elements = A - spar.diags(A.diagonal())\n        off_diagonal_elements = off_diagonal_elements.toarray()\n    elif isinstance(A, np.ndarray):\n        off_diagonal_elements = A - np.diag(np.diag(A))\n    else:\n        raise ValueError('Unsupported matrix type.')\n    return np.allclose(off_diagonal_elements, 0)",
            "def is_diagonal(A):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if isinstance(A, spar.spmatrix):\n        off_diagonal_elements = A - spar.diags(A.diagonal())\n        off_diagonal_elements = off_diagonal_elements.toarray()\n    elif isinstance(A, np.ndarray):\n        off_diagonal_elements = A - np.diag(np.diag(A))\n    else:\n        raise ValueError('Unsupported matrix type.')\n    return np.allclose(off_diagonal_elements, 0)"
        ]
    },
    {
        "func_name": "SA_eigsh",
        "original": "def SA_eigsh(sigma):\n    if hasattr(np.random, 'default_rng'):\n        g = np.random.default_rng(123)\n    else:\n        g = np.random.RandomState(123)\n    n = A.shape[0]\n    v0 = g.normal(loc=0.0, scale=1.0, size=n)\n    return sparla.eigsh(A, k=1, sigma=sigma, which='SA', v0=v0, return_eigenvectors=False)",
        "mutated": [
            "def SA_eigsh(sigma):\n    if False:\n        i = 10\n    if hasattr(np.random, 'default_rng'):\n        g = np.random.default_rng(123)\n    else:\n        g = np.random.RandomState(123)\n    n = A.shape[0]\n    v0 = g.normal(loc=0.0, scale=1.0, size=n)\n    return sparla.eigsh(A, k=1, sigma=sigma, which='SA', v0=v0, return_eigenvectors=False)",
            "def SA_eigsh(sigma):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if hasattr(np.random, 'default_rng'):\n        g = np.random.default_rng(123)\n    else:\n        g = np.random.RandomState(123)\n    n = A.shape[0]\n    v0 = g.normal(loc=0.0, scale=1.0, size=n)\n    return sparla.eigsh(A, k=1, sigma=sigma, which='SA', v0=v0, return_eigenvectors=False)",
            "def SA_eigsh(sigma):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if hasattr(np.random, 'default_rng'):\n        g = np.random.default_rng(123)\n    else:\n        g = np.random.RandomState(123)\n    n = A.shape[0]\n    v0 = g.normal(loc=0.0, scale=1.0, size=n)\n    return sparla.eigsh(A, k=1, sigma=sigma, which='SA', v0=v0, return_eigenvectors=False)",
            "def SA_eigsh(sigma):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if hasattr(np.random, 'default_rng'):\n        g = np.random.default_rng(123)\n    else:\n        g = np.random.RandomState(123)\n    n = A.shape[0]\n    v0 = g.normal(loc=0.0, scale=1.0, size=n)\n    return sparla.eigsh(A, k=1, sigma=sigma, which='SA', v0=v0, return_eigenvectors=False)",
            "def SA_eigsh(sigma):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if hasattr(np.random, 'default_rng'):\n        g = np.random.default_rng(123)\n    else:\n        g = np.random.RandomState(123)\n    n = A.shape[0]\n    v0 = g.normal(loc=0.0, scale=1.0, size=n)\n    return sparla.eigsh(A, k=1, sigma=sigma, which='SA', v0=v0, return_eigenvectors=False)"
        ]
    },
    {
        "func_name": "is_psd_within_tol",
        "original": "def is_psd_within_tol(A, tol):\n    \"\"\"\n    Return True if we can certify that A is PSD (up to tolerance \"tol\").\n\n    First we check if A is PSD according to the Gershgorin Circle Theorem.\n\n    If Gershgorin is inconclusive, then we use an iterative method (from ARPACK,\n    as called through SciPy) to estimate extremal eigenvalues of certain shifted\n    versions of A. The shifts are chosen so that the signs of those eigenvalues\n    tell us the signs of the eigenvalues of A.\n\n    If there are numerical issues then it's possible that this function returns\n    False even when A is PSD. If you know that you're in that situation, then\n    you should replace A by\n\n        A = cvxpy.atoms.affine.wraps.psd_wrap(A).\n\n    Parameters\n    ----------\n    A : Union[np.ndarray, spar.spmatrix]\n        Symmetric (or Hermitian) NumPy ndarray or SciPy sparse matrix.\n\n    tol : float\n        Nonnegative. Something very small, like 1e-10.\n    \"\"\"\n    if gershgorin_psd_check(A, tol):\n        return True\n    if is_diagonal(A):\n        if isinstance(A, csc_matrix):\n            return np.all(A.data >= -tol)\n        else:\n            min_diag_entry = np.min(np.diag(A))\n            return min_diag_entry >= -tol\n\n    def SA_eigsh(sigma):\n        if hasattr(np.random, 'default_rng'):\n            g = np.random.default_rng(123)\n        else:\n            g = np.random.RandomState(123)\n        n = A.shape[0]\n        v0 = g.normal(loc=0.0, scale=1.0, size=n)\n        return sparla.eigsh(A, k=1, sigma=sigma, which='SA', v0=v0, return_eigenvectors=False)\n    try:\n        ev = SA_eigsh(-tol)\n    except sparla.ArpackNoConvergence as e:\n        message = \"\\n        CVXPY note: This failure was encountered while trying to certify\\n        that a matrix is positive semi-definite (see [1] for a definition).\\n        In rare cases, this method fails for numerical reasons even when the matrix is\\n        positive semi-definite. If you know that you're in that situation, you can\\n        replace the matrix A by cvxpy.psd_wrap(A).\\n\\n        [1] https://en.wikipedia.org/wiki/Definite_matrix\\n        \"\n        error_with_note = f'{str(e)}\\n\\n{message}'\n        raise sparla.ArpackNoConvergence(error_with_note, e.eigenvalues, e.eigenvectors)\n    if np.isnan(ev).any():\n        temp = tol - np.finfo(A.dtype).eps\n        ev = SA_eigsh(-temp)\n    return np.all(ev >= -tol)",
        "mutated": [
            "def is_psd_within_tol(A, tol):\n    if False:\n        i = 10\n    '\\n    Return True if we can certify that A is PSD (up to tolerance \"tol\").\\n\\n    First we check if A is PSD according to the Gershgorin Circle Theorem.\\n\\n    If Gershgorin is inconclusive, then we use an iterative method (from ARPACK,\\n    as called through SciPy) to estimate extremal eigenvalues of certain shifted\\n    versions of A. The shifts are chosen so that the signs of those eigenvalues\\n    tell us the signs of the eigenvalues of A.\\n\\n    If there are numerical issues then it\\'s possible that this function returns\\n    False even when A is PSD. If you know that you\\'re in that situation, then\\n    you should replace A by\\n\\n        A = cvxpy.atoms.affine.wraps.psd_wrap(A).\\n\\n    Parameters\\n    ----------\\n    A : Union[np.ndarray, spar.spmatrix]\\n        Symmetric (or Hermitian) NumPy ndarray or SciPy sparse matrix.\\n\\n    tol : float\\n        Nonnegative. Something very small, like 1e-10.\\n    '\n    if gershgorin_psd_check(A, tol):\n        return True\n    if is_diagonal(A):\n        if isinstance(A, csc_matrix):\n            return np.all(A.data >= -tol)\n        else:\n            min_diag_entry = np.min(np.diag(A))\n            return min_diag_entry >= -tol\n\n    def SA_eigsh(sigma):\n        if hasattr(np.random, 'default_rng'):\n            g = np.random.default_rng(123)\n        else:\n            g = np.random.RandomState(123)\n        n = A.shape[0]\n        v0 = g.normal(loc=0.0, scale=1.0, size=n)\n        return sparla.eigsh(A, k=1, sigma=sigma, which='SA', v0=v0, return_eigenvectors=False)\n    try:\n        ev = SA_eigsh(-tol)\n    except sparla.ArpackNoConvergence as e:\n        message = \"\\n        CVXPY note: This failure was encountered while trying to certify\\n        that a matrix is positive semi-definite (see [1] for a definition).\\n        In rare cases, this method fails for numerical reasons even when the matrix is\\n        positive semi-definite. If you know that you're in that situation, you can\\n        replace the matrix A by cvxpy.psd_wrap(A).\\n\\n        [1] https://en.wikipedia.org/wiki/Definite_matrix\\n        \"\n        error_with_note = f'{str(e)}\\n\\n{message}'\n        raise sparla.ArpackNoConvergence(error_with_note, e.eigenvalues, e.eigenvectors)\n    if np.isnan(ev).any():\n        temp = tol - np.finfo(A.dtype).eps\n        ev = SA_eigsh(-temp)\n    return np.all(ev >= -tol)",
            "def is_psd_within_tol(A, tol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Return True if we can certify that A is PSD (up to tolerance \"tol\").\\n\\n    First we check if A is PSD according to the Gershgorin Circle Theorem.\\n\\n    If Gershgorin is inconclusive, then we use an iterative method (from ARPACK,\\n    as called through SciPy) to estimate extremal eigenvalues of certain shifted\\n    versions of A. The shifts are chosen so that the signs of those eigenvalues\\n    tell us the signs of the eigenvalues of A.\\n\\n    If there are numerical issues then it\\'s possible that this function returns\\n    False even when A is PSD. If you know that you\\'re in that situation, then\\n    you should replace A by\\n\\n        A = cvxpy.atoms.affine.wraps.psd_wrap(A).\\n\\n    Parameters\\n    ----------\\n    A : Union[np.ndarray, spar.spmatrix]\\n        Symmetric (or Hermitian) NumPy ndarray or SciPy sparse matrix.\\n\\n    tol : float\\n        Nonnegative. Something very small, like 1e-10.\\n    '\n    if gershgorin_psd_check(A, tol):\n        return True\n    if is_diagonal(A):\n        if isinstance(A, csc_matrix):\n            return np.all(A.data >= -tol)\n        else:\n            min_diag_entry = np.min(np.diag(A))\n            return min_diag_entry >= -tol\n\n    def SA_eigsh(sigma):\n        if hasattr(np.random, 'default_rng'):\n            g = np.random.default_rng(123)\n        else:\n            g = np.random.RandomState(123)\n        n = A.shape[0]\n        v0 = g.normal(loc=0.0, scale=1.0, size=n)\n        return sparla.eigsh(A, k=1, sigma=sigma, which='SA', v0=v0, return_eigenvectors=False)\n    try:\n        ev = SA_eigsh(-tol)\n    except sparla.ArpackNoConvergence as e:\n        message = \"\\n        CVXPY note: This failure was encountered while trying to certify\\n        that a matrix is positive semi-definite (see [1] for a definition).\\n        In rare cases, this method fails for numerical reasons even when the matrix is\\n        positive semi-definite. If you know that you're in that situation, you can\\n        replace the matrix A by cvxpy.psd_wrap(A).\\n\\n        [1] https://en.wikipedia.org/wiki/Definite_matrix\\n        \"\n        error_with_note = f'{str(e)}\\n\\n{message}'\n        raise sparla.ArpackNoConvergence(error_with_note, e.eigenvalues, e.eigenvectors)\n    if np.isnan(ev).any():\n        temp = tol - np.finfo(A.dtype).eps\n        ev = SA_eigsh(-temp)\n    return np.all(ev >= -tol)",
            "def is_psd_within_tol(A, tol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Return True if we can certify that A is PSD (up to tolerance \"tol\").\\n\\n    First we check if A is PSD according to the Gershgorin Circle Theorem.\\n\\n    If Gershgorin is inconclusive, then we use an iterative method (from ARPACK,\\n    as called through SciPy) to estimate extremal eigenvalues of certain shifted\\n    versions of A. The shifts are chosen so that the signs of those eigenvalues\\n    tell us the signs of the eigenvalues of A.\\n\\n    If there are numerical issues then it\\'s possible that this function returns\\n    False even when A is PSD. If you know that you\\'re in that situation, then\\n    you should replace A by\\n\\n        A = cvxpy.atoms.affine.wraps.psd_wrap(A).\\n\\n    Parameters\\n    ----------\\n    A : Union[np.ndarray, spar.spmatrix]\\n        Symmetric (or Hermitian) NumPy ndarray or SciPy sparse matrix.\\n\\n    tol : float\\n        Nonnegative. Something very small, like 1e-10.\\n    '\n    if gershgorin_psd_check(A, tol):\n        return True\n    if is_diagonal(A):\n        if isinstance(A, csc_matrix):\n            return np.all(A.data >= -tol)\n        else:\n            min_diag_entry = np.min(np.diag(A))\n            return min_diag_entry >= -tol\n\n    def SA_eigsh(sigma):\n        if hasattr(np.random, 'default_rng'):\n            g = np.random.default_rng(123)\n        else:\n            g = np.random.RandomState(123)\n        n = A.shape[0]\n        v0 = g.normal(loc=0.0, scale=1.0, size=n)\n        return sparla.eigsh(A, k=1, sigma=sigma, which='SA', v0=v0, return_eigenvectors=False)\n    try:\n        ev = SA_eigsh(-tol)\n    except sparla.ArpackNoConvergence as e:\n        message = \"\\n        CVXPY note: This failure was encountered while trying to certify\\n        that a matrix is positive semi-definite (see [1] for a definition).\\n        In rare cases, this method fails for numerical reasons even when the matrix is\\n        positive semi-definite. If you know that you're in that situation, you can\\n        replace the matrix A by cvxpy.psd_wrap(A).\\n\\n        [1] https://en.wikipedia.org/wiki/Definite_matrix\\n        \"\n        error_with_note = f'{str(e)}\\n\\n{message}'\n        raise sparla.ArpackNoConvergence(error_with_note, e.eigenvalues, e.eigenvectors)\n    if np.isnan(ev).any():\n        temp = tol - np.finfo(A.dtype).eps\n        ev = SA_eigsh(-temp)\n    return np.all(ev >= -tol)",
            "def is_psd_within_tol(A, tol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Return True if we can certify that A is PSD (up to tolerance \"tol\").\\n\\n    First we check if A is PSD according to the Gershgorin Circle Theorem.\\n\\n    If Gershgorin is inconclusive, then we use an iterative method (from ARPACK,\\n    as called through SciPy) to estimate extremal eigenvalues of certain shifted\\n    versions of A. The shifts are chosen so that the signs of those eigenvalues\\n    tell us the signs of the eigenvalues of A.\\n\\n    If there are numerical issues then it\\'s possible that this function returns\\n    False even when A is PSD. If you know that you\\'re in that situation, then\\n    you should replace A by\\n\\n        A = cvxpy.atoms.affine.wraps.psd_wrap(A).\\n\\n    Parameters\\n    ----------\\n    A : Union[np.ndarray, spar.spmatrix]\\n        Symmetric (or Hermitian) NumPy ndarray or SciPy sparse matrix.\\n\\n    tol : float\\n        Nonnegative. Something very small, like 1e-10.\\n    '\n    if gershgorin_psd_check(A, tol):\n        return True\n    if is_diagonal(A):\n        if isinstance(A, csc_matrix):\n            return np.all(A.data >= -tol)\n        else:\n            min_diag_entry = np.min(np.diag(A))\n            return min_diag_entry >= -tol\n\n    def SA_eigsh(sigma):\n        if hasattr(np.random, 'default_rng'):\n            g = np.random.default_rng(123)\n        else:\n            g = np.random.RandomState(123)\n        n = A.shape[0]\n        v0 = g.normal(loc=0.0, scale=1.0, size=n)\n        return sparla.eigsh(A, k=1, sigma=sigma, which='SA', v0=v0, return_eigenvectors=False)\n    try:\n        ev = SA_eigsh(-tol)\n    except sparla.ArpackNoConvergence as e:\n        message = \"\\n        CVXPY note: This failure was encountered while trying to certify\\n        that a matrix is positive semi-definite (see [1] for a definition).\\n        In rare cases, this method fails for numerical reasons even when the matrix is\\n        positive semi-definite. If you know that you're in that situation, you can\\n        replace the matrix A by cvxpy.psd_wrap(A).\\n\\n        [1] https://en.wikipedia.org/wiki/Definite_matrix\\n        \"\n        error_with_note = f'{str(e)}\\n\\n{message}'\n        raise sparla.ArpackNoConvergence(error_with_note, e.eigenvalues, e.eigenvectors)\n    if np.isnan(ev).any():\n        temp = tol - np.finfo(A.dtype).eps\n        ev = SA_eigsh(-temp)\n    return np.all(ev >= -tol)",
            "def is_psd_within_tol(A, tol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Return True if we can certify that A is PSD (up to tolerance \"tol\").\\n\\n    First we check if A is PSD according to the Gershgorin Circle Theorem.\\n\\n    If Gershgorin is inconclusive, then we use an iterative method (from ARPACK,\\n    as called through SciPy) to estimate extremal eigenvalues of certain shifted\\n    versions of A. The shifts are chosen so that the signs of those eigenvalues\\n    tell us the signs of the eigenvalues of A.\\n\\n    If there are numerical issues then it\\'s possible that this function returns\\n    False even when A is PSD. If you know that you\\'re in that situation, then\\n    you should replace A by\\n\\n        A = cvxpy.atoms.affine.wraps.psd_wrap(A).\\n\\n    Parameters\\n    ----------\\n    A : Union[np.ndarray, spar.spmatrix]\\n        Symmetric (or Hermitian) NumPy ndarray or SciPy sparse matrix.\\n\\n    tol : float\\n        Nonnegative. Something very small, like 1e-10.\\n    '\n    if gershgorin_psd_check(A, tol):\n        return True\n    if is_diagonal(A):\n        if isinstance(A, csc_matrix):\n            return np.all(A.data >= -tol)\n        else:\n            min_diag_entry = np.min(np.diag(A))\n            return min_diag_entry >= -tol\n\n    def SA_eigsh(sigma):\n        if hasattr(np.random, 'default_rng'):\n            g = np.random.default_rng(123)\n        else:\n            g = np.random.RandomState(123)\n        n = A.shape[0]\n        v0 = g.normal(loc=0.0, scale=1.0, size=n)\n        return sparla.eigsh(A, k=1, sigma=sigma, which='SA', v0=v0, return_eigenvectors=False)\n    try:\n        ev = SA_eigsh(-tol)\n    except sparla.ArpackNoConvergence as e:\n        message = \"\\n        CVXPY note: This failure was encountered while trying to certify\\n        that a matrix is positive semi-definite (see [1] for a definition).\\n        In rare cases, this method fails for numerical reasons even when the matrix is\\n        positive semi-definite. If you know that you're in that situation, you can\\n        replace the matrix A by cvxpy.psd_wrap(A).\\n\\n        [1] https://en.wikipedia.org/wiki/Definite_matrix\\n        \"\n        error_with_note = f'{str(e)}\\n\\n{message}'\n        raise sparla.ArpackNoConvergence(error_with_note, e.eigenvalues, e.eigenvectors)\n    if np.isnan(ev).any():\n        temp = tol - np.finfo(A.dtype).eps\n        ev = SA_eigsh(-temp)\n    return np.all(ev >= -tol)"
        ]
    },
    {
        "func_name": "gershgorin_psd_check",
        "original": "def gershgorin_psd_check(A, tol):\n    \"\"\"\n    Use the Gershgorin Circle Theorem\n\n        https://en.wikipedia.org/wiki/Gershgorin_circle_theorem\n\n    As a sufficient condition for A being PSD with tolerance \"tol\".\n\n    The computational complexity of this function is O(nnz(A)).\n\n    Parameters\n    ----------\n    A : Union[np.ndarray, spar.spmatrix]\n        Symmetric (or Hermitian) NumPy ndarray or SciPy sparse matrix.\n\n    tol : float\n        Nonnegative. Something very small, like 1e-10.\n\n    Returns\n    -------\n    True if A is PSD according to the Gershgorin Circle Theorem.\n    Otherwise, return False.\n    \"\"\"\n    if isinstance(A, spar.spmatrix):\n        diag = A.diagonal()\n        if np.any(diag < -tol):\n            return False\n        A_shift = A - spar.diags(diag)\n        A_shift = np.abs(A_shift)\n        radii = np.array(A_shift.sum(axis=0)).ravel()\n        return np.all(diag - radii >= -tol)\n    elif isinstance(A, np.ndarray):\n        diag = np.diag(A)\n        if np.any(diag < -tol):\n            return False\n        A_shift = A - np.diag(diag)\n        A_shift = np.abs(A_shift)\n        radii = A_shift.sum(axis=0)\n        return np.all(diag - radii >= -tol)\n    else:\n        raise ValueError()",
        "mutated": [
            "def gershgorin_psd_check(A, tol):\n    if False:\n        i = 10\n    '\\n    Use the Gershgorin Circle Theorem\\n\\n        https://en.wikipedia.org/wiki/Gershgorin_circle_theorem\\n\\n    As a sufficient condition for A being PSD with tolerance \"tol\".\\n\\n    The computational complexity of this function is O(nnz(A)).\\n\\n    Parameters\\n    ----------\\n    A : Union[np.ndarray, spar.spmatrix]\\n        Symmetric (or Hermitian) NumPy ndarray or SciPy sparse matrix.\\n\\n    tol : float\\n        Nonnegative. Something very small, like 1e-10.\\n\\n    Returns\\n    -------\\n    True if A is PSD according to the Gershgorin Circle Theorem.\\n    Otherwise, return False.\\n    '\n    if isinstance(A, spar.spmatrix):\n        diag = A.diagonal()\n        if np.any(diag < -tol):\n            return False\n        A_shift = A - spar.diags(diag)\n        A_shift = np.abs(A_shift)\n        radii = np.array(A_shift.sum(axis=0)).ravel()\n        return np.all(diag - radii >= -tol)\n    elif isinstance(A, np.ndarray):\n        diag = np.diag(A)\n        if np.any(diag < -tol):\n            return False\n        A_shift = A - np.diag(diag)\n        A_shift = np.abs(A_shift)\n        radii = A_shift.sum(axis=0)\n        return np.all(diag - radii >= -tol)\n    else:\n        raise ValueError()",
            "def gershgorin_psd_check(A, tol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Use the Gershgorin Circle Theorem\\n\\n        https://en.wikipedia.org/wiki/Gershgorin_circle_theorem\\n\\n    As a sufficient condition for A being PSD with tolerance \"tol\".\\n\\n    The computational complexity of this function is O(nnz(A)).\\n\\n    Parameters\\n    ----------\\n    A : Union[np.ndarray, spar.spmatrix]\\n        Symmetric (or Hermitian) NumPy ndarray or SciPy sparse matrix.\\n\\n    tol : float\\n        Nonnegative. Something very small, like 1e-10.\\n\\n    Returns\\n    -------\\n    True if A is PSD according to the Gershgorin Circle Theorem.\\n    Otherwise, return False.\\n    '\n    if isinstance(A, spar.spmatrix):\n        diag = A.diagonal()\n        if np.any(diag < -tol):\n            return False\n        A_shift = A - spar.diags(diag)\n        A_shift = np.abs(A_shift)\n        radii = np.array(A_shift.sum(axis=0)).ravel()\n        return np.all(diag - radii >= -tol)\n    elif isinstance(A, np.ndarray):\n        diag = np.diag(A)\n        if np.any(diag < -tol):\n            return False\n        A_shift = A - np.diag(diag)\n        A_shift = np.abs(A_shift)\n        radii = A_shift.sum(axis=0)\n        return np.all(diag - radii >= -tol)\n    else:\n        raise ValueError()",
            "def gershgorin_psd_check(A, tol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Use the Gershgorin Circle Theorem\\n\\n        https://en.wikipedia.org/wiki/Gershgorin_circle_theorem\\n\\n    As a sufficient condition for A being PSD with tolerance \"tol\".\\n\\n    The computational complexity of this function is O(nnz(A)).\\n\\n    Parameters\\n    ----------\\n    A : Union[np.ndarray, spar.spmatrix]\\n        Symmetric (or Hermitian) NumPy ndarray or SciPy sparse matrix.\\n\\n    tol : float\\n        Nonnegative. Something very small, like 1e-10.\\n\\n    Returns\\n    -------\\n    True if A is PSD according to the Gershgorin Circle Theorem.\\n    Otherwise, return False.\\n    '\n    if isinstance(A, spar.spmatrix):\n        diag = A.diagonal()\n        if np.any(diag < -tol):\n            return False\n        A_shift = A - spar.diags(diag)\n        A_shift = np.abs(A_shift)\n        radii = np.array(A_shift.sum(axis=0)).ravel()\n        return np.all(diag - radii >= -tol)\n    elif isinstance(A, np.ndarray):\n        diag = np.diag(A)\n        if np.any(diag < -tol):\n            return False\n        A_shift = A - np.diag(diag)\n        A_shift = np.abs(A_shift)\n        radii = A_shift.sum(axis=0)\n        return np.all(diag - radii >= -tol)\n    else:\n        raise ValueError()",
            "def gershgorin_psd_check(A, tol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Use the Gershgorin Circle Theorem\\n\\n        https://en.wikipedia.org/wiki/Gershgorin_circle_theorem\\n\\n    As a sufficient condition for A being PSD with tolerance \"tol\".\\n\\n    The computational complexity of this function is O(nnz(A)).\\n\\n    Parameters\\n    ----------\\n    A : Union[np.ndarray, spar.spmatrix]\\n        Symmetric (or Hermitian) NumPy ndarray or SciPy sparse matrix.\\n\\n    tol : float\\n        Nonnegative. Something very small, like 1e-10.\\n\\n    Returns\\n    -------\\n    True if A is PSD according to the Gershgorin Circle Theorem.\\n    Otherwise, return False.\\n    '\n    if isinstance(A, spar.spmatrix):\n        diag = A.diagonal()\n        if np.any(diag < -tol):\n            return False\n        A_shift = A - spar.diags(diag)\n        A_shift = np.abs(A_shift)\n        radii = np.array(A_shift.sum(axis=0)).ravel()\n        return np.all(diag - radii >= -tol)\n    elif isinstance(A, np.ndarray):\n        diag = np.diag(A)\n        if np.any(diag < -tol):\n            return False\n        A_shift = A - np.diag(diag)\n        A_shift = np.abs(A_shift)\n        radii = A_shift.sum(axis=0)\n        return np.all(diag - radii >= -tol)\n    else:\n        raise ValueError()",
            "def gershgorin_psd_check(A, tol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Use the Gershgorin Circle Theorem\\n\\n        https://en.wikipedia.org/wiki/Gershgorin_circle_theorem\\n\\n    As a sufficient condition for A being PSD with tolerance \"tol\".\\n\\n    The computational complexity of this function is O(nnz(A)).\\n\\n    Parameters\\n    ----------\\n    A : Union[np.ndarray, spar.spmatrix]\\n        Symmetric (or Hermitian) NumPy ndarray or SciPy sparse matrix.\\n\\n    tol : float\\n        Nonnegative. Something very small, like 1e-10.\\n\\n    Returns\\n    -------\\n    True if A is PSD according to the Gershgorin Circle Theorem.\\n    Otherwise, return False.\\n    '\n    if isinstance(A, spar.spmatrix):\n        diag = A.diagonal()\n        if np.any(diag < -tol):\n            return False\n        A_shift = A - spar.diags(diag)\n        A_shift = np.abs(A_shift)\n        radii = np.array(A_shift.sum(axis=0)).ravel()\n        return np.all(diag - radii >= -tol)\n    elif isinstance(A, np.ndarray):\n        diag = np.diag(A)\n        if np.any(diag < -tol):\n            return False\n        A_shift = A - np.diag(diag)\n        A_shift = np.abs(A_shift)\n        radii = A_shift.sum(axis=0)\n        return np.all(diag - radii >= -tol)\n    else:\n        raise ValueError()"
        ]
    },
    {
        "func_name": "sparse_cholesky",
        "original": "def sparse_cholesky(A, sym_tol=settings.CHOL_SYM_TOL, assume_posdef=False):\n    \"\"\"\n    The input matrix A must be real and symmetric. If A is positive definite then\n    Eigen will be used to compute its sparse Cholesky decomposition with AMD-ordering.\n    If A is negative definite, then the analogous operation will be applied to -A.\n\n    If Cholesky succeeds, then we return a lower-triangular matrix L in\n    CSR-format and a permutation vector p so (L[p, :]) @ (L[p, :]).T == A\n    within numerical precision.\n\n    We raise a ValueError if Eigen's Cholesky fails or if we certify indefiniteness\n    before calling Eigen. While checking for indefiniteness, we also check that\n     ||A - A'||_Fro / sqrt(n) <= sym_tol, where n is the order of the matrix.\n    \"\"\"\n    if not isinstance(A, spar.spmatrix):\n        raise ValueError(SparseCholeskyMessages.NOT_SPARSE)\n    if np.iscomplexobj(A):\n        raise ValueError(SparseCholeskyMessages.NOT_REAL)\n    if not assume_posdef:\n        symdiff = A - A.T\n        sz = symdiff.data.size\n        if sz > 0 and la.norm(symdiff.data) > sym_tol * sz ** 0.5:\n            raise ValueError(SparseCholeskyMessages.ASYMMETRIC)\n        d = A.diagonal()\n        maybe_posdef = np.all(d > 0)\n        maybe_negdef = np.all(d < 0)\n        if not (maybe_posdef or maybe_negdef):\n            raise ValueError(SparseCholeskyMessages.INDEFINITE)\n        if maybe_negdef:\n            (_, L, p) = sparse_cholesky(-A, sym_tol, assume_posdef=True)\n            return (-1.0, L, p)\n    A_coo = spar.coo_matrix(A)\n    n = A.shape[0]\n    inrows = spchol.IntVector(A_coo.row)\n    incols = spchol.IntVector(A_coo.col)\n    invals = spchol.DoubleVector(A_coo.data)\n    outpivs = spchol.IntVector()\n    outrows = spchol.IntVector()\n    outcols = spchol.IntVector()\n    outvals = spchol.DoubleVector()\n    try:\n        spchol.sparse_chol_from_vecs(n, inrows, incols, invals, outpivs, outrows, outcols, outvals)\n    except RuntimeError as e:\n        if e.args[0] == SparseCholeskyMessages.EIGEN_FAIL:\n            raise ValueError(e.args)\n        else:\n            raise RuntimeError(e.args)\n    outvals = np.array(outvals)\n    outrows = np.array(outrows)\n    outcols = np.array(outcols)\n    outpivs = np.array(outpivs)\n    L = spar.csr_matrix((outvals, (outrows, outcols)), shape=(n, n))\n    return (1.0, L, outpivs)",
        "mutated": [
            "def sparse_cholesky(A, sym_tol=settings.CHOL_SYM_TOL, assume_posdef=False):\n    if False:\n        i = 10\n    \"\\n    The input matrix A must be real and symmetric. If A is positive definite then\\n    Eigen will be used to compute its sparse Cholesky decomposition with AMD-ordering.\\n    If A is negative definite, then the analogous operation will be applied to -A.\\n\\n    If Cholesky succeeds, then we return a lower-triangular matrix L in\\n    CSR-format and a permutation vector p so (L[p, :]) @ (L[p, :]).T == A\\n    within numerical precision.\\n\\n    We raise a ValueError if Eigen's Cholesky fails or if we certify indefiniteness\\n    before calling Eigen. While checking for indefiniteness, we also check that\\n     ||A - A'||_Fro / sqrt(n) <= sym_tol, where n is the order of the matrix.\\n    \"\n    if not isinstance(A, spar.spmatrix):\n        raise ValueError(SparseCholeskyMessages.NOT_SPARSE)\n    if np.iscomplexobj(A):\n        raise ValueError(SparseCholeskyMessages.NOT_REAL)\n    if not assume_posdef:\n        symdiff = A - A.T\n        sz = symdiff.data.size\n        if sz > 0 and la.norm(symdiff.data) > sym_tol * sz ** 0.5:\n            raise ValueError(SparseCholeskyMessages.ASYMMETRIC)\n        d = A.diagonal()\n        maybe_posdef = np.all(d > 0)\n        maybe_negdef = np.all(d < 0)\n        if not (maybe_posdef or maybe_negdef):\n            raise ValueError(SparseCholeskyMessages.INDEFINITE)\n        if maybe_negdef:\n            (_, L, p) = sparse_cholesky(-A, sym_tol, assume_posdef=True)\n            return (-1.0, L, p)\n    A_coo = spar.coo_matrix(A)\n    n = A.shape[0]\n    inrows = spchol.IntVector(A_coo.row)\n    incols = spchol.IntVector(A_coo.col)\n    invals = spchol.DoubleVector(A_coo.data)\n    outpivs = spchol.IntVector()\n    outrows = spchol.IntVector()\n    outcols = spchol.IntVector()\n    outvals = spchol.DoubleVector()\n    try:\n        spchol.sparse_chol_from_vecs(n, inrows, incols, invals, outpivs, outrows, outcols, outvals)\n    except RuntimeError as e:\n        if e.args[0] == SparseCholeskyMessages.EIGEN_FAIL:\n            raise ValueError(e.args)\n        else:\n            raise RuntimeError(e.args)\n    outvals = np.array(outvals)\n    outrows = np.array(outrows)\n    outcols = np.array(outcols)\n    outpivs = np.array(outpivs)\n    L = spar.csr_matrix((outvals, (outrows, outcols)), shape=(n, n))\n    return (1.0, L, outpivs)",
            "def sparse_cholesky(A, sym_tol=settings.CHOL_SYM_TOL, assume_posdef=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    The input matrix A must be real and symmetric. If A is positive definite then\\n    Eigen will be used to compute its sparse Cholesky decomposition with AMD-ordering.\\n    If A is negative definite, then the analogous operation will be applied to -A.\\n\\n    If Cholesky succeeds, then we return a lower-triangular matrix L in\\n    CSR-format and a permutation vector p so (L[p, :]) @ (L[p, :]).T == A\\n    within numerical precision.\\n\\n    We raise a ValueError if Eigen's Cholesky fails or if we certify indefiniteness\\n    before calling Eigen. While checking for indefiniteness, we also check that\\n     ||A - A'||_Fro / sqrt(n) <= sym_tol, where n is the order of the matrix.\\n    \"\n    if not isinstance(A, spar.spmatrix):\n        raise ValueError(SparseCholeskyMessages.NOT_SPARSE)\n    if np.iscomplexobj(A):\n        raise ValueError(SparseCholeskyMessages.NOT_REAL)\n    if not assume_posdef:\n        symdiff = A - A.T\n        sz = symdiff.data.size\n        if sz > 0 and la.norm(symdiff.data) > sym_tol * sz ** 0.5:\n            raise ValueError(SparseCholeskyMessages.ASYMMETRIC)\n        d = A.diagonal()\n        maybe_posdef = np.all(d > 0)\n        maybe_negdef = np.all(d < 0)\n        if not (maybe_posdef or maybe_negdef):\n            raise ValueError(SparseCholeskyMessages.INDEFINITE)\n        if maybe_negdef:\n            (_, L, p) = sparse_cholesky(-A, sym_tol, assume_posdef=True)\n            return (-1.0, L, p)\n    A_coo = spar.coo_matrix(A)\n    n = A.shape[0]\n    inrows = spchol.IntVector(A_coo.row)\n    incols = spchol.IntVector(A_coo.col)\n    invals = spchol.DoubleVector(A_coo.data)\n    outpivs = spchol.IntVector()\n    outrows = spchol.IntVector()\n    outcols = spchol.IntVector()\n    outvals = spchol.DoubleVector()\n    try:\n        spchol.sparse_chol_from_vecs(n, inrows, incols, invals, outpivs, outrows, outcols, outvals)\n    except RuntimeError as e:\n        if e.args[0] == SparseCholeskyMessages.EIGEN_FAIL:\n            raise ValueError(e.args)\n        else:\n            raise RuntimeError(e.args)\n    outvals = np.array(outvals)\n    outrows = np.array(outrows)\n    outcols = np.array(outcols)\n    outpivs = np.array(outpivs)\n    L = spar.csr_matrix((outvals, (outrows, outcols)), shape=(n, n))\n    return (1.0, L, outpivs)",
            "def sparse_cholesky(A, sym_tol=settings.CHOL_SYM_TOL, assume_posdef=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    The input matrix A must be real and symmetric. If A is positive definite then\\n    Eigen will be used to compute its sparse Cholesky decomposition with AMD-ordering.\\n    If A is negative definite, then the analogous operation will be applied to -A.\\n\\n    If Cholesky succeeds, then we return a lower-triangular matrix L in\\n    CSR-format and a permutation vector p so (L[p, :]) @ (L[p, :]).T == A\\n    within numerical precision.\\n\\n    We raise a ValueError if Eigen's Cholesky fails or if we certify indefiniteness\\n    before calling Eigen. While checking for indefiniteness, we also check that\\n     ||A - A'||_Fro / sqrt(n) <= sym_tol, where n is the order of the matrix.\\n    \"\n    if not isinstance(A, spar.spmatrix):\n        raise ValueError(SparseCholeskyMessages.NOT_SPARSE)\n    if np.iscomplexobj(A):\n        raise ValueError(SparseCholeskyMessages.NOT_REAL)\n    if not assume_posdef:\n        symdiff = A - A.T\n        sz = symdiff.data.size\n        if sz > 0 and la.norm(symdiff.data) > sym_tol * sz ** 0.5:\n            raise ValueError(SparseCholeskyMessages.ASYMMETRIC)\n        d = A.diagonal()\n        maybe_posdef = np.all(d > 0)\n        maybe_negdef = np.all(d < 0)\n        if not (maybe_posdef or maybe_negdef):\n            raise ValueError(SparseCholeskyMessages.INDEFINITE)\n        if maybe_negdef:\n            (_, L, p) = sparse_cholesky(-A, sym_tol, assume_posdef=True)\n            return (-1.0, L, p)\n    A_coo = spar.coo_matrix(A)\n    n = A.shape[0]\n    inrows = spchol.IntVector(A_coo.row)\n    incols = spchol.IntVector(A_coo.col)\n    invals = spchol.DoubleVector(A_coo.data)\n    outpivs = spchol.IntVector()\n    outrows = spchol.IntVector()\n    outcols = spchol.IntVector()\n    outvals = spchol.DoubleVector()\n    try:\n        spchol.sparse_chol_from_vecs(n, inrows, incols, invals, outpivs, outrows, outcols, outvals)\n    except RuntimeError as e:\n        if e.args[0] == SparseCholeskyMessages.EIGEN_FAIL:\n            raise ValueError(e.args)\n        else:\n            raise RuntimeError(e.args)\n    outvals = np.array(outvals)\n    outrows = np.array(outrows)\n    outcols = np.array(outcols)\n    outpivs = np.array(outpivs)\n    L = spar.csr_matrix((outvals, (outrows, outcols)), shape=(n, n))\n    return (1.0, L, outpivs)",
            "def sparse_cholesky(A, sym_tol=settings.CHOL_SYM_TOL, assume_posdef=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    The input matrix A must be real and symmetric. If A is positive definite then\\n    Eigen will be used to compute its sparse Cholesky decomposition with AMD-ordering.\\n    If A is negative definite, then the analogous operation will be applied to -A.\\n\\n    If Cholesky succeeds, then we return a lower-triangular matrix L in\\n    CSR-format and a permutation vector p so (L[p, :]) @ (L[p, :]).T == A\\n    within numerical precision.\\n\\n    We raise a ValueError if Eigen's Cholesky fails or if we certify indefiniteness\\n    before calling Eigen. While checking for indefiniteness, we also check that\\n     ||A - A'||_Fro / sqrt(n) <= sym_tol, where n is the order of the matrix.\\n    \"\n    if not isinstance(A, spar.spmatrix):\n        raise ValueError(SparseCholeskyMessages.NOT_SPARSE)\n    if np.iscomplexobj(A):\n        raise ValueError(SparseCholeskyMessages.NOT_REAL)\n    if not assume_posdef:\n        symdiff = A - A.T\n        sz = symdiff.data.size\n        if sz > 0 and la.norm(symdiff.data) > sym_tol * sz ** 0.5:\n            raise ValueError(SparseCholeskyMessages.ASYMMETRIC)\n        d = A.diagonal()\n        maybe_posdef = np.all(d > 0)\n        maybe_negdef = np.all(d < 0)\n        if not (maybe_posdef or maybe_negdef):\n            raise ValueError(SparseCholeskyMessages.INDEFINITE)\n        if maybe_negdef:\n            (_, L, p) = sparse_cholesky(-A, sym_tol, assume_posdef=True)\n            return (-1.0, L, p)\n    A_coo = spar.coo_matrix(A)\n    n = A.shape[0]\n    inrows = spchol.IntVector(A_coo.row)\n    incols = spchol.IntVector(A_coo.col)\n    invals = spchol.DoubleVector(A_coo.data)\n    outpivs = spchol.IntVector()\n    outrows = spchol.IntVector()\n    outcols = spchol.IntVector()\n    outvals = spchol.DoubleVector()\n    try:\n        spchol.sparse_chol_from_vecs(n, inrows, incols, invals, outpivs, outrows, outcols, outvals)\n    except RuntimeError as e:\n        if e.args[0] == SparseCholeskyMessages.EIGEN_FAIL:\n            raise ValueError(e.args)\n        else:\n            raise RuntimeError(e.args)\n    outvals = np.array(outvals)\n    outrows = np.array(outrows)\n    outcols = np.array(outcols)\n    outpivs = np.array(outpivs)\n    L = spar.csr_matrix((outvals, (outrows, outcols)), shape=(n, n))\n    return (1.0, L, outpivs)",
            "def sparse_cholesky(A, sym_tol=settings.CHOL_SYM_TOL, assume_posdef=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    The input matrix A must be real and symmetric. If A is positive definite then\\n    Eigen will be used to compute its sparse Cholesky decomposition with AMD-ordering.\\n    If A is negative definite, then the analogous operation will be applied to -A.\\n\\n    If Cholesky succeeds, then we return a lower-triangular matrix L in\\n    CSR-format and a permutation vector p so (L[p, :]) @ (L[p, :]).T == A\\n    within numerical precision.\\n\\n    We raise a ValueError if Eigen's Cholesky fails or if we certify indefiniteness\\n    before calling Eigen. While checking for indefiniteness, we also check that\\n     ||A - A'||_Fro / sqrt(n) <= sym_tol, where n is the order of the matrix.\\n    \"\n    if not isinstance(A, spar.spmatrix):\n        raise ValueError(SparseCholeskyMessages.NOT_SPARSE)\n    if np.iscomplexobj(A):\n        raise ValueError(SparseCholeskyMessages.NOT_REAL)\n    if not assume_posdef:\n        symdiff = A - A.T\n        sz = symdiff.data.size\n        if sz > 0 and la.norm(symdiff.data) > sym_tol * sz ** 0.5:\n            raise ValueError(SparseCholeskyMessages.ASYMMETRIC)\n        d = A.diagonal()\n        maybe_posdef = np.all(d > 0)\n        maybe_negdef = np.all(d < 0)\n        if not (maybe_posdef or maybe_negdef):\n            raise ValueError(SparseCholeskyMessages.INDEFINITE)\n        if maybe_negdef:\n            (_, L, p) = sparse_cholesky(-A, sym_tol, assume_posdef=True)\n            return (-1.0, L, p)\n    A_coo = spar.coo_matrix(A)\n    n = A.shape[0]\n    inrows = spchol.IntVector(A_coo.row)\n    incols = spchol.IntVector(A_coo.col)\n    invals = spchol.DoubleVector(A_coo.data)\n    outpivs = spchol.IntVector()\n    outrows = spchol.IntVector()\n    outcols = spchol.IntVector()\n    outvals = spchol.DoubleVector()\n    try:\n        spchol.sparse_chol_from_vecs(n, inrows, incols, invals, outpivs, outrows, outcols, outvals)\n    except RuntimeError as e:\n        if e.args[0] == SparseCholeskyMessages.EIGEN_FAIL:\n            raise ValueError(e.args)\n        else:\n            raise RuntimeError(e.args)\n    outvals = np.array(outvals)\n    outrows = np.array(outrows)\n    outcols = np.array(outcols)\n    outpivs = np.array(outpivs)\n    L = spar.csr_matrix((outvals, (outrows, outcols)), shape=(n, n))\n    return (1.0, L, outpivs)"
        ]
    }
]