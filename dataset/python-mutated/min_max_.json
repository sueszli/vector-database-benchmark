[
    {
        "func_name": "sliding_min_max",
        "original": "@numba.jit(nopython=True, nogil=True, parallel=False)\ndef sliding_min_max(values: np.ndarray, result_dtype: np.dtype, start: np.ndarray, end: np.ndarray, min_periods: int, is_max: bool) -> tuple[np.ndarray, list[int]]:\n    N = len(start)\n    nobs = 0\n    output = np.empty(N, dtype=result_dtype)\n    na_pos = []\n    Q: list = []\n    W: list = []\n    for i in range(N):\n        curr_win_size = end[i] - start[i]\n        if i == 0:\n            st = start[i]\n        else:\n            st = end[i - 1]\n        for k in range(st, end[i]):\n            ai = values[k]\n            if not np.isnan(ai):\n                nobs += 1\n            elif is_max:\n                ai = -np.inf\n            else:\n                ai = np.inf\n            if is_max:\n                while Q and (ai >= values[Q[-1]] or values[Q[-1]] != values[Q[-1]]):\n                    Q.pop()\n            else:\n                while Q and (ai <= values[Q[-1]] or values[Q[-1]] != values[Q[-1]]):\n                    Q.pop()\n            Q.append(k)\n            W.append(k)\n        while Q and Q[0] <= start[i] - 1:\n            Q.pop(0)\n        while W and W[0] <= start[i] - 1:\n            if not np.isnan(values[W[0]]):\n                nobs -= 1\n            W.pop(0)\n        if Q and curr_win_size > 0 and (nobs >= min_periods):\n            output[i] = values[Q[0]]\n        elif values.dtype.kind != 'i':\n            output[i] = np.nan\n        else:\n            na_pos.append(i)\n    return (output, na_pos)",
        "mutated": [
            "@numba.jit(nopython=True, nogil=True, parallel=False)\ndef sliding_min_max(values: np.ndarray, result_dtype: np.dtype, start: np.ndarray, end: np.ndarray, min_periods: int, is_max: bool) -> tuple[np.ndarray, list[int]]:\n    if False:\n        i = 10\n    N = len(start)\n    nobs = 0\n    output = np.empty(N, dtype=result_dtype)\n    na_pos = []\n    Q: list = []\n    W: list = []\n    for i in range(N):\n        curr_win_size = end[i] - start[i]\n        if i == 0:\n            st = start[i]\n        else:\n            st = end[i - 1]\n        for k in range(st, end[i]):\n            ai = values[k]\n            if not np.isnan(ai):\n                nobs += 1\n            elif is_max:\n                ai = -np.inf\n            else:\n                ai = np.inf\n            if is_max:\n                while Q and (ai >= values[Q[-1]] or values[Q[-1]] != values[Q[-1]]):\n                    Q.pop()\n            else:\n                while Q and (ai <= values[Q[-1]] or values[Q[-1]] != values[Q[-1]]):\n                    Q.pop()\n            Q.append(k)\n            W.append(k)\n        while Q and Q[0] <= start[i] - 1:\n            Q.pop(0)\n        while W and W[0] <= start[i] - 1:\n            if not np.isnan(values[W[0]]):\n                nobs -= 1\n            W.pop(0)\n        if Q and curr_win_size > 0 and (nobs >= min_periods):\n            output[i] = values[Q[0]]\n        elif values.dtype.kind != 'i':\n            output[i] = np.nan\n        else:\n            na_pos.append(i)\n    return (output, na_pos)",
            "@numba.jit(nopython=True, nogil=True, parallel=False)\ndef sliding_min_max(values: np.ndarray, result_dtype: np.dtype, start: np.ndarray, end: np.ndarray, min_periods: int, is_max: bool) -> tuple[np.ndarray, list[int]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    N = len(start)\n    nobs = 0\n    output = np.empty(N, dtype=result_dtype)\n    na_pos = []\n    Q: list = []\n    W: list = []\n    for i in range(N):\n        curr_win_size = end[i] - start[i]\n        if i == 0:\n            st = start[i]\n        else:\n            st = end[i - 1]\n        for k in range(st, end[i]):\n            ai = values[k]\n            if not np.isnan(ai):\n                nobs += 1\n            elif is_max:\n                ai = -np.inf\n            else:\n                ai = np.inf\n            if is_max:\n                while Q and (ai >= values[Q[-1]] or values[Q[-1]] != values[Q[-1]]):\n                    Q.pop()\n            else:\n                while Q and (ai <= values[Q[-1]] or values[Q[-1]] != values[Q[-1]]):\n                    Q.pop()\n            Q.append(k)\n            W.append(k)\n        while Q and Q[0] <= start[i] - 1:\n            Q.pop(0)\n        while W and W[0] <= start[i] - 1:\n            if not np.isnan(values[W[0]]):\n                nobs -= 1\n            W.pop(0)\n        if Q and curr_win_size > 0 and (nobs >= min_periods):\n            output[i] = values[Q[0]]\n        elif values.dtype.kind != 'i':\n            output[i] = np.nan\n        else:\n            na_pos.append(i)\n    return (output, na_pos)",
            "@numba.jit(nopython=True, nogil=True, parallel=False)\ndef sliding_min_max(values: np.ndarray, result_dtype: np.dtype, start: np.ndarray, end: np.ndarray, min_periods: int, is_max: bool) -> tuple[np.ndarray, list[int]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    N = len(start)\n    nobs = 0\n    output = np.empty(N, dtype=result_dtype)\n    na_pos = []\n    Q: list = []\n    W: list = []\n    for i in range(N):\n        curr_win_size = end[i] - start[i]\n        if i == 0:\n            st = start[i]\n        else:\n            st = end[i - 1]\n        for k in range(st, end[i]):\n            ai = values[k]\n            if not np.isnan(ai):\n                nobs += 1\n            elif is_max:\n                ai = -np.inf\n            else:\n                ai = np.inf\n            if is_max:\n                while Q and (ai >= values[Q[-1]] or values[Q[-1]] != values[Q[-1]]):\n                    Q.pop()\n            else:\n                while Q and (ai <= values[Q[-1]] or values[Q[-1]] != values[Q[-1]]):\n                    Q.pop()\n            Q.append(k)\n            W.append(k)\n        while Q and Q[0] <= start[i] - 1:\n            Q.pop(0)\n        while W and W[0] <= start[i] - 1:\n            if not np.isnan(values[W[0]]):\n                nobs -= 1\n            W.pop(0)\n        if Q and curr_win_size > 0 and (nobs >= min_periods):\n            output[i] = values[Q[0]]\n        elif values.dtype.kind != 'i':\n            output[i] = np.nan\n        else:\n            na_pos.append(i)\n    return (output, na_pos)",
            "@numba.jit(nopython=True, nogil=True, parallel=False)\ndef sliding_min_max(values: np.ndarray, result_dtype: np.dtype, start: np.ndarray, end: np.ndarray, min_periods: int, is_max: bool) -> tuple[np.ndarray, list[int]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    N = len(start)\n    nobs = 0\n    output = np.empty(N, dtype=result_dtype)\n    na_pos = []\n    Q: list = []\n    W: list = []\n    for i in range(N):\n        curr_win_size = end[i] - start[i]\n        if i == 0:\n            st = start[i]\n        else:\n            st = end[i - 1]\n        for k in range(st, end[i]):\n            ai = values[k]\n            if not np.isnan(ai):\n                nobs += 1\n            elif is_max:\n                ai = -np.inf\n            else:\n                ai = np.inf\n            if is_max:\n                while Q and (ai >= values[Q[-1]] or values[Q[-1]] != values[Q[-1]]):\n                    Q.pop()\n            else:\n                while Q and (ai <= values[Q[-1]] or values[Q[-1]] != values[Q[-1]]):\n                    Q.pop()\n            Q.append(k)\n            W.append(k)\n        while Q and Q[0] <= start[i] - 1:\n            Q.pop(0)\n        while W and W[0] <= start[i] - 1:\n            if not np.isnan(values[W[0]]):\n                nobs -= 1\n            W.pop(0)\n        if Q and curr_win_size > 0 and (nobs >= min_periods):\n            output[i] = values[Q[0]]\n        elif values.dtype.kind != 'i':\n            output[i] = np.nan\n        else:\n            na_pos.append(i)\n    return (output, na_pos)",
            "@numba.jit(nopython=True, nogil=True, parallel=False)\ndef sliding_min_max(values: np.ndarray, result_dtype: np.dtype, start: np.ndarray, end: np.ndarray, min_periods: int, is_max: bool) -> tuple[np.ndarray, list[int]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    N = len(start)\n    nobs = 0\n    output = np.empty(N, dtype=result_dtype)\n    na_pos = []\n    Q: list = []\n    W: list = []\n    for i in range(N):\n        curr_win_size = end[i] - start[i]\n        if i == 0:\n            st = start[i]\n        else:\n            st = end[i - 1]\n        for k in range(st, end[i]):\n            ai = values[k]\n            if not np.isnan(ai):\n                nobs += 1\n            elif is_max:\n                ai = -np.inf\n            else:\n                ai = np.inf\n            if is_max:\n                while Q and (ai >= values[Q[-1]] or values[Q[-1]] != values[Q[-1]]):\n                    Q.pop()\n            else:\n                while Q and (ai <= values[Q[-1]] or values[Q[-1]] != values[Q[-1]]):\n                    Q.pop()\n            Q.append(k)\n            W.append(k)\n        while Q and Q[0] <= start[i] - 1:\n            Q.pop(0)\n        while W and W[0] <= start[i] - 1:\n            if not np.isnan(values[W[0]]):\n                nobs -= 1\n            W.pop(0)\n        if Q and curr_win_size > 0 and (nobs >= min_periods):\n            output[i] = values[Q[0]]\n        elif values.dtype.kind != 'i':\n            output[i] = np.nan\n        else:\n            na_pos.append(i)\n    return (output, na_pos)"
        ]
    },
    {
        "func_name": "grouped_min_max",
        "original": "@numba.jit(nopython=True, nogil=True, parallel=False)\ndef grouped_min_max(values: np.ndarray, result_dtype: np.dtype, labels: npt.NDArray[np.intp], ngroups: int, min_periods: int, is_max: bool) -> tuple[np.ndarray, list[int]]:\n    N = len(labels)\n    nobs = np.zeros(ngroups, dtype=np.int64)\n    na_pos = []\n    output = np.empty(ngroups, dtype=result_dtype)\n    for i in range(N):\n        lab = labels[i]\n        val = values[i]\n        if lab < 0:\n            continue\n        if values.dtype.kind == 'i' or not np.isnan(val):\n            nobs[lab] += 1\n        else:\n            continue\n        if nobs[lab] == 1:\n            output[lab] = val\n            continue\n        if is_max:\n            if val > output[lab]:\n                output[lab] = val\n        elif val < output[lab]:\n            output[lab] = val\n    for (lab, count) in enumerate(nobs):\n        if count < min_periods:\n            na_pos.append(lab)\n    return (output, na_pos)",
        "mutated": [
            "@numba.jit(nopython=True, nogil=True, parallel=False)\ndef grouped_min_max(values: np.ndarray, result_dtype: np.dtype, labels: npt.NDArray[np.intp], ngroups: int, min_periods: int, is_max: bool) -> tuple[np.ndarray, list[int]]:\n    if False:\n        i = 10\n    N = len(labels)\n    nobs = np.zeros(ngroups, dtype=np.int64)\n    na_pos = []\n    output = np.empty(ngroups, dtype=result_dtype)\n    for i in range(N):\n        lab = labels[i]\n        val = values[i]\n        if lab < 0:\n            continue\n        if values.dtype.kind == 'i' or not np.isnan(val):\n            nobs[lab] += 1\n        else:\n            continue\n        if nobs[lab] == 1:\n            output[lab] = val\n            continue\n        if is_max:\n            if val > output[lab]:\n                output[lab] = val\n        elif val < output[lab]:\n            output[lab] = val\n    for (lab, count) in enumerate(nobs):\n        if count < min_periods:\n            na_pos.append(lab)\n    return (output, na_pos)",
            "@numba.jit(nopython=True, nogil=True, parallel=False)\ndef grouped_min_max(values: np.ndarray, result_dtype: np.dtype, labels: npt.NDArray[np.intp], ngroups: int, min_periods: int, is_max: bool) -> tuple[np.ndarray, list[int]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    N = len(labels)\n    nobs = np.zeros(ngroups, dtype=np.int64)\n    na_pos = []\n    output = np.empty(ngroups, dtype=result_dtype)\n    for i in range(N):\n        lab = labels[i]\n        val = values[i]\n        if lab < 0:\n            continue\n        if values.dtype.kind == 'i' or not np.isnan(val):\n            nobs[lab] += 1\n        else:\n            continue\n        if nobs[lab] == 1:\n            output[lab] = val\n            continue\n        if is_max:\n            if val > output[lab]:\n                output[lab] = val\n        elif val < output[lab]:\n            output[lab] = val\n    for (lab, count) in enumerate(nobs):\n        if count < min_periods:\n            na_pos.append(lab)\n    return (output, na_pos)",
            "@numba.jit(nopython=True, nogil=True, parallel=False)\ndef grouped_min_max(values: np.ndarray, result_dtype: np.dtype, labels: npt.NDArray[np.intp], ngroups: int, min_periods: int, is_max: bool) -> tuple[np.ndarray, list[int]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    N = len(labels)\n    nobs = np.zeros(ngroups, dtype=np.int64)\n    na_pos = []\n    output = np.empty(ngroups, dtype=result_dtype)\n    for i in range(N):\n        lab = labels[i]\n        val = values[i]\n        if lab < 0:\n            continue\n        if values.dtype.kind == 'i' or not np.isnan(val):\n            nobs[lab] += 1\n        else:\n            continue\n        if nobs[lab] == 1:\n            output[lab] = val\n            continue\n        if is_max:\n            if val > output[lab]:\n                output[lab] = val\n        elif val < output[lab]:\n            output[lab] = val\n    for (lab, count) in enumerate(nobs):\n        if count < min_periods:\n            na_pos.append(lab)\n    return (output, na_pos)",
            "@numba.jit(nopython=True, nogil=True, parallel=False)\ndef grouped_min_max(values: np.ndarray, result_dtype: np.dtype, labels: npt.NDArray[np.intp], ngroups: int, min_periods: int, is_max: bool) -> tuple[np.ndarray, list[int]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    N = len(labels)\n    nobs = np.zeros(ngroups, dtype=np.int64)\n    na_pos = []\n    output = np.empty(ngroups, dtype=result_dtype)\n    for i in range(N):\n        lab = labels[i]\n        val = values[i]\n        if lab < 0:\n            continue\n        if values.dtype.kind == 'i' or not np.isnan(val):\n            nobs[lab] += 1\n        else:\n            continue\n        if nobs[lab] == 1:\n            output[lab] = val\n            continue\n        if is_max:\n            if val > output[lab]:\n                output[lab] = val\n        elif val < output[lab]:\n            output[lab] = val\n    for (lab, count) in enumerate(nobs):\n        if count < min_periods:\n            na_pos.append(lab)\n    return (output, na_pos)",
            "@numba.jit(nopython=True, nogil=True, parallel=False)\ndef grouped_min_max(values: np.ndarray, result_dtype: np.dtype, labels: npt.NDArray[np.intp], ngroups: int, min_periods: int, is_max: bool) -> tuple[np.ndarray, list[int]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    N = len(labels)\n    nobs = np.zeros(ngroups, dtype=np.int64)\n    na_pos = []\n    output = np.empty(ngroups, dtype=result_dtype)\n    for i in range(N):\n        lab = labels[i]\n        val = values[i]\n        if lab < 0:\n            continue\n        if values.dtype.kind == 'i' or not np.isnan(val):\n            nobs[lab] += 1\n        else:\n            continue\n        if nobs[lab] == 1:\n            output[lab] = val\n            continue\n        if is_max:\n            if val > output[lab]:\n                output[lab] = val\n        elif val < output[lab]:\n            output[lab] = val\n    for (lab, count) in enumerate(nobs):\n        if count < min_periods:\n            na_pos.append(lab)\n    return (output, na_pos)"
        ]
    }
]