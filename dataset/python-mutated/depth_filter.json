[
    {
        "func_name": "read_camera_parameters",
        "original": "def read_camera_parameters(filename):\n    with open(filename) as f:\n        lines = f.readlines()\n        lines = [line.rstrip() for line in lines]\n    extrinsics = np.fromstring(' '.join(lines[1:5]), dtype=np.float32, sep=' ').reshape((4, 4))\n    intrinsics = np.fromstring(' '.join(lines[7:10]), dtype=np.float32, sep=' ').reshape((3, 3))\n    return (intrinsics, extrinsics)",
        "mutated": [
            "def read_camera_parameters(filename):\n    if False:\n        i = 10\n    with open(filename) as f:\n        lines = f.readlines()\n        lines = [line.rstrip() for line in lines]\n    extrinsics = np.fromstring(' '.join(lines[1:5]), dtype=np.float32, sep=' ').reshape((4, 4))\n    intrinsics = np.fromstring(' '.join(lines[7:10]), dtype=np.float32, sep=' ').reshape((3, 3))\n    return (intrinsics, extrinsics)",
            "def read_camera_parameters(filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    with open(filename) as f:\n        lines = f.readlines()\n        lines = [line.rstrip() for line in lines]\n    extrinsics = np.fromstring(' '.join(lines[1:5]), dtype=np.float32, sep=' ').reshape((4, 4))\n    intrinsics = np.fromstring(' '.join(lines[7:10]), dtype=np.float32, sep=' ').reshape((3, 3))\n    return (intrinsics, extrinsics)",
            "def read_camera_parameters(filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    with open(filename) as f:\n        lines = f.readlines()\n        lines = [line.rstrip() for line in lines]\n    extrinsics = np.fromstring(' '.join(lines[1:5]), dtype=np.float32, sep=' ').reshape((4, 4))\n    intrinsics = np.fromstring(' '.join(lines[7:10]), dtype=np.float32, sep=' ').reshape((3, 3))\n    return (intrinsics, extrinsics)",
            "def read_camera_parameters(filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    with open(filename) as f:\n        lines = f.readlines()\n        lines = [line.rstrip() for line in lines]\n    extrinsics = np.fromstring(' '.join(lines[1:5]), dtype=np.float32, sep=' ').reshape((4, 4))\n    intrinsics = np.fromstring(' '.join(lines[7:10]), dtype=np.float32, sep=' ').reshape((3, 3))\n    return (intrinsics, extrinsics)",
            "def read_camera_parameters(filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    with open(filename) as f:\n        lines = f.readlines()\n        lines = [line.rstrip() for line in lines]\n    extrinsics = np.fromstring(' '.join(lines[1:5]), dtype=np.float32, sep=' ').reshape((4, 4))\n    intrinsics = np.fromstring(' '.join(lines[7:10]), dtype=np.float32, sep=' ').reshape((3, 3))\n    return (intrinsics, extrinsics)"
        ]
    },
    {
        "func_name": "read_img",
        "original": "def read_img(filename):\n    img = Image.open(filename)\n    np_img = np.array(img, dtype=np.float32) / 255.0\n    return np_img",
        "mutated": [
            "def read_img(filename):\n    if False:\n        i = 10\n    img = Image.open(filename)\n    np_img = np.array(img, dtype=np.float32) / 255.0\n    return np_img",
            "def read_img(filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    img = Image.open(filename)\n    np_img = np.array(img, dtype=np.float32) / 255.0\n    return np_img",
            "def read_img(filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    img = Image.open(filename)\n    np_img = np.array(img, dtype=np.float32) / 255.0\n    return np_img",
            "def read_img(filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    img = Image.open(filename)\n    np_img = np.array(img, dtype=np.float32) / 255.0\n    return np_img",
            "def read_img(filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    img = Image.open(filename)\n    np_img = np.array(img, dtype=np.float32) / 255.0\n    return np_img"
        ]
    },
    {
        "func_name": "read_mask",
        "original": "def read_mask(filename):\n    return read_img(filename) > 0.5",
        "mutated": [
            "def read_mask(filename):\n    if False:\n        i = 10\n    return read_img(filename) > 0.5",
            "def read_mask(filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return read_img(filename) > 0.5",
            "def read_mask(filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return read_img(filename) > 0.5",
            "def read_mask(filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return read_img(filename) > 0.5",
            "def read_mask(filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return read_img(filename) > 0.5"
        ]
    },
    {
        "func_name": "save_mask",
        "original": "def save_mask(filename, mask):\n    assert mask.dtype == bool\n    mask = mask.astype(np.uint8) * 255\n    Image.fromarray(mask).save(filename)",
        "mutated": [
            "def save_mask(filename, mask):\n    if False:\n        i = 10\n    assert mask.dtype == bool\n    mask = mask.astype(np.uint8) * 255\n    Image.fromarray(mask).save(filename)",
            "def save_mask(filename, mask):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    assert mask.dtype == bool\n    mask = mask.astype(np.uint8) * 255\n    Image.fromarray(mask).save(filename)",
            "def save_mask(filename, mask):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    assert mask.dtype == bool\n    mask = mask.astype(np.uint8) * 255\n    Image.fromarray(mask).save(filename)",
            "def save_mask(filename, mask):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    assert mask.dtype == bool\n    mask = mask.astype(np.uint8) * 255\n    Image.fromarray(mask).save(filename)",
            "def save_mask(filename, mask):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    assert mask.dtype == bool\n    mask = mask.astype(np.uint8) * 255\n    Image.fromarray(mask).save(filename)"
        ]
    },
    {
        "func_name": "read_pair_file",
        "original": "def read_pair_file(filename):\n    data = []\n    with open(filename) as f:\n        num_viewpoint = int(f.readline())\n        for view_idx in range(num_viewpoint):\n            ref_view = int(f.readline().rstrip())\n            src_views = [int(x) for x in f.readline().rstrip().split()[1::2]]\n            if len(src_views) > 0:\n                data.append((ref_view, src_views))\n    return data",
        "mutated": [
            "def read_pair_file(filename):\n    if False:\n        i = 10\n    data = []\n    with open(filename) as f:\n        num_viewpoint = int(f.readline())\n        for view_idx in range(num_viewpoint):\n            ref_view = int(f.readline().rstrip())\n            src_views = [int(x) for x in f.readline().rstrip().split()[1::2]]\n            if len(src_views) > 0:\n                data.append((ref_view, src_views))\n    return data",
            "def read_pair_file(filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    data = []\n    with open(filename) as f:\n        num_viewpoint = int(f.readline())\n        for view_idx in range(num_viewpoint):\n            ref_view = int(f.readline().rstrip())\n            src_views = [int(x) for x in f.readline().rstrip().split()[1::2]]\n            if len(src_views) > 0:\n                data.append((ref_view, src_views))\n    return data",
            "def read_pair_file(filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    data = []\n    with open(filename) as f:\n        num_viewpoint = int(f.readline())\n        for view_idx in range(num_viewpoint):\n            ref_view = int(f.readline().rstrip())\n            src_views = [int(x) for x in f.readline().rstrip().split()[1::2]]\n            if len(src_views) > 0:\n                data.append((ref_view, src_views))\n    return data",
            "def read_pair_file(filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    data = []\n    with open(filename) as f:\n        num_viewpoint = int(f.readline())\n        for view_idx in range(num_viewpoint):\n            ref_view = int(f.readline().rstrip())\n            src_views = [int(x) for x in f.readline().rstrip().split()[1::2]]\n            if len(src_views) > 0:\n                data.append((ref_view, src_views))\n    return data",
            "def read_pair_file(filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    data = []\n    with open(filename) as f:\n        num_viewpoint = int(f.readline())\n        for view_idx in range(num_viewpoint):\n            ref_view = int(f.readline().rstrip())\n            src_views = [int(x) for x in f.readline().rstrip().split()[1::2]]\n            if len(src_views) > 0:\n                data.append((ref_view, src_views))\n    return data"
        ]
    },
    {
        "func_name": "reproject_with_depth",
        "original": "def reproject_with_depth(depth_ref, intrinsics_ref, extrinsics_ref, depth_src, intrinsics_src, extrinsics_src):\n    (width, height) = (depth_ref.shape[1], depth_ref.shape[0])\n    (x_ref, y_ref) = np.meshgrid(np.arange(0, width), np.arange(0, height))\n    (x_ref, y_ref) = (x_ref.reshape([-1]), y_ref.reshape([-1]))\n    xyz_ref = np.matmul(np.linalg.inv(intrinsics_ref), np.vstack((x_ref, y_ref, np.ones_like(x_ref))) * depth_ref.reshape([-1]))\n    xyz_src = np.matmul(np.matmul(extrinsics_src, np.linalg.inv(extrinsics_ref)), np.vstack((xyz_ref, np.ones_like(x_ref))))[:3]\n    K_xyz_src = np.matmul(intrinsics_src, xyz_src)\n    xy_src = K_xyz_src[:2] / K_xyz_src[2:3]\n    x_src = xy_src[0].reshape([height, width]).astype(np.float32)\n    y_src = xy_src[1].reshape([height, width]).astype(np.float32)\n    sampled_depth_src = cv2.remap(depth_src, x_src, y_src, interpolation=cv2.INTER_LINEAR)\n    xyz_src = np.matmul(np.linalg.inv(intrinsics_src), np.vstack((xy_src, np.ones_like(x_ref))) * sampled_depth_src.reshape([-1]))\n    xyz_reprojected = np.matmul(np.matmul(extrinsics_ref, np.linalg.inv(extrinsics_src)), np.vstack((xyz_src, np.ones_like(x_ref))))[:3]\n    depth_reprojected = xyz_reprojected[2].reshape([height, width]).astype(np.float32)\n    K_xyz_reprojected = np.matmul(intrinsics_ref, xyz_reprojected)\n    xy_reprojected = K_xyz_reprojected[:2] / K_xyz_reprojected[2:3]\n    x_reprojected = xy_reprojected[0].reshape([height, width]).astype(np.float32)\n    y_reprojected = xy_reprojected[1].reshape([height, width]).astype(np.float32)\n    return (depth_reprojected, x_reprojected, y_reprojected, x_src, y_src)",
        "mutated": [
            "def reproject_with_depth(depth_ref, intrinsics_ref, extrinsics_ref, depth_src, intrinsics_src, extrinsics_src):\n    if False:\n        i = 10\n    (width, height) = (depth_ref.shape[1], depth_ref.shape[0])\n    (x_ref, y_ref) = np.meshgrid(np.arange(0, width), np.arange(0, height))\n    (x_ref, y_ref) = (x_ref.reshape([-1]), y_ref.reshape([-1]))\n    xyz_ref = np.matmul(np.linalg.inv(intrinsics_ref), np.vstack((x_ref, y_ref, np.ones_like(x_ref))) * depth_ref.reshape([-1]))\n    xyz_src = np.matmul(np.matmul(extrinsics_src, np.linalg.inv(extrinsics_ref)), np.vstack((xyz_ref, np.ones_like(x_ref))))[:3]\n    K_xyz_src = np.matmul(intrinsics_src, xyz_src)\n    xy_src = K_xyz_src[:2] / K_xyz_src[2:3]\n    x_src = xy_src[0].reshape([height, width]).astype(np.float32)\n    y_src = xy_src[1].reshape([height, width]).astype(np.float32)\n    sampled_depth_src = cv2.remap(depth_src, x_src, y_src, interpolation=cv2.INTER_LINEAR)\n    xyz_src = np.matmul(np.linalg.inv(intrinsics_src), np.vstack((xy_src, np.ones_like(x_ref))) * sampled_depth_src.reshape([-1]))\n    xyz_reprojected = np.matmul(np.matmul(extrinsics_ref, np.linalg.inv(extrinsics_src)), np.vstack((xyz_src, np.ones_like(x_ref))))[:3]\n    depth_reprojected = xyz_reprojected[2].reshape([height, width]).astype(np.float32)\n    K_xyz_reprojected = np.matmul(intrinsics_ref, xyz_reprojected)\n    xy_reprojected = K_xyz_reprojected[:2] / K_xyz_reprojected[2:3]\n    x_reprojected = xy_reprojected[0].reshape([height, width]).astype(np.float32)\n    y_reprojected = xy_reprojected[1].reshape([height, width]).astype(np.float32)\n    return (depth_reprojected, x_reprojected, y_reprojected, x_src, y_src)",
            "def reproject_with_depth(depth_ref, intrinsics_ref, extrinsics_ref, depth_src, intrinsics_src, extrinsics_src):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (width, height) = (depth_ref.shape[1], depth_ref.shape[0])\n    (x_ref, y_ref) = np.meshgrid(np.arange(0, width), np.arange(0, height))\n    (x_ref, y_ref) = (x_ref.reshape([-1]), y_ref.reshape([-1]))\n    xyz_ref = np.matmul(np.linalg.inv(intrinsics_ref), np.vstack((x_ref, y_ref, np.ones_like(x_ref))) * depth_ref.reshape([-1]))\n    xyz_src = np.matmul(np.matmul(extrinsics_src, np.linalg.inv(extrinsics_ref)), np.vstack((xyz_ref, np.ones_like(x_ref))))[:3]\n    K_xyz_src = np.matmul(intrinsics_src, xyz_src)\n    xy_src = K_xyz_src[:2] / K_xyz_src[2:3]\n    x_src = xy_src[0].reshape([height, width]).astype(np.float32)\n    y_src = xy_src[1].reshape([height, width]).astype(np.float32)\n    sampled_depth_src = cv2.remap(depth_src, x_src, y_src, interpolation=cv2.INTER_LINEAR)\n    xyz_src = np.matmul(np.linalg.inv(intrinsics_src), np.vstack((xy_src, np.ones_like(x_ref))) * sampled_depth_src.reshape([-1]))\n    xyz_reprojected = np.matmul(np.matmul(extrinsics_ref, np.linalg.inv(extrinsics_src)), np.vstack((xyz_src, np.ones_like(x_ref))))[:3]\n    depth_reprojected = xyz_reprojected[2].reshape([height, width]).astype(np.float32)\n    K_xyz_reprojected = np.matmul(intrinsics_ref, xyz_reprojected)\n    xy_reprojected = K_xyz_reprojected[:2] / K_xyz_reprojected[2:3]\n    x_reprojected = xy_reprojected[0].reshape([height, width]).astype(np.float32)\n    y_reprojected = xy_reprojected[1].reshape([height, width]).astype(np.float32)\n    return (depth_reprojected, x_reprojected, y_reprojected, x_src, y_src)",
            "def reproject_with_depth(depth_ref, intrinsics_ref, extrinsics_ref, depth_src, intrinsics_src, extrinsics_src):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (width, height) = (depth_ref.shape[1], depth_ref.shape[0])\n    (x_ref, y_ref) = np.meshgrid(np.arange(0, width), np.arange(0, height))\n    (x_ref, y_ref) = (x_ref.reshape([-1]), y_ref.reshape([-1]))\n    xyz_ref = np.matmul(np.linalg.inv(intrinsics_ref), np.vstack((x_ref, y_ref, np.ones_like(x_ref))) * depth_ref.reshape([-1]))\n    xyz_src = np.matmul(np.matmul(extrinsics_src, np.linalg.inv(extrinsics_ref)), np.vstack((xyz_ref, np.ones_like(x_ref))))[:3]\n    K_xyz_src = np.matmul(intrinsics_src, xyz_src)\n    xy_src = K_xyz_src[:2] / K_xyz_src[2:3]\n    x_src = xy_src[0].reshape([height, width]).astype(np.float32)\n    y_src = xy_src[1].reshape([height, width]).astype(np.float32)\n    sampled_depth_src = cv2.remap(depth_src, x_src, y_src, interpolation=cv2.INTER_LINEAR)\n    xyz_src = np.matmul(np.linalg.inv(intrinsics_src), np.vstack((xy_src, np.ones_like(x_ref))) * sampled_depth_src.reshape([-1]))\n    xyz_reprojected = np.matmul(np.matmul(extrinsics_ref, np.linalg.inv(extrinsics_src)), np.vstack((xyz_src, np.ones_like(x_ref))))[:3]\n    depth_reprojected = xyz_reprojected[2].reshape([height, width]).astype(np.float32)\n    K_xyz_reprojected = np.matmul(intrinsics_ref, xyz_reprojected)\n    xy_reprojected = K_xyz_reprojected[:2] / K_xyz_reprojected[2:3]\n    x_reprojected = xy_reprojected[0].reshape([height, width]).astype(np.float32)\n    y_reprojected = xy_reprojected[1].reshape([height, width]).astype(np.float32)\n    return (depth_reprojected, x_reprojected, y_reprojected, x_src, y_src)",
            "def reproject_with_depth(depth_ref, intrinsics_ref, extrinsics_ref, depth_src, intrinsics_src, extrinsics_src):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (width, height) = (depth_ref.shape[1], depth_ref.shape[0])\n    (x_ref, y_ref) = np.meshgrid(np.arange(0, width), np.arange(0, height))\n    (x_ref, y_ref) = (x_ref.reshape([-1]), y_ref.reshape([-1]))\n    xyz_ref = np.matmul(np.linalg.inv(intrinsics_ref), np.vstack((x_ref, y_ref, np.ones_like(x_ref))) * depth_ref.reshape([-1]))\n    xyz_src = np.matmul(np.matmul(extrinsics_src, np.linalg.inv(extrinsics_ref)), np.vstack((xyz_ref, np.ones_like(x_ref))))[:3]\n    K_xyz_src = np.matmul(intrinsics_src, xyz_src)\n    xy_src = K_xyz_src[:2] / K_xyz_src[2:3]\n    x_src = xy_src[0].reshape([height, width]).astype(np.float32)\n    y_src = xy_src[1].reshape([height, width]).astype(np.float32)\n    sampled_depth_src = cv2.remap(depth_src, x_src, y_src, interpolation=cv2.INTER_LINEAR)\n    xyz_src = np.matmul(np.linalg.inv(intrinsics_src), np.vstack((xy_src, np.ones_like(x_ref))) * sampled_depth_src.reshape([-1]))\n    xyz_reprojected = np.matmul(np.matmul(extrinsics_ref, np.linalg.inv(extrinsics_src)), np.vstack((xyz_src, np.ones_like(x_ref))))[:3]\n    depth_reprojected = xyz_reprojected[2].reshape([height, width]).astype(np.float32)\n    K_xyz_reprojected = np.matmul(intrinsics_ref, xyz_reprojected)\n    xy_reprojected = K_xyz_reprojected[:2] / K_xyz_reprojected[2:3]\n    x_reprojected = xy_reprojected[0].reshape([height, width]).astype(np.float32)\n    y_reprojected = xy_reprojected[1].reshape([height, width]).astype(np.float32)\n    return (depth_reprojected, x_reprojected, y_reprojected, x_src, y_src)",
            "def reproject_with_depth(depth_ref, intrinsics_ref, extrinsics_ref, depth_src, intrinsics_src, extrinsics_src):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (width, height) = (depth_ref.shape[1], depth_ref.shape[0])\n    (x_ref, y_ref) = np.meshgrid(np.arange(0, width), np.arange(0, height))\n    (x_ref, y_ref) = (x_ref.reshape([-1]), y_ref.reshape([-1]))\n    xyz_ref = np.matmul(np.linalg.inv(intrinsics_ref), np.vstack((x_ref, y_ref, np.ones_like(x_ref))) * depth_ref.reshape([-1]))\n    xyz_src = np.matmul(np.matmul(extrinsics_src, np.linalg.inv(extrinsics_ref)), np.vstack((xyz_ref, np.ones_like(x_ref))))[:3]\n    K_xyz_src = np.matmul(intrinsics_src, xyz_src)\n    xy_src = K_xyz_src[:2] / K_xyz_src[2:3]\n    x_src = xy_src[0].reshape([height, width]).astype(np.float32)\n    y_src = xy_src[1].reshape([height, width]).astype(np.float32)\n    sampled_depth_src = cv2.remap(depth_src, x_src, y_src, interpolation=cv2.INTER_LINEAR)\n    xyz_src = np.matmul(np.linalg.inv(intrinsics_src), np.vstack((xy_src, np.ones_like(x_ref))) * sampled_depth_src.reshape([-1]))\n    xyz_reprojected = np.matmul(np.matmul(extrinsics_ref, np.linalg.inv(extrinsics_src)), np.vstack((xyz_src, np.ones_like(x_ref))))[:3]\n    depth_reprojected = xyz_reprojected[2].reshape([height, width]).astype(np.float32)\n    K_xyz_reprojected = np.matmul(intrinsics_ref, xyz_reprojected)\n    xy_reprojected = K_xyz_reprojected[:2] / K_xyz_reprojected[2:3]\n    x_reprojected = xy_reprojected[0].reshape([height, width]).astype(np.float32)\n    y_reprojected = xy_reprojected[1].reshape([height, width]).astype(np.float32)\n    return (depth_reprojected, x_reprojected, y_reprojected, x_src, y_src)"
        ]
    },
    {
        "func_name": "check_geometric_consistency",
        "original": "def check_geometric_consistency(depth_ref, intrinsics_ref, extrinsics_ref, depth_src, intrinsics_src, extrinsics_src):\n    (width, height) = (depth_ref.shape[1], depth_ref.shape[0])\n    (x_ref, y_ref) = np.meshgrid(np.arange(0, width), np.arange(0, height))\n    (depth_reprojected, x2d_reprojected, y2d_reprojected, x2d_src, y2d_src) = reproject_with_depth(depth_ref, intrinsics_ref, extrinsics_ref, depth_src, intrinsics_src, extrinsics_src)\n    dist = np.sqrt((x2d_reprojected - x_ref) ** 2 + (y2d_reprojected - y_ref) ** 2)\n    depth_diff = np.abs(depth_reprojected - depth_ref)\n    relative_depth_diff = depth_diff / depth_ref\n    mask = np.logical_and(dist < 1, relative_depth_diff < 0.01)\n    depth_reprojected[~mask] = 0\n    return (mask, depth_reprojected, x2d_src, y2d_src)",
        "mutated": [
            "def check_geometric_consistency(depth_ref, intrinsics_ref, extrinsics_ref, depth_src, intrinsics_src, extrinsics_src):\n    if False:\n        i = 10\n    (width, height) = (depth_ref.shape[1], depth_ref.shape[0])\n    (x_ref, y_ref) = np.meshgrid(np.arange(0, width), np.arange(0, height))\n    (depth_reprojected, x2d_reprojected, y2d_reprojected, x2d_src, y2d_src) = reproject_with_depth(depth_ref, intrinsics_ref, extrinsics_ref, depth_src, intrinsics_src, extrinsics_src)\n    dist = np.sqrt((x2d_reprojected - x_ref) ** 2 + (y2d_reprojected - y_ref) ** 2)\n    depth_diff = np.abs(depth_reprojected - depth_ref)\n    relative_depth_diff = depth_diff / depth_ref\n    mask = np.logical_and(dist < 1, relative_depth_diff < 0.01)\n    depth_reprojected[~mask] = 0\n    return (mask, depth_reprojected, x2d_src, y2d_src)",
            "def check_geometric_consistency(depth_ref, intrinsics_ref, extrinsics_ref, depth_src, intrinsics_src, extrinsics_src):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (width, height) = (depth_ref.shape[1], depth_ref.shape[0])\n    (x_ref, y_ref) = np.meshgrid(np.arange(0, width), np.arange(0, height))\n    (depth_reprojected, x2d_reprojected, y2d_reprojected, x2d_src, y2d_src) = reproject_with_depth(depth_ref, intrinsics_ref, extrinsics_ref, depth_src, intrinsics_src, extrinsics_src)\n    dist = np.sqrt((x2d_reprojected - x_ref) ** 2 + (y2d_reprojected - y_ref) ** 2)\n    depth_diff = np.abs(depth_reprojected - depth_ref)\n    relative_depth_diff = depth_diff / depth_ref\n    mask = np.logical_and(dist < 1, relative_depth_diff < 0.01)\n    depth_reprojected[~mask] = 0\n    return (mask, depth_reprojected, x2d_src, y2d_src)",
            "def check_geometric_consistency(depth_ref, intrinsics_ref, extrinsics_ref, depth_src, intrinsics_src, extrinsics_src):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (width, height) = (depth_ref.shape[1], depth_ref.shape[0])\n    (x_ref, y_ref) = np.meshgrid(np.arange(0, width), np.arange(0, height))\n    (depth_reprojected, x2d_reprojected, y2d_reprojected, x2d_src, y2d_src) = reproject_with_depth(depth_ref, intrinsics_ref, extrinsics_ref, depth_src, intrinsics_src, extrinsics_src)\n    dist = np.sqrt((x2d_reprojected - x_ref) ** 2 + (y2d_reprojected - y_ref) ** 2)\n    depth_diff = np.abs(depth_reprojected - depth_ref)\n    relative_depth_diff = depth_diff / depth_ref\n    mask = np.logical_and(dist < 1, relative_depth_diff < 0.01)\n    depth_reprojected[~mask] = 0\n    return (mask, depth_reprojected, x2d_src, y2d_src)",
            "def check_geometric_consistency(depth_ref, intrinsics_ref, extrinsics_ref, depth_src, intrinsics_src, extrinsics_src):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (width, height) = (depth_ref.shape[1], depth_ref.shape[0])\n    (x_ref, y_ref) = np.meshgrid(np.arange(0, width), np.arange(0, height))\n    (depth_reprojected, x2d_reprojected, y2d_reprojected, x2d_src, y2d_src) = reproject_with_depth(depth_ref, intrinsics_ref, extrinsics_ref, depth_src, intrinsics_src, extrinsics_src)\n    dist = np.sqrt((x2d_reprojected - x_ref) ** 2 + (y2d_reprojected - y_ref) ** 2)\n    depth_diff = np.abs(depth_reprojected - depth_ref)\n    relative_depth_diff = depth_diff / depth_ref\n    mask = np.logical_and(dist < 1, relative_depth_diff < 0.01)\n    depth_reprojected[~mask] = 0\n    return (mask, depth_reprojected, x2d_src, y2d_src)",
            "def check_geometric_consistency(depth_ref, intrinsics_ref, extrinsics_ref, depth_src, intrinsics_src, extrinsics_src):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (width, height) = (depth_ref.shape[1], depth_ref.shape[0])\n    (x_ref, y_ref) = np.meshgrid(np.arange(0, width), np.arange(0, height))\n    (depth_reprojected, x2d_reprojected, y2d_reprojected, x2d_src, y2d_src) = reproject_with_depth(depth_ref, intrinsics_ref, extrinsics_ref, depth_src, intrinsics_src, extrinsics_src)\n    dist = np.sqrt((x2d_reprojected - x_ref) ** 2 + (y2d_reprojected - y_ref) ** 2)\n    depth_diff = np.abs(depth_reprojected - depth_ref)\n    relative_depth_diff = depth_diff / depth_ref\n    mask = np.logical_and(dist < 1, relative_depth_diff < 0.01)\n    depth_reprojected[~mask] = 0\n    return (mask, depth_reprojected, x2d_src, y2d_src)"
        ]
    },
    {
        "func_name": "filter_depth",
        "original": "def filter_depth(pair_folder, scan_folder, out_folder, thres_view):\n    pair_file = os.path.join(pair_folder, 'pair.txt')\n    vertexs = []\n    vertex_colors = []\n    pair_data = read_pair_file(pair_file)\n    for (ref_view, src_views) in pair_data:\n        (ref_intrinsics, ref_extrinsics) = read_camera_parameters(os.path.join(scan_folder, 'cams/{:0>8}_cam.txt'.format(ref_view)))\n        ref_img = read_img(os.path.join(scan_folder, 'images/{:0>8}.jpg'.format(ref_view)))\n        ref_depth_est = read_pfm(os.path.join(out_folder, 'depth_est/{:0>8}.pfm'.format(ref_view)))[0]\n        confidence = read_pfm(os.path.join(out_folder, 'confidence/{:0>8}.pfm'.format(ref_view)))[0]\n        photo_mask = confidence > 0.9\n        all_srcview_depth_ests = []\n        all_srcview_x = []\n        all_srcview_y = []\n        all_srcview_geomask = []\n        geo_mask_sum = 0\n        for src_view in src_views:\n            (src_intrinsics, src_extrinsics) = read_camera_parameters(os.path.join(scan_folder, 'cams/{:0>8}_cam.txt'.format(src_view)))\n            src_depth_est = read_pfm(os.path.join(out_folder, 'depth_est/{:0>8}.pfm'.format(src_view)))[0]\n            (geo_mask, depth_reprojected, x2d_src, y2d_src) = check_geometric_consistency(ref_depth_est, ref_intrinsics, ref_extrinsics, src_depth_est, src_intrinsics, src_extrinsics)\n            geo_mask_sum += geo_mask.astype(np.int32)\n            all_srcview_depth_ests.append(depth_reprojected)\n            all_srcview_x.append(x2d_src)\n            all_srcview_y.append(y2d_src)\n            all_srcview_geomask.append(geo_mask)\n        depth_est_averaged = (sum(all_srcview_depth_ests) + ref_depth_est) / (geo_mask_sum + 1)\n        geo_mask = geo_mask_sum >= thres_view\n        final_mask = np.logical_and(photo_mask, geo_mask)\n        os.makedirs(os.path.join(out_folder, 'mask'), exist_ok=True)\n        save_mask(os.path.join(out_folder, 'mask/{:0>8}_photo.png'.format(ref_view)), photo_mask)\n        save_mask(os.path.join(out_folder, 'mask/{:0>8}_geo.png'.format(ref_view)), geo_mask)\n        save_mask(os.path.join(out_folder, 'mask/{:0>8}_final.png'.format(ref_view)), final_mask)\n        (height, width) = depth_est_averaged.shape[:2]\n        (x, y) = np.meshgrid(np.arange(0, width), np.arange(0, height))\n        valid_points = final_mask\n        (x, y, depth) = (x[valid_points], y[valid_points], depth_est_averaged[valid_points])\n        color = ref_img[valid_points]\n        xyz_ref = np.matmul(np.linalg.inv(ref_intrinsics), np.vstack((x, y, np.ones_like(x))) * depth)\n        xyz_world = np.matmul(np.linalg.inv(ref_extrinsics), np.vstack((xyz_ref, np.ones_like(x))))[:3]\n        vertexs.append(xyz_world.transpose((1, 0)))\n        vertex_colors.append((color * 255).astype(np.uint8))\n    vertexs = np.concatenate(vertexs, axis=0)\n    vertex_colors = np.concatenate(vertex_colors, axis=0)\n    vertexs = np.array([tuple(v) for v in vertexs], dtype=[('x', 'f4'), ('y', 'f4'), ('z', 'f4')])\n    vertex_colors = np.array([tuple(v) for v in vertex_colors], dtype=[('red', 'u1'), ('green', 'u1'), ('blue', 'u1')])\n    vertex_all = np.empty(len(vertexs), vertexs.dtype.descr + vertex_colors.dtype.descr)\n    for prop in vertexs.dtype.names:\n        vertex_all[prop] = vertexs[prop]\n    for prop in vertex_colors.dtype.names:\n        vertex_all[prop] = vertex_colors[prop]\n    el = PlyElement.describe(vertex_all, 'vertex')\n    pcd = PlyData([el])\n    return pcd",
        "mutated": [
            "def filter_depth(pair_folder, scan_folder, out_folder, thres_view):\n    if False:\n        i = 10\n    pair_file = os.path.join(pair_folder, 'pair.txt')\n    vertexs = []\n    vertex_colors = []\n    pair_data = read_pair_file(pair_file)\n    for (ref_view, src_views) in pair_data:\n        (ref_intrinsics, ref_extrinsics) = read_camera_parameters(os.path.join(scan_folder, 'cams/{:0>8}_cam.txt'.format(ref_view)))\n        ref_img = read_img(os.path.join(scan_folder, 'images/{:0>8}.jpg'.format(ref_view)))\n        ref_depth_est = read_pfm(os.path.join(out_folder, 'depth_est/{:0>8}.pfm'.format(ref_view)))[0]\n        confidence = read_pfm(os.path.join(out_folder, 'confidence/{:0>8}.pfm'.format(ref_view)))[0]\n        photo_mask = confidence > 0.9\n        all_srcview_depth_ests = []\n        all_srcview_x = []\n        all_srcview_y = []\n        all_srcview_geomask = []\n        geo_mask_sum = 0\n        for src_view in src_views:\n            (src_intrinsics, src_extrinsics) = read_camera_parameters(os.path.join(scan_folder, 'cams/{:0>8}_cam.txt'.format(src_view)))\n            src_depth_est = read_pfm(os.path.join(out_folder, 'depth_est/{:0>8}.pfm'.format(src_view)))[0]\n            (geo_mask, depth_reprojected, x2d_src, y2d_src) = check_geometric_consistency(ref_depth_est, ref_intrinsics, ref_extrinsics, src_depth_est, src_intrinsics, src_extrinsics)\n            geo_mask_sum += geo_mask.astype(np.int32)\n            all_srcview_depth_ests.append(depth_reprojected)\n            all_srcview_x.append(x2d_src)\n            all_srcview_y.append(y2d_src)\n            all_srcview_geomask.append(geo_mask)\n        depth_est_averaged = (sum(all_srcview_depth_ests) + ref_depth_est) / (geo_mask_sum + 1)\n        geo_mask = geo_mask_sum >= thres_view\n        final_mask = np.logical_and(photo_mask, geo_mask)\n        os.makedirs(os.path.join(out_folder, 'mask'), exist_ok=True)\n        save_mask(os.path.join(out_folder, 'mask/{:0>8}_photo.png'.format(ref_view)), photo_mask)\n        save_mask(os.path.join(out_folder, 'mask/{:0>8}_geo.png'.format(ref_view)), geo_mask)\n        save_mask(os.path.join(out_folder, 'mask/{:0>8}_final.png'.format(ref_view)), final_mask)\n        (height, width) = depth_est_averaged.shape[:2]\n        (x, y) = np.meshgrid(np.arange(0, width), np.arange(0, height))\n        valid_points = final_mask\n        (x, y, depth) = (x[valid_points], y[valid_points], depth_est_averaged[valid_points])\n        color = ref_img[valid_points]\n        xyz_ref = np.matmul(np.linalg.inv(ref_intrinsics), np.vstack((x, y, np.ones_like(x))) * depth)\n        xyz_world = np.matmul(np.linalg.inv(ref_extrinsics), np.vstack((xyz_ref, np.ones_like(x))))[:3]\n        vertexs.append(xyz_world.transpose((1, 0)))\n        vertex_colors.append((color * 255).astype(np.uint8))\n    vertexs = np.concatenate(vertexs, axis=0)\n    vertex_colors = np.concatenate(vertex_colors, axis=0)\n    vertexs = np.array([tuple(v) for v in vertexs], dtype=[('x', 'f4'), ('y', 'f4'), ('z', 'f4')])\n    vertex_colors = np.array([tuple(v) for v in vertex_colors], dtype=[('red', 'u1'), ('green', 'u1'), ('blue', 'u1')])\n    vertex_all = np.empty(len(vertexs), vertexs.dtype.descr + vertex_colors.dtype.descr)\n    for prop in vertexs.dtype.names:\n        vertex_all[prop] = vertexs[prop]\n    for prop in vertex_colors.dtype.names:\n        vertex_all[prop] = vertex_colors[prop]\n    el = PlyElement.describe(vertex_all, 'vertex')\n    pcd = PlyData([el])\n    return pcd",
            "def filter_depth(pair_folder, scan_folder, out_folder, thres_view):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    pair_file = os.path.join(pair_folder, 'pair.txt')\n    vertexs = []\n    vertex_colors = []\n    pair_data = read_pair_file(pair_file)\n    for (ref_view, src_views) in pair_data:\n        (ref_intrinsics, ref_extrinsics) = read_camera_parameters(os.path.join(scan_folder, 'cams/{:0>8}_cam.txt'.format(ref_view)))\n        ref_img = read_img(os.path.join(scan_folder, 'images/{:0>8}.jpg'.format(ref_view)))\n        ref_depth_est = read_pfm(os.path.join(out_folder, 'depth_est/{:0>8}.pfm'.format(ref_view)))[0]\n        confidence = read_pfm(os.path.join(out_folder, 'confidence/{:0>8}.pfm'.format(ref_view)))[0]\n        photo_mask = confidence > 0.9\n        all_srcview_depth_ests = []\n        all_srcview_x = []\n        all_srcview_y = []\n        all_srcview_geomask = []\n        geo_mask_sum = 0\n        for src_view in src_views:\n            (src_intrinsics, src_extrinsics) = read_camera_parameters(os.path.join(scan_folder, 'cams/{:0>8}_cam.txt'.format(src_view)))\n            src_depth_est = read_pfm(os.path.join(out_folder, 'depth_est/{:0>8}.pfm'.format(src_view)))[0]\n            (geo_mask, depth_reprojected, x2d_src, y2d_src) = check_geometric_consistency(ref_depth_est, ref_intrinsics, ref_extrinsics, src_depth_est, src_intrinsics, src_extrinsics)\n            geo_mask_sum += geo_mask.astype(np.int32)\n            all_srcview_depth_ests.append(depth_reprojected)\n            all_srcview_x.append(x2d_src)\n            all_srcview_y.append(y2d_src)\n            all_srcview_geomask.append(geo_mask)\n        depth_est_averaged = (sum(all_srcview_depth_ests) + ref_depth_est) / (geo_mask_sum + 1)\n        geo_mask = geo_mask_sum >= thres_view\n        final_mask = np.logical_and(photo_mask, geo_mask)\n        os.makedirs(os.path.join(out_folder, 'mask'), exist_ok=True)\n        save_mask(os.path.join(out_folder, 'mask/{:0>8}_photo.png'.format(ref_view)), photo_mask)\n        save_mask(os.path.join(out_folder, 'mask/{:0>8}_geo.png'.format(ref_view)), geo_mask)\n        save_mask(os.path.join(out_folder, 'mask/{:0>8}_final.png'.format(ref_view)), final_mask)\n        (height, width) = depth_est_averaged.shape[:2]\n        (x, y) = np.meshgrid(np.arange(0, width), np.arange(0, height))\n        valid_points = final_mask\n        (x, y, depth) = (x[valid_points], y[valid_points], depth_est_averaged[valid_points])\n        color = ref_img[valid_points]\n        xyz_ref = np.matmul(np.linalg.inv(ref_intrinsics), np.vstack((x, y, np.ones_like(x))) * depth)\n        xyz_world = np.matmul(np.linalg.inv(ref_extrinsics), np.vstack((xyz_ref, np.ones_like(x))))[:3]\n        vertexs.append(xyz_world.transpose((1, 0)))\n        vertex_colors.append((color * 255).astype(np.uint8))\n    vertexs = np.concatenate(vertexs, axis=0)\n    vertex_colors = np.concatenate(vertex_colors, axis=0)\n    vertexs = np.array([tuple(v) for v in vertexs], dtype=[('x', 'f4'), ('y', 'f4'), ('z', 'f4')])\n    vertex_colors = np.array([tuple(v) for v in vertex_colors], dtype=[('red', 'u1'), ('green', 'u1'), ('blue', 'u1')])\n    vertex_all = np.empty(len(vertexs), vertexs.dtype.descr + vertex_colors.dtype.descr)\n    for prop in vertexs.dtype.names:\n        vertex_all[prop] = vertexs[prop]\n    for prop in vertex_colors.dtype.names:\n        vertex_all[prop] = vertex_colors[prop]\n    el = PlyElement.describe(vertex_all, 'vertex')\n    pcd = PlyData([el])\n    return pcd",
            "def filter_depth(pair_folder, scan_folder, out_folder, thres_view):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    pair_file = os.path.join(pair_folder, 'pair.txt')\n    vertexs = []\n    vertex_colors = []\n    pair_data = read_pair_file(pair_file)\n    for (ref_view, src_views) in pair_data:\n        (ref_intrinsics, ref_extrinsics) = read_camera_parameters(os.path.join(scan_folder, 'cams/{:0>8}_cam.txt'.format(ref_view)))\n        ref_img = read_img(os.path.join(scan_folder, 'images/{:0>8}.jpg'.format(ref_view)))\n        ref_depth_est = read_pfm(os.path.join(out_folder, 'depth_est/{:0>8}.pfm'.format(ref_view)))[0]\n        confidence = read_pfm(os.path.join(out_folder, 'confidence/{:0>8}.pfm'.format(ref_view)))[0]\n        photo_mask = confidence > 0.9\n        all_srcview_depth_ests = []\n        all_srcview_x = []\n        all_srcview_y = []\n        all_srcview_geomask = []\n        geo_mask_sum = 0\n        for src_view in src_views:\n            (src_intrinsics, src_extrinsics) = read_camera_parameters(os.path.join(scan_folder, 'cams/{:0>8}_cam.txt'.format(src_view)))\n            src_depth_est = read_pfm(os.path.join(out_folder, 'depth_est/{:0>8}.pfm'.format(src_view)))[0]\n            (geo_mask, depth_reprojected, x2d_src, y2d_src) = check_geometric_consistency(ref_depth_est, ref_intrinsics, ref_extrinsics, src_depth_est, src_intrinsics, src_extrinsics)\n            geo_mask_sum += geo_mask.astype(np.int32)\n            all_srcview_depth_ests.append(depth_reprojected)\n            all_srcview_x.append(x2d_src)\n            all_srcview_y.append(y2d_src)\n            all_srcview_geomask.append(geo_mask)\n        depth_est_averaged = (sum(all_srcview_depth_ests) + ref_depth_est) / (geo_mask_sum + 1)\n        geo_mask = geo_mask_sum >= thres_view\n        final_mask = np.logical_and(photo_mask, geo_mask)\n        os.makedirs(os.path.join(out_folder, 'mask'), exist_ok=True)\n        save_mask(os.path.join(out_folder, 'mask/{:0>8}_photo.png'.format(ref_view)), photo_mask)\n        save_mask(os.path.join(out_folder, 'mask/{:0>8}_geo.png'.format(ref_view)), geo_mask)\n        save_mask(os.path.join(out_folder, 'mask/{:0>8}_final.png'.format(ref_view)), final_mask)\n        (height, width) = depth_est_averaged.shape[:2]\n        (x, y) = np.meshgrid(np.arange(0, width), np.arange(0, height))\n        valid_points = final_mask\n        (x, y, depth) = (x[valid_points], y[valid_points], depth_est_averaged[valid_points])\n        color = ref_img[valid_points]\n        xyz_ref = np.matmul(np.linalg.inv(ref_intrinsics), np.vstack((x, y, np.ones_like(x))) * depth)\n        xyz_world = np.matmul(np.linalg.inv(ref_extrinsics), np.vstack((xyz_ref, np.ones_like(x))))[:3]\n        vertexs.append(xyz_world.transpose((1, 0)))\n        vertex_colors.append((color * 255).astype(np.uint8))\n    vertexs = np.concatenate(vertexs, axis=0)\n    vertex_colors = np.concatenate(vertex_colors, axis=0)\n    vertexs = np.array([tuple(v) for v in vertexs], dtype=[('x', 'f4'), ('y', 'f4'), ('z', 'f4')])\n    vertex_colors = np.array([tuple(v) for v in vertex_colors], dtype=[('red', 'u1'), ('green', 'u1'), ('blue', 'u1')])\n    vertex_all = np.empty(len(vertexs), vertexs.dtype.descr + vertex_colors.dtype.descr)\n    for prop in vertexs.dtype.names:\n        vertex_all[prop] = vertexs[prop]\n    for prop in vertex_colors.dtype.names:\n        vertex_all[prop] = vertex_colors[prop]\n    el = PlyElement.describe(vertex_all, 'vertex')\n    pcd = PlyData([el])\n    return pcd",
            "def filter_depth(pair_folder, scan_folder, out_folder, thres_view):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    pair_file = os.path.join(pair_folder, 'pair.txt')\n    vertexs = []\n    vertex_colors = []\n    pair_data = read_pair_file(pair_file)\n    for (ref_view, src_views) in pair_data:\n        (ref_intrinsics, ref_extrinsics) = read_camera_parameters(os.path.join(scan_folder, 'cams/{:0>8}_cam.txt'.format(ref_view)))\n        ref_img = read_img(os.path.join(scan_folder, 'images/{:0>8}.jpg'.format(ref_view)))\n        ref_depth_est = read_pfm(os.path.join(out_folder, 'depth_est/{:0>8}.pfm'.format(ref_view)))[0]\n        confidence = read_pfm(os.path.join(out_folder, 'confidence/{:0>8}.pfm'.format(ref_view)))[0]\n        photo_mask = confidence > 0.9\n        all_srcview_depth_ests = []\n        all_srcview_x = []\n        all_srcview_y = []\n        all_srcview_geomask = []\n        geo_mask_sum = 0\n        for src_view in src_views:\n            (src_intrinsics, src_extrinsics) = read_camera_parameters(os.path.join(scan_folder, 'cams/{:0>8}_cam.txt'.format(src_view)))\n            src_depth_est = read_pfm(os.path.join(out_folder, 'depth_est/{:0>8}.pfm'.format(src_view)))[0]\n            (geo_mask, depth_reprojected, x2d_src, y2d_src) = check_geometric_consistency(ref_depth_est, ref_intrinsics, ref_extrinsics, src_depth_est, src_intrinsics, src_extrinsics)\n            geo_mask_sum += geo_mask.astype(np.int32)\n            all_srcview_depth_ests.append(depth_reprojected)\n            all_srcview_x.append(x2d_src)\n            all_srcview_y.append(y2d_src)\n            all_srcview_geomask.append(geo_mask)\n        depth_est_averaged = (sum(all_srcview_depth_ests) + ref_depth_est) / (geo_mask_sum + 1)\n        geo_mask = geo_mask_sum >= thres_view\n        final_mask = np.logical_and(photo_mask, geo_mask)\n        os.makedirs(os.path.join(out_folder, 'mask'), exist_ok=True)\n        save_mask(os.path.join(out_folder, 'mask/{:0>8}_photo.png'.format(ref_view)), photo_mask)\n        save_mask(os.path.join(out_folder, 'mask/{:0>8}_geo.png'.format(ref_view)), geo_mask)\n        save_mask(os.path.join(out_folder, 'mask/{:0>8}_final.png'.format(ref_view)), final_mask)\n        (height, width) = depth_est_averaged.shape[:2]\n        (x, y) = np.meshgrid(np.arange(0, width), np.arange(0, height))\n        valid_points = final_mask\n        (x, y, depth) = (x[valid_points], y[valid_points], depth_est_averaged[valid_points])\n        color = ref_img[valid_points]\n        xyz_ref = np.matmul(np.linalg.inv(ref_intrinsics), np.vstack((x, y, np.ones_like(x))) * depth)\n        xyz_world = np.matmul(np.linalg.inv(ref_extrinsics), np.vstack((xyz_ref, np.ones_like(x))))[:3]\n        vertexs.append(xyz_world.transpose((1, 0)))\n        vertex_colors.append((color * 255).astype(np.uint8))\n    vertexs = np.concatenate(vertexs, axis=0)\n    vertex_colors = np.concatenate(vertex_colors, axis=0)\n    vertexs = np.array([tuple(v) for v in vertexs], dtype=[('x', 'f4'), ('y', 'f4'), ('z', 'f4')])\n    vertex_colors = np.array([tuple(v) for v in vertex_colors], dtype=[('red', 'u1'), ('green', 'u1'), ('blue', 'u1')])\n    vertex_all = np.empty(len(vertexs), vertexs.dtype.descr + vertex_colors.dtype.descr)\n    for prop in vertexs.dtype.names:\n        vertex_all[prop] = vertexs[prop]\n    for prop in vertex_colors.dtype.names:\n        vertex_all[prop] = vertex_colors[prop]\n    el = PlyElement.describe(vertex_all, 'vertex')\n    pcd = PlyData([el])\n    return pcd",
            "def filter_depth(pair_folder, scan_folder, out_folder, thres_view):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    pair_file = os.path.join(pair_folder, 'pair.txt')\n    vertexs = []\n    vertex_colors = []\n    pair_data = read_pair_file(pair_file)\n    for (ref_view, src_views) in pair_data:\n        (ref_intrinsics, ref_extrinsics) = read_camera_parameters(os.path.join(scan_folder, 'cams/{:0>8}_cam.txt'.format(ref_view)))\n        ref_img = read_img(os.path.join(scan_folder, 'images/{:0>8}.jpg'.format(ref_view)))\n        ref_depth_est = read_pfm(os.path.join(out_folder, 'depth_est/{:0>8}.pfm'.format(ref_view)))[0]\n        confidence = read_pfm(os.path.join(out_folder, 'confidence/{:0>8}.pfm'.format(ref_view)))[0]\n        photo_mask = confidence > 0.9\n        all_srcview_depth_ests = []\n        all_srcview_x = []\n        all_srcview_y = []\n        all_srcview_geomask = []\n        geo_mask_sum = 0\n        for src_view in src_views:\n            (src_intrinsics, src_extrinsics) = read_camera_parameters(os.path.join(scan_folder, 'cams/{:0>8}_cam.txt'.format(src_view)))\n            src_depth_est = read_pfm(os.path.join(out_folder, 'depth_est/{:0>8}.pfm'.format(src_view)))[0]\n            (geo_mask, depth_reprojected, x2d_src, y2d_src) = check_geometric_consistency(ref_depth_est, ref_intrinsics, ref_extrinsics, src_depth_est, src_intrinsics, src_extrinsics)\n            geo_mask_sum += geo_mask.astype(np.int32)\n            all_srcview_depth_ests.append(depth_reprojected)\n            all_srcview_x.append(x2d_src)\n            all_srcview_y.append(y2d_src)\n            all_srcview_geomask.append(geo_mask)\n        depth_est_averaged = (sum(all_srcview_depth_ests) + ref_depth_est) / (geo_mask_sum + 1)\n        geo_mask = geo_mask_sum >= thres_view\n        final_mask = np.logical_and(photo_mask, geo_mask)\n        os.makedirs(os.path.join(out_folder, 'mask'), exist_ok=True)\n        save_mask(os.path.join(out_folder, 'mask/{:0>8}_photo.png'.format(ref_view)), photo_mask)\n        save_mask(os.path.join(out_folder, 'mask/{:0>8}_geo.png'.format(ref_view)), geo_mask)\n        save_mask(os.path.join(out_folder, 'mask/{:0>8}_final.png'.format(ref_view)), final_mask)\n        (height, width) = depth_est_averaged.shape[:2]\n        (x, y) = np.meshgrid(np.arange(0, width), np.arange(0, height))\n        valid_points = final_mask\n        (x, y, depth) = (x[valid_points], y[valid_points], depth_est_averaged[valid_points])\n        color = ref_img[valid_points]\n        xyz_ref = np.matmul(np.linalg.inv(ref_intrinsics), np.vstack((x, y, np.ones_like(x))) * depth)\n        xyz_world = np.matmul(np.linalg.inv(ref_extrinsics), np.vstack((xyz_ref, np.ones_like(x))))[:3]\n        vertexs.append(xyz_world.transpose((1, 0)))\n        vertex_colors.append((color * 255).astype(np.uint8))\n    vertexs = np.concatenate(vertexs, axis=0)\n    vertex_colors = np.concatenate(vertex_colors, axis=0)\n    vertexs = np.array([tuple(v) for v in vertexs], dtype=[('x', 'f4'), ('y', 'f4'), ('z', 'f4')])\n    vertex_colors = np.array([tuple(v) for v in vertex_colors], dtype=[('red', 'u1'), ('green', 'u1'), ('blue', 'u1')])\n    vertex_all = np.empty(len(vertexs), vertexs.dtype.descr + vertex_colors.dtype.descr)\n    for prop in vertexs.dtype.names:\n        vertex_all[prop] = vertexs[prop]\n    for prop in vertex_colors.dtype.names:\n        vertex_all[prop] = vertex_colors[prop]\n    el = PlyElement.describe(vertex_all, 'vertex')\n    pcd = PlyData([el])\n    return pcd"
        ]
    },
    {
        "func_name": "pcd_depth_filter",
        "original": "def pcd_depth_filter(scene, test_dir, save_dir, thres_view):\n    old_scene_folder = os.path.join(test_dir, scene)\n    new_scene_folder = os.path.join(save_dir, scene)\n    out_folder = os.path.join(save_dir, scene)\n    pcd = filter_depth(old_scene_folder, new_scene_folder, out_folder, thres_view)\n    return pcd",
        "mutated": [
            "def pcd_depth_filter(scene, test_dir, save_dir, thres_view):\n    if False:\n        i = 10\n    old_scene_folder = os.path.join(test_dir, scene)\n    new_scene_folder = os.path.join(save_dir, scene)\n    out_folder = os.path.join(save_dir, scene)\n    pcd = filter_depth(old_scene_folder, new_scene_folder, out_folder, thres_view)\n    return pcd",
            "def pcd_depth_filter(scene, test_dir, save_dir, thres_view):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    old_scene_folder = os.path.join(test_dir, scene)\n    new_scene_folder = os.path.join(save_dir, scene)\n    out_folder = os.path.join(save_dir, scene)\n    pcd = filter_depth(old_scene_folder, new_scene_folder, out_folder, thres_view)\n    return pcd",
            "def pcd_depth_filter(scene, test_dir, save_dir, thres_view):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    old_scene_folder = os.path.join(test_dir, scene)\n    new_scene_folder = os.path.join(save_dir, scene)\n    out_folder = os.path.join(save_dir, scene)\n    pcd = filter_depth(old_scene_folder, new_scene_folder, out_folder, thres_view)\n    return pcd",
            "def pcd_depth_filter(scene, test_dir, save_dir, thres_view):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    old_scene_folder = os.path.join(test_dir, scene)\n    new_scene_folder = os.path.join(save_dir, scene)\n    out_folder = os.path.join(save_dir, scene)\n    pcd = filter_depth(old_scene_folder, new_scene_folder, out_folder, thres_view)\n    return pcd",
            "def pcd_depth_filter(scene, test_dir, save_dir, thres_view):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    old_scene_folder = os.path.join(test_dir, scene)\n    new_scene_folder = os.path.join(save_dir, scene)\n    out_folder = os.path.join(save_dir, scene)\n    pcd = filter_depth(old_scene_folder, new_scene_folder, out_folder, thres_view)\n    return pcd"
        ]
    }
]