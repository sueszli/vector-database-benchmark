[
    {
        "func_name": "move",
        "original": "def move(piece, move: Move, rotnum):\n    newpiece = copy.deepcopy(piece)\n    match move:\n        case Move.DOWN:\n            for p in newpiece:\n                p[0] += 1\n        case Move.RIGHT:\n            for p in newpiece:\n                p[1] += 1\n        case Move.LEFT:\n            for p in newpiece:\n                p[1] -= 1\n        case Move.ROTATE:\n            for i in range(4):\n                newpiece[i][0] += rotations[rotnum][i][0]\n                newpiece[i][1] += rotations[rotnum][i][1]\n            rotnum += 1\n            if rotnum == 4:\n                rotnum = 0\n    rows = [p[0] for p in newpiece]\n    cols = [p[1] for p in newpiece]\n    if max(rows) > 9 or max(cols) > 9 or min(cols) < 0 or (min(rows) < 0):\n        return (piece, rotnum)\n    else:\n        return (newpiece, rotnum)",
        "mutated": [
            "def move(piece, move: Move, rotnum):\n    if False:\n        i = 10\n    newpiece = copy.deepcopy(piece)\n    match move:\n        case Move.DOWN:\n            for p in newpiece:\n                p[0] += 1\n        case Move.RIGHT:\n            for p in newpiece:\n                p[1] += 1\n        case Move.LEFT:\n            for p in newpiece:\n                p[1] -= 1\n        case Move.ROTATE:\n            for i in range(4):\n                newpiece[i][0] += rotations[rotnum][i][0]\n                newpiece[i][1] += rotations[rotnum][i][1]\n            rotnum += 1\n            if rotnum == 4:\n                rotnum = 0\n    rows = [p[0] for p in newpiece]\n    cols = [p[1] for p in newpiece]\n    if max(rows) > 9 or max(cols) > 9 or min(cols) < 0 or (min(rows) < 0):\n        return (piece, rotnum)\n    else:\n        return (newpiece, rotnum)",
            "def move(piece, move: Move, rotnum):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    newpiece = copy.deepcopy(piece)\n    match move:\n        case Move.DOWN:\n            for p in newpiece:\n                p[0] += 1\n        case Move.RIGHT:\n            for p in newpiece:\n                p[1] += 1\n        case Move.LEFT:\n            for p in newpiece:\n                p[1] -= 1\n        case Move.ROTATE:\n            for i in range(4):\n                newpiece[i][0] += rotations[rotnum][i][0]\n                newpiece[i][1] += rotations[rotnum][i][1]\n            rotnum += 1\n            if rotnum == 4:\n                rotnum = 0\n    rows = [p[0] for p in newpiece]\n    cols = [p[1] for p in newpiece]\n    if max(rows) > 9 or max(cols) > 9 or min(cols) < 0 or (min(rows) < 0):\n        return (piece, rotnum)\n    else:\n        return (newpiece, rotnum)",
            "def move(piece, move: Move, rotnum):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    newpiece = copy.deepcopy(piece)\n    match move:\n        case Move.DOWN:\n            for p in newpiece:\n                p[0] += 1\n        case Move.RIGHT:\n            for p in newpiece:\n                p[1] += 1\n        case Move.LEFT:\n            for p in newpiece:\n                p[1] -= 1\n        case Move.ROTATE:\n            for i in range(4):\n                newpiece[i][0] += rotations[rotnum][i][0]\n                newpiece[i][1] += rotations[rotnum][i][1]\n            rotnum += 1\n            if rotnum == 4:\n                rotnum = 0\n    rows = [p[0] for p in newpiece]\n    cols = [p[1] for p in newpiece]\n    if max(rows) > 9 or max(cols) > 9 or min(cols) < 0 or (min(rows) < 0):\n        return (piece, rotnum)\n    else:\n        return (newpiece, rotnum)",
            "def move(piece, move: Move, rotnum):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    newpiece = copy.deepcopy(piece)\n    match move:\n        case Move.DOWN:\n            for p in newpiece:\n                p[0] += 1\n        case Move.RIGHT:\n            for p in newpiece:\n                p[1] += 1\n        case Move.LEFT:\n            for p in newpiece:\n                p[1] -= 1\n        case Move.ROTATE:\n            for i in range(4):\n                newpiece[i][0] += rotations[rotnum][i][0]\n                newpiece[i][1] += rotations[rotnum][i][1]\n            rotnum += 1\n            if rotnum == 4:\n                rotnum = 0\n    rows = [p[0] for p in newpiece]\n    cols = [p[1] for p in newpiece]\n    if max(rows) > 9 or max(cols) > 9 or min(cols) < 0 or (min(rows) < 0):\n        return (piece, rotnum)\n    else:\n        return (newpiece, rotnum)",
            "def move(piece, move: Move, rotnum):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    newpiece = copy.deepcopy(piece)\n    match move:\n        case Move.DOWN:\n            for p in newpiece:\n                p[0] += 1\n        case Move.RIGHT:\n            for p in newpiece:\n                p[1] += 1\n        case Move.LEFT:\n            for p in newpiece:\n                p[1] -= 1\n        case Move.ROTATE:\n            for i in range(4):\n                newpiece[i][0] += rotations[rotnum][i][0]\n                newpiece[i][1] += rotations[rotnum][i][1]\n            rotnum += 1\n            if rotnum == 4:\n                rotnum = 0\n    rows = [p[0] for p in newpiece]\n    cols = [p[1] for p in newpiece]\n    if max(rows) > 9 or max(cols) > 9 or min(cols) < 0 or (min(rows) < 0):\n        return (piece, rotnum)\n    else:\n        return (newpiece, rotnum)"
        ]
    },
    {
        "func_name": "print_screen",
        "original": "def print_screen(screen, piece):\n    sc = copy.deepcopy(screen)\n    for p in piece:\n        sc[p[0]][p[1]] = pixel_busy\n    for row in sc:\n        print(''.join(row))",
        "mutated": [
            "def print_screen(screen, piece):\n    if False:\n        i = 10\n    sc = copy.deepcopy(screen)\n    for p in piece:\n        sc[p[0]][p[1]] = pixel_busy\n    for row in sc:\n        print(''.join(row))",
            "def print_screen(screen, piece):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    sc = copy.deepcopy(screen)\n    for p in piece:\n        sc[p[0]][p[1]] = pixel_busy\n    for row in sc:\n        print(''.join(row))",
            "def print_screen(screen, piece):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    sc = copy.deepcopy(screen)\n    for p in piece:\n        sc[p[0]][p[1]] = pixel_busy\n    for row in sc:\n        print(''.join(row))",
            "def print_screen(screen, piece):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    sc = copy.deepcopy(screen)\n    for p in piece:\n        sc[p[0]][p[1]] = pixel_busy\n    for row in sc:\n        print(''.join(row))",
            "def print_screen(screen, piece):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    sc = copy.deepcopy(screen)\n    for p in piece:\n        sc[p[0]][p[1]] = pixel_busy\n    for row in sc:\n        print(''.join(row))"
        ]
    },
    {
        "func_name": "tetris",
        "original": "def tetris():\n    from enum import Enum\n    import keyboard\n    import os\n    import copy\n    pixel = '\ud83d\udd32'\n    pixel_busy = '\ud83d\udd33'\n    rotnum = 0\n\n    class Move(Enum):\n        DOWN = 1\n        RIGHT = 2\n        LEFT = 3\n        ROTATE = 4\n    rotations = (((0, 2), (-1, 1), (0, 0), (1, -1)), ((2, 0), (1, 1), (0, 0), (-1, -1)), ((0, -2), (1, -1), (0, 0), (-1, 1)), ((-1, 0), (0, -1), (1, 0), (2, 1)))\n\n    def move(piece, move: Move, rotnum):\n        newpiece = copy.deepcopy(piece)\n        match move:\n            case Move.DOWN:\n                for p in newpiece:\n                    p[0] += 1\n            case Move.RIGHT:\n                for p in newpiece:\n                    p[1] += 1\n            case Move.LEFT:\n                for p in newpiece:\n                    p[1] -= 1\n            case Move.ROTATE:\n                for i in range(4):\n                    newpiece[i][0] += rotations[rotnum][i][0]\n                    newpiece[i][1] += rotations[rotnum][i][1]\n                rotnum += 1\n                if rotnum == 4:\n                    rotnum = 0\n        rows = [p[0] for p in newpiece]\n        cols = [p[1] for p in newpiece]\n        if max(rows) > 9 or max(cols) > 9 or min(cols) < 0 or (min(rows) < 0):\n            return (piece, rotnum)\n        else:\n            return (newpiece, rotnum)\n\n    def print_screen(screen, piece):\n        sc = copy.deepcopy(screen)\n        for p in piece:\n            sc[p[0]][p[1]] = pixel_busy\n        for row in sc:\n            print(''.join(row))\n    row = []\n    for _ in range(10):\n        row.append(pixel)\n    screen = []\n    for _ in range(10):\n        screen.append(row.copy())\n    cleanScreen = screen.copy()\n    tetris_piece = [[0, 0], [1, 0], [1, 1], [1, 2]]\n    newpiece = tetris_piece\n    while True:\n        event = keyboard.read_event()\n        if event.name == 'esc':\n            break\n        elif event.event_type == keyboard.KEY_DOWN:\n            if event.name == 'left':\n                (newpiece, rotnum) = move(newpiece, Move.LEFT, rotnum)\n            if event.name == 'right':\n                (newpiece, rotnum) = move(newpiece, Move.RIGHT, rotnum)\n            if event.name == 'down':\n                (newpiece, rotnum) = move(newpiece, Move.DOWN, rotnum)\n            if event.name == 'space':\n                (newpiece, rotnum) = move(newpiece, Move.ROTATE, rotnum)\n            os.system('clear')\n            print_screen(cleanScreen, newpiece)",
        "mutated": [
            "def tetris():\n    if False:\n        i = 10\n    from enum import Enum\n    import keyboard\n    import os\n    import copy\n    pixel = '\ud83d\udd32'\n    pixel_busy = '\ud83d\udd33'\n    rotnum = 0\n\n    class Move(Enum):\n        DOWN = 1\n        RIGHT = 2\n        LEFT = 3\n        ROTATE = 4\n    rotations = (((0, 2), (-1, 1), (0, 0), (1, -1)), ((2, 0), (1, 1), (0, 0), (-1, -1)), ((0, -2), (1, -1), (0, 0), (-1, 1)), ((-1, 0), (0, -1), (1, 0), (2, 1)))\n\n    def move(piece, move: Move, rotnum):\n        newpiece = copy.deepcopy(piece)\n        match move:\n            case Move.DOWN:\n                for p in newpiece:\n                    p[0] += 1\n            case Move.RIGHT:\n                for p in newpiece:\n                    p[1] += 1\n            case Move.LEFT:\n                for p in newpiece:\n                    p[1] -= 1\n            case Move.ROTATE:\n                for i in range(4):\n                    newpiece[i][0] += rotations[rotnum][i][0]\n                    newpiece[i][1] += rotations[rotnum][i][1]\n                rotnum += 1\n                if rotnum == 4:\n                    rotnum = 0\n        rows = [p[0] for p in newpiece]\n        cols = [p[1] for p in newpiece]\n        if max(rows) > 9 or max(cols) > 9 or min(cols) < 0 or (min(rows) < 0):\n            return (piece, rotnum)\n        else:\n            return (newpiece, rotnum)\n\n    def print_screen(screen, piece):\n        sc = copy.deepcopy(screen)\n        for p in piece:\n            sc[p[0]][p[1]] = pixel_busy\n        for row in sc:\n            print(''.join(row))\n    row = []\n    for _ in range(10):\n        row.append(pixel)\n    screen = []\n    for _ in range(10):\n        screen.append(row.copy())\n    cleanScreen = screen.copy()\n    tetris_piece = [[0, 0], [1, 0], [1, 1], [1, 2]]\n    newpiece = tetris_piece\n    while True:\n        event = keyboard.read_event()\n        if event.name == 'esc':\n            break\n        elif event.event_type == keyboard.KEY_DOWN:\n            if event.name == 'left':\n                (newpiece, rotnum) = move(newpiece, Move.LEFT, rotnum)\n            if event.name == 'right':\n                (newpiece, rotnum) = move(newpiece, Move.RIGHT, rotnum)\n            if event.name == 'down':\n                (newpiece, rotnum) = move(newpiece, Move.DOWN, rotnum)\n            if event.name == 'space':\n                (newpiece, rotnum) = move(newpiece, Move.ROTATE, rotnum)\n            os.system('clear')\n            print_screen(cleanScreen, newpiece)",
            "def tetris():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    from enum import Enum\n    import keyboard\n    import os\n    import copy\n    pixel = '\ud83d\udd32'\n    pixel_busy = '\ud83d\udd33'\n    rotnum = 0\n\n    class Move(Enum):\n        DOWN = 1\n        RIGHT = 2\n        LEFT = 3\n        ROTATE = 4\n    rotations = (((0, 2), (-1, 1), (0, 0), (1, -1)), ((2, 0), (1, 1), (0, 0), (-1, -1)), ((0, -2), (1, -1), (0, 0), (-1, 1)), ((-1, 0), (0, -1), (1, 0), (2, 1)))\n\n    def move(piece, move: Move, rotnum):\n        newpiece = copy.deepcopy(piece)\n        match move:\n            case Move.DOWN:\n                for p in newpiece:\n                    p[0] += 1\n            case Move.RIGHT:\n                for p in newpiece:\n                    p[1] += 1\n            case Move.LEFT:\n                for p in newpiece:\n                    p[1] -= 1\n            case Move.ROTATE:\n                for i in range(4):\n                    newpiece[i][0] += rotations[rotnum][i][0]\n                    newpiece[i][1] += rotations[rotnum][i][1]\n                rotnum += 1\n                if rotnum == 4:\n                    rotnum = 0\n        rows = [p[0] for p in newpiece]\n        cols = [p[1] for p in newpiece]\n        if max(rows) > 9 or max(cols) > 9 or min(cols) < 0 or (min(rows) < 0):\n            return (piece, rotnum)\n        else:\n            return (newpiece, rotnum)\n\n    def print_screen(screen, piece):\n        sc = copy.deepcopy(screen)\n        for p in piece:\n            sc[p[0]][p[1]] = pixel_busy\n        for row in sc:\n            print(''.join(row))\n    row = []\n    for _ in range(10):\n        row.append(pixel)\n    screen = []\n    for _ in range(10):\n        screen.append(row.copy())\n    cleanScreen = screen.copy()\n    tetris_piece = [[0, 0], [1, 0], [1, 1], [1, 2]]\n    newpiece = tetris_piece\n    while True:\n        event = keyboard.read_event()\n        if event.name == 'esc':\n            break\n        elif event.event_type == keyboard.KEY_DOWN:\n            if event.name == 'left':\n                (newpiece, rotnum) = move(newpiece, Move.LEFT, rotnum)\n            if event.name == 'right':\n                (newpiece, rotnum) = move(newpiece, Move.RIGHT, rotnum)\n            if event.name == 'down':\n                (newpiece, rotnum) = move(newpiece, Move.DOWN, rotnum)\n            if event.name == 'space':\n                (newpiece, rotnum) = move(newpiece, Move.ROTATE, rotnum)\n            os.system('clear')\n            print_screen(cleanScreen, newpiece)",
            "def tetris():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    from enum import Enum\n    import keyboard\n    import os\n    import copy\n    pixel = '\ud83d\udd32'\n    pixel_busy = '\ud83d\udd33'\n    rotnum = 0\n\n    class Move(Enum):\n        DOWN = 1\n        RIGHT = 2\n        LEFT = 3\n        ROTATE = 4\n    rotations = (((0, 2), (-1, 1), (0, 0), (1, -1)), ((2, 0), (1, 1), (0, 0), (-1, -1)), ((0, -2), (1, -1), (0, 0), (-1, 1)), ((-1, 0), (0, -1), (1, 0), (2, 1)))\n\n    def move(piece, move: Move, rotnum):\n        newpiece = copy.deepcopy(piece)\n        match move:\n            case Move.DOWN:\n                for p in newpiece:\n                    p[0] += 1\n            case Move.RIGHT:\n                for p in newpiece:\n                    p[1] += 1\n            case Move.LEFT:\n                for p in newpiece:\n                    p[1] -= 1\n            case Move.ROTATE:\n                for i in range(4):\n                    newpiece[i][0] += rotations[rotnum][i][0]\n                    newpiece[i][1] += rotations[rotnum][i][1]\n                rotnum += 1\n                if rotnum == 4:\n                    rotnum = 0\n        rows = [p[0] for p in newpiece]\n        cols = [p[1] for p in newpiece]\n        if max(rows) > 9 or max(cols) > 9 or min(cols) < 0 or (min(rows) < 0):\n            return (piece, rotnum)\n        else:\n            return (newpiece, rotnum)\n\n    def print_screen(screen, piece):\n        sc = copy.deepcopy(screen)\n        for p in piece:\n            sc[p[0]][p[1]] = pixel_busy\n        for row in sc:\n            print(''.join(row))\n    row = []\n    for _ in range(10):\n        row.append(pixel)\n    screen = []\n    for _ in range(10):\n        screen.append(row.copy())\n    cleanScreen = screen.copy()\n    tetris_piece = [[0, 0], [1, 0], [1, 1], [1, 2]]\n    newpiece = tetris_piece\n    while True:\n        event = keyboard.read_event()\n        if event.name == 'esc':\n            break\n        elif event.event_type == keyboard.KEY_DOWN:\n            if event.name == 'left':\n                (newpiece, rotnum) = move(newpiece, Move.LEFT, rotnum)\n            if event.name == 'right':\n                (newpiece, rotnum) = move(newpiece, Move.RIGHT, rotnum)\n            if event.name == 'down':\n                (newpiece, rotnum) = move(newpiece, Move.DOWN, rotnum)\n            if event.name == 'space':\n                (newpiece, rotnum) = move(newpiece, Move.ROTATE, rotnum)\n            os.system('clear')\n            print_screen(cleanScreen, newpiece)",
            "def tetris():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    from enum import Enum\n    import keyboard\n    import os\n    import copy\n    pixel = '\ud83d\udd32'\n    pixel_busy = '\ud83d\udd33'\n    rotnum = 0\n\n    class Move(Enum):\n        DOWN = 1\n        RIGHT = 2\n        LEFT = 3\n        ROTATE = 4\n    rotations = (((0, 2), (-1, 1), (0, 0), (1, -1)), ((2, 0), (1, 1), (0, 0), (-1, -1)), ((0, -2), (1, -1), (0, 0), (-1, 1)), ((-1, 0), (0, -1), (1, 0), (2, 1)))\n\n    def move(piece, move: Move, rotnum):\n        newpiece = copy.deepcopy(piece)\n        match move:\n            case Move.DOWN:\n                for p in newpiece:\n                    p[0] += 1\n            case Move.RIGHT:\n                for p in newpiece:\n                    p[1] += 1\n            case Move.LEFT:\n                for p in newpiece:\n                    p[1] -= 1\n            case Move.ROTATE:\n                for i in range(4):\n                    newpiece[i][0] += rotations[rotnum][i][0]\n                    newpiece[i][1] += rotations[rotnum][i][1]\n                rotnum += 1\n                if rotnum == 4:\n                    rotnum = 0\n        rows = [p[0] for p in newpiece]\n        cols = [p[1] for p in newpiece]\n        if max(rows) > 9 or max(cols) > 9 or min(cols) < 0 or (min(rows) < 0):\n            return (piece, rotnum)\n        else:\n            return (newpiece, rotnum)\n\n    def print_screen(screen, piece):\n        sc = copy.deepcopy(screen)\n        for p in piece:\n            sc[p[0]][p[1]] = pixel_busy\n        for row in sc:\n            print(''.join(row))\n    row = []\n    for _ in range(10):\n        row.append(pixel)\n    screen = []\n    for _ in range(10):\n        screen.append(row.copy())\n    cleanScreen = screen.copy()\n    tetris_piece = [[0, 0], [1, 0], [1, 1], [1, 2]]\n    newpiece = tetris_piece\n    while True:\n        event = keyboard.read_event()\n        if event.name == 'esc':\n            break\n        elif event.event_type == keyboard.KEY_DOWN:\n            if event.name == 'left':\n                (newpiece, rotnum) = move(newpiece, Move.LEFT, rotnum)\n            if event.name == 'right':\n                (newpiece, rotnum) = move(newpiece, Move.RIGHT, rotnum)\n            if event.name == 'down':\n                (newpiece, rotnum) = move(newpiece, Move.DOWN, rotnum)\n            if event.name == 'space':\n                (newpiece, rotnum) = move(newpiece, Move.ROTATE, rotnum)\n            os.system('clear')\n            print_screen(cleanScreen, newpiece)",
            "def tetris():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    from enum import Enum\n    import keyboard\n    import os\n    import copy\n    pixel = '\ud83d\udd32'\n    pixel_busy = '\ud83d\udd33'\n    rotnum = 0\n\n    class Move(Enum):\n        DOWN = 1\n        RIGHT = 2\n        LEFT = 3\n        ROTATE = 4\n    rotations = (((0, 2), (-1, 1), (0, 0), (1, -1)), ((2, 0), (1, 1), (0, 0), (-1, -1)), ((0, -2), (1, -1), (0, 0), (-1, 1)), ((-1, 0), (0, -1), (1, 0), (2, 1)))\n\n    def move(piece, move: Move, rotnum):\n        newpiece = copy.deepcopy(piece)\n        match move:\n            case Move.DOWN:\n                for p in newpiece:\n                    p[0] += 1\n            case Move.RIGHT:\n                for p in newpiece:\n                    p[1] += 1\n            case Move.LEFT:\n                for p in newpiece:\n                    p[1] -= 1\n            case Move.ROTATE:\n                for i in range(4):\n                    newpiece[i][0] += rotations[rotnum][i][0]\n                    newpiece[i][1] += rotations[rotnum][i][1]\n                rotnum += 1\n                if rotnum == 4:\n                    rotnum = 0\n        rows = [p[0] for p in newpiece]\n        cols = [p[1] for p in newpiece]\n        if max(rows) > 9 or max(cols) > 9 or min(cols) < 0 or (min(rows) < 0):\n            return (piece, rotnum)\n        else:\n            return (newpiece, rotnum)\n\n    def print_screen(screen, piece):\n        sc = copy.deepcopy(screen)\n        for p in piece:\n            sc[p[0]][p[1]] = pixel_busy\n        for row in sc:\n            print(''.join(row))\n    row = []\n    for _ in range(10):\n        row.append(pixel)\n    screen = []\n    for _ in range(10):\n        screen.append(row.copy())\n    cleanScreen = screen.copy()\n    tetris_piece = [[0, 0], [1, 0], [1, 1], [1, 2]]\n    newpiece = tetris_piece\n    while True:\n        event = keyboard.read_event()\n        if event.name == 'esc':\n            break\n        elif event.event_type == keyboard.KEY_DOWN:\n            if event.name == 'left':\n                (newpiece, rotnum) = move(newpiece, Move.LEFT, rotnum)\n            if event.name == 'right':\n                (newpiece, rotnum) = move(newpiece, Move.RIGHT, rotnum)\n            if event.name == 'down':\n                (newpiece, rotnum) = move(newpiece, Move.DOWN, rotnum)\n            if event.name == 'space':\n                (newpiece, rotnum) = move(newpiece, Move.ROTATE, rotnum)\n            os.system('clear')\n            print_screen(cleanScreen, newpiece)"
        ]
    }
]