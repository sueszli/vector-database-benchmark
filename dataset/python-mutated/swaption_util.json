[
    {
        "func_name": "discount_factors_and_bond_prices_from_samples",
        "original": "def discount_factors_and_bond_prices_from_samples(expiries: types.RealTensor, payment_times: types.RealTensor, sample_discount_curve_paths_fn: Callable[..., Tuple[types.RealTensor, types.RealTensor, types.RealTensor]], num_samples: types.IntTensor, times: types.RealTensor=None, curve_times: types.RealTensor=None, dtype: tf.DType=None) -> Tuple[types.RealTensor, types.RealTensor]:\n    \"\"\"Utility function to compute the discount factors and the bond prices.\n\n  Args:\n    expiries: A real `Tensor` of any shape and dtype. The time to expiration of\n      the swaptions. The shape of this input determines the number (and shape)\n      of swaptions to be priced and the shape of the output - e.g. if there are\n      two swaptions, and there are 11 payment dates for each swaption, then the\n      shape of `expiries` is [2, 11], with entries repeated along the second\n      axis.\n    payment_times: A real `Tensor` of same dtype and compatible shape with\n      `expiries` - e.g. if there are two swaptions, and there are 11 payment\n      dates for each swaption, then the shape of `payment_times` should be [2,\n      11]\n    sample_discount_curve_paths_fn: Callable which takes the following args:\n      1) times: Rank 1 `Tensor` of positive real values, specifying the times at\n        which the path points are to be evaluated.\n      2) curve_times: Rank 1 `Tensor` of positive real values, specifying the\n        maturities at which the discount curve is to be computed at each\n        simulation time.\n      3) num_samples: Positive scalar integer specifying the number of paths to\n        draw.\n      Returns three `Tensor`s, the first being a N-D tensor of shape\n        `model_batch_shape + [num_samples, m, k, d]` containing the simulated\n        zero coupon bond curves, the second being a `Tensor` of shape\n        `model_batch_shape + [num_samples, k, d]` containing the simulated\n        short rate paths, the third `Tensor` of shape\n        `model_batch_shape + [num_samples, k, d]` containing the simulated path\n        discount factors. Here, m is the size of `curve_times`, k is the size\n        of `times`, d is the dimensionality of the paths and\n        `model_batch_shape` is shape of the batch of independent HJM models.\n    num_samples: Positive scalar `int32` `Tensor`. The number of simulation\n      paths during Monte-Carlo valuation.\n    times: An optional rank 1 `Tensor` of increasing positive real values. The\n      times at which Monte Carlo simulations are performed.\n      Default value: `None`.\n    curve_times: An optional rank 1 `Tensor` of positive real values. The\n      maturities at which spot discount curve is computed during simulations.\n      Default value: `None`.\n    dtype: The default dtype to use when converting values to `Tensor`s.\n      Default value: `None` which means that default dtypes inferred by\n        TensorFlow are used.\n\n  Returns:\n    Two real tensors, `discount_factors` and `bond_prices`, both of shape\n    [num_samples] + swaption_batch_shape + [dim], where `dim` is the dimension\n    of each path (e.g for a Hull-White with two models, dim==2; while for HJM\n    dim==1 always). `swaption_batch_shape` has the same rank as `expiries.shape`\n    and its leading dimensions are broadcasted to `model_batch_shape`.\n  \"\"\"\n    if times is not None:\n        sim_times = tf.convert_to_tensor(times, dtype=dtype)\n    else:\n        sim_times = tf.reshape(expiries, shape=[-1])\n        sim_times = tf.sort(sim_times, name='sort_sim_times')\n    swaptionlet_shape = tf.shape(payment_times)\n    tau = payment_times - expiries\n    if curve_times is not None:\n        curve_times = tf.convert_to_tensor(curve_times, dtype=dtype)\n    else:\n        curve_times = tf.reshape(tau, shape=[-1])\n        (curve_times, _) = tf.unique(curve_times)\n        curve_times = tf.sort(curve_times, name='sort_curve_times')\n    (p_t_tau, r_t, discount_factors) = sample_discount_curve_paths_fn(times=sim_times, curve_times=curve_times, num_samples=num_samples)\n    dim = tf.shape(p_t_tau)[-1]\n    model_batch_shape = tf.shape(p_t_tau)[:-4]\n    model_batch_rank = p_t_tau.shape[:-4].rank\n    instr_batch_shape = tf.shape(expiries)[model_batch_rank:]\n    try:\n        swaptionlet_shape = tf.concat([model_batch_shape, instr_batch_shape], axis=0)\n        expiries = tf.broadcast_to(expiries, swaptionlet_shape)\n        tau = tf.broadcast_to(tau, swaptionlet_shape)\n    except:\n        raise ValueError('The leading dimensions of `expiries` of shape {} are not compatible with the batch shape {} of the model.'.format(expiries.shape.as_list(), p_t_tau.shape.as_list()[:-4]))\n    if discount_factors is None:\n        dt = tf.concat(axis=0, values=[[0.0], sim_times[1:] - sim_times[:-1]])\n        dt = tf.expand_dims(tf.expand_dims(dt, axis=-1), axis=0)\n        cumul_rdt = tf.transpose(utils.cumsum_using_matvec(tf.transpose(r_t * dt, perm=[0, 2, 1])), perm=[0, 2, 1])\n        discount_factors = tf.math.exp(-cumul_rdt)\n    discount_factors = tf.expand_dims(discount_factors, axis=model_batch_rank + 1)\n    discount_factors_simulated = tf.repeat(discount_factors, tf.shape(p_t_tau)[model_batch_rank + 1], axis=model_batch_rank + 1)\n    new_shape = tf.concat([model_batch_shape, [-1]], axis=0)\n    sim_time_index = tf.searchsorted(sim_times, tf.reshape(expiries, [-1]))\n    curve_time_index = tf.searchsorted(curve_times, tf.reshape(tau, [-1]))\n    sim_time_index = tf.reshape(sim_time_index, new_shape)\n    curve_time_index = tf.reshape(curve_time_index, new_shape)\n    gather_index = tf.stack([curve_time_index, sim_time_index], axis=-1)\n    discount_factors_simulated = _gather_tensor_at_swaption_payoff(discount_factors_simulated, gather_index)\n    payoff_discount_factors = tf.reshape(discount_factors_simulated, tf.concat([[num_samples], swaptionlet_shape, [dim]], axis=0))\n    p_t_tau = _gather_tensor_at_swaption_payoff(p_t_tau, gather_index)\n    payoff_bond_price = tf.reshape(p_t_tau, tf.concat([[num_samples], swaptionlet_shape, [dim]], axis=0))\n    return (payoff_discount_factors, payoff_bond_price)",
        "mutated": [
            "def discount_factors_and_bond_prices_from_samples(expiries: types.RealTensor, payment_times: types.RealTensor, sample_discount_curve_paths_fn: Callable[..., Tuple[types.RealTensor, types.RealTensor, types.RealTensor]], num_samples: types.IntTensor, times: types.RealTensor=None, curve_times: types.RealTensor=None, dtype: tf.DType=None) -> Tuple[types.RealTensor, types.RealTensor]:\n    if False:\n        i = 10\n    'Utility function to compute the discount factors and the bond prices.\\n\\n  Args:\\n    expiries: A real `Tensor` of any shape and dtype. The time to expiration of\\n      the swaptions. The shape of this input determines the number (and shape)\\n      of swaptions to be priced and the shape of the output - e.g. if there are\\n      two swaptions, and there are 11 payment dates for each swaption, then the\\n      shape of `expiries` is [2, 11], with entries repeated along the second\\n      axis.\\n    payment_times: A real `Tensor` of same dtype and compatible shape with\\n      `expiries` - e.g. if there are two swaptions, and there are 11 payment\\n      dates for each swaption, then the shape of `payment_times` should be [2,\\n      11]\\n    sample_discount_curve_paths_fn: Callable which takes the following args:\\n      1) times: Rank 1 `Tensor` of positive real values, specifying the times at\\n        which the path points are to be evaluated.\\n      2) curve_times: Rank 1 `Tensor` of positive real values, specifying the\\n        maturities at which the discount curve is to be computed at each\\n        simulation time.\\n      3) num_samples: Positive scalar integer specifying the number of paths to\\n        draw.\\n      Returns three `Tensor`s, the first being a N-D tensor of shape\\n        `model_batch_shape + [num_samples, m, k, d]` containing the simulated\\n        zero coupon bond curves, the second being a `Tensor` of shape\\n        `model_batch_shape + [num_samples, k, d]` containing the simulated\\n        short rate paths, the third `Tensor` of shape\\n        `model_batch_shape + [num_samples, k, d]` containing the simulated path\\n        discount factors. Here, m is the size of `curve_times`, k is the size\\n        of `times`, d is the dimensionality of the paths and\\n        `model_batch_shape` is shape of the batch of independent HJM models.\\n    num_samples: Positive scalar `int32` `Tensor`. The number of simulation\\n      paths during Monte-Carlo valuation.\\n    times: An optional rank 1 `Tensor` of increasing positive real values. The\\n      times at which Monte Carlo simulations are performed.\\n      Default value: `None`.\\n    curve_times: An optional rank 1 `Tensor` of positive real values. The\\n      maturities at which spot discount curve is computed during simulations.\\n      Default value: `None`.\\n    dtype: The default dtype to use when converting values to `Tensor`s.\\n      Default value: `None` which means that default dtypes inferred by\\n        TensorFlow are used.\\n\\n  Returns:\\n    Two real tensors, `discount_factors` and `bond_prices`, both of shape\\n    [num_samples] + swaption_batch_shape + [dim], where `dim` is the dimension\\n    of each path (e.g for a Hull-White with two models, dim==2; while for HJM\\n    dim==1 always). `swaption_batch_shape` has the same rank as `expiries.shape`\\n    and its leading dimensions are broadcasted to `model_batch_shape`.\\n  '\n    if times is not None:\n        sim_times = tf.convert_to_tensor(times, dtype=dtype)\n    else:\n        sim_times = tf.reshape(expiries, shape=[-1])\n        sim_times = tf.sort(sim_times, name='sort_sim_times')\n    swaptionlet_shape = tf.shape(payment_times)\n    tau = payment_times - expiries\n    if curve_times is not None:\n        curve_times = tf.convert_to_tensor(curve_times, dtype=dtype)\n    else:\n        curve_times = tf.reshape(tau, shape=[-1])\n        (curve_times, _) = tf.unique(curve_times)\n        curve_times = tf.sort(curve_times, name='sort_curve_times')\n    (p_t_tau, r_t, discount_factors) = sample_discount_curve_paths_fn(times=sim_times, curve_times=curve_times, num_samples=num_samples)\n    dim = tf.shape(p_t_tau)[-1]\n    model_batch_shape = tf.shape(p_t_tau)[:-4]\n    model_batch_rank = p_t_tau.shape[:-4].rank\n    instr_batch_shape = tf.shape(expiries)[model_batch_rank:]\n    try:\n        swaptionlet_shape = tf.concat([model_batch_shape, instr_batch_shape], axis=0)\n        expiries = tf.broadcast_to(expiries, swaptionlet_shape)\n        tau = tf.broadcast_to(tau, swaptionlet_shape)\n    except:\n        raise ValueError('The leading dimensions of `expiries` of shape {} are not compatible with the batch shape {} of the model.'.format(expiries.shape.as_list(), p_t_tau.shape.as_list()[:-4]))\n    if discount_factors is None:\n        dt = tf.concat(axis=0, values=[[0.0], sim_times[1:] - sim_times[:-1]])\n        dt = tf.expand_dims(tf.expand_dims(dt, axis=-1), axis=0)\n        cumul_rdt = tf.transpose(utils.cumsum_using_matvec(tf.transpose(r_t * dt, perm=[0, 2, 1])), perm=[0, 2, 1])\n        discount_factors = tf.math.exp(-cumul_rdt)\n    discount_factors = tf.expand_dims(discount_factors, axis=model_batch_rank + 1)\n    discount_factors_simulated = tf.repeat(discount_factors, tf.shape(p_t_tau)[model_batch_rank + 1], axis=model_batch_rank + 1)\n    new_shape = tf.concat([model_batch_shape, [-1]], axis=0)\n    sim_time_index = tf.searchsorted(sim_times, tf.reshape(expiries, [-1]))\n    curve_time_index = tf.searchsorted(curve_times, tf.reshape(tau, [-1]))\n    sim_time_index = tf.reshape(sim_time_index, new_shape)\n    curve_time_index = tf.reshape(curve_time_index, new_shape)\n    gather_index = tf.stack([curve_time_index, sim_time_index], axis=-1)\n    discount_factors_simulated = _gather_tensor_at_swaption_payoff(discount_factors_simulated, gather_index)\n    payoff_discount_factors = tf.reshape(discount_factors_simulated, tf.concat([[num_samples], swaptionlet_shape, [dim]], axis=0))\n    p_t_tau = _gather_tensor_at_swaption_payoff(p_t_tau, gather_index)\n    payoff_bond_price = tf.reshape(p_t_tau, tf.concat([[num_samples], swaptionlet_shape, [dim]], axis=0))\n    return (payoff_discount_factors, payoff_bond_price)",
            "def discount_factors_and_bond_prices_from_samples(expiries: types.RealTensor, payment_times: types.RealTensor, sample_discount_curve_paths_fn: Callable[..., Tuple[types.RealTensor, types.RealTensor, types.RealTensor]], num_samples: types.IntTensor, times: types.RealTensor=None, curve_times: types.RealTensor=None, dtype: tf.DType=None) -> Tuple[types.RealTensor, types.RealTensor]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Utility function to compute the discount factors and the bond prices.\\n\\n  Args:\\n    expiries: A real `Tensor` of any shape and dtype. The time to expiration of\\n      the swaptions. The shape of this input determines the number (and shape)\\n      of swaptions to be priced and the shape of the output - e.g. if there are\\n      two swaptions, and there are 11 payment dates for each swaption, then the\\n      shape of `expiries` is [2, 11], with entries repeated along the second\\n      axis.\\n    payment_times: A real `Tensor` of same dtype and compatible shape with\\n      `expiries` - e.g. if there are two swaptions, and there are 11 payment\\n      dates for each swaption, then the shape of `payment_times` should be [2,\\n      11]\\n    sample_discount_curve_paths_fn: Callable which takes the following args:\\n      1) times: Rank 1 `Tensor` of positive real values, specifying the times at\\n        which the path points are to be evaluated.\\n      2) curve_times: Rank 1 `Tensor` of positive real values, specifying the\\n        maturities at which the discount curve is to be computed at each\\n        simulation time.\\n      3) num_samples: Positive scalar integer specifying the number of paths to\\n        draw.\\n      Returns three `Tensor`s, the first being a N-D tensor of shape\\n        `model_batch_shape + [num_samples, m, k, d]` containing the simulated\\n        zero coupon bond curves, the second being a `Tensor` of shape\\n        `model_batch_shape + [num_samples, k, d]` containing the simulated\\n        short rate paths, the third `Tensor` of shape\\n        `model_batch_shape + [num_samples, k, d]` containing the simulated path\\n        discount factors. Here, m is the size of `curve_times`, k is the size\\n        of `times`, d is the dimensionality of the paths and\\n        `model_batch_shape` is shape of the batch of independent HJM models.\\n    num_samples: Positive scalar `int32` `Tensor`. The number of simulation\\n      paths during Monte-Carlo valuation.\\n    times: An optional rank 1 `Tensor` of increasing positive real values. The\\n      times at which Monte Carlo simulations are performed.\\n      Default value: `None`.\\n    curve_times: An optional rank 1 `Tensor` of positive real values. The\\n      maturities at which spot discount curve is computed during simulations.\\n      Default value: `None`.\\n    dtype: The default dtype to use when converting values to `Tensor`s.\\n      Default value: `None` which means that default dtypes inferred by\\n        TensorFlow are used.\\n\\n  Returns:\\n    Two real tensors, `discount_factors` and `bond_prices`, both of shape\\n    [num_samples] + swaption_batch_shape + [dim], where `dim` is the dimension\\n    of each path (e.g for a Hull-White with two models, dim==2; while for HJM\\n    dim==1 always). `swaption_batch_shape` has the same rank as `expiries.shape`\\n    and its leading dimensions are broadcasted to `model_batch_shape`.\\n  '\n    if times is not None:\n        sim_times = tf.convert_to_tensor(times, dtype=dtype)\n    else:\n        sim_times = tf.reshape(expiries, shape=[-1])\n        sim_times = tf.sort(sim_times, name='sort_sim_times')\n    swaptionlet_shape = tf.shape(payment_times)\n    tau = payment_times - expiries\n    if curve_times is not None:\n        curve_times = tf.convert_to_tensor(curve_times, dtype=dtype)\n    else:\n        curve_times = tf.reshape(tau, shape=[-1])\n        (curve_times, _) = tf.unique(curve_times)\n        curve_times = tf.sort(curve_times, name='sort_curve_times')\n    (p_t_tau, r_t, discount_factors) = sample_discount_curve_paths_fn(times=sim_times, curve_times=curve_times, num_samples=num_samples)\n    dim = tf.shape(p_t_tau)[-1]\n    model_batch_shape = tf.shape(p_t_tau)[:-4]\n    model_batch_rank = p_t_tau.shape[:-4].rank\n    instr_batch_shape = tf.shape(expiries)[model_batch_rank:]\n    try:\n        swaptionlet_shape = tf.concat([model_batch_shape, instr_batch_shape], axis=0)\n        expiries = tf.broadcast_to(expiries, swaptionlet_shape)\n        tau = tf.broadcast_to(tau, swaptionlet_shape)\n    except:\n        raise ValueError('The leading dimensions of `expiries` of shape {} are not compatible with the batch shape {} of the model.'.format(expiries.shape.as_list(), p_t_tau.shape.as_list()[:-4]))\n    if discount_factors is None:\n        dt = tf.concat(axis=0, values=[[0.0], sim_times[1:] - sim_times[:-1]])\n        dt = tf.expand_dims(tf.expand_dims(dt, axis=-1), axis=0)\n        cumul_rdt = tf.transpose(utils.cumsum_using_matvec(tf.transpose(r_t * dt, perm=[0, 2, 1])), perm=[0, 2, 1])\n        discount_factors = tf.math.exp(-cumul_rdt)\n    discount_factors = tf.expand_dims(discount_factors, axis=model_batch_rank + 1)\n    discount_factors_simulated = tf.repeat(discount_factors, tf.shape(p_t_tau)[model_batch_rank + 1], axis=model_batch_rank + 1)\n    new_shape = tf.concat([model_batch_shape, [-1]], axis=0)\n    sim_time_index = tf.searchsorted(sim_times, tf.reshape(expiries, [-1]))\n    curve_time_index = tf.searchsorted(curve_times, tf.reshape(tau, [-1]))\n    sim_time_index = tf.reshape(sim_time_index, new_shape)\n    curve_time_index = tf.reshape(curve_time_index, new_shape)\n    gather_index = tf.stack([curve_time_index, sim_time_index], axis=-1)\n    discount_factors_simulated = _gather_tensor_at_swaption_payoff(discount_factors_simulated, gather_index)\n    payoff_discount_factors = tf.reshape(discount_factors_simulated, tf.concat([[num_samples], swaptionlet_shape, [dim]], axis=0))\n    p_t_tau = _gather_tensor_at_swaption_payoff(p_t_tau, gather_index)\n    payoff_bond_price = tf.reshape(p_t_tau, tf.concat([[num_samples], swaptionlet_shape, [dim]], axis=0))\n    return (payoff_discount_factors, payoff_bond_price)",
            "def discount_factors_and_bond_prices_from_samples(expiries: types.RealTensor, payment_times: types.RealTensor, sample_discount_curve_paths_fn: Callable[..., Tuple[types.RealTensor, types.RealTensor, types.RealTensor]], num_samples: types.IntTensor, times: types.RealTensor=None, curve_times: types.RealTensor=None, dtype: tf.DType=None) -> Tuple[types.RealTensor, types.RealTensor]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Utility function to compute the discount factors and the bond prices.\\n\\n  Args:\\n    expiries: A real `Tensor` of any shape and dtype. The time to expiration of\\n      the swaptions. The shape of this input determines the number (and shape)\\n      of swaptions to be priced and the shape of the output - e.g. if there are\\n      two swaptions, and there are 11 payment dates for each swaption, then the\\n      shape of `expiries` is [2, 11], with entries repeated along the second\\n      axis.\\n    payment_times: A real `Tensor` of same dtype and compatible shape with\\n      `expiries` - e.g. if there are two swaptions, and there are 11 payment\\n      dates for each swaption, then the shape of `payment_times` should be [2,\\n      11]\\n    sample_discount_curve_paths_fn: Callable which takes the following args:\\n      1) times: Rank 1 `Tensor` of positive real values, specifying the times at\\n        which the path points are to be evaluated.\\n      2) curve_times: Rank 1 `Tensor` of positive real values, specifying the\\n        maturities at which the discount curve is to be computed at each\\n        simulation time.\\n      3) num_samples: Positive scalar integer specifying the number of paths to\\n        draw.\\n      Returns three `Tensor`s, the first being a N-D tensor of shape\\n        `model_batch_shape + [num_samples, m, k, d]` containing the simulated\\n        zero coupon bond curves, the second being a `Tensor` of shape\\n        `model_batch_shape + [num_samples, k, d]` containing the simulated\\n        short rate paths, the third `Tensor` of shape\\n        `model_batch_shape + [num_samples, k, d]` containing the simulated path\\n        discount factors. Here, m is the size of `curve_times`, k is the size\\n        of `times`, d is the dimensionality of the paths and\\n        `model_batch_shape` is shape of the batch of independent HJM models.\\n    num_samples: Positive scalar `int32` `Tensor`. The number of simulation\\n      paths during Monte-Carlo valuation.\\n    times: An optional rank 1 `Tensor` of increasing positive real values. The\\n      times at which Monte Carlo simulations are performed.\\n      Default value: `None`.\\n    curve_times: An optional rank 1 `Tensor` of positive real values. The\\n      maturities at which spot discount curve is computed during simulations.\\n      Default value: `None`.\\n    dtype: The default dtype to use when converting values to `Tensor`s.\\n      Default value: `None` which means that default dtypes inferred by\\n        TensorFlow are used.\\n\\n  Returns:\\n    Two real tensors, `discount_factors` and `bond_prices`, both of shape\\n    [num_samples] + swaption_batch_shape + [dim], where `dim` is the dimension\\n    of each path (e.g for a Hull-White with two models, dim==2; while for HJM\\n    dim==1 always). `swaption_batch_shape` has the same rank as `expiries.shape`\\n    and its leading dimensions are broadcasted to `model_batch_shape`.\\n  '\n    if times is not None:\n        sim_times = tf.convert_to_tensor(times, dtype=dtype)\n    else:\n        sim_times = tf.reshape(expiries, shape=[-1])\n        sim_times = tf.sort(sim_times, name='sort_sim_times')\n    swaptionlet_shape = tf.shape(payment_times)\n    tau = payment_times - expiries\n    if curve_times is not None:\n        curve_times = tf.convert_to_tensor(curve_times, dtype=dtype)\n    else:\n        curve_times = tf.reshape(tau, shape=[-1])\n        (curve_times, _) = tf.unique(curve_times)\n        curve_times = tf.sort(curve_times, name='sort_curve_times')\n    (p_t_tau, r_t, discount_factors) = sample_discount_curve_paths_fn(times=sim_times, curve_times=curve_times, num_samples=num_samples)\n    dim = tf.shape(p_t_tau)[-1]\n    model_batch_shape = tf.shape(p_t_tau)[:-4]\n    model_batch_rank = p_t_tau.shape[:-4].rank\n    instr_batch_shape = tf.shape(expiries)[model_batch_rank:]\n    try:\n        swaptionlet_shape = tf.concat([model_batch_shape, instr_batch_shape], axis=0)\n        expiries = tf.broadcast_to(expiries, swaptionlet_shape)\n        tau = tf.broadcast_to(tau, swaptionlet_shape)\n    except:\n        raise ValueError('The leading dimensions of `expiries` of shape {} are not compatible with the batch shape {} of the model.'.format(expiries.shape.as_list(), p_t_tau.shape.as_list()[:-4]))\n    if discount_factors is None:\n        dt = tf.concat(axis=0, values=[[0.0], sim_times[1:] - sim_times[:-1]])\n        dt = tf.expand_dims(tf.expand_dims(dt, axis=-1), axis=0)\n        cumul_rdt = tf.transpose(utils.cumsum_using_matvec(tf.transpose(r_t * dt, perm=[0, 2, 1])), perm=[0, 2, 1])\n        discount_factors = tf.math.exp(-cumul_rdt)\n    discount_factors = tf.expand_dims(discount_factors, axis=model_batch_rank + 1)\n    discount_factors_simulated = tf.repeat(discount_factors, tf.shape(p_t_tau)[model_batch_rank + 1], axis=model_batch_rank + 1)\n    new_shape = tf.concat([model_batch_shape, [-1]], axis=0)\n    sim_time_index = tf.searchsorted(sim_times, tf.reshape(expiries, [-1]))\n    curve_time_index = tf.searchsorted(curve_times, tf.reshape(tau, [-1]))\n    sim_time_index = tf.reshape(sim_time_index, new_shape)\n    curve_time_index = tf.reshape(curve_time_index, new_shape)\n    gather_index = tf.stack([curve_time_index, sim_time_index], axis=-1)\n    discount_factors_simulated = _gather_tensor_at_swaption_payoff(discount_factors_simulated, gather_index)\n    payoff_discount_factors = tf.reshape(discount_factors_simulated, tf.concat([[num_samples], swaptionlet_shape, [dim]], axis=0))\n    p_t_tau = _gather_tensor_at_swaption_payoff(p_t_tau, gather_index)\n    payoff_bond_price = tf.reshape(p_t_tau, tf.concat([[num_samples], swaptionlet_shape, [dim]], axis=0))\n    return (payoff_discount_factors, payoff_bond_price)",
            "def discount_factors_and_bond_prices_from_samples(expiries: types.RealTensor, payment_times: types.RealTensor, sample_discount_curve_paths_fn: Callable[..., Tuple[types.RealTensor, types.RealTensor, types.RealTensor]], num_samples: types.IntTensor, times: types.RealTensor=None, curve_times: types.RealTensor=None, dtype: tf.DType=None) -> Tuple[types.RealTensor, types.RealTensor]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Utility function to compute the discount factors and the bond prices.\\n\\n  Args:\\n    expiries: A real `Tensor` of any shape and dtype. The time to expiration of\\n      the swaptions. The shape of this input determines the number (and shape)\\n      of swaptions to be priced and the shape of the output - e.g. if there are\\n      two swaptions, and there are 11 payment dates for each swaption, then the\\n      shape of `expiries` is [2, 11], with entries repeated along the second\\n      axis.\\n    payment_times: A real `Tensor` of same dtype and compatible shape with\\n      `expiries` - e.g. if there are two swaptions, and there are 11 payment\\n      dates for each swaption, then the shape of `payment_times` should be [2,\\n      11]\\n    sample_discount_curve_paths_fn: Callable which takes the following args:\\n      1) times: Rank 1 `Tensor` of positive real values, specifying the times at\\n        which the path points are to be evaluated.\\n      2) curve_times: Rank 1 `Tensor` of positive real values, specifying the\\n        maturities at which the discount curve is to be computed at each\\n        simulation time.\\n      3) num_samples: Positive scalar integer specifying the number of paths to\\n        draw.\\n      Returns three `Tensor`s, the first being a N-D tensor of shape\\n        `model_batch_shape + [num_samples, m, k, d]` containing the simulated\\n        zero coupon bond curves, the second being a `Tensor` of shape\\n        `model_batch_shape + [num_samples, k, d]` containing the simulated\\n        short rate paths, the third `Tensor` of shape\\n        `model_batch_shape + [num_samples, k, d]` containing the simulated path\\n        discount factors. Here, m is the size of `curve_times`, k is the size\\n        of `times`, d is the dimensionality of the paths and\\n        `model_batch_shape` is shape of the batch of independent HJM models.\\n    num_samples: Positive scalar `int32` `Tensor`. The number of simulation\\n      paths during Monte-Carlo valuation.\\n    times: An optional rank 1 `Tensor` of increasing positive real values. The\\n      times at which Monte Carlo simulations are performed.\\n      Default value: `None`.\\n    curve_times: An optional rank 1 `Tensor` of positive real values. The\\n      maturities at which spot discount curve is computed during simulations.\\n      Default value: `None`.\\n    dtype: The default dtype to use when converting values to `Tensor`s.\\n      Default value: `None` which means that default dtypes inferred by\\n        TensorFlow are used.\\n\\n  Returns:\\n    Two real tensors, `discount_factors` and `bond_prices`, both of shape\\n    [num_samples] + swaption_batch_shape + [dim], where `dim` is the dimension\\n    of each path (e.g for a Hull-White with two models, dim==2; while for HJM\\n    dim==1 always). `swaption_batch_shape` has the same rank as `expiries.shape`\\n    and its leading dimensions are broadcasted to `model_batch_shape`.\\n  '\n    if times is not None:\n        sim_times = tf.convert_to_tensor(times, dtype=dtype)\n    else:\n        sim_times = tf.reshape(expiries, shape=[-1])\n        sim_times = tf.sort(sim_times, name='sort_sim_times')\n    swaptionlet_shape = tf.shape(payment_times)\n    tau = payment_times - expiries\n    if curve_times is not None:\n        curve_times = tf.convert_to_tensor(curve_times, dtype=dtype)\n    else:\n        curve_times = tf.reshape(tau, shape=[-1])\n        (curve_times, _) = tf.unique(curve_times)\n        curve_times = tf.sort(curve_times, name='sort_curve_times')\n    (p_t_tau, r_t, discount_factors) = sample_discount_curve_paths_fn(times=sim_times, curve_times=curve_times, num_samples=num_samples)\n    dim = tf.shape(p_t_tau)[-1]\n    model_batch_shape = tf.shape(p_t_tau)[:-4]\n    model_batch_rank = p_t_tau.shape[:-4].rank\n    instr_batch_shape = tf.shape(expiries)[model_batch_rank:]\n    try:\n        swaptionlet_shape = tf.concat([model_batch_shape, instr_batch_shape], axis=0)\n        expiries = tf.broadcast_to(expiries, swaptionlet_shape)\n        tau = tf.broadcast_to(tau, swaptionlet_shape)\n    except:\n        raise ValueError('The leading dimensions of `expiries` of shape {} are not compatible with the batch shape {} of the model.'.format(expiries.shape.as_list(), p_t_tau.shape.as_list()[:-4]))\n    if discount_factors is None:\n        dt = tf.concat(axis=0, values=[[0.0], sim_times[1:] - sim_times[:-1]])\n        dt = tf.expand_dims(tf.expand_dims(dt, axis=-1), axis=0)\n        cumul_rdt = tf.transpose(utils.cumsum_using_matvec(tf.transpose(r_t * dt, perm=[0, 2, 1])), perm=[0, 2, 1])\n        discount_factors = tf.math.exp(-cumul_rdt)\n    discount_factors = tf.expand_dims(discount_factors, axis=model_batch_rank + 1)\n    discount_factors_simulated = tf.repeat(discount_factors, tf.shape(p_t_tau)[model_batch_rank + 1], axis=model_batch_rank + 1)\n    new_shape = tf.concat([model_batch_shape, [-1]], axis=0)\n    sim_time_index = tf.searchsorted(sim_times, tf.reshape(expiries, [-1]))\n    curve_time_index = tf.searchsorted(curve_times, tf.reshape(tau, [-1]))\n    sim_time_index = tf.reshape(sim_time_index, new_shape)\n    curve_time_index = tf.reshape(curve_time_index, new_shape)\n    gather_index = tf.stack([curve_time_index, sim_time_index], axis=-1)\n    discount_factors_simulated = _gather_tensor_at_swaption_payoff(discount_factors_simulated, gather_index)\n    payoff_discount_factors = tf.reshape(discount_factors_simulated, tf.concat([[num_samples], swaptionlet_shape, [dim]], axis=0))\n    p_t_tau = _gather_tensor_at_swaption_payoff(p_t_tau, gather_index)\n    payoff_bond_price = tf.reshape(p_t_tau, tf.concat([[num_samples], swaptionlet_shape, [dim]], axis=0))\n    return (payoff_discount_factors, payoff_bond_price)",
            "def discount_factors_and_bond_prices_from_samples(expiries: types.RealTensor, payment_times: types.RealTensor, sample_discount_curve_paths_fn: Callable[..., Tuple[types.RealTensor, types.RealTensor, types.RealTensor]], num_samples: types.IntTensor, times: types.RealTensor=None, curve_times: types.RealTensor=None, dtype: tf.DType=None) -> Tuple[types.RealTensor, types.RealTensor]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Utility function to compute the discount factors and the bond prices.\\n\\n  Args:\\n    expiries: A real `Tensor` of any shape and dtype. The time to expiration of\\n      the swaptions. The shape of this input determines the number (and shape)\\n      of swaptions to be priced and the shape of the output - e.g. if there are\\n      two swaptions, and there are 11 payment dates for each swaption, then the\\n      shape of `expiries` is [2, 11], with entries repeated along the second\\n      axis.\\n    payment_times: A real `Tensor` of same dtype and compatible shape with\\n      `expiries` - e.g. if there are two swaptions, and there are 11 payment\\n      dates for each swaption, then the shape of `payment_times` should be [2,\\n      11]\\n    sample_discount_curve_paths_fn: Callable which takes the following args:\\n      1) times: Rank 1 `Tensor` of positive real values, specifying the times at\\n        which the path points are to be evaluated.\\n      2) curve_times: Rank 1 `Tensor` of positive real values, specifying the\\n        maturities at which the discount curve is to be computed at each\\n        simulation time.\\n      3) num_samples: Positive scalar integer specifying the number of paths to\\n        draw.\\n      Returns three `Tensor`s, the first being a N-D tensor of shape\\n        `model_batch_shape + [num_samples, m, k, d]` containing the simulated\\n        zero coupon bond curves, the second being a `Tensor` of shape\\n        `model_batch_shape + [num_samples, k, d]` containing the simulated\\n        short rate paths, the third `Tensor` of shape\\n        `model_batch_shape + [num_samples, k, d]` containing the simulated path\\n        discount factors. Here, m is the size of `curve_times`, k is the size\\n        of `times`, d is the dimensionality of the paths and\\n        `model_batch_shape` is shape of the batch of independent HJM models.\\n    num_samples: Positive scalar `int32` `Tensor`. The number of simulation\\n      paths during Monte-Carlo valuation.\\n    times: An optional rank 1 `Tensor` of increasing positive real values. The\\n      times at which Monte Carlo simulations are performed.\\n      Default value: `None`.\\n    curve_times: An optional rank 1 `Tensor` of positive real values. The\\n      maturities at which spot discount curve is computed during simulations.\\n      Default value: `None`.\\n    dtype: The default dtype to use when converting values to `Tensor`s.\\n      Default value: `None` which means that default dtypes inferred by\\n        TensorFlow are used.\\n\\n  Returns:\\n    Two real tensors, `discount_factors` and `bond_prices`, both of shape\\n    [num_samples] + swaption_batch_shape + [dim], where `dim` is the dimension\\n    of each path (e.g for a Hull-White with two models, dim==2; while for HJM\\n    dim==1 always). `swaption_batch_shape` has the same rank as `expiries.shape`\\n    and its leading dimensions are broadcasted to `model_batch_shape`.\\n  '\n    if times is not None:\n        sim_times = tf.convert_to_tensor(times, dtype=dtype)\n    else:\n        sim_times = tf.reshape(expiries, shape=[-1])\n        sim_times = tf.sort(sim_times, name='sort_sim_times')\n    swaptionlet_shape = tf.shape(payment_times)\n    tau = payment_times - expiries\n    if curve_times is not None:\n        curve_times = tf.convert_to_tensor(curve_times, dtype=dtype)\n    else:\n        curve_times = tf.reshape(tau, shape=[-1])\n        (curve_times, _) = tf.unique(curve_times)\n        curve_times = tf.sort(curve_times, name='sort_curve_times')\n    (p_t_tau, r_t, discount_factors) = sample_discount_curve_paths_fn(times=sim_times, curve_times=curve_times, num_samples=num_samples)\n    dim = tf.shape(p_t_tau)[-1]\n    model_batch_shape = tf.shape(p_t_tau)[:-4]\n    model_batch_rank = p_t_tau.shape[:-4].rank\n    instr_batch_shape = tf.shape(expiries)[model_batch_rank:]\n    try:\n        swaptionlet_shape = tf.concat([model_batch_shape, instr_batch_shape], axis=0)\n        expiries = tf.broadcast_to(expiries, swaptionlet_shape)\n        tau = tf.broadcast_to(tau, swaptionlet_shape)\n    except:\n        raise ValueError('The leading dimensions of `expiries` of shape {} are not compatible with the batch shape {} of the model.'.format(expiries.shape.as_list(), p_t_tau.shape.as_list()[:-4]))\n    if discount_factors is None:\n        dt = tf.concat(axis=0, values=[[0.0], sim_times[1:] - sim_times[:-1]])\n        dt = tf.expand_dims(tf.expand_dims(dt, axis=-1), axis=0)\n        cumul_rdt = tf.transpose(utils.cumsum_using_matvec(tf.transpose(r_t * dt, perm=[0, 2, 1])), perm=[0, 2, 1])\n        discount_factors = tf.math.exp(-cumul_rdt)\n    discount_factors = tf.expand_dims(discount_factors, axis=model_batch_rank + 1)\n    discount_factors_simulated = tf.repeat(discount_factors, tf.shape(p_t_tau)[model_batch_rank + 1], axis=model_batch_rank + 1)\n    new_shape = tf.concat([model_batch_shape, [-1]], axis=0)\n    sim_time_index = tf.searchsorted(sim_times, tf.reshape(expiries, [-1]))\n    curve_time_index = tf.searchsorted(curve_times, tf.reshape(tau, [-1]))\n    sim_time_index = tf.reshape(sim_time_index, new_shape)\n    curve_time_index = tf.reshape(curve_time_index, new_shape)\n    gather_index = tf.stack([curve_time_index, sim_time_index], axis=-1)\n    discount_factors_simulated = _gather_tensor_at_swaption_payoff(discount_factors_simulated, gather_index)\n    payoff_discount_factors = tf.reshape(discount_factors_simulated, tf.concat([[num_samples], swaptionlet_shape, [dim]], axis=0))\n    p_t_tau = _gather_tensor_at_swaption_payoff(p_t_tau, gather_index)\n    payoff_bond_price = tf.reshape(p_t_tau, tf.concat([[num_samples], swaptionlet_shape, [dim]], axis=0))\n    return (payoff_discount_factors, payoff_bond_price)"
        ]
    },
    {
        "func_name": "_gather_tensor_at_swaption_payoff",
        "original": "def _gather_tensor_at_swaption_payoff(param, indices):\n    \"\"\"Returns the values of the input `Tensor` at Swaption payoff times.\n\n  `Tensor`s such as simulated path discount factors and spot discount curves\n  have shape `[batch_shape, num_samples, curve_times, sim_times, dim]`. In\n  order to compute swaption payoffs at exercise times, we need to gather their\n  values at `[batch_shape, num_samples, curve_times_idx, sim_times_idx, dim]`\n  where `curve_times_idx` are the relevant indices corresponding to times at\n  which spot discount curves are sampled and `sim_times_idx` are the relevant\n  indices corresponding to simulation times.\n\n  To achieve this task we first transpose the tensor to shape\n  `[batch_shape, curve_times, sim_times, dim, num_samples]` and then use\n  `tf.gather_nd`.\n\n  Args:\n    param: The `Tensor` from which values will be extracted. The shape of the\n      `Tensor` is `[batch_shape, num_samples, curve_times, sim_times, dim]`.\n    indices: A N-D `Tensor` of shape `batch_shape + [num_indices, 2]`. The first\n      column contains the indices along the `curve_times` axis and the second\n      column contains the indices along the `sim_times` axis.\n\n  Returns:\n    A `Tensor` of same dtype as `param` and shape\n    `[num_samples, batch_shape, num_indices, dim]`.\n  \"\"\"\n    batch_rank = param.shape[:-4].rank\n    perm = list(range(batch_rank)) + [batch_rank + 1, batch_rank + 2, batch_rank + 3, batch_rank]\n    param = tf.transpose(param, perm=perm)\n    param = tf.gather_nd(param, indices, batch_dims=batch_rank)\n    perm = [2 + batch_rank] + list(range(2 + batch_rank))\n    param = tf.transpose(param, perm=perm)\n    return param",
        "mutated": [
            "def _gather_tensor_at_swaption_payoff(param, indices):\n    if False:\n        i = 10\n    'Returns the values of the input `Tensor` at Swaption payoff times.\\n\\n  `Tensor`s such as simulated path discount factors and spot discount curves\\n  have shape `[batch_shape, num_samples, curve_times, sim_times, dim]`. In\\n  order to compute swaption payoffs at exercise times, we need to gather their\\n  values at `[batch_shape, num_samples, curve_times_idx, sim_times_idx, dim]`\\n  where `curve_times_idx` are the relevant indices corresponding to times at\\n  which spot discount curves are sampled and `sim_times_idx` are the relevant\\n  indices corresponding to simulation times.\\n\\n  To achieve this task we first transpose the tensor to shape\\n  `[batch_shape, curve_times, sim_times, dim, num_samples]` and then use\\n  `tf.gather_nd`.\\n\\n  Args:\\n    param: The `Tensor` from which values will be extracted. The shape of the\\n      `Tensor` is `[batch_shape, num_samples, curve_times, sim_times, dim]`.\\n    indices: A N-D `Tensor` of shape `batch_shape + [num_indices, 2]`. The first\\n      column contains the indices along the `curve_times` axis and the second\\n      column contains the indices along the `sim_times` axis.\\n\\n  Returns:\\n    A `Tensor` of same dtype as `param` and shape\\n    `[num_samples, batch_shape, num_indices, dim]`.\\n  '\n    batch_rank = param.shape[:-4].rank\n    perm = list(range(batch_rank)) + [batch_rank + 1, batch_rank + 2, batch_rank + 3, batch_rank]\n    param = tf.transpose(param, perm=perm)\n    param = tf.gather_nd(param, indices, batch_dims=batch_rank)\n    perm = [2 + batch_rank] + list(range(2 + batch_rank))\n    param = tf.transpose(param, perm=perm)\n    return param",
            "def _gather_tensor_at_swaption_payoff(param, indices):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns the values of the input `Tensor` at Swaption payoff times.\\n\\n  `Tensor`s such as simulated path discount factors and spot discount curves\\n  have shape `[batch_shape, num_samples, curve_times, sim_times, dim]`. In\\n  order to compute swaption payoffs at exercise times, we need to gather their\\n  values at `[batch_shape, num_samples, curve_times_idx, sim_times_idx, dim]`\\n  where `curve_times_idx` are the relevant indices corresponding to times at\\n  which spot discount curves are sampled and `sim_times_idx` are the relevant\\n  indices corresponding to simulation times.\\n\\n  To achieve this task we first transpose the tensor to shape\\n  `[batch_shape, curve_times, sim_times, dim, num_samples]` and then use\\n  `tf.gather_nd`.\\n\\n  Args:\\n    param: The `Tensor` from which values will be extracted. The shape of the\\n      `Tensor` is `[batch_shape, num_samples, curve_times, sim_times, dim]`.\\n    indices: A N-D `Tensor` of shape `batch_shape + [num_indices, 2]`. The first\\n      column contains the indices along the `curve_times` axis and the second\\n      column contains the indices along the `sim_times` axis.\\n\\n  Returns:\\n    A `Tensor` of same dtype as `param` and shape\\n    `[num_samples, batch_shape, num_indices, dim]`.\\n  '\n    batch_rank = param.shape[:-4].rank\n    perm = list(range(batch_rank)) + [batch_rank + 1, batch_rank + 2, batch_rank + 3, batch_rank]\n    param = tf.transpose(param, perm=perm)\n    param = tf.gather_nd(param, indices, batch_dims=batch_rank)\n    perm = [2 + batch_rank] + list(range(2 + batch_rank))\n    param = tf.transpose(param, perm=perm)\n    return param",
            "def _gather_tensor_at_swaption_payoff(param, indices):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns the values of the input `Tensor` at Swaption payoff times.\\n\\n  `Tensor`s such as simulated path discount factors and spot discount curves\\n  have shape `[batch_shape, num_samples, curve_times, sim_times, dim]`. In\\n  order to compute swaption payoffs at exercise times, we need to gather their\\n  values at `[batch_shape, num_samples, curve_times_idx, sim_times_idx, dim]`\\n  where `curve_times_idx` are the relevant indices corresponding to times at\\n  which spot discount curves are sampled and `sim_times_idx` are the relevant\\n  indices corresponding to simulation times.\\n\\n  To achieve this task we first transpose the tensor to shape\\n  `[batch_shape, curve_times, sim_times, dim, num_samples]` and then use\\n  `tf.gather_nd`.\\n\\n  Args:\\n    param: The `Tensor` from which values will be extracted. The shape of the\\n      `Tensor` is `[batch_shape, num_samples, curve_times, sim_times, dim]`.\\n    indices: A N-D `Tensor` of shape `batch_shape + [num_indices, 2]`. The first\\n      column contains the indices along the `curve_times` axis and the second\\n      column contains the indices along the `sim_times` axis.\\n\\n  Returns:\\n    A `Tensor` of same dtype as `param` and shape\\n    `[num_samples, batch_shape, num_indices, dim]`.\\n  '\n    batch_rank = param.shape[:-4].rank\n    perm = list(range(batch_rank)) + [batch_rank + 1, batch_rank + 2, batch_rank + 3, batch_rank]\n    param = tf.transpose(param, perm=perm)\n    param = tf.gather_nd(param, indices, batch_dims=batch_rank)\n    perm = [2 + batch_rank] + list(range(2 + batch_rank))\n    param = tf.transpose(param, perm=perm)\n    return param",
            "def _gather_tensor_at_swaption_payoff(param, indices):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns the values of the input `Tensor` at Swaption payoff times.\\n\\n  `Tensor`s such as simulated path discount factors and spot discount curves\\n  have shape `[batch_shape, num_samples, curve_times, sim_times, dim]`. In\\n  order to compute swaption payoffs at exercise times, we need to gather their\\n  values at `[batch_shape, num_samples, curve_times_idx, sim_times_idx, dim]`\\n  where `curve_times_idx` are the relevant indices corresponding to times at\\n  which spot discount curves are sampled and `sim_times_idx` are the relevant\\n  indices corresponding to simulation times.\\n\\n  To achieve this task we first transpose the tensor to shape\\n  `[batch_shape, curve_times, sim_times, dim, num_samples]` and then use\\n  `tf.gather_nd`.\\n\\n  Args:\\n    param: The `Tensor` from which values will be extracted. The shape of the\\n      `Tensor` is `[batch_shape, num_samples, curve_times, sim_times, dim]`.\\n    indices: A N-D `Tensor` of shape `batch_shape + [num_indices, 2]`. The first\\n      column contains the indices along the `curve_times` axis and the second\\n      column contains the indices along the `sim_times` axis.\\n\\n  Returns:\\n    A `Tensor` of same dtype as `param` and shape\\n    `[num_samples, batch_shape, num_indices, dim]`.\\n  '\n    batch_rank = param.shape[:-4].rank\n    perm = list(range(batch_rank)) + [batch_rank + 1, batch_rank + 2, batch_rank + 3, batch_rank]\n    param = tf.transpose(param, perm=perm)\n    param = tf.gather_nd(param, indices, batch_dims=batch_rank)\n    perm = [2 + batch_rank] + list(range(2 + batch_rank))\n    param = tf.transpose(param, perm=perm)\n    return param",
            "def _gather_tensor_at_swaption_payoff(param, indices):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns the values of the input `Tensor` at Swaption payoff times.\\n\\n  `Tensor`s such as simulated path discount factors and spot discount curves\\n  have shape `[batch_shape, num_samples, curve_times, sim_times, dim]`. In\\n  order to compute swaption payoffs at exercise times, we need to gather their\\n  values at `[batch_shape, num_samples, curve_times_idx, sim_times_idx, dim]`\\n  where `curve_times_idx` are the relevant indices corresponding to times at\\n  which spot discount curves are sampled and `sim_times_idx` are the relevant\\n  indices corresponding to simulation times.\\n\\n  To achieve this task we first transpose the tensor to shape\\n  `[batch_shape, curve_times, sim_times, dim, num_samples]` and then use\\n  `tf.gather_nd`.\\n\\n  Args:\\n    param: The `Tensor` from which values will be extracted. The shape of the\\n      `Tensor` is `[batch_shape, num_samples, curve_times, sim_times, dim]`.\\n    indices: A N-D `Tensor` of shape `batch_shape + [num_indices, 2]`. The first\\n      column contains the indices along the `curve_times` axis and the second\\n      column contains the indices along the `sim_times` axis.\\n\\n  Returns:\\n    A `Tensor` of same dtype as `param` and shape\\n    `[num_samples, batch_shape, num_indices, dim]`.\\n  '\n    batch_rank = param.shape[:-4].rank\n    perm = list(range(batch_rank)) + [batch_rank + 1, batch_rank + 2, batch_rank + 3, batch_rank]\n    param = tf.transpose(param, perm=perm)\n    param = tf.gather_nd(param, indices, batch_dims=batch_rank)\n    perm = [2 + batch_rank] + list(range(2 + batch_rank))\n    param = tf.transpose(param, perm=perm)\n    return param"
        ]
    }
]