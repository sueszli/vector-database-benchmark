[
    {
        "func_name": "inner",
        "original": "def inner(fn: RawSensorEvaluationFunction) -> SensorDefinition:\n    check.callable_param(fn, 'fn')\n    sensor_def = SensorDefinition.dagster_internal_init(name=name, job_name=job_name, evaluation_fn=fn, minimum_interval_seconds=minimum_interval_seconds, description=description, job=job, jobs=jobs, default_status=default_status, asset_selection=asset_selection, required_resource_keys=required_resource_keys)\n    update_wrapper(sensor_def, wrapped=fn)\n    return sensor_def",
        "mutated": [
            "def inner(fn: RawSensorEvaluationFunction) -> SensorDefinition:\n    if False:\n        i = 10\n    check.callable_param(fn, 'fn')\n    sensor_def = SensorDefinition.dagster_internal_init(name=name, job_name=job_name, evaluation_fn=fn, minimum_interval_seconds=minimum_interval_seconds, description=description, job=job, jobs=jobs, default_status=default_status, asset_selection=asset_selection, required_resource_keys=required_resource_keys)\n    update_wrapper(sensor_def, wrapped=fn)\n    return sensor_def",
            "def inner(fn: RawSensorEvaluationFunction) -> SensorDefinition:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    check.callable_param(fn, 'fn')\n    sensor_def = SensorDefinition.dagster_internal_init(name=name, job_name=job_name, evaluation_fn=fn, minimum_interval_seconds=minimum_interval_seconds, description=description, job=job, jobs=jobs, default_status=default_status, asset_selection=asset_selection, required_resource_keys=required_resource_keys)\n    update_wrapper(sensor_def, wrapped=fn)\n    return sensor_def",
            "def inner(fn: RawSensorEvaluationFunction) -> SensorDefinition:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    check.callable_param(fn, 'fn')\n    sensor_def = SensorDefinition.dagster_internal_init(name=name, job_name=job_name, evaluation_fn=fn, minimum_interval_seconds=minimum_interval_seconds, description=description, job=job, jobs=jobs, default_status=default_status, asset_selection=asset_selection, required_resource_keys=required_resource_keys)\n    update_wrapper(sensor_def, wrapped=fn)\n    return sensor_def",
            "def inner(fn: RawSensorEvaluationFunction) -> SensorDefinition:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    check.callable_param(fn, 'fn')\n    sensor_def = SensorDefinition.dagster_internal_init(name=name, job_name=job_name, evaluation_fn=fn, minimum_interval_seconds=minimum_interval_seconds, description=description, job=job, jobs=jobs, default_status=default_status, asset_selection=asset_selection, required_resource_keys=required_resource_keys)\n    update_wrapper(sensor_def, wrapped=fn)\n    return sensor_def",
            "def inner(fn: RawSensorEvaluationFunction) -> SensorDefinition:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    check.callable_param(fn, 'fn')\n    sensor_def = SensorDefinition.dagster_internal_init(name=name, job_name=job_name, evaluation_fn=fn, minimum_interval_seconds=minimum_interval_seconds, description=description, job=job, jobs=jobs, default_status=default_status, asset_selection=asset_selection, required_resource_keys=required_resource_keys)\n    update_wrapper(sensor_def, wrapped=fn)\n    return sensor_def"
        ]
    },
    {
        "func_name": "sensor",
        "original": "def sensor(job_name: Optional[str]=None, *, name: Optional[str]=None, minimum_interval_seconds: Optional[int]=None, description: Optional[str]=None, job: Optional[ExecutableDefinition]=None, jobs: Optional[Sequence[ExecutableDefinition]]=None, default_status: DefaultSensorStatus=DefaultSensorStatus.STOPPED, asset_selection: Optional[AssetSelection]=None, required_resource_keys: Optional[Set[str]]=None) -> Callable[[RawSensorEvaluationFunction], SensorDefinition]:\n    \"\"\"Creates a sensor where the decorated function is used as the sensor's evaluation function.\n\n    The decorated function may:\n\n    1. Return a `RunRequest` object.\n    2. Return a list of `RunRequest` objects.\n    3. Return a `SkipReason` object, providing a descriptive message of why no runs were requested.\n    4. Return nothing (skipping without providing a reason)\n    5. Yield a `SkipReason` or yield one or more `RunRequest` objects.\n\n    Takes a :py:class:`~dagster.SensorEvaluationContext`.\n\n    Args:\n        name (Optional[str]): The name of the sensor. Defaults to the name of the decorated\n            function.\n        minimum_interval_seconds (Optional[int]): The minimum number of seconds that will elapse\n            between sensor evaluations.\n        description (Optional[str]): A human-readable description of the sensor.\n        job (Optional[Union[GraphDefinition, JobDefinition, UnresolvedAssetJobDefinition]]):\n            The job to be executed when the sensor fires.\n        jobs (Optional[Sequence[Union[GraphDefinition, JobDefinition, UnresolvedAssetJobDefinition]]]):\n            (experimental) A list of jobs to be executed when the sensor fires.\n        default_status (DefaultSensorStatus): Whether the sensor starts as running or not. The default\n            status can be overridden from the Dagster UI or via the GraphQL API.\n        asset_selection (AssetSelection): (Experimental) an asset selection to launch a run for if\n            the sensor condition is met. This can be provided instead of specifying a job.\n    \"\"\"\n    check.opt_str_param(name, 'name')\n\n    def inner(fn: RawSensorEvaluationFunction) -> SensorDefinition:\n        check.callable_param(fn, 'fn')\n        sensor_def = SensorDefinition.dagster_internal_init(name=name, job_name=job_name, evaluation_fn=fn, minimum_interval_seconds=minimum_interval_seconds, description=description, job=job, jobs=jobs, default_status=default_status, asset_selection=asset_selection, required_resource_keys=required_resource_keys)\n        update_wrapper(sensor_def, wrapped=fn)\n        return sensor_def\n    return inner",
        "mutated": [
            "def sensor(job_name: Optional[str]=None, *, name: Optional[str]=None, minimum_interval_seconds: Optional[int]=None, description: Optional[str]=None, job: Optional[ExecutableDefinition]=None, jobs: Optional[Sequence[ExecutableDefinition]]=None, default_status: DefaultSensorStatus=DefaultSensorStatus.STOPPED, asset_selection: Optional[AssetSelection]=None, required_resource_keys: Optional[Set[str]]=None) -> Callable[[RawSensorEvaluationFunction], SensorDefinition]:\n    if False:\n        i = 10\n    \"Creates a sensor where the decorated function is used as the sensor's evaluation function.\\n\\n    The decorated function may:\\n\\n    1. Return a `RunRequest` object.\\n    2. Return a list of `RunRequest` objects.\\n    3. Return a `SkipReason` object, providing a descriptive message of why no runs were requested.\\n    4. Return nothing (skipping without providing a reason)\\n    5. Yield a `SkipReason` or yield one or more `RunRequest` objects.\\n\\n    Takes a :py:class:`~dagster.SensorEvaluationContext`.\\n\\n    Args:\\n        name (Optional[str]): The name of the sensor. Defaults to the name of the decorated\\n            function.\\n        minimum_interval_seconds (Optional[int]): The minimum number of seconds that will elapse\\n            between sensor evaluations.\\n        description (Optional[str]): A human-readable description of the sensor.\\n        job (Optional[Union[GraphDefinition, JobDefinition, UnresolvedAssetJobDefinition]]):\\n            The job to be executed when the sensor fires.\\n        jobs (Optional[Sequence[Union[GraphDefinition, JobDefinition, UnresolvedAssetJobDefinition]]]):\\n            (experimental) A list of jobs to be executed when the sensor fires.\\n        default_status (DefaultSensorStatus): Whether the sensor starts as running or not. The default\\n            status can be overridden from the Dagster UI or via the GraphQL API.\\n        asset_selection (AssetSelection): (Experimental) an asset selection to launch a run for if\\n            the sensor condition is met. This can be provided instead of specifying a job.\\n    \"\n    check.opt_str_param(name, 'name')\n\n    def inner(fn: RawSensorEvaluationFunction) -> SensorDefinition:\n        check.callable_param(fn, 'fn')\n        sensor_def = SensorDefinition.dagster_internal_init(name=name, job_name=job_name, evaluation_fn=fn, minimum_interval_seconds=minimum_interval_seconds, description=description, job=job, jobs=jobs, default_status=default_status, asset_selection=asset_selection, required_resource_keys=required_resource_keys)\n        update_wrapper(sensor_def, wrapped=fn)\n        return sensor_def\n    return inner",
            "def sensor(job_name: Optional[str]=None, *, name: Optional[str]=None, minimum_interval_seconds: Optional[int]=None, description: Optional[str]=None, job: Optional[ExecutableDefinition]=None, jobs: Optional[Sequence[ExecutableDefinition]]=None, default_status: DefaultSensorStatus=DefaultSensorStatus.STOPPED, asset_selection: Optional[AssetSelection]=None, required_resource_keys: Optional[Set[str]]=None) -> Callable[[RawSensorEvaluationFunction], SensorDefinition]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Creates a sensor where the decorated function is used as the sensor's evaluation function.\\n\\n    The decorated function may:\\n\\n    1. Return a `RunRequest` object.\\n    2. Return a list of `RunRequest` objects.\\n    3. Return a `SkipReason` object, providing a descriptive message of why no runs were requested.\\n    4. Return nothing (skipping without providing a reason)\\n    5. Yield a `SkipReason` or yield one or more `RunRequest` objects.\\n\\n    Takes a :py:class:`~dagster.SensorEvaluationContext`.\\n\\n    Args:\\n        name (Optional[str]): The name of the sensor. Defaults to the name of the decorated\\n            function.\\n        minimum_interval_seconds (Optional[int]): The minimum number of seconds that will elapse\\n            between sensor evaluations.\\n        description (Optional[str]): A human-readable description of the sensor.\\n        job (Optional[Union[GraphDefinition, JobDefinition, UnresolvedAssetJobDefinition]]):\\n            The job to be executed when the sensor fires.\\n        jobs (Optional[Sequence[Union[GraphDefinition, JobDefinition, UnresolvedAssetJobDefinition]]]):\\n            (experimental) A list of jobs to be executed when the sensor fires.\\n        default_status (DefaultSensorStatus): Whether the sensor starts as running or not. The default\\n            status can be overridden from the Dagster UI or via the GraphQL API.\\n        asset_selection (AssetSelection): (Experimental) an asset selection to launch a run for if\\n            the sensor condition is met. This can be provided instead of specifying a job.\\n    \"\n    check.opt_str_param(name, 'name')\n\n    def inner(fn: RawSensorEvaluationFunction) -> SensorDefinition:\n        check.callable_param(fn, 'fn')\n        sensor_def = SensorDefinition.dagster_internal_init(name=name, job_name=job_name, evaluation_fn=fn, minimum_interval_seconds=minimum_interval_seconds, description=description, job=job, jobs=jobs, default_status=default_status, asset_selection=asset_selection, required_resource_keys=required_resource_keys)\n        update_wrapper(sensor_def, wrapped=fn)\n        return sensor_def\n    return inner",
            "def sensor(job_name: Optional[str]=None, *, name: Optional[str]=None, minimum_interval_seconds: Optional[int]=None, description: Optional[str]=None, job: Optional[ExecutableDefinition]=None, jobs: Optional[Sequence[ExecutableDefinition]]=None, default_status: DefaultSensorStatus=DefaultSensorStatus.STOPPED, asset_selection: Optional[AssetSelection]=None, required_resource_keys: Optional[Set[str]]=None) -> Callable[[RawSensorEvaluationFunction], SensorDefinition]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Creates a sensor where the decorated function is used as the sensor's evaluation function.\\n\\n    The decorated function may:\\n\\n    1. Return a `RunRequest` object.\\n    2. Return a list of `RunRequest` objects.\\n    3. Return a `SkipReason` object, providing a descriptive message of why no runs were requested.\\n    4. Return nothing (skipping without providing a reason)\\n    5. Yield a `SkipReason` or yield one or more `RunRequest` objects.\\n\\n    Takes a :py:class:`~dagster.SensorEvaluationContext`.\\n\\n    Args:\\n        name (Optional[str]): The name of the sensor. Defaults to the name of the decorated\\n            function.\\n        minimum_interval_seconds (Optional[int]): The minimum number of seconds that will elapse\\n            between sensor evaluations.\\n        description (Optional[str]): A human-readable description of the sensor.\\n        job (Optional[Union[GraphDefinition, JobDefinition, UnresolvedAssetJobDefinition]]):\\n            The job to be executed when the sensor fires.\\n        jobs (Optional[Sequence[Union[GraphDefinition, JobDefinition, UnresolvedAssetJobDefinition]]]):\\n            (experimental) A list of jobs to be executed when the sensor fires.\\n        default_status (DefaultSensorStatus): Whether the sensor starts as running or not. The default\\n            status can be overridden from the Dagster UI or via the GraphQL API.\\n        asset_selection (AssetSelection): (Experimental) an asset selection to launch a run for if\\n            the sensor condition is met. This can be provided instead of specifying a job.\\n    \"\n    check.opt_str_param(name, 'name')\n\n    def inner(fn: RawSensorEvaluationFunction) -> SensorDefinition:\n        check.callable_param(fn, 'fn')\n        sensor_def = SensorDefinition.dagster_internal_init(name=name, job_name=job_name, evaluation_fn=fn, minimum_interval_seconds=minimum_interval_seconds, description=description, job=job, jobs=jobs, default_status=default_status, asset_selection=asset_selection, required_resource_keys=required_resource_keys)\n        update_wrapper(sensor_def, wrapped=fn)\n        return sensor_def\n    return inner",
            "def sensor(job_name: Optional[str]=None, *, name: Optional[str]=None, minimum_interval_seconds: Optional[int]=None, description: Optional[str]=None, job: Optional[ExecutableDefinition]=None, jobs: Optional[Sequence[ExecutableDefinition]]=None, default_status: DefaultSensorStatus=DefaultSensorStatus.STOPPED, asset_selection: Optional[AssetSelection]=None, required_resource_keys: Optional[Set[str]]=None) -> Callable[[RawSensorEvaluationFunction], SensorDefinition]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Creates a sensor where the decorated function is used as the sensor's evaluation function.\\n\\n    The decorated function may:\\n\\n    1. Return a `RunRequest` object.\\n    2. Return a list of `RunRequest` objects.\\n    3. Return a `SkipReason` object, providing a descriptive message of why no runs were requested.\\n    4. Return nothing (skipping without providing a reason)\\n    5. Yield a `SkipReason` or yield one or more `RunRequest` objects.\\n\\n    Takes a :py:class:`~dagster.SensorEvaluationContext`.\\n\\n    Args:\\n        name (Optional[str]): The name of the sensor. Defaults to the name of the decorated\\n            function.\\n        minimum_interval_seconds (Optional[int]): The minimum number of seconds that will elapse\\n            between sensor evaluations.\\n        description (Optional[str]): A human-readable description of the sensor.\\n        job (Optional[Union[GraphDefinition, JobDefinition, UnresolvedAssetJobDefinition]]):\\n            The job to be executed when the sensor fires.\\n        jobs (Optional[Sequence[Union[GraphDefinition, JobDefinition, UnresolvedAssetJobDefinition]]]):\\n            (experimental) A list of jobs to be executed when the sensor fires.\\n        default_status (DefaultSensorStatus): Whether the sensor starts as running or not. The default\\n            status can be overridden from the Dagster UI or via the GraphQL API.\\n        asset_selection (AssetSelection): (Experimental) an asset selection to launch a run for if\\n            the sensor condition is met. This can be provided instead of specifying a job.\\n    \"\n    check.opt_str_param(name, 'name')\n\n    def inner(fn: RawSensorEvaluationFunction) -> SensorDefinition:\n        check.callable_param(fn, 'fn')\n        sensor_def = SensorDefinition.dagster_internal_init(name=name, job_name=job_name, evaluation_fn=fn, minimum_interval_seconds=minimum_interval_seconds, description=description, job=job, jobs=jobs, default_status=default_status, asset_selection=asset_selection, required_resource_keys=required_resource_keys)\n        update_wrapper(sensor_def, wrapped=fn)\n        return sensor_def\n    return inner",
            "def sensor(job_name: Optional[str]=None, *, name: Optional[str]=None, minimum_interval_seconds: Optional[int]=None, description: Optional[str]=None, job: Optional[ExecutableDefinition]=None, jobs: Optional[Sequence[ExecutableDefinition]]=None, default_status: DefaultSensorStatus=DefaultSensorStatus.STOPPED, asset_selection: Optional[AssetSelection]=None, required_resource_keys: Optional[Set[str]]=None) -> Callable[[RawSensorEvaluationFunction], SensorDefinition]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Creates a sensor where the decorated function is used as the sensor's evaluation function.\\n\\n    The decorated function may:\\n\\n    1. Return a `RunRequest` object.\\n    2. Return a list of `RunRequest` objects.\\n    3. Return a `SkipReason` object, providing a descriptive message of why no runs were requested.\\n    4. Return nothing (skipping without providing a reason)\\n    5. Yield a `SkipReason` or yield one or more `RunRequest` objects.\\n\\n    Takes a :py:class:`~dagster.SensorEvaluationContext`.\\n\\n    Args:\\n        name (Optional[str]): The name of the sensor. Defaults to the name of the decorated\\n            function.\\n        minimum_interval_seconds (Optional[int]): The minimum number of seconds that will elapse\\n            between sensor evaluations.\\n        description (Optional[str]): A human-readable description of the sensor.\\n        job (Optional[Union[GraphDefinition, JobDefinition, UnresolvedAssetJobDefinition]]):\\n            The job to be executed when the sensor fires.\\n        jobs (Optional[Sequence[Union[GraphDefinition, JobDefinition, UnresolvedAssetJobDefinition]]]):\\n            (experimental) A list of jobs to be executed when the sensor fires.\\n        default_status (DefaultSensorStatus): Whether the sensor starts as running or not. The default\\n            status can be overridden from the Dagster UI or via the GraphQL API.\\n        asset_selection (AssetSelection): (Experimental) an asset selection to launch a run for if\\n            the sensor condition is met. This can be provided instead of specifying a job.\\n    \"\n    check.opt_str_param(name, 'name')\n\n    def inner(fn: RawSensorEvaluationFunction) -> SensorDefinition:\n        check.callable_param(fn, 'fn')\n        sensor_def = SensorDefinition.dagster_internal_init(name=name, job_name=job_name, evaluation_fn=fn, minimum_interval_seconds=minimum_interval_seconds, description=description, job=job, jobs=jobs, default_status=default_status, asset_selection=asset_selection, required_resource_keys=required_resource_keys)\n        update_wrapper(sensor_def, wrapped=fn)\n        return sensor_def\n    return inner"
        ]
    },
    {
        "func_name": "_wrapped_fn",
        "original": "def _wrapped_fn(*args, **kwargs) -> Any:\n    result = fn(*args, **kwargs)\n    if inspect.isgenerator(result) or isinstance(result, list):\n        for item in result:\n            yield item\n    elif isinstance(result, (RunRequest, SkipReason)):\n        yield result\n    elif isinstance(result, SensorResult):\n        if result.cursor:\n            raise DagsterInvariantViolationError(f'Error in asset sensor {sensor_name}: Sensor returned a SensorResult with a cursor value. The cursor is managed by the asset sensor and should not be modified by a user.')\n        yield result\n    elif result is not None:\n        raise DagsterInvariantViolationError(f'Error in sensor {sensor_name}: Sensor unexpectedly returned output {result} of type {type(result)}.  Should only return SkipReason or RunRequest objects.')",
        "mutated": [
            "def _wrapped_fn(*args, **kwargs) -> Any:\n    if False:\n        i = 10\n    result = fn(*args, **kwargs)\n    if inspect.isgenerator(result) or isinstance(result, list):\n        for item in result:\n            yield item\n    elif isinstance(result, (RunRequest, SkipReason)):\n        yield result\n    elif isinstance(result, SensorResult):\n        if result.cursor:\n            raise DagsterInvariantViolationError(f'Error in asset sensor {sensor_name}: Sensor returned a SensorResult with a cursor value. The cursor is managed by the asset sensor and should not be modified by a user.')\n        yield result\n    elif result is not None:\n        raise DagsterInvariantViolationError(f'Error in sensor {sensor_name}: Sensor unexpectedly returned output {result} of type {type(result)}.  Should only return SkipReason or RunRequest objects.')",
            "def _wrapped_fn(*args, **kwargs) -> Any:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    result = fn(*args, **kwargs)\n    if inspect.isgenerator(result) or isinstance(result, list):\n        for item in result:\n            yield item\n    elif isinstance(result, (RunRequest, SkipReason)):\n        yield result\n    elif isinstance(result, SensorResult):\n        if result.cursor:\n            raise DagsterInvariantViolationError(f'Error in asset sensor {sensor_name}: Sensor returned a SensorResult with a cursor value. The cursor is managed by the asset sensor and should not be modified by a user.')\n        yield result\n    elif result is not None:\n        raise DagsterInvariantViolationError(f'Error in sensor {sensor_name}: Sensor unexpectedly returned output {result} of type {type(result)}.  Should only return SkipReason or RunRequest objects.')",
            "def _wrapped_fn(*args, **kwargs) -> Any:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    result = fn(*args, **kwargs)\n    if inspect.isgenerator(result) or isinstance(result, list):\n        for item in result:\n            yield item\n    elif isinstance(result, (RunRequest, SkipReason)):\n        yield result\n    elif isinstance(result, SensorResult):\n        if result.cursor:\n            raise DagsterInvariantViolationError(f'Error in asset sensor {sensor_name}: Sensor returned a SensorResult with a cursor value. The cursor is managed by the asset sensor and should not be modified by a user.')\n        yield result\n    elif result is not None:\n        raise DagsterInvariantViolationError(f'Error in sensor {sensor_name}: Sensor unexpectedly returned output {result} of type {type(result)}.  Should only return SkipReason or RunRequest objects.')",
            "def _wrapped_fn(*args, **kwargs) -> Any:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    result = fn(*args, **kwargs)\n    if inspect.isgenerator(result) or isinstance(result, list):\n        for item in result:\n            yield item\n    elif isinstance(result, (RunRequest, SkipReason)):\n        yield result\n    elif isinstance(result, SensorResult):\n        if result.cursor:\n            raise DagsterInvariantViolationError(f'Error in asset sensor {sensor_name}: Sensor returned a SensorResult with a cursor value. The cursor is managed by the asset sensor and should not be modified by a user.')\n        yield result\n    elif result is not None:\n        raise DagsterInvariantViolationError(f'Error in sensor {sensor_name}: Sensor unexpectedly returned output {result} of type {type(result)}.  Should only return SkipReason or RunRequest objects.')",
            "def _wrapped_fn(*args, **kwargs) -> Any:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    result = fn(*args, **kwargs)\n    if inspect.isgenerator(result) or isinstance(result, list):\n        for item in result:\n            yield item\n    elif isinstance(result, (RunRequest, SkipReason)):\n        yield result\n    elif isinstance(result, SensorResult):\n        if result.cursor:\n            raise DagsterInvariantViolationError(f'Error in asset sensor {sensor_name}: Sensor returned a SensorResult with a cursor value. The cursor is managed by the asset sensor and should not be modified by a user.')\n        yield result\n    elif result is not None:\n        raise DagsterInvariantViolationError(f'Error in sensor {sensor_name}: Sensor unexpectedly returned output {result} of type {type(result)}.  Should only return SkipReason or RunRequest objects.')"
        ]
    },
    {
        "func_name": "inner",
        "original": "def inner(fn: AssetMaterializationFunction) -> AssetSensorDefinition:\n    check.callable_param(fn, 'fn')\n    sensor_name = name or fn.__name__\n\n    def _wrapped_fn(*args, **kwargs) -> Any:\n        result = fn(*args, **kwargs)\n        if inspect.isgenerator(result) or isinstance(result, list):\n            for item in result:\n                yield item\n        elif isinstance(result, (RunRequest, SkipReason)):\n            yield result\n        elif isinstance(result, SensorResult):\n            if result.cursor:\n                raise DagsterInvariantViolationError(f'Error in asset sensor {sensor_name}: Sensor returned a SensorResult with a cursor value. The cursor is managed by the asset sensor and should not be modified by a user.')\n            yield result\n        elif result is not None:\n            raise DagsterInvariantViolationError(f'Error in sensor {sensor_name}: Sensor unexpectedly returned output {result} of type {type(result)}.  Should only return SkipReason or RunRequest objects.')\n    _wrapped_fn = update_wrapper(_wrapped_fn, wrapped=fn)\n    return AssetSensorDefinition(name=sensor_name, asset_key=asset_key, job_name=job_name, asset_materialization_fn=_wrapped_fn, minimum_interval_seconds=minimum_interval_seconds, description=description, job=job, jobs=jobs, default_status=default_status, required_resource_keys=required_resource_keys)",
        "mutated": [
            "def inner(fn: AssetMaterializationFunction) -> AssetSensorDefinition:\n    if False:\n        i = 10\n    check.callable_param(fn, 'fn')\n    sensor_name = name or fn.__name__\n\n    def _wrapped_fn(*args, **kwargs) -> Any:\n        result = fn(*args, **kwargs)\n        if inspect.isgenerator(result) or isinstance(result, list):\n            for item in result:\n                yield item\n        elif isinstance(result, (RunRequest, SkipReason)):\n            yield result\n        elif isinstance(result, SensorResult):\n            if result.cursor:\n                raise DagsterInvariantViolationError(f'Error in asset sensor {sensor_name}: Sensor returned a SensorResult with a cursor value. The cursor is managed by the asset sensor and should not be modified by a user.')\n            yield result\n        elif result is not None:\n            raise DagsterInvariantViolationError(f'Error in sensor {sensor_name}: Sensor unexpectedly returned output {result} of type {type(result)}.  Should only return SkipReason or RunRequest objects.')\n    _wrapped_fn = update_wrapper(_wrapped_fn, wrapped=fn)\n    return AssetSensorDefinition(name=sensor_name, asset_key=asset_key, job_name=job_name, asset_materialization_fn=_wrapped_fn, minimum_interval_seconds=minimum_interval_seconds, description=description, job=job, jobs=jobs, default_status=default_status, required_resource_keys=required_resource_keys)",
            "def inner(fn: AssetMaterializationFunction) -> AssetSensorDefinition:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    check.callable_param(fn, 'fn')\n    sensor_name = name or fn.__name__\n\n    def _wrapped_fn(*args, **kwargs) -> Any:\n        result = fn(*args, **kwargs)\n        if inspect.isgenerator(result) or isinstance(result, list):\n            for item in result:\n                yield item\n        elif isinstance(result, (RunRequest, SkipReason)):\n            yield result\n        elif isinstance(result, SensorResult):\n            if result.cursor:\n                raise DagsterInvariantViolationError(f'Error in asset sensor {sensor_name}: Sensor returned a SensorResult with a cursor value. The cursor is managed by the asset sensor and should not be modified by a user.')\n            yield result\n        elif result is not None:\n            raise DagsterInvariantViolationError(f'Error in sensor {sensor_name}: Sensor unexpectedly returned output {result} of type {type(result)}.  Should only return SkipReason or RunRequest objects.')\n    _wrapped_fn = update_wrapper(_wrapped_fn, wrapped=fn)\n    return AssetSensorDefinition(name=sensor_name, asset_key=asset_key, job_name=job_name, asset_materialization_fn=_wrapped_fn, minimum_interval_seconds=minimum_interval_seconds, description=description, job=job, jobs=jobs, default_status=default_status, required_resource_keys=required_resource_keys)",
            "def inner(fn: AssetMaterializationFunction) -> AssetSensorDefinition:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    check.callable_param(fn, 'fn')\n    sensor_name = name or fn.__name__\n\n    def _wrapped_fn(*args, **kwargs) -> Any:\n        result = fn(*args, **kwargs)\n        if inspect.isgenerator(result) or isinstance(result, list):\n            for item in result:\n                yield item\n        elif isinstance(result, (RunRequest, SkipReason)):\n            yield result\n        elif isinstance(result, SensorResult):\n            if result.cursor:\n                raise DagsterInvariantViolationError(f'Error in asset sensor {sensor_name}: Sensor returned a SensorResult with a cursor value. The cursor is managed by the asset sensor and should not be modified by a user.')\n            yield result\n        elif result is not None:\n            raise DagsterInvariantViolationError(f'Error in sensor {sensor_name}: Sensor unexpectedly returned output {result} of type {type(result)}.  Should only return SkipReason or RunRequest objects.')\n    _wrapped_fn = update_wrapper(_wrapped_fn, wrapped=fn)\n    return AssetSensorDefinition(name=sensor_name, asset_key=asset_key, job_name=job_name, asset_materialization_fn=_wrapped_fn, minimum_interval_seconds=minimum_interval_seconds, description=description, job=job, jobs=jobs, default_status=default_status, required_resource_keys=required_resource_keys)",
            "def inner(fn: AssetMaterializationFunction) -> AssetSensorDefinition:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    check.callable_param(fn, 'fn')\n    sensor_name = name or fn.__name__\n\n    def _wrapped_fn(*args, **kwargs) -> Any:\n        result = fn(*args, **kwargs)\n        if inspect.isgenerator(result) or isinstance(result, list):\n            for item in result:\n                yield item\n        elif isinstance(result, (RunRequest, SkipReason)):\n            yield result\n        elif isinstance(result, SensorResult):\n            if result.cursor:\n                raise DagsterInvariantViolationError(f'Error in asset sensor {sensor_name}: Sensor returned a SensorResult with a cursor value. The cursor is managed by the asset sensor and should not be modified by a user.')\n            yield result\n        elif result is not None:\n            raise DagsterInvariantViolationError(f'Error in sensor {sensor_name}: Sensor unexpectedly returned output {result} of type {type(result)}.  Should only return SkipReason or RunRequest objects.')\n    _wrapped_fn = update_wrapper(_wrapped_fn, wrapped=fn)\n    return AssetSensorDefinition(name=sensor_name, asset_key=asset_key, job_name=job_name, asset_materialization_fn=_wrapped_fn, minimum_interval_seconds=minimum_interval_seconds, description=description, job=job, jobs=jobs, default_status=default_status, required_resource_keys=required_resource_keys)",
            "def inner(fn: AssetMaterializationFunction) -> AssetSensorDefinition:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    check.callable_param(fn, 'fn')\n    sensor_name = name or fn.__name__\n\n    def _wrapped_fn(*args, **kwargs) -> Any:\n        result = fn(*args, **kwargs)\n        if inspect.isgenerator(result) or isinstance(result, list):\n            for item in result:\n                yield item\n        elif isinstance(result, (RunRequest, SkipReason)):\n            yield result\n        elif isinstance(result, SensorResult):\n            if result.cursor:\n                raise DagsterInvariantViolationError(f'Error in asset sensor {sensor_name}: Sensor returned a SensorResult with a cursor value. The cursor is managed by the asset sensor and should not be modified by a user.')\n            yield result\n        elif result is not None:\n            raise DagsterInvariantViolationError(f'Error in sensor {sensor_name}: Sensor unexpectedly returned output {result} of type {type(result)}.  Should only return SkipReason or RunRequest objects.')\n    _wrapped_fn = update_wrapper(_wrapped_fn, wrapped=fn)\n    return AssetSensorDefinition(name=sensor_name, asset_key=asset_key, job_name=job_name, asset_materialization_fn=_wrapped_fn, minimum_interval_seconds=minimum_interval_seconds, description=description, job=job, jobs=jobs, default_status=default_status, required_resource_keys=required_resource_keys)"
        ]
    },
    {
        "func_name": "asset_sensor",
        "original": "def asset_sensor(asset_key: AssetKey, *, job_name: Optional[str]=None, name: Optional[str]=None, minimum_interval_seconds: Optional[int]=None, description: Optional[str]=None, job: Optional[ExecutableDefinition]=None, jobs: Optional[Sequence[ExecutableDefinition]]=None, default_status: DefaultSensorStatus=DefaultSensorStatus.STOPPED, required_resource_keys: Optional[Set[str]]=None) -> Callable[[AssetMaterializationFunction], AssetSensorDefinition]:\n    \"\"\"Creates an asset sensor where the decorated function is used as the asset sensor's evaluation\n    function.\n\n    If the asset has been materialized multiple times between since the last sensor tick, the\n    evaluation function will only be invoked once, with the latest materialization.\n\n    The decorated function may:\n\n    1. Return a `RunRequest` object.\n    2. Return a list of `RunRequest` objects.\n    3. Return a `SkipReason` object, providing a descriptive message of why no runs were requested.\n    4. Return nothing (skipping without providing a reason)\n    5. Yield a `SkipReason` or yield one or more `RunRequest` objects.\n\n    Takes a :py:class:`~dagster.SensorEvaluationContext` and an EventLogEntry corresponding to an\n    AssetMaterialization event.\n\n    Args:\n        asset_key (AssetKey): The asset_key this sensor monitors.\n        name (Optional[str]): The name of the sensor. Defaults to the name of the decorated\n            function.\n        minimum_interval_seconds (Optional[int]): The minimum number of seconds that will elapse\n            between sensor evaluations.\n        description (Optional[str]): A human-readable description of the sensor.\n        job (Optional[Union[GraphDefinition, JobDefinition, UnresolvedAssetJobDefinition]]): The\n            job to be executed when the sensor fires.\n        jobs (Optional[Sequence[Union[GraphDefinition, JobDefinition, UnresolvedAssetJobDefinition]]]):\n            (experimental) A list of jobs to be executed when the sensor fires.\n        default_status (DefaultSensorStatus): Whether the sensor starts as running or not. The default\n            status can be overridden from the Dagster UI or via the GraphQL API.\n\n\n    Example:\n        .. code-block:: python\n\n            from dagster import AssetKey, EventLogEntry, SensorEvaluationContext, asset_sensor\n\n\n            @asset_sensor(asset_key=AssetKey(\"my_table\"), job=my_job)\n            def my_asset_sensor(context: SensorEvaluationContext, asset_event: EventLogEntry):\n                return RunRequest(\n                    run_key=context.cursor,\n                    run_config={\n                        \"ops\": {\n                            \"read_materialization\": {\n                                \"config\": {\n                                    \"asset_key\": asset_event.dagster_event.asset_key.path,\n                                }\n                            }\n                        }\n                    },\n                )\n    \"\"\"\n    check.opt_str_param(name, 'name')\n\n    def inner(fn: AssetMaterializationFunction) -> AssetSensorDefinition:\n        check.callable_param(fn, 'fn')\n        sensor_name = name or fn.__name__\n\n        def _wrapped_fn(*args, **kwargs) -> Any:\n            result = fn(*args, **kwargs)\n            if inspect.isgenerator(result) or isinstance(result, list):\n                for item in result:\n                    yield item\n            elif isinstance(result, (RunRequest, SkipReason)):\n                yield result\n            elif isinstance(result, SensorResult):\n                if result.cursor:\n                    raise DagsterInvariantViolationError(f'Error in asset sensor {sensor_name}: Sensor returned a SensorResult with a cursor value. The cursor is managed by the asset sensor and should not be modified by a user.')\n                yield result\n            elif result is not None:\n                raise DagsterInvariantViolationError(f'Error in sensor {sensor_name}: Sensor unexpectedly returned output {result} of type {type(result)}.  Should only return SkipReason or RunRequest objects.')\n        _wrapped_fn = update_wrapper(_wrapped_fn, wrapped=fn)\n        return AssetSensorDefinition(name=sensor_name, asset_key=asset_key, job_name=job_name, asset_materialization_fn=_wrapped_fn, minimum_interval_seconds=minimum_interval_seconds, description=description, job=job, jobs=jobs, default_status=default_status, required_resource_keys=required_resource_keys)\n    return inner",
        "mutated": [
            "def asset_sensor(asset_key: AssetKey, *, job_name: Optional[str]=None, name: Optional[str]=None, minimum_interval_seconds: Optional[int]=None, description: Optional[str]=None, job: Optional[ExecutableDefinition]=None, jobs: Optional[Sequence[ExecutableDefinition]]=None, default_status: DefaultSensorStatus=DefaultSensorStatus.STOPPED, required_resource_keys: Optional[Set[str]]=None) -> Callable[[AssetMaterializationFunction], AssetSensorDefinition]:\n    if False:\n        i = 10\n    'Creates an asset sensor where the decorated function is used as the asset sensor\\'s evaluation\\n    function.\\n\\n    If the asset has been materialized multiple times between since the last sensor tick, the\\n    evaluation function will only be invoked once, with the latest materialization.\\n\\n    The decorated function may:\\n\\n    1. Return a `RunRequest` object.\\n    2. Return a list of `RunRequest` objects.\\n    3. Return a `SkipReason` object, providing a descriptive message of why no runs were requested.\\n    4. Return nothing (skipping without providing a reason)\\n    5. Yield a `SkipReason` or yield one or more `RunRequest` objects.\\n\\n    Takes a :py:class:`~dagster.SensorEvaluationContext` and an EventLogEntry corresponding to an\\n    AssetMaterialization event.\\n\\n    Args:\\n        asset_key (AssetKey): The asset_key this sensor monitors.\\n        name (Optional[str]): The name of the sensor. Defaults to the name of the decorated\\n            function.\\n        minimum_interval_seconds (Optional[int]): The minimum number of seconds that will elapse\\n            between sensor evaluations.\\n        description (Optional[str]): A human-readable description of the sensor.\\n        job (Optional[Union[GraphDefinition, JobDefinition, UnresolvedAssetJobDefinition]]): The\\n            job to be executed when the sensor fires.\\n        jobs (Optional[Sequence[Union[GraphDefinition, JobDefinition, UnresolvedAssetJobDefinition]]]):\\n            (experimental) A list of jobs to be executed when the sensor fires.\\n        default_status (DefaultSensorStatus): Whether the sensor starts as running or not. The default\\n            status can be overridden from the Dagster UI or via the GraphQL API.\\n\\n\\n    Example:\\n        .. code-block:: python\\n\\n            from dagster import AssetKey, EventLogEntry, SensorEvaluationContext, asset_sensor\\n\\n\\n            @asset_sensor(asset_key=AssetKey(\"my_table\"), job=my_job)\\n            def my_asset_sensor(context: SensorEvaluationContext, asset_event: EventLogEntry):\\n                return RunRequest(\\n                    run_key=context.cursor,\\n                    run_config={\\n                        \"ops\": {\\n                            \"read_materialization\": {\\n                                \"config\": {\\n                                    \"asset_key\": asset_event.dagster_event.asset_key.path,\\n                                }\\n                            }\\n                        }\\n                    },\\n                )\\n    '\n    check.opt_str_param(name, 'name')\n\n    def inner(fn: AssetMaterializationFunction) -> AssetSensorDefinition:\n        check.callable_param(fn, 'fn')\n        sensor_name = name or fn.__name__\n\n        def _wrapped_fn(*args, **kwargs) -> Any:\n            result = fn(*args, **kwargs)\n            if inspect.isgenerator(result) or isinstance(result, list):\n                for item in result:\n                    yield item\n            elif isinstance(result, (RunRequest, SkipReason)):\n                yield result\n            elif isinstance(result, SensorResult):\n                if result.cursor:\n                    raise DagsterInvariantViolationError(f'Error in asset sensor {sensor_name}: Sensor returned a SensorResult with a cursor value. The cursor is managed by the asset sensor and should not be modified by a user.')\n                yield result\n            elif result is not None:\n                raise DagsterInvariantViolationError(f'Error in sensor {sensor_name}: Sensor unexpectedly returned output {result} of type {type(result)}.  Should only return SkipReason or RunRequest objects.')\n        _wrapped_fn = update_wrapper(_wrapped_fn, wrapped=fn)\n        return AssetSensorDefinition(name=sensor_name, asset_key=asset_key, job_name=job_name, asset_materialization_fn=_wrapped_fn, minimum_interval_seconds=minimum_interval_seconds, description=description, job=job, jobs=jobs, default_status=default_status, required_resource_keys=required_resource_keys)\n    return inner",
            "def asset_sensor(asset_key: AssetKey, *, job_name: Optional[str]=None, name: Optional[str]=None, minimum_interval_seconds: Optional[int]=None, description: Optional[str]=None, job: Optional[ExecutableDefinition]=None, jobs: Optional[Sequence[ExecutableDefinition]]=None, default_status: DefaultSensorStatus=DefaultSensorStatus.STOPPED, required_resource_keys: Optional[Set[str]]=None) -> Callable[[AssetMaterializationFunction], AssetSensorDefinition]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Creates an asset sensor where the decorated function is used as the asset sensor\\'s evaluation\\n    function.\\n\\n    If the asset has been materialized multiple times between since the last sensor tick, the\\n    evaluation function will only be invoked once, with the latest materialization.\\n\\n    The decorated function may:\\n\\n    1. Return a `RunRequest` object.\\n    2. Return a list of `RunRequest` objects.\\n    3. Return a `SkipReason` object, providing a descriptive message of why no runs were requested.\\n    4. Return nothing (skipping without providing a reason)\\n    5. Yield a `SkipReason` or yield one or more `RunRequest` objects.\\n\\n    Takes a :py:class:`~dagster.SensorEvaluationContext` and an EventLogEntry corresponding to an\\n    AssetMaterialization event.\\n\\n    Args:\\n        asset_key (AssetKey): The asset_key this sensor monitors.\\n        name (Optional[str]): The name of the sensor. Defaults to the name of the decorated\\n            function.\\n        minimum_interval_seconds (Optional[int]): The minimum number of seconds that will elapse\\n            between sensor evaluations.\\n        description (Optional[str]): A human-readable description of the sensor.\\n        job (Optional[Union[GraphDefinition, JobDefinition, UnresolvedAssetJobDefinition]]): The\\n            job to be executed when the sensor fires.\\n        jobs (Optional[Sequence[Union[GraphDefinition, JobDefinition, UnresolvedAssetJobDefinition]]]):\\n            (experimental) A list of jobs to be executed when the sensor fires.\\n        default_status (DefaultSensorStatus): Whether the sensor starts as running or not. The default\\n            status can be overridden from the Dagster UI or via the GraphQL API.\\n\\n\\n    Example:\\n        .. code-block:: python\\n\\n            from dagster import AssetKey, EventLogEntry, SensorEvaluationContext, asset_sensor\\n\\n\\n            @asset_sensor(asset_key=AssetKey(\"my_table\"), job=my_job)\\n            def my_asset_sensor(context: SensorEvaluationContext, asset_event: EventLogEntry):\\n                return RunRequest(\\n                    run_key=context.cursor,\\n                    run_config={\\n                        \"ops\": {\\n                            \"read_materialization\": {\\n                                \"config\": {\\n                                    \"asset_key\": asset_event.dagster_event.asset_key.path,\\n                                }\\n                            }\\n                        }\\n                    },\\n                )\\n    '\n    check.opt_str_param(name, 'name')\n\n    def inner(fn: AssetMaterializationFunction) -> AssetSensorDefinition:\n        check.callable_param(fn, 'fn')\n        sensor_name = name or fn.__name__\n\n        def _wrapped_fn(*args, **kwargs) -> Any:\n            result = fn(*args, **kwargs)\n            if inspect.isgenerator(result) or isinstance(result, list):\n                for item in result:\n                    yield item\n            elif isinstance(result, (RunRequest, SkipReason)):\n                yield result\n            elif isinstance(result, SensorResult):\n                if result.cursor:\n                    raise DagsterInvariantViolationError(f'Error in asset sensor {sensor_name}: Sensor returned a SensorResult with a cursor value. The cursor is managed by the asset sensor and should not be modified by a user.')\n                yield result\n            elif result is not None:\n                raise DagsterInvariantViolationError(f'Error in sensor {sensor_name}: Sensor unexpectedly returned output {result} of type {type(result)}.  Should only return SkipReason or RunRequest objects.')\n        _wrapped_fn = update_wrapper(_wrapped_fn, wrapped=fn)\n        return AssetSensorDefinition(name=sensor_name, asset_key=asset_key, job_name=job_name, asset_materialization_fn=_wrapped_fn, minimum_interval_seconds=minimum_interval_seconds, description=description, job=job, jobs=jobs, default_status=default_status, required_resource_keys=required_resource_keys)\n    return inner",
            "def asset_sensor(asset_key: AssetKey, *, job_name: Optional[str]=None, name: Optional[str]=None, minimum_interval_seconds: Optional[int]=None, description: Optional[str]=None, job: Optional[ExecutableDefinition]=None, jobs: Optional[Sequence[ExecutableDefinition]]=None, default_status: DefaultSensorStatus=DefaultSensorStatus.STOPPED, required_resource_keys: Optional[Set[str]]=None) -> Callable[[AssetMaterializationFunction], AssetSensorDefinition]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Creates an asset sensor where the decorated function is used as the asset sensor\\'s evaluation\\n    function.\\n\\n    If the asset has been materialized multiple times between since the last sensor tick, the\\n    evaluation function will only be invoked once, with the latest materialization.\\n\\n    The decorated function may:\\n\\n    1. Return a `RunRequest` object.\\n    2. Return a list of `RunRequest` objects.\\n    3. Return a `SkipReason` object, providing a descriptive message of why no runs were requested.\\n    4. Return nothing (skipping without providing a reason)\\n    5. Yield a `SkipReason` or yield one or more `RunRequest` objects.\\n\\n    Takes a :py:class:`~dagster.SensorEvaluationContext` and an EventLogEntry corresponding to an\\n    AssetMaterialization event.\\n\\n    Args:\\n        asset_key (AssetKey): The asset_key this sensor monitors.\\n        name (Optional[str]): The name of the sensor. Defaults to the name of the decorated\\n            function.\\n        minimum_interval_seconds (Optional[int]): The minimum number of seconds that will elapse\\n            between sensor evaluations.\\n        description (Optional[str]): A human-readable description of the sensor.\\n        job (Optional[Union[GraphDefinition, JobDefinition, UnresolvedAssetJobDefinition]]): The\\n            job to be executed when the sensor fires.\\n        jobs (Optional[Sequence[Union[GraphDefinition, JobDefinition, UnresolvedAssetJobDefinition]]]):\\n            (experimental) A list of jobs to be executed when the sensor fires.\\n        default_status (DefaultSensorStatus): Whether the sensor starts as running or not. The default\\n            status can be overridden from the Dagster UI or via the GraphQL API.\\n\\n\\n    Example:\\n        .. code-block:: python\\n\\n            from dagster import AssetKey, EventLogEntry, SensorEvaluationContext, asset_sensor\\n\\n\\n            @asset_sensor(asset_key=AssetKey(\"my_table\"), job=my_job)\\n            def my_asset_sensor(context: SensorEvaluationContext, asset_event: EventLogEntry):\\n                return RunRequest(\\n                    run_key=context.cursor,\\n                    run_config={\\n                        \"ops\": {\\n                            \"read_materialization\": {\\n                                \"config\": {\\n                                    \"asset_key\": asset_event.dagster_event.asset_key.path,\\n                                }\\n                            }\\n                        }\\n                    },\\n                )\\n    '\n    check.opt_str_param(name, 'name')\n\n    def inner(fn: AssetMaterializationFunction) -> AssetSensorDefinition:\n        check.callable_param(fn, 'fn')\n        sensor_name = name or fn.__name__\n\n        def _wrapped_fn(*args, **kwargs) -> Any:\n            result = fn(*args, **kwargs)\n            if inspect.isgenerator(result) or isinstance(result, list):\n                for item in result:\n                    yield item\n            elif isinstance(result, (RunRequest, SkipReason)):\n                yield result\n            elif isinstance(result, SensorResult):\n                if result.cursor:\n                    raise DagsterInvariantViolationError(f'Error in asset sensor {sensor_name}: Sensor returned a SensorResult with a cursor value. The cursor is managed by the asset sensor and should not be modified by a user.')\n                yield result\n            elif result is not None:\n                raise DagsterInvariantViolationError(f'Error in sensor {sensor_name}: Sensor unexpectedly returned output {result} of type {type(result)}.  Should only return SkipReason or RunRequest objects.')\n        _wrapped_fn = update_wrapper(_wrapped_fn, wrapped=fn)\n        return AssetSensorDefinition(name=sensor_name, asset_key=asset_key, job_name=job_name, asset_materialization_fn=_wrapped_fn, minimum_interval_seconds=minimum_interval_seconds, description=description, job=job, jobs=jobs, default_status=default_status, required_resource_keys=required_resource_keys)\n    return inner",
            "def asset_sensor(asset_key: AssetKey, *, job_name: Optional[str]=None, name: Optional[str]=None, minimum_interval_seconds: Optional[int]=None, description: Optional[str]=None, job: Optional[ExecutableDefinition]=None, jobs: Optional[Sequence[ExecutableDefinition]]=None, default_status: DefaultSensorStatus=DefaultSensorStatus.STOPPED, required_resource_keys: Optional[Set[str]]=None) -> Callable[[AssetMaterializationFunction], AssetSensorDefinition]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Creates an asset sensor where the decorated function is used as the asset sensor\\'s evaluation\\n    function.\\n\\n    If the asset has been materialized multiple times between since the last sensor tick, the\\n    evaluation function will only be invoked once, with the latest materialization.\\n\\n    The decorated function may:\\n\\n    1. Return a `RunRequest` object.\\n    2. Return a list of `RunRequest` objects.\\n    3. Return a `SkipReason` object, providing a descriptive message of why no runs were requested.\\n    4. Return nothing (skipping without providing a reason)\\n    5. Yield a `SkipReason` or yield one or more `RunRequest` objects.\\n\\n    Takes a :py:class:`~dagster.SensorEvaluationContext` and an EventLogEntry corresponding to an\\n    AssetMaterialization event.\\n\\n    Args:\\n        asset_key (AssetKey): The asset_key this sensor monitors.\\n        name (Optional[str]): The name of the sensor. Defaults to the name of the decorated\\n            function.\\n        minimum_interval_seconds (Optional[int]): The minimum number of seconds that will elapse\\n            between sensor evaluations.\\n        description (Optional[str]): A human-readable description of the sensor.\\n        job (Optional[Union[GraphDefinition, JobDefinition, UnresolvedAssetJobDefinition]]): The\\n            job to be executed when the sensor fires.\\n        jobs (Optional[Sequence[Union[GraphDefinition, JobDefinition, UnresolvedAssetJobDefinition]]]):\\n            (experimental) A list of jobs to be executed when the sensor fires.\\n        default_status (DefaultSensorStatus): Whether the sensor starts as running or not. The default\\n            status can be overridden from the Dagster UI or via the GraphQL API.\\n\\n\\n    Example:\\n        .. code-block:: python\\n\\n            from dagster import AssetKey, EventLogEntry, SensorEvaluationContext, asset_sensor\\n\\n\\n            @asset_sensor(asset_key=AssetKey(\"my_table\"), job=my_job)\\n            def my_asset_sensor(context: SensorEvaluationContext, asset_event: EventLogEntry):\\n                return RunRequest(\\n                    run_key=context.cursor,\\n                    run_config={\\n                        \"ops\": {\\n                            \"read_materialization\": {\\n                                \"config\": {\\n                                    \"asset_key\": asset_event.dagster_event.asset_key.path,\\n                                }\\n                            }\\n                        }\\n                    },\\n                )\\n    '\n    check.opt_str_param(name, 'name')\n\n    def inner(fn: AssetMaterializationFunction) -> AssetSensorDefinition:\n        check.callable_param(fn, 'fn')\n        sensor_name = name or fn.__name__\n\n        def _wrapped_fn(*args, **kwargs) -> Any:\n            result = fn(*args, **kwargs)\n            if inspect.isgenerator(result) or isinstance(result, list):\n                for item in result:\n                    yield item\n            elif isinstance(result, (RunRequest, SkipReason)):\n                yield result\n            elif isinstance(result, SensorResult):\n                if result.cursor:\n                    raise DagsterInvariantViolationError(f'Error in asset sensor {sensor_name}: Sensor returned a SensorResult with a cursor value. The cursor is managed by the asset sensor and should not be modified by a user.')\n                yield result\n            elif result is not None:\n                raise DagsterInvariantViolationError(f'Error in sensor {sensor_name}: Sensor unexpectedly returned output {result} of type {type(result)}.  Should only return SkipReason or RunRequest objects.')\n        _wrapped_fn = update_wrapper(_wrapped_fn, wrapped=fn)\n        return AssetSensorDefinition(name=sensor_name, asset_key=asset_key, job_name=job_name, asset_materialization_fn=_wrapped_fn, minimum_interval_seconds=minimum_interval_seconds, description=description, job=job, jobs=jobs, default_status=default_status, required_resource_keys=required_resource_keys)\n    return inner",
            "def asset_sensor(asset_key: AssetKey, *, job_name: Optional[str]=None, name: Optional[str]=None, minimum_interval_seconds: Optional[int]=None, description: Optional[str]=None, job: Optional[ExecutableDefinition]=None, jobs: Optional[Sequence[ExecutableDefinition]]=None, default_status: DefaultSensorStatus=DefaultSensorStatus.STOPPED, required_resource_keys: Optional[Set[str]]=None) -> Callable[[AssetMaterializationFunction], AssetSensorDefinition]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Creates an asset sensor where the decorated function is used as the asset sensor\\'s evaluation\\n    function.\\n\\n    If the asset has been materialized multiple times between since the last sensor tick, the\\n    evaluation function will only be invoked once, with the latest materialization.\\n\\n    The decorated function may:\\n\\n    1. Return a `RunRequest` object.\\n    2. Return a list of `RunRequest` objects.\\n    3. Return a `SkipReason` object, providing a descriptive message of why no runs were requested.\\n    4. Return nothing (skipping without providing a reason)\\n    5. Yield a `SkipReason` or yield one or more `RunRequest` objects.\\n\\n    Takes a :py:class:`~dagster.SensorEvaluationContext` and an EventLogEntry corresponding to an\\n    AssetMaterialization event.\\n\\n    Args:\\n        asset_key (AssetKey): The asset_key this sensor monitors.\\n        name (Optional[str]): The name of the sensor. Defaults to the name of the decorated\\n            function.\\n        minimum_interval_seconds (Optional[int]): The minimum number of seconds that will elapse\\n            between sensor evaluations.\\n        description (Optional[str]): A human-readable description of the sensor.\\n        job (Optional[Union[GraphDefinition, JobDefinition, UnresolvedAssetJobDefinition]]): The\\n            job to be executed when the sensor fires.\\n        jobs (Optional[Sequence[Union[GraphDefinition, JobDefinition, UnresolvedAssetJobDefinition]]]):\\n            (experimental) A list of jobs to be executed when the sensor fires.\\n        default_status (DefaultSensorStatus): Whether the sensor starts as running or not. The default\\n            status can be overridden from the Dagster UI or via the GraphQL API.\\n\\n\\n    Example:\\n        .. code-block:: python\\n\\n            from dagster import AssetKey, EventLogEntry, SensorEvaluationContext, asset_sensor\\n\\n\\n            @asset_sensor(asset_key=AssetKey(\"my_table\"), job=my_job)\\n            def my_asset_sensor(context: SensorEvaluationContext, asset_event: EventLogEntry):\\n                return RunRequest(\\n                    run_key=context.cursor,\\n                    run_config={\\n                        \"ops\": {\\n                            \"read_materialization\": {\\n                                \"config\": {\\n                                    \"asset_key\": asset_event.dagster_event.asset_key.path,\\n                                }\\n                            }\\n                        }\\n                    },\\n                )\\n    '\n    check.opt_str_param(name, 'name')\n\n    def inner(fn: AssetMaterializationFunction) -> AssetSensorDefinition:\n        check.callable_param(fn, 'fn')\n        sensor_name = name or fn.__name__\n\n        def _wrapped_fn(*args, **kwargs) -> Any:\n            result = fn(*args, **kwargs)\n            if inspect.isgenerator(result) or isinstance(result, list):\n                for item in result:\n                    yield item\n            elif isinstance(result, (RunRequest, SkipReason)):\n                yield result\n            elif isinstance(result, SensorResult):\n                if result.cursor:\n                    raise DagsterInvariantViolationError(f'Error in asset sensor {sensor_name}: Sensor returned a SensorResult with a cursor value. The cursor is managed by the asset sensor and should not be modified by a user.')\n                yield result\n            elif result is not None:\n                raise DagsterInvariantViolationError(f'Error in sensor {sensor_name}: Sensor unexpectedly returned output {result} of type {type(result)}.  Should only return SkipReason or RunRequest objects.')\n        _wrapped_fn = update_wrapper(_wrapped_fn, wrapped=fn)\n        return AssetSensorDefinition(name=sensor_name, asset_key=asset_key, job_name=job_name, asset_materialization_fn=_wrapped_fn, minimum_interval_seconds=minimum_interval_seconds, description=description, job=job, jobs=jobs, default_status=default_status, required_resource_keys=required_resource_keys)\n    return inner"
        ]
    },
    {
        "func_name": "inner",
        "original": "def inner(fn: MultiAssetMaterializationFunction) -> MultiAssetSensorDefinition:\n    check.callable_param(fn, 'fn')\n    sensor_name = name or fn.__name__\n    sensor_def = MultiAssetSensorDefinition(name=sensor_name, monitored_assets=monitored_assets, job_name=job_name, asset_materialization_fn=fn, minimum_interval_seconds=minimum_interval_seconds, description=description, job=job, jobs=jobs, default_status=default_status, request_assets=request_assets, required_resource_keys=required_resource_keys)\n    update_wrapper(sensor_def, wrapped=fn)\n    return sensor_def",
        "mutated": [
            "def inner(fn: MultiAssetMaterializationFunction) -> MultiAssetSensorDefinition:\n    if False:\n        i = 10\n    check.callable_param(fn, 'fn')\n    sensor_name = name or fn.__name__\n    sensor_def = MultiAssetSensorDefinition(name=sensor_name, monitored_assets=monitored_assets, job_name=job_name, asset_materialization_fn=fn, minimum_interval_seconds=minimum_interval_seconds, description=description, job=job, jobs=jobs, default_status=default_status, request_assets=request_assets, required_resource_keys=required_resource_keys)\n    update_wrapper(sensor_def, wrapped=fn)\n    return sensor_def",
            "def inner(fn: MultiAssetMaterializationFunction) -> MultiAssetSensorDefinition:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    check.callable_param(fn, 'fn')\n    sensor_name = name or fn.__name__\n    sensor_def = MultiAssetSensorDefinition(name=sensor_name, monitored_assets=monitored_assets, job_name=job_name, asset_materialization_fn=fn, minimum_interval_seconds=minimum_interval_seconds, description=description, job=job, jobs=jobs, default_status=default_status, request_assets=request_assets, required_resource_keys=required_resource_keys)\n    update_wrapper(sensor_def, wrapped=fn)\n    return sensor_def",
            "def inner(fn: MultiAssetMaterializationFunction) -> MultiAssetSensorDefinition:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    check.callable_param(fn, 'fn')\n    sensor_name = name or fn.__name__\n    sensor_def = MultiAssetSensorDefinition(name=sensor_name, monitored_assets=monitored_assets, job_name=job_name, asset_materialization_fn=fn, minimum_interval_seconds=minimum_interval_seconds, description=description, job=job, jobs=jobs, default_status=default_status, request_assets=request_assets, required_resource_keys=required_resource_keys)\n    update_wrapper(sensor_def, wrapped=fn)\n    return sensor_def",
            "def inner(fn: MultiAssetMaterializationFunction) -> MultiAssetSensorDefinition:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    check.callable_param(fn, 'fn')\n    sensor_name = name or fn.__name__\n    sensor_def = MultiAssetSensorDefinition(name=sensor_name, monitored_assets=monitored_assets, job_name=job_name, asset_materialization_fn=fn, minimum_interval_seconds=minimum_interval_seconds, description=description, job=job, jobs=jobs, default_status=default_status, request_assets=request_assets, required_resource_keys=required_resource_keys)\n    update_wrapper(sensor_def, wrapped=fn)\n    return sensor_def",
            "def inner(fn: MultiAssetMaterializationFunction) -> MultiAssetSensorDefinition:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    check.callable_param(fn, 'fn')\n    sensor_name = name or fn.__name__\n    sensor_def = MultiAssetSensorDefinition(name=sensor_name, monitored_assets=monitored_assets, job_name=job_name, asset_materialization_fn=fn, minimum_interval_seconds=minimum_interval_seconds, description=description, job=job, jobs=jobs, default_status=default_status, request_assets=request_assets, required_resource_keys=required_resource_keys)\n    update_wrapper(sensor_def, wrapped=fn)\n    return sensor_def"
        ]
    },
    {
        "func_name": "multi_asset_sensor",
        "original": "@experimental\ndef multi_asset_sensor(monitored_assets: Union[Sequence[AssetKey], AssetSelection], *, job_name: Optional[str]=None, name: Optional[str]=None, minimum_interval_seconds: Optional[int]=None, description: Optional[str]=None, job: Optional[ExecutableDefinition]=None, jobs: Optional[Sequence[ExecutableDefinition]]=None, default_status: DefaultSensorStatus=DefaultSensorStatus.STOPPED, request_assets: Optional[AssetSelection]=None, required_resource_keys: Optional[Set[str]]=None) -> Callable[[MultiAssetMaterializationFunction], MultiAssetSensorDefinition]:\n    \"\"\"Creates an asset sensor that can monitor multiple assets.\n\n    The decorated function is used as the asset sensor's evaluation\n    function.  The decorated function may:\n\n    1. Return a `RunRequest` object.\n    2. Return a list of `RunRequest` objects.\n    3. Return a `SkipReason` object, providing a descriptive message of why no runs were requested.\n    4. Return nothing (skipping without providing a reason)\n    5. Yield a `SkipReason` or yield one or more `RunRequest` objects.\n\n    Takes a :py:class:`~dagster.MultiAssetSensorEvaluationContext`.\n\n    Args:\n        monitored_assets (Union[Sequence[AssetKey], AssetSelection]): The assets this\n            sensor monitors. If an AssetSelection object is provided, it will only apply to assets\n            within the Definitions that this sensor is part of.\n        name (Optional[str]): The name of the sensor. Defaults to the name of the decorated\n            function.\n        minimum_interval_seconds (Optional[int]): The minimum number of seconds that will elapse\n            between sensor evaluations.\n        description (Optional[str]): A human-readable description of the sensor.\n        job (Optional[Union[GraphDefinition, JobDefinition, UnresolvedAssetJobDefinition]]): The\n            job to be executed when the sensor fires.\n        jobs (Optional[Sequence[Union[GraphDefinition, JobDefinition, UnresolvedAssetJobDefinition]]]):\n            (experimental) A list of jobs to be executed when the sensor fires.\n        default_status (DefaultSensorStatus): Whether the sensor starts as running or not. The default\n            status can be overridden from the Dagster UI or via the GraphQL API.\n        request_assets (Optional[AssetSelection]): (Experimental) an asset selection to launch a run\n            for if the sensor condition is met. This can be provided instead of specifying a job.\n    \"\"\"\n    check.opt_str_param(name, 'name')\n    if not isinstance(monitored_assets, AssetSelection) and (not (isinstance(monitored_assets, collections.abc.Sequence) and all((isinstance(el, AssetKey) for el in monitored_assets)))):\n        check.failed(f'The value passed to monitored_assets param must be either an AssetSelection or a Sequence of AssetKeys, but was a {type(monitored_assets)}')\n\n    def inner(fn: MultiAssetMaterializationFunction) -> MultiAssetSensorDefinition:\n        check.callable_param(fn, 'fn')\n        sensor_name = name or fn.__name__\n        sensor_def = MultiAssetSensorDefinition(name=sensor_name, monitored_assets=monitored_assets, job_name=job_name, asset_materialization_fn=fn, minimum_interval_seconds=minimum_interval_seconds, description=description, job=job, jobs=jobs, default_status=default_status, request_assets=request_assets, required_resource_keys=required_resource_keys)\n        update_wrapper(sensor_def, wrapped=fn)\n        return sensor_def\n    return inner",
        "mutated": [
            "@experimental\ndef multi_asset_sensor(monitored_assets: Union[Sequence[AssetKey], AssetSelection], *, job_name: Optional[str]=None, name: Optional[str]=None, minimum_interval_seconds: Optional[int]=None, description: Optional[str]=None, job: Optional[ExecutableDefinition]=None, jobs: Optional[Sequence[ExecutableDefinition]]=None, default_status: DefaultSensorStatus=DefaultSensorStatus.STOPPED, request_assets: Optional[AssetSelection]=None, required_resource_keys: Optional[Set[str]]=None) -> Callable[[MultiAssetMaterializationFunction], MultiAssetSensorDefinition]:\n    if False:\n        i = 10\n    \"Creates an asset sensor that can monitor multiple assets.\\n\\n    The decorated function is used as the asset sensor's evaluation\\n    function.  The decorated function may:\\n\\n    1. Return a `RunRequest` object.\\n    2. Return a list of `RunRequest` objects.\\n    3. Return a `SkipReason` object, providing a descriptive message of why no runs were requested.\\n    4. Return nothing (skipping without providing a reason)\\n    5. Yield a `SkipReason` or yield one or more `RunRequest` objects.\\n\\n    Takes a :py:class:`~dagster.MultiAssetSensorEvaluationContext`.\\n\\n    Args:\\n        monitored_assets (Union[Sequence[AssetKey], AssetSelection]): The assets this\\n            sensor monitors. If an AssetSelection object is provided, it will only apply to assets\\n            within the Definitions that this sensor is part of.\\n        name (Optional[str]): The name of the sensor. Defaults to the name of the decorated\\n            function.\\n        minimum_interval_seconds (Optional[int]): The minimum number of seconds that will elapse\\n            between sensor evaluations.\\n        description (Optional[str]): A human-readable description of the sensor.\\n        job (Optional[Union[GraphDefinition, JobDefinition, UnresolvedAssetJobDefinition]]): The\\n            job to be executed when the sensor fires.\\n        jobs (Optional[Sequence[Union[GraphDefinition, JobDefinition, UnresolvedAssetJobDefinition]]]):\\n            (experimental) A list of jobs to be executed when the sensor fires.\\n        default_status (DefaultSensorStatus): Whether the sensor starts as running or not. The default\\n            status can be overridden from the Dagster UI or via the GraphQL API.\\n        request_assets (Optional[AssetSelection]): (Experimental) an asset selection to launch a run\\n            for if the sensor condition is met. This can be provided instead of specifying a job.\\n    \"\n    check.opt_str_param(name, 'name')\n    if not isinstance(monitored_assets, AssetSelection) and (not (isinstance(monitored_assets, collections.abc.Sequence) and all((isinstance(el, AssetKey) for el in monitored_assets)))):\n        check.failed(f'The value passed to monitored_assets param must be either an AssetSelection or a Sequence of AssetKeys, but was a {type(monitored_assets)}')\n\n    def inner(fn: MultiAssetMaterializationFunction) -> MultiAssetSensorDefinition:\n        check.callable_param(fn, 'fn')\n        sensor_name = name or fn.__name__\n        sensor_def = MultiAssetSensorDefinition(name=sensor_name, monitored_assets=monitored_assets, job_name=job_name, asset_materialization_fn=fn, minimum_interval_seconds=minimum_interval_seconds, description=description, job=job, jobs=jobs, default_status=default_status, request_assets=request_assets, required_resource_keys=required_resource_keys)\n        update_wrapper(sensor_def, wrapped=fn)\n        return sensor_def\n    return inner",
            "@experimental\ndef multi_asset_sensor(monitored_assets: Union[Sequence[AssetKey], AssetSelection], *, job_name: Optional[str]=None, name: Optional[str]=None, minimum_interval_seconds: Optional[int]=None, description: Optional[str]=None, job: Optional[ExecutableDefinition]=None, jobs: Optional[Sequence[ExecutableDefinition]]=None, default_status: DefaultSensorStatus=DefaultSensorStatus.STOPPED, request_assets: Optional[AssetSelection]=None, required_resource_keys: Optional[Set[str]]=None) -> Callable[[MultiAssetMaterializationFunction], MultiAssetSensorDefinition]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Creates an asset sensor that can monitor multiple assets.\\n\\n    The decorated function is used as the asset sensor's evaluation\\n    function.  The decorated function may:\\n\\n    1. Return a `RunRequest` object.\\n    2. Return a list of `RunRequest` objects.\\n    3. Return a `SkipReason` object, providing a descriptive message of why no runs were requested.\\n    4. Return nothing (skipping without providing a reason)\\n    5. Yield a `SkipReason` or yield one or more `RunRequest` objects.\\n\\n    Takes a :py:class:`~dagster.MultiAssetSensorEvaluationContext`.\\n\\n    Args:\\n        monitored_assets (Union[Sequence[AssetKey], AssetSelection]): The assets this\\n            sensor monitors. If an AssetSelection object is provided, it will only apply to assets\\n            within the Definitions that this sensor is part of.\\n        name (Optional[str]): The name of the sensor. Defaults to the name of the decorated\\n            function.\\n        minimum_interval_seconds (Optional[int]): The minimum number of seconds that will elapse\\n            between sensor evaluations.\\n        description (Optional[str]): A human-readable description of the sensor.\\n        job (Optional[Union[GraphDefinition, JobDefinition, UnresolvedAssetJobDefinition]]): The\\n            job to be executed when the sensor fires.\\n        jobs (Optional[Sequence[Union[GraphDefinition, JobDefinition, UnresolvedAssetJobDefinition]]]):\\n            (experimental) A list of jobs to be executed when the sensor fires.\\n        default_status (DefaultSensorStatus): Whether the sensor starts as running or not. The default\\n            status can be overridden from the Dagster UI or via the GraphQL API.\\n        request_assets (Optional[AssetSelection]): (Experimental) an asset selection to launch a run\\n            for if the sensor condition is met. This can be provided instead of specifying a job.\\n    \"\n    check.opt_str_param(name, 'name')\n    if not isinstance(monitored_assets, AssetSelection) and (not (isinstance(monitored_assets, collections.abc.Sequence) and all((isinstance(el, AssetKey) for el in monitored_assets)))):\n        check.failed(f'The value passed to monitored_assets param must be either an AssetSelection or a Sequence of AssetKeys, but was a {type(monitored_assets)}')\n\n    def inner(fn: MultiAssetMaterializationFunction) -> MultiAssetSensorDefinition:\n        check.callable_param(fn, 'fn')\n        sensor_name = name or fn.__name__\n        sensor_def = MultiAssetSensorDefinition(name=sensor_name, monitored_assets=monitored_assets, job_name=job_name, asset_materialization_fn=fn, minimum_interval_seconds=minimum_interval_seconds, description=description, job=job, jobs=jobs, default_status=default_status, request_assets=request_assets, required_resource_keys=required_resource_keys)\n        update_wrapper(sensor_def, wrapped=fn)\n        return sensor_def\n    return inner",
            "@experimental\ndef multi_asset_sensor(monitored_assets: Union[Sequence[AssetKey], AssetSelection], *, job_name: Optional[str]=None, name: Optional[str]=None, minimum_interval_seconds: Optional[int]=None, description: Optional[str]=None, job: Optional[ExecutableDefinition]=None, jobs: Optional[Sequence[ExecutableDefinition]]=None, default_status: DefaultSensorStatus=DefaultSensorStatus.STOPPED, request_assets: Optional[AssetSelection]=None, required_resource_keys: Optional[Set[str]]=None) -> Callable[[MultiAssetMaterializationFunction], MultiAssetSensorDefinition]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Creates an asset sensor that can monitor multiple assets.\\n\\n    The decorated function is used as the asset sensor's evaluation\\n    function.  The decorated function may:\\n\\n    1. Return a `RunRequest` object.\\n    2. Return a list of `RunRequest` objects.\\n    3. Return a `SkipReason` object, providing a descriptive message of why no runs were requested.\\n    4. Return nothing (skipping without providing a reason)\\n    5. Yield a `SkipReason` or yield one or more `RunRequest` objects.\\n\\n    Takes a :py:class:`~dagster.MultiAssetSensorEvaluationContext`.\\n\\n    Args:\\n        monitored_assets (Union[Sequence[AssetKey], AssetSelection]): The assets this\\n            sensor monitors. If an AssetSelection object is provided, it will only apply to assets\\n            within the Definitions that this sensor is part of.\\n        name (Optional[str]): The name of the sensor. Defaults to the name of the decorated\\n            function.\\n        minimum_interval_seconds (Optional[int]): The minimum number of seconds that will elapse\\n            between sensor evaluations.\\n        description (Optional[str]): A human-readable description of the sensor.\\n        job (Optional[Union[GraphDefinition, JobDefinition, UnresolvedAssetJobDefinition]]): The\\n            job to be executed when the sensor fires.\\n        jobs (Optional[Sequence[Union[GraphDefinition, JobDefinition, UnresolvedAssetJobDefinition]]]):\\n            (experimental) A list of jobs to be executed when the sensor fires.\\n        default_status (DefaultSensorStatus): Whether the sensor starts as running or not. The default\\n            status can be overridden from the Dagster UI or via the GraphQL API.\\n        request_assets (Optional[AssetSelection]): (Experimental) an asset selection to launch a run\\n            for if the sensor condition is met. This can be provided instead of specifying a job.\\n    \"\n    check.opt_str_param(name, 'name')\n    if not isinstance(monitored_assets, AssetSelection) and (not (isinstance(monitored_assets, collections.abc.Sequence) and all((isinstance(el, AssetKey) for el in monitored_assets)))):\n        check.failed(f'The value passed to monitored_assets param must be either an AssetSelection or a Sequence of AssetKeys, but was a {type(monitored_assets)}')\n\n    def inner(fn: MultiAssetMaterializationFunction) -> MultiAssetSensorDefinition:\n        check.callable_param(fn, 'fn')\n        sensor_name = name or fn.__name__\n        sensor_def = MultiAssetSensorDefinition(name=sensor_name, monitored_assets=monitored_assets, job_name=job_name, asset_materialization_fn=fn, minimum_interval_seconds=minimum_interval_seconds, description=description, job=job, jobs=jobs, default_status=default_status, request_assets=request_assets, required_resource_keys=required_resource_keys)\n        update_wrapper(sensor_def, wrapped=fn)\n        return sensor_def\n    return inner",
            "@experimental\ndef multi_asset_sensor(monitored_assets: Union[Sequence[AssetKey], AssetSelection], *, job_name: Optional[str]=None, name: Optional[str]=None, minimum_interval_seconds: Optional[int]=None, description: Optional[str]=None, job: Optional[ExecutableDefinition]=None, jobs: Optional[Sequence[ExecutableDefinition]]=None, default_status: DefaultSensorStatus=DefaultSensorStatus.STOPPED, request_assets: Optional[AssetSelection]=None, required_resource_keys: Optional[Set[str]]=None) -> Callable[[MultiAssetMaterializationFunction], MultiAssetSensorDefinition]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Creates an asset sensor that can monitor multiple assets.\\n\\n    The decorated function is used as the asset sensor's evaluation\\n    function.  The decorated function may:\\n\\n    1. Return a `RunRequest` object.\\n    2. Return a list of `RunRequest` objects.\\n    3. Return a `SkipReason` object, providing a descriptive message of why no runs were requested.\\n    4. Return nothing (skipping without providing a reason)\\n    5. Yield a `SkipReason` or yield one or more `RunRequest` objects.\\n\\n    Takes a :py:class:`~dagster.MultiAssetSensorEvaluationContext`.\\n\\n    Args:\\n        monitored_assets (Union[Sequence[AssetKey], AssetSelection]): The assets this\\n            sensor monitors. If an AssetSelection object is provided, it will only apply to assets\\n            within the Definitions that this sensor is part of.\\n        name (Optional[str]): The name of the sensor. Defaults to the name of the decorated\\n            function.\\n        minimum_interval_seconds (Optional[int]): The minimum number of seconds that will elapse\\n            between sensor evaluations.\\n        description (Optional[str]): A human-readable description of the sensor.\\n        job (Optional[Union[GraphDefinition, JobDefinition, UnresolvedAssetJobDefinition]]): The\\n            job to be executed when the sensor fires.\\n        jobs (Optional[Sequence[Union[GraphDefinition, JobDefinition, UnresolvedAssetJobDefinition]]]):\\n            (experimental) A list of jobs to be executed when the sensor fires.\\n        default_status (DefaultSensorStatus): Whether the sensor starts as running or not. The default\\n            status can be overridden from the Dagster UI or via the GraphQL API.\\n        request_assets (Optional[AssetSelection]): (Experimental) an asset selection to launch a run\\n            for if the sensor condition is met. This can be provided instead of specifying a job.\\n    \"\n    check.opt_str_param(name, 'name')\n    if not isinstance(monitored_assets, AssetSelection) and (not (isinstance(monitored_assets, collections.abc.Sequence) and all((isinstance(el, AssetKey) for el in monitored_assets)))):\n        check.failed(f'The value passed to monitored_assets param must be either an AssetSelection or a Sequence of AssetKeys, but was a {type(monitored_assets)}')\n\n    def inner(fn: MultiAssetMaterializationFunction) -> MultiAssetSensorDefinition:\n        check.callable_param(fn, 'fn')\n        sensor_name = name or fn.__name__\n        sensor_def = MultiAssetSensorDefinition(name=sensor_name, monitored_assets=monitored_assets, job_name=job_name, asset_materialization_fn=fn, minimum_interval_seconds=minimum_interval_seconds, description=description, job=job, jobs=jobs, default_status=default_status, request_assets=request_assets, required_resource_keys=required_resource_keys)\n        update_wrapper(sensor_def, wrapped=fn)\n        return sensor_def\n    return inner",
            "@experimental\ndef multi_asset_sensor(monitored_assets: Union[Sequence[AssetKey], AssetSelection], *, job_name: Optional[str]=None, name: Optional[str]=None, minimum_interval_seconds: Optional[int]=None, description: Optional[str]=None, job: Optional[ExecutableDefinition]=None, jobs: Optional[Sequence[ExecutableDefinition]]=None, default_status: DefaultSensorStatus=DefaultSensorStatus.STOPPED, request_assets: Optional[AssetSelection]=None, required_resource_keys: Optional[Set[str]]=None) -> Callable[[MultiAssetMaterializationFunction], MultiAssetSensorDefinition]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Creates an asset sensor that can monitor multiple assets.\\n\\n    The decorated function is used as the asset sensor's evaluation\\n    function.  The decorated function may:\\n\\n    1. Return a `RunRequest` object.\\n    2. Return a list of `RunRequest` objects.\\n    3. Return a `SkipReason` object, providing a descriptive message of why no runs were requested.\\n    4. Return nothing (skipping without providing a reason)\\n    5. Yield a `SkipReason` or yield one or more `RunRequest` objects.\\n\\n    Takes a :py:class:`~dagster.MultiAssetSensorEvaluationContext`.\\n\\n    Args:\\n        monitored_assets (Union[Sequence[AssetKey], AssetSelection]): The assets this\\n            sensor monitors. If an AssetSelection object is provided, it will only apply to assets\\n            within the Definitions that this sensor is part of.\\n        name (Optional[str]): The name of the sensor. Defaults to the name of the decorated\\n            function.\\n        minimum_interval_seconds (Optional[int]): The minimum number of seconds that will elapse\\n            between sensor evaluations.\\n        description (Optional[str]): A human-readable description of the sensor.\\n        job (Optional[Union[GraphDefinition, JobDefinition, UnresolvedAssetJobDefinition]]): The\\n            job to be executed when the sensor fires.\\n        jobs (Optional[Sequence[Union[GraphDefinition, JobDefinition, UnresolvedAssetJobDefinition]]]):\\n            (experimental) A list of jobs to be executed when the sensor fires.\\n        default_status (DefaultSensorStatus): Whether the sensor starts as running or not. The default\\n            status can be overridden from the Dagster UI or via the GraphQL API.\\n        request_assets (Optional[AssetSelection]): (Experimental) an asset selection to launch a run\\n            for if the sensor condition is met. This can be provided instead of specifying a job.\\n    \"\n    check.opt_str_param(name, 'name')\n    if not isinstance(monitored_assets, AssetSelection) and (not (isinstance(monitored_assets, collections.abc.Sequence) and all((isinstance(el, AssetKey) for el in monitored_assets)))):\n        check.failed(f'The value passed to monitored_assets param must be either an AssetSelection or a Sequence of AssetKeys, but was a {type(monitored_assets)}')\n\n    def inner(fn: MultiAssetMaterializationFunction) -> MultiAssetSensorDefinition:\n        check.callable_param(fn, 'fn')\n        sensor_name = name or fn.__name__\n        sensor_def = MultiAssetSensorDefinition(name=sensor_name, monitored_assets=monitored_assets, job_name=job_name, asset_materialization_fn=fn, minimum_interval_seconds=minimum_interval_seconds, description=description, job=job, jobs=jobs, default_status=default_status, request_assets=request_assets, required_resource_keys=required_resource_keys)\n        update_wrapper(sensor_def, wrapped=fn)\n        return sensor_def\n    return inner"
        ]
    }
]