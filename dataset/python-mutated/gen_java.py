import re
import textwrap
import bindings as bi

class JavaTypeTranslator(bi.TypeTranslator):

    def __init__(self):
        if False:
            print('Hello World!')
        bi.TypeTranslator.__init__(self)
        self.types['string'] = 'String'
type_adapter = JavaTypeTranslator()

def translate_type(h2o_type, schema):
    if False:
        print('Hello World!')
    return type_adapter.translate(h2o_type, schema)

def get_java_value(field):
    if False:
        while True:
            i = 10
    value = field['value']
    h2o_type = field['type']
    java_type = translate_type(h2o_type, field['schema_name'])
    if java_type == 'float' and value == 'Infinity':
        return 'Float.POSITIVE_INFINITY'
    if java_type == 'double' and value == 'Infinity':
        return 'Double.POSITIVE_INFINITY'
    if java_type == 'long':
        return str(value) + 'L'
    if java_type == 'float':
        return str(value) + 'f'
    if java_type == 'boolean':
        return str(value).lower()
    if java_type == 'String' and (value == '' or value is None):
        return '""'
    if java_type == 'String':
        return '"%s"' % value
    if value is None:
        return 'null'
    if h2o_type.startswith('enum'):
        return field['schema_name'] + '.' + value
    if h2o_type.endswith('[][]'):
        return 'null'
    if h2o_type.endswith('[]'):
        basetype = field['schema_name'] if field['is_schema'] else h2o_type.partition('[')[0]
        if basetype == 'Iced':
            basetype = 'Object'
        return 'new %s[]{%s}' % (basetype, str(value)[1:-1])
    if h2o_type.startswith('Map'):
        return 'null'
    if h2o_type.startswith('Key'):
        return 'null'
    return value

def translate_name(name):
    if False:
        return 10
    '\n    Convert names with underscores into camelcase.\n\n    For example:\n        "num_rows" => "numRows"\n        "very_long_json_name" => "veryLongJsonName"\n        "build_GBM_model" => "buildGbmModel"\n        "KEY" => "key"\n        "middle___underscores" => "middleUnderscores"\n        "_exclude_fields" => "_excludeFields" (retain initial/trailing underscores)\n        "__http_status__" => "__httpStatus__"\n\n    :param name: name to be converted\n    '
    parts = name.split('_')
    i = 0
    while parts[i] == '':
        parts[i] = '_'
        i += 1
    parts[i] = parts[i].lower()
    for j in range(i + 1, len(parts)):
        parts[j] = parts[j].capitalize()
    i = len(parts) - 1
    while parts[i] == '':
        parts[i] = '_'
        i -= 1
    return ''.join(parts)

def dedent(ind, text):
    if False:
        i = 10
        return i + 15
    '\n    Dedent text to the specific indentation level.\n\n    :param ind: common indentation level for the resulting text (number of spaces to append to every line)\n    :param text: text that should be transformed.\n    :return: ``text`` with all common indentation removed, and then the specified amount of indentation added.\n    '
    text2 = textwrap.dedent(text)
    if ind == 0:
        return text2
    indent_str = ' ' * ind
    return '\n'.join((indent_str + line for line in text2.split('\n')))

def generate_schema(class_name, schema):
    if False:
        while True:
            i = 10
    '\n    Generate schema Java class.\n\n    :param class_name: name of the class\n    :param schema: information about the class\n    '
    superclass = schema['superclass']
    if superclass == 'Schema':
        superclass = 'Object'
    has_map = False
    is_model_builder = False
    has_inherited = False
    for field in schema['fields']:
        if field['name'] == '__meta':
            continue
        if field['is_inherited']:
            has_inherited = True
            continue
        if field['type'].startswith('Map'):
            has_map = True
        if field['name'] == 'can_build':
            is_model_builder = True
    fields = []
    for field in schema['fields']:
        if field['name'] == '__meta':
            continue
        java_type = translate_type(field['type'], field['schema_name'])
        java_value = get_java_value(field)
        if False and is_model_builder and (field['name'] == 'parameters'):
            fields.append(('parameters', 'null', 'ModelParameterSchemaV3[]', field['help'], field['is_inherited']))
        else:
            fields.append((field['name'], java_value, java_type, field['help'], field['is_inherited']))
    class_decl = class_name
    if 'generics' in schema:
        class_decl += '<' + ', '.join(('%s extends %s' % (t, long_type) for (t, long_type) in schema['generics'])) + '>'
    super_decl = superclass
    if 'super_generics' in schema:
        super_decl += '<' + ', '.join(schema['super_generics']) + '>'
    yield '/*'
    yield ' * This file is auto-generated by h2o-3/h2o-bindings/bin/gen_java.py'
    yield ' * Copyright 2016 H2O.ai;  Apache License Version 2.0 (see LICENSE for details)'
    yield ' */'
    yield 'package water.bindings.pojos;'
    yield ''
    yield 'import com.google.gson.Gson;'
    yield 'import com.google.gson.annotations.*;'
    yield ('import java.util.Map;' if has_map else None)
    yield ''
    yield ''
    yield ('public class %s extends %s {' % (class_decl, super_decl) if super_decl != 'Object' else None)
    yield ('public class %s {' % class_decl if super_decl == 'Object' else None)
    yield ''
    for (name, value, ftype, fhelp, inherited) in fields:
        if inherited:
            continue
        ccname = translate_name(name)
        yield '    /**'
        yield bi.wrap(fhelp, indent='     * ')
        yield '     */'
        yield ('    @SerializedName("%s")' % name if name != ccname else None)
        yield ('    public %s %s;' % (ftype, ccname))
        yield ''
    if has_inherited:
        yield ''
        yield ('    /*' + '-' * 114)
        yield ('    //' + ' ' * 50 + 'INHERITED')
        yield ('    //' + '-' * 114)
        yield ''
        for (name, value, ftype, fhelp, inherited) in fields:
            if not inherited:
                continue
            yield bi.wrap(fhelp, '    // ')
            yield ('    public %s %s;' % (ftype, translate_name(name)))
            yield ''
        yield '    */'
        yield ''
    yield '    /**'
    yield '     * Public constructor'
    yield '     */'
    yield ('    public %s() {' % class_name)
    for (name, value, _, _, _) in fields:
        if name == 'parameters':
            continue
        if value == 'null':
            continue
        yield ('        %s = %s;' % (translate_name(name), value))
    yield '    }'
    yield ''
    yield '    /**'
    yield '     * Return the contents of this object as a JSON String.'
    yield '     */'
    yield '    @Override'
    yield '    public String toString() {'
    yield '        return new Gson().toJson(this);'
    yield '    }'
    yield ''
    yield '}'

def generate_enum(name, values):
    if False:
        return 10
    if {'enum', 'int', 'double', 'boolean', 'long', 'byte', 'class', 'lambda', 'null'} & set(values):
        values = [v.upper() for v in values]
    yield '/*'
    yield ' * This file is auto-generated by h2o-3/h2o-bindings/bin/gen_java.py'
    yield ' * Copyright 2016 H2O.ai;  Apache License Version 2.0 (see LICENSE for details)'
    yield ' */'
    yield 'package water.bindings.pojos;'
    yield ''
    yield ('public enum ' + name + ' {')
    for value in values:
        yield ('    %s,' % value)
    yield '}'

def generate_proxy(classname, endpoints):
    if False:
        while True:
            i = 10
    '\n    Generate a Retrofit Proxy class.\n\n    Retrofit interfaces look like this:\n        public interface GitHubService {\n            @GET("/users/{user}/repos")\n            Call<List<Repo>> listRepos(@Path("user") String user);\n        }\n      :param classname: name of the class\n      :param endpoints: list of endpoints served by this class\n    '
    var_pattern = re.compile('\\{(\\w+)\\}')
    helper_class = []
    found_key_array_parameter = False
    yield '/*'
    yield ' * This file is auto-generated by h2o-3/h2o-bindings/bin/gen_java.py'
    yield ' * Copyright 2016 H2O.ai;  Apache License Version 2.0 (see LICENSE for details)'
    yield ' */'
    yield 'package water.bindings.proxies.retrofit;'
    yield ''
    yield 'import water.bindings.pojos.*;'
    yield 'import retrofit2.*;'
    yield 'import retrofit2.http.*;'
    yield ('import java.util.Map;' if classname == 'Grid' or classname == 'ModelBuilders' else None)
    yield ''
    yield ('public interface ' + classname + ' {')
    yield ''
    for e in endpoints:
        method = e['handler_method']
        if method == 'exec':
            method = e['api_name']
        param_strs = []
        required_param_strs = []
        for field in e['input_params']:
            fname = field['name']
            if field['is_path_param']:
                ftype = 'Path'
            elif e['http_method'] == 'GET':
                ftype = 'Query'
            else:
                ftype = 'Field'
            ptype = translate_type(field['type'], field['schema_name'])
            if ptype.endswith('KeyV3') or ptype == 'ColSpecifierV3':
                ptype = 'String'
            if ptype.endswith('KeyV3[]'):
                ptype = 'String[]'
            param_str = '@{ftype}("{fname}") {ptype} {fname}'.format(**locals())
            param_strs.append(param_str)
            if field['required']:
                required_param_strs.append(param_str)
        if len(param_strs) == len(required_param_strs):
            required_param_strs = None
        yield u'  /** '
        yield bi.wrap(e['summary'], indent='   * ')
        for field in e['input_params']:
            s = '   *   @param %s ' % field['name']
            yield (s + bi.wrap(field['help'], indent='   *' + ' ' * (len(s) - 4), indent_first=False))
        yield u'   */'
        for params in [param_strs, required_param_strs]:
            if params is None:
                continue
            yield (u'  @FormUrlEncoded' if e['http_method'] == 'POST' else None)
            yield u'  @{method}("{path}")'.format(method=e['http_method'], path=e['url_pattern'])
            if len(params) <= 1:
                args = params[0] if params else ''
                yield '  Call<{schema}> {method}({args});'.format(schema=e['output_schema'], method=method, args=args)
            else:
                yield '  Call<{schema}> {method}('.format(schema=e['output_schema'], method=method)
                for arg in params:
                    yield ('    ' + arg + ('' if arg == params[-1] else ','))
                yield '  );'
            yield ''
        if 'algo' in e:
            helper_class.append('    /**')
            helper_class.append(bi.wrap(e['summary'], indent='     * '))
            helper_class.append('     */')
            helper_class.append('    public static Call<{oschema}> {method}({outer_class} z, {ischema} p) {{'.format(ischema=e['input_schema'], oschema=e['output_schema'], method=method, outer_class=classname))
            helper_class.append('      return z.{method}('.format(method=method))
            for field in e['input_params']:
                ptype = translate_type(field['type'], field['schema_name'])
                pname = translate_name(field['name'])
                if ptype.endswith('KeyV3'):
                    s = '(p.{parm} == null? null : p.{parm}.name)'.format(parm=pname)
                elif ptype.endswith('KeyV3[]'):
                    found_key_array_parameter = True
                    s = '(p.{parm} == null? null : keyArrayToStringArray(p.{parm}))'.format(parm=pname)
                elif ptype == 'ColSpecifierV3':
                    s = '(p.{parm} == null? null : p.{parm}.columnName)'.format(parm=pname)
                else:
                    s = 'p.' + pname
                if field != e['input_params'][-1]:
                    s += ','
                helper_class.append('        ' + s)
            helper_class.append('      );')
            helper_class.append('    }')
            helper_class.append('')
    if helper_class:
        yield ''
        yield '  @SuppressWarnings("unused")'
        yield '  class Helper {'
        for line in helper_class:
            yield line
        if found_key_array_parameter:
            yield '    /**'
            yield '     * Return an array of Strings for an array of keys.'
            yield '     */'
            yield '    public static String[] keyArrayToStringArray(KeyV3[] keys) {'
            yield '      if (keys == null) return null;'
            yield '      String[] ids = new String[keys.length];'
            yield '      int i = 0;'
            yield '      for (KeyV3 key : keys) ids[i++] = key.name;'
            yield '      return ids;'
            yield '    }'
        yield '  }'
        yield ''
    yield '}'

def generate_main_class(endpoints):
    if False:
        while True:
            i = 10
    yield dedent(0, '\n        /*\n         * This file is auto-generated by h2o-3/h2o-bindings/bin/gen_java.py\n         * Copyright 2016 H2O.ai;  Apache License Version 2.0 (see LICENSE for details)\n         */\n        package water.bindings;\n\n        import water.bindings.pojos.*;\n        import water.bindings.proxies.retrofit.*;\n        import retrofit2.*;\n        import retrofit2.converter.gson.GsonConverterFactory;\n        import com.google.gson.*;\n        import com.google.gson.reflect.TypeToken;\n        import com.google.gson.stream.JsonReader;\n        import com.google.gson.stream.JsonWriter;\n        import okhttp3.OkHttpClient;\n        import java.io.IOException;\n        import java.util.concurrent.TimeUnit;\n        import java.lang.reflect.Array;\n        import java.lang.reflect.Field;\n        import java.lang.reflect.InvocationTargetException;\n        import java.lang.reflect.Type;\n\n\n        @SuppressWarnings("unused")\n        public class H2oApi {\n\n          public static String DEFAULT_URL = "http://localhost:54321/";\n\n          public H2oApi() {\n            this(DEFAULT_URL);\n          }\n          public H2oApi(String url) {\n            _url = url;\n          }\n\n          public H2oApi setUrl(String url) {\n            _url = url;\n            retrofit = null;\n            return this;\n          }\n\n          public H2oApi setTimeout(int t) {\n            timeout_s = t;\n            retrofit = null;\n            return this;\n          }\n\n          /**\n           * Set time interval for job polling in {@link #waitForJobCompletion(JobKeyV3)}.\n           *   @param millis time interval, in milliseconds\n           */\n          public H2oApi setJobPollInterval(int millis) {\n            pollInterval_ms = millis;\n            return this;\n          }\n\n          /**\n           * Continuously poll server for the status of the given job, until it completes.\n           *   @param jobKey job to query\n           *   @return the finished job\n           */\n          public JobV3 waitForJobCompletion(JobKeyV3 jobKey) {\n            return waitForJobCompletion(keyToString(jobKey));\n          }\n          public JobV3 waitForJobCompletion(String jobId) {\n            Jobs jobService = getService(Jobs.class);\n            Response<JobsV3> jobsResponse = null;\n            int retries = 3;\n            JobsV3 jobs = null;\n            do {\n              try {\n                Thread.sleep(pollInterval_ms);\n                jobsResponse = jobService.fetch(jobId).execute();\n              } catch (IOException e) {\n                System.err.println("Caught exception: " + e);\n              } catch (InterruptedException e) { /* pass */ }\n              if (jobsResponse == null || !jobsResponse.isSuccessful())\n                if (retries-- > 0)\n                  continue;\n                else\n                  throw new RuntimeException("/3/Jobs/" + jobId + " failed 3 times.");\n              jobs = jobsResponse.body();\n              if (jobs.jobs == null || jobs.jobs.length != 1)\n                throw new RuntimeException("Failed to find Job: " + jobId);\n            } while (jobs != null && jobs.jobs[0].status.equals("RUNNING"));\n            return jobs == null? null : jobs.jobs[0];\n          }\n\n        ')
    for route in endpoints:
        apiname = route['api_name']
        class_name = route['class_name']
        outtype = route['output_schema']
        input_fields = route['input_params']
        required_fields = [field for field in input_fields if field['required']]
        input_fields_wo_excluded = [field for field in input_fields if field['name'] != '_exclude_fields']
        if class_name == 'SegmentModelsBuilders':
            continue
        yield '  /**'
        yield bi.wrap(route['summary'], indent='   * ')
        yield '   */'
        li = len(input_fields)
        le = len(input_fields_wo_excluded)
        lr = len(required_fields)
        assert lr <= 3, 'Too many required fields in method ' + apiname
        if lr == li:
            input_fields = None
            input_fields_wo_excluded = None
        elif le == li or le == lr or li >= 4:
            input_fields_wo_excluded = None
        if 'parse' == apiname:
            required_fields = None
        for fields in [required_fields, input_fields_wo_excluded, input_fields]:
            if fields is None:
                continue
            use_schema_param = len(fields) >= 4
            value_field_strs = []
            typed_field_strs = []
            for field in fields:
                ftype = translate_type(field['type'], field['schema_name'])
                fname = translate_name(field['name'])
                typed_field_strs.append('%s %s' % (ftype, fname))
                if use_schema_param:
                    fname = 'params.' + fname
                if ftype.endswith('KeyV3'):
                    s = 'keyToString(%s)' % fname
                elif ftype.endswith('KeyV3[]'):
                    s = 'keyArrayToStringArray(%s)' % fname
                elif ftype == 'ColSpecifierV3':
                    s = 'colToString(%s)' % fname
                else:
                    s = fname
                value_field_strs.append(s)
            if use_schema_param:
                args = route['input_schema'] + ' params'
                values = '\n      ' + ',\n      '.join(value_field_strs) + '\n    '
            else:
                args = ', '.join(typed_field_strs)
                values = ', '.join(value_field_strs)
                if fields == input_fields_wo_excluded:
                    values += ', ""'
            method = apiname if route['handler_method'] == 'exec' else route['handler_method']
            yield '  public {type} {method}({args}) throws IOException {{'.format(type=outtype, method=apiname, args=args)
            yield '    {clazz} s = getService({clazz}.class);'.format(clazz=class_name)
            yield '    return s.{method}({values}).execute().body();'.format(method=method, values=values)
            yield '  }'
        yield ''
    yield dedent(2, '\n\n          //--------- PRIVATE --------------------------------------------------------------------------------------------------\n\n          private Retrofit retrofit;\n          private String _url = DEFAULT_URL;\n          private int timeout_s = 60;\n          private int pollInterval_ms = 1000;\n\n          private void initializeRetrofit() {\n            Gson gson = new GsonBuilder()\n              .registerTypeAdapterFactory(new ModelV3TypeAdapter())\n              .registerTypeAdapter(KeyV3.class, new KeySerializer())\n              .registerTypeAdapter(ColSpecifierV3.class, new ColSerializer())\n              .registerTypeAdapter(ModelBuilderSchema.class, new ModelDeserializer())\n              .registerTypeAdapter(ModelSchemaBaseV3.class, new ModelSchemaDeserializer())\n              .registerTypeAdapter(ModelOutputSchemaV3.class, new ModelOutputDeserializer())\n              .registerTypeAdapter(ModelParametersSchemaV3.class, new ModelParametersDeserializer())\n              .create();\n\n            OkHttpClient client = new OkHttpClient.Builder()\n              .connectTimeout(timeout_s, TimeUnit.SECONDS)\n              .writeTimeout(timeout_s, TimeUnit.SECONDS)\n              .readTimeout(timeout_s, TimeUnit.SECONDS)\n              .build();\n\n            this.retrofit = new Retrofit.Builder()\n              .client(client)\n              .baseUrl(_url)\n              .addConverterFactory(GsonConverterFactory.create(gson))\n              .build();\n          }\n\n          private Retrofit getRetrofit() {\n            if (retrofit == null) initializeRetrofit();\n            return retrofit;\n          }\n\n          private <T> T getService(Class<T> clazz) {\n            return getRetrofit().create(clazz);\n          }\n\n\n          /**\n           * Keys get sent as Strings and returned as objects also containing the type and URL,\n           * so they need a custom GSON serializer.\n           */\n          private static class KeySerializer implements JsonSerializer<KeyV3>, JsonDeserializer<KeyV3> {\n            @Override\n            public JsonElement serialize(KeyV3 key, Type typeOfKey, JsonSerializationContext context) {\n              return new JsonPrimitive(key.name);\n            }\n            @Override\n            public KeyV3 deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) {\n              if (json.isJsonNull()) return null;\n              JsonObject jobj = json.getAsJsonObject();\n              String type = jobj.get("type").getAsString();\n              switch (type) {\n                // TODO: dynamically generate all possible cases\n                case "Key<Model>": return context.deserialize(jobj, ModelKeyV3.class);\n                case "Key<Job>":   return context.deserialize(jobj, JobKeyV3.class);\n                case "Key<Grid>":  return context.deserialize(jobj, GridKeyV3.class);\n                case "Key<Frame>": return context.deserialize(jobj, FrameKeyV3.class);\n                default: throw new JsonParseException("Unable to deserialize key of type " + type);\n              }\n            }\n          }\n\n          private static class ColSerializer implements JsonSerializer<ColSpecifierV3> {\n            @Override\n            public JsonElement serialize(ColSpecifierV3 col, Type typeOfCol, JsonSerializationContext context) {\n              return new JsonPrimitive(col.columnName);\n            }\n          }\n\n        ')

    def inj(middle):
        if False:
            return 10
        return lambda schema, algo: schema[:len(algo)] + middle + schema[len(algo):]
    for (clz, base, target_clz_factory) in [('ModelDeserializer', 'ModelBuilderSchema', lambda schema, algo: schema), ('ModelSchemaDeserializer', 'ModelSchemaBaseV3', inj('Model')), ('ModelOutputDeserializer', 'ModelOutputSchemaV3', inj('ModelOutput')), ('ModelParametersDeserializer', 'ModelParametersSchemaV3', inj('Parameters'))]:
        yield '  /**'
        yield ('   * Factory method for parsing a %s json object into an instance of the model-specific subclass.' % base)
        yield '   */'
        yield ('  private static class %s implements JsonDeserializer<%s> {' % (clz, base))
        yield '    @Override'
        yield ('    public %s deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)' % base)
        yield '      throws JsonParseException {'
        yield '      if (json.isJsonNull()) return null;'
        yield '      if (json.isJsonObject()) {'
        yield '        JsonObject jobj = json.getAsJsonObject();'
        yield '        if (jobj.has("algo")) {'
        yield '          String algo = jobj.get("algo").getAsJsonPrimitive().getAsString().toLowerCase();'
        yield '          switch (algo) {'
        for route in endpoints:
            if route['class_name'] == 'ModelBuilders' and route['api_name'].startswith('train'):
                algo = route['algo']
                oschema = route['output_schema']
                assert oschema.lower()[:len(algo)] == algo, 'Wrong output schema for algo %s: %s' % (algo, oschema)
                model = target_clz_factory(oschema, algo)
                yield '            case "{algo}": return context.deserialize(json, {model}.class);'.format(**locals())
        yield '            default:'
        yield '              throw new JsonParseException("Unable to deserialize model of type " + algo);'
        yield '          }'
        yield '        }'
        yield '      }'
        yield ('      throw new JsonParseException("Invalid %s element " + json.toString());' % base)
        yield '    }'
        yield '  }'
        yield ''
    yield dedent(2, '\n          private static class ModelV3TypeAdapter implements TypeAdapterFactory {\n            @Override\n            public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\n              final Class<? super T> rawType = type.getRawType();\n              if (!ModelBuilderSchema.class.isAssignableFrom(rawType) &&\n                  !ModelSchemaBaseV3.class.isAssignableFrom(rawType)) return null;\n              final TypeAdapter<T> delegate = gson.getDelegateAdapter(this, type);\n              return new TypeAdapter<T>() {\n                @Override\n                public void write(JsonWriter out, T value) throws IOException {\n                  delegate.write(out, value);\n                }\n                @Override\n                public T read(JsonReader in) throws IOException {\n                  JsonObject jobj = new JsonParser().parse(in).getAsJsonObject();\n                  if (jobj.has("parameters") && jobj.get("parameters").isJsonArray()) {\n                    JsonArray jarr = jobj.get("parameters").getAsJsonArray();\n                    JsonObject paramsNew = new JsonObject();\n                    for (JsonElement item : jarr) {\n                      JsonObject itemObj = item.getAsJsonObject();\n                      paramsNew.add(itemObj.get("name").getAsString(), itemObj.get("actual_value"));\n                    }\n                    jobj.add("parameters", paramsNew);\n                  }\n                  // noinspection unchecked\n                  return (T) new Gson().fromJson(jobj, rawType);\n                }\n              };\n            }\n          }\n\n\n          /**\n           * Return an array of Strings for an array of keys.\n           */\n          public static String[] keyArrayToStringArray(KeyV3[] keys) {\n            if (keys == null) return null;\n            String[] ids = new String[keys.length];\n            int i = 0;\n            for (KeyV3 key : keys) ids[i++] = key.name;\n            return ids;\n          }\n\n          /**\n           * Return an array of keys from an array of Strings.\n           * @param ids array of string ids to convert to KeyV3\'s\n           * @param clz class of key objects to create. Since we have JobKeyV3, FrameKeyV3, ModelKeyV3, etc -- this\n           *            method needs to know which of these keys you want to create\n           */\n          public static <T extends KeyV3> T[] stringArrayToKeyArray(String[] ids, Class<T> clz) {\n            if (ids == null) return null;\n            // noinspection unchecked\n            T[] keys = (T[]) Array.newInstance(clz, ids.length);\n            String keyType = clz.getSimpleName();\n            if (keyType.endsWith("KeyV3")) keyType = keyType.substring(0, keyType.length()-5);\n            try {\n              int i = 0;\n              for (String id: ids) {\n                keys[i] = clz.getConstructor().newInstance();\n                keys[i].name = id;\n                keys[i].type = keyType;\n                i++;\n              }\n            }\n            catch (Exception e) {\n              e.printStackTrace();\n            }\n            return keys;\n          }\n\n          /**\n           *\n           */\n          public static String keyToString(KeyV3 key) {\n            return key == null? null : key.name;\n          }\n\n          /**\n           *\n           */\n          public static FrameKeyV3 stringToFrameKey(String key) {\n            if (key == null) return null;\n            FrameKeyV3 k = new FrameKeyV3();\n            k.name = key;\n            return k;\n          }\n\n          /**\n           *\n           */\n          private static String colToString(ColSpecifierV3 col) {\n            return col == null? null : col.columnName;\n          }\n\n          /**\n           *\n           */\n          public static String stringToCol(String col) {\n            if (col == null) return null;\n            ColSpecifierV3 c = new ColSpecifierV3();\n            c.columnName = col;\n            return col;\n          }\n\n\n          public static void copyFields(Object to, Object from) {\n            Field[] fromFields = from.getClass().getDeclaredFields();\n            Field[] toFields   = to.getClass().getDeclaredFields();\n\n            for (Field fromField : fromFields){\n              Field toField;\n              try {\n                toField = to.getClass().getDeclaredField(fromField.getName());\n                fromField.setAccessible(true);\n                toField.setAccessible(true);\n                toField.set(to, fromField.get(from));\n              }\n              catch (Exception ignored) {\n                // NoSuchField is the normal case\n              }\n            }\n          }\n        }\n        ')

def main():
    if False:
        for i in range(10):
            print('nop')
    bi.init('Java', 'java')
    schemas_map = bi.schemas_map(add_generics=True)
    for (name, schema) in schemas_map.items():
        bi.vprint('Generating schema: ' + name)
        bi.write_to_file('water/bindings/pojos/%s.java' % name, generate_schema(name, schema))
    for (name, values) in bi.enums().items():
        bi.vprint('Generating enum: ' + name)
        bi.write_to_file('water/bindings/pojos/%s.java' % name, generate_enum(name, sorted(values)))
    for (name, endpoints) in bi.endpoint_groups().items():
        if name != 'SegmentModelsBuilders':
            bi.vprint('Generating proxy: ' + name)
            bi.write_to_file('water/bindings/proxies/retrofit/%s.java' % name, generate_proxy(name, endpoints))
    bi.vprint('Generating H2oApi.java')
    bi.write_to_file('water/bindings/H2oApi.java', generate_main_class(bi.endpoints()))
    type_adapter.vprint_translation_map()
if __name__ == '__main__':
    main()