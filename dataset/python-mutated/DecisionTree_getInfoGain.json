[
    {
        "func_name": "calcShannonEnt",
        "original": "def calcShannonEnt(dataSet):\n    \"\"\"calcShannonEnt(calculate Shannon entropy \u8ba1\u7b97label\u5206\u7c7b\u6807\u7b7e\u7684\u9999\u519c\u71b5)\n\n    Args:\n        dataSet \u6570\u636e\u96c6\n    Returns:\n        \u8fd4\u56de\u9999\u519c\u71b5\u7684\u8ba1\u7b97\u503c\n    Raises:\n\n    \"\"\"\n    numEntries = len(dataSet)\n    labelCounts = {}\n    for featVec in dataSet:\n        currentLabel = featVec[-1]\n        if currentLabel not in labelCounts.keys():\n            labelCounts[currentLabel] = 0\n        labelCounts[currentLabel] += 1\n    shannonEnt = 0.0\n    for key in labelCounts:\n        prob = float(labelCounts[key]) / numEntries\n        shannonEnt -= prob * log(prob, 2)\n    return shannonEnt",
        "mutated": [
            "def calcShannonEnt(dataSet):\n    if False:\n        i = 10\n    'calcShannonEnt(calculate Shannon entropy \u8ba1\u7b97label\u5206\u7c7b\u6807\u7b7e\u7684\u9999\u519c\u71b5)\\n\\n    Args:\\n        dataSet \u6570\u636e\u96c6\\n    Returns:\\n        \u8fd4\u56de\u9999\u519c\u71b5\u7684\u8ba1\u7b97\u503c\\n    Raises:\\n\\n    '\n    numEntries = len(dataSet)\n    labelCounts = {}\n    for featVec in dataSet:\n        currentLabel = featVec[-1]\n        if currentLabel not in labelCounts.keys():\n            labelCounts[currentLabel] = 0\n        labelCounts[currentLabel] += 1\n    shannonEnt = 0.0\n    for key in labelCounts:\n        prob = float(labelCounts[key]) / numEntries\n        shannonEnt -= prob * log(prob, 2)\n    return shannonEnt",
            "def calcShannonEnt(dataSet):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'calcShannonEnt(calculate Shannon entropy \u8ba1\u7b97label\u5206\u7c7b\u6807\u7b7e\u7684\u9999\u519c\u71b5)\\n\\n    Args:\\n        dataSet \u6570\u636e\u96c6\\n    Returns:\\n        \u8fd4\u56de\u9999\u519c\u71b5\u7684\u8ba1\u7b97\u503c\\n    Raises:\\n\\n    '\n    numEntries = len(dataSet)\n    labelCounts = {}\n    for featVec in dataSet:\n        currentLabel = featVec[-1]\n        if currentLabel not in labelCounts.keys():\n            labelCounts[currentLabel] = 0\n        labelCounts[currentLabel] += 1\n    shannonEnt = 0.0\n    for key in labelCounts:\n        prob = float(labelCounts[key]) / numEntries\n        shannonEnt -= prob * log(prob, 2)\n    return shannonEnt",
            "def calcShannonEnt(dataSet):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'calcShannonEnt(calculate Shannon entropy \u8ba1\u7b97label\u5206\u7c7b\u6807\u7b7e\u7684\u9999\u519c\u71b5)\\n\\n    Args:\\n        dataSet \u6570\u636e\u96c6\\n    Returns:\\n        \u8fd4\u56de\u9999\u519c\u71b5\u7684\u8ba1\u7b97\u503c\\n    Raises:\\n\\n    '\n    numEntries = len(dataSet)\n    labelCounts = {}\n    for featVec in dataSet:\n        currentLabel = featVec[-1]\n        if currentLabel not in labelCounts.keys():\n            labelCounts[currentLabel] = 0\n        labelCounts[currentLabel] += 1\n    shannonEnt = 0.0\n    for key in labelCounts:\n        prob = float(labelCounts[key]) / numEntries\n        shannonEnt -= prob * log(prob, 2)\n    return shannonEnt",
            "def calcShannonEnt(dataSet):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'calcShannonEnt(calculate Shannon entropy \u8ba1\u7b97label\u5206\u7c7b\u6807\u7b7e\u7684\u9999\u519c\u71b5)\\n\\n    Args:\\n        dataSet \u6570\u636e\u96c6\\n    Returns:\\n        \u8fd4\u56de\u9999\u519c\u71b5\u7684\u8ba1\u7b97\u503c\\n    Raises:\\n\\n    '\n    numEntries = len(dataSet)\n    labelCounts = {}\n    for featVec in dataSet:\n        currentLabel = featVec[-1]\n        if currentLabel not in labelCounts.keys():\n            labelCounts[currentLabel] = 0\n        labelCounts[currentLabel] += 1\n    shannonEnt = 0.0\n    for key in labelCounts:\n        prob = float(labelCounts[key]) / numEntries\n        shannonEnt -= prob * log(prob, 2)\n    return shannonEnt",
            "def calcShannonEnt(dataSet):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'calcShannonEnt(calculate Shannon entropy \u8ba1\u7b97label\u5206\u7c7b\u6807\u7b7e\u7684\u9999\u519c\u71b5)\\n\\n    Args:\\n        dataSet \u6570\u636e\u96c6\\n    Returns:\\n        \u8fd4\u56de\u9999\u519c\u71b5\u7684\u8ba1\u7b97\u503c\\n    Raises:\\n\\n    '\n    numEntries = len(dataSet)\n    labelCounts = {}\n    for featVec in dataSet:\n        currentLabel = featVec[-1]\n        if currentLabel not in labelCounts.keys():\n            labelCounts[currentLabel] = 0\n        labelCounts[currentLabel] += 1\n    shannonEnt = 0.0\n    for key in labelCounts:\n        prob = float(labelCounts[key]) / numEntries\n        shannonEnt -= prob * log(prob, 2)\n    return shannonEnt"
        ]
    },
    {
        "func_name": "splitDataSet",
        "original": "def splitDataSet(dataSet, axis, value):\n    \"\"\"splitDataSet(\u901a\u8fc7\u904d\u5386dataSet\u6570\u636e\u96c6\uff0c\u6c42\u51faaxis\u5bf9\u5e94\u7684colnum\u5217\u7684\u503c\u4e3avalue\u7684\u884c)\n\n    Args:\n        dataSet \u6570\u636e\u96c6\n        axis \u8868\u793a\u6bcf\u4e00\u884c\u7684axis\u5217\n        value \u8868\u793aaxis\u5217\u5bf9\u5e94\u7684value\u503c\n    Returns:\n        axis\u5217\u4e3avalue\u7684\u6570\u636e\u96c6\u3010\u8be5\u6570\u636e\u96c6\u9700\u8981\u6392\u9664axis\u5217\u3011\n    Raises:\n\n    \"\"\"\n    retDataSet = []\n    for featVec in dataSet:\n        if featVec[axis] == value:\n            reducedFeatVec = featVec[:axis]\n            '\\n            \u8bf7\u767e\u5ea6\u67e5\u8be2\u4e00\u4e0b:  extend\u548cappend\u7684\u533a\u522b\\n            '\n            reducedFeatVec.extend(featVec[axis + 1:])\n            retDataSet.append(reducedFeatVec)\n    return retDataSet",
        "mutated": [
            "def splitDataSet(dataSet, axis, value):\n    if False:\n        i = 10\n    'splitDataSet(\u901a\u8fc7\u904d\u5386dataSet\u6570\u636e\u96c6\uff0c\u6c42\u51faaxis\u5bf9\u5e94\u7684colnum\u5217\u7684\u503c\u4e3avalue\u7684\u884c)\\n\\n    Args:\\n        dataSet \u6570\u636e\u96c6\\n        axis \u8868\u793a\u6bcf\u4e00\u884c\u7684axis\u5217\\n        value \u8868\u793aaxis\u5217\u5bf9\u5e94\u7684value\u503c\\n    Returns:\\n        axis\u5217\u4e3avalue\u7684\u6570\u636e\u96c6\u3010\u8be5\u6570\u636e\u96c6\u9700\u8981\u6392\u9664axis\u5217\u3011\\n    Raises:\\n\\n    '\n    retDataSet = []\n    for featVec in dataSet:\n        if featVec[axis] == value:\n            reducedFeatVec = featVec[:axis]\n            '\\n            \u8bf7\u767e\u5ea6\u67e5\u8be2\u4e00\u4e0b:  extend\u548cappend\u7684\u533a\u522b\\n            '\n            reducedFeatVec.extend(featVec[axis + 1:])\n            retDataSet.append(reducedFeatVec)\n    return retDataSet",
            "def splitDataSet(dataSet, axis, value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'splitDataSet(\u901a\u8fc7\u904d\u5386dataSet\u6570\u636e\u96c6\uff0c\u6c42\u51faaxis\u5bf9\u5e94\u7684colnum\u5217\u7684\u503c\u4e3avalue\u7684\u884c)\\n\\n    Args:\\n        dataSet \u6570\u636e\u96c6\\n        axis \u8868\u793a\u6bcf\u4e00\u884c\u7684axis\u5217\\n        value \u8868\u793aaxis\u5217\u5bf9\u5e94\u7684value\u503c\\n    Returns:\\n        axis\u5217\u4e3avalue\u7684\u6570\u636e\u96c6\u3010\u8be5\u6570\u636e\u96c6\u9700\u8981\u6392\u9664axis\u5217\u3011\\n    Raises:\\n\\n    '\n    retDataSet = []\n    for featVec in dataSet:\n        if featVec[axis] == value:\n            reducedFeatVec = featVec[:axis]\n            '\\n            \u8bf7\u767e\u5ea6\u67e5\u8be2\u4e00\u4e0b:  extend\u548cappend\u7684\u533a\u522b\\n            '\n            reducedFeatVec.extend(featVec[axis + 1:])\n            retDataSet.append(reducedFeatVec)\n    return retDataSet",
            "def splitDataSet(dataSet, axis, value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'splitDataSet(\u901a\u8fc7\u904d\u5386dataSet\u6570\u636e\u96c6\uff0c\u6c42\u51faaxis\u5bf9\u5e94\u7684colnum\u5217\u7684\u503c\u4e3avalue\u7684\u884c)\\n\\n    Args:\\n        dataSet \u6570\u636e\u96c6\\n        axis \u8868\u793a\u6bcf\u4e00\u884c\u7684axis\u5217\\n        value \u8868\u793aaxis\u5217\u5bf9\u5e94\u7684value\u503c\\n    Returns:\\n        axis\u5217\u4e3avalue\u7684\u6570\u636e\u96c6\u3010\u8be5\u6570\u636e\u96c6\u9700\u8981\u6392\u9664axis\u5217\u3011\\n    Raises:\\n\\n    '\n    retDataSet = []\n    for featVec in dataSet:\n        if featVec[axis] == value:\n            reducedFeatVec = featVec[:axis]\n            '\\n            \u8bf7\u767e\u5ea6\u67e5\u8be2\u4e00\u4e0b:  extend\u548cappend\u7684\u533a\u522b\\n            '\n            reducedFeatVec.extend(featVec[axis + 1:])\n            retDataSet.append(reducedFeatVec)\n    return retDataSet",
            "def splitDataSet(dataSet, axis, value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'splitDataSet(\u901a\u8fc7\u904d\u5386dataSet\u6570\u636e\u96c6\uff0c\u6c42\u51faaxis\u5bf9\u5e94\u7684colnum\u5217\u7684\u503c\u4e3avalue\u7684\u884c)\\n\\n    Args:\\n        dataSet \u6570\u636e\u96c6\\n        axis \u8868\u793a\u6bcf\u4e00\u884c\u7684axis\u5217\\n        value \u8868\u793aaxis\u5217\u5bf9\u5e94\u7684value\u503c\\n    Returns:\\n        axis\u5217\u4e3avalue\u7684\u6570\u636e\u96c6\u3010\u8be5\u6570\u636e\u96c6\u9700\u8981\u6392\u9664axis\u5217\u3011\\n    Raises:\\n\\n    '\n    retDataSet = []\n    for featVec in dataSet:\n        if featVec[axis] == value:\n            reducedFeatVec = featVec[:axis]\n            '\\n            \u8bf7\u767e\u5ea6\u67e5\u8be2\u4e00\u4e0b:  extend\u548cappend\u7684\u533a\u522b\\n            '\n            reducedFeatVec.extend(featVec[axis + 1:])\n            retDataSet.append(reducedFeatVec)\n    return retDataSet",
            "def splitDataSet(dataSet, axis, value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'splitDataSet(\u901a\u8fc7\u904d\u5386dataSet\u6570\u636e\u96c6\uff0c\u6c42\u51faaxis\u5bf9\u5e94\u7684colnum\u5217\u7684\u503c\u4e3avalue\u7684\u884c)\\n\\n    Args:\\n        dataSet \u6570\u636e\u96c6\\n        axis \u8868\u793a\u6bcf\u4e00\u884c\u7684axis\u5217\\n        value \u8868\u793aaxis\u5217\u5bf9\u5e94\u7684value\u503c\\n    Returns:\\n        axis\u5217\u4e3avalue\u7684\u6570\u636e\u96c6\u3010\u8be5\u6570\u636e\u96c6\u9700\u8981\u6392\u9664axis\u5217\u3011\\n    Raises:\\n\\n    '\n    retDataSet = []\n    for featVec in dataSet:\n        if featVec[axis] == value:\n            reducedFeatVec = featVec[:axis]\n            '\\n            \u8bf7\u767e\u5ea6\u67e5\u8be2\u4e00\u4e0b:  extend\u548cappend\u7684\u533a\u522b\\n            '\n            reducedFeatVec.extend(featVec[axis + 1:])\n            retDataSet.append(reducedFeatVec)\n    return retDataSet"
        ]
    },
    {
        "func_name": "getFeatureShannonEnt",
        "original": "def getFeatureShannonEnt(dataSet, labels):\n    \"\"\"chooseBestFeatureToSplit(\u9009\u62e9\u6700\u597d\u7684\u7279\u5f81)\n\n    Args:\n        dataSet \u6570\u636e\u96c6\n    Returns:\n        bestFeature \u6700\u4f18\u7684\u7279\u5f81\u5217\n    Raises:\n\n    \"\"\"\n    numFeatures = len(dataSet[0]) - 1\n    baseEntropy = calcShannonEnt(dataSet)\n    (bestInfoGain, bestFeature, endEntropy) = (0.0, -1, 0.0)\n    for i in range(numFeatures):\n        featList = [example[i] for example in dataSet]\n        uniqueVals = set(featList)\n        newEntropy = 0.0\n        for value in uniqueVals:\n            subDataSet = splitDataSet(dataSet, i, value)\n            prob = len(subDataSet) / float(len(dataSet))\n            newEntropy += prob * calcShannonEnt(subDataSet)\n        infoGain = baseEntropy - newEntropy\n        if infoGain > bestInfoGain:\n            endEntropy = newEntropy\n            bestInfoGain = infoGain\n            bestFeature = i\n    else:\n        if numFeatures < 0:\n            labels[bestFeature] = 'null'\n    return (labels[bestFeature], baseEntropy, endEntropy, bestInfoGain)",
        "mutated": [
            "def getFeatureShannonEnt(dataSet, labels):\n    if False:\n        i = 10\n    'chooseBestFeatureToSplit(\u9009\u62e9\u6700\u597d\u7684\u7279\u5f81)\\n\\n    Args:\\n        dataSet \u6570\u636e\u96c6\\n    Returns:\\n        bestFeature \u6700\u4f18\u7684\u7279\u5f81\u5217\\n    Raises:\\n\\n    '\n    numFeatures = len(dataSet[0]) - 1\n    baseEntropy = calcShannonEnt(dataSet)\n    (bestInfoGain, bestFeature, endEntropy) = (0.0, -1, 0.0)\n    for i in range(numFeatures):\n        featList = [example[i] for example in dataSet]\n        uniqueVals = set(featList)\n        newEntropy = 0.0\n        for value in uniqueVals:\n            subDataSet = splitDataSet(dataSet, i, value)\n            prob = len(subDataSet) / float(len(dataSet))\n            newEntropy += prob * calcShannonEnt(subDataSet)\n        infoGain = baseEntropy - newEntropy\n        if infoGain > bestInfoGain:\n            endEntropy = newEntropy\n            bestInfoGain = infoGain\n            bestFeature = i\n    else:\n        if numFeatures < 0:\n            labels[bestFeature] = 'null'\n    return (labels[bestFeature], baseEntropy, endEntropy, bestInfoGain)",
            "def getFeatureShannonEnt(dataSet, labels):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'chooseBestFeatureToSplit(\u9009\u62e9\u6700\u597d\u7684\u7279\u5f81)\\n\\n    Args:\\n        dataSet \u6570\u636e\u96c6\\n    Returns:\\n        bestFeature \u6700\u4f18\u7684\u7279\u5f81\u5217\\n    Raises:\\n\\n    '\n    numFeatures = len(dataSet[0]) - 1\n    baseEntropy = calcShannonEnt(dataSet)\n    (bestInfoGain, bestFeature, endEntropy) = (0.0, -1, 0.0)\n    for i in range(numFeatures):\n        featList = [example[i] for example in dataSet]\n        uniqueVals = set(featList)\n        newEntropy = 0.0\n        for value in uniqueVals:\n            subDataSet = splitDataSet(dataSet, i, value)\n            prob = len(subDataSet) / float(len(dataSet))\n            newEntropy += prob * calcShannonEnt(subDataSet)\n        infoGain = baseEntropy - newEntropy\n        if infoGain > bestInfoGain:\n            endEntropy = newEntropy\n            bestInfoGain = infoGain\n            bestFeature = i\n    else:\n        if numFeatures < 0:\n            labels[bestFeature] = 'null'\n    return (labels[bestFeature], baseEntropy, endEntropy, bestInfoGain)",
            "def getFeatureShannonEnt(dataSet, labels):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'chooseBestFeatureToSplit(\u9009\u62e9\u6700\u597d\u7684\u7279\u5f81)\\n\\n    Args:\\n        dataSet \u6570\u636e\u96c6\\n    Returns:\\n        bestFeature \u6700\u4f18\u7684\u7279\u5f81\u5217\\n    Raises:\\n\\n    '\n    numFeatures = len(dataSet[0]) - 1\n    baseEntropy = calcShannonEnt(dataSet)\n    (bestInfoGain, bestFeature, endEntropy) = (0.0, -1, 0.0)\n    for i in range(numFeatures):\n        featList = [example[i] for example in dataSet]\n        uniqueVals = set(featList)\n        newEntropy = 0.0\n        for value in uniqueVals:\n            subDataSet = splitDataSet(dataSet, i, value)\n            prob = len(subDataSet) / float(len(dataSet))\n            newEntropy += prob * calcShannonEnt(subDataSet)\n        infoGain = baseEntropy - newEntropy\n        if infoGain > bestInfoGain:\n            endEntropy = newEntropy\n            bestInfoGain = infoGain\n            bestFeature = i\n    else:\n        if numFeatures < 0:\n            labels[bestFeature] = 'null'\n    return (labels[bestFeature], baseEntropy, endEntropy, bestInfoGain)",
            "def getFeatureShannonEnt(dataSet, labels):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'chooseBestFeatureToSplit(\u9009\u62e9\u6700\u597d\u7684\u7279\u5f81)\\n\\n    Args:\\n        dataSet \u6570\u636e\u96c6\\n    Returns:\\n        bestFeature \u6700\u4f18\u7684\u7279\u5f81\u5217\\n    Raises:\\n\\n    '\n    numFeatures = len(dataSet[0]) - 1\n    baseEntropy = calcShannonEnt(dataSet)\n    (bestInfoGain, bestFeature, endEntropy) = (0.0, -1, 0.0)\n    for i in range(numFeatures):\n        featList = [example[i] for example in dataSet]\n        uniqueVals = set(featList)\n        newEntropy = 0.0\n        for value in uniqueVals:\n            subDataSet = splitDataSet(dataSet, i, value)\n            prob = len(subDataSet) / float(len(dataSet))\n            newEntropy += prob * calcShannonEnt(subDataSet)\n        infoGain = baseEntropy - newEntropy\n        if infoGain > bestInfoGain:\n            endEntropy = newEntropy\n            bestInfoGain = infoGain\n            bestFeature = i\n    else:\n        if numFeatures < 0:\n            labels[bestFeature] = 'null'\n    return (labels[bestFeature], baseEntropy, endEntropy, bestInfoGain)",
            "def getFeatureShannonEnt(dataSet, labels):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'chooseBestFeatureToSplit(\u9009\u62e9\u6700\u597d\u7684\u7279\u5f81)\\n\\n    Args:\\n        dataSet \u6570\u636e\u96c6\\n    Returns:\\n        bestFeature \u6700\u4f18\u7684\u7279\u5f81\u5217\\n    Raises:\\n\\n    '\n    numFeatures = len(dataSet[0]) - 1\n    baseEntropy = calcShannonEnt(dataSet)\n    (bestInfoGain, bestFeature, endEntropy) = (0.0, -1, 0.0)\n    for i in range(numFeatures):\n        featList = [example[i] for example in dataSet]\n        uniqueVals = set(featList)\n        newEntropy = 0.0\n        for value in uniqueVals:\n            subDataSet = splitDataSet(dataSet, i, value)\n            prob = len(subDataSet) / float(len(dataSet))\n            newEntropy += prob * calcShannonEnt(subDataSet)\n        infoGain = baseEntropy - newEntropy\n        if infoGain > bestInfoGain:\n            endEntropy = newEntropy\n            bestInfoGain = infoGain\n            bestFeature = i\n    else:\n        if numFeatures < 0:\n            labels[bestFeature] = 'null'\n    return (labels[bestFeature], baseEntropy, endEntropy, bestInfoGain)"
        ]
    }
]