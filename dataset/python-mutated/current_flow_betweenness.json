[
    {
        "func_name": "approximate_current_flow_betweenness_centrality",
        "original": "@not_implemented_for('directed')\n@py_random_state(7)\n@nx._dispatch(edge_attrs='weight')\ndef approximate_current_flow_betweenness_centrality(G, normalized=True, weight=None, dtype=float, solver='full', epsilon=0.5, kmax=10000, seed=None):\n    \"\"\"Compute the approximate current-flow betweenness centrality for nodes.\n\n    Approximates the current-flow betweenness centrality within absolute\n    error of epsilon with high probability [1]_.\n\n\n    Parameters\n    ----------\n    G : graph\n      A NetworkX graph\n\n    normalized : bool, optional (default=True)\n      If True the betweenness values are normalized by 2/[(n-1)(n-2)] where\n      n is the number of nodes in G.\n\n    weight : string or None, optional (default=None)\n      Key for edge data used as the edge weight.\n      If None, then use 1 as each edge weight.\n      The weight reflects the capacity or the strength of the\n      edge.\n\n    dtype : data type (float)\n      Default data type for internal matrices.\n      Set to np.float32 for lower memory consumption.\n\n    solver : string (default='full')\n       Type of linear solver to use for computing the flow matrix.\n       Options are \"full\" (uses most memory), \"lu\" (recommended), and\n       \"cg\" (uses least memory).\n\n    epsilon: float\n        Absolute error tolerance.\n\n    kmax: int\n       Maximum number of sample node pairs to use for approximation.\n\n    seed : integer, random_state, or None (default)\n        Indicator of random number generation state.\n        See :ref:`Randomness<randomness>`.\n\n    Returns\n    -------\n    nodes : dictionary\n       Dictionary of nodes with betweenness centrality as the value.\n\n    See Also\n    --------\n    current_flow_betweenness_centrality\n\n    Notes\n    -----\n    The running time is $O((1/\\\\epsilon^2)m{\\\\sqrt k} \\\\log n)$\n    and the space required is $O(m)$ for $n$ nodes and $m$ edges.\n\n    If the edges have a 'weight' attribute they will be used as\n    weights in this algorithm.  Unspecified weights are set to 1.\n\n    References\n    ----------\n    .. [1] Ulrik Brandes and Daniel Fleischer:\n       Centrality Measures Based on Current Flow.\n       Proc. 22nd Symp. Theoretical Aspects of Computer Science (STACS '05).\n       LNCS 3404, pp. 533-544. Springer-Verlag, 2005.\n       https://doi.org/10.1007/978-3-540-31856-9_44\n    \"\"\"\n    import numpy as np\n    if not nx.is_connected(G):\n        raise nx.NetworkXError('Graph not connected.')\n    solvername = {'full': FullInverseLaplacian, 'lu': SuperLUInverseLaplacian, 'cg': CGInverseLaplacian}\n    n = G.number_of_nodes()\n    ordering = list(reverse_cuthill_mckee_ordering(G))\n    H = nx.relabel_nodes(G, dict(zip(ordering, range(n))))\n    L = nx.laplacian_matrix(H, nodelist=range(n), weight=weight).asformat('csc')\n    L = L.astype(dtype)\n    C = solvername[solver](L, dtype=dtype)\n    betweenness = dict.fromkeys(H, 0.0)\n    nb = (n - 1.0) * (n - 2.0)\n    cstar = n * (n - 1) / nb\n    l = 1\n    k = l * int(np.ceil((cstar / epsilon) ** 2 * np.log(n)))\n    if k > kmax:\n        msg = f'Number random pairs k>kmax ({k}>{kmax}) '\n        raise nx.NetworkXError(msg, 'Increase kmax or epsilon')\n    cstar2k = cstar / (2 * k)\n    for _ in range(k):\n        (s, t) = pair = seed.sample(range(n), 2)\n        b = np.zeros(n, dtype=dtype)\n        b[s] = 1\n        b[t] = -1\n        p = C.solve(b)\n        for v in H:\n            if v in pair:\n                continue\n            for nbr in H[v]:\n                w = H[v][nbr].get(weight, 1.0)\n                betweenness[v] += w * np.abs(p[v] - p[nbr]) * cstar2k\n    if normalized:\n        factor = 1.0\n    else:\n        factor = nb / 2.0\n    return {ordering[k]: v * factor for (k, v) in betweenness.items()}",
        "mutated": [
            "@not_implemented_for('directed')\n@py_random_state(7)\n@nx._dispatch(edge_attrs='weight')\ndef approximate_current_flow_betweenness_centrality(G, normalized=True, weight=None, dtype=float, solver='full', epsilon=0.5, kmax=10000, seed=None):\n    if False:\n        i = 10\n    'Compute the approximate current-flow betweenness centrality for nodes.\\n\\n    Approximates the current-flow betweenness centrality within absolute\\n    error of epsilon with high probability [1]_.\\n\\n\\n    Parameters\\n    ----------\\n    G : graph\\n      A NetworkX graph\\n\\n    normalized : bool, optional (default=True)\\n      If True the betweenness values are normalized by 2/[(n-1)(n-2)] where\\n      n is the number of nodes in G.\\n\\n    weight : string or None, optional (default=None)\\n      Key for edge data used as the edge weight.\\n      If None, then use 1 as each edge weight.\\n      The weight reflects the capacity or the strength of the\\n      edge.\\n\\n    dtype : data type (float)\\n      Default data type for internal matrices.\\n      Set to np.float32 for lower memory consumption.\\n\\n    solver : string (default=\\'full\\')\\n       Type of linear solver to use for computing the flow matrix.\\n       Options are \"full\" (uses most memory), \"lu\" (recommended), and\\n       \"cg\" (uses least memory).\\n\\n    epsilon: float\\n        Absolute error tolerance.\\n\\n    kmax: int\\n       Maximum number of sample node pairs to use for approximation.\\n\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    nodes : dictionary\\n       Dictionary of nodes with betweenness centrality as the value.\\n\\n    See Also\\n    --------\\n    current_flow_betweenness_centrality\\n\\n    Notes\\n    -----\\n    The running time is $O((1/\\\\epsilon^2)m{\\\\sqrt k} \\\\log n)$\\n    and the space required is $O(m)$ for $n$ nodes and $m$ edges.\\n\\n    If the edges have a \\'weight\\' attribute they will be used as\\n    weights in this algorithm.  Unspecified weights are set to 1.\\n\\n    References\\n    ----------\\n    .. [1] Ulrik Brandes and Daniel Fleischer:\\n       Centrality Measures Based on Current Flow.\\n       Proc. 22nd Symp. Theoretical Aspects of Computer Science (STACS \\'05).\\n       LNCS 3404, pp. 533-544. Springer-Verlag, 2005.\\n       https://doi.org/10.1007/978-3-540-31856-9_44\\n    '\n    import numpy as np\n    if not nx.is_connected(G):\n        raise nx.NetworkXError('Graph not connected.')\n    solvername = {'full': FullInverseLaplacian, 'lu': SuperLUInverseLaplacian, 'cg': CGInverseLaplacian}\n    n = G.number_of_nodes()\n    ordering = list(reverse_cuthill_mckee_ordering(G))\n    H = nx.relabel_nodes(G, dict(zip(ordering, range(n))))\n    L = nx.laplacian_matrix(H, nodelist=range(n), weight=weight).asformat('csc')\n    L = L.astype(dtype)\n    C = solvername[solver](L, dtype=dtype)\n    betweenness = dict.fromkeys(H, 0.0)\n    nb = (n - 1.0) * (n - 2.0)\n    cstar = n * (n - 1) / nb\n    l = 1\n    k = l * int(np.ceil((cstar / epsilon) ** 2 * np.log(n)))\n    if k > kmax:\n        msg = f'Number random pairs k>kmax ({k}>{kmax}) '\n        raise nx.NetworkXError(msg, 'Increase kmax or epsilon')\n    cstar2k = cstar / (2 * k)\n    for _ in range(k):\n        (s, t) = pair = seed.sample(range(n), 2)\n        b = np.zeros(n, dtype=dtype)\n        b[s] = 1\n        b[t] = -1\n        p = C.solve(b)\n        for v in H:\n            if v in pair:\n                continue\n            for nbr in H[v]:\n                w = H[v][nbr].get(weight, 1.0)\n                betweenness[v] += w * np.abs(p[v] - p[nbr]) * cstar2k\n    if normalized:\n        factor = 1.0\n    else:\n        factor = nb / 2.0\n    return {ordering[k]: v * factor for (k, v) in betweenness.items()}",
            "@not_implemented_for('directed')\n@py_random_state(7)\n@nx._dispatch(edge_attrs='weight')\ndef approximate_current_flow_betweenness_centrality(G, normalized=True, weight=None, dtype=float, solver='full', epsilon=0.5, kmax=10000, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Compute the approximate current-flow betweenness centrality for nodes.\\n\\n    Approximates the current-flow betweenness centrality within absolute\\n    error of epsilon with high probability [1]_.\\n\\n\\n    Parameters\\n    ----------\\n    G : graph\\n      A NetworkX graph\\n\\n    normalized : bool, optional (default=True)\\n      If True the betweenness values are normalized by 2/[(n-1)(n-2)] where\\n      n is the number of nodes in G.\\n\\n    weight : string or None, optional (default=None)\\n      Key for edge data used as the edge weight.\\n      If None, then use 1 as each edge weight.\\n      The weight reflects the capacity or the strength of the\\n      edge.\\n\\n    dtype : data type (float)\\n      Default data type for internal matrices.\\n      Set to np.float32 for lower memory consumption.\\n\\n    solver : string (default=\\'full\\')\\n       Type of linear solver to use for computing the flow matrix.\\n       Options are \"full\" (uses most memory), \"lu\" (recommended), and\\n       \"cg\" (uses least memory).\\n\\n    epsilon: float\\n        Absolute error tolerance.\\n\\n    kmax: int\\n       Maximum number of sample node pairs to use for approximation.\\n\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    nodes : dictionary\\n       Dictionary of nodes with betweenness centrality as the value.\\n\\n    See Also\\n    --------\\n    current_flow_betweenness_centrality\\n\\n    Notes\\n    -----\\n    The running time is $O((1/\\\\epsilon^2)m{\\\\sqrt k} \\\\log n)$\\n    and the space required is $O(m)$ for $n$ nodes and $m$ edges.\\n\\n    If the edges have a \\'weight\\' attribute they will be used as\\n    weights in this algorithm.  Unspecified weights are set to 1.\\n\\n    References\\n    ----------\\n    .. [1] Ulrik Brandes and Daniel Fleischer:\\n       Centrality Measures Based on Current Flow.\\n       Proc. 22nd Symp. Theoretical Aspects of Computer Science (STACS \\'05).\\n       LNCS 3404, pp. 533-544. Springer-Verlag, 2005.\\n       https://doi.org/10.1007/978-3-540-31856-9_44\\n    '\n    import numpy as np\n    if not nx.is_connected(G):\n        raise nx.NetworkXError('Graph not connected.')\n    solvername = {'full': FullInverseLaplacian, 'lu': SuperLUInverseLaplacian, 'cg': CGInverseLaplacian}\n    n = G.number_of_nodes()\n    ordering = list(reverse_cuthill_mckee_ordering(G))\n    H = nx.relabel_nodes(G, dict(zip(ordering, range(n))))\n    L = nx.laplacian_matrix(H, nodelist=range(n), weight=weight).asformat('csc')\n    L = L.astype(dtype)\n    C = solvername[solver](L, dtype=dtype)\n    betweenness = dict.fromkeys(H, 0.0)\n    nb = (n - 1.0) * (n - 2.0)\n    cstar = n * (n - 1) / nb\n    l = 1\n    k = l * int(np.ceil((cstar / epsilon) ** 2 * np.log(n)))\n    if k > kmax:\n        msg = f'Number random pairs k>kmax ({k}>{kmax}) '\n        raise nx.NetworkXError(msg, 'Increase kmax or epsilon')\n    cstar2k = cstar / (2 * k)\n    for _ in range(k):\n        (s, t) = pair = seed.sample(range(n), 2)\n        b = np.zeros(n, dtype=dtype)\n        b[s] = 1\n        b[t] = -1\n        p = C.solve(b)\n        for v in H:\n            if v in pair:\n                continue\n            for nbr in H[v]:\n                w = H[v][nbr].get(weight, 1.0)\n                betweenness[v] += w * np.abs(p[v] - p[nbr]) * cstar2k\n    if normalized:\n        factor = 1.0\n    else:\n        factor = nb / 2.0\n    return {ordering[k]: v * factor for (k, v) in betweenness.items()}",
            "@not_implemented_for('directed')\n@py_random_state(7)\n@nx._dispatch(edge_attrs='weight')\ndef approximate_current_flow_betweenness_centrality(G, normalized=True, weight=None, dtype=float, solver='full', epsilon=0.5, kmax=10000, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Compute the approximate current-flow betweenness centrality for nodes.\\n\\n    Approximates the current-flow betweenness centrality within absolute\\n    error of epsilon with high probability [1]_.\\n\\n\\n    Parameters\\n    ----------\\n    G : graph\\n      A NetworkX graph\\n\\n    normalized : bool, optional (default=True)\\n      If True the betweenness values are normalized by 2/[(n-1)(n-2)] where\\n      n is the number of nodes in G.\\n\\n    weight : string or None, optional (default=None)\\n      Key for edge data used as the edge weight.\\n      If None, then use 1 as each edge weight.\\n      The weight reflects the capacity or the strength of the\\n      edge.\\n\\n    dtype : data type (float)\\n      Default data type for internal matrices.\\n      Set to np.float32 for lower memory consumption.\\n\\n    solver : string (default=\\'full\\')\\n       Type of linear solver to use for computing the flow matrix.\\n       Options are \"full\" (uses most memory), \"lu\" (recommended), and\\n       \"cg\" (uses least memory).\\n\\n    epsilon: float\\n        Absolute error tolerance.\\n\\n    kmax: int\\n       Maximum number of sample node pairs to use for approximation.\\n\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    nodes : dictionary\\n       Dictionary of nodes with betweenness centrality as the value.\\n\\n    See Also\\n    --------\\n    current_flow_betweenness_centrality\\n\\n    Notes\\n    -----\\n    The running time is $O((1/\\\\epsilon^2)m{\\\\sqrt k} \\\\log n)$\\n    and the space required is $O(m)$ for $n$ nodes and $m$ edges.\\n\\n    If the edges have a \\'weight\\' attribute they will be used as\\n    weights in this algorithm.  Unspecified weights are set to 1.\\n\\n    References\\n    ----------\\n    .. [1] Ulrik Brandes and Daniel Fleischer:\\n       Centrality Measures Based on Current Flow.\\n       Proc. 22nd Symp. Theoretical Aspects of Computer Science (STACS \\'05).\\n       LNCS 3404, pp. 533-544. Springer-Verlag, 2005.\\n       https://doi.org/10.1007/978-3-540-31856-9_44\\n    '\n    import numpy as np\n    if not nx.is_connected(G):\n        raise nx.NetworkXError('Graph not connected.')\n    solvername = {'full': FullInverseLaplacian, 'lu': SuperLUInverseLaplacian, 'cg': CGInverseLaplacian}\n    n = G.number_of_nodes()\n    ordering = list(reverse_cuthill_mckee_ordering(G))\n    H = nx.relabel_nodes(G, dict(zip(ordering, range(n))))\n    L = nx.laplacian_matrix(H, nodelist=range(n), weight=weight).asformat('csc')\n    L = L.astype(dtype)\n    C = solvername[solver](L, dtype=dtype)\n    betweenness = dict.fromkeys(H, 0.0)\n    nb = (n - 1.0) * (n - 2.0)\n    cstar = n * (n - 1) / nb\n    l = 1\n    k = l * int(np.ceil((cstar / epsilon) ** 2 * np.log(n)))\n    if k > kmax:\n        msg = f'Number random pairs k>kmax ({k}>{kmax}) '\n        raise nx.NetworkXError(msg, 'Increase kmax or epsilon')\n    cstar2k = cstar / (2 * k)\n    for _ in range(k):\n        (s, t) = pair = seed.sample(range(n), 2)\n        b = np.zeros(n, dtype=dtype)\n        b[s] = 1\n        b[t] = -1\n        p = C.solve(b)\n        for v in H:\n            if v in pair:\n                continue\n            for nbr in H[v]:\n                w = H[v][nbr].get(weight, 1.0)\n                betweenness[v] += w * np.abs(p[v] - p[nbr]) * cstar2k\n    if normalized:\n        factor = 1.0\n    else:\n        factor = nb / 2.0\n    return {ordering[k]: v * factor for (k, v) in betweenness.items()}",
            "@not_implemented_for('directed')\n@py_random_state(7)\n@nx._dispatch(edge_attrs='weight')\ndef approximate_current_flow_betweenness_centrality(G, normalized=True, weight=None, dtype=float, solver='full', epsilon=0.5, kmax=10000, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Compute the approximate current-flow betweenness centrality for nodes.\\n\\n    Approximates the current-flow betweenness centrality within absolute\\n    error of epsilon with high probability [1]_.\\n\\n\\n    Parameters\\n    ----------\\n    G : graph\\n      A NetworkX graph\\n\\n    normalized : bool, optional (default=True)\\n      If True the betweenness values are normalized by 2/[(n-1)(n-2)] where\\n      n is the number of nodes in G.\\n\\n    weight : string or None, optional (default=None)\\n      Key for edge data used as the edge weight.\\n      If None, then use 1 as each edge weight.\\n      The weight reflects the capacity or the strength of the\\n      edge.\\n\\n    dtype : data type (float)\\n      Default data type for internal matrices.\\n      Set to np.float32 for lower memory consumption.\\n\\n    solver : string (default=\\'full\\')\\n       Type of linear solver to use for computing the flow matrix.\\n       Options are \"full\" (uses most memory), \"lu\" (recommended), and\\n       \"cg\" (uses least memory).\\n\\n    epsilon: float\\n        Absolute error tolerance.\\n\\n    kmax: int\\n       Maximum number of sample node pairs to use for approximation.\\n\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    nodes : dictionary\\n       Dictionary of nodes with betweenness centrality as the value.\\n\\n    See Also\\n    --------\\n    current_flow_betweenness_centrality\\n\\n    Notes\\n    -----\\n    The running time is $O((1/\\\\epsilon^2)m{\\\\sqrt k} \\\\log n)$\\n    and the space required is $O(m)$ for $n$ nodes and $m$ edges.\\n\\n    If the edges have a \\'weight\\' attribute they will be used as\\n    weights in this algorithm.  Unspecified weights are set to 1.\\n\\n    References\\n    ----------\\n    .. [1] Ulrik Brandes and Daniel Fleischer:\\n       Centrality Measures Based on Current Flow.\\n       Proc. 22nd Symp. Theoretical Aspects of Computer Science (STACS \\'05).\\n       LNCS 3404, pp. 533-544. Springer-Verlag, 2005.\\n       https://doi.org/10.1007/978-3-540-31856-9_44\\n    '\n    import numpy as np\n    if not nx.is_connected(G):\n        raise nx.NetworkXError('Graph not connected.')\n    solvername = {'full': FullInverseLaplacian, 'lu': SuperLUInverseLaplacian, 'cg': CGInverseLaplacian}\n    n = G.number_of_nodes()\n    ordering = list(reverse_cuthill_mckee_ordering(G))\n    H = nx.relabel_nodes(G, dict(zip(ordering, range(n))))\n    L = nx.laplacian_matrix(H, nodelist=range(n), weight=weight).asformat('csc')\n    L = L.astype(dtype)\n    C = solvername[solver](L, dtype=dtype)\n    betweenness = dict.fromkeys(H, 0.0)\n    nb = (n - 1.0) * (n - 2.0)\n    cstar = n * (n - 1) / nb\n    l = 1\n    k = l * int(np.ceil((cstar / epsilon) ** 2 * np.log(n)))\n    if k > kmax:\n        msg = f'Number random pairs k>kmax ({k}>{kmax}) '\n        raise nx.NetworkXError(msg, 'Increase kmax or epsilon')\n    cstar2k = cstar / (2 * k)\n    for _ in range(k):\n        (s, t) = pair = seed.sample(range(n), 2)\n        b = np.zeros(n, dtype=dtype)\n        b[s] = 1\n        b[t] = -1\n        p = C.solve(b)\n        for v in H:\n            if v in pair:\n                continue\n            for nbr in H[v]:\n                w = H[v][nbr].get(weight, 1.0)\n                betweenness[v] += w * np.abs(p[v] - p[nbr]) * cstar2k\n    if normalized:\n        factor = 1.0\n    else:\n        factor = nb / 2.0\n    return {ordering[k]: v * factor for (k, v) in betweenness.items()}",
            "@not_implemented_for('directed')\n@py_random_state(7)\n@nx._dispatch(edge_attrs='weight')\ndef approximate_current_flow_betweenness_centrality(G, normalized=True, weight=None, dtype=float, solver='full', epsilon=0.5, kmax=10000, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Compute the approximate current-flow betweenness centrality for nodes.\\n\\n    Approximates the current-flow betweenness centrality within absolute\\n    error of epsilon with high probability [1]_.\\n\\n\\n    Parameters\\n    ----------\\n    G : graph\\n      A NetworkX graph\\n\\n    normalized : bool, optional (default=True)\\n      If True the betweenness values are normalized by 2/[(n-1)(n-2)] where\\n      n is the number of nodes in G.\\n\\n    weight : string or None, optional (default=None)\\n      Key for edge data used as the edge weight.\\n      If None, then use 1 as each edge weight.\\n      The weight reflects the capacity or the strength of the\\n      edge.\\n\\n    dtype : data type (float)\\n      Default data type for internal matrices.\\n      Set to np.float32 for lower memory consumption.\\n\\n    solver : string (default=\\'full\\')\\n       Type of linear solver to use for computing the flow matrix.\\n       Options are \"full\" (uses most memory), \"lu\" (recommended), and\\n       \"cg\" (uses least memory).\\n\\n    epsilon: float\\n        Absolute error tolerance.\\n\\n    kmax: int\\n       Maximum number of sample node pairs to use for approximation.\\n\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    nodes : dictionary\\n       Dictionary of nodes with betweenness centrality as the value.\\n\\n    See Also\\n    --------\\n    current_flow_betweenness_centrality\\n\\n    Notes\\n    -----\\n    The running time is $O((1/\\\\epsilon^2)m{\\\\sqrt k} \\\\log n)$\\n    and the space required is $O(m)$ for $n$ nodes and $m$ edges.\\n\\n    If the edges have a \\'weight\\' attribute they will be used as\\n    weights in this algorithm.  Unspecified weights are set to 1.\\n\\n    References\\n    ----------\\n    .. [1] Ulrik Brandes and Daniel Fleischer:\\n       Centrality Measures Based on Current Flow.\\n       Proc. 22nd Symp. Theoretical Aspects of Computer Science (STACS \\'05).\\n       LNCS 3404, pp. 533-544. Springer-Verlag, 2005.\\n       https://doi.org/10.1007/978-3-540-31856-9_44\\n    '\n    import numpy as np\n    if not nx.is_connected(G):\n        raise nx.NetworkXError('Graph not connected.')\n    solvername = {'full': FullInverseLaplacian, 'lu': SuperLUInverseLaplacian, 'cg': CGInverseLaplacian}\n    n = G.number_of_nodes()\n    ordering = list(reverse_cuthill_mckee_ordering(G))\n    H = nx.relabel_nodes(G, dict(zip(ordering, range(n))))\n    L = nx.laplacian_matrix(H, nodelist=range(n), weight=weight).asformat('csc')\n    L = L.astype(dtype)\n    C = solvername[solver](L, dtype=dtype)\n    betweenness = dict.fromkeys(H, 0.0)\n    nb = (n - 1.0) * (n - 2.0)\n    cstar = n * (n - 1) / nb\n    l = 1\n    k = l * int(np.ceil((cstar / epsilon) ** 2 * np.log(n)))\n    if k > kmax:\n        msg = f'Number random pairs k>kmax ({k}>{kmax}) '\n        raise nx.NetworkXError(msg, 'Increase kmax or epsilon')\n    cstar2k = cstar / (2 * k)\n    for _ in range(k):\n        (s, t) = pair = seed.sample(range(n), 2)\n        b = np.zeros(n, dtype=dtype)\n        b[s] = 1\n        b[t] = -1\n        p = C.solve(b)\n        for v in H:\n            if v in pair:\n                continue\n            for nbr in H[v]:\n                w = H[v][nbr].get(weight, 1.0)\n                betweenness[v] += w * np.abs(p[v] - p[nbr]) * cstar2k\n    if normalized:\n        factor = 1.0\n    else:\n        factor = nb / 2.0\n    return {ordering[k]: v * factor for (k, v) in betweenness.items()}"
        ]
    },
    {
        "func_name": "current_flow_betweenness_centrality",
        "original": "@not_implemented_for('directed')\n@nx._dispatch(edge_attrs='weight')\ndef current_flow_betweenness_centrality(G, normalized=True, weight=None, dtype=float, solver='full'):\n    \"\"\"Compute current-flow betweenness centrality for nodes.\n\n    Current-flow betweenness centrality uses an electrical current\n    model for information spreading in contrast to betweenness\n    centrality which uses shortest paths.\n\n    Current-flow betweenness centrality is also known as\n    random-walk betweenness centrality [2]_.\n\n    Parameters\n    ----------\n    G : graph\n      A NetworkX graph\n\n    normalized : bool, optional (default=True)\n      If True the betweenness values are normalized by 2/[(n-1)(n-2)] where\n      n is the number of nodes in G.\n\n    weight : string or None, optional (default=None)\n      Key for edge data used as the edge weight.\n      If None, then use 1 as each edge weight.\n      The weight reflects the capacity or the strength of the\n      edge.\n\n    dtype : data type (float)\n      Default data type for internal matrices.\n      Set to np.float32 for lower memory consumption.\n\n    solver : string (default='full')\n       Type of linear solver to use for computing the flow matrix.\n       Options are \"full\" (uses most memory), \"lu\" (recommended), and\n       \"cg\" (uses least memory).\n\n    Returns\n    -------\n    nodes : dictionary\n       Dictionary of nodes with betweenness centrality as the value.\n\n    See Also\n    --------\n    approximate_current_flow_betweenness_centrality\n    betweenness_centrality\n    edge_betweenness_centrality\n    edge_current_flow_betweenness_centrality\n\n    Notes\n    -----\n    Current-flow betweenness can be computed in  $O(I(n-1)+mn \\\\log n)$\n    time [1]_, where $I(n-1)$ is the time needed to compute the\n    inverse Laplacian.  For a full matrix this is $O(n^3)$ but using\n    sparse methods you can achieve $O(nm{\\\\sqrt k})$ where $k$ is the\n    Laplacian matrix condition number.\n\n    The space required is $O(nw)$ where $w$ is the width of the sparse\n    Laplacian matrix.  Worse case is $w=n$ for $O(n^2)$.\n\n    If the edges have a 'weight' attribute they will be used as\n    weights in this algorithm.  Unspecified weights are set to 1.\n\n    References\n    ----------\n    .. [1] Centrality Measures Based on Current Flow.\n       Ulrik Brandes and Daniel Fleischer,\n       Proc. 22nd Symp. Theoretical Aspects of Computer Science (STACS '05).\n       LNCS 3404, pp. 533-544. Springer-Verlag, 2005.\n       https://doi.org/10.1007/978-3-540-31856-9_44\n\n    .. [2] A measure of betweenness centrality based on random walks,\n       M. E. J. Newman, Social Networks 27, 39-54 (2005).\n    \"\"\"\n    if not nx.is_connected(G):\n        raise nx.NetworkXError('Graph not connected.')\n    n = G.number_of_nodes()\n    ordering = list(reverse_cuthill_mckee_ordering(G))\n    H = nx.relabel_nodes(G, dict(zip(ordering, range(n))))\n    betweenness = dict.fromkeys(H, 0.0)\n    for (row, (s, t)) in flow_matrix_row(H, weight=weight, dtype=dtype, solver=solver):\n        pos = dict(zip(row.argsort()[::-1], range(n)))\n        for i in range(n):\n            betweenness[s] += (i - pos[i]) * row[i]\n            betweenness[t] += (n - i - 1 - pos[i]) * row[i]\n    if normalized:\n        nb = (n - 1.0) * (n - 2.0)\n    else:\n        nb = 2.0\n    for v in H:\n        betweenness[v] = float((betweenness[v] - v) * 2.0 / nb)\n    return {ordering[k]: v for (k, v) in betweenness.items()}",
        "mutated": [
            "@not_implemented_for('directed')\n@nx._dispatch(edge_attrs='weight')\ndef current_flow_betweenness_centrality(G, normalized=True, weight=None, dtype=float, solver='full'):\n    if False:\n        i = 10\n    'Compute current-flow betweenness centrality for nodes.\\n\\n    Current-flow betweenness centrality uses an electrical current\\n    model for information spreading in contrast to betweenness\\n    centrality which uses shortest paths.\\n\\n    Current-flow betweenness centrality is also known as\\n    random-walk betweenness centrality [2]_.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n      A NetworkX graph\\n\\n    normalized : bool, optional (default=True)\\n      If True the betweenness values are normalized by 2/[(n-1)(n-2)] where\\n      n is the number of nodes in G.\\n\\n    weight : string or None, optional (default=None)\\n      Key for edge data used as the edge weight.\\n      If None, then use 1 as each edge weight.\\n      The weight reflects the capacity or the strength of the\\n      edge.\\n\\n    dtype : data type (float)\\n      Default data type for internal matrices.\\n      Set to np.float32 for lower memory consumption.\\n\\n    solver : string (default=\\'full\\')\\n       Type of linear solver to use for computing the flow matrix.\\n       Options are \"full\" (uses most memory), \"lu\" (recommended), and\\n       \"cg\" (uses least memory).\\n\\n    Returns\\n    -------\\n    nodes : dictionary\\n       Dictionary of nodes with betweenness centrality as the value.\\n\\n    See Also\\n    --------\\n    approximate_current_flow_betweenness_centrality\\n    betweenness_centrality\\n    edge_betweenness_centrality\\n    edge_current_flow_betweenness_centrality\\n\\n    Notes\\n    -----\\n    Current-flow betweenness can be computed in  $O(I(n-1)+mn \\\\log n)$\\n    time [1]_, where $I(n-1)$ is the time needed to compute the\\n    inverse Laplacian.  For a full matrix this is $O(n^3)$ but using\\n    sparse methods you can achieve $O(nm{\\\\sqrt k})$ where $k$ is the\\n    Laplacian matrix condition number.\\n\\n    The space required is $O(nw)$ where $w$ is the width of the sparse\\n    Laplacian matrix.  Worse case is $w=n$ for $O(n^2)$.\\n\\n    If the edges have a \\'weight\\' attribute they will be used as\\n    weights in this algorithm.  Unspecified weights are set to 1.\\n\\n    References\\n    ----------\\n    .. [1] Centrality Measures Based on Current Flow.\\n       Ulrik Brandes and Daniel Fleischer,\\n       Proc. 22nd Symp. Theoretical Aspects of Computer Science (STACS \\'05).\\n       LNCS 3404, pp. 533-544. Springer-Verlag, 2005.\\n       https://doi.org/10.1007/978-3-540-31856-9_44\\n\\n    .. [2] A measure of betweenness centrality based on random walks,\\n       M. E. J. Newman, Social Networks 27, 39-54 (2005).\\n    '\n    if not nx.is_connected(G):\n        raise nx.NetworkXError('Graph not connected.')\n    n = G.number_of_nodes()\n    ordering = list(reverse_cuthill_mckee_ordering(G))\n    H = nx.relabel_nodes(G, dict(zip(ordering, range(n))))\n    betweenness = dict.fromkeys(H, 0.0)\n    for (row, (s, t)) in flow_matrix_row(H, weight=weight, dtype=dtype, solver=solver):\n        pos = dict(zip(row.argsort()[::-1], range(n)))\n        for i in range(n):\n            betweenness[s] += (i - pos[i]) * row[i]\n            betweenness[t] += (n - i - 1 - pos[i]) * row[i]\n    if normalized:\n        nb = (n - 1.0) * (n - 2.0)\n    else:\n        nb = 2.0\n    for v in H:\n        betweenness[v] = float((betweenness[v] - v) * 2.0 / nb)\n    return {ordering[k]: v for (k, v) in betweenness.items()}",
            "@not_implemented_for('directed')\n@nx._dispatch(edge_attrs='weight')\ndef current_flow_betweenness_centrality(G, normalized=True, weight=None, dtype=float, solver='full'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Compute current-flow betweenness centrality for nodes.\\n\\n    Current-flow betweenness centrality uses an electrical current\\n    model for information spreading in contrast to betweenness\\n    centrality which uses shortest paths.\\n\\n    Current-flow betweenness centrality is also known as\\n    random-walk betweenness centrality [2]_.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n      A NetworkX graph\\n\\n    normalized : bool, optional (default=True)\\n      If True the betweenness values are normalized by 2/[(n-1)(n-2)] where\\n      n is the number of nodes in G.\\n\\n    weight : string or None, optional (default=None)\\n      Key for edge data used as the edge weight.\\n      If None, then use 1 as each edge weight.\\n      The weight reflects the capacity or the strength of the\\n      edge.\\n\\n    dtype : data type (float)\\n      Default data type for internal matrices.\\n      Set to np.float32 for lower memory consumption.\\n\\n    solver : string (default=\\'full\\')\\n       Type of linear solver to use for computing the flow matrix.\\n       Options are \"full\" (uses most memory), \"lu\" (recommended), and\\n       \"cg\" (uses least memory).\\n\\n    Returns\\n    -------\\n    nodes : dictionary\\n       Dictionary of nodes with betweenness centrality as the value.\\n\\n    See Also\\n    --------\\n    approximate_current_flow_betweenness_centrality\\n    betweenness_centrality\\n    edge_betweenness_centrality\\n    edge_current_flow_betweenness_centrality\\n\\n    Notes\\n    -----\\n    Current-flow betweenness can be computed in  $O(I(n-1)+mn \\\\log n)$\\n    time [1]_, where $I(n-1)$ is the time needed to compute the\\n    inverse Laplacian.  For a full matrix this is $O(n^3)$ but using\\n    sparse methods you can achieve $O(nm{\\\\sqrt k})$ where $k$ is the\\n    Laplacian matrix condition number.\\n\\n    The space required is $O(nw)$ where $w$ is the width of the sparse\\n    Laplacian matrix.  Worse case is $w=n$ for $O(n^2)$.\\n\\n    If the edges have a \\'weight\\' attribute they will be used as\\n    weights in this algorithm.  Unspecified weights are set to 1.\\n\\n    References\\n    ----------\\n    .. [1] Centrality Measures Based on Current Flow.\\n       Ulrik Brandes and Daniel Fleischer,\\n       Proc. 22nd Symp. Theoretical Aspects of Computer Science (STACS \\'05).\\n       LNCS 3404, pp. 533-544. Springer-Verlag, 2005.\\n       https://doi.org/10.1007/978-3-540-31856-9_44\\n\\n    .. [2] A measure of betweenness centrality based on random walks,\\n       M. E. J. Newman, Social Networks 27, 39-54 (2005).\\n    '\n    if not nx.is_connected(G):\n        raise nx.NetworkXError('Graph not connected.')\n    n = G.number_of_nodes()\n    ordering = list(reverse_cuthill_mckee_ordering(G))\n    H = nx.relabel_nodes(G, dict(zip(ordering, range(n))))\n    betweenness = dict.fromkeys(H, 0.0)\n    for (row, (s, t)) in flow_matrix_row(H, weight=weight, dtype=dtype, solver=solver):\n        pos = dict(zip(row.argsort()[::-1], range(n)))\n        for i in range(n):\n            betweenness[s] += (i - pos[i]) * row[i]\n            betweenness[t] += (n - i - 1 - pos[i]) * row[i]\n    if normalized:\n        nb = (n - 1.0) * (n - 2.0)\n    else:\n        nb = 2.0\n    for v in H:\n        betweenness[v] = float((betweenness[v] - v) * 2.0 / nb)\n    return {ordering[k]: v for (k, v) in betweenness.items()}",
            "@not_implemented_for('directed')\n@nx._dispatch(edge_attrs='weight')\ndef current_flow_betweenness_centrality(G, normalized=True, weight=None, dtype=float, solver='full'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Compute current-flow betweenness centrality for nodes.\\n\\n    Current-flow betweenness centrality uses an electrical current\\n    model for information spreading in contrast to betweenness\\n    centrality which uses shortest paths.\\n\\n    Current-flow betweenness centrality is also known as\\n    random-walk betweenness centrality [2]_.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n      A NetworkX graph\\n\\n    normalized : bool, optional (default=True)\\n      If True the betweenness values are normalized by 2/[(n-1)(n-2)] where\\n      n is the number of nodes in G.\\n\\n    weight : string or None, optional (default=None)\\n      Key for edge data used as the edge weight.\\n      If None, then use 1 as each edge weight.\\n      The weight reflects the capacity or the strength of the\\n      edge.\\n\\n    dtype : data type (float)\\n      Default data type for internal matrices.\\n      Set to np.float32 for lower memory consumption.\\n\\n    solver : string (default=\\'full\\')\\n       Type of linear solver to use for computing the flow matrix.\\n       Options are \"full\" (uses most memory), \"lu\" (recommended), and\\n       \"cg\" (uses least memory).\\n\\n    Returns\\n    -------\\n    nodes : dictionary\\n       Dictionary of nodes with betweenness centrality as the value.\\n\\n    See Also\\n    --------\\n    approximate_current_flow_betweenness_centrality\\n    betweenness_centrality\\n    edge_betweenness_centrality\\n    edge_current_flow_betweenness_centrality\\n\\n    Notes\\n    -----\\n    Current-flow betweenness can be computed in  $O(I(n-1)+mn \\\\log n)$\\n    time [1]_, where $I(n-1)$ is the time needed to compute the\\n    inverse Laplacian.  For a full matrix this is $O(n^3)$ but using\\n    sparse methods you can achieve $O(nm{\\\\sqrt k})$ where $k$ is the\\n    Laplacian matrix condition number.\\n\\n    The space required is $O(nw)$ where $w$ is the width of the sparse\\n    Laplacian matrix.  Worse case is $w=n$ for $O(n^2)$.\\n\\n    If the edges have a \\'weight\\' attribute they will be used as\\n    weights in this algorithm.  Unspecified weights are set to 1.\\n\\n    References\\n    ----------\\n    .. [1] Centrality Measures Based on Current Flow.\\n       Ulrik Brandes and Daniel Fleischer,\\n       Proc. 22nd Symp. Theoretical Aspects of Computer Science (STACS \\'05).\\n       LNCS 3404, pp. 533-544. Springer-Verlag, 2005.\\n       https://doi.org/10.1007/978-3-540-31856-9_44\\n\\n    .. [2] A measure of betweenness centrality based on random walks,\\n       M. E. J. Newman, Social Networks 27, 39-54 (2005).\\n    '\n    if not nx.is_connected(G):\n        raise nx.NetworkXError('Graph not connected.')\n    n = G.number_of_nodes()\n    ordering = list(reverse_cuthill_mckee_ordering(G))\n    H = nx.relabel_nodes(G, dict(zip(ordering, range(n))))\n    betweenness = dict.fromkeys(H, 0.0)\n    for (row, (s, t)) in flow_matrix_row(H, weight=weight, dtype=dtype, solver=solver):\n        pos = dict(zip(row.argsort()[::-1], range(n)))\n        for i in range(n):\n            betweenness[s] += (i - pos[i]) * row[i]\n            betweenness[t] += (n - i - 1 - pos[i]) * row[i]\n    if normalized:\n        nb = (n - 1.0) * (n - 2.0)\n    else:\n        nb = 2.0\n    for v in H:\n        betweenness[v] = float((betweenness[v] - v) * 2.0 / nb)\n    return {ordering[k]: v for (k, v) in betweenness.items()}",
            "@not_implemented_for('directed')\n@nx._dispatch(edge_attrs='weight')\ndef current_flow_betweenness_centrality(G, normalized=True, weight=None, dtype=float, solver='full'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Compute current-flow betweenness centrality for nodes.\\n\\n    Current-flow betweenness centrality uses an electrical current\\n    model for information spreading in contrast to betweenness\\n    centrality which uses shortest paths.\\n\\n    Current-flow betweenness centrality is also known as\\n    random-walk betweenness centrality [2]_.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n      A NetworkX graph\\n\\n    normalized : bool, optional (default=True)\\n      If True the betweenness values are normalized by 2/[(n-1)(n-2)] where\\n      n is the number of nodes in G.\\n\\n    weight : string or None, optional (default=None)\\n      Key for edge data used as the edge weight.\\n      If None, then use 1 as each edge weight.\\n      The weight reflects the capacity or the strength of the\\n      edge.\\n\\n    dtype : data type (float)\\n      Default data type for internal matrices.\\n      Set to np.float32 for lower memory consumption.\\n\\n    solver : string (default=\\'full\\')\\n       Type of linear solver to use for computing the flow matrix.\\n       Options are \"full\" (uses most memory), \"lu\" (recommended), and\\n       \"cg\" (uses least memory).\\n\\n    Returns\\n    -------\\n    nodes : dictionary\\n       Dictionary of nodes with betweenness centrality as the value.\\n\\n    See Also\\n    --------\\n    approximate_current_flow_betweenness_centrality\\n    betweenness_centrality\\n    edge_betweenness_centrality\\n    edge_current_flow_betweenness_centrality\\n\\n    Notes\\n    -----\\n    Current-flow betweenness can be computed in  $O(I(n-1)+mn \\\\log n)$\\n    time [1]_, where $I(n-1)$ is the time needed to compute the\\n    inverse Laplacian.  For a full matrix this is $O(n^3)$ but using\\n    sparse methods you can achieve $O(nm{\\\\sqrt k})$ where $k$ is the\\n    Laplacian matrix condition number.\\n\\n    The space required is $O(nw)$ where $w$ is the width of the sparse\\n    Laplacian matrix.  Worse case is $w=n$ for $O(n^2)$.\\n\\n    If the edges have a \\'weight\\' attribute they will be used as\\n    weights in this algorithm.  Unspecified weights are set to 1.\\n\\n    References\\n    ----------\\n    .. [1] Centrality Measures Based on Current Flow.\\n       Ulrik Brandes and Daniel Fleischer,\\n       Proc. 22nd Symp. Theoretical Aspects of Computer Science (STACS \\'05).\\n       LNCS 3404, pp. 533-544. Springer-Verlag, 2005.\\n       https://doi.org/10.1007/978-3-540-31856-9_44\\n\\n    .. [2] A measure of betweenness centrality based on random walks,\\n       M. E. J. Newman, Social Networks 27, 39-54 (2005).\\n    '\n    if not nx.is_connected(G):\n        raise nx.NetworkXError('Graph not connected.')\n    n = G.number_of_nodes()\n    ordering = list(reverse_cuthill_mckee_ordering(G))\n    H = nx.relabel_nodes(G, dict(zip(ordering, range(n))))\n    betweenness = dict.fromkeys(H, 0.0)\n    for (row, (s, t)) in flow_matrix_row(H, weight=weight, dtype=dtype, solver=solver):\n        pos = dict(zip(row.argsort()[::-1], range(n)))\n        for i in range(n):\n            betweenness[s] += (i - pos[i]) * row[i]\n            betweenness[t] += (n - i - 1 - pos[i]) * row[i]\n    if normalized:\n        nb = (n - 1.0) * (n - 2.0)\n    else:\n        nb = 2.0\n    for v in H:\n        betweenness[v] = float((betweenness[v] - v) * 2.0 / nb)\n    return {ordering[k]: v for (k, v) in betweenness.items()}",
            "@not_implemented_for('directed')\n@nx._dispatch(edge_attrs='weight')\ndef current_flow_betweenness_centrality(G, normalized=True, weight=None, dtype=float, solver='full'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Compute current-flow betweenness centrality for nodes.\\n\\n    Current-flow betweenness centrality uses an electrical current\\n    model for information spreading in contrast to betweenness\\n    centrality which uses shortest paths.\\n\\n    Current-flow betweenness centrality is also known as\\n    random-walk betweenness centrality [2]_.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n      A NetworkX graph\\n\\n    normalized : bool, optional (default=True)\\n      If True the betweenness values are normalized by 2/[(n-1)(n-2)] where\\n      n is the number of nodes in G.\\n\\n    weight : string or None, optional (default=None)\\n      Key for edge data used as the edge weight.\\n      If None, then use 1 as each edge weight.\\n      The weight reflects the capacity or the strength of the\\n      edge.\\n\\n    dtype : data type (float)\\n      Default data type for internal matrices.\\n      Set to np.float32 for lower memory consumption.\\n\\n    solver : string (default=\\'full\\')\\n       Type of linear solver to use for computing the flow matrix.\\n       Options are \"full\" (uses most memory), \"lu\" (recommended), and\\n       \"cg\" (uses least memory).\\n\\n    Returns\\n    -------\\n    nodes : dictionary\\n       Dictionary of nodes with betweenness centrality as the value.\\n\\n    See Also\\n    --------\\n    approximate_current_flow_betweenness_centrality\\n    betweenness_centrality\\n    edge_betweenness_centrality\\n    edge_current_flow_betweenness_centrality\\n\\n    Notes\\n    -----\\n    Current-flow betweenness can be computed in  $O(I(n-1)+mn \\\\log n)$\\n    time [1]_, where $I(n-1)$ is the time needed to compute the\\n    inverse Laplacian.  For a full matrix this is $O(n^3)$ but using\\n    sparse methods you can achieve $O(nm{\\\\sqrt k})$ where $k$ is the\\n    Laplacian matrix condition number.\\n\\n    The space required is $O(nw)$ where $w$ is the width of the sparse\\n    Laplacian matrix.  Worse case is $w=n$ for $O(n^2)$.\\n\\n    If the edges have a \\'weight\\' attribute they will be used as\\n    weights in this algorithm.  Unspecified weights are set to 1.\\n\\n    References\\n    ----------\\n    .. [1] Centrality Measures Based on Current Flow.\\n       Ulrik Brandes and Daniel Fleischer,\\n       Proc. 22nd Symp. Theoretical Aspects of Computer Science (STACS \\'05).\\n       LNCS 3404, pp. 533-544. Springer-Verlag, 2005.\\n       https://doi.org/10.1007/978-3-540-31856-9_44\\n\\n    .. [2] A measure of betweenness centrality based on random walks,\\n       M. E. J. Newman, Social Networks 27, 39-54 (2005).\\n    '\n    if not nx.is_connected(G):\n        raise nx.NetworkXError('Graph not connected.')\n    n = G.number_of_nodes()\n    ordering = list(reverse_cuthill_mckee_ordering(G))\n    H = nx.relabel_nodes(G, dict(zip(ordering, range(n))))\n    betweenness = dict.fromkeys(H, 0.0)\n    for (row, (s, t)) in flow_matrix_row(H, weight=weight, dtype=dtype, solver=solver):\n        pos = dict(zip(row.argsort()[::-1], range(n)))\n        for i in range(n):\n            betweenness[s] += (i - pos[i]) * row[i]\n            betweenness[t] += (n - i - 1 - pos[i]) * row[i]\n    if normalized:\n        nb = (n - 1.0) * (n - 2.0)\n    else:\n        nb = 2.0\n    for v in H:\n        betweenness[v] = float((betweenness[v] - v) * 2.0 / nb)\n    return {ordering[k]: v for (k, v) in betweenness.items()}"
        ]
    },
    {
        "func_name": "edge_current_flow_betweenness_centrality",
        "original": "@not_implemented_for('directed')\n@nx._dispatch(edge_attrs='weight')\ndef edge_current_flow_betweenness_centrality(G, normalized=True, weight=None, dtype=float, solver='full'):\n    \"\"\"Compute current-flow betweenness centrality for edges.\n\n    Current-flow betweenness centrality uses an electrical current\n    model for information spreading in contrast to betweenness\n    centrality which uses shortest paths.\n\n    Current-flow betweenness centrality is also known as\n    random-walk betweenness centrality [2]_.\n\n    Parameters\n    ----------\n    G : graph\n      A NetworkX graph\n\n    normalized : bool, optional (default=True)\n      If True the betweenness values are normalized by 2/[(n-1)(n-2)] where\n      n is the number of nodes in G.\n\n    weight : string or None, optional (default=None)\n      Key for edge data used as the edge weight.\n      If None, then use 1 as each edge weight.\n      The weight reflects the capacity or the strength of the\n      edge.\n\n    dtype : data type (default=float)\n      Default data type for internal matrices.\n      Set to np.float32 for lower memory consumption.\n\n    solver : string (default='full')\n       Type of linear solver to use for computing the flow matrix.\n       Options are \"full\" (uses most memory), \"lu\" (recommended), and\n       \"cg\" (uses least memory).\n\n    Returns\n    -------\n    nodes : dictionary\n       Dictionary of edge tuples with betweenness centrality as the value.\n\n    Raises\n    ------\n    NetworkXError\n        The algorithm does not support DiGraphs.\n        If the input graph is an instance of DiGraph class, NetworkXError\n        is raised.\n\n    See Also\n    --------\n    betweenness_centrality\n    edge_betweenness_centrality\n    current_flow_betweenness_centrality\n\n    Notes\n    -----\n    Current-flow betweenness can be computed in $O(I(n-1)+mn \\\\log n)$\n    time [1]_, where $I(n-1)$ is the time needed to compute the\n    inverse Laplacian.  For a full matrix this is $O(n^3)$ but using\n    sparse methods you can achieve $O(nm{\\\\sqrt k})$ where $k$ is the\n    Laplacian matrix condition number.\n\n    The space required is $O(nw)$ where $w$ is the width of the sparse\n    Laplacian matrix.  Worse case is $w=n$ for $O(n^2)$.\n\n    If the edges have a 'weight' attribute they will be used as\n    weights in this algorithm.  Unspecified weights are set to 1.\n\n    References\n    ----------\n    .. [1] Centrality Measures Based on Current Flow.\n       Ulrik Brandes and Daniel Fleischer,\n       Proc. 22nd Symp. Theoretical Aspects of Computer Science (STACS '05).\n       LNCS 3404, pp. 533-544. Springer-Verlag, 2005.\n       https://doi.org/10.1007/978-3-540-31856-9_44\n\n    .. [2] A measure of betweenness centrality based on random walks,\n       M. E. J. Newman, Social Networks 27, 39-54 (2005).\n    \"\"\"\n    if not nx.is_connected(G):\n        raise nx.NetworkXError('Graph not connected.')\n    n = G.number_of_nodes()\n    ordering = list(reverse_cuthill_mckee_ordering(G))\n    H = nx.relabel_nodes(G, dict(zip(ordering, range(n))))\n    edges = (tuple(sorted((u, v))) for (u, v) in H.edges())\n    betweenness = dict.fromkeys(edges, 0.0)\n    if normalized:\n        nb = (n - 1.0) * (n - 2.0)\n    else:\n        nb = 2.0\n    for (row, e) in flow_matrix_row(H, weight=weight, dtype=dtype, solver=solver):\n        pos = dict(zip(row.argsort()[::-1], range(1, n + 1)))\n        for i in range(n):\n            betweenness[e] += (i + 1 - pos[i]) * row[i]\n            betweenness[e] += (n - i - pos[i]) * row[i]\n        betweenness[e] /= nb\n    return {(ordering[s], ordering[t]): v for ((s, t), v) in betweenness.items()}",
        "mutated": [
            "@not_implemented_for('directed')\n@nx._dispatch(edge_attrs='weight')\ndef edge_current_flow_betweenness_centrality(G, normalized=True, weight=None, dtype=float, solver='full'):\n    if False:\n        i = 10\n    'Compute current-flow betweenness centrality for edges.\\n\\n    Current-flow betweenness centrality uses an electrical current\\n    model for information spreading in contrast to betweenness\\n    centrality which uses shortest paths.\\n\\n    Current-flow betweenness centrality is also known as\\n    random-walk betweenness centrality [2]_.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n      A NetworkX graph\\n\\n    normalized : bool, optional (default=True)\\n      If True the betweenness values are normalized by 2/[(n-1)(n-2)] where\\n      n is the number of nodes in G.\\n\\n    weight : string or None, optional (default=None)\\n      Key for edge data used as the edge weight.\\n      If None, then use 1 as each edge weight.\\n      The weight reflects the capacity or the strength of the\\n      edge.\\n\\n    dtype : data type (default=float)\\n      Default data type for internal matrices.\\n      Set to np.float32 for lower memory consumption.\\n\\n    solver : string (default=\\'full\\')\\n       Type of linear solver to use for computing the flow matrix.\\n       Options are \"full\" (uses most memory), \"lu\" (recommended), and\\n       \"cg\" (uses least memory).\\n\\n    Returns\\n    -------\\n    nodes : dictionary\\n       Dictionary of edge tuples with betweenness centrality as the value.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        The algorithm does not support DiGraphs.\\n        If the input graph is an instance of DiGraph class, NetworkXError\\n        is raised.\\n\\n    See Also\\n    --------\\n    betweenness_centrality\\n    edge_betweenness_centrality\\n    current_flow_betweenness_centrality\\n\\n    Notes\\n    -----\\n    Current-flow betweenness can be computed in $O(I(n-1)+mn \\\\log n)$\\n    time [1]_, where $I(n-1)$ is the time needed to compute the\\n    inverse Laplacian.  For a full matrix this is $O(n^3)$ but using\\n    sparse methods you can achieve $O(nm{\\\\sqrt k})$ where $k$ is the\\n    Laplacian matrix condition number.\\n\\n    The space required is $O(nw)$ where $w$ is the width of the sparse\\n    Laplacian matrix.  Worse case is $w=n$ for $O(n^2)$.\\n\\n    If the edges have a \\'weight\\' attribute they will be used as\\n    weights in this algorithm.  Unspecified weights are set to 1.\\n\\n    References\\n    ----------\\n    .. [1] Centrality Measures Based on Current Flow.\\n       Ulrik Brandes and Daniel Fleischer,\\n       Proc. 22nd Symp. Theoretical Aspects of Computer Science (STACS \\'05).\\n       LNCS 3404, pp. 533-544. Springer-Verlag, 2005.\\n       https://doi.org/10.1007/978-3-540-31856-9_44\\n\\n    .. [2] A measure of betweenness centrality based on random walks,\\n       M. E. J. Newman, Social Networks 27, 39-54 (2005).\\n    '\n    if not nx.is_connected(G):\n        raise nx.NetworkXError('Graph not connected.')\n    n = G.number_of_nodes()\n    ordering = list(reverse_cuthill_mckee_ordering(G))\n    H = nx.relabel_nodes(G, dict(zip(ordering, range(n))))\n    edges = (tuple(sorted((u, v))) for (u, v) in H.edges())\n    betweenness = dict.fromkeys(edges, 0.0)\n    if normalized:\n        nb = (n - 1.0) * (n - 2.0)\n    else:\n        nb = 2.0\n    for (row, e) in flow_matrix_row(H, weight=weight, dtype=dtype, solver=solver):\n        pos = dict(zip(row.argsort()[::-1], range(1, n + 1)))\n        for i in range(n):\n            betweenness[e] += (i + 1 - pos[i]) * row[i]\n            betweenness[e] += (n - i - pos[i]) * row[i]\n        betweenness[e] /= nb\n    return {(ordering[s], ordering[t]): v for ((s, t), v) in betweenness.items()}",
            "@not_implemented_for('directed')\n@nx._dispatch(edge_attrs='weight')\ndef edge_current_flow_betweenness_centrality(G, normalized=True, weight=None, dtype=float, solver='full'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Compute current-flow betweenness centrality for edges.\\n\\n    Current-flow betweenness centrality uses an electrical current\\n    model for information spreading in contrast to betweenness\\n    centrality which uses shortest paths.\\n\\n    Current-flow betweenness centrality is also known as\\n    random-walk betweenness centrality [2]_.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n      A NetworkX graph\\n\\n    normalized : bool, optional (default=True)\\n      If True the betweenness values are normalized by 2/[(n-1)(n-2)] where\\n      n is the number of nodes in G.\\n\\n    weight : string or None, optional (default=None)\\n      Key for edge data used as the edge weight.\\n      If None, then use 1 as each edge weight.\\n      The weight reflects the capacity or the strength of the\\n      edge.\\n\\n    dtype : data type (default=float)\\n      Default data type for internal matrices.\\n      Set to np.float32 for lower memory consumption.\\n\\n    solver : string (default=\\'full\\')\\n       Type of linear solver to use for computing the flow matrix.\\n       Options are \"full\" (uses most memory), \"lu\" (recommended), and\\n       \"cg\" (uses least memory).\\n\\n    Returns\\n    -------\\n    nodes : dictionary\\n       Dictionary of edge tuples with betweenness centrality as the value.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        The algorithm does not support DiGraphs.\\n        If the input graph is an instance of DiGraph class, NetworkXError\\n        is raised.\\n\\n    See Also\\n    --------\\n    betweenness_centrality\\n    edge_betweenness_centrality\\n    current_flow_betweenness_centrality\\n\\n    Notes\\n    -----\\n    Current-flow betweenness can be computed in $O(I(n-1)+mn \\\\log n)$\\n    time [1]_, where $I(n-1)$ is the time needed to compute the\\n    inverse Laplacian.  For a full matrix this is $O(n^3)$ but using\\n    sparse methods you can achieve $O(nm{\\\\sqrt k})$ where $k$ is the\\n    Laplacian matrix condition number.\\n\\n    The space required is $O(nw)$ where $w$ is the width of the sparse\\n    Laplacian matrix.  Worse case is $w=n$ for $O(n^2)$.\\n\\n    If the edges have a \\'weight\\' attribute they will be used as\\n    weights in this algorithm.  Unspecified weights are set to 1.\\n\\n    References\\n    ----------\\n    .. [1] Centrality Measures Based on Current Flow.\\n       Ulrik Brandes and Daniel Fleischer,\\n       Proc. 22nd Symp. Theoretical Aspects of Computer Science (STACS \\'05).\\n       LNCS 3404, pp. 533-544. Springer-Verlag, 2005.\\n       https://doi.org/10.1007/978-3-540-31856-9_44\\n\\n    .. [2] A measure of betweenness centrality based on random walks,\\n       M. E. J. Newman, Social Networks 27, 39-54 (2005).\\n    '\n    if not nx.is_connected(G):\n        raise nx.NetworkXError('Graph not connected.')\n    n = G.number_of_nodes()\n    ordering = list(reverse_cuthill_mckee_ordering(G))\n    H = nx.relabel_nodes(G, dict(zip(ordering, range(n))))\n    edges = (tuple(sorted((u, v))) for (u, v) in H.edges())\n    betweenness = dict.fromkeys(edges, 0.0)\n    if normalized:\n        nb = (n - 1.0) * (n - 2.0)\n    else:\n        nb = 2.0\n    for (row, e) in flow_matrix_row(H, weight=weight, dtype=dtype, solver=solver):\n        pos = dict(zip(row.argsort()[::-1], range(1, n + 1)))\n        for i in range(n):\n            betweenness[e] += (i + 1 - pos[i]) * row[i]\n            betweenness[e] += (n - i - pos[i]) * row[i]\n        betweenness[e] /= nb\n    return {(ordering[s], ordering[t]): v for ((s, t), v) in betweenness.items()}",
            "@not_implemented_for('directed')\n@nx._dispatch(edge_attrs='weight')\ndef edge_current_flow_betweenness_centrality(G, normalized=True, weight=None, dtype=float, solver='full'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Compute current-flow betweenness centrality for edges.\\n\\n    Current-flow betweenness centrality uses an electrical current\\n    model for information spreading in contrast to betweenness\\n    centrality which uses shortest paths.\\n\\n    Current-flow betweenness centrality is also known as\\n    random-walk betweenness centrality [2]_.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n      A NetworkX graph\\n\\n    normalized : bool, optional (default=True)\\n      If True the betweenness values are normalized by 2/[(n-1)(n-2)] where\\n      n is the number of nodes in G.\\n\\n    weight : string or None, optional (default=None)\\n      Key for edge data used as the edge weight.\\n      If None, then use 1 as each edge weight.\\n      The weight reflects the capacity or the strength of the\\n      edge.\\n\\n    dtype : data type (default=float)\\n      Default data type for internal matrices.\\n      Set to np.float32 for lower memory consumption.\\n\\n    solver : string (default=\\'full\\')\\n       Type of linear solver to use for computing the flow matrix.\\n       Options are \"full\" (uses most memory), \"lu\" (recommended), and\\n       \"cg\" (uses least memory).\\n\\n    Returns\\n    -------\\n    nodes : dictionary\\n       Dictionary of edge tuples with betweenness centrality as the value.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        The algorithm does not support DiGraphs.\\n        If the input graph is an instance of DiGraph class, NetworkXError\\n        is raised.\\n\\n    See Also\\n    --------\\n    betweenness_centrality\\n    edge_betweenness_centrality\\n    current_flow_betweenness_centrality\\n\\n    Notes\\n    -----\\n    Current-flow betweenness can be computed in $O(I(n-1)+mn \\\\log n)$\\n    time [1]_, where $I(n-1)$ is the time needed to compute the\\n    inverse Laplacian.  For a full matrix this is $O(n^3)$ but using\\n    sparse methods you can achieve $O(nm{\\\\sqrt k})$ where $k$ is the\\n    Laplacian matrix condition number.\\n\\n    The space required is $O(nw)$ where $w$ is the width of the sparse\\n    Laplacian matrix.  Worse case is $w=n$ for $O(n^2)$.\\n\\n    If the edges have a \\'weight\\' attribute they will be used as\\n    weights in this algorithm.  Unspecified weights are set to 1.\\n\\n    References\\n    ----------\\n    .. [1] Centrality Measures Based on Current Flow.\\n       Ulrik Brandes and Daniel Fleischer,\\n       Proc. 22nd Symp. Theoretical Aspects of Computer Science (STACS \\'05).\\n       LNCS 3404, pp. 533-544. Springer-Verlag, 2005.\\n       https://doi.org/10.1007/978-3-540-31856-9_44\\n\\n    .. [2] A measure of betweenness centrality based on random walks,\\n       M. E. J. Newman, Social Networks 27, 39-54 (2005).\\n    '\n    if not nx.is_connected(G):\n        raise nx.NetworkXError('Graph not connected.')\n    n = G.number_of_nodes()\n    ordering = list(reverse_cuthill_mckee_ordering(G))\n    H = nx.relabel_nodes(G, dict(zip(ordering, range(n))))\n    edges = (tuple(sorted((u, v))) for (u, v) in H.edges())\n    betweenness = dict.fromkeys(edges, 0.0)\n    if normalized:\n        nb = (n - 1.0) * (n - 2.0)\n    else:\n        nb = 2.0\n    for (row, e) in flow_matrix_row(H, weight=weight, dtype=dtype, solver=solver):\n        pos = dict(zip(row.argsort()[::-1], range(1, n + 1)))\n        for i in range(n):\n            betweenness[e] += (i + 1 - pos[i]) * row[i]\n            betweenness[e] += (n - i - pos[i]) * row[i]\n        betweenness[e] /= nb\n    return {(ordering[s], ordering[t]): v for ((s, t), v) in betweenness.items()}",
            "@not_implemented_for('directed')\n@nx._dispatch(edge_attrs='weight')\ndef edge_current_flow_betweenness_centrality(G, normalized=True, weight=None, dtype=float, solver='full'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Compute current-flow betweenness centrality for edges.\\n\\n    Current-flow betweenness centrality uses an electrical current\\n    model for information spreading in contrast to betweenness\\n    centrality which uses shortest paths.\\n\\n    Current-flow betweenness centrality is also known as\\n    random-walk betweenness centrality [2]_.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n      A NetworkX graph\\n\\n    normalized : bool, optional (default=True)\\n      If True the betweenness values are normalized by 2/[(n-1)(n-2)] where\\n      n is the number of nodes in G.\\n\\n    weight : string or None, optional (default=None)\\n      Key for edge data used as the edge weight.\\n      If None, then use 1 as each edge weight.\\n      The weight reflects the capacity or the strength of the\\n      edge.\\n\\n    dtype : data type (default=float)\\n      Default data type for internal matrices.\\n      Set to np.float32 for lower memory consumption.\\n\\n    solver : string (default=\\'full\\')\\n       Type of linear solver to use for computing the flow matrix.\\n       Options are \"full\" (uses most memory), \"lu\" (recommended), and\\n       \"cg\" (uses least memory).\\n\\n    Returns\\n    -------\\n    nodes : dictionary\\n       Dictionary of edge tuples with betweenness centrality as the value.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        The algorithm does not support DiGraphs.\\n        If the input graph is an instance of DiGraph class, NetworkXError\\n        is raised.\\n\\n    See Also\\n    --------\\n    betweenness_centrality\\n    edge_betweenness_centrality\\n    current_flow_betweenness_centrality\\n\\n    Notes\\n    -----\\n    Current-flow betweenness can be computed in $O(I(n-1)+mn \\\\log n)$\\n    time [1]_, where $I(n-1)$ is the time needed to compute the\\n    inverse Laplacian.  For a full matrix this is $O(n^3)$ but using\\n    sparse methods you can achieve $O(nm{\\\\sqrt k})$ where $k$ is the\\n    Laplacian matrix condition number.\\n\\n    The space required is $O(nw)$ where $w$ is the width of the sparse\\n    Laplacian matrix.  Worse case is $w=n$ for $O(n^2)$.\\n\\n    If the edges have a \\'weight\\' attribute they will be used as\\n    weights in this algorithm.  Unspecified weights are set to 1.\\n\\n    References\\n    ----------\\n    .. [1] Centrality Measures Based on Current Flow.\\n       Ulrik Brandes and Daniel Fleischer,\\n       Proc. 22nd Symp. Theoretical Aspects of Computer Science (STACS \\'05).\\n       LNCS 3404, pp. 533-544. Springer-Verlag, 2005.\\n       https://doi.org/10.1007/978-3-540-31856-9_44\\n\\n    .. [2] A measure of betweenness centrality based on random walks,\\n       M. E. J. Newman, Social Networks 27, 39-54 (2005).\\n    '\n    if not nx.is_connected(G):\n        raise nx.NetworkXError('Graph not connected.')\n    n = G.number_of_nodes()\n    ordering = list(reverse_cuthill_mckee_ordering(G))\n    H = nx.relabel_nodes(G, dict(zip(ordering, range(n))))\n    edges = (tuple(sorted((u, v))) for (u, v) in H.edges())\n    betweenness = dict.fromkeys(edges, 0.0)\n    if normalized:\n        nb = (n - 1.0) * (n - 2.0)\n    else:\n        nb = 2.0\n    for (row, e) in flow_matrix_row(H, weight=weight, dtype=dtype, solver=solver):\n        pos = dict(zip(row.argsort()[::-1], range(1, n + 1)))\n        for i in range(n):\n            betweenness[e] += (i + 1 - pos[i]) * row[i]\n            betweenness[e] += (n - i - pos[i]) * row[i]\n        betweenness[e] /= nb\n    return {(ordering[s], ordering[t]): v for ((s, t), v) in betweenness.items()}",
            "@not_implemented_for('directed')\n@nx._dispatch(edge_attrs='weight')\ndef edge_current_flow_betweenness_centrality(G, normalized=True, weight=None, dtype=float, solver='full'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Compute current-flow betweenness centrality for edges.\\n\\n    Current-flow betweenness centrality uses an electrical current\\n    model for information spreading in contrast to betweenness\\n    centrality which uses shortest paths.\\n\\n    Current-flow betweenness centrality is also known as\\n    random-walk betweenness centrality [2]_.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n      A NetworkX graph\\n\\n    normalized : bool, optional (default=True)\\n      If True the betweenness values are normalized by 2/[(n-1)(n-2)] where\\n      n is the number of nodes in G.\\n\\n    weight : string or None, optional (default=None)\\n      Key for edge data used as the edge weight.\\n      If None, then use 1 as each edge weight.\\n      The weight reflects the capacity or the strength of the\\n      edge.\\n\\n    dtype : data type (default=float)\\n      Default data type for internal matrices.\\n      Set to np.float32 for lower memory consumption.\\n\\n    solver : string (default=\\'full\\')\\n       Type of linear solver to use for computing the flow matrix.\\n       Options are \"full\" (uses most memory), \"lu\" (recommended), and\\n       \"cg\" (uses least memory).\\n\\n    Returns\\n    -------\\n    nodes : dictionary\\n       Dictionary of edge tuples with betweenness centrality as the value.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        The algorithm does not support DiGraphs.\\n        If the input graph is an instance of DiGraph class, NetworkXError\\n        is raised.\\n\\n    See Also\\n    --------\\n    betweenness_centrality\\n    edge_betweenness_centrality\\n    current_flow_betweenness_centrality\\n\\n    Notes\\n    -----\\n    Current-flow betweenness can be computed in $O(I(n-1)+mn \\\\log n)$\\n    time [1]_, where $I(n-1)$ is the time needed to compute the\\n    inverse Laplacian.  For a full matrix this is $O(n^3)$ but using\\n    sparse methods you can achieve $O(nm{\\\\sqrt k})$ where $k$ is the\\n    Laplacian matrix condition number.\\n\\n    The space required is $O(nw)$ where $w$ is the width of the sparse\\n    Laplacian matrix.  Worse case is $w=n$ for $O(n^2)$.\\n\\n    If the edges have a \\'weight\\' attribute they will be used as\\n    weights in this algorithm.  Unspecified weights are set to 1.\\n\\n    References\\n    ----------\\n    .. [1] Centrality Measures Based on Current Flow.\\n       Ulrik Brandes and Daniel Fleischer,\\n       Proc. 22nd Symp. Theoretical Aspects of Computer Science (STACS \\'05).\\n       LNCS 3404, pp. 533-544. Springer-Verlag, 2005.\\n       https://doi.org/10.1007/978-3-540-31856-9_44\\n\\n    .. [2] A measure of betweenness centrality based on random walks,\\n       M. E. J. Newman, Social Networks 27, 39-54 (2005).\\n    '\n    if not nx.is_connected(G):\n        raise nx.NetworkXError('Graph not connected.')\n    n = G.number_of_nodes()\n    ordering = list(reverse_cuthill_mckee_ordering(G))\n    H = nx.relabel_nodes(G, dict(zip(ordering, range(n))))\n    edges = (tuple(sorted((u, v))) for (u, v) in H.edges())\n    betweenness = dict.fromkeys(edges, 0.0)\n    if normalized:\n        nb = (n - 1.0) * (n - 2.0)\n    else:\n        nb = 2.0\n    for (row, e) in flow_matrix_row(H, weight=weight, dtype=dtype, solver=solver):\n        pos = dict(zip(row.argsort()[::-1], range(1, n + 1)))\n        for i in range(n):\n            betweenness[e] += (i + 1 - pos[i]) * row[i]\n            betweenness[e] += (n - i - pos[i]) * row[i]\n        betweenness[e] /= nb\n    return {(ordering[s], ordering[t]): v for ((s, t), v) in betweenness.items()}"
        ]
    }
]