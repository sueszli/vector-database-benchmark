[
    {
        "func_name": "test_searchsorted",
        "original": "@pytest.mark.parametrize('freq', ['D', '2D'])\ndef test_searchsorted(self, freq):\n    pidx = PeriodIndex(['2014-01-01', '2014-01-02', '2014-01-03', '2014-01-04', '2014-01-05'], freq=freq)\n    p1 = Period('2014-01-01', freq=freq)\n    assert pidx.searchsorted(p1) == 0\n    p2 = Period('2014-01-04', freq=freq)\n    assert pidx.searchsorted(p2) == 3\n    assert pidx.searchsorted(NaT) == 5\n    msg = 'Input has different freq=h from PeriodArray'\n    with pytest.raises(IncompatibleFrequency, match=msg):\n        pidx.searchsorted(Period('2014-01-01', freq='h'))\n    msg = 'Input has different freq=5D from PeriodArray'\n    with pytest.raises(IncompatibleFrequency, match=msg):\n        pidx.searchsorted(Period('2014-01-01', freq='5D'))",
        "mutated": [
            "@pytest.mark.parametrize('freq', ['D', '2D'])\ndef test_searchsorted(self, freq):\n    if False:\n        i = 10\n    pidx = PeriodIndex(['2014-01-01', '2014-01-02', '2014-01-03', '2014-01-04', '2014-01-05'], freq=freq)\n    p1 = Period('2014-01-01', freq=freq)\n    assert pidx.searchsorted(p1) == 0\n    p2 = Period('2014-01-04', freq=freq)\n    assert pidx.searchsorted(p2) == 3\n    assert pidx.searchsorted(NaT) == 5\n    msg = 'Input has different freq=h from PeriodArray'\n    with pytest.raises(IncompatibleFrequency, match=msg):\n        pidx.searchsorted(Period('2014-01-01', freq='h'))\n    msg = 'Input has different freq=5D from PeriodArray'\n    with pytest.raises(IncompatibleFrequency, match=msg):\n        pidx.searchsorted(Period('2014-01-01', freq='5D'))",
            "@pytest.mark.parametrize('freq', ['D', '2D'])\ndef test_searchsorted(self, freq):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    pidx = PeriodIndex(['2014-01-01', '2014-01-02', '2014-01-03', '2014-01-04', '2014-01-05'], freq=freq)\n    p1 = Period('2014-01-01', freq=freq)\n    assert pidx.searchsorted(p1) == 0\n    p2 = Period('2014-01-04', freq=freq)\n    assert pidx.searchsorted(p2) == 3\n    assert pidx.searchsorted(NaT) == 5\n    msg = 'Input has different freq=h from PeriodArray'\n    with pytest.raises(IncompatibleFrequency, match=msg):\n        pidx.searchsorted(Period('2014-01-01', freq='h'))\n    msg = 'Input has different freq=5D from PeriodArray'\n    with pytest.raises(IncompatibleFrequency, match=msg):\n        pidx.searchsorted(Period('2014-01-01', freq='5D'))",
            "@pytest.mark.parametrize('freq', ['D', '2D'])\ndef test_searchsorted(self, freq):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    pidx = PeriodIndex(['2014-01-01', '2014-01-02', '2014-01-03', '2014-01-04', '2014-01-05'], freq=freq)\n    p1 = Period('2014-01-01', freq=freq)\n    assert pidx.searchsorted(p1) == 0\n    p2 = Period('2014-01-04', freq=freq)\n    assert pidx.searchsorted(p2) == 3\n    assert pidx.searchsorted(NaT) == 5\n    msg = 'Input has different freq=h from PeriodArray'\n    with pytest.raises(IncompatibleFrequency, match=msg):\n        pidx.searchsorted(Period('2014-01-01', freq='h'))\n    msg = 'Input has different freq=5D from PeriodArray'\n    with pytest.raises(IncompatibleFrequency, match=msg):\n        pidx.searchsorted(Period('2014-01-01', freq='5D'))",
            "@pytest.mark.parametrize('freq', ['D', '2D'])\ndef test_searchsorted(self, freq):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    pidx = PeriodIndex(['2014-01-01', '2014-01-02', '2014-01-03', '2014-01-04', '2014-01-05'], freq=freq)\n    p1 = Period('2014-01-01', freq=freq)\n    assert pidx.searchsorted(p1) == 0\n    p2 = Period('2014-01-04', freq=freq)\n    assert pidx.searchsorted(p2) == 3\n    assert pidx.searchsorted(NaT) == 5\n    msg = 'Input has different freq=h from PeriodArray'\n    with pytest.raises(IncompatibleFrequency, match=msg):\n        pidx.searchsorted(Period('2014-01-01', freq='h'))\n    msg = 'Input has different freq=5D from PeriodArray'\n    with pytest.raises(IncompatibleFrequency, match=msg):\n        pidx.searchsorted(Period('2014-01-01', freq='5D'))",
            "@pytest.mark.parametrize('freq', ['D', '2D'])\ndef test_searchsorted(self, freq):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    pidx = PeriodIndex(['2014-01-01', '2014-01-02', '2014-01-03', '2014-01-04', '2014-01-05'], freq=freq)\n    p1 = Period('2014-01-01', freq=freq)\n    assert pidx.searchsorted(p1) == 0\n    p2 = Period('2014-01-04', freq=freq)\n    assert pidx.searchsorted(p2) == 3\n    assert pidx.searchsorted(NaT) == 5\n    msg = 'Input has different freq=h from PeriodArray'\n    with pytest.raises(IncompatibleFrequency, match=msg):\n        pidx.searchsorted(Period('2014-01-01', freq='h'))\n    msg = 'Input has different freq=5D from PeriodArray'\n    with pytest.raises(IncompatibleFrequency, match=msg):\n        pidx.searchsorted(Period('2014-01-01', freq='5D'))"
        ]
    },
    {
        "func_name": "test_searchsorted_different_argument_classes",
        "original": "def test_searchsorted_different_argument_classes(self, listlike_box):\n    pidx = PeriodIndex(['2014-01-01', '2014-01-02', '2014-01-03', '2014-01-04', '2014-01-05'], freq='D')\n    result = pidx.searchsorted(listlike_box(pidx))\n    expected = np.arange(len(pidx), dtype=result.dtype)\n    tm.assert_numpy_array_equal(result, expected)\n    result = pidx._data.searchsorted(listlike_box(pidx))\n    tm.assert_numpy_array_equal(result, expected)",
        "mutated": [
            "def test_searchsorted_different_argument_classes(self, listlike_box):\n    if False:\n        i = 10\n    pidx = PeriodIndex(['2014-01-01', '2014-01-02', '2014-01-03', '2014-01-04', '2014-01-05'], freq='D')\n    result = pidx.searchsorted(listlike_box(pidx))\n    expected = np.arange(len(pidx), dtype=result.dtype)\n    tm.assert_numpy_array_equal(result, expected)\n    result = pidx._data.searchsorted(listlike_box(pidx))\n    tm.assert_numpy_array_equal(result, expected)",
            "def test_searchsorted_different_argument_classes(self, listlike_box):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    pidx = PeriodIndex(['2014-01-01', '2014-01-02', '2014-01-03', '2014-01-04', '2014-01-05'], freq='D')\n    result = pidx.searchsorted(listlike_box(pidx))\n    expected = np.arange(len(pidx), dtype=result.dtype)\n    tm.assert_numpy_array_equal(result, expected)\n    result = pidx._data.searchsorted(listlike_box(pidx))\n    tm.assert_numpy_array_equal(result, expected)",
            "def test_searchsorted_different_argument_classes(self, listlike_box):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    pidx = PeriodIndex(['2014-01-01', '2014-01-02', '2014-01-03', '2014-01-04', '2014-01-05'], freq='D')\n    result = pidx.searchsorted(listlike_box(pidx))\n    expected = np.arange(len(pidx), dtype=result.dtype)\n    tm.assert_numpy_array_equal(result, expected)\n    result = pidx._data.searchsorted(listlike_box(pidx))\n    tm.assert_numpy_array_equal(result, expected)",
            "def test_searchsorted_different_argument_classes(self, listlike_box):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    pidx = PeriodIndex(['2014-01-01', '2014-01-02', '2014-01-03', '2014-01-04', '2014-01-05'], freq='D')\n    result = pidx.searchsorted(listlike_box(pidx))\n    expected = np.arange(len(pidx), dtype=result.dtype)\n    tm.assert_numpy_array_equal(result, expected)\n    result = pidx._data.searchsorted(listlike_box(pidx))\n    tm.assert_numpy_array_equal(result, expected)",
            "def test_searchsorted_different_argument_classes(self, listlike_box):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    pidx = PeriodIndex(['2014-01-01', '2014-01-02', '2014-01-03', '2014-01-04', '2014-01-05'], freq='D')\n    result = pidx.searchsorted(listlike_box(pidx))\n    expected = np.arange(len(pidx), dtype=result.dtype)\n    tm.assert_numpy_array_equal(result, expected)\n    result = pidx._data.searchsorted(listlike_box(pidx))\n    tm.assert_numpy_array_equal(result, expected)"
        ]
    },
    {
        "func_name": "test_searchsorted_invalid",
        "original": "def test_searchsorted_invalid(self):\n    pidx = PeriodIndex(['2014-01-01', '2014-01-02', '2014-01-03', '2014-01-04', '2014-01-05'], freq='D')\n    other = np.array([0, 1], dtype=np.int64)\n    msg = '|'.join(['searchsorted requires compatible dtype or scalar', \"value should be a 'Period', 'NaT', or array of those. Got\"])\n    with pytest.raises(TypeError, match=msg):\n        pidx.searchsorted(other)\n    with pytest.raises(TypeError, match=msg):\n        pidx.searchsorted(other.astype('timedelta64[ns]'))\n    with pytest.raises(TypeError, match=msg):\n        pidx.searchsorted(np.timedelta64(4))\n    with pytest.raises(TypeError, match=msg):\n        pidx.searchsorted(np.timedelta64('NaT', 'ms'))\n    with pytest.raises(TypeError, match=msg):\n        pidx.searchsorted(np.datetime64(4, 'ns'))\n    with pytest.raises(TypeError, match=msg):\n        pidx.searchsorted(np.datetime64('NaT', 'ns'))",
        "mutated": [
            "def test_searchsorted_invalid(self):\n    if False:\n        i = 10\n    pidx = PeriodIndex(['2014-01-01', '2014-01-02', '2014-01-03', '2014-01-04', '2014-01-05'], freq='D')\n    other = np.array([0, 1], dtype=np.int64)\n    msg = '|'.join(['searchsorted requires compatible dtype or scalar', \"value should be a 'Period', 'NaT', or array of those. Got\"])\n    with pytest.raises(TypeError, match=msg):\n        pidx.searchsorted(other)\n    with pytest.raises(TypeError, match=msg):\n        pidx.searchsorted(other.astype('timedelta64[ns]'))\n    with pytest.raises(TypeError, match=msg):\n        pidx.searchsorted(np.timedelta64(4))\n    with pytest.raises(TypeError, match=msg):\n        pidx.searchsorted(np.timedelta64('NaT', 'ms'))\n    with pytest.raises(TypeError, match=msg):\n        pidx.searchsorted(np.datetime64(4, 'ns'))\n    with pytest.raises(TypeError, match=msg):\n        pidx.searchsorted(np.datetime64('NaT', 'ns'))",
            "def test_searchsorted_invalid(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    pidx = PeriodIndex(['2014-01-01', '2014-01-02', '2014-01-03', '2014-01-04', '2014-01-05'], freq='D')\n    other = np.array([0, 1], dtype=np.int64)\n    msg = '|'.join(['searchsorted requires compatible dtype or scalar', \"value should be a 'Period', 'NaT', or array of those. Got\"])\n    with pytest.raises(TypeError, match=msg):\n        pidx.searchsorted(other)\n    with pytest.raises(TypeError, match=msg):\n        pidx.searchsorted(other.astype('timedelta64[ns]'))\n    with pytest.raises(TypeError, match=msg):\n        pidx.searchsorted(np.timedelta64(4))\n    with pytest.raises(TypeError, match=msg):\n        pidx.searchsorted(np.timedelta64('NaT', 'ms'))\n    with pytest.raises(TypeError, match=msg):\n        pidx.searchsorted(np.datetime64(4, 'ns'))\n    with pytest.raises(TypeError, match=msg):\n        pidx.searchsorted(np.datetime64('NaT', 'ns'))",
            "def test_searchsorted_invalid(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    pidx = PeriodIndex(['2014-01-01', '2014-01-02', '2014-01-03', '2014-01-04', '2014-01-05'], freq='D')\n    other = np.array([0, 1], dtype=np.int64)\n    msg = '|'.join(['searchsorted requires compatible dtype or scalar', \"value should be a 'Period', 'NaT', or array of those. Got\"])\n    with pytest.raises(TypeError, match=msg):\n        pidx.searchsorted(other)\n    with pytest.raises(TypeError, match=msg):\n        pidx.searchsorted(other.astype('timedelta64[ns]'))\n    with pytest.raises(TypeError, match=msg):\n        pidx.searchsorted(np.timedelta64(4))\n    with pytest.raises(TypeError, match=msg):\n        pidx.searchsorted(np.timedelta64('NaT', 'ms'))\n    with pytest.raises(TypeError, match=msg):\n        pidx.searchsorted(np.datetime64(4, 'ns'))\n    with pytest.raises(TypeError, match=msg):\n        pidx.searchsorted(np.datetime64('NaT', 'ns'))",
            "def test_searchsorted_invalid(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    pidx = PeriodIndex(['2014-01-01', '2014-01-02', '2014-01-03', '2014-01-04', '2014-01-05'], freq='D')\n    other = np.array([0, 1], dtype=np.int64)\n    msg = '|'.join(['searchsorted requires compatible dtype or scalar', \"value should be a 'Period', 'NaT', or array of those. Got\"])\n    with pytest.raises(TypeError, match=msg):\n        pidx.searchsorted(other)\n    with pytest.raises(TypeError, match=msg):\n        pidx.searchsorted(other.astype('timedelta64[ns]'))\n    with pytest.raises(TypeError, match=msg):\n        pidx.searchsorted(np.timedelta64(4))\n    with pytest.raises(TypeError, match=msg):\n        pidx.searchsorted(np.timedelta64('NaT', 'ms'))\n    with pytest.raises(TypeError, match=msg):\n        pidx.searchsorted(np.datetime64(4, 'ns'))\n    with pytest.raises(TypeError, match=msg):\n        pidx.searchsorted(np.datetime64('NaT', 'ns'))",
            "def test_searchsorted_invalid(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    pidx = PeriodIndex(['2014-01-01', '2014-01-02', '2014-01-03', '2014-01-04', '2014-01-05'], freq='D')\n    other = np.array([0, 1], dtype=np.int64)\n    msg = '|'.join(['searchsorted requires compatible dtype or scalar', \"value should be a 'Period', 'NaT', or array of those. Got\"])\n    with pytest.raises(TypeError, match=msg):\n        pidx.searchsorted(other)\n    with pytest.raises(TypeError, match=msg):\n        pidx.searchsorted(other.astype('timedelta64[ns]'))\n    with pytest.raises(TypeError, match=msg):\n        pidx.searchsorted(np.timedelta64(4))\n    with pytest.raises(TypeError, match=msg):\n        pidx.searchsorted(np.timedelta64('NaT', 'ms'))\n    with pytest.raises(TypeError, match=msg):\n        pidx.searchsorted(np.datetime64(4, 'ns'))\n    with pytest.raises(TypeError, match=msg):\n        pidx.searchsorted(np.datetime64('NaT', 'ns'))"
        ]
    }
]