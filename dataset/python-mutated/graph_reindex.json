[
    {
        "func_name": "graph_reindex",
        "original": "@deprecated(since='2.4.0', update_to='paddle.geometric.reindex_graph', level=1, reason='paddle.incubate.graph_reindex will be removed in future')\ndef graph_reindex(x, neighbors, count, value_buffer=None, index_buffer=None, flag_buffer_hashtable=False, name=None):\n    \"\"\"\n\n    Graph Reindex API.\n\n    This API is mainly used in Graph Learning domain, which should be used\n    in conjunction with `graph_sample_neighbors` API. And the main purpose\n    is to reindex the ids information of the input nodes, and return the\n    corresponding graph edges after reindex.\n\n    Notes:\n        The number in x should be unique, otherwise it would cause potential errors.\n        Besides, we also support multi-edge-types neighbors reindexing. If we have different\n        edge_type neighbors for x, we should concatenate all the neighbors and count of x.\n        We will reindex all the nodes from 0.\n\n    Take input nodes x = [0, 1, 2] as an example.\n    If we have neighbors = [8, 9, 0, 4, 7, 6, 7], and count = [2, 3, 2],\n    then we know that the neighbors of 0 is [8, 9], the neighbors of 1\n    is [0, 4, 7], and the neighbors of 2 is [6, 7].\n\n    Args:\n        x (Tensor): The input nodes which we sample neighbors for. The available\n                    data type is int32, int64.\n        neighbors (Tensor): The neighbors of the input nodes `x`. The data type\n                            should be the same with `x`.\n        count (Tensor): The neighbor count of the input nodes `x`. And the\n                        data type should be int32.\n        value_buffer (Tensor, optional): Value buffer for hashtable. The data type should\n                                    be int32, and should be filled with -1. Default is None.\n        index_buffer (Tensor, optional): Index buffer for hashtable. The data type should\n                                    be int32, and should be filled with -1. Default is None.\n        flag_buffer_hashtable (bool, optional): Whether to use buffer for hashtable to speed up.\n                                      Default is False. Only useful for gpu version currently.\n        name (str, optional): Name for the operation (optional, default is None).\n                              For more information, please refer to :ref:`api_guide_Name`.\n\n    Returns:\n        - reindex_src (Tensor), The source node index of graph edges after reindex.\n        - reindex_dst (Tensor), The destination node index of graph edges after reindex.\n        - out_nodes (Tensor), The index of unique input nodes and neighbors before reindex,\n          where we put the input nodes `x` in the front, and put neighbor\n          nodes in the back.\n\n    Examples:\n        .. code-block:: python\n\n            >>> import paddle\n\n            >>> x = [0, 1, 2]\n            >>> neighbors_e1 = [8, 9, 0, 4, 7, 6, 7]\n            >>> count_e1 = [2, 3, 2]\n            >>> x = paddle.to_tensor(x, dtype=\"int64\")\n            >>> neighbors_e1 = paddle.to_tensor(neighbors_e1, dtype=\"int64\")\n            >>> count_e1 = paddle.to_tensor(count_e1, dtype=\"int32\")\n\n            >>> reindex_src, reindex_dst, out_nodes = paddle.incubate.graph_reindex(\n            ...     x,\n            ...     neighbors_e1,\n            ...     count_e1,\n            ... )\n            >>> print(reindex_src)\n            Tensor(shape=[7], dtype=int64, place=Place(cpu), stop_gradient=True,\n            [3, 4, 0, 5, 6, 7, 6])\n            >>> print(reindex_dst)\n            Tensor(shape=[7], dtype=int64, place=Place(cpu), stop_gradient=True,\n            [0, 0, 1, 1, 1, 2, 2])\n            >>> print(out_nodes)\n            Tensor(shape=[8], dtype=int64, place=Place(cpu), stop_gradient=True,\n            [0, 1, 2, 8, 9, 4, 7, 6])\n\n            >>> neighbors_e2 = [0, 2, 3, 5, 1]\n            >>> count_e2 = [1, 3, 1]\n            >>> neighbors_e2 = paddle.to_tensor(neighbors_e2, dtype=\"int64\")\n            >>> count_e2 = paddle.to_tensor(count_e2, dtype=\"int32\")\n\n            >>> neighbors = paddle.concat([neighbors_e1, neighbors_e2])\n            >>> count = paddle.concat([count_e1, count_e2])\n            >>> reindex_src, reindex_dst, out_nodes = paddle.incubate.graph_reindex(x, neighbors, count)\n            >>> print(reindex_src)\n            Tensor(shape=[12], dtype=int64, place=Place(cpu), stop_gradient=True,\n            [3, 4, 0, 5, 6, 7, 6, 0, 2, 8, 9, 1])\n            >>> print(reindex_dst)\n            Tensor(shape=[12], dtype=int64, place=Place(cpu), stop_gradient=True,\n            [0, 0, 1, 1, 1, 2, 2, 0, 1, 1, 1, 2])\n            >>> print(out_nodes)\n            Tensor(shape=[10], dtype=int64, place=Place(cpu), stop_gradient=True,\n            [0, 1, 2, 8, 9, 4, 7, 6, 3, 5])\n\n    \"\"\"\n    if flag_buffer_hashtable:\n        if value_buffer is None or index_buffer is None:\n            raise ValueError('`value_buffer` and `index_buffer` should notbe None if `flag_buffer_hashtable` is True.')\n    if in_dynamic_mode():\n        (reindex_src, reindex_dst, out_nodes) = _C_ops.reindex_graph(x, neighbors, count, value_buffer, index_buffer)\n        return (reindex_src, reindex_dst, out_nodes)\n    check_variable_and_dtype(x, 'X', ('int32', 'int64'), 'graph_reindex')\n    check_variable_and_dtype(neighbors, 'Neighbors', ('int32', 'int64'), 'graph_reindex')\n    check_variable_and_dtype(count, 'Count', 'int32', 'graph_reindex')\n    if flag_buffer_hashtable:\n        check_variable_and_dtype(value_buffer, 'HashTable_Value', 'int32', 'graph_reindex')\n        check_variable_and_dtype(index_buffer, 'HashTable_Index', 'int32', 'graph_reindex')\n    helper = LayerHelper('graph_reindex', **locals())\n    reindex_src = helper.create_variable_for_type_inference(dtype=x.dtype)\n    reindex_dst = helper.create_variable_for_type_inference(dtype=x.dtype)\n    out_nodes = helper.create_variable_for_type_inference(dtype=x.dtype)\n    helper.append_op(type='graph_reindex', inputs={'X': x, 'Neighbors': neighbors, 'Count': count, 'HashTable_Value': value_buffer if flag_buffer_hashtable else None, 'HashTable_Index': index_buffer if flag_buffer_hashtable else None}, outputs={'Reindex_Src': reindex_src, 'Reindex_Dst': reindex_dst, 'Out_Nodes': out_nodes})\n    return (reindex_src, reindex_dst, out_nodes)",
        "mutated": [
            "@deprecated(since='2.4.0', update_to='paddle.geometric.reindex_graph', level=1, reason='paddle.incubate.graph_reindex will be removed in future')\ndef graph_reindex(x, neighbors, count, value_buffer=None, index_buffer=None, flag_buffer_hashtable=False, name=None):\n    if False:\n        i = 10\n    '\\n\\n    Graph Reindex API.\\n\\n    This API is mainly used in Graph Learning domain, which should be used\\n    in conjunction with `graph_sample_neighbors` API. And the main purpose\\n    is to reindex the ids information of the input nodes, and return the\\n    corresponding graph edges after reindex.\\n\\n    Notes:\\n        The number in x should be unique, otherwise it would cause potential errors.\\n        Besides, we also support multi-edge-types neighbors reindexing. If we have different\\n        edge_type neighbors for x, we should concatenate all the neighbors and count of x.\\n        We will reindex all the nodes from 0.\\n\\n    Take input nodes x = [0, 1, 2] as an example.\\n    If we have neighbors = [8, 9, 0, 4, 7, 6, 7], and count = [2, 3, 2],\\n    then we know that the neighbors of 0 is [8, 9], the neighbors of 1\\n    is [0, 4, 7], and the neighbors of 2 is [6, 7].\\n\\n    Args:\\n        x (Tensor): The input nodes which we sample neighbors for. The available\\n                    data type is int32, int64.\\n        neighbors (Tensor): The neighbors of the input nodes `x`. The data type\\n                            should be the same with `x`.\\n        count (Tensor): The neighbor count of the input nodes `x`. And the\\n                        data type should be int32.\\n        value_buffer (Tensor, optional): Value buffer for hashtable. The data type should\\n                                    be int32, and should be filled with -1. Default is None.\\n        index_buffer (Tensor, optional): Index buffer for hashtable. The data type should\\n                                    be int32, and should be filled with -1. Default is None.\\n        flag_buffer_hashtable (bool, optional): Whether to use buffer for hashtable to speed up.\\n                                      Default is False. Only useful for gpu version currently.\\n        name (str, optional): Name for the operation (optional, default is None).\\n                              For more information, please refer to :ref:`api_guide_Name`.\\n\\n    Returns:\\n        - reindex_src (Tensor), The source node index of graph edges after reindex.\\n        - reindex_dst (Tensor), The destination node index of graph edges after reindex.\\n        - out_nodes (Tensor), The index of unique input nodes and neighbors before reindex,\\n          where we put the input nodes `x` in the front, and put neighbor\\n          nodes in the back.\\n\\n    Examples:\\n        .. code-block:: python\\n\\n            >>> import paddle\\n\\n            >>> x = [0, 1, 2]\\n            >>> neighbors_e1 = [8, 9, 0, 4, 7, 6, 7]\\n            >>> count_e1 = [2, 3, 2]\\n            >>> x = paddle.to_tensor(x, dtype=\"int64\")\\n            >>> neighbors_e1 = paddle.to_tensor(neighbors_e1, dtype=\"int64\")\\n            >>> count_e1 = paddle.to_tensor(count_e1, dtype=\"int32\")\\n\\n            >>> reindex_src, reindex_dst, out_nodes = paddle.incubate.graph_reindex(\\n            ...     x,\\n            ...     neighbors_e1,\\n            ...     count_e1,\\n            ... )\\n            >>> print(reindex_src)\\n            Tensor(shape=[7], dtype=int64, place=Place(cpu), stop_gradient=True,\\n            [3, 4, 0, 5, 6, 7, 6])\\n            >>> print(reindex_dst)\\n            Tensor(shape=[7], dtype=int64, place=Place(cpu), stop_gradient=True,\\n            [0, 0, 1, 1, 1, 2, 2])\\n            >>> print(out_nodes)\\n            Tensor(shape=[8], dtype=int64, place=Place(cpu), stop_gradient=True,\\n            [0, 1, 2, 8, 9, 4, 7, 6])\\n\\n            >>> neighbors_e2 = [0, 2, 3, 5, 1]\\n            >>> count_e2 = [1, 3, 1]\\n            >>> neighbors_e2 = paddle.to_tensor(neighbors_e2, dtype=\"int64\")\\n            >>> count_e2 = paddle.to_tensor(count_e2, dtype=\"int32\")\\n\\n            >>> neighbors = paddle.concat([neighbors_e1, neighbors_e2])\\n            >>> count = paddle.concat([count_e1, count_e2])\\n            >>> reindex_src, reindex_dst, out_nodes = paddle.incubate.graph_reindex(x, neighbors, count)\\n            >>> print(reindex_src)\\n            Tensor(shape=[12], dtype=int64, place=Place(cpu), stop_gradient=True,\\n            [3, 4, 0, 5, 6, 7, 6, 0, 2, 8, 9, 1])\\n            >>> print(reindex_dst)\\n            Tensor(shape=[12], dtype=int64, place=Place(cpu), stop_gradient=True,\\n            [0, 0, 1, 1, 1, 2, 2, 0, 1, 1, 1, 2])\\n            >>> print(out_nodes)\\n            Tensor(shape=[10], dtype=int64, place=Place(cpu), stop_gradient=True,\\n            [0, 1, 2, 8, 9, 4, 7, 6, 3, 5])\\n\\n    '\n    if flag_buffer_hashtable:\n        if value_buffer is None or index_buffer is None:\n            raise ValueError('`value_buffer` and `index_buffer` should notbe None if `flag_buffer_hashtable` is True.')\n    if in_dynamic_mode():\n        (reindex_src, reindex_dst, out_nodes) = _C_ops.reindex_graph(x, neighbors, count, value_buffer, index_buffer)\n        return (reindex_src, reindex_dst, out_nodes)\n    check_variable_and_dtype(x, 'X', ('int32', 'int64'), 'graph_reindex')\n    check_variable_and_dtype(neighbors, 'Neighbors', ('int32', 'int64'), 'graph_reindex')\n    check_variable_and_dtype(count, 'Count', 'int32', 'graph_reindex')\n    if flag_buffer_hashtable:\n        check_variable_and_dtype(value_buffer, 'HashTable_Value', 'int32', 'graph_reindex')\n        check_variable_and_dtype(index_buffer, 'HashTable_Index', 'int32', 'graph_reindex')\n    helper = LayerHelper('graph_reindex', **locals())\n    reindex_src = helper.create_variable_for_type_inference(dtype=x.dtype)\n    reindex_dst = helper.create_variable_for_type_inference(dtype=x.dtype)\n    out_nodes = helper.create_variable_for_type_inference(dtype=x.dtype)\n    helper.append_op(type='graph_reindex', inputs={'X': x, 'Neighbors': neighbors, 'Count': count, 'HashTable_Value': value_buffer if flag_buffer_hashtable else None, 'HashTable_Index': index_buffer if flag_buffer_hashtable else None}, outputs={'Reindex_Src': reindex_src, 'Reindex_Dst': reindex_dst, 'Out_Nodes': out_nodes})\n    return (reindex_src, reindex_dst, out_nodes)",
            "@deprecated(since='2.4.0', update_to='paddle.geometric.reindex_graph', level=1, reason='paddle.incubate.graph_reindex will be removed in future')\ndef graph_reindex(x, neighbors, count, value_buffer=None, index_buffer=None, flag_buffer_hashtable=False, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n\\n    Graph Reindex API.\\n\\n    This API is mainly used in Graph Learning domain, which should be used\\n    in conjunction with `graph_sample_neighbors` API. And the main purpose\\n    is to reindex the ids information of the input nodes, and return the\\n    corresponding graph edges after reindex.\\n\\n    Notes:\\n        The number in x should be unique, otherwise it would cause potential errors.\\n        Besides, we also support multi-edge-types neighbors reindexing. If we have different\\n        edge_type neighbors for x, we should concatenate all the neighbors and count of x.\\n        We will reindex all the nodes from 0.\\n\\n    Take input nodes x = [0, 1, 2] as an example.\\n    If we have neighbors = [8, 9, 0, 4, 7, 6, 7], and count = [2, 3, 2],\\n    then we know that the neighbors of 0 is [8, 9], the neighbors of 1\\n    is [0, 4, 7], and the neighbors of 2 is [6, 7].\\n\\n    Args:\\n        x (Tensor): The input nodes which we sample neighbors for. The available\\n                    data type is int32, int64.\\n        neighbors (Tensor): The neighbors of the input nodes `x`. The data type\\n                            should be the same with `x`.\\n        count (Tensor): The neighbor count of the input nodes `x`. And the\\n                        data type should be int32.\\n        value_buffer (Tensor, optional): Value buffer for hashtable. The data type should\\n                                    be int32, and should be filled with -1. Default is None.\\n        index_buffer (Tensor, optional): Index buffer for hashtable. The data type should\\n                                    be int32, and should be filled with -1. Default is None.\\n        flag_buffer_hashtable (bool, optional): Whether to use buffer for hashtable to speed up.\\n                                      Default is False. Only useful for gpu version currently.\\n        name (str, optional): Name for the operation (optional, default is None).\\n                              For more information, please refer to :ref:`api_guide_Name`.\\n\\n    Returns:\\n        - reindex_src (Tensor), The source node index of graph edges after reindex.\\n        - reindex_dst (Tensor), The destination node index of graph edges after reindex.\\n        - out_nodes (Tensor), The index of unique input nodes and neighbors before reindex,\\n          where we put the input nodes `x` in the front, and put neighbor\\n          nodes in the back.\\n\\n    Examples:\\n        .. code-block:: python\\n\\n            >>> import paddle\\n\\n            >>> x = [0, 1, 2]\\n            >>> neighbors_e1 = [8, 9, 0, 4, 7, 6, 7]\\n            >>> count_e1 = [2, 3, 2]\\n            >>> x = paddle.to_tensor(x, dtype=\"int64\")\\n            >>> neighbors_e1 = paddle.to_tensor(neighbors_e1, dtype=\"int64\")\\n            >>> count_e1 = paddle.to_tensor(count_e1, dtype=\"int32\")\\n\\n            >>> reindex_src, reindex_dst, out_nodes = paddle.incubate.graph_reindex(\\n            ...     x,\\n            ...     neighbors_e1,\\n            ...     count_e1,\\n            ... )\\n            >>> print(reindex_src)\\n            Tensor(shape=[7], dtype=int64, place=Place(cpu), stop_gradient=True,\\n            [3, 4, 0, 5, 6, 7, 6])\\n            >>> print(reindex_dst)\\n            Tensor(shape=[7], dtype=int64, place=Place(cpu), stop_gradient=True,\\n            [0, 0, 1, 1, 1, 2, 2])\\n            >>> print(out_nodes)\\n            Tensor(shape=[8], dtype=int64, place=Place(cpu), stop_gradient=True,\\n            [0, 1, 2, 8, 9, 4, 7, 6])\\n\\n            >>> neighbors_e2 = [0, 2, 3, 5, 1]\\n            >>> count_e2 = [1, 3, 1]\\n            >>> neighbors_e2 = paddle.to_tensor(neighbors_e2, dtype=\"int64\")\\n            >>> count_e2 = paddle.to_tensor(count_e2, dtype=\"int32\")\\n\\n            >>> neighbors = paddle.concat([neighbors_e1, neighbors_e2])\\n            >>> count = paddle.concat([count_e1, count_e2])\\n            >>> reindex_src, reindex_dst, out_nodes = paddle.incubate.graph_reindex(x, neighbors, count)\\n            >>> print(reindex_src)\\n            Tensor(shape=[12], dtype=int64, place=Place(cpu), stop_gradient=True,\\n            [3, 4, 0, 5, 6, 7, 6, 0, 2, 8, 9, 1])\\n            >>> print(reindex_dst)\\n            Tensor(shape=[12], dtype=int64, place=Place(cpu), stop_gradient=True,\\n            [0, 0, 1, 1, 1, 2, 2, 0, 1, 1, 1, 2])\\n            >>> print(out_nodes)\\n            Tensor(shape=[10], dtype=int64, place=Place(cpu), stop_gradient=True,\\n            [0, 1, 2, 8, 9, 4, 7, 6, 3, 5])\\n\\n    '\n    if flag_buffer_hashtable:\n        if value_buffer is None or index_buffer is None:\n            raise ValueError('`value_buffer` and `index_buffer` should notbe None if `flag_buffer_hashtable` is True.')\n    if in_dynamic_mode():\n        (reindex_src, reindex_dst, out_nodes) = _C_ops.reindex_graph(x, neighbors, count, value_buffer, index_buffer)\n        return (reindex_src, reindex_dst, out_nodes)\n    check_variable_and_dtype(x, 'X', ('int32', 'int64'), 'graph_reindex')\n    check_variable_and_dtype(neighbors, 'Neighbors', ('int32', 'int64'), 'graph_reindex')\n    check_variable_and_dtype(count, 'Count', 'int32', 'graph_reindex')\n    if flag_buffer_hashtable:\n        check_variable_and_dtype(value_buffer, 'HashTable_Value', 'int32', 'graph_reindex')\n        check_variable_and_dtype(index_buffer, 'HashTable_Index', 'int32', 'graph_reindex')\n    helper = LayerHelper('graph_reindex', **locals())\n    reindex_src = helper.create_variable_for_type_inference(dtype=x.dtype)\n    reindex_dst = helper.create_variable_for_type_inference(dtype=x.dtype)\n    out_nodes = helper.create_variable_for_type_inference(dtype=x.dtype)\n    helper.append_op(type='graph_reindex', inputs={'X': x, 'Neighbors': neighbors, 'Count': count, 'HashTable_Value': value_buffer if flag_buffer_hashtable else None, 'HashTable_Index': index_buffer if flag_buffer_hashtable else None}, outputs={'Reindex_Src': reindex_src, 'Reindex_Dst': reindex_dst, 'Out_Nodes': out_nodes})\n    return (reindex_src, reindex_dst, out_nodes)",
            "@deprecated(since='2.4.0', update_to='paddle.geometric.reindex_graph', level=1, reason='paddle.incubate.graph_reindex will be removed in future')\ndef graph_reindex(x, neighbors, count, value_buffer=None, index_buffer=None, flag_buffer_hashtable=False, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n\\n    Graph Reindex API.\\n\\n    This API is mainly used in Graph Learning domain, which should be used\\n    in conjunction with `graph_sample_neighbors` API. And the main purpose\\n    is to reindex the ids information of the input nodes, and return the\\n    corresponding graph edges after reindex.\\n\\n    Notes:\\n        The number in x should be unique, otherwise it would cause potential errors.\\n        Besides, we also support multi-edge-types neighbors reindexing. If we have different\\n        edge_type neighbors for x, we should concatenate all the neighbors and count of x.\\n        We will reindex all the nodes from 0.\\n\\n    Take input nodes x = [0, 1, 2] as an example.\\n    If we have neighbors = [8, 9, 0, 4, 7, 6, 7], and count = [2, 3, 2],\\n    then we know that the neighbors of 0 is [8, 9], the neighbors of 1\\n    is [0, 4, 7], and the neighbors of 2 is [6, 7].\\n\\n    Args:\\n        x (Tensor): The input nodes which we sample neighbors for. The available\\n                    data type is int32, int64.\\n        neighbors (Tensor): The neighbors of the input nodes `x`. The data type\\n                            should be the same with `x`.\\n        count (Tensor): The neighbor count of the input nodes `x`. And the\\n                        data type should be int32.\\n        value_buffer (Tensor, optional): Value buffer for hashtable. The data type should\\n                                    be int32, and should be filled with -1. Default is None.\\n        index_buffer (Tensor, optional): Index buffer for hashtable. The data type should\\n                                    be int32, and should be filled with -1. Default is None.\\n        flag_buffer_hashtable (bool, optional): Whether to use buffer for hashtable to speed up.\\n                                      Default is False. Only useful for gpu version currently.\\n        name (str, optional): Name for the operation (optional, default is None).\\n                              For more information, please refer to :ref:`api_guide_Name`.\\n\\n    Returns:\\n        - reindex_src (Tensor), The source node index of graph edges after reindex.\\n        - reindex_dst (Tensor), The destination node index of graph edges after reindex.\\n        - out_nodes (Tensor), The index of unique input nodes and neighbors before reindex,\\n          where we put the input nodes `x` in the front, and put neighbor\\n          nodes in the back.\\n\\n    Examples:\\n        .. code-block:: python\\n\\n            >>> import paddle\\n\\n            >>> x = [0, 1, 2]\\n            >>> neighbors_e1 = [8, 9, 0, 4, 7, 6, 7]\\n            >>> count_e1 = [2, 3, 2]\\n            >>> x = paddle.to_tensor(x, dtype=\"int64\")\\n            >>> neighbors_e1 = paddle.to_tensor(neighbors_e1, dtype=\"int64\")\\n            >>> count_e1 = paddle.to_tensor(count_e1, dtype=\"int32\")\\n\\n            >>> reindex_src, reindex_dst, out_nodes = paddle.incubate.graph_reindex(\\n            ...     x,\\n            ...     neighbors_e1,\\n            ...     count_e1,\\n            ... )\\n            >>> print(reindex_src)\\n            Tensor(shape=[7], dtype=int64, place=Place(cpu), stop_gradient=True,\\n            [3, 4, 0, 5, 6, 7, 6])\\n            >>> print(reindex_dst)\\n            Tensor(shape=[7], dtype=int64, place=Place(cpu), stop_gradient=True,\\n            [0, 0, 1, 1, 1, 2, 2])\\n            >>> print(out_nodes)\\n            Tensor(shape=[8], dtype=int64, place=Place(cpu), stop_gradient=True,\\n            [0, 1, 2, 8, 9, 4, 7, 6])\\n\\n            >>> neighbors_e2 = [0, 2, 3, 5, 1]\\n            >>> count_e2 = [1, 3, 1]\\n            >>> neighbors_e2 = paddle.to_tensor(neighbors_e2, dtype=\"int64\")\\n            >>> count_e2 = paddle.to_tensor(count_e2, dtype=\"int32\")\\n\\n            >>> neighbors = paddle.concat([neighbors_e1, neighbors_e2])\\n            >>> count = paddle.concat([count_e1, count_e2])\\n            >>> reindex_src, reindex_dst, out_nodes = paddle.incubate.graph_reindex(x, neighbors, count)\\n            >>> print(reindex_src)\\n            Tensor(shape=[12], dtype=int64, place=Place(cpu), stop_gradient=True,\\n            [3, 4, 0, 5, 6, 7, 6, 0, 2, 8, 9, 1])\\n            >>> print(reindex_dst)\\n            Tensor(shape=[12], dtype=int64, place=Place(cpu), stop_gradient=True,\\n            [0, 0, 1, 1, 1, 2, 2, 0, 1, 1, 1, 2])\\n            >>> print(out_nodes)\\n            Tensor(shape=[10], dtype=int64, place=Place(cpu), stop_gradient=True,\\n            [0, 1, 2, 8, 9, 4, 7, 6, 3, 5])\\n\\n    '\n    if flag_buffer_hashtable:\n        if value_buffer is None or index_buffer is None:\n            raise ValueError('`value_buffer` and `index_buffer` should notbe None if `flag_buffer_hashtable` is True.')\n    if in_dynamic_mode():\n        (reindex_src, reindex_dst, out_nodes) = _C_ops.reindex_graph(x, neighbors, count, value_buffer, index_buffer)\n        return (reindex_src, reindex_dst, out_nodes)\n    check_variable_and_dtype(x, 'X', ('int32', 'int64'), 'graph_reindex')\n    check_variable_and_dtype(neighbors, 'Neighbors', ('int32', 'int64'), 'graph_reindex')\n    check_variable_and_dtype(count, 'Count', 'int32', 'graph_reindex')\n    if flag_buffer_hashtable:\n        check_variable_and_dtype(value_buffer, 'HashTable_Value', 'int32', 'graph_reindex')\n        check_variable_and_dtype(index_buffer, 'HashTable_Index', 'int32', 'graph_reindex')\n    helper = LayerHelper('graph_reindex', **locals())\n    reindex_src = helper.create_variable_for_type_inference(dtype=x.dtype)\n    reindex_dst = helper.create_variable_for_type_inference(dtype=x.dtype)\n    out_nodes = helper.create_variable_for_type_inference(dtype=x.dtype)\n    helper.append_op(type='graph_reindex', inputs={'X': x, 'Neighbors': neighbors, 'Count': count, 'HashTable_Value': value_buffer if flag_buffer_hashtable else None, 'HashTable_Index': index_buffer if flag_buffer_hashtable else None}, outputs={'Reindex_Src': reindex_src, 'Reindex_Dst': reindex_dst, 'Out_Nodes': out_nodes})\n    return (reindex_src, reindex_dst, out_nodes)",
            "@deprecated(since='2.4.0', update_to='paddle.geometric.reindex_graph', level=1, reason='paddle.incubate.graph_reindex will be removed in future')\ndef graph_reindex(x, neighbors, count, value_buffer=None, index_buffer=None, flag_buffer_hashtable=False, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n\\n    Graph Reindex API.\\n\\n    This API is mainly used in Graph Learning domain, which should be used\\n    in conjunction with `graph_sample_neighbors` API. And the main purpose\\n    is to reindex the ids information of the input nodes, and return the\\n    corresponding graph edges after reindex.\\n\\n    Notes:\\n        The number in x should be unique, otherwise it would cause potential errors.\\n        Besides, we also support multi-edge-types neighbors reindexing. If we have different\\n        edge_type neighbors for x, we should concatenate all the neighbors and count of x.\\n        We will reindex all the nodes from 0.\\n\\n    Take input nodes x = [0, 1, 2] as an example.\\n    If we have neighbors = [8, 9, 0, 4, 7, 6, 7], and count = [2, 3, 2],\\n    then we know that the neighbors of 0 is [8, 9], the neighbors of 1\\n    is [0, 4, 7], and the neighbors of 2 is [6, 7].\\n\\n    Args:\\n        x (Tensor): The input nodes which we sample neighbors for. The available\\n                    data type is int32, int64.\\n        neighbors (Tensor): The neighbors of the input nodes `x`. The data type\\n                            should be the same with `x`.\\n        count (Tensor): The neighbor count of the input nodes `x`. And the\\n                        data type should be int32.\\n        value_buffer (Tensor, optional): Value buffer for hashtable. The data type should\\n                                    be int32, and should be filled with -1. Default is None.\\n        index_buffer (Tensor, optional): Index buffer for hashtable. The data type should\\n                                    be int32, and should be filled with -1. Default is None.\\n        flag_buffer_hashtable (bool, optional): Whether to use buffer for hashtable to speed up.\\n                                      Default is False. Only useful for gpu version currently.\\n        name (str, optional): Name for the operation (optional, default is None).\\n                              For more information, please refer to :ref:`api_guide_Name`.\\n\\n    Returns:\\n        - reindex_src (Tensor), The source node index of graph edges after reindex.\\n        - reindex_dst (Tensor), The destination node index of graph edges after reindex.\\n        - out_nodes (Tensor), The index of unique input nodes and neighbors before reindex,\\n          where we put the input nodes `x` in the front, and put neighbor\\n          nodes in the back.\\n\\n    Examples:\\n        .. code-block:: python\\n\\n            >>> import paddle\\n\\n            >>> x = [0, 1, 2]\\n            >>> neighbors_e1 = [8, 9, 0, 4, 7, 6, 7]\\n            >>> count_e1 = [2, 3, 2]\\n            >>> x = paddle.to_tensor(x, dtype=\"int64\")\\n            >>> neighbors_e1 = paddle.to_tensor(neighbors_e1, dtype=\"int64\")\\n            >>> count_e1 = paddle.to_tensor(count_e1, dtype=\"int32\")\\n\\n            >>> reindex_src, reindex_dst, out_nodes = paddle.incubate.graph_reindex(\\n            ...     x,\\n            ...     neighbors_e1,\\n            ...     count_e1,\\n            ... )\\n            >>> print(reindex_src)\\n            Tensor(shape=[7], dtype=int64, place=Place(cpu), stop_gradient=True,\\n            [3, 4, 0, 5, 6, 7, 6])\\n            >>> print(reindex_dst)\\n            Tensor(shape=[7], dtype=int64, place=Place(cpu), stop_gradient=True,\\n            [0, 0, 1, 1, 1, 2, 2])\\n            >>> print(out_nodes)\\n            Tensor(shape=[8], dtype=int64, place=Place(cpu), stop_gradient=True,\\n            [0, 1, 2, 8, 9, 4, 7, 6])\\n\\n            >>> neighbors_e2 = [0, 2, 3, 5, 1]\\n            >>> count_e2 = [1, 3, 1]\\n            >>> neighbors_e2 = paddle.to_tensor(neighbors_e2, dtype=\"int64\")\\n            >>> count_e2 = paddle.to_tensor(count_e2, dtype=\"int32\")\\n\\n            >>> neighbors = paddle.concat([neighbors_e1, neighbors_e2])\\n            >>> count = paddle.concat([count_e1, count_e2])\\n            >>> reindex_src, reindex_dst, out_nodes = paddle.incubate.graph_reindex(x, neighbors, count)\\n            >>> print(reindex_src)\\n            Tensor(shape=[12], dtype=int64, place=Place(cpu), stop_gradient=True,\\n            [3, 4, 0, 5, 6, 7, 6, 0, 2, 8, 9, 1])\\n            >>> print(reindex_dst)\\n            Tensor(shape=[12], dtype=int64, place=Place(cpu), stop_gradient=True,\\n            [0, 0, 1, 1, 1, 2, 2, 0, 1, 1, 1, 2])\\n            >>> print(out_nodes)\\n            Tensor(shape=[10], dtype=int64, place=Place(cpu), stop_gradient=True,\\n            [0, 1, 2, 8, 9, 4, 7, 6, 3, 5])\\n\\n    '\n    if flag_buffer_hashtable:\n        if value_buffer is None or index_buffer is None:\n            raise ValueError('`value_buffer` and `index_buffer` should notbe None if `flag_buffer_hashtable` is True.')\n    if in_dynamic_mode():\n        (reindex_src, reindex_dst, out_nodes) = _C_ops.reindex_graph(x, neighbors, count, value_buffer, index_buffer)\n        return (reindex_src, reindex_dst, out_nodes)\n    check_variable_and_dtype(x, 'X', ('int32', 'int64'), 'graph_reindex')\n    check_variable_and_dtype(neighbors, 'Neighbors', ('int32', 'int64'), 'graph_reindex')\n    check_variable_and_dtype(count, 'Count', 'int32', 'graph_reindex')\n    if flag_buffer_hashtable:\n        check_variable_and_dtype(value_buffer, 'HashTable_Value', 'int32', 'graph_reindex')\n        check_variable_and_dtype(index_buffer, 'HashTable_Index', 'int32', 'graph_reindex')\n    helper = LayerHelper('graph_reindex', **locals())\n    reindex_src = helper.create_variable_for_type_inference(dtype=x.dtype)\n    reindex_dst = helper.create_variable_for_type_inference(dtype=x.dtype)\n    out_nodes = helper.create_variable_for_type_inference(dtype=x.dtype)\n    helper.append_op(type='graph_reindex', inputs={'X': x, 'Neighbors': neighbors, 'Count': count, 'HashTable_Value': value_buffer if flag_buffer_hashtable else None, 'HashTable_Index': index_buffer if flag_buffer_hashtable else None}, outputs={'Reindex_Src': reindex_src, 'Reindex_Dst': reindex_dst, 'Out_Nodes': out_nodes})\n    return (reindex_src, reindex_dst, out_nodes)",
            "@deprecated(since='2.4.0', update_to='paddle.geometric.reindex_graph', level=1, reason='paddle.incubate.graph_reindex will be removed in future')\ndef graph_reindex(x, neighbors, count, value_buffer=None, index_buffer=None, flag_buffer_hashtable=False, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n\\n    Graph Reindex API.\\n\\n    This API is mainly used in Graph Learning domain, which should be used\\n    in conjunction with `graph_sample_neighbors` API. And the main purpose\\n    is to reindex the ids information of the input nodes, and return the\\n    corresponding graph edges after reindex.\\n\\n    Notes:\\n        The number in x should be unique, otherwise it would cause potential errors.\\n        Besides, we also support multi-edge-types neighbors reindexing. If we have different\\n        edge_type neighbors for x, we should concatenate all the neighbors and count of x.\\n        We will reindex all the nodes from 0.\\n\\n    Take input nodes x = [0, 1, 2] as an example.\\n    If we have neighbors = [8, 9, 0, 4, 7, 6, 7], and count = [2, 3, 2],\\n    then we know that the neighbors of 0 is [8, 9], the neighbors of 1\\n    is [0, 4, 7], and the neighbors of 2 is [6, 7].\\n\\n    Args:\\n        x (Tensor): The input nodes which we sample neighbors for. The available\\n                    data type is int32, int64.\\n        neighbors (Tensor): The neighbors of the input nodes `x`. The data type\\n                            should be the same with `x`.\\n        count (Tensor): The neighbor count of the input nodes `x`. And the\\n                        data type should be int32.\\n        value_buffer (Tensor, optional): Value buffer for hashtable. The data type should\\n                                    be int32, and should be filled with -1. Default is None.\\n        index_buffer (Tensor, optional): Index buffer for hashtable. The data type should\\n                                    be int32, and should be filled with -1. Default is None.\\n        flag_buffer_hashtable (bool, optional): Whether to use buffer for hashtable to speed up.\\n                                      Default is False. Only useful for gpu version currently.\\n        name (str, optional): Name for the operation (optional, default is None).\\n                              For more information, please refer to :ref:`api_guide_Name`.\\n\\n    Returns:\\n        - reindex_src (Tensor), The source node index of graph edges after reindex.\\n        - reindex_dst (Tensor), The destination node index of graph edges after reindex.\\n        - out_nodes (Tensor), The index of unique input nodes and neighbors before reindex,\\n          where we put the input nodes `x` in the front, and put neighbor\\n          nodes in the back.\\n\\n    Examples:\\n        .. code-block:: python\\n\\n            >>> import paddle\\n\\n            >>> x = [0, 1, 2]\\n            >>> neighbors_e1 = [8, 9, 0, 4, 7, 6, 7]\\n            >>> count_e1 = [2, 3, 2]\\n            >>> x = paddle.to_tensor(x, dtype=\"int64\")\\n            >>> neighbors_e1 = paddle.to_tensor(neighbors_e1, dtype=\"int64\")\\n            >>> count_e1 = paddle.to_tensor(count_e1, dtype=\"int32\")\\n\\n            >>> reindex_src, reindex_dst, out_nodes = paddle.incubate.graph_reindex(\\n            ...     x,\\n            ...     neighbors_e1,\\n            ...     count_e1,\\n            ... )\\n            >>> print(reindex_src)\\n            Tensor(shape=[7], dtype=int64, place=Place(cpu), stop_gradient=True,\\n            [3, 4, 0, 5, 6, 7, 6])\\n            >>> print(reindex_dst)\\n            Tensor(shape=[7], dtype=int64, place=Place(cpu), stop_gradient=True,\\n            [0, 0, 1, 1, 1, 2, 2])\\n            >>> print(out_nodes)\\n            Tensor(shape=[8], dtype=int64, place=Place(cpu), stop_gradient=True,\\n            [0, 1, 2, 8, 9, 4, 7, 6])\\n\\n            >>> neighbors_e2 = [0, 2, 3, 5, 1]\\n            >>> count_e2 = [1, 3, 1]\\n            >>> neighbors_e2 = paddle.to_tensor(neighbors_e2, dtype=\"int64\")\\n            >>> count_e2 = paddle.to_tensor(count_e2, dtype=\"int32\")\\n\\n            >>> neighbors = paddle.concat([neighbors_e1, neighbors_e2])\\n            >>> count = paddle.concat([count_e1, count_e2])\\n            >>> reindex_src, reindex_dst, out_nodes = paddle.incubate.graph_reindex(x, neighbors, count)\\n            >>> print(reindex_src)\\n            Tensor(shape=[12], dtype=int64, place=Place(cpu), stop_gradient=True,\\n            [3, 4, 0, 5, 6, 7, 6, 0, 2, 8, 9, 1])\\n            >>> print(reindex_dst)\\n            Tensor(shape=[12], dtype=int64, place=Place(cpu), stop_gradient=True,\\n            [0, 0, 1, 1, 1, 2, 2, 0, 1, 1, 1, 2])\\n            >>> print(out_nodes)\\n            Tensor(shape=[10], dtype=int64, place=Place(cpu), stop_gradient=True,\\n            [0, 1, 2, 8, 9, 4, 7, 6, 3, 5])\\n\\n    '\n    if flag_buffer_hashtable:\n        if value_buffer is None or index_buffer is None:\n            raise ValueError('`value_buffer` and `index_buffer` should notbe None if `flag_buffer_hashtable` is True.')\n    if in_dynamic_mode():\n        (reindex_src, reindex_dst, out_nodes) = _C_ops.reindex_graph(x, neighbors, count, value_buffer, index_buffer)\n        return (reindex_src, reindex_dst, out_nodes)\n    check_variable_and_dtype(x, 'X', ('int32', 'int64'), 'graph_reindex')\n    check_variable_and_dtype(neighbors, 'Neighbors', ('int32', 'int64'), 'graph_reindex')\n    check_variable_and_dtype(count, 'Count', 'int32', 'graph_reindex')\n    if flag_buffer_hashtable:\n        check_variable_and_dtype(value_buffer, 'HashTable_Value', 'int32', 'graph_reindex')\n        check_variable_and_dtype(index_buffer, 'HashTable_Index', 'int32', 'graph_reindex')\n    helper = LayerHelper('graph_reindex', **locals())\n    reindex_src = helper.create_variable_for_type_inference(dtype=x.dtype)\n    reindex_dst = helper.create_variable_for_type_inference(dtype=x.dtype)\n    out_nodes = helper.create_variable_for_type_inference(dtype=x.dtype)\n    helper.append_op(type='graph_reindex', inputs={'X': x, 'Neighbors': neighbors, 'Count': count, 'HashTable_Value': value_buffer if flag_buffer_hashtable else None, 'HashTable_Index': index_buffer if flag_buffer_hashtable else None}, outputs={'Reindex_Src': reindex_src, 'Reindex_Dst': reindex_dst, 'Out_Nodes': out_nodes})\n    return (reindex_src, reindex_dst, out_nodes)"
        ]
    }
]