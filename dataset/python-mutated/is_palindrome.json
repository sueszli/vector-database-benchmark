[
    {
        "func_name": "is_palindrome",
        "original": "def is_palindrome(head):\n    if not head:\n        return True\n    (fast, slow) = (head.next, head)\n    while fast and fast.next:\n        fast = fast.next.next\n        slow = slow.next\n    second = slow.next\n    slow.next = None\n    node = None\n    while second:\n        nxt = second.next\n        second.next = node\n        node = second\n        second = nxt\n    while node:\n        if node.val != head.val:\n            return False\n        node = node.next\n        head = head.next\n    return True",
        "mutated": [
            "def is_palindrome(head):\n    if False:\n        i = 10\n    if not head:\n        return True\n    (fast, slow) = (head.next, head)\n    while fast and fast.next:\n        fast = fast.next.next\n        slow = slow.next\n    second = slow.next\n    slow.next = None\n    node = None\n    while second:\n        nxt = second.next\n        second.next = node\n        node = second\n        second = nxt\n    while node:\n        if node.val != head.val:\n            return False\n        node = node.next\n        head = head.next\n    return True",
            "def is_palindrome(head):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not head:\n        return True\n    (fast, slow) = (head.next, head)\n    while fast and fast.next:\n        fast = fast.next.next\n        slow = slow.next\n    second = slow.next\n    slow.next = None\n    node = None\n    while second:\n        nxt = second.next\n        second.next = node\n        node = second\n        second = nxt\n    while node:\n        if node.val != head.val:\n            return False\n        node = node.next\n        head = head.next\n    return True",
            "def is_palindrome(head):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not head:\n        return True\n    (fast, slow) = (head.next, head)\n    while fast and fast.next:\n        fast = fast.next.next\n        slow = slow.next\n    second = slow.next\n    slow.next = None\n    node = None\n    while second:\n        nxt = second.next\n        second.next = node\n        node = second\n        second = nxt\n    while node:\n        if node.val != head.val:\n            return False\n        node = node.next\n        head = head.next\n    return True",
            "def is_palindrome(head):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not head:\n        return True\n    (fast, slow) = (head.next, head)\n    while fast and fast.next:\n        fast = fast.next.next\n        slow = slow.next\n    second = slow.next\n    slow.next = None\n    node = None\n    while second:\n        nxt = second.next\n        second.next = node\n        node = second\n        second = nxt\n    while node:\n        if node.val != head.val:\n            return False\n        node = node.next\n        head = head.next\n    return True",
            "def is_palindrome(head):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not head:\n        return True\n    (fast, slow) = (head.next, head)\n    while fast and fast.next:\n        fast = fast.next.next\n        slow = slow.next\n    second = slow.next\n    slow.next = None\n    node = None\n    while second:\n        nxt = second.next\n        second.next = node\n        node = second\n        second = nxt\n    while node:\n        if node.val != head.val:\n            return False\n        node = node.next\n        head = head.next\n    return True"
        ]
    },
    {
        "func_name": "is_palindrome_stack",
        "original": "def is_palindrome_stack(head):\n    if not head or not head.next:\n        return True\n    slow = fast = cur = head\n    while fast and fast.next:\n        (fast, slow) = (fast.next.next, slow.next)\n    stack = [slow.val]\n    while slow.next:\n        slow = slow.next\n        stack.append(slow.val)\n    while stack:\n        if stack.pop() != cur.val:\n            return False\n        cur = cur.next\n    return True",
        "mutated": [
            "def is_palindrome_stack(head):\n    if False:\n        i = 10\n    if not head or not head.next:\n        return True\n    slow = fast = cur = head\n    while fast and fast.next:\n        (fast, slow) = (fast.next.next, slow.next)\n    stack = [slow.val]\n    while slow.next:\n        slow = slow.next\n        stack.append(slow.val)\n    while stack:\n        if stack.pop() != cur.val:\n            return False\n        cur = cur.next\n    return True",
            "def is_palindrome_stack(head):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not head or not head.next:\n        return True\n    slow = fast = cur = head\n    while fast and fast.next:\n        (fast, slow) = (fast.next.next, slow.next)\n    stack = [slow.val]\n    while slow.next:\n        slow = slow.next\n        stack.append(slow.val)\n    while stack:\n        if stack.pop() != cur.val:\n            return False\n        cur = cur.next\n    return True",
            "def is_palindrome_stack(head):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not head or not head.next:\n        return True\n    slow = fast = cur = head\n    while fast and fast.next:\n        (fast, slow) = (fast.next.next, slow.next)\n    stack = [slow.val]\n    while slow.next:\n        slow = slow.next\n        stack.append(slow.val)\n    while stack:\n        if stack.pop() != cur.val:\n            return False\n        cur = cur.next\n    return True",
            "def is_palindrome_stack(head):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not head or not head.next:\n        return True\n    slow = fast = cur = head\n    while fast and fast.next:\n        (fast, slow) = (fast.next.next, slow.next)\n    stack = [slow.val]\n    while slow.next:\n        slow = slow.next\n        stack.append(slow.val)\n    while stack:\n        if stack.pop() != cur.val:\n            return False\n        cur = cur.next\n    return True",
            "def is_palindrome_stack(head):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not head or not head.next:\n        return True\n    slow = fast = cur = head\n    while fast and fast.next:\n        (fast, slow) = (fast.next.next, slow.next)\n    stack = [slow.val]\n    while slow.next:\n        slow = slow.next\n        stack.append(slow.val)\n    while stack:\n        if stack.pop() != cur.val:\n            return False\n        cur = cur.next\n    return True"
        ]
    },
    {
        "func_name": "is_palindrome_dict",
        "original": "def is_palindrome_dict(head):\n    \"\"\"\n    This function builds up a dictionary where the keys are the values of the list,\n    and the values are the positions at which these values occur in the list.\n    We then iterate over the dict and if there is more than one key with an odd\n    number of occurrences, bail out and return False.\n    Otherwise, we want to ensure that the positions of occurrence sum to the\n    value of the length of the list - 1, working from the outside of the list inward.\n    For example:\n    Input: 1 -> 1 -> 2 -> 3 -> 2 -> 1 -> 1\n    d = {1: [0,1,5,6], 2: [2,4], 3: [3]}\n    '3' is the middle outlier, 2+4=6, 0+6=6 and 5+1=6 so we have a palindrome.\n    \"\"\"\n    if not head or not head.next:\n        return True\n    d = {}\n    pos = 0\n    while head:\n        if head.val in d.keys():\n            d[head.val].append(pos)\n        else:\n            d[head.val] = [pos]\n        head = head.next\n        pos += 1\n    checksum = pos - 1\n    middle = 0\n    for v in d.values():\n        if len(v) % 2 != 0:\n            middle += 1\n        else:\n            step = 0\n            for i in range(0, len(v)):\n                if v[i] + v[len(v) - 1 - step] != checksum:\n                    return False\n                step += 1\n        if middle > 1:\n            return False\n    return True",
        "mutated": [
            "def is_palindrome_dict(head):\n    if False:\n        i = 10\n    \"\\n    This function builds up a dictionary where the keys are the values of the list,\\n    and the values are the positions at which these values occur in the list.\\n    We then iterate over the dict and if there is more than one key with an odd\\n    number of occurrences, bail out and return False.\\n    Otherwise, we want to ensure that the positions of occurrence sum to the\\n    value of the length of the list - 1, working from the outside of the list inward.\\n    For example:\\n    Input: 1 -> 1 -> 2 -> 3 -> 2 -> 1 -> 1\\n    d = {1: [0,1,5,6], 2: [2,4], 3: [3]}\\n    '3' is the middle outlier, 2+4=6, 0+6=6 and 5+1=6 so we have a palindrome.\\n    \"\n    if not head or not head.next:\n        return True\n    d = {}\n    pos = 0\n    while head:\n        if head.val in d.keys():\n            d[head.val].append(pos)\n        else:\n            d[head.val] = [pos]\n        head = head.next\n        pos += 1\n    checksum = pos - 1\n    middle = 0\n    for v in d.values():\n        if len(v) % 2 != 0:\n            middle += 1\n        else:\n            step = 0\n            for i in range(0, len(v)):\n                if v[i] + v[len(v) - 1 - step] != checksum:\n                    return False\n                step += 1\n        if middle > 1:\n            return False\n    return True",
            "def is_palindrome_dict(head):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    This function builds up a dictionary where the keys are the values of the list,\\n    and the values are the positions at which these values occur in the list.\\n    We then iterate over the dict and if there is more than one key with an odd\\n    number of occurrences, bail out and return False.\\n    Otherwise, we want to ensure that the positions of occurrence sum to the\\n    value of the length of the list - 1, working from the outside of the list inward.\\n    For example:\\n    Input: 1 -> 1 -> 2 -> 3 -> 2 -> 1 -> 1\\n    d = {1: [0,1,5,6], 2: [2,4], 3: [3]}\\n    '3' is the middle outlier, 2+4=6, 0+6=6 and 5+1=6 so we have a palindrome.\\n    \"\n    if not head or not head.next:\n        return True\n    d = {}\n    pos = 0\n    while head:\n        if head.val in d.keys():\n            d[head.val].append(pos)\n        else:\n            d[head.val] = [pos]\n        head = head.next\n        pos += 1\n    checksum = pos - 1\n    middle = 0\n    for v in d.values():\n        if len(v) % 2 != 0:\n            middle += 1\n        else:\n            step = 0\n            for i in range(0, len(v)):\n                if v[i] + v[len(v) - 1 - step] != checksum:\n                    return False\n                step += 1\n        if middle > 1:\n            return False\n    return True",
            "def is_palindrome_dict(head):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    This function builds up a dictionary where the keys are the values of the list,\\n    and the values are the positions at which these values occur in the list.\\n    We then iterate over the dict and if there is more than one key with an odd\\n    number of occurrences, bail out and return False.\\n    Otherwise, we want to ensure that the positions of occurrence sum to the\\n    value of the length of the list - 1, working from the outside of the list inward.\\n    For example:\\n    Input: 1 -> 1 -> 2 -> 3 -> 2 -> 1 -> 1\\n    d = {1: [0,1,5,6], 2: [2,4], 3: [3]}\\n    '3' is the middle outlier, 2+4=6, 0+6=6 and 5+1=6 so we have a palindrome.\\n    \"\n    if not head or not head.next:\n        return True\n    d = {}\n    pos = 0\n    while head:\n        if head.val in d.keys():\n            d[head.val].append(pos)\n        else:\n            d[head.val] = [pos]\n        head = head.next\n        pos += 1\n    checksum = pos - 1\n    middle = 0\n    for v in d.values():\n        if len(v) % 2 != 0:\n            middle += 1\n        else:\n            step = 0\n            for i in range(0, len(v)):\n                if v[i] + v[len(v) - 1 - step] != checksum:\n                    return False\n                step += 1\n        if middle > 1:\n            return False\n    return True",
            "def is_palindrome_dict(head):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    This function builds up a dictionary where the keys are the values of the list,\\n    and the values are the positions at which these values occur in the list.\\n    We then iterate over the dict and if there is more than one key with an odd\\n    number of occurrences, bail out and return False.\\n    Otherwise, we want to ensure that the positions of occurrence sum to the\\n    value of the length of the list - 1, working from the outside of the list inward.\\n    For example:\\n    Input: 1 -> 1 -> 2 -> 3 -> 2 -> 1 -> 1\\n    d = {1: [0,1,5,6], 2: [2,4], 3: [3]}\\n    '3' is the middle outlier, 2+4=6, 0+6=6 and 5+1=6 so we have a palindrome.\\n    \"\n    if not head or not head.next:\n        return True\n    d = {}\n    pos = 0\n    while head:\n        if head.val in d.keys():\n            d[head.val].append(pos)\n        else:\n            d[head.val] = [pos]\n        head = head.next\n        pos += 1\n    checksum = pos - 1\n    middle = 0\n    for v in d.values():\n        if len(v) % 2 != 0:\n            middle += 1\n        else:\n            step = 0\n            for i in range(0, len(v)):\n                if v[i] + v[len(v) - 1 - step] != checksum:\n                    return False\n                step += 1\n        if middle > 1:\n            return False\n    return True",
            "def is_palindrome_dict(head):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    This function builds up a dictionary where the keys are the values of the list,\\n    and the values are the positions at which these values occur in the list.\\n    We then iterate over the dict and if there is more than one key with an odd\\n    number of occurrences, bail out and return False.\\n    Otherwise, we want to ensure that the positions of occurrence sum to the\\n    value of the length of the list - 1, working from the outside of the list inward.\\n    For example:\\n    Input: 1 -> 1 -> 2 -> 3 -> 2 -> 1 -> 1\\n    d = {1: [0,1,5,6], 2: [2,4], 3: [3]}\\n    '3' is the middle outlier, 2+4=6, 0+6=6 and 5+1=6 so we have a palindrome.\\n    \"\n    if not head or not head.next:\n        return True\n    d = {}\n    pos = 0\n    while head:\n        if head.val in d.keys():\n            d[head.val].append(pos)\n        else:\n            d[head.val] = [pos]\n        head = head.next\n        pos += 1\n    checksum = pos - 1\n    middle = 0\n    for v in d.values():\n        if len(v) % 2 != 0:\n            middle += 1\n        else:\n            step = 0\n            for i in range(0, len(v)):\n                if v[i] + v[len(v) - 1 - step] != checksum:\n                    return False\n                step += 1\n        if middle > 1:\n            return False\n    return True"
        ]
    }
]