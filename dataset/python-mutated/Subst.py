"""SCons.Subst

SCons string substitution.

"""
__revision__ = 'src/engine/SCons/Subst.py bee7caf9defd6e108fc2998a2520ddb36a967691 2019-12-17 02:07:09 bdeegan'
import collections
import re
import SCons.Errors
from SCons.Util import is_String, is_Sequence
_strconv = [SCons.Util.to_String_for_subst, SCons.Util.to_String_for_subst, SCons.Util.to_String_for_signature]
AllowableExceptions = (IndexError, NameError)

def SetAllowableExceptions(*excepts):
    if False:
        while True:
            i = 10
    global AllowableExceptions
    AllowableExceptions = [_f for _f in excepts if _f]

def raise_exception(exception, target, s):
    if False:
        return 10
    name = exception.__class__.__name__
    msg = "%s `%s' trying to evaluate `%s'" % (name, exception, s)
    if target:
        raise SCons.Errors.BuildError(target[0], msg)
    else:
        raise SCons.Errors.UserError(msg)

class Literal(object):
    """A wrapper for a string.  If you use this object wrapped
    around a string, then it will be interpreted as literal.
    When passed to the command interpreter, all special
    characters will be escaped."""

    def __init__(self, lstr):
        if False:
            return 10
        self.lstr = lstr

    def __str__(self):
        if False:
            i = 10
            return i + 15
        return self.lstr

    def escape(self, escape_func):
        if False:
            while True:
                i = 10
        return escape_func(self.lstr)

    def for_signature(self):
        if False:
            return 10
        return self.lstr

    def is_literal(self):
        if False:
            return 10
        return 1

    def __eq__(self, other):
        if False:
            i = 10
            return i + 15
        if not isinstance(other, Literal):
            return False
        return self.lstr == other.lstr

    def __neq__(self, other):
        if False:
            return 10
        return not self.__eq__(other)

    def __hash__(self):
        if False:
            return 10
        return hash(self.lstr)

class SpecialAttrWrapper(object):
    """This is a wrapper for what we call a 'Node special attribute.'
    This is any of the attributes of a Node that we can reference from
    Environment variable substitution, such as $TARGET.abspath or
    $SOURCES[1].filebase.  We implement the same methods as Literal
    so we can handle special characters, plus a for_signature method,
    such that we can return some canonical string during signature
    calculation to avoid unnecessary rebuilds."""

    def __init__(self, lstr, for_signature=None):
        if False:
            i = 10
            return i + 15
        'The for_signature parameter, if supplied, will be the\n        canonical string we return from for_signature().  Else\n        we will simply return lstr.'
        self.lstr = lstr
        if for_signature:
            self.forsig = for_signature
        else:
            self.forsig = lstr

    def __str__(self):
        if False:
            i = 10
            return i + 15
        return self.lstr

    def escape(self, escape_func):
        if False:
            return 10
        return escape_func(self.lstr)

    def for_signature(self):
        if False:
            return 10
        return self.forsig

    def is_literal(self):
        if False:
            while True:
                i = 10
        return 1

def quote_spaces(arg):
    if False:
        print('Hello World!')
    'Generic function for putting double quotes around any string that\n    has white space in it.'
    if ' ' in arg or '\t' in arg:
        return '"%s"' % arg
    else:
        return str(arg)

class CmdStringHolder(collections.UserString):
    """This is a special class used to hold strings generated by
    scons_subst() and scons_subst_list().  It defines a special method
    escape().  When passed a function with an escape algorithm for a
    particular platform, it will return the contained string with the
    proper escape sequences inserted.
    """

    def __init__(self, cmd, literal=None):
        if False:
            i = 10
            return i + 15
        collections.UserString.__init__(self, cmd)
        self.literal = literal

    def is_literal(self):
        if False:
            for i in range(10):
                print('nop')
        return self.literal

    def escape(self, escape_func, quote_func=quote_spaces):
        if False:
            i = 10
            return i + 15
        'Escape the string with the supplied function.  The\n        function is expected to take an arbitrary string, then\n        return it with all special characters escaped and ready\n        for passing to the command interpreter.\n\n        After calling this function, the next call to str() will\n        return the escaped string.\n        '
        if self.is_literal():
            return escape_func(self.data)
        elif ' ' in self.data or '\t' in self.data:
            return quote_func(self.data)
        else:
            return self.data

def escape_list(mylist, escape_func):
    if False:
        return 10
    'Escape a list of arguments by running the specified escape_func\n    on every object in the list that has an escape() method.'

    def escape(obj, escape_func=escape_func):
        if False:
            i = 10
            return i + 15
        try:
            e = obj.escape
        except AttributeError:
            return obj
        else:
            return e(escape_func)
    return list(map(escape, mylist))

class NLWrapper(object):
    """A wrapper class that delays turning a list of sources or targets
    into a NodeList until it's needed.  The specified function supplied
    when the object is initialized is responsible for turning raw nodes
    into proxies that implement the special attributes like .abspath,
    .source, etc.  This way, we avoid creating those proxies just
    "in case" someone is going to use $TARGET or the like, and only
    go through the trouble if we really have to.

    In practice, this might be a wash performance-wise, but it's a little
    cleaner conceptually...
    """

    def __init__(self, list, func):
        if False:
            for i in range(10):
                print('nop')
        self.list = list
        self.func = func

    def _return_nodelist(self):
        if False:
            print('Hello World!')
        return self.nodelist

    def _gen_nodelist(self):
        if False:
            i = 10
            return i + 15
        mylist = self.list
        if mylist is None:
            mylist = []
        elif not is_Sequence(mylist):
            mylist = [mylist]
        self.nodelist = SCons.Util.NodeList(list(map(self.func, mylist)))
        self._create_nodelist = self._return_nodelist
        return self.nodelist
    _create_nodelist = _gen_nodelist

class Targets_or_Sources(collections.UserList):
    """A class that implements $TARGETS or $SOURCES expansions by in turn
    wrapping a NLWrapper.  This class handles the different methods used
    to access the list, calling the NLWrapper to create proxies on demand.

    Note that we subclass collections.UserList purely so that the
    is_Sequence() function will identify an object of this class as
    a list during variable expansion.  We're not really using any
    collections.UserList methods in practice.
    """

    def __init__(self, nl):
        if False:
            while True:
                i = 10
        self.nl = nl

    def __getattr__(self, attr):
        if False:
            return 10
        nl = self.nl._create_nodelist()
        return getattr(nl, attr)

    def __getitem__(self, i):
        if False:
            return 10
        nl = self.nl._create_nodelist()
        return nl[i]

    def __getslice__(self, i, j):
        if False:
            while True:
                i = 10
        nl = self.nl._create_nodelist()
        i = max(i, 0)
        j = max(j, 0)
        return nl[i:j]

    def __str__(self):
        if False:
            print('Hello World!')
        nl = self.nl._create_nodelist()
        return str(nl)

    def __repr__(self):
        if False:
            i = 10
            return i + 15
        nl = self.nl._create_nodelist()
        return repr(nl)

class Target_or_Source(object):
    """A class that implements $TARGET or $SOURCE expansions by in turn
    wrapping a NLWrapper.  This class handles the different methods used
    to access an individual proxy Node, calling the NLWrapper to create
    a proxy on demand.
    """

    def __init__(self, nl):
        if False:
            print('Hello World!')
        self.nl = nl

    def __getattr__(self, attr):
        if False:
            while True:
                i = 10
        nl = self.nl._create_nodelist()
        try:
            nl0 = nl[0]
        except IndexError:
            raise AttributeError('NodeList has no attribute: %s' % attr)
        return getattr(nl0, attr)

    def __str__(self):
        if False:
            return 10
        nl = self.nl._create_nodelist()
        if nl:
            return str(nl[0])
        return ''

    def __repr__(self):
        if False:
            i = 10
            return i + 15
        nl = self.nl._create_nodelist()
        if nl:
            return repr(nl[0])
        return ''

class NullNodeList(SCons.Util.NullSeq):

    def __call__(self, *args, **kwargs):
        if False:
            while True:
                i = 10
        return ''

    def __str__(self):
        if False:
            return 10
        return ''
NullNodesList = NullNodeList()

def subst_dict(target, source):
    if False:
        while True:
            i = 10
    'Create a dictionary for substitution of special\n    construction variables.\n\n    This translates the following special arguments:\n\n    target - the target (object or array of objects),\n             used to generate the TARGET and TARGETS\n             construction variables\n\n    source - the source (object or array of objects),\n             used to generate the SOURCES and SOURCE\n             construction variables\n    '
    dict = {}
    if target:

        def get_tgt_subst_proxy(thing):
            if False:
                i = 10
                return i + 15
            try:
                subst_proxy = thing.get_subst_proxy()
            except AttributeError:
                subst_proxy = thing
            return subst_proxy
        tnl = NLWrapper(target, get_tgt_subst_proxy)
        dict['TARGETS'] = Targets_or_Sources(tnl)
        dict['TARGET'] = Target_or_Source(tnl)
        dict['CHANGED_TARGETS'] = '$TARGETS'
        dict['UNCHANGED_TARGETS'] = '$TARGETS'
    else:
        dict['TARGETS'] = NullNodesList
        dict['TARGET'] = NullNodesList
    if source:

        def get_src_subst_proxy(node):
            if False:
                for i in range(10):
                    print('nop')
            try:
                rfile = node.rfile
            except AttributeError:
                pass
            else:
                node = rfile()
            try:
                return node.get_subst_proxy()
            except AttributeError:
                return node
        snl = NLWrapper(source, get_src_subst_proxy)
        dict['SOURCES'] = Targets_or_Sources(snl)
        dict['SOURCE'] = Target_or_Source(snl)
        dict['CHANGED_SOURCES'] = '$SOURCES'
        dict['UNCHANGED_SOURCES'] = '$SOURCES'
    else:
        dict['SOURCES'] = NullNodesList
        dict['SOURCE'] = NullNodesList
    return dict
SUBST_CMD = 0
SUBST_RAW = 1
SUBST_SIG = 2
_rm = re.compile('\\$[()]')
_rm_split = re.compile('(?<!\\$)(\\$[()])')
_regex_remove = [_rm, None, _rm_split]

def _rm_list(list):
    if False:
        i = 10
        return i + 15
    return [l for l in list if l not in ('$(', '$)')]

def _remove_list(list):
    if False:
        print('Hello World!')
    result = []
    depth = 0
    for l in list:
        if l == '$(':
            depth += 1
        elif l == '$)':
            depth -= 1
            if depth < 0:
                break
        elif depth == 0:
            result.append(l)
    if depth != 0:
        return None
    return result
_list_remove = [_rm_list, None, _remove_list]
_dollar_exps_str = '\\$[\\$\\(\\)]|\\$[_a-zA-Z][\\.\\w]*|\\${[^}]*}'
_dollar_exps = re.compile('(%s)' % _dollar_exps_str)
_separate_args = re.compile('(%s|\\s+|[^\\s\\$]+|\\$)' % _dollar_exps_str)
_space_sep = re.compile('[\\t ]+(?![^{]*})')

def scons_subst(strSubst, env, mode=SUBST_RAW, target=None, source=None, gvars={}, lvars={}, conv=None):
    if False:
        return 10
    "Expand a string or list containing construction variable\n    substitutions.\n\n    This is the work-horse function for substitutions in file names\n    and the like.  The companion scons_subst_list() function (below)\n    handles separating command lines into lists of arguments, so see\n    that function if that's what you're looking for.\n    "
    if isinstance(strSubst, str) and '$' not in strSubst or isinstance(strSubst, CmdStringHolder):
        return strSubst

    class StringSubber(object):
        """A class to construct the results of a scons_subst() call.

        This binds a specific construction environment, mode, target and
        source with two methods (substitute() and expand()) that handle
        the expansion.
        """

        def __init__(self, env, mode, conv, gvars):
            if False:
                i = 10
                return i + 15
            self.env = env
            self.mode = mode
            self.conv = conv
            self.gvars = gvars

        def expand(self, s, lvars):
            if False:
                print('Hello World!')
            'Expand a single "token" as necessary, returning an\n            appropriate string containing the expansion.\n\n            This handles expanding different types of things (strings,\n            lists, callables) appropriately.  It calls the wrapper\n            substitute() method to re-expand things as necessary, so that\n            the results of expansions of side-by-side strings still get\n            re-evaluated separately, not smushed together.\n            '
            if is_String(s):
                try:
                    (s0, s1) = s[:2]
                except (IndexError, ValueError):
                    return s
                if s0 != '$':
                    return s
                if s1 == '$':
                    return '$$'
                elif s1 in '()':
                    return s
                else:
                    key = s[1:]
                    if key[0] == '{' or '.' in key:
                        if key[0] == '{':
                            key = key[1:-1]
                        try:
                            s = eval(key, self.gvars, lvars)
                        except KeyboardInterrupt:
                            raise
                        except Exception as e:
                            if e.__class__ in AllowableExceptions:
                                return ''
                            raise_exception(e, lvars['TARGETS'], s)
                    elif key in lvars:
                        s = lvars[key]
                    elif key in self.gvars:
                        s = self.gvars[key]
                    elif NameError not in AllowableExceptions:
                        raise_exception(NameError(key), lvars['TARGETS'], s)
                    else:
                        return ''
                    lv = lvars.copy()
                    var = key.split('.')[0]
                    lv[var] = ''
                    return self.substitute(s, lv)
            elif is_Sequence(s):

                def func(l, conv=self.conv, substitute=self.substitute, lvars=lvars):
                    if False:
                        i = 10
                        return i + 15
                    return conv(substitute(l, lvars))
                return list(map(func, s))
            elif callable(s):
                try:
                    s = s(target=lvars['TARGETS'], source=lvars['SOURCES'], env=self.env, for_signature=self.mode != SUBST_CMD)
                except TypeError:
                    if self.mode == SUBST_RAW:
                        return s
                    s = self.conv(s)
                return self.substitute(s, lvars)
            elif s is None:
                return ''
            else:
                return s

        def substitute(self, args, lvars):
            if False:
                i = 10
                return i + 15
            'Substitute expansions in an argument or list of arguments.\n\n            This serves as a wrapper for splitting up a string into\n            separate tokens.\n            '
            if is_String(args) and (not isinstance(args, CmdStringHolder)):
                args = str(args)
                try:

                    def sub_match(match):
                        if False:
                            i = 10
                            return i + 15
                        return self.conv(self.expand(match.group(1), lvars))
                    result = _dollar_exps.sub(sub_match, args)
                except TypeError:
                    args = _separate_args.findall(args)
                    result = []
                    for a in args:
                        result.append(self.conv(self.expand(a, lvars)))
                    if len(result) == 1:
                        result = result[0]
                    else:
                        result = ''.join(map(str, result))
                return result
            else:
                return self.expand(args, lvars)
    if conv is None:
        conv = _strconv[mode]
    if 'TARGET' not in lvars:
        d = subst_dict(target, source)
        if d:
            lvars = lvars.copy()
            lvars.update(d)
    gvars['__builtins__'] = __builtins__
    ss = StringSubber(env, mode, conv, gvars)
    result = ss.substitute(strSubst, lvars)
    try:
        del gvars['__builtins__']
    except KeyError:
        pass
    res = result
    if is_String(result):
        remove = _regex_remove[mode]
        if remove:
            if mode == SUBST_SIG:
                result = _list_remove[mode](remove.split(result))
                if result is None:
                    raise SCons.Errors.UserError('Unbalanced $(/$) in: ' + res)
                result = ' '.join(result)
            else:
                result = remove.sub('', result)
        if mode != SUBST_RAW:
            result = _space_sep.sub(' ', result).strip()
        result = result.replace('$$', '$')
    elif is_Sequence(result):
        remove = _list_remove[mode]
        if remove:
            result = remove(result)
            if result is None:
                raise SCons.Errors.UserError('Unbalanced $(/$) in: ' + str(res))
    return result

def scons_subst_list(strSubst, env, mode=SUBST_RAW, target=None, source=None, gvars={}, lvars={}, conv=None):
    if False:
        while True:
            i = 10
    "Substitute construction variables in a string (or list or other\n    object) and separate the arguments into a command list.\n\n    The companion scons_subst() function (above) handles basic\n    substitutions within strings, so see that function instead\n    if that's what you're looking for.\n    "

    class ListSubber(collections.UserList):
        """A class to construct the results of a scons_subst_list() call.

        Like StringSubber, this class binds a specific construction
        environment, mode, target and source with two methods
        (substitute() and expand()) that handle the expansion.

        In addition, however, this class is used to track the state of
        the result(s) we're gathering so we can do the appropriate thing
        whenever we have to append another word to the result--start a new
        line, start a new word, append to the current word, etc.  We do
        this by setting the "append" attribute to the right method so
        that our wrapper methods only need ever call ListSubber.append(),
        and the rest of the object takes care of doing the right thing
        internally.
        """

        def __init__(self, env, mode, conv, gvars):
            if False:
                for i in range(10):
                    print('nop')
            collections.UserList.__init__(self, [])
            self.env = env
            self.mode = mode
            self.conv = conv
            self.gvars = gvars
            if self.mode == SUBST_RAW:
                self.add_strip = lambda x: self.append(x)
            else:
                self.add_strip = lambda x: None
            self.in_strip = None
            self.next_line()

        def expand(self, s, lvars, within_list):
            if False:
                for i in range(10):
                    print('nop')
            'Expand a single "token" as necessary, appending the\n            expansion to the current result.\n\n            This handles expanding different types of things (strings,\n            lists, callables) appropriately.  It calls the wrapper\n            substitute() method to re-expand things as necessary, so that\n            the results of expansions of side-by-side strings still get\n            re-evaluated separately, not smushed together.\n            '
            if is_String(s):
                try:
                    (s0, s1) = s[:2]
                except (IndexError, ValueError):
                    self.append(s)
                    return
                if s0 != '$':
                    self.append(s)
                    return
                if s1 == '$':
                    self.append('$')
                elif s1 == '(':
                    self.open_strip('$(')
                elif s1 == ')':
                    self.close_strip('$)')
                else:
                    key = s[1:]
                    if key[0] == '{' or key.find('.') >= 0:
                        if key[0] == '{':
                            key = key[1:-1]
                        try:
                            s = eval(key, self.gvars, lvars)
                        except KeyboardInterrupt:
                            raise
                        except Exception as e:
                            if e.__class__ in AllowableExceptions:
                                return
                            raise_exception(e, lvars['TARGETS'], s)
                    elif key in lvars:
                        s = lvars[key]
                    elif key in self.gvars:
                        s = self.gvars[key]
                    elif NameError not in AllowableExceptions:
                        raise_exception(NameError(), lvars['TARGETS'], s)
                    else:
                        return
                    lv = lvars.copy()
                    var = key.split('.')[0]
                    lv[var] = ''
                    self.substitute(s, lv, 0)
                    self.this_word()
            elif is_Sequence(s):
                for a in s:
                    self.substitute(a, lvars, 1)
                    self.next_word()
            elif callable(s):
                try:
                    s = s(target=lvars['TARGETS'], source=lvars['SOURCES'], env=self.env, for_signature=self.mode != SUBST_CMD)
                except TypeError:
                    if self.mode == SUBST_RAW:
                        self.append(s)
                        return
                    s = self.conv(s)
                self.substitute(s, lvars, within_list)
            elif s is None:
                self.this_word()
            else:
                self.append(s)

        def substitute(self, args, lvars, within_list):
            if False:
                for i in range(10):
                    print('nop')
            'Substitute expansions in an argument or list of arguments.\n\n            This serves as a wrapper for splitting up a string into\n            separate tokens.\n            '
            if is_String(args) and (not isinstance(args, CmdStringHolder)):
                args = str(args)
                args = _separate_args.findall(args)
                for a in args:
                    if a[0] in ' \t\n\r\x0c\x0b':
                        if '\n' in a:
                            self.next_line()
                        elif within_list:
                            self.append(a)
                        else:
                            self.next_word()
                    else:
                        self.expand(a, lvars, within_list)
            else:
                self.expand(args, lvars, within_list)

        def next_line(self):
            if False:
                i = 10
                return i + 15
            'Arrange for the next word to start a new line.  This\n            is like starting a new word, except that we have to append\n            another line to the result.'
            collections.UserList.append(self, [])
            self.next_word()

        def this_word(self):
            if False:
                print('Hello World!')
            'Arrange for the next word to append to the end of the\n            current last word in the result.'
            self.append = self.add_to_current_word

        def next_word(self):
            if False:
                i = 10
                return i + 15
            'Arrange for the next word to start a new word.'
            self.append = self.add_new_word

        def add_to_current_word(self, x):
            if False:
                for i in range(10):
                    print('nop')
            'Append the string x to the end of the current last word\n            in the result.  If that is not possible, then just add\n            it as a new word.  Make sure the entire concatenated string\n            inherits the object attributes of x (in particular, the\n            escape function) by wrapping it as CmdStringHolder.'
            if not self.in_strip or self.mode != SUBST_SIG:
                try:
                    current_word = self[-1][-1]
                except IndexError:
                    self.add_new_word(x)
                else:
                    try:
                        last_char = str(current_word)[-1]
                    except IndexError:
                        last_char = '\x00'
                    if last_char in '<>|':
                        self.add_new_word(x)
                    else:
                        y = current_word + x
                        y = self.conv(y)
                        if is_String(y):
                            y = CmdStringHolder(y, None)
                        self[-1][-1] = y

        def add_new_word(self, x):
            if False:
                i = 10
                return i + 15
            if not self.in_strip or self.mode != SUBST_SIG:
                literal = self.literal(x)
                x = self.conv(x)
                if is_String(x):
                    x = CmdStringHolder(x, literal)
                self[-1].append(x)
            self.append = self.add_to_current_word

        def literal(self, x):
            if False:
                print('Hello World!')
            try:
                l = x.is_literal
            except AttributeError:
                return None
            else:
                return l()

        def open_strip(self, x):
            if False:
                while True:
                    i = 10
            'Handle the "open strip" $( token.'
            self.add_strip(x)
            self.in_strip = 1

        def close_strip(self, x):
            if False:
                while True:
                    i = 10
            'Handle the "close strip" $) token.'
            self.add_strip(x)
            self.in_strip = None
    if conv is None:
        conv = _strconv[mode]
    if 'TARGET' not in lvars:
        d = subst_dict(target, source)
        if d:
            lvars = lvars.copy()
            lvars.update(d)
    gvars['__builtins__'] = __builtins__
    ls = ListSubber(env, mode, conv, gvars)
    ls.substitute(strSubst, lvars, 0)
    try:
        del gvars['__builtins__']
    except KeyError:
        pass
    return ls.data

def scons_subst_once(strSubst, env, key):
    if False:
        for i in range(10):
            print('nop')
    "Perform single (non-recursive) substitution of a single\n    construction variable keyword.\n\n    This is used when setting a variable when copying or overriding values\n    in an Environment.  We want to capture (expand) the old value before\n    we override it, so people can do things like:\n\n        env2 = env.Clone(CCFLAGS = '$CCFLAGS -g')\n\n    We do this with some straightforward, brute-force code here...\n    "
    if isinstance(strSubst, str) and strSubst.find('$') < 0:
        return strSubst
    matchlist = ['$' + key, '${' + key + '}']
    val = env.get(key, '')

    def sub_match(match, val=val, matchlist=matchlist):
        if False:
            while True:
                i = 10
        a = match.group(1)
        if a in matchlist:
            a = val
        if is_Sequence(a):
            return ' '.join(map(str, a))
        else:
            return str(a)
    if is_Sequence(strSubst):
        result = []
        for arg in strSubst:
            if is_String(arg):
                if arg in matchlist:
                    arg = val
                    if is_Sequence(arg):
                        result.extend(arg)
                    else:
                        result.append(arg)
                else:
                    result.append(_dollar_exps.sub(sub_match, arg))
            else:
                result.append(arg)
        return result
    elif is_String(strSubst):
        return _dollar_exps.sub(sub_match, strSubst)
    else:
        return strSubst