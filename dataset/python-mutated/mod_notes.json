[
    {
        "func_name": "__init__",
        "original": "def __init__(self, reddit: 'praw.Reddit'):\n    \"\"\"Initialize a :class:`.BaseModNotes` instance.\n\n        :param reddit: An instance of :class:`.Reddit`.\n\n        \"\"\"\n    self._reddit = reddit",
        "mutated": [
            "def __init__(self, reddit: 'praw.Reddit'):\n    if False:\n        i = 10\n    'Initialize a :class:`.BaseModNotes` instance.\\n\\n        :param reddit: An instance of :class:`.Reddit`.\\n\\n        '\n    self._reddit = reddit",
            "def __init__(self, reddit: 'praw.Reddit'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Initialize a :class:`.BaseModNotes` instance.\\n\\n        :param reddit: An instance of :class:`.Reddit`.\\n\\n        '\n    self._reddit = reddit",
            "def __init__(self, reddit: 'praw.Reddit'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Initialize a :class:`.BaseModNotes` instance.\\n\\n        :param reddit: An instance of :class:`.Reddit`.\\n\\n        '\n    self._reddit = reddit",
            "def __init__(self, reddit: 'praw.Reddit'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Initialize a :class:`.BaseModNotes` instance.\\n\\n        :param reddit: An instance of :class:`.Reddit`.\\n\\n        '\n    self._reddit = reddit",
            "def __init__(self, reddit: 'praw.Reddit'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Initialize a :class:`.BaseModNotes` instance.\\n\\n        :param reddit: An instance of :class:`.Reddit`.\\n\\n        '\n    self._reddit = reddit"
        ]
    },
    {
        "func_name": "_all_generator",
        "original": "def _all_generator(self, redditor: RedditorType, subreddit: SubredditType, **generator_kwargs: Any):\n    PRAWBase._safely_add_arguments(arguments=generator_kwargs, key='params', subreddit=subreddit, user=redditor)\n    return ListingGenerator(self._reddit, API_PATH['mod_notes'], **generator_kwargs)",
        "mutated": [
            "def _all_generator(self, redditor: RedditorType, subreddit: SubredditType, **generator_kwargs: Any):\n    if False:\n        i = 10\n    PRAWBase._safely_add_arguments(arguments=generator_kwargs, key='params', subreddit=subreddit, user=redditor)\n    return ListingGenerator(self._reddit, API_PATH['mod_notes'], **generator_kwargs)",
            "def _all_generator(self, redditor: RedditorType, subreddit: SubredditType, **generator_kwargs: Any):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    PRAWBase._safely_add_arguments(arguments=generator_kwargs, key='params', subreddit=subreddit, user=redditor)\n    return ListingGenerator(self._reddit, API_PATH['mod_notes'], **generator_kwargs)",
            "def _all_generator(self, redditor: RedditorType, subreddit: SubredditType, **generator_kwargs: Any):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    PRAWBase._safely_add_arguments(arguments=generator_kwargs, key='params', subreddit=subreddit, user=redditor)\n    return ListingGenerator(self._reddit, API_PATH['mod_notes'], **generator_kwargs)",
            "def _all_generator(self, redditor: RedditorType, subreddit: SubredditType, **generator_kwargs: Any):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    PRAWBase._safely_add_arguments(arguments=generator_kwargs, key='params', subreddit=subreddit, user=redditor)\n    return ListingGenerator(self._reddit, API_PATH['mod_notes'], **generator_kwargs)",
            "def _all_generator(self, redditor: RedditorType, subreddit: SubredditType, **generator_kwargs: Any):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    PRAWBase._safely_add_arguments(arguments=generator_kwargs, key='params', subreddit=subreddit, user=redditor)\n    return ListingGenerator(self._reddit, API_PATH['mod_notes'], **generator_kwargs)"
        ]
    },
    {
        "func_name": "_bulk_generator",
        "original": "def _bulk_generator(self, redditors: List[RedditorType], subreddits: List[SubredditType]) -> Generator['praw.models.ModNote', None, None]:\n    subreddits_iter = iter(subreddits)\n    redditors_iter = iter(redditors)\n    while True:\n        subreddits_chunk = list(islice(subreddits_iter, 500))\n        users_chunk = list(islice(redditors_iter, 500))\n        if not any([subreddits_chunk, users_chunk]):\n            break\n        params = {'subreddits': ','.join(map(str, subreddits_chunk)), 'users': ','.join(map(str, users_chunk))}\n        response = self._reddit.get(API_PATH['mod_notes_bulk'], params=params)\n        for note_dict in response['mod_notes']:\n            yield self._reddit._objector.objectify(note_dict)",
        "mutated": [
            "def _bulk_generator(self, redditors: List[RedditorType], subreddits: List[SubredditType]) -> Generator['praw.models.ModNote', None, None]:\n    if False:\n        i = 10\n    subreddits_iter = iter(subreddits)\n    redditors_iter = iter(redditors)\n    while True:\n        subreddits_chunk = list(islice(subreddits_iter, 500))\n        users_chunk = list(islice(redditors_iter, 500))\n        if not any([subreddits_chunk, users_chunk]):\n            break\n        params = {'subreddits': ','.join(map(str, subreddits_chunk)), 'users': ','.join(map(str, users_chunk))}\n        response = self._reddit.get(API_PATH['mod_notes_bulk'], params=params)\n        for note_dict in response['mod_notes']:\n            yield self._reddit._objector.objectify(note_dict)",
            "def _bulk_generator(self, redditors: List[RedditorType], subreddits: List[SubredditType]) -> Generator['praw.models.ModNote', None, None]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    subreddits_iter = iter(subreddits)\n    redditors_iter = iter(redditors)\n    while True:\n        subreddits_chunk = list(islice(subreddits_iter, 500))\n        users_chunk = list(islice(redditors_iter, 500))\n        if not any([subreddits_chunk, users_chunk]):\n            break\n        params = {'subreddits': ','.join(map(str, subreddits_chunk)), 'users': ','.join(map(str, users_chunk))}\n        response = self._reddit.get(API_PATH['mod_notes_bulk'], params=params)\n        for note_dict in response['mod_notes']:\n            yield self._reddit._objector.objectify(note_dict)",
            "def _bulk_generator(self, redditors: List[RedditorType], subreddits: List[SubredditType]) -> Generator['praw.models.ModNote', None, None]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    subreddits_iter = iter(subreddits)\n    redditors_iter = iter(redditors)\n    while True:\n        subreddits_chunk = list(islice(subreddits_iter, 500))\n        users_chunk = list(islice(redditors_iter, 500))\n        if not any([subreddits_chunk, users_chunk]):\n            break\n        params = {'subreddits': ','.join(map(str, subreddits_chunk)), 'users': ','.join(map(str, users_chunk))}\n        response = self._reddit.get(API_PATH['mod_notes_bulk'], params=params)\n        for note_dict in response['mod_notes']:\n            yield self._reddit._objector.objectify(note_dict)",
            "def _bulk_generator(self, redditors: List[RedditorType], subreddits: List[SubredditType]) -> Generator['praw.models.ModNote', None, None]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    subreddits_iter = iter(subreddits)\n    redditors_iter = iter(redditors)\n    while True:\n        subreddits_chunk = list(islice(subreddits_iter, 500))\n        users_chunk = list(islice(redditors_iter, 500))\n        if not any([subreddits_chunk, users_chunk]):\n            break\n        params = {'subreddits': ','.join(map(str, subreddits_chunk)), 'users': ','.join(map(str, users_chunk))}\n        response = self._reddit.get(API_PATH['mod_notes_bulk'], params=params)\n        for note_dict in response['mod_notes']:\n            yield self._reddit._objector.objectify(note_dict)",
            "def _bulk_generator(self, redditors: List[RedditorType], subreddits: List[SubredditType]) -> Generator['praw.models.ModNote', None, None]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    subreddits_iter = iter(subreddits)\n    redditors_iter = iter(redditors)\n    while True:\n        subreddits_chunk = list(islice(subreddits_iter, 500))\n        users_chunk = list(islice(redditors_iter, 500))\n        if not any([subreddits_chunk, users_chunk]):\n            break\n        params = {'subreddits': ','.join(map(str, subreddits_chunk)), 'users': ','.join(map(str, users_chunk))}\n        response = self._reddit.get(API_PATH['mod_notes_bulk'], params=params)\n        for note_dict in response['mod_notes']:\n            yield self._reddit._objector.objectify(note_dict)"
        ]
    },
    {
        "func_name": "_ensure_attribute",
        "original": "def _ensure_attribute(self, error_message: str, **attributes: Any) -> Any:\n    (attribute, _value) = attributes.popitem()\n    value = _value or getattr(self, attribute, None)\n    if value is None:\n        raise TypeError(error_message)\n    return value",
        "mutated": [
            "def _ensure_attribute(self, error_message: str, **attributes: Any) -> Any:\n    if False:\n        i = 10\n    (attribute, _value) = attributes.popitem()\n    value = _value or getattr(self, attribute, None)\n    if value is None:\n        raise TypeError(error_message)\n    return value",
            "def _ensure_attribute(self, error_message: str, **attributes: Any) -> Any:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (attribute, _value) = attributes.popitem()\n    value = _value or getattr(self, attribute, None)\n    if value is None:\n        raise TypeError(error_message)\n    return value",
            "def _ensure_attribute(self, error_message: str, **attributes: Any) -> Any:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (attribute, _value) = attributes.popitem()\n    value = _value or getattr(self, attribute, None)\n    if value is None:\n        raise TypeError(error_message)\n    return value",
            "def _ensure_attribute(self, error_message: str, **attributes: Any) -> Any:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (attribute, _value) = attributes.popitem()\n    value = _value or getattr(self, attribute, None)\n    if value is None:\n        raise TypeError(error_message)\n    return value",
            "def _ensure_attribute(self, error_message: str, **attributes: Any) -> Any:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (attribute, _value) = attributes.popitem()\n    value = _value or getattr(self, attribute, None)\n    if value is None:\n        raise TypeError(error_message)\n    return value"
        ]
    },
    {
        "func_name": "_notes",
        "original": "def _notes(self, all_notes: bool, redditors: List[RedditorType], subreddits: List[SubredditType], **generator_kwargs: Any) -> Generator['praw.models.ModNote', None, None]:\n    if all_notes:\n        for subreddit in subreddits:\n            for redditor in redditors:\n                yield from self._all_generator(redditor, subreddit, **generator_kwargs)\n    else:\n        yield from self._bulk_generator(redditors, subreddits)",
        "mutated": [
            "def _notes(self, all_notes: bool, redditors: List[RedditorType], subreddits: List[SubredditType], **generator_kwargs: Any) -> Generator['praw.models.ModNote', None, None]:\n    if False:\n        i = 10\n    if all_notes:\n        for subreddit in subreddits:\n            for redditor in redditors:\n                yield from self._all_generator(redditor, subreddit, **generator_kwargs)\n    else:\n        yield from self._bulk_generator(redditors, subreddits)",
            "def _notes(self, all_notes: bool, redditors: List[RedditorType], subreddits: List[SubredditType], **generator_kwargs: Any) -> Generator['praw.models.ModNote', None, None]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if all_notes:\n        for subreddit in subreddits:\n            for redditor in redditors:\n                yield from self._all_generator(redditor, subreddit, **generator_kwargs)\n    else:\n        yield from self._bulk_generator(redditors, subreddits)",
            "def _notes(self, all_notes: bool, redditors: List[RedditorType], subreddits: List[SubredditType], **generator_kwargs: Any) -> Generator['praw.models.ModNote', None, None]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if all_notes:\n        for subreddit in subreddits:\n            for redditor in redditors:\n                yield from self._all_generator(redditor, subreddit, **generator_kwargs)\n    else:\n        yield from self._bulk_generator(redditors, subreddits)",
            "def _notes(self, all_notes: bool, redditors: List[RedditorType], subreddits: List[SubredditType], **generator_kwargs: Any) -> Generator['praw.models.ModNote', None, None]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if all_notes:\n        for subreddit in subreddits:\n            for redditor in redditors:\n                yield from self._all_generator(redditor, subreddit, **generator_kwargs)\n    else:\n        yield from self._bulk_generator(redditors, subreddits)",
            "def _notes(self, all_notes: bool, redditors: List[RedditorType], subreddits: List[SubredditType], **generator_kwargs: Any) -> Generator['praw.models.ModNote', None, None]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if all_notes:\n        for subreddit in subreddits:\n            for redditor in redditors:\n                yield from self._all_generator(redditor, subreddit, **generator_kwargs)\n    else:\n        yield from self._bulk_generator(redditors, subreddits)"
        ]
    },
    {
        "func_name": "create",
        "original": "def create(self, *, label: Optional[str]=None, note: str, redditor: Optional[RedditorType]=None, subreddit: Optional[SubredditType]=None, thing: Optional[Union[Comment, Submission, str]]=None, **other_settings: Any) -> 'praw.models.ModNote':\n    \"\"\"Create a :class:`.ModNote` for a redditor in the specified subreddit.\n\n        :param label: The label for the note. As of this writing, this can be one of the\n            following: ``\"ABUSE_WARNING\"``, ``\"BAN\"``, ``\"BOT_BAN\"``,\n            ``\"HELPFUL_USER\"``, ``\"PERMA_BAN\"``, ``\"SOLID_CONTRIBUTOR\"``,\n            ``\"SPAM_WARNING\"``, ``\"SPAM_WATCH\"``, or ``None`` (default: ``None``).\n        :param note: The content of the note. As of this writing, this is limited to 250\n            characters.\n        :param redditor: The redditor to create the note for (default: ``None``).\n\n            .. note::\n\n                This parameter is required if ``thing`` is not provided or this is not\n                called from a :class:`.Redditor` instance (e.g.,\n                ``reddit.redditor.notes``).\n\n        :param subreddit: The subreddit associated with the note (default: ``None``).\n\n            .. note::\n\n                This parameter is required if ``thing`` is not provided or this is not\n                called from a :class:`.Subreddit` instance (e.g.,\n                ``reddit.subreddit.mod``).\n\n        :param thing: Either the fullname of a comment/submission, a :class:`.Comment`,\n            or a :class:`.Submission` to associate with the note.\n        :param other_settings: Additional keyword arguments can be provided to handle\n            new parameters as Reddit introduces them.\n\n        :returns: The new :class:`.ModNote` object.\n\n        For example, to create a note for u/spez in r/test:\n\n        .. code-block:: python\n\n            reddit.subreddit(\"test\").mod.notes.create(\n                label=\"HELPFUL_USER\", note=\"Test note\", redditor=\"spez\"\n            )\n            # or\n            reddit.redditor(\"spez\").mod.notes.create(\n                label=\"HELPFUL_USER\", note=\"Test note\", subreddit=\"test\"\n            )\n            # or\n            reddit.notes.create(\n                label=\"HELPFUL_USER\", note=\"Test note\", redditor=\"spez\", subreddit=\"test\"\n            )\n\n        \"\"\"\n    reddit_id = None\n    if thing:\n        if isinstance(thing, str):\n            reddit_id = thing\n            if not (getattr(self, 'redditor', redditor) and getattr(self, 'subreddit', subreddit)):\n                thing = next(self._reddit.info(fullnames=[thing]))\n        else:\n            reddit_id = thing.fullname\n        redditor = getattr(self, 'redditor', redditor) or thing.author\n        subreddit = getattr(self, 'subreddit', subreddit) or thing.subreddit\n    redditor = self._ensure_attribute(\"Either the 'redditor' or 'thing' parameters must be provided or this method must be called from a Redditor instance (e.g., 'redditor.notes').\", redditor=redditor)\n    subreddit = self._ensure_attribute(\"Either the 'subreddit' or 'thing' parameters must be provided or this method must be called from a Subreddit instance (e.g., 'subreddit.mod.notes').\", subreddit=subreddit)\n    data = {'user': str(redditor), 'subreddit': str(subreddit), 'note': note}\n    if label:\n        data['label'] = label\n    if reddit_id:\n        data['reddit_id'] = reddit_id\n    data.update(other_settings)\n    return self._reddit.post(API_PATH['mod_notes'], data=data)",
        "mutated": [
            "def create(self, *, label: Optional[str]=None, note: str, redditor: Optional[RedditorType]=None, subreddit: Optional[SubredditType]=None, thing: Optional[Union[Comment, Submission, str]]=None, **other_settings: Any) -> 'praw.models.ModNote':\n    if False:\n        i = 10\n    'Create a :class:`.ModNote` for a redditor in the specified subreddit.\\n\\n        :param label: The label for the note. As of this writing, this can be one of the\\n            following: ``\"ABUSE_WARNING\"``, ``\"BAN\"``, ``\"BOT_BAN\"``,\\n            ``\"HELPFUL_USER\"``, ``\"PERMA_BAN\"``, ``\"SOLID_CONTRIBUTOR\"``,\\n            ``\"SPAM_WARNING\"``, ``\"SPAM_WATCH\"``, or ``None`` (default: ``None``).\\n        :param note: The content of the note. As of this writing, this is limited to 250\\n            characters.\\n        :param redditor: The redditor to create the note for (default: ``None``).\\n\\n            .. note::\\n\\n                This parameter is required if ``thing`` is not provided or this is not\\n                called from a :class:`.Redditor` instance (e.g.,\\n                ``reddit.redditor.notes``).\\n\\n        :param subreddit: The subreddit associated with the note (default: ``None``).\\n\\n            .. note::\\n\\n                This parameter is required if ``thing`` is not provided or this is not\\n                called from a :class:`.Subreddit` instance (e.g.,\\n                ``reddit.subreddit.mod``).\\n\\n        :param thing: Either the fullname of a comment/submission, a :class:`.Comment`,\\n            or a :class:`.Submission` to associate with the note.\\n        :param other_settings: Additional keyword arguments can be provided to handle\\n            new parameters as Reddit introduces them.\\n\\n        :returns: The new :class:`.ModNote` object.\\n\\n        For example, to create a note for u/spez in r/test:\\n\\n        .. code-block:: python\\n\\n            reddit.subreddit(\"test\").mod.notes.create(\\n                label=\"HELPFUL_USER\", note=\"Test note\", redditor=\"spez\"\\n            )\\n            # or\\n            reddit.redditor(\"spez\").mod.notes.create(\\n                label=\"HELPFUL_USER\", note=\"Test note\", subreddit=\"test\"\\n            )\\n            # or\\n            reddit.notes.create(\\n                label=\"HELPFUL_USER\", note=\"Test note\", redditor=\"spez\", subreddit=\"test\"\\n            )\\n\\n        '\n    reddit_id = None\n    if thing:\n        if isinstance(thing, str):\n            reddit_id = thing\n            if not (getattr(self, 'redditor', redditor) and getattr(self, 'subreddit', subreddit)):\n                thing = next(self._reddit.info(fullnames=[thing]))\n        else:\n            reddit_id = thing.fullname\n        redditor = getattr(self, 'redditor', redditor) or thing.author\n        subreddit = getattr(self, 'subreddit', subreddit) or thing.subreddit\n    redditor = self._ensure_attribute(\"Either the 'redditor' or 'thing' parameters must be provided or this method must be called from a Redditor instance (e.g., 'redditor.notes').\", redditor=redditor)\n    subreddit = self._ensure_attribute(\"Either the 'subreddit' or 'thing' parameters must be provided or this method must be called from a Subreddit instance (e.g., 'subreddit.mod.notes').\", subreddit=subreddit)\n    data = {'user': str(redditor), 'subreddit': str(subreddit), 'note': note}\n    if label:\n        data['label'] = label\n    if reddit_id:\n        data['reddit_id'] = reddit_id\n    data.update(other_settings)\n    return self._reddit.post(API_PATH['mod_notes'], data=data)",
            "def create(self, *, label: Optional[str]=None, note: str, redditor: Optional[RedditorType]=None, subreddit: Optional[SubredditType]=None, thing: Optional[Union[Comment, Submission, str]]=None, **other_settings: Any) -> 'praw.models.ModNote':\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Create a :class:`.ModNote` for a redditor in the specified subreddit.\\n\\n        :param label: The label for the note. As of this writing, this can be one of the\\n            following: ``\"ABUSE_WARNING\"``, ``\"BAN\"``, ``\"BOT_BAN\"``,\\n            ``\"HELPFUL_USER\"``, ``\"PERMA_BAN\"``, ``\"SOLID_CONTRIBUTOR\"``,\\n            ``\"SPAM_WARNING\"``, ``\"SPAM_WATCH\"``, or ``None`` (default: ``None``).\\n        :param note: The content of the note. As of this writing, this is limited to 250\\n            characters.\\n        :param redditor: The redditor to create the note for (default: ``None``).\\n\\n            .. note::\\n\\n                This parameter is required if ``thing`` is not provided or this is not\\n                called from a :class:`.Redditor` instance (e.g.,\\n                ``reddit.redditor.notes``).\\n\\n        :param subreddit: The subreddit associated with the note (default: ``None``).\\n\\n            .. note::\\n\\n                This parameter is required if ``thing`` is not provided or this is not\\n                called from a :class:`.Subreddit` instance (e.g.,\\n                ``reddit.subreddit.mod``).\\n\\n        :param thing: Either the fullname of a comment/submission, a :class:`.Comment`,\\n            or a :class:`.Submission` to associate with the note.\\n        :param other_settings: Additional keyword arguments can be provided to handle\\n            new parameters as Reddit introduces them.\\n\\n        :returns: The new :class:`.ModNote` object.\\n\\n        For example, to create a note for u/spez in r/test:\\n\\n        .. code-block:: python\\n\\n            reddit.subreddit(\"test\").mod.notes.create(\\n                label=\"HELPFUL_USER\", note=\"Test note\", redditor=\"spez\"\\n            )\\n            # or\\n            reddit.redditor(\"spez\").mod.notes.create(\\n                label=\"HELPFUL_USER\", note=\"Test note\", subreddit=\"test\"\\n            )\\n            # or\\n            reddit.notes.create(\\n                label=\"HELPFUL_USER\", note=\"Test note\", redditor=\"spez\", subreddit=\"test\"\\n            )\\n\\n        '\n    reddit_id = None\n    if thing:\n        if isinstance(thing, str):\n            reddit_id = thing\n            if not (getattr(self, 'redditor', redditor) and getattr(self, 'subreddit', subreddit)):\n                thing = next(self._reddit.info(fullnames=[thing]))\n        else:\n            reddit_id = thing.fullname\n        redditor = getattr(self, 'redditor', redditor) or thing.author\n        subreddit = getattr(self, 'subreddit', subreddit) or thing.subreddit\n    redditor = self._ensure_attribute(\"Either the 'redditor' or 'thing' parameters must be provided or this method must be called from a Redditor instance (e.g., 'redditor.notes').\", redditor=redditor)\n    subreddit = self._ensure_attribute(\"Either the 'subreddit' or 'thing' parameters must be provided or this method must be called from a Subreddit instance (e.g., 'subreddit.mod.notes').\", subreddit=subreddit)\n    data = {'user': str(redditor), 'subreddit': str(subreddit), 'note': note}\n    if label:\n        data['label'] = label\n    if reddit_id:\n        data['reddit_id'] = reddit_id\n    data.update(other_settings)\n    return self._reddit.post(API_PATH['mod_notes'], data=data)",
            "def create(self, *, label: Optional[str]=None, note: str, redditor: Optional[RedditorType]=None, subreddit: Optional[SubredditType]=None, thing: Optional[Union[Comment, Submission, str]]=None, **other_settings: Any) -> 'praw.models.ModNote':\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Create a :class:`.ModNote` for a redditor in the specified subreddit.\\n\\n        :param label: The label for the note. As of this writing, this can be one of the\\n            following: ``\"ABUSE_WARNING\"``, ``\"BAN\"``, ``\"BOT_BAN\"``,\\n            ``\"HELPFUL_USER\"``, ``\"PERMA_BAN\"``, ``\"SOLID_CONTRIBUTOR\"``,\\n            ``\"SPAM_WARNING\"``, ``\"SPAM_WATCH\"``, or ``None`` (default: ``None``).\\n        :param note: The content of the note. As of this writing, this is limited to 250\\n            characters.\\n        :param redditor: The redditor to create the note for (default: ``None``).\\n\\n            .. note::\\n\\n                This parameter is required if ``thing`` is not provided or this is not\\n                called from a :class:`.Redditor` instance (e.g.,\\n                ``reddit.redditor.notes``).\\n\\n        :param subreddit: The subreddit associated with the note (default: ``None``).\\n\\n            .. note::\\n\\n                This parameter is required if ``thing`` is not provided or this is not\\n                called from a :class:`.Subreddit` instance (e.g.,\\n                ``reddit.subreddit.mod``).\\n\\n        :param thing: Either the fullname of a comment/submission, a :class:`.Comment`,\\n            or a :class:`.Submission` to associate with the note.\\n        :param other_settings: Additional keyword arguments can be provided to handle\\n            new parameters as Reddit introduces them.\\n\\n        :returns: The new :class:`.ModNote` object.\\n\\n        For example, to create a note for u/spez in r/test:\\n\\n        .. code-block:: python\\n\\n            reddit.subreddit(\"test\").mod.notes.create(\\n                label=\"HELPFUL_USER\", note=\"Test note\", redditor=\"spez\"\\n            )\\n            # or\\n            reddit.redditor(\"spez\").mod.notes.create(\\n                label=\"HELPFUL_USER\", note=\"Test note\", subreddit=\"test\"\\n            )\\n            # or\\n            reddit.notes.create(\\n                label=\"HELPFUL_USER\", note=\"Test note\", redditor=\"spez\", subreddit=\"test\"\\n            )\\n\\n        '\n    reddit_id = None\n    if thing:\n        if isinstance(thing, str):\n            reddit_id = thing\n            if not (getattr(self, 'redditor', redditor) and getattr(self, 'subreddit', subreddit)):\n                thing = next(self._reddit.info(fullnames=[thing]))\n        else:\n            reddit_id = thing.fullname\n        redditor = getattr(self, 'redditor', redditor) or thing.author\n        subreddit = getattr(self, 'subreddit', subreddit) or thing.subreddit\n    redditor = self._ensure_attribute(\"Either the 'redditor' or 'thing' parameters must be provided or this method must be called from a Redditor instance (e.g., 'redditor.notes').\", redditor=redditor)\n    subreddit = self._ensure_attribute(\"Either the 'subreddit' or 'thing' parameters must be provided or this method must be called from a Subreddit instance (e.g., 'subreddit.mod.notes').\", subreddit=subreddit)\n    data = {'user': str(redditor), 'subreddit': str(subreddit), 'note': note}\n    if label:\n        data['label'] = label\n    if reddit_id:\n        data['reddit_id'] = reddit_id\n    data.update(other_settings)\n    return self._reddit.post(API_PATH['mod_notes'], data=data)",
            "def create(self, *, label: Optional[str]=None, note: str, redditor: Optional[RedditorType]=None, subreddit: Optional[SubredditType]=None, thing: Optional[Union[Comment, Submission, str]]=None, **other_settings: Any) -> 'praw.models.ModNote':\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Create a :class:`.ModNote` for a redditor in the specified subreddit.\\n\\n        :param label: The label for the note. As of this writing, this can be one of the\\n            following: ``\"ABUSE_WARNING\"``, ``\"BAN\"``, ``\"BOT_BAN\"``,\\n            ``\"HELPFUL_USER\"``, ``\"PERMA_BAN\"``, ``\"SOLID_CONTRIBUTOR\"``,\\n            ``\"SPAM_WARNING\"``, ``\"SPAM_WATCH\"``, or ``None`` (default: ``None``).\\n        :param note: The content of the note. As of this writing, this is limited to 250\\n            characters.\\n        :param redditor: The redditor to create the note for (default: ``None``).\\n\\n            .. note::\\n\\n                This parameter is required if ``thing`` is not provided or this is not\\n                called from a :class:`.Redditor` instance (e.g.,\\n                ``reddit.redditor.notes``).\\n\\n        :param subreddit: The subreddit associated with the note (default: ``None``).\\n\\n            .. note::\\n\\n                This parameter is required if ``thing`` is not provided or this is not\\n                called from a :class:`.Subreddit` instance (e.g.,\\n                ``reddit.subreddit.mod``).\\n\\n        :param thing: Either the fullname of a comment/submission, a :class:`.Comment`,\\n            or a :class:`.Submission` to associate with the note.\\n        :param other_settings: Additional keyword arguments can be provided to handle\\n            new parameters as Reddit introduces them.\\n\\n        :returns: The new :class:`.ModNote` object.\\n\\n        For example, to create a note for u/spez in r/test:\\n\\n        .. code-block:: python\\n\\n            reddit.subreddit(\"test\").mod.notes.create(\\n                label=\"HELPFUL_USER\", note=\"Test note\", redditor=\"spez\"\\n            )\\n            # or\\n            reddit.redditor(\"spez\").mod.notes.create(\\n                label=\"HELPFUL_USER\", note=\"Test note\", subreddit=\"test\"\\n            )\\n            # or\\n            reddit.notes.create(\\n                label=\"HELPFUL_USER\", note=\"Test note\", redditor=\"spez\", subreddit=\"test\"\\n            )\\n\\n        '\n    reddit_id = None\n    if thing:\n        if isinstance(thing, str):\n            reddit_id = thing\n            if not (getattr(self, 'redditor', redditor) and getattr(self, 'subreddit', subreddit)):\n                thing = next(self._reddit.info(fullnames=[thing]))\n        else:\n            reddit_id = thing.fullname\n        redditor = getattr(self, 'redditor', redditor) or thing.author\n        subreddit = getattr(self, 'subreddit', subreddit) or thing.subreddit\n    redditor = self._ensure_attribute(\"Either the 'redditor' or 'thing' parameters must be provided or this method must be called from a Redditor instance (e.g., 'redditor.notes').\", redditor=redditor)\n    subreddit = self._ensure_attribute(\"Either the 'subreddit' or 'thing' parameters must be provided or this method must be called from a Subreddit instance (e.g., 'subreddit.mod.notes').\", subreddit=subreddit)\n    data = {'user': str(redditor), 'subreddit': str(subreddit), 'note': note}\n    if label:\n        data['label'] = label\n    if reddit_id:\n        data['reddit_id'] = reddit_id\n    data.update(other_settings)\n    return self._reddit.post(API_PATH['mod_notes'], data=data)",
            "def create(self, *, label: Optional[str]=None, note: str, redditor: Optional[RedditorType]=None, subreddit: Optional[SubredditType]=None, thing: Optional[Union[Comment, Submission, str]]=None, **other_settings: Any) -> 'praw.models.ModNote':\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Create a :class:`.ModNote` for a redditor in the specified subreddit.\\n\\n        :param label: The label for the note. As of this writing, this can be one of the\\n            following: ``\"ABUSE_WARNING\"``, ``\"BAN\"``, ``\"BOT_BAN\"``,\\n            ``\"HELPFUL_USER\"``, ``\"PERMA_BAN\"``, ``\"SOLID_CONTRIBUTOR\"``,\\n            ``\"SPAM_WARNING\"``, ``\"SPAM_WATCH\"``, or ``None`` (default: ``None``).\\n        :param note: The content of the note. As of this writing, this is limited to 250\\n            characters.\\n        :param redditor: The redditor to create the note for (default: ``None``).\\n\\n            .. note::\\n\\n                This parameter is required if ``thing`` is not provided or this is not\\n                called from a :class:`.Redditor` instance (e.g.,\\n                ``reddit.redditor.notes``).\\n\\n        :param subreddit: The subreddit associated with the note (default: ``None``).\\n\\n            .. note::\\n\\n                This parameter is required if ``thing`` is not provided or this is not\\n                called from a :class:`.Subreddit` instance (e.g.,\\n                ``reddit.subreddit.mod``).\\n\\n        :param thing: Either the fullname of a comment/submission, a :class:`.Comment`,\\n            or a :class:`.Submission` to associate with the note.\\n        :param other_settings: Additional keyword arguments can be provided to handle\\n            new parameters as Reddit introduces them.\\n\\n        :returns: The new :class:`.ModNote` object.\\n\\n        For example, to create a note for u/spez in r/test:\\n\\n        .. code-block:: python\\n\\n            reddit.subreddit(\"test\").mod.notes.create(\\n                label=\"HELPFUL_USER\", note=\"Test note\", redditor=\"spez\"\\n            )\\n            # or\\n            reddit.redditor(\"spez\").mod.notes.create(\\n                label=\"HELPFUL_USER\", note=\"Test note\", subreddit=\"test\"\\n            )\\n            # or\\n            reddit.notes.create(\\n                label=\"HELPFUL_USER\", note=\"Test note\", redditor=\"spez\", subreddit=\"test\"\\n            )\\n\\n        '\n    reddit_id = None\n    if thing:\n        if isinstance(thing, str):\n            reddit_id = thing\n            if not (getattr(self, 'redditor', redditor) and getattr(self, 'subreddit', subreddit)):\n                thing = next(self._reddit.info(fullnames=[thing]))\n        else:\n            reddit_id = thing.fullname\n        redditor = getattr(self, 'redditor', redditor) or thing.author\n        subreddit = getattr(self, 'subreddit', subreddit) or thing.subreddit\n    redditor = self._ensure_attribute(\"Either the 'redditor' or 'thing' parameters must be provided or this method must be called from a Redditor instance (e.g., 'redditor.notes').\", redditor=redditor)\n    subreddit = self._ensure_attribute(\"Either the 'subreddit' or 'thing' parameters must be provided or this method must be called from a Subreddit instance (e.g., 'subreddit.mod.notes').\", subreddit=subreddit)\n    data = {'user': str(redditor), 'subreddit': str(subreddit), 'note': note}\n    if label:\n        data['label'] = label\n    if reddit_id:\n        data['reddit_id'] = reddit_id\n    data.update(other_settings)\n    return self._reddit.post(API_PATH['mod_notes'], data=data)"
        ]
    },
    {
        "func_name": "delete",
        "original": "def delete(self, *, delete_all: bool=False, note_id: Optional[str]=None, redditor: Optional[RedditorType]=None, subreddit: Optional[SubredditType]=None):\n    \"\"\"Delete note(s) for a redditor.\n\n        :param delete_all: When ``True``, delete all notes for the specified redditor in\n            the specified subreddit (default: ``False``).\n\n            .. note::\n\n                This will make a request for each note.\n\n        :param note_id: The ID of the note to delete. This parameter is ignored if\n            ``delete_all`` is ``True``.\n        :param redditor: The redditor to delete the note(s) for (default: ``None``). Can\n            be a :class:`.Redditor` instance or a redditor name.\n\n            .. note::\n\n                This parameter is required if this method is **not** called from a\n                :class:`.Redditor` instance (e.g., ``redditor.notes``).\n\n        :param subreddit: The subreddit to delete the note(s) from (default: ``None``).\n            Can be a :class:`.Subreddit` instance or a subreddit name.\n\n            .. note::\n\n                This parameter is required if this method is **not** called from a\n                :class:`.Subreddit` instance (e.g., ``reddit.subreddit.mod``).\n\n\n        For example, to delete a note with the ID\n        ``\"ModNote_d324b280-5ecc-435d-8159-3e259e84e339\"``, try:\n\n        .. code-block:: python\n\n            reddit.subreddit(\"test\").mod.notes.delete(\n                note_id=\"ModNote_d324b280-5ecc-435d-8159-3e259e84e339\", redditor=\"spez\"\n            )\n            # or\n            reddit.redditor(\"spez\").notes.delete(\n                note_id=\"ModNote_d324b280-5ecc-435d-8159-3e259e84e339\", subreddit=\"test\"\n            )\n            # or\n            reddit.notes.delete(\n                note_id=\"ModNote_d324b280-5ecc-435d-8159-3e259e84e339\",\n                subreddit=\"test\",\n                redditor=\"spez\",\n            )\n\n        To delete all notes for u/spez, try:\n\n        .. code-block:: python\n\n            reddit.subreddit(\"test\").mod.notes.delete(delete_all=True, redditor=\"spez\")\n            # or\n            reddit.redditor(\"spez\").notes.delete(delete_all=True, subreddit=\"test\")\n            # or\n            reddit.notes.delete(delete_all=True, subreddit=\"test\", redditor=\"spez\")\n\n        \"\"\"\n    redditor = self._ensure_attribute(\"Either the 'redditor' parameter must be provided or this method must be called from a Redditor instance (e.g., 'redditor.notes').\", redditor=redditor)\n    subreddit = self._ensure_attribute(\"Either the 'subreddit' parameter must be provided or this method must be called from a Subreddit instance (e.g., 'subreddit.mod.notes').\", subreddit=subreddit)\n    if not delete_all and note_id is None:\n        msg = \"Either 'note_id' or 'delete_all' must be provided.\"\n        raise TypeError(msg)\n    if delete_all:\n        for note in self._notes(True, [redditor], [subreddit]):\n            note.delete()\n    else:\n        params = {'user': str(redditor), 'subreddit': str(subreddit), 'note_id': note_id}\n        self._reddit.delete(API_PATH['mod_notes'], params=params)",
        "mutated": [
            "def delete(self, *, delete_all: bool=False, note_id: Optional[str]=None, redditor: Optional[RedditorType]=None, subreddit: Optional[SubredditType]=None):\n    if False:\n        i = 10\n    'Delete note(s) for a redditor.\\n\\n        :param delete_all: When ``True``, delete all notes for the specified redditor in\\n            the specified subreddit (default: ``False``).\\n\\n            .. note::\\n\\n                This will make a request for each note.\\n\\n        :param note_id: The ID of the note to delete. This parameter is ignored if\\n            ``delete_all`` is ``True``.\\n        :param redditor: The redditor to delete the note(s) for (default: ``None``). Can\\n            be a :class:`.Redditor` instance or a redditor name.\\n\\n            .. note::\\n\\n                This parameter is required if this method is **not** called from a\\n                :class:`.Redditor` instance (e.g., ``redditor.notes``).\\n\\n        :param subreddit: The subreddit to delete the note(s) from (default: ``None``).\\n            Can be a :class:`.Subreddit` instance or a subreddit name.\\n\\n            .. note::\\n\\n                This parameter is required if this method is **not** called from a\\n                :class:`.Subreddit` instance (e.g., ``reddit.subreddit.mod``).\\n\\n\\n        For example, to delete a note with the ID\\n        ``\"ModNote_d324b280-5ecc-435d-8159-3e259e84e339\"``, try:\\n\\n        .. code-block:: python\\n\\n            reddit.subreddit(\"test\").mod.notes.delete(\\n                note_id=\"ModNote_d324b280-5ecc-435d-8159-3e259e84e339\", redditor=\"spez\"\\n            )\\n            # or\\n            reddit.redditor(\"spez\").notes.delete(\\n                note_id=\"ModNote_d324b280-5ecc-435d-8159-3e259e84e339\", subreddit=\"test\"\\n            )\\n            # or\\n            reddit.notes.delete(\\n                note_id=\"ModNote_d324b280-5ecc-435d-8159-3e259e84e339\",\\n                subreddit=\"test\",\\n                redditor=\"spez\",\\n            )\\n\\n        To delete all notes for u/spez, try:\\n\\n        .. code-block:: python\\n\\n            reddit.subreddit(\"test\").mod.notes.delete(delete_all=True, redditor=\"spez\")\\n            # or\\n            reddit.redditor(\"spez\").notes.delete(delete_all=True, subreddit=\"test\")\\n            # or\\n            reddit.notes.delete(delete_all=True, subreddit=\"test\", redditor=\"spez\")\\n\\n        '\n    redditor = self._ensure_attribute(\"Either the 'redditor' parameter must be provided or this method must be called from a Redditor instance (e.g., 'redditor.notes').\", redditor=redditor)\n    subreddit = self._ensure_attribute(\"Either the 'subreddit' parameter must be provided or this method must be called from a Subreddit instance (e.g., 'subreddit.mod.notes').\", subreddit=subreddit)\n    if not delete_all and note_id is None:\n        msg = \"Either 'note_id' or 'delete_all' must be provided.\"\n        raise TypeError(msg)\n    if delete_all:\n        for note in self._notes(True, [redditor], [subreddit]):\n            note.delete()\n    else:\n        params = {'user': str(redditor), 'subreddit': str(subreddit), 'note_id': note_id}\n        self._reddit.delete(API_PATH['mod_notes'], params=params)",
            "def delete(self, *, delete_all: bool=False, note_id: Optional[str]=None, redditor: Optional[RedditorType]=None, subreddit: Optional[SubredditType]=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Delete note(s) for a redditor.\\n\\n        :param delete_all: When ``True``, delete all notes for the specified redditor in\\n            the specified subreddit (default: ``False``).\\n\\n            .. note::\\n\\n                This will make a request for each note.\\n\\n        :param note_id: The ID of the note to delete. This parameter is ignored if\\n            ``delete_all`` is ``True``.\\n        :param redditor: The redditor to delete the note(s) for (default: ``None``). Can\\n            be a :class:`.Redditor` instance or a redditor name.\\n\\n            .. note::\\n\\n                This parameter is required if this method is **not** called from a\\n                :class:`.Redditor` instance (e.g., ``redditor.notes``).\\n\\n        :param subreddit: The subreddit to delete the note(s) from (default: ``None``).\\n            Can be a :class:`.Subreddit` instance or a subreddit name.\\n\\n            .. note::\\n\\n                This parameter is required if this method is **not** called from a\\n                :class:`.Subreddit` instance (e.g., ``reddit.subreddit.mod``).\\n\\n\\n        For example, to delete a note with the ID\\n        ``\"ModNote_d324b280-5ecc-435d-8159-3e259e84e339\"``, try:\\n\\n        .. code-block:: python\\n\\n            reddit.subreddit(\"test\").mod.notes.delete(\\n                note_id=\"ModNote_d324b280-5ecc-435d-8159-3e259e84e339\", redditor=\"spez\"\\n            )\\n            # or\\n            reddit.redditor(\"spez\").notes.delete(\\n                note_id=\"ModNote_d324b280-5ecc-435d-8159-3e259e84e339\", subreddit=\"test\"\\n            )\\n            # or\\n            reddit.notes.delete(\\n                note_id=\"ModNote_d324b280-5ecc-435d-8159-3e259e84e339\",\\n                subreddit=\"test\",\\n                redditor=\"spez\",\\n            )\\n\\n        To delete all notes for u/spez, try:\\n\\n        .. code-block:: python\\n\\n            reddit.subreddit(\"test\").mod.notes.delete(delete_all=True, redditor=\"spez\")\\n            # or\\n            reddit.redditor(\"spez\").notes.delete(delete_all=True, subreddit=\"test\")\\n            # or\\n            reddit.notes.delete(delete_all=True, subreddit=\"test\", redditor=\"spez\")\\n\\n        '\n    redditor = self._ensure_attribute(\"Either the 'redditor' parameter must be provided or this method must be called from a Redditor instance (e.g., 'redditor.notes').\", redditor=redditor)\n    subreddit = self._ensure_attribute(\"Either the 'subreddit' parameter must be provided or this method must be called from a Subreddit instance (e.g., 'subreddit.mod.notes').\", subreddit=subreddit)\n    if not delete_all and note_id is None:\n        msg = \"Either 'note_id' or 'delete_all' must be provided.\"\n        raise TypeError(msg)\n    if delete_all:\n        for note in self._notes(True, [redditor], [subreddit]):\n            note.delete()\n    else:\n        params = {'user': str(redditor), 'subreddit': str(subreddit), 'note_id': note_id}\n        self._reddit.delete(API_PATH['mod_notes'], params=params)",
            "def delete(self, *, delete_all: bool=False, note_id: Optional[str]=None, redditor: Optional[RedditorType]=None, subreddit: Optional[SubredditType]=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Delete note(s) for a redditor.\\n\\n        :param delete_all: When ``True``, delete all notes for the specified redditor in\\n            the specified subreddit (default: ``False``).\\n\\n            .. note::\\n\\n                This will make a request for each note.\\n\\n        :param note_id: The ID of the note to delete. This parameter is ignored if\\n            ``delete_all`` is ``True``.\\n        :param redditor: The redditor to delete the note(s) for (default: ``None``). Can\\n            be a :class:`.Redditor` instance or a redditor name.\\n\\n            .. note::\\n\\n                This parameter is required if this method is **not** called from a\\n                :class:`.Redditor` instance (e.g., ``redditor.notes``).\\n\\n        :param subreddit: The subreddit to delete the note(s) from (default: ``None``).\\n            Can be a :class:`.Subreddit` instance or a subreddit name.\\n\\n            .. note::\\n\\n                This parameter is required if this method is **not** called from a\\n                :class:`.Subreddit` instance (e.g., ``reddit.subreddit.mod``).\\n\\n\\n        For example, to delete a note with the ID\\n        ``\"ModNote_d324b280-5ecc-435d-8159-3e259e84e339\"``, try:\\n\\n        .. code-block:: python\\n\\n            reddit.subreddit(\"test\").mod.notes.delete(\\n                note_id=\"ModNote_d324b280-5ecc-435d-8159-3e259e84e339\", redditor=\"spez\"\\n            )\\n            # or\\n            reddit.redditor(\"spez\").notes.delete(\\n                note_id=\"ModNote_d324b280-5ecc-435d-8159-3e259e84e339\", subreddit=\"test\"\\n            )\\n            # or\\n            reddit.notes.delete(\\n                note_id=\"ModNote_d324b280-5ecc-435d-8159-3e259e84e339\",\\n                subreddit=\"test\",\\n                redditor=\"spez\",\\n            )\\n\\n        To delete all notes for u/spez, try:\\n\\n        .. code-block:: python\\n\\n            reddit.subreddit(\"test\").mod.notes.delete(delete_all=True, redditor=\"spez\")\\n            # or\\n            reddit.redditor(\"spez\").notes.delete(delete_all=True, subreddit=\"test\")\\n            # or\\n            reddit.notes.delete(delete_all=True, subreddit=\"test\", redditor=\"spez\")\\n\\n        '\n    redditor = self._ensure_attribute(\"Either the 'redditor' parameter must be provided or this method must be called from a Redditor instance (e.g., 'redditor.notes').\", redditor=redditor)\n    subreddit = self._ensure_attribute(\"Either the 'subreddit' parameter must be provided or this method must be called from a Subreddit instance (e.g., 'subreddit.mod.notes').\", subreddit=subreddit)\n    if not delete_all and note_id is None:\n        msg = \"Either 'note_id' or 'delete_all' must be provided.\"\n        raise TypeError(msg)\n    if delete_all:\n        for note in self._notes(True, [redditor], [subreddit]):\n            note.delete()\n    else:\n        params = {'user': str(redditor), 'subreddit': str(subreddit), 'note_id': note_id}\n        self._reddit.delete(API_PATH['mod_notes'], params=params)",
            "def delete(self, *, delete_all: bool=False, note_id: Optional[str]=None, redditor: Optional[RedditorType]=None, subreddit: Optional[SubredditType]=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Delete note(s) for a redditor.\\n\\n        :param delete_all: When ``True``, delete all notes for the specified redditor in\\n            the specified subreddit (default: ``False``).\\n\\n            .. note::\\n\\n                This will make a request for each note.\\n\\n        :param note_id: The ID of the note to delete. This parameter is ignored if\\n            ``delete_all`` is ``True``.\\n        :param redditor: The redditor to delete the note(s) for (default: ``None``). Can\\n            be a :class:`.Redditor` instance or a redditor name.\\n\\n            .. note::\\n\\n                This parameter is required if this method is **not** called from a\\n                :class:`.Redditor` instance (e.g., ``redditor.notes``).\\n\\n        :param subreddit: The subreddit to delete the note(s) from (default: ``None``).\\n            Can be a :class:`.Subreddit` instance or a subreddit name.\\n\\n            .. note::\\n\\n                This parameter is required if this method is **not** called from a\\n                :class:`.Subreddit` instance (e.g., ``reddit.subreddit.mod``).\\n\\n\\n        For example, to delete a note with the ID\\n        ``\"ModNote_d324b280-5ecc-435d-8159-3e259e84e339\"``, try:\\n\\n        .. code-block:: python\\n\\n            reddit.subreddit(\"test\").mod.notes.delete(\\n                note_id=\"ModNote_d324b280-5ecc-435d-8159-3e259e84e339\", redditor=\"spez\"\\n            )\\n            # or\\n            reddit.redditor(\"spez\").notes.delete(\\n                note_id=\"ModNote_d324b280-5ecc-435d-8159-3e259e84e339\", subreddit=\"test\"\\n            )\\n            # or\\n            reddit.notes.delete(\\n                note_id=\"ModNote_d324b280-5ecc-435d-8159-3e259e84e339\",\\n                subreddit=\"test\",\\n                redditor=\"spez\",\\n            )\\n\\n        To delete all notes for u/spez, try:\\n\\n        .. code-block:: python\\n\\n            reddit.subreddit(\"test\").mod.notes.delete(delete_all=True, redditor=\"spez\")\\n            # or\\n            reddit.redditor(\"spez\").notes.delete(delete_all=True, subreddit=\"test\")\\n            # or\\n            reddit.notes.delete(delete_all=True, subreddit=\"test\", redditor=\"spez\")\\n\\n        '\n    redditor = self._ensure_attribute(\"Either the 'redditor' parameter must be provided or this method must be called from a Redditor instance (e.g., 'redditor.notes').\", redditor=redditor)\n    subreddit = self._ensure_attribute(\"Either the 'subreddit' parameter must be provided or this method must be called from a Subreddit instance (e.g., 'subreddit.mod.notes').\", subreddit=subreddit)\n    if not delete_all and note_id is None:\n        msg = \"Either 'note_id' or 'delete_all' must be provided.\"\n        raise TypeError(msg)\n    if delete_all:\n        for note in self._notes(True, [redditor], [subreddit]):\n            note.delete()\n    else:\n        params = {'user': str(redditor), 'subreddit': str(subreddit), 'note_id': note_id}\n        self._reddit.delete(API_PATH['mod_notes'], params=params)",
            "def delete(self, *, delete_all: bool=False, note_id: Optional[str]=None, redditor: Optional[RedditorType]=None, subreddit: Optional[SubredditType]=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Delete note(s) for a redditor.\\n\\n        :param delete_all: When ``True``, delete all notes for the specified redditor in\\n            the specified subreddit (default: ``False``).\\n\\n            .. note::\\n\\n                This will make a request for each note.\\n\\n        :param note_id: The ID of the note to delete. This parameter is ignored if\\n            ``delete_all`` is ``True``.\\n        :param redditor: The redditor to delete the note(s) for (default: ``None``). Can\\n            be a :class:`.Redditor` instance or a redditor name.\\n\\n            .. note::\\n\\n                This parameter is required if this method is **not** called from a\\n                :class:`.Redditor` instance (e.g., ``redditor.notes``).\\n\\n        :param subreddit: The subreddit to delete the note(s) from (default: ``None``).\\n            Can be a :class:`.Subreddit` instance or a subreddit name.\\n\\n            .. note::\\n\\n                This parameter is required if this method is **not** called from a\\n                :class:`.Subreddit` instance (e.g., ``reddit.subreddit.mod``).\\n\\n\\n        For example, to delete a note with the ID\\n        ``\"ModNote_d324b280-5ecc-435d-8159-3e259e84e339\"``, try:\\n\\n        .. code-block:: python\\n\\n            reddit.subreddit(\"test\").mod.notes.delete(\\n                note_id=\"ModNote_d324b280-5ecc-435d-8159-3e259e84e339\", redditor=\"spez\"\\n            )\\n            # or\\n            reddit.redditor(\"spez\").notes.delete(\\n                note_id=\"ModNote_d324b280-5ecc-435d-8159-3e259e84e339\", subreddit=\"test\"\\n            )\\n            # or\\n            reddit.notes.delete(\\n                note_id=\"ModNote_d324b280-5ecc-435d-8159-3e259e84e339\",\\n                subreddit=\"test\",\\n                redditor=\"spez\",\\n            )\\n\\n        To delete all notes for u/spez, try:\\n\\n        .. code-block:: python\\n\\n            reddit.subreddit(\"test\").mod.notes.delete(delete_all=True, redditor=\"spez\")\\n            # or\\n            reddit.redditor(\"spez\").notes.delete(delete_all=True, subreddit=\"test\")\\n            # or\\n            reddit.notes.delete(delete_all=True, subreddit=\"test\", redditor=\"spez\")\\n\\n        '\n    redditor = self._ensure_attribute(\"Either the 'redditor' parameter must be provided or this method must be called from a Redditor instance (e.g., 'redditor.notes').\", redditor=redditor)\n    subreddit = self._ensure_attribute(\"Either the 'subreddit' parameter must be provided or this method must be called from a Subreddit instance (e.g., 'subreddit.mod.notes').\", subreddit=subreddit)\n    if not delete_all and note_id is None:\n        msg = \"Either 'note_id' or 'delete_all' must be provided.\"\n        raise TypeError(msg)\n    if delete_all:\n        for note in self._notes(True, [redditor], [subreddit]):\n            note.delete()\n    else:\n        params = {'user': str(redditor), 'subreddit': str(subreddit), 'note_id': note_id}\n        self._reddit.delete(API_PATH['mod_notes'], params=params)"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, reddit: 'praw.Reddit', redditor: RedditorType):\n    \"\"\"Initialize a :class:`.RedditorModNotes` instance.\n\n        :param reddit: An instance of :class:`.Reddit`.\n        :param redditor: An instance of :class:`.Redditor`.\n\n        \"\"\"\n    super().__init__(reddit)\n    self.redditor = redditor",
        "mutated": [
            "def __init__(self, reddit: 'praw.Reddit', redditor: RedditorType):\n    if False:\n        i = 10\n    'Initialize a :class:`.RedditorModNotes` instance.\\n\\n        :param reddit: An instance of :class:`.Reddit`.\\n        :param redditor: An instance of :class:`.Redditor`.\\n\\n        '\n    super().__init__(reddit)\n    self.redditor = redditor",
            "def __init__(self, reddit: 'praw.Reddit', redditor: RedditorType):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Initialize a :class:`.RedditorModNotes` instance.\\n\\n        :param reddit: An instance of :class:`.Reddit`.\\n        :param redditor: An instance of :class:`.Redditor`.\\n\\n        '\n    super().__init__(reddit)\n    self.redditor = redditor",
            "def __init__(self, reddit: 'praw.Reddit', redditor: RedditorType):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Initialize a :class:`.RedditorModNotes` instance.\\n\\n        :param reddit: An instance of :class:`.Reddit`.\\n        :param redditor: An instance of :class:`.Redditor`.\\n\\n        '\n    super().__init__(reddit)\n    self.redditor = redditor",
            "def __init__(self, reddit: 'praw.Reddit', redditor: RedditorType):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Initialize a :class:`.RedditorModNotes` instance.\\n\\n        :param reddit: An instance of :class:`.Reddit`.\\n        :param redditor: An instance of :class:`.Redditor`.\\n\\n        '\n    super().__init__(reddit)\n    self.redditor = redditor",
            "def __init__(self, reddit: 'praw.Reddit', redditor: RedditorType):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Initialize a :class:`.RedditorModNotes` instance.\\n\\n        :param reddit: An instance of :class:`.Reddit`.\\n        :param redditor: An instance of :class:`.Redditor`.\\n\\n        '\n    super().__init__(reddit)\n    self.redditor = redditor"
        ]
    },
    {
        "func_name": "subreddits",
        "original": "def subreddits(self, *subreddits: SubredditType, all_notes: Optional[bool]=None, **generator_kwargs: Any) -> Generator['praw.models.ModNote', None, None]:\n    \"\"\"Return notes for this :class:`.Redditor` from one or more subreddits.\n\n        :param subreddits: One or more subreddits to retrieve the notes from. Must be\n            either a :class:`.Subreddit` or a subreddit name.\n        :param all_notes: Whether to return all notes or only the latest note (default:\n            ``True`` if only one subreddit is provided otherwise ``False``).\n\n            .. note::\n\n                Setting this to ``True`` will result in a request for each subreddit.\n\n\n        :returns: A generator that yields the most recent :class:`.ModNote` (or ``None``\n            if this redditor doesn't have any notes) per subreddit in their relative\n            order. If ``all_notes`` is ``True``, this will yield all notes or ``None``\n            from each subreddit for this redditor.\n\n        For example, all the notes for u/spez in r/test can be iterated through like so:\n\n        .. code-block:: python\n\n            redditor = reddit.redditor(\"spez\")\n\n            for note in redditor.notes.subreddits(\"test\"):\n                print(f\"{note.label}: {note.note}\")\n\n        For example, the latest note for u/spez from r/test and r/redditdev can be\n        iterated through like so:\n\n        .. code-block:: python\n\n            redditor = reddit.redditor(\"spez\")\n            subreddit = reddit.subreddit(\"redditdev\")\n\n            for note in redditor.notes.subreddits(\"test\", subreddit):\n                print(f\"{note.label}: {note.note}\")\n\n        For example, **all** the notes for u/spez in r/test and r/redditdev can be\n        iterated through like so:\n\n        .. code-block:: python\n\n            redditor = reddit.redditor(\"spez\")\n            subreddit = reddit.subreddit(\"redditdev\")\n\n            for note in redditor.notes.subreddits(\"test\", subreddit, all_notes=True):\n                print(f\"{note.label}: {note.note}\")\n\n        \"\"\"\n    if len(subreddits) == 0:\n        msg = 'At least 1 subreddit must be provided.'\n        raise ValueError(msg)\n    if all_notes is None:\n        all_notes = len(subreddits) == 1\n    return self._notes(all_notes, [self.redditor] * len(subreddits), list(subreddits), **generator_kwargs)",
        "mutated": [
            "def subreddits(self, *subreddits: SubredditType, all_notes: Optional[bool]=None, **generator_kwargs: Any) -> Generator['praw.models.ModNote', None, None]:\n    if False:\n        i = 10\n    'Return notes for this :class:`.Redditor` from one or more subreddits.\\n\\n        :param subreddits: One or more subreddits to retrieve the notes from. Must be\\n            either a :class:`.Subreddit` or a subreddit name.\\n        :param all_notes: Whether to return all notes or only the latest note (default:\\n            ``True`` if only one subreddit is provided otherwise ``False``).\\n\\n            .. note::\\n\\n                Setting this to ``True`` will result in a request for each subreddit.\\n\\n\\n        :returns: A generator that yields the most recent :class:`.ModNote` (or ``None``\\n            if this redditor doesn\\'t have any notes) per subreddit in their relative\\n            order. If ``all_notes`` is ``True``, this will yield all notes or ``None``\\n            from each subreddit for this redditor.\\n\\n        For example, all the notes for u/spez in r/test can be iterated through like so:\\n\\n        .. code-block:: python\\n\\n            redditor = reddit.redditor(\"spez\")\\n\\n            for note in redditor.notes.subreddits(\"test\"):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        For example, the latest note for u/spez from r/test and r/redditdev can be\\n        iterated through like so:\\n\\n        .. code-block:: python\\n\\n            redditor = reddit.redditor(\"spez\")\\n            subreddit = reddit.subreddit(\"redditdev\")\\n\\n            for note in redditor.notes.subreddits(\"test\", subreddit):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        For example, **all** the notes for u/spez in r/test and r/redditdev can be\\n        iterated through like so:\\n\\n        .. code-block:: python\\n\\n            redditor = reddit.redditor(\"spez\")\\n            subreddit = reddit.subreddit(\"redditdev\")\\n\\n            for note in redditor.notes.subreddits(\"test\", subreddit, all_notes=True):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        '\n    if len(subreddits) == 0:\n        msg = 'At least 1 subreddit must be provided.'\n        raise ValueError(msg)\n    if all_notes is None:\n        all_notes = len(subreddits) == 1\n    return self._notes(all_notes, [self.redditor] * len(subreddits), list(subreddits), **generator_kwargs)",
            "def subreddits(self, *subreddits: SubredditType, all_notes: Optional[bool]=None, **generator_kwargs: Any) -> Generator['praw.models.ModNote', None, None]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Return notes for this :class:`.Redditor` from one or more subreddits.\\n\\n        :param subreddits: One or more subreddits to retrieve the notes from. Must be\\n            either a :class:`.Subreddit` or a subreddit name.\\n        :param all_notes: Whether to return all notes or only the latest note (default:\\n            ``True`` if only one subreddit is provided otherwise ``False``).\\n\\n            .. note::\\n\\n                Setting this to ``True`` will result in a request for each subreddit.\\n\\n\\n        :returns: A generator that yields the most recent :class:`.ModNote` (or ``None``\\n            if this redditor doesn\\'t have any notes) per subreddit in their relative\\n            order. If ``all_notes`` is ``True``, this will yield all notes or ``None``\\n            from each subreddit for this redditor.\\n\\n        For example, all the notes for u/spez in r/test can be iterated through like so:\\n\\n        .. code-block:: python\\n\\n            redditor = reddit.redditor(\"spez\")\\n\\n            for note in redditor.notes.subreddits(\"test\"):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        For example, the latest note for u/spez from r/test and r/redditdev can be\\n        iterated through like so:\\n\\n        .. code-block:: python\\n\\n            redditor = reddit.redditor(\"spez\")\\n            subreddit = reddit.subreddit(\"redditdev\")\\n\\n            for note in redditor.notes.subreddits(\"test\", subreddit):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        For example, **all** the notes for u/spez in r/test and r/redditdev can be\\n        iterated through like so:\\n\\n        .. code-block:: python\\n\\n            redditor = reddit.redditor(\"spez\")\\n            subreddit = reddit.subreddit(\"redditdev\")\\n\\n            for note in redditor.notes.subreddits(\"test\", subreddit, all_notes=True):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        '\n    if len(subreddits) == 0:\n        msg = 'At least 1 subreddit must be provided.'\n        raise ValueError(msg)\n    if all_notes is None:\n        all_notes = len(subreddits) == 1\n    return self._notes(all_notes, [self.redditor] * len(subreddits), list(subreddits), **generator_kwargs)",
            "def subreddits(self, *subreddits: SubredditType, all_notes: Optional[bool]=None, **generator_kwargs: Any) -> Generator['praw.models.ModNote', None, None]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Return notes for this :class:`.Redditor` from one or more subreddits.\\n\\n        :param subreddits: One or more subreddits to retrieve the notes from. Must be\\n            either a :class:`.Subreddit` or a subreddit name.\\n        :param all_notes: Whether to return all notes or only the latest note (default:\\n            ``True`` if only one subreddit is provided otherwise ``False``).\\n\\n            .. note::\\n\\n                Setting this to ``True`` will result in a request for each subreddit.\\n\\n\\n        :returns: A generator that yields the most recent :class:`.ModNote` (or ``None``\\n            if this redditor doesn\\'t have any notes) per subreddit in their relative\\n            order. If ``all_notes`` is ``True``, this will yield all notes or ``None``\\n            from each subreddit for this redditor.\\n\\n        For example, all the notes for u/spez in r/test can be iterated through like so:\\n\\n        .. code-block:: python\\n\\n            redditor = reddit.redditor(\"spez\")\\n\\n            for note in redditor.notes.subreddits(\"test\"):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        For example, the latest note for u/spez from r/test and r/redditdev can be\\n        iterated through like so:\\n\\n        .. code-block:: python\\n\\n            redditor = reddit.redditor(\"spez\")\\n            subreddit = reddit.subreddit(\"redditdev\")\\n\\n            for note in redditor.notes.subreddits(\"test\", subreddit):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        For example, **all** the notes for u/spez in r/test and r/redditdev can be\\n        iterated through like so:\\n\\n        .. code-block:: python\\n\\n            redditor = reddit.redditor(\"spez\")\\n            subreddit = reddit.subreddit(\"redditdev\")\\n\\n            for note in redditor.notes.subreddits(\"test\", subreddit, all_notes=True):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        '\n    if len(subreddits) == 0:\n        msg = 'At least 1 subreddit must be provided.'\n        raise ValueError(msg)\n    if all_notes is None:\n        all_notes = len(subreddits) == 1\n    return self._notes(all_notes, [self.redditor] * len(subreddits), list(subreddits), **generator_kwargs)",
            "def subreddits(self, *subreddits: SubredditType, all_notes: Optional[bool]=None, **generator_kwargs: Any) -> Generator['praw.models.ModNote', None, None]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Return notes for this :class:`.Redditor` from one or more subreddits.\\n\\n        :param subreddits: One or more subreddits to retrieve the notes from. Must be\\n            either a :class:`.Subreddit` or a subreddit name.\\n        :param all_notes: Whether to return all notes or only the latest note (default:\\n            ``True`` if only one subreddit is provided otherwise ``False``).\\n\\n            .. note::\\n\\n                Setting this to ``True`` will result in a request for each subreddit.\\n\\n\\n        :returns: A generator that yields the most recent :class:`.ModNote` (or ``None``\\n            if this redditor doesn\\'t have any notes) per subreddit in their relative\\n            order. If ``all_notes`` is ``True``, this will yield all notes or ``None``\\n            from each subreddit for this redditor.\\n\\n        For example, all the notes for u/spez in r/test can be iterated through like so:\\n\\n        .. code-block:: python\\n\\n            redditor = reddit.redditor(\"spez\")\\n\\n            for note in redditor.notes.subreddits(\"test\"):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        For example, the latest note for u/spez from r/test and r/redditdev can be\\n        iterated through like so:\\n\\n        .. code-block:: python\\n\\n            redditor = reddit.redditor(\"spez\")\\n            subreddit = reddit.subreddit(\"redditdev\")\\n\\n            for note in redditor.notes.subreddits(\"test\", subreddit):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        For example, **all** the notes for u/spez in r/test and r/redditdev can be\\n        iterated through like so:\\n\\n        .. code-block:: python\\n\\n            redditor = reddit.redditor(\"spez\")\\n            subreddit = reddit.subreddit(\"redditdev\")\\n\\n            for note in redditor.notes.subreddits(\"test\", subreddit, all_notes=True):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        '\n    if len(subreddits) == 0:\n        msg = 'At least 1 subreddit must be provided.'\n        raise ValueError(msg)\n    if all_notes is None:\n        all_notes = len(subreddits) == 1\n    return self._notes(all_notes, [self.redditor] * len(subreddits), list(subreddits), **generator_kwargs)",
            "def subreddits(self, *subreddits: SubredditType, all_notes: Optional[bool]=None, **generator_kwargs: Any) -> Generator['praw.models.ModNote', None, None]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Return notes for this :class:`.Redditor` from one or more subreddits.\\n\\n        :param subreddits: One or more subreddits to retrieve the notes from. Must be\\n            either a :class:`.Subreddit` or a subreddit name.\\n        :param all_notes: Whether to return all notes or only the latest note (default:\\n            ``True`` if only one subreddit is provided otherwise ``False``).\\n\\n            .. note::\\n\\n                Setting this to ``True`` will result in a request for each subreddit.\\n\\n\\n        :returns: A generator that yields the most recent :class:`.ModNote` (or ``None``\\n            if this redditor doesn\\'t have any notes) per subreddit in their relative\\n            order. If ``all_notes`` is ``True``, this will yield all notes or ``None``\\n            from each subreddit for this redditor.\\n\\n        For example, all the notes for u/spez in r/test can be iterated through like so:\\n\\n        .. code-block:: python\\n\\n            redditor = reddit.redditor(\"spez\")\\n\\n            for note in redditor.notes.subreddits(\"test\"):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        For example, the latest note for u/spez from r/test and r/redditdev can be\\n        iterated through like so:\\n\\n        .. code-block:: python\\n\\n            redditor = reddit.redditor(\"spez\")\\n            subreddit = reddit.subreddit(\"redditdev\")\\n\\n            for note in redditor.notes.subreddits(\"test\", subreddit):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        For example, **all** the notes for u/spez in r/test and r/redditdev can be\\n        iterated through like so:\\n\\n        .. code-block:: python\\n\\n            redditor = reddit.redditor(\"spez\")\\n            subreddit = reddit.subreddit(\"redditdev\")\\n\\n            for note in redditor.notes.subreddits(\"test\", subreddit, all_notes=True):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        '\n    if len(subreddits) == 0:\n        msg = 'At least 1 subreddit must be provided.'\n        raise ValueError(msg)\n    if all_notes is None:\n        all_notes = len(subreddits) == 1\n    return self._notes(all_notes, [self.redditor] * len(subreddits), list(subreddits), **generator_kwargs)"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, reddit: 'praw.Reddit', subreddit: SubredditType):\n    \"\"\"Initialize a :class:`.SubredditModNotes` instance.\n\n        :param reddit: An instance of :class:`.Reddit`.\n        :param subreddit: An instance of :class:`.Subreddit`.\n\n        \"\"\"\n    super().__init__(reddit)\n    self.subreddit = subreddit",
        "mutated": [
            "def __init__(self, reddit: 'praw.Reddit', subreddit: SubredditType):\n    if False:\n        i = 10\n    'Initialize a :class:`.SubredditModNotes` instance.\\n\\n        :param reddit: An instance of :class:`.Reddit`.\\n        :param subreddit: An instance of :class:`.Subreddit`.\\n\\n        '\n    super().__init__(reddit)\n    self.subreddit = subreddit",
            "def __init__(self, reddit: 'praw.Reddit', subreddit: SubredditType):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Initialize a :class:`.SubredditModNotes` instance.\\n\\n        :param reddit: An instance of :class:`.Reddit`.\\n        :param subreddit: An instance of :class:`.Subreddit`.\\n\\n        '\n    super().__init__(reddit)\n    self.subreddit = subreddit",
            "def __init__(self, reddit: 'praw.Reddit', subreddit: SubredditType):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Initialize a :class:`.SubredditModNotes` instance.\\n\\n        :param reddit: An instance of :class:`.Reddit`.\\n        :param subreddit: An instance of :class:`.Subreddit`.\\n\\n        '\n    super().__init__(reddit)\n    self.subreddit = subreddit",
            "def __init__(self, reddit: 'praw.Reddit', subreddit: SubredditType):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Initialize a :class:`.SubredditModNotes` instance.\\n\\n        :param reddit: An instance of :class:`.Reddit`.\\n        :param subreddit: An instance of :class:`.Subreddit`.\\n\\n        '\n    super().__init__(reddit)\n    self.subreddit = subreddit",
            "def __init__(self, reddit: 'praw.Reddit', subreddit: SubredditType):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Initialize a :class:`.SubredditModNotes` instance.\\n\\n        :param reddit: An instance of :class:`.Reddit`.\\n        :param subreddit: An instance of :class:`.Subreddit`.\\n\\n        '\n    super().__init__(reddit)\n    self.subreddit = subreddit"
        ]
    },
    {
        "func_name": "redditors",
        "original": "def redditors(self, *redditors: RedditorType, all_notes: Optional[bool]=None, **generator_kwargs: Any) -> Generator['praw.models.ModNote', None, None]:\n    \"\"\"Return notes from this :class:`.Subreddit` for one or more redditors.\n\n        :param redditors: One or more redditors to retrieve notes for. Must be either a\n            :class:`.Redditor` or a redditor name.\n        :param all_notes: Whether to return all notes or only the latest note (default:\n            ``True`` if only one redditor is provided otherwise ``False``).\n\n            .. note::\n\n                Setting this to ``True`` will result in a request for each redditor.\n\n\n        :returns: A generator that yields the most recent :class:`.ModNote` (or ``None``\n            if the user doesn't have any notes in this subreddit) per redditor in their\n            relative order. If ``all_notes`` is ``True``, this will yield all notes for\n            each redditor.\n\n        For example, all the notes for u/spez in r/test can be iterated through like so:\n\n        .. code-block:: python\n\n            subreddit = reddit.subreddit(\"test\")\n\n            for note in subreddit.mod.notes.redditors(\"spez\"):\n                print(f\"{note.label}: {note.note}\")\n\n        For example, the latest note for u/spez and u/bboe from r/test can be iterated\n        through like so:\n\n        .. code-block:: python\n\n            subreddit = reddit.subreddit(\"test\")\n            redditor = reddit.redditor(\"bboe\")\n\n            for note in subreddit.mod.notes.redditors(\"spez\", redditor):\n                print(f\"{note.label}: {note.note}\")\n\n        For example, **all** the notes for both u/spez and u/bboe in r/test can be\n        iterated through like so:\n\n        .. code-block:: python\n\n            subreddit = reddit.subreddit(\"test\")\n            redditor = reddit.redditor(\"bboe\")\n\n            for note in subreddit.mod.notes.redditors(\"spez\", redditor, all_notes=True):\n                print(f\"{note.label}: {note.note}\")\n\n        \"\"\"\n    if len(redditors) == 0:\n        msg = 'At least 1 redditor must be provided.'\n        raise ValueError(msg)\n    if all_notes is None:\n        all_notes = len(redditors) == 1\n    return self._notes(all_notes, list(redditors), [self.subreddit] * len(redditors), **generator_kwargs)",
        "mutated": [
            "def redditors(self, *redditors: RedditorType, all_notes: Optional[bool]=None, **generator_kwargs: Any) -> Generator['praw.models.ModNote', None, None]:\n    if False:\n        i = 10\n    'Return notes from this :class:`.Subreddit` for one or more redditors.\\n\\n        :param redditors: One or more redditors to retrieve notes for. Must be either a\\n            :class:`.Redditor` or a redditor name.\\n        :param all_notes: Whether to return all notes or only the latest note (default:\\n            ``True`` if only one redditor is provided otherwise ``False``).\\n\\n            .. note::\\n\\n                Setting this to ``True`` will result in a request for each redditor.\\n\\n\\n        :returns: A generator that yields the most recent :class:`.ModNote` (or ``None``\\n            if the user doesn\\'t have any notes in this subreddit) per redditor in their\\n            relative order. If ``all_notes`` is ``True``, this will yield all notes for\\n            each redditor.\\n\\n        For example, all the notes for u/spez in r/test can be iterated through like so:\\n\\n        .. code-block:: python\\n\\n            subreddit = reddit.subreddit(\"test\")\\n\\n            for note in subreddit.mod.notes.redditors(\"spez\"):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        For example, the latest note for u/spez and u/bboe from r/test can be iterated\\n        through like so:\\n\\n        .. code-block:: python\\n\\n            subreddit = reddit.subreddit(\"test\")\\n            redditor = reddit.redditor(\"bboe\")\\n\\n            for note in subreddit.mod.notes.redditors(\"spez\", redditor):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        For example, **all** the notes for both u/spez and u/bboe in r/test can be\\n        iterated through like so:\\n\\n        .. code-block:: python\\n\\n            subreddit = reddit.subreddit(\"test\")\\n            redditor = reddit.redditor(\"bboe\")\\n\\n            for note in subreddit.mod.notes.redditors(\"spez\", redditor, all_notes=True):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        '\n    if len(redditors) == 0:\n        msg = 'At least 1 redditor must be provided.'\n        raise ValueError(msg)\n    if all_notes is None:\n        all_notes = len(redditors) == 1\n    return self._notes(all_notes, list(redditors), [self.subreddit] * len(redditors), **generator_kwargs)",
            "def redditors(self, *redditors: RedditorType, all_notes: Optional[bool]=None, **generator_kwargs: Any) -> Generator['praw.models.ModNote', None, None]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Return notes from this :class:`.Subreddit` for one or more redditors.\\n\\n        :param redditors: One or more redditors to retrieve notes for. Must be either a\\n            :class:`.Redditor` or a redditor name.\\n        :param all_notes: Whether to return all notes or only the latest note (default:\\n            ``True`` if only one redditor is provided otherwise ``False``).\\n\\n            .. note::\\n\\n                Setting this to ``True`` will result in a request for each redditor.\\n\\n\\n        :returns: A generator that yields the most recent :class:`.ModNote` (or ``None``\\n            if the user doesn\\'t have any notes in this subreddit) per redditor in their\\n            relative order. If ``all_notes`` is ``True``, this will yield all notes for\\n            each redditor.\\n\\n        For example, all the notes for u/spez in r/test can be iterated through like so:\\n\\n        .. code-block:: python\\n\\n            subreddit = reddit.subreddit(\"test\")\\n\\n            for note in subreddit.mod.notes.redditors(\"spez\"):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        For example, the latest note for u/spez and u/bboe from r/test can be iterated\\n        through like so:\\n\\n        .. code-block:: python\\n\\n            subreddit = reddit.subreddit(\"test\")\\n            redditor = reddit.redditor(\"bboe\")\\n\\n            for note in subreddit.mod.notes.redditors(\"spez\", redditor):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        For example, **all** the notes for both u/spez and u/bboe in r/test can be\\n        iterated through like so:\\n\\n        .. code-block:: python\\n\\n            subreddit = reddit.subreddit(\"test\")\\n            redditor = reddit.redditor(\"bboe\")\\n\\n            for note in subreddit.mod.notes.redditors(\"spez\", redditor, all_notes=True):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        '\n    if len(redditors) == 0:\n        msg = 'At least 1 redditor must be provided.'\n        raise ValueError(msg)\n    if all_notes is None:\n        all_notes = len(redditors) == 1\n    return self._notes(all_notes, list(redditors), [self.subreddit] * len(redditors), **generator_kwargs)",
            "def redditors(self, *redditors: RedditorType, all_notes: Optional[bool]=None, **generator_kwargs: Any) -> Generator['praw.models.ModNote', None, None]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Return notes from this :class:`.Subreddit` for one or more redditors.\\n\\n        :param redditors: One or more redditors to retrieve notes for. Must be either a\\n            :class:`.Redditor` or a redditor name.\\n        :param all_notes: Whether to return all notes or only the latest note (default:\\n            ``True`` if only one redditor is provided otherwise ``False``).\\n\\n            .. note::\\n\\n                Setting this to ``True`` will result in a request for each redditor.\\n\\n\\n        :returns: A generator that yields the most recent :class:`.ModNote` (or ``None``\\n            if the user doesn\\'t have any notes in this subreddit) per redditor in their\\n            relative order. If ``all_notes`` is ``True``, this will yield all notes for\\n            each redditor.\\n\\n        For example, all the notes for u/spez in r/test can be iterated through like so:\\n\\n        .. code-block:: python\\n\\n            subreddit = reddit.subreddit(\"test\")\\n\\n            for note in subreddit.mod.notes.redditors(\"spez\"):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        For example, the latest note for u/spez and u/bboe from r/test can be iterated\\n        through like so:\\n\\n        .. code-block:: python\\n\\n            subreddit = reddit.subreddit(\"test\")\\n            redditor = reddit.redditor(\"bboe\")\\n\\n            for note in subreddit.mod.notes.redditors(\"spez\", redditor):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        For example, **all** the notes for both u/spez and u/bboe in r/test can be\\n        iterated through like so:\\n\\n        .. code-block:: python\\n\\n            subreddit = reddit.subreddit(\"test\")\\n            redditor = reddit.redditor(\"bboe\")\\n\\n            for note in subreddit.mod.notes.redditors(\"spez\", redditor, all_notes=True):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        '\n    if len(redditors) == 0:\n        msg = 'At least 1 redditor must be provided.'\n        raise ValueError(msg)\n    if all_notes is None:\n        all_notes = len(redditors) == 1\n    return self._notes(all_notes, list(redditors), [self.subreddit] * len(redditors), **generator_kwargs)",
            "def redditors(self, *redditors: RedditorType, all_notes: Optional[bool]=None, **generator_kwargs: Any) -> Generator['praw.models.ModNote', None, None]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Return notes from this :class:`.Subreddit` for one or more redditors.\\n\\n        :param redditors: One or more redditors to retrieve notes for. Must be either a\\n            :class:`.Redditor` or a redditor name.\\n        :param all_notes: Whether to return all notes or only the latest note (default:\\n            ``True`` if only one redditor is provided otherwise ``False``).\\n\\n            .. note::\\n\\n                Setting this to ``True`` will result in a request for each redditor.\\n\\n\\n        :returns: A generator that yields the most recent :class:`.ModNote` (or ``None``\\n            if the user doesn\\'t have any notes in this subreddit) per redditor in their\\n            relative order. If ``all_notes`` is ``True``, this will yield all notes for\\n            each redditor.\\n\\n        For example, all the notes for u/spez in r/test can be iterated through like so:\\n\\n        .. code-block:: python\\n\\n            subreddit = reddit.subreddit(\"test\")\\n\\n            for note in subreddit.mod.notes.redditors(\"spez\"):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        For example, the latest note for u/spez and u/bboe from r/test can be iterated\\n        through like so:\\n\\n        .. code-block:: python\\n\\n            subreddit = reddit.subreddit(\"test\")\\n            redditor = reddit.redditor(\"bboe\")\\n\\n            for note in subreddit.mod.notes.redditors(\"spez\", redditor):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        For example, **all** the notes for both u/spez and u/bboe in r/test can be\\n        iterated through like so:\\n\\n        .. code-block:: python\\n\\n            subreddit = reddit.subreddit(\"test\")\\n            redditor = reddit.redditor(\"bboe\")\\n\\n            for note in subreddit.mod.notes.redditors(\"spez\", redditor, all_notes=True):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        '\n    if len(redditors) == 0:\n        msg = 'At least 1 redditor must be provided.'\n        raise ValueError(msg)\n    if all_notes is None:\n        all_notes = len(redditors) == 1\n    return self._notes(all_notes, list(redditors), [self.subreddit] * len(redditors), **generator_kwargs)",
            "def redditors(self, *redditors: RedditorType, all_notes: Optional[bool]=None, **generator_kwargs: Any) -> Generator['praw.models.ModNote', None, None]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Return notes from this :class:`.Subreddit` for one or more redditors.\\n\\n        :param redditors: One or more redditors to retrieve notes for. Must be either a\\n            :class:`.Redditor` or a redditor name.\\n        :param all_notes: Whether to return all notes or only the latest note (default:\\n            ``True`` if only one redditor is provided otherwise ``False``).\\n\\n            .. note::\\n\\n                Setting this to ``True`` will result in a request for each redditor.\\n\\n\\n        :returns: A generator that yields the most recent :class:`.ModNote` (or ``None``\\n            if the user doesn\\'t have any notes in this subreddit) per redditor in their\\n            relative order. If ``all_notes`` is ``True``, this will yield all notes for\\n            each redditor.\\n\\n        For example, all the notes for u/spez in r/test can be iterated through like so:\\n\\n        .. code-block:: python\\n\\n            subreddit = reddit.subreddit(\"test\")\\n\\n            for note in subreddit.mod.notes.redditors(\"spez\"):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        For example, the latest note for u/spez and u/bboe from r/test can be iterated\\n        through like so:\\n\\n        .. code-block:: python\\n\\n            subreddit = reddit.subreddit(\"test\")\\n            redditor = reddit.redditor(\"bboe\")\\n\\n            for note in subreddit.mod.notes.redditors(\"spez\", redditor):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        For example, **all** the notes for both u/spez and u/bboe in r/test can be\\n        iterated through like so:\\n\\n        .. code-block:: python\\n\\n            subreddit = reddit.subreddit(\"test\")\\n            redditor = reddit.redditor(\"bboe\")\\n\\n            for note in subreddit.mod.notes.redditors(\"spez\", redditor, all_notes=True):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        '\n    if len(redditors) == 0:\n        msg = 'At least 1 redditor must be provided.'\n        raise ValueError(msg)\n    if all_notes is None:\n        all_notes = len(redditors) == 1\n    return self._notes(all_notes, list(redditors), [self.subreddit] * len(redditors), **generator_kwargs)"
        ]
    },
    {
        "func_name": "__call__",
        "original": "def __call__(self, *, all_notes: bool=False, pairs: Optional[List[Tuple[SubredditType, RedditorType]]]=None, redditors: Optional[List[RedditorType]]=None, subreddits: Optional[List[SubredditType]]=None, things: Optional[List[ThingType]]=None, **generator_kwargs: Any) -> Generator['praw.models.ModNote', None, None]:\n    \"\"\"Get note(s) for each subreddit/user pair, or ``None`` if they don't have any.\n\n        :param all_notes: Whether to return all notes or only the latest note for each\n            subreddit/redditor pair (default: ``False``).\n\n            .. note::\n\n                Setting this to ``True`` will result in a request for each unique\n                subreddit/redditor pair. If ``subreddits`` and ``redditors`` are\n                provided, this will make a request equivalent to number of redditors\n                multiplied by the number of subreddits.\n\n        :param pairs: A list of subreddit/redditor tuples.\n\n            .. note::\n\n                Required if ``subreddits``, ``redditors``, nor ``things`` are provided.\n\n        :param redditors: A list of redditors to return notes for. This parameter is\n            used in tandem with ``subreddits`` to get notes from multiple subreddits for\n            each of the provided redditors.\n\n            .. note::\n\n                Required if ``items`` or ``things`` is not provided or if ``subreddits``\n                **is** provided.\n\n        :param subreddits: A list of subreddits to return notes for. This parameter is\n            used in tandem with ``redditors`` to get notes for multiple redditors from\n            each of the provided subreddits.\n\n            .. note::\n\n                Required if ``items`` or ``things`` is not provided or if ``redditors``\n                **is** provided.\n\n        :param things: A list of comments and/or submissions to return notes for.\n        :param generator_kwargs: Additional keyword arguments passed to the generator.\n            This parameter is ignored when ``all_notes`` is ``False``.\n\n        :returns: A generator that yields the most recent :class:`.ModNote` (or ``None``\n            if the user doesn't have any notes) per entry in their relative order. If\n            ``all_notes`` is ``True``, this will yield all notes for each entry.\n\n        .. note::\n\n            This method will merge the subreddits and redditors provided from ``pairs``,\n            ``redditors``, ``subreddits``, and ``things``.\n\n        .. note::\n\n            This method accepts :class:`.Redditor` instances or redditor names and\n            :class:`.Subreddit` instances or subreddit names where applicable.\n\n        For example, the latest note for u/spez in r/redditdev and r/test, and for\n        u/bboe in r/redditdev can be iterated through like so:\n\n        .. code-block:: python\n\n            redditor = reddit.redditor(\"bboe\")\n            subreddit = reddit.subreddit(\"redditdev\")\n\n            pairs = [(subreddit, \"spez\"), (\"test\", \"spez\"), (subreddit, redditor)]\n\n            for note in reddit.notes(pairs=pairs):\n                print(f\"{note.label}: {note.note}\")\n\n        For example, **all** the notes for u/spez and u/bboe in r/announcements,\n        r/redditdev, and r/test can be iterated through like so:\n\n        .. code-block:: python\n\n            redditor = reddit.redditor(\"bboe\")\n            subreddit = reddit.subreddit(\"redditdev\")\n\n            for note in reddit.notes(\n                redditors=[\"spez\", redditor],\n                subreddits=[\"announcements\", subreddit, \"test\"],\n                all_notes=True,\n            ):\n                print(f\"{note.label}: {note.note}\")\n\n        For example, the latest note for the authors of the last 5 comments and\n        submissions from r/test can be iterated through like so:\n\n        .. code-block:: python\n\n            submissions = list(reddit.subreddit(\"test\").new(limit=5))\n            comments = list(reddit.subreddit(\"test\").comments(limit=5))\n\n            for note in reddit.notes(things=submissions + comments):\n                print(f\"{note.label}: {note.note}\")\n\n        .. note::\n\n            Setting ``all_notes`` to ``True`` will make a request for each redditor and\n            subreddit combination. The previous example will make 6 requests.\n\n        \"\"\"\n    if pairs is None:\n        pairs = []\n    if redditors is None:\n        redditors = []\n    if subreddits is None:\n        subreddits = []\n    if things is None:\n        things = []\n    if not pairs + redditors + subreddits + things:\n        msg = \"Either the 'pairs', 'redditors', 'subreddits', or 'things' parameters must be provided.\"\n        raise TypeError(msg)\n    if len(redditors) * len(subreddits) == 0 and len(redditors) + len(subreddits) > 0:\n        raise TypeError(\"'redditors' must be non-empty if 'subreddits' is not empty.\" if len(subreddits) > 0 else \"'subreddits' must be non-empty if 'redditors' is not empty.\")\n    merged_redditors = []\n    merged_subreddits = []\n    items = pairs + [(subreddit, redditor) for redditor in set(redditors) for subreddit in set(subreddits)] + things\n    for item in items:\n        if isinstance(item, (Comment, Submission)):\n            merged_redditors.append(item.author.name)\n            merged_subreddits.append(item.subreddit.display_name)\n        elif isinstance(item, Tuple):\n            (subreddit, redditor) = item\n            merged_redditors.append(redditor)\n            merged_subreddits.append(subreddit)\n        else:\n            msg = f'Cannot get subreddit and author fields from type {type(item)}'\n            raise ValueError(msg)\n    return self._notes(all_notes, merged_redditors, merged_subreddits, **generator_kwargs)",
        "mutated": [
            "def __call__(self, *, all_notes: bool=False, pairs: Optional[List[Tuple[SubredditType, RedditorType]]]=None, redditors: Optional[List[RedditorType]]=None, subreddits: Optional[List[SubredditType]]=None, things: Optional[List[ThingType]]=None, **generator_kwargs: Any) -> Generator['praw.models.ModNote', None, None]:\n    if False:\n        i = 10\n    'Get note(s) for each subreddit/user pair, or ``None`` if they don\\'t have any.\\n\\n        :param all_notes: Whether to return all notes or only the latest note for each\\n            subreddit/redditor pair (default: ``False``).\\n\\n            .. note::\\n\\n                Setting this to ``True`` will result in a request for each unique\\n                subreddit/redditor pair. If ``subreddits`` and ``redditors`` are\\n                provided, this will make a request equivalent to number of redditors\\n                multiplied by the number of subreddits.\\n\\n        :param pairs: A list of subreddit/redditor tuples.\\n\\n            .. note::\\n\\n                Required if ``subreddits``, ``redditors``, nor ``things`` are provided.\\n\\n        :param redditors: A list of redditors to return notes for. This parameter is\\n            used in tandem with ``subreddits`` to get notes from multiple subreddits for\\n            each of the provided redditors.\\n\\n            .. note::\\n\\n                Required if ``items`` or ``things`` is not provided or if ``subreddits``\\n                **is** provided.\\n\\n        :param subreddits: A list of subreddits to return notes for. This parameter is\\n            used in tandem with ``redditors`` to get notes for multiple redditors from\\n            each of the provided subreddits.\\n\\n            .. note::\\n\\n                Required if ``items`` or ``things`` is not provided or if ``redditors``\\n                **is** provided.\\n\\n        :param things: A list of comments and/or submissions to return notes for.\\n        :param generator_kwargs: Additional keyword arguments passed to the generator.\\n            This parameter is ignored when ``all_notes`` is ``False``.\\n\\n        :returns: A generator that yields the most recent :class:`.ModNote` (or ``None``\\n            if the user doesn\\'t have any notes) per entry in their relative order. If\\n            ``all_notes`` is ``True``, this will yield all notes for each entry.\\n\\n        .. note::\\n\\n            This method will merge the subreddits and redditors provided from ``pairs``,\\n            ``redditors``, ``subreddits``, and ``things``.\\n\\n        .. note::\\n\\n            This method accepts :class:`.Redditor` instances or redditor names and\\n            :class:`.Subreddit` instances or subreddit names where applicable.\\n\\n        For example, the latest note for u/spez in r/redditdev and r/test, and for\\n        u/bboe in r/redditdev can be iterated through like so:\\n\\n        .. code-block:: python\\n\\n            redditor = reddit.redditor(\"bboe\")\\n            subreddit = reddit.subreddit(\"redditdev\")\\n\\n            pairs = [(subreddit, \"spez\"), (\"test\", \"spez\"), (subreddit, redditor)]\\n\\n            for note in reddit.notes(pairs=pairs):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        For example, **all** the notes for u/spez and u/bboe in r/announcements,\\n        r/redditdev, and r/test can be iterated through like so:\\n\\n        .. code-block:: python\\n\\n            redditor = reddit.redditor(\"bboe\")\\n            subreddit = reddit.subreddit(\"redditdev\")\\n\\n            for note in reddit.notes(\\n                redditors=[\"spez\", redditor],\\n                subreddits=[\"announcements\", subreddit, \"test\"],\\n                all_notes=True,\\n            ):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        For example, the latest note for the authors of the last 5 comments and\\n        submissions from r/test can be iterated through like so:\\n\\n        .. code-block:: python\\n\\n            submissions = list(reddit.subreddit(\"test\").new(limit=5))\\n            comments = list(reddit.subreddit(\"test\").comments(limit=5))\\n\\n            for note in reddit.notes(things=submissions + comments):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        .. note::\\n\\n            Setting ``all_notes`` to ``True`` will make a request for each redditor and\\n            subreddit combination. The previous example will make 6 requests.\\n\\n        '\n    if pairs is None:\n        pairs = []\n    if redditors is None:\n        redditors = []\n    if subreddits is None:\n        subreddits = []\n    if things is None:\n        things = []\n    if not pairs + redditors + subreddits + things:\n        msg = \"Either the 'pairs', 'redditors', 'subreddits', or 'things' parameters must be provided.\"\n        raise TypeError(msg)\n    if len(redditors) * len(subreddits) == 0 and len(redditors) + len(subreddits) > 0:\n        raise TypeError(\"'redditors' must be non-empty if 'subreddits' is not empty.\" if len(subreddits) > 0 else \"'subreddits' must be non-empty if 'redditors' is not empty.\")\n    merged_redditors = []\n    merged_subreddits = []\n    items = pairs + [(subreddit, redditor) for redditor in set(redditors) for subreddit in set(subreddits)] + things\n    for item in items:\n        if isinstance(item, (Comment, Submission)):\n            merged_redditors.append(item.author.name)\n            merged_subreddits.append(item.subreddit.display_name)\n        elif isinstance(item, Tuple):\n            (subreddit, redditor) = item\n            merged_redditors.append(redditor)\n            merged_subreddits.append(subreddit)\n        else:\n            msg = f'Cannot get subreddit and author fields from type {type(item)}'\n            raise ValueError(msg)\n    return self._notes(all_notes, merged_redditors, merged_subreddits, **generator_kwargs)",
            "def __call__(self, *, all_notes: bool=False, pairs: Optional[List[Tuple[SubredditType, RedditorType]]]=None, redditors: Optional[List[RedditorType]]=None, subreddits: Optional[List[SubredditType]]=None, things: Optional[List[ThingType]]=None, **generator_kwargs: Any) -> Generator['praw.models.ModNote', None, None]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Get note(s) for each subreddit/user pair, or ``None`` if they don\\'t have any.\\n\\n        :param all_notes: Whether to return all notes or only the latest note for each\\n            subreddit/redditor pair (default: ``False``).\\n\\n            .. note::\\n\\n                Setting this to ``True`` will result in a request for each unique\\n                subreddit/redditor pair. If ``subreddits`` and ``redditors`` are\\n                provided, this will make a request equivalent to number of redditors\\n                multiplied by the number of subreddits.\\n\\n        :param pairs: A list of subreddit/redditor tuples.\\n\\n            .. note::\\n\\n                Required if ``subreddits``, ``redditors``, nor ``things`` are provided.\\n\\n        :param redditors: A list of redditors to return notes for. This parameter is\\n            used in tandem with ``subreddits`` to get notes from multiple subreddits for\\n            each of the provided redditors.\\n\\n            .. note::\\n\\n                Required if ``items`` or ``things`` is not provided or if ``subreddits``\\n                **is** provided.\\n\\n        :param subreddits: A list of subreddits to return notes for. This parameter is\\n            used in tandem with ``redditors`` to get notes for multiple redditors from\\n            each of the provided subreddits.\\n\\n            .. note::\\n\\n                Required if ``items`` or ``things`` is not provided or if ``redditors``\\n                **is** provided.\\n\\n        :param things: A list of comments and/or submissions to return notes for.\\n        :param generator_kwargs: Additional keyword arguments passed to the generator.\\n            This parameter is ignored when ``all_notes`` is ``False``.\\n\\n        :returns: A generator that yields the most recent :class:`.ModNote` (or ``None``\\n            if the user doesn\\'t have any notes) per entry in their relative order. If\\n            ``all_notes`` is ``True``, this will yield all notes for each entry.\\n\\n        .. note::\\n\\n            This method will merge the subreddits and redditors provided from ``pairs``,\\n            ``redditors``, ``subreddits``, and ``things``.\\n\\n        .. note::\\n\\n            This method accepts :class:`.Redditor` instances or redditor names and\\n            :class:`.Subreddit` instances or subreddit names where applicable.\\n\\n        For example, the latest note for u/spez in r/redditdev and r/test, and for\\n        u/bboe in r/redditdev can be iterated through like so:\\n\\n        .. code-block:: python\\n\\n            redditor = reddit.redditor(\"bboe\")\\n            subreddit = reddit.subreddit(\"redditdev\")\\n\\n            pairs = [(subreddit, \"spez\"), (\"test\", \"spez\"), (subreddit, redditor)]\\n\\n            for note in reddit.notes(pairs=pairs):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        For example, **all** the notes for u/spez and u/bboe in r/announcements,\\n        r/redditdev, and r/test can be iterated through like so:\\n\\n        .. code-block:: python\\n\\n            redditor = reddit.redditor(\"bboe\")\\n            subreddit = reddit.subreddit(\"redditdev\")\\n\\n            for note in reddit.notes(\\n                redditors=[\"spez\", redditor],\\n                subreddits=[\"announcements\", subreddit, \"test\"],\\n                all_notes=True,\\n            ):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        For example, the latest note for the authors of the last 5 comments and\\n        submissions from r/test can be iterated through like so:\\n\\n        .. code-block:: python\\n\\n            submissions = list(reddit.subreddit(\"test\").new(limit=5))\\n            comments = list(reddit.subreddit(\"test\").comments(limit=5))\\n\\n            for note in reddit.notes(things=submissions + comments):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        .. note::\\n\\n            Setting ``all_notes`` to ``True`` will make a request for each redditor and\\n            subreddit combination. The previous example will make 6 requests.\\n\\n        '\n    if pairs is None:\n        pairs = []\n    if redditors is None:\n        redditors = []\n    if subreddits is None:\n        subreddits = []\n    if things is None:\n        things = []\n    if not pairs + redditors + subreddits + things:\n        msg = \"Either the 'pairs', 'redditors', 'subreddits', or 'things' parameters must be provided.\"\n        raise TypeError(msg)\n    if len(redditors) * len(subreddits) == 0 and len(redditors) + len(subreddits) > 0:\n        raise TypeError(\"'redditors' must be non-empty if 'subreddits' is not empty.\" if len(subreddits) > 0 else \"'subreddits' must be non-empty if 'redditors' is not empty.\")\n    merged_redditors = []\n    merged_subreddits = []\n    items = pairs + [(subreddit, redditor) for redditor in set(redditors) for subreddit in set(subreddits)] + things\n    for item in items:\n        if isinstance(item, (Comment, Submission)):\n            merged_redditors.append(item.author.name)\n            merged_subreddits.append(item.subreddit.display_name)\n        elif isinstance(item, Tuple):\n            (subreddit, redditor) = item\n            merged_redditors.append(redditor)\n            merged_subreddits.append(subreddit)\n        else:\n            msg = f'Cannot get subreddit and author fields from type {type(item)}'\n            raise ValueError(msg)\n    return self._notes(all_notes, merged_redditors, merged_subreddits, **generator_kwargs)",
            "def __call__(self, *, all_notes: bool=False, pairs: Optional[List[Tuple[SubredditType, RedditorType]]]=None, redditors: Optional[List[RedditorType]]=None, subreddits: Optional[List[SubredditType]]=None, things: Optional[List[ThingType]]=None, **generator_kwargs: Any) -> Generator['praw.models.ModNote', None, None]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Get note(s) for each subreddit/user pair, or ``None`` if they don\\'t have any.\\n\\n        :param all_notes: Whether to return all notes or only the latest note for each\\n            subreddit/redditor pair (default: ``False``).\\n\\n            .. note::\\n\\n                Setting this to ``True`` will result in a request for each unique\\n                subreddit/redditor pair. If ``subreddits`` and ``redditors`` are\\n                provided, this will make a request equivalent to number of redditors\\n                multiplied by the number of subreddits.\\n\\n        :param pairs: A list of subreddit/redditor tuples.\\n\\n            .. note::\\n\\n                Required if ``subreddits``, ``redditors``, nor ``things`` are provided.\\n\\n        :param redditors: A list of redditors to return notes for. This parameter is\\n            used in tandem with ``subreddits`` to get notes from multiple subreddits for\\n            each of the provided redditors.\\n\\n            .. note::\\n\\n                Required if ``items`` or ``things`` is not provided or if ``subreddits``\\n                **is** provided.\\n\\n        :param subreddits: A list of subreddits to return notes for. This parameter is\\n            used in tandem with ``redditors`` to get notes for multiple redditors from\\n            each of the provided subreddits.\\n\\n            .. note::\\n\\n                Required if ``items`` or ``things`` is not provided or if ``redditors``\\n                **is** provided.\\n\\n        :param things: A list of comments and/or submissions to return notes for.\\n        :param generator_kwargs: Additional keyword arguments passed to the generator.\\n            This parameter is ignored when ``all_notes`` is ``False``.\\n\\n        :returns: A generator that yields the most recent :class:`.ModNote` (or ``None``\\n            if the user doesn\\'t have any notes) per entry in their relative order. If\\n            ``all_notes`` is ``True``, this will yield all notes for each entry.\\n\\n        .. note::\\n\\n            This method will merge the subreddits and redditors provided from ``pairs``,\\n            ``redditors``, ``subreddits``, and ``things``.\\n\\n        .. note::\\n\\n            This method accepts :class:`.Redditor` instances or redditor names and\\n            :class:`.Subreddit` instances or subreddit names where applicable.\\n\\n        For example, the latest note for u/spez in r/redditdev and r/test, and for\\n        u/bboe in r/redditdev can be iterated through like so:\\n\\n        .. code-block:: python\\n\\n            redditor = reddit.redditor(\"bboe\")\\n            subreddit = reddit.subreddit(\"redditdev\")\\n\\n            pairs = [(subreddit, \"spez\"), (\"test\", \"spez\"), (subreddit, redditor)]\\n\\n            for note in reddit.notes(pairs=pairs):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        For example, **all** the notes for u/spez and u/bboe in r/announcements,\\n        r/redditdev, and r/test can be iterated through like so:\\n\\n        .. code-block:: python\\n\\n            redditor = reddit.redditor(\"bboe\")\\n            subreddit = reddit.subreddit(\"redditdev\")\\n\\n            for note in reddit.notes(\\n                redditors=[\"spez\", redditor],\\n                subreddits=[\"announcements\", subreddit, \"test\"],\\n                all_notes=True,\\n            ):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        For example, the latest note for the authors of the last 5 comments and\\n        submissions from r/test can be iterated through like so:\\n\\n        .. code-block:: python\\n\\n            submissions = list(reddit.subreddit(\"test\").new(limit=5))\\n            comments = list(reddit.subreddit(\"test\").comments(limit=5))\\n\\n            for note in reddit.notes(things=submissions + comments):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        .. note::\\n\\n            Setting ``all_notes`` to ``True`` will make a request for each redditor and\\n            subreddit combination. The previous example will make 6 requests.\\n\\n        '\n    if pairs is None:\n        pairs = []\n    if redditors is None:\n        redditors = []\n    if subreddits is None:\n        subreddits = []\n    if things is None:\n        things = []\n    if not pairs + redditors + subreddits + things:\n        msg = \"Either the 'pairs', 'redditors', 'subreddits', or 'things' parameters must be provided.\"\n        raise TypeError(msg)\n    if len(redditors) * len(subreddits) == 0 and len(redditors) + len(subreddits) > 0:\n        raise TypeError(\"'redditors' must be non-empty if 'subreddits' is not empty.\" if len(subreddits) > 0 else \"'subreddits' must be non-empty if 'redditors' is not empty.\")\n    merged_redditors = []\n    merged_subreddits = []\n    items = pairs + [(subreddit, redditor) for redditor in set(redditors) for subreddit in set(subreddits)] + things\n    for item in items:\n        if isinstance(item, (Comment, Submission)):\n            merged_redditors.append(item.author.name)\n            merged_subreddits.append(item.subreddit.display_name)\n        elif isinstance(item, Tuple):\n            (subreddit, redditor) = item\n            merged_redditors.append(redditor)\n            merged_subreddits.append(subreddit)\n        else:\n            msg = f'Cannot get subreddit and author fields from type {type(item)}'\n            raise ValueError(msg)\n    return self._notes(all_notes, merged_redditors, merged_subreddits, **generator_kwargs)",
            "def __call__(self, *, all_notes: bool=False, pairs: Optional[List[Tuple[SubredditType, RedditorType]]]=None, redditors: Optional[List[RedditorType]]=None, subreddits: Optional[List[SubredditType]]=None, things: Optional[List[ThingType]]=None, **generator_kwargs: Any) -> Generator['praw.models.ModNote', None, None]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Get note(s) for each subreddit/user pair, or ``None`` if they don\\'t have any.\\n\\n        :param all_notes: Whether to return all notes or only the latest note for each\\n            subreddit/redditor pair (default: ``False``).\\n\\n            .. note::\\n\\n                Setting this to ``True`` will result in a request for each unique\\n                subreddit/redditor pair. If ``subreddits`` and ``redditors`` are\\n                provided, this will make a request equivalent to number of redditors\\n                multiplied by the number of subreddits.\\n\\n        :param pairs: A list of subreddit/redditor tuples.\\n\\n            .. note::\\n\\n                Required if ``subreddits``, ``redditors``, nor ``things`` are provided.\\n\\n        :param redditors: A list of redditors to return notes for. This parameter is\\n            used in tandem with ``subreddits`` to get notes from multiple subreddits for\\n            each of the provided redditors.\\n\\n            .. note::\\n\\n                Required if ``items`` or ``things`` is not provided or if ``subreddits``\\n                **is** provided.\\n\\n        :param subreddits: A list of subreddits to return notes for. This parameter is\\n            used in tandem with ``redditors`` to get notes for multiple redditors from\\n            each of the provided subreddits.\\n\\n            .. note::\\n\\n                Required if ``items`` or ``things`` is not provided or if ``redditors``\\n                **is** provided.\\n\\n        :param things: A list of comments and/or submissions to return notes for.\\n        :param generator_kwargs: Additional keyword arguments passed to the generator.\\n            This parameter is ignored when ``all_notes`` is ``False``.\\n\\n        :returns: A generator that yields the most recent :class:`.ModNote` (or ``None``\\n            if the user doesn\\'t have any notes) per entry in their relative order. If\\n            ``all_notes`` is ``True``, this will yield all notes for each entry.\\n\\n        .. note::\\n\\n            This method will merge the subreddits and redditors provided from ``pairs``,\\n            ``redditors``, ``subreddits``, and ``things``.\\n\\n        .. note::\\n\\n            This method accepts :class:`.Redditor` instances or redditor names and\\n            :class:`.Subreddit` instances or subreddit names where applicable.\\n\\n        For example, the latest note for u/spez in r/redditdev and r/test, and for\\n        u/bboe in r/redditdev can be iterated through like so:\\n\\n        .. code-block:: python\\n\\n            redditor = reddit.redditor(\"bboe\")\\n            subreddit = reddit.subreddit(\"redditdev\")\\n\\n            pairs = [(subreddit, \"spez\"), (\"test\", \"spez\"), (subreddit, redditor)]\\n\\n            for note in reddit.notes(pairs=pairs):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        For example, **all** the notes for u/spez and u/bboe in r/announcements,\\n        r/redditdev, and r/test can be iterated through like so:\\n\\n        .. code-block:: python\\n\\n            redditor = reddit.redditor(\"bboe\")\\n            subreddit = reddit.subreddit(\"redditdev\")\\n\\n            for note in reddit.notes(\\n                redditors=[\"spez\", redditor],\\n                subreddits=[\"announcements\", subreddit, \"test\"],\\n                all_notes=True,\\n            ):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        For example, the latest note for the authors of the last 5 comments and\\n        submissions from r/test can be iterated through like so:\\n\\n        .. code-block:: python\\n\\n            submissions = list(reddit.subreddit(\"test\").new(limit=5))\\n            comments = list(reddit.subreddit(\"test\").comments(limit=5))\\n\\n            for note in reddit.notes(things=submissions + comments):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        .. note::\\n\\n            Setting ``all_notes`` to ``True`` will make a request for each redditor and\\n            subreddit combination. The previous example will make 6 requests.\\n\\n        '\n    if pairs is None:\n        pairs = []\n    if redditors is None:\n        redditors = []\n    if subreddits is None:\n        subreddits = []\n    if things is None:\n        things = []\n    if not pairs + redditors + subreddits + things:\n        msg = \"Either the 'pairs', 'redditors', 'subreddits', or 'things' parameters must be provided.\"\n        raise TypeError(msg)\n    if len(redditors) * len(subreddits) == 0 and len(redditors) + len(subreddits) > 0:\n        raise TypeError(\"'redditors' must be non-empty if 'subreddits' is not empty.\" if len(subreddits) > 0 else \"'subreddits' must be non-empty if 'redditors' is not empty.\")\n    merged_redditors = []\n    merged_subreddits = []\n    items = pairs + [(subreddit, redditor) for redditor in set(redditors) for subreddit in set(subreddits)] + things\n    for item in items:\n        if isinstance(item, (Comment, Submission)):\n            merged_redditors.append(item.author.name)\n            merged_subreddits.append(item.subreddit.display_name)\n        elif isinstance(item, Tuple):\n            (subreddit, redditor) = item\n            merged_redditors.append(redditor)\n            merged_subreddits.append(subreddit)\n        else:\n            msg = f'Cannot get subreddit and author fields from type {type(item)}'\n            raise ValueError(msg)\n    return self._notes(all_notes, merged_redditors, merged_subreddits, **generator_kwargs)",
            "def __call__(self, *, all_notes: bool=False, pairs: Optional[List[Tuple[SubredditType, RedditorType]]]=None, redditors: Optional[List[RedditorType]]=None, subreddits: Optional[List[SubredditType]]=None, things: Optional[List[ThingType]]=None, **generator_kwargs: Any) -> Generator['praw.models.ModNote', None, None]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Get note(s) for each subreddit/user pair, or ``None`` if they don\\'t have any.\\n\\n        :param all_notes: Whether to return all notes or only the latest note for each\\n            subreddit/redditor pair (default: ``False``).\\n\\n            .. note::\\n\\n                Setting this to ``True`` will result in a request for each unique\\n                subreddit/redditor pair. If ``subreddits`` and ``redditors`` are\\n                provided, this will make a request equivalent to number of redditors\\n                multiplied by the number of subreddits.\\n\\n        :param pairs: A list of subreddit/redditor tuples.\\n\\n            .. note::\\n\\n                Required if ``subreddits``, ``redditors``, nor ``things`` are provided.\\n\\n        :param redditors: A list of redditors to return notes for. This parameter is\\n            used in tandem with ``subreddits`` to get notes from multiple subreddits for\\n            each of the provided redditors.\\n\\n            .. note::\\n\\n                Required if ``items`` or ``things`` is not provided or if ``subreddits``\\n                **is** provided.\\n\\n        :param subreddits: A list of subreddits to return notes for. This parameter is\\n            used in tandem with ``redditors`` to get notes for multiple redditors from\\n            each of the provided subreddits.\\n\\n            .. note::\\n\\n                Required if ``items`` or ``things`` is not provided or if ``redditors``\\n                **is** provided.\\n\\n        :param things: A list of comments and/or submissions to return notes for.\\n        :param generator_kwargs: Additional keyword arguments passed to the generator.\\n            This parameter is ignored when ``all_notes`` is ``False``.\\n\\n        :returns: A generator that yields the most recent :class:`.ModNote` (or ``None``\\n            if the user doesn\\'t have any notes) per entry in their relative order. If\\n            ``all_notes`` is ``True``, this will yield all notes for each entry.\\n\\n        .. note::\\n\\n            This method will merge the subreddits and redditors provided from ``pairs``,\\n            ``redditors``, ``subreddits``, and ``things``.\\n\\n        .. note::\\n\\n            This method accepts :class:`.Redditor` instances or redditor names and\\n            :class:`.Subreddit` instances or subreddit names where applicable.\\n\\n        For example, the latest note for u/spez in r/redditdev and r/test, and for\\n        u/bboe in r/redditdev can be iterated through like so:\\n\\n        .. code-block:: python\\n\\n            redditor = reddit.redditor(\"bboe\")\\n            subreddit = reddit.subreddit(\"redditdev\")\\n\\n            pairs = [(subreddit, \"spez\"), (\"test\", \"spez\"), (subreddit, redditor)]\\n\\n            for note in reddit.notes(pairs=pairs):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        For example, **all** the notes for u/spez and u/bboe in r/announcements,\\n        r/redditdev, and r/test can be iterated through like so:\\n\\n        .. code-block:: python\\n\\n            redditor = reddit.redditor(\"bboe\")\\n            subreddit = reddit.subreddit(\"redditdev\")\\n\\n            for note in reddit.notes(\\n                redditors=[\"spez\", redditor],\\n                subreddits=[\"announcements\", subreddit, \"test\"],\\n                all_notes=True,\\n            ):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        For example, the latest note for the authors of the last 5 comments and\\n        submissions from r/test can be iterated through like so:\\n\\n        .. code-block:: python\\n\\n            submissions = list(reddit.subreddit(\"test\").new(limit=5))\\n            comments = list(reddit.subreddit(\"test\").comments(limit=5))\\n\\n            for note in reddit.notes(things=submissions + comments):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        .. note::\\n\\n            Setting ``all_notes`` to ``True`` will make a request for each redditor and\\n            subreddit combination. The previous example will make 6 requests.\\n\\n        '\n    if pairs is None:\n        pairs = []\n    if redditors is None:\n        redditors = []\n    if subreddits is None:\n        subreddits = []\n    if things is None:\n        things = []\n    if not pairs + redditors + subreddits + things:\n        msg = \"Either the 'pairs', 'redditors', 'subreddits', or 'things' parameters must be provided.\"\n        raise TypeError(msg)\n    if len(redditors) * len(subreddits) == 0 and len(redditors) + len(subreddits) > 0:\n        raise TypeError(\"'redditors' must be non-empty if 'subreddits' is not empty.\" if len(subreddits) > 0 else \"'subreddits' must be non-empty if 'redditors' is not empty.\")\n    merged_redditors = []\n    merged_subreddits = []\n    items = pairs + [(subreddit, redditor) for redditor in set(redditors) for subreddit in set(subreddits)] + things\n    for item in items:\n        if isinstance(item, (Comment, Submission)):\n            merged_redditors.append(item.author.name)\n            merged_subreddits.append(item.subreddit.display_name)\n        elif isinstance(item, Tuple):\n            (subreddit, redditor) = item\n            merged_redditors.append(redditor)\n            merged_subreddits.append(subreddit)\n        else:\n            msg = f'Cannot get subreddit and author fields from type {type(item)}'\n            raise ValueError(msg)\n    return self._notes(all_notes, merged_redditors, merged_subreddits, **generator_kwargs)"
        ]
    },
    {
        "func_name": "things",
        "original": "def things(self, *things: ThingType, all_notes: Optional[bool]=None, **generator_kwargs: Any) -> Generator['praw.models.ModNote', None, None]:\n    \"\"\"Return notes associated with the author of a :class:`.Comment` or :class:`.Submission`.\n\n        :param things: One or more things to return notes on. Must be a\n            :class:`.Comment` or :class:`.Submission`.\n        :param all_notes: Whether to return all notes, or only the latest (default:\n            ``True`` if only one thing is provided otherwise ``False``).\n\n            .. note::\n\n                Setting this to ``True`` will result in a request for each thing.\n\n\n        :returns: A generator that yields the most recent :class:`.ModNote` (or ``None``\n            if the user doesn't have any notes) per entry in their relative order. If\n            ``all_notes`` is ``True``, this will yield all notes for each entry.\n\n        For example, to get the latest note for the authors of the top 25 submissions in\n        r/test:\n\n        .. code-block:: python\n\n            submissions = reddit.subreddit(\"test\").top(limit=25)\n            for note in reddit.notes.things(*submissions):\n                print(f\"{note.label}: {note.note}\")\n\n        For example, to get the latest note for the authors of the last 25 comments in\n        r/test:\n\n        .. code-block:: python\n\n            comments = reddit.subreddit(\"test\").comments(limit=25)\n            for note in reddit.notes.things(*comments):\n                print(f\"{note.label}: {note.note}\")\n\n        \"\"\"\n    subreddits = []\n    redditors = []\n    for thing in things:\n        subreddits.append(thing.subreddit)\n        redditors.append(thing.author)\n    if all_notes is None:\n        all_notes = len(things) == 1\n    return self._notes(all_notes, redditors, subreddits, **generator_kwargs)",
        "mutated": [
            "def things(self, *things: ThingType, all_notes: Optional[bool]=None, **generator_kwargs: Any) -> Generator['praw.models.ModNote', None, None]:\n    if False:\n        i = 10\n    'Return notes associated with the author of a :class:`.Comment` or :class:`.Submission`.\\n\\n        :param things: One or more things to return notes on. Must be a\\n            :class:`.Comment` or :class:`.Submission`.\\n        :param all_notes: Whether to return all notes, or only the latest (default:\\n            ``True`` if only one thing is provided otherwise ``False``).\\n\\n            .. note::\\n\\n                Setting this to ``True`` will result in a request for each thing.\\n\\n\\n        :returns: A generator that yields the most recent :class:`.ModNote` (or ``None``\\n            if the user doesn\\'t have any notes) per entry in their relative order. If\\n            ``all_notes`` is ``True``, this will yield all notes for each entry.\\n\\n        For example, to get the latest note for the authors of the top 25 submissions in\\n        r/test:\\n\\n        .. code-block:: python\\n\\n            submissions = reddit.subreddit(\"test\").top(limit=25)\\n            for note in reddit.notes.things(*submissions):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        For example, to get the latest note for the authors of the last 25 comments in\\n        r/test:\\n\\n        .. code-block:: python\\n\\n            comments = reddit.subreddit(\"test\").comments(limit=25)\\n            for note in reddit.notes.things(*comments):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        '\n    subreddits = []\n    redditors = []\n    for thing in things:\n        subreddits.append(thing.subreddit)\n        redditors.append(thing.author)\n    if all_notes is None:\n        all_notes = len(things) == 1\n    return self._notes(all_notes, redditors, subreddits, **generator_kwargs)",
            "def things(self, *things: ThingType, all_notes: Optional[bool]=None, **generator_kwargs: Any) -> Generator['praw.models.ModNote', None, None]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Return notes associated with the author of a :class:`.Comment` or :class:`.Submission`.\\n\\n        :param things: One or more things to return notes on. Must be a\\n            :class:`.Comment` or :class:`.Submission`.\\n        :param all_notes: Whether to return all notes, or only the latest (default:\\n            ``True`` if only one thing is provided otherwise ``False``).\\n\\n            .. note::\\n\\n                Setting this to ``True`` will result in a request for each thing.\\n\\n\\n        :returns: A generator that yields the most recent :class:`.ModNote` (or ``None``\\n            if the user doesn\\'t have any notes) per entry in their relative order. If\\n            ``all_notes`` is ``True``, this will yield all notes for each entry.\\n\\n        For example, to get the latest note for the authors of the top 25 submissions in\\n        r/test:\\n\\n        .. code-block:: python\\n\\n            submissions = reddit.subreddit(\"test\").top(limit=25)\\n            for note in reddit.notes.things(*submissions):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        For example, to get the latest note for the authors of the last 25 comments in\\n        r/test:\\n\\n        .. code-block:: python\\n\\n            comments = reddit.subreddit(\"test\").comments(limit=25)\\n            for note in reddit.notes.things(*comments):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        '\n    subreddits = []\n    redditors = []\n    for thing in things:\n        subreddits.append(thing.subreddit)\n        redditors.append(thing.author)\n    if all_notes is None:\n        all_notes = len(things) == 1\n    return self._notes(all_notes, redditors, subreddits, **generator_kwargs)",
            "def things(self, *things: ThingType, all_notes: Optional[bool]=None, **generator_kwargs: Any) -> Generator['praw.models.ModNote', None, None]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Return notes associated with the author of a :class:`.Comment` or :class:`.Submission`.\\n\\n        :param things: One or more things to return notes on. Must be a\\n            :class:`.Comment` or :class:`.Submission`.\\n        :param all_notes: Whether to return all notes, or only the latest (default:\\n            ``True`` if only one thing is provided otherwise ``False``).\\n\\n            .. note::\\n\\n                Setting this to ``True`` will result in a request for each thing.\\n\\n\\n        :returns: A generator that yields the most recent :class:`.ModNote` (or ``None``\\n            if the user doesn\\'t have any notes) per entry in their relative order. If\\n            ``all_notes`` is ``True``, this will yield all notes for each entry.\\n\\n        For example, to get the latest note for the authors of the top 25 submissions in\\n        r/test:\\n\\n        .. code-block:: python\\n\\n            submissions = reddit.subreddit(\"test\").top(limit=25)\\n            for note in reddit.notes.things(*submissions):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        For example, to get the latest note for the authors of the last 25 comments in\\n        r/test:\\n\\n        .. code-block:: python\\n\\n            comments = reddit.subreddit(\"test\").comments(limit=25)\\n            for note in reddit.notes.things(*comments):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        '\n    subreddits = []\n    redditors = []\n    for thing in things:\n        subreddits.append(thing.subreddit)\n        redditors.append(thing.author)\n    if all_notes is None:\n        all_notes = len(things) == 1\n    return self._notes(all_notes, redditors, subreddits, **generator_kwargs)",
            "def things(self, *things: ThingType, all_notes: Optional[bool]=None, **generator_kwargs: Any) -> Generator['praw.models.ModNote', None, None]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Return notes associated with the author of a :class:`.Comment` or :class:`.Submission`.\\n\\n        :param things: One or more things to return notes on. Must be a\\n            :class:`.Comment` or :class:`.Submission`.\\n        :param all_notes: Whether to return all notes, or only the latest (default:\\n            ``True`` if only one thing is provided otherwise ``False``).\\n\\n            .. note::\\n\\n                Setting this to ``True`` will result in a request for each thing.\\n\\n\\n        :returns: A generator that yields the most recent :class:`.ModNote` (or ``None``\\n            if the user doesn\\'t have any notes) per entry in their relative order. If\\n            ``all_notes`` is ``True``, this will yield all notes for each entry.\\n\\n        For example, to get the latest note for the authors of the top 25 submissions in\\n        r/test:\\n\\n        .. code-block:: python\\n\\n            submissions = reddit.subreddit(\"test\").top(limit=25)\\n            for note in reddit.notes.things(*submissions):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        For example, to get the latest note for the authors of the last 25 comments in\\n        r/test:\\n\\n        .. code-block:: python\\n\\n            comments = reddit.subreddit(\"test\").comments(limit=25)\\n            for note in reddit.notes.things(*comments):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        '\n    subreddits = []\n    redditors = []\n    for thing in things:\n        subreddits.append(thing.subreddit)\n        redditors.append(thing.author)\n    if all_notes is None:\n        all_notes = len(things) == 1\n    return self._notes(all_notes, redditors, subreddits, **generator_kwargs)",
            "def things(self, *things: ThingType, all_notes: Optional[bool]=None, **generator_kwargs: Any) -> Generator['praw.models.ModNote', None, None]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Return notes associated with the author of a :class:`.Comment` or :class:`.Submission`.\\n\\n        :param things: One or more things to return notes on. Must be a\\n            :class:`.Comment` or :class:`.Submission`.\\n        :param all_notes: Whether to return all notes, or only the latest (default:\\n            ``True`` if only one thing is provided otherwise ``False``).\\n\\n            .. note::\\n\\n                Setting this to ``True`` will result in a request for each thing.\\n\\n\\n        :returns: A generator that yields the most recent :class:`.ModNote` (or ``None``\\n            if the user doesn\\'t have any notes) per entry in their relative order. If\\n            ``all_notes`` is ``True``, this will yield all notes for each entry.\\n\\n        For example, to get the latest note for the authors of the top 25 submissions in\\n        r/test:\\n\\n        .. code-block:: python\\n\\n            submissions = reddit.subreddit(\"test\").top(limit=25)\\n            for note in reddit.notes.things(*submissions):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        For example, to get the latest note for the authors of the last 25 comments in\\n        r/test:\\n\\n        .. code-block:: python\\n\\n            comments = reddit.subreddit(\"test\").comments(limit=25)\\n            for note in reddit.notes.things(*comments):\\n                print(f\"{note.label}: {note.note}\")\\n\\n        '\n    subreddits = []\n    redditors = []\n    for thing in things:\n        subreddits.append(thing.subreddit)\n        redditors.append(thing.author)\n    if all_notes is None:\n        all_notes = len(things) == 1\n    return self._notes(all_notes, redditors, subreddits, **generator_kwargs)"
        ]
    }
]