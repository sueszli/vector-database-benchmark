[
    {
        "func_name": "test_basic",
        "original": "def test_basic():\n    t = BoostBuild.Tester(use_test_config=False)\n    t.write('jamroot.jam', 'exe a1 : a1.cpp : <conditional>@a1-rule ;\\nrule a1-rule ( properties * )\\n{\\n    if <variant>debug in $(properties)\\n    {\\n        return <define>OK ;\\n    }\\n}\\n\\nexe a2 : a2.cpp : <conditional>@$(__name__).a2-rule\\n    <variant>debug:<optimization>speed ;\\nrule a2-rule ( properties * )\\n{\\n    if <optimization>speed in $(properties)\\n    {\\n        return <define>OK ;\\n    }\\n}\\n\\nexe a3 : a3.cpp :\\n    <conditional>@$(__name__).a3-rule-1\\n    <conditional>@$(__name__).a3-rule-2 ;\\nrule a3-rule-1 ( properties * )\\n{\\n    if <optimization>speed in $(properties)\\n    {\\n        return <define>OK ;\\n    }\\n}\\nrule a3-rule-2 ( properties * )\\n{\\n    if <variant>debug in $(properties)\\n    {\\n        return <optimization>speed ;\\n    }\\n}\\n')\n    t.write('a1.cpp', '#ifdef OK\\nint main() {}\\n#endif\\n')\n    t.write('a2.cpp', '#ifdef OK\\nint main() {}\\n#endif\\n')\n    t.write('a3.cpp', '#ifdef OK\\nint main() {}\\n#endif\\n')\n    t.run_build_system()\n    t.expect_addition('bin/$toolset/debug*/a1.exe')\n    t.expect_addition('bin/$toolset/debug/optimization-speed*/a2.exe')\n    t.expect_addition('bin/$toolset/debug/optimization-speed*/a3.exe')\n    t.cleanup()",
        "mutated": [
            "def test_basic():\n    if False:\n        i = 10\n    t = BoostBuild.Tester(use_test_config=False)\n    t.write('jamroot.jam', 'exe a1 : a1.cpp : <conditional>@a1-rule ;\\nrule a1-rule ( properties * )\\n{\\n    if <variant>debug in $(properties)\\n    {\\n        return <define>OK ;\\n    }\\n}\\n\\nexe a2 : a2.cpp : <conditional>@$(__name__).a2-rule\\n    <variant>debug:<optimization>speed ;\\nrule a2-rule ( properties * )\\n{\\n    if <optimization>speed in $(properties)\\n    {\\n        return <define>OK ;\\n    }\\n}\\n\\nexe a3 : a3.cpp :\\n    <conditional>@$(__name__).a3-rule-1\\n    <conditional>@$(__name__).a3-rule-2 ;\\nrule a3-rule-1 ( properties * )\\n{\\n    if <optimization>speed in $(properties)\\n    {\\n        return <define>OK ;\\n    }\\n}\\nrule a3-rule-2 ( properties * )\\n{\\n    if <variant>debug in $(properties)\\n    {\\n        return <optimization>speed ;\\n    }\\n}\\n')\n    t.write('a1.cpp', '#ifdef OK\\nint main() {}\\n#endif\\n')\n    t.write('a2.cpp', '#ifdef OK\\nint main() {}\\n#endif\\n')\n    t.write('a3.cpp', '#ifdef OK\\nint main() {}\\n#endif\\n')\n    t.run_build_system()\n    t.expect_addition('bin/$toolset/debug*/a1.exe')\n    t.expect_addition('bin/$toolset/debug/optimization-speed*/a2.exe')\n    t.expect_addition('bin/$toolset/debug/optimization-speed*/a3.exe')\n    t.cleanup()",
            "def test_basic():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    t = BoostBuild.Tester(use_test_config=False)\n    t.write('jamroot.jam', 'exe a1 : a1.cpp : <conditional>@a1-rule ;\\nrule a1-rule ( properties * )\\n{\\n    if <variant>debug in $(properties)\\n    {\\n        return <define>OK ;\\n    }\\n}\\n\\nexe a2 : a2.cpp : <conditional>@$(__name__).a2-rule\\n    <variant>debug:<optimization>speed ;\\nrule a2-rule ( properties * )\\n{\\n    if <optimization>speed in $(properties)\\n    {\\n        return <define>OK ;\\n    }\\n}\\n\\nexe a3 : a3.cpp :\\n    <conditional>@$(__name__).a3-rule-1\\n    <conditional>@$(__name__).a3-rule-2 ;\\nrule a3-rule-1 ( properties * )\\n{\\n    if <optimization>speed in $(properties)\\n    {\\n        return <define>OK ;\\n    }\\n}\\nrule a3-rule-2 ( properties * )\\n{\\n    if <variant>debug in $(properties)\\n    {\\n        return <optimization>speed ;\\n    }\\n}\\n')\n    t.write('a1.cpp', '#ifdef OK\\nint main() {}\\n#endif\\n')\n    t.write('a2.cpp', '#ifdef OK\\nint main() {}\\n#endif\\n')\n    t.write('a3.cpp', '#ifdef OK\\nint main() {}\\n#endif\\n')\n    t.run_build_system()\n    t.expect_addition('bin/$toolset/debug*/a1.exe')\n    t.expect_addition('bin/$toolset/debug/optimization-speed*/a2.exe')\n    t.expect_addition('bin/$toolset/debug/optimization-speed*/a3.exe')\n    t.cleanup()",
            "def test_basic():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    t = BoostBuild.Tester(use_test_config=False)\n    t.write('jamroot.jam', 'exe a1 : a1.cpp : <conditional>@a1-rule ;\\nrule a1-rule ( properties * )\\n{\\n    if <variant>debug in $(properties)\\n    {\\n        return <define>OK ;\\n    }\\n}\\n\\nexe a2 : a2.cpp : <conditional>@$(__name__).a2-rule\\n    <variant>debug:<optimization>speed ;\\nrule a2-rule ( properties * )\\n{\\n    if <optimization>speed in $(properties)\\n    {\\n        return <define>OK ;\\n    }\\n}\\n\\nexe a3 : a3.cpp :\\n    <conditional>@$(__name__).a3-rule-1\\n    <conditional>@$(__name__).a3-rule-2 ;\\nrule a3-rule-1 ( properties * )\\n{\\n    if <optimization>speed in $(properties)\\n    {\\n        return <define>OK ;\\n    }\\n}\\nrule a3-rule-2 ( properties * )\\n{\\n    if <variant>debug in $(properties)\\n    {\\n        return <optimization>speed ;\\n    }\\n}\\n')\n    t.write('a1.cpp', '#ifdef OK\\nint main() {}\\n#endif\\n')\n    t.write('a2.cpp', '#ifdef OK\\nint main() {}\\n#endif\\n')\n    t.write('a3.cpp', '#ifdef OK\\nint main() {}\\n#endif\\n')\n    t.run_build_system()\n    t.expect_addition('bin/$toolset/debug*/a1.exe')\n    t.expect_addition('bin/$toolset/debug/optimization-speed*/a2.exe')\n    t.expect_addition('bin/$toolset/debug/optimization-speed*/a3.exe')\n    t.cleanup()",
            "def test_basic():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    t = BoostBuild.Tester(use_test_config=False)\n    t.write('jamroot.jam', 'exe a1 : a1.cpp : <conditional>@a1-rule ;\\nrule a1-rule ( properties * )\\n{\\n    if <variant>debug in $(properties)\\n    {\\n        return <define>OK ;\\n    }\\n}\\n\\nexe a2 : a2.cpp : <conditional>@$(__name__).a2-rule\\n    <variant>debug:<optimization>speed ;\\nrule a2-rule ( properties * )\\n{\\n    if <optimization>speed in $(properties)\\n    {\\n        return <define>OK ;\\n    }\\n}\\n\\nexe a3 : a3.cpp :\\n    <conditional>@$(__name__).a3-rule-1\\n    <conditional>@$(__name__).a3-rule-2 ;\\nrule a3-rule-1 ( properties * )\\n{\\n    if <optimization>speed in $(properties)\\n    {\\n        return <define>OK ;\\n    }\\n}\\nrule a3-rule-2 ( properties * )\\n{\\n    if <variant>debug in $(properties)\\n    {\\n        return <optimization>speed ;\\n    }\\n}\\n')\n    t.write('a1.cpp', '#ifdef OK\\nint main() {}\\n#endif\\n')\n    t.write('a2.cpp', '#ifdef OK\\nint main() {}\\n#endif\\n')\n    t.write('a3.cpp', '#ifdef OK\\nint main() {}\\n#endif\\n')\n    t.run_build_system()\n    t.expect_addition('bin/$toolset/debug*/a1.exe')\n    t.expect_addition('bin/$toolset/debug/optimization-speed*/a2.exe')\n    t.expect_addition('bin/$toolset/debug/optimization-speed*/a3.exe')\n    t.cleanup()",
            "def test_basic():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    t = BoostBuild.Tester(use_test_config=False)\n    t.write('jamroot.jam', 'exe a1 : a1.cpp : <conditional>@a1-rule ;\\nrule a1-rule ( properties * )\\n{\\n    if <variant>debug in $(properties)\\n    {\\n        return <define>OK ;\\n    }\\n}\\n\\nexe a2 : a2.cpp : <conditional>@$(__name__).a2-rule\\n    <variant>debug:<optimization>speed ;\\nrule a2-rule ( properties * )\\n{\\n    if <optimization>speed in $(properties)\\n    {\\n        return <define>OK ;\\n    }\\n}\\n\\nexe a3 : a3.cpp :\\n    <conditional>@$(__name__).a3-rule-1\\n    <conditional>@$(__name__).a3-rule-2 ;\\nrule a3-rule-1 ( properties * )\\n{\\n    if <optimization>speed in $(properties)\\n    {\\n        return <define>OK ;\\n    }\\n}\\nrule a3-rule-2 ( properties * )\\n{\\n    if <variant>debug in $(properties)\\n    {\\n        return <optimization>speed ;\\n    }\\n}\\n')\n    t.write('a1.cpp', '#ifdef OK\\nint main() {}\\n#endif\\n')\n    t.write('a2.cpp', '#ifdef OK\\nint main() {}\\n#endif\\n')\n    t.write('a3.cpp', '#ifdef OK\\nint main() {}\\n#endif\\n')\n    t.run_build_system()\n    t.expect_addition('bin/$toolset/debug*/a1.exe')\n    t.expect_addition('bin/$toolset/debug/optimization-speed*/a2.exe')\n    t.expect_addition('bin/$toolset/debug/optimization-speed*/a3.exe')\n    t.cleanup()"
        ]
    },
    {
        "func_name": "test_glob_in_indirect_conditional",
        "original": "def test_glob_in_indirect_conditional():\n    \"\"\"\n      Regression test: project-rules.glob rule run from inside an indirect\n    conditional should report an error as it depends on the 'currently loaded\n    project' concept and indirect conditional rules get called only after all\n    the project modules have already finished loading.\n\n    \"\"\"\n    t = BoostBuild.Tester(use_test_config=False)\n    t.write('jamroot.jam', 'use-project /library-example/foo : util/foo ;\\nbuild-project app ;\\n')\n    t.write('app/app.cpp', 'int main() {}\\n')\n    t.write('app/jamfile.jam', 'exe app : app.cpp /library-example/foo//bar ;')\n    t.write('util/foo/bar.cpp', '#ifdef _WIN32\\n__declspec(dllexport)\\n#endif\\nvoid foo() {}\\n')\n    t.write('util/foo/jamfile.jam', 'rule print-my-sources ( properties * )\\n{\\n    ECHO My sources: ;\\n    ECHO [ glob *.cpp ] ;\\n}\\nlib bar : bar.cpp : <conditional>@print-my-sources ;\\n')\n    t.run_build_system(status=1)\n    t.expect_output_lines(['My sources:', 'bar.cpp'], False)\n    t.expect_output_lines('error: Reference to the project currently being loaded requested when there was no project module being loaded.')\n    t.cleanup()",
        "mutated": [
            "def test_glob_in_indirect_conditional():\n    if False:\n        i = 10\n    \"\\n      Regression test: project-rules.glob rule run from inside an indirect\\n    conditional should report an error as it depends on the 'currently loaded\\n    project' concept and indirect conditional rules get called only after all\\n    the project modules have already finished loading.\\n\\n    \"\n    t = BoostBuild.Tester(use_test_config=False)\n    t.write('jamroot.jam', 'use-project /library-example/foo : util/foo ;\\nbuild-project app ;\\n')\n    t.write('app/app.cpp', 'int main() {}\\n')\n    t.write('app/jamfile.jam', 'exe app : app.cpp /library-example/foo//bar ;')\n    t.write('util/foo/bar.cpp', '#ifdef _WIN32\\n__declspec(dllexport)\\n#endif\\nvoid foo() {}\\n')\n    t.write('util/foo/jamfile.jam', 'rule print-my-sources ( properties * )\\n{\\n    ECHO My sources: ;\\n    ECHO [ glob *.cpp ] ;\\n}\\nlib bar : bar.cpp : <conditional>@print-my-sources ;\\n')\n    t.run_build_system(status=1)\n    t.expect_output_lines(['My sources:', 'bar.cpp'], False)\n    t.expect_output_lines('error: Reference to the project currently being loaded requested when there was no project module being loaded.')\n    t.cleanup()",
            "def test_glob_in_indirect_conditional():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n      Regression test: project-rules.glob rule run from inside an indirect\\n    conditional should report an error as it depends on the 'currently loaded\\n    project' concept and indirect conditional rules get called only after all\\n    the project modules have already finished loading.\\n\\n    \"\n    t = BoostBuild.Tester(use_test_config=False)\n    t.write('jamroot.jam', 'use-project /library-example/foo : util/foo ;\\nbuild-project app ;\\n')\n    t.write('app/app.cpp', 'int main() {}\\n')\n    t.write('app/jamfile.jam', 'exe app : app.cpp /library-example/foo//bar ;')\n    t.write('util/foo/bar.cpp', '#ifdef _WIN32\\n__declspec(dllexport)\\n#endif\\nvoid foo() {}\\n')\n    t.write('util/foo/jamfile.jam', 'rule print-my-sources ( properties * )\\n{\\n    ECHO My sources: ;\\n    ECHO [ glob *.cpp ] ;\\n}\\nlib bar : bar.cpp : <conditional>@print-my-sources ;\\n')\n    t.run_build_system(status=1)\n    t.expect_output_lines(['My sources:', 'bar.cpp'], False)\n    t.expect_output_lines('error: Reference to the project currently being loaded requested when there was no project module being loaded.')\n    t.cleanup()",
            "def test_glob_in_indirect_conditional():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n      Regression test: project-rules.glob rule run from inside an indirect\\n    conditional should report an error as it depends on the 'currently loaded\\n    project' concept and indirect conditional rules get called only after all\\n    the project modules have already finished loading.\\n\\n    \"\n    t = BoostBuild.Tester(use_test_config=False)\n    t.write('jamroot.jam', 'use-project /library-example/foo : util/foo ;\\nbuild-project app ;\\n')\n    t.write('app/app.cpp', 'int main() {}\\n')\n    t.write('app/jamfile.jam', 'exe app : app.cpp /library-example/foo//bar ;')\n    t.write('util/foo/bar.cpp', '#ifdef _WIN32\\n__declspec(dllexport)\\n#endif\\nvoid foo() {}\\n')\n    t.write('util/foo/jamfile.jam', 'rule print-my-sources ( properties * )\\n{\\n    ECHO My sources: ;\\n    ECHO [ glob *.cpp ] ;\\n}\\nlib bar : bar.cpp : <conditional>@print-my-sources ;\\n')\n    t.run_build_system(status=1)\n    t.expect_output_lines(['My sources:', 'bar.cpp'], False)\n    t.expect_output_lines('error: Reference to the project currently being loaded requested when there was no project module being loaded.')\n    t.cleanup()",
            "def test_glob_in_indirect_conditional():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n      Regression test: project-rules.glob rule run from inside an indirect\\n    conditional should report an error as it depends on the 'currently loaded\\n    project' concept and indirect conditional rules get called only after all\\n    the project modules have already finished loading.\\n\\n    \"\n    t = BoostBuild.Tester(use_test_config=False)\n    t.write('jamroot.jam', 'use-project /library-example/foo : util/foo ;\\nbuild-project app ;\\n')\n    t.write('app/app.cpp', 'int main() {}\\n')\n    t.write('app/jamfile.jam', 'exe app : app.cpp /library-example/foo//bar ;')\n    t.write('util/foo/bar.cpp', '#ifdef _WIN32\\n__declspec(dllexport)\\n#endif\\nvoid foo() {}\\n')\n    t.write('util/foo/jamfile.jam', 'rule print-my-sources ( properties * )\\n{\\n    ECHO My sources: ;\\n    ECHO [ glob *.cpp ] ;\\n}\\nlib bar : bar.cpp : <conditional>@print-my-sources ;\\n')\n    t.run_build_system(status=1)\n    t.expect_output_lines(['My sources:', 'bar.cpp'], False)\n    t.expect_output_lines('error: Reference to the project currently being loaded requested when there was no project module being loaded.')\n    t.cleanup()",
            "def test_glob_in_indirect_conditional():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n      Regression test: project-rules.glob rule run from inside an indirect\\n    conditional should report an error as it depends on the 'currently loaded\\n    project' concept and indirect conditional rules get called only after all\\n    the project modules have already finished loading.\\n\\n    \"\n    t = BoostBuild.Tester(use_test_config=False)\n    t.write('jamroot.jam', 'use-project /library-example/foo : util/foo ;\\nbuild-project app ;\\n')\n    t.write('app/app.cpp', 'int main() {}\\n')\n    t.write('app/jamfile.jam', 'exe app : app.cpp /library-example/foo//bar ;')\n    t.write('util/foo/bar.cpp', '#ifdef _WIN32\\n__declspec(dllexport)\\n#endif\\nvoid foo() {}\\n')\n    t.write('util/foo/jamfile.jam', 'rule print-my-sources ( properties * )\\n{\\n    ECHO My sources: ;\\n    ECHO [ glob *.cpp ] ;\\n}\\nlib bar : bar.cpp : <conditional>@print-my-sources ;\\n')\n    t.run_build_system(status=1)\n    t.expect_output_lines(['My sources:', 'bar.cpp'], False)\n    t.expect_output_lines('error: Reference to the project currently being loaded requested when there was no project module being loaded.')\n    t.cleanup()"
        ]
    }
]