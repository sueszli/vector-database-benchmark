"""Read/write .osm formatted XML files."""
import bz2
import xml.sax
from pathlib import Path
from warnings import warn
from xml.etree import ElementTree as ET
import networkx as nx
import numpy as np
import pandas as pd
from . import settings
from . import utils
from . import utils_graph
from ._version import __version__

class _OSMContentHandler(xml.sax.handler.ContentHandler):
    """
    SAX content handler for OSM XML.

    Used to build an Overpass-like response JSON object in self.object. For
    format notes, see https://wiki.openstreetmap.org/wiki/OSM_XML and
    https://overpass-api.de
    """

    def __init__(self):
        if False:
            i = 10
            return i + 15
        self._element = None
        self.object = {'elements': []}

    def startElement(self, name, attrs):
        if False:
            for i in range(10):
                print('nop')
        if name == 'osm':
            self.object.update({k: v for (k, v) in attrs.items() if k in {'version', 'generator'}})
        elif name in {'node', 'way'}:
            self._element = dict(type=name, tags={}, nodes=[], **attrs)
            self._element.update({k: float(v) for (k, v) in attrs.items() if k in {'lat', 'lon'}})
            self._element.update({k: int(v) for (k, v) in attrs.items() if k in {'id', 'uid', 'version', 'changeset'}})
        elif name == 'relation':
            self._element = dict(type=name, tags={}, members=[], **attrs)
            self._element.update({k: int(v) for (k, v) in attrs.items() if k in {'id', 'uid', 'version', 'changeset'}})
        elif name == 'tag':
            self._element['tags'].update({attrs['k']: attrs['v']})
        elif name == 'nd':
            self._element['nodes'].append(int(attrs['ref']))
        elif name == 'member':
            self._element['members'].append({k: int(v) if k == 'ref' else v for (k, v) in attrs.items()})

    def endElement(self, name):
        if False:
            i = 10
            return i + 15
        if name in {'node', 'way', 'relation'}:
            self.object['elements'].append(self._element)

def _overpass_json_from_file(filepath):
    if False:
        for i in range(10):
            print('nop')
    '\n    Read OSM XML from file and return Overpass-like JSON.\n\n    Parameters\n    ----------\n    filepath : string or pathlib.Path\n        path to file containing OSM XML data\n\n    Returns\n    -------\n    OSMContentHandler object\n    '

    def _opener(filepath):
        if False:
            while True:
                i = 10
        if filepath.suffix == '.bz2':
            return bz2.BZ2File(filepath)
        return filepath.open()
    with _opener(Path(filepath)) as f:
        root_attrs = ET.parse(f).getroot().attrib
        if 'generator' in root_attrs and 'OSMnx' in root_attrs['generator']:
            warn('The XML file you are loading appears to have been generated by OSMnx: this use case is not supported and may not behave as expected. To save/load graphs to/from disk for later use in OSMnx, use the `io.save_graphml` and `io.load_graphml` functions instead. Refer to the documentation for details.', stacklevel=2)
    with _opener(Path(filepath)) as f:
        handler = _OSMContentHandler()
        xml.sax.parse(f, handler)
        return handler.object

def save_graph_xml(data, filepath=None, node_tags=settings.osm_xml_node_tags, node_attrs=settings.osm_xml_node_attrs, edge_tags=settings.osm_xml_way_tags, edge_attrs=settings.osm_xml_way_attrs, oneway=False, merge_edges=True, edge_tag_aggs=None, api_version=0.6, precision=6):
    if False:
        print('Hello World!')
    '\n    Do not use: deprecated.\n\n    The `save_graph_xml` has moved from the `osm_xml` module to the `io`\n    module. `osm_xml.save_graph_xml` has been deprecated and will be removed\n    in a future release. Access the function via the `io` module instead.\n\n    Parameters\n    ----------\n    data : networkx.multidigraph\n        do not use, deprecated\n    filepath : string or pathlib.Path\n        do not use, deprecated\n    node_tags : list\n        do not use, deprecated\n    node_attrs: list\n        do not use, deprecated\n    edge_tags : list\n        do not use, deprecated\n    edge_attrs : list\n        do not use, deprecated\n    oneway : bool\n        do not use, deprecated\n    merge_edges : bool\n        do not use, deprecated\n    edge_tag_aggs : list of length-2 string tuples\n        do not use, deprecated\n    api_version : float\n        do not use, deprecated\n    precision : int\n        do not use, deprecated\n\n    Returns\n    -------\n    None\n    '
    warn('The save_graph_xml function has moved from the osm_xml module to the io module.  osm_xml.save_graph_xml has been deprecated and will be removed in a  future release. Access the function via the io module instead.', stacklevel=2)
    _save_graph_xml(data, filepath, node_tags, node_attrs, edge_tags, edge_attrs, oneway, merge_edges, edge_tag_aggs, api_version, precision)

def _save_graph_xml(data, filepath=None, node_tags=settings.osm_xml_node_tags, node_attrs=settings.osm_xml_node_attrs, edge_tags=settings.osm_xml_way_tags, edge_attrs=settings.osm_xml_way_attrs, oneway=False, merge_edges=True, edge_tag_aggs=None, api_version=0.6, precision=6):
    if False:
        while True:
            i = 10
    '\n    Save graph to disk as an OSM-formatted XML .osm file.\n\n    Parameters\n    ----------\n    data : networkx multi(di)graph OR a length 2 iterable of nodes/edges\n        geopandas GeoDataFrames\n    filepath : string or pathlib.Path\n        path to the .osm file including extension. if None, use default data\n        folder + graph.osm\n    node_tags : list\n        osm node tags to include in output OSM XML\n    node_attrs: list\n        osm node attributes to include in output OSM XML\n    edge_tags : list\n        osm way tags to include in output OSM XML\n    edge_attrs : list\n        osm way attributes to include in output OSM XML\n    oneway : bool\n        the default oneway value used to fill this tag where missing\n    merge_edges : bool\n        if True merges graph edges such that each OSM way has one entry\n        and one entry only in the OSM XML. Otherwise, every OSM way\n        will have a separate entry for each node pair it contains.\n    edge_tag_aggs : list of length-2 string tuples\n        useful only if merge_edges is True, this argument allows the user\n        to specify edge attributes to aggregate such that the merged\n        OSM way entry tags accurately represent the sum total of\n        their component edge attributes. For example, if the user\n        wants the OSM way to have a "length" attribute, the user must\n        specify `edge_tag_aggs=[(\'length\', \'sum\')]` in order to tell\n        this method to aggregate the lengths of the individual\n        component edges. Otherwise, the length attribute will simply\n        reflect the length of the first edge associated with the way.\n    api_version : float\n        OpenStreetMap API version to write to the XML file header\n    precision : int\n        number of decimal places to round latitude and longitude values\n\n    Returns\n    -------\n    None\n    '
    if filepath is None:
        filepath = Path(settings.data_folder) / 'graph.osm'
    else:
        filepath = Path(filepath)
    filepath.parent.mkdir(parents=True, exist_ok=True)
    if not settings.all_oneway:
        warn('For the `save_graph_xml` function to behave properly, the graph must have been created with `ox.settings.all_oneway=True`.', stacklevel=2)
    try:
        (gdf_nodes, gdf_edges) = data
    except ValueError:
        (gdf_nodes, gdf_edges) = utils_graph.graph_to_gdfs(data, node_geometry=False, fill_edge_geometry=False)
    gdf_nodes.rename(columns={'x': 'lon', 'y': 'lat'}, inplace=True)
    gdf_nodes['lon'] = gdf_nodes['lon'].round(precision)
    gdf_nodes['lat'] = gdf_nodes['lat'].round(precision)
    gdf_nodes = gdf_nodes.reset_index().rename(columns={'osmid': 'id'})
    if 'id' in gdf_edges.columns:
        gdf_edges = gdf_edges[[col for col in gdf_edges if col != 'id']]
    if 'uniqueid' in gdf_edges.columns:
        gdf_edges = gdf_edges.rename(columns={'uniqueid': 'id'})
    else:
        gdf_edges = gdf_edges.reset_index().reset_index().rename(columns={'index': 'id'})
    for table in (gdf_nodes, gdf_edges):
        table['uid'] = '1'
        table['user'] = 'OSMnx'
        table['version'] = '1'
        table['changeset'] = '1'
        table['timestamp'] = utils.ts(template='{:%Y-%m-%dT%H:%M:%SZ}')
    if 'oneway' in gdf_edges.columns:
        gdf_edges.loc[pd.isnull(gdf_edges['oneway']), 'oneway'] = oneway
        gdf_edges.loc[:, 'oneway'] = gdf_edges['oneway'].astype(str)
        gdf_edges.loc[:, 'oneway'] = gdf_edges['oneway'].str.replace('False', 'no').replace('True', 'yes')
    root = ET.Element('osm', attrib={'version': str(api_version), 'generator': f'OSMnx {__version__}'})
    root = _append_nodes_xml_tree(root, gdf_nodes, node_attrs, node_tags)
    root = _append_edges_xml_tree(root, gdf_edges, edge_attrs, edge_tags, edge_tag_aggs, merge_edges)
    ET.ElementTree(root).write(filepath, encoding='utf-8', xml_declaration=True)
    utils.log(f'Saved graph as .osm file at {filepath!r}')

def _append_nodes_xml_tree(root, gdf_nodes, node_attrs, node_tags):
    if False:
        while True:
            i = 10
    '\n    Append nodes to an XML tree.\n\n    Parameters\n    ----------\n    root : ElementTree.Element\n        xml tree\n    gdf_nodes : geopandas.GeoDataFrame\n        GeoDataFrame of graph nodes\n    node_attrs : list\n        osm way attributes to include in output OSM XML\n    node_tags : list\n        osm way tags to include in output OSM XML\n\n    Returns\n    -------\n    root : ElementTree.Element\n        xml tree with nodes appended\n    '
    for (_, row) in gdf_nodes.iterrows():
        row_str = row.dropna().astype(str)
        node = ET.SubElement(root, 'node', attrib=row_str[node_attrs].to_dict())
        for tag in node_tags:
            if tag in row_str:
                ET.SubElement(node, 'tag', attrib={'k': tag, 'v': row_str[tag]})
    return root

def _create_way_for_each_edge(root, gdf_edges, edge_attrs, edge_tags):
    if False:
        i = 10
        return i + 15
    '\n    Append a new way to an empty XML tree graph for each edge in way.\n\n    This will generate separate OSM ways for each network edge, even if the\n    edges are all part of the same original OSM way. As such, each way will be\n    composed of two nodes, and there will be many ways with the same OSM ID.\n    This does not conform to the OSM XML schema standard, but the data will\n    still comprise a valid network and will be readable by most OSM tools.\n\n    Parameters\n    ----------\n    root : ElementTree.Element\n        an empty XML tree\n    gdf_edges : geopandas.GeoDataFrame\n        GeoDataFrame of graph edges\n    edge_attrs : list\n        osm way attributes to include in output OSM XML\n    edge_tags : list\n        osm way tags to include in output OSM XML\n    '
    for (_, row) in gdf_edges.iterrows():
        row_str = row.dropna().astype(str)
        edge = ET.SubElement(root, 'way', attrib=row_str[edge_attrs].to_dict())
        ET.SubElement(edge, 'nd', attrib={'ref': row_str['u']})
        ET.SubElement(edge, 'nd', attrib={'ref': row_str['v']})
        for tag in edge_tags:
            if tag in row_str:
                ET.SubElement(edge, 'tag', attrib={'k': tag, 'v': row_str[tag]})

def _append_merged_edge_attrs(xml_edge, sample_edge, all_edges_df, edge_tags, edge_tag_aggs):
    if False:
        return 10
    "\n    Extract edge attributes and append to XML edge.\n\n    Parameters\n    ----------\n    xml_edge : ElementTree.SubElement\n        XML representation of an output graph edge\n    sample_edge: pandas.Series\n        sample row from the the dataframe of way edges\n    all_edges_df: pandas.DataFrame\n        a dataframe with one row for each edge in an OSM way\n    edge_tags : list\n        osm way tags to include in output OSM XML\n    edge_tag_aggs : list of length-2 string tuples\n        useful only if merge_edges is True, this argument allows the user to\n        specify edge attributes to aggregate such that the merged OSM way\n        entry tags accurately represent the sum total of their component edge\n        attributes. For example if the user wants the OSM way to have a length\n        attribute, the user must specify `edge_tag_aggs=[('length', 'sum')]`\n        to tell this method to aggregate the lengths of the individual\n        component edges. Otherwise, the length attribute will simply reflect\n        the length of the first edge associated with the way.\n\n    "
    if edge_tag_aggs is None:
        for tag in edge_tags:
            if tag in sample_edge:
                ET.SubElement(xml_edge, 'tag', attrib={'k': tag, 'v': sample_edge[tag]})
    else:
        for tag in edge_tags:
            if tag in sample_edge and tag not in (t for (t, agg) in edge_tag_aggs):
                ET.SubElement(xml_edge, 'tag', attrib={'k': tag, 'v': sample_edge[tag]})
        for (tag, agg) in edge_tag_aggs:
            if tag in all_edges_df.columns:
                ET.SubElement(xml_edge, 'tag', attrib={'k': tag, 'v': str(all_edges_df[tag].aggregate(agg))})

def _append_nodes_as_edge_attrs(xml_edge, sample_edge, all_edges_df):
    if False:
        while True:
            i = 10
    '\n    Extract list of ordered nodes and append as attributes of XML edge.\n\n    Parameters\n    ----------\n    xml_edge : ElementTree.SubElement\n        XML representation of an output graph edge\n    sample_edge: pandas.Series\n        sample row from the the dataframe of way edges\n    all_edges_df: pandas.DataFrame\n        a dataframe with one row for each edge in an OSM way\n    '
    if len(all_edges_df) == 1:
        ET.SubElement(xml_edge, 'nd', attrib={'ref': sample_edge['u']})
        ET.SubElement(xml_edge, 'nd', attrib={'ref': sample_edge['v']})
    else:
        try:
            ordered_nodes = _get_unique_nodes_ordered_from_way(all_edges_df)
        except nx.NetworkXUnfeasible:
            first_node = all_edges_df.iloc[0]['u']
            ordered_nodes = _get_unique_nodes_ordered_from_way(all_edges_df.iloc[1:])
            ordered_nodes = [first_node] + ordered_nodes
        for node in ordered_nodes:
            ET.SubElement(xml_edge, 'nd', attrib={'ref': str(node)})

def _append_edges_xml_tree(root, gdf_edges, edge_attrs, edge_tags, edge_tag_aggs, merge_edges):
    if False:
        print('Hello World!')
    '\n    Append edges to an XML tree.\n\n    Parameters\n    ----------\n    root : ElementTree.Element\n        xml tree\n    gdf_edges : geopandas.GeoDataFrame\n        GeoDataFrame of graph edges\n    edge_attrs : list\n        osm way attributes to include in output OSM XML\n    edge_tags : list\n        osm way tags to include in output OSM XML\n    edge_tag_aggs : list of length-2 string tuples\n        useful only if merge_edges is True, this argument allows the user\n        to specify edge attributes to aggregate such that the merged\n        OSM way entry tags accurately represent the sum total of\n        their component edge attributes. For example, if the user\n        wants the OSM way to have a "length" attribute, the user must\n        specify `edge_tag_aggs=[(\'length\', \'sum\')]` in order to tell\n        this method to aggregate the lengths of the individual\n        component edges. Otherwise, the length attribute will simply\n        reflect the length of the first edge associated with the way.\n    merge_edges : bool\n        if True merges graph edges such that each OSM way has one entry\n        and one entry only in the OSM XML. Otherwise, every OSM way\n        will have a separate entry for each node pair it contains.\n\n    Returns\n    -------\n    root : ElementTree.Element\n        XML tree with edges appended\n    '
    gdf_edges.reset_index(inplace=True)
    if merge_edges:
        for (_, all_way_edges) in gdf_edges.groupby('id'):
            first = all_way_edges.iloc[0].dropna().astype(str)
            edge = ET.SubElement(root, 'way', attrib=first[edge_attrs].dropna().to_dict())
            _append_nodes_as_edge_attrs(xml_edge=edge, sample_edge=first, all_edges_df=all_way_edges)
            _append_merged_edge_attrs(xml_edge=edge, sample_edge=first, edge_tags=edge_tags, edge_tag_aggs=edge_tag_aggs, all_edges_df=all_way_edges)
    else:
        _create_way_for_each_edge(root=root, gdf_edges=gdf_edges, edge_attrs=edge_attrs, edge_tags=edge_tags)
    return root

def _get_unique_nodes_ordered_from_way(df_way_edges):
    if False:
        for i in range(10):
            print('nop')
    "\n    Recover original node order from edges associated with a single OSM way.\n\n    Parameters\n    ----------\n    df_way_edges : pandas.DataFrame\n        Dataframe containing columns 'u' and 'v' corresponding to\n        origin/destination nodes.\n\n    Returns\n    -------\n    unique_ordered_nodes : list\n        An ordered list of unique node IDs. If the edges do not all connect\n        (e.g. [(1, 2), (2,3), (10, 11), (11, 12), (12, 13)]), then this method\n        will return only those nodes associated with the largest component of\n        connected edges, even if subsequent connected chunks are contain more\n        total nodes. This ensures a proper topological representation of nodes\n        in the XML way records because if there are unconnected components,\n        the sorting algorithm cannot recover their original order. We would\n        not likely ever encounter this kind of disconnected structure of nodes\n        within a given way, but it is not explicitly forbidden in the OSM XML\n        design schema.\n    "
    G = nx.MultiDiGraph()
    df_way_edges.reset_index(inplace=True)
    all_nodes = list(df_way_edges['u'].values) + list(df_way_edges['v'].values)
    G.add_nodes_from(all_nodes)
    G.add_edges_from(df_way_edges[['u', 'v']].values)
    H = utils_graph.get_largest_component(G, strongly=False)
    unique_ordered_nodes = list(nx.topological_sort(H))
    num_unique_nodes = len(np.unique(all_nodes))
    if len(unique_ordered_nodes) < num_unique_nodes:
        utils.log(f'Recovered order for {len(unique_ordered_nodes)} of {num_unique_nodes} nodes')
    return unique_ordered_nodes