[
    {
        "func_name": "fix_rpath",
        "original": "def fix_rpath(PATH):\n    \"\"\"FIX broken @rpath on Qt, PyQt, and /usr/local/ dependencies with no @rpath\"\"\"\n    duplicate_path = os.path.join(PATH, 'lib', 'openshot_qt')\n    if os.path.exists(duplicate_path):\n        shutil.rmtree(duplicate_path)\n    for (root, dirs, files) in os.walk(PATH):\n        for basename in files:\n            file_path = os.path.join(root, basename)\n            relative_path = os.path.relpath(root, PATH)\n            if os.path.splitext(file_path)[-1] in non_executables or basename.startswith('.') or 'profiles' in file_path:\n                continue\n            executable_path = os.path.join('@executable_path', relative_path, basename)\n            if relative_path == '.':\n                executable_path = os.path.join('@executable_path', basename)\n            call(['install_name_tool', file_path, '-id', executable_path])\n            raw_output = subprocess.Popen(['oTool', '-L', file_path], stdout=subprocess.PIPE).communicate()[0].decode('utf-8')\n            for output in raw_output.split('\\n')[1:-1]:\n                if output and 'is not an object file' not in output and ('.o):' not in output):\n                    dependency_path = output.split('\\t')[1].split(' ')[0]\n                    (dependency_base_path, dependency_name) = os.path.split(dependency_path)\n                    if '/usr/local' in dependency_path or '@rpath' in dependency_path:\n                        dependency_exe_path = os.path.join('@executable_path', dependency_name)\n                        if not os.path.exists(os.path.join(PATH, dependency_name)):\n                            print('ERROR: /usr/local PATH not found in EXE folder: %s' % dependency_path)\n                        else:\n                            call(['install_name_tool', file_path, '-change', dependency_path, dependency_exe_path])",
        "mutated": [
            "def fix_rpath(PATH):\n    if False:\n        i = 10\n    'FIX broken @rpath on Qt, PyQt, and /usr/local/ dependencies with no @rpath'\n    duplicate_path = os.path.join(PATH, 'lib', 'openshot_qt')\n    if os.path.exists(duplicate_path):\n        shutil.rmtree(duplicate_path)\n    for (root, dirs, files) in os.walk(PATH):\n        for basename in files:\n            file_path = os.path.join(root, basename)\n            relative_path = os.path.relpath(root, PATH)\n            if os.path.splitext(file_path)[-1] in non_executables or basename.startswith('.') or 'profiles' in file_path:\n                continue\n            executable_path = os.path.join('@executable_path', relative_path, basename)\n            if relative_path == '.':\n                executable_path = os.path.join('@executable_path', basename)\n            call(['install_name_tool', file_path, '-id', executable_path])\n            raw_output = subprocess.Popen(['oTool', '-L', file_path], stdout=subprocess.PIPE).communicate()[0].decode('utf-8')\n            for output in raw_output.split('\\n')[1:-1]:\n                if output and 'is not an object file' not in output and ('.o):' not in output):\n                    dependency_path = output.split('\\t')[1].split(' ')[0]\n                    (dependency_base_path, dependency_name) = os.path.split(dependency_path)\n                    if '/usr/local' in dependency_path or '@rpath' in dependency_path:\n                        dependency_exe_path = os.path.join('@executable_path', dependency_name)\n                        if not os.path.exists(os.path.join(PATH, dependency_name)):\n                            print('ERROR: /usr/local PATH not found in EXE folder: %s' % dependency_path)\n                        else:\n                            call(['install_name_tool', file_path, '-change', dependency_path, dependency_exe_path])",
            "def fix_rpath(PATH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'FIX broken @rpath on Qt, PyQt, and /usr/local/ dependencies with no @rpath'\n    duplicate_path = os.path.join(PATH, 'lib', 'openshot_qt')\n    if os.path.exists(duplicate_path):\n        shutil.rmtree(duplicate_path)\n    for (root, dirs, files) in os.walk(PATH):\n        for basename in files:\n            file_path = os.path.join(root, basename)\n            relative_path = os.path.relpath(root, PATH)\n            if os.path.splitext(file_path)[-1] in non_executables or basename.startswith('.') or 'profiles' in file_path:\n                continue\n            executable_path = os.path.join('@executable_path', relative_path, basename)\n            if relative_path == '.':\n                executable_path = os.path.join('@executable_path', basename)\n            call(['install_name_tool', file_path, '-id', executable_path])\n            raw_output = subprocess.Popen(['oTool', '-L', file_path], stdout=subprocess.PIPE).communicate()[0].decode('utf-8')\n            for output in raw_output.split('\\n')[1:-1]:\n                if output and 'is not an object file' not in output and ('.o):' not in output):\n                    dependency_path = output.split('\\t')[1].split(' ')[0]\n                    (dependency_base_path, dependency_name) = os.path.split(dependency_path)\n                    if '/usr/local' in dependency_path or '@rpath' in dependency_path:\n                        dependency_exe_path = os.path.join('@executable_path', dependency_name)\n                        if not os.path.exists(os.path.join(PATH, dependency_name)):\n                            print('ERROR: /usr/local PATH not found in EXE folder: %s' % dependency_path)\n                        else:\n                            call(['install_name_tool', file_path, '-change', dependency_path, dependency_exe_path])",
            "def fix_rpath(PATH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'FIX broken @rpath on Qt, PyQt, and /usr/local/ dependencies with no @rpath'\n    duplicate_path = os.path.join(PATH, 'lib', 'openshot_qt')\n    if os.path.exists(duplicate_path):\n        shutil.rmtree(duplicate_path)\n    for (root, dirs, files) in os.walk(PATH):\n        for basename in files:\n            file_path = os.path.join(root, basename)\n            relative_path = os.path.relpath(root, PATH)\n            if os.path.splitext(file_path)[-1] in non_executables or basename.startswith('.') or 'profiles' in file_path:\n                continue\n            executable_path = os.path.join('@executable_path', relative_path, basename)\n            if relative_path == '.':\n                executable_path = os.path.join('@executable_path', basename)\n            call(['install_name_tool', file_path, '-id', executable_path])\n            raw_output = subprocess.Popen(['oTool', '-L', file_path], stdout=subprocess.PIPE).communicate()[0].decode('utf-8')\n            for output in raw_output.split('\\n')[1:-1]:\n                if output and 'is not an object file' not in output and ('.o):' not in output):\n                    dependency_path = output.split('\\t')[1].split(' ')[0]\n                    (dependency_base_path, dependency_name) = os.path.split(dependency_path)\n                    if '/usr/local' in dependency_path or '@rpath' in dependency_path:\n                        dependency_exe_path = os.path.join('@executable_path', dependency_name)\n                        if not os.path.exists(os.path.join(PATH, dependency_name)):\n                            print('ERROR: /usr/local PATH not found in EXE folder: %s' % dependency_path)\n                        else:\n                            call(['install_name_tool', file_path, '-change', dependency_path, dependency_exe_path])",
            "def fix_rpath(PATH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'FIX broken @rpath on Qt, PyQt, and /usr/local/ dependencies with no @rpath'\n    duplicate_path = os.path.join(PATH, 'lib', 'openshot_qt')\n    if os.path.exists(duplicate_path):\n        shutil.rmtree(duplicate_path)\n    for (root, dirs, files) in os.walk(PATH):\n        for basename in files:\n            file_path = os.path.join(root, basename)\n            relative_path = os.path.relpath(root, PATH)\n            if os.path.splitext(file_path)[-1] in non_executables or basename.startswith('.') or 'profiles' in file_path:\n                continue\n            executable_path = os.path.join('@executable_path', relative_path, basename)\n            if relative_path == '.':\n                executable_path = os.path.join('@executable_path', basename)\n            call(['install_name_tool', file_path, '-id', executable_path])\n            raw_output = subprocess.Popen(['oTool', '-L', file_path], stdout=subprocess.PIPE).communicate()[0].decode('utf-8')\n            for output in raw_output.split('\\n')[1:-1]:\n                if output and 'is not an object file' not in output and ('.o):' not in output):\n                    dependency_path = output.split('\\t')[1].split(' ')[0]\n                    (dependency_base_path, dependency_name) = os.path.split(dependency_path)\n                    if '/usr/local' in dependency_path or '@rpath' in dependency_path:\n                        dependency_exe_path = os.path.join('@executable_path', dependency_name)\n                        if not os.path.exists(os.path.join(PATH, dependency_name)):\n                            print('ERROR: /usr/local PATH not found in EXE folder: %s' % dependency_path)\n                        else:\n                            call(['install_name_tool', file_path, '-change', dependency_path, dependency_exe_path])",
            "def fix_rpath(PATH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'FIX broken @rpath on Qt, PyQt, and /usr/local/ dependencies with no @rpath'\n    duplicate_path = os.path.join(PATH, 'lib', 'openshot_qt')\n    if os.path.exists(duplicate_path):\n        shutil.rmtree(duplicate_path)\n    for (root, dirs, files) in os.walk(PATH):\n        for basename in files:\n            file_path = os.path.join(root, basename)\n            relative_path = os.path.relpath(root, PATH)\n            if os.path.splitext(file_path)[-1] in non_executables or basename.startswith('.') or 'profiles' in file_path:\n                continue\n            executable_path = os.path.join('@executable_path', relative_path, basename)\n            if relative_path == '.':\n                executable_path = os.path.join('@executable_path', basename)\n            call(['install_name_tool', file_path, '-id', executable_path])\n            raw_output = subprocess.Popen(['oTool', '-L', file_path], stdout=subprocess.PIPE).communicate()[0].decode('utf-8')\n            for output in raw_output.split('\\n')[1:-1]:\n                if output and 'is not an object file' not in output and ('.o):' not in output):\n                    dependency_path = output.split('\\t')[1].split(' ')[0]\n                    (dependency_base_path, dependency_name) = os.path.split(dependency_path)\n                    if '/usr/local' in dependency_path or '@rpath' in dependency_path:\n                        dependency_exe_path = os.path.join('@executable_path', dependency_name)\n                        if not os.path.exists(os.path.join(PATH, dependency_name)):\n                            print('ERROR: /usr/local PATH not found in EXE folder: %s' % dependency_path)\n                        else:\n                            call(['install_name_tool', file_path, '-change', dependency_path, dependency_exe_path])"
        ]
    },
    {
        "func_name": "print_min_versions",
        "original": "def print_min_versions(PATH):\n    \"\"\"Print ALL MINIMUM and SDK VERSIONS for files in OpenShot build folder.\n    This does not list all dependent libraries though, and sometimes one of those can cause issues.\"\"\"\n    REGEX_SDK_MATCH = re.compile('.*(LC_VERSION_MIN_MACOSX).*version (\\\\d+\\\\.\\\\d+).*sdk (\\\\d+\\\\.\\\\d+).*(cmd)', re.DOTALL)\n    REGEX_SDK_MATCH2 = re.compile('.*sdk\\\\s(.*)\\\\s*minos\\\\s(.*)')\n    VERSIONS = {}\n    for (root, dirs, files) in os.walk(PATH):\n        for basename in files:\n            file_path = os.path.join(root, basename)\n            file_parts = file_path.split('/')\n            if os.path.splitext(file_path)[-1] in non_executables or basename.startswith('.'):\n                continue\n            raw_output = subprocess.Popen(['oTool', '-l', file_path], stdout=subprocess.PIPE).communicate()[0].decode('utf-8')\n            matches = REGEX_SDK_MATCH.findall(raw_output)\n            matches2 = REGEX_SDK_MATCH2.findall(raw_output)\n            min_version = None\n            sdk_version = None\n            if matches and len(matches[0]) == 4:\n                min_version = matches[0][1]\n                sdk_version = matches[0][2]\n            elif matches2 and len(matches2[0]) == 2:\n                sdk_version = matches2[0][0]\n                min_version = matches2[0][1]\n            if min_version and sdk_version:\n                print('... scanning %s for min version (min: %s, sdk: %s)' % (file_path.replace(PATH, ''), min_version, sdk_version))\n                if min_version in VERSIONS:\n                    if file_path not in VERSIONS[min_version]:\n                        VERSIONS[min_version].append(file_path)\n                else:\n                    VERSIONS[min_version] = [file_path]\n                if min_version in ['11.0']:\n                    print('ERROR!!!! Minimum OS X version not met for %s' % file_path)\n    print('\\nSummary of Minimum Mac SDKs for Dependencies:')\n    for key in sorted(VERSIONS.keys()):\n        print('\\n%s' % key)\n        for file_path in VERSIONS[key]:\n            print('  %s' % file_path)\n    print('\\nCount of Minimum Mac SDKs for Dependencies:')\n    for key in sorted(VERSIONS.keys()):\n        print('%s (%d)' % (key, len(VERSIONS[key])))",
        "mutated": [
            "def print_min_versions(PATH):\n    if False:\n        i = 10\n    'Print ALL MINIMUM and SDK VERSIONS for files in OpenShot build folder.\\n    This does not list all dependent libraries though, and sometimes one of those can cause issues.'\n    REGEX_SDK_MATCH = re.compile('.*(LC_VERSION_MIN_MACOSX).*version (\\\\d+\\\\.\\\\d+).*sdk (\\\\d+\\\\.\\\\d+).*(cmd)', re.DOTALL)\n    REGEX_SDK_MATCH2 = re.compile('.*sdk\\\\s(.*)\\\\s*minos\\\\s(.*)')\n    VERSIONS = {}\n    for (root, dirs, files) in os.walk(PATH):\n        for basename in files:\n            file_path = os.path.join(root, basename)\n            file_parts = file_path.split('/')\n            if os.path.splitext(file_path)[-1] in non_executables or basename.startswith('.'):\n                continue\n            raw_output = subprocess.Popen(['oTool', '-l', file_path], stdout=subprocess.PIPE).communicate()[0].decode('utf-8')\n            matches = REGEX_SDK_MATCH.findall(raw_output)\n            matches2 = REGEX_SDK_MATCH2.findall(raw_output)\n            min_version = None\n            sdk_version = None\n            if matches and len(matches[0]) == 4:\n                min_version = matches[0][1]\n                sdk_version = matches[0][2]\n            elif matches2 and len(matches2[0]) == 2:\n                sdk_version = matches2[0][0]\n                min_version = matches2[0][1]\n            if min_version and sdk_version:\n                print('... scanning %s for min version (min: %s, sdk: %s)' % (file_path.replace(PATH, ''), min_version, sdk_version))\n                if min_version in VERSIONS:\n                    if file_path not in VERSIONS[min_version]:\n                        VERSIONS[min_version].append(file_path)\n                else:\n                    VERSIONS[min_version] = [file_path]\n                if min_version in ['11.0']:\n                    print('ERROR!!!! Minimum OS X version not met for %s' % file_path)\n    print('\\nSummary of Minimum Mac SDKs for Dependencies:')\n    for key in sorted(VERSIONS.keys()):\n        print('\\n%s' % key)\n        for file_path in VERSIONS[key]:\n            print('  %s' % file_path)\n    print('\\nCount of Minimum Mac SDKs for Dependencies:')\n    for key in sorted(VERSIONS.keys()):\n        print('%s (%d)' % (key, len(VERSIONS[key])))",
            "def print_min_versions(PATH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Print ALL MINIMUM and SDK VERSIONS for files in OpenShot build folder.\\n    This does not list all dependent libraries though, and sometimes one of those can cause issues.'\n    REGEX_SDK_MATCH = re.compile('.*(LC_VERSION_MIN_MACOSX).*version (\\\\d+\\\\.\\\\d+).*sdk (\\\\d+\\\\.\\\\d+).*(cmd)', re.DOTALL)\n    REGEX_SDK_MATCH2 = re.compile('.*sdk\\\\s(.*)\\\\s*minos\\\\s(.*)')\n    VERSIONS = {}\n    for (root, dirs, files) in os.walk(PATH):\n        for basename in files:\n            file_path = os.path.join(root, basename)\n            file_parts = file_path.split('/')\n            if os.path.splitext(file_path)[-1] in non_executables or basename.startswith('.'):\n                continue\n            raw_output = subprocess.Popen(['oTool', '-l', file_path], stdout=subprocess.PIPE).communicate()[0].decode('utf-8')\n            matches = REGEX_SDK_MATCH.findall(raw_output)\n            matches2 = REGEX_SDK_MATCH2.findall(raw_output)\n            min_version = None\n            sdk_version = None\n            if matches and len(matches[0]) == 4:\n                min_version = matches[0][1]\n                sdk_version = matches[0][2]\n            elif matches2 and len(matches2[0]) == 2:\n                sdk_version = matches2[0][0]\n                min_version = matches2[0][1]\n            if min_version and sdk_version:\n                print('... scanning %s for min version (min: %s, sdk: %s)' % (file_path.replace(PATH, ''), min_version, sdk_version))\n                if min_version in VERSIONS:\n                    if file_path not in VERSIONS[min_version]:\n                        VERSIONS[min_version].append(file_path)\n                else:\n                    VERSIONS[min_version] = [file_path]\n                if min_version in ['11.0']:\n                    print('ERROR!!!! Minimum OS X version not met for %s' % file_path)\n    print('\\nSummary of Minimum Mac SDKs for Dependencies:')\n    for key in sorted(VERSIONS.keys()):\n        print('\\n%s' % key)\n        for file_path in VERSIONS[key]:\n            print('  %s' % file_path)\n    print('\\nCount of Minimum Mac SDKs for Dependencies:')\n    for key in sorted(VERSIONS.keys()):\n        print('%s (%d)' % (key, len(VERSIONS[key])))",
            "def print_min_versions(PATH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Print ALL MINIMUM and SDK VERSIONS for files in OpenShot build folder.\\n    This does not list all dependent libraries though, and sometimes one of those can cause issues.'\n    REGEX_SDK_MATCH = re.compile('.*(LC_VERSION_MIN_MACOSX).*version (\\\\d+\\\\.\\\\d+).*sdk (\\\\d+\\\\.\\\\d+).*(cmd)', re.DOTALL)\n    REGEX_SDK_MATCH2 = re.compile('.*sdk\\\\s(.*)\\\\s*minos\\\\s(.*)')\n    VERSIONS = {}\n    for (root, dirs, files) in os.walk(PATH):\n        for basename in files:\n            file_path = os.path.join(root, basename)\n            file_parts = file_path.split('/')\n            if os.path.splitext(file_path)[-1] in non_executables or basename.startswith('.'):\n                continue\n            raw_output = subprocess.Popen(['oTool', '-l', file_path], stdout=subprocess.PIPE).communicate()[0].decode('utf-8')\n            matches = REGEX_SDK_MATCH.findall(raw_output)\n            matches2 = REGEX_SDK_MATCH2.findall(raw_output)\n            min_version = None\n            sdk_version = None\n            if matches and len(matches[0]) == 4:\n                min_version = matches[0][1]\n                sdk_version = matches[0][2]\n            elif matches2 and len(matches2[0]) == 2:\n                sdk_version = matches2[0][0]\n                min_version = matches2[0][1]\n            if min_version and sdk_version:\n                print('... scanning %s for min version (min: %s, sdk: %s)' % (file_path.replace(PATH, ''), min_version, sdk_version))\n                if min_version in VERSIONS:\n                    if file_path not in VERSIONS[min_version]:\n                        VERSIONS[min_version].append(file_path)\n                else:\n                    VERSIONS[min_version] = [file_path]\n                if min_version in ['11.0']:\n                    print('ERROR!!!! Minimum OS X version not met for %s' % file_path)\n    print('\\nSummary of Minimum Mac SDKs for Dependencies:')\n    for key in sorted(VERSIONS.keys()):\n        print('\\n%s' % key)\n        for file_path in VERSIONS[key]:\n            print('  %s' % file_path)\n    print('\\nCount of Minimum Mac SDKs for Dependencies:')\n    for key in sorted(VERSIONS.keys()):\n        print('%s (%d)' % (key, len(VERSIONS[key])))",
            "def print_min_versions(PATH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Print ALL MINIMUM and SDK VERSIONS for files in OpenShot build folder.\\n    This does not list all dependent libraries though, and sometimes one of those can cause issues.'\n    REGEX_SDK_MATCH = re.compile('.*(LC_VERSION_MIN_MACOSX).*version (\\\\d+\\\\.\\\\d+).*sdk (\\\\d+\\\\.\\\\d+).*(cmd)', re.DOTALL)\n    REGEX_SDK_MATCH2 = re.compile('.*sdk\\\\s(.*)\\\\s*minos\\\\s(.*)')\n    VERSIONS = {}\n    for (root, dirs, files) in os.walk(PATH):\n        for basename in files:\n            file_path = os.path.join(root, basename)\n            file_parts = file_path.split('/')\n            if os.path.splitext(file_path)[-1] in non_executables or basename.startswith('.'):\n                continue\n            raw_output = subprocess.Popen(['oTool', '-l', file_path], stdout=subprocess.PIPE).communicate()[0].decode('utf-8')\n            matches = REGEX_SDK_MATCH.findall(raw_output)\n            matches2 = REGEX_SDK_MATCH2.findall(raw_output)\n            min_version = None\n            sdk_version = None\n            if matches and len(matches[0]) == 4:\n                min_version = matches[0][1]\n                sdk_version = matches[0][2]\n            elif matches2 and len(matches2[0]) == 2:\n                sdk_version = matches2[0][0]\n                min_version = matches2[0][1]\n            if min_version and sdk_version:\n                print('... scanning %s for min version (min: %s, sdk: %s)' % (file_path.replace(PATH, ''), min_version, sdk_version))\n                if min_version in VERSIONS:\n                    if file_path not in VERSIONS[min_version]:\n                        VERSIONS[min_version].append(file_path)\n                else:\n                    VERSIONS[min_version] = [file_path]\n                if min_version in ['11.0']:\n                    print('ERROR!!!! Minimum OS X version not met for %s' % file_path)\n    print('\\nSummary of Minimum Mac SDKs for Dependencies:')\n    for key in sorted(VERSIONS.keys()):\n        print('\\n%s' % key)\n        for file_path in VERSIONS[key]:\n            print('  %s' % file_path)\n    print('\\nCount of Minimum Mac SDKs for Dependencies:')\n    for key in sorted(VERSIONS.keys()):\n        print('%s (%d)' % (key, len(VERSIONS[key])))",
            "def print_min_versions(PATH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Print ALL MINIMUM and SDK VERSIONS for files in OpenShot build folder.\\n    This does not list all dependent libraries though, and sometimes one of those can cause issues.'\n    REGEX_SDK_MATCH = re.compile('.*(LC_VERSION_MIN_MACOSX).*version (\\\\d+\\\\.\\\\d+).*sdk (\\\\d+\\\\.\\\\d+).*(cmd)', re.DOTALL)\n    REGEX_SDK_MATCH2 = re.compile('.*sdk\\\\s(.*)\\\\s*minos\\\\s(.*)')\n    VERSIONS = {}\n    for (root, dirs, files) in os.walk(PATH):\n        for basename in files:\n            file_path = os.path.join(root, basename)\n            file_parts = file_path.split('/')\n            if os.path.splitext(file_path)[-1] in non_executables or basename.startswith('.'):\n                continue\n            raw_output = subprocess.Popen(['oTool', '-l', file_path], stdout=subprocess.PIPE).communicate()[0].decode('utf-8')\n            matches = REGEX_SDK_MATCH.findall(raw_output)\n            matches2 = REGEX_SDK_MATCH2.findall(raw_output)\n            min_version = None\n            sdk_version = None\n            if matches and len(matches[0]) == 4:\n                min_version = matches[0][1]\n                sdk_version = matches[0][2]\n            elif matches2 and len(matches2[0]) == 2:\n                sdk_version = matches2[0][0]\n                min_version = matches2[0][1]\n            if min_version and sdk_version:\n                print('... scanning %s for min version (min: %s, sdk: %s)' % (file_path.replace(PATH, ''), min_version, sdk_version))\n                if min_version in VERSIONS:\n                    if file_path not in VERSIONS[min_version]:\n                        VERSIONS[min_version].append(file_path)\n                else:\n                    VERSIONS[min_version] = [file_path]\n                if min_version in ['11.0']:\n                    print('ERROR!!!! Minimum OS X version not met for %s' % file_path)\n    print('\\nSummary of Minimum Mac SDKs for Dependencies:')\n    for key in sorted(VERSIONS.keys()):\n        print('\\n%s' % key)\n        for file_path in VERSIONS[key]:\n            print('  %s' % file_path)\n    print('\\nCount of Minimum Mac SDKs for Dependencies:')\n    for key in sorted(VERSIONS.keys()):\n        print('%s (%d)' % (key, len(VERSIONS[key])))"
        ]
    }
]