[
    {
        "func_name": "__init__",
        "original": "def __init__(self):\n    self.audit_lookup = {0: 'No auditing', 1: 'Success', 2: 'Failure', 3: 'Success, Failure', 'Not Defined': 'Not Defined', None: 'Not Defined'}\n    self.advanced_audit_lookup = {0: 'No Auditing', 1: 'Success', 2: 'Failure', 3: 'Success and Failure', None: 'Not Configured'}\n    self.sc_removal_lookup = {'0': 'No Action', '1': 'Lock Workstation', '2': 'Force Logoff', '3': 'Disconnect if a Remote Desktop Services session', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.uac_admin_prompt_lookup = {0: 'Elevate without prompting', 1: 'Prompt for credentials on the secure desktop', 2: 'Prompt for consent on the secure desktop', 3: 'Prompt for credentials', 4: 'Prompt for consent', 5: 'Prompt for consent for non-Windows binaries', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.uac_user_prompt_lookup = {0: 'Automatically deny elevation requests', 1: 'Prompt for credentials on the secure desktop', 3: 'Prompt for credentials', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.enabled_one_disabled_zero = {0: 'Disabled', 1: 'Enabled', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.enabled_one_disabled_zero_transform = {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.enabled_one_disabled_zero, 'value_lookup': False}, 'PutArgs': {'lookup': self.enabled_one_disabled_zero, 'value_lookup': True}}\n    self.s4u2self_options = {0: 'Default', 1: 'Enabled', 2: 'Disabled', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.audit_transform = {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.audit_lookup, 'value_lookup': False}, 'PutArgs': {'lookup': self.audit_lookup, 'value_lookup': True}}\n    self.advanced_audit_transform = {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.advanced_audit_lookup, 'value_lookup': False}, 'PutArgs': {'lookup': self.advanced_audit_lookup, 'value_lookup': True}}\n    self.enabled_one_disabled_zero_strings = {'0': 'Disabled', '1': 'Enabled', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.enabled_one_disabled_zero_strings_transform = {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.enabled_one_disabled_zero_strings, 'value_lookup': False}, 'PutArgs': {'lookup': self.enabled_one_disabled_zero_strings, 'value_lookup': True}}\n    self.security_options_gpedit_path = ['Computer Configuration', 'Windows Settings', 'Security Settings', 'Local Policies', 'Security Options']\n    self.windows_firewall_gpedit_path = ['Computer Configuration', 'Windows Settings', 'Security Settings', 'Windows Firewall with Advanced Security', 'Windows Firewall with Advanced Security - Local Group Policy Object']\n    self.password_policy_gpedit_path = ['Computer Configuration', 'Windows Settings', 'Security Settings', 'Account Policies', 'Password Policy']\n    self.audit_policy_gpedit_path = ['Computer Configuration', 'Windows Settings', 'Security Settings', 'Local Policies', 'Audit Policy']\n    self.advanced_audit_policy_gpedit_path = ['Computer Configuration', 'Windows Settings', 'Security Settings', 'Advanced Audit Policy Configuration', 'System Audit Policies - Local Group Policy Object']\n    self.account_lockout_policy_gpedit_path = ['Computer Configuration', 'Windows Settings', 'Security Settings', 'Account Policies', 'Account Lockout Policy']\n    self.user_rights_assignment_gpedit_path = ['Computer Configuration', 'Windows Settings', 'Security Settings', 'Local Policies', 'User Rights Assignment']\n    self.block_ms_accounts = {0: 'This policy is disabled', 1: \"Users can't add Microsoft accounts\", 3: \"Users can't add or log on with Microsoft accounts\", None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.ldap_server_binding_token_requirements = {0: 'Never', 1: 'When supported', 2: 'Always', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.ldap_server_signing_requirements = {1: 'None', 2: 'Require signing', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.smb_server_name_hardening_levels = {0: 'Off', 1: 'Accept if provided by client', 2: 'Required from client', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.locked_session_user_info = {1: 'User display name, domain and user names', 2: 'User display name only', 3: 'Do not display user information', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.force_guest = {0: 'Classic - local users authenticate as themselves', 1: 'Guest only - local users authenticate as Guest', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.force_key_protection = {0: 'User input is not required when new keys are stored and used', 1: 'User is prompted when the key is first used', 2: 'User must enter a password each time they use a key', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.firewall_inbound_connections = {'blockinbound': 'Block (default)', 'blockinboundalways': 'Block all connections', 'allowinbound': 'Allow', 'notconfigured': 'Not configured'}\n    self.firewall_outbound_connections = {'blockoutbound': 'Block', 'allowoutbound': 'Allow (default)', 'notconfigured': 'Not configured'}\n    self.firewall_rule_merging = {'enable': 'Yes (default)', 'disable': 'No', 'notconfigured': 'Not configured'}\n    self.firewall_log_packets_connections = {'enable': 'Yes', 'disable': 'No (default)', 'notconfigured': 'Not configured'}\n    self.firewall_notification = {'enable': 'Yes', 'disable': 'No', 'notconfigured': 'Not configured'}\n    self.firewall_state = {'on': 'On (recommended)', 'off': 'Off', 'notconfigured': 'Not configured'}\n    self.krb_encryption_types = {0: 'No minimum', 1: 'DES_CBC_CRC', 2: 'DES_CBD_MD5', 4: 'RC4_HMAC_MD5', 8: 'AES128_HMAC_SHA1', 16: 'AES256_HMAC_SHA1', 2147483616: 'Future Encryption Types', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.lm_compat_levels = {0: 'Send LM & NTLM response', 1: 'Send LM & NTLM - use NTLMv2 session security if negotiated', 2: 'Send NTLM response only', 3: 'Send NTLMv2 response only', 4: 'Send NTLMv2 response only. Refuse LM', 5: 'Send NTLMv2 response only. Refuse LM & NTLM', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.ldap_signing_reqs = {0: 'None', 1: 'Negotiate signing', 2: 'Require signing', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.ntlm_session_security_levels = {0: 'No minimum', 524288: 'Require NTLMv2 session security', 536870912: 'Require 128-bit encryption', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.ntlm_audit_settings = {0: 'Disable', 1: 'Enable auditing for domain accounts', 2: 'Enable auditing for all accounts', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.ntlm_domain_audit_settings = {0: 'Disable', 1: 'Enable for domain accounts to domain servers', 3: 'Enable for domain accounts', 5: 'Enable for domain servers', 7: 'Enable all', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.incoming_ntlm_settings = {0: 'Allow all', 1: 'Deny all domain accounts', 2: 'Deny all accounts', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.ntlm_domain_auth_settings = {0: 'Disable', 1: 'Deny for domain accounts to domain servers', 3: 'Deny for domain accounts', 5: 'Deny for domain servers', 7: 'Deny all', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.outgoing_ntlm_settings = {0: 'Allow all', 1: 'Audit all', 2: 'Deny all', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.enabled_one_disabled_zero_no_not_defined = {0: 'Disabled', 1: 'Enabled'}\n    self.enabled_one_disabled_zero_no_not_defined_transform = {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.enabled_one_disabled_zero_no_not_defined, 'value_lookup': False}, 'PutArgs': {'lookup': self.enabled_one_disabled_zero_no_not_defined, 'value_lookup': True}}\n    self.policies = {'Machine': {'lgpo_section': 'Computer Configuration', 'policies': {'StartupScripts': {'Policy': 'Startup Scripts', 'lgpo_section': ['Computer Configuration', 'Windows Settings', 'Scripts (Startup/Shutdown)', 'Startup'], 'ScriptIni': {'Section': 'Startup', 'IniPath': os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'Machine', 'Scripts', 'scripts.ini')}}, 'StartupPowershellScripts': {'Policy': 'Startup Powershell Scripts', 'lgpo_section': ['Computer Configuration', 'Windows Settings', 'Scripts (Startup/Shutdown)', 'Startup'], 'ScriptIni': {'Section': 'Startup', 'IniPath': os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'Machine', 'Scripts', 'psscripts.ini')}}, 'StartupPowershellScriptOrder': {'Policy': 'Startup - For this GPO, run scripts in the following order', 'lgpo_section': ['Computer Configuration', 'Windows Settings', 'Scripts (Startup/Shutdown)', 'Startup'], 'ScriptIni': {'IniPath': os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'Machine', 'Scripts', 'psscripts.ini'), 'Section': 'ScriptsConfig', 'SettingName': 'StartExecutePSFirst', 'Settings': ['true', 'false', None]}, 'Transform': {'Get': '_powershell_script_order_conversion', 'Put': '_powershell_script_order_reverse_conversion'}}, 'ShutdownScripts': {'Policy': 'Shutdown Scripts', 'lgpo_section': ['Computer Configuration', 'Windows Settings', 'Scripts (Startup/Shutdown)', 'Shutdown'], 'ScriptIni': {'Section': 'Shutdown', 'IniPath': os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'Machine', 'Scripts', 'scripts.ini')}}, 'ShutdownPowershellScripts': {'Policy': 'Shutdown Powershell Scripts', 'lgpo_section': ['Computer Configuration', 'Windows Settings', 'Scripts (Startup/Shutdown)', 'Shutdown'], 'ScriptIni': {'Section': 'Shutdown', 'IniPath': os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'Machine', 'Scripts', 'psscripts.ini')}}, 'ShutdownPowershellScriptOrder': {'Policy': 'Shutdown - For this GPO, run scripts in the following order', 'lgpo_section': ['Computer Configuration', 'Windows Settings', 'Scripts (Startup/Shutdown)', 'Shutdown'], 'ScriptIni': {'IniPath': os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'Machine', 'Scripts', 'psscripts.ini'), 'Section': 'ScriptsConfig', 'SettingName': 'EndExecutePSFirst', 'Settings': ['true', 'false', None]}, 'Transform': {'Get': '_powershell_script_order_conversion', 'Put': '_powershell_script_order_reverse_conversion'}}, 'LSAAnonymousNameLookup': {'Policy': 'Network access: Allow anonymous SID/Name translation', 'lgpo_section': self.password_policy_gpedit_path, 'Settings': self.enabled_one_disabled_zero_no_not_defined.keys(), 'Secedit': {'Option': 'LSAAnonymousNameLookup', 'Section': 'System Access'}, 'Transform': self.enabled_one_disabled_zero_no_not_defined_transform}, 'RestrictAnonymousSam': {'Policy': 'Network access: Do not allow anonymous enumeration of SAM accounts', 'lgpo_section': self.security_options_gpedit_path, 'Settings': self.enabled_one_disabled_zero.keys(), 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'RestrictAnonymousSam', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'RestrictRemoteSAM': {'Policy': 'Network access: Restrict clients allowed to make remote calls to SAM', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'RestrictRemoteSAM', 'Type': 'REG_SZ'}, 'Transform': {'Put': '_string_put_transform'}}, 'RestrictAnonymous': {'Policy': 'Network access: Do not allow anonymous enumeration of SAM accounts and shares', 'lgpo_section': self.security_options_gpedit_path, 'Settings': self.enabled_one_disabled_zero.keys(), 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'RestrictAnonymous', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'DisableDomainCreds': {'Policy': 'Network access: Do not allow storage of passwords and credentials for network authentication', 'lgpo_section': self.security_options_gpedit_path, 'Settings': self.enabled_one_disabled_zero.keys(), 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'DisableDomainCreds', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'EveryoneIncludesAnonymous': {'Policy': 'Network access: Let Everyone permissions apply to anonymous users', 'lgpo_section': self.security_options_gpedit_path, 'Settings': self.enabled_one_disabled_zero.keys(), 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'everyoneincludesanonymous', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'NullSessionPipes': {'Policy': 'Network access: Named Pipes that can be accessed anonymously', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'NullSessionPipes', 'Type': 'REG_MULTI_SZ'}, 'Transform': {'Put': '_multi_string_put_transform', 'Get': '_multi_string_get_transform'}}, 'RemoteRegistryExactPaths': {'Policy': 'Network access: Remotely accessible registry paths', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\SecurePipeServers\\\\winreg\\\\AllowedExactPaths', 'Value': 'Machine', 'Type': 'REG_MULTI_SZ'}, 'Transform': {'Put': '_multi_string_put_transform', 'Get': '_multi_string_get_transform'}}, 'RemoteRegistryPaths': {'Policy': 'Network access: Remotely accessible registry paths and sub-paths', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\SecurePipeServers\\\\winreg\\\\AllowedPaths', 'Value': 'Machine', 'Type': 'REG_MULTI_SZ'}, 'Transform': {'Put': '_multi_string_put_transform', 'Get': '_multi_string_get_transform'}}, 'RestrictNullSessAccess': {'Policy': 'Network access: Restrict anonymous access to Named Pipes and Shares', 'lgpo_section': self.security_options_gpedit_path, 'Settings': self.enabled_one_disabled_zero.keys(), 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'RestrictNullSessAccess', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'NullSessionShares': {'Policy': 'Network access: Shares that can be accessed anonymously', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'NullSessionShares', 'Type': 'REG_MULTI_SZ'}, 'Transform': {'Put': '_multi_string_put_transform', 'Get': '_multi_string_get_transform'}}, 'ForceGuest': {'Policy': 'Network access: Sharing and security model for local accounts', 'lgpo_section': self.security_options_gpedit_path, 'Settings': self.force_guest.keys(), 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'ForceGuest', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.force_guest, 'value_lookup': False}, 'PutArgs': {'lookup': self.force_guest, 'value_lookup': True}}}, 'WfwDomainState': {'Policy': 'Network firewall: Domain: State', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_state.keys(), 'NetSH': {'Profile': 'domain', 'Section': 'state', 'Option': 'State'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_state, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_state, 'value_lookup': True}}}, 'WfwPrivateState': {'Policy': 'Network firewall: Private: State', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_state.keys(), 'NetSH': {'Profile': 'private', 'Section': 'state', 'Option': 'State'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_state, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_state, 'value_lookup': True}}}, 'WfwPublicState': {'Policy': 'Network firewall: Public: State', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_state.keys(), 'NetSH': {'Profile': 'public', 'Section': 'state', 'Option': 'State'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_state, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_state, 'value_lookup': True}}}, 'WfwDomainInboundConnections': {'Policy': 'Network firewall: Domain: Inbound connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_inbound_connections.keys(), 'NetSH': {'Profile': 'domain', 'Section': 'firewallpolicy', 'Option': 'Inbound'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_inbound_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_inbound_connections, 'value_lookup': True}}}, 'WfwPrivateInboundConnections': {'Policy': 'Network firewall: Private: Inbound connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_inbound_connections.keys(), 'NetSH': {'Profile': 'private', 'Section': 'firewallpolicy', 'Option': 'Inbound'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_inbound_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_inbound_connections, 'value_lookup': True}}}, 'WfwPublicInboundConnections': {'Policy': 'Network firewall: Public: Inbound connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_inbound_connections.keys(), 'NetSH': {'Profile': 'public', 'Section': 'firewallpolicy', 'Option': 'Inbound'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_inbound_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_inbound_connections, 'value_lookup': True}}}, 'WfwDomainOutboundConnections': {'Policy': 'Network firewall: Domain: Outbound connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_outbound_connections.keys(), 'NetSH': {'Profile': 'domain', 'Section': 'firewallpolicy', 'Option': 'Outbound'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_outbound_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_outbound_connections, 'value_lookup': True}}}, 'WfwPrivateOutboundConnections': {'Policy': 'Network firewall: Private: Outbound connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_outbound_connections.keys(), 'NetSH': {'Profile': 'private', 'Section': 'firewallpolicy', 'Option': 'Outbound'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_outbound_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_outbound_connections, 'value_lookup': True}}}, 'WfwPublicOutboundConnections': {'Policy': 'Network firewall: Public: Outbound connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_outbound_connections.keys(), 'NetSH': {'Profile': 'public', 'Section': 'firewallpolicy', 'Option': 'Outbound'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_outbound_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_outbound_connections, 'value_lookup': True}}}, 'WfwDomainSettingsNotification': {'Policy': 'Network firewall: Domain: Settings: Display a notification', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_notification.keys(), 'NetSH': {'Profile': 'domain', 'Section': 'settings', 'Option': 'InboundUserNotification'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_notification, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_notification, 'value_lookup': True}}}, 'WfwPrivateSettingsNotification': {'Policy': 'Network firewall: Private: Settings: Display a notification', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_notification.keys(), 'NetSH': {'Profile': 'private', 'Section': 'settings', 'Option': 'InboundUserNotification'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_notification, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_notification, 'value_lookup': True}}}, 'WfwPublicSettingsNotification': {'Policy': 'Network firewall: Public: Settings: Display a notification', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_notification.keys(), 'NetSH': {'Profile': 'public', 'Section': 'settings', 'Option': 'InboundUserNotification'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_notification, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_notification, 'value_lookup': True}}}, 'WfwDomainSettingsLocalFirewallRules': {'Policy': 'Network firewall: Domain: Settings: Apply local firewall rules', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_rule_merging.keys(), 'NetSH': {'Profile': 'domain', 'Section': 'settings', 'Option': 'LocalFirewallRules'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': True}}}, 'WfwPrivateSettingsLocalFirewallRules': {'Policy': 'Network firewall: Private: Settings: Apply local firewall rules', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_rule_merging.keys(), 'NetSH': {'Profile': 'private', 'Section': 'settings', 'Option': 'LocalFirewallRules'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': True}}}, 'WfwPublicSettingsLocalFirewallRules': {'Policy': 'Network firewall: Public: Settings: Apply local firewall rules', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_rule_merging.keys(), 'NetSH': {'Profile': 'public', 'Section': 'settings', 'Option': 'LocalFirewallRules'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': True}}}, 'WfwDomainSettingsLocalConnectionRules': {'Policy': 'Network firewall: Domain: Settings: Apply local connection security rules', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_rule_merging.keys(), 'NetSH': {'Profile': 'domain', 'Section': 'settings', 'Option': 'LocalConSecRules'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': True}}}, 'WfwPrivateSettingsLocalConnectionRules': {'Policy': 'Network firewall: Private: Settings: Apply local connection security rules', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_rule_merging.keys(), 'NetSH': {'Profile': 'private', 'Section': 'settings', 'Option': 'LocalConSecRules'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': True}}}, 'WfwPublicSettingsLocalConnectionRules': {'Policy': 'Network firewall: Public: Settings: Apply local connection security rules', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_rule_merging.keys(), 'NetSH': {'Profile': 'public', 'Section': 'settings', 'Option': 'LocalConSecRules'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': True}}}, 'WfwDomainLoggingName': {'Policy': 'Network firewall: Domain: Logging: Name', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': None, 'NetSH': {'Profile': 'domain', 'Section': 'logging', 'Option': 'FileName'}}, 'WfwPrivateLoggingName': {'Policy': 'Network firewall: Private: Logging: Name', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': None, 'NetSH': {'Profile': 'private', 'Section': 'logging', 'Option': 'FileName'}}, 'WfwPublicLoggingName': {'Policy': 'Network firewall: Public: Logging: Name', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': None, 'NetSH': {'Profile': 'public', 'Section': 'logging', 'Option': 'FileName'}}, 'WfwDomainLoggingMaxFileSize': {'Policy': 'Network firewall: Domain: Logging: Size limit (KB)', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': None, 'NetSH': {'Profile': 'domain', 'Section': 'logging', 'Option': 'MaxFileSize'}}, 'WfwPrivateLoggingMaxFileSize': {'Policy': 'Network firewall: Private: Logging: Size limit (KB)', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': None, 'NetSH': {'Profile': 'private', 'Section': 'logging', 'Option': 'MaxFileSize'}}, 'WfwPublicLoggingMaxFileSize': {'Policy': 'Network firewall: Public: Logging: Size limit (KB)', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': None, 'NetSH': {'Profile': 'public', 'Section': 'logging', 'Option': 'MaxFileSize'}}, 'WfwDomainLoggingAllowedConnections': {'Policy': 'Network firewall: Domain: Logging: Log successful connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_log_packets_connections.keys(), 'NetSH': {'Profile': 'domain', 'Section': 'logging', 'Option': 'LogAllowedConnections'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': True}}}, 'WfwPrivateLoggingAllowedConnections': {'Policy': 'Network firewall: Private: Logging: Log successful connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_log_packets_connections.keys(), 'NetSH': {'Profile': 'private', 'Section': 'logging', 'Option': 'LogAllowedConnections'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': True}}}, 'WfwPublicLoggingAllowedConnections': {'Policy': 'Network firewall: Public: Logging: Log successful connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_log_packets_connections.keys(), 'NetSH': {'Profile': 'public', 'Section': 'logging', 'Option': 'LogAllowedConnections'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': True}}}, 'WfwDomainLoggingDroppedConnections': {'Policy': 'Network firewall: Domain: Logging: Log dropped packets', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_log_packets_connections.keys(), 'NetSH': {'Profile': 'domain', 'Section': 'logging', 'Option': 'LogDroppedConnections'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': True}}}, 'WfwPrivateLoggingDroppedConnections': {'Policy': 'Network firewall: Private: Logging: Log dropped packets', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_log_packets_connections.keys(), 'NetSH': {'Profile': 'private', 'Section': 'logging', 'Option': 'LogDroppedConnections'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': True}}}, 'WfwPublicLoggingDroppedConnections': {'Policy': 'Network firewall: Public: Logging: Log dropped packets', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_log_packets_connections.keys(), 'NetSH': {'Profile': 'public', 'Section': 'logging', 'Option': 'LogDroppedConnections'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': True}}}, 'PasswordHistory': {'Policy': 'Enforce password history', 'lgpo_section': self.password_policy_gpedit_path, 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 24}}, 'NetUserModal': {'Modal': 0, 'Option': 'password_hist_len'}}, 'MaxPasswordAge': {'Policy': 'Maximum password age', 'lgpo_section': self.password_policy_gpedit_path, 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 1, 'max': 86313600, 'zero_value': 4294967295}}, 'NetUserModal': {'Modal': 0, 'Option': 'max_passwd_age'}, 'Transform': {'Get': '_seconds_to_days', 'Put': '_days_to_seconds', 'GetArgs': {'zero_value': 4294967295}, 'PutArgs': {'zero_value': 4294967295}}}, 'MinPasswordAge': {'Policy': 'Minimum password age', 'lgpo_section': self.password_policy_gpedit_path, 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 86313600}}, 'NetUserModal': {'Modal': 0, 'Option': 'min_passwd_age'}, 'Transform': {'Get': '_seconds_to_days', 'Put': '_days_to_seconds'}}, 'MinPasswordLen': {'Policy': 'Minimum password length', 'lgpo_section': self.password_policy_gpedit_path, 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 14}}, 'NetUserModal': {'Modal': 0, 'Option': 'min_passwd_len'}}, 'PasswordComplexity': {'Policy': 'Password must meet complexity requirements', 'lgpo_section': self.password_policy_gpedit_path, 'Settings': self.enabled_one_disabled_zero_no_not_defined.keys(), 'Secedit': {'Option': 'PasswordComplexity', 'Section': 'System Access'}, 'Transform': self.enabled_one_disabled_zero_no_not_defined_transform}, 'ClearTextPasswords': {'Policy': 'Store passwords using reversible encryption', 'lgpo_section': self.password_policy_gpedit_path, 'Settings': self.enabled_one_disabled_zero_no_not_defined.keys(), 'Secedit': {'Option': 'ClearTextPassword', 'Section': 'System Access'}, 'Transform': self.enabled_one_disabled_zero_no_not_defined_transform}, 'RelaxMinimumPasswordLengthLimits': {'Policy': 'Relax minimum password length limits', 'lgpo_section': self.password_policy_gpedit_path, 'Settings': self.enabled_one_disabled_zero.keys(), 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\SAM', 'Value': 'RelaxMinimumPasswordLengthLimits', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'AdminAccountStatus': {'Policy': 'Accounts: Administrator account status', 'Settings': self.enabled_one_disabled_zero_no_not_defined.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Secedit': {'Option': 'EnableAdminAccount', 'Section': 'System Access'}, 'Transform': self.enabled_one_disabled_zero_no_not_defined_transform}, 'NoConnectedUser': {'Policy': 'Accounts: Block Microsoft accounts', 'Settings': self.block_ms_accounts.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\policies\\\\system', 'Value': 'NoConnectedUser', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.block_ms_accounts, 'value_lookup': False}, 'PutArgs': {'lookup': self.block_ms_accounts, 'value_lookup': True}}}, 'GuestAccountStatus': {'Policy': 'Accounts: Guest account status', 'Settings': self.enabled_one_disabled_zero_no_not_defined.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Secedit': {'Option': 'EnableGuestAccount', 'Section': 'System Access'}, 'Transform': self.enabled_one_disabled_zero_no_not_defined_transform}, 'LimitBlankPasswordUse': {'Policy': 'Accounts: Limit local account use of blank passwords to console logon only', 'lgpo_section': self.security_options_gpedit_path, 'Settings': self.enabled_one_disabled_zero.keys(), 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'limitblankpassworduse', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'RenameAdministratorAccount': {'Policy': 'Accounts: Rename administrator account', 'Settings': None, 'lgpo_section': self.security_options_gpedit_path, 'Secedit': {'Option': 'NewAdministratorName', 'Section': 'System Access'}, 'Transform': {'Get': '_strip_quotes', 'Put': '_add_quotes'}}, 'RenameGuestAccount': {'Policy': 'Accounts: Rename guest account', 'Settings': None, 'lgpo_section': self.security_options_gpedit_path, 'Secedit': {'Option': 'NewGuestName', 'Section': 'System Access'}, 'Transform': {'Get': '_strip_quotes', 'Put': '_add_quotes'}}, 'AuditBaseObjects': {'Policy': 'Audit: Audit the access of global system objects', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'AuditBaseObjects', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'SceNoApplyLegacyAuditPolicy': {'Policy': 'Audit: Force audit policy subcategory settings (Windows Vista or later) to override audit policy category settings', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'SCENoApplyLegacyAuditPolicy', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'DontDisplayLastUserName': {'Policy': 'Interactive logon: Do not display last user name', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'DontDisplayLastUserName', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'CachedLogonsCount': {'Policy': 'Interactive logon: Number of previous logons to cache (in case domain controller is not available)', 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 50}}, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon', 'Value': 'CachedLogonsCount', 'Type': 'REG_SZ'}}, 'ForceUnlockLogon': {'Policy': 'Interactive logon: Require Domain Controller authentication to unlock workstation', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon', 'Value': 'ForceUnlockLogon', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'ScRemoveOption': {'Policy': 'Interactive logon: Smart card removal behavior', 'Settings': self.sc_removal_lookup.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon', 'Value': 'ScRemoveOption', 'Type': 'REG_SZ'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.sc_removal_lookup, 'value_lookup': False}, 'PutArgs': {'lookup': self.sc_removal_lookup, 'value_lookup': True}}}, 'DisableCAD': {'Policy': 'Interactive logon: Do not require CTRL+ALT+DEL', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'DisableCAD', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'FilterAdministratorToken': {'Policy': 'User Account Control: Admin Approval Mode for the built-in Administrator account', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'FilterAdministratorToken', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'EnableUIADesktopToggle': {'Policy': 'User Account Control: Allow UIAccess applications to prompt for elevation without using the secure desktop', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'EnableUIADesktopToggle', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'ConsentPromptBehaviorAdmin': {'Policy': 'User Account Control: Behavior of the elevation prompt for administrators in Admin Approval Mode', 'Settings': self.uac_admin_prompt_lookup.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'ConsentPromptBehaviorAdmin', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.uac_admin_prompt_lookup, 'value_lookup': False}, 'PutArgs': {'lookup': self.uac_admin_prompt_lookup, 'value_lookup': True}}}, 'ConsentPromptBehaviorUser': {'Policy': 'User Account Control: Behavior of the elevation prompt for standard users', 'Settings': self.uac_user_prompt_lookup.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'ConsentPromptBehaviorUser', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.uac_user_prompt_lookup, 'value_lookup': False}, 'PutArgs': {'lookup': self.uac_user_prompt_lookup, 'value_lookup': True}}}, 'EnableInstallerDetection': {'Policy': 'User Account Control: Detect application installations and prompt for elevation', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'EnableInstallerDetection', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'ValidateAdminCodeSignatures': {'Policy': 'User Account Control: Only elevate executables that are signed and validated', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'ValidateAdminCodeSignatures', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'EnableSecureUIAPaths': {'Policy': 'User Account Control: Only elevate UIAccess applications that are installed in secure locations', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'EnableSecureUIAPaths', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'EnableLUA': {'Policy': 'User Account Control: Run all administrators in Admin Approval Mode', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'EnableLUA', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'PromptOnSecureDesktop': {'Policy': 'User Account Control: Switch to the secure desktop when prompting for elevation', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'PromptOnSecureDesktop', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'EnableVirtualization': {'Policy': 'User Account Control: Virtualize file and registry write failures to per-user locations', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'EnableVirtualization', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'PasswordExpiryWarning': {'Policy': 'Interactive logon: Prompt user to change password before expiration', 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 999}}, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon', 'Value': 'PasswordExpiryWarning', 'Type': 'REG_DWORD'}}, 'MaxDevicePasswordFailedAttempts': {'Policy': 'Interactive logon: Machine account lockout threshold', 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 999}}, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\policies\\\\system', 'Value': 'MaxDevicePasswordFailedAttempts', 'Type': 'REG_DWORD'}}, 'InactivityTimeoutSecs': {'Policy': 'Interactive logon: Machine inactivity limit', 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 599940}}, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\policies\\\\system', 'Value': 'InactivityTimeoutSecs', 'Type': 'REG_DWORD'}}, 'legalnoticetext': {'Policy': 'Interactive logon: Message text for users attempting to log on', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\policies\\\\system', 'Value': 'legalnoticetext', 'Type': 'REG_SZ'}, 'Transform': {'Put': '_string_put_transform'}}, 'legalnoticecaption': {'Policy': 'Interactive logon: Message title for users attempting to log on', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\policies\\\\system', 'Value': 'legalnoticecaption', 'Type': 'REG_SZ'}, 'Transform': {'Put': '_string_put_transform'}}, 'DontDisplayLockedUserId': {'Policy': 'Interactive logon: Display user information when the session is locked', 'Settings': self.locked_session_user_info.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\policies\\\\system', 'Value': 'DontDisplayLockedUserId', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.locked_session_user_info, 'value_lookup': False}, 'PutArgs': {'lookup': self.locked_session_user_info, 'value_lookup': True}}}, 'ScForceOption': {'Policy': 'Interactive logon: Require smart card', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'ScForceOption', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'Client_RequireSecuritySignature': {'Policy': 'Microsoft network client: Digitally sign communications (always)', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\LanmanWorkstation\\\\Parameters', 'Value': 'RequireSecuritySignature', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'Client_EnableSecuritySignature': {'Policy': 'Microsoft network client: Digitally sign communications (if server agrees)', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\LanmanWorkstation\\\\Parameters', 'Value': 'EnableSecuritySignature', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'EnablePlainTextPassword': {'Policy': 'Microsoft network client: Send unencrypted password to third-party SMB servers', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\LanmanWorkstation\\\\Parameters', 'Value': 'EnablePlainTextPassword', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'AutoDisconnect': {'Policy': 'Microsoft network server: Amount of idle time required before suspending session', 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 99999}}, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'AutoDisconnect', 'Type': 'REG_DWORD'}}, 'EnableS4U2SelfForClaims': {'Policy': 'Microsoft network server: Attempt S4U2Self to obtain claim information', 'Settings': self.s4u2self_options.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'EnableS4U2SelfForClaims', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.s4u2self_options, 'value_lookup': False}, 'PutArgs': {'lookup': self.s4u2self_options, 'value_lookup': True}}}, 'Server_RequireSecuritySignature': {'Policy': 'Microsoft network server: Digitally sign communications (always)', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'RequireSecuritySignature', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'Server_EnableSecuritySignature': {'Policy': 'Microsoft network server: Digitally sign communications (if client agrees)', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'EnableSecuritySignature', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'EnableForcedLogoff': {'Policy': 'Microsoft network server: Disconnect clients when logon hours expire', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'EnableForcedLogoff', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'SmbServerNameHardeningLevel': {'Policy': 'Microsoft network server: Server SPN target name validation level', 'Settings': self.smb_server_name_hardening_levels.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'SmbServerNameHardeningLevel', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.smb_server_name_hardening_levels, 'value_lookup': False}, 'PutArgs': {'lookup': self.smb_server_name_hardening_levels, 'value_lookup': True}}}, 'FullPrivilegeAuditing': {'Policy': 'Audit: Audit the use of Backup and Restore privilege', 'Settings': [chr(0), chr(1)], 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'FullPrivilegeAuditing', 'Type': 'REG_BINARY'}, 'Transform': {'Get': '_binary_enable_zero_disable_one_conversion', 'Put': '_binary_enable_zero_disable_one_reverse_conversion'}}, 'CrashOnAuditFail': {'Policy': 'Audit: Shut down system immediately if unable to log security audits', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'CrashOnAuditFail', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'UndockWithoutLogon': {'Policy': 'Devices: Allow undock without having to log on', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'UndockWithoutLogon', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'AddPrinterDrivers': {'Policy': 'Devices: Prevent users from installing printer drivers', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\Print\\\\Providers\\\\LanMan Print Services\\\\Servers', 'Value': 'AddPrinterDrivers', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'AllocateDASD': {'Policy': 'Devices: Allowed to format and eject removable media', 'Settings': ['9999', '0', '1', '2'], 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon', 'Value': 'AllocateDASD', 'Type': 'REG_SZ'}, 'Transform': {'Get': '_dasd_conversion', 'Put': '_dasd_reverse_conversion'}}, 'AllocateCDRoms': {'Policy': 'Devices: Restrict CD-ROM access to locally logged-on user only', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon', 'Value': 'AllocateCDRoms', 'Type': 'REG_SZ'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'AllocateFloppies': {'Policy': 'Devices: Restrict floppy access to locally logged-on user only', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon', 'Value': 'AllocateFloppies', 'Type': 'REG_SZ'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'DriverSigningPolicy': {'Policy': 'Devices: Unsigned driver installation behavior', 'Settings': ['3,0', '3,' + chr(1), '3,' + chr(2)], 'lgpo_section': self.security_options_gpedit_path, 'Secedit': {'Option': 'MACHINE\\\\Software\\\\Microsoft\\\\Driver Signing\\\\Policy', 'Section': 'Registry Values'}, 'Transform': {'Get': '_driver_signing_reg_conversion', 'Put': '_driver_signing_reg_reverse_conversion'}}, 'SubmitControl': {'Policy': 'Domain controller: Allow server operators to schedule tasks', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'SubmitControl', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'VulnerableChannelAllowList': {'Policy': 'Domain controller: Allow vulnerable Netlogon secure channel connections', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'VulnerableChannelAllowList', 'Type': 'REG_SZ'}, 'Transform': {'Put': '_string_put_transform'}}, 'LdapEnforceChannelBinding': {'Policy': 'Domain controller: LDAP server channel binding token requirements', 'Settings': self.ldap_server_binding_token_requirements.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\NTDS\\\\Parameters', 'Value': 'LdapEnforceChannelBinding', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.ldap_server_binding_token_requirements, 'value_lookup': False}, 'PutArgs': {'lookup': self.ldap_server_binding_token_requirements, 'value_lookup': True}}}, 'LDAPServerIntegrity': {'Policy': 'Domain controller: LDAP server signing requirements', 'Settings': self.ldap_server_signing_requirements.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\NTDS\\\\Parameters', 'Value': 'LDAPServerIntegrity', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.ldap_server_signing_requirements, 'value_lookup': False}, 'PutArgs': {'lookup': self.ldap_server_signing_requirements, 'value_lookup': True}}}, 'RefusePasswordChange': {'Policy': 'Domain controller: Refuse machine account password changes', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'RefusePasswordChange', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'RequireSignOrSeal': {'Policy': 'Domain member: Digitally encrypt or sign secure channel data (always)', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'RequireSignOrSeal', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'SealSecureChannel': {'Policy': 'Domain member: Digitally encrypt secure channel data (when possible)', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'SealSecureChannel', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'SignSecureChannel': {'Policy': 'Domain member: Digitally sign secure channel data (when possible)', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'SignSecureChannel', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'DisablePasswordChange': {'Policy': 'Domain member: Disable machine account password changes', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'DisablePasswordChange', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'MaximumPasswordAge': {'Policy': 'Domain member: Maximum machine account password age', 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 999}}, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'MaximumPasswordAge', 'Type': 'REG_DWORD'}}, 'RequireStrongKey': {'Policy': 'Domain member: Require strong (Windows 2000 or later) session key', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'RequireStrongKey', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'LockoutDuration': {'Policy': 'Account lockout duration', 'lgpo_section': self.account_lockout_policy_gpedit_path, 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 6000000, 'zero_value': 4294967295}}, 'NetUserModal': {'Modal': 3, 'Option': 'lockout_duration'}, 'Transform': {'Get': '_seconds_to_minutes', 'Put': '_minutes_to_seconds', 'GetArgs': {'zero_value': 4294967295}, 'PutArgs': {'zero_value': 4294967295}}}, 'LockoutThreshold': {'Policy': 'Account lockout threshold', 'lgpo_section': self.account_lockout_policy_gpedit_path, 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 1000}}, 'NetUserModal': {'Modal': 3, 'Option': 'lockout_threshold'}}, 'LockoutWindow': {'Policy': 'Reset account lockout counter after', 'lgpo_section': self.account_lockout_policy_gpedit_path, 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 6000000}}, 'NetUserModal': {'Modal': 3, 'Option': 'lockout_observation_window'}, 'Transform': {'Get': '_seconds_to_minutes', 'Put': '_minutes_to_seconds'}}, 'AuditAccountLogon': {'Policy': 'Audit account logon events', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditAccountLogon', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditAccountManage': {'Policy': 'Audit account management', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditAccountManage', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditDSAccess': {'Policy': 'Audit directory service access', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditDSAccess', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditLogonEvents': {'Policy': 'Audit logon events', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditLogonEvents', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditObjectAccess': {'Policy': 'Audit object access', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditObjectAccess', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditPolicyChange': {'Policy': 'Audit policy change', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditPolicyChange', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditPrivilegeUse': {'Policy': 'Audit privilege use', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditPrivilegeUse', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditProcessTracking': {'Policy': 'Audit process tracking', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditProcessTracking', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditSystemEvents': {'Policy': 'Audit system events', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditSystemEvents', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditCredentialValidation': {'Policy': 'Audit Credential Validation', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Credential Validation'}, 'Transform': self.advanced_audit_transform}, 'AuditKerberosAuthenticationService': {'Policy': 'Audit Kerberos Authentication Service', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Kerberos Authentication Service'}, 'Transform': self.advanced_audit_transform}, 'AuditKerberosServiceTicketOperations': {'Policy': 'Audit Kerberos Service Ticket Operations', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Kerberos Service Ticket Operations'}, 'Transform': self.advanced_audit_transform}, 'AuditOtherAccountLogonEvents': {'Policy': 'Audit Other Account Logon Events', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Other Account Logon Events'}, 'Transform': self.advanced_audit_transform}, 'AuditApplicationGroupManagement': {'Policy': 'Audit Application Group Management', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Application Group Management'}, 'Transform': self.advanced_audit_transform}, 'AuditComputerAccountManagement': {'Policy': 'Audit Computer Account Management', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Computer Account Management'}, 'Transform': self.advanced_audit_transform}, 'AuditDistributionGroupManagement': {'Policy': 'Audit Distribution Group Management', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Distribution Group Management'}, 'Transform': self.advanced_audit_transform}, 'AuditOtherAccountManagementEvents': {'Policy': 'Audit Other Account Management Events', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Other Account Management Events'}, 'Transform': self.advanced_audit_transform}, 'AuditSecurityGroupManagement': {'Policy': 'Audit Security Group Management', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Security Group Management'}, 'Transform': self.advanced_audit_transform}, 'AuditUserAccountManagement': {'Policy': 'Audit User Account Management', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit User Account Management'}, 'Transform': self.advanced_audit_transform}, 'AuditDPAPIActivity': {'Policy': 'Audit DPAPI Activity', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit DPAPI Activity'}, 'Transform': self.advanced_audit_transform}, 'AuditPNPActivity': {'Policy': 'Audit PNP Activity', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit PNP Activity'}, 'Transform': self.advanced_audit_transform}, 'AuditProcessCreation': {'Policy': 'Audit Process Creation', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Process Creation'}, 'Transform': self.advanced_audit_transform}, 'AuditProcessTermination': {'Policy': 'Audit Process Termination', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Process Termination'}, 'Transform': self.advanced_audit_transform}, 'AuditRPCEvents': {'Policy': 'Audit RPC Events', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit RPC Events'}, 'Transform': self.advanced_audit_transform}, 'AuditTokenRightAdjusted': {'Policy': 'Audit Token Right Adjusted', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Token Right Adjusted'}, 'Transform': self.advanced_audit_transform}, 'AuditDetailedDirectoryServiceReplication': {'Policy': 'Audit Detailed Directory Service Replication', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Detailed Directory Service Replication'}, 'Transform': self.advanced_audit_transform}, 'AuditDirectoryServiceAccess': {'Policy': 'Audit Directory Service Access', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Directory Service Access'}, 'Transform': self.advanced_audit_transform}, 'AuditDirectoryServiceChanges': {'Policy': 'Audit Directory Service Changes', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Directory Service Changes'}, 'Transform': self.advanced_audit_transform}, 'AuditDirectoryServiceReplication': {'Policy': 'Audit Directory Service Replication', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Directory Service Replication'}, 'Transform': self.advanced_audit_transform}, 'AuditAccountLockout': {'Policy': 'Audit Account Lockout', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Account Lockout'}, 'Transform': self.advanced_audit_transform}, 'AuditUserDeviceClaims': {'Policy': 'Audit User / Device Claims', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit User / Device Claims'}, 'Transform': self.advanced_audit_transform}, 'AuditGroupMembership': {'Policy': 'Audit Group Membership', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Group Membership'}, 'Transform': self.advanced_audit_transform}, 'AuditIPsecExtendedMode': {'Policy': 'Audit IPsec Extended Mode', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit IPsec Extended Mode'}, 'Transform': self.advanced_audit_transform}, 'AuditIPsecMainMode': {'Policy': 'Audit IPsec Main Mode', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit IPsec Main Mode'}, 'Transform': self.advanced_audit_transform}, 'AuditIPsecQuickMode': {'Policy': 'Audit IPsec Quick Mode', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit IPsec Quick Mode'}, 'Transform': self.advanced_audit_transform}, 'AuditLogoff': {'Policy': 'Audit Logoff', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Logoff'}, 'Transform': self.advanced_audit_transform}, 'AuditLogon': {'Policy': 'Audit Logon', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Logon'}, 'Transform': self.advanced_audit_transform}, 'AuditNetworkPolicyServer': {'Policy': 'Audit Network Policy Server', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Network Policy Server'}, 'Transform': self.advanced_audit_transform}, 'AuditOtherLogonLogoffEvents': {'Policy': 'Audit Other Logon/Logoff Events', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Other Logon/Logoff Events'}, 'Transform': self.advanced_audit_transform}, 'AuditSpecialLogon': {'Policy': 'Audit Special Logon', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Special Logon'}, 'Transform': self.advanced_audit_transform}, 'AuditApplicationGenerated': {'Policy': 'Audit Application Generated', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Application Generated'}, 'Transform': self.advanced_audit_transform}, 'AuditCertificationServices': {'Policy': 'Audit Certification Services', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Certification Services'}, 'Transform': self.advanced_audit_transform}, 'AuditDetailedFileShare': {'Policy': 'Audit Detailed File Share', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Detailed File Share'}, 'Transform': self.advanced_audit_transform}, 'AuditFileShare': {'Policy': 'Audit File Share', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit File Share'}, 'Transform': self.advanced_audit_transform}, 'AuditFileSystem': {'Policy': 'Audit File System', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit File System'}, 'Transform': self.advanced_audit_transform}, 'AuditFilteringPlatformConnection': {'Policy': 'Audit Filtering Platform Connection', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Filtering Platform Connection'}, 'Transform': self.advanced_audit_transform}, 'AuditFilteringPlatformPacketDrop': {'Policy': 'Audit Filtering Platform Packet Drop', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Filtering Platform Packet Drop'}, 'Transform': self.advanced_audit_transform}, 'AuditHandleManipulation': {'Policy': 'Audit Handle Manipulation', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Handle Manipulation'}, 'Transform': self.advanced_audit_transform}, 'AuditKernelObject': {'Policy': 'Audit Kernel Object', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Kernel Object'}, 'Transform': self.advanced_audit_transform}, 'AuditOtherObjectAccessEvents': {'Policy': 'Audit Other Object Access Events', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Other Object Access Events'}, 'Transform': self.advanced_audit_transform}, 'AuditRegistry': {'Policy': 'Audit Registry', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Registry'}, 'Transform': self.advanced_audit_transform}, 'AuditRemovableStorage': {'Policy': 'Audit Removable Storage', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Removable Storage'}, 'Transform': self.advanced_audit_transform}, 'AuditSAM': {'Policy': 'Audit SAM', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit SAM'}, 'Transform': self.advanced_audit_transform}, 'AuditCentralAccessPolicyStaging': {'Policy': 'Audit Central Access Policy Staging', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Central Access Policy Staging'}, 'Transform': self.advanced_audit_transform}, 'AuditAuditPolicyChange': {'Policy': 'Audit Audit Policy Change', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Audit Policy Change'}, 'Transform': self.advanced_audit_transform}, 'AuditAuthenticationPolicyChange': {'Policy': 'Audit Authentication Policy Change', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Authentication Policy Change'}, 'Transform': self.advanced_audit_transform}, 'AuditAuthorizationPolicyChange': {'Policy': 'Audit Authorization Policy Change', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Authorization Policy Change'}, 'Transform': self.advanced_audit_transform}, 'AuditFilteringPlatformPolicyChange': {'Policy': 'Audit Filtering Platform Policy Change', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Filtering Platform Policy Change'}, 'Transform': self.advanced_audit_transform}, 'AuditMPSSVCRuleLevelPolicyChange': {'Policy': 'Audit MPSSVC Rule-Level Policy Change', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit MPSSVC Rule-Level Policy Change'}, 'Transform': self.advanced_audit_transform}, 'AuditOtherPolicyChangeEvents': {'Policy': 'Audit Other Policy Change Events', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Other Policy Change Events'}, 'Transform': self.advanced_audit_transform}, 'AuditNonSensitivePrivilegeUse': {'Policy': 'Audit Non Sensitive Privilege Use', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Non Sensitive Privilege Use'}, 'Transform': self.advanced_audit_transform}, 'AuditOtherPrivilegeUseEvents': {'Policy': 'Audit Other Privilege Use Events', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Other Privilege Use Events'}, 'Transform': self.advanced_audit_transform}, 'AuditSensitivePrivilegeUse': {'Policy': 'Audit Sensitive Privilege Use', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Sensitive Privilege Use'}, 'Transform': self.advanced_audit_transform}, 'AuditIPsecDriver': {'Policy': 'Audit IPsec Driver', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit IPsec Driver'}, 'Transform': self.advanced_audit_transform}, 'AuditOtherSystemEvents': {'Policy': 'Audit Other System Events', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Other System Events'}, 'Transform': self.advanced_audit_transform}, 'AuditSecurityStateChange': {'Policy': 'Audit Security State Change', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Security State Change'}, 'Transform': self.advanced_audit_transform}, 'AuditSecuritySystemExtension': {'Policy': 'Audit Security System Extension', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Security System Extension'}, 'Transform': self.advanced_audit_transform}, 'AuditSystemIntegrity': {'Policy': 'Audit System Integrity', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit System Integrity'}, 'Transform': self.advanced_audit_transform}, 'SeTrustedCredManAccessPrivilege': {'Policy': 'Access Credential Manager as a trusted caller', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeTrustedCredManAccessPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeNetworkLogonRight': {'Policy': 'Access this computer from the network', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeNetworkLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeTcbPrivilege': {'Policy': 'Act as part of the operating system', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeTcbPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeMachineAccountPrivilege': {'Policy': 'Add workstations to domain', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeMachineAccountPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeIncreaseQuotaPrivilege': {'Policy': 'Adjust memory quotas for a process', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeIncreaseQuotaPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeInteractiveLogonRight': {'Policy': 'Allow log on locally', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeInteractiveLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeRemoteInteractiveLogonRight': {'Policy': 'Allow log on through Remote Desktop Services', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeRemoteInteractiveLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeBackupPrivilege': {'Policy': 'Backup files and directories', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeBackupPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeChangeNotifyPrivilege': {'Policy': 'Bypass traverse checking', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeChangeNotifyPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeSystemtimePrivilege': {'Policy': 'Change the system time', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeSystemtimePrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeTimeZonePrivilege': {'Policy': 'Change the time zone', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeTimeZonePrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeCreatePagefilePrivilege': {'Policy': 'Create a pagefile', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeCreatePagefilePrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeCreateTokenPrivilege': {'Policy': 'Create a token object', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeCreateTokenPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeCreateGlobalPrivilege': {'Policy': 'Create global objects', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeCreateGlobalPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeCreatePermanentPrivilege': {'Policy': 'Create permanent shared objects', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeCreatePermanentPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeCreateSymbolicLinkPrivilege': {'Policy': 'Create symbolic links', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeCreateSymbolicLinkPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeDebugPrivilege': {'Policy': 'Debug programs', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeDebugPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeDenyNetworkLogonRight': {'Policy': 'Deny access to this computer from the network', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeDenyNetworkLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeDenyBatchLogonRight': {'Policy': 'Deny log on as a batch job', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeDenyBatchLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeDenyServiceLogonRight': {'Policy': 'Deny log on as a service', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeDenyServiceLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeDenyInteractiveLogonRight': {'Policy': 'Deny log on locally', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeDenyInteractiveLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeDenyRemoteInteractiveLogonRight': {'Policy': 'Deny log on through Remote Desktop Services', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeDenyRemoteInteractiveLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeEnableDelegationPrivilege': {'Policy': 'Enable computer and user accounts to be trusted for delegation', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeEnableDelegationPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeRemoteShutdownPrivilege': {'Policy': 'Force shutdown from a remote system', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeRemoteShutdownPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeAuditPrivilege': {'Policy': 'Generate security audits', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeAuditPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeImpersonatePrivilege': {'Policy': 'Impersonate a client after authentication', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeImpersonatePrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeIncreaseWorkingSetPrivilege': {'Policy': 'Increase a process working set', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeIncreaseWorkingSetPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeIncreaseBasePriorityPrivilege': {'Policy': 'Increase scheduling priority', 'rights_assignment': True, 'lgpo_section': self.user_rights_assignment_gpedit_path, 'Settings': None, 'LsaRights': {'Option': 'SeIncreaseBasePriorityPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeLoadDriverPrivilege': {'Policy': 'Load and unload device drivers', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeLoadDriverPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeLockMemoryPrivilege': {'Policy': 'Lock pages in memory', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeLockMemoryPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeBatchLogonRight': {'Policy': 'Log on as a batch job', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeBatchLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeServiceLogonRight': {'Policy': 'Log on as a service', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeServiceLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeSecurityPrivilege': {'Policy': 'Manage auditing and security log', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeSecurityPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeRelabelPrivilege': {'Policy': 'Modify an object label', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeRelabelPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeSystemEnvironmentPrivilege': {'Policy': 'Modify firmware environment values', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeSystemEnvironmentPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeManageVolumePrivilege': {'Policy': 'Perform volume maintenance tasks', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeManageVolumePrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeProfileSingleProcessPrivilege': {'Policy': 'Profile single process', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeProfileSingleProcessPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeSystemProfilePrivilege': {'Policy': 'Profile system performance', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeSystemProfilePrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeUndockPrivilege': {'Policy': 'Remove computer from docking station', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeUndockPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeAssignPrimaryTokenPrivilege': {'Policy': 'Replace a process level token', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeAssignPrimaryTokenPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeRestorePrivilege': {'Policy': 'Restore files and directories', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeRestorePrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeShutdownPrivilege': {'Policy': 'Shut down the system', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeShutdownPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeSyncAgentPrivilege': {'Policy': 'Synchronize directory service data', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeSyncAgentPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeTakeOwnershipPrivilege': {'Policy': 'Take ownership of files or other objects', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeTakeOwnershipPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'RecoveryConsoleSecurityLevel': {'Policy': 'Recovery console: Allow automatic administrative logon', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Setup\\\\RecoveryConsole', 'Value': 'SecurityLevel', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'RecoveryConsoleSetCommand': {'Policy': 'Recovery console: Allow floppy copy and access to all drives and all folders', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Setup\\\\RecoveryConsole', 'Value': 'SetCommand', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'ForceKeyProtection': {'Policy': 'System Cryptography: Force strong key protection for user keys stored on the computer', 'Settings': self.force_key_protection.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Policies\\\\Microsoft\\\\Cryptography', 'Value': 'ForceKeyProtection', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.force_key_protection, 'value_lookup': False}, 'PutArgs': {'lookup': self.force_key_protection, 'value_lookup': True}}}, 'FIPSAlgorithmPolicy': {'Policy': 'System Cryptography: Use FIPS compliant algorithms for encryption, hashing, and signing', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\FIPSAlgorithmPolicy', 'Value': 'Enabled', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'MachineAccessRestriction': {'Policy': 'DCOM: Machine Access Restrictions in Security Descriptor Definition Language (SDDL) syntax', 'Settings': None, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Policies\\\\Microsoft\\\\Windows NT\\\\DCOM', 'Value': 'MachineAccessRestriction', 'Type': 'REG_SZ'}, 'Transform': {'Put': '_string_put_transform'}}, 'MachineLaunchRestriction': {'Policy': 'DCOM: Machine Launch Restrictions in Security Descriptor Definition Language (SDDL) syntax', 'Settings': None, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Policies\\\\Microsoft\\\\Windows NT\\\\DCOM', 'Value': 'MachineLaunchRestriction', 'Type': 'REG_SZ'}, 'Transform': {'Put': '_string_put_transform'}}, 'UseMachineId': {'Policy': 'Network security: Allow Local System to use computer identity for NTLM', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'UseMachineId', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'allownullsessionfallback': {'Policy': 'Network security: Allow LocalSystem NULL session fallback', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\MSV1_0', 'Value': 'allownullsessionfallback', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'AllowOnlineID': {'Policy': 'Network security: Allow PKU2U authentication requests to this computer to use online identities.', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\pku2u', 'Value': 'AllowOnlineID', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'KrbSupportedEncryptionTypes': {'Policy': 'Network security: Configure encryption types allowed for Kerberos', 'Settings': None, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\policies\\\\system\\\\Kerberos\\\\Parameters', 'Value': 'SupportedEncryptionTypes', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup_bitwise_add', 'Put': '_dict_lookup_bitwise_add', 'GetArgs': {'lookup': self.krb_encryption_types, 'value_lookup': False}, 'PutArgs': {'lookup': self.krb_encryption_types, 'value_lookup': True}}}, 'NoLMHash': {'Policy': 'Network security: Do not store LAN Manager hash value on next password change', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'NoLMHash', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'ForceLogoffWhenHourExpire': {'Policy': 'Network security: Force logoff when logon hours expire', 'lgpo_section': self.security_options_gpedit_path, 'Settings': self.enabled_one_disabled_zero_no_not_defined.keys(), 'Secedit': {'Option': 'ForceLogoffWhenHourExpire', 'Section': 'System Access'}, 'Transform': self.enabled_one_disabled_zero_no_not_defined_transform}, 'LmCompatibilityLevel': {'Policy': 'Network security: LAN Manager authentication level', 'Settings': self.lm_compat_levels.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'LmCompatibilityLevel', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.lm_compat_levels, 'value_lookup': False}, 'PutArgs': {'lookup': self.lm_compat_levels, 'value_lookup': True}}}, 'LDAPClientIntegrity': {'Policy': 'Network security: LDAP client signing requirements', 'Settings': self.ldap_signing_reqs.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\ldap', 'Value': 'LDAPClientIntegrity', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.ldap_signing_reqs, 'value_lookup': False}, 'PutArgs': {'lookup': self.ldap_signing_reqs, 'value_lookup': True}}}, 'NTLMMinClientSec': {'Policy': 'Network security: Minimum session security for NTLM SSP based (including secure RPC) clients', 'Settings': None, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\MSV1_0', 'Value': 'NTLMMinClientSec', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup_bitwise_add', 'Put': '_dict_lookup_bitwise_add', 'GetArgs': {'lookup': self.ntlm_session_security_levels, 'value_lookup': False}, 'PutArgs': {'lookup': self.ntlm_session_security_levels, 'value_lookup': True}}}, 'NTLMMinServerSec': {'Policy': 'Network security: Minimum session security for NTLM SSP based (including secure RPC) servers', 'Settings': None, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\MSV1_0', 'Value': 'NTLMMinServerSec', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup_bitwise_add', 'Put': '_dict_lookup_bitwise_add', 'GetArgs': {'lookup': self.ntlm_session_security_levels, 'value_lookup': False}, 'PutArgs': {'lookup': self.ntlm_session_security_levels, 'value_lookup': True}}}, 'ClientAllowedNTLMServers': {'Policy': 'Network security: Restrict NTLM: Add remote server exceptions for NTLM authentication', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\MSV1_0', 'Value': 'ClientAllowedNTLMServers', 'Type': 'REG_MULTI_SZ'}, 'Transform': {'Put': '_multi_string_put_transform', 'Get': '_multi_string_get_transform'}}, 'DCAllowedNTLMServers': {'Policy': 'Network security: Restrict NTLM: Add server exceptions in this domain', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'DCAllowedNTLMServers', 'Type': 'REG_MULTI_SZ'}, 'Transform': {'Put': '_multi_string_put_transform', 'Get': '_multi_string_get_transform'}}, 'AuditReceivingNTLMTraffic': {'Policy': 'Network security: Restrict NTLM: Audit Incoming NTLM Traffic', 'Settings': self.ntlm_audit_settings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\LSA\\\\MSV1_0', 'Value': 'AuditReceivingNTLMTraffic', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.ntlm_audit_settings, 'value_lookup': False}, 'PutArgs': {'lookup': self.ntlm_audit_settings, 'value_lookup': True}}}, 'AuditNTLMInDomain': {'Policy': 'Network security: Restrict NTLM: Audit NTLM authentication in this domain', 'Settings': self.ntlm_domain_audit_settings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'AuditNTLMInDomain', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.ntlm_domain_audit_settings, 'value_lookup': False}, 'PutArgs': {'lookup': self.ntlm_domain_audit_settings, 'value_lookup': True}}}, 'RestrictReceivingNTLMTraffic': {'Policy': 'Network security: Restrict NTLM: Incoming NTLM traffic', 'Settings': self.incoming_ntlm_settings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\LSA\\\\MSV1_0', 'Value': 'RestrictReceivingNTLMTraffic', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.incoming_ntlm_settings, 'value_lookup': False}, 'PutArgs': {'lookup': self.incoming_ntlm_settings, 'value_lookup': True}}}, 'RestrictNTLMInDomain': {'Policy': 'Network security: Restrict NTLM: NTLM authentication in this domain', 'Settings': self.ntlm_domain_auth_settings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'RestrictNTLMInDomain', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.ntlm_domain_auth_settings, 'value_lookup': False}, 'PutArgs': {'lookup': self.ntlm_domain_auth_settings, 'value_lookup': True}}}, 'RestrictSendingNTLMTraffic': {'Policy': 'Network security: Restrict NTLM: Outgoing NTLM traffic to remote servers', 'Settings': self.outgoing_ntlm_settings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\MSV1_0', 'Value': 'RestrictSendingNTLMTraffic', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.outgoing_ntlm_settings, 'value_lookup': False}, 'PutArgs': {'lookup': self.outgoing_ntlm_settings, 'value_lookup': True}}}, 'ShutdownWithoutLogon': {'Policy': 'Shutdown: Allow system to be shut down without having to log on', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\policies\\\\system', 'Value': 'ShutdownWithoutLogon', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'ClearPageFileAtShutdown': {'Policy': 'Shutdown: Clear virtual memory pagefile', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\SESSION MANAGER\\\\MEMORY MANAGEMENT', 'Value': 'ClearPageFileAtShutdown', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'ObCaseInsensitive': {'Policy': 'System objects: Require case insensitivity for non-Windows subsystems', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\SESSION MANAGER\\\\Kernel', 'Value': 'ObCaseInsensitive', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'ProtectionMode': {'Policy': 'System objects: Strengthen default permissions of internal system objects (e.g. Symbolic Links)', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\SESSION MANAGER', 'Value': 'ProtectionMode', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'OptionalSubsystems': {'Policy': 'System settings: Optional subsystems', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\SESSION MANAGER\\\\SubSystems', 'Value': 'optional', 'Type': 'REG_MULTI_SZ'}, 'Transform': {'Put': '_multi_string_put_transform', 'Get': '_multi_string_get_transform'}}, 'AuthenticodeEnabled': {'Policy': 'System settings: Use Certificate Rules on Windows Executables for Software Restriction Policies', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Policies\\\\Microsoft\\\\Windows\\\\safer\\\\codeidentifiers', 'Value': 'AuthenticodeEnabled', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}}}, 'User': {'lgpo_section': 'User Configuration', 'policies': {}}}",
        "mutated": [
            "def __init__(self):\n    if False:\n        i = 10\n    self.audit_lookup = {0: 'No auditing', 1: 'Success', 2: 'Failure', 3: 'Success, Failure', 'Not Defined': 'Not Defined', None: 'Not Defined'}\n    self.advanced_audit_lookup = {0: 'No Auditing', 1: 'Success', 2: 'Failure', 3: 'Success and Failure', None: 'Not Configured'}\n    self.sc_removal_lookup = {'0': 'No Action', '1': 'Lock Workstation', '2': 'Force Logoff', '3': 'Disconnect if a Remote Desktop Services session', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.uac_admin_prompt_lookup = {0: 'Elevate without prompting', 1: 'Prompt for credentials on the secure desktop', 2: 'Prompt for consent on the secure desktop', 3: 'Prompt for credentials', 4: 'Prompt for consent', 5: 'Prompt for consent for non-Windows binaries', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.uac_user_prompt_lookup = {0: 'Automatically deny elevation requests', 1: 'Prompt for credentials on the secure desktop', 3: 'Prompt for credentials', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.enabled_one_disabled_zero = {0: 'Disabled', 1: 'Enabled', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.enabled_one_disabled_zero_transform = {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.enabled_one_disabled_zero, 'value_lookup': False}, 'PutArgs': {'lookup': self.enabled_one_disabled_zero, 'value_lookup': True}}\n    self.s4u2self_options = {0: 'Default', 1: 'Enabled', 2: 'Disabled', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.audit_transform = {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.audit_lookup, 'value_lookup': False}, 'PutArgs': {'lookup': self.audit_lookup, 'value_lookup': True}}\n    self.advanced_audit_transform = {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.advanced_audit_lookup, 'value_lookup': False}, 'PutArgs': {'lookup': self.advanced_audit_lookup, 'value_lookup': True}}\n    self.enabled_one_disabled_zero_strings = {'0': 'Disabled', '1': 'Enabled', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.enabled_one_disabled_zero_strings_transform = {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.enabled_one_disabled_zero_strings, 'value_lookup': False}, 'PutArgs': {'lookup': self.enabled_one_disabled_zero_strings, 'value_lookup': True}}\n    self.security_options_gpedit_path = ['Computer Configuration', 'Windows Settings', 'Security Settings', 'Local Policies', 'Security Options']\n    self.windows_firewall_gpedit_path = ['Computer Configuration', 'Windows Settings', 'Security Settings', 'Windows Firewall with Advanced Security', 'Windows Firewall with Advanced Security - Local Group Policy Object']\n    self.password_policy_gpedit_path = ['Computer Configuration', 'Windows Settings', 'Security Settings', 'Account Policies', 'Password Policy']\n    self.audit_policy_gpedit_path = ['Computer Configuration', 'Windows Settings', 'Security Settings', 'Local Policies', 'Audit Policy']\n    self.advanced_audit_policy_gpedit_path = ['Computer Configuration', 'Windows Settings', 'Security Settings', 'Advanced Audit Policy Configuration', 'System Audit Policies - Local Group Policy Object']\n    self.account_lockout_policy_gpedit_path = ['Computer Configuration', 'Windows Settings', 'Security Settings', 'Account Policies', 'Account Lockout Policy']\n    self.user_rights_assignment_gpedit_path = ['Computer Configuration', 'Windows Settings', 'Security Settings', 'Local Policies', 'User Rights Assignment']\n    self.block_ms_accounts = {0: 'This policy is disabled', 1: \"Users can't add Microsoft accounts\", 3: \"Users can't add or log on with Microsoft accounts\", None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.ldap_server_binding_token_requirements = {0: 'Never', 1: 'When supported', 2: 'Always', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.ldap_server_signing_requirements = {1: 'None', 2: 'Require signing', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.smb_server_name_hardening_levels = {0: 'Off', 1: 'Accept if provided by client', 2: 'Required from client', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.locked_session_user_info = {1: 'User display name, domain and user names', 2: 'User display name only', 3: 'Do not display user information', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.force_guest = {0: 'Classic - local users authenticate as themselves', 1: 'Guest only - local users authenticate as Guest', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.force_key_protection = {0: 'User input is not required when new keys are stored and used', 1: 'User is prompted when the key is first used', 2: 'User must enter a password each time they use a key', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.firewall_inbound_connections = {'blockinbound': 'Block (default)', 'blockinboundalways': 'Block all connections', 'allowinbound': 'Allow', 'notconfigured': 'Not configured'}\n    self.firewall_outbound_connections = {'blockoutbound': 'Block', 'allowoutbound': 'Allow (default)', 'notconfigured': 'Not configured'}\n    self.firewall_rule_merging = {'enable': 'Yes (default)', 'disable': 'No', 'notconfigured': 'Not configured'}\n    self.firewall_log_packets_connections = {'enable': 'Yes', 'disable': 'No (default)', 'notconfigured': 'Not configured'}\n    self.firewall_notification = {'enable': 'Yes', 'disable': 'No', 'notconfigured': 'Not configured'}\n    self.firewall_state = {'on': 'On (recommended)', 'off': 'Off', 'notconfigured': 'Not configured'}\n    self.krb_encryption_types = {0: 'No minimum', 1: 'DES_CBC_CRC', 2: 'DES_CBD_MD5', 4: 'RC4_HMAC_MD5', 8: 'AES128_HMAC_SHA1', 16: 'AES256_HMAC_SHA1', 2147483616: 'Future Encryption Types', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.lm_compat_levels = {0: 'Send LM & NTLM response', 1: 'Send LM & NTLM - use NTLMv2 session security if negotiated', 2: 'Send NTLM response only', 3: 'Send NTLMv2 response only', 4: 'Send NTLMv2 response only. Refuse LM', 5: 'Send NTLMv2 response only. Refuse LM & NTLM', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.ldap_signing_reqs = {0: 'None', 1: 'Negotiate signing', 2: 'Require signing', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.ntlm_session_security_levels = {0: 'No minimum', 524288: 'Require NTLMv2 session security', 536870912: 'Require 128-bit encryption', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.ntlm_audit_settings = {0: 'Disable', 1: 'Enable auditing for domain accounts', 2: 'Enable auditing for all accounts', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.ntlm_domain_audit_settings = {0: 'Disable', 1: 'Enable for domain accounts to domain servers', 3: 'Enable for domain accounts', 5: 'Enable for domain servers', 7: 'Enable all', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.incoming_ntlm_settings = {0: 'Allow all', 1: 'Deny all domain accounts', 2: 'Deny all accounts', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.ntlm_domain_auth_settings = {0: 'Disable', 1: 'Deny for domain accounts to domain servers', 3: 'Deny for domain accounts', 5: 'Deny for domain servers', 7: 'Deny all', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.outgoing_ntlm_settings = {0: 'Allow all', 1: 'Audit all', 2: 'Deny all', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.enabled_one_disabled_zero_no_not_defined = {0: 'Disabled', 1: 'Enabled'}\n    self.enabled_one_disabled_zero_no_not_defined_transform = {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.enabled_one_disabled_zero_no_not_defined, 'value_lookup': False}, 'PutArgs': {'lookup': self.enabled_one_disabled_zero_no_not_defined, 'value_lookup': True}}\n    self.policies = {'Machine': {'lgpo_section': 'Computer Configuration', 'policies': {'StartupScripts': {'Policy': 'Startup Scripts', 'lgpo_section': ['Computer Configuration', 'Windows Settings', 'Scripts (Startup/Shutdown)', 'Startup'], 'ScriptIni': {'Section': 'Startup', 'IniPath': os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'Machine', 'Scripts', 'scripts.ini')}}, 'StartupPowershellScripts': {'Policy': 'Startup Powershell Scripts', 'lgpo_section': ['Computer Configuration', 'Windows Settings', 'Scripts (Startup/Shutdown)', 'Startup'], 'ScriptIni': {'Section': 'Startup', 'IniPath': os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'Machine', 'Scripts', 'psscripts.ini')}}, 'StartupPowershellScriptOrder': {'Policy': 'Startup - For this GPO, run scripts in the following order', 'lgpo_section': ['Computer Configuration', 'Windows Settings', 'Scripts (Startup/Shutdown)', 'Startup'], 'ScriptIni': {'IniPath': os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'Machine', 'Scripts', 'psscripts.ini'), 'Section': 'ScriptsConfig', 'SettingName': 'StartExecutePSFirst', 'Settings': ['true', 'false', None]}, 'Transform': {'Get': '_powershell_script_order_conversion', 'Put': '_powershell_script_order_reverse_conversion'}}, 'ShutdownScripts': {'Policy': 'Shutdown Scripts', 'lgpo_section': ['Computer Configuration', 'Windows Settings', 'Scripts (Startup/Shutdown)', 'Shutdown'], 'ScriptIni': {'Section': 'Shutdown', 'IniPath': os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'Machine', 'Scripts', 'scripts.ini')}}, 'ShutdownPowershellScripts': {'Policy': 'Shutdown Powershell Scripts', 'lgpo_section': ['Computer Configuration', 'Windows Settings', 'Scripts (Startup/Shutdown)', 'Shutdown'], 'ScriptIni': {'Section': 'Shutdown', 'IniPath': os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'Machine', 'Scripts', 'psscripts.ini')}}, 'ShutdownPowershellScriptOrder': {'Policy': 'Shutdown - For this GPO, run scripts in the following order', 'lgpo_section': ['Computer Configuration', 'Windows Settings', 'Scripts (Startup/Shutdown)', 'Shutdown'], 'ScriptIni': {'IniPath': os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'Machine', 'Scripts', 'psscripts.ini'), 'Section': 'ScriptsConfig', 'SettingName': 'EndExecutePSFirst', 'Settings': ['true', 'false', None]}, 'Transform': {'Get': '_powershell_script_order_conversion', 'Put': '_powershell_script_order_reverse_conversion'}}, 'LSAAnonymousNameLookup': {'Policy': 'Network access: Allow anonymous SID/Name translation', 'lgpo_section': self.password_policy_gpedit_path, 'Settings': self.enabled_one_disabled_zero_no_not_defined.keys(), 'Secedit': {'Option': 'LSAAnonymousNameLookup', 'Section': 'System Access'}, 'Transform': self.enabled_one_disabled_zero_no_not_defined_transform}, 'RestrictAnonymousSam': {'Policy': 'Network access: Do not allow anonymous enumeration of SAM accounts', 'lgpo_section': self.security_options_gpedit_path, 'Settings': self.enabled_one_disabled_zero.keys(), 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'RestrictAnonymousSam', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'RestrictRemoteSAM': {'Policy': 'Network access: Restrict clients allowed to make remote calls to SAM', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'RestrictRemoteSAM', 'Type': 'REG_SZ'}, 'Transform': {'Put': '_string_put_transform'}}, 'RestrictAnonymous': {'Policy': 'Network access: Do not allow anonymous enumeration of SAM accounts and shares', 'lgpo_section': self.security_options_gpedit_path, 'Settings': self.enabled_one_disabled_zero.keys(), 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'RestrictAnonymous', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'DisableDomainCreds': {'Policy': 'Network access: Do not allow storage of passwords and credentials for network authentication', 'lgpo_section': self.security_options_gpedit_path, 'Settings': self.enabled_one_disabled_zero.keys(), 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'DisableDomainCreds', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'EveryoneIncludesAnonymous': {'Policy': 'Network access: Let Everyone permissions apply to anonymous users', 'lgpo_section': self.security_options_gpedit_path, 'Settings': self.enabled_one_disabled_zero.keys(), 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'everyoneincludesanonymous', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'NullSessionPipes': {'Policy': 'Network access: Named Pipes that can be accessed anonymously', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'NullSessionPipes', 'Type': 'REG_MULTI_SZ'}, 'Transform': {'Put': '_multi_string_put_transform', 'Get': '_multi_string_get_transform'}}, 'RemoteRegistryExactPaths': {'Policy': 'Network access: Remotely accessible registry paths', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\SecurePipeServers\\\\winreg\\\\AllowedExactPaths', 'Value': 'Machine', 'Type': 'REG_MULTI_SZ'}, 'Transform': {'Put': '_multi_string_put_transform', 'Get': '_multi_string_get_transform'}}, 'RemoteRegistryPaths': {'Policy': 'Network access: Remotely accessible registry paths and sub-paths', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\SecurePipeServers\\\\winreg\\\\AllowedPaths', 'Value': 'Machine', 'Type': 'REG_MULTI_SZ'}, 'Transform': {'Put': '_multi_string_put_transform', 'Get': '_multi_string_get_transform'}}, 'RestrictNullSessAccess': {'Policy': 'Network access: Restrict anonymous access to Named Pipes and Shares', 'lgpo_section': self.security_options_gpedit_path, 'Settings': self.enabled_one_disabled_zero.keys(), 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'RestrictNullSessAccess', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'NullSessionShares': {'Policy': 'Network access: Shares that can be accessed anonymously', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'NullSessionShares', 'Type': 'REG_MULTI_SZ'}, 'Transform': {'Put': '_multi_string_put_transform', 'Get': '_multi_string_get_transform'}}, 'ForceGuest': {'Policy': 'Network access: Sharing and security model for local accounts', 'lgpo_section': self.security_options_gpedit_path, 'Settings': self.force_guest.keys(), 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'ForceGuest', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.force_guest, 'value_lookup': False}, 'PutArgs': {'lookup': self.force_guest, 'value_lookup': True}}}, 'WfwDomainState': {'Policy': 'Network firewall: Domain: State', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_state.keys(), 'NetSH': {'Profile': 'domain', 'Section': 'state', 'Option': 'State'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_state, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_state, 'value_lookup': True}}}, 'WfwPrivateState': {'Policy': 'Network firewall: Private: State', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_state.keys(), 'NetSH': {'Profile': 'private', 'Section': 'state', 'Option': 'State'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_state, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_state, 'value_lookup': True}}}, 'WfwPublicState': {'Policy': 'Network firewall: Public: State', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_state.keys(), 'NetSH': {'Profile': 'public', 'Section': 'state', 'Option': 'State'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_state, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_state, 'value_lookup': True}}}, 'WfwDomainInboundConnections': {'Policy': 'Network firewall: Domain: Inbound connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_inbound_connections.keys(), 'NetSH': {'Profile': 'domain', 'Section': 'firewallpolicy', 'Option': 'Inbound'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_inbound_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_inbound_connections, 'value_lookup': True}}}, 'WfwPrivateInboundConnections': {'Policy': 'Network firewall: Private: Inbound connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_inbound_connections.keys(), 'NetSH': {'Profile': 'private', 'Section': 'firewallpolicy', 'Option': 'Inbound'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_inbound_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_inbound_connections, 'value_lookup': True}}}, 'WfwPublicInboundConnections': {'Policy': 'Network firewall: Public: Inbound connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_inbound_connections.keys(), 'NetSH': {'Profile': 'public', 'Section': 'firewallpolicy', 'Option': 'Inbound'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_inbound_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_inbound_connections, 'value_lookup': True}}}, 'WfwDomainOutboundConnections': {'Policy': 'Network firewall: Domain: Outbound connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_outbound_connections.keys(), 'NetSH': {'Profile': 'domain', 'Section': 'firewallpolicy', 'Option': 'Outbound'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_outbound_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_outbound_connections, 'value_lookup': True}}}, 'WfwPrivateOutboundConnections': {'Policy': 'Network firewall: Private: Outbound connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_outbound_connections.keys(), 'NetSH': {'Profile': 'private', 'Section': 'firewallpolicy', 'Option': 'Outbound'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_outbound_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_outbound_connections, 'value_lookup': True}}}, 'WfwPublicOutboundConnections': {'Policy': 'Network firewall: Public: Outbound connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_outbound_connections.keys(), 'NetSH': {'Profile': 'public', 'Section': 'firewallpolicy', 'Option': 'Outbound'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_outbound_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_outbound_connections, 'value_lookup': True}}}, 'WfwDomainSettingsNotification': {'Policy': 'Network firewall: Domain: Settings: Display a notification', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_notification.keys(), 'NetSH': {'Profile': 'domain', 'Section': 'settings', 'Option': 'InboundUserNotification'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_notification, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_notification, 'value_lookup': True}}}, 'WfwPrivateSettingsNotification': {'Policy': 'Network firewall: Private: Settings: Display a notification', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_notification.keys(), 'NetSH': {'Profile': 'private', 'Section': 'settings', 'Option': 'InboundUserNotification'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_notification, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_notification, 'value_lookup': True}}}, 'WfwPublicSettingsNotification': {'Policy': 'Network firewall: Public: Settings: Display a notification', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_notification.keys(), 'NetSH': {'Profile': 'public', 'Section': 'settings', 'Option': 'InboundUserNotification'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_notification, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_notification, 'value_lookup': True}}}, 'WfwDomainSettingsLocalFirewallRules': {'Policy': 'Network firewall: Domain: Settings: Apply local firewall rules', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_rule_merging.keys(), 'NetSH': {'Profile': 'domain', 'Section': 'settings', 'Option': 'LocalFirewallRules'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': True}}}, 'WfwPrivateSettingsLocalFirewallRules': {'Policy': 'Network firewall: Private: Settings: Apply local firewall rules', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_rule_merging.keys(), 'NetSH': {'Profile': 'private', 'Section': 'settings', 'Option': 'LocalFirewallRules'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': True}}}, 'WfwPublicSettingsLocalFirewallRules': {'Policy': 'Network firewall: Public: Settings: Apply local firewall rules', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_rule_merging.keys(), 'NetSH': {'Profile': 'public', 'Section': 'settings', 'Option': 'LocalFirewallRules'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': True}}}, 'WfwDomainSettingsLocalConnectionRules': {'Policy': 'Network firewall: Domain: Settings: Apply local connection security rules', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_rule_merging.keys(), 'NetSH': {'Profile': 'domain', 'Section': 'settings', 'Option': 'LocalConSecRules'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': True}}}, 'WfwPrivateSettingsLocalConnectionRules': {'Policy': 'Network firewall: Private: Settings: Apply local connection security rules', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_rule_merging.keys(), 'NetSH': {'Profile': 'private', 'Section': 'settings', 'Option': 'LocalConSecRules'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': True}}}, 'WfwPublicSettingsLocalConnectionRules': {'Policy': 'Network firewall: Public: Settings: Apply local connection security rules', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_rule_merging.keys(), 'NetSH': {'Profile': 'public', 'Section': 'settings', 'Option': 'LocalConSecRules'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': True}}}, 'WfwDomainLoggingName': {'Policy': 'Network firewall: Domain: Logging: Name', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': None, 'NetSH': {'Profile': 'domain', 'Section': 'logging', 'Option': 'FileName'}}, 'WfwPrivateLoggingName': {'Policy': 'Network firewall: Private: Logging: Name', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': None, 'NetSH': {'Profile': 'private', 'Section': 'logging', 'Option': 'FileName'}}, 'WfwPublicLoggingName': {'Policy': 'Network firewall: Public: Logging: Name', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': None, 'NetSH': {'Profile': 'public', 'Section': 'logging', 'Option': 'FileName'}}, 'WfwDomainLoggingMaxFileSize': {'Policy': 'Network firewall: Domain: Logging: Size limit (KB)', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': None, 'NetSH': {'Profile': 'domain', 'Section': 'logging', 'Option': 'MaxFileSize'}}, 'WfwPrivateLoggingMaxFileSize': {'Policy': 'Network firewall: Private: Logging: Size limit (KB)', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': None, 'NetSH': {'Profile': 'private', 'Section': 'logging', 'Option': 'MaxFileSize'}}, 'WfwPublicLoggingMaxFileSize': {'Policy': 'Network firewall: Public: Logging: Size limit (KB)', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': None, 'NetSH': {'Profile': 'public', 'Section': 'logging', 'Option': 'MaxFileSize'}}, 'WfwDomainLoggingAllowedConnections': {'Policy': 'Network firewall: Domain: Logging: Log successful connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_log_packets_connections.keys(), 'NetSH': {'Profile': 'domain', 'Section': 'logging', 'Option': 'LogAllowedConnections'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': True}}}, 'WfwPrivateLoggingAllowedConnections': {'Policy': 'Network firewall: Private: Logging: Log successful connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_log_packets_connections.keys(), 'NetSH': {'Profile': 'private', 'Section': 'logging', 'Option': 'LogAllowedConnections'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': True}}}, 'WfwPublicLoggingAllowedConnections': {'Policy': 'Network firewall: Public: Logging: Log successful connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_log_packets_connections.keys(), 'NetSH': {'Profile': 'public', 'Section': 'logging', 'Option': 'LogAllowedConnections'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': True}}}, 'WfwDomainLoggingDroppedConnections': {'Policy': 'Network firewall: Domain: Logging: Log dropped packets', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_log_packets_connections.keys(), 'NetSH': {'Profile': 'domain', 'Section': 'logging', 'Option': 'LogDroppedConnections'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': True}}}, 'WfwPrivateLoggingDroppedConnections': {'Policy': 'Network firewall: Private: Logging: Log dropped packets', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_log_packets_connections.keys(), 'NetSH': {'Profile': 'private', 'Section': 'logging', 'Option': 'LogDroppedConnections'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': True}}}, 'WfwPublicLoggingDroppedConnections': {'Policy': 'Network firewall: Public: Logging: Log dropped packets', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_log_packets_connections.keys(), 'NetSH': {'Profile': 'public', 'Section': 'logging', 'Option': 'LogDroppedConnections'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': True}}}, 'PasswordHistory': {'Policy': 'Enforce password history', 'lgpo_section': self.password_policy_gpedit_path, 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 24}}, 'NetUserModal': {'Modal': 0, 'Option': 'password_hist_len'}}, 'MaxPasswordAge': {'Policy': 'Maximum password age', 'lgpo_section': self.password_policy_gpedit_path, 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 1, 'max': 86313600, 'zero_value': 4294967295}}, 'NetUserModal': {'Modal': 0, 'Option': 'max_passwd_age'}, 'Transform': {'Get': '_seconds_to_days', 'Put': '_days_to_seconds', 'GetArgs': {'zero_value': 4294967295}, 'PutArgs': {'zero_value': 4294967295}}}, 'MinPasswordAge': {'Policy': 'Minimum password age', 'lgpo_section': self.password_policy_gpedit_path, 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 86313600}}, 'NetUserModal': {'Modal': 0, 'Option': 'min_passwd_age'}, 'Transform': {'Get': '_seconds_to_days', 'Put': '_days_to_seconds'}}, 'MinPasswordLen': {'Policy': 'Minimum password length', 'lgpo_section': self.password_policy_gpedit_path, 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 14}}, 'NetUserModal': {'Modal': 0, 'Option': 'min_passwd_len'}}, 'PasswordComplexity': {'Policy': 'Password must meet complexity requirements', 'lgpo_section': self.password_policy_gpedit_path, 'Settings': self.enabled_one_disabled_zero_no_not_defined.keys(), 'Secedit': {'Option': 'PasswordComplexity', 'Section': 'System Access'}, 'Transform': self.enabled_one_disabled_zero_no_not_defined_transform}, 'ClearTextPasswords': {'Policy': 'Store passwords using reversible encryption', 'lgpo_section': self.password_policy_gpedit_path, 'Settings': self.enabled_one_disabled_zero_no_not_defined.keys(), 'Secedit': {'Option': 'ClearTextPassword', 'Section': 'System Access'}, 'Transform': self.enabled_one_disabled_zero_no_not_defined_transform}, 'RelaxMinimumPasswordLengthLimits': {'Policy': 'Relax minimum password length limits', 'lgpo_section': self.password_policy_gpedit_path, 'Settings': self.enabled_one_disabled_zero.keys(), 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\SAM', 'Value': 'RelaxMinimumPasswordLengthLimits', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'AdminAccountStatus': {'Policy': 'Accounts: Administrator account status', 'Settings': self.enabled_one_disabled_zero_no_not_defined.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Secedit': {'Option': 'EnableAdminAccount', 'Section': 'System Access'}, 'Transform': self.enabled_one_disabled_zero_no_not_defined_transform}, 'NoConnectedUser': {'Policy': 'Accounts: Block Microsoft accounts', 'Settings': self.block_ms_accounts.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\policies\\\\system', 'Value': 'NoConnectedUser', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.block_ms_accounts, 'value_lookup': False}, 'PutArgs': {'lookup': self.block_ms_accounts, 'value_lookup': True}}}, 'GuestAccountStatus': {'Policy': 'Accounts: Guest account status', 'Settings': self.enabled_one_disabled_zero_no_not_defined.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Secedit': {'Option': 'EnableGuestAccount', 'Section': 'System Access'}, 'Transform': self.enabled_one_disabled_zero_no_not_defined_transform}, 'LimitBlankPasswordUse': {'Policy': 'Accounts: Limit local account use of blank passwords to console logon only', 'lgpo_section': self.security_options_gpedit_path, 'Settings': self.enabled_one_disabled_zero.keys(), 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'limitblankpassworduse', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'RenameAdministratorAccount': {'Policy': 'Accounts: Rename administrator account', 'Settings': None, 'lgpo_section': self.security_options_gpedit_path, 'Secedit': {'Option': 'NewAdministratorName', 'Section': 'System Access'}, 'Transform': {'Get': '_strip_quotes', 'Put': '_add_quotes'}}, 'RenameGuestAccount': {'Policy': 'Accounts: Rename guest account', 'Settings': None, 'lgpo_section': self.security_options_gpedit_path, 'Secedit': {'Option': 'NewGuestName', 'Section': 'System Access'}, 'Transform': {'Get': '_strip_quotes', 'Put': '_add_quotes'}}, 'AuditBaseObjects': {'Policy': 'Audit: Audit the access of global system objects', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'AuditBaseObjects', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'SceNoApplyLegacyAuditPolicy': {'Policy': 'Audit: Force audit policy subcategory settings (Windows Vista or later) to override audit policy category settings', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'SCENoApplyLegacyAuditPolicy', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'DontDisplayLastUserName': {'Policy': 'Interactive logon: Do not display last user name', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'DontDisplayLastUserName', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'CachedLogonsCount': {'Policy': 'Interactive logon: Number of previous logons to cache (in case domain controller is not available)', 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 50}}, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon', 'Value': 'CachedLogonsCount', 'Type': 'REG_SZ'}}, 'ForceUnlockLogon': {'Policy': 'Interactive logon: Require Domain Controller authentication to unlock workstation', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon', 'Value': 'ForceUnlockLogon', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'ScRemoveOption': {'Policy': 'Interactive logon: Smart card removal behavior', 'Settings': self.sc_removal_lookup.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon', 'Value': 'ScRemoveOption', 'Type': 'REG_SZ'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.sc_removal_lookup, 'value_lookup': False}, 'PutArgs': {'lookup': self.sc_removal_lookup, 'value_lookup': True}}}, 'DisableCAD': {'Policy': 'Interactive logon: Do not require CTRL+ALT+DEL', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'DisableCAD', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'FilterAdministratorToken': {'Policy': 'User Account Control: Admin Approval Mode for the built-in Administrator account', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'FilterAdministratorToken', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'EnableUIADesktopToggle': {'Policy': 'User Account Control: Allow UIAccess applications to prompt for elevation without using the secure desktop', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'EnableUIADesktopToggle', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'ConsentPromptBehaviorAdmin': {'Policy': 'User Account Control: Behavior of the elevation prompt for administrators in Admin Approval Mode', 'Settings': self.uac_admin_prompt_lookup.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'ConsentPromptBehaviorAdmin', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.uac_admin_prompt_lookup, 'value_lookup': False}, 'PutArgs': {'lookup': self.uac_admin_prompt_lookup, 'value_lookup': True}}}, 'ConsentPromptBehaviorUser': {'Policy': 'User Account Control: Behavior of the elevation prompt for standard users', 'Settings': self.uac_user_prompt_lookup.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'ConsentPromptBehaviorUser', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.uac_user_prompt_lookup, 'value_lookup': False}, 'PutArgs': {'lookup': self.uac_user_prompt_lookup, 'value_lookup': True}}}, 'EnableInstallerDetection': {'Policy': 'User Account Control: Detect application installations and prompt for elevation', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'EnableInstallerDetection', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'ValidateAdminCodeSignatures': {'Policy': 'User Account Control: Only elevate executables that are signed and validated', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'ValidateAdminCodeSignatures', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'EnableSecureUIAPaths': {'Policy': 'User Account Control: Only elevate UIAccess applications that are installed in secure locations', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'EnableSecureUIAPaths', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'EnableLUA': {'Policy': 'User Account Control: Run all administrators in Admin Approval Mode', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'EnableLUA', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'PromptOnSecureDesktop': {'Policy': 'User Account Control: Switch to the secure desktop when prompting for elevation', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'PromptOnSecureDesktop', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'EnableVirtualization': {'Policy': 'User Account Control: Virtualize file and registry write failures to per-user locations', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'EnableVirtualization', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'PasswordExpiryWarning': {'Policy': 'Interactive logon: Prompt user to change password before expiration', 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 999}}, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon', 'Value': 'PasswordExpiryWarning', 'Type': 'REG_DWORD'}}, 'MaxDevicePasswordFailedAttempts': {'Policy': 'Interactive logon: Machine account lockout threshold', 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 999}}, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\policies\\\\system', 'Value': 'MaxDevicePasswordFailedAttempts', 'Type': 'REG_DWORD'}}, 'InactivityTimeoutSecs': {'Policy': 'Interactive logon: Machine inactivity limit', 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 599940}}, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\policies\\\\system', 'Value': 'InactivityTimeoutSecs', 'Type': 'REG_DWORD'}}, 'legalnoticetext': {'Policy': 'Interactive logon: Message text for users attempting to log on', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\policies\\\\system', 'Value': 'legalnoticetext', 'Type': 'REG_SZ'}, 'Transform': {'Put': '_string_put_transform'}}, 'legalnoticecaption': {'Policy': 'Interactive logon: Message title for users attempting to log on', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\policies\\\\system', 'Value': 'legalnoticecaption', 'Type': 'REG_SZ'}, 'Transform': {'Put': '_string_put_transform'}}, 'DontDisplayLockedUserId': {'Policy': 'Interactive logon: Display user information when the session is locked', 'Settings': self.locked_session_user_info.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\policies\\\\system', 'Value': 'DontDisplayLockedUserId', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.locked_session_user_info, 'value_lookup': False}, 'PutArgs': {'lookup': self.locked_session_user_info, 'value_lookup': True}}}, 'ScForceOption': {'Policy': 'Interactive logon: Require smart card', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'ScForceOption', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'Client_RequireSecuritySignature': {'Policy': 'Microsoft network client: Digitally sign communications (always)', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\LanmanWorkstation\\\\Parameters', 'Value': 'RequireSecuritySignature', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'Client_EnableSecuritySignature': {'Policy': 'Microsoft network client: Digitally sign communications (if server agrees)', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\LanmanWorkstation\\\\Parameters', 'Value': 'EnableSecuritySignature', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'EnablePlainTextPassword': {'Policy': 'Microsoft network client: Send unencrypted password to third-party SMB servers', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\LanmanWorkstation\\\\Parameters', 'Value': 'EnablePlainTextPassword', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'AutoDisconnect': {'Policy': 'Microsoft network server: Amount of idle time required before suspending session', 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 99999}}, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'AutoDisconnect', 'Type': 'REG_DWORD'}}, 'EnableS4U2SelfForClaims': {'Policy': 'Microsoft network server: Attempt S4U2Self to obtain claim information', 'Settings': self.s4u2self_options.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'EnableS4U2SelfForClaims', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.s4u2self_options, 'value_lookup': False}, 'PutArgs': {'lookup': self.s4u2self_options, 'value_lookup': True}}}, 'Server_RequireSecuritySignature': {'Policy': 'Microsoft network server: Digitally sign communications (always)', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'RequireSecuritySignature', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'Server_EnableSecuritySignature': {'Policy': 'Microsoft network server: Digitally sign communications (if client agrees)', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'EnableSecuritySignature', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'EnableForcedLogoff': {'Policy': 'Microsoft network server: Disconnect clients when logon hours expire', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'EnableForcedLogoff', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'SmbServerNameHardeningLevel': {'Policy': 'Microsoft network server: Server SPN target name validation level', 'Settings': self.smb_server_name_hardening_levels.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'SmbServerNameHardeningLevel', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.smb_server_name_hardening_levels, 'value_lookup': False}, 'PutArgs': {'lookup': self.smb_server_name_hardening_levels, 'value_lookup': True}}}, 'FullPrivilegeAuditing': {'Policy': 'Audit: Audit the use of Backup and Restore privilege', 'Settings': [chr(0), chr(1)], 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'FullPrivilegeAuditing', 'Type': 'REG_BINARY'}, 'Transform': {'Get': '_binary_enable_zero_disable_one_conversion', 'Put': '_binary_enable_zero_disable_one_reverse_conversion'}}, 'CrashOnAuditFail': {'Policy': 'Audit: Shut down system immediately if unable to log security audits', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'CrashOnAuditFail', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'UndockWithoutLogon': {'Policy': 'Devices: Allow undock without having to log on', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'UndockWithoutLogon', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'AddPrinterDrivers': {'Policy': 'Devices: Prevent users from installing printer drivers', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\Print\\\\Providers\\\\LanMan Print Services\\\\Servers', 'Value': 'AddPrinterDrivers', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'AllocateDASD': {'Policy': 'Devices: Allowed to format and eject removable media', 'Settings': ['9999', '0', '1', '2'], 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon', 'Value': 'AllocateDASD', 'Type': 'REG_SZ'}, 'Transform': {'Get': '_dasd_conversion', 'Put': '_dasd_reverse_conversion'}}, 'AllocateCDRoms': {'Policy': 'Devices: Restrict CD-ROM access to locally logged-on user only', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon', 'Value': 'AllocateCDRoms', 'Type': 'REG_SZ'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'AllocateFloppies': {'Policy': 'Devices: Restrict floppy access to locally logged-on user only', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon', 'Value': 'AllocateFloppies', 'Type': 'REG_SZ'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'DriverSigningPolicy': {'Policy': 'Devices: Unsigned driver installation behavior', 'Settings': ['3,0', '3,' + chr(1), '3,' + chr(2)], 'lgpo_section': self.security_options_gpedit_path, 'Secedit': {'Option': 'MACHINE\\\\Software\\\\Microsoft\\\\Driver Signing\\\\Policy', 'Section': 'Registry Values'}, 'Transform': {'Get': '_driver_signing_reg_conversion', 'Put': '_driver_signing_reg_reverse_conversion'}}, 'SubmitControl': {'Policy': 'Domain controller: Allow server operators to schedule tasks', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'SubmitControl', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'VulnerableChannelAllowList': {'Policy': 'Domain controller: Allow vulnerable Netlogon secure channel connections', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'VulnerableChannelAllowList', 'Type': 'REG_SZ'}, 'Transform': {'Put': '_string_put_transform'}}, 'LdapEnforceChannelBinding': {'Policy': 'Domain controller: LDAP server channel binding token requirements', 'Settings': self.ldap_server_binding_token_requirements.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\NTDS\\\\Parameters', 'Value': 'LdapEnforceChannelBinding', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.ldap_server_binding_token_requirements, 'value_lookup': False}, 'PutArgs': {'lookup': self.ldap_server_binding_token_requirements, 'value_lookup': True}}}, 'LDAPServerIntegrity': {'Policy': 'Domain controller: LDAP server signing requirements', 'Settings': self.ldap_server_signing_requirements.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\NTDS\\\\Parameters', 'Value': 'LDAPServerIntegrity', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.ldap_server_signing_requirements, 'value_lookup': False}, 'PutArgs': {'lookup': self.ldap_server_signing_requirements, 'value_lookup': True}}}, 'RefusePasswordChange': {'Policy': 'Domain controller: Refuse machine account password changes', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'RefusePasswordChange', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'RequireSignOrSeal': {'Policy': 'Domain member: Digitally encrypt or sign secure channel data (always)', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'RequireSignOrSeal', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'SealSecureChannel': {'Policy': 'Domain member: Digitally encrypt secure channel data (when possible)', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'SealSecureChannel', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'SignSecureChannel': {'Policy': 'Domain member: Digitally sign secure channel data (when possible)', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'SignSecureChannel', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'DisablePasswordChange': {'Policy': 'Domain member: Disable machine account password changes', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'DisablePasswordChange', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'MaximumPasswordAge': {'Policy': 'Domain member: Maximum machine account password age', 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 999}}, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'MaximumPasswordAge', 'Type': 'REG_DWORD'}}, 'RequireStrongKey': {'Policy': 'Domain member: Require strong (Windows 2000 or later) session key', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'RequireStrongKey', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'LockoutDuration': {'Policy': 'Account lockout duration', 'lgpo_section': self.account_lockout_policy_gpedit_path, 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 6000000, 'zero_value': 4294967295}}, 'NetUserModal': {'Modal': 3, 'Option': 'lockout_duration'}, 'Transform': {'Get': '_seconds_to_minutes', 'Put': '_minutes_to_seconds', 'GetArgs': {'zero_value': 4294967295}, 'PutArgs': {'zero_value': 4294967295}}}, 'LockoutThreshold': {'Policy': 'Account lockout threshold', 'lgpo_section': self.account_lockout_policy_gpedit_path, 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 1000}}, 'NetUserModal': {'Modal': 3, 'Option': 'lockout_threshold'}}, 'LockoutWindow': {'Policy': 'Reset account lockout counter after', 'lgpo_section': self.account_lockout_policy_gpedit_path, 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 6000000}}, 'NetUserModal': {'Modal': 3, 'Option': 'lockout_observation_window'}, 'Transform': {'Get': '_seconds_to_minutes', 'Put': '_minutes_to_seconds'}}, 'AuditAccountLogon': {'Policy': 'Audit account logon events', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditAccountLogon', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditAccountManage': {'Policy': 'Audit account management', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditAccountManage', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditDSAccess': {'Policy': 'Audit directory service access', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditDSAccess', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditLogonEvents': {'Policy': 'Audit logon events', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditLogonEvents', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditObjectAccess': {'Policy': 'Audit object access', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditObjectAccess', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditPolicyChange': {'Policy': 'Audit policy change', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditPolicyChange', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditPrivilegeUse': {'Policy': 'Audit privilege use', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditPrivilegeUse', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditProcessTracking': {'Policy': 'Audit process tracking', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditProcessTracking', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditSystemEvents': {'Policy': 'Audit system events', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditSystemEvents', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditCredentialValidation': {'Policy': 'Audit Credential Validation', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Credential Validation'}, 'Transform': self.advanced_audit_transform}, 'AuditKerberosAuthenticationService': {'Policy': 'Audit Kerberos Authentication Service', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Kerberos Authentication Service'}, 'Transform': self.advanced_audit_transform}, 'AuditKerberosServiceTicketOperations': {'Policy': 'Audit Kerberos Service Ticket Operations', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Kerberos Service Ticket Operations'}, 'Transform': self.advanced_audit_transform}, 'AuditOtherAccountLogonEvents': {'Policy': 'Audit Other Account Logon Events', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Other Account Logon Events'}, 'Transform': self.advanced_audit_transform}, 'AuditApplicationGroupManagement': {'Policy': 'Audit Application Group Management', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Application Group Management'}, 'Transform': self.advanced_audit_transform}, 'AuditComputerAccountManagement': {'Policy': 'Audit Computer Account Management', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Computer Account Management'}, 'Transform': self.advanced_audit_transform}, 'AuditDistributionGroupManagement': {'Policy': 'Audit Distribution Group Management', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Distribution Group Management'}, 'Transform': self.advanced_audit_transform}, 'AuditOtherAccountManagementEvents': {'Policy': 'Audit Other Account Management Events', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Other Account Management Events'}, 'Transform': self.advanced_audit_transform}, 'AuditSecurityGroupManagement': {'Policy': 'Audit Security Group Management', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Security Group Management'}, 'Transform': self.advanced_audit_transform}, 'AuditUserAccountManagement': {'Policy': 'Audit User Account Management', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit User Account Management'}, 'Transform': self.advanced_audit_transform}, 'AuditDPAPIActivity': {'Policy': 'Audit DPAPI Activity', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit DPAPI Activity'}, 'Transform': self.advanced_audit_transform}, 'AuditPNPActivity': {'Policy': 'Audit PNP Activity', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit PNP Activity'}, 'Transform': self.advanced_audit_transform}, 'AuditProcessCreation': {'Policy': 'Audit Process Creation', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Process Creation'}, 'Transform': self.advanced_audit_transform}, 'AuditProcessTermination': {'Policy': 'Audit Process Termination', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Process Termination'}, 'Transform': self.advanced_audit_transform}, 'AuditRPCEvents': {'Policy': 'Audit RPC Events', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit RPC Events'}, 'Transform': self.advanced_audit_transform}, 'AuditTokenRightAdjusted': {'Policy': 'Audit Token Right Adjusted', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Token Right Adjusted'}, 'Transform': self.advanced_audit_transform}, 'AuditDetailedDirectoryServiceReplication': {'Policy': 'Audit Detailed Directory Service Replication', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Detailed Directory Service Replication'}, 'Transform': self.advanced_audit_transform}, 'AuditDirectoryServiceAccess': {'Policy': 'Audit Directory Service Access', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Directory Service Access'}, 'Transform': self.advanced_audit_transform}, 'AuditDirectoryServiceChanges': {'Policy': 'Audit Directory Service Changes', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Directory Service Changes'}, 'Transform': self.advanced_audit_transform}, 'AuditDirectoryServiceReplication': {'Policy': 'Audit Directory Service Replication', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Directory Service Replication'}, 'Transform': self.advanced_audit_transform}, 'AuditAccountLockout': {'Policy': 'Audit Account Lockout', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Account Lockout'}, 'Transform': self.advanced_audit_transform}, 'AuditUserDeviceClaims': {'Policy': 'Audit User / Device Claims', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit User / Device Claims'}, 'Transform': self.advanced_audit_transform}, 'AuditGroupMembership': {'Policy': 'Audit Group Membership', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Group Membership'}, 'Transform': self.advanced_audit_transform}, 'AuditIPsecExtendedMode': {'Policy': 'Audit IPsec Extended Mode', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit IPsec Extended Mode'}, 'Transform': self.advanced_audit_transform}, 'AuditIPsecMainMode': {'Policy': 'Audit IPsec Main Mode', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit IPsec Main Mode'}, 'Transform': self.advanced_audit_transform}, 'AuditIPsecQuickMode': {'Policy': 'Audit IPsec Quick Mode', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit IPsec Quick Mode'}, 'Transform': self.advanced_audit_transform}, 'AuditLogoff': {'Policy': 'Audit Logoff', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Logoff'}, 'Transform': self.advanced_audit_transform}, 'AuditLogon': {'Policy': 'Audit Logon', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Logon'}, 'Transform': self.advanced_audit_transform}, 'AuditNetworkPolicyServer': {'Policy': 'Audit Network Policy Server', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Network Policy Server'}, 'Transform': self.advanced_audit_transform}, 'AuditOtherLogonLogoffEvents': {'Policy': 'Audit Other Logon/Logoff Events', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Other Logon/Logoff Events'}, 'Transform': self.advanced_audit_transform}, 'AuditSpecialLogon': {'Policy': 'Audit Special Logon', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Special Logon'}, 'Transform': self.advanced_audit_transform}, 'AuditApplicationGenerated': {'Policy': 'Audit Application Generated', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Application Generated'}, 'Transform': self.advanced_audit_transform}, 'AuditCertificationServices': {'Policy': 'Audit Certification Services', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Certification Services'}, 'Transform': self.advanced_audit_transform}, 'AuditDetailedFileShare': {'Policy': 'Audit Detailed File Share', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Detailed File Share'}, 'Transform': self.advanced_audit_transform}, 'AuditFileShare': {'Policy': 'Audit File Share', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit File Share'}, 'Transform': self.advanced_audit_transform}, 'AuditFileSystem': {'Policy': 'Audit File System', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit File System'}, 'Transform': self.advanced_audit_transform}, 'AuditFilteringPlatformConnection': {'Policy': 'Audit Filtering Platform Connection', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Filtering Platform Connection'}, 'Transform': self.advanced_audit_transform}, 'AuditFilteringPlatformPacketDrop': {'Policy': 'Audit Filtering Platform Packet Drop', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Filtering Platform Packet Drop'}, 'Transform': self.advanced_audit_transform}, 'AuditHandleManipulation': {'Policy': 'Audit Handle Manipulation', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Handle Manipulation'}, 'Transform': self.advanced_audit_transform}, 'AuditKernelObject': {'Policy': 'Audit Kernel Object', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Kernel Object'}, 'Transform': self.advanced_audit_transform}, 'AuditOtherObjectAccessEvents': {'Policy': 'Audit Other Object Access Events', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Other Object Access Events'}, 'Transform': self.advanced_audit_transform}, 'AuditRegistry': {'Policy': 'Audit Registry', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Registry'}, 'Transform': self.advanced_audit_transform}, 'AuditRemovableStorage': {'Policy': 'Audit Removable Storage', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Removable Storage'}, 'Transform': self.advanced_audit_transform}, 'AuditSAM': {'Policy': 'Audit SAM', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit SAM'}, 'Transform': self.advanced_audit_transform}, 'AuditCentralAccessPolicyStaging': {'Policy': 'Audit Central Access Policy Staging', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Central Access Policy Staging'}, 'Transform': self.advanced_audit_transform}, 'AuditAuditPolicyChange': {'Policy': 'Audit Audit Policy Change', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Audit Policy Change'}, 'Transform': self.advanced_audit_transform}, 'AuditAuthenticationPolicyChange': {'Policy': 'Audit Authentication Policy Change', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Authentication Policy Change'}, 'Transform': self.advanced_audit_transform}, 'AuditAuthorizationPolicyChange': {'Policy': 'Audit Authorization Policy Change', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Authorization Policy Change'}, 'Transform': self.advanced_audit_transform}, 'AuditFilteringPlatformPolicyChange': {'Policy': 'Audit Filtering Platform Policy Change', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Filtering Platform Policy Change'}, 'Transform': self.advanced_audit_transform}, 'AuditMPSSVCRuleLevelPolicyChange': {'Policy': 'Audit MPSSVC Rule-Level Policy Change', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit MPSSVC Rule-Level Policy Change'}, 'Transform': self.advanced_audit_transform}, 'AuditOtherPolicyChangeEvents': {'Policy': 'Audit Other Policy Change Events', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Other Policy Change Events'}, 'Transform': self.advanced_audit_transform}, 'AuditNonSensitivePrivilegeUse': {'Policy': 'Audit Non Sensitive Privilege Use', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Non Sensitive Privilege Use'}, 'Transform': self.advanced_audit_transform}, 'AuditOtherPrivilegeUseEvents': {'Policy': 'Audit Other Privilege Use Events', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Other Privilege Use Events'}, 'Transform': self.advanced_audit_transform}, 'AuditSensitivePrivilegeUse': {'Policy': 'Audit Sensitive Privilege Use', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Sensitive Privilege Use'}, 'Transform': self.advanced_audit_transform}, 'AuditIPsecDriver': {'Policy': 'Audit IPsec Driver', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit IPsec Driver'}, 'Transform': self.advanced_audit_transform}, 'AuditOtherSystemEvents': {'Policy': 'Audit Other System Events', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Other System Events'}, 'Transform': self.advanced_audit_transform}, 'AuditSecurityStateChange': {'Policy': 'Audit Security State Change', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Security State Change'}, 'Transform': self.advanced_audit_transform}, 'AuditSecuritySystemExtension': {'Policy': 'Audit Security System Extension', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Security System Extension'}, 'Transform': self.advanced_audit_transform}, 'AuditSystemIntegrity': {'Policy': 'Audit System Integrity', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit System Integrity'}, 'Transform': self.advanced_audit_transform}, 'SeTrustedCredManAccessPrivilege': {'Policy': 'Access Credential Manager as a trusted caller', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeTrustedCredManAccessPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeNetworkLogonRight': {'Policy': 'Access this computer from the network', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeNetworkLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeTcbPrivilege': {'Policy': 'Act as part of the operating system', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeTcbPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeMachineAccountPrivilege': {'Policy': 'Add workstations to domain', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeMachineAccountPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeIncreaseQuotaPrivilege': {'Policy': 'Adjust memory quotas for a process', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeIncreaseQuotaPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeInteractiveLogonRight': {'Policy': 'Allow log on locally', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeInteractiveLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeRemoteInteractiveLogonRight': {'Policy': 'Allow log on through Remote Desktop Services', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeRemoteInteractiveLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeBackupPrivilege': {'Policy': 'Backup files and directories', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeBackupPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeChangeNotifyPrivilege': {'Policy': 'Bypass traverse checking', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeChangeNotifyPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeSystemtimePrivilege': {'Policy': 'Change the system time', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeSystemtimePrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeTimeZonePrivilege': {'Policy': 'Change the time zone', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeTimeZonePrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeCreatePagefilePrivilege': {'Policy': 'Create a pagefile', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeCreatePagefilePrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeCreateTokenPrivilege': {'Policy': 'Create a token object', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeCreateTokenPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeCreateGlobalPrivilege': {'Policy': 'Create global objects', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeCreateGlobalPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeCreatePermanentPrivilege': {'Policy': 'Create permanent shared objects', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeCreatePermanentPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeCreateSymbolicLinkPrivilege': {'Policy': 'Create symbolic links', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeCreateSymbolicLinkPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeDebugPrivilege': {'Policy': 'Debug programs', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeDebugPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeDenyNetworkLogonRight': {'Policy': 'Deny access to this computer from the network', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeDenyNetworkLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeDenyBatchLogonRight': {'Policy': 'Deny log on as a batch job', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeDenyBatchLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeDenyServiceLogonRight': {'Policy': 'Deny log on as a service', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeDenyServiceLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeDenyInteractiveLogonRight': {'Policy': 'Deny log on locally', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeDenyInteractiveLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeDenyRemoteInteractiveLogonRight': {'Policy': 'Deny log on through Remote Desktop Services', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeDenyRemoteInteractiveLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeEnableDelegationPrivilege': {'Policy': 'Enable computer and user accounts to be trusted for delegation', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeEnableDelegationPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeRemoteShutdownPrivilege': {'Policy': 'Force shutdown from a remote system', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeRemoteShutdownPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeAuditPrivilege': {'Policy': 'Generate security audits', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeAuditPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeImpersonatePrivilege': {'Policy': 'Impersonate a client after authentication', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeImpersonatePrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeIncreaseWorkingSetPrivilege': {'Policy': 'Increase a process working set', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeIncreaseWorkingSetPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeIncreaseBasePriorityPrivilege': {'Policy': 'Increase scheduling priority', 'rights_assignment': True, 'lgpo_section': self.user_rights_assignment_gpedit_path, 'Settings': None, 'LsaRights': {'Option': 'SeIncreaseBasePriorityPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeLoadDriverPrivilege': {'Policy': 'Load and unload device drivers', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeLoadDriverPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeLockMemoryPrivilege': {'Policy': 'Lock pages in memory', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeLockMemoryPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeBatchLogonRight': {'Policy': 'Log on as a batch job', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeBatchLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeServiceLogonRight': {'Policy': 'Log on as a service', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeServiceLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeSecurityPrivilege': {'Policy': 'Manage auditing and security log', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeSecurityPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeRelabelPrivilege': {'Policy': 'Modify an object label', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeRelabelPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeSystemEnvironmentPrivilege': {'Policy': 'Modify firmware environment values', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeSystemEnvironmentPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeManageVolumePrivilege': {'Policy': 'Perform volume maintenance tasks', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeManageVolumePrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeProfileSingleProcessPrivilege': {'Policy': 'Profile single process', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeProfileSingleProcessPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeSystemProfilePrivilege': {'Policy': 'Profile system performance', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeSystemProfilePrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeUndockPrivilege': {'Policy': 'Remove computer from docking station', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeUndockPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeAssignPrimaryTokenPrivilege': {'Policy': 'Replace a process level token', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeAssignPrimaryTokenPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeRestorePrivilege': {'Policy': 'Restore files and directories', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeRestorePrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeShutdownPrivilege': {'Policy': 'Shut down the system', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeShutdownPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeSyncAgentPrivilege': {'Policy': 'Synchronize directory service data', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeSyncAgentPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeTakeOwnershipPrivilege': {'Policy': 'Take ownership of files or other objects', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeTakeOwnershipPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'RecoveryConsoleSecurityLevel': {'Policy': 'Recovery console: Allow automatic administrative logon', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Setup\\\\RecoveryConsole', 'Value': 'SecurityLevel', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'RecoveryConsoleSetCommand': {'Policy': 'Recovery console: Allow floppy copy and access to all drives and all folders', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Setup\\\\RecoveryConsole', 'Value': 'SetCommand', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'ForceKeyProtection': {'Policy': 'System Cryptography: Force strong key protection for user keys stored on the computer', 'Settings': self.force_key_protection.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Policies\\\\Microsoft\\\\Cryptography', 'Value': 'ForceKeyProtection', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.force_key_protection, 'value_lookup': False}, 'PutArgs': {'lookup': self.force_key_protection, 'value_lookup': True}}}, 'FIPSAlgorithmPolicy': {'Policy': 'System Cryptography: Use FIPS compliant algorithms for encryption, hashing, and signing', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\FIPSAlgorithmPolicy', 'Value': 'Enabled', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'MachineAccessRestriction': {'Policy': 'DCOM: Machine Access Restrictions in Security Descriptor Definition Language (SDDL) syntax', 'Settings': None, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Policies\\\\Microsoft\\\\Windows NT\\\\DCOM', 'Value': 'MachineAccessRestriction', 'Type': 'REG_SZ'}, 'Transform': {'Put': '_string_put_transform'}}, 'MachineLaunchRestriction': {'Policy': 'DCOM: Machine Launch Restrictions in Security Descriptor Definition Language (SDDL) syntax', 'Settings': None, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Policies\\\\Microsoft\\\\Windows NT\\\\DCOM', 'Value': 'MachineLaunchRestriction', 'Type': 'REG_SZ'}, 'Transform': {'Put': '_string_put_transform'}}, 'UseMachineId': {'Policy': 'Network security: Allow Local System to use computer identity for NTLM', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'UseMachineId', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'allownullsessionfallback': {'Policy': 'Network security: Allow LocalSystem NULL session fallback', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\MSV1_0', 'Value': 'allownullsessionfallback', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'AllowOnlineID': {'Policy': 'Network security: Allow PKU2U authentication requests to this computer to use online identities.', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\pku2u', 'Value': 'AllowOnlineID', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'KrbSupportedEncryptionTypes': {'Policy': 'Network security: Configure encryption types allowed for Kerberos', 'Settings': None, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\policies\\\\system\\\\Kerberos\\\\Parameters', 'Value': 'SupportedEncryptionTypes', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup_bitwise_add', 'Put': '_dict_lookup_bitwise_add', 'GetArgs': {'lookup': self.krb_encryption_types, 'value_lookup': False}, 'PutArgs': {'lookup': self.krb_encryption_types, 'value_lookup': True}}}, 'NoLMHash': {'Policy': 'Network security: Do not store LAN Manager hash value on next password change', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'NoLMHash', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'ForceLogoffWhenHourExpire': {'Policy': 'Network security: Force logoff when logon hours expire', 'lgpo_section': self.security_options_gpedit_path, 'Settings': self.enabled_one_disabled_zero_no_not_defined.keys(), 'Secedit': {'Option': 'ForceLogoffWhenHourExpire', 'Section': 'System Access'}, 'Transform': self.enabled_one_disabled_zero_no_not_defined_transform}, 'LmCompatibilityLevel': {'Policy': 'Network security: LAN Manager authentication level', 'Settings': self.lm_compat_levels.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'LmCompatibilityLevel', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.lm_compat_levels, 'value_lookup': False}, 'PutArgs': {'lookup': self.lm_compat_levels, 'value_lookup': True}}}, 'LDAPClientIntegrity': {'Policy': 'Network security: LDAP client signing requirements', 'Settings': self.ldap_signing_reqs.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\ldap', 'Value': 'LDAPClientIntegrity', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.ldap_signing_reqs, 'value_lookup': False}, 'PutArgs': {'lookup': self.ldap_signing_reqs, 'value_lookup': True}}}, 'NTLMMinClientSec': {'Policy': 'Network security: Minimum session security for NTLM SSP based (including secure RPC) clients', 'Settings': None, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\MSV1_0', 'Value': 'NTLMMinClientSec', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup_bitwise_add', 'Put': '_dict_lookup_bitwise_add', 'GetArgs': {'lookup': self.ntlm_session_security_levels, 'value_lookup': False}, 'PutArgs': {'lookup': self.ntlm_session_security_levels, 'value_lookup': True}}}, 'NTLMMinServerSec': {'Policy': 'Network security: Minimum session security for NTLM SSP based (including secure RPC) servers', 'Settings': None, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\MSV1_0', 'Value': 'NTLMMinServerSec', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup_bitwise_add', 'Put': '_dict_lookup_bitwise_add', 'GetArgs': {'lookup': self.ntlm_session_security_levels, 'value_lookup': False}, 'PutArgs': {'lookup': self.ntlm_session_security_levels, 'value_lookup': True}}}, 'ClientAllowedNTLMServers': {'Policy': 'Network security: Restrict NTLM: Add remote server exceptions for NTLM authentication', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\MSV1_0', 'Value': 'ClientAllowedNTLMServers', 'Type': 'REG_MULTI_SZ'}, 'Transform': {'Put': '_multi_string_put_transform', 'Get': '_multi_string_get_transform'}}, 'DCAllowedNTLMServers': {'Policy': 'Network security: Restrict NTLM: Add server exceptions in this domain', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'DCAllowedNTLMServers', 'Type': 'REG_MULTI_SZ'}, 'Transform': {'Put': '_multi_string_put_transform', 'Get': '_multi_string_get_transform'}}, 'AuditReceivingNTLMTraffic': {'Policy': 'Network security: Restrict NTLM: Audit Incoming NTLM Traffic', 'Settings': self.ntlm_audit_settings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\LSA\\\\MSV1_0', 'Value': 'AuditReceivingNTLMTraffic', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.ntlm_audit_settings, 'value_lookup': False}, 'PutArgs': {'lookup': self.ntlm_audit_settings, 'value_lookup': True}}}, 'AuditNTLMInDomain': {'Policy': 'Network security: Restrict NTLM: Audit NTLM authentication in this domain', 'Settings': self.ntlm_domain_audit_settings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'AuditNTLMInDomain', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.ntlm_domain_audit_settings, 'value_lookup': False}, 'PutArgs': {'lookup': self.ntlm_domain_audit_settings, 'value_lookup': True}}}, 'RestrictReceivingNTLMTraffic': {'Policy': 'Network security: Restrict NTLM: Incoming NTLM traffic', 'Settings': self.incoming_ntlm_settings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\LSA\\\\MSV1_0', 'Value': 'RestrictReceivingNTLMTraffic', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.incoming_ntlm_settings, 'value_lookup': False}, 'PutArgs': {'lookup': self.incoming_ntlm_settings, 'value_lookup': True}}}, 'RestrictNTLMInDomain': {'Policy': 'Network security: Restrict NTLM: NTLM authentication in this domain', 'Settings': self.ntlm_domain_auth_settings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'RestrictNTLMInDomain', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.ntlm_domain_auth_settings, 'value_lookup': False}, 'PutArgs': {'lookup': self.ntlm_domain_auth_settings, 'value_lookup': True}}}, 'RestrictSendingNTLMTraffic': {'Policy': 'Network security: Restrict NTLM: Outgoing NTLM traffic to remote servers', 'Settings': self.outgoing_ntlm_settings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\MSV1_0', 'Value': 'RestrictSendingNTLMTraffic', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.outgoing_ntlm_settings, 'value_lookup': False}, 'PutArgs': {'lookup': self.outgoing_ntlm_settings, 'value_lookup': True}}}, 'ShutdownWithoutLogon': {'Policy': 'Shutdown: Allow system to be shut down without having to log on', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\policies\\\\system', 'Value': 'ShutdownWithoutLogon', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'ClearPageFileAtShutdown': {'Policy': 'Shutdown: Clear virtual memory pagefile', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\SESSION MANAGER\\\\MEMORY MANAGEMENT', 'Value': 'ClearPageFileAtShutdown', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'ObCaseInsensitive': {'Policy': 'System objects: Require case insensitivity for non-Windows subsystems', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\SESSION MANAGER\\\\Kernel', 'Value': 'ObCaseInsensitive', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'ProtectionMode': {'Policy': 'System objects: Strengthen default permissions of internal system objects (e.g. Symbolic Links)', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\SESSION MANAGER', 'Value': 'ProtectionMode', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'OptionalSubsystems': {'Policy': 'System settings: Optional subsystems', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\SESSION MANAGER\\\\SubSystems', 'Value': 'optional', 'Type': 'REG_MULTI_SZ'}, 'Transform': {'Put': '_multi_string_put_transform', 'Get': '_multi_string_get_transform'}}, 'AuthenticodeEnabled': {'Policy': 'System settings: Use Certificate Rules on Windows Executables for Software Restriction Policies', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Policies\\\\Microsoft\\\\Windows\\\\safer\\\\codeidentifiers', 'Value': 'AuthenticodeEnabled', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}}}, 'User': {'lgpo_section': 'User Configuration', 'policies': {}}}",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.audit_lookup = {0: 'No auditing', 1: 'Success', 2: 'Failure', 3: 'Success, Failure', 'Not Defined': 'Not Defined', None: 'Not Defined'}\n    self.advanced_audit_lookup = {0: 'No Auditing', 1: 'Success', 2: 'Failure', 3: 'Success and Failure', None: 'Not Configured'}\n    self.sc_removal_lookup = {'0': 'No Action', '1': 'Lock Workstation', '2': 'Force Logoff', '3': 'Disconnect if a Remote Desktop Services session', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.uac_admin_prompt_lookup = {0: 'Elevate without prompting', 1: 'Prompt for credentials on the secure desktop', 2: 'Prompt for consent on the secure desktop', 3: 'Prompt for credentials', 4: 'Prompt for consent', 5: 'Prompt for consent for non-Windows binaries', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.uac_user_prompt_lookup = {0: 'Automatically deny elevation requests', 1: 'Prompt for credentials on the secure desktop', 3: 'Prompt for credentials', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.enabled_one_disabled_zero = {0: 'Disabled', 1: 'Enabled', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.enabled_one_disabled_zero_transform = {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.enabled_one_disabled_zero, 'value_lookup': False}, 'PutArgs': {'lookup': self.enabled_one_disabled_zero, 'value_lookup': True}}\n    self.s4u2self_options = {0: 'Default', 1: 'Enabled', 2: 'Disabled', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.audit_transform = {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.audit_lookup, 'value_lookup': False}, 'PutArgs': {'lookup': self.audit_lookup, 'value_lookup': True}}\n    self.advanced_audit_transform = {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.advanced_audit_lookup, 'value_lookup': False}, 'PutArgs': {'lookup': self.advanced_audit_lookup, 'value_lookup': True}}\n    self.enabled_one_disabled_zero_strings = {'0': 'Disabled', '1': 'Enabled', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.enabled_one_disabled_zero_strings_transform = {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.enabled_one_disabled_zero_strings, 'value_lookup': False}, 'PutArgs': {'lookup': self.enabled_one_disabled_zero_strings, 'value_lookup': True}}\n    self.security_options_gpedit_path = ['Computer Configuration', 'Windows Settings', 'Security Settings', 'Local Policies', 'Security Options']\n    self.windows_firewall_gpedit_path = ['Computer Configuration', 'Windows Settings', 'Security Settings', 'Windows Firewall with Advanced Security', 'Windows Firewall with Advanced Security - Local Group Policy Object']\n    self.password_policy_gpedit_path = ['Computer Configuration', 'Windows Settings', 'Security Settings', 'Account Policies', 'Password Policy']\n    self.audit_policy_gpedit_path = ['Computer Configuration', 'Windows Settings', 'Security Settings', 'Local Policies', 'Audit Policy']\n    self.advanced_audit_policy_gpedit_path = ['Computer Configuration', 'Windows Settings', 'Security Settings', 'Advanced Audit Policy Configuration', 'System Audit Policies - Local Group Policy Object']\n    self.account_lockout_policy_gpedit_path = ['Computer Configuration', 'Windows Settings', 'Security Settings', 'Account Policies', 'Account Lockout Policy']\n    self.user_rights_assignment_gpedit_path = ['Computer Configuration', 'Windows Settings', 'Security Settings', 'Local Policies', 'User Rights Assignment']\n    self.block_ms_accounts = {0: 'This policy is disabled', 1: \"Users can't add Microsoft accounts\", 3: \"Users can't add or log on with Microsoft accounts\", None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.ldap_server_binding_token_requirements = {0: 'Never', 1: 'When supported', 2: 'Always', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.ldap_server_signing_requirements = {1: 'None', 2: 'Require signing', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.smb_server_name_hardening_levels = {0: 'Off', 1: 'Accept if provided by client', 2: 'Required from client', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.locked_session_user_info = {1: 'User display name, domain and user names', 2: 'User display name only', 3: 'Do not display user information', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.force_guest = {0: 'Classic - local users authenticate as themselves', 1: 'Guest only - local users authenticate as Guest', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.force_key_protection = {0: 'User input is not required when new keys are stored and used', 1: 'User is prompted when the key is first used', 2: 'User must enter a password each time they use a key', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.firewall_inbound_connections = {'blockinbound': 'Block (default)', 'blockinboundalways': 'Block all connections', 'allowinbound': 'Allow', 'notconfigured': 'Not configured'}\n    self.firewall_outbound_connections = {'blockoutbound': 'Block', 'allowoutbound': 'Allow (default)', 'notconfigured': 'Not configured'}\n    self.firewall_rule_merging = {'enable': 'Yes (default)', 'disable': 'No', 'notconfigured': 'Not configured'}\n    self.firewall_log_packets_connections = {'enable': 'Yes', 'disable': 'No (default)', 'notconfigured': 'Not configured'}\n    self.firewall_notification = {'enable': 'Yes', 'disable': 'No', 'notconfigured': 'Not configured'}\n    self.firewall_state = {'on': 'On (recommended)', 'off': 'Off', 'notconfigured': 'Not configured'}\n    self.krb_encryption_types = {0: 'No minimum', 1: 'DES_CBC_CRC', 2: 'DES_CBD_MD5', 4: 'RC4_HMAC_MD5', 8: 'AES128_HMAC_SHA1', 16: 'AES256_HMAC_SHA1', 2147483616: 'Future Encryption Types', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.lm_compat_levels = {0: 'Send LM & NTLM response', 1: 'Send LM & NTLM - use NTLMv2 session security if negotiated', 2: 'Send NTLM response only', 3: 'Send NTLMv2 response only', 4: 'Send NTLMv2 response only. Refuse LM', 5: 'Send NTLMv2 response only. Refuse LM & NTLM', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.ldap_signing_reqs = {0: 'None', 1: 'Negotiate signing', 2: 'Require signing', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.ntlm_session_security_levels = {0: 'No minimum', 524288: 'Require NTLMv2 session security', 536870912: 'Require 128-bit encryption', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.ntlm_audit_settings = {0: 'Disable', 1: 'Enable auditing for domain accounts', 2: 'Enable auditing for all accounts', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.ntlm_domain_audit_settings = {0: 'Disable', 1: 'Enable for domain accounts to domain servers', 3: 'Enable for domain accounts', 5: 'Enable for domain servers', 7: 'Enable all', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.incoming_ntlm_settings = {0: 'Allow all', 1: 'Deny all domain accounts', 2: 'Deny all accounts', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.ntlm_domain_auth_settings = {0: 'Disable', 1: 'Deny for domain accounts to domain servers', 3: 'Deny for domain accounts', 5: 'Deny for domain servers', 7: 'Deny all', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.outgoing_ntlm_settings = {0: 'Allow all', 1: 'Audit all', 2: 'Deny all', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.enabled_one_disabled_zero_no_not_defined = {0: 'Disabled', 1: 'Enabled'}\n    self.enabled_one_disabled_zero_no_not_defined_transform = {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.enabled_one_disabled_zero_no_not_defined, 'value_lookup': False}, 'PutArgs': {'lookup': self.enabled_one_disabled_zero_no_not_defined, 'value_lookup': True}}\n    self.policies = {'Machine': {'lgpo_section': 'Computer Configuration', 'policies': {'StartupScripts': {'Policy': 'Startup Scripts', 'lgpo_section': ['Computer Configuration', 'Windows Settings', 'Scripts (Startup/Shutdown)', 'Startup'], 'ScriptIni': {'Section': 'Startup', 'IniPath': os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'Machine', 'Scripts', 'scripts.ini')}}, 'StartupPowershellScripts': {'Policy': 'Startup Powershell Scripts', 'lgpo_section': ['Computer Configuration', 'Windows Settings', 'Scripts (Startup/Shutdown)', 'Startup'], 'ScriptIni': {'Section': 'Startup', 'IniPath': os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'Machine', 'Scripts', 'psscripts.ini')}}, 'StartupPowershellScriptOrder': {'Policy': 'Startup - For this GPO, run scripts in the following order', 'lgpo_section': ['Computer Configuration', 'Windows Settings', 'Scripts (Startup/Shutdown)', 'Startup'], 'ScriptIni': {'IniPath': os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'Machine', 'Scripts', 'psscripts.ini'), 'Section': 'ScriptsConfig', 'SettingName': 'StartExecutePSFirst', 'Settings': ['true', 'false', None]}, 'Transform': {'Get': '_powershell_script_order_conversion', 'Put': '_powershell_script_order_reverse_conversion'}}, 'ShutdownScripts': {'Policy': 'Shutdown Scripts', 'lgpo_section': ['Computer Configuration', 'Windows Settings', 'Scripts (Startup/Shutdown)', 'Shutdown'], 'ScriptIni': {'Section': 'Shutdown', 'IniPath': os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'Machine', 'Scripts', 'scripts.ini')}}, 'ShutdownPowershellScripts': {'Policy': 'Shutdown Powershell Scripts', 'lgpo_section': ['Computer Configuration', 'Windows Settings', 'Scripts (Startup/Shutdown)', 'Shutdown'], 'ScriptIni': {'Section': 'Shutdown', 'IniPath': os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'Machine', 'Scripts', 'psscripts.ini')}}, 'ShutdownPowershellScriptOrder': {'Policy': 'Shutdown - For this GPO, run scripts in the following order', 'lgpo_section': ['Computer Configuration', 'Windows Settings', 'Scripts (Startup/Shutdown)', 'Shutdown'], 'ScriptIni': {'IniPath': os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'Machine', 'Scripts', 'psscripts.ini'), 'Section': 'ScriptsConfig', 'SettingName': 'EndExecutePSFirst', 'Settings': ['true', 'false', None]}, 'Transform': {'Get': '_powershell_script_order_conversion', 'Put': '_powershell_script_order_reverse_conversion'}}, 'LSAAnonymousNameLookup': {'Policy': 'Network access: Allow anonymous SID/Name translation', 'lgpo_section': self.password_policy_gpedit_path, 'Settings': self.enabled_one_disabled_zero_no_not_defined.keys(), 'Secedit': {'Option': 'LSAAnonymousNameLookup', 'Section': 'System Access'}, 'Transform': self.enabled_one_disabled_zero_no_not_defined_transform}, 'RestrictAnonymousSam': {'Policy': 'Network access: Do not allow anonymous enumeration of SAM accounts', 'lgpo_section': self.security_options_gpedit_path, 'Settings': self.enabled_one_disabled_zero.keys(), 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'RestrictAnonymousSam', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'RestrictRemoteSAM': {'Policy': 'Network access: Restrict clients allowed to make remote calls to SAM', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'RestrictRemoteSAM', 'Type': 'REG_SZ'}, 'Transform': {'Put': '_string_put_transform'}}, 'RestrictAnonymous': {'Policy': 'Network access: Do not allow anonymous enumeration of SAM accounts and shares', 'lgpo_section': self.security_options_gpedit_path, 'Settings': self.enabled_one_disabled_zero.keys(), 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'RestrictAnonymous', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'DisableDomainCreds': {'Policy': 'Network access: Do not allow storage of passwords and credentials for network authentication', 'lgpo_section': self.security_options_gpedit_path, 'Settings': self.enabled_one_disabled_zero.keys(), 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'DisableDomainCreds', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'EveryoneIncludesAnonymous': {'Policy': 'Network access: Let Everyone permissions apply to anonymous users', 'lgpo_section': self.security_options_gpedit_path, 'Settings': self.enabled_one_disabled_zero.keys(), 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'everyoneincludesanonymous', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'NullSessionPipes': {'Policy': 'Network access: Named Pipes that can be accessed anonymously', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'NullSessionPipes', 'Type': 'REG_MULTI_SZ'}, 'Transform': {'Put': '_multi_string_put_transform', 'Get': '_multi_string_get_transform'}}, 'RemoteRegistryExactPaths': {'Policy': 'Network access: Remotely accessible registry paths', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\SecurePipeServers\\\\winreg\\\\AllowedExactPaths', 'Value': 'Machine', 'Type': 'REG_MULTI_SZ'}, 'Transform': {'Put': '_multi_string_put_transform', 'Get': '_multi_string_get_transform'}}, 'RemoteRegistryPaths': {'Policy': 'Network access: Remotely accessible registry paths and sub-paths', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\SecurePipeServers\\\\winreg\\\\AllowedPaths', 'Value': 'Machine', 'Type': 'REG_MULTI_SZ'}, 'Transform': {'Put': '_multi_string_put_transform', 'Get': '_multi_string_get_transform'}}, 'RestrictNullSessAccess': {'Policy': 'Network access: Restrict anonymous access to Named Pipes and Shares', 'lgpo_section': self.security_options_gpedit_path, 'Settings': self.enabled_one_disabled_zero.keys(), 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'RestrictNullSessAccess', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'NullSessionShares': {'Policy': 'Network access: Shares that can be accessed anonymously', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'NullSessionShares', 'Type': 'REG_MULTI_SZ'}, 'Transform': {'Put': '_multi_string_put_transform', 'Get': '_multi_string_get_transform'}}, 'ForceGuest': {'Policy': 'Network access: Sharing and security model for local accounts', 'lgpo_section': self.security_options_gpedit_path, 'Settings': self.force_guest.keys(), 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'ForceGuest', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.force_guest, 'value_lookup': False}, 'PutArgs': {'lookup': self.force_guest, 'value_lookup': True}}}, 'WfwDomainState': {'Policy': 'Network firewall: Domain: State', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_state.keys(), 'NetSH': {'Profile': 'domain', 'Section': 'state', 'Option': 'State'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_state, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_state, 'value_lookup': True}}}, 'WfwPrivateState': {'Policy': 'Network firewall: Private: State', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_state.keys(), 'NetSH': {'Profile': 'private', 'Section': 'state', 'Option': 'State'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_state, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_state, 'value_lookup': True}}}, 'WfwPublicState': {'Policy': 'Network firewall: Public: State', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_state.keys(), 'NetSH': {'Profile': 'public', 'Section': 'state', 'Option': 'State'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_state, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_state, 'value_lookup': True}}}, 'WfwDomainInboundConnections': {'Policy': 'Network firewall: Domain: Inbound connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_inbound_connections.keys(), 'NetSH': {'Profile': 'domain', 'Section': 'firewallpolicy', 'Option': 'Inbound'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_inbound_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_inbound_connections, 'value_lookup': True}}}, 'WfwPrivateInboundConnections': {'Policy': 'Network firewall: Private: Inbound connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_inbound_connections.keys(), 'NetSH': {'Profile': 'private', 'Section': 'firewallpolicy', 'Option': 'Inbound'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_inbound_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_inbound_connections, 'value_lookup': True}}}, 'WfwPublicInboundConnections': {'Policy': 'Network firewall: Public: Inbound connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_inbound_connections.keys(), 'NetSH': {'Profile': 'public', 'Section': 'firewallpolicy', 'Option': 'Inbound'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_inbound_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_inbound_connections, 'value_lookup': True}}}, 'WfwDomainOutboundConnections': {'Policy': 'Network firewall: Domain: Outbound connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_outbound_connections.keys(), 'NetSH': {'Profile': 'domain', 'Section': 'firewallpolicy', 'Option': 'Outbound'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_outbound_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_outbound_connections, 'value_lookup': True}}}, 'WfwPrivateOutboundConnections': {'Policy': 'Network firewall: Private: Outbound connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_outbound_connections.keys(), 'NetSH': {'Profile': 'private', 'Section': 'firewallpolicy', 'Option': 'Outbound'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_outbound_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_outbound_connections, 'value_lookup': True}}}, 'WfwPublicOutboundConnections': {'Policy': 'Network firewall: Public: Outbound connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_outbound_connections.keys(), 'NetSH': {'Profile': 'public', 'Section': 'firewallpolicy', 'Option': 'Outbound'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_outbound_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_outbound_connections, 'value_lookup': True}}}, 'WfwDomainSettingsNotification': {'Policy': 'Network firewall: Domain: Settings: Display a notification', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_notification.keys(), 'NetSH': {'Profile': 'domain', 'Section': 'settings', 'Option': 'InboundUserNotification'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_notification, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_notification, 'value_lookup': True}}}, 'WfwPrivateSettingsNotification': {'Policy': 'Network firewall: Private: Settings: Display a notification', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_notification.keys(), 'NetSH': {'Profile': 'private', 'Section': 'settings', 'Option': 'InboundUserNotification'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_notification, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_notification, 'value_lookup': True}}}, 'WfwPublicSettingsNotification': {'Policy': 'Network firewall: Public: Settings: Display a notification', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_notification.keys(), 'NetSH': {'Profile': 'public', 'Section': 'settings', 'Option': 'InboundUserNotification'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_notification, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_notification, 'value_lookup': True}}}, 'WfwDomainSettingsLocalFirewallRules': {'Policy': 'Network firewall: Domain: Settings: Apply local firewall rules', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_rule_merging.keys(), 'NetSH': {'Profile': 'domain', 'Section': 'settings', 'Option': 'LocalFirewallRules'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': True}}}, 'WfwPrivateSettingsLocalFirewallRules': {'Policy': 'Network firewall: Private: Settings: Apply local firewall rules', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_rule_merging.keys(), 'NetSH': {'Profile': 'private', 'Section': 'settings', 'Option': 'LocalFirewallRules'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': True}}}, 'WfwPublicSettingsLocalFirewallRules': {'Policy': 'Network firewall: Public: Settings: Apply local firewall rules', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_rule_merging.keys(), 'NetSH': {'Profile': 'public', 'Section': 'settings', 'Option': 'LocalFirewallRules'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': True}}}, 'WfwDomainSettingsLocalConnectionRules': {'Policy': 'Network firewall: Domain: Settings: Apply local connection security rules', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_rule_merging.keys(), 'NetSH': {'Profile': 'domain', 'Section': 'settings', 'Option': 'LocalConSecRules'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': True}}}, 'WfwPrivateSettingsLocalConnectionRules': {'Policy': 'Network firewall: Private: Settings: Apply local connection security rules', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_rule_merging.keys(), 'NetSH': {'Profile': 'private', 'Section': 'settings', 'Option': 'LocalConSecRules'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': True}}}, 'WfwPublicSettingsLocalConnectionRules': {'Policy': 'Network firewall: Public: Settings: Apply local connection security rules', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_rule_merging.keys(), 'NetSH': {'Profile': 'public', 'Section': 'settings', 'Option': 'LocalConSecRules'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': True}}}, 'WfwDomainLoggingName': {'Policy': 'Network firewall: Domain: Logging: Name', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': None, 'NetSH': {'Profile': 'domain', 'Section': 'logging', 'Option': 'FileName'}}, 'WfwPrivateLoggingName': {'Policy': 'Network firewall: Private: Logging: Name', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': None, 'NetSH': {'Profile': 'private', 'Section': 'logging', 'Option': 'FileName'}}, 'WfwPublicLoggingName': {'Policy': 'Network firewall: Public: Logging: Name', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': None, 'NetSH': {'Profile': 'public', 'Section': 'logging', 'Option': 'FileName'}}, 'WfwDomainLoggingMaxFileSize': {'Policy': 'Network firewall: Domain: Logging: Size limit (KB)', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': None, 'NetSH': {'Profile': 'domain', 'Section': 'logging', 'Option': 'MaxFileSize'}}, 'WfwPrivateLoggingMaxFileSize': {'Policy': 'Network firewall: Private: Logging: Size limit (KB)', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': None, 'NetSH': {'Profile': 'private', 'Section': 'logging', 'Option': 'MaxFileSize'}}, 'WfwPublicLoggingMaxFileSize': {'Policy': 'Network firewall: Public: Logging: Size limit (KB)', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': None, 'NetSH': {'Profile': 'public', 'Section': 'logging', 'Option': 'MaxFileSize'}}, 'WfwDomainLoggingAllowedConnections': {'Policy': 'Network firewall: Domain: Logging: Log successful connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_log_packets_connections.keys(), 'NetSH': {'Profile': 'domain', 'Section': 'logging', 'Option': 'LogAllowedConnections'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': True}}}, 'WfwPrivateLoggingAllowedConnections': {'Policy': 'Network firewall: Private: Logging: Log successful connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_log_packets_connections.keys(), 'NetSH': {'Profile': 'private', 'Section': 'logging', 'Option': 'LogAllowedConnections'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': True}}}, 'WfwPublicLoggingAllowedConnections': {'Policy': 'Network firewall: Public: Logging: Log successful connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_log_packets_connections.keys(), 'NetSH': {'Profile': 'public', 'Section': 'logging', 'Option': 'LogAllowedConnections'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': True}}}, 'WfwDomainLoggingDroppedConnections': {'Policy': 'Network firewall: Domain: Logging: Log dropped packets', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_log_packets_connections.keys(), 'NetSH': {'Profile': 'domain', 'Section': 'logging', 'Option': 'LogDroppedConnections'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': True}}}, 'WfwPrivateLoggingDroppedConnections': {'Policy': 'Network firewall: Private: Logging: Log dropped packets', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_log_packets_connections.keys(), 'NetSH': {'Profile': 'private', 'Section': 'logging', 'Option': 'LogDroppedConnections'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': True}}}, 'WfwPublicLoggingDroppedConnections': {'Policy': 'Network firewall: Public: Logging: Log dropped packets', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_log_packets_connections.keys(), 'NetSH': {'Profile': 'public', 'Section': 'logging', 'Option': 'LogDroppedConnections'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': True}}}, 'PasswordHistory': {'Policy': 'Enforce password history', 'lgpo_section': self.password_policy_gpedit_path, 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 24}}, 'NetUserModal': {'Modal': 0, 'Option': 'password_hist_len'}}, 'MaxPasswordAge': {'Policy': 'Maximum password age', 'lgpo_section': self.password_policy_gpedit_path, 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 1, 'max': 86313600, 'zero_value': 4294967295}}, 'NetUserModal': {'Modal': 0, 'Option': 'max_passwd_age'}, 'Transform': {'Get': '_seconds_to_days', 'Put': '_days_to_seconds', 'GetArgs': {'zero_value': 4294967295}, 'PutArgs': {'zero_value': 4294967295}}}, 'MinPasswordAge': {'Policy': 'Minimum password age', 'lgpo_section': self.password_policy_gpedit_path, 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 86313600}}, 'NetUserModal': {'Modal': 0, 'Option': 'min_passwd_age'}, 'Transform': {'Get': '_seconds_to_days', 'Put': '_days_to_seconds'}}, 'MinPasswordLen': {'Policy': 'Minimum password length', 'lgpo_section': self.password_policy_gpedit_path, 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 14}}, 'NetUserModal': {'Modal': 0, 'Option': 'min_passwd_len'}}, 'PasswordComplexity': {'Policy': 'Password must meet complexity requirements', 'lgpo_section': self.password_policy_gpedit_path, 'Settings': self.enabled_one_disabled_zero_no_not_defined.keys(), 'Secedit': {'Option': 'PasswordComplexity', 'Section': 'System Access'}, 'Transform': self.enabled_one_disabled_zero_no_not_defined_transform}, 'ClearTextPasswords': {'Policy': 'Store passwords using reversible encryption', 'lgpo_section': self.password_policy_gpedit_path, 'Settings': self.enabled_one_disabled_zero_no_not_defined.keys(), 'Secedit': {'Option': 'ClearTextPassword', 'Section': 'System Access'}, 'Transform': self.enabled_one_disabled_zero_no_not_defined_transform}, 'RelaxMinimumPasswordLengthLimits': {'Policy': 'Relax minimum password length limits', 'lgpo_section': self.password_policy_gpedit_path, 'Settings': self.enabled_one_disabled_zero.keys(), 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\SAM', 'Value': 'RelaxMinimumPasswordLengthLimits', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'AdminAccountStatus': {'Policy': 'Accounts: Administrator account status', 'Settings': self.enabled_one_disabled_zero_no_not_defined.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Secedit': {'Option': 'EnableAdminAccount', 'Section': 'System Access'}, 'Transform': self.enabled_one_disabled_zero_no_not_defined_transform}, 'NoConnectedUser': {'Policy': 'Accounts: Block Microsoft accounts', 'Settings': self.block_ms_accounts.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\policies\\\\system', 'Value': 'NoConnectedUser', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.block_ms_accounts, 'value_lookup': False}, 'PutArgs': {'lookup': self.block_ms_accounts, 'value_lookup': True}}}, 'GuestAccountStatus': {'Policy': 'Accounts: Guest account status', 'Settings': self.enabled_one_disabled_zero_no_not_defined.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Secedit': {'Option': 'EnableGuestAccount', 'Section': 'System Access'}, 'Transform': self.enabled_one_disabled_zero_no_not_defined_transform}, 'LimitBlankPasswordUse': {'Policy': 'Accounts: Limit local account use of blank passwords to console logon only', 'lgpo_section': self.security_options_gpedit_path, 'Settings': self.enabled_one_disabled_zero.keys(), 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'limitblankpassworduse', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'RenameAdministratorAccount': {'Policy': 'Accounts: Rename administrator account', 'Settings': None, 'lgpo_section': self.security_options_gpedit_path, 'Secedit': {'Option': 'NewAdministratorName', 'Section': 'System Access'}, 'Transform': {'Get': '_strip_quotes', 'Put': '_add_quotes'}}, 'RenameGuestAccount': {'Policy': 'Accounts: Rename guest account', 'Settings': None, 'lgpo_section': self.security_options_gpedit_path, 'Secedit': {'Option': 'NewGuestName', 'Section': 'System Access'}, 'Transform': {'Get': '_strip_quotes', 'Put': '_add_quotes'}}, 'AuditBaseObjects': {'Policy': 'Audit: Audit the access of global system objects', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'AuditBaseObjects', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'SceNoApplyLegacyAuditPolicy': {'Policy': 'Audit: Force audit policy subcategory settings (Windows Vista or later) to override audit policy category settings', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'SCENoApplyLegacyAuditPolicy', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'DontDisplayLastUserName': {'Policy': 'Interactive logon: Do not display last user name', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'DontDisplayLastUserName', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'CachedLogonsCount': {'Policy': 'Interactive logon: Number of previous logons to cache (in case domain controller is not available)', 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 50}}, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon', 'Value': 'CachedLogonsCount', 'Type': 'REG_SZ'}}, 'ForceUnlockLogon': {'Policy': 'Interactive logon: Require Domain Controller authentication to unlock workstation', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon', 'Value': 'ForceUnlockLogon', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'ScRemoveOption': {'Policy': 'Interactive logon: Smart card removal behavior', 'Settings': self.sc_removal_lookup.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon', 'Value': 'ScRemoveOption', 'Type': 'REG_SZ'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.sc_removal_lookup, 'value_lookup': False}, 'PutArgs': {'lookup': self.sc_removal_lookup, 'value_lookup': True}}}, 'DisableCAD': {'Policy': 'Interactive logon: Do not require CTRL+ALT+DEL', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'DisableCAD', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'FilterAdministratorToken': {'Policy': 'User Account Control: Admin Approval Mode for the built-in Administrator account', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'FilterAdministratorToken', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'EnableUIADesktopToggle': {'Policy': 'User Account Control: Allow UIAccess applications to prompt for elevation without using the secure desktop', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'EnableUIADesktopToggle', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'ConsentPromptBehaviorAdmin': {'Policy': 'User Account Control: Behavior of the elevation prompt for administrators in Admin Approval Mode', 'Settings': self.uac_admin_prompt_lookup.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'ConsentPromptBehaviorAdmin', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.uac_admin_prompt_lookup, 'value_lookup': False}, 'PutArgs': {'lookup': self.uac_admin_prompt_lookup, 'value_lookup': True}}}, 'ConsentPromptBehaviorUser': {'Policy': 'User Account Control: Behavior of the elevation prompt for standard users', 'Settings': self.uac_user_prompt_lookup.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'ConsentPromptBehaviorUser', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.uac_user_prompt_lookup, 'value_lookup': False}, 'PutArgs': {'lookup': self.uac_user_prompt_lookup, 'value_lookup': True}}}, 'EnableInstallerDetection': {'Policy': 'User Account Control: Detect application installations and prompt for elevation', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'EnableInstallerDetection', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'ValidateAdminCodeSignatures': {'Policy': 'User Account Control: Only elevate executables that are signed and validated', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'ValidateAdminCodeSignatures', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'EnableSecureUIAPaths': {'Policy': 'User Account Control: Only elevate UIAccess applications that are installed in secure locations', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'EnableSecureUIAPaths', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'EnableLUA': {'Policy': 'User Account Control: Run all administrators in Admin Approval Mode', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'EnableLUA', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'PromptOnSecureDesktop': {'Policy': 'User Account Control: Switch to the secure desktop when prompting for elevation', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'PromptOnSecureDesktop', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'EnableVirtualization': {'Policy': 'User Account Control: Virtualize file and registry write failures to per-user locations', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'EnableVirtualization', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'PasswordExpiryWarning': {'Policy': 'Interactive logon: Prompt user to change password before expiration', 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 999}}, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon', 'Value': 'PasswordExpiryWarning', 'Type': 'REG_DWORD'}}, 'MaxDevicePasswordFailedAttempts': {'Policy': 'Interactive logon: Machine account lockout threshold', 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 999}}, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\policies\\\\system', 'Value': 'MaxDevicePasswordFailedAttempts', 'Type': 'REG_DWORD'}}, 'InactivityTimeoutSecs': {'Policy': 'Interactive logon: Machine inactivity limit', 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 599940}}, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\policies\\\\system', 'Value': 'InactivityTimeoutSecs', 'Type': 'REG_DWORD'}}, 'legalnoticetext': {'Policy': 'Interactive logon: Message text for users attempting to log on', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\policies\\\\system', 'Value': 'legalnoticetext', 'Type': 'REG_SZ'}, 'Transform': {'Put': '_string_put_transform'}}, 'legalnoticecaption': {'Policy': 'Interactive logon: Message title for users attempting to log on', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\policies\\\\system', 'Value': 'legalnoticecaption', 'Type': 'REG_SZ'}, 'Transform': {'Put': '_string_put_transform'}}, 'DontDisplayLockedUserId': {'Policy': 'Interactive logon: Display user information when the session is locked', 'Settings': self.locked_session_user_info.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\policies\\\\system', 'Value': 'DontDisplayLockedUserId', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.locked_session_user_info, 'value_lookup': False}, 'PutArgs': {'lookup': self.locked_session_user_info, 'value_lookup': True}}}, 'ScForceOption': {'Policy': 'Interactive logon: Require smart card', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'ScForceOption', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'Client_RequireSecuritySignature': {'Policy': 'Microsoft network client: Digitally sign communications (always)', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\LanmanWorkstation\\\\Parameters', 'Value': 'RequireSecuritySignature', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'Client_EnableSecuritySignature': {'Policy': 'Microsoft network client: Digitally sign communications (if server agrees)', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\LanmanWorkstation\\\\Parameters', 'Value': 'EnableSecuritySignature', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'EnablePlainTextPassword': {'Policy': 'Microsoft network client: Send unencrypted password to third-party SMB servers', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\LanmanWorkstation\\\\Parameters', 'Value': 'EnablePlainTextPassword', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'AutoDisconnect': {'Policy': 'Microsoft network server: Amount of idle time required before suspending session', 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 99999}}, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'AutoDisconnect', 'Type': 'REG_DWORD'}}, 'EnableS4U2SelfForClaims': {'Policy': 'Microsoft network server: Attempt S4U2Self to obtain claim information', 'Settings': self.s4u2self_options.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'EnableS4U2SelfForClaims', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.s4u2self_options, 'value_lookup': False}, 'PutArgs': {'lookup': self.s4u2self_options, 'value_lookup': True}}}, 'Server_RequireSecuritySignature': {'Policy': 'Microsoft network server: Digitally sign communications (always)', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'RequireSecuritySignature', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'Server_EnableSecuritySignature': {'Policy': 'Microsoft network server: Digitally sign communications (if client agrees)', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'EnableSecuritySignature', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'EnableForcedLogoff': {'Policy': 'Microsoft network server: Disconnect clients when logon hours expire', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'EnableForcedLogoff', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'SmbServerNameHardeningLevel': {'Policy': 'Microsoft network server: Server SPN target name validation level', 'Settings': self.smb_server_name_hardening_levels.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'SmbServerNameHardeningLevel', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.smb_server_name_hardening_levels, 'value_lookup': False}, 'PutArgs': {'lookup': self.smb_server_name_hardening_levels, 'value_lookup': True}}}, 'FullPrivilegeAuditing': {'Policy': 'Audit: Audit the use of Backup and Restore privilege', 'Settings': [chr(0), chr(1)], 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'FullPrivilegeAuditing', 'Type': 'REG_BINARY'}, 'Transform': {'Get': '_binary_enable_zero_disable_one_conversion', 'Put': '_binary_enable_zero_disable_one_reverse_conversion'}}, 'CrashOnAuditFail': {'Policy': 'Audit: Shut down system immediately if unable to log security audits', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'CrashOnAuditFail', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'UndockWithoutLogon': {'Policy': 'Devices: Allow undock without having to log on', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'UndockWithoutLogon', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'AddPrinterDrivers': {'Policy': 'Devices: Prevent users from installing printer drivers', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\Print\\\\Providers\\\\LanMan Print Services\\\\Servers', 'Value': 'AddPrinterDrivers', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'AllocateDASD': {'Policy': 'Devices: Allowed to format and eject removable media', 'Settings': ['9999', '0', '1', '2'], 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon', 'Value': 'AllocateDASD', 'Type': 'REG_SZ'}, 'Transform': {'Get': '_dasd_conversion', 'Put': '_dasd_reverse_conversion'}}, 'AllocateCDRoms': {'Policy': 'Devices: Restrict CD-ROM access to locally logged-on user only', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon', 'Value': 'AllocateCDRoms', 'Type': 'REG_SZ'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'AllocateFloppies': {'Policy': 'Devices: Restrict floppy access to locally logged-on user only', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon', 'Value': 'AllocateFloppies', 'Type': 'REG_SZ'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'DriverSigningPolicy': {'Policy': 'Devices: Unsigned driver installation behavior', 'Settings': ['3,0', '3,' + chr(1), '3,' + chr(2)], 'lgpo_section': self.security_options_gpedit_path, 'Secedit': {'Option': 'MACHINE\\\\Software\\\\Microsoft\\\\Driver Signing\\\\Policy', 'Section': 'Registry Values'}, 'Transform': {'Get': '_driver_signing_reg_conversion', 'Put': '_driver_signing_reg_reverse_conversion'}}, 'SubmitControl': {'Policy': 'Domain controller: Allow server operators to schedule tasks', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'SubmitControl', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'VulnerableChannelAllowList': {'Policy': 'Domain controller: Allow vulnerable Netlogon secure channel connections', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'VulnerableChannelAllowList', 'Type': 'REG_SZ'}, 'Transform': {'Put': '_string_put_transform'}}, 'LdapEnforceChannelBinding': {'Policy': 'Domain controller: LDAP server channel binding token requirements', 'Settings': self.ldap_server_binding_token_requirements.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\NTDS\\\\Parameters', 'Value': 'LdapEnforceChannelBinding', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.ldap_server_binding_token_requirements, 'value_lookup': False}, 'PutArgs': {'lookup': self.ldap_server_binding_token_requirements, 'value_lookup': True}}}, 'LDAPServerIntegrity': {'Policy': 'Domain controller: LDAP server signing requirements', 'Settings': self.ldap_server_signing_requirements.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\NTDS\\\\Parameters', 'Value': 'LDAPServerIntegrity', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.ldap_server_signing_requirements, 'value_lookup': False}, 'PutArgs': {'lookup': self.ldap_server_signing_requirements, 'value_lookup': True}}}, 'RefusePasswordChange': {'Policy': 'Domain controller: Refuse machine account password changes', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'RefusePasswordChange', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'RequireSignOrSeal': {'Policy': 'Domain member: Digitally encrypt or sign secure channel data (always)', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'RequireSignOrSeal', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'SealSecureChannel': {'Policy': 'Domain member: Digitally encrypt secure channel data (when possible)', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'SealSecureChannel', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'SignSecureChannel': {'Policy': 'Domain member: Digitally sign secure channel data (when possible)', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'SignSecureChannel', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'DisablePasswordChange': {'Policy': 'Domain member: Disable machine account password changes', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'DisablePasswordChange', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'MaximumPasswordAge': {'Policy': 'Domain member: Maximum machine account password age', 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 999}}, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'MaximumPasswordAge', 'Type': 'REG_DWORD'}}, 'RequireStrongKey': {'Policy': 'Domain member: Require strong (Windows 2000 or later) session key', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'RequireStrongKey', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'LockoutDuration': {'Policy': 'Account lockout duration', 'lgpo_section': self.account_lockout_policy_gpedit_path, 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 6000000, 'zero_value': 4294967295}}, 'NetUserModal': {'Modal': 3, 'Option': 'lockout_duration'}, 'Transform': {'Get': '_seconds_to_minutes', 'Put': '_minutes_to_seconds', 'GetArgs': {'zero_value': 4294967295}, 'PutArgs': {'zero_value': 4294967295}}}, 'LockoutThreshold': {'Policy': 'Account lockout threshold', 'lgpo_section': self.account_lockout_policy_gpedit_path, 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 1000}}, 'NetUserModal': {'Modal': 3, 'Option': 'lockout_threshold'}}, 'LockoutWindow': {'Policy': 'Reset account lockout counter after', 'lgpo_section': self.account_lockout_policy_gpedit_path, 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 6000000}}, 'NetUserModal': {'Modal': 3, 'Option': 'lockout_observation_window'}, 'Transform': {'Get': '_seconds_to_minutes', 'Put': '_minutes_to_seconds'}}, 'AuditAccountLogon': {'Policy': 'Audit account logon events', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditAccountLogon', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditAccountManage': {'Policy': 'Audit account management', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditAccountManage', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditDSAccess': {'Policy': 'Audit directory service access', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditDSAccess', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditLogonEvents': {'Policy': 'Audit logon events', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditLogonEvents', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditObjectAccess': {'Policy': 'Audit object access', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditObjectAccess', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditPolicyChange': {'Policy': 'Audit policy change', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditPolicyChange', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditPrivilegeUse': {'Policy': 'Audit privilege use', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditPrivilegeUse', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditProcessTracking': {'Policy': 'Audit process tracking', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditProcessTracking', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditSystemEvents': {'Policy': 'Audit system events', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditSystemEvents', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditCredentialValidation': {'Policy': 'Audit Credential Validation', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Credential Validation'}, 'Transform': self.advanced_audit_transform}, 'AuditKerberosAuthenticationService': {'Policy': 'Audit Kerberos Authentication Service', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Kerberos Authentication Service'}, 'Transform': self.advanced_audit_transform}, 'AuditKerberosServiceTicketOperations': {'Policy': 'Audit Kerberos Service Ticket Operations', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Kerberos Service Ticket Operations'}, 'Transform': self.advanced_audit_transform}, 'AuditOtherAccountLogonEvents': {'Policy': 'Audit Other Account Logon Events', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Other Account Logon Events'}, 'Transform': self.advanced_audit_transform}, 'AuditApplicationGroupManagement': {'Policy': 'Audit Application Group Management', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Application Group Management'}, 'Transform': self.advanced_audit_transform}, 'AuditComputerAccountManagement': {'Policy': 'Audit Computer Account Management', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Computer Account Management'}, 'Transform': self.advanced_audit_transform}, 'AuditDistributionGroupManagement': {'Policy': 'Audit Distribution Group Management', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Distribution Group Management'}, 'Transform': self.advanced_audit_transform}, 'AuditOtherAccountManagementEvents': {'Policy': 'Audit Other Account Management Events', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Other Account Management Events'}, 'Transform': self.advanced_audit_transform}, 'AuditSecurityGroupManagement': {'Policy': 'Audit Security Group Management', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Security Group Management'}, 'Transform': self.advanced_audit_transform}, 'AuditUserAccountManagement': {'Policy': 'Audit User Account Management', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit User Account Management'}, 'Transform': self.advanced_audit_transform}, 'AuditDPAPIActivity': {'Policy': 'Audit DPAPI Activity', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit DPAPI Activity'}, 'Transform': self.advanced_audit_transform}, 'AuditPNPActivity': {'Policy': 'Audit PNP Activity', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit PNP Activity'}, 'Transform': self.advanced_audit_transform}, 'AuditProcessCreation': {'Policy': 'Audit Process Creation', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Process Creation'}, 'Transform': self.advanced_audit_transform}, 'AuditProcessTermination': {'Policy': 'Audit Process Termination', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Process Termination'}, 'Transform': self.advanced_audit_transform}, 'AuditRPCEvents': {'Policy': 'Audit RPC Events', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit RPC Events'}, 'Transform': self.advanced_audit_transform}, 'AuditTokenRightAdjusted': {'Policy': 'Audit Token Right Adjusted', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Token Right Adjusted'}, 'Transform': self.advanced_audit_transform}, 'AuditDetailedDirectoryServiceReplication': {'Policy': 'Audit Detailed Directory Service Replication', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Detailed Directory Service Replication'}, 'Transform': self.advanced_audit_transform}, 'AuditDirectoryServiceAccess': {'Policy': 'Audit Directory Service Access', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Directory Service Access'}, 'Transform': self.advanced_audit_transform}, 'AuditDirectoryServiceChanges': {'Policy': 'Audit Directory Service Changes', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Directory Service Changes'}, 'Transform': self.advanced_audit_transform}, 'AuditDirectoryServiceReplication': {'Policy': 'Audit Directory Service Replication', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Directory Service Replication'}, 'Transform': self.advanced_audit_transform}, 'AuditAccountLockout': {'Policy': 'Audit Account Lockout', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Account Lockout'}, 'Transform': self.advanced_audit_transform}, 'AuditUserDeviceClaims': {'Policy': 'Audit User / Device Claims', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit User / Device Claims'}, 'Transform': self.advanced_audit_transform}, 'AuditGroupMembership': {'Policy': 'Audit Group Membership', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Group Membership'}, 'Transform': self.advanced_audit_transform}, 'AuditIPsecExtendedMode': {'Policy': 'Audit IPsec Extended Mode', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit IPsec Extended Mode'}, 'Transform': self.advanced_audit_transform}, 'AuditIPsecMainMode': {'Policy': 'Audit IPsec Main Mode', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit IPsec Main Mode'}, 'Transform': self.advanced_audit_transform}, 'AuditIPsecQuickMode': {'Policy': 'Audit IPsec Quick Mode', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit IPsec Quick Mode'}, 'Transform': self.advanced_audit_transform}, 'AuditLogoff': {'Policy': 'Audit Logoff', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Logoff'}, 'Transform': self.advanced_audit_transform}, 'AuditLogon': {'Policy': 'Audit Logon', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Logon'}, 'Transform': self.advanced_audit_transform}, 'AuditNetworkPolicyServer': {'Policy': 'Audit Network Policy Server', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Network Policy Server'}, 'Transform': self.advanced_audit_transform}, 'AuditOtherLogonLogoffEvents': {'Policy': 'Audit Other Logon/Logoff Events', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Other Logon/Logoff Events'}, 'Transform': self.advanced_audit_transform}, 'AuditSpecialLogon': {'Policy': 'Audit Special Logon', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Special Logon'}, 'Transform': self.advanced_audit_transform}, 'AuditApplicationGenerated': {'Policy': 'Audit Application Generated', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Application Generated'}, 'Transform': self.advanced_audit_transform}, 'AuditCertificationServices': {'Policy': 'Audit Certification Services', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Certification Services'}, 'Transform': self.advanced_audit_transform}, 'AuditDetailedFileShare': {'Policy': 'Audit Detailed File Share', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Detailed File Share'}, 'Transform': self.advanced_audit_transform}, 'AuditFileShare': {'Policy': 'Audit File Share', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit File Share'}, 'Transform': self.advanced_audit_transform}, 'AuditFileSystem': {'Policy': 'Audit File System', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit File System'}, 'Transform': self.advanced_audit_transform}, 'AuditFilteringPlatformConnection': {'Policy': 'Audit Filtering Platform Connection', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Filtering Platform Connection'}, 'Transform': self.advanced_audit_transform}, 'AuditFilteringPlatformPacketDrop': {'Policy': 'Audit Filtering Platform Packet Drop', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Filtering Platform Packet Drop'}, 'Transform': self.advanced_audit_transform}, 'AuditHandleManipulation': {'Policy': 'Audit Handle Manipulation', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Handle Manipulation'}, 'Transform': self.advanced_audit_transform}, 'AuditKernelObject': {'Policy': 'Audit Kernel Object', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Kernel Object'}, 'Transform': self.advanced_audit_transform}, 'AuditOtherObjectAccessEvents': {'Policy': 'Audit Other Object Access Events', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Other Object Access Events'}, 'Transform': self.advanced_audit_transform}, 'AuditRegistry': {'Policy': 'Audit Registry', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Registry'}, 'Transform': self.advanced_audit_transform}, 'AuditRemovableStorage': {'Policy': 'Audit Removable Storage', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Removable Storage'}, 'Transform': self.advanced_audit_transform}, 'AuditSAM': {'Policy': 'Audit SAM', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit SAM'}, 'Transform': self.advanced_audit_transform}, 'AuditCentralAccessPolicyStaging': {'Policy': 'Audit Central Access Policy Staging', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Central Access Policy Staging'}, 'Transform': self.advanced_audit_transform}, 'AuditAuditPolicyChange': {'Policy': 'Audit Audit Policy Change', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Audit Policy Change'}, 'Transform': self.advanced_audit_transform}, 'AuditAuthenticationPolicyChange': {'Policy': 'Audit Authentication Policy Change', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Authentication Policy Change'}, 'Transform': self.advanced_audit_transform}, 'AuditAuthorizationPolicyChange': {'Policy': 'Audit Authorization Policy Change', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Authorization Policy Change'}, 'Transform': self.advanced_audit_transform}, 'AuditFilteringPlatformPolicyChange': {'Policy': 'Audit Filtering Platform Policy Change', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Filtering Platform Policy Change'}, 'Transform': self.advanced_audit_transform}, 'AuditMPSSVCRuleLevelPolicyChange': {'Policy': 'Audit MPSSVC Rule-Level Policy Change', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit MPSSVC Rule-Level Policy Change'}, 'Transform': self.advanced_audit_transform}, 'AuditOtherPolicyChangeEvents': {'Policy': 'Audit Other Policy Change Events', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Other Policy Change Events'}, 'Transform': self.advanced_audit_transform}, 'AuditNonSensitivePrivilegeUse': {'Policy': 'Audit Non Sensitive Privilege Use', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Non Sensitive Privilege Use'}, 'Transform': self.advanced_audit_transform}, 'AuditOtherPrivilegeUseEvents': {'Policy': 'Audit Other Privilege Use Events', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Other Privilege Use Events'}, 'Transform': self.advanced_audit_transform}, 'AuditSensitivePrivilegeUse': {'Policy': 'Audit Sensitive Privilege Use', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Sensitive Privilege Use'}, 'Transform': self.advanced_audit_transform}, 'AuditIPsecDriver': {'Policy': 'Audit IPsec Driver', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit IPsec Driver'}, 'Transform': self.advanced_audit_transform}, 'AuditOtherSystemEvents': {'Policy': 'Audit Other System Events', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Other System Events'}, 'Transform': self.advanced_audit_transform}, 'AuditSecurityStateChange': {'Policy': 'Audit Security State Change', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Security State Change'}, 'Transform': self.advanced_audit_transform}, 'AuditSecuritySystemExtension': {'Policy': 'Audit Security System Extension', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Security System Extension'}, 'Transform': self.advanced_audit_transform}, 'AuditSystemIntegrity': {'Policy': 'Audit System Integrity', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit System Integrity'}, 'Transform': self.advanced_audit_transform}, 'SeTrustedCredManAccessPrivilege': {'Policy': 'Access Credential Manager as a trusted caller', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeTrustedCredManAccessPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeNetworkLogonRight': {'Policy': 'Access this computer from the network', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeNetworkLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeTcbPrivilege': {'Policy': 'Act as part of the operating system', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeTcbPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeMachineAccountPrivilege': {'Policy': 'Add workstations to domain', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeMachineAccountPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeIncreaseQuotaPrivilege': {'Policy': 'Adjust memory quotas for a process', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeIncreaseQuotaPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeInteractiveLogonRight': {'Policy': 'Allow log on locally', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeInteractiveLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeRemoteInteractiveLogonRight': {'Policy': 'Allow log on through Remote Desktop Services', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeRemoteInteractiveLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeBackupPrivilege': {'Policy': 'Backup files and directories', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeBackupPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeChangeNotifyPrivilege': {'Policy': 'Bypass traverse checking', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeChangeNotifyPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeSystemtimePrivilege': {'Policy': 'Change the system time', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeSystemtimePrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeTimeZonePrivilege': {'Policy': 'Change the time zone', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeTimeZonePrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeCreatePagefilePrivilege': {'Policy': 'Create a pagefile', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeCreatePagefilePrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeCreateTokenPrivilege': {'Policy': 'Create a token object', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeCreateTokenPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeCreateGlobalPrivilege': {'Policy': 'Create global objects', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeCreateGlobalPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeCreatePermanentPrivilege': {'Policy': 'Create permanent shared objects', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeCreatePermanentPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeCreateSymbolicLinkPrivilege': {'Policy': 'Create symbolic links', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeCreateSymbolicLinkPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeDebugPrivilege': {'Policy': 'Debug programs', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeDebugPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeDenyNetworkLogonRight': {'Policy': 'Deny access to this computer from the network', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeDenyNetworkLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeDenyBatchLogonRight': {'Policy': 'Deny log on as a batch job', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeDenyBatchLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeDenyServiceLogonRight': {'Policy': 'Deny log on as a service', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeDenyServiceLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeDenyInteractiveLogonRight': {'Policy': 'Deny log on locally', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeDenyInteractiveLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeDenyRemoteInteractiveLogonRight': {'Policy': 'Deny log on through Remote Desktop Services', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeDenyRemoteInteractiveLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeEnableDelegationPrivilege': {'Policy': 'Enable computer and user accounts to be trusted for delegation', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeEnableDelegationPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeRemoteShutdownPrivilege': {'Policy': 'Force shutdown from a remote system', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeRemoteShutdownPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeAuditPrivilege': {'Policy': 'Generate security audits', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeAuditPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeImpersonatePrivilege': {'Policy': 'Impersonate a client after authentication', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeImpersonatePrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeIncreaseWorkingSetPrivilege': {'Policy': 'Increase a process working set', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeIncreaseWorkingSetPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeIncreaseBasePriorityPrivilege': {'Policy': 'Increase scheduling priority', 'rights_assignment': True, 'lgpo_section': self.user_rights_assignment_gpedit_path, 'Settings': None, 'LsaRights': {'Option': 'SeIncreaseBasePriorityPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeLoadDriverPrivilege': {'Policy': 'Load and unload device drivers', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeLoadDriverPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeLockMemoryPrivilege': {'Policy': 'Lock pages in memory', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeLockMemoryPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeBatchLogonRight': {'Policy': 'Log on as a batch job', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeBatchLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeServiceLogonRight': {'Policy': 'Log on as a service', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeServiceLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeSecurityPrivilege': {'Policy': 'Manage auditing and security log', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeSecurityPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeRelabelPrivilege': {'Policy': 'Modify an object label', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeRelabelPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeSystemEnvironmentPrivilege': {'Policy': 'Modify firmware environment values', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeSystemEnvironmentPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeManageVolumePrivilege': {'Policy': 'Perform volume maintenance tasks', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeManageVolumePrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeProfileSingleProcessPrivilege': {'Policy': 'Profile single process', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeProfileSingleProcessPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeSystemProfilePrivilege': {'Policy': 'Profile system performance', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeSystemProfilePrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeUndockPrivilege': {'Policy': 'Remove computer from docking station', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeUndockPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeAssignPrimaryTokenPrivilege': {'Policy': 'Replace a process level token', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeAssignPrimaryTokenPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeRestorePrivilege': {'Policy': 'Restore files and directories', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeRestorePrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeShutdownPrivilege': {'Policy': 'Shut down the system', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeShutdownPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeSyncAgentPrivilege': {'Policy': 'Synchronize directory service data', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeSyncAgentPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeTakeOwnershipPrivilege': {'Policy': 'Take ownership of files or other objects', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeTakeOwnershipPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'RecoveryConsoleSecurityLevel': {'Policy': 'Recovery console: Allow automatic administrative logon', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Setup\\\\RecoveryConsole', 'Value': 'SecurityLevel', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'RecoveryConsoleSetCommand': {'Policy': 'Recovery console: Allow floppy copy and access to all drives and all folders', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Setup\\\\RecoveryConsole', 'Value': 'SetCommand', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'ForceKeyProtection': {'Policy': 'System Cryptography: Force strong key protection for user keys stored on the computer', 'Settings': self.force_key_protection.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Policies\\\\Microsoft\\\\Cryptography', 'Value': 'ForceKeyProtection', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.force_key_protection, 'value_lookup': False}, 'PutArgs': {'lookup': self.force_key_protection, 'value_lookup': True}}}, 'FIPSAlgorithmPolicy': {'Policy': 'System Cryptography: Use FIPS compliant algorithms for encryption, hashing, and signing', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\FIPSAlgorithmPolicy', 'Value': 'Enabled', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'MachineAccessRestriction': {'Policy': 'DCOM: Machine Access Restrictions in Security Descriptor Definition Language (SDDL) syntax', 'Settings': None, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Policies\\\\Microsoft\\\\Windows NT\\\\DCOM', 'Value': 'MachineAccessRestriction', 'Type': 'REG_SZ'}, 'Transform': {'Put': '_string_put_transform'}}, 'MachineLaunchRestriction': {'Policy': 'DCOM: Machine Launch Restrictions in Security Descriptor Definition Language (SDDL) syntax', 'Settings': None, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Policies\\\\Microsoft\\\\Windows NT\\\\DCOM', 'Value': 'MachineLaunchRestriction', 'Type': 'REG_SZ'}, 'Transform': {'Put': '_string_put_transform'}}, 'UseMachineId': {'Policy': 'Network security: Allow Local System to use computer identity for NTLM', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'UseMachineId', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'allownullsessionfallback': {'Policy': 'Network security: Allow LocalSystem NULL session fallback', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\MSV1_0', 'Value': 'allownullsessionfallback', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'AllowOnlineID': {'Policy': 'Network security: Allow PKU2U authentication requests to this computer to use online identities.', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\pku2u', 'Value': 'AllowOnlineID', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'KrbSupportedEncryptionTypes': {'Policy': 'Network security: Configure encryption types allowed for Kerberos', 'Settings': None, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\policies\\\\system\\\\Kerberos\\\\Parameters', 'Value': 'SupportedEncryptionTypes', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup_bitwise_add', 'Put': '_dict_lookup_bitwise_add', 'GetArgs': {'lookup': self.krb_encryption_types, 'value_lookup': False}, 'PutArgs': {'lookup': self.krb_encryption_types, 'value_lookup': True}}}, 'NoLMHash': {'Policy': 'Network security: Do not store LAN Manager hash value on next password change', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'NoLMHash', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'ForceLogoffWhenHourExpire': {'Policy': 'Network security: Force logoff when logon hours expire', 'lgpo_section': self.security_options_gpedit_path, 'Settings': self.enabled_one_disabled_zero_no_not_defined.keys(), 'Secedit': {'Option': 'ForceLogoffWhenHourExpire', 'Section': 'System Access'}, 'Transform': self.enabled_one_disabled_zero_no_not_defined_transform}, 'LmCompatibilityLevel': {'Policy': 'Network security: LAN Manager authentication level', 'Settings': self.lm_compat_levels.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'LmCompatibilityLevel', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.lm_compat_levels, 'value_lookup': False}, 'PutArgs': {'lookup': self.lm_compat_levels, 'value_lookup': True}}}, 'LDAPClientIntegrity': {'Policy': 'Network security: LDAP client signing requirements', 'Settings': self.ldap_signing_reqs.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\ldap', 'Value': 'LDAPClientIntegrity', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.ldap_signing_reqs, 'value_lookup': False}, 'PutArgs': {'lookup': self.ldap_signing_reqs, 'value_lookup': True}}}, 'NTLMMinClientSec': {'Policy': 'Network security: Minimum session security for NTLM SSP based (including secure RPC) clients', 'Settings': None, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\MSV1_0', 'Value': 'NTLMMinClientSec', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup_bitwise_add', 'Put': '_dict_lookup_bitwise_add', 'GetArgs': {'lookup': self.ntlm_session_security_levels, 'value_lookup': False}, 'PutArgs': {'lookup': self.ntlm_session_security_levels, 'value_lookup': True}}}, 'NTLMMinServerSec': {'Policy': 'Network security: Minimum session security for NTLM SSP based (including secure RPC) servers', 'Settings': None, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\MSV1_0', 'Value': 'NTLMMinServerSec', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup_bitwise_add', 'Put': '_dict_lookup_bitwise_add', 'GetArgs': {'lookup': self.ntlm_session_security_levels, 'value_lookup': False}, 'PutArgs': {'lookup': self.ntlm_session_security_levels, 'value_lookup': True}}}, 'ClientAllowedNTLMServers': {'Policy': 'Network security: Restrict NTLM: Add remote server exceptions for NTLM authentication', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\MSV1_0', 'Value': 'ClientAllowedNTLMServers', 'Type': 'REG_MULTI_SZ'}, 'Transform': {'Put': '_multi_string_put_transform', 'Get': '_multi_string_get_transform'}}, 'DCAllowedNTLMServers': {'Policy': 'Network security: Restrict NTLM: Add server exceptions in this domain', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'DCAllowedNTLMServers', 'Type': 'REG_MULTI_SZ'}, 'Transform': {'Put': '_multi_string_put_transform', 'Get': '_multi_string_get_transform'}}, 'AuditReceivingNTLMTraffic': {'Policy': 'Network security: Restrict NTLM: Audit Incoming NTLM Traffic', 'Settings': self.ntlm_audit_settings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\LSA\\\\MSV1_0', 'Value': 'AuditReceivingNTLMTraffic', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.ntlm_audit_settings, 'value_lookup': False}, 'PutArgs': {'lookup': self.ntlm_audit_settings, 'value_lookup': True}}}, 'AuditNTLMInDomain': {'Policy': 'Network security: Restrict NTLM: Audit NTLM authentication in this domain', 'Settings': self.ntlm_domain_audit_settings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'AuditNTLMInDomain', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.ntlm_domain_audit_settings, 'value_lookup': False}, 'PutArgs': {'lookup': self.ntlm_domain_audit_settings, 'value_lookup': True}}}, 'RestrictReceivingNTLMTraffic': {'Policy': 'Network security: Restrict NTLM: Incoming NTLM traffic', 'Settings': self.incoming_ntlm_settings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\LSA\\\\MSV1_0', 'Value': 'RestrictReceivingNTLMTraffic', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.incoming_ntlm_settings, 'value_lookup': False}, 'PutArgs': {'lookup': self.incoming_ntlm_settings, 'value_lookup': True}}}, 'RestrictNTLMInDomain': {'Policy': 'Network security: Restrict NTLM: NTLM authentication in this domain', 'Settings': self.ntlm_domain_auth_settings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'RestrictNTLMInDomain', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.ntlm_domain_auth_settings, 'value_lookup': False}, 'PutArgs': {'lookup': self.ntlm_domain_auth_settings, 'value_lookup': True}}}, 'RestrictSendingNTLMTraffic': {'Policy': 'Network security: Restrict NTLM: Outgoing NTLM traffic to remote servers', 'Settings': self.outgoing_ntlm_settings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\MSV1_0', 'Value': 'RestrictSendingNTLMTraffic', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.outgoing_ntlm_settings, 'value_lookup': False}, 'PutArgs': {'lookup': self.outgoing_ntlm_settings, 'value_lookup': True}}}, 'ShutdownWithoutLogon': {'Policy': 'Shutdown: Allow system to be shut down without having to log on', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\policies\\\\system', 'Value': 'ShutdownWithoutLogon', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'ClearPageFileAtShutdown': {'Policy': 'Shutdown: Clear virtual memory pagefile', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\SESSION MANAGER\\\\MEMORY MANAGEMENT', 'Value': 'ClearPageFileAtShutdown', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'ObCaseInsensitive': {'Policy': 'System objects: Require case insensitivity for non-Windows subsystems', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\SESSION MANAGER\\\\Kernel', 'Value': 'ObCaseInsensitive', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'ProtectionMode': {'Policy': 'System objects: Strengthen default permissions of internal system objects (e.g. Symbolic Links)', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\SESSION MANAGER', 'Value': 'ProtectionMode', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'OptionalSubsystems': {'Policy': 'System settings: Optional subsystems', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\SESSION MANAGER\\\\SubSystems', 'Value': 'optional', 'Type': 'REG_MULTI_SZ'}, 'Transform': {'Put': '_multi_string_put_transform', 'Get': '_multi_string_get_transform'}}, 'AuthenticodeEnabled': {'Policy': 'System settings: Use Certificate Rules on Windows Executables for Software Restriction Policies', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Policies\\\\Microsoft\\\\Windows\\\\safer\\\\codeidentifiers', 'Value': 'AuthenticodeEnabled', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}}}, 'User': {'lgpo_section': 'User Configuration', 'policies': {}}}",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.audit_lookup = {0: 'No auditing', 1: 'Success', 2: 'Failure', 3: 'Success, Failure', 'Not Defined': 'Not Defined', None: 'Not Defined'}\n    self.advanced_audit_lookup = {0: 'No Auditing', 1: 'Success', 2: 'Failure', 3: 'Success and Failure', None: 'Not Configured'}\n    self.sc_removal_lookup = {'0': 'No Action', '1': 'Lock Workstation', '2': 'Force Logoff', '3': 'Disconnect if a Remote Desktop Services session', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.uac_admin_prompt_lookup = {0: 'Elevate without prompting', 1: 'Prompt for credentials on the secure desktop', 2: 'Prompt for consent on the secure desktop', 3: 'Prompt for credentials', 4: 'Prompt for consent', 5: 'Prompt for consent for non-Windows binaries', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.uac_user_prompt_lookup = {0: 'Automatically deny elevation requests', 1: 'Prompt for credentials on the secure desktop', 3: 'Prompt for credentials', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.enabled_one_disabled_zero = {0: 'Disabled', 1: 'Enabled', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.enabled_one_disabled_zero_transform = {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.enabled_one_disabled_zero, 'value_lookup': False}, 'PutArgs': {'lookup': self.enabled_one_disabled_zero, 'value_lookup': True}}\n    self.s4u2self_options = {0: 'Default', 1: 'Enabled', 2: 'Disabled', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.audit_transform = {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.audit_lookup, 'value_lookup': False}, 'PutArgs': {'lookup': self.audit_lookup, 'value_lookup': True}}\n    self.advanced_audit_transform = {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.advanced_audit_lookup, 'value_lookup': False}, 'PutArgs': {'lookup': self.advanced_audit_lookup, 'value_lookup': True}}\n    self.enabled_one_disabled_zero_strings = {'0': 'Disabled', '1': 'Enabled', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.enabled_one_disabled_zero_strings_transform = {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.enabled_one_disabled_zero_strings, 'value_lookup': False}, 'PutArgs': {'lookup': self.enabled_one_disabled_zero_strings, 'value_lookup': True}}\n    self.security_options_gpedit_path = ['Computer Configuration', 'Windows Settings', 'Security Settings', 'Local Policies', 'Security Options']\n    self.windows_firewall_gpedit_path = ['Computer Configuration', 'Windows Settings', 'Security Settings', 'Windows Firewall with Advanced Security', 'Windows Firewall with Advanced Security - Local Group Policy Object']\n    self.password_policy_gpedit_path = ['Computer Configuration', 'Windows Settings', 'Security Settings', 'Account Policies', 'Password Policy']\n    self.audit_policy_gpedit_path = ['Computer Configuration', 'Windows Settings', 'Security Settings', 'Local Policies', 'Audit Policy']\n    self.advanced_audit_policy_gpedit_path = ['Computer Configuration', 'Windows Settings', 'Security Settings', 'Advanced Audit Policy Configuration', 'System Audit Policies - Local Group Policy Object']\n    self.account_lockout_policy_gpedit_path = ['Computer Configuration', 'Windows Settings', 'Security Settings', 'Account Policies', 'Account Lockout Policy']\n    self.user_rights_assignment_gpedit_path = ['Computer Configuration', 'Windows Settings', 'Security Settings', 'Local Policies', 'User Rights Assignment']\n    self.block_ms_accounts = {0: 'This policy is disabled', 1: \"Users can't add Microsoft accounts\", 3: \"Users can't add or log on with Microsoft accounts\", None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.ldap_server_binding_token_requirements = {0: 'Never', 1: 'When supported', 2: 'Always', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.ldap_server_signing_requirements = {1: 'None', 2: 'Require signing', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.smb_server_name_hardening_levels = {0: 'Off', 1: 'Accept if provided by client', 2: 'Required from client', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.locked_session_user_info = {1: 'User display name, domain and user names', 2: 'User display name only', 3: 'Do not display user information', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.force_guest = {0: 'Classic - local users authenticate as themselves', 1: 'Guest only - local users authenticate as Guest', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.force_key_protection = {0: 'User input is not required when new keys are stored and used', 1: 'User is prompted when the key is first used', 2: 'User must enter a password each time they use a key', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.firewall_inbound_connections = {'blockinbound': 'Block (default)', 'blockinboundalways': 'Block all connections', 'allowinbound': 'Allow', 'notconfigured': 'Not configured'}\n    self.firewall_outbound_connections = {'blockoutbound': 'Block', 'allowoutbound': 'Allow (default)', 'notconfigured': 'Not configured'}\n    self.firewall_rule_merging = {'enable': 'Yes (default)', 'disable': 'No', 'notconfigured': 'Not configured'}\n    self.firewall_log_packets_connections = {'enable': 'Yes', 'disable': 'No (default)', 'notconfigured': 'Not configured'}\n    self.firewall_notification = {'enable': 'Yes', 'disable': 'No', 'notconfigured': 'Not configured'}\n    self.firewall_state = {'on': 'On (recommended)', 'off': 'Off', 'notconfigured': 'Not configured'}\n    self.krb_encryption_types = {0: 'No minimum', 1: 'DES_CBC_CRC', 2: 'DES_CBD_MD5', 4: 'RC4_HMAC_MD5', 8: 'AES128_HMAC_SHA1', 16: 'AES256_HMAC_SHA1', 2147483616: 'Future Encryption Types', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.lm_compat_levels = {0: 'Send LM & NTLM response', 1: 'Send LM & NTLM - use NTLMv2 session security if negotiated', 2: 'Send NTLM response only', 3: 'Send NTLMv2 response only', 4: 'Send NTLMv2 response only. Refuse LM', 5: 'Send NTLMv2 response only. Refuse LM & NTLM', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.ldap_signing_reqs = {0: 'None', 1: 'Negotiate signing', 2: 'Require signing', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.ntlm_session_security_levels = {0: 'No minimum', 524288: 'Require NTLMv2 session security', 536870912: 'Require 128-bit encryption', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.ntlm_audit_settings = {0: 'Disable', 1: 'Enable auditing for domain accounts', 2: 'Enable auditing for all accounts', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.ntlm_domain_audit_settings = {0: 'Disable', 1: 'Enable for domain accounts to domain servers', 3: 'Enable for domain accounts', 5: 'Enable for domain servers', 7: 'Enable all', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.incoming_ntlm_settings = {0: 'Allow all', 1: 'Deny all domain accounts', 2: 'Deny all accounts', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.ntlm_domain_auth_settings = {0: 'Disable', 1: 'Deny for domain accounts to domain servers', 3: 'Deny for domain accounts', 5: 'Deny for domain servers', 7: 'Deny all', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.outgoing_ntlm_settings = {0: 'Allow all', 1: 'Audit all', 2: 'Deny all', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.enabled_one_disabled_zero_no_not_defined = {0: 'Disabled', 1: 'Enabled'}\n    self.enabled_one_disabled_zero_no_not_defined_transform = {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.enabled_one_disabled_zero_no_not_defined, 'value_lookup': False}, 'PutArgs': {'lookup': self.enabled_one_disabled_zero_no_not_defined, 'value_lookup': True}}\n    self.policies = {'Machine': {'lgpo_section': 'Computer Configuration', 'policies': {'StartupScripts': {'Policy': 'Startup Scripts', 'lgpo_section': ['Computer Configuration', 'Windows Settings', 'Scripts (Startup/Shutdown)', 'Startup'], 'ScriptIni': {'Section': 'Startup', 'IniPath': os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'Machine', 'Scripts', 'scripts.ini')}}, 'StartupPowershellScripts': {'Policy': 'Startup Powershell Scripts', 'lgpo_section': ['Computer Configuration', 'Windows Settings', 'Scripts (Startup/Shutdown)', 'Startup'], 'ScriptIni': {'Section': 'Startup', 'IniPath': os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'Machine', 'Scripts', 'psscripts.ini')}}, 'StartupPowershellScriptOrder': {'Policy': 'Startup - For this GPO, run scripts in the following order', 'lgpo_section': ['Computer Configuration', 'Windows Settings', 'Scripts (Startup/Shutdown)', 'Startup'], 'ScriptIni': {'IniPath': os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'Machine', 'Scripts', 'psscripts.ini'), 'Section': 'ScriptsConfig', 'SettingName': 'StartExecutePSFirst', 'Settings': ['true', 'false', None]}, 'Transform': {'Get': '_powershell_script_order_conversion', 'Put': '_powershell_script_order_reverse_conversion'}}, 'ShutdownScripts': {'Policy': 'Shutdown Scripts', 'lgpo_section': ['Computer Configuration', 'Windows Settings', 'Scripts (Startup/Shutdown)', 'Shutdown'], 'ScriptIni': {'Section': 'Shutdown', 'IniPath': os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'Machine', 'Scripts', 'scripts.ini')}}, 'ShutdownPowershellScripts': {'Policy': 'Shutdown Powershell Scripts', 'lgpo_section': ['Computer Configuration', 'Windows Settings', 'Scripts (Startup/Shutdown)', 'Shutdown'], 'ScriptIni': {'Section': 'Shutdown', 'IniPath': os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'Machine', 'Scripts', 'psscripts.ini')}}, 'ShutdownPowershellScriptOrder': {'Policy': 'Shutdown - For this GPO, run scripts in the following order', 'lgpo_section': ['Computer Configuration', 'Windows Settings', 'Scripts (Startup/Shutdown)', 'Shutdown'], 'ScriptIni': {'IniPath': os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'Machine', 'Scripts', 'psscripts.ini'), 'Section': 'ScriptsConfig', 'SettingName': 'EndExecutePSFirst', 'Settings': ['true', 'false', None]}, 'Transform': {'Get': '_powershell_script_order_conversion', 'Put': '_powershell_script_order_reverse_conversion'}}, 'LSAAnonymousNameLookup': {'Policy': 'Network access: Allow anonymous SID/Name translation', 'lgpo_section': self.password_policy_gpedit_path, 'Settings': self.enabled_one_disabled_zero_no_not_defined.keys(), 'Secedit': {'Option': 'LSAAnonymousNameLookup', 'Section': 'System Access'}, 'Transform': self.enabled_one_disabled_zero_no_not_defined_transform}, 'RestrictAnonymousSam': {'Policy': 'Network access: Do not allow anonymous enumeration of SAM accounts', 'lgpo_section': self.security_options_gpedit_path, 'Settings': self.enabled_one_disabled_zero.keys(), 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'RestrictAnonymousSam', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'RestrictRemoteSAM': {'Policy': 'Network access: Restrict clients allowed to make remote calls to SAM', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'RestrictRemoteSAM', 'Type': 'REG_SZ'}, 'Transform': {'Put': '_string_put_transform'}}, 'RestrictAnonymous': {'Policy': 'Network access: Do not allow anonymous enumeration of SAM accounts and shares', 'lgpo_section': self.security_options_gpedit_path, 'Settings': self.enabled_one_disabled_zero.keys(), 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'RestrictAnonymous', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'DisableDomainCreds': {'Policy': 'Network access: Do not allow storage of passwords and credentials for network authentication', 'lgpo_section': self.security_options_gpedit_path, 'Settings': self.enabled_one_disabled_zero.keys(), 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'DisableDomainCreds', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'EveryoneIncludesAnonymous': {'Policy': 'Network access: Let Everyone permissions apply to anonymous users', 'lgpo_section': self.security_options_gpedit_path, 'Settings': self.enabled_one_disabled_zero.keys(), 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'everyoneincludesanonymous', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'NullSessionPipes': {'Policy': 'Network access: Named Pipes that can be accessed anonymously', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'NullSessionPipes', 'Type': 'REG_MULTI_SZ'}, 'Transform': {'Put': '_multi_string_put_transform', 'Get': '_multi_string_get_transform'}}, 'RemoteRegistryExactPaths': {'Policy': 'Network access: Remotely accessible registry paths', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\SecurePipeServers\\\\winreg\\\\AllowedExactPaths', 'Value': 'Machine', 'Type': 'REG_MULTI_SZ'}, 'Transform': {'Put': '_multi_string_put_transform', 'Get': '_multi_string_get_transform'}}, 'RemoteRegistryPaths': {'Policy': 'Network access: Remotely accessible registry paths and sub-paths', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\SecurePipeServers\\\\winreg\\\\AllowedPaths', 'Value': 'Machine', 'Type': 'REG_MULTI_SZ'}, 'Transform': {'Put': '_multi_string_put_transform', 'Get': '_multi_string_get_transform'}}, 'RestrictNullSessAccess': {'Policy': 'Network access: Restrict anonymous access to Named Pipes and Shares', 'lgpo_section': self.security_options_gpedit_path, 'Settings': self.enabled_one_disabled_zero.keys(), 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'RestrictNullSessAccess', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'NullSessionShares': {'Policy': 'Network access: Shares that can be accessed anonymously', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'NullSessionShares', 'Type': 'REG_MULTI_SZ'}, 'Transform': {'Put': '_multi_string_put_transform', 'Get': '_multi_string_get_transform'}}, 'ForceGuest': {'Policy': 'Network access: Sharing and security model for local accounts', 'lgpo_section': self.security_options_gpedit_path, 'Settings': self.force_guest.keys(), 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'ForceGuest', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.force_guest, 'value_lookup': False}, 'PutArgs': {'lookup': self.force_guest, 'value_lookup': True}}}, 'WfwDomainState': {'Policy': 'Network firewall: Domain: State', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_state.keys(), 'NetSH': {'Profile': 'domain', 'Section': 'state', 'Option': 'State'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_state, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_state, 'value_lookup': True}}}, 'WfwPrivateState': {'Policy': 'Network firewall: Private: State', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_state.keys(), 'NetSH': {'Profile': 'private', 'Section': 'state', 'Option': 'State'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_state, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_state, 'value_lookup': True}}}, 'WfwPublicState': {'Policy': 'Network firewall: Public: State', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_state.keys(), 'NetSH': {'Profile': 'public', 'Section': 'state', 'Option': 'State'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_state, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_state, 'value_lookup': True}}}, 'WfwDomainInboundConnections': {'Policy': 'Network firewall: Domain: Inbound connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_inbound_connections.keys(), 'NetSH': {'Profile': 'domain', 'Section': 'firewallpolicy', 'Option': 'Inbound'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_inbound_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_inbound_connections, 'value_lookup': True}}}, 'WfwPrivateInboundConnections': {'Policy': 'Network firewall: Private: Inbound connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_inbound_connections.keys(), 'NetSH': {'Profile': 'private', 'Section': 'firewallpolicy', 'Option': 'Inbound'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_inbound_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_inbound_connections, 'value_lookup': True}}}, 'WfwPublicInboundConnections': {'Policy': 'Network firewall: Public: Inbound connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_inbound_connections.keys(), 'NetSH': {'Profile': 'public', 'Section': 'firewallpolicy', 'Option': 'Inbound'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_inbound_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_inbound_connections, 'value_lookup': True}}}, 'WfwDomainOutboundConnections': {'Policy': 'Network firewall: Domain: Outbound connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_outbound_connections.keys(), 'NetSH': {'Profile': 'domain', 'Section': 'firewallpolicy', 'Option': 'Outbound'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_outbound_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_outbound_connections, 'value_lookup': True}}}, 'WfwPrivateOutboundConnections': {'Policy': 'Network firewall: Private: Outbound connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_outbound_connections.keys(), 'NetSH': {'Profile': 'private', 'Section': 'firewallpolicy', 'Option': 'Outbound'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_outbound_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_outbound_connections, 'value_lookup': True}}}, 'WfwPublicOutboundConnections': {'Policy': 'Network firewall: Public: Outbound connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_outbound_connections.keys(), 'NetSH': {'Profile': 'public', 'Section': 'firewallpolicy', 'Option': 'Outbound'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_outbound_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_outbound_connections, 'value_lookup': True}}}, 'WfwDomainSettingsNotification': {'Policy': 'Network firewall: Domain: Settings: Display a notification', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_notification.keys(), 'NetSH': {'Profile': 'domain', 'Section': 'settings', 'Option': 'InboundUserNotification'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_notification, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_notification, 'value_lookup': True}}}, 'WfwPrivateSettingsNotification': {'Policy': 'Network firewall: Private: Settings: Display a notification', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_notification.keys(), 'NetSH': {'Profile': 'private', 'Section': 'settings', 'Option': 'InboundUserNotification'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_notification, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_notification, 'value_lookup': True}}}, 'WfwPublicSettingsNotification': {'Policy': 'Network firewall: Public: Settings: Display a notification', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_notification.keys(), 'NetSH': {'Profile': 'public', 'Section': 'settings', 'Option': 'InboundUserNotification'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_notification, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_notification, 'value_lookup': True}}}, 'WfwDomainSettingsLocalFirewallRules': {'Policy': 'Network firewall: Domain: Settings: Apply local firewall rules', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_rule_merging.keys(), 'NetSH': {'Profile': 'domain', 'Section': 'settings', 'Option': 'LocalFirewallRules'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': True}}}, 'WfwPrivateSettingsLocalFirewallRules': {'Policy': 'Network firewall: Private: Settings: Apply local firewall rules', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_rule_merging.keys(), 'NetSH': {'Profile': 'private', 'Section': 'settings', 'Option': 'LocalFirewallRules'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': True}}}, 'WfwPublicSettingsLocalFirewallRules': {'Policy': 'Network firewall: Public: Settings: Apply local firewall rules', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_rule_merging.keys(), 'NetSH': {'Profile': 'public', 'Section': 'settings', 'Option': 'LocalFirewallRules'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': True}}}, 'WfwDomainSettingsLocalConnectionRules': {'Policy': 'Network firewall: Domain: Settings: Apply local connection security rules', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_rule_merging.keys(), 'NetSH': {'Profile': 'domain', 'Section': 'settings', 'Option': 'LocalConSecRules'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': True}}}, 'WfwPrivateSettingsLocalConnectionRules': {'Policy': 'Network firewall: Private: Settings: Apply local connection security rules', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_rule_merging.keys(), 'NetSH': {'Profile': 'private', 'Section': 'settings', 'Option': 'LocalConSecRules'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': True}}}, 'WfwPublicSettingsLocalConnectionRules': {'Policy': 'Network firewall: Public: Settings: Apply local connection security rules', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_rule_merging.keys(), 'NetSH': {'Profile': 'public', 'Section': 'settings', 'Option': 'LocalConSecRules'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': True}}}, 'WfwDomainLoggingName': {'Policy': 'Network firewall: Domain: Logging: Name', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': None, 'NetSH': {'Profile': 'domain', 'Section': 'logging', 'Option': 'FileName'}}, 'WfwPrivateLoggingName': {'Policy': 'Network firewall: Private: Logging: Name', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': None, 'NetSH': {'Profile': 'private', 'Section': 'logging', 'Option': 'FileName'}}, 'WfwPublicLoggingName': {'Policy': 'Network firewall: Public: Logging: Name', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': None, 'NetSH': {'Profile': 'public', 'Section': 'logging', 'Option': 'FileName'}}, 'WfwDomainLoggingMaxFileSize': {'Policy': 'Network firewall: Domain: Logging: Size limit (KB)', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': None, 'NetSH': {'Profile': 'domain', 'Section': 'logging', 'Option': 'MaxFileSize'}}, 'WfwPrivateLoggingMaxFileSize': {'Policy': 'Network firewall: Private: Logging: Size limit (KB)', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': None, 'NetSH': {'Profile': 'private', 'Section': 'logging', 'Option': 'MaxFileSize'}}, 'WfwPublicLoggingMaxFileSize': {'Policy': 'Network firewall: Public: Logging: Size limit (KB)', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': None, 'NetSH': {'Profile': 'public', 'Section': 'logging', 'Option': 'MaxFileSize'}}, 'WfwDomainLoggingAllowedConnections': {'Policy': 'Network firewall: Domain: Logging: Log successful connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_log_packets_connections.keys(), 'NetSH': {'Profile': 'domain', 'Section': 'logging', 'Option': 'LogAllowedConnections'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': True}}}, 'WfwPrivateLoggingAllowedConnections': {'Policy': 'Network firewall: Private: Logging: Log successful connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_log_packets_connections.keys(), 'NetSH': {'Profile': 'private', 'Section': 'logging', 'Option': 'LogAllowedConnections'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': True}}}, 'WfwPublicLoggingAllowedConnections': {'Policy': 'Network firewall: Public: Logging: Log successful connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_log_packets_connections.keys(), 'NetSH': {'Profile': 'public', 'Section': 'logging', 'Option': 'LogAllowedConnections'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': True}}}, 'WfwDomainLoggingDroppedConnections': {'Policy': 'Network firewall: Domain: Logging: Log dropped packets', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_log_packets_connections.keys(), 'NetSH': {'Profile': 'domain', 'Section': 'logging', 'Option': 'LogDroppedConnections'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': True}}}, 'WfwPrivateLoggingDroppedConnections': {'Policy': 'Network firewall: Private: Logging: Log dropped packets', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_log_packets_connections.keys(), 'NetSH': {'Profile': 'private', 'Section': 'logging', 'Option': 'LogDroppedConnections'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': True}}}, 'WfwPublicLoggingDroppedConnections': {'Policy': 'Network firewall: Public: Logging: Log dropped packets', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_log_packets_connections.keys(), 'NetSH': {'Profile': 'public', 'Section': 'logging', 'Option': 'LogDroppedConnections'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': True}}}, 'PasswordHistory': {'Policy': 'Enforce password history', 'lgpo_section': self.password_policy_gpedit_path, 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 24}}, 'NetUserModal': {'Modal': 0, 'Option': 'password_hist_len'}}, 'MaxPasswordAge': {'Policy': 'Maximum password age', 'lgpo_section': self.password_policy_gpedit_path, 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 1, 'max': 86313600, 'zero_value': 4294967295}}, 'NetUserModal': {'Modal': 0, 'Option': 'max_passwd_age'}, 'Transform': {'Get': '_seconds_to_days', 'Put': '_days_to_seconds', 'GetArgs': {'zero_value': 4294967295}, 'PutArgs': {'zero_value': 4294967295}}}, 'MinPasswordAge': {'Policy': 'Minimum password age', 'lgpo_section': self.password_policy_gpedit_path, 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 86313600}}, 'NetUserModal': {'Modal': 0, 'Option': 'min_passwd_age'}, 'Transform': {'Get': '_seconds_to_days', 'Put': '_days_to_seconds'}}, 'MinPasswordLen': {'Policy': 'Minimum password length', 'lgpo_section': self.password_policy_gpedit_path, 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 14}}, 'NetUserModal': {'Modal': 0, 'Option': 'min_passwd_len'}}, 'PasswordComplexity': {'Policy': 'Password must meet complexity requirements', 'lgpo_section': self.password_policy_gpedit_path, 'Settings': self.enabled_one_disabled_zero_no_not_defined.keys(), 'Secedit': {'Option': 'PasswordComplexity', 'Section': 'System Access'}, 'Transform': self.enabled_one_disabled_zero_no_not_defined_transform}, 'ClearTextPasswords': {'Policy': 'Store passwords using reversible encryption', 'lgpo_section': self.password_policy_gpedit_path, 'Settings': self.enabled_one_disabled_zero_no_not_defined.keys(), 'Secedit': {'Option': 'ClearTextPassword', 'Section': 'System Access'}, 'Transform': self.enabled_one_disabled_zero_no_not_defined_transform}, 'RelaxMinimumPasswordLengthLimits': {'Policy': 'Relax minimum password length limits', 'lgpo_section': self.password_policy_gpedit_path, 'Settings': self.enabled_one_disabled_zero.keys(), 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\SAM', 'Value': 'RelaxMinimumPasswordLengthLimits', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'AdminAccountStatus': {'Policy': 'Accounts: Administrator account status', 'Settings': self.enabled_one_disabled_zero_no_not_defined.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Secedit': {'Option': 'EnableAdminAccount', 'Section': 'System Access'}, 'Transform': self.enabled_one_disabled_zero_no_not_defined_transform}, 'NoConnectedUser': {'Policy': 'Accounts: Block Microsoft accounts', 'Settings': self.block_ms_accounts.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\policies\\\\system', 'Value': 'NoConnectedUser', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.block_ms_accounts, 'value_lookup': False}, 'PutArgs': {'lookup': self.block_ms_accounts, 'value_lookup': True}}}, 'GuestAccountStatus': {'Policy': 'Accounts: Guest account status', 'Settings': self.enabled_one_disabled_zero_no_not_defined.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Secedit': {'Option': 'EnableGuestAccount', 'Section': 'System Access'}, 'Transform': self.enabled_one_disabled_zero_no_not_defined_transform}, 'LimitBlankPasswordUse': {'Policy': 'Accounts: Limit local account use of blank passwords to console logon only', 'lgpo_section': self.security_options_gpedit_path, 'Settings': self.enabled_one_disabled_zero.keys(), 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'limitblankpassworduse', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'RenameAdministratorAccount': {'Policy': 'Accounts: Rename administrator account', 'Settings': None, 'lgpo_section': self.security_options_gpedit_path, 'Secedit': {'Option': 'NewAdministratorName', 'Section': 'System Access'}, 'Transform': {'Get': '_strip_quotes', 'Put': '_add_quotes'}}, 'RenameGuestAccount': {'Policy': 'Accounts: Rename guest account', 'Settings': None, 'lgpo_section': self.security_options_gpedit_path, 'Secedit': {'Option': 'NewGuestName', 'Section': 'System Access'}, 'Transform': {'Get': '_strip_quotes', 'Put': '_add_quotes'}}, 'AuditBaseObjects': {'Policy': 'Audit: Audit the access of global system objects', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'AuditBaseObjects', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'SceNoApplyLegacyAuditPolicy': {'Policy': 'Audit: Force audit policy subcategory settings (Windows Vista or later) to override audit policy category settings', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'SCENoApplyLegacyAuditPolicy', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'DontDisplayLastUserName': {'Policy': 'Interactive logon: Do not display last user name', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'DontDisplayLastUserName', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'CachedLogonsCount': {'Policy': 'Interactive logon: Number of previous logons to cache (in case domain controller is not available)', 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 50}}, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon', 'Value': 'CachedLogonsCount', 'Type': 'REG_SZ'}}, 'ForceUnlockLogon': {'Policy': 'Interactive logon: Require Domain Controller authentication to unlock workstation', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon', 'Value': 'ForceUnlockLogon', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'ScRemoveOption': {'Policy': 'Interactive logon: Smart card removal behavior', 'Settings': self.sc_removal_lookup.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon', 'Value': 'ScRemoveOption', 'Type': 'REG_SZ'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.sc_removal_lookup, 'value_lookup': False}, 'PutArgs': {'lookup': self.sc_removal_lookup, 'value_lookup': True}}}, 'DisableCAD': {'Policy': 'Interactive logon: Do not require CTRL+ALT+DEL', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'DisableCAD', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'FilterAdministratorToken': {'Policy': 'User Account Control: Admin Approval Mode for the built-in Administrator account', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'FilterAdministratorToken', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'EnableUIADesktopToggle': {'Policy': 'User Account Control: Allow UIAccess applications to prompt for elevation without using the secure desktop', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'EnableUIADesktopToggle', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'ConsentPromptBehaviorAdmin': {'Policy': 'User Account Control: Behavior of the elevation prompt for administrators in Admin Approval Mode', 'Settings': self.uac_admin_prompt_lookup.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'ConsentPromptBehaviorAdmin', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.uac_admin_prompt_lookup, 'value_lookup': False}, 'PutArgs': {'lookup': self.uac_admin_prompt_lookup, 'value_lookup': True}}}, 'ConsentPromptBehaviorUser': {'Policy': 'User Account Control: Behavior of the elevation prompt for standard users', 'Settings': self.uac_user_prompt_lookup.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'ConsentPromptBehaviorUser', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.uac_user_prompt_lookup, 'value_lookup': False}, 'PutArgs': {'lookup': self.uac_user_prompt_lookup, 'value_lookup': True}}}, 'EnableInstallerDetection': {'Policy': 'User Account Control: Detect application installations and prompt for elevation', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'EnableInstallerDetection', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'ValidateAdminCodeSignatures': {'Policy': 'User Account Control: Only elevate executables that are signed and validated', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'ValidateAdminCodeSignatures', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'EnableSecureUIAPaths': {'Policy': 'User Account Control: Only elevate UIAccess applications that are installed in secure locations', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'EnableSecureUIAPaths', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'EnableLUA': {'Policy': 'User Account Control: Run all administrators in Admin Approval Mode', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'EnableLUA', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'PromptOnSecureDesktop': {'Policy': 'User Account Control: Switch to the secure desktop when prompting for elevation', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'PromptOnSecureDesktop', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'EnableVirtualization': {'Policy': 'User Account Control: Virtualize file and registry write failures to per-user locations', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'EnableVirtualization', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'PasswordExpiryWarning': {'Policy': 'Interactive logon: Prompt user to change password before expiration', 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 999}}, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon', 'Value': 'PasswordExpiryWarning', 'Type': 'REG_DWORD'}}, 'MaxDevicePasswordFailedAttempts': {'Policy': 'Interactive logon: Machine account lockout threshold', 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 999}}, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\policies\\\\system', 'Value': 'MaxDevicePasswordFailedAttempts', 'Type': 'REG_DWORD'}}, 'InactivityTimeoutSecs': {'Policy': 'Interactive logon: Machine inactivity limit', 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 599940}}, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\policies\\\\system', 'Value': 'InactivityTimeoutSecs', 'Type': 'REG_DWORD'}}, 'legalnoticetext': {'Policy': 'Interactive logon: Message text for users attempting to log on', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\policies\\\\system', 'Value': 'legalnoticetext', 'Type': 'REG_SZ'}, 'Transform': {'Put': '_string_put_transform'}}, 'legalnoticecaption': {'Policy': 'Interactive logon: Message title for users attempting to log on', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\policies\\\\system', 'Value': 'legalnoticecaption', 'Type': 'REG_SZ'}, 'Transform': {'Put': '_string_put_transform'}}, 'DontDisplayLockedUserId': {'Policy': 'Interactive logon: Display user information when the session is locked', 'Settings': self.locked_session_user_info.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\policies\\\\system', 'Value': 'DontDisplayLockedUserId', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.locked_session_user_info, 'value_lookup': False}, 'PutArgs': {'lookup': self.locked_session_user_info, 'value_lookup': True}}}, 'ScForceOption': {'Policy': 'Interactive logon: Require smart card', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'ScForceOption', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'Client_RequireSecuritySignature': {'Policy': 'Microsoft network client: Digitally sign communications (always)', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\LanmanWorkstation\\\\Parameters', 'Value': 'RequireSecuritySignature', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'Client_EnableSecuritySignature': {'Policy': 'Microsoft network client: Digitally sign communications (if server agrees)', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\LanmanWorkstation\\\\Parameters', 'Value': 'EnableSecuritySignature', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'EnablePlainTextPassword': {'Policy': 'Microsoft network client: Send unencrypted password to third-party SMB servers', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\LanmanWorkstation\\\\Parameters', 'Value': 'EnablePlainTextPassword', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'AutoDisconnect': {'Policy': 'Microsoft network server: Amount of idle time required before suspending session', 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 99999}}, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'AutoDisconnect', 'Type': 'REG_DWORD'}}, 'EnableS4U2SelfForClaims': {'Policy': 'Microsoft network server: Attempt S4U2Self to obtain claim information', 'Settings': self.s4u2self_options.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'EnableS4U2SelfForClaims', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.s4u2self_options, 'value_lookup': False}, 'PutArgs': {'lookup': self.s4u2self_options, 'value_lookup': True}}}, 'Server_RequireSecuritySignature': {'Policy': 'Microsoft network server: Digitally sign communications (always)', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'RequireSecuritySignature', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'Server_EnableSecuritySignature': {'Policy': 'Microsoft network server: Digitally sign communications (if client agrees)', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'EnableSecuritySignature', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'EnableForcedLogoff': {'Policy': 'Microsoft network server: Disconnect clients when logon hours expire', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'EnableForcedLogoff', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'SmbServerNameHardeningLevel': {'Policy': 'Microsoft network server: Server SPN target name validation level', 'Settings': self.smb_server_name_hardening_levels.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'SmbServerNameHardeningLevel', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.smb_server_name_hardening_levels, 'value_lookup': False}, 'PutArgs': {'lookup': self.smb_server_name_hardening_levels, 'value_lookup': True}}}, 'FullPrivilegeAuditing': {'Policy': 'Audit: Audit the use of Backup and Restore privilege', 'Settings': [chr(0), chr(1)], 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'FullPrivilegeAuditing', 'Type': 'REG_BINARY'}, 'Transform': {'Get': '_binary_enable_zero_disable_one_conversion', 'Put': '_binary_enable_zero_disable_one_reverse_conversion'}}, 'CrashOnAuditFail': {'Policy': 'Audit: Shut down system immediately if unable to log security audits', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'CrashOnAuditFail', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'UndockWithoutLogon': {'Policy': 'Devices: Allow undock without having to log on', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'UndockWithoutLogon', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'AddPrinterDrivers': {'Policy': 'Devices: Prevent users from installing printer drivers', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\Print\\\\Providers\\\\LanMan Print Services\\\\Servers', 'Value': 'AddPrinterDrivers', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'AllocateDASD': {'Policy': 'Devices: Allowed to format and eject removable media', 'Settings': ['9999', '0', '1', '2'], 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon', 'Value': 'AllocateDASD', 'Type': 'REG_SZ'}, 'Transform': {'Get': '_dasd_conversion', 'Put': '_dasd_reverse_conversion'}}, 'AllocateCDRoms': {'Policy': 'Devices: Restrict CD-ROM access to locally logged-on user only', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon', 'Value': 'AllocateCDRoms', 'Type': 'REG_SZ'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'AllocateFloppies': {'Policy': 'Devices: Restrict floppy access to locally logged-on user only', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon', 'Value': 'AllocateFloppies', 'Type': 'REG_SZ'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'DriverSigningPolicy': {'Policy': 'Devices: Unsigned driver installation behavior', 'Settings': ['3,0', '3,' + chr(1), '3,' + chr(2)], 'lgpo_section': self.security_options_gpedit_path, 'Secedit': {'Option': 'MACHINE\\\\Software\\\\Microsoft\\\\Driver Signing\\\\Policy', 'Section': 'Registry Values'}, 'Transform': {'Get': '_driver_signing_reg_conversion', 'Put': '_driver_signing_reg_reverse_conversion'}}, 'SubmitControl': {'Policy': 'Domain controller: Allow server operators to schedule tasks', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'SubmitControl', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'VulnerableChannelAllowList': {'Policy': 'Domain controller: Allow vulnerable Netlogon secure channel connections', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'VulnerableChannelAllowList', 'Type': 'REG_SZ'}, 'Transform': {'Put': '_string_put_transform'}}, 'LdapEnforceChannelBinding': {'Policy': 'Domain controller: LDAP server channel binding token requirements', 'Settings': self.ldap_server_binding_token_requirements.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\NTDS\\\\Parameters', 'Value': 'LdapEnforceChannelBinding', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.ldap_server_binding_token_requirements, 'value_lookup': False}, 'PutArgs': {'lookup': self.ldap_server_binding_token_requirements, 'value_lookup': True}}}, 'LDAPServerIntegrity': {'Policy': 'Domain controller: LDAP server signing requirements', 'Settings': self.ldap_server_signing_requirements.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\NTDS\\\\Parameters', 'Value': 'LDAPServerIntegrity', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.ldap_server_signing_requirements, 'value_lookup': False}, 'PutArgs': {'lookup': self.ldap_server_signing_requirements, 'value_lookup': True}}}, 'RefusePasswordChange': {'Policy': 'Domain controller: Refuse machine account password changes', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'RefusePasswordChange', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'RequireSignOrSeal': {'Policy': 'Domain member: Digitally encrypt or sign secure channel data (always)', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'RequireSignOrSeal', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'SealSecureChannel': {'Policy': 'Domain member: Digitally encrypt secure channel data (when possible)', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'SealSecureChannel', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'SignSecureChannel': {'Policy': 'Domain member: Digitally sign secure channel data (when possible)', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'SignSecureChannel', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'DisablePasswordChange': {'Policy': 'Domain member: Disable machine account password changes', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'DisablePasswordChange', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'MaximumPasswordAge': {'Policy': 'Domain member: Maximum machine account password age', 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 999}}, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'MaximumPasswordAge', 'Type': 'REG_DWORD'}}, 'RequireStrongKey': {'Policy': 'Domain member: Require strong (Windows 2000 or later) session key', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'RequireStrongKey', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'LockoutDuration': {'Policy': 'Account lockout duration', 'lgpo_section': self.account_lockout_policy_gpedit_path, 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 6000000, 'zero_value': 4294967295}}, 'NetUserModal': {'Modal': 3, 'Option': 'lockout_duration'}, 'Transform': {'Get': '_seconds_to_minutes', 'Put': '_minutes_to_seconds', 'GetArgs': {'zero_value': 4294967295}, 'PutArgs': {'zero_value': 4294967295}}}, 'LockoutThreshold': {'Policy': 'Account lockout threshold', 'lgpo_section': self.account_lockout_policy_gpedit_path, 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 1000}}, 'NetUserModal': {'Modal': 3, 'Option': 'lockout_threshold'}}, 'LockoutWindow': {'Policy': 'Reset account lockout counter after', 'lgpo_section': self.account_lockout_policy_gpedit_path, 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 6000000}}, 'NetUserModal': {'Modal': 3, 'Option': 'lockout_observation_window'}, 'Transform': {'Get': '_seconds_to_minutes', 'Put': '_minutes_to_seconds'}}, 'AuditAccountLogon': {'Policy': 'Audit account logon events', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditAccountLogon', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditAccountManage': {'Policy': 'Audit account management', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditAccountManage', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditDSAccess': {'Policy': 'Audit directory service access', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditDSAccess', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditLogonEvents': {'Policy': 'Audit logon events', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditLogonEvents', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditObjectAccess': {'Policy': 'Audit object access', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditObjectAccess', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditPolicyChange': {'Policy': 'Audit policy change', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditPolicyChange', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditPrivilegeUse': {'Policy': 'Audit privilege use', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditPrivilegeUse', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditProcessTracking': {'Policy': 'Audit process tracking', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditProcessTracking', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditSystemEvents': {'Policy': 'Audit system events', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditSystemEvents', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditCredentialValidation': {'Policy': 'Audit Credential Validation', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Credential Validation'}, 'Transform': self.advanced_audit_transform}, 'AuditKerberosAuthenticationService': {'Policy': 'Audit Kerberos Authentication Service', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Kerberos Authentication Service'}, 'Transform': self.advanced_audit_transform}, 'AuditKerberosServiceTicketOperations': {'Policy': 'Audit Kerberos Service Ticket Operations', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Kerberos Service Ticket Operations'}, 'Transform': self.advanced_audit_transform}, 'AuditOtherAccountLogonEvents': {'Policy': 'Audit Other Account Logon Events', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Other Account Logon Events'}, 'Transform': self.advanced_audit_transform}, 'AuditApplicationGroupManagement': {'Policy': 'Audit Application Group Management', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Application Group Management'}, 'Transform': self.advanced_audit_transform}, 'AuditComputerAccountManagement': {'Policy': 'Audit Computer Account Management', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Computer Account Management'}, 'Transform': self.advanced_audit_transform}, 'AuditDistributionGroupManagement': {'Policy': 'Audit Distribution Group Management', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Distribution Group Management'}, 'Transform': self.advanced_audit_transform}, 'AuditOtherAccountManagementEvents': {'Policy': 'Audit Other Account Management Events', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Other Account Management Events'}, 'Transform': self.advanced_audit_transform}, 'AuditSecurityGroupManagement': {'Policy': 'Audit Security Group Management', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Security Group Management'}, 'Transform': self.advanced_audit_transform}, 'AuditUserAccountManagement': {'Policy': 'Audit User Account Management', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit User Account Management'}, 'Transform': self.advanced_audit_transform}, 'AuditDPAPIActivity': {'Policy': 'Audit DPAPI Activity', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit DPAPI Activity'}, 'Transform': self.advanced_audit_transform}, 'AuditPNPActivity': {'Policy': 'Audit PNP Activity', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit PNP Activity'}, 'Transform': self.advanced_audit_transform}, 'AuditProcessCreation': {'Policy': 'Audit Process Creation', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Process Creation'}, 'Transform': self.advanced_audit_transform}, 'AuditProcessTermination': {'Policy': 'Audit Process Termination', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Process Termination'}, 'Transform': self.advanced_audit_transform}, 'AuditRPCEvents': {'Policy': 'Audit RPC Events', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit RPC Events'}, 'Transform': self.advanced_audit_transform}, 'AuditTokenRightAdjusted': {'Policy': 'Audit Token Right Adjusted', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Token Right Adjusted'}, 'Transform': self.advanced_audit_transform}, 'AuditDetailedDirectoryServiceReplication': {'Policy': 'Audit Detailed Directory Service Replication', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Detailed Directory Service Replication'}, 'Transform': self.advanced_audit_transform}, 'AuditDirectoryServiceAccess': {'Policy': 'Audit Directory Service Access', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Directory Service Access'}, 'Transform': self.advanced_audit_transform}, 'AuditDirectoryServiceChanges': {'Policy': 'Audit Directory Service Changes', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Directory Service Changes'}, 'Transform': self.advanced_audit_transform}, 'AuditDirectoryServiceReplication': {'Policy': 'Audit Directory Service Replication', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Directory Service Replication'}, 'Transform': self.advanced_audit_transform}, 'AuditAccountLockout': {'Policy': 'Audit Account Lockout', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Account Lockout'}, 'Transform': self.advanced_audit_transform}, 'AuditUserDeviceClaims': {'Policy': 'Audit User / Device Claims', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit User / Device Claims'}, 'Transform': self.advanced_audit_transform}, 'AuditGroupMembership': {'Policy': 'Audit Group Membership', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Group Membership'}, 'Transform': self.advanced_audit_transform}, 'AuditIPsecExtendedMode': {'Policy': 'Audit IPsec Extended Mode', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit IPsec Extended Mode'}, 'Transform': self.advanced_audit_transform}, 'AuditIPsecMainMode': {'Policy': 'Audit IPsec Main Mode', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit IPsec Main Mode'}, 'Transform': self.advanced_audit_transform}, 'AuditIPsecQuickMode': {'Policy': 'Audit IPsec Quick Mode', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit IPsec Quick Mode'}, 'Transform': self.advanced_audit_transform}, 'AuditLogoff': {'Policy': 'Audit Logoff', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Logoff'}, 'Transform': self.advanced_audit_transform}, 'AuditLogon': {'Policy': 'Audit Logon', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Logon'}, 'Transform': self.advanced_audit_transform}, 'AuditNetworkPolicyServer': {'Policy': 'Audit Network Policy Server', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Network Policy Server'}, 'Transform': self.advanced_audit_transform}, 'AuditOtherLogonLogoffEvents': {'Policy': 'Audit Other Logon/Logoff Events', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Other Logon/Logoff Events'}, 'Transform': self.advanced_audit_transform}, 'AuditSpecialLogon': {'Policy': 'Audit Special Logon', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Special Logon'}, 'Transform': self.advanced_audit_transform}, 'AuditApplicationGenerated': {'Policy': 'Audit Application Generated', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Application Generated'}, 'Transform': self.advanced_audit_transform}, 'AuditCertificationServices': {'Policy': 'Audit Certification Services', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Certification Services'}, 'Transform': self.advanced_audit_transform}, 'AuditDetailedFileShare': {'Policy': 'Audit Detailed File Share', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Detailed File Share'}, 'Transform': self.advanced_audit_transform}, 'AuditFileShare': {'Policy': 'Audit File Share', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit File Share'}, 'Transform': self.advanced_audit_transform}, 'AuditFileSystem': {'Policy': 'Audit File System', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit File System'}, 'Transform': self.advanced_audit_transform}, 'AuditFilteringPlatformConnection': {'Policy': 'Audit Filtering Platform Connection', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Filtering Platform Connection'}, 'Transform': self.advanced_audit_transform}, 'AuditFilteringPlatformPacketDrop': {'Policy': 'Audit Filtering Platform Packet Drop', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Filtering Platform Packet Drop'}, 'Transform': self.advanced_audit_transform}, 'AuditHandleManipulation': {'Policy': 'Audit Handle Manipulation', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Handle Manipulation'}, 'Transform': self.advanced_audit_transform}, 'AuditKernelObject': {'Policy': 'Audit Kernel Object', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Kernel Object'}, 'Transform': self.advanced_audit_transform}, 'AuditOtherObjectAccessEvents': {'Policy': 'Audit Other Object Access Events', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Other Object Access Events'}, 'Transform': self.advanced_audit_transform}, 'AuditRegistry': {'Policy': 'Audit Registry', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Registry'}, 'Transform': self.advanced_audit_transform}, 'AuditRemovableStorage': {'Policy': 'Audit Removable Storage', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Removable Storage'}, 'Transform': self.advanced_audit_transform}, 'AuditSAM': {'Policy': 'Audit SAM', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit SAM'}, 'Transform': self.advanced_audit_transform}, 'AuditCentralAccessPolicyStaging': {'Policy': 'Audit Central Access Policy Staging', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Central Access Policy Staging'}, 'Transform': self.advanced_audit_transform}, 'AuditAuditPolicyChange': {'Policy': 'Audit Audit Policy Change', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Audit Policy Change'}, 'Transform': self.advanced_audit_transform}, 'AuditAuthenticationPolicyChange': {'Policy': 'Audit Authentication Policy Change', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Authentication Policy Change'}, 'Transform': self.advanced_audit_transform}, 'AuditAuthorizationPolicyChange': {'Policy': 'Audit Authorization Policy Change', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Authorization Policy Change'}, 'Transform': self.advanced_audit_transform}, 'AuditFilteringPlatformPolicyChange': {'Policy': 'Audit Filtering Platform Policy Change', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Filtering Platform Policy Change'}, 'Transform': self.advanced_audit_transform}, 'AuditMPSSVCRuleLevelPolicyChange': {'Policy': 'Audit MPSSVC Rule-Level Policy Change', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit MPSSVC Rule-Level Policy Change'}, 'Transform': self.advanced_audit_transform}, 'AuditOtherPolicyChangeEvents': {'Policy': 'Audit Other Policy Change Events', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Other Policy Change Events'}, 'Transform': self.advanced_audit_transform}, 'AuditNonSensitivePrivilegeUse': {'Policy': 'Audit Non Sensitive Privilege Use', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Non Sensitive Privilege Use'}, 'Transform': self.advanced_audit_transform}, 'AuditOtherPrivilegeUseEvents': {'Policy': 'Audit Other Privilege Use Events', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Other Privilege Use Events'}, 'Transform': self.advanced_audit_transform}, 'AuditSensitivePrivilegeUse': {'Policy': 'Audit Sensitive Privilege Use', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Sensitive Privilege Use'}, 'Transform': self.advanced_audit_transform}, 'AuditIPsecDriver': {'Policy': 'Audit IPsec Driver', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit IPsec Driver'}, 'Transform': self.advanced_audit_transform}, 'AuditOtherSystemEvents': {'Policy': 'Audit Other System Events', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Other System Events'}, 'Transform': self.advanced_audit_transform}, 'AuditSecurityStateChange': {'Policy': 'Audit Security State Change', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Security State Change'}, 'Transform': self.advanced_audit_transform}, 'AuditSecuritySystemExtension': {'Policy': 'Audit Security System Extension', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Security System Extension'}, 'Transform': self.advanced_audit_transform}, 'AuditSystemIntegrity': {'Policy': 'Audit System Integrity', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit System Integrity'}, 'Transform': self.advanced_audit_transform}, 'SeTrustedCredManAccessPrivilege': {'Policy': 'Access Credential Manager as a trusted caller', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeTrustedCredManAccessPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeNetworkLogonRight': {'Policy': 'Access this computer from the network', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeNetworkLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeTcbPrivilege': {'Policy': 'Act as part of the operating system', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeTcbPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeMachineAccountPrivilege': {'Policy': 'Add workstations to domain', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeMachineAccountPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeIncreaseQuotaPrivilege': {'Policy': 'Adjust memory quotas for a process', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeIncreaseQuotaPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeInteractiveLogonRight': {'Policy': 'Allow log on locally', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeInteractiveLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeRemoteInteractiveLogonRight': {'Policy': 'Allow log on through Remote Desktop Services', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeRemoteInteractiveLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeBackupPrivilege': {'Policy': 'Backup files and directories', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeBackupPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeChangeNotifyPrivilege': {'Policy': 'Bypass traverse checking', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeChangeNotifyPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeSystemtimePrivilege': {'Policy': 'Change the system time', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeSystemtimePrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeTimeZonePrivilege': {'Policy': 'Change the time zone', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeTimeZonePrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeCreatePagefilePrivilege': {'Policy': 'Create a pagefile', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeCreatePagefilePrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeCreateTokenPrivilege': {'Policy': 'Create a token object', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeCreateTokenPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeCreateGlobalPrivilege': {'Policy': 'Create global objects', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeCreateGlobalPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeCreatePermanentPrivilege': {'Policy': 'Create permanent shared objects', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeCreatePermanentPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeCreateSymbolicLinkPrivilege': {'Policy': 'Create symbolic links', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeCreateSymbolicLinkPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeDebugPrivilege': {'Policy': 'Debug programs', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeDebugPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeDenyNetworkLogonRight': {'Policy': 'Deny access to this computer from the network', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeDenyNetworkLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeDenyBatchLogonRight': {'Policy': 'Deny log on as a batch job', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeDenyBatchLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeDenyServiceLogonRight': {'Policy': 'Deny log on as a service', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeDenyServiceLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeDenyInteractiveLogonRight': {'Policy': 'Deny log on locally', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeDenyInteractiveLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeDenyRemoteInteractiveLogonRight': {'Policy': 'Deny log on through Remote Desktop Services', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeDenyRemoteInteractiveLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeEnableDelegationPrivilege': {'Policy': 'Enable computer and user accounts to be trusted for delegation', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeEnableDelegationPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeRemoteShutdownPrivilege': {'Policy': 'Force shutdown from a remote system', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeRemoteShutdownPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeAuditPrivilege': {'Policy': 'Generate security audits', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeAuditPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeImpersonatePrivilege': {'Policy': 'Impersonate a client after authentication', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeImpersonatePrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeIncreaseWorkingSetPrivilege': {'Policy': 'Increase a process working set', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeIncreaseWorkingSetPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeIncreaseBasePriorityPrivilege': {'Policy': 'Increase scheduling priority', 'rights_assignment': True, 'lgpo_section': self.user_rights_assignment_gpedit_path, 'Settings': None, 'LsaRights': {'Option': 'SeIncreaseBasePriorityPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeLoadDriverPrivilege': {'Policy': 'Load and unload device drivers', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeLoadDriverPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeLockMemoryPrivilege': {'Policy': 'Lock pages in memory', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeLockMemoryPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeBatchLogonRight': {'Policy': 'Log on as a batch job', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeBatchLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeServiceLogonRight': {'Policy': 'Log on as a service', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeServiceLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeSecurityPrivilege': {'Policy': 'Manage auditing and security log', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeSecurityPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeRelabelPrivilege': {'Policy': 'Modify an object label', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeRelabelPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeSystemEnvironmentPrivilege': {'Policy': 'Modify firmware environment values', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeSystemEnvironmentPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeManageVolumePrivilege': {'Policy': 'Perform volume maintenance tasks', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeManageVolumePrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeProfileSingleProcessPrivilege': {'Policy': 'Profile single process', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeProfileSingleProcessPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeSystemProfilePrivilege': {'Policy': 'Profile system performance', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeSystemProfilePrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeUndockPrivilege': {'Policy': 'Remove computer from docking station', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeUndockPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeAssignPrimaryTokenPrivilege': {'Policy': 'Replace a process level token', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeAssignPrimaryTokenPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeRestorePrivilege': {'Policy': 'Restore files and directories', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeRestorePrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeShutdownPrivilege': {'Policy': 'Shut down the system', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeShutdownPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeSyncAgentPrivilege': {'Policy': 'Synchronize directory service data', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeSyncAgentPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeTakeOwnershipPrivilege': {'Policy': 'Take ownership of files or other objects', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeTakeOwnershipPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'RecoveryConsoleSecurityLevel': {'Policy': 'Recovery console: Allow automatic administrative logon', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Setup\\\\RecoveryConsole', 'Value': 'SecurityLevel', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'RecoveryConsoleSetCommand': {'Policy': 'Recovery console: Allow floppy copy and access to all drives and all folders', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Setup\\\\RecoveryConsole', 'Value': 'SetCommand', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'ForceKeyProtection': {'Policy': 'System Cryptography: Force strong key protection for user keys stored on the computer', 'Settings': self.force_key_protection.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Policies\\\\Microsoft\\\\Cryptography', 'Value': 'ForceKeyProtection', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.force_key_protection, 'value_lookup': False}, 'PutArgs': {'lookup': self.force_key_protection, 'value_lookup': True}}}, 'FIPSAlgorithmPolicy': {'Policy': 'System Cryptography: Use FIPS compliant algorithms for encryption, hashing, and signing', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\FIPSAlgorithmPolicy', 'Value': 'Enabled', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'MachineAccessRestriction': {'Policy': 'DCOM: Machine Access Restrictions in Security Descriptor Definition Language (SDDL) syntax', 'Settings': None, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Policies\\\\Microsoft\\\\Windows NT\\\\DCOM', 'Value': 'MachineAccessRestriction', 'Type': 'REG_SZ'}, 'Transform': {'Put': '_string_put_transform'}}, 'MachineLaunchRestriction': {'Policy': 'DCOM: Machine Launch Restrictions in Security Descriptor Definition Language (SDDL) syntax', 'Settings': None, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Policies\\\\Microsoft\\\\Windows NT\\\\DCOM', 'Value': 'MachineLaunchRestriction', 'Type': 'REG_SZ'}, 'Transform': {'Put': '_string_put_transform'}}, 'UseMachineId': {'Policy': 'Network security: Allow Local System to use computer identity for NTLM', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'UseMachineId', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'allownullsessionfallback': {'Policy': 'Network security: Allow LocalSystem NULL session fallback', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\MSV1_0', 'Value': 'allownullsessionfallback', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'AllowOnlineID': {'Policy': 'Network security: Allow PKU2U authentication requests to this computer to use online identities.', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\pku2u', 'Value': 'AllowOnlineID', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'KrbSupportedEncryptionTypes': {'Policy': 'Network security: Configure encryption types allowed for Kerberos', 'Settings': None, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\policies\\\\system\\\\Kerberos\\\\Parameters', 'Value': 'SupportedEncryptionTypes', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup_bitwise_add', 'Put': '_dict_lookup_bitwise_add', 'GetArgs': {'lookup': self.krb_encryption_types, 'value_lookup': False}, 'PutArgs': {'lookup': self.krb_encryption_types, 'value_lookup': True}}}, 'NoLMHash': {'Policy': 'Network security: Do not store LAN Manager hash value on next password change', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'NoLMHash', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'ForceLogoffWhenHourExpire': {'Policy': 'Network security: Force logoff when logon hours expire', 'lgpo_section': self.security_options_gpedit_path, 'Settings': self.enabled_one_disabled_zero_no_not_defined.keys(), 'Secedit': {'Option': 'ForceLogoffWhenHourExpire', 'Section': 'System Access'}, 'Transform': self.enabled_one_disabled_zero_no_not_defined_transform}, 'LmCompatibilityLevel': {'Policy': 'Network security: LAN Manager authentication level', 'Settings': self.lm_compat_levels.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'LmCompatibilityLevel', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.lm_compat_levels, 'value_lookup': False}, 'PutArgs': {'lookup': self.lm_compat_levels, 'value_lookup': True}}}, 'LDAPClientIntegrity': {'Policy': 'Network security: LDAP client signing requirements', 'Settings': self.ldap_signing_reqs.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\ldap', 'Value': 'LDAPClientIntegrity', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.ldap_signing_reqs, 'value_lookup': False}, 'PutArgs': {'lookup': self.ldap_signing_reqs, 'value_lookup': True}}}, 'NTLMMinClientSec': {'Policy': 'Network security: Minimum session security for NTLM SSP based (including secure RPC) clients', 'Settings': None, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\MSV1_0', 'Value': 'NTLMMinClientSec', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup_bitwise_add', 'Put': '_dict_lookup_bitwise_add', 'GetArgs': {'lookup': self.ntlm_session_security_levels, 'value_lookup': False}, 'PutArgs': {'lookup': self.ntlm_session_security_levels, 'value_lookup': True}}}, 'NTLMMinServerSec': {'Policy': 'Network security: Minimum session security for NTLM SSP based (including secure RPC) servers', 'Settings': None, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\MSV1_0', 'Value': 'NTLMMinServerSec', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup_bitwise_add', 'Put': '_dict_lookup_bitwise_add', 'GetArgs': {'lookup': self.ntlm_session_security_levels, 'value_lookup': False}, 'PutArgs': {'lookup': self.ntlm_session_security_levels, 'value_lookup': True}}}, 'ClientAllowedNTLMServers': {'Policy': 'Network security: Restrict NTLM: Add remote server exceptions for NTLM authentication', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\MSV1_0', 'Value': 'ClientAllowedNTLMServers', 'Type': 'REG_MULTI_SZ'}, 'Transform': {'Put': '_multi_string_put_transform', 'Get': '_multi_string_get_transform'}}, 'DCAllowedNTLMServers': {'Policy': 'Network security: Restrict NTLM: Add server exceptions in this domain', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'DCAllowedNTLMServers', 'Type': 'REG_MULTI_SZ'}, 'Transform': {'Put': '_multi_string_put_transform', 'Get': '_multi_string_get_transform'}}, 'AuditReceivingNTLMTraffic': {'Policy': 'Network security: Restrict NTLM: Audit Incoming NTLM Traffic', 'Settings': self.ntlm_audit_settings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\LSA\\\\MSV1_0', 'Value': 'AuditReceivingNTLMTraffic', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.ntlm_audit_settings, 'value_lookup': False}, 'PutArgs': {'lookup': self.ntlm_audit_settings, 'value_lookup': True}}}, 'AuditNTLMInDomain': {'Policy': 'Network security: Restrict NTLM: Audit NTLM authentication in this domain', 'Settings': self.ntlm_domain_audit_settings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'AuditNTLMInDomain', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.ntlm_domain_audit_settings, 'value_lookup': False}, 'PutArgs': {'lookup': self.ntlm_domain_audit_settings, 'value_lookup': True}}}, 'RestrictReceivingNTLMTraffic': {'Policy': 'Network security: Restrict NTLM: Incoming NTLM traffic', 'Settings': self.incoming_ntlm_settings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\LSA\\\\MSV1_0', 'Value': 'RestrictReceivingNTLMTraffic', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.incoming_ntlm_settings, 'value_lookup': False}, 'PutArgs': {'lookup': self.incoming_ntlm_settings, 'value_lookup': True}}}, 'RestrictNTLMInDomain': {'Policy': 'Network security: Restrict NTLM: NTLM authentication in this domain', 'Settings': self.ntlm_domain_auth_settings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'RestrictNTLMInDomain', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.ntlm_domain_auth_settings, 'value_lookup': False}, 'PutArgs': {'lookup': self.ntlm_domain_auth_settings, 'value_lookup': True}}}, 'RestrictSendingNTLMTraffic': {'Policy': 'Network security: Restrict NTLM: Outgoing NTLM traffic to remote servers', 'Settings': self.outgoing_ntlm_settings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\MSV1_0', 'Value': 'RestrictSendingNTLMTraffic', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.outgoing_ntlm_settings, 'value_lookup': False}, 'PutArgs': {'lookup': self.outgoing_ntlm_settings, 'value_lookup': True}}}, 'ShutdownWithoutLogon': {'Policy': 'Shutdown: Allow system to be shut down without having to log on', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\policies\\\\system', 'Value': 'ShutdownWithoutLogon', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'ClearPageFileAtShutdown': {'Policy': 'Shutdown: Clear virtual memory pagefile', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\SESSION MANAGER\\\\MEMORY MANAGEMENT', 'Value': 'ClearPageFileAtShutdown', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'ObCaseInsensitive': {'Policy': 'System objects: Require case insensitivity for non-Windows subsystems', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\SESSION MANAGER\\\\Kernel', 'Value': 'ObCaseInsensitive', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'ProtectionMode': {'Policy': 'System objects: Strengthen default permissions of internal system objects (e.g. Symbolic Links)', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\SESSION MANAGER', 'Value': 'ProtectionMode', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'OptionalSubsystems': {'Policy': 'System settings: Optional subsystems', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\SESSION MANAGER\\\\SubSystems', 'Value': 'optional', 'Type': 'REG_MULTI_SZ'}, 'Transform': {'Put': '_multi_string_put_transform', 'Get': '_multi_string_get_transform'}}, 'AuthenticodeEnabled': {'Policy': 'System settings: Use Certificate Rules on Windows Executables for Software Restriction Policies', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Policies\\\\Microsoft\\\\Windows\\\\safer\\\\codeidentifiers', 'Value': 'AuthenticodeEnabled', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}}}, 'User': {'lgpo_section': 'User Configuration', 'policies': {}}}",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.audit_lookup = {0: 'No auditing', 1: 'Success', 2: 'Failure', 3: 'Success, Failure', 'Not Defined': 'Not Defined', None: 'Not Defined'}\n    self.advanced_audit_lookup = {0: 'No Auditing', 1: 'Success', 2: 'Failure', 3: 'Success and Failure', None: 'Not Configured'}\n    self.sc_removal_lookup = {'0': 'No Action', '1': 'Lock Workstation', '2': 'Force Logoff', '3': 'Disconnect if a Remote Desktop Services session', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.uac_admin_prompt_lookup = {0: 'Elevate without prompting', 1: 'Prompt for credentials on the secure desktop', 2: 'Prompt for consent on the secure desktop', 3: 'Prompt for credentials', 4: 'Prompt for consent', 5: 'Prompt for consent for non-Windows binaries', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.uac_user_prompt_lookup = {0: 'Automatically deny elevation requests', 1: 'Prompt for credentials on the secure desktop', 3: 'Prompt for credentials', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.enabled_one_disabled_zero = {0: 'Disabled', 1: 'Enabled', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.enabled_one_disabled_zero_transform = {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.enabled_one_disabled_zero, 'value_lookup': False}, 'PutArgs': {'lookup': self.enabled_one_disabled_zero, 'value_lookup': True}}\n    self.s4u2self_options = {0: 'Default', 1: 'Enabled', 2: 'Disabled', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.audit_transform = {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.audit_lookup, 'value_lookup': False}, 'PutArgs': {'lookup': self.audit_lookup, 'value_lookup': True}}\n    self.advanced_audit_transform = {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.advanced_audit_lookup, 'value_lookup': False}, 'PutArgs': {'lookup': self.advanced_audit_lookup, 'value_lookup': True}}\n    self.enabled_one_disabled_zero_strings = {'0': 'Disabled', '1': 'Enabled', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.enabled_one_disabled_zero_strings_transform = {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.enabled_one_disabled_zero_strings, 'value_lookup': False}, 'PutArgs': {'lookup': self.enabled_one_disabled_zero_strings, 'value_lookup': True}}\n    self.security_options_gpedit_path = ['Computer Configuration', 'Windows Settings', 'Security Settings', 'Local Policies', 'Security Options']\n    self.windows_firewall_gpedit_path = ['Computer Configuration', 'Windows Settings', 'Security Settings', 'Windows Firewall with Advanced Security', 'Windows Firewall with Advanced Security - Local Group Policy Object']\n    self.password_policy_gpedit_path = ['Computer Configuration', 'Windows Settings', 'Security Settings', 'Account Policies', 'Password Policy']\n    self.audit_policy_gpedit_path = ['Computer Configuration', 'Windows Settings', 'Security Settings', 'Local Policies', 'Audit Policy']\n    self.advanced_audit_policy_gpedit_path = ['Computer Configuration', 'Windows Settings', 'Security Settings', 'Advanced Audit Policy Configuration', 'System Audit Policies - Local Group Policy Object']\n    self.account_lockout_policy_gpedit_path = ['Computer Configuration', 'Windows Settings', 'Security Settings', 'Account Policies', 'Account Lockout Policy']\n    self.user_rights_assignment_gpedit_path = ['Computer Configuration', 'Windows Settings', 'Security Settings', 'Local Policies', 'User Rights Assignment']\n    self.block_ms_accounts = {0: 'This policy is disabled', 1: \"Users can't add Microsoft accounts\", 3: \"Users can't add or log on with Microsoft accounts\", None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.ldap_server_binding_token_requirements = {0: 'Never', 1: 'When supported', 2: 'Always', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.ldap_server_signing_requirements = {1: 'None', 2: 'Require signing', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.smb_server_name_hardening_levels = {0: 'Off', 1: 'Accept if provided by client', 2: 'Required from client', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.locked_session_user_info = {1: 'User display name, domain and user names', 2: 'User display name only', 3: 'Do not display user information', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.force_guest = {0: 'Classic - local users authenticate as themselves', 1: 'Guest only - local users authenticate as Guest', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.force_key_protection = {0: 'User input is not required when new keys are stored and used', 1: 'User is prompted when the key is first used', 2: 'User must enter a password each time they use a key', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.firewall_inbound_connections = {'blockinbound': 'Block (default)', 'blockinboundalways': 'Block all connections', 'allowinbound': 'Allow', 'notconfigured': 'Not configured'}\n    self.firewall_outbound_connections = {'blockoutbound': 'Block', 'allowoutbound': 'Allow (default)', 'notconfigured': 'Not configured'}\n    self.firewall_rule_merging = {'enable': 'Yes (default)', 'disable': 'No', 'notconfigured': 'Not configured'}\n    self.firewall_log_packets_connections = {'enable': 'Yes', 'disable': 'No (default)', 'notconfigured': 'Not configured'}\n    self.firewall_notification = {'enable': 'Yes', 'disable': 'No', 'notconfigured': 'Not configured'}\n    self.firewall_state = {'on': 'On (recommended)', 'off': 'Off', 'notconfigured': 'Not configured'}\n    self.krb_encryption_types = {0: 'No minimum', 1: 'DES_CBC_CRC', 2: 'DES_CBD_MD5', 4: 'RC4_HMAC_MD5', 8: 'AES128_HMAC_SHA1', 16: 'AES256_HMAC_SHA1', 2147483616: 'Future Encryption Types', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.lm_compat_levels = {0: 'Send LM & NTLM response', 1: 'Send LM & NTLM - use NTLMv2 session security if negotiated', 2: 'Send NTLM response only', 3: 'Send NTLMv2 response only', 4: 'Send NTLMv2 response only. Refuse LM', 5: 'Send NTLMv2 response only. Refuse LM & NTLM', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.ldap_signing_reqs = {0: 'None', 1: 'Negotiate signing', 2: 'Require signing', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.ntlm_session_security_levels = {0: 'No minimum', 524288: 'Require NTLMv2 session security', 536870912: 'Require 128-bit encryption', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.ntlm_audit_settings = {0: 'Disable', 1: 'Enable auditing for domain accounts', 2: 'Enable auditing for all accounts', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.ntlm_domain_audit_settings = {0: 'Disable', 1: 'Enable for domain accounts to domain servers', 3: 'Enable for domain accounts', 5: 'Enable for domain servers', 7: 'Enable all', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.incoming_ntlm_settings = {0: 'Allow all', 1: 'Deny all domain accounts', 2: 'Deny all accounts', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.ntlm_domain_auth_settings = {0: 'Disable', 1: 'Deny for domain accounts to domain servers', 3: 'Deny for domain accounts', 5: 'Deny for domain servers', 7: 'Deny all', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.outgoing_ntlm_settings = {0: 'Allow all', 1: 'Audit all', 2: 'Deny all', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.enabled_one_disabled_zero_no_not_defined = {0: 'Disabled', 1: 'Enabled'}\n    self.enabled_one_disabled_zero_no_not_defined_transform = {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.enabled_one_disabled_zero_no_not_defined, 'value_lookup': False}, 'PutArgs': {'lookup': self.enabled_one_disabled_zero_no_not_defined, 'value_lookup': True}}\n    self.policies = {'Machine': {'lgpo_section': 'Computer Configuration', 'policies': {'StartupScripts': {'Policy': 'Startup Scripts', 'lgpo_section': ['Computer Configuration', 'Windows Settings', 'Scripts (Startup/Shutdown)', 'Startup'], 'ScriptIni': {'Section': 'Startup', 'IniPath': os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'Machine', 'Scripts', 'scripts.ini')}}, 'StartupPowershellScripts': {'Policy': 'Startup Powershell Scripts', 'lgpo_section': ['Computer Configuration', 'Windows Settings', 'Scripts (Startup/Shutdown)', 'Startup'], 'ScriptIni': {'Section': 'Startup', 'IniPath': os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'Machine', 'Scripts', 'psscripts.ini')}}, 'StartupPowershellScriptOrder': {'Policy': 'Startup - For this GPO, run scripts in the following order', 'lgpo_section': ['Computer Configuration', 'Windows Settings', 'Scripts (Startup/Shutdown)', 'Startup'], 'ScriptIni': {'IniPath': os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'Machine', 'Scripts', 'psscripts.ini'), 'Section': 'ScriptsConfig', 'SettingName': 'StartExecutePSFirst', 'Settings': ['true', 'false', None]}, 'Transform': {'Get': '_powershell_script_order_conversion', 'Put': '_powershell_script_order_reverse_conversion'}}, 'ShutdownScripts': {'Policy': 'Shutdown Scripts', 'lgpo_section': ['Computer Configuration', 'Windows Settings', 'Scripts (Startup/Shutdown)', 'Shutdown'], 'ScriptIni': {'Section': 'Shutdown', 'IniPath': os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'Machine', 'Scripts', 'scripts.ini')}}, 'ShutdownPowershellScripts': {'Policy': 'Shutdown Powershell Scripts', 'lgpo_section': ['Computer Configuration', 'Windows Settings', 'Scripts (Startup/Shutdown)', 'Shutdown'], 'ScriptIni': {'Section': 'Shutdown', 'IniPath': os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'Machine', 'Scripts', 'psscripts.ini')}}, 'ShutdownPowershellScriptOrder': {'Policy': 'Shutdown - For this GPO, run scripts in the following order', 'lgpo_section': ['Computer Configuration', 'Windows Settings', 'Scripts (Startup/Shutdown)', 'Shutdown'], 'ScriptIni': {'IniPath': os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'Machine', 'Scripts', 'psscripts.ini'), 'Section': 'ScriptsConfig', 'SettingName': 'EndExecutePSFirst', 'Settings': ['true', 'false', None]}, 'Transform': {'Get': '_powershell_script_order_conversion', 'Put': '_powershell_script_order_reverse_conversion'}}, 'LSAAnonymousNameLookup': {'Policy': 'Network access: Allow anonymous SID/Name translation', 'lgpo_section': self.password_policy_gpedit_path, 'Settings': self.enabled_one_disabled_zero_no_not_defined.keys(), 'Secedit': {'Option': 'LSAAnonymousNameLookup', 'Section': 'System Access'}, 'Transform': self.enabled_one_disabled_zero_no_not_defined_transform}, 'RestrictAnonymousSam': {'Policy': 'Network access: Do not allow anonymous enumeration of SAM accounts', 'lgpo_section': self.security_options_gpedit_path, 'Settings': self.enabled_one_disabled_zero.keys(), 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'RestrictAnonymousSam', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'RestrictRemoteSAM': {'Policy': 'Network access: Restrict clients allowed to make remote calls to SAM', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'RestrictRemoteSAM', 'Type': 'REG_SZ'}, 'Transform': {'Put': '_string_put_transform'}}, 'RestrictAnonymous': {'Policy': 'Network access: Do not allow anonymous enumeration of SAM accounts and shares', 'lgpo_section': self.security_options_gpedit_path, 'Settings': self.enabled_one_disabled_zero.keys(), 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'RestrictAnonymous', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'DisableDomainCreds': {'Policy': 'Network access: Do not allow storage of passwords and credentials for network authentication', 'lgpo_section': self.security_options_gpedit_path, 'Settings': self.enabled_one_disabled_zero.keys(), 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'DisableDomainCreds', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'EveryoneIncludesAnonymous': {'Policy': 'Network access: Let Everyone permissions apply to anonymous users', 'lgpo_section': self.security_options_gpedit_path, 'Settings': self.enabled_one_disabled_zero.keys(), 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'everyoneincludesanonymous', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'NullSessionPipes': {'Policy': 'Network access: Named Pipes that can be accessed anonymously', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'NullSessionPipes', 'Type': 'REG_MULTI_SZ'}, 'Transform': {'Put': '_multi_string_put_transform', 'Get': '_multi_string_get_transform'}}, 'RemoteRegistryExactPaths': {'Policy': 'Network access: Remotely accessible registry paths', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\SecurePipeServers\\\\winreg\\\\AllowedExactPaths', 'Value': 'Machine', 'Type': 'REG_MULTI_SZ'}, 'Transform': {'Put': '_multi_string_put_transform', 'Get': '_multi_string_get_transform'}}, 'RemoteRegistryPaths': {'Policy': 'Network access: Remotely accessible registry paths and sub-paths', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\SecurePipeServers\\\\winreg\\\\AllowedPaths', 'Value': 'Machine', 'Type': 'REG_MULTI_SZ'}, 'Transform': {'Put': '_multi_string_put_transform', 'Get': '_multi_string_get_transform'}}, 'RestrictNullSessAccess': {'Policy': 'Network access: Restrict anonymous access to Named Pipes and Shares', 'lgpo_section': self.security_options_gpedit_path, 'Settings': self.enabled_one_disabled_zero.keys(), 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'RestrictNullSessAccess', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'NullSessionShares': {'Policy': 'Network access: Shares that can be accessed anonymously', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'NullSessionShares', 'Type': 'REG_MULTI_SZ'}, 'Transform': {'Put': '_multi_string_put_transform', 'Get': '_multi_string_get_transform'}}, 'ForceGuest': {'Policy': 'Network access: Sharing and security model for local accounts', 'lgpo_section': self.security_options_gpedit_path, 'Settings': self.force_guest.keys(), 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'ForceGuest', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.force_guest, 'value_lookup': False}, 'PutArgs': {'lookup': self.force_guest, 'value_lookup': True}}}, 'WfwDomainState': {'Policy': 'Network firewall: Domain: State', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_state.keys(), 'NetSH': {'Profile': 'domain', 'Section': 'state', 'Option': 'State'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_state, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_state, 'value_lookup': True}}}, 'WfwPrivateState': {'Policy': 'Network firewall: Private: State', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_state.keys(), 'NetSH': {'Profile': 'private', 'Section': 'state', 'Option': 'State'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_state, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_state, 'value_lookup': True}}}, 'WfwPublicState': {'Policy': 'Network firewall: Public: State', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_state.keys(), 'NetSH': {'Profile': 'public', 'Section': 'state', 'Option': 'State'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_state, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_state, 'value_lookup': True}}}, 'WfwDomainInboundConnections': {'Policy': 'Network firewall: Domain: Inbound connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_inbound_connections.keys(), 'NetSH': {'Profile': 'domain', 'Section': 'firewallpolicy', 'Option': 'Inbound'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_inbound_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_inbound_connections, 'value_lookup': True}}}, 'WfwPrivateInboundConnections': {'Policy': 'Network firewall: Private: Inbound connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_inbound_connections.keys(), 'NetSH': {'Profile': 'private', 'Section': 'firewallpolicy', 'Option': 'Inbound'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_inbound_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_inbound_connections, 'value_lookup': True}}}, 'WfwPublicInboundConnections': {'Policy': 'Network firewall: Public: Inbound connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_inbound_connections.keys(), 'NetSH': {'Profile': 'public', 'Section': 'firewallpolicy', 'Option': 'Inbound'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_inbound_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_inbound_connections, 'value_lookup': True}}}, 'WfwDomainOutboundConnections': {'Policy': 'Network firewall: Domain: Outbound connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_outbound_connections.keys(), 'NetSH': {'Profile': 'domain', 'Section': 'firewallpolicy', 'Option': 'Outbound'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_outbound_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_outbound_connections, 'value_lookup': True}}}, 'WfwPrivateOutboundConnections': {'Policy': 'Network firewall: Private: Outbound connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_outbound_connections.keys(), 'NetSH': {'Profile': 'private', 'Section': 'firewallpolicy', 'Option': 'Outbound'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_outbound_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_outbound_connections, 'value_lookup': True}}}, 'WfwPublicOutboundConnections': {'Policy': 'Network firewall: Public: Outbound connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_outbound_connections.keys(), 'NetSH': {'Profile': 'public', 'Section': 'firewallpolicy', 'Option': 'Outbound'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_outbound_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_outbound_connections, 'value_lookup': True}}}, 'WfwDomainSettingsNotification': {'Policy': 'Network firewall: Domain: Settings: Display a notification', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_notification.keys(), 'NetSH': {'Profile': 'domain', 'Section': 'settings', 'Option': 'InboundUserNotification'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_notification, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_notification, 'value_lookup': True}}}, 'WfwPrivateSettingsNotification': {'Policy': 'Network firewall: Private: Settings: Display a notification', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_notification.keys(), 'NetSH': {'Profile': 'private', 'Section': 'settings', 'Option': 'InboundUserNotification'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_notification, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_notification, 'value_lookup': True}}}, 'WfwPublicSettingsNotification': {'Policy': 'Network firewall: Public: Settings: Display a notification', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_notification.keys(), 'NetSH': {'Profile': 'public', 'Section': 'settings', 'Option': 'InboundUserNotification'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_notification, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_notification, 'value_lookup': True}}}, 'WfwDomainSettingsLocalFirewallRules': {'Policy': 'Network firewall: Domain: Settings: Apply local firewall rules', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_rule_merging.keys(), 'NetSH': {'Profile': 'domain', 'Section': 'settings', 'Option': 'LocalFirewallRules'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': True}}}, 'WfwPrivateSettingsLocalFirewallRules': {'Policy': 'Network firewall: Private: Settings: Apply local firewall rules', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_rule_merging.keys(), 'NetSH': {'Profile': 'private', 'Section': 'settings', 'Option': 'LocalFirewallRules'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': True}}}, 'WfwPublicSettingsLocalFirewallRules': {'Policy': 'Network firewall: Public: Settings: Apply local firewall rules', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_rule_merging.keys(), 'NetSH': {'Profile': 'public', 'Section': 'settings', 'Option': 'LocalFirewallRules'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': True}}}, 'WfwDomainSettingsLocalConnectionRules': {'Policy': 'Network firewall: Domain: Settings: Apply local connection security rules', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_rule_merging.keys(), 'NetSH': {'Profile': 'domain', 'Section': 'settings', 'Option': 'LocalConSecRules'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': True}}}, 'WfwPrivateSettingsLocalConnectionRules': {'Policy': 'Network firewall: Private: Settings: Apply local connection security rules', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_rule_merging.keys(), 'NetSH': {'Profile': 'private', 'Section': 'settings', 'Option': 'LocalConSecRules'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': True}}}, 'WfwPublicSettingsLocalConnectionRules': {'Policy': 'Network firewall: Public: Settings: Apply local connection security rules', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_rule_merging.keys(), 'NetSH': {'Profile': 'public', 'Section': 'settings', 'Option': 'LocalConSecRules'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': True}}}, 'WfwDomainLoggingName': {'Policy': 'Network firewall: Domain: Logging: Name', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': None, 'NetSH': {'Profile': 'domain', 'Section': 'logging', 'Option': 'FileName'}}, 'WfwPrivateLoggingName': {'Policy': 'Network firewall: Private: Logging: Name', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': None, 'NetSH': {'Profile': 'private', 'Section': 'logging', 'Option': 'FileName'}}, 'WfwPublicLoggingName': {'Policy': 'Network firewall: Public: Logging: Name', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': None, 'NetSH': {'Profile': 'public', 'Section': 'logging', 'Option': 'FileName'}}, 'WfwDomainLoggingMaxFileSize': {'Policy': 'Network firewall: Domain: Logging: Size limit (KB)', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': None, 'NetSH': {'Profile': 'domain', 'Section': 'logging', 'Option': 'MaxFileSize'}}, 'WfwPrivateLoggingMaxFileSize': {'Policy': 'Network firewall: Private: Logging: Size limit (KB)', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': None, 'NetSH': {'Profile': 'private', 'Section': 'logging', 'Option': 'MaxFileSize'}}, 'WfwPublicLoggingMaxFileSize': {'Policy': 'Network firewall: Public: Logging: Size limit (KB)', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': None, 'NetSH': {'Profile': 'public', 'Section': 'logging', 'Option': 'MaxFileSize'}}, 'WfwDomainLoggingAllowedConnections': {'Policy': 'Network firewall: Domain: Logging: Log successful connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_log_packets_connections.keys(), 'NetSH': {'Profile': 'domain', 'Section': 'logging', 'Option': 'LogAllowedConnections'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': True}}}, 'WfwPrivateLoggingAllowedConnections': {'Policy': 'Network firewall: Private: Logging: Log successful connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_log_packets_connections.keys(), 'NetSH': {'Profile': 'private', 'Section': 'logging', 'Option': 'LogAllowedConnections'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': True}}}, 'WfwPublicLoggingAllowedConnections': {'Policy': 'Network firewall: Public: Logging: Log successful connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_log_packets_connections.keys(), 'NetSH': {'Profile': 'public', 'Section': 'logging', 'Option': 'LogAllowedConnections'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': True}}}, 'WfwDomainLoggingDroppedConnections': {'Policy': 'Network firewall: Domain: Logging: Log dropped packets', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_log_packets_connections.keys(), 'NetSH': {'Profile': 'domain', 'Section': 'logging', 'Option': 'LogDroppedConnections'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': True}}}, 'WfwPrivateLoggingDroppedConnections': {'Policy': 'Network firewall: Private: Logging: Log dropped packets', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_log_packets_connections.keys(), 'NetSH': {'Profile': 'private', 'Section': 'logging', 'Option': 'LogDroppedConnections'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': True}}}, 'WfwPublicLoggingDroppedConnections': {'Policy': 'Network firewall: Public: Logging: Log dropped packets', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_log_packets_connections.keys(), 'NetSH': {'Profile': 'public', 'Section': 'logging', 'Option': 'LogDroppedConnections'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': True}}}, 'PasswordHistory': {'Policy': 'Enforce password history', 'lgpo_section': self.password_policy_gpedit_path, 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 24}}, 'NetUserModal': {'Modal': 0, 'Option': 'password_hist_len'}}, 'MaxPasswordAge': {'Policy': 'Maximum password age', 'lgpo_section': self.password_policy_gpedit_path, 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 1, 'max': 86313600, 'zero_value': 4294967295}}, 'NetUserModal': {'Modal': 0, 'Option': 'max_passwd_age'}, 'Transform': {'Get': '_seconds_to_days', 'Put': '_days_to_seconds', 'GetArgs': {'zero_value': 4294967295}, 'PutArgs': {'zero_value': 4294967295}}}, 'MinPasswordAge': {'Policy': 'Minimum password age', 'lgpo_section': self.password_policy_gpedit_path, 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 86313600}}, 'NetUserModal': {'Modal': 0, 'Option': 'min_passwd_age'}, 'Transform': {'Get': '_seconds_to_days', 'Put': '_days_to_seconds'}}, 'MinPasswordLen': {'Policy': 'Minimum password length', 'lgpo_section': self.password_policy_gpedit_path, 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 14}}, 'NetUserModal': {'Modal': 0, 'Option': 'min_passwd_len'}}, 'PasswordComplexity': {'Policy': 'Password must meet complexity requirements', 'lgpo_section': self.password_policy_gpedit_path, 'Settings': self.enabled_one_disabled_zero_no_not_defined.keys(), 'Secedit': {'Option': 'PasswordComplexity', 'Section': 'System Access'}, 'Transform': self.enabled_one_disabled_zero_no_not_defined_transform}, 'ClearTextPasswords': {'Policy': 'Store passwords using reversible encryption', 'lgpo_section': self.password_policy_gpedit_path, 'Settings': self.enabled_one_disabled_zero_no_not_defined.keys(), 'Secedit': {'Option': 'ClearTextPassword', 'Section': 'System Access'}, 'Transform': self.enabled_one_disabled_zero_no_not_defined_transform}, 'RelaxMinimumPasswordLengthLimits': {'Policy': 'Relax minimum password length limits', 'lgpo_section': self.password_policy_gpedit_path, 'Settings': self.enabled_one_disabled_zero.keys(), 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\SAM', 'Value': 'RelaxMinimumPasswordLengthLimits', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'AdminAccountStatus': {'Policy': 'Accounts: Administrator account status', 'Settings': self.enabled_one_disabled_zero_no_not_defined.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Secedit': {'Option': 'EnableAdminAccount', 'Section': 'System Access'}, 'Transform': self.enabled_one_disabled_zero_no_not_defined_transform}, 'NoConnectedUser': {'Policy': 'Accounts: Block Microsoft accounts', 'Settings': self.block_ms_accounts.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\policies\\\\system', 'Value': 'NoConnectedUser', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.block_ms_accounts, 'value_lookup': False}, 'PutArgs': {'lookup': self.block_ms_accounts, 'value_lookup': True}}}, 'GuestAccountStatus': {'Policy': 'Accounts: Guest account status', 'Settings': self.enabled_one_disabled_zero_no_not_defined.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Secedit': {'Option': 'EnableGuestAccount', 'Section': 'System Access'}, 'Transform': self.enabled_one_disabled_zero_no_not_defined_transform}, 'LimitBlankPasswordUse': {'Policy': 'Accounts: Limit local account use of blank passwords to console logon only', 'lgpo_section': self.security_options_gpedit_path, 'Settings': self.enabled_one_disabled_zero.keys(), 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'limitblankpassworduse', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'RenameAdministratorAccount': {'Policy': 'Accounts: Rename administrator account', 'Settings': None, 'lgpo_section': self.security_options_gpedit_path, 'Secedit': {'Option': 'NewAdministratorName', 'Section': 'System Access'}, 'Transform': {'Get': '_strip_quotes', 'Put': '_add_quotes'}}, 'RenameGuestAccount': {'Policy': 'Accounts: Rename guest account', 'Settings': None, 'lgpo_section': self.security_options_gpedit_path, 'Secedit': {'Option': 'NewGuestName', 'Section': 'System Access'}, 'Transform': {'Get': '_strip_quotes', 'Put': '_add_quotes'}}, 'AuditBaseObjects': {'Policy': 'Audit: Audit the access of global system objects', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'AuditBaseObjects', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'SceNoApplyLegacyAuditPolicy': {'Policy': 'Audit: Force audit policy subcategory settings (Windows Vista or later) to override audit policy category settings', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'SCENoApplyLegacyAuditPolicy', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'DontDisplayLastUserName': {'Policy': 'Interactive logon: Do not display last user name', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'DontDisplayLastUserName', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'CachedLogonsCount': {'Policy': 'Interactive logon: Number of previous logons to cache (in case domain controller is not available)', 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 50}}, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon', 'Value': 'CachedLogonsCount', 'Type': 'REG_SZ'}}, 'ForceUnlockLogon': {'Policy': 'Interactive logon: Require Domain Controller authentication to unlock workstation', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon', 'Value': 'ForceUnlockLogon', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'ScRemoveOption': {'Policy': 'Interactive logon: Smart card removal behavior', 'Settings': self.sc_removal_lookup.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon', 'Value': 'ScRemoveOption', 'Type': 'REG_SZ'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.sc_removal_lookup, 'value_lookup': False}, 'PutArgs': {'lookup': self.sc_removal_lookup, 'value_lookup': True}}}, 'DisableCAD': {'Policy': 'Interactive logon: Do not require CTRL+ALT+DEL', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'DisableCAD', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'FilterAdministratorToken': {'Policy': 'User Account Control: Admin Approval Mode for the built-in Administrator account', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'FilterAdministratorToken', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'EnableUIADesktopToggle': {'Policy': 'User Account Control: Allow UIAccess applications to prompt for elevation without using the secure desktop', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'EnableUIADesktopToggle', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'ConsentPromptBehaviorAdmin': {'Policy': 'User Account Control: Behavior of the elevation prompt for administrators in Admin Approval Mode', 'Settings': self.uac_admin_prompt_lookup.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'ConsentPromptBehaviorAdmin', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.uac_admin_prompt_lookup, 'value_lookup': False}, 'PutArgs': {'lookup': self.uac_admin_prompt_lookup, 'value_lookup': True}}}, 'ConsentPromptBehaviorUser': {'Policy': 'User Account Control: Behavior of the elevation prompt for standard users', 'Settings': self.uac_user_prompt_lookup.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'ConsentPromptBehaviorUser', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.uac_user_prompt_lookup, 'value_lookup': False}, 'PutArgs': {'lookup': self.uac_user_prompt_lookup, 'value_lookup': True}}}, 'EnableInstallerDetection': {'Policy': 'User Account Control: Detect application installations and prompt for elevation', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'EnableInstallerDetection', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'ValidateAdminCodeSignatures': {'Policy': 'User Account Control: Only elevate executables that are signed and validated', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'ValidateAdminCodeSignatures', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'EnableSecureUIAPaths': {'Policy': 'User Account Control: Only elevate UIAccess applications that are installed in secure locations', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'EnableSecureUIAPaths', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'EnableLUA': {'Policy': 'User Account Control: Run all administrators in Admin Approval Mode', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'EnableLUA', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'PromptOnSecureDesktop': {'Policy': 'User Account Control: Switch to the secure desktop when prompting for elevation', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'PromptOnSecureDesktop', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'EnableVirtualization': {'Policy': 'User Account Control: Virtualize file and registry write failures to per-user locations', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'EnableVirtualization', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'PasswordExpiryWarning': {'Policy': 'Interactive logon: Prompt user to change password before expiration', 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 999}}, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon', 'Value': 'PasswordExpiryWarning', 'Type': 'REG_DWORD'}}, 'MaxDevicePasswordFailedAttempts': {'Policy': 'Interactive logon: Machine account lockout threshold', 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 999}}, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\policies\\\\system', 'Value': 'MaxDevicePasswordFailedAttempts', 'Type': 'REG_DWORD'}}, 'InactivityTimeoutSecs': {'Policy': 'Interactive logon: Machine inactivity limit', 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 599940}}, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\policies\\\\system', 'Value': 'InactivityTimeoutSecs', 'Type': 'REG_DWORD'}}, 'legalnoticetext': {'Policy': 'Interactive logon: Message text for users attempting to log on', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\policies\\\\system', 'Value': 'legalnoticetext', 'Type': 'REG_SZ'}, 'Transform': {'Put': '_string_put_transform'}}, 'legalnoticecaption': {'Policy': 'Interactive logon: Message title for users attempting to log on', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\policies\\\\system', 'Value': 'legalnoticecaption', 'Type': 'REG_SZ'}, 'Transform': {'Put': '_string_put_transform'}}, 'DontDisplayLockedUserId': {'Policy': 'Interactive logon: Display user information when the session is locked', 'Settings': self.locked_session_user_info.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\policies\\\\system', 'Value': 'DontDisplayLockedUserId', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.locked_session_user_info, 'value_lookup': False}, 'PutArgs': {'lookup': self.locked_session_user_info, 'value_lookup': True}}}, 'ScForceOption': {'Policy': 'Interactive logon: Require smart card', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'ScForceOption', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'Client_RequireSecuritySignature': {'Policy': 'Microsoft network client: Digitally sign communications (always)', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\LanmanWorkstation\\\\Parameters', 'Value': 'RequireSecuritySignature', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'Client_EnableSecuritySignature': {'Policy': 'Microsoft network client: Digitally sign communications (if server agrees)', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\LanmanWorkstation\\\\Parameters', 'Value': 'EnableSecuritySignature', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'EnablePlainTextPassword': {'Policy': 'Microsoft network client: Send unencrypted password to third-party SMB servers', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\LanmanWorkstation\\\\Parameters', 'Value': 'EnablePlainTextPassword', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'AutoDisconnect': {'Policy': 'Microsoft network server: Amount of idle time required before suspending session', 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 99999}}, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'AutoDisconnect', 'Type': 'REG_DWORD'}}, 'EnableS4U2SelfForClaims': {'Policy': 'Microsoft network server: Attempt S4U2Self to obtain claim information', 'Settings': self.s4u2self_options.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'EnableS4U2SelfForClaims', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.s4u2self_options, 'value_lookup': False}, 'PutArgs': {'lookup': self.s4u2self_options, 'value_lookup': True}}}, 'Server_RequireSecuritySignature': {'Policy': 'Microsoft network server: Digitally sign communications (always)', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'RequireSecuritySignature', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'Server_EnableSecuritySignature': {'Policy': 'Microsoft network server: Digitally sign communications (if client agrees)', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'EnableSecuritySignature', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'EnableForcedLogoff': {'Policy': 'Microsoft network server: Disconnect clients when logon hours expire', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'EnableForcedLogoff', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'SmbServerNameHardeningLevel': {'Policy': 'Microsoft network server: Server SPN target name validation level', 'Settings': self.smb_server_name_hardening_levels.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'SmbServerNameHardeningLevel', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.smb_server_name_hardening_levels, 'value_lookup': False}, 'PutArgs': {'lookup': self.smb_server_name_hardening_levels, 'value_lookup': True}}}, 'FullPrivilegeAuditing': {'Policy': 'Audit: Audit the use of Backup and Restore privilege', 'Settings': [chr(0), chr(1)], 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'FullPrivilegeAuditing', 'Type': 'REG_BINARY'}, 'Transform': {'Get': '_binary_enable_zero_disable_one_conversion', 'Put': '_binary_enable_zero_disable_one_reverse_conversion'}}, 'CrashOnAuditFail': {'Policy': 'Audit: Shut down system immediately if unable to log security audits', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'CrashOnAuditFail', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'UndockWithoutLogon': {'Policy': 'Devices: Allow undock without having to log on', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'UndockWithoutLogon', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'AddPrinterDrivers': {'Policy': 'Devices: Prevent users from installing printer drivers', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\Print\\\\Providers\\\\LanMan Print Services\\\\Servers', 'Value': 'AddPrinterDrivers', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'AllocateDASD': {'Policy': 'Devices: Allowed to format and eject removable media', 'Settings': ['9999', '0', '1', '2'], 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon', 'Value': 'AllocateDASD', 'Type': 'REG_SZ'}, 'Transform': {'Get': '_dasd_conversion', 'Put': '_dasd_reverse_conversion'}}, 'AllocateCDRoms': {'Policy': 'Devices: Restrict CD-ROM access to locally logged-on user only', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon', 'Value': 'AllocateCDRoms', 'Type': 'REG_SZ'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'AllocateFloppies': {'Policy': 'Devices: Restrict floppy access to locally logged-on user only', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon', 'Value': 'AllocateFloppies', 'Type': 'REG_SZ'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'DriverSigningPolicy': {'Policy': 'Devices: Unsigned driver installation behavior', 'Settings': ['3,0', '3,' + chr(1), '3,' + chr(2)], 'lgpo_section': self.security_options_gpedit_path, 'Secedit': {'Option': 'MACHINE\\\\Software\\\\Microsoft\\\\Driver Signing\\\\Policy', 'Section': 'Registry Values'}, 'Transform': {'Get': '_driver_signing_reg_conversion', 'Put': '_driver_signing_reg_reverse_conversion'}}, 'SubmitControl': {'Policy': 'Domain controller: Allow server operators to schedule tasks', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'SubmitControl', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'VulnerableChannelAllowList': {'Policy': 'Domain controller: Allow vulnerable Netlogon secure channel connections', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'VulnerableChannelAllowList', 'Type': 'REG_SZ'}, 'Transform': {'Put': '_string_put_transform'}}, 'LdapEnforceChannelBinding': {'Policy': 'Domain controller: LDAP server channel binding token requirements', 'Settings': self.ldap_server_binding_token_requirements.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\NTDS\\\\Parameters', 'Value': 'LdapEnforceChannelBinding', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.ldap_server_binding_token_requirements, 'value_lookup': False}, 'PutArgs': {'lookup': self.ldap_server_binding_token_requirements, 'value_lookup': True}}}, 'LDAPServerIntegrity': {'Policy': 'Domain controller: LDAP server signing requirements', 'Settings': self.ldap_server_signing_requirements.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\NTDS\\\\Parameters', 'Value': 'LDAPServerIntegrity', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.ldap_server_signing_requirements, 'value_lookup': False}, 'PutArgs': {'lookup': self.ldap_server_signing_requirements, 'value_lookup': True}}}, 'RefusePasswordChange': {'Policy': 'Domain controller: Refuse machine account password changes', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'RefusePasswordChange', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'RequireSignOrSeal': {'Policy': 'Domain member: Digitally encrypt or sign secure channel data (always)', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'RequireSignOrSeal', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'SealSecureChannel': {'Policy': 'Domain member: Digitally encrypt secure channel data (when possible)', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'SealSecureChannel', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'SignSecureChannel': {'Policy': 'Domain member: Digitally sign secure channel data (when possible)', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'SignSecureChannel', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'DisablePasswordChange': {'Policy': 'Domain member: Disable machine account password changes', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'DisablePasswordChange', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'MaximumPasswordAge': {'Policy': 'Domain member: Maximum machine account password age', 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 999}}, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'MaximumPasswordAge', 'Type': 'REG_DWORD'}}, 'RequireStrongKey': {'Policy': 'Domain member: Require strong (Windows 2000 or later) session key', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'RequireStrongKey', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'LockoutDuration': {'Policy': 'Account lockout duration', 'lgpo_section': self.account_lockout_policy_gpedit_path, 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 6000000, 'zero_value': 4294967295}}, 'NetUserModal': {'Modal': 3, 'Option': 'lockout_duration'}, 'Transform': {'Get': '_seconds_to_minutes', 'Put': '_minutes_to_seconds', 'GetArgs': {'zero_value': 4294967295}, 'PutArgs': {'zero_value': 4294967295}}}, 'LockoutThreshold': {'Policy': 'Account lockout threshold', 'lgpo_section': self.account_lockout_policy_gpedit_path, 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 1000}}, 'NetUserModal': {'Modal': 3, 'Option': 'lockout_threshold'}}, 'LockoutWindow': {'Policy': 'Reset account lockout counter after', 'lgpo_section': self.account_lockout_policy_gpedit_path, 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 6000000}}, 'NetUserModal': {'Modal': 3, 'Option': 'lockout_observation_window'}, 'Transform': {'Get': '_seconds_to_minutes', 'Put': '_minutes_to_seconds'}}, 'AuditAccountLogon': {'Policy': 'Audit account logon events', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditAccountLogon', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditAccountManage': {'Policy': 'Audit account management', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditAccountManage', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditDSAccess': {'Policy': 'Audit directory service access', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditDSAccess', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditLogonEvents': {'Policy': 'Audit logon events', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditLogonEvents', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditObjectAccess': {'Policy': 'Audit object access', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditObjectAccess', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditPolicyChange': {'Policy': 'Audit policy change', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditPolicyChange', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditPrivilegeUse': {'Policy': 'Audit privilege use', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditPrivilegeUse', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditProcessTracking': {'Policy': 'Audit process tracking', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditProcessTracking', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditSystemEvents': {'Policy': 'Audit system events', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditSystemEvents', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditCredentialValidation': {'Policy': 'Audit Credential Validation', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Credential Validation'}, 'Transform': self.advanced_audit_transform}, 'AuditKerberosAuthenticationService': {'Policy': 'Audit Kerberos Authentication Service', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Kerberos Authentication Service'}, 'Transform': self.advanced_audit_transform}, 'AuditKerberosServiceTicketOperations': {'Policy': 'Audit Kerberos Service Ticket Operations', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Kerberos Service Ticket Operations'}, 'Transform': self.advanced_audit_transform}, 'AuditOtherAccountLogonEvents': {'Policy': 'Audit Other Account Logon Events', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Other Account Logon Events'}, 'Transform': self.advanced_audit_transform}, 'AuditApplicationGroupManagement': {'Policy': 'Audit Application Group Management', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Application Group Management'}, 'Transform': self.advanced_audit_transform}, 'AuditComputerAccountManagement': {'Policy': 'Audit Computer Account Management', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Computer Account Management'}, 'Transform': self.advanced_audit_transform}, 'AuditDistributionGroupManagement': {'Policy': 'Audit Distribution Group Management', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Distribution Group Management'}, 'Transform': self.advanced_audit_transform}, 'AuditOtherAccountManagementEvents': {'Policy': 'Audit Other Account Management Events', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Other Account Management Events'}, 'Transform': self.advanced_audit_transform}, 'AuditSecurityGroupManagement': {'Policy': 'Audit Security Group Management', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Security Group Management'}, 'Transform': self.advanced_audit_transform}, 'AuditUserAccountManagement': {'Policy': 'Audit User Account Management', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit User Account Management'}, 'Transform': self.advanced_audit_transform}, 'AuditDPAPIActivity': {'Policy': 'Audit DPAPI Activity', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit DPAPI Activity'}, 'Transform': self.advanced_audit_transform}, 'AuditPNPActivity': {'Policy': 'Audit PNP Activity', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit PNP Activity'}, 'Transform': self.advanced_audit_transform}, 'AuditProcessCreation': {'Policy': 'Audit Process Creation', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Process Creation'}, 'Transform': self.advanced_audit_transform}, 'AuditProcessTermination': {'Policy': 'Audit Process Termination', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Process Termination'}, 'Transform': self.advanced_audit_transform}, 'AuditRPCEvents': {'Policy': 'Audit RPC Events', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit RPC Events'}, 'Transform': self.advanced_audit_transform}, 'AuditTokenRightAdjusted': {'Policy': 'Audit Token Right Adjusted', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Token Right Adjusted'}, 'Transform': self.advanced_audit_transform}, 'AuditDetailedDirectoryServiceReplication': {'Policy': 'Audit Detailed Directory Service Replication', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Detailed Directory Service Replication'}, 'Transform': self.advanced_audit_transform}, 'AuditDirectoryServiceAccess': {'Policy': 'Audit Directory Service Access', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Directory Service Access'}, 'Transform': self.advanced_audit_transform}, 'AuditDirectoryServiceChanges': {'Policy': 'Audit Directory Service Changes', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Directory Service Changes'}, 'Transform': self.advanced_audit_transform}, 'AuditDirectoryServiceReplication': {'Policy': 'Audit Directory Service Replication', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Directory Service Replication'}, 'Transform': self.advanced_audit_transform}, 'AuditAccountLockout': {'Policy': 'Audit Account Lockout', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Account Lockout'}, 'Transform': self.advanced_audit_transform}, 'AuditUserDeviceClaims': {'Policy': 'Audit User / Device Claims', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit User / Device Claims'}, 'Transform': self.advanced_audit_transform}, 'AuditGroupMembership': {'Policy': 'Audit Group Membership', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Group Membership'}, 'Transform': self.advanced_audit_transform}, 'AuditIPsecExtendedMode': {'Policy': 'Audit IPsec Extended Mode', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit IPsec Extended Mode'}, 'Transform': self.advanced_audit_transform}, 'AuditIPsecMainMode': {'Policy': 'Audit IPsec Main Mode', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit IPsec Main Mode'}, 'Transform': self.advanced_audit_transform}, 'AuditIPsecQuickMode': {'Policy': 'Audit IPsec Quick Mode', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit IPsec Quick Mode'}, 'Transform': self.advanced_audit_transform}, 'AuditLogoff': {'Policy': 'Audit Logoff', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Logoff'}, 'Transform': self.advanced_audit_transform}, 'AuditLogon': {'Policy': 'Audit Logon', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Logon'}, 'Transform': self.advanced_audit_transform}, 'AuditNetworkPolicyServer': {'Policy': 'Audit Network Policy Server', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Network Policy Server'}, 'Transform': self.advanced_audit_transform}, 'AuditOtherLogonLogoffEvents': {'Policy': 'Audit Other Logon/Logoff Events', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Other Logon/Logoff Events'}, 'Transform': self.advanced_audit_transform}, 'AuditSpecialLogon': {'Policy': 'Audit Special Logon', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Special Logon'}, 'Transform': self.advanced_audit_transform}, 'AuditApplicationGenerated': {'Policy': 'Audit Application Generated', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Application Generated'}, 'Transform': self.advanced_audit_transform}, 'AuditCertificationServices': {'Policy': 'Audit Certification Services', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Certification Services'}, 'Transform': self.advanced_audit_transform}, 'AuditDetailedFileShare': {'Policy': 'Audit Detailed File Share', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Detailed File Share'}, 'Transform': self.advanced_audit_transform}, 'AuditFileShare': {'Policy': 'Audit File Share', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit File Share'}, 'Transform': self.advanced_audit_transform}, 'AuditFileSystem': {'Policy': 'Audit File System', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit File System'}, 'Transform': self.advanced_audit_transform}, 'AuditFilteringPlatformConnection': {'Policy': 'Audit Filtering Platform Connection', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Filtering Platform Connection'}, 'Transform': self.advanced_audit_transform}, 'AuditFilteringPlatformPacketDrop': {'Policy': 'Audit Filtering Platform Packet Drop', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Filtering Platform Packet Drop'}, 'Transform': self.advanced_audit_transform}, 'AuditHandleManipulation': {'Policy': 'Audit Handle Manipulation', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Handle Manipulation'}, 'Transform': self.advanced_audit_transform}, 'AuditKernelObject': {'Policy': 'Audit Kernel Object', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Kernel Object'}, 'Transform': self.advanced_audit_transform}, 'AuditOtherObjectAccessEvents': {'Policy': 'Audit Other Object Access Events', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Other Object Access Events'}, 'Transform': self.advanced_audit_transform}, 'AuditRegistry': {'Policy': 'Audit Registry', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Registry'}, 'Transform': self.advanced_audit_transform}, 'AuditRemovableStorage': {'Policy': 'Audit Removable Storage', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Removable Storage'}, 'Transform': self.advanced_audit_transform}, 'AuditSAM': {'Policy': 'Audit SAM', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit SAM'}, 'Transform': self.advanced_audit_transform}, 'AuditCentralAccessPolicyStaging': {'Policy': 'Audit Central Access Policy Staging', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Central Access Policy Staging'}, 'Transform': self.advanced_audit_transform}, 'AuditAuditPolicyChange': {'Policy': 'Audit Audit Policy Change', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Audit Policy Change'}, 'Transform': self.advanced_audit_transform}, 'AuditAuthenticationPolicyChange': {'Policy': 'Audit Authentication Policy Change', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Authentication Policy Change'}, 'Transform': self.advanced_audit_transform}, 'AuditAuthorizationPolicyChange': {'Policy': 'Audit Authorization Policy Change', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Authorization Policy Change'}, 'Transform': self.advanced_audit_transform}, 'AuditFilteringPlatformPolicyChange': {'Policy': 'Audit Filtering Platform Policy Change', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Filtering Platform Policy Change'}, 'Transform': self.advanced_audit_transform}, 'AuditMPSSVCRuleLevelPolicyChange': {'Policy': 'Audit MPSSVC Rule-Level Policy Change', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit MPSSVC Rule-Level Policy Change'}, 'Transform': self.advanced_audit_transform}, 'AuditOtherPolicyChangeEvents': {'Policy': 'Audit Other Policy Change Events', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Other Policy Change Events'}, 'Transform': self.advanced_audit_transform}, 'AuditNonSensitivePrivilegeUse': {'Policy': 'Audit Non Sensitive Privilege Use', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Non Sensitive Privilege Use'}, 'Transform': self.advanced_audit_transform}, 'AuditOtherPrivilegeUseEvents': {'Policy': 'Audit Other Privilege Use Events', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Other Privilege Use Events'}, 'Transform': self.advanced_audit_transform}, 'AuditSensitivePrivilegeUse': {'Policy': 'Audit Sensitive Privilege Use', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Sensitive Privilege Use'}, 'Transform': self.advanced_audit_transform}, 'AuditIPsecDriver': {'Policy': 'Audit IPsec Driver', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit IPsec Driver'}, 'Transform': self.advanced_audit_transform}, 'AuditOtherSystemEvents': {'Policy': 'Audit Other System Events', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Other System Events'}, 'Transform': self.advanced_audit_transform}, 'AuditSecurityStateChange': {'Policy': 'Audit Security State Change', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Security State Change'}, 'Transform': self.advanced_audit_transform}, 'AuditSecuritySystemExtension': {'Policy': 'Audit Security System Extension', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Security System Extension'}, 'Transform': self.advanced_audit_transform}, 'AuditSystemIntegrity': {'Policy': 'Audit System Integrity', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit System Integrity'}, 'Transform': self.advanced_audit_transform}, 'SeTrustedCredManAccessPrivilege': {'Policy': 'Access Credential Manager as a trusted caller', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeTrustedCredManAccessPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeNetworkLogonRight': {'Policy': 'Access this computer from the network', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeNetworkLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeTcbPrivilege': {'Policy': 'Act as part of the operating system', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeTcbPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeMachineAccountPrivilege': {'Policy': 'Add workstations to domain', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeMachineAccountPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeIncreaseQuotaPrivilege': {'Policy': 'Adjust memory quotas for a process', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeIncreaseQuotaPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeInteractiveLogonRight': {'Policy': 'Allow log on locally', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeInteractiveLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeRemoteInteractiveLogonRight': {'Policy': 'Allow log on through Remote Desktop Services', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeRemoteInteractiveLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeBackupPrivilege': {'Policy': 'Backup files and directories', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeBackupPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeChangeNotifyPrivilege': {'Policy': 'Bypass traverse checking', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeChangeNotifyPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeSystemtimePrivilege': {'Policy': 'Change the system time', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeSystemtimePrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeTimeZonePrivilege': {'Policy': 'Change the time zone', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeTimeZonePrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeCreatePagefilePrivilege': {'Policy': 'Create a pagefile', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeCreatePagefilePrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeCreateTokenPrivilege': {'Policy': 'Create a token object', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeCreateTokenPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeCreateGlobalPrivilege': {'Policy': 'Create global objects', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeCreateGlobalPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeCreatePermanentPrivilege': {'Policy': 'Create permanent shared objects', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeCreatePermanentPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeCreateSymbolicLinkPrivilege': {'Policy': 'Create symbolic links', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeCreateSymbolicLinkPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeDebugPrivilege': {'Policy': 'Debug programs', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeDebugPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeDenyNetworkLogonRight': {'Policy': 'Deny access to this computer from the network', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeDenyNetworkLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeDenyBatchLogonRight': {'Policy': 'Deny log on as a batch job', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeDenyBatchLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeDenyServiceLogonRight': {'Policy': 'Deny log on as a service', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeDenyServiceLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeDenyInteractiveLogonRight': {'Policy': 'Deny log on locally', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeDenyInteractiveLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeDenyRemoteInteractiveLogonRight': {'Policy': 'Deny log on through Remote Desktop Services', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeDenyRemoteInteractiveLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeEnableDelegationPrivilege': {'Policy': 'Enable computer and user accounts to be trusted for delegation', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeEnableDelegationPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeRemoteShutdownPrivilege': {'Policy': 'Force shutdown from a remote system', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeRemoteShutdownPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeAuditPrivilege': {'Policy': 'Generate security audits', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeAuditPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeImpersonatePrivilege': {'Policy': 'Impersonate a client after authentication', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeImpersonatePrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeIncreaseWorkingSetPrivilege': {'Policy': 'Increase a process working set', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeIncreaseWorkingSetPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeIncreaseBasePriorityPrivilege': {'Policy': 'Increase scheduling priority', 'rights_assignment': True, 'lgpo_section': self.user_rights_assignment_gpedit_path, 'Settings': None, 'LsaRights': {'Option': 'SeIncreaseBasePriorityPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeLoadDriverPrivilege': {'Policy': 'Load and unload device drivers', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeLoadDriverPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeLockMemoryPrivilege': {'Policy': 'Lock pages in memory', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeLockMemoryPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeBatchLogonRight': {'Policy': 'Log on as a batch job', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeBatchLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeServiceLogonRight': {'Policy': 'Log on as a service', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeServiceLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeSecurityPrivilege': {'Policy': 'Manage auditing and security log', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeSecurityPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeRelabelPrivilege': {'Policy': 'Modify an object label', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeRelabelPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeSystemEnvironmentPrivilege': {'Policy': 'Modify firmware environment values', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeSystemEnvironmentPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeManageVolumePrivilege': {'Policy': 'Perform volume maintenance tasks', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeManageVolumePrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeProfileSingleProcessPrivilege': {'Policy': 'Profile single process', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeProfileSingleProcessPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeSystemProfilePrivilege': {'Policy': 'Profile system performance', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeSystemProfilePrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeUndockPrivilege': {'Policy': 'Remove computer from docking station', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeUndockPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeAssignPrimaryTokenPrivilege': {'Policy': 'Replace a process level token', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeAssignPrimaryTokenPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeRestorePrivilege': {'Policy': 'Restore files and directories', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeRestorePrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeShutdownPrivilege': {'Policy': 'Shut down the system', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeShutdownPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeSyncAgentPrivilege': {'Policy': 'Synchronize directory service data', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeSyncAgentPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeTakeOwnershipPrivilege': {'Policy': 'Take ownership of files or other objects', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeTakeOwnershipPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'RecoveryConsoleSecurityLevel': {'Policy': 'Recovery console: Allow automatic administrative logon', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Setup\\\\RecoveryConsole', 'Value': 'SecurityLevel', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'RecoveryConsoleSetCommand': {'Policy': 'Recovery console: Allow floppy copy and access to all drives and all folders', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Setup\\\\RecoveryConsole', 'Value': 'SetCommand', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'ForceKeyProtection': {'Policy': 'System Cryptography: Force strong key protection for user keys stored on the computer', 'Settings': self.force_key_protection.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Policies\\\\Microsoft\\\\Cryptography', 'Value': 'ForceKeyProtection', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.force_key_protection, 'value_lookup': False}, 'PutArgs': {'lookup': self.force_key_protection, 'value_lookup': True}}}, 'FIPSAlgorithmPolicy': {'Policy': 'System Cryptography: Use FIPS compliant algorithms for encryption, hashing, and signing', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\FIPSAlgorithmPolicy', 'Value': 'Enabled', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'MachineAccessRestriction': {'Policy': 'DCOM: Machine Access Restrictions in Security Descriptor Definition Language (SDDL) syntax', 'Settings': None, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Policies\\\\Microsoft\\\\Windows NT\\\\DCOM', 'Value': 'MachineAccessRestriction', 'Type': 'REG_SZ'}, 'Transform': {'Put': '_string_put_transform'}}, 'MachineLaunchRestriction': {'Policy': 'DCOM: Machine Launch Restrictions in Security Descriptor Definition Language (SDDL) syntax', 'Settings': None, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Policies\\\\Microsoft\\\\Windows NT\\\\DCOM', 'Value': 'MachineLaunchRestriction', 'Type': 'REG_SZ'}, 'Transform': {'Put': '_string_put_transform'}}, 'UseMachineId': {'Policy': 'Network security: Allow Local System to use computer identity for NTLM', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'UseMachineId', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'allownullsessionfallback': {'Policy': 'Network security: Allow LocalSystem NULL session fallback', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\MSV1_0', 'Value': 'allownullsessionfallback', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'AllowOnlineID': {'Policy': 'Network security: Allow PKU2U authentication requests to this computer to use online identities.', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\pku2u', 'Value': 'AllowOnlineID', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'KrbSupportedEncryptionTypes': {'Policy': 'Network security: Configure encryption types allowed for Kerberos', 'Settings': None, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\policies\\\\system\\\\Kerberos\\\\Parameters', 'Value': 'SupportedEncryptionTypes', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup_bitwise_add', 'Put': '_dict_lookup_bitwise_add', 'GetArgs': {'lookup': self.krb_encryption_types, 'value_lookup': False}, 'PutArgs': {'lookup': self.krb_encryption_types, 'value_lookup': True}}}, 'NoLMHash': {'Policy': 'Network security: Do not store LAN Manager hash value on next password change', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'NoLMHash', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'ForceLogoffWhenHourExpire': {'Policy': 'Network security: Force logoff when logon hours expire', 'lgpo_section': self.security_options_gpedit_path, 'Settings': self.enabled_one_disabled_zero_no_not_defined.keys(), 'Secedit': {'Option': 'ForceLogoffWhenHourExpire', 'Section': 'System Access'}, 'Transform': self.enabled_one_disabled_zero_no_not_defined_transform}, 'LmCompatibilityLevel': {'Policy': 'Network security: LAN Manager authentication level', 'Settings': self.lm_compat_levels.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'LmCompatibilityLevel', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.lm_compat_levels, 'value_lookup': False}, 'PutArgs': {'lookup': self.lm_compat_levels, 'value_lookup': True}}}, 'LDAPClientIntegrity': {'Policy': 'Network security: LDAP client signing requirements', 'Settings': self.ldap_signing_reqs.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\ldap', 'Value': 'LDAPClientIntegrity', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.ldap_signing_reqs, 'value_lookup': False}, 'PutArgs': {'lookup': self.ldap_signing_reqs, 'value_lookup': True}}}, 'NTLMMinClientSec': {'Policy': 'Network security: Minimum session security for NTLM SSP based (including secure RPC) clients', 'Settings': None, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\MSV1_0', 'Value': 'NTLMMinClientSec', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup_bitwise_add', 'Put': '_dict_lookup_bitwise_add', 'GetArgs': {'lookup': self.ntlm_session_security_levels, 'value_lookup': False}, 'PutArgs': {'lookup': self.ntlm_session_security_levels, 'value_lookup': True}}}, 'NTLMMinServerSec': {'Policy': 'Network security: Minimum session security for NTLM SSP based (including secure RPC) servers', 'Settings': None, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\MSV1_0', 'Value': 'NTLMMinServerSec', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup_bitwise_add', 'Put': '_dict_lookup_bitwise_add', 'GetArgs': {'lookup': self.ntlm_session_security_levels, 'value_lookup': False}, 'PutArgs': {'lookup': self.ntlm_session_security_levels, 'value_lookup': True}}}, 'ClientAllowedNTLMServers': {'Policy': 'Network security: Restrict NTLM: Add remote server exceptions for NTLM authentication', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\MSV1_0', 'Value': 'ClientAllowedNTLMServers', 'Type': 'REG_MULTI_SZ'}, 'Transform': {'Put': '_multi_string_put_transform', 'Get': '_multi_string_get_transform'}}, 'DCAllowedNTLMServers': {'Policy': 'Network security: Restrict NTLM: Add server exceptions in this domain', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'DCAllowedNTLMServers', 'Type': 'REG_MULTI_SZ'}, 'Transform': {'Put': '_multi_string_put_transform', 'Get': '_multi_string_get_transform'}}, 'AuditReceivingNTLMTraffic': {'Policy': 'Network security: Restrict NTLM: Audit Incoming NTLM Traffic', 'Settings': self.ntlm_audit_settings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\LSA\\\\MSV1_0', 'Value': 'AuditReceivingNTLMTraffic', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.ntlm_audit_settings, 'value_lookup': False}, 'PutArgs': {'lookup': self.ntlm_audit_settings, 'value_lookup': True}}}, 'AuditNTLMInDomain': {'Policy': 'Network security: Restrict NTLM: Audit NTLM authentication in this domain', 'Settings': self.ntlm_domain_audit_settings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'AuditNTLMInDomain', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.ntlm_domain_audit_settings, 'value_lookup': False}, 'PutArgs': {'lookup': self.ntlm_domain_audit_settings, 'value_lookup': True}}}, 'RestrictReceivingNTLMTraffic': {'Policy': 'Network security: Restrict NTLM: Incoming NTLM traffic', 'Settings': self.incoming_ntlm_settings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\LSA\\\\MSV1_0', 'Value': 'RestrictReceivingNTLMTraffic', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.incoming_ntlm_settings, 'value_lookup': False}, 'PutArgs': {'lookup': self.incoming_ntlm_settings, 'value_lookup': True}}}, 'RestrictNTLMInDomain': {'Policy': 'Network security: Restrict NTLM: NTLM authentication in this domain', 'Settings': self.ntlm_domain_auth_settings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'RestrictNTLMInDomain', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.ntlm_domain_auth_settings, 'value_lookup': False}, 'PutArgs': {'lookup': self.ntlm_domain_auth_settings, 'value_lookup': True}}}, 'RestrictSendingNTLMTraffic': {'Policy': 'Network security: Restrict NTLM: Outgoing NTLM traffic to remote servers', 'Settings': self.outgoing_ntlm_settings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\MSV1_0', 'Value': 'RestrictSendingNTLMTraffic', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.outgoing_ntlm_settings, 'value_lookup': False}, 'PutArgs': {'lookup': self.outgoing_ntlm_settings, 'value_lookup': True}}}, 'ShutdownWithoutLogon': {'Policy': 'Shutdown: Allow system to be shut down without having to log on', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\policies\\\\system', 'Value': 'ShutdownWithoutLogon', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'ClearPageFileAtShutdown': {'Policy': 'Shutdown: Clear virtual memory pagefile', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\SESSION MANAGER\\\\MEMORY MANAGEMENT', 'Value': 'ClearPageFileAtShutdown', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'ObCaseInsensitive': {'Policy': 'System objects: Require case insensitivity for non-Windows subsystems', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\SESSION MANAGER\\\\Kernel', 'Value': 'ObCaseInsensitive', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'ProtectionMode': {'Policy': 'System objects: Strengthen default permissions of internal system objects (e.g. Symbolic Links)', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\SESSION MANAGER', 'Value': 'ProtectionMode', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'OptionalSubsystems': {'Policy': 'System settings: Optional subsystems', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\SESSION MANAGER\\\\SubSystems', 'Value': 'optional', 'Type': 'REG_MULTI_SZ'}, 'Transform': {'Put': '_multi_string_put_transform', 'Get': '_multi_string_get_transform'}}, 'AuthenticodeEnabled': {'Policy': 'System settings: Use Certificate Rules on Windows Executables for Software Restriction Policies', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Policies\\\\Microsoft\\\\Windows\\\\safer\\\\codeidentifiers', 'Value': 'AuthenticodeEnabled', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}}}, 'User': {'lgpo_section': 'User Configuration', 'policies': {}}}",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.audit_lookup = {0: 'No auditing', 1: 'Success', 2: 'Failure', 3: 'Success, Failure', 'Not Defined': 'Not Defined', None: 'Not Defined'}\n    self.advanced_audit_lookup = {0: 'No Auditing', 1: 'Success', 2: 'Failure', 3: 'Success and Failure', None: 'Not Configured'}\n    self.sc_removal_lookup = {'0': 'No Action', '1': 'Lock Workstation', '2': 'Force Logoff', '3': 'Disconnect if a Remote Desktop Services session', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.uac_admin_prompt_lookup = {0: 'Elevate without prompting', 1: 'Prompt for credentials on the secure desktop', 2: 'Prompt for consent on the secure desktop', 3: 'Prompt for credentials', 4: 'Prompt for consent', 5: 'Prompt for consent for non-Windows binaries', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.uac_user_prompt_lookup = {0: 'Automatically deny elevation requests', 1: 'Prompt for credentials on the secure desktop', 3: 'Prompt for credentials', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.enabled_one_disabled_zero = {0: 'Disabled', 1: 'Enabled', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.enabled_one_disabled_zero_transform = {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.enabled_one_disabled_zero, 'value_lookup': False}, 'PutArgs': {'lookup': self.enabled_one_disabled_zero, 'value_lookup': True}}\n    self.s4u2self_options = {0: 'Default', 1: 'Enabled', 2: 'Disabled', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.audit_transform = {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.audit_lookup, 'value_lookup': False}, 'PutArgs': {'lookup': self.audit_lookup, 'value_lookup': True}}\n    self.advanced_audit_transform = {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.advanced_audit_lookup, 'value_lookup': False}, 'PutArgs': {'lookup': self.advanced_audit_lookup, 'value_lookup': True}}\n    self.enabled_one_disabled_zero_strings = {'0': 'Disabled', '1': 'Enabled', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.enabled_one_disabled_zero_strings_transform = {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.enabled_one_disabled_zero_strings, 'value_lookup': False}, 'PutArgs': {'lookup': self.enabled_one_disabled_zero_strings, 'value_lookup': True}}\n    self.security_options_gpedit_path = ['Computer Configuration', 'Windows Settings', 'Security Settings', 'Local Policies', 'Security Options']\n    self.windows_firewall_gpedit_path = ['Computer Configuration', 'Windows Settings', 'Security Settings', 'Windows Firewall with Advanced Security', 'Windows Firewall with Advanced Security - Local Group Policy Object']\n    self.password_policy_gpedit_path = ['Computer Configuration', 'Windows Settings', 'Security Settings', 'Account Policies', 'Password Policy']\n    self.audit_policy_gpedit_path = ['Computer Configuration', 'Windows Settings', 'Security Settings', 'Local Policies', 'Audit Policy']\n    self.advanced_audit_policy_gpedit_path = ['Computer Configuration', 'Windows Settings', 'Security Settings', 'Advanced Audit Policy Configuration', 'System Audit Policies - Local Group Policy Object']\n    self.account_lockout_policy_gpedit_path = ['Computer Configuration', 'Windows Settings', 'Security Settings', 'Account Policies', 'Account Lockout Policy']\n    self.user_rights_assignment_gpedit_path = ['Computer Configuration', 'Windows Settings', 'Security Settings', 'Local Policies', 'User Rights Assignment']\n    self.block_ms_accounts = {0: 'This policy is disabled', 1: \"Users can't add Microsoft accounts\", 3: \"Users can't add or log on with Microsoft accounts\", None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.ldap_server_binding_token_requirements = {0: 'Never', 1: 'When supported', 2: 'Always', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.ldap_server_signing_requirements = {1: 'None', 2: 'Require signing', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.smb_server_name_hardening_levels = {0: 'Off', 1: 'Accept if provided by client', 2: 'Required from client', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.locked_session_user_info = {1: 'User display name, domain and user names', 2: 'User display name only', 3: 'Do not display user information', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.force_guest = {0: 'Classic - local users authenticate as themselves', 1: 'Guest only - local users authenticate as Guest', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.force_key_protection = {0: 'User input is not required when new keys are stored and used', 1: 'User is prompted when the key is first used', 2: 'User must enter a password each time they use a key', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.firewall_inbound_connections = {'blockinbound': 'Block (default)', 'blockinboundalways': 'Block all connections', 'allowinbound': 'Allow', 'notconfigured': 'Not configured'}\n    self.firewall_outbound_connections = {'blockoutbound': 'Block', 'allowoutbound': 'Allow (default)', 'notconfigured': 'Not configured'}\n    self.firewall_rule_merging = {'enable': 'Yes (default)', 'disable': 'No', 'notconfigured': 'Not configured'}\n    self.firewall_log_packets_connections = {'enable': 'Yes', 'disable': 'No (default)', 'notconfigured': 'Not configured'}\n    self.firewall_notification = {'enable': 'Yes', 'disable': 'No', 'notconfigured': 'Not configured'}\n    self.firewall_state = {'on': 'On (recommended)', 'off': 'Off', 'notconfigured': 'Not configured'}\n    self.krb_encryption_types = {0: 'No minimum', 1: 'DES_CBC_CRC', 2: 'DES_CBD_MD5', 4: 'RC4_HMAC_MD5', 8: 'AES128_HMAC_SHA1', 16: 'AES256_HMAC_SHA1', 2147483616: 'Future Encryption Types', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.lm_compat_levels = {0: 'Send LM & NTLM response', 1: 'Send LM & NTLM - use NTLMv2 session security if negotiated', 2: 'Send NTLM response only', 3: 'Send NTLMv2 response only', 4: 'Send NTLMv2 response only. Refuse LM', 5: 'Send NTLMv2 response only. Refuse LM & NTLM', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.ldap_signing_reqs = {0: 'None', 1: 'Negotiate signing', 2: 'Require signing', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.ntlm_session_security_levels = {0: 'No minimum', 524288: 'Require NTLMv2 session security', 536870912: 'Require 128-bit encryption', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.ntlm_audit_settings = {0: 'Disable', 1: 'Enable auditing for domain accounts', 2: 'Enable auditing for all accounts', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.ntlm_domain_audit_settings = {0: 'Disable', 1: 'Enable for domain accounts to domain servers', 3: 'Enable for domain accounts', 5: 'Enable for domain servers', 7: 'Enable all', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.incoming_ntlm_settings = {0: 'Allow all', 1: 'Deny all domain accounts', 2: 'Deny all accounts', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.ntlm_domain_auth_settings = {0: 'Disable', 1: 'Deny for domain accounts to domain servers', 3: 'Deny for domain accounts', 5: 'Deny for domain servers', 7: 'Deny all', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.outgoing_ntlm_settings = {0: 'Allow all', 1: 'Audit all', 2: 'Deny all', None: 'Not Defined', '(value not set)': 'Not Defined'}\n    self.enabled_one_disabled_zero_no_not_defined = {0: 'Disabled', 1: 'Enabled'}\n    self.enabled_one_disabled_zero_no_not_defined_transform = {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.enabled_one_disabled_zero_no_not_defined, 'value_lookup': False}, 'PutArgs': {'lookup': self.enabled_one_disabled_zero_no_not_defined, 'value_lookup': True}}\n    self.policies = {'Machine': {'lgpo_section': 'Computer Configuration', 'policies': {'StartupScripts': {'Policy': 'Startup Scripts', 'lgpo_section': ['Computer Configuration', 'Windows Settings', 'Scripts (Startup/Shutdown)', 'Startup'], 'ScriptIni': {'Section': 'Startup', 'IniPath': os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'Machine', 'Scripts', 'scripts.ini')}}, 'StartupPowershellScripts': {'Policy': 'Startup Powershell Scripts', 'lgpo_section': ['Computer Configuration', 'Windows Settings', 'Scripts (Startup/Shutdown)', 'Startup'], 'ScriptIni': {'Section': 'Startup', 'IniPath': os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'Machine', 'Scripts', 'psscripts.ini')}}, 'StartupPowershellScriptOrder': {'Policy': 'Startup - For this GPO, run scripts in the following order', 'lgpo_section': ['Computer Configuration', 'Windows Settings', 'Scripts (Startup/Shutdown)', 'Startup'], 'ScriptIni': {'IniPath': os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'Machine', 'Scripts', 'psscripts.ini'), 'Section': 'ScriptsConfig', 'SettingName': 'StartExecutePSFirst', 'Settings': ['true', 'false', None]}, 'Transform': {'Get': '_powershell_script_order_conversion', 'Put': '_powershell_script_order_reverse_conversion'}}, 'ShutdownScripts': {'Policy': 'Shutdown Scripts', 'lgpo_section': ['Computer Configuration', 'Windows Settings', 'Scripts (Startup/Shutdown)', 'Shutdown'], 'ScriptIni': {'Section': 'Shutdown', 'IniPath': os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'Machine', 'Scripts', 'scripts.ini')}}, 'ShutdownPowershellScripts': {'Policy': 'Shutdown Powershell Scripts', 'lgpo_section': ['Computer Configuration', 'Windows Settings', 'Scripts (Startup/Shutdown)', 'Shutdown'], 'ScriptIni': {'Section': 'Shutdown', 'IniPath': os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'Machine', 'Scripts', 'psscripts.ini')}}, 'ShutdownPowershellScriptOrder': {'Policy': 'Shutdown - For this GPO, run scripts in the following order', 'lgpo_section': ['Computer Configuration', 'Windows Settings', 'Scripts (Startup/Shutdown)', 'Shutdown'], 'ScriptIni': {'IniPath': os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'Machine', 'Scripts', 'psscripts.ini'), 'Section': 'ScriptsConfig', 'SettingName': 'EndExecutePSFirst', 'Settings': ['true', 'false', None]}, 'Transform': {'Get': '_powershell_script_order_conversion', 'Put': '_powershell_script_order_reverse_conversion'}}, 'LSAAnonymousNameLookup': {'Policy': 'Network access: Allow anonymous SID/Name translation', 'lgpo_section': self.password_policy_gpedit_path, 'Settings': self.enabled_one_disabled_zero_no_not_defined.keys(), 'Secedit': {'Option': 'LSAAnonymousNameLookup', 'Section': 'System Access'}, 'Transform': self.enabled_one_disabled_zero_no_not_defined_transform}, 'RestrictAnonymousSam': {'Policy': 'Network access: Do not allow anonymous enumeration of SAM accounts', 'lgpo_section': self.security_options_gpedit_path, 'Settings': self.enabled_one_disabled_zero.keys(), 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'RestrictAnonymousSam', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'RestrictRemoteSAM': {'Policy': 'Network access: Restrict clients allowed to make remote calls to SAM', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'RestrictRemoteSAM', 'Type': 'REG_SZ'}, 'Transform': {'Put': '_string_put_transform'}}, 'RestrictAnonymous': {'Policy': 'Network access: Do not allow anonymous enumeration of SAM accounts and shares', 'lgpo_section': self.security_options_gpedit_path, 'Settings': self.enabled_one_disabled_zero.keys(), 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'RestrictAnonymous', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'DisableDomainCreds': {'Policy': 'Network access: Do not allow storage of passwords and credentials for network authentication', 'lgpo_section': self.security_options_gpedit_path, 'Settings': self.enabled_one_disabled_zero.keys(), 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'DisableDomainCreds', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'EveryoneIncludesAnonymous': {'Policy': 'Network access: Let Everyone permissions apply to anonymous users', 'lgpo_section': self.security_options_gpedit_path, 'Settings': self.enabled_one_disabled_zero.keys(), 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'everyoneincludesanonymous', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'NullSessionPipes': {'Policy': 'Network access: Named Pipes that can be accessed anonymously', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'NullSessionPipes', 'Type': 'REG_MULTI_SZ'}, 'Transform': {'Put': '_multi_string_put_transform', 'Get': '_multi_string_get_transform'}}, 'RemoteRegistryExactPaths': {'Policy': 'Network access: Remotely accessible registry paths', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\SecurePipeServers\\\\winreg\\\\AllowedExactPaths', 'Value': 'Machine', 'Type': 'REG_MULTI_SZ'}, 'Transform': {'Put': '_multi_string_put_transform', 'Get': '_multi_string_get_transform'}}, 'RemoteRegistryPaths': {'Policy': 'Network access: Remotely accessible registry paths and sub-paths', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\SecurePipeServers\\\\winreg\\\\AllowedPaths', 'Value': 'Machine', 'Type': 'REG_MULTI_SZ'}, 'Transform': {'Put': '_multi_string_put_transform', 'Get': '_multi_string_get_transform'}}, 'RestrictNullSessAccess': {'Policy': 'Network access: Restrict anonymous access to Named Pipes and Shares', 'lgpo_section': self.security_options_gpedit_path, 'Settings': self.enabled_one_disabled_zero.keys(), 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'RestrictNullSessAccess', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'NullSessionShares': {'Policy': 'Network access: Shares that can be accessed anonymously', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'NullSessionShares', 'Type': 'REG_MULTI_SZ'}, 'Transform': {'Put': '_multi_string_put_transform', 'Get': '_multi_string_get_transform'}}, 'ForceGuest': {'Policy': 'Network access: Sharing and security model for local accounts', 'lgpo_section': self.security_options_gpedit_path, 'Settings': self.force_guest.keys(), 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'ForceGuest', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.force_guest, 'value_lookup': False}, 'PutArgs': {'lookup': self.force_guest, 'value_lookup': True}}}, 'WfwDomainState': {'Policy': 'Network firewall: Domain: State', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_state.keys(), 'NetSH': {'Profile': 'domain', 'Section': 'state', 'Option': 'State'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_state, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_state, 'value_lookup': True}}}, 'WfwPrivateState': {'Policy': 'Network firewall: Private: State', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_state.keys(), 'NetSH': {'Profile': 'private', 'Section': 'state', 'Option': 'State'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_state, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_state, 'value_lookup': True}}}, 'WfwPublicState': {'Policy': 'Network firewall: Public: State', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_state.keys(), 'NetSH': {'Profile': 'public', 'Section': 'state', 'Option': 'State'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_state, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_state, 'value_lookup': True}}}, 'WfwDomainInboundConnections': {'Policy': 'Network firewall: Domain: Inbound connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_inbound_connections.keys(), 'NetSH': {'Profile': 'domain', 'Section': 'firewallpolicy', 'Option': 'Inbound'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_inbound_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_inbound_connections, 'value_lookup': True}}}, 'WfwPrivateInboundConnections': {'Policy': 'Network firewall: Private: Inbound connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_inbound_connections.keys(), 'NetSH': {'Profile': 'private', 'Section': 'firewallpolicy', 'Option': 'Inbound'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_inbound_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_inbound_connections, 'value_lookup': True}}}, 'WfwPublicInboundConnections': {'Policy': 'Network firewall: Public: Inbound connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_inbound_connections.keys(), 'NetSH': {'Profile': 'public', 'Section': 'firewallpolicy', 'Option': 'Inbound'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_inbound_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_inbound_connections, 'value_lookup': True}}}, 'WfwDomainOutboundConnections': {'Policy': 'Network firewall: Domain: Outbound connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_outbound_connections.keys(), 'NetSH': {'Profile': 'domain', 'Section': 'firewallpolicy', 'Option': 'Outbound'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_outbound_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_outbound_connections, 'value_lookup': True}}}, 'WfwPrivateOutboundConnections': {'Policy': 'Network firewall: Private: Outbound connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_outbound_connections.keys(), 'NetSH': {'Profile': 'private', 'Section': 'firewallpolicy', 'Option': 'Outbound'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_outbound_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_outbound_connections, 'value_lookup': True}}}, 'WfwPublicOutboundConnections': {'Policy': 'Network firewall: Public: Outbound connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_outbound_connections.keys(), 'NetSH': {'Profile': 'public', 'Section': 'firewallpolicy', 'Option': 'Outbound'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_outbound_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_outbound_connections, 'value_lookup': True}}}, 'WfwDomainSettingsNotification': {'Policy': 'Network firewall: Domain: Settings: Display a notification', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_notification.keys(), 'NetSH': {'Profile': 'domain', 'Section': 'settings', 'Option': 'InboundUserNotification'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_notification, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_notification, 'value_lookup': True}}}, 'WfwPrivateSettingsNotification': {'Policy': 'Network firewall: Private: Settings: Display a notification', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_notification.keys(), 'NetSH': {'Profile': 'private', 'Section': 'settings', 'Option': 'InboundUserNotification'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_notification, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_notification, 'value_lookup': True}}}, 'WfwPublicSettingsNotification': {'Policy': 'Network firewall: Public: Settings: Display a notification', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_notification.keys(), 'NetSH': {'Profile': 'public', 'Section': 'settings', 'Option': 'InboundUserNotification'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_notification, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_notification, 'value_lookup': True}}}, 'WfwDomainSettingsLocalFirewallRules': {'Policy': 'Network firewall: Domain: Settings: Apply local firewall rules', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_rule_merging.keys(), 'NetSH': {'Profile': 'domain', 'Section': 'settings', 'Option': 'LocalFirewallRules'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': True}}}, 'WfwPrivateSettingsLocalFirewallRules': {'Policy': 'Network firewall: Private: Settings: Apply local firewall rules', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_rule_merging.keys(), 'NetSH': {'Profile': 'private', 'Section': 'settings', 'Option': 'LocalFirewallRules'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': True}}}, 'WfwPublicSettingsLocalFirewallRules': {'Policy': 'Network firewall: Public: Settings: Apply local firewall rules', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_rule_merging.keys(), 'NetSH': {'Profile': 'public', 'Section': 'settings', 'Option': 'LocalFirewallRules'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': True}}}, 'WfwDomainSettingsLocalConnectionRules': {'Policy': 'Network firewall: Domain: Settings: Apply local connection security rules', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_rule_merging.keys(), 'NetSH': {'Profile': 'domain', 'Section': 'settings', 'Option': 'LocalConSecRules'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': True}}}, 'WfwPrivateSettingsLocalConnectionRules': {'Policy': 'Network firewall: Private: Settings: Apply local connection security rules', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_rule_merging.keys(), 'NetSH': {'Profile': 'private', 'Section': 'settings', 'Option': 'LocalConSecRules'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': True}}}, 'WfwPublicSettingsLocalConnectionRules': {'Policy': 'Network firewall: Public: Settings: Apply local connection security rules', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_rule_merging.keys(), 'NetSH': {'Profile': 'public', 'Section': 'settings', 'Option': 'LocalConSecRules'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_rule_merging, 'value_lookup': True}}}, 'WfwDomainLoggingName': {'Policy': 'Network firewall: Domain: Logging: Name', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': None, 'NetSH': {'Profile': 'domain', 'Section': 'logging', 'Option': 'FileName'}}, 'WfwPrivateLoggingName': {'Policy': 'Network firewall: Private: Logging: Name', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': None, 'NetSH': {'Profile': 'private', 'Section': 'logging', 'Option': 'FileName'}}, 'WfwPublicLoggingName': {'Policy': 'Network firewall: Public: Logging: Name', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': None, 'NetSH': {'Profile': 'public', 'Section': 'logging', 'Option': 'FileName'}}, 'WfwDomainLoggingMaxFileSize': {'Policy': 'Network firewall: Domain: Logging: Size limit (KB)', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': None, 'NetSH': {'Profile': 'domain', 'Section': 'logging', 'Option': 'MaxFileSize'}}, 'WfwPrivateLoggingMaxFileSize': {'Policy': 'Network firewall: Private: Logging: Size limit (KB)', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': None, 'NetSH': {'Profile': 'private', 'Section': 'logging', 'Option': 'MaxFileSize'}}, 'WfwPublicLoggingMaxFileSize': {'Policy': 'Network firewall: Public: Logging: Size limit (KB)', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': None, 'NetSH': {'Profile': 'public', 'Section': 'logging', 'Option': 'MaxFileSize'}}, 'WfwDomainLoggingAllowedConnections': {'Policy': 'Network firewall: Domain: Logging: Log successful connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_log_packets_connections.keys(), 'NetSH': {'Profile': 'domain', 'Section': 'logging', 'Option': 'LogAllowedConnections'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': True}}}, 'WfwPrivateLoggingAllowedConnections': {'Policy': 'Network firewall: Private: Logging: Log successful connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_log_packets_connections.keys(), 'NetSH': {'Profile': 'private', 'Section': 'logging', 'Option': 'LogAllowedConnections'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': True}}}, 'WfwPublicLoggingAllowedConnections': {'Policy': 'Network firewall: Public: Logging: Log successful connections', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_log_packets_connections.keys(), 'NetSH': {'Profile': 'public', 'Section': 'logging', 'Option': 'LogAllowedConnections'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': True}}}, 'WfwDomainLoggingDroppedConnections': {'Policy': 'Network firewall: Domain: Logging: Log dropped packets', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_log_packets_connections.keys(), 'NetSH': {'Profile': 'domain', 'Section': 'logging', 'Option': 'LogDroppedConnections'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': True}}}, 'WfwPrivateLoggingDroppedConnections': {'Policy': 'Network firewall: Private: Logging: Log dropped packets', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_log_packets_connections.keys(), 'NetSH': {'Profile': 'private', 'Section': 'logging', 'Option': 'LogDroppedConnections'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': True}}}, 'WfwPublicLoggingDroppedConnections': {'Policy': 'Network firewall: Public: Logging: Log dropped packets', 'lgpo_section': self.windows_firewall_gpedit_path, 'Settings': self.firewall_log_packets_connections.keys(), 'NetSH': {'Profile': 'public', 'Section': 'logging', 'Option': 'LogDroppedConnections'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': False}, 'PutArgs': {'lookup': self.firewall_log_packets_connections, 'value_lookup': True}}}, 'PasswordHistory': {'Policy': 'Enforce password history', 'lgpo_section': self.password_policy_gpedit_path, 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 24}}, 'NetUserModal': {'Modal': 0, 'Option': 'password_hist_len'}}, 'MaxPasswordAge': {'Policy': 'Maximum password age', 'lgpo_section': self.password_policy_gpedit_path, 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 1, 'max': 86313600, 'zero_value': 4294967295}}, 'NetUserModal': {'Modal': 0, 'Option': 'max_passwd_age'}, 'Transform': {'Get': '_seconds_to_days', 'Put': '_days_to_seconds', 'GetArgs': {'zero_value': 4294967295}, 'PutArgs': {'zero_value': 4294967295}}}, 'MinPasswordAge': {'Policy': 'Minimum password age', 'lgpo_section': self.password_policy_gpedit_path, 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 86313600}}, 'NetUserModal': {'Modal': 0, 'Option': 'min_passwd_age'}, 'Transform': {'Get': '_seconds_to_days', 'Put': '_days_to_seconds'}}, 'MinPasswordLen': {'Policy': 'Minimum password length', 'lgpo_section': self.password_policy_gpedit_path, 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 14}}, 'NetUserModal': {'Modal': 0, 'Option': 'min_passwd_len'}}, 'PasswordComplexity': {'Policy': 'Password must meet complexity requirements', 'lgpo_section': self.password_policy_gpedit_path, 'Settings': self.enabled_one_disabled_zero_no_not_defined.keys(), 'Secedit': {'Option': 'PasswordComplexity', 'Section': 'System Access'}, 'Transform': self.enabled_one_disabled_zero_no_not_defined_transform}, 'ClearTextPasswords': {'Policy': 'Store passwords using reversible encryption', 'lgpo_section': self.password_policy_gpedit_path, 'Settings': self.enabled_one_disabled_zero_no_not_defined.keys(), 'Secedit': {'Option': 'ClearTextPassword', 'Section': 'System Access'}, 'Transform': self.enabled_one_disabled_zero_no_not_defined_transform}, 'RelaxMinimumPasswordLengthLimits': {'Policy': 'Relax minimum password length limits', 'lgpo_section': self.password_policy_gpedit_path, 'Settings': self.enabled_one_disabled_zero.keys(), 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\SAM', 'Value': 'RelaxMinimumPasswordLengthLimits', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'AdminAccountStatus': {'Policy': 'Accounts: Administrator account status', 'Settings': self.enabled_one_disabled_zero_no_not_defined.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Secedit': {'Option': 'EnableAdminAccount', 'Section': 'System Access'}, 'Transform': self.enabled_one_disabled_zero_no_not_defined_transform}, 'NoConnectedUser': {'Policy': 'Accounts: Block Microsoft accounts', 'Settings': self.block_ms_accounts.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\policies\\\\system', 'Value': 'NoConnectedUser', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.block_ms_accounts, 'value_lookup': False}, 'PutArgs': {'lookup': self.block_ms_accounts, 'value_lookup': True}}}, 'GuestAccountStatus': {'Policy': 'Accounts: Guest account status', 'Settings': self.enabled_one_disabled_zero_no_not_defined.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Secedit': {'Option': 'EnableGuestAccount', 'Section': 'System Access'}, 'Transform': self.enabled_one_disabled_zero_no_not_defined_transform}, 'LimitBlankPasswordUse': {'Policy': 'Accounts: Limit local account use of blank passwords to console logon only', 'lgpo_section': self.security_options_gpedit_path, 'Settings': self.enabled_one_disabled_zero.keys(), 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'limitblankpassworduse', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'RenameAdministratorAccount': {'Policy': 'Accounts: Rename administrator account', 'Settings': None, 'lgpo_section': self.security_options_gpedit_path, 'Secedit': {'Option': 'NewAdministratorName', 'Section': 'System Access'}, 'Transform': {'Get': '_strip_quotes', 'Put': '_add_quotes'}}, 'RenameGuestAccount': {'Policy': 'Accounts: Rename guest account', 'Settings': None, 'lgpo_section': self.security_options_gpedit_path, 'Secedit': {'Option': 'NewGuestName', 'Section': 'System Access'}, 'Transform': {'Get': '_strip_quotes', 'Put': '_add_quotes'}}, 'AuditBaseObjects': {'Policy': 'Audit: Audit the access of global system objects', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'AuditBaseObjects', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'SceNoApplyLegacyAuditPolicy': {'Policy': 'Audit: Force audit policy subcategory settings (Windows Vista or later) to override audit policy category settings', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'SCENoApplyLegacyAuditPolicy', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'DontDisplayLastUserName': {'Policy': 'Interactive logon: Do not display last user name', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'DontDisplayLastUserName', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'CachedLogonsCount': {'Policy': 'Interactive logon: Number of previous logons to cache (in case domain controller is not available)', 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 50}}, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon', 'Value': 'CachedLogonsCount', 'Type': 'REG_SZ'}}, 'ForceUnlockLogon': {'Policy': 'Interactive logon: Require Domain Controller authentication to unlock workstation', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon', 'Value': 'ForceUnlockLogon', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'ScRemoveOption': {'Policy': 'Interactive logon: Smart card removal behavior', 'Settings': self.sc_removal_lookup.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon', 'Value': 'ScRemoveOption', 'Type': 'REG_SZ'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.sc_removal_lookup, 'value_lookup': False}, 'PutArgs': {'lookup': self.sc_removal_lookup, 'value_lookup': True}}}, 'DisableCAD': {'Policy': 'Interactive logon: Do not require CTRL+ALT+DEL', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'DisableCAD', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'FilterAdministratorToken': {'Policy': 'User Account Control: Admin Approval Mode for the built-in Administrator account', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'FilterAdministratorToken', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'EnableUIADesktopToggle': {'Policy': 'User Account Control: Allow UIAccess applications to prompt for elevation without using the secure desktop', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'EnableUIADesktopToggle', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'ConsentPromptBehaviorAdmin': {'Policy': 'User Account Control: Behavior of the elevation prompt for administrators in Admin Approval Mode', 'Settings': self.uac_admin_prompt_lookup.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'ConsentPromptBehaviorAdmin', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.uac_admin_prompt_lookup, 'value_lookup': False}, 'PutArgs': {'lookup': self.uac_admin_prompt_lookup, 'value_lookup': True}}}, 'ConsentPromptBehaviorUser': {'Policy': 'User Account Control: Behavior of the elevation prompt for standard users', 'Settings': self.uac_user_prompt_lookup.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'ConsentPromptBehaviorUser', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.uac_user_prompt_lookup, 'value_lookup': False}, 'PutArgs': {'lookup': self.uac_user_prompt_lookup, 'value_lookup': True}}}, 'EnableInstallerDetection': {'Policy': 'User Account Control: Detect application installations and prompt for elevation', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'EnableInstallerDetection', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'ValidateAdminCodeSignatures': {'Policy': 'User Account Control: Only elevate executables that are signed and validated', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'ValidateAdminCodeSignatures', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'EnableSecureUIAPaths': {'Policy': 'User Account Control: Only elevate UIAccess applications that are installed in secure locations', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'EnableSecureUIAPaths', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'EnableLUA': {'Policy': 'User Account Control: Run all administrators in Admin Approval Mode', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'EnableLUA', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'PromptOnSecureDesktop': {'Policy': 'User Account Control: Switch to the secure desktop when prompting for elevation', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'PromptOnSecureDesktop', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'EnableVirtualization': {'Policy': 'User Account Control: Virtualize file and registry write failures to per-user locations', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'EnableVirtualization', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'PasswordExpiryWarning': {'Policy': 'Interactive logon: Prompt user to change password before expiration', 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 999}}, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon', 'Value': 'PasswordExpiryWarning', 'Type': 'REG_DWORD'}}, 'MaxDevicePasswordFailedAttempts': {'Policy': 'Interactive logon: Machine account lockout threshold', 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 999}}, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\policies\\\\system', 'Value': 'MaxDevicePasswordFailedAttempts', 'Type': 'REG_DWORD'}}, 'InactivityTimeoutSecs': {'Policy': 'Interactive logon: Machine inactivity limit', 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 599940}}, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\policies\\\\system', 'Value': 'InactivityTimeoutSecs', 'Type': 'REG_DWORD'}}, 'legalnoticetext': {'Policy': 'Interactive logon: Message text for users attempting to log on', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\policies\\\\system', 'Value': 'legalnoticetext', 'Type': 'REG_SZ'}, 'Transform': {'Put': '_string_put_transform'}}, 'legalnoticecaption': {'Policy': 'Interactive logon: Message title for users attempting to log on', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\policies\\\\system', 'Value': 'legalnoticecaption', 'Type': 'REG_SZ'}, 'Transform': {'Put': '_string_put_transform'}}, 'DontDisplayLockedUserId': {'Policy': 'Interactive logon: Display user information when the session is locked', 'Settings': self.locked_session_user_info.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\policies\\\\system', 'Value': 'DontDisplayLockedUserId', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.locked_session_user_info, 'value_lookup': False}, 'PutArgs': {'lookup': self.locked_session_user_info, 'value_lookup': True}}}, 'ScForceOption': {'Policy': 'Interactive logon: Require smart card', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'ScForceOption', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'Client_RequireSecuritySignature': {'Policy': 'Microsoft network client: Digitally sign communications (always)', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\LanmanWorkstation\\\\Parameters', 'Value': 'RequireSecuritySignature', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'Client_EnableSecuritySignature': {'Policy': 'Microsoft network client: Digitally sign communications (if server agrees)', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\LanmanWorkstation\\\\Parameters', 'Value': 'EnableSecuritySignature', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'EnablePlainTextPassword': {'Policy': 'Microsoft network client: Send unencrypted password to third-party SMB servers', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\LanmanWorkstation\\\\Parameters', 'Value': 'EnablePlainTextPassword', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'AutoDisconnect': {'Policy': 'Microsoft network server: Amount of idle time required before suspending session', 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 99999}}, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'AutoDisconnect', 'Type': 'REG_DWORD'}}, 'EnableS4U2SelfForClaims': {'Policy': 'Microsoft network server: Attempt S4U2Self to obtain claim information', 'Settings': self.s4u2self_options.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'EnableS4U2SelfForClaims', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.s4u2self_options, 'value_lookup': False}, 'PutArgs': {'lookup': self.s4u2self_options, 'value_lookup': True}}}, 'Server_RequireSecuritySignature': {'Policy': 'Microsoft network server: Digitally sign communications (always)', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'RequireSecuritySignature', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'Server_EnableSecuritySignature': {'Policy': 'Microsoft network server: Digitally sign communications (if client agrees)', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'EnableSecuritySignature', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'EnableForcedLogoff': {'Policy': 'Microsoft network server: Disconnect clients when logon hours expire', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'EnableForcedLogoff', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'SmbServerNameHardeningLevel': {'Policy': 'Microsoft network server: Server SPN target name validation level', 'Settings': self.smb_server_name_hardening_levels.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\LanmanServer\\\\Parameters', 'Value': 'SmbServerNameHardeningLevel', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.smb_server_name_hardening_levels, 'value_lookup': False}, 'PutArgs': {'lookup': self.smb_server_name_hardening_levels, 'value_lookup': True}}}, 'FullPrivilegeAuditing': {'Policy': 'Audit: Audit the use of Backup and Restore privilege', 'Settings': [chr(0), chr(1)], 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'FullPrivilegeAuditing', 'Type': 'REG_BINARY'}, 'Transform': {'Get': '_binary_enable_zero_disable_one_conversion', 'Put': '_binary_enable_zero_disable_one_reverse_conversion'}}, 'CrashOnAuditFail': {'Policy': 'Audit: Shut down system immediately if unable to log security audits', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'CrashOnAuditFail', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'UndockWithoutLogon': {'Policy': 'Devices: Allow undock without having to log on', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System', 'Value': 'UndockWithoutLogon', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'AddPrinterDrivers': {'Policy': 'Devices: Prevent users from installing printer drivers', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\Print\\\\Providers\\\\LanMan Print Services\\\\Servers', 'Value': 'AddPrinterDrivers', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'AllocateDASD': {'Policy': 'Devices: Allowed to format and eject removable media', 'Settings': ['9999', '0', '1', '2'], 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon', 'Value': 'AllocateDASD', 'Type': 'REG_SZ'}, 'Transform': {'Get': '_dasd_conversion', 'Put': '_dasd_reverse_conversion'}}, 'AllocateCDRoms': {'Policy': 'Devices: Restrict CD-ROM access to locally logged-on user only', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon', 'Value': 'AllocateCDRoms', 'Type': 'REG_SZ'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'AllocateFloppies': {'Policy': 'Devices: Restrict floppy access to locally logged-on user only', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon', 'Value': 'AllocateFloppies', 'Type': 'REG_SZ'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'DriverSigningPolicy': {'Policy': 'Devices: Unsigned driver installation behavior', 'Settings': ['3,0', '3,' + chr(1), '3,' + chr(2)], 'lgpo_section': self.security_options_gpedit_path, 'Secedit': {'Option': 'MACHINE\\\\Software\\\\Microsoft\\\\Driver Signing\\\\Policy', 'Section': 'Registry Values'}, 'Transform': {'Get': '_driver_signing_reg_conversion', 'Put': '_driver_signing_reg_reverse_conversion'}}, 'SubmitControl': {'Policy': 'Domain controller: Allow server operators to schedule tasks', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'SubmitControl', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'VulnerableChannelAllowList': {'Policy': 'Domain controller: Allow vulnerable Netlogon secure channel connections', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'VulnerableChannelAllowList', 'Type': 'REG_SZ'}, 'Transform': {'Put': '_string_put_transform'}}, 'LdapEnforceChannelBinding': {'Policy': 'Domain controller: LDAP server channel binding token requirements', 'Settings': self.ldap_server_binding_token_requirements.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\NTDS\\\\Parameters', 'Value': 'LdapEnforceChannelBinding', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.ldap_server_binding_token_requirements, 'value_lookup': False}, 'PutArgs': {'lookup': self.ldap_server_binding_token_requirements, 'value_lookup': True}}}, 'LDAPServerIntegrity': {'Policy': 'Domain controller: LDAP server signing requirements', 'Settings': self.ldap_server_signing_requirements.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\NTDS\\\\Parameters', 'Value': 'LDAPServerIntegrity', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.ldap_server_signing_requirements, 'value_lookup': False}, 'PutArgs': {'lookup': self.ldap_server_signing_requirements, 'value_lookup': True}}}, 'RefusePasswordChange': {'Policy': 'Domain controller: Refuse machine account password changes', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'RefusePasswordChange', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'RequireSignOrSeal': {'Policy': 'Domain member: Digitally encrypt or sign secure channel data (always)', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'RequireSignOrSeal', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'SealSecureChannel': {'Policy': 'Domain member: Digitally encrypt secure channel data (when possible)', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'SealSecureChannel', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'SignSecureChannel': {'Policy': 'Domain member: Digitally sign secure channel data (when possible)', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'SignSecureChannel', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'DisablePasswordChange': {'Policy': 'Domain member: Disable machine account password changes', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'DisablePasswordChange', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'MaximumPasswordAge': {'Policy': 'Domain member: Maximum machine account password age', 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 999}}, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'MaximumPasswordAge', 'Type': 'REG_DWORD'}}, 'RequireStrongKey': {'Policy': 'Domain member: Require strong (Windows 2000 or later) session key', 'Settings': self.enabled_one_disabled_zero_strings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'RequireStrongKey', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_strings_transform}, 'LockoutDuration': {'Policy': 'Account lockout duration', 'lgpo_section': self.account_lockout_policy_gpedit_path, 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 6000000, 'zero_value': 4294967295}}, 'NetUserModal': {'Modal': 3, 'Option': 'lockout_duration'}, 'Transform': {'Get': '_seconds_to_minutes', 'Put': '_minutes_to_seconds', 'GetArgs': {'zero_value': 4294967295}, 'PutArgs': {'zero_value': 4294967295}}}, 'LockoutThreshold': {'Policy': 'Account lockout threshold', 'lgpo_section': self.account_lockout_policy_gpedit_path, 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 1000}}, 'NetUserModal': {'Modal': 3, 'Option': 'lockout_threshold'}}, 'LockoutWindow': {'Policy': 'Reset account lockout counter after', 'lgpo_section': self.account_lockout_policy_gpedit_path, 'Settings': {'Function': '_in_range_inclusive', 'Args': {'min': 0, 'max': 6000000}}, 'NetUserModal': {'Modal': 3, 'Option': 'lockout_observation_window'}, 'Transform': {'Get': '_seconds_to_minutes', 'Put': '_minutes_to_seconds'}}, 'AuditAccountLogon': {'Policy': 'Audit account logon events', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditAccountLogon', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditAccountManage': {'Policy': 'Audit account management', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditAccountManage', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditDSAccess': {'Policy': 'Audit directory service access', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditDSAccess', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditLogonEvents': {'Policy': 'Audit logon events', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditLogonEvents', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditObjectAccess': {'Policy': 'Audit object access', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditObjectAccess', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditPolicyChange': {'Policy': 'Audit policy change', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditPolicyChange', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditPrivilegeUse': {'Policy': 'Audit privilege use', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditPrivilegeUse', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditProcessTracking': {'Policy': 'Audit process tracking', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditProcessTracking', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditSystemEvents': {'Policy': 'Audit system events', 'lgpo_section': self.audit_policy_gpedit_path, 'Settings': self.audit_lookup.keys(), 'Secedit': {'Option': 'AuditSystemEvents', 'Section': 'Event Audit'}, 'Transform': self.audit_transform}, 'AuditCredentialValidation': {'Policy': 'Audit Credential Validation', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Credential Validation'}, 'Transform': self.advanced_audit_transform}, 'AuditKerberosAuthenticationService': {'Policy': 'Audit Kerberos Authentication Service', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Kerberos Authentication Service'}, 'Transform': self.advanced_audit_transform}, 'AuditKerberosServiceTicketOperations': {'Policy': 'Audit Kerberos Service Ticket Operations', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Kerberos Service Ticket Operations'}, 'Transform': self.advanced_audit_transform}, 'AuditOtherAccountLogonEvents': {'Policy': 'Audit Other Account Logon Events', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Other Account Logon Events'}, 'Transform': self.advanced_audit_transform}, 'AuditApplicationGroupManagement': {'Policy': 'Audit Application Group Management', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Application Group Management'}, 'Transform': self.advanced_audit_transform}, 'AuditComputerAccountManagement': {'Policy': 'Audit Computer Account Management', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Computer Account Management'}, 'Transform': self.advanced_audit_transform}, 'AuditDistributionGroupManagement': {'Policy': 'Audit Distribution Group Management', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Distribution Group Management'}, 'Transform': self.advanced_audit_transform}, 'AuditOtherAccountManagementEvents': {'Policy': 'Audit Other Account Management Events', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Other Account Management Events'}, 'Transform': self.advanced_audit_transform}, 'AuditSecurityGroupManagement': {'Policy': 'Audit Security Group Management', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Security Group Management'}, 'Transform': self.advanced_audit_transform}, 'AuditUserAccountManagement': {'Policy': 'Audit User Account Management', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit User Account Management'}, 'Transform': self.advanced_audit_transform}, 'AuditDPAPIActivity': {'Policy': 'Audit DPAPI Activity', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit DPAPI Activity'}, 'Transform': self.advanced_audit_transform}, 'AuditPNPActivity': {'Policy': 'Audit PNP Activity', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit PNP Activity'}, 'Transform': self.advanced_audit_transform}, 'AuditProcessCreation': {'Policy': 'Audit Process Creation', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Process Creation'}, 'Transform': self.advanced_audit_transform}, 'AuditProcessTermination': {'Policy': 'Audit Process Termination', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Process Termination'}, 'Transform': self.advanced_audit_transform}, 'AuditRPCEvents': {'Policy': 'Audit RPC Events', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit RPC Events'}, 'Transform': self.advanced_audit_transform}, 'AuditTokenRightAdjusted': {'Policy': 'Audit Token Right Adjusted', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Token Right Adjusted'}, 'Transform': self.advanced_audit_transform}, 'AuditDetailedDirectoryServiceReplication': {'Policy': 'Audit Detailed Directory Service Replication', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Detailed Directory Service Replication'}, 'Transform': self.advanced_audit_transform}, 'AuditDirectoryServiceAccess': {'Policy': 'Audit Directory Service Access', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Directory Service Access'}, 'Transform': self.advanced_audit_transform}, 'AuditDirectoryServiceChanges': {'Policy': 'Audit Directory Service Changes', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Directory Service Changes'}, 'Transform': self.advanced_audit_transform}, 'AuditDirectoryServiceReplication': {'Policy': 'Audit Directory Service Replication', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Directory Service Replication'}, 'Transform': self.advanced_audit_transform}, 'AuditAccountLockout': {'Policy': 'Audit Account Lockout', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Account Lockout'}, 'Transform': self.advanced_audit_transform}, 'AuditUserDeviceClaims': {'Policy': 'Audit User / Device Claims', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit User / Device Claims'}, 'Transform': self.advanced_audit_transform}, 'AuditGroupMembership': {'Policy': 'Audit Group Membership', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Group Membership'}, 'Transform': self.advanced_audit_transform}, 'AuditIPsecExtendedMode': {'Policy': 'Audit IPsec Extended Mode', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit IPsec Extended Mode'}, 'Transform': self.advanced_audit_transform}, 'AuditIPsecMainMode': {'Policy': 'Audit IPsec Main Mode', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit IPsec Main Mode'}, 'Transform': self.advanced_audit_transform}, 'AuditIPsecQuickMode': {'Policy': 'Audit IPsec Quick Mode', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit IPsec Quick Mode'}, 'Transform': self.advanced_audit_transform}, 'AuditLogoff': {'Policy': 'Audit Logoff', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Logoff'}, 'Transform': self.advanced_audit_transform}, 'AuditLogon': {'Policy': 'Audit Logon', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Logon'}, 'Transform': self.advanced_audit_transform}, 'AuditNetworkPolicyServer': {'Policy': 'Audit Network Policy Server', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Network Policy Server'}, 'Transform': self.advanced_audit_transform}, 'AuditOtherLogonLogoffEvents': {'Policy': 'Audit Other Logon/Logoff Events', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Other Logon/Logoff Events'}, 'Transform': self.advanced_audit_transform}, 'AuditSpecialLogon': {'Policy': 'Audit Special Logon', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Special Logon'}, 'Transform': self.advanced_audit_transform}, 'AuditApplicationGenerated': {'Policy': 'Audit Application Generated', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Application Generated'}, 'Transform': self.advanced_audit_transform}, 'AuditCertificationServices': {'Policy': 'Audit Certification Services', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Certification Services'}, 'Transform': self.advanced_audit_transform}, 'AuditDetailedFileShare': {'Policy': 'Audit Detailed File Share', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Detailed File Share'}, 'Transform': self.advanced_audit_transform}, 'AuditFileShare': {'Policy': 'Audit File Share', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit File Share'}, 'Transform': self.advanced_audit_transform}, 'AuditFileSystem': {'Policy': 'Audit File System', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit File System'}, 'Transform': self.advanced_audit_transform}, 'AuditFilteringPlatformConnection': {'Policy': 'Audit Filtering Platform Connection', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Filtering Platform Connection'}, 'Transform': self.advanced_audit_transform}, 'AuditFilteringPlatformPacketDrop': {'Policy': 'Audit Filtering Platform Packet Drop', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Filtering Platform Packet Drop'}, 'Transform': self.advanced_audit_transform}, 'AuditHandleManipulation': {'Policy': 'Audit Handle Manipulation', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Handle Manipulation'}, 'Transform': self.advanced_audit_transform}, 'AuditKernelObject': {'Policy': 'Audit Kernel Object', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Kernel Object'}, 'Transform': self.advanced_audit_transform}, 'AuditOtherObjectAccessEvents': {'Policy': 'Audit Other Object Access Events', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Other Object Access Events'}, 'Transform': self.advanced_audit_transform}, 'AuditRegistry': {'Policy': 'Audit Registry', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Registry'}, 'Transform': self.advanced_audit_transform}, 'AuditRemovableStorage': {'Policy': 'Audit Removable Storage', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Removable Storage'}, 'Transform': self.advanced_audit_transform}, 'AuditSAM': {'Policy': 'Audit SAM', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit SAM'}, 'Transform': self.advanced_audit_transform}, 'AuditCentralAccessPolicyStaging': {'Policy': 'Audit Central Access Policy Staging', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Central Access Policy Staging'}, 'Transform': self.advanced_audit_transform}, 'AuditAuditPolicyChange': {'Policy': 'Audit Audit Policy Change', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Audit Policy Change'}, 'Transform': self.advanced_audit_transform}, 'AuditAuthenticationPolicyChange': {'Policy': 'Audit Authentication Policy Change', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Authentication Policy Change'}, 'Transform': self.advanced_audit_transform}, 'AuditAuthorizationPolicyChange': {'Policy': 'Audit Authorization Policy Change', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Authorization Policy Change'}, 'Transform': self.advanced_audit_transform}, 'AuditFilteringPlatformPolicyChange': {'Policy': 'Audit Filtering Platform Policy Change', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Filtering Platform Policy Change'}, 'Transform': self.advanced_audit_transform}, 'AuditMPSSVCRuleLevelPolicyChange': {'Policy': 'Audit MPSSVC Rule-Level Policy Change', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit MPSSVC Rule-Level Policy Change'}, 'Transform': self.advanced_audit_transform}, 'AuditOtherPolicyChangeEvents': {'Policy': 'Audit Other Policy Change Events', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Other Policy Change Events'}, 'Transform': self.advanced_audit_transform}, 'AuditNonSensitivePrivilegeUse': {'Policy': 'Audit Non Sensitive Privilege Use', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Non Sensitive Privilege Use'}, 'Transform': self.advanced_audit_transform}, 'AuditOtherPrivilegeUseEvents': {'Policy': 'Audit Other Privilege Use Events', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Other Privilege Use Events'}, 'Transform': self.advanced_audit_transform}, 'AuditSensitivePrivilegeUse': {'Policy': 'Audit Sensitive Privilege Use', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Sensitive Privilege Use'}, 'Transform': self.advanced_audit_transform}, 'AuditIPsecDriver': {'Policy': 'Audit IPsec Driver', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit IPsec Driver'}, 'Transform': self.advanced_audit_transform}, 'AuditOtherSystemEvents': {'Policy': 'Audit Other System Events', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Other System Events'}, 'Transform': self.advanced_audit_transform}, 'AuditSecurityStateChange': {'Policy': 'Audit Security State Change', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Security State Change'}, 'Transform': self.advanced_audit_transform}, 'AuditSecuritySystemExtension': {'Policy': 'Audit Security System Extension', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit Security System Extension'}, 'Transform': self.advanced_audit_transform}, 'AuditSystemIntegrity': {'Policy': 'Audit System Integrity', 'lgpo_section': self.advanced_audit_policy_gpedit_path, 'Settings': self.advanced_audit_lookup.keys(), 'AdvAudit': {'Option': 'Audit System Integrity'}, 'Transform': self.advanced_audit_transform}, 'SeTrustedCredManAccessPrivilege': {'Policy': 'Access Credential Manager as a trusted caller', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeTrustedCredManAccessPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeNetworkLogonRight': {'Policy': 'Access this computer from the network', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeNetworkLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeTcbPrivilege': {'Policy': 'Act as part of the operating system', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeTcbPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeMachineAccountPrivilege': {'Policy': 'Add workstations to domain', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeMachineAccountPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeIncreaseQuotaPrivilege': {'Policy': 'Adjust memory quotas for a process', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeIncreaseQuotaPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeInteractiveLogonRight': {'Policy': 'Allow log on locally', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeInteractiveLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeRemoteInteractiveLogonRight': {'Policy': 'Allow log on through Remote Desktop Services', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeRemoteInteractiveLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeBackupPrivilege': {'Policy': 'Backup files and directories', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeBackupPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeChangeNotifyPrivilege': {'Policy': 'Bypass traverse checking', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeChangeNotifyPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeSystemtimePrivilege': {'Policy': 'Change the system time', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeSystemtimePrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeTimeZonePrivilege': {'Policy': 'Change the time zone', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeTimeZonePrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeCreatePagefilePrivilege': {'Policy': 'Create a pagefile', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeCreatePagefilePrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeCreateTokenPrivilege': {'Policy': 'Create a token object', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeCreateTokenPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeCreateGlobalPrivilege': {'Policy': 'Create global objects', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeCreateGlobalPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeCreatePermanentPrivilege': {'Policy': 'Create permanent shared objects', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeCreatePermanentPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeCreateSymbolicLinkPrivilege': {'Policy': 'Create symbolic links', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeCreateSymbolicLinkPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeDebugPrivilege': {'Policy': 'Debug programs', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeDebugPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeDenyNetworkLogonRight': {'Policy': 'Deny access to this computer from the network', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeDenyNetworkLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeDenyBatchLogonRight': {'Policy': 'Deny log on as a batch job', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeDenyBatchLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeDenyServiceLogonRight': {'Policy': 'Deny log on as a service', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeDenyServiceLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeDenyInteractiveLogonRight': {'Policy': 'Deny log on locally', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeDenyInteractiveLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeDenyRemoteInteractiveLogonRight': {'Policy': 'Deny log on through Remote Desktop Services', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeDenyRemoteInteractiveLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeEnableDelegationPrivilege': {'Policy': 'Enable computer and user accounts to be trusted for delegation', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeEnableDelegationPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeRemoteShutdownPrivilege': {'Policy': 'Force shutdown from a remote system', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeRemoteShutdownPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeAuditPrivilege': {'Policy': 'Generate security audits', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeAuditPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeImpersonatePrivilege': {'Policy': 'Impersonate a client after authentication', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeImpersonatePrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeIncreaseWorkingSetPrivilege': {'Policy': 'Increase a process working set', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeIncreaseWorkingSetPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeIncreaseBasePriorityPrivilege': {'Policy': 'Increase scheduling priority', 'rights_assignment': True, 'lgpo_section': self.user_rights_assignment_gpedit_path, 'Settings': None, 'LsaRights': {'Option': 'SeIncreaseBasePriorityPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeLoadDriverPrivilege': {'Policy': 'Load and unload device drivers', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeLoadDriverPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeLockMemoryPrivilege': {'Policy': 'Lock pages in memory', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeLockMemoryPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeBatchLogonRight': {'Policy': 'Log on as a batch job', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeBatchLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeServiceLogonRight': {'Policy': 'Log on as a service', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeServiceLogonRight'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeSecurityPrivilege': {'Policy': 'Manage auditing and security log', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeSecurityPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeRelabelPrivilege': {'Policy': 'Modify an object label', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeRelabelPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeSystemEnvironmentPrivilege': {'Policy': 'Modify firmware environment values', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeSystemEnvironmentPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeManageVolumePrivilege': {'Policy': 'Perform volume maintenance tasks', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeManageVolumePrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeProfileSingleProcessPrivilege': {'Policy': 'Profile single process', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeProfileSingleProcessPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeSystemProfilePrivilege': {'Policy': 'Profile system performance', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeSystemProfilePrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeUndockPrivilege': {'Policy': 'Remove computer from docking station', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeUndockPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeAssignPrimaryTokenPrivilege': {'Policy': 'Replace a process level token', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeAssignPrimaryTokenPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeRestorePrivilege': {'Policy': 'Restore files and directories', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeRestorePrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeShutdownPrivilege': {'Policy': 'Shut down the system', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeShutdownPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeSyncAgentPrivilege': {'Policy': 'Synchronize directory service data', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeSyncAgentPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'SeTakeOwnershipPrivilege': {'Policy': 'Take ownership of files or other objects', 'lgpo_section': self.user_rights_assignment_gpedit_path, 'rights_assignment': True, 'Settings': None, 'LsaRights': {'Option': 'SeTakeOwnershipPrivilege'}, 'Transform': {'Get': '_sidConversion', 'Put': '_usernamesToSidObjects'}}, 'RecoveryConsoleSecurityLevel': {'Policy': 'Recovery console: Allow automatic administrative logon', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Setup\\\\RecoveryConsole', 'Value': 'SecurityLevel', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'RecoveryConsoleSetCommand': {'Policy': 'Recovery console: Allow floppy copy and access to all drives and all folders', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Setup\\\\RecoveryConsole', 'Value': 'SetCommand', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'ForceKeyProtection': {'Policy': 'System Cryptography: Force strong key protection for user keys stored on the computer', 'Settings': self.force_key_protection.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Policies\\\\Microsoft\\\\Cryptography', 'Value': 'ForceKeyProtection', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.force_key_protection, 'value_lookup': False}, 'PutArgs': {'lookup': self.force_key_protection, 'value_lookup': True}}}, 'FIPSAlgorithmPolicy': {'Policy': 'System Cryptography: Use FIPS compliant algorithms for encryption, hashing, and signing', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\FIPSAlgorithmPolicy', 'Value': 'Enabled', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'MachineAccessRestriction': {'Policy': 'DCOM: Machine Access Restrictions in Security Descriptor Definition Language (SDDL) syntax', 'Settings': None, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Policies\\\\Microsoft\\\\Windows NT\\\\DCOM', 'Value': 'MachineAccessRestriction', 'Type': 'REG_SZ'}, 'Transform': {'Put': '_string_put_transform'}}, 'MachineLaunchRestriction': {'Policy': 'DCOM: Machine Launch Restrictions in Security Descriptor Definition Language (SDDL) syntax', 'Settings': None, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'Software\\\\Policies\\\\Microsoft\\\\Windows NT\\\\DCOM', 'Value': 'MachineLaunchRestriction', 'Type': 'REG_SZ'}, 'Transform': {'Put': '_string_put_transform'}}, 'UseMachineId': {'Policy': 'Network security: Allow Local System to use computer identity for NTLM', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'UseMachineId', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'allownullsessionfallback': {'Policy': 'Network security: Allow LocalSystem NULL session fallback', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\MSV1_0', 'Value': 'allownullsessionfallback', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'AllowOnlineID': {'Policy': 'Network security: Allow PKU2U authentication requests to this computer to use online identities.', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\pku2u', 'Value': 'AllowOnlineID', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'KrbSupportedEncryptionTypes': {'Policy': 'Network security: Configure encryption types allowed for Kerberos', 'Settings': None, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\policies\\\\system\\\\Kerberos\\\\Parameters', 'Value': 'SupportedEncryptionTypes', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup_bitwise_add', 'Put': '_dict_lookup_bitwise_add', 'GetArgs': {'lookup': self.krb_encryption_types, 'value_lookup': False}, 'PutArgs': {'lookup': self.krb_encryption_types, 'value_lookup': True}}}, 'NoLMHash': {'Policy': 'Network security: Do not store LAN Manager hash value on next password change', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'NoLMHash', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'ForceLogoffWhenHourExpire': {'Policy': 'Network security: Force logoff when logon hours expire', 'lgpo_section': self.security_options_gpedit_path, 'Settings': self.enabled_one_disabled_zero_no_not_defined.keys(), 'Secedit': {'Option': 'ForceLogoffWhenHourExpire', 'Section': 'System Access'}, 'Transform': self.enabled_one_disabled_zero_no_not_defined_transform}, 'LmCompatibilityLevel': {'Policy': 'Network security: LAN Manager authentication level', 'Settings': self.lm_compat_levels.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa', 'Value': 'LmCompatibilityLevel', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.lm_compat_levels, 'value_lookup': False}, 'PutArgs': {'lookup': self.lm_compat_levels, 'value_lookup': True}}}, 'LDAPClientIntegrity': {'Policy': 'Network security: LDAP client signing requirements', 'Settings': self.ldap_signing_reqs.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\ldap', 'Value': 'LDAPClientIntegrity', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.ldap_signing_reqs, 'value_lookup': False}, 'PutArgs': {'lookup': self.ldap_signing_reqs, 'value_lookup': True}}}, 'NTLMMinClientSec': {'Policy': 'Network security: Minimum session security for NTLM SSP based (including secure RPC) clients', 'Settings': None, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\MSV1_0', 'Value': 'NTLMMinClientSec', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup_bitwise_add', 'Put': '_dict_lookup_bitwise_add', 'GetArgs': {'lookup': self.ntlm_session_security_levels, 'value_lookup': False}, 'PutArgs': {'lookup': self.ntlm_session_security_levels, 'value_lookup': True}}}, 'NTLMMinServerSec': {'Policy': 'Network security: Minimum session security for NTLM SSP based (including secure RPC) servers', 'Settings': None, 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\MSV1_0', 'Value': 'NTLMMinServerSec', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup_bitwise_add', 'Put': '_dict_lookup_bitwise_add', 'GetArgs': {'lookup': self.ntlm_session_security_levels, 'value_lookup': False}, 'PutArgs': {'lookup': self.ntlm_session_security_levels, 'value_lookup': True}}}, 'ClientAllowedNTLMServers': {'Policy': 'Network security: Restrict NTLM: Add remote server exceptions for NTLM authentication', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\MSV1_0', 'Value': 'ClientAllowedNTLMServers', 'Type': 'REG_MULTI_SZ'}, 'Transform': {'Put': '_multi_string_put_transform', 'Get': '_multi_string_get_transform'}}, 'DCAllowedNTLMServers': {'Policy': 'Network security: Restrict NTLM: Add server exceptions in this domain', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'DCAllowedNTLMServers', 'Type': 'REG_MULTI_SZ'}, 'Transform': {'Put': '_multi_string_put_transform', 'Get': '_multi_string_get_transform'}}, 'AuditReceivingNTLMTraffic': {'Policy': 'Network security: Restrict NTLM: Audit Incoming NTLM Traffic', 'Settings': self.ntlm_audit_settings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\LSA\\\\MSV1_0', 'Value': 'AuditReceivingNTLMTraffic', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.ntlm_audit_settings, 'value_lookup': False}, 'PutArgs': {'lookup': self.ntlm_audit_settings, 'value_lookup': True}}}, 'AuditNTLMInDomain': {'Policy': 'Network security: Restrict NTLM: Audit NTLM authentication in this domain', 'Settings': self.ntlm_domain_audit_settings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'AuditNTLMInDomain', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.ntlm_domain_audit_settings, 'value_lookup': False}, 'PutArgs': {'lookup': self.ntlm_domain_audit_settings, 'value_lookup': True}}}, 'RestrictReceivingNTLMTraffic': {'Policy': 'Network security: Restrict NTLM: Incoming NTLM traffic', 'Settings': self.incoming_ntlm_settings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\LSA\\\\MSV1_0', 'Value': 'RestrictReceivingNTLMTraffic', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.incoming_ntlm_settings, 'value_lookup': False}, 'PutArgs': {'lookup': self.incoming_ntlm_settings, 'value_lookup': True}}}, 'RestrictNTLMInDomain': {'Policy': 'Network security: Restrict NTLM: NTLM authentication in this domain', 'Settings': self.ntlm_domain_auth_settings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\Netlogon\\\\Parameters', 'Value': 'RestrictNTLMInDomain', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.ntlm_domain_auth_settings, 'value_lookup': False}, 'PutArgs': {'lookup': self.ntlm_domain_auth_settings, 'value_lookup': True}}}, 'RestrictSendingNTLMTraffic': {'Policy': 'Network security: Restrict NTLM: Outgoing NTLM traffic to remote servers', 'Settings': self.outgoing_ntlm_settings.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\MSV1_0', 'Value': 'RestrictSendingNTLMTraffic', 'Type': 'REG_DWORD'}, 'Transform': {'Get': '_dict_lookup', 'Put': '_dict_lookup', 'GetArgs': {'lookup': self.outgoing_ntlm_settings, 'value_lookup': False}, 'PutArgs': {'lookup': self.outgoing_ntlm_settings, 'value_lookup': True}}}, 'ShutdownWithoutLogon': {'Policy': 'Shutdown: Allow system to be shut down without having to log on', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\policies\\\\system', 'Value': 'ShutdownWithoutLogon', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'ClearPageFileAtShutdown': {'Policy': 'Shutdown: Clear virtual memory pagefile', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\SESSION MANAGER\\\\MEMORY MANAGEMENT', 'Value': 'ClearPageFileAtShutdown', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'ObCaseInsensitive': {'Policy': 'System objects: Require case insensitivity for non-Windows subsystems', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\SESSION MANAGER\\\\Kernel', 'Value': 'ObCaseInsensitive', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'ProtectionMode': {'Policy': 'System objects: Strengthen default permissions of internal system objects (e.g. Symbolic Links)', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\SESSION MANAGER', 'Value': 'ProtectionMode', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}, 'OptionalSubsystems': {'Policy': 'System settings: Optional subsystems', 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'System\\\\CurrentControlSet\\\\Control\\\\SESSION MANAGER\\\\SubSystems', 'Value': 'optional', 'Type': 'REG_MULTI_SZ'}, 'Transform': {'Put': '_multi_string_put_transform', 'Get': '_multi_string_get_transform'}}, 'AuthenticodeEnabled': {'Policy': 'System settings: Use Certificate Rules on Windows Executables for Software Restriction Policies', 'Settings': self.enabled_one_disabled_zero.keys(), 'lgpo_section': self.security_options_gpedit_path, 'Registry': {'Hive': 'HKEY_LOCAL_MACHINE', 'Path': 'SOFTWARE\\\\Policies\\\\Microsoft\\\\Windows\\\\safer\\\\codeidentifiers', 'Value': 'AuthenticodeEnabled', 'Type': 'REG_DWORD'}, 'Transform': self.enabled_one_disabled_zero_transform}}}, 'User': {'lgpo_section': 'User Configuration', 'policies': {}}}"
        ]
    },
    {
        "func_name": "_notEmpty",
        "original": "@classmethod\ndef _notEmpty(cls, val, **kwargs):\n    \"\"\"\n        ensures a value is not empty\n        \"\"\"\n    if val:\n        return True\n    else:\n        return False",
        "mutated": [
            "@classmethod\ndef _notEmpty(cls, val, **kwargs):\n    if False:\n        i = 10\n    '\\n        ensures a value is not empty\\n        '\n    if val:\n        return True\n    else:\n        return False",
            "@classmethod\ndef _notEmpty(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        ensures a value is not empty\\n        '\n    if val:\n        return True\n    else:\n        return False",
            "@classmethod\ndef _notEmpty(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        ensures a value is not empty\\n        '\n    if val:\n        return True\n    else:\n        return False",
            "@classmethod\ndef _notEmpty(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        ensures a value is not empty\\n        '\n    if val:\n        return True\n    else:\n        return False",
            "@classmethod\ndef _notEmpty(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        ensures a value is not empty\\n        '\n    if val:\n        return True\n    else:\n        return False"
        ]
    },
    {
        "func_name": "_seconds_to_days",
        "original": "@classmethod\ndef _seconds_to_days(cls, val, **kwargs):\n    \"\"\"\n        converts a number of seconds to days\n        \"\"\"\n    zero_value = kwargs.get('zero_value', 0)\n    if val is not None:\n        if val == zero_value:\n            return 0\n        return val / 86400\n    else:\n        return 'Not Defined'",
        "mutated": [
            "@classmethod\ndef _seconds_to_days(cls, val, **kwargs):\n    if False:\n        i = 10\n    '\\n        converts a number of seconds to days\\n        '\n    zero_value = kwargs.get('zero_value', 0)\n    if val is not None:\n        if val == zero_value:\n            return 0\n        return val / 86400\n    else:\n        return 'Not Defined'",
            "@classmethod\ndef _seconds_to_days(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        converts a number of seconds to days\\n        '\n    zero_value = kwargs.get('zero_value', 0)\n    if val is not None:\n        if val == zero_value:\n            return 0\n        return val / 86400\n    else:\n        return 'Not Defined'",
            "@classmethod\ndef _seconds_to_days(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        converts a number of seconds to days\\n        '\n    zero_value = kwargs.get('zero_value', 0)\n    if val is not None:\n        if val == zero_value:\n            return 0\n        return val / 86400\n    else:\n        return 'Not Defined'",
            "@classmethod\ndef _seconds_to_days(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        converts a number of seconds to days\\n        '\n    zero_value = kwargs.get('zero_value', 0)\n    if val is not None:\n        if val == zero_value:\n            return 0\n        return val / 86400\n    else:\n        return 'Not Defined'",
            "@classmethod\ndef _seconds_to_days(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        converts a number of seconds to days\\n        '\n    zero_value = kwargs.get('zero_value', 0)\n    if val is not None:\n        if val == zero_value:\n            return 0\n        return val / 86400\n    else:\n        return 'Not Defined'"
        ]
    },
    {
        "func_name": "_days_to_seconds",
        "original": "@classmethod\ndef _days_to_seconds(cls, val, **kwargs):\n    \"\"\"\n        converts a number of days to seconds\n        \"\"\"\n    zero_value = kwargs.get('zero_value', 0)\n    if val is not None:\n        if val == 0:\n            return zero_value\n        return val * 86400\n    else:\n        return 'Not Defined'",
        "mutated": [
            "@classmethod\ndef _days_to_seconds(cls, val, **kwargs):\n    if False:\n        i = 10\n    '\\n        converts a number of days to seconds\\n        '\n    zero_value = kwargs.get('zero_value', 0)\n    if val is not None:\n        if val == 0:\n            return zero_value\n        return val * 86400\n    else:\n        return 'Not Defined'",
            "@classmethod\ndef _days_to_seconds(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        converts a number of days to seconds\\n        '\n    zero_value = kwargs.get('zero_value', 0)\n    if val is not None:\n        if val == 0:\n            return zero_value\n        return val * 86400\n    else:\n        return 'Not Defined'",
            "@classmethod\ndef _days_to_seconds(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        converts a number of days to seconds\\n        '\n    zero_value = kwargs.get('zero_value', 0)\n    if val is not None:\n        if val == 0:\n            return zero_value\n        return val * 86400\n    else:\n        return 'Not Defined'",
            "@classmethod\ndef _days_to_seconds(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        converts a number of days to seconds\\n        '\n    zero_value = kwargs.get('zero_value', 0)\n    if val is not None:\n        if val == 0:\n            return zero_value\n        return val * 86400\n    else:\n        return 'Not Defined'",
            "@classmethod\ndef _days_to_seconds(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        converts a number of days to seconds\\n        '\n    zero_value = kwargs.get('zero_value', 0)\n    if val is not None:\n        if val == 0:\n            return zero_value\n        return val * 86400\n    else:\n        return 'Not Defined'"
        ]
    },
    {
        "func_name": "_seconds_to_minutes",
        "original": "@classmethod\ndef _seconds_to_minutes(cls, val, **kwargs):\n    \"\"\"\n        converts a number of seconds to minutes\n        \"\"\"\n    zero_value = kwargs.get('zero_value', 0)\n    if val is not None:\n        if val == zero_value:\n            return 0\n        return val / 60\n    else:\n        return 'Not Defined'",
        "mutated": [
            "@classmethod\ndef _seconds_to_minutes(cls, val, **kwargs):\n    if False:\n        i = 10\n    '\\n        converts a number of seconds to minutes\\n        '\n    zero_value = kwargs.get('zero_value', 0)\n    if val is not None:\n        if val == zero_value:\n            return 0\n        return val / 60\n    else:\n        return 'Not Defined'",
            "@classmethod\ndef _seconds_to_minutes(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        converts a number of seconds to minutes\\n        '\n    zero_value = kwargs.get('zero_value', 0)\n    if val is not None:\n        if val == zero_value:\n            return 0\n        return val / 60\n    else:\n        return 'Not Defined'",
            "@classmethod\ndef _seconds_to_minutes(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        converts a number of seconds to minutes\\n        '\n    zero_value = kwargs.get('zero_value', 0)\n    if val is not None:\n        if val == zero_value:\n            return 0\n        return val / 60\n    else:\n        return 'Not Defined'",
            "@classmethod\ndef _seconds_to_minutes(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        converts a number of seconds to minutes\\n        '\n    zero_value = kwargs.get('zero_value', 0)\n    if val is not None:\n        if val == zero_value:\n            return 0\n        return val / 60\n    else:\n        return 'Not Defined'",
            "@classmethod\ndef _seconds_to_minutes(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        converts a number of seconds to minutes\\n        '\n    zero_value = kwargs.get('zero_value', 0)\n    if val is not None:\n        if val == zero_value:\n            return 0\n        return val / 60\n    else:\n        return 'Not Defined'"
        ]
    },
    {
        "func_name": "_minutes_to_seconds",
        "original": "@classmethod\ndef _minutes_to_seconds(cls, val, **kwargs):\n    \"\"\"\n        converts number of minutes to seconds\n        \"\"\"\n    zero_value = kwargs.get('zero_value', 0)\n    if val is not None:\n        if val == 0:\n            return zero_value\n        return val * 60\n    else:\n        return 'Not Defined'",
        "mutated": [
            "@classmethod\ndef _minutes_to_seconds(cls, val, **kwargs):\n    if False:\n        i = 10\n    '\\n        converts number of minutes to seconds\\n        '\n    zero_value = kwargs.get('zero_value', 0)\n    if val is not None:\n        if val == 0:\n            return zero_value\n        return val * 60\n    else:\n        return 'Not Defined'",
            "@classmethod\ndef _minutes_to_seconds(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        converts number of minutes to seconds\\n        '\n    zero_value = kwargs.get('zero_value', 0)\n    if val is not None:\n        if val == 0:\n            return zero_value\n        return val * 60\n    else:\n        return 'Not Defined'",
            "@classmethod\ndef _minutes_to_seconds(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        converts number of minutes to seconds\\n        '\n    zero_value = kwargs.get('zero_value', 0)\n    if val is not None:\n        if val == 0:\n            return zero_value\n        return val * 60\n    else:\n        return 'Not Defined'",
            "@classmethod\ndef _minutes_to_seconds(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        converts number of minutes to seconds\\n        '\n    zero_value = kwargs.get('zero_value', 0)\n    if val is not None:\n        if val == 0:\n            return zero_value\n        return val * 60\n    else:\n        return 'Not Defined'",
            "@classmethod\ndef _minutes_to_seconds(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        converts number of minutes to seconds\\n        '\n    zero_value = kwargs.get('zero_value', 0)\n    if val is not None:\n        if val == 0:\n            return zero_value\n        return val * 60\n    else:\n        return 'Not Defined'"
        ]
    },
    {
        "func_name": "_strip_quotes",
        "original": "@classmethod\ndef _strip_quotes(cls, val, **kwargs):\n    \"\"\"\n        strips quotes from a string\n        \"\"\"\n    return val.replace('\"', '')",
        "mutated": [
            "@classmethod\ndef _strip_quotes(cls, val, **kwargs):\n    if False:\n        i = 10\n    '\\n        strips quotes from a string\\n        '\n    return val.replace('\"', '')",
            "@classmethod\ndef _strip_quotes(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        strips quotes from a string\\n        '\n    return val.replace('\"', '')",
            "@classmethod\ndef _strip_quotes(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        strips quotes from a string\\n        '\n    return val.replace('\"', '')",
            "@classmethod\ndef _strip_quotes(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        strips quotes from a string\\n        '\n    return val.replace('\"', '')",
            "@classmethod\ndef _strip_quotes(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        strips quotes from a string\\n        '\n    return val.replace('\"', '')"
        ]
    },
    {
        "func_name": "_add_quotes",
        "original": "@classmethod\ndef _add_quotes(cls, val, **kwargs):\n    \"\"\"\n        add quotes around the string\n        \"\"\"\n    return f'\"{val}\"'",
        "mutated": [
            "@classmethod\ndef _add_quotes(cls, val, **kwargs):\n    if False:\n        i = 10\n    '\\n        add quotes around the string\\n        '\n    return f'\"{val}\"'",
            "@classmethod\ndef _add_quotes(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        add quotes around the string\\n        '\n    return f'\"{val}\"'",
            "@classmethod\ndef _add_quotes(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        add quotes around the string\\n        '\n    return f'\"{val}\"'",
            "@classmethod\ndef _add_quotes(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        add quotes around the string\\n        '\n    return f'\"{val}\"'",
            "@classmethod\ndef _add_quotes(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        add quotes around the string\\n        '\n    return f'\"{val}\"'"
        ]
    },
    {
        "func_name": "_binary_enable_zero_disable_one_conversion",
        "original": "@classmethod\ndef _binary_enable_zero_disable_one_conversion(cls, val, **kwargs):\n    \"\"\"\n        converts a binary 0/1 to Disabled/Enabled\n        \"\"\"\n    try:\n        if val is not None:\n            if ord(val) == 0:\n                return 'Disabled'\n            elif ord(val) == 1:\n                return 'Enabled'\n            else:\n                return f'Invalid Value: {val!r}'\n        else:\n            return 'Not Defined'\n    except TypeError:\n        return 'Invalid Value'",
        "mutated": [
            "@classmethod\ndef _binary_enable_zero_disable_one_conversion(cls, val, **kwargs):\n    if False:\n        i = 10\n    '\\n        converts a binary 0/1 to Disabled/Enabled\\n        '\n    try:\n        if val is not None:\n            if ord(val) == 0:\n                return 'Disabled'\n            elif ord(val) == 1:\n                return 'Enabled'\n            else:\n                return f'Invalid Value: {val!r}'\n        else:\n            return 'Not Defined'\n    except TypeError:\n        return 'Invalid Value'",
            "@classmethod\ndef _binary_enable_zero_disable_one_conversion(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        converts a binary 0/1 to Disabled/Enabled\\n        '\n    try:\n        if val is not None:\n            if ord(val) == 0:\n                return 'Disabled'\n            elif ord(val) == 1:\n                return 'Enabled'\n            else:\n                return f'Invalid Value: {val!r}'\n        else:\n            return 'Not Defined'\n    except TypeError:\n        return 'Invalid Value'",
            "@classmethod\ndef _binary_enable_zero_disable_one_conversion(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        converts a binary 0/1 to Disabled/Enabled\\n        '\n    try:\n        if val is not None:\n            if ord(val) == 0:\n                return 'Disabled'\n            elif ord(val) == 1:\n                return 'Enabled'\n            else:\n                return f'Invalid Value: {val!r}'\n        else:\n            return 'Not Defined'\n    except TypeError:\n        return 'Invalid Value'",
            "@classmethod\ndef _binary_enable_zero_disable_one_conversion(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        converts a binary 0/1 to Disabled/Enabled\\n        '\n    try:\n        if val is not None:\n            if ord(val) == 0:\n                return 'Disabled'\n            elif ord(val) == 1:\n                return 'Enabled'\n            else:\n                return f'Invalid Value: {val!r}'\n        else:\n            return 'Not Defined'\n    except TypeError:\n        return 'Invalid Value'",
            "@classmethod\ndef _binary_enable_zero_disable_one_conversion(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        converts a binary 0/1 to Disabled/Enabled\\n        '\n    try:\n        if val is not None:\n            if ord(val) == 0:\n                return 'Disabled'\n            elif ord(val) == 1:\n                return 'Enabled'\n            else:\n                return f'Invalid Value: {val!r}'\n        else:\n            return 'Not Defined'\n    except TypeError:\n        return 'Invalid Value'"
        ]
    },
    {
        "func_name": "_binary_enable_zero_disable_one_reverse_conversion",
        "original": "@classmethod\ndef _binary_enable_zero_disable_one_reverse_conversion(cls, val, **kwargs):\n    \"\"\"\n        converts Enabled/Disabled to unicode char to write to a REG_BINARY value\n        \"\"\"\n    if val is not None:\n        if val.upper() == 'DISABLED':\n            return chr(0)\n        elif val.upper() == 'ENABLED':\n            return chr(1)\n        else:\n            return None\n    else:\n        return None",
        "mutated": [
            "@classmethod\ndef _binary_enable_zero_disable_one_reverse_conversion(cls, val, **kwargs):\n    if False:\n        i = 10\n    '\\n        converts Enabled/Disabled to unicode char to write to a REG_BINARY value\\n        '\n    if val is not None:\n        if val.upper() == 'DISABLED':\n            return chr(0)\n        elif val.upper() == 'ENABLED':\n            return chr(1)\n        else:\n            return None\n    else:\n        return None",
            "@classmethod\ndef _binary_enable_zero_disable_one_reverse_conversion(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        converts Enabled/Disabled to unicode char to write to a REG_BINARY value\\n        '\n    if val is not None:\n        if val.upper() == 'DISABLED':\n            return chr(0)\n        elif val.upper() == 'ENABLED':\n            return chr(1)\n        else:\n            return None\n    else:\n        return None",
            "@classmethod\ndef _binary_enable_zero_disable_one_reverse_conversion(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        converts Enabled/Disabled to unicode char to write to a REG_BINARY value\\n        '\n    if val is not None:\n        if val.upper() == 'DISABLED':\n            return chr(0)\n        elif val.upper() == 'ENABLED':\n            return chr(1)\n        else:\n            return None\n    else:\n        return None",
            "@classmethod\ndef _binary_enable_zero_disable_one_reverse_conversion(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        converts Enabled/Disabled to unicode char to write to a REG_BINARY value\\n        '\n    if val is not None:\n        if val.upper() == 'DISABLED':\n            return chr(0)\n        elif val.upper() == 'ENABLED':\n            return chr(1)\n        else:\n            return None\n    else:\n        return None",
            "@classmethod\ndef _binary_enable_zero_disable_one_reverse_conversion(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        converts Enabled/Disabled to unicode char to write to a REG_BINARY value\\n        '\n    if val is not None:\n        if val.upper() == 'DISABLED':\n            return chr(0)\n        elif val.upper() == 'ENABLED':\n            return chr(1)\n        else:\n            return None\n    else:\n        return None"
        ]
    },
    {
        "func_name": "_dasd_conversion",
        "original": "@classmethod\ndef _dasd_conversion(cls, val, **kwargs):\n    \"\"\"\n        converts 0/1/2 for dasd reg key\n        \"\"\"\n    if val is not None:\n        if val == '0' or val == 0 or val == '':\n            return 'Administrators'\n        elif val == '1' or val == 1:\n            return 'Administrators and Power Users'\n        elif val == '2' or val == 2:\n            return 'Administrators and Interactive Users'\n        else:\n            return 'Not Defined'\n    else:\n        return 'Not Defined'",
        "mutated": [
            "@classmethod\ndef _dasd_conversion(cls, val, **kwargs):\n    if False:\n        i = 10\n    '\\n        converts 0/1/2 for dasd reg key\\n        '\n    if val is not None:\n        if val == '0' or val == 0 or val == '':\n            return 'Administrators'\n        elif val == '1' or val == 1:\n            return 'Administrators and Power Users'\n        elif val == '2' or val == 2:\n            return 'Administrators and Interactive Users'\n        else:\n            return 'Not Defined'\n    else:\n        return 'Not Defined'",
            "@classmethod\ndef _dasd_conversion(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        converts 0/1/2 for dasd reg key\\n        '\n    if val is not None:\n        if val == '0' or val == 0 or val == '':\n            return 'Administrators'\n        elif val == '1' or val == 1:\n            return 'Administrators and Power Users'\n        elif val == '2' or val == 2:\n            return 'Administrators and Interactive Users'\n        else:\n            return 'Not Defined'\n    else:\n        return 'Not Defined'",
            "@classmethod\ndef _dasd_conversion(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        converts 0/1/2 for dasd reg key\\n        '\n    if val is not None:\n        if val == '0' or val == 0 or val == '':\n            return 'Administrators'\n        elif val == '1' or val == 1:\n            return 'Administrators and Power Users'\n        elif val == '2' or val == 2:\n            return 'Administrators and Interactive Users'\n        else:\n            return 'Not Defined'\n    else:\n        return 'Not Defined'",
            "@classmethod\ndef _dasd_conversion(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        converts 0/1/2 for dasd reg key\\n        '\n    if val is not None:\n        if val == '0' or val == 0 or val == '':\n            return 'Administrators'\n        elif val == '1' or val == 1:\n            return 'Administrators and Power Users'\n        elif val == '2' or val == 2:\n            return 'Administrators and Interactive Users'\n        else:\n            return 'Not Defined'\n    else:\n        return 'Not Defined'",
            "@classmethod\ndef _dasd_conversion(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        converts 0/1/2 for dasd reg key\\n        '\n    if val is not None:\n        if val == '0' or val == 0 or val == '':\n            return 'Administrators'\n        elif val == '1' or val == 1:\n            return 'Administrators and Power Users'\n        elif val == '2' or val == 2:\n            return 'Administrators and Interactive Users'\n        else:\n            return 'Not Defined'\n    else:\n        return 'Not Defined'"
        ]
    },
    {
        "func_name": "_dasd_reverse_conversion",
        "original": "@classmethod\ndef _dasd_reverse_conversion(cls, val, **kwargs):\n    \"\"\"\n        converts DASD String values to the reg_sz value\n        \"\"\"\n    if val is not None:\n        if val.upper() == 'ADMINISTRATORS':\n            return '0'\n        elif val.upper() == 'ADMINISTRATORS AND POWER USERS':\n            return '1'\n        elif val.upper() == 'ADMINISTRATORS AND INTERACTIVE USERS':\n            return '2'\n        elif val.upper() == 'NOT DEFINED':\n            return '9999'\n        else:\n            return 'Invalid Value'\n    else:\n        return 'Not Defined'",
        "mutated": [
            "@classmethod\ndef _dasd_reverse_conversion(cls, val, **kwargs):\n    if False:\n        i = 10\n    '\\n        converts DASD String values to the reg_sz value\\n        '\n    if val is not None:\n        if val.upper() == 'ADMINISTRATORS':\n            return '0'\n        elif val.upper() == 'ADMINISTRATORS AND POWER USERS':\n            return '1'\n        elif val.upper() == 'ADMINISTRATORS AND INTERACTIVE USERS':\n            return '2'\n        elif val.upper() == 'NOT DEFINED':\n            return '9999'\n        else:\n            return 'Invalid Value'\n    else:\n        return 'Not Defined'",
            "@classmethod\ndef _dasd_reverse_conversion(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        converts DASD String values to the reg_sz value\\n        '\n    if val is not None:\n        if val.upper() == 'ADMINISTRATORS':\n            return '0'\n        elif val.upper() == 'ADMINISTRATORS AND POWER USERS':\n            return '1'\n        elif val.upper() == 'ADMINISTRATORS AND INTERACTIVE USERS':\n            return '2'\n        elif val.upper() == 'NOT DEFINED':\n            return '9999'\n        else:\n            return 'Invalid Value'\n    else:\n        return 'Not Defined'",
            "@classmethod\ndef _dasd_reverse_conversion(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        converts DASD String values to the reg_sz value\\n        '\n    if val is not None:\n        if val.upper() == 'ADMINISTRATORS':\n            return '0'\n        elif val.upper() == 'ADMINISTRATORS AND POWER USERS':\n            return '1'\n        elif val.upper() == 'ADMINISTRATORS AND INTERACTIVE USERS':\n            return '2'\n        elif val.upper() == 'NOT DEFINED':\n            return '9999'\n        else:\n            return 'Invalid Value'\n    else:\n        return 'Not Defined'",
            "@classmethod\ndef _dasd_reverse_conversion(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        converts DASD String values to the reg_sz value\\n        '\n    if val is not None:\n        if val.upper() == 'ADMINISTRATORS':\n            return '0'\n        elif val.upper() == 'ADMINISTRATORS AND POWER USERS':\n            return '1'\n        elif val.upper() == 'ADMINISTRATORS AND INTERACTIVE USERS':\n            return '2'\n        elif val.upper() == 'NOT DEFINED':\n            return '9999'\n        else:\n            return 'Invalid Value'\n    else:\n        return 'Not Defined'",
            "@classmethod\ndef _dasd_reverse_conversion(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        converts DASD String values to the reg_sz value\\n        '\n    if val is not None:\n        if val.upper() == 'ADMINISTRATORS':\n            return '0'\n        elif val.upper() == 'ADMINISTRATORS AND POWER USERS':\n            return '1'\n        elif val.upper() == 'ADMINISTRATORS AND INTERACTIVE USERS':\n            return '2'\n        elif val.upper() == 'NOT DEFINED':\n            return '9999'\n        else:\n            return 'Invalid Value'\n    else:\n        return 'Not Defined'"
        ]
    },
    {
        "func_name": "_in_range_inclusive",
        "original": "@classmethod\ndef _in_range_inclusive(cls, val, **kwargs):\n    \"\"\"\n        checks that a value is in an inclusive range\n        The value for 0 used by Max Password Age is actually 0xffffffff\n        \"\"\"\n    minimum = kwargs.get('min', 0)\n    maximum = kwargs.get('max', 1)\n    zero_value = kwargs.get('zero_value', 0)\n    if isinstance(val, str):\n        if val.lower() == 'not defined':\n            return True\n        else:\n            try:\n                val = int(val)\n            except ValueError:\n                return False\n    if val is not None:\n        if minimum <= val <= maximum or val == zero_value:\n            return True\n        else:\n            return False\n    else:\n        return False",
        "mutated": [
            "@classmethod\ndef _in_range_inclusive(cls, val, **kwargs):\n    if False:\n        i = 10\n    '\\n        checks that a value is in an inclusive range\\n        The value for 0 used by Max Password Age is actually 0xffffffff\\n        '\n    minimum = kwargs.get('min', 0)\n    maximum = kwargs.get('max', 1)\n    zero_value = kwargs.get('zero_value', 0)\n    if isinstance(val, str):\n        if val.lower() == 'not defined':\n            return True\n        else:\n            try:\n                val = int(val)\n            except ValueError:\n                return False\n    if val is not None:\n        if minimum <= val <= maximum or val == zero_value:\n            return True\n        else:\n            return False\n    else:\n        return False",
            "@classmethod\ndef _in_range_inclusive(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        checks that a value is in an inclusive range\\n        The value for 0 used by Max Password Age is actually 0xffffffff\\n        '\n    minimum = kwargs.get('min', 0)\n    maximum = kwargs.get('max', 1)\n    zero_value = kwargs.get('zero_value', 0)\n    if isinstance(val, str):\n        if val.lower() == 'not defined':\n            return True\n        else:\n            try:\n                val = int(val)\n            except ValueError:\n                return False\n    if val is not None:\n        if minimum <= val <= maximum or val == zero_value:\n            return True\n        else:\n            return False\n    else:\n        return False",
            "@classmethod\ndef _in_range_inclusive(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        checks that a value is in an inclusive range\\n        The value for 0 used by Max Password Age is actually 0xffffffff\\n        '\n    minimum = kwargs.get('min', 0)\n    maximum = kwargs.get('max', 1)\n    zero_value = kwargs.get('zero_value', 0)\n    if isinstance(val, str):\n        if val.lower() == 'not defined':\n            return True\n        else:\n            try:\n                val = int(val)\n            except ValueError:\n                return False\n    if val is not None:\n        if minimum <= val <= maximum or val == zero_value:\n            return True\n        else:\n            return False\n    else:\n        return False",
            "@classmethod\ndef _in_range_inclusive(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        checks that a value is in an inclusive range\\n        The value for 0 used by Max Password Age is actually 0xffffffff\\n        '\n    minimum = kwargs.get('min', 0)\n    maximum = kwargs.get('max', 1)\n    zero_value = kwargs.get('zero_value', 0)\n    if isinstance(val, str):\n        if val.lower() == 'not defined':\n            return True\n        else:\n            try:\n                val = int(val)\n            except ValueError:\n                return False\n    if val is not None:\n        if minimum <= val <= maximum or val == zero_value:\n            return True\n        else:\n            return False\n    else:\n        return False",
            "@classmethod\ndef _in_range_inclusive(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        checks that a value is in an inclusive range\\n        The value for 0 used by Max Password Age is actually 0xffffffff\\n        '\n    minimum = kwargs.get('min', 0)\n    maximum = kwargs.get('max', 1)\n    zero_value = kwargs.get('zero_value', 0)\n    if isinstance(val, str):\n        if val.lower() == 'not defined':\n            return True\n        else:\n            try:\n                val = int(val)\n            except ValueError:\n                return False\n    if val is not None:\n        if minimum <= val <= maximum or val == zero_value:\n            return True\n        else:\n            return False\n    else:\n        return False"
        ]
    },
    {
        "func_name": "_driver_signing_reg_conversion",
        "original": "@classmethod\ndef _driver_signing_reg_conversion(cls, val, **kwargs):\n    \"\"\"\n        converts the binary value in the registry for driver signing into the\n        correct string representation\n        \"\"\"\n    log.trace('we have %s for the driver signing value', val)\n    if val is not None:\n        _val = val.split(',')\n        if len(_val) == 2:\n            if _val[1] == '0':\n                return 'Silently Succeed'\n            elif _val[1] == '1':\n                return 'Warn but allow installation'\n            elif _val[1] == '2':\n                return 'Do not allow installation'\n            elif _val[1] == 'Not Defined':\n                return 'Not Defined'\n            else:\n                return 'Invalid Value'\n        else:\n            return 'Not Defined'\n    else:\n        return 'Not Defined'",
        "mutated": [
            "@classmethod\ndef _driver_signing_reg_conversion(cls, val, **kwargs):\n    if False:\n        i = 10\n    '\\n        converts the binary value in the registry for driver signing into the\\n        correct string representation\\n        '\n    log.trace('we have %s for the driver signing value', val)\n    if val is not None:\n        _val = val.split(',')\n        if len(_val) == 2:\n            if _val[1] == '0':\n                return 'Silently Succeed'\n            elif _val[1] == '1':\n                return 'Warn but allow installation'\n            elif _val[1] == '2':\n                return 'Do not allow installation'\n            elif _val[1] == 'Not Defined':\n                return 'Not Defined'\n            else:\n                return 'Invalid Value'\n        else:\n            return 'Not Defined'\n    else:\n        return 'Not Defined'",
            "@classmethod\ndef _driver_signing_reg_conversion(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        converts the binary value in the registry for driver signing into the\\n        correct string representation\\n        '\n    log.trace('we have %s for the driver signing value', val)\n    if val is not None:\n        _val = val.split(',')\n        if len(_val) == 2:\n            if _val[1] == '0':\n                return 'Silently Succeed'\n            elif _val[1] == '1':\n                return 'Warn but allow installation'\n            elif _val[1] == '2':\n                return 'Do not allow installation'\n            elif _val[1] == 'Not Defined':\n                return 'Not Defined'\n            else:\n                return 'Invalid Value'\n        else:\n            return 'Not Defined'\n    else:\n        return 'Not Defined'",
            "@classmethod\ndef _driver_signing_reg_conversion(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        converts the binary value in the registry for driver signing into the\\n        correct string representation\\n        '\n    log.trace('we have %s for the driver signing value', val)\n    if val is not None:\n        _val = val.split(',')\n        if len(_val) == 2:\n            if _val[1] == '0':\n                return 'Silently Succeed'\n            elif _val[1] == '1':\n                return 'Warn but allow installation'\n            elif _val[1] == '2':\n                return 'Do not allow installation'\n            elif _val[1] == 'Not Defined':\n                return 'Not Defined'\n            else:\n                return 'Invalid Value'\n        else:\n            return 'Not Defined'\n    else:\n        return 'Not Defined'",
            "@classmethod\ndef _driver_signing_reg_conversion(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        converts the binary value in the registry for driver signing into the\\n        correct string representation\\n        '\n    log.trace('we have %s for the driver signing value', val)\n    if val is not None:\n        _val = val.split(',')\n        if len(_val) == 2:\n            if _val[1] == '0':\n                return 'Silently Succeed'\n            elif _val[1] == '1':\n                return 'Warn but allow installation'\n            elif _val[1] == '2':\n                return 'Do not allow installation'\n            elif _val[1] == 'Not Defined':\n                return 'Not Defined'\n            else:\n                return 'Invalid Value'\n        else:\n            return 'Not Defined'\n    else:\n        return 'Not Defined'",
            "@classmethod\ndef _driver_signing_reg_conversion(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        converts the binary value in the registry for driver signing into the\\n        correct string representation\\n        '\n    log.trace('we have %s for the driver signing value', val)\n    if val is not None:\n        _val = val.split(',')\n        if len(_val) == 2:\n            if _val[1] == '0':\n                return 'Silently Succeed'\n            elif _val[1] == '1':\n                return 'Warn but allow installation'\n            elif _val[1] == '2':\n                return 'Do not allow installation'\n            elif _val[1] == 'Not Defined':\n                return 'Not Defined'\n            else:\n                return 'Invalid Value'\n        else:\n            return 'Not Defined'\n    else:\n        return 'Not Defined'"
        ]
    },
    {
        "func_name": "_driver_signing_reg_reverse_conversion",
        "original": "@classmethod\ndef _driver_signing_reg_reverse_conversion(cls, val, **kwargs):\n    \"\"\"\n        converts the string value seen in the GUI to the correct registry value\n        for secedit\n        \"\"\"\n    if val is not None:\n        if val.upper() == 'SILENTLY SUCCEED':\n            return ','.join(['3', '0'])\n        elif val.upper() == 'WARN BUT ALLOW INSTALLATION':\n            return ','.join(['3', chr(1)])\n        elif val.upper() == 'DO NOT ALLOW INSTALLATION':\n            return ','.join(['3', chr(2)])\n        else:\n            return 'Invalid Value'\n    else:\n        return 'Not Defined'",
        "mutated": [
            "@classmethod\ndef _driver_signing_reg_reverse_conversion(cls, val, **kwargs):\n    if False:\n        i = 10\n    '\\n        converts the string value seen in the GUI to the correct registry value\\n        for secedit\\n        '\n    if val is not None:\n        if val.upper() == 'SILENTLY SUCCEED':\n            return ','.join(['3', '0'])\n        elif val.upper() == 'WARN BUT ALLOW INSTALLATION':\n            return ','.join(['3', chr(1)])\n        elif val.upper() == 'DO NOT ALLOW INSTALLATION':\n            return ','.join(['3', chr(2)])\n        else:\n            return 'Invalid Value'\n    else:\n        return 'Not Defined'",
            "@classmethod\ndef _driver_signing_reg_reverse_conversion(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        converts the string value seen in the GUI to the correct registry value\\n        for secedit\\n        '\n    if val is not None:\n        if val.upper() == 'SILENTLY SUCCEED':\n            return ','.join(['3', '0'])\n        elif val.upper() == 'WARN BUT ALLOW INSTALLATION':\n            return ','.join(['3', chr(1)])\n        elif val.upper() == 'DO NOT ALLOW INSTALLATION':\n            return ','.join(['3', chr(2)])\n        else:\n            return 'Invalid Value'\n    else:\n        return 'Not Defined'",
            "@classmethod\ndef _driver_signing_reg_reverse_conversion(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        converts the string value seen in the GUI to the correct registry value\\n        for secedit\\n        '\n    if val is not None:\n        if val.upper() == 'SILENTLY SUCCEED':\n            return ','.join(['3', '0'])\n        elif val.upper() == 'WARN BUT ALLOW INSTALLATION':\n            return ','.join(['3', chr(1)])\n        elif val.upper() == 'DO NOT ALLOW INSTALLATION':\n            return ','.join(['3', chr(2)])\n        else:\n            return 'Invalid Value'\n    else:\n        return 'Not Defined'",
            "@classmethod\ndef _driver_signing_reg_reverse_conversion(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        converts the string value seen in the GUI to the correct registry value\\n        for secedit\\n        '\n    if val is not None:\n        if val.upper() == 'SILENTLY SUCCEED':\n            return ','.join(['3', '0'])\n        elif val.upper() == 'WARN BUT ALLOW INSTALLATION':\n            return ','.join(['3', chr(1)])\n        elif val.upper() == 'DO NOT ALLOW INSTALLATION':\n            return ','.join(['3', chr(2)])\n        else:\n            return 'Invalid Value'\n    else:\n        return 'Not Defined'",
            "@classmethod\ndef _driver_signing_reg_reverse_conversion(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        converts the string value seen in the GUI to the correct registry value\\n        for secedit\\n        '\n    if val is not None:\n        if val.upper() == 'SILENTLY SUCCEED':\n            return ','.join(['3', '0'])\n        elif val.upper() == 'WARN BUT ALLOW INSTALLATION':\n            return ','.join(['3', chr(1)])\n        elif val.upper() == 'DO NOT ALLOW INSTALLATION':\n            return ','.join(['3', chr(2)])\n        else:\n            return 'Invalid Value'\n    else:\n        return 'Not Defined'"
        ]
    },
    {
        "func_name": "_sidConversion",
        "original": "@classmethod\ndef _sidConversion(cls, val, **kwargs):\n    \"\"\"\n        converts a list of pysid objects to string representations\n        \"\"\"\n    if isinstance(val, str):\n        val = val.split(',')\n    usernames = []\n    for _sid in val:\n        try:\n            userSid = win32security.LookupAccountSid('', _sid)\n            if userSid[1]:\n                userSid = f'{userSid[1]}\\\\{userSid[0]}'\n            else:\n                userSid = f'{userSid[0]}'\n        except Exception:\n            userSid = win32security.ConvertSidToStringSid(_sid)\n            log.warning(\"Unable to convert SID '%s' to a friendly name. The SID will be displayed instead of a user/group name.\", userSid)\n        usernames.append(userSid)\n    return usernames",
        "mutated": [
            "@classmethod\ndef _sidConversion(cls, val, **kwargs):\n    if False:\n        i = 10\n    '\\n        converts a list of pysid objects to string representations\\n        '\n    if isinstance(val, str):\n        val = val.split(',')\n    usernames = []\n    for _sid in val:\n        try:\n            userSid = win32security.LookupAccountSid('', _sid)\n            if userSid[1]:\n                userSid = f'{userSid[1]}\\\\{userSid[0]}'\n            else:\n                userSid = f'{userSid[0]}'\n        except Exception:\n            userSid = win32security.ConvertSidToStringSid(_sid)\n            log.warning(\"Unable to convert SID '%s' to a friendly name. The SID will be displayed instead of a user/group name.\", userSid)\n        usernames.append(userSid)\n    return usernames",
            "@classmethod\ndef _sidConversion(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        converts a list of pysid objects to string representations\\n        '\n    if isinstance(val, str):\n        val = val.split(',')\n    usernames = []\n    for _sid in val:\n        try:\n            userSid = win32security.LookupAccountSid('', _sid)\n            if userSid[1]:\n                userSid = f'{userSid[1]}\\\\{userSid[0]}'\n            else:\n                userSid = f'{userSid[0]}'\n        except Exception:\n            userSid = win32security.ConvertSidToStringSid(_sid)\n            log.warning(\"Unable to convert SID '%s' to a friendly name. The SID will be displayed instead of a user/group name.\", userSid)\n        usernames.append(userSid)\n    return usernames",
            "@classmethod\ndef _sidConversion(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        converts a list of pysid objects to string representations\\n        '\n    if isinstance(val, str):\n        val = val.split(',')\n    usernames = []\n    for _sid in val:\n        try:\n            userSid = win32security.LookupAccountSid('', _sid)\n            if userSid[1]:\n                userSid = f'{userSid[1]}\\\\{userSid[0]}'\n            else:\n                userSid = f'{userSid[0]}'\n        except Exception:\n            userSid = win32security.ConvertSidToStringSid(_sid)\n            log.warning(\"Unable to convert SID '%s' to a friendly name. The SID will be displayed instead of a user/group name.\", userSid)\n        usernames.append(userSid)\n    return usernames",
            "@classmethod\ndef _sidConversion(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        converts a list of pysid objects to string representations\\n        '\n    if isinstance(val, str):\n        val = val.split(',')\n    usernames = []\n    for _sid in val:\n        try:\n            userSid = win32security.LookupAccountSid('', _sid)\n            if userSid[1]:\n                userSid = f'{userSid[1]}\\\\{userSid[0]}'\n            else:\n                userSid = f'{userSid[0]}'\n        except Exception:\n            userSid = win32security.ConvertSidToStringSid(_sid)\n            log.warning(\"Unable to convert SID '%s' to a friendly name. The SID will be displayed instead of a user/group name.\", userSid)\n        usernames.append(userSid)\n    return usernames",
            "@classmethod\ndef _sidConversion(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        converts a list of pysid objects to string representations\\n        '\n    if isinstance(val, str):\n        val = val.split(',')\n    usernames = []\n    for _sid in val:\n        try:\n            userSid = win32security.LookupAccountSid('', _sid)\n            if userSid[1]:\n                userSid = f'{userSid[1]}\\\\{userSid[0]}'\n            else:\n                userSid = f'{userSid[0]}'\n        except Exception:\n            userSid = win32security.ConvertSidToStringSid(_sid)\n            log.warning(\"Unable to convert SID '%s' to a friendly name. The SID will be displayed instead of a user/group name.\", userSid)\n        usernames.append(userSid)\n    return usernames"
        ]
    },
    {
        "func_name": "_usernamesToSidObjects",
        "original": "@classmethod\ndef _usernamesToSidObjects(cls, val, **kwargs):\n    \"\"\"\n        converts a list of usernames to sid objects\n        \"\"\"\n    if not val:\n        return val\n    if isinstance(val, str):\n        val = val.split(',')\n    sids = []\n    for _user in val:\n        try:\n            sid = win32security.LookupAccountName('', _user)[0]\n            sids.append(sid)\n        except Exception as e:\n            log.exception('Handle this explicitly')\n            raise CommandExecutionError('There was an error obtaining the SID of user \"{}\". Error returned: {}'.format(_user, e))\n    return sids",
        "mutated": [
            "@classmethod\ndef _usernamesToSidObjects(cls, val, **kwargs):\n    if False:\n        i = 10\n    '\\n        converts a list of usernames to sid objects\\n        '\n    if not val:\n        return val\n    if isinstance(val, str):\n        val = val.split(',')\n    sids = []\n    for _user in val:\n        try:\n            sid = win32security.LookupAccountName('', _user)[0]\n            sids.append(sid)\n        except Exception as e:\n            log.exception('Handle this explicitly')\n            raise CommandExecutionError('There was an error obtaining the SID of user \"{}\". Error returned: {}'.format(_user, e))\n    return sids",
            "@classmethod\ndef _usernamesToSidObjects(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        converts a list of usernames to sid objects\\n        '\n    if not val:\n        return val\n    if isinstance(val, str):\n        val = val.split(',')\n    sids = []\n    for _user in val:\n        try:\n            sid = win32security.LookupAccountName('', _user)[0]\n            sids.append(sid)\n        except Exception as e:\n            log.exception('Handle this explicitly')\n            raise CommandExecutionError('There was an error obtaining the SID of user \"{}\". Error returned: {}'.format(_user, e))\n    return sids",
            "@classmethod\ndef _usernamesToSidObjects(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        converts a list of usernames to sid objects\\n        '\n    if not val:\n        return val\n    if isinstance(val, str):\n        val = val.split(',')\n    sids = []\n    for _user in val:\n        try:\n            sid = win32security.LookupAccountName('', _user)[0]\n            sids.append(sid)\n        except Exception as e:\n            log.exception('Handle this explicitly')\n            raise CommandExecutionError('There was an error obtaining the SID of user \"{}\". Error returned: {}'.format(_user, e))\n    return sids",
            "@classmethod\ndef _usernamesToSidObjects(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        converts a list of usernames to sid objects\\n        '\n    if not val:\n        return val\n    if isinstance(val, str):\n        val = val.split(',')\n    sids = []\n    for _user in val:\n        try:\n            sid = win32security.LookupAccountName('', _user)[0]\n            sids.append(sid)\n        except Exception as e:\n            log.exception('Handle this explicitly')\n            raise CommandExecutionError('There was an error obtaining the SID of user \"{}\". Error returned: {}'.format(_user, e))\n    return sids",
            "@classmethod\ndef _usernamesToSidObjects(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        converts a list of usernames to sid objects\\n        '\n    if not val:\n        return val\n    if isinstance(val, str):\n        val = val.split(',')\n    sids = []\n    for _user in val:\n        try:\n            sid = win32security.LookupAccountName('', _user)[0]\n            sids.append(sid)\n        except Exception as e:\n            log.exception('Handle this explicitly')\n            raise CommandExecutionError('There was an error obtaining the SID of user \"{}\". Error returned: {}'.format(_user, e))\n    return sids"
        ]
    },
    {
        "func_name": "_powershell_script_order_conversion",
        "original": "@classmethod\ndef _powershell_script_order_conversion(cls, val, **kwargs):\n    \"\"\"\n        converts true/false/None to the GUI representation of the powershell\n        startup/shutdown script order\n        \"\"\"\n    log.trace('script order value = %s', val)\n    if val is None or val == 'None':\n        return 'Not Configured'\n    elif val == 'true':\n        return 'Run Windows PowerShell scripts first'\n    elif val == 'false':\n        return 'Run Windows PowerShell scripts last'\n    else:\n        return 'Invalid Value'",
        "mutated": [
            "@classmethod\ndef _powershell_script_order_conversion(cls, val, **kwargs):\n    if False:\n        i = 10\n    '\\n        converts true/false/None to the GUI representation of the powershell\\n        startup/shutdown script order\\n        '\n    log.trace('script order value = %s', val)\n    if val is None or val == 'None':\n        return 'Not Configured'\n    elif val == 'true':\n        return 'Run Windows PowerShell scripts first'\n    elif val == 'false':\n        return 'Run Windows PowerShell scripts last'\n    else:\n        return 'Invalid Value'",
            "@classmethod\ndef _powershell_script_order_conversion(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        converts true/false/None to the GUI representation of the powershell\\n        startup/shutdown script order\\n        '\n    log.trace('script order value = %s', val)\n    if val is None or val == 'None':\n        return 'Not Configured'\n    elif val == 'true':\n        return 'Run Windows PowerShell scripts first'\n    elif val == 'false':\n        return 'Run Windows PowerShell scripts last'\n    else:\n        return 'Invalid Value'",
            "@classmethod\ndef _powershell_script_order_conversion(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        converts true/false/None to the GUI representation of the powershell\\n        startup/shutdown script order\\n        '\n    log.trace('script order value = %s', val)\n    if val is None or val == 'None':\n        return 'Not Configured'\n    elif val == 'true':\n        return 'Run Windows PowerShell scripts first'\n    elif val == 'false':\n        return 'Run Windows PowerShell scripts last'\n    else:\n        return 'Invalid Value'",
            "@classmethod\ndef _powershell_script_order_conversion(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        converts true/false/None to the GUI representation of the powershell\\n        startup/shutdown script order\\n        '\n    log.trace('script order value = %s', val)\n    if val is None or val == 'None':\n        return 'Not Configured'\n    elif val == 'true':\n        return 'Run Windows PowerShell scripts first'\n    elif val == 'false':\n        return 'Run Windows PowerShell scripts last'\n    else:\n        return 'Invalid Value'",
            "@classmethod\ndef _powershell_script_order_conversion(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        converts true/false/None to the GUI representation of the powershell\\n        startup/shutdown script order\\n        '\n    log.trace('script order value = %s', val)\n    if val is None or val == 'None':\n        return 'Not Configured'\n    elif val == 'true':\n        return 'Run Windows PowerShell scripts first'\n    elif val == 'false':\n        return 'Run Windows PowerShell scripts last'\n    else:\n        return 'Invalid Value'"
        ]
    },
    {
        "func_name": "_powershell_script_order_reverse_conversion",
        "original": "@classmethod\ndef _powershell_script_order_reverse_conversion(cls, val, **kwargs):\n    \"\"\"\n        converts powershell script GUI strings representations to\n        True/False/None\n        \"\"\"\n    if val.upper() == 'Run Windows PowerShell scripts first'.upper():\n        return 'true'\n    elif val.upper() == 'Run Windows PowerShell scripts last'.upper():\n        return 'false'\n    elif val == 'Not Configured':\n        return None\n    else:\n        return 'Invalid Value'",
        "mutated": [
            "@classmethod\ndef _powershell_script_order_reverse_conversion(cls, val, **kwargs):\n    if False:\n        i = 10\n    '\\n        converts powershell script GUI strings representations to\\n        True/False/None\\n        '\n    if val.upper() == 'Run Windows PowerShell scripts first'.upper():\n        return 'true'\n    elif val.upper() == 'Run Windows PowerShell scripts last'.upper():\n        return 'false'\n    elif val == 'Not Configured':\n        return None\n    else:\n        return 'Invalid Value'",
            "@classmethod\ndef _powershell_script_order_reverse_conversion(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        converts powershell script GUI strings representations to\\n        True/False/None\\n        '\n    if val.upper() == 'Run Windows PowerShell scripts first'.upper():\n        return 'true'\n    elif val.upper() == 'Run Windows PowerShell scripts last'.upper():\n        return 'false'\n    elif val == 'Not Configured':\n        return None\n    else:\n        return 'Invalid Value'",
            "@classmethod\ndef _powershell_script_order_reverse_conversion(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        converts powershell script GUI strings representations to\\n        True/False/None\\n        '\n    if val.upper() == 'Run Windows PowerShell scripts first'.upper():\n        return 'true'\n    elif val.upper() == 'Run Windows PowerShell scripts last'.upper():\n        return 'false'\n    elif val == 'Not Configured':\n        return None\n    else:\n        return 'Invalid Value'",
            "@classmethod\ndef _powershell_script_order_reverse_conversion(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        converts powershell script GUI strings representations to\\n        True/False/None\\n        '\n    if val.upper() == 'Run Windows PowerShell scripts first'.upper():\n        return 'true'\n    elif val.upper() == 'Run Windows PowerShell scripts last'.upper():\n        return 'false'\n    elif val == 'Not Configured':\n        return None\n    else:\n        return 'Invalid Value'",
            "@classmethod\ndef _powershell_script_order_reverse_conversion(cls, val, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        converts powershell script GUI strings representations to\\n        True/False/None\\n        '\n    if val.upper() == 'Run Windows PowerShell scripts first'.upper():\n        return 'true'\n    elif val.upper() == 'Run Windows PowerShell scripts last'.upper():\n        return 'false'\n    elif val == 'Not Configured':\n        return None\n    else:\n        return 'Invalid Value'"
        ]
    },
    {
        "func_name": "_dict_lookup",
        "original": "@classmethod\ndef _dict_lookup(cls, item, **kwargs):\n    \"\"\"\n        Retrieves the key or value from a dict based on the item\n        kwarg lookup dict to search for item\n        kwarg value_lookup bool to determine if item should be compared to keys\n        or values\n        \"\"\"\n    log.trace('item == %s', item)\n    value_lookup = kwargs.get('value_lookup', False)\n    if 'lookup' in kwargs:\n        for (k, v) in kwargs['lookup'].items():\n            if value_lookup:\n                if str(v).lower() == str(item).lower():\n                    log.trace('returning key %s', k)\n                    return k\n            elif str(k).lower() == str(item).lower():\n                log.trace('returning value %s', v)\n                return v\n    return 'Invalid Value'",
        "mutated": [
            "@classmethod\ndef _dict_lookup(cls, item, **kwargs):\n    if False:\n        i = 10\n    '\\n        Retrieves the key or value from a dict based on the item\\n        kwarg lookup dict to search for item\\n        kwarg value_lookup bool to determine if item should be compared to keys\\n        or values\\n        '\n    log.trace('item == %s', item)\n    value_lookup = kwargs.get('value_lookup', False)\n    if 'lookup' in kwargs:\n        for (k, v) in kwargs['lookup'].items():\n            if value_lookup:\n                if str(v).lower() == str(item).lower():\n                    log.trace('returning key %s', k)\n                    return k\n            elif str(k).lower() == str(item).lower():\n                log.trace('returning value %s', v)\n                return v\n    return 'Invalid Value'",
            "@classmethod\ndef _dict_lookup(cls, item, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Retrieves the key or value from a dict based on the item\\n        kwarg lookup dict to search for item\\n        kwarg value_lookup bool to determine if item should be compared to keys\\n        or values\\n        '\n    log.trace('item == %s', item)\n    value_lookup = kwargs.get('value_lookup', False)\n    if 'lookup' in kwargs:\n        for (k, v) in kwargs['lookup'].items():\n            if value_lookup:\n                if str(v).lower() == str(item).lower():\n                    log.trace('returning key %s', k)\n                    return k\n            elif str(k).lower() == str(item).lower():\n                log.trace('returning value %s', v)\n                return v\n    return 'Invalid Value'",
            "@classmethod\ndef _dict_lookup(cls, item, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Retrieves the key or value from a dict based on the item\\n        kwarg lookup dict to search for item\\n        kwarg value_lookup bool to determine if item should be compared to keys\\n        or values\\n        '\n    log.trace('item == %s', item)\n    value_lookup = kwargs.get('value_lookup', False)\n    if 'lookup' in kwargs:\n        for (k, v) in kwargs['lookup'].items():\n            if value_lookup:\n                if str(v).lower() == str(item).lower():\n                    log.trace('returning key %s', k)\n                    return k\n            elif str(k).lower() == str(item).lower():\n                log.trace('returning value %s', v)\n                return v\n    return 'Invalid Value'",
            "@classmethod\ndef _dict_lookup(cls, item, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Retrieves the key or value from a dict based on the item\\n        kwarg lookup dict to search for item\\n        kwarg value_lookup bool to determine if item should be compared to keys\\n        or values\\n        '\n    log.trace('item == %s', item)\n    value_lookup = kwargs.get('value_lookup', False)\n    if 'lookup' in kwargs:\n        for (k, v) in kwargs['lookup'].items():\n            if value_lookup:\n                if str(v).lower() == str(item).lower():\n                    log.trace('returning key %s', k)\n                    return k\n            elif str(k).lower() == str(item).lower():\n                log.trace('returning value %s', v)\n                return v\n    return 'Invalid Value'",
            "@classmethod\ndef _dict_lookup(cls, item, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Retrieves the key or value from a dict based on the item\\n        kwarg lookup dict to search for item\\n        kwarg value_lookup bool to determine if item should be compared to keys\\n        or values\\n        '\n    log.trace('item == %s', item)\n    value_lookup = kwargs.get('value_lookup', False)\n    if 'lookup' in kwargs:\n        for (k, v) in kwargs['lookup'].items():\n            if value_lookup:\n                if str(v).lower() == str(item).lower():\n                    log.trace('returning key %s', k)\n                    return k\n            elif str(k).lower() == str(item).lower():\n                log.trace('returning value %s', v)\n                return v\n    return 'Invalid Value'"
        ]
    },
    {
        "func_name": "_dict_lookup_bitwise_add",
        "original": "@classmethod\ndef _dict_lookup_bitwise_add(cls, item, **kwargs):\n    \"\"\"\n        kwarg value_lookup bool to determine if item_list should be compared to keys\n        or values\n\n        kwarg test_zero is used to determine if 0 should be tested when value_lookup is false\n        lookup should be a dict with integers for keys\n\n        if value_lookup is True, item is expected to be a list\n            the function will return the sum of the keys whose values are in the item list\n        if value_lookup is False, item is expected to be an integer\n            the function will return the values for the keys\n            which successfully \"bitwise and\" with item\n        \"\"\"\n    value_lookup = kwargs.get('value_lookup', False)\n    test_zero = kwargs.get('test_zero', False)\n    ret_val = None\n    if str(item).lower() == 'not defined':\n        return None\n    if value_lookup:\n        if not isinstance(item, list):\n            return 'Invalid Value'\n        ret_val = 0\n    else:\n        if not isinstance(item, int):\n            return 'Invalid Value'\n        ret_val = []\n    if 'lookup' in kwargs:\n        for (k, v) in kwargs['lookup'].items():\n            if value_lookup:\n                if str(v).lower() in [z.lower() for z in item]:\n                    ret_val = ret_val + k\n            else:\n                do_test = True\n                if not test_zero:\n                    if k == 0:\n                        do_test = False\n                if do_test and isinstance(k, int) and (item & k == k):\n                    ret_val.append(v)\n    else:\n        return 'Invalid Value'\n    return ret_val",
        "mutated": [
            "@classmethod\ndef _dict_lookup_bitwise_add(cls, item, **kwargs):\n    if False:\n        i = 10\n    '\\n        kwarg value_lookup bool to determine if item_list should be compared to keys\\n        or values\\n\\n        kwarg test_zero is used to determine if 0 should be tested when value_lookup is false\\n        lookup should be a dict with integers for keys\\n\\n        if value_lookup is True, item is expected to be a list\\n            the function will return the sum of the keys whose values are in the item list\\n        if value_lookup is False, item is expected to be an integer\\n            the function will return the values for the keys\\n            which successfully \"bitwise and\" with item\\n        '\n    value_lookup = kwargs.get('value_lookup', False)\n    test_zero = kwargs.get('test_zero', False)\n    ret_val = None\n    if str(item).lower() == 'not defined':\n        return None\n    if value_lookup:\n        if not isinstance(item, list):\n            return 'Invalid Value'\n        ret_val = 0\n    else:\n        if not isinstance(item, int):\n            return 'Invalid Value'\n        ret_val = []\n    if 'lookup' in kwargs:\n        for (k, v) in kwargs['lookup'].items():\n            if value_lookup:\n                if str(v).lower() in [z.lower() for z in item]:\n                    ret_val = ret_val + k\n            else:\n                do_test = True\n                if not test_zero:\n                    if k == 0:\n                        do_test = False\n                if do_test and isinstance(k, int) and (item & k == k):\n                    ret_val.append(v)\n    else:\n        return 'Invalid Value'\n    return ret_val",
            "@classmethod\ndef _dict_lookup_bitwise_add(cls, item, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        kwarg value_lookup bool to determine if item_list should be compared to keys\\n        or values\\n\\n        kwarg test_zero is used to determine if 0 should be tested when value_lookup is false\\n        lookup should be a dict with integers for keys\\n\\n        if value_lookup is True, item is expected to be a list\\n            the function will return the sum of the keys whose values are in the item list\\n        if value_lookup is False, item is expected to be an integer\\n            the function will return the values for the keys\\n            which successfully \"bitwise and\" with item\\n        '\n    value_lookup = kwargs.get('value_lookup', False)\n    test_zero = kwargs.get('test_zero', False)\n    ret_val = None\n    if str(item).lower() == 'not defined':\n        return None\n    if value_lookup:\n        if not isinstance(item, list):\n            return 'Invalid Value'\n        ret_val = 0\n    else:\n        if not isinstance(item, int):\n            return 'Invalid Value'\n        ret_val = []\n    if 'lookup' in kwargs:\n        for (k, v) in kwargs['lookup'].items():\n            if value_lookup:\n                if str(v).lower() in [z.lower() for z in item]:\n                    ret_val = ret_val + k\n            else:\n                do_test = True\n                if not test_zero:\n                    if k == 0:\n                        do_test = False\n                if do_test and isinstance(k, int) and (item & k == k):\n                    ret_val.append(v)\n    else:\n        return 'Invalid Value'\n    return ret_val",
            "@classmethod\ndef _dict_lookup_bitwise_add(cls, item, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        kwarg value_lookup bool to determine if item_list should be compared to keys\\n        or values\\n\\n        kwarg test_zero is used to determine if 0 should be tested when value_lookup is false\\n        lookup should be a dict with integers for keys\\n\\n        if value_lookup is True, item is expected to be a list\\n            the function will return the sum of the keys whose values are in the item list\\n        if value_lookup is False, item is expected to be an integer\\n            the function will return the values for the keys\\n            which successfully \"bitwise and\" with item\\n        '\n    value_lookup = kwargs.get('value_lookup', False)\n    test_zero = kwargs.get('test_zero', False)\n    ret_val = None\n    if str(item).lower() == 'not defined':\n        return None\n    if value_lookup:\n        if not isinstance(item, list):\n            return 'Invalid Value'\n        ret_val = 0\n    else:\n        if not isinstance(item, int):\n            return 'Invalid Value'\n        ret_val = []\n    if 'lookup' in kwargs:\n        for (k, v) in kwargs['lookup'].items():\n            if value_lookup:\n                if str(v).lower() in [z.lower() for z in item]:\n                    ret_val = ret_val + k\n            else:\n                do_test = True\n                if not test_zero:\n                    if k == 0:\n                        do_test = False\n                if do_test and isinstance(k, int) and (item & k == k):\n                    ret_val.append(v)\n    else:\n        return 'Invalid Value'\n    return ret_val",
            "@classmethod\ndef _dict_lookup_bitwise_add(cls, item, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        kwarg value_lookup bool to determine if item_list should be compared to keys\\n        or values\\n\\n        kwarg test_zero is used to determine if 0 should be tested when value_lookup is false\\n        lookup should be a dict with integers for keys\\n\\n        if value_lookup is True, item is expected to be a list\\n            the function will return the sum of the keys whose values are in the item list\\n        if value_lookup is False, item is expected to be an integer\\n            the function will return the values for the keys\\n            which successfully \"bitwise and\" with item\\n        '\n    value_lookup = kwargs.get('value_lookup', False)\n    test_zero = kwargs.get('test_zero', False)\n    ret_val = None\n    if str(item).lower() == 'not defined':\n        return None\n    if value_lookup:\n        if not isinstance(item, list):\n            return 'Invalid Value'\n        ret_val = 0\n    else:\n        if not isinstance(item, int):\n            return 'Invalid Value'\n        ret_val = []\n    if 'lookup' in kwargs:\n        for (k, v) in kwargs['lookup'].items():\n            if value_lookup:\n                if str(v).lower() in [z.lower() for z in item]:\n                    ret_val = ret_val + k\n            else:\n                do_test = True\n                if not test_zero:\n                    if k == 0:\n                        do_test = False\n                if do_test and isinstance(k, int) and (item & k == k):\n                    ret_val.append(v)\n    else:\n        return 'Invalid Value'\n    return ret_val",
            "@classmethod\ndef _dict_lookup_bitwise_add(cls, item, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        kwarg value_lookup bool to determine if item_list should be compared to keys\\n        or values\\n\\n        kwarg test_zero is used to determine if 0 should be tested when value_lookup is false\\n        lookup should be a dict with integers for keys\\n\\n        if value_lookup is True, item is expected to be a list\\n            the function will return the sum of the keys whose values are in the item list\\n        if value_lookup is False, item is expected to be an integer\\n            the function will return the values for the keys\\n            which successfully \"bitwise and\" with item\\n        '\n    value_lookup = kwargs.get('value_lookup', False)\n    test_zero = kwargs.get('test_zero', False)\n    ret_val = None\n    if str(item).lower() == 'not defined':\n        return None\n    if value_lookup:\n        if not isinstance(item, list):\n            return 'Invalid Value'\n        ret_val = 0\n    else:\n        if not isinstance(item, int):\n            return 'Invalid Value'\n        ret_val = []\n    if 'lookup' in kwargs:\n        for (k, v) in kwargs['lookup'].items():\n            if value_lookup:\n                if str(v).lower() in [z.lower() for z in item]:\n                    ret_val = ret_val + k\n            else:\n                do_test = True\n                if not test_zero:\n                    if k == 0:\n                        do_test = False\n                if do_test and isinstance(k, int) and (item & k == k):\n                    ret_val.append(v)\n    else:\n        return 'Invalid Value'\n    return ret_val"
        ]
    },
    {
        "func_name": "_multi_string_put_transform",
        "original": "@classmethod\ndef _multi_string_put_transform(cls, item, **kwargs):\n    \"\"\"\n        transform for setting REG_MULTI_SZ to properly handle \"Not Defined\"\n        \"\"\"\n    if isinstance(item, list):\n        return item\n    elif isinstance(item, str):\n        if item.lower() == 'not defined':\n            return None\n        else:\n            return item.split(',')\n    else:\n        return 'Invalid Value'",
        "mutated": [
            "@classmethod\ndef _multi_string_put_transform(cls, item, **kwargs):\n    if False:\n        i = 10\n    '\\n        transform for setting REG_MULTI_SZ to properly handle \"Not Defined\"\\n        '\n    if isinstance(item, list):\n        return item\n    elif isinstance(item, str):\n        if item.lower() == 'not defined':\n            return None\n        else:\n            return item.split(',')\n    else:\n        return 'Invalid Value'",
            "@classmethod\ndef _multi_string_put_transform(cls, item, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        transform for setting REG_MULTI_SZ to properly handle \"Not Defined\"\\n        '\n    if isinstance(item, list):\n        return item\n    elif isinstance(item, str):\n        if item.lower() == 'not defined':\n            return None\n        else:\n            return item.split(',')\n    else:\n        return 'Invalid Value'",
            "@classmethod\ndef _multi_string_put_transform(cls, item, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        transform for setting REG_MULTI_SZ to properly handle \"Not Defined\"\\n        '\n    if isinstance(item, list):\n        return item\n    elif isinstance(item, str):\n        if item.lower() == 'not defined':\n            return None\n        else:\n            return item.split(',')\n    else:\n        return 'Invalid Value'",
            "@classmethod\ndef _multi_string_put_transform(cls, item, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        transform for setting REG_MULTI_SZ to properly handle \"Not Defined\"\\n        '\n    if isinstance(item, list):\n        return item\n    elif isinstance(item, str):\n        if item.lower() == 'not defined':\n            return None\n        else:\n            return item.split(',')\n    else:\n        return 'Invalid Value'",
            "@classmethod\ndef _multi_string_put_transform(cls, item, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        transform for setting REG_MULTI_SZ to properly handle \"Not Defined\"\\n        '\n    if isinstance(item, list):\n        return item\n    elif isinstance(item, str):\n        if item.lower() == 'not defined':\n            return None\n        else:\n            return item.split(',')\n    else:\n        return 'Invalid Value'"
        ]
    },
    {
        "func_name": "_multi_string_get_transform",
        "original": "@classmethod\ndef _multi_string_get_transform(cls, item, **kwargs):\n    \"\"\"\n        transform for getting REG_MULTI_SZ to properly handle `None`\n        \"\"\"\n    if isinstance(item, list):\n        return item\n    elif item is None:\n        return 'Not Defined'\n    else:\n        return 'Invalid Value'",
        "mutated": [
            "@classmethod\ndef _multi_string_get_transform(cls, item, **kwargs):\n    if False:\n        i = 10\n    '\\n        transform for getting REG_MULTI_SZ to properly handle `None`\\n        '\n    if isinstance(item, list):\n        return item\n    elif item is None:\n        return 'Not Defined'\n    else:\n        return 'Invalid Value'",
            "@classmethod\ndef _multi_string_get_transform(cls, item, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        transform for getting REG_MULTI_SZ to properly handle `None`\\n        '\n    if isinstance(item, list):\n        return item\n    elif item is None:\n        return 'Not Defined'\n    else:\n        return 'Invalid Value'",
            "@classmethod\ndef _multi_string_get_transform(cls, item, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        transform for getting REG_MULTI_SZ to properly handle `None`\\n        '\n    if isinstance(item, list):\n        return item\n    elif item is None:\n        return 'Not Defined'\n    else:\n        return 'Invalid Value'",
            "@classmethod\ndef _multi_string_get_transform(cls, item, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        transform for getting REG_MULTI_SZ to properly handle `None`\\n        '\n    if isinstance(item, list):\n        return item\n    elif item is None:\n        return 'Not Defined'\n    else:\n        return 'Invalid Value'",
            "@classmethod\ndef _multi_string_get_transform(cls, item, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        transform for getting REG_MULTI_SZ to properly handle `None`\\n        '\n    if isinstance(item, list):\n        return item\n    elif item is None:\n        return 'Not Defined'\n    else:\n        return 'Invalid Value'"
        ]
    },
    {
        "func_name": "_string_put_transform",
        "original": "@classmethod\ndef _string_put_transform(cls, item, **kwargs):\n    \"\"\"\n        transform for a REG_SZ to properly handle \"Not Defined\"\n        \"\"\"\n    if isinstance(item, str):\n        if item.lower() == 'not defined':\n            return None\n        else:\n            return item",
        "mutated": [
            "@classmethod\ndef _string_put_transform(cls, item, **kwargs):\n    if False:\n        i = 10\n    '\\n        transform for a REG_SZ to properly handle \"Not Defined\"\\n        '\n    if isinstance(item, str):\n        if item.lower() == 'not defined':\n            return None\n        else:\n            return item",
            "@classmethod\ndef _string_put_transform(cls, item, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        transform for a REG_SZ to properly handle \"Not Defined\"\\n        '\n    if isinstance(item, str):\n        if item.lower() == 'not defined':\n            return None\n        else:\n            return item",
            "@classmethod\ndef _string_put_transform(cls, item, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        transform for a REG_SZ to properly handle \"Not Defined\"\\n        '\n    if isinstance(item, str):\n        if item.lower() == 'not defined':\n            return None\n        else:\n            return item",
            "@classmethod\ndef _string_put_transform(cls, item, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        transform for a REG_SZ to properly handle \"Not Defined\"\\n        '\n    if isinstance(item, str):\n        if item.lower() == 'not defined':\n            return None\n        else:\n            return item",
            "@classmethod\ndef _string_put_transform(cls, item, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        transform for a REG_SZ to properly handle \"Not Defined\"\\n        '\n    if isinstance(item, str):\n        if item.lower() == 'not defined':\n            return None\n        else:\n            return item"
        ]
    },
    {
        "func_name": "__virtual__",
        "original": "def __virtual__():\n    \"\"\"\n    Only works on Windows systems\n    \"\"\"\n    if not salt.utils.platform.is_windows():\n        return (False, 'win_lgpo: Not a Windows System')\n    if not HAS_WINDOWS_MODULES:\n        return (False, 'win_lgpo: Required modules failed to load')\n    return __virtualname__",
        "mutated": [
            "def __virtual__():\n    if False:\n        i = 10\n    '\\n    Only works on Windows systems\\n    '\n    if not salt.utils.platform.is_windows():\n        return (False, 'win_lgpo: Not a Windows System')\n    if not HAS_WINDOWS_MODULES:\n        return (False, 'win_lgpo: Required modules failed to load')\n    return __virtualname__",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Only works on Windows systems\\n    '\n    if not salt.utils.platform.is_windows():\n        return (False, 'win_lgpo: Not a Windows System')\n    if not HAS_WINDOWS_MODULES:\n        return (False, 'win_lgpo: Required modules failed to load')\n    return __virtualname__",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Only works on Windows systems\\n    '\n    if not salt.utils.platform.is_windows():\n        return (False, 'win_lgpo: Not a Windows System')\n    if not HAS_WINDOWS_MODULES:\n        return (False, 'win_lgpo: Required modules failed to load')\n    return __virtualname__",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Only works on Windows systems\\n    '\n    if not salt.utils.platform.is_windows():\n        return (False, 'win_lgpo: Not a Windows System')\n    if not HAS_WINDOWS_MODULES:\n        return (False, 'win_lgpo: Required modules failed to load')\n    return __virtualname__",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Only works on Windows systems\\n    '\n    if not salt.utils.platform.is_windows():\n        return (False, 'win_lgpo: Not a Windows System')\n    if not HAS_WINDOWS_MODULES:\n        return (False, 'win_lgpo: Required modules failed to load')\n    return __virtualname__"
        ]
    },
    {
        "func_name": "_updateNamespace",
        "original": "def _updateNamespace(item, new_namespace):\n    \"\"\"\n    helper function to recursively update the namespaces of an item\n    \"\"\"\n    temp_item = ''\n    i = item.tag.find('}')\n    if i >= 0:\n        temp_item = item.tag[i + 1:]\n    else:\n        temp_item = item.tag\n    item.tag = f'{{{new_namespace}}}{temp_item}'\n    for child in item.getiterator():\n        if isinstance(child.tag, str):\n            temp_item = ''\n            i = child.tag.find('}')\n            if i >= 0:\n                temp_item = child.tag[i + 1:]\n            else:\n                temp_item = child.tag\n            child.tag = f'{{{new_namespace}}}{temp_item}'\n    return item",
        "mutated": [
            "def _updateNamespace(item, new_namespace):\n    if False:\n        i = 10\n    '\\n    helper function to recursively update the namespaces of an item\\n    '\n    temp_item = ''\n    i = item.tag.find('}')\n    if i >= 0:\n        temp_item = item.tag[i + 1:]\n    else:\n        temp_item = item.tag\n    item.tag = f'{{{new_namespace}}}{temp_item}'\n    for child in item.getiterator():\n        if isinstance(child.tag, str):\n            temp_item = ''\n            i = child.tag.find('}')\n            if i >= 0:\n                temp_item = child.tag[i + 1:]\n            else:\n                temp_item = child.tag\n            child.tag = f'{{{new_namespace}}}{temp_item}'\n    return item",
            "def _updateNamespace(item, new_namespace):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    helper function to recursively update the namespaces of an item\\n    '\n    temp_item = ''\n    i = item.tag.find('}')\n    if i >= 0:\n        temp_item = item.tag[i + 1:]\n    else:\n        temp_item = item.tag\n    item.tag = f'{{{new_namespace}}}{temp_item}'\n    for child in item.getiterator():\n        if isinstance(child.tag, str):\n            temp_item = ''\n            i = child.tag.find('}')\n            if i >= 0:\n                temp_item = child.tag[i + 1:]\n            else:\n                temp_item = child.tag\n            child.tag = f'{{{new_namespace}}}{temp_item}'\n    return item",
            "def _updateNamespace(item, new_namespace):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    helper function to recursively update the namespaces of an item\\n    '\n    temp_item = ''\n    i = item.tag.find('}')\n    if i >= 0:\n        temp_item = item.tag[i + 1:]\n    else:\n        temp_item = item.tag\n    item.tag = f'{{{new_namespace}}}{temp_item}'\n    for child in item.getiterator():\n        if isinstance(child.tag, str):\n            temp_item = ''\n            i = child.tag.find('}')\n            if i >= 0:\n                temp_item = child.tag[i + 1:]\n            else:\n                temp_item = child.tag\n            child.tag = f'{{{new_namespace}}}{temp_item}'\n    return item",
            "def _updateNamespace(item, new_namespace):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    helper function to recursively update the namespaces of an item\\n    '\n    temp_item = ''\n    i = item.tag.find('}')\n    if i >= 0:\n        temp_item = item.tag[i + 1:]\n    else:\n        temp_item = item.tag\n    item.tag = f'{{{new_namespace}}}{temp_item}'\n    for child in item.getiterator():\n        if isinstance(child.tag, str):\n            temp_item = ''\n            i = child.tag.find('}')\n            if i >= 0:\n                temp_item = child.tag[i + 1:]\n            else:\n                temp_item = child.tag\n            child.tag = f'{{{new_namespace}}}{temp_item}'\n    return item",
            "def _updateNamespace(item, new_namespace):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    helper function to recursively update the namespaces of an item\\n    '\n    temp_item = ''\n    i = item.tag.find('}')\n    if i >= 0:\n        temp_item = item.tag[i + 1:]\n    else:\n        temp_item = item.tag\n    item.tag = f'{{{new_namespace}}}{temp_item}'\n    for child in item.getiterator():\n        if isinstance(child.tag, str):\n            temp_item = ''\n            i = child.tag.find('}')\n            if i >= 0:\n                temp_item = child.tag[i + 1:]\n            else:\n                temp_item = child.tag\n            child.tag = f'{{{new_namespace}}}{temp_item}'\n    return item"
        ]
    },
    {
        "func_name": "_updatePolicyElements",
        "original": "def _updatePolicyElements(policy_item, regkey):\n    \"\"\"\n    helper function to add the reg key to each policies element definitions if\n    the key attribute is not defined to make xpath searching easier for each\n    child in the policy <elements> item\n    \"\"\"\n    for child in policy_item.getiterator():\n        if 'valueName' in child.attrib:\n            if 'key' not in child.attrib:\n                child.attrib['key'] = regkey\n    return policy_item",
        "mutated": [
            "def _updatePolicyElements(policy_item, regkey):\n    if False:\n        i = 10\n    '\\n    helper function to add the reg key to each policies element definitions if\\n    the key attribute is not defined to make xpath searching easier for each\\n    child in the policy <elements> item\\n    '\n    for child in policy_item.getiterator():\n        if 'valueName' in child.attrib:\n            if 'key' not in child.attrib:\n                child.attrib['key'] = regkey\n    return policy_item",
            "def _updatePolicyElements(policy_item, regkey):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    helper function to add the reg key to each policies element definitions if\\n    the key attribute is not defined to make xpath searching easier for each\\n    child in the policy <elements> item\\n    '\n    for child in policy_item.getiterator():\n        if 'valueName' in child.attrib:\n            if 'key' not in child.attrib:\n                child.attrib['key'] = regkey\n    return policy_item",
            "def _updatePolicyElements(policy_item, regkey):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    helper function to add the reg key to each policies element definitions if\\n    the key attribute is not defined to make xpath searching easier for each\\n    child in the policy <elements> item\\n    '\n    for child in policy_item.getiterator():\n        if 'valueName' in child.attrib:\n            if 'key' not in child.attrib:\n                child.attrib['key'] = regkey\n    return policy_item",
            "def _updatePolicyElements(policy_item, regkey):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    helper function to add the reg key to each policies element definitions if\\n    the key attribute is not defined to make xpath searching easier for each\\n    child in the policy <elements> item\\n    '\n    for child in policy_item.getiterator():\n        if 'valueName' in child.attrib:\n            if 'key' not in child.attrib:\n                child.attrib['key'] = regkey\n    return policy_item",
            "def _updatePolicyElements(policy_item, regkey):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    helper function to add the reg key to each policies element definitions if\\n    the key attribute is not defined to make xpath searching easier for each\\n    child in the policy <elements> item\\n    '\n    for child in policy_item.getiterator():\n        if 'valueName' in child.attrib:\n            if 'key' not in child.attrib:\n                child.attrib['key'] = regkey\n    return policy_item"
        ]
    },
    {
        "func_name": "_remove_unicode_encoding",
        "original": "def _remove_unicode_encoding(xml_file):\n    \"\"\"\n    attempts to remove the \"encoding='unicode'\" from an xml file\n    as lxml does not support that on a windows node currently\n\n    see issue #38100 (Search.adml)\n\n    For some reason this file is encoded 'utf-16'\n    \"\"\"\n    with salt.utils.files.fopen(xml_file, 'rb') as f:\n        xml_content = f.read()\n    modified_xml = re.sub(' encoding=[\\\\\\'\"]+unicode[\\\\\\'\"]+', '', xml_content.decode('utf-16'), count=1)\n    xml_tree = lxml.etree.parse(io.StringIO(modified_xml))\n    return xml_tree",
        "mutated": [
            "def _remove_unicode_encoding(xml_file):\n    if False:\n        i = 10\n    '\\n    attempts to remove the \"encoding=\\'unicode\\'\" from an xml file\\n    as lxml does not support that on a windows node currently\\n\\n    see issue #38100 (Search.adml)\\n\\n    For some reason this file is encoded \\'utf-16\\'\\n    '\n    with salt.utils.files.fopen(xml_file, 'rb') as f:\n        xml_content = f.read()\n    modified_xml = re.sub(' encoding=[\\\\\\'\"]+unicode[\\\\\\'\"]+', '', xml_content.decode('utf-16'), count=1)\n    xml_tree = lxml.etree.parse(io.StringIO(modified_xml))\n    return xml_tree",
            "def _remove_unicode_encoding(xml_file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    attempts to remove the \"encoding=\\'unicode\\'\" from an xml file\\n    as lxml does not support that on a windows node currently\\n\\n    see issue #38100 (Search.adml)\\n\\n    For some reason this file is encoded \\'utf-16\\'\\n    '\n    with salt.utils.files.fopen(xml_file, 'rb') as f:\n        xml_content = f.read()\n    modified_xml = re.sub(' encoding=[\\\\\\'\"]+unicode[\\\\\\'\"]+', '', xml_content.decode('utf-16'), count=1)\n    xml_tree = lxml.etree.parse(io.StringIO(modified_xml))\n    return xml_tree",
            "def _remove_unicode_encoding(xml_file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    attempts to remove the \"encoding=\\'unicode\\'\" from an xml file\\n    as lxml does not support that on a windows node currently\\n\\n    see issue #38100 (Search.adml)\\n\\n    For some reason this file is encoded \\'utf-16\\'\\n    '\n    with salt.utils.files.fopen(xml_file, 'rb') as f:\n        xml_content = f.read()\n    modified_xml = re.sub(' encoding=[\\\\\\'\"]+unicode[\\\\\\'\"]+', '', xml_content.decode('utf-16'), count=1)\n    xml_tree = lxml.etree.parse(io.StringIO(modified_xml))\n    return xml_tree",
            "def _remove_unicode_encoding(xml_file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    attempts to remove the \"encoding=\\'unicode\\'\" from an xml file\\n    as lxml does not support that on a windows node currently\\n\\n    see issue #38100 (Search.adml)\\n\\n    For some reason this file is encoded \\'utf-16\\'\\n    '\n    with salt.utils.files.fopen(xml_file, 'rb') as f:\n        xml_content = f.read()\n    modified_xml = re.sub(' encoding=[\\\\\\'\"]+unicode[\\\\\\'\"]+', '', xml_content.decode('utf-16'), count=1)\n    xml_tree = lxml.etree.parse(io.StringIO(modified_xml))\n    return xml_tree",
            "def _remove_unicode_encoding(xml_file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    attempts to remove the \"encoding=\\'unicode\\'\" from an xml file\\n    as lxml does not support that on a windows node currently\\n\\n    see issue #38100 (Search.adml)\\n\\n    For some reason this file is encoded \\'utf-16\\'\\n    '\n    with salt.utils.files.fopen(xml_file, 'rb') as f:\n        xml_content = f.read()\n    modified_xml = re.sub(' encoding=[\\\\\\'\"]+unicode[\\\\\\'\"]+', '', xml_content.decode('utf-16'), count=1)\n    xml_tree = lxml.etree.parse(io.StringIO(modified_xml))\n    return xml_tree"
        ]
    },
    {
        "func_name": "_remove_invalid_xmlns",
        "original": "def _remove_invalid_xmlns(xml_file):\n    \"\"\"\n    Attempts to remove an invalid xmlns entry in newer versions of\n    WindowsDefender.adml\n\n    xmlns=\"http://schemas.microsoft.com/GroupPolicy/2006/07/PolicyDefinitions\"\n\n    For some reason this file is encoded 'utf-8'\n    \"\"\"\n    with salt.utils.files.fopen(xml_file, 'rb') as f:\n        xml_content = f.read()\n    modified_xml = re.sub(' xmlns=[\\\\\\'\"]+.*[\\\\\\'\"]+', '', xml_content.decode('utf-8'), count=1)\n    xml_tree = lxml.etree.parse(io.StringIO(modified_xml))\n    return xml_tree",
        "mutated": [
            "def _remove_invalid_xmlns(xml_file):\n    if False:\n        i = 10\n    '\\n    Attempts to remove an invalid xmlns entry in newer versions of\\n    WindowsDefender.adml\\n\\n    xmlns=\"http://schemas.microsoft.com/GroupPolicy/2006/07/PolicyDefinitions\"\\n\\n    For some reason this file is encoded \\'utf-8\\'\\n    '\n    with salt.utils.files.fopen(xml_file, 'rb') as f:\n        xml_content = f.read()\n    modified_xml = re.sub(' xmlns=[\\\\\\'\"]+.*[\\\\\\'\"]+', '', xml_content.decode('utf-8'), count=1)\n    xml_tree = lxml.etree.parse(io.StringIO(modified_xml))\n    return xml_tree",
            "def _remove_invalid_xmlns(xml_file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Attempts to remove an invalid xmlns entry in newer versions of\\n    WindowsDefender.adml\\n\\n    xmlns=\"http://schemas.microsoft.com/GroupPolicy/2006/07/PolicyDefinitions\"\\n\\n    For some reason this file is encoded \\'utf-8\\'\\n    '\n    with salt.utils.files.fopen(xml_file, 'rb') as f:\n        xml_content = f.read()\n    modified_xml = re.sub(' xmlns=[\\\\\\'\"]+.*[\\\\\\'\"]+', '', xml_content.decode('utf-8'), count=1)\n    xml_tree = lxml.etree.parse(io.StringIO(modified_xml))\n    return xml_tree",
            "def _remove_invalid_xmlns(xml_file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Attempts to remove an invalid xmlns entry in newer versions of\\n    WindowsDefender.adml\\n\\n    xmlns=\"http://schemas.microsoft.com/GroupPolicy/2006/07/PolicyDefinitions\"\\n\\n    For some reason this file is encoded \\'utf-8\\'\\n    '\n    with salt.utils.files.fopen(xml_file, 'rb') as f:\n        xml_content = f.read()\n    modified_xml = re.sub(' xmlns=[\\\\\\'\"]+.*[\\\\\\'\"]+', '', xml_content.decode('utf-8'), count=1)\n    xml_tree = lxml.etree.parse(io.StringIO(modified_xml))\n    return xml_tree",
            "def _remove_invalid_xmlns(xml_file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Attempts to remove an invalid xmlns entry in newer versions of\\n    WindowsDefender.adml\\n\\n    xmlns=\"http://schemas.microsoft.com/GroupPolicy/2006/07/PolicyDefinitions\"\\n\\n    For some reason this file is encoded \\'utf-8\\'\\n    '\n    with salt.utils.files.fopen(xml_file, 'rb') as f:\n        xml_content = f.read()\n    modified_xml = re.sub(' xmlns=[\\\\\\'\"]+.*[\\\\\\'\"]+', '', xml_content.decode('utf-8'), count=1)\n    xml_tree = lxml.etree.parse(io.StringIO(modified_xml))\n    return xml_tree",
            "def _remove_invalid_xmlns(xml_file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Attempts to remove an invalid xmlns entry in newer versions of\\n    WindowsDefender.adml\\n\\n    xmlns=\"http://schemas.microsoft.com/GroupPolicy/2006/07/PolicyDefinitions\"\\n\\n    For some reason this file is encoded \\'utf-8\\'\\n    '\n    with salt.utils.files.fopen(xml_file, 'rb') as f:\n        xml_content = f.read()\n    modified_xml = re.sub(' xmlns=[\\\\\\'\"]+.*[\\\\\\'\"]+', '', xml_content.decode('utf-8'), count=1)\n    xml_tree = lxml.etree.parse(io.StringIO(modified_xml))\n    return xml_tree"
        ]
    },
    {
        "func_name": "_parse_xml",
        "original": "def _parse_xml(adm_file):\n    \"\"\"\n    Parse the admx/adml file. There are 3 scenarios (so far) that we'll likely\n    encounter:\n\n    1. Valid File\n    2. invalid encoding (encoding=\"unicode\") which the lxml library doesn't\n       recognize\n    3. invalid xmlns entry in the xml header, which the lxml library doesn't\n       recognize\n    \"\"\"\n    parser = lxml.etree.XMLParser(remove_comments=True)\n    modified_xml = ''\n    with salt.utils.files.fopen(adm_file, 'rb') as rfh:\n        file_hash = f'{zlib.crc32(rfh.read()) & 4294967295:X}'\n    (name, ext) = os.path.splitext(os.path.basename(adm_file))\n    hashed_filename = f'{name}-{file_hash}{ext}'\n    cache_dir = os.path.join(__opts__['cachedir'], 'lgpo', 'policy_defs')\n    if not os.path.exists(cache_dir):\n        os.makedirs(cache_dir)\n    out_file = os.path.join(cache_dir, hashed_filename)\n    if not os.path.isfile(out_file):\n        log.debug('LGPO: Generating policy template cache for %s%s', name, ext)\n        file_list = glob.glob(os.path.join(cache_dir, f'{name}*{ext}'))\n        for file_path in file_list:\n            os.remove(file_path)\n        with salt.utils.files.fopen(adm_file, 'rb') as rfh:\n            encoding = 'utf-8'\n            raw = rfh.read()\n            try:\n                raw = raw.decode(encoding)\n            except UnicodeDecodeError:\n                log.trace('LGPO: Detecting encoding')\n                encoding = 'utf-16'\n                raw = raw.decode(encoding)\n            for line in raw.split('\\r\\n'):\n                if 'key=\"' in line:\n                    start = line.index('key=\"')\n                    q1 = line[start:].index('\"') + start\n                    q2 = line[q1 + 1:].index('\"') + q1 + 1\n                    line = line.replace(line[start:q2], line[start:q2].lower())\n                    found_key = True\n                modified_xml += line + '\\r\\n'\n        modified_xml = modified_xml.replace('\u201c', '\"').replace('\u201d', '\"')\n        modified_xml = modified_xml.replace('\u2018', \"'\").replace('\u2019', \"'\")\n        modified_xml = modified_xml.replace('\u2013', '-').replace('\u2014', '-')\n        with salt.utils.files.fopen(out_file, 'wb') as wfh:\n            wfh.write(modified_xml.encode(encoding))\n    try:\n        xml_tree = lxml.etree.parse(out_file, parser=parser)\n    except lxml.etree.XMLSyntaxError:\n        try:\n            xml_tree = _remove_unicode_encoding(out_file)\n        except lxml.etree.XMLSyntaxError:\n            xml_tree = _remove_invalid_xmlns(out_file)\n    return xml_tree",
        "mutated": [
            "def _parse_xml(adm_file):\n    if False:\n        i = 10\n    '\\n    Parse the admx/adml file. There are 3 scenarios (so far) that we\\'ll likely\\n    encounter:\\n\\n    1. Valid File\\n    2. invalid encoding (encoding=\"unicode\") which the lxml library doesn\\'t\\n       recognize\\n    3. invalid xmlns entry in the xml header, which the lxml library doesn\\'t\\n       recognize\\n    '\n    parser = lxml.etree.XMLParser(remove_comments=True)\n    modified_xml = ''\n    with salt.utils.files.fopen(adm_file, 'rb') as rfh:\n        file_hash = f'{zlib.crc32(rfh.read()) & 4294967295:X}'\n    (name, ext) = os.path.splitext(os.path.basename(adm_file))\n    hashed_filename = f'{name}-{file_hash}{ext}'\n    cache_dir = os.path.join(__opts__['cachedir'], 'lgpo', 'policy_defs')\n    if not os.path.exists(cache_dir):\n        os.makedirs(cache_dir)\n    out_file = os.path.join(cache_dir, hashed_filename)\n    if not os.path.isfile(out_file):\n        log.debug('LGPO: Generating policy template cache for %s%s', name, ext)\n        file_list = glob.glob(os.path.join(cache_dir, f'{name}*{ext}'))\n        for file_path in file_list:\n            os.remove(file_path)\n        with salt.utils.files.fopen(adm_file, 'rb') as rfh:\n            encoding = 'utf-8'\n            raw = rfh.read()\n            try:\n                raw = raw.decode(encoding)\n            except UnicodeDecodeError:\n                log.trace('LGPO: Detecting encoding')\n                encoding = 'utf-16'\n                raw = raw.decode(encoding)\n            for line in raw.split('\\r\\n'):\n                if 'key=\"' in line:\n                    start = line.index('key=\"')\n                    q1 = line[start:].index('\"') + start\n                    q2 = line[q1 + 1:].index('\"') + q1 + 1\n                    line = line.replace(line[start:q2], line[start:q2].lower())\n                    found_key = True\n                modified_xml += line + '\\r\\n'\n        modified_xml = modified_xml.replace('\u201c', '\"').replace('\u201d', '\"')\n        modified_xml = modified_xml.replace('\u2018', \"'\").replace('\u2019', \"'\")\n        modified_xml = modified_xml.replace('\u2013', '-').replace('\u2014', '-')\n        with salt.utils.files.fopen(out_file, 'wb') as wfh:\n            wfh.write(modified_xml.encode(encoding))\n    try:\n        xml_tree = lxml.etree.parse(out_file, parser=parser)\n    except lxml.etree.XMLSyntaxError:\n        try:\n            xml_tree = _remove_unicode_encoding(out_file)\n        except lxml.etree.XMLSyntaxError:\n            xml_tree = _remove_invalid_xmlns(out_file)\n    return xml_tree",
            "def _parse_xml(adm_file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Parse the admx/adml file. There are 3 scenarios (so far) that we\\'ll likely\\n    encounter:\\n\\n    1. Valid File\\n    2. invalid encoding (encoding=\"unicode\") which the lxml library doesn\\'t\\n       recognize\\n    3. invalid xmlns entry in the xml header, which the lxml library doesn\\'t\\n       recognize\\n    '\n    parser = lxml.etree.XMLParser(remove_comments=True)\n    modified_xml = ''\n    with salt.utils.files.fopen(adm_file, 'rb') as rfh:\n        file_hash = f'{zlib.crc32(rfh.read()) & 4294967295:X}'\n    (name, ext) = os.path.splitext(os.path.basename(adm_file))\n    hashed_filename = f'{name}-{file_hash}{ext}'\n    cache_dir = os.path.join(__opts__['cachedir'], 'lgpo', 'policy_defs')\n    if not os.path.exists(cache_dir):\n        os.makedirs(cache_dir)\n    out_file = os.path.join(cache_dir, hashed_filename)\n    if not os.path.isfile(out_file):\n        log.debug('LGPO: Generating policy template cache for %s%s', name, ext)\n        file_list = glob.glob(os.path.join(cache_dir, f'{name}*{ext}'))\n        for file_path in file_list:\n            os.remove(file_path)\n        with salt.utils.files.fopen(adm_file, 'rb') as rfh:\n            encoding = 'utf-8'\n            raw = rfh.read()\n            try:\n                raw = raw.decode(encoding)\n            except UnicodeDecodeError:\n                log.trace('LGPO: Detecting encoding')\n                encoding = 'utf-16'\n                raw = raw.decode(encoding)\n            for line in raw.split('\\r\\n'):\n                if 'key=\"' in line:\n                    start = line.index('key=\"')\n                    q1 = line[start:].index('\"') + start\n                    q2 = line[q1 + 1:].index('\"') + q1 + 1\n                    line = line.replace(line[start:q2], line[start:q2].lower())\n                    found_key = True\n                modified_xml += line + '\\r\\n'\n        modified_xml = modified_xml.replace('\u201c', '\"').replace('\u201d', '\"')\n        modified_xml = modified_xml.replace('\u2018', \"'\").replace('\u2019', \"'\")\n        modified_xml = modified_xml.replace('\u2013', '-').replace('\u2014', '-')\n        with salt.utils.files.fopen(out_file, 'wb') as wfh:\n            wfh.write(modified_xml.encode(encoding))\n    try:\n        xml_tree = lxml.etree.parse(out_file, parser=parser)\n    except lxml.etree.XMLSyntaxError:\n        try:\n            xml_tree = _remove_unicode_encoding(out_file)\n        except lxml.etree.XMLSyntaxError:\n            xml_tree = _remove_invalid_xmlns(out_file)\n    return xml_tree",
            "def _parse_xml(adm_file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Parse the admx/adml file. There are 3 scenarios (so far) that we\\'ll likely\\n    encounter:\\n\\n    1. Valid File\\n    2. invalid encoding (encoding=\"unicode\") which the lxml library doesn\\'t\\n       recognize\\n    3. invalid xmlns entry in the xml header, which the lxml library doesn\\'t\\n       recognize\\n    '\n    parser = lxml.etree.XMLParser(remove_comments=True)\n    modified_xml = ''\n    with salt.utils.files.fopen(adm_file, 'rb') as rfh:\n        file_hash = f'{zlib.crc32(rfh.read()) & 4294967295:X}'\n    (name, ext) = os.path.splitext(os.path.basename(adm_file))\n    hashed_filename = f'{name}-{file_hash}{ext}'\n    cache_dir = os.path.join(__opts__['cachedir'], 'lgpo', 'policy_defs')\n    if not os.path.exists(cache_dir):\n        os.makedirs(cache_dir)\n    out_file = os.path.join(cache_dir, hashed_filename)\n    if not os.path.isfile(out_file):\n        log.debug('LGPO: Generating policy template cache for %s%s', name, ext)\n        file_list = glob.glob(os.path.join(cache_dir, f'{name}*{ext}'))\n        for file_path in file_list:\n            os.remove(file_path)\n        with salt.utils.files.fopen(adm_file, 'rb') as rfh:\n            encoding = 'utf-8'\n            raw = rfh.read()\n            try:\n                raw = raw.decode(encoding)\n            except UnicodeDecodeError:\n                log.trace('LGPO: Detecting encoding')\n                encoding = 'utf-16'\n                raw = raw.decode(encoding)\n            for line in raw.split('\\r\\n'):\n                if 'key=\"' in line:\n                    start = line.index('key=\"')\n                    q1 = line[start:].index('\"') + start\n                    q2 = line[q1 + 1:].index('\"') + q1 + 1\n                    line = line.replace(line[start:q2], line[start:q2].lower())\n                    found_key = True\n                modified_xml += line + '\\r\\n'\n        modified_xml = modified_xml.replace('\u201c', '\"').replace('\u201d', '\"')\n        modified_xml = modified_xml.replace('\u2018', \"'\").replace('\u2019', \"'\")\n        modified_xml = modified_xml.replace('\u2013', '-').replace('\u2014', '-')\n        with salt.utils.files.fopen(out_file, 'wb') as wfh:\n            wfh.write(modified_xml.encode(encoding))\n    try:\n        xml_tree = lxml.etree.parse(out_file, parser=parser)\n    except lxml.etree.XMLSyntaxError:\n        try:\n            xml_tree = _remove_unicode_encoding(out_file)\n        except lxml.etree.XMLSyntaxError:\n            xml_tree = _remove_invalid_xmlns(out_file)\n    return xml_tree",
            "def _parse_xml(adm_file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Parse the admx/adml file. There are 3 scenarios (so far) that we\\'ll likely\\n    encounter:\\n\\n    1. Valid File\\n    2. invalid encoding (encoding=\"unicode\") which the lxml library doesn\\'t\\n       recognize\\n    3. invalid xmlns entry in the xml header, which the lxml library doesn\\'t\\n       recognize\\n    '\n    parser = lxml.etree.XMLParser(remove_comments=True)\n    modified_xml = ''\n    with salt.utils.files.fopen(adm_file, 'rb') as rfh:\n        file_hash = f'{zlib.crc32(rfh.read()) & 4294967295:X}'\n    (name, ext) = os.path.splitext(os.path.basename(adm_file))\n    hashed_filename = f'{name}-{file_hash}{ext}'\n    cache_dir = os.path.join(__opts__['cachedir'], 'lgpo', 'policy_defs')\n    if not os.path.exists(cache_dir):\n        os.makedirs(cache_dir)\n    out_file = os.path.join(cache_dir, hashed_filename)\n    if not os.path.isfile(out_file):\n        log.debug('LGPO: Generating policy template cache for %s%s', name, ext)\n        file_list = glob.glob(os.path.join(cache_dir, f'{name}*{ext}'))\n        for file_path in file_list:\n            os.remove(file_path)\n        with salt.utils.files.fopen(adm_file, 'rb') as rfh:\n            encoding = 'utf-8'\n            raw = rfh.read()\n            try:\n                raw = raw.decode(encoding)\n            except UnicodeDecodeError:\n                log.trace('LGPO: Detecting encoding')\n                encoding = 'utf-16'\n                raw = raw.decode(encoding)\n            for line in raw.split('\\r\\n'):\n                if 'key=\"' in line:\n                    start = line.index('key=\"')\n                    q1 = line[start:].index('\"') + start\n                    q2 = line[q1 + 1:].index('\"') + q1 + 1\n                    line = line.replace(line[start:q2], line[start:q2].lower())\n                    found_key = True\n                modified_xml += line + '\\r\\n'\n        modified_xml = modified_xml.replace('\u201c', '\"').replace('\u201d', '\"')\n        modified_xml = modified_xml.replace('\u2018', \"'\").replace('\u2019', \"'\")\n        modified_xml = modified_xml.replace('\u2013', '-').replace('\u2014', '-')\n        with salt.utils.files.fopen(out_file, 'wb') as wfh:\n            wfh.write(modified_xml.encode(encoding))\n    try:\n        xml_tree = lxml.etree.parse(out_file, parser=parser)\n    except lxml.etree.XMLSyntaxError:\n        try:\n            xml_tree = _remove_unicode_encoding(out_file)\n        except lxml.etree.XMLSyntaxError:\n            xml_tree = _remove_invalid_xmlns(out_file)\n    return xml_tree",
            "def _parse_xml(adm_file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Parse the admx/adml file. There are 3 scenarios (so far) that we\\'ll likely\\n    encounter:\\n\\n    1. Valid File\\n    2. invalid encoding (encoding=\"unicode\") which the lxml library doesn\\'t\\n       recognize\\n    3. invalid xmlns entry in the xml header, which the lxml library doesn\\'t\\n       recognize\\n    '\n    parser = lxml.etree.XMLParser(remove_comments=True)\n    modified_xml = ''\n    with salt.utils.files.fopen(adm_file, 'rb') as rfh:\n        file_hash = f'{zlib.crc32(rfh.read()) & 4294967295:X}'\n    (name, ext) = os.path.splitext(os.path.basename(adm_file))\n    hashed_filename = f'{name}-{file_hash}{ext}'\n    cache_dir = os.path.join(__opts__['cachedir'], 'lgpo', 'policy_defs')\n    if not os.path.exists(cache_dir):\n        os.makedirs(cache_dir)\n    out_file = os.path.join(cache_dir, hashed_filename)\n    if not os.path.isfile(out_file):\n        log.debug('LGPO: Generating policy template cache for %s%s', name, ext)\n        file_list = glob.glob(os.path.join(cache_dir, f'{name}*{ext}'))\n        for file_path in file_list:\n            os.remove(file_path)\n        with salt.utils.files.fopen(adm_file, 'rb') as rfh:\n            encoding = 'utf-8'\n            raw = rfh.read()\n            try:\n                raw = raw.decode(encoding)\n            except UnicodeDecodeError:\n                log.trace('LGPO: Detecting encoding')\n                encoding = 'utf-16'\n                raw = raw.decode(encoding)\n            for line in raw.split('\\r\\n'):\n                if 'key=\"' in line:\n                    start = line.index('key=\"')\n                    q1 = line[start:].index('\"') + start\n                    q2 = line[q1 + 1:].index('\"') + q1 + 1\n                    line = line.replace(line[start:q2], line[start:q2].lower())\n                    found_key = True\n                modified_xml += line + '\\r\\n'\n        modified_xml = modified_xml.replace('\u201c', '\"').replace('\u201d', '\"')\n        modified_xml = modified_xml.replace('\u2018', \"'\").replace('\u2019', \"'\")\n        modified_xml = modified_xml.replace('\u2013', '-').replace('\u2014', '-')\n        with salt.utils.files.fopen(out_file, 'wb') as wfh:\n            wfh.write(modified_xml.encode(encoding))\n    try:\n        xml_tree = lxml.etree.parse(out_file, parser=parser)\n    except lxml.etree.XMLSyntaxError:\n        try:\n            xml_tree = _remove_unicode_encoding(out_file)\n        except lxml.etree.XMLSyntaxError:\n            xml_tree = _remove_invalid_xmlns(out_file)\n    return xml_tree"
        ]
    },
    {
        "func_name": "_load_policy_definitions",
        "original": "def _load_policy_definitions(path='c:\\\\Windows\\\\PolicyDefinitions', language='en-US'):\n    \"\"\"\n    helper function to process all ADMX files in the specified policy_def_path\n    and build a single XML doc that we can search/use for ADMX policy processing\n    \"\"\"\n    display_language_fallback = INSTALL_LANGUAGE\n    t_policy_definitions = lxml.etree.Element('policyDefinitions')\n    t_policy_definitions.append(lxml.etree.Element('categories'))\n    t_policy_definitions.append(lxml.etree.Element('policies'))\n    t_policy_definitions.append(lxml.etree.Element('policyNamespaces'))\n    t_policy_definition_resources = lxml.etree.Element('policyDefinitionResources')\n    policydefs_policies_xpath = etree.XPath('/policyDefinitions/policies')\n    policydefs_categories_xpath = etree.XPath('/policyDefinitions/categories')\n    policydefs_policyns_xpath = etree.XPath('/policyDefinitions/policyNamespaces')\n    policydefs_resources_localname_xpath = etree.XPath('//*[local-name() = \"policyDefinitionResources\"]/*')\n    policydef_resources_xpath = etree.XPath('/policyDefinitionResources')\n    for (root, dirs, files) in salt.utils.path.os_walk(path):\n        if root == path:\n            for t_admx_file in files:\n                (admx_file_name, admx_file_ext) = os.path.splitext(t_admx_file)\n                if not admx_file_ext == '.admx':\n                    log.debug('%s is not an ADMX file', t_admx_file)\n                    continue\n                admx_file = os.path.join(root, t_admx_file)\n                try:\n                    xml_tree = _parse_xml(admx_file)\n                except lxml.etree.XMLSyntaxError:\n                    log.error('An error was found while processing admx file %s, all policies from this file will be unavailable via this module', admx_file)\n                    continue\n                namespaces = xml_tree.getroot().nsmap\n                namespace_string = ''\n                if None in namespaces:\n                    namespaces['None'] = namespaces[None]\n                    namespaces.pop(None)\n                    namespace_string = 'None:'\n                this_namespace = xml_tree.xpath('/{0}policyDefinitions/{0}policyNamespaces/{0}target/@namespace'.format(namespace_string), namespaces=namespaces)[0]\n                categories = xml_tree.xpath('/{0}policyDefinitions/{0}categories/{0}category'.format(namespace_string), namespaces=namespaces)\n                for category in categories:\n                    temp_cat = category\n                    temp_cat = _updateNamespace(temp_cat, this_namespace)\n                    policydefs_categories_xpath(t_policy_definitions)[0].append(temp_cat)\n                policies = xml_tree.xpath('/{0}policyDefinitions/{0}policies/{0}policy'.format(namespace_string), namespaces=namespaces)\n                for policy in policies:\n                    temp_pol = policy\n                    temp_pol = _updateNamespace(temp_pol, this_namespace)\n                    if 'key' in temp_pol.attrib:\n                        temp_pol = _updatePolicyElements(temp_pol, temp_pol.attrib['key'])\n                    policydefs_policies_xpath(t_policy_definitions)[0].append(temp_pol)\n                policy_namespaces = xml_tree.xpath('/{0}policyDefinitions/{0}policyNamespaces/{0}*'.format(namespace_string), namespaces=namespaces)\n                for policy_ns in policy_namespaces:\n                    temp_ns = policy_ns\n                    temp_ns = _updateNamespace(temp_ns, this_namespace)\n                    policydefs_policyns_xpath(t_policy_definitions)[0].append(temp_ns)\n                adml_file = os.path.join(root, language, admx_file_name + '.adml')\n                if not __salt__['file.file_exists'](adml_file):\n                    log.info('An ADML file in the specified ADML language \"%s\" does not exist for the ADMX \"%s\", the the abbreviated language code will be tried.', language, t_admx_file)\n                    adml_file = os.path.join(root, language.split('-')[0], admx_file_name + '.adml')\n                    if not __salt__['file.file_exists'](adml_file):\n                        log.info('An ADML file in the specified ADML language code %s does not exist for the ADMX \"%s\", the fallback language will be tried.', language[:2], t_admx_file)\n                        adml_file = os.path.join(root, display_language_fallback, admx_file_name + '.adml')\n                        if not __salt__['file.file_exists'](adml_file):\n                            log.info('An ADML file in the specified ADML fallback language \"%s\" does not exist for the ADMX \"%s\" the abbreviated fallback language code will be tried.', display_language_fallback, t_admx_file)\n                            adml_file = os.path.join(root, display_language_fallback.split('-')[0], admx_file_name + '.adml')\n                            if not __salt__['file.file_exists'](adml_file):\n                                raise SaltInvocationError('An ADML file in the specified ADML language \"{}\" and the fallback language \"{}\" do not exist for the ADMX \"{}\".'.format(language, display_language_fallback, t_admx_file))\n                try:\n                    xml_tree = _parse_xml(adml_file)\n                except lxml.etree.XMLSyntaxError:\n                    log.error('An error was found while processing adml file %s, all policies from this file will be unavailable via this module', adml_file)\n                    continue\n                if None in namespaces:\n                    namespaces['None'] = namespaces[None]\n                    namespaces.pop(None)\n                policydefs_resources = policydefs_resources_localname_xpath(xml_tree)\n                for policydefs_resource in policydefs_resources:\n                    t_poldef = policydefs_resource\n                    t_poldef = _updateNamespace(t_poldef, this_namespace)\n                    policydef_resources_xpath(t_policy_definition_resources)[0].append(t_poldef)\n    __context__['lgpo.policy_definitions'] = t_policy_definitions\n    __context__['lgpo.policy_resources'] = t_policy_definition_resources",
        "mutated": [
            "def _load_policy_definitions(path='c:\\\\Windows\\\\PolicyDefinitions', language='en-US'):\n    if False:\n        i = 10\n    '\\n    helper function to process all ADMX files in the specified policy_def_path\\n    and build a single XML doc that we can search/use for ADMX policy processing\\n    '\n    display_language_fallback = INSTALL_LANGUAGE\n    t_policy_definitions = lxml.etree.Element('policyDefinitions')\n    t_policy_definitions.append(lxml.etree.Element('categories'))\n    t_policy_definitions.append(lxml.etree.Element('policies'))\n    t_policy_definitions.append(lxml.etree.Element('policyNamespaces'))\n    t_policy_definition_resources = lxml.etree.Element('policyDefinitionResources')\n    policydefs_policies_xpath = etree.XPath('/policyDefinitions/policies')\n    policydefs_categories_xpath = etree.XPath('/policyDefinitions/categories')\n    policydefs_policyns_xpath = etree.XPath('/policyDefinitions/policyNamespaces')\n    policydefs_resources_localname_xpath = etree.XPath('//*[local-name() = \"policyDefinitionResources\"]/*')\n    policydef_resources_xpath = etree.XPath('/policyDefinitionResources')\n    for (root, dirs, files) in salt.utils.path.os_walk(path):\n        if root == path:\n            for t_admx_file in files:\n                (admx_file_name, admx_file_ext) = os.path.splitext(t_admx_file)\n                if not admx_file_ext == '.admx':\n                    log.debug('%s is not an ADMX file', t_admx_file)\n                    continue\n                admx_file = os.path.join(root, t_admx_file)\n                try:\n                    xml_tree = _parse_xml(admx_file)\n                except lxml.etree.XMLSyntaxError:\n                    log.error('An error was found while processing admx file %s, all policies from this file will be unavailable via this module', admx_file)\n                    continue\n                namespaces = xml_tree.getroot().nsmap\n                namespace_string = ''\n                if None in namespaces:\n                    namespaces['None'] = namespaces[None]\n                    namespaces.pop(None)\n                    namespace_string = 'None:'\n                this_namespace = xml_tree.xpath('/{0}policyDefinitions/{0}policyNamespaces/{0}target/@namespace'.format(namespace_string), namespaces=namespaces)[0]\n                categories = xml_tree.xpath('/{0}policyDefinitions/{0}categories/{0}category'.format(namespace_string), namespaces=namespaces)\n                for category in categories:\n                    temp_cat = category\n                    temp_cat = _updateNamespace(temp_cat, this_namespace)\n                    policydefs_categories_xpath(t_policy_definitions)[0].append(temp_cat)\n                policies = xml_tree.xpath('/{0}policyDefinitions/{0}policies/{0}policy'.format(namespace_string), namespaces=namespaces)\n                for policy in policies:\n                    temp_pol = policy\n                    temp_pol = _updateNamespace(temp_pol, this_namespace)\n                    if 'key' in temp_pol.attrib:\n                        temp_pol = _updatePolicyElements(temp_pol, temp_pol.attrib['key'])\n                    policydefs_policies_xpath(t_policy_definitions)[0].append(temp_pol)\n                policy_namespaces = xml_tree.xpath('/{0}policyDefinitions/{0}policyNamespaces/{0}*'.format(namespace_string), namespaces=namespaces)\n                for policy_ns in policy_namespaces:\n                    temp_ns = policy_ns\n                    temp_ns = _updateNamespace(temp_ns, this_namespace)\n                    policydefs_policyns_xpath(t_policy_definitions)[0].append(temp_ns)\n                adml_file = os.path.join(root, language, admx_file_name + '.adml')\n                if not __salt__['file.file_exists'](adml_file):\n                    log.info('An ADML file in the specified ADML language \"%s\" does not exist for the ADMX \"%s\", the the abbreviated language code will be tried.', language, t_admx_file)\n                    adml_file = os.path.join(root, language.split('-')[0], admx_file_name + '.adml')\n                    if not __salt__['file.file_exists'](adml_file):\n                        log.info('An ADML file in the specified ADML language code %s does not exist for the ADMX \"%s\", the fallback language will be tried.', language[:2], t_admx_file)\n                        adml_file = os.path.join(root, display_language_fallback, admx_file_name + '.adml')\n                        if not __salt__['file.file_exists'](adml_file):\n                            log.info('An ADML file in the specified ADML fallback language \"%s\" does not exist for the ADMX \"%s\" the abbreviated fallback language code will be tried.', display_language_fallback, t_admx_file)\n                            adml_file = os.path.join(root, display_language_fallback.split('-')[0], admx_file_name + '.adml')\n                            if not __salt__['file.file_exists'](adml_file):\n                                raise SaltInvocationError('An ADML file in the specified ADML language \"{}\" and the fallback language \"{}\" do not exist for the ADMX \"{}\".'.format(language, display_language_fallback, t_admx_file))\n                try:\n                    xml_tree = _parse_xml(adml_file)\n                except lxml.etree.XMLSyntaxError:\n                    log.error('An error was found while processing adml file %s, all policies from this file will be unavailable via this module', adml_file)\n                    continue\n                if None in namespaces:\n                    namespaces['None'] = namespaces[None]\n                    namespaces.pop(None)\n                policydefs_resources = policydefs_resources_localname_xpath(xml_tree)\n                for policydefs_resource in policydefs_resources:\n                    t_poldef = policydefs_resource\n                    t_poldef = _updateNamespace(t_poldef, this_namespace)\n                    policydef_resources_xpath(t_policy_definition_resources)[0].append(t_poldef)\n    __context__['lgpo.policy_definitions'] = t_policy_definitions\n    __context__['lgpo.policy_resources'] = t_policy_definition_resources",
            "def _load_policy_definitions(path='c:\\\\Windows\\\\PolicyDefinitions', language='en-US'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    helper function to process all ADMX files in the specified policy_def_path\\n    and build a single XML doc that we can search/use for ADMX policy processing\\n    '\n    display_language_fallback = INSTALL_LANGUAGE\n    t_policy_definitions = lxml.etree.Element('policyDefinitions')\n    t_policy_definitions.append(lxml.etree.Element('categories'))\n    t_policy_definitions.append(lxml.etree.Element('policies'))\n    t_policy_definitions.append(lxml.etree.Element('policyNamespaces'))\n    t_policy_definition_resources = lxml.etree.Element('policyDefinitionResources')\n    policydefs_policies_xpath = etree.XPath('/policyDefinitions/policies')\n    policydefs_categories_xpath = etree.XPath('/policyDefinitions/categories')\n    policydefs_policyns_xpath = etree.XPath('/policyDefinitions/policyNamespaces')\n    policydefs_resources_localname_xpath = etree.XPath('//*[local-name() = \"policyDefinitionResources\"]/*')\n    policydef_resources_xpath = etree.XPath('/policyDefinitionResources')\n    for (root, dirs, files) in salt.utils.path.os_walk(path):\n        if root == path:\n            for t_admx_file in files:\n                (admx_file_name, admx_file_ext) = os.path.splitext(t_admx_file)\n                if not admx_file_ext == '.admx':\n                    log.debug('%s is not an ADMX file', t_admx_file)\n                    continue\n                admx_file = os.path.join(root, t_admx_file)\n                try:\n                    xml_tree = _parse_xml(admx_file)\n                except lxml.etree.XMLSyntaxError:\n                    log.error('An error was found while processing admx file %s, all policies from this file will be unavailable via this module', admx_file)\n                    continue\n                namespaces = xml_tree.getroot().nsmap\n                namespace_string = ''\n                if None in namespaces:\n                    namespaces['None'] = namespaces[None]\n                    namespaces.pop(None)\n                    namespace_string = 'None:'\n                this_namespace = xml_tree.xpath('/{0}policyDefinitions/{0}policyNamespaces/{0}target/@namespace'.format(namespace_string), namespaces=namespaces)[0]\n                categories = xml_tree.xpath('/{0}policyDefinitions/{0}categories/{0}category'.format(namespace_string), namespaces=namespaces)\n                for category in categories:\n                    temp_cat = category\n                    temp_cat = _updateNamespace(temp_cat, this_namespace)\n                    policydefs_categories_xpath(t_policy_definitions)[0].append(temp_cat)\n                policies = xml_tree.xpath('/{0}policyDefinitions/{0}policies/{0}policy'.format(namespace_string), namespaces=namespaces)\n                for policy in policies:\n                    temp_pol = policy\n                    temp_pol = _updateNamespace(temp_pol, this_namespace)\n                    if 'key' in temp_pol.attrib:\n                        temp_pol = _updatePolicyElements(temp_pol, temp_pol.attrib['key'])\n                    policydefs_policies_xpath(t_policy_definitions)[0].append(temp_pol)\n                policy_namespaces = xml_tree.xpath('/{0}policyDefinitions/{0}policyNamespaces/{0}*'.format(namespace_string), namespaces=namespaces)\n                for policy_ns in policy_namespaces:\n                    temp_ns = policy_ns\n                    temp_ns = _updateNamespace(temp_ns, this_namespace)\n                    policydefs_policyns_xpath(t_policy_definitions)[0].append(temp_ns)\n                adml_file = os.path.join(root, language, admx_file_name + '.adml')\n                if not __salt__['file.file_exists'](adml_file):\n                    log.info('An ADML file in the specified ADML language \"%s\" does not exist for the ADMX \"%s\", the the abbreviated language code will be tried.', language, t_admx_file)\n                    adml_file = os.path.join(root, language.split('-')[0], admx_file_name + '.adml')\n                    if not __salt__['file.file_exists'](adml_file):\n                        log.info('An ADML file in the specified ADML language code %s does not exist for the ADMX \"%s\", the fallback language will be tried.', language[:2], t_admx_file)\n                        adml_file = os.path.join(root, display_language_fallback, admx_file_name + '.adml')\n                        if not __salt__['file.file_exists'](adml_file):\n                            log.info('An ADML file in the specified ADML fallback language \"%s\" does not exist for the ADMX \"%s\" the abbreviated fallback language code will be tried.', display_language_fallback, t_admx_file)\n                            adml_file = os.path.join(root, display_language_fallback.split('-')[0], admx_file_name + '.adml')\n                            if not __salt__['file.file_exists'](adml_file):\n                                raise SaltInvocationError('An ADML file in the specified ADML language \"{}\" and the fallback language \"{}\" do not exist for the ADMX \"{}\".'.format(language, display_language_fallback, t_admx_file))\n                try:\n                    xml_tree = _parse_xml(adml_file)\n                except lxml.etree.XMLSyntaxError:\n                    log.error('An error was found while processing adml file %s, all policies from this file will be unavailable via this module', adml_file)\n                    continue\n                if None in namespaces:\n                    namespaces['None'] = namespaces[None]\n                    namespaces.pop(None)\n                policydefs_resources = policydefs_resources_localname_xpath(xml_tree)\n                for policydefs_resource in policydefs_resources:\n                    t_poldef = policydefs_resource\n                    t_poldef = _updateNamespace(t_poldef, this_namespace)\n                    policydef_resources_xpath(t_policy_definition_resources)[0].append(t_poldef)\n    __context__['lgpo.policy_definitions'] = t_policy_definitions\n    __context__['lgpo.policy_resources'] = t_policy_definition_resources",
            "def _load_policy_definitions(path='c:\\\\Windows\\\\PolicyDefinitions', language='en-US'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    helper function to process all ADMX files in the specified policy_def_path\\n    and build a single XML doc that we can search/use for ADMX policy processing\\n    '\n    display_language_fallback = INSTALL_LANGUAGE\n    t_policy_definitions = lxml.etree.Element('policyDefinitions')\n    t_policy_definitions.append(lxml.etree.Element('categories'))\n    t_policy_definitions.append(lxml.etree.Element('policies'))\n    t_policy_definitions.append(lxml.etree.Element('policyNamespaces'))\n    t_policy_definition_resources = lxml.etree.Element('policyDefinitionResources')\n    policydefs_policies_xpath = etree.XPath('/policyDefinitions/policies')\n    policydefs_categories_xpath = etree.XPath('/policyDefinitions/categories')\n    policydefs_policyns_xpath = etree.XPath('/policyDefinitions/policyNamespaces')\n    policydefs_resources_localname_xpath = etree.XPath('//*[local-name() = \"policyDefinitionResources\"]/*')\n    policydef_resources_xpath = etree.XPath('/policyDefinitionResources')\n    for (root, dirs, files) in salt.utils.path.os_walk(path):\n        if root == path:\n            for t_admx_file in files:\n                (admx_file_name, admx_file_ext) = os.path.splitext(t_admx_file)\n                if not admx_file_ext == '.admx':\n                    log.debug('%s is not an ADMX file', t_admx_file)\n                    continue\n                admx_file = os.path.join(root, t_admx_file)\n                try:\n                    xml_tree = _parse_xml(admx_file)\n                except lxml.etree.XMLSyntaxError:\n                    log.error('An error was found while processing admx file %s, all policies from this file will be unavailable via this module', admx_file)\n                    continue\n                namespaces = xml_tree.getroot().nsmap\n                namespace_string = ''\n                if None in namespaces:\n                    namespaces['None'] = namespaces[None]\n                    namespaces.pop(None)\n                    namespace_string = 'None:'\n                this_namespace = xml_tree.xpath('/{0}policyDefinitions/{0}policyNamespaces/{0}target/@namespace'.format(namespace_string), namespaces=namespaces)[0]\n                categories = xml_tree.xpath('/{0}policyDefinitions/{0}categories/{0}category'.format(namespace_string), namespaces=namespaces)\n                for category in categories:\n                    temp_cat = category\n                    temp_cat = _updateNamespace(temp_cat, this_namespace)\n                    policydefs_categories_xpath(t_policy_definitions)[0].append(temp_cat)\n                policies = xml_tree.xpath('/{0}policyDefinitions/{0}policies/{0}policy'.format(namespace_string), namespaces=namespaces)\n                for policy in policies:\n                    temp_pol = policy\n                    temp_pol = _updateNamespace(temp_pol, this_namespace)\n                    if 'key' in temp_pol.attrib:\n                        temp_pol = _updatePolicyElements(temp_pol, temp_pol.attrib['key'])\n                    policydefs_policies_xpath(t_policy_definitions)[0].append(temp_pol)\n                policy_namespaces = xml_tree.xpath('/{0}policyDefinitions/{0}policyNamespaces/{0}*'.format(namespace_string), namespaces=namespaces)\n                for policy_ns in policy_namespaces:\n                    temp_ns = policy_ns\n                    temp_ns = _updateNamespace(temp_ns, this_namespace)\n                    policydefs_policyns_xpath(t_policy_definitions)[0].append(temp_ns)\n                adml_file = os.path.join(root, language, admx_file_name + '.adml')\n                if not __salt__['file.file_exists'](adml_file):\n                    log.info('An ADML file in the specified ADML language \"%s\" does not exist for the ADMX \"%s\", the the abbreviated language code will be tried.', language, t_admx_file)\n                    adml_file = os.path.join(root, language.split('-')[0], admx_file_name + '.adml')\n                    if not __salt__['file.file_exists'](adml_file):\n                        log.info('An ADML file in the specified ADML language code %s does not exist for the ADMX \"%s\", the fallback language will be tried.', language[:2], t_admx_file)\n                        adml_file = os.path.join(root, display_language_fallback, admx_file_name + '.adml')\n                        if not __salt__['file.file_exists'](adml_file):\n                            log.info('An ADML file in the specified ADML fallback language \"%s\" does not exist for the ADMX \"%s\" the abbreviated fallback language code will be tried.', display_language_fallback, t_admx_file)\n                            adml_file = os.path.join(root, display_language_fallback.split('-')[0], admx_file_name + '.adml')\n                            if not __salt__['file.file_exists'](adml_file):\n                                raise SaltInvocationError('An ADML file in the specified ADML language \"{}\" and the fallback language \"{}\" do not exist for the ADMX \"{}\".'.format(language, display_language_fallback, t_admx_file))\n                try:\n                    xml_tree = _parse_xml(adml_file)\n                except lxml.etree.XMLSyntaxError:\n                    log.error('An error was found while processing adml file %s, all policies from this file will be unavailable via this module', adml_file)\n                    continue\n                if None in namespaces:\n                    namespaces['None'] = namespaces[None]\n                    namespaces.pop(None)\n                policydefs_resources = policydefs_resources_localname_xpath(xml_tree)\n                for policydefs_resource in policydefs_resources:\n                    t_poldef = policydefs_resource\n                    t_poldef = _updateNamespace(t_poldef, this_namespace)\n                    policydef_resources_xpath(t_policy_definition_resources)[0].append(t_poldef)\n    __context__['lgpo.policy_definitions'] = t_policy_definitions\n    __context__['lgpo.policy_resources'] = t_policy_definition_resources",
            "def _load_policy_definitions(path='c:\\\\Windows\\\\PolicyDefinitions', language='en-US'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    helper function to process all ADMX files in the specified policy_def_path\\n    and build a single XML doc that we can search/use for ADMX policy processing\\n    '\n    display_language_fallback = INSTALL_LANGUAGE\n    t_policy_definitions = lxml.etree.Element('policyDefinitions')\n    t_policy_definitions.append(lxml.etree.Element('categories'))\n    t_policy_definitions.append(lxml.etree.Element('policies'))\n    t_policy_definitions.append(lxml.etree.Element('policyNamespaces'))\n    t_policy_definition_resources = lxml.etree.Element('policyDefinitionResources')\n    policydefs_policies_xpath = etree.XPath('/policyDefinitions/policies')\n    policydefs_categories_xpath = etree.XPath('/policyDefinitions/categories')\n    policydefs_policyns_xpath = etree.XPath('/policyDefinitions/policyNamespaces')\n    policydefs_resources_localname_xpath = etree.XPath('//*[local-name() = \"policyDefinitionResources\"]/*')\n    policydef_resources_xpath = etree.XPath('/policyDefinitionResources')\n    for (root, dirs, files) in salt.utils.path.os_walk(path):\n        if root == path:\n            for t_admx_file in files:\n                (admx_file_name, admx_file_ext) = os.path.splitext(t_admx_file)\n                if not admx_file_ext == '.admx':\n                    log.debug('%s is not an ADMX file', t_admx_file)\n                    continue\n                admx_file = os.path.join(root, t_admx_file)\n                try:\n                    xml_tree = _parse_xml(admx_file)\n                except lxml.etree.XMLSyntaxError:\n                    log.error('An error was found while processing admx file %s, all policies from this file will be unavailable via this module', admx_file)\n                    continue\n                namespaces = xml_tree.getroot().nsmap\n                namespace_string = ''\n                if None in namespaces:\n                    namespaces['None'] = namespaces[None]\n                    namespaces.pop(None)\n                    namespace_string = 'None:'\n                this_namespace = xml_tree.xpath('/{0}policyDefinitions/{0}policyNamespaces/{0}target/@namespace'.format(namespace_string), namespaces=namespaces)[0]\n                categories = xml_tree.xpath('/{0}policyDefinitions/{0}categories/{0}category'.format(namespace_string), namespaces=namespaces)\n                for category in categories:\n                    temp_cat = category\n                    temp_cat = _updateNamespace(temp_cat, this_namespace)\n                    policydefs_categories_xpath(t_policy_definitions)[0].append(temp_cat)\n                policies = xml_tree.xpath('/{0}policyDefinitions/{0}policies/{0}policy'.format(namespace_string), namespaces=namespaces)\n                for policy in policies:\n                    temp_pol = policy\n                    temp_pol = _updateNamespace(temp_pol, this_namespace)\n                    if 'key' in temp_pol.attrib:\n                        temp_pol = _updatePolicyElements(temp_pol, temp_pol.attrib['key'])\n                    policydefs_policies_xpath(t_policy_definitions)[0].append(temp_pol)\n                policy_namespaces = xml_tree.xpath('/{0}policyDefinitions/{0}policyNamespaces/{0}*'.format(namespace_string), namespaces=namespaces)\n                for policy_ns in policy_namespaces:\n                    temp_ns = policy_ns\n                    temp_ns = _updateNamespace(temp_ns, this_namespace)\n                    policydefs_policyns_xpath(t_policy_definitions)[0].append(temp_ns)\n                adml_file = os.path.join(root, language, admx_file_name + '.adml')\n                if not __salt__['file.file_exists'](adml_file):\n                    log.info('An ADML file in the specified ADML language \"%s\" does not exist for the ADMX \"%s\", the the abbreviated language code will be tried.', language, t_admx_file)\n                    adml_file = os.path.join(root, language.split('-')[0], admx_file_name + '.adml')\n                    if not __salt__['file.file_exists'](adml_file):\n                        log.info('An ADML file in the specified ADML language code %s does not exist for the ADMX \"%s\", the fallback language will be tried.', language[:2], t_admx_file)\n                        adml_file = os.path.join(root, display_language_fallback, admx_file_name + '.adml')\n                        if not __salt__['file.file_exists'](adml_file):\n                            log.info('An ADML file in the specified ADML fallback language \"%s\" does not exist for the ADMX \"%s\" the abbreviated fallback language code will be tried.', display_language_fallback, t_admx_file)\n                            adml_file = os.path.join(root, display_language_fallback.split('-')[0], admx_file_name + '.adml')\n                            if not __salt__['file.file_exists'](adml_file):\n                                raise SaltInvocationError('An ADML file in the specified ADML language \"{}\" and the fallback language \"{}\" do not exist for the ADMX \"{}\".'.format(language, display_language_fallback, t_admx_file))\n                try:\n                    xml_tree = _parse_xml(adml_file)\n                except lxml.etree.XMLSyntaxError:\n                    log.error('An error was found while processing adml file %s, all policies from this file will be unavailable via this module', adml_file)\n                    continue\n                if None in namespaces:\n                    namespaces['None'] = namespaces[None]\n                    namespaces.pop(None)\n                policydefs_resources = policydefs_resources_localname_xpath(xml_tree)\n                for policydefs_resource in policydefs_resources:\n                    t_poldef = policydefs_resource\n                    t_poldef = _updateNamespace(t_poldef, this_namespace)\n                    policydef_resources_xpath(t_policy_definition_resources)[0].append(t_poldef)\n    __context__['lgpo.policy_definitions'] = t_policy_definitions\n    __context__['lgpo.policy_resources'] = t_policy_definition_resources",
            "def _load_policy_definitions(path='c:\\\\Windows\\\\PolicyDefinitions', language='en-US'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    helper function to process all ADMX files in the specified policy_def_path\\n    and build a single XML doc that we can search/use for ADMX policy processing\\n    '\n    display_language_fallback = INSTALL_LANGUAGE\n    t_policy_definitions = lxml.etree.Element('policyDefinitions')\n    t_policy_definitions.append(lxml.etree.Element('categories'))\n    t_policy_definitions.append(lxml.etree.Element('policies'))\n    t_policy_definitions.append(lxml.etree.Element('policyNamespaces'))\n    t_policy_definition_resources = lxml.etree.Element('policyDefinitionResources')\n    policydefs_policies_xpath = etree.XPath('/policyDefinitions/policies')\n    policydefs_categories_xpath = etree.XPath('/policyDefinitions/categories')\n    policydefs_policyns_xpath = etree.XPath('/policyDefinitions/policyNamespaces')\n    policydefs_resources_localname_xpath = etree.XPath('//*[local-name() = \"policyDefinitionResources\"]/*')\n    policydef_resources_xpath = etree.XPath('/policyDefinitionResources')\n    for (root, dirs, files) in salt.utils.path.os_walk(path):\n        if root == path:\n            for t_admx_file in files:\n                (admx_file_name, admx_file_ext) = os.path.splitext(t_admx_file)\n                if not admx_file_ext == '.admx':\n                    log.debug('%s is not an ADMX file', t_admx_file)\n                    continue\n                admx_file = os.path.join(root, t_admx_file)\n                try:\n                    xml_tree = _parse_xml(admx_file)\n                except lxml.etree.XMLSyntaxError:\n                    log.error('An error was found while processing admx file %s, all policies from this file will be unavailable via this module', admx_file)\n                    continue\n                namespaces = xml_tree.getroot().nsmap\n                namespace_string = ''\n                if None in namespaces:\n                    namespaces['None'] = namespaces[None]\n                    namespaces.pop(None)\n                    namespace_string = 'None:'\n                this_namespace = xml_tree.xpath('/{0}policyDefinitions/{0}policyNamespaces/{0}target/@namespace'.format(namespace_string), namespaces=namespaces)[0]\n                categories = xml_tree.xpath('/{0}policyDefinitions/{0}categories/{0}category'.format(namespace_string), namespaces=namespaces)\n                for category in categories:\n                    temp_cat = category\n                    temp_cat = _updateNamespace(temp_cat, this_namespace)\n                    policydefs_categories_xpath(t_policy_definitions)[0].append(temp_cat)\n                policies = xml_tree.xpath('/{0}policyDefinitions/{0}policies/{0}policy'.format(namespace_string), namespaces=namespaces)\n                for policy in policies:\n                    temp_pol = policy\n                    temp_pol = _updateNamespace(temp_pol, this_namespace)\n                    if 'key' in temp_pol.attrib:\n                        temp_pol = _updatePolicyElements(temp_pol, temp_pol.attrib['key'])\n                    policydefs_policies_xpath(t_policy_definitions)[0].append(temp_pol)\n                policy_namespaces = xml_tree.xpath('/{0}policyDefinitions/{0}policyNamespaces/{0}*'.format(namespace_string), namespaces=namespaces)\n                for policy_ns in policy_namespaces:\n                    temp_ns = policy_ns\n                    temp_ns = _updateNamespace(temp_ns, this_namespace)\n                    policydefs_policyns_xpath(t_policy_definitions)[0].append(temp_ns)\n                adml_file = os.path.join(root, language, admx_file_name + '.adml')\n                if not __salt__['file.file_exists'](adml_file):\n                    log.info('An ADML file in the specified ADML language \"%s\" does not exist for the ADMX \"%s\", the the abbreviated language code will be tried.', language, t_admx_file)\n                    adml_file = os.path.join(root, language.split('-')[0], admx_file_name + '.adml')\n                    if not __salt__['file.file_exists'](adml_file):\n                        log.info('An ADML file in the specified ADML language code %s does not exist for the ADMX \"%s\", the fallback language will be tried.', language[:2], t_admx_file)\n                        adml_file = os.path.join(root, display_language_fallback, admx_file_name + '.adml')\n                        if not __salt__['file.file_exists'](adml_file):\n                            log.info('An ADML file in the specified ADML fallback language \"%s\" does not exist for the ADMX \"%s\" the abbreviated fallback language code will be tried.', display_language_fallback, t_admx_file)\n                            adml_file = os.path.join(root, display_language_fallback.split('-')[0], admx_file_name + '.adml')\n                            if not __salt__['file.file_exists'](adml_file):\n                                raise SaltInvocationError('An ADML file in the specified ADML language \"{}\" and the fallback language \"{}\" do not exist for the ADMX \"{}\".'.format(language, display_language_fallback, t_admx_file))\n                try:\n                    xml_tree = _parse_xml(adml_file)\n                except lxml.etree.XMLSyntaxError:\n                    log.error('An error was found while processing adml file %s, all policies from this file will be unavailable via this module', adml_file)\n                    continue\n                if None in namespaces:\n                    namespaces['None'] = namespaces[None]\n                    namespaces.pop(None)\n                policydefs_resources = policydefs_resources_localname_xpath(xml_tree)\n                for policydefs_resource in policydefs_resources:\n                    t_poldef = policydefs_resource\n                    t_poldef = _updateNamespace(t_poldef, this_namespace)\n                    policydef_resources_xpath(t_policy_definition_resources)[0].append(t_poldef)\n    __context__['lgpo.policy_definitions'] = t_policy_definitions\n    __context__['lgpo.policy_resources'] = t_policy_definition_resources"
        ]
    },
    {
        "func_name": "_get_policy_definitions",
        "original": "def _get_policy_definitions(path='c:\\\\Windows\\\\PolicyDefinitions', language='en-US'):\n    if 'lgpo.policy_definitions' not in __context__:\n        log.debug('LGPO: Loading policy definitions')\n        _load_policy_definitions(path=path, language=language)\n    return __context__['lgpo.policy_definitions']",
        "mutated": [
            "def _get_policy_definitions(path='c:\\\\Windows\\\\PolicyDefinitions', language='en-US'):\n    if False:\n        i = 10\n    if 'lgpo.policy_definitions' not in __context__:\n        log.debug('LGPO: Loading policy definitions')\n        _load_policy_definitions(path=path, language=language)\n    return __context__['lgpo.policy_definitions']",
            "def _get_policy_definitions(path='c:\\\\Windows\\\\PolicyDefinitions', language='en-US'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if 'lgpo.policy_definitions' not in __context__:\n        log.debug('LGPO: Loading policy definitions')\n        _load_policy_definitions(path=path, language=language)\n    return __context__['lgpo.policy_definitions']",
            "def _get_policy_definitions(path='c:\\\\Windows\\\\PolicyDefinitions', language='en-US'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if 'lgpo.policy_definitions' not in __context__:\n        log.debug('LGPO: Loading policy definitions')\n        _load_policy_definitions(path=path, language=language)\n    return __context__['lgpo.policy_definitions']",
            "def _get_policy_definitions(path='c:\\\\Windows\\\\PolicyDefinitions', language='en-US'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if 'lgpo.policy_definitions' not in __context__:\n        log.debug('LGPO: Loading policy definitions')\n        _load_policy_definitions(path=path, language=language)\n    return __context__['lgpo.policy_definitions']",
            "def _get_policy_definitions(path='c:\\\\Windows\\\\PolicyDefinitions', language='en-US'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if 'lgpo.policy_definitions' not in __context__:\n        log.debug('LGPO: Loading policy definitions')\n        _load_policy_definitions(path=path, language=language)\n    return __context__['lgpo.policy_definitions']"
        ]
    },
    {
        "func_name": "_get_policy_resources",
        "original": "def _get_policy_resources(path='c:\\\\Windows\\\\PolicyDefinitions', language='en-US'):\n    if 'lgpo.policy_resources' not in __context__:\n        log.debug('LGPO: Loading policy resources')\n        _load_policy_definitions(path=path, language=language)\n    return __context__['lgpo.policy_resources']",
        "mutated": [
            "def _get_policy_resources(path='c:\\\\Windows\\\\PolicyDefinitions', language='en-US'):\n    if False:\n        i = 10\n    if 'lgpo.policy_resources' not in __context__:\n        log.debug('LGPO: Loading policy resources')\n        _load_policy_definitions(path=path, language=language)\n    return __context__['lgpo.policy_resources']",
            "def _get_policy_resources(path='c:\\\\Windows\\\\PolicyDefinitions', language='en-US'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if 'lgpo.policy_resources' not in __context__:\n        log.debug('LGPO: Loading policy resources')\n        _load_policy_definitions(path=path, language=language)\n    return __context__['lgpo.policy_resources']",
            "def _get_policy_resources(path='c:\\\\Windows\\\\PolicyDefinitions', language='en-US'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if 'lgpo.policy_resources' not in __context__:\n        log.debug('LGPO: Loading policy resources')\n        _load_policy_definitions(path=path, language=language)\n    return __context__['lgpo.policy_resources']",
            "def _get_policy_resources(path='c:\\\\Windows\\\\PolicyDefinitions', language='en-US'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if 'lgpo.policy_resources' not in __context__:\n        log.debug('LGPO: Loading policy resources')\n        _load_policy_definitions(path=path, language=language)\n    return __context__['lgpo.policy_resources']",
            "def _get_policy_resources(path='c:\\\\Windows\\\\PolicyDefinitions', language='en-US'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if 'lgpo.policy_resources' not in __context__:\n        log.debug('LGPO: Loading policy resources')\n        _load_policy_definitions(path=path, language=language)\n    return __context__['lgpo.policy_resources']"
        ]
    },
    {
        "func_name": "_buildElementNsmap",
        "original": "def _buildElementNsmap(using_elements):\n    \"\"\"\n    build a namespace map for an ADMX element\n    \"\"\"\n    thisMap = {}\n    for e in using_elements:\n        thisMap[e.attrib['prefix']] = e.attrib['namespace']\n    return thisMap",
        "mutated": [
            "def _buildElementNsmap(using_elements):\n    if False:\n        i = 10\n    '\\n    build a namespace map for an ADMX element\\n    '\n    thisMap = {}\n    for e in using_elements:\n        thisMap[e.attrib['prefix']] = e.attrib['namespace']\n    return thisMap",
            "def _buildElementNsmap(using_elements):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    build a namespace map for an ADMX element\\n    '\n    thisMap = {}\n    for e in using_elements:\n        thisMap[e.attrib['prefix']] = e.attrib['namespace']\n    return thisMap",
            "def _buildElementNsmap(using_elements):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    build a namespace map for an ADMX element\\n    '\n    thisMap = {}\n    for e in using_elements:\n        thisMap[e.attrib['prefix']] = e.attrib['namespace']\n    return thisMap",
            "def _buildElementNsmap(using_elements):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    build a namespace map for an ADMX element\\n    '\n    thisMap = {}\n    for e in using_elements:\n        thisMap[e.attrib['prefix']] = e.attrib['namespace']\n    return thisMap",
            "def _buildElementNsmap(using_elements):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    build a namespace map for an ADMX element\\n    '\n    thisMap = {}\n    for e in using_elements:\n        thisMap[e.attrib['prefix']] = e.attrib['namespace']\n    return thisMap"
        ]
    },
    {
        "func_name": "_get_advaudit_defaults",
        "original": "def _get_advaudit_defaults(option=None):\n    \"\"\"\n    Loads audit.csv defaults into a dict in __context__ called\n    'lgpo.audit_defaults'. The dictionary includes fieldnames and all\n    configurable policies as keys. The values are used to create/modify the\n    ``audit.csv`` file. The first entry is `fieldnames` used to create the\n    header for the csv file. The rest of the entries are the audit policy names.\n    Sample data follows:\n\n    {\n        'fieldnames': ['Machine Name',\n                       'Policy Target',\n                       'Subcategory',\n                       'Subcategory GUID',\n                       'Inclusion Setting',\n                       'Exclusion Setting',\n                       'Setting Value'],\n        'Audit Sensitive Privilege Use': {'Auditpol Name': 'Sensitive Privilege Use',\n                                          'Exclusion Setting': '',\n                                          'Inclusion Setting': 'No Auditing',\n                                          'Machine Name': 'WIN-8FGT3E045SE',\n                                          'Policy Target': 'System',\n                                          'Setting Value': '0',\n                                          'Subcategory': u'Audit Sensitive Privilege Use',\n                                          'Subcategory GUID': '{0CCE9228-69AE-11D9-BED3-505054503030}'},\n        'Audit Special Logon': {'Auditpol Name': 'Special Logon',\n                                'Exclusion Setting': '',\n                                'Inclusion Setting': 'No Auditing',\n                                'Machine Name': 'WIN-8FGT3E045SE',\n                                'Policy Target': 'System',\n                                'Setting Value': '0',\n                                'Subcategory': u'Audit Special Logon',\n                                'Subcategory GUID': '{0CCE921B-69AE-11D9-BED3-505054503030}'},\n        'Audit System Integrity': {'Auditpol Name': 'System Integrity',\n                                   'Exclusion Setting': '',\n                                   'Inclusion Setting': 'No Auditing',\n                                   'Machine Name': 'WIN-8FGT3E045SE',\n                                   'Policy Target': 'System',\n                                   'Setting Value': '0',\n                                   'Subcategory': u'Audit System Integrity',\n                                   'Subcategory GUID': '{0CCE9212-69AE-11D9-BED3-505054503030}'},\n        ...\n    }\n\n    .. note::\n        `Auditpol Name` designates the value to use when setting the value with\n        the auditpol command\n\n    Args:\n        option (str): The item from the dictionary to return. If ``None`` the\n            entire dictionary is returned. Default is ``None``\n\n    Returns:\n        dict: If ``None`` or one of the audit settings is passed\n        list: If ``fieldnames`` is passed\n    \"\"\"\n    if 'lgpo.audit_defaults' not in __context__:\n        log.debug('Loading auditpol defaults into __context__')\n        dump = __utils__['auditpol.get_auditpol_dump']()\n        reader = csv.DictReader(dump)\n        audit_defaults = {'fieldnames': reader.fieldnames}\n        for row in reader:\n            row['Machine Name'] = ''\n            row['Auditpol Name'] = row['Subcategory']\n            if row['Subcategory'] == 'Central Policy Staging':\n                row['Subcategory'] = 'Audit Central Access Policy Staging'\n            elif row['Subcategory'] == 'Plug and Play Events':\n                row['Subcategory'] = 'Audit PNP Activity'\n            elif row['Subcategory'] == 'Token Right Adjusted Events':\n                row['Subcategory'] = 'Audit Token Right Adjusted'\n            else:\n                row['Subcategory'] = 'Audit {}'.format(row['Subcategory'])\n            audit_defaults[row['Subcategory']] = row\n        __context__['lgpo.audit_defaults'] = audit_defaults\n    if option:\n        return __context__['lgpo.audit_defaults'][option]\n    else:\n        return __context__['lgpo.audit_defaults']",
        "mutated": [
            "def _get_advaudit_defaults(option=None):\n    if False:\n        i = 10\n    \"\\n    Loads audit.csv defaults into a dict in __context__ called\\n    'lgpo.audit_defaults'. The dictionary includes fieldnames and all\\n    configurable policies as keys. The values are used to create/modify the\\n    ``audit.csv`` file. The first entry is `fieldnames` used to create the\\n    header for the csv file. The rest of the entries are the audit policy names.\\n    Sample data follows:\\n\\n    {\\n        'fieldnames': ['Machine Name',\\n                       'Policy Target',\\n                       'Subcategory',\\n                       'Subcategory GUID',\\n                       'Inclusion Setting',\\n                       'Exclusion Setting',\\n                       'Setting Value'],\\n        'Audit Sensitive Privilege Use': {'Auditpol Name': 'Sensitive Privilege Use',\\n                                          'Exclusion Setting': '',\\n                                          'Inclusion Setting': 'No Auditing',\\n                                          'Machine Name': 'WIN-8FGT3E045SE',\\n                                          'Policy Target': 'System',\\n                                          'Setting Value': '0',\\n                                          'Subcategory': u'Audit Sensitive Privilege Use',\\n                                          'Subcategory GUID': '{0CCE9228-69AE-11D9-BED3-505054503030}'},\\n        'Audit Special Logon': {'Auditpol Name': 'Special Logon',\\n                                'Exclusion Setting': '',\\n                                'Inclusion Setting': 'No Auditing',\\n                                'Machine Name': 'WIN-8FGT3E045SE',\\n                                'Policy Target': 'System',\\n                                'Setting Value': '0',\\n                                'Subcategory': u'Audit Special Logon',\\n                                'Subcategory GUID': '{0CCE921B-69AE-11D9-BED3-505054503030}'},\\n        'Audit System Integrity': {'Auditpol Name': 'System Integrity',\\n                                   'Exclusion Setting': '',\\n                                   'Inclusion Setting': 'No Auditing',\\n                                   'Machine Name': 'WIN-8FGT3E045SE',\\n                                   'Policy Target': 'System',\\n                                   'Setting Value': '0',\\n                                   'Subcategory': u'Audit System Integrity',\\n                                   'Subcategory GUID': '{0CCE9212-69AE-11D9-BED3-505054503030}'},\\n        ...\\n    }\\n\\n    .. note::\\n        `Auditpol Name` designates the value to use when setting the value with\\n        the auditpol command\\n\\n    Args:\\n        option (str): The item from the dictionary to return. If ``None`` the\\n            entire dictionary is returned. Default is ``None``\\n\\n    Returns:\\n        dict: If ``None`` or one of the audit settings is passed\\n        list: If ``fieldnames`` is passed\\n    \"\n    if 'lgpo.audit_defaults' not in __context__:\n        log.debug('Loading auditpol defaults into __context__')\n        dump = __utils__['auditpol.get_auditpol_dump']()\n        reader = csv.DictReader(dump)\n        audit_defaults = {'fieldnames': reader.fieldnames}\n        for row in reader:\n            row['Machine Name'] = ''\n            row['Auditpol Name'] = row['Subcategory']\n            if row['Subcategory'] == 'Central Policy Staging':\n                row['Subcategory'] = 'Audit Central Access Policy Staging'\n            elif row['Subcategory'] == 'Plug and Play Events':\n                row['Subcategory'] = 'Audit PNP Activity'\n            elif row['Subcategory'] == 'Token Right Adjusted Events':\n                row['Subcategory'] = 'Audit Token Right Adjusted'\n            else:\n                row['Subcategory'] = 'Audit {}'.format(row['Subcategory'])\n            audit_defaults[row['Subcategory']] = row\n        __context__['lgpo.audit_defaults'] = audit_defaults\n    if option:\n        return __context__['lgpo.audit_defaults'][option]\n    else:\n        return __context__['lgpo.audit_defaults']",
            "def _get_advaudit_defaults(option=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Loads audit.csv defaults into a dict in __context__ called\\n    'lgpo.audit_defaults'. The dictionary includes fieldnames and all\\n    configurable policies as keys. The values are used to create/modify the\\n    ``audit.csv`` file. The first entry is `fieldnames` used to create the\\n    header for the csv file. The rest of the entries are the audit policy names.\\n    Sample data follows:\\n\\n    {\\n        'fieldnames': ['Machine Name',\\n                       'Policy Target',\\n                       'Subcategory',\\n                       'Subcategory GUID',\\n                       'Inclusion Setting',\\n                       'Exclusion Setting',\\n                       'Setting Value'],\\n        'Audit Sensitive Privilege Use': {'Auditpol Name': 'Sensitive Privilege Use',\\n                                          'Exclusion Setting': '',\\n                                          'Inclusion Setting': 'No Auditing',\\n                                          'Machine Name': 'WIN-8FGT3E045SE',\\n                                          'Policy Target': 'System',\\n                                          'Setting Value': '0',\\n                                          'Subcategory': u'Audit Sensitive Privilege Use',\\n                                          'Subcategory GUID': '{0CCE9228-69AE-11D9-BED3-505054503030}'},\\n        'Audit Special Logon': {'Auditpol Name': 'Special Logon',\\n                                'Exclusion Setting': '',\\n                                'Inclusion Setting': 'No Auditing',\\n                                'Machine Name': 'WIN-8FGT3E045SE',\\n                                'Policy Target': 'System',\\n                                'Setting Value': '0',\\n                                'Subcategory': u'Audit Special Logon',\\n                                'Subcategory GUID': '{0CCE921B-69AE-11D9-BED3-505054503030}'},\\n        'Audit System Integrity': {'Auditpol Name': 'System Integrity',\\n                                   'Exclusion Setting': '',\\n                                   'Inclusion Setting': 'No Auditing',\\n                                   'Machine Name': 'WIN-8FGT3E045SE',\\n                                   'Policy Target': 'System',\\n                                   'Setting Value': '0',\\n                                   'Subcategory': u'Audit System Integrity',\\n                                   'Subcategory GUID': '{0CCE9212-69AE-11D9-BED3-505054503030}'},\\n        ...\\n    }\\n\\n    .. note::\\n        `Auditpol Name` designates the value to use when setting the value with\\n        the auditpol command\\n\\n    Args:\\n        option (str): The item from the dictionary to return. If ``None`` the\\n            entire dictionary is returned. Default is ``None``\\n\\n    Returns:\\n        dict: If ``None`` or one of the audit settings is passed\\n        list: If ``fieldnames`` is passed\\n    \"\n    if 'lgpo.audit_defaults' not in __context__:\n        log.debug('Loading auditpol defaults into __context__')\n        dump = __utils__['auditpol.get_auditpol_dump']()\n        reader = csv.DictReader(dump)\n        audit_defaults = {'fieldnames': reader.fieldnames}\n        for row in reader:\n            row['Machine Name'] = ''\n            row['Auditpol Name'] = row['Subcategory']\n            if row['Subcategory'] == 'Central Policy Staging':\n                row['Subcategory'] = 'Audit Central Access Policy Staging'\n            elif row['Subcategory'] == 'Plug and Play Events':\n                row['Subcategory'] = 'Audit PNP Activity'\n            elif row['Subcategory'] == 'Token Right Adjusted Events':\n                row['Subcategory'] = 'Audit Token Right Adjusted'\n            else:\n                row['Subcategory'] = 'Audit {}'.format(row['Subcategory'])\n            audit_defaults[row['Subcategory']] = row\n        __context__['lgpo.audit_defaults'] = audit_defaults\n    if option:\n        return __context__['lgpo.audit_defaults'][option]\n    else:\n        return __context__['lgpo.audit_defaults']",
            "def _get_advaudit_defaults(option=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Loads audit.csv defaults into a dict in __context__ called\\n    'lgpo.audit_defaults'. The dictionary includes fieldnames and all\\n    configurable policies as keys. The values are used to create/modify the\\n    ``audit.csv`` file. The first entry is `fieldnames` used to create the\\n    header for the csv file. The rest of the entries are the audit policy names.\\n    Sample data follows:\\n\\n    {\\n        'fieldnames': ['Machine Name',\\n                       'Policy Target',\\n                       'Subcategory',\\n                       'Subcategory GUID',\\n                       'Inclusion Setting',\\n                       'Exclusion Setting',\\n                       'Setting Value'],\\n        'Audit Sensitive Privilege Use': {'Auditpol Name': 'Sensitive Privilege Use',\\n                                          'Exclusion Setting': '',\\n                                          'Inclusion Setting': 'No Auditing',\\n                                          'Machine Name': 'WIN-8FGT3E045SE',\\n                                          'Policy Target': 'System',\\n                                          'Setting Value': '0',\\n                                          'Subcategory': u'Audit Sensitive Privilege Use',\\n                                          'Subcategory GUID': '{0CCE9228-69AE-11D9-BED3-505054503030}'},\\n        'Audit Special Logon': {'Auditpol Name': 'Special Logon',\\n                                'Exclusion Setting': '',\\n                                'Inclusion Setting': 'No Auditing',\\n                                'Machine Name': 'WIN-8FGT3E045SE',\\n                                'Policy Target': 'System',\\n                                'Setting Value': '0',\\n                                'Subcategory': u'Audit Special Logon',\\n                                'Subcategory GUID': '{0CCE921B-69AE-11D9-BED3-505054503030}'},\\n        'Audit System Integrity': {'Auditpol Name': 'System Integrity',\\n                                   'Exclusion Setting': '',\\n                                   'Inclusion Setting': 'No Auditing',\\n                                   'Machine Name': 'WIN-8FGT3E045SE',\\n                                   'Policy Target': 'System',\\n                                   'Setting Value': '0',\\n                                   'Subcategory': u'Audit System Integrity',\\n                                   'Subcategory GUID': '{0CCE9212-69AE-11D9-BED3-505054503030}'},\\n        ...\\n    }\\n\\n    .. note::\\n        `Auditpol Name` designates the value to use when setting the value with\\n        the auditpol command\\n\\n    Args:\\n        option (str): The item from the dictionary to return. If ``None`` the\\n            entire dictionary is returned. Default is ``None``\\n\\n    Returns:\\n        dict: If ``None`` or one of the audit settings is passed\\n        list: If ``fieldnames`` is passed\\n    \"\n    if 'lgpo.audit_defaults' not in __context__:\n        log.debug('Loading auditpol defaults into __context__')\n        dump = __utils__['auditpol.get_auditpol_dump']()\n        reader = csv.DictReader(dump)\n        audit_defaults = {'fieldnames': reader.fieldnames}\n        for row in reader:\n            row['Machine Name'] = ''\n            row['Auditpol Name'] = row['Subcategory']\n            if row['Subcategory'] == 'Central Policy Staging':\n                row['Subcategory'] = 'Audit Central Access Policy Staging'\n            elif row['Subcategory'] == 'Plug and Play Events':\n                row['Subcategory'] = 'Audit PNP Activity'\n            elif row['Subcategory'] == 'Token Right Adjusted Events':\n                row['Subcategory'] = 'Audit Token Right Adjusted'\n            else:\n                row['Subcategory'] = 'Audit {}'.format(row['Subcategory'])\n            audit_defaults[row['Subcategory']] = row\n        __context__['lgpo.audit_defaults'] = audit_defaults\n    if option:\n        return __context__['lgpo.audit_defaults'][option]\n    else:\n        return __context__['lgpo.audit_defaults']",
            "def _get_advaudit_defaults(option=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Loads audit.csv defaults into a dict in __context__ called\\n    'lgpo.audit_defaults'. The dictionary includes fieldnames and all\\n    configurable policies as keys. The values are used to create/modify the\\n    ``audit.csv`` file. The first entry is `fieldnames` used to create the\\n    header for the csv file. The rest of the entries are the audit policy names.\\n    Sample data follows:\\n\\n    {\\n        'fieldnames': ['Machine Name',\\n                       'Policy Target',\\n                       'Subcategory',\\n                       'Subcategory GUID',\\n                       'Inclusion Setting',\\n                       'Exclusion Setting',\\n                       'Setting Value'],\\n        'Audit Sensitive Privilege Use': {'Auditpol Name': 'Sensitive Privilege Use',\\n                                          'Exclusion Setting': '',\\n                                          'Inclusion Setting': 'No Auditing',\\n                                          'Machine Name': 'WIN-8FGT3E045SE',\\n                                          'Policy Target': 'System',\\n                                          'Setting Value': '0',\\n                                          'Subcategory': u'Audit Sensitive Privilege Use',\\n                                          'Subcategory GUID': '{0CCE9228-69AE-11D9-BED3-505054503030}'},\\n        'Audit Special Logon': {'Auditpol Name': 'Special Logon',\\n                                'Exclusion Setting': '',\\n                                'Inclusion Setting': 'No Auditing',\\n                                'Machine Name': 'WIN-8FGT3E045SE',\\n                                'Policy Target': 'System',\\n                                'Setting Value': '0',\\n                                'Subcategory': u'Audit Special Logon',\\n                                'Subcategory GUID': '{0CCE921B-69AE-11D9-BED3-505054503030}'},\\n        'Audit System Integrity': {'Auditpol Name': 'System Integrity',\\n                                   'Exclusion Setting': '',\\n                                   'Inclusion Setting': 'No Auditing',\\n                                   'Machine Name': 'WIN-8FGT3E045SE',\\n                                   'Policy Target': 'System',\\n                                   'Setting Value': '0',\\n                                   'Subcategory': u'Audit System Integrity',\\n                                   'Subcategory GUID': '{0CCE9212-69AE-11D9-BED3-505054503030}'},\\n        ...\\n    }\\n\\n    .. note::\\n        `Auditpol Name` designates the value to use when setting the value with\\n        the auditpol command\\n\\n    Args:\\n        option (str): The item from the dictionary to return. If ``None`` the\\n            entire dictionary is returned. Default is ``None``\\n\\n    Returns:\\n        dict: If ``None`` or one of the audit settings is passed\\n        list: If ``fieldnames`` is passed\\n    \"\n    if 'lgpo.audit_defaults' not in __context__:\n        log.debug('Loading auditpol defaults into __context__')\n        dump = __utils__['auditpol.get_auditpol_dump']()\n        reader = csv.DictReader(dump)\n        audit_defaults = {'fieldnames': reader.fieldnames}\n        for row in reader:\n            row['Machine Name'] = ''\n            row['Auditpol Name'] = row['Subcategory']\n            if row['Subcategory'] == 'Central Policy Staging':\n                row['Subcategory'] = 'Audit Central Access Policy Staging'\n            elif row['Subcategory'] == 'Plug and Play Events':\n                row['Subcategory'] = 'Audit PNP Activity'\n            elif row['Subcategory'] == 'Token Right Adjusted Events':\n                row['Subcategory'] = 'Audit Token Right Adjusted'\n            else:\n                row['Subcategory'] = 'Audit {}'.format(row['Subcategory'])\n            audit_defaults[row['Subcategory']] = row\n        __context__['lgpo.audit_defaults'] = audit_defaults\n    if option:\n        return __context__['lgpo.audit_defaults'][option]\n    else:\n        return __context__['lgpo.audit_defaults']",
            "def _get_advaudit_defaults(option=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Loads audit.csv defaults into a dict in __context__ called\\n    'lgpo.audit_defaults'. The dictionary includes fieldnames and all\\n    configurable policies as keys. The values are used to create/modify the\\n    ``audit.csv`` file. The first entry is `fieldnames` used to create the\\n    header for the csv file. The rest of the entries are the audit policy names.\\n    Sample data follows:\\n\\n    {\\n        'fieldnames': ['Machine Name',\\n                       'Policy Target',\\n                       'Subcategory',\\n                       'Subcategory GUID',\\n                       'Inclusion Setting',\\n                       'Exclusion Setting',\\n                       'Setting Value'],\\n        'Audit Sensitive Privilege Use': {'Auditpol Name': 'Sensitive Privilege Use',\\n                                          'Exclusion Setting': '',\\n                                          'Inclusion Setting': 'No Auditing',\\n                                          'Machine Name': 'WIN-8FGT3E045SE',\\n                                          'Policy Target': 'System',\\n                                          'Setting Value': '0',\\n                                          'Subcategory': u'Audit Sensitive Privilege Use',\\n                                          'Subcategory GUID': '{0CCE9228-69AE-11D9-BED3-505054503030}'},\\n        'Audit Special Logon': {'Auditpol Name': 'Special Logon',\\n                                'Exclusion Setting': '',\\n                                'Inclusion Setting': 'No Auditing',\\n                                'Machine Name': 'WIN-8FGT3E045SE',\\n                                'Policy Target': 'System',\\n                                'Setting Value': '0',\\n                                'Subcategory': u'Audit Special Logon',\\n                                'Subcategory GUID': '{0CCE921B-69AE-11D9-BED3-505054503030}'},\\n        'Audit System Integrity': {'Auditpol Name': 'System Integrity',\\n                                   'Exclusion Setting': '',\\n                                   'Inclusion Setting': 'No Auditing',\\n                                   'Machine Name': 'WIN-8FGT3E045SE',\\n                                   'Policy Target': 'System',\\n                                   'Setting Value': '0',\\n                                   'Subcategory': u'Audit System Integrity',\\n                                   'Subcategory GUID': '{0CCE9212-69AE-11D9-BED3-505054503030}'},\\n        ...\\n    }\\n\\n    .. note::\\n        `Auditpol Name` designates the value to use when setting the value with\\n        the auditpol command\\n\\n    Args:\\n        option (str): The item from the dictionary to return. If ``None`` the\\n            entire dictionary is returned. Default is ``None``\\n\\n    Returns:\\n        dict: If ``None`` or one of the audit settings is passed\\n        list: If ``fieldnames`` is passed\\n    \"\n    if 'lgpo.audit_defaults' not in __context__:\n        log.debug('Loading auditpol defaults into __context__')\n        dump = __utils__['auditpol.get_auditpol_dump']()\n        reader = csv.DictReader(dump)\n        audit_defaults = {'fieldnames': reader.fieldnames}\n        for row in reader:\n            row['Machine Name'] = ''\n            row['Auditpol Name'] = row['Subcategory']\n            if row['Subcategory'] == 'Central Policy Staging':\n                row['Subcategory'] = 'Audit Central Access Policy Staging'\n            elif row['Subcategory'] == 'Plug and Play Events':\n                row['Subcategory'] = 'Audit PNP Activity'\n            elif row['Subcategory'] == 'Token Right Adjusted Events':\n                row['Subcategory'] = 'Audit Token Right Adjusted'\n            else:\n                row['Subcategory'] = 'Audit {}'.format(row['Subcategory'])\n            audit_defaults[row['Subcategory']] = row\n        __context__['lgpo.audit_defaults'] = audit_defaults\n    if option:\n        return __context__['lgpo.audit_defaults'][option]\n    else:\n        return __context__['lgpo.audit_defaults']"
        ]
    },
    {
        "func_name": "_advaudit_check_csv",
        "original": "def _advaudit_check_csv():\n    \"\"\"\n    This function checks for the existence of the `audit.csv` file here:\n    `C:\\\\Windows\\\\security\\\\audit`\n\n    If the file does not exist, then it copies the `audit.csv` file from the\n    Group Policy location:\n    `C:\\\\Windows\\\\System32\\\\GroupPolicy\\\\Machine\\\\Microsoft\\\\Windows NT\\\\Audit`\n\n    If there is no `audit.csv` in either location, then a default `audit.csv`\n    file is created.\n    \"\"\"\n    system_root = os.environ.get('SystemRoot', 'C:\\\\Windows')\n    f_audit = os.path.join(system_root, 'security', 'audit', 'audit.csv')\n    f_audit_gpo = os.path.join(system_root, 'System32', 'GroupPolicy', 'Machine', 'Microsoft', 'Windows NT', 'Audit', 'audit.csv')\n    if not __salt__['file.file_exists'](f_audit):\n        if __salt__['file.file_exists'](f_audit_gpo):\n            __salt__['file.copy'](f_audit_gpo, f_audit)\n        else:\n            field_names = _get_advaudit_defaults('fieldnames')\n            __salt__['file.makedirs'](f_audit)\n            __salt__['file.write'](f_audit, ','.join(field_names))",
        "mutated": [
            "def _advaudit_check_csv():\n    if False:\n        i = 10\n    '\\n    This function checks for the existence of the `audit.csv` file here:\\n    `C:\\\\Windows\\\\security\\\\audit`\\n\\n    If the file does not exist, then it copies the `audit.csv` file from the\\n    Group Policy location:\\n    `C:\\\\Windows\\\\System32\\\\GroupPolicy\\\\Machine\\\\Microsoft\\\\Windows NT\\\\Audit`\\n\\n    If there is no `audit.csv` in either location, then a default `audit.csv`\\n    file is created.\\n    '\n    system_root = os.environ.get('SystemRoot', 'C:\\\\Windows')\n    f_audit = os.path.join(system_root, 'security', 'audit', 'audit.csv')\n    f_audit_gpo = os.path.join(system_root, 'System32', 'GroupPolicy', 'Machine', 'Microsoft', 'Windows NT', 'Audit', 'audit.csv')\n    if not __salt__['file.file_exists'](f_audit):\n        if __salt__['file.file_exists'](f_audit_gpo):\n            __salt__['file.copy'](f_audit_gpo, f_audit)\n        else:\n            field_names = _get_advaudit_defaults('fieldnames')\n            __salt__['file.makedirs'](f_audit)\n            __salt__['file.write'](f_audit, ','.join(field_names))",
            "def _advaudit_check_csv():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    This function checks for the existence of the `audit.csv` file here:\\n    `C:\\\\Windows\\\\security\\\\audit`\\n\\n    If the file does not exist, then it copies the `audit.csv` file from the\\n    Group Policy location:\\n    `C:\\\\Windows\\\\System32\\\\GroupPolicy\\\\Machine\\\\Microsoft\\\\Windows NT\\\\Audit`\\n\\n    If there is no `audit.csv` in either location, then a default `audit.csv`\\n    file is created.\\n    '\n    system_root = os.environ.get('SystemRoot', 'C:\\\\Windows')\n    f_audit = os.path.join(system_root, 'security', 'audit', 'audit.csv')\n    f_audit_gpo = os.path.join(system_root, 'System32', 'GroupPolicy', 'Machine', 'Microsoft', 'Windows NT', 'Audit', 'audit.csv')\n    if not __salt__['file.file_exists'](f_audit):\n        if __salt__['file.file_exists'](f_audit_gpo):\n            __salt__['file.copy'](f_audit_gpo, f_audit)\n        else:\n            field_names = _get_advaudit_defaults('fieldnames')\n            __salt__['file.makedirs'](f_audit)\n            __salt__['file.write'](f_audit, ','.join(field_names))",
            "def _advaudit_check_csv():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    This function checks for the existence of the `audit.csv` file here:\\n    `C:\\\\Windows\\\\security\\\\audit`\\n\\n    If the file does not exist, then it copies the `audit.csv` file from the\\n    Group Policy location:\\n    `C:\\\\Windows\\\\System32\\\\GroupPolicy\\\\Machine\\\\Microsoft\\\\Windows NT\\\\Audit`\\n\\n    If there is no `audit.csv` in either location, then a default `audit.csv`\\n    file is created.\\n    '\n    system_root = os.environ.get('SystemRoot', 'C:\\\\Windows')\n    f_audit = os.path.join(system_root, 'security', 'audit', 'audit.csv')\n    f_audit_gpo = os.path.join(system_root, 'System32', 'GroupPolicy', 'Machine', 'Microsoft', 'Windows NT', 'Audit', 'audit.csv')\n    if not __salt__['file.file_exists'](f_audit):\n        if __salt__['file.file_exists'](f_audit_gpo):\n            __salt__['file.copy'](f_audit_gpo, f_audit)\n        else:\n            field_names = _get_advaudit_defaults('fieldnames')\n            __salt__['file.makedirs'](f_audit)\n            __salt__['file.write'](f_audit, ','.join(field_names))",
            "def _advaudit_check_csv():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    This function checks for the existence of the `audit.csv` file here:\\n    `C:\\\\Windows\\\\security\\\\audit`\\n\\n    If the file does not exist, then it copies the `audit.csv` file from the\\n    Group Policy location:\\n    `C:\\\\Windows\\\\System32\\\\GroupPolicy\\\\Machine\\\\Microsoft\\\\Windows NT\\\\Audit`\\n\\n    If there is no `audit.csv` in either location, then a default `audit.csv`\\n    file is created.\\n    '\n    system_root = os.environ.get('SystemRoot', 'C:\\\\Windows')\n    f_audit = os.path.join(system_root, 'security', 'audit', 'audit.csv')\n    f_audit_gpo = os.path.join(system_root, 'System32', 'GroupPolicy', 'Machine', 'Microsoft', 'Windows NT', 'Audit', 'audit.csv')\n    if not __salt__['file.file_exists'](f_audit):\n        if __salt__['file.file_exists'](f_audit_gpo):\n            __salt__['file.copy'](f_audit_gpo, f_audit)\n        else:\n            field_names = _get_advaudit_defaults('fieldnames')\n            __salt__['file.makedirs'](f_audit)\n            __salt__['file.write'](f_audit, ','.join(field_names))",
            "def _advaudit_check_csv():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    This function checks for the existence of the `audit.csv` file here:\\n    `C:\\\\Windows\\\\security\\\\audit`\\n\\n    If the file does not exist, then it copies the `audit.csv` file from the\\n    Group Policy location:\\n    `C:\\\\Windows\\\\System32\\\\GroupPolicy\\\\Machine\\\\Microsoft\\\\Windows NT\\\\Audit`\\n\\n    If there is no `audit.csv` in either location, then a default `audit.csv`\\n    file is created.\\n    '\n    system_root = os.environ.get('SystemRoot', 'C:\\\\Windows')\n    f_audit = os.path.join(system_root, 'security', 'audit', 'audit.csv')\n    f_audit_gpo = os.path.join(system_root, 'System32', 'GroupPolicy', 'Machine', 'Microsoft', 'Windows NT', 'Audit', 'audit.csv')\n    if not __salt__['file.file_exists'](f_audit):\n        if __salt__['file.file_exists'](f_audit_gpo):\n            __salt__['file.copy'](f_audit_gpo, f_audit)\n        else:\n            field_names = _get_advaudit_defaults('fieldnames')\n            __salt__['file.makedirs'](f_audit)\n            __salt__['file.write'](f_audit, ','.join(field_names))"
        ]
    },
    {
        "func_name": "_get_advaudit_value",
        "original": "def _get_advaudit_value(option, refresh=False):\n    \"\"\"\n    Get the Advanced Auditing policy as configured in\n    ``C:\\\\Windows\\\\Security\\\\Audit\\\\audit.csv``\n\n    Args:\n\n        option (str):\n            The name of the setting as it appears in audit.csv\n\n        refresh (bool):\n            Refresh secedit data stored in __context__. This is needed for\n            testing where the state is setting the value, but the module that\n            is checking the value has its own __context__.\n\n    Returns:\n        bool: ``True`` if successful, otherwise ``False``\n    \"\"\"\n    if 'lgpo.adv_audit_data' not in __context__ or refresh is True:\n        system_root = os.environ.get('SystemRoot', 'C:\\\\Windows')\n        f_audit = os.path.join(system_root, 'security', 'audit', 'audit.csv')\n        _advaudit_check_csv()\n        audit_settings = {}\n        with salt.utils.files.fopen(f_audit, mode='r') as csv_file:\n            reader = csv.DictReader(csv_file)\n            for row in reader:\n                audit_settings.update({row['Subcategory']: row['Setting Value']})\n        __context__['lgpo.adv_audit_data'] = audit_settings\n    return __context__['lgpo.adv_audit_data'].get(option, None)",
        "mutated": [
            "def _get_advaudit_value(option, refresh=False):\n    if False:\n        i = 10\n    '\\n    Get the Advanced Auditing policy as configured in\\n    ``C:\\\\Windows\\\\Security\\\\Audit\\\\audit.csv``\\n\\n    Args:\\n\\n        option (str):\\n            The name of the setting as it appears in audit.csv\\n\\n        refresh (bool):\\n            Refresh secedit data stored in __context__. This is needed for\\n            testing where the state is setting the value, but the module that\\n            is checking the value has its own __context__.\\n\\n    Returns:\\n        bool: ``True`` if successful, otherwise ``False``\\n    '\n    if 'lgpo.adv_audit_data' not in __context__ or refresh is True:\n        system_root = os.environ.get('SystemRoot', 'C:\\\\Windows')\n        f_audit = os.path.join(system_root, 'security', 'audit', 'audit.csv')\n        _advaudit_check_csv()\n        audit_settings = {}\n        with salt.utils.files.fopen(f_audit, mode='r') as csv_file:\n            reader = csv.DictReader(csv_file)\n            for row in reader:\n                audit_settings.update({row['Subcategory']: row['Setting Value']})\n        __context__['lgpo.adv_audit_data'] = audit_settings\n    return __context__['lgpo.adv_audit_data'].get(option, None)",
            "def _get_advaudit_value(option, refresh=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Get the Advanced Auditing policy as configured in\\n    ``C:\\\\Windows\\\\Security\\\\Audit\\\\audit.csv``\\n\\n    Args:\\n\\n        option (str):\\n            The name of the setting as it appears in audit.csv\\n\\n        refresh (bool):\\n            Refresh secedit data stored in __context__. This is needed for\\n            testing where the state is setting the value, but the module that\\n            is checking the value has its own __context__.\\n\\n    Returns:\\n        bool: ``True`` if successful, otherwise ``False``\\n    '\n    if 'lgpo.adv_audit_data' not in __context__ or refresh is True:\n        system_root = os.environ.get('SystemRoot', 'C:\\\\Windows')\n        f_audit = os.path.join(system_root, 'security', 'audit', 'audit.csv')\n        _advaudit_check_csv()\n        audit_settings = {}\n        with salt.utils.files.fopen(f_audit, mode='r') as csv_file:\n            reader = csv.DictReader(csv_file)\n            for row in reader:\n                audit_settings.update({row['Subcategory']: row['Setting Value']})\n        __context__['lgpo.adv_audit_data'] = audit_settings\n    return __context__['lgpo.adv_audit_data'].get(option, None)",
            "def _get_advaudit_value(option, refresh=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Get the Advanced Auditing policy as configured in\\n    ``C:\\\\Windows\\\\Security\\\\Audit\\\\audit.csv``\\n\\n    Args:\\n\\n        option (str):\\n            The name of the setting as it appears in audit.csv\\n\\n        refresh (bool):\\n            Refresh secedit data stored in __context__. This is needed for\\n            testing where the state is setting the value, but the module that\\n            is checking the value has its own __context__.\\n\\n    Returns:\\n        bool: ``True`` if successful, otherwise ``False``\\n    '\n    if 'lgpo.adv_audit_data' not in __context__ or refresh is True:\n        system_root = os.environ.get('SystemRoot', 'C:\\\\Windows')\n        f_audit = os.path.join(system_root, 'security', 'audit', 'audit.csv')\n        _advaudit_check_csv()\n        audit_settings = {}\n        with salt.utils.files.fopen(f_audit, mode='r') as csv_file:\n            reader = csv.DictReader(csv_file)\n            for row in reader:\n                audit_settings.update({row['Subcategory']: row['Setting Value']})\n        __context__['lgpo.adv_audit_data'] = audit_settings\n    return __context__['lgpo.adv_audit_data'].get(option, None)",
            "def _get_advaudit_value(option, refresh=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Get the Advanced Auditing policy as configured in\\n    ``C:\\\\Windows\\\\Security\\\\Audit\\\\audit.csv``\\n\\n    Args:\\n\\n        option (str):\\n            The name of the setting as it appears in audit.csv\\n\\n        refresh (bool):\\n            Refresh secedit data stored in __context__. This is needed for\\n            testing where the state is setting the value, but the module that\\n            is checking the value has its own __context__.\\n\\n    Returns:\\n        bool: ``True`` if successful, otherwise ``False``\\n    '\n    if 'lgpo.adv_audit_data' not in __context__ or refresh is True:\n        system_root = os.environ.get('SystemRoot', 'C:\\\\Windows')\n        f_audit = os.path.join(system_root, 'security', 'audit', 'audit.csv')\n        _advaudit_check_csv()\n        audit_settings = {}\n        with salt.utils.files.fopen(f_audit, mode='r') as csv_file:\n            reader = csv.DictReader(csv_file)\n            for row in reader:\n                audit_settings.update({row['Subcategory']: row['Setting Value']})\n        __context__['lgpo.adv_audit_data'] = audit_settings\n    return __context__['lgpo.adv_audit_data'].get(option, None)",
            "def _get_advaudit_value(option, refresh=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Get the Advanced Auditing policy as configured in\\n    ``C:\\\\Windows\\\\Security\\\\Audit\\\\audit.csv``\\n\\n    Args:\\n\\n        option (str):\\n            The name of the setting as it appears in audit.csv\\n\\n        refresh (bool):\\n            Refresh secedit data stored in __context__. This is needed for\\n            testing where the state is setting the value, but the module that\\n            is checking the value has its own __context__.\\n\\n    Returns:\\n        bool: ``True`` if successful, otherwise ``False``\\n    '\n    if 'lgpo.adv_audit_data' not in __context__ or refresh is True:\n        system_root = os.environ.get('SystemRoot', 'C:\\\\Windows')\n        f_audit = os.path.join(system_root, 'security', 'audit', 'audit.csv')\n        _advaudit_check_csv()\n        audit_settings = {}\n        with salt.utils.files.fopen(f_audit, mode='r') as csv_file:\n            reader = csv.DictReader(csv_file)\n            for row in reader:\n                audit_settings.update({row['Subcategory']: row['Setting Value']})\n        __context__['lgpo.adv_audit_data'] = audit_settings\n    return __context__['lgpo.adv_audit_data'].get(option, None)"
        ]
    },
    {
        "func_name": "_set_advaudit_file_data",
        "original": "def _set_advaudit_file_data(option, value):\n    \"\"\"\n    Helper function that sets the Advanced Audit settings in the two .csv files\n    on Windows. Those files are located at:\n    C:\\\\Windows\\\\Security\\\\Audit\\\\audit.csv\n    C:\\\\Windows\\\\System32\\\\GroupPolicy\\\\Machine\\\\Microsoft\\\\Windows NT\\\\Audit\\\\audit.csv\n\n    Args:\n        option (str): The name of the option to set\n        value (str): The value to set. ['None', '0', '1', '2', '3']\n\n    Returns:\n        bool: ``True`` if successful, otherwise ``False``\n    \"\"\"\n    system_root = os.environ.get('SystemRoot', 'C:\\\\Windows')\n    f_audit = os.path.join(system_root, 'security', 'audit', 'audit.csv')\n    f_audit_gpo = os.path.join(system_root, 'System32', 'GroupPolicy', 'Machine', 'Microsoft', 'Windows NT', 'Audit', 'audit.csv')\n    f_temp = tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='.csv', prefix='audit')\n    auditpol_values = {'None': 'No Auditing', '0': 'No Auditing', '1': 'Success', '2': 'Failure', '3': 'Success and Failure'}\n    _advaudit_check_csv()\n    try:\n        with salt.utils.files.fopen(f_audit, mode='r') as csv_file:\n            reader = csv.DictReader(csv_file)\n            with salt.utils.files.fopen(f_temp.name, mode='w') as tmp_file:\n                writer = csv.DictWriter(tmp_file, fieldnames=reader.fieldnames)\n                writer.writeheader()\n                value_written = False\n                for row in reader:\n                    if row['Subcategory'] == option:\n                        if not value == 'None':\n                            row['Inclusion Setting'] = auditpol_values[value]\n                            row['Setting Value'] = value\n                            log.trace('LGPO: Setting %s to %s', option, value)\n                            writer.writerow(row)\n                        else:\n                            log.trace('LGPO: Removing %s', option)\n                        value_written = True\n                    else:\n                        writer.writerow(row)\n                if not value_written:\n                    if not value == 'None':\n                        log.trace('LGPO: Setting %s to %s', option, value)\n                        defaults = _get_advaudit_defaults(option)\n                        writer.writerow({'Machine Name': defaults['Machine Name'], 'Policy Target': defaults['Policy Target'], 'Subcategory': defaults['Subcategory'], 'Subcategory GUID': defaults['Subcategory GUID'], 'Inclusion Setting': auditpol_values[value], 'Exclusion Setting': defaults['Exclusion Setting'], 'Setting Value': value})\n                    value_written = True\n        if value_written:\n            __salt__['file.copy'](f_temp.name, f_audit, remove_existing=True)\n            __salt__['file.makedirs'](f_audit_gpo)\n            __salt__['file.copy'](f_temp.name, f_audit_gpo, remove_existing=True)\n    finally:\n        f_temp.close()\n        __salt__['file.remove'](f_temp.name)\n    return value_written",
        "mutated": [
            "def _set_advaudit_file_data(option, value):\n    if False:\n        i = 10\n    \"\\n    Helper function that sets the Advanced Audit settings in the two .csv files\\n    on Windows. Those files are located at:\\n    C:\\\\Windows\\\\Security\\\\Audit\\\\audit.csv\\n    C:\\\\Windows\\\\System32\\\\GroupPolicy\\\\Machine\\\\Microsoft\\\\Windows NT\\\\Audit\\\\audit.csv\\n\\n    Args:\\n        option (str): The name of the option to set\\n        value (str): The value to set. ['None', '0', '1', '2', '3']\\n\\n    Returns:\\n        bool: ``True`` if successful, otherwise ``False``\\n    \"\n    system_root = os.environ.get('SystemRoot', 'C:\\\\Windows')\n    f_audit = os.path.join(system_root, 'security', 'audit', 'audit.csv')\n    f_audit_gpo = os.path.join(system_root, 'System32', 'GroupPolicy', 'Machine', 'Microsoft', 'Windows NT', 'Audit', 'audit.csv')\n    f_temp = tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='.csv', prefix='audit')\n    auditpol_values = {'None': 'No Auditing', '0': 'No Auditing', '1': 'Success', '2': 'Failure', '3': 'Success and Failure'}\n    _advaudit_check_csv()\n    try:\n        with salt.utils.files.fopen(f_audit, mode='r') as csv_file:\n            reader = csv.DictReader(csv_file)\n            with salt.utils.files.fopen(f_temp.name, mode='w') as tmp_file:\n                writer = csv.DictWriter(tmp_file, fieldnames=reader.fieldnames)\n                writer.writeheader()\n                value_written = False\n                for row in reader:\n                    if row['Subcategory'] == option:\n                        if not value == 'None':\n                            row['Inclusion Setting'] = auditpol_values[value]\n                            row['Setting Value'] = value\n                            log.trace('LGPO: Setting %s to %s', option, value)\n                            writer.writerow(row)\n                        else:\n                            log.trace('LGPO: Removing %s', option)\n                        value_written = True\n                    else:\n                        writer.writerow(row)\n                if not value_written:\n                    if not value == 'None':\n                        log.trace('LGPO: Setting %s to %s', option, value)\n                        defaults = _get_advaudit_defaults(option)\n                        writer.writerow({'Machine Name': defaults['Machine Name'], 'Policy Target': defaults['Policy Target'], 'Subcategory': defaults['Subcategory'], 'Subcategory GUID': defaults['Subcategory GUID'], 'Inclusion Setting': auditpol_values[value], 'Exclusion Setting': defaults['Exclusion Setting'], 'Setting Value': value})\n                    value_written = True\n        if value_written:\n            __salt__['file.copy'](f_temp.name, f_audit, remove_existing=True)\n            __salt__['file.makedirs'](f_audit_gpo)\n            __salt__['file.copy'](f_temp.name, f_audit_gpo, remove_existing=True)\n    finally:\n        f_temp.close()\n        __salt__['file.remove'](f_temp.name)\n    return value_written",
            "def _set_advaudit_file_data(option, value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Helper function that sets the Advanced Audit settings in the two .csv files\\n    on Windows. Those files are located at:\\n    C:\\\\Windows\\\\Security\\\\Audit\\\\audit.csv\\n    C:\\\\Windows\\\\System32\\\\GroupPolicy\\\\Machine\\\\Microsoft\\\\Windows NT\\\\Audit\\\\audit.csv\\n\\n    Args:\\n        option (str): The name of the option to set\\n        value (str): The value to set. ['None', '0', '1', '2', '3']\\n\\n    Returns:\\n        bool: ``True`` if successful, otherwise ``False``\\n    \"\n    system_root = os.environ.get('SystemRoot', 'C:\\\\Windows')\n    f_audit = os.path.join(system_root, 'security', 'audit', 'audit.csv')\n    f_audit_gpo = os.path.join(system_root, 'System32', 'GroupPolicy', 'Machine', 'Microsoft', 'Windows NT', 'Audit', 'audit.csv')\n    f_temp = tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='.csv', prefix='audit')\n    auditpol_values = {'None': 'No Auditing', '0': 'No Auditing', '1': 'Success', '2': 'Failure', '3': 'Success and Failure'}\n    _advaudit_check_csv()\n    try:\n        with salt.utils.files.fopen(f_audit, mode='r') as csv_file:\n            reader = csv.DictReader(csv_file)\n            with salt.utils.files.fopen(f_temp.name, mode='w') as tmp_file:\n                writer = csv.DictWriter(tmp_file, fieldnames=reader.fieldnames)\n                writer.writeheader()\n                value_written = False\n                for row in reader:\n                    if row['Subcategory'] == option:\n                        if not value == 'None':\n                            row['Inclusion Setting'] = auditpol_values[value]\n                            row['Setting Value'] = value\n                            log.trace('LGPO: Setting %s to %s', option, value)\n                            writer.writerow(row)\n                        else:\n                            log.trace('LGPO: Removing %s', option)\n                        value_written = True\n                    else:\n                        writer.writerow(row)\n                if not value_written:\n                    if not value == 'None':\n                        log.trace('LGPO: Setting %s to %s', option, value)\n                        defaults = _get_advaudit_defaults(option)\n                        writer.writerow({'Machine Name': defaults['Machine Name'], 'Policy Target': defaults['Policy Target'], 'Subcategory': defaults['Subcategory'], 'Subcategory GUID': defaults['Subcategory GUID'], 'Inclusion Setting': auditpol_values[value], 'Exclusion Setting': defaults['Exclusion Setting'], 'Setting Value': value})\n                    value_written = True\n        if value_written:\n            __salt__['file.copy'](f_temp.name, f_audit, remove_existing=True)\n            __salt__['file.makedirs'](f_audit_gpo)\n            __salt__['file.copy'](f_temp.name, f_audit_gpo, remove_existing=True)\n    finally:\n        f_temp.close()\n        __salt__['file.remove'](f_temp.name)\n    return value_written",
            "def _set_advaudit_file_data(option, value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Helper function that sets the Advanced Audit settings in the two .csv files\\n    on Windows. Those files are located at:\\n    C:\\\\Windows\\\\Security\\\\Audit\\\\audit.csv\\n    C:\\\\Windows\\\\System32\\\\GroupPolicy\\\\Machine\\\\Microsoft\\\\Windows NT\\\\Audit\\\\audit.csv\\n\\n    Args:\\n        option (str): The name of the option to set\\n        value (str): The value to set. ['None', '0', '1', '2', '3']\\n\\n    Returns:\\n        bool: ``True`` if successful, otherwise ``False``\\n    \"\n    system_root = os.environ.get('SystemRoot', 'C:\\\\Windows')\n    f_audit = os.path.join(system_root, 'security', 'audit', 'audit.csv')\n    f_audit_gpo = os.path.join(system_root, 'System32', 'GroupPolicy', 'Machine', 'Microsoft', 'Windows NT', 'Audit', 'audit.csv')\n    f_temp = tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='.csv', prefix='audit')\n    auditpol_values = {'None': 'No Auditing', '0': 'No Auditing', '1': 'Success', '2': 'Failure', '3': 'Success and Failure'}\n    _advaudit_check_csv()\n    try:\n        with salt.utils.files.fopen(f_audit, mode='r') as csv_file:\n            reader = csv.DictReader(csv_file)\n            with salt.utils.files.fopen(f_temp.name, mode='w') as tmp_file:\n                writer = csv.DictWriter(tmp_file, fieldnames=reader.fieldnames)\n                writer.writeheader()\n                value_written = False\n                for row in reader:\n                    if row['Subcategory'] == option:\n                        if not value == 'None':\n                            row['Inclusion Setting'] = auditpol_values[value]\n                            row['Setting Value'] = value\n                            log.trace('LGPO: Setting %s to %s', option, value)\n                            writer.writerow(row)\n                        else:\n                            log.trace('LGPO: Removing %s', option)\n                        value_written = True\n                    else:\n                        writer.writerow(row)\n                if not value_written:\n                    if not value == 'None':\n                        log.trace('LGPO: Setting %s to %s', option, value)\n                        defaults = _get_advaudit_defaults(option)\n                        writer.writerow({'Machine Name': defaults['Machine Name'], 'Policy Target': defaults['Policy Target'], 'Subcategory': defaults['Subcategory'], 'Subcategory GUID': defaults['Subcategory GUID'], 'Inclusion Setting': auditpol_values[value], 'Exclusion Setting': defaults['Exclusion Setting'], 'Setting Value': value})\n                    value_written = True\n        if value_written:\n            __salt__['file.copy'](f_temp.name, f_audit, remove_existing=True)\n            __salt__['file.makedirs'](f_audit_gpo)\n            __salt__['file.copy'](f_temp.name, f_audit_gpo, remove_existing=True)\n    finally:\n        f_temp.close()\n        __salt__['file.remove'](f_temp.name)\n    return value_written",
            "def _set_advaudit_file_data(option, value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Helper function that sets the Advanced Audit settings in the two .csv files\\n    on Windows. Those files are located at:\\n    C:\\\\Windows\\\\Security\\\\Audit\\\\audit.csv\\n    C:\\\\Windows\\\\System32\\\\GroupPolicy\\\\Machine\\\\Microsoft\\\\Windows NT\\\\Audit\\\\audit.csv\\n\\n    Args:\\n        option (str): The name of the option to set\\n        value (str): The value to set. ['None', '0', '1', '2', '3']\\n\\n    Returns:\\n        bool: ``True`` if successful, otherwise ``False``\\n    \"\n    system_root = os.environ.get('SystemRoot', 'C:\\\\Windows')\n    f_audit = os.path.join(system_root, 'security', 'audit', 'audit.csv')\n    f_audit_gpo = os.path.join(system_root, 'System32', 'GroupPolicy', 'Machine', 'Microsoft', 'Windows NT', 'Audit', 'audit.csv')\n    f_temp = tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='.csv', prefix='audit')\n    auditpol_values = {'None': 'No Auditing', '0': 'No Auditing', '1': 'Success', '2': 'Failure', '3': 'Success and Failure'}\n    _advaudit_check_csv()\n    try:\n        with salt.utils.files.fopen(f_audit, mode='r') as csv_file:\n            reader = csv.DictReader(csv_file)\n            with salt.utils.files.fopen(f_temp.name, mode='w') as tmp_file:\n                writer = csv.DictWriter(tmp_file, fieldnames=reader.fieldnames)\n                writer.writeheader()\n                value_written = False\n                for row in reader:\n                    if row['Subcategory'] == option:\n                        if not value == 'None':\n                            row['Inclusion Setting'] = auditpol_values[value]\n                            row['Setting Value'] = value\n                            log.trace('LGPO: Setting %s to %s', option, value)\n                            writer.writerow(row)\n                        else:\n                            log.trace('LGPO: Removing %s', option)\n                        value_written = True\n                    else:\n                        writer.writerow(row)\n                if not value_written:\n                    if not value == 'None':\n                        log.trace('LGPO: Setting %s to %s', option, value)\n                        defaults = _get_advaudit_defaults(option)\n                        writer.writerow({'Machine Name': defaults['Machine Name'], 'Policy Target': defaults['Policy Target'], 'Subcategory': defaults['Subcategory'], 'Subcategory GUID': defaults['Subcategory GUID'], 'Inclusion Setting': auditpol_values[value], 'Exclusion Setting': defaults['Exclusion Setting'], 'Setting Value': value})\n                    value_written = True\n        if value_written:\n            __salt__['file.copy'](f_temp.name, f_audit, remove_existing=True)\n            __salt__['file.makedirs'](f_audit_gpo)\n            __salt__['file.copy'](f_temp.name, f_audit_gpo, remove_existing=True)\n    finally:\n        f_temp.close()\n        __salt__['file.remove'](f_temp.name)\n    return value_written",
            "def _set_advaudit_file_data(option, value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Helper function that sets the Advanced Audit settings in the two .csv files\\n    on Windows. Those files are located at:\\n    C:\\\\Windows\\\\Security\\\\Audit\\\\audit.csv\\n    C:\\\\Windows\\\\System32\\\\GroupPolicy\\\\Machine\\\\Microsoft\\\\Windows NT\\\\Audit\\\\audit.csv\\n\\n    Args:\\n        option (str): The name of the option to set\\n        value (str): The value to set. ['None', '0', '1', '2', '3']\\n\\n    Returns:\\n        bool: ``True`` if successful, otherwise ``False``\\n    \"\n    system_root = os.environ.get('SystemRoot', 'C:\\\\Windows')\n    f_audit = os.path.join(system_root, 'security', 'audit', 'audit.csv')\n    f_audit_gpo = os.path.join(system_root, 'System32', 'GroupPolicy', 'Machine', 'Microsoft', 'Windows NT', 'Audit', 'audit.csv')\n    f_temp = tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='.csv', prefix='audit')\n    auditpol_values = {'None': 'No Auditing', '0': 'No Auditing', '1': 'Success', '2': 'Failure', '3': 'Success and Failure'}\n    _advaudit_check_csv()\n    try:\n        with salt.utils.files.fopen(f_audit, mode='r') as csv_file:\n            reader = csv.DictReader(csv_file)\n            with salt.utils.files.fopen(f_temp.name, mode='w') as tmp_file:\n                writer = csv.DictWriter(tmp_file, fieldnames=reader.fieldnames)\n                writer.writeheader()\n                value_written = False\n                for row in reader:\n                    if row['Subcategory'] == option:\n                        if not value == 'None':\n                            row['Inclusion Setting'] = auditpol_values[value]\n                            row['Setting Value'] = value\n                            log.trace('LGPO: Setting %s to %s', option, value)\n                            writer.writerow(row)\n                        else:\n                            log.trace('LGPO: Removing %s', option)\n                        value_written = True\n                    else:\n                        writer.writerow(row)\n                if not value_written:\n                    if not value == 'None':\n                        log.trace('LGPO: Setting %s to %s', option, value)\n                        defaults = _get_advaudit_defaults(option)\n                        writer.writerow({'Machine Name': defaults['Machine Name'], 'Policy Target': defaults['Policy Target'], 'Subcategory': defaults['Subcategory'], 'Subcategory GUID': defaults['Subcategory GUID'], 'Inclusion Setting': auditpol_values[value], 'Exclusion Setting': defaults['Exclusion Setting'], 'Setting Value': value})\n                    value_written = True\n        if value_written:\n            __salt__['file.copy'](f_temp.name, f_audit, remove_existing=True)\n            __salt__['file.makedirs'](f_audit_gpo)\n            __salt__['file.copy'](f_temp.name, f_audit_gpo, remove_existing=True)\n    finally:\n        f_temp.close()\n        __salt__['file.remove'](f_temp.name)\n    return value_written"
        ]
    },
    {
        "func_name": "_set_advaudit_pol_data",
        "original": "def _set_advaudit_pol_data(option, value):\n    \"\"\"\n    Helper function that updates the current applied settings to match what has\n    just been set in the audit.csv files. We're doing it this way instead of\n    running `gpupdate`\n\n    Args:\n        option (str): The name of the option to set\n        value (str): The value to set. ['None', '0', '1', '2', '3']\n\n    Returns:\n        bool: ``True`` if successful, otherwise ``False``\n    \"\"\"\n    auditpol_values = {'None': 'No Auditing', '0': 'No Auditing', '1': 'Success', '2': 'Failure', '3': 'Success and Failure'}\n    defaults = _get_advaudit_defaults(option)\n    return __utils__['auditpol.set_setting'](name=defaults['Auditpol Name'], value=auditpol_values[value])",
        "mutated": [
            "def _set_advaudit_pol_data(option, value):\n    if False:\n        i = 10\n    \"\\n    Helper function that updates the current applied settings to match what has\\n    just been set in the audit.csv files. We're doing it this way instead of\\n    running `gpupdate`\\n\\n    Args:\\n        option (str): The name of the option to set\\n        value (str): The value to set. ['None', '0', '1', '2', '3']\\n\\n    Returns:\\n        bool: ``True`` if successful, otherwise ``False``\\n    \"\n    auditpol_values = {'None': 'No Auditing', '0': 'No Auditing', '1': 'Success', '2': 'Failure', '3': 'Success and Failure'}\n    defaults = _get_advaudit_defaults(option)\n    return __utils__['auditpol.set_setting'](name=defaults['Auditpol Name'], value=auditpol_values[value])",
            "def _set_advaudit_pol_data(option, value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Helper function that updates the current applied settings to match what has\\n    just been set in the audit.csv files. We're doing it this way instead of\\n    running `gpupdate`\\n\\n    Args:\\n        option (str): The name of the option to set\\n        value (str): The value to set. ['None', '0', '1', '2', '3']\\n\\n    Returns:\\n        bool: ``True`` if successful, otherwise ``False``\\n    \"\n    auditpol_values = {'None': 'No Auditing', '0': 'No Auditing', '1': 'Success', '2': 'Failure', '3': 'Success and Failure'}\n    defaults = _get_advaudit_defaults(option)\n    return __utils__['auditpol.set_setting'](name=defaults['Auditpol Name'], value=auditpol_values[value])",
            "def _set_advaudit_pol_data(option, value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Helper function that updates the current applied settings to match what has\\n    just been set in the audit.csv files. We're doing it this way instead of\\n    running `gpupdate`\\n\\n    Args:\\n        option (str): The name of the option to set\\n        value (str): The value to set. ['None', '0', '1', '2', '3']\\n\\n    Returns:\\n        bool: ``True`` if successful, otherwise ``False``\\n    \"\n    auditpol_values = {'None': 'No Auditing', '0': 'No Auditing', '1': 'Success', '2': 'Failure', '3': 'Success and Failure'}\n    defaults = _get_advaudit_defaults(option)\n    return __utils__['auditpol.set_setting'](name=defaults['Auditpol Name'], value=auditpol_values[value])",
            "def _set_advaudit_pol_data(option, value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Helper function that updates the current applied settings to match what has\\n    just been set in the audit.csv files. We're doing it this way instead of\\n    running `gpupdate`\\n\\n    Args:\\n        option (str): The name of the option to set\\n        value (str): The value to set. ['None', '0', '1', '2', '3']\\n\\n    Returns:\\n        bool: ``True`` if successful, otherwise ``False``\\n    \"\n    auditpol_values = {'None': 'No Auditing', '0': 'No Auditing', '1': 'Success', '2': 'Failure', '3': 'Success and Failure'}\n    defaults = _get_advaudit_defaults(option)\n    return __utils__['auditpol.set_setting'](name=defaults['Auditpol Name'], value=auditpol_values[value])",
            "def _set_advaudit_pol_data(option, value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Helper function that updates the current applied settings to match what has\\n    just been set in the audit.csv files. We're doing it this way instead of\\n    running `gpupdate`\\n\\n    Args:\\n        option (str): The name of the option to set\\n        value (str): The value to set. ['None', '0', '1', '2', '3']\\n\\n    Returns:\\n        bool: ``True`` if successful, otherwise ``False``\\n    \"\n    auditpol_values = {'None': 'No Auditing', '0': 'No Auditing', '1': 'Success', '2': 'Failure', '3': 'Success and Failure'}\n    defaults = _get_advaudit_defaults(option)\n    return __utils__['auditpol.set_setting'](name=defaults['Auditpol Name'], value=auditpol_values[value])"
        ]
    },
    {
        "func_name": "_set_advaudit_value",
        "original": "def _set_advaudit_value(option, value):\n    \"\"\"\n    Helper function to update the Advanced Audit policy on the machine. This\n    function modifies the two ``audit.csv`` files in the following locations:\n\n    C:\\\\Windows\\\\Security\\\\Audit\\\\audit.csv\n    C:\\\\Windows\\\\System32\\\\GroupPolicy\\\\Machine\\\\Microsoft\\\\Windows NT\\\\Audit\\\\audit.csv\n\n    Then it applies those settings using ``auditpol``\n\n    After that, it updates ``__context__`` with the new setting\n\n    Args:\n        option (str): The name of the option to set\n        value (str): The value to set. ['None', '0', '1', '2', '3']\n\n    Returns:\n        bool: ``True`` if successful, otherwise ``False``\n    \"\"\"\n    if not _set_advaudit_file_data(option=option, value=value):\n        raise CommandExecutionError(f'Failed to set audit.csv option: {option}')\n    if not _set_advaudit_pol_data(option=option, value=value):\n        log.error('Failed to apply audit setting: %s\\nPolicy will take effect on next GPO update', option)\n    if 'lgpo.adv_audit_data' not in __context__:\n        _get_advaudit_value(option)\n    if value is None:\n        log.debug('LGPO: Removing Advanced Audit data: %s', option)\n        __context__['lgpo.adv_audit_data'].pop(option)\n    else:\n        log.debug('LGPO: Updating Advanced Audit data: %s: %s', option, value)\n        __context__['lgpo.adv_audit_data'][option] = value\n    return True",
        "mutated": [
            "def _set_advaudit_value(option, value):\n    if False:\n        i = 10\n    \"\\n    Helper function to update the Advanced Audit policy on the machine. This\\n    function modifies the two ``audit.csv`` files in the following locations:\\n\\n    C:\\\\Windows\\\\Security\\\\Audit\\\\audit.csv\\n    C:\\\\Windows\\\\System32\\\\GroupPolicy\\\\Machine\\\\Microsoft\\\\Windows NT\\\\Audit\\\\audit.csv\\n\\n    Then it applies those settings using ``auditpol``\\n\\n    After that, it updates ``__context__`` with the new setting\\n\\n    Args:\\n        option (str): The name of the option to set\\n        value (str): The value to set. ['None', '0', '1', '2', '3']\\n\\n    Returns:\\n        bool: ``True`` if successful, otherwise ``False``\\n    \"\n    if not _set_advaudit_file_data(option=option, value=value):\n        raise CommandExecutionError(f'Failed to set audit.csv option: {option}')\n    if not _set_advaudit_pol_data(option=option, value=value):\n        log.error('Failed to apply audit setting: %s\\nPolicy will take effect on next GPO update', option)\n    if 'lgpo.adv_audit_data' not in __context__:\n        _get_advaudit_value(option)\n    if value is None:\n        log.debug('LGPO: Removing Advanced Audit data: %s', option)\n        __context__['lgpo.adv_audit_data'].pop(option)\n    else:\n        log.debug('LGPO: Updating Advanced Audit data: %s: %s', option, value)\n        __context__['lgpo.adv_audit_data'][option] = value\n    return True",
            "def _set_advaudit_value(option, value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Helper function to update the Advanced Audit policy on the machine. This\\n    function modifies the two ``audit.csv`` files in the following locations:\\n\\n    C:\\\\Windows\\\\Security\\\\Audit\\\\audit.csv\\n    C:\\\\Windows\\\\System32\\\\GroupPolicy\\\\Machine\\\\Microsoft\\\\Windows NT\\\\Audit\\\\audit.csv\\n\\n    Then it applies those settings using ``auditpol``\\n\\n    After that, it updates ``__context__`` with the new setting\\n\\n    Args:\\n        option (str): The name of the option to set\\n        value (str): The value to set. ['None', '0', '1', '2', '3']\\n\\n    Returns:\\n        bool: ``True`` if successful, otherwise ``False``\\n    \"\n    if not _set_advaudit_file_data(option=option, value=value):\n        raise CommandExecutionError(f'Failed to set audit.csv option: {option}')\n    if not _set_advaudit_pol_data(option=option, value=value):\n        log.error('Failed to apply audit setting: %s\\nPolicy will take effect on next GPO update', option)\n    if 'lgpo.adv_audit_data' not in __context__:\n        _get_advaudit_value(option)\n    if value is None:\n        log.debug('LGPO: Removing Advanced Audit data: %s', option)\n        __context__['lgpo.adv_audit_data'].pop(option)\n    else:\n        log.debug('LGPO: Updating Advanced Audit data: %s: %s', option, value)\n        __context__['lgpo.adv_audit_data'][option] = value\n    return True",
            "def _set_advaudit_value(option, value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Helper function to update the Advanced Audit policy on the machine. This\\n    function modifies the two ``audit.csv`` files in the following locations:\\n\\n    C:\\\\Windows\\\\Security\\\\Audit\\\\audit.csv\\n    C:\\\\Windows\\\\System32\\\\GroupPolicy\\\\Machine\\\\Microsoft\\\\Windows NT\\\\Audit\\\\audit.csv\\n\\n    Then it applies those settings using ``auditpol``\\n\\n    After that, it updates ``__context__`` with the new setting\\n\\n    Args:\\n        option (str): The name of the option to set\\n        value (str): The value to set. ['None', '0', '1', '2', '3']\\n\\n    Returns:\\n        bool: ``True`` if successful, otherwise ``False``\\n    \"\n    if not _set_advaudit_file_data(option=option, value=value):\n        raise CommandExecutionError(f'Failed to set audit.csv option: {option}')\n    if not _set_advaudit_pol_data(option=option, value=value):\n        log.error('Failed to apply audit setting: %s\\nPolicy will take effect on next GPO update', option)\n    if 'lgpo.adv_audit_data' not in __context__:\n        _get_advaudit_value(option)\n    if value is None:\n        log.debug('LGPO: Removing Advanced Audit data: %s', option)\n        __context__['lgpo.adv_audit_data'].pop(option)\n    else:\n        log.debug('LGPO: Updating Advanced Audit data: %s: %s', option, value)\n        __context__['lgpo.adv_audit_data'][option] = value\n    return True",
            "def _set_advaudit_value(option, value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Helper function to update the Advanced Audit policy on the machine. This\\n    function modifies the two ``audit.csv`` files in the following locations:\\n\\n    C:\\\\Windows\\\\Security\\\\Audit\\\\audit.csv\\n    C:\\\\Windows\\\\System32\\\\GroupPolicy\\\\Machine\\\\Microsoft\\\\Windows NT\\\\Audit\\\\audit.csv\\n\\n    Then it applies those settings using ``auditpol``\\n\\n    After that, it updates ``__context__`` with the new setting\\n\\n    Args:\\n        option (str): The name of the option to set\\n        value (str): The value to set. ['None', '0', '1', '2', '3']\\n\\n    Returns:\\n        bool: ``True`` if successful, otherwise ``False``\\n    \"\n    if not _set_advaudit_file_data(option=option, value=value):\n        raise CommandExecutionError(f'Failed to set audit.csv option: {option}')\n    if not _set_advaudit_pol_data(option=option, value=value):\n        log.error('Failed to apply audit setting: %s\\nPolicy will take effect on next GPO update', option)\n    if 'lgpo.adv_audit_data' not in __context__:\n        _get_advaudit_value(option)\n    if value is None:\n        log.debug('LGPO: Removing Advanced Audit data: %s', option)\n        __context__['lgpo.adv_audit_data'].pop(option)\n    else:\n        log.debug('LGPO: Updating Advanced Audit data: %s: %s', option, value)\n        __context__['lgpo.adv_audit_data'][option] = value\n    return True",
            "def _set_advaudit_value(option, value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Helper function to update the Advanced Audit policy on the machine. This\\n    function modifies the two ``audit.csv`` files in the following locations:\\n\\n    C:\\\\Windows\\\\Security\\\\Audit\\\\audit.csv\\n    C:\\\\Windows\\\\System32\\\\GroupPolicy\\\\Machine\\\\Microsoft\\\\Windows NT\\\\Audit\\\\audit.csv\\n\\n    Then it applies those settings using ``auditpol``\\n\\n    After that, it updates ``__context__`` with the new setting\\n\\n    Args:\\n        option (str): The name of the option to set\\n        value (str): The value to set. ['None', '0', '1', '2', '3']\\n\\n    Returns:\\n        bool: ``True`` if successful, otherwise ``False``\\n    \"\n    if not _set_advaudit_file_data(option=option, value=value):\n        raise CommandExecutionError(f'Failed to set audit.csv option: {option}')\n    if not _set_advaudit_pol_data(option=option, value=value):\n        log.error('Failed to apply audit setting: %s\\nPolicy will take effect on next GPO update', option)\n    if 'lgpo.adv_audit_data' not in __context__:\n        _get_advaudit_value(option)\n    if value is None:\n        log.debug('LGPO: Removing Advanced Audit data: %s', option)\n        __context__['lgpo.adv_audit_data'].pop(option)\n    else:\n        log.debug('LGPO: Updating Advanced Audit data: %s: %s', option, value)\n        __context__['lgpo.adv_audit_data'][option] = value\n    return True"
        ]
    },
    {
        "func_name": "_get_netsh_value",
        "original": "def _get_netsh_value(profile, option):\n    if 'lgpo.netsh_data' not in __context__:\n        __context__['lgpo.netsh_data'] = {}\n    if profile not in __context__['lgpo.netsh_data']:\n        log.debug('LGPO: Loading netsh data for %s profile', profile)\n        settings = salt.utils.win_lgpo_netsh.get_all_settings(profile=profile, store='lgpo')\n        __context__['lgpo.netsh_data'].update({profile: settings})\n    log.trace('LGPO: netsh returning value: %s', __context__['lgpo.netsh_data'][profile][option])\n    return __context__['lgpo.netsh_data'][profile][option]",
        "mutated": [
            "def _get_netsh_value(profile, option):\n    if False:\n        i = 10\n    if 'lgpo.netsh_data' not in __context__:\n        __context__['lgpo.netsh_data'] = {}\n    if profile not in __context__['lgpo.netsh_data']:\n        log.debug('LGPO: Loading netsh data for %s profile', profile)\n        settings = salt.utils.win_lgpo_netsh.get_all_settings(profile=profile, store='lgpo')\n        __context__['lgpo.netsh_data'].update({profile: settings})\n    log.trace('LGPO: netsh returning value: %s', __context__['lgpo.netsh_data'][profile][option])\n    return __context__['lgpo.netsh_data'][profile][option]",
            "def _get_netsh_value(profile, option):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if 'lgpo.netsh_data' not in __context__:\n        __context__['lgpo.netsh_data'] = {}\n    if profile not in __context__['lgpo.netsh_data']:\n        log.debug('LGPO: Loading netsh data for %s profile', profile)\n        settings = salt.utils.win_lgpo_netsh.get_all_settings(profile=profile, store='lgpo')\n        __context__['lgpo.netsh_data'].update({profile: settings})\n    log.trace('LGPO: netsh returning value: %s', __context__['lgpo.netsh_data'][profile][option])\n    return __context__['lgpo.netsh_data'][profile][option]",
            "def _get_netsh_value(profile, option):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if 'lgpo.netsh_data' not in __context__:\n        __context__['lgpo.netsh_data'] = {}\n    if profile not in __context__['lgpo.netsh_data']:\n        log.debug('LGPO: Loading netsh data for %s profile', profile)\n        settings = salt.utils.win_lgpo_netsh.get_all_settings(profile=profile, store='lgpo')\n        __context__['lgpo.netsh_data'].update({profile: settings})\n    log.trace('LGPO: netsh returning value: %s', __context__['lgpo.netsh_data'][profile][option])\n    return __context__['lgpo.netsh_data'][profile][option]",
            "def _get_netsh_value(profile, option):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if 'lgpo.netsh_data' not in __context__:\n        __context__['lgpo.netsh_data'] = {}\n    if profile not in __context__['lgpo.netsh_data']:\n        log.debug('LGPO: Loading netsh data for %s profile', profile)\n        settings = salt.utils.win_lgpo_netsh.get_all_settings(profile=profile, store='lgpo')\n        __context__['lgpo.netsh_data'].update({profile: settings})\n    log.trace('LGPO: netsh returning value: %s', __context__['lgpo.netsh_data'][profile][option])\n    return __context__['lgpo.netsh_data'][profile][option]",
            "def _get_netsh_value(profile, option):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if 'lgpo.netsh_data' not in __context__:\n        __context__['lgpo.netsh_data'] = {}\n    if profile not in __context__['lgpo.netsh_data']:\n        log.debug('LGPO: Loading netsh data for %s profile', profile)\n        settings = salt.utils.win_lgpo_netsh.get_all_settings(profile=profile, store='lgpo')\n        __context__['lgpo.netsh_data'].update({profile: settings})\n    log.trace('LGPO: netsh returning value: %s', __context__['lgpo.netsh_data'][profile][option])\n    return __context__['lgpo.netsh_data'][profile][option]"
        ]
    },
    {
        "func_name": "_set_netsh_value",
        "original": "def _set_netsh_value(profile, section, option, value):\n    if section not in ('firewallpolicy', 'settings', 'logging', 'state'):\n        raise ValueError(f'LGPO: Invalid section: {section}')\n    log.trace('LGPO: Setting the following\\nProfile: %s\\nSection: %s\\nOption: %s\\nValue: %s', profile, section, option, value)\n    if section == 'firewallpolicy':\n        salt.utils.win_lgpo_netsh.set_firewall_settings(profile=profile, inbound=value if option == 'Inbound' else None, outbound=value if option == 'Outbound' else None, store='lgpo')\n    if section == 'settings':\n        salt.utils.win_lgpo_netsh.set_settings(profile=profile, setting=option, value=value, store='lgpo')\n    if section == 'state':\n        salt.utils.win_lgpo_netsh.set_state(profile=profile, state=value, store='lgpo')\n    if section == 'logging':\n        if option in ('FileName', 'MaxFileSize'):\n            if value == 'Not configured':\n                value = 'notconfigured'\n        if option.startswith('Log'):\n            option = option[3:]\n        salt.utils.win_lgpo_netsh.set_logging_settings(profile=profile, setting=option, value=value, store='lgpo')\n    log.trace('LGPO: Clearing netsh data for %s profile', profile)\n    __context__['lgpo.netsh_data'].pop(profile)\n    return True",
        "mutated": [
            "def _set_netsh_value(profile, section, option, value):\n    if False:\n        i = 10\n    if section not in ('firewallpolicy', 'settings', 'logging', 'state'):\n        raise ValueError(f'LGPO: Invalid section: {section}')\n    log.trace('LGPO: Setting the following\\nProfile: %s\\nSection: %s\\nOption: %s\\nValue: %s', profile, section, option, value)\n    if section == 'firewallpolicy':\n        salt.utils.win_lgpo_netsh.set_firewall_settings(profile=profile, inbound=value if option == 'Inbound' else None, outbound=value if option == 'Outbound' else None, store='lgpo')\n    if section == 'settings':\n        salt.utils.win_lgpo_netsh.set_settings(profile=profile, setting=option, value=value, store='lgpo')\n    if section == 'state':\n        salt.utils.win_lgpo_netsh.set_state(profile=profile, state=value, store='lgpo')\n    if section == 'logging':\n        if option in ('FileName', 'MaxFileSize'):\n            if value == 'Not configured':\n                value = 'notconfigured'\n        if option.startswith('Log'):\n            option = option[3:]\n        salt.utils.win_lgpo_netsh.set_logging_settings(profile=profile, setting=option, value=value, store='lgpo')\n    log.trace('LGPO: Clearing netsh data for %s profile', profile)\n    __context__['lgpo.netsh_data'].pop(profile)\n    return True",
            "def _set_netsh_value(profile, section, option, value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if section not in ('firewallpolicy', 'settings', 'logging', 'state'):\n        raise ValueError(f'LGPO: Invalid section: {section}')\n    log.trace('LGPO: Setting the following\\nProfile: %s\\nSection: %s\\nOption: %s\\nValue: %s', profile, section, option, value)\n    if section == 'firewallpolicy':\n        salt.utils.win_lgpo_netsh.set_firewall_settings(profile=profile, inbound=value if option == 'Inbound' else None, outbound=value if option == 'Outbound' else None, store='lgpo')\n    if section == 'settings':\n        salt.utils.win_lgpo_netsh.set_settings(profile=profile, setting=option, value=value, store='lgpo')\n    if section == 'state':\n        salt.utils.win_lgpo_netsh.set_state(profile=profile, state=value, store='lgpo')\n    if section == 'logging':\n        if option in ('FileName', 'MaxFileSize'):\n            if value == 'Not configured':\n                value = 'notconfigured'\n        if option.startswith('Log'):\n            option = option[3:]\n        salt.utils.win_lgpo_netsh.set_logging_settings(profile=profile, setting=option, value=value, store='lgpo')\n    log.trace('LGPO: Clearing netsh data for %s profile', profile)\n    __context__['lgpo.netsh_data'].pop(profile)\n    return True",
            "def _set_netsh_value(profile, section, option, value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if section not in ('firewallpolicy', 'settings', 'logging', 'state'):\n        raise ValueError(f'LGPO: Invalid section: {section}')\n    log.trace('LGPO: Setting the following\\nProfile: %s\\nSection: %s\\nOption: %s\\nValue: %s', profile, section, option, value)\n    if section == 'firewallpolicy':\n        salt.utils.win_lgpo_netsh.set_firewall_settings(profile=profile, inbound=value if option == 'Inbound' else None, outbound=value if option == 'Outbound' else None, store='lgpo')\n    if section == 'settings':\n        salt.utils.win_lgpo_netsh.set_settings(profile=profile, setting=option, value=value, store='lgpo')\n    if section == 'state':\n        salt.utils.win_lgpo_netsh.set_state(profile=profile, state=value, store='lgpo')\n    if section == 'logging':\n        if option in ('FileName', 'MaxFileSize'):\n            if value == 'Not configured':\n                value = 'notconfigured'\n        if option.startswith('Log'):\n            option = option[3:]\n        salt.utils.win_lgpo_netsh.set_logging_settings(profile=profile, setting=option, value=value, store='lgpo')\n    log.trace('LGPO: Clearing netsh data for %s profile', profile)\n    __context__['lgpo.netsh_data'].pop(profile)\n    return True",
            "def _set_netsh_value(profile, section, option, value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if section not in ('firewallpolicy', 'settings', 'logging', 'state'):\n        raise ValueError(f'LGPO: Invalid section: {section}')\n    log.trace('LGPO: Setting the following\\nProfile: %s\\nSection: %s\\nOption: %s\\nValue: %s', profile, section, option, value)\n    if section == 'firewallpolicy':\n        salt.utils.win_lgpo_netsh.set_firewall_settings(profile=profile, inbound=value if option == 'Inbound' else None, outbound=value if option == 'Outbound' else None, store='lgpo')\n    if section == 'settings':\n        salt.utils.win_lgpo_netsh.set_settings(profile=profile, setting=option, value=value, store='lgpo')\n    if section == 'state':\n        salt.utils.win_lgpo_netsh.set_state(profile=profile, state=value, store='lgpo')\n    if section == 'logging':\n        if option in ('FileName', 'MaxFileSize'):\n            if value == 'Not configured':\n                value = 'notconfigured'\n        if option.startswith('Log'):\n            option = option[3:]\n        salt.utils.win_lgpo_netsh.set_logging_settings(profile=profile, setting=option, value=value, store='lgpo')\n    log.trace('LGPO: Clearing netsh data for %s profile', profile)\n    __context__['lgpo.netsh_data'].pop(profile)\n    return True",
            "def _set_netsh_value(profile, section, option, value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if section not in ('firewallpolicy', 'settings', 'logging', 'state'):\n        raise ValueError(f'LGPO: Invalid section: {section}')\n    log.trace('LGPO: Setting the following\\nProfile: %s\\nSection: %s\\nOption: %s\\nValue: %s', profile, section, option, value)\n    if section == 'firewallpolicy':\n        salt.utils.win_lgpo_netsh.set_firewall_settings(profile=profile, inbound=value if option == 'Inbound' else None, outbound=value if option == 'Outbound' else None, store='lgpo')\n    if section == 'settings':\n        salt.utils.win_lgpo_netsh.set_settings(profile=profile, setting=option, value=value, store='lgpo')\n    if section == 'state':\n        salt.utils.win_lgpo_netsh.set_state(profile=profile, state=value, store='lgpo')\n    if section == 'logging':\n        if option in ('FileName', 'MaxFileSize'):\n            if value == 'Not configured':\n                value = 'notconfigured'\n        if option.startswith('Log'):\n            option = option[3:]\n        salt.utils.win_lgpo_netsh.set_logging_settings(profile=profile, setting=option, value=value, store='lgpo')\n    log.trace('LGPO: Clearing netsh data for %s profile', profile)\n    __context__['lgpo.netsh_data'].pop(profile)\n    return True"
        ]
    },
    {
        "func_name": "_load_secedit_data",
        "original": "def _load_secedit_data():\n    \"\"\"\n    Helper function that loads secedit data. It runs `secedit /export /cfg\n    <file_name>` which creates a file that contains the secedit data.\n\n    Returns:\n        str: The contents of the file generated by the secedit command\n    \"\"\"\n    f_exp = os.path.join(__opts__['cachedir'], f'secedit-{UUID}.txt')\n    try:\n        __salt__['cmd.run'](['secedit', '/export', '/cfg', f_exp])\n        with salt.utils.files.fopen(f_exp, encoding='utf-16') as fp:\n            secedit_data = fp.readlines()\n        return secedit_data\n    finally:\n        if __salt__['file.file_exists'](f_exp):\n            __salt__['file.remove'](f_exp)",
        "mutated": [
            "def _load_secedit_data():\n    if False:\n        i = 10\n    '\\n    Helper function that loads secedit data. It runs `secedit /export /cfg\\n    <file_name>` which creates a file that contains the secedit data.\\n\\n    Returns:\\n        str: The contents of the file generated by the secedit command\\n    '\n    f_exp = os.path.join(__opts__['cachedir'], f'secedit-{UUID}.txt')\n    try:\n        __salt__['cmd.run'](['secedit', '/export', '/cfg', f_exp])\n        with salt.utils.files.fopen(f_exp, encoding='utf-16') as fp:\n            secedit_data = fp.readlines()\n        return secedit_data\n    finally:\n        if __salt__['file.file_exists'](f_exp):\n            __salt__['file.remove'](f_exp)",
            "def _load_secedit_data():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Helper function that loads secedit data. It runs `secedit /export /cfg\\n    <file_name>` which creates a file that contains the secedit data.\\n\\n    Returns:\\n        str: The contents of the file generated by the secedit command\\n    '\n    f_exp = os.path.join(__opts__['cachedir'], f'secedit-{UUID}.txt')\n    try:\n        __salt__['cmd.run'](['secedit', '/export', '/cfg', f_exp])\n        with salt.utils.files.fopen(f_exp, encoding='utf-16') as fp:\n            secedit_data = fp.readlines()\n        return secedit_data\n    finally:\n        if __salt__['file.file_exists'](f_exp):\n            __salt__['file.remove'](f_exp)",
            "def _load_secedit_data():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Helper function that loads secedit data. It runs `secedit /export /cfg\\n    <file_name>` which creates a file that contains the secedit data.\\n\\n    Returns:\\n        str: The contents of the file generated by the secedit command\\n    '\n    f_exp = os.path.join(__opts__['cachedir'], f'secedit-{UUID}.txt')\n    try:\n        __salt__['cmd.run'](['secedit', '/export', '/cfg', f_exp])\n        with salt.utils.files.fopen(f_exp, encoding='utf-16') as fp:\n            secedit_data = fp.readlines()\n        return secedit_data\n    finally:\n        if __salt__['file.file_exists'](f_exp):\n            __salt__['file.remove'](f_exp)",
            "def _load_secedit_data():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Helper function that loads secedit data. It runs `secedit /export /cfg\\n    <file_name>` which creates a file that contains the secedit data.\\n\\n    Returns:\\n        str: The contents of the file generated by the secedit command\\n    '\n    f_exp = os.path.join(__opts__['cachedir'], f'secedit-{UUID}.txt')\n    try:\n        __salt__['cmd.run'](['secedit', '/export', '/cfg', f_exp])\n        with salt.utils.files.fopen(f_exp, encoding='utf-16') as fp:\n            secedit_data = fp.readlines()\n        return secedit_data\n    finally:\n        if __salt__['file.file_exists'](f_exp):\n            __salt__['file.remove'](f_exp)",
            "def _load_secedit_data():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Helper function that loads secedit data. It runs `secedit /export /cfg\\n    <file_name>` which creates a file that contains the secedit data.\\n\\n    Returns:\\n        str: The contents of the file generated by the secedit command\\n    '\n    f_exp = os.path.join(__opts__['cachedir'], f'secedit-{UUID}.txt')\n    try:\n        __salt__['cmd.run'](['secedit', '/export', '/cfg', f_exp])\n        with salt.utils.files.fopen(f_exp, encoding='utf-16') as fp:\n            secedit_data = fp.readlines()\n        return secedit_data\n    finally:\n        if __salt__['file.file_exists'](f_exp):\n            __salt__['file.remove'](f_exp)"
        ]
    },
    {
        "func_name": "_get_secedit_data",
        "original": "def _get_secedit_data(refresh=False):\n    \"\"\"\n    Helper function that returns the secedit data in __context__ if it exists\n    and puts the secedit data in __context__ if it does not.\n\n    Args:\n\n        refresh (bool):\n            Refresh secedit data stored in __context__. This is needed for\n            testing where the state is setting the value, but the module that\n            is checking the value has its own __context__.\n\n    Returns:\n        str: secedit data from __context__\n    \"\"\"\n    if 'lgpo.secedit_data' not in __context__ or refresh is True:\n        log.debug('LGPO: Loading secedit data')\n        __context__['lgpo.secedit_data'] = _load_secedit_data()\n    return __context__['lgpo.secedit_data']",
        "mutated": [
            "def _get_secedit_data(refresh=False):\n    if False:\n        i = 10\n    '\\n    Helper function that returns the secedit data in __context__ if it exists\\n    and puts the secedit data in __context__ if it does not.\\n\\n    Args:\\n\\n        refresh (bool):\\n            Refresh secedit data stored in __context__. This is needed for\\n            testing where the state is setting the value, but the module that\\n            is checking the value has its own __context__.\\n\\n    Returns:\\n        str: secedit data from __context__\\n    '\n    if 'lgpo.secedit_data' not in __context__ or refresh is True:\n        log.debug('LGPO: Loading secedit data')\n        __context__['lgpo.secedit_data'] = _load_secedit_data()\n    return __context__['lgpo.secedit_data']",
            "def _get_secedit_data(refresh=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Helper function that returns the secedit data in __context__ if it exists\\n    and puts the secedit data in __context__ if it does not.\\n\\n    Args:\\n\\n        refresh (bool):\\n            Refresh secedit data stored in __context__. This is needed for\\n            testing where the state is setting the value, but the module that\\n            is checking the value has its own __context__.\\n\\n    Returns:\\n        str: secedit data from __context__\\n    '\n    if 'lgpo.secedit_data' not in __context__ or refresh is True:\n        log.debug('LGPO: Loading secedit data')\n        __context__['lgpo.secedit_data'] = _load_secedit_data()\n    return __context__['lgpo.secedit_data']",
            "def _get_secedit_data(refresh=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Helper function that returns the secedit data in __context__ if it exists\\n    and puts the secedit data in __context__ if it does not.\\n\\n    Args:\\n\\n        refresh (bool):\\n            Refresh secedit data stored in __context__. This is needed for\\n            testing where the state is setting the value, but the module that\\n            is checking the value has its own __context__.\\n\\n    Returns:\\n        str: secedit data from __context__\\n    '\n    if 'lgpo.secedit_data' not in __context__ or refresh is True:\n        log.debug('LGPO: Loading secedit data')\n        __context__['lgpo.secedit_data'] = _load_secedit_data()\n    return __context__['lgpo.secedit_data']",
            "def _get_secedit_data(refresh=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Helper function that returns the secedit data in __context__ if it exists\\n    and puts the secedit data in __context__ if it does not.\\n\\n    Args:\\n\\n        refresh (bool):\\n            Refresh secedit data stored in __context__. This is needed for\\n            testing where the state is setting the value, but the module that\\n            is checking the value has its own __context__.\\n\\n    Returns:\\n        str: secedit data from __context__\\n    '\n    if 'lgpo.secedit_data' not in __context__ or refresh is True:\n        log.debug('LGPO: Loading secedit data')\n        __context__['lgpo.secedit_data'] = _load_secedit_data()\n    return __context__['lgpo.secedit_data']",
            "def _get_secedit_data(refresh=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Helper function that returns the secedit data in __context__ if it exists\\n    and puts the secedit data in __context__ if it does not.\\n\\n    Args:\\n\\n        refresh (bool):\\n            Refresh secedit data stored in __context__. This is needed for\\n            testing where the state is setting the value, but the module that\\n            is checking the value has its own __context__.\\n\\n    Returns:\\n        str: secedit data from __context__\\n    '\n    if 'lgpo.secedit_data' not in __context__ or refresh is True:\n        log.debug('LGPO: Loading secedit data')\n        __context__['lgpo.secedit_data'] = _load_secedit_data()\n    return __context__['lgpo.secedit_data']"
        ]
    },
    {
        "func_name": "_get_secedit_value",
        "original": "def _get_secedit_value(option):\n    \"\"\"\n    Helper function that looks for the passed option in the secedit data\n    \"\"\"\n    secedit_data = _get_secedit_data()\n    for _line in secedit_data:\n        if _line.startswith(option):\n            return _line.split('=')[1].strip()\n    return 'Not Defined'",
        "mutated": [
            "def _get_secedit_value(option):\n    if False:\n        i = 10\n    '\\n    Helper function that looks for the passed option in the secedit data\\n    '\n    secedit_data = _get_secedit_data()\n    for _line in secedit_data:\n        if _line.startswith(option):\n            return _line.split('=')[1].strip()\n    return 'Not Defined'",
            "def _get_secedit_value(option):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Helper function that looks for the passed option in the secedit data\\n    '\n    secedit_data = _get_secedit_data()\n    for _line in secedit_data:\n        if _line.startswith(option):\n            return _line.split('=')[1].strip()\n    return 'Not Defined'",
            "def _get_secedit_value(option):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Helper function that looks for the passed option in the secedit data\\n    '\n    secedit_data = _get_secedit_data()\n    for _line in secedit_data:\n        if _line.startswith(option):\n            return _line.split('=')[1].strip()\n    return 'Not Defined'",
            "def _get_secedit_value(option):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Helper function that looks for the passed option in the secedit data\\n    '\n    secedit_data = _get_secedit_data()\n    for _line in secedit_data:\n        if _line.startswith(option):\n            return _line.split('=')[1].strip()\n    return 'Not Defined'",
            "def _get_secedit_value(option):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Helper function that looks for the passed option in the secedit data\\n    '\n    secedit_data = _get_secedit_data()\n    for _line in secedit_data:\n        if _line.startswith(option):\n            return _line.split('=')[1].strip()\n    return 'Not Defined'"
        ]
    },
    {
        "func_name": "_write_secedit_data",
        "original": "def _write_secedit_data(inf_data):\n    \"\"\"\n    Helper function to write secedit data to the database\n    \"\"\"\n    f_sdb = os.path.join(os.getenv('WINDIR'), 'security', 'database', 'salt.sdb')\n    f_inf = os.path.join(__opts__['cachedir'], f'secedit-{UUID}.inf')\n    try:\n        with salt.utils.files.fopen(f_inf, 'w', encoding='utf-16') as fp:\n            fp.write(inf_data)\n        cmd = ['secedit', '/import', '/db', f_sdb, '/cfg', f_inf]\n        retcode = __salt__['cmd.retcode'](cmd)\n        if not retcode == 0:\n            log.debug('Secedit failed to import template data')\n            return False\n        cmd = ['secedit', '/configure', '/db', f_sdb]\n        retcode = __salt__['cmd.retcode'](cmd)\n        if not retcode == 0:\n            log.debug('Secedit failed to apply security database')\n            return False\n        __context__.pop('lgpo.secedit_data', None)\n        return True\n    finally:\n        if __salt__['file.file_exists'](f_inf):\n            __salt__['file.remove'](f_inf)",
        "mutated": [
            "def _write_secedit_data(inf_data):\n    if False:\n        i = 10\n    '\\n    Helper function to write secedit data to the database\\n    '\n    f_sdb = os.path.join(os.getenv('WINDIR'), 'security', 'database', 'salt.sdb')\n    f_inf = os.path.join(__opts__['cachedir'], f'secedit-{UUID}.inf')\n    try:\n        with salt.utils.files.fopen(f_inf, 'w', encoding='utf-16') as fp:\n            fp.write(inf_data)\n        cmd = ['secedit', '/import', '/db', f_sdb, '/cfg', f_inf]\n        retcode = __salt__['cmd.retcode'](cmd)\n        if not retcode == 0:\n            log.debug('Secedit failed to import template data')\n            return False\n        cmd = ['secedit', '/configure', '/db', f_sdb]\n        retcode = __salt__['cmd.retcode'](cmd)\n        if not retcode == 0:\n            log.debug('Secedit failed to apply security database')\n            return False\n        __context__.pop('lgpo.secedit_data', None)\n        return True\n    finally:\n        if __salt__['file.file_exists'](f_inf):\n            __salt__['file.remove'](f_inf)",
            "def _write_secedit_data(inf_data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Helper function to write secedit data to the database\\n    '\n    f_sdb = os.path.join(os.getenv('WINDIR'), 'security', 'database', 'salt.sdb')\n    f_inf = os.path.join(__opts__['cachedir'], f'secedit-{UUID}.inf')\n    try:\n        with salt.utils.files.fopen(f_inf, 'w', encoding='utf-16') as fp:\n            fp.write(inf_data)\n        cmd = ['secedit', '/import', '/db', f_sdb, '/cfg', f_inf]\n        retcode = __salt__['cmd.retcode'](cmd)\n        if not retcode == 0:\n            log.debug('Secedit failed to import template data')\n            return False\n        cmd = ['secedit', '/configure', '/db', f_sdb]\n        retcode = __salt__['cmd.retcode'](cmd)\n        if not retcode == 0:\n            log.debug('Secedit failed to apply security database')\n            return False\n        __context__.pop('lgpo.secedit_data', None)\n        return True\n    finally:\n        if __salt__['file.file_exists'](f_inf):\n            __salt__['file.remove'](f_inf)",
            "def _write_secedit_data(inf_data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Helper function to write secedit data to the database\\n    '\n    f_sdb = os.path.join(os.getenv('WINDIR'), 'security', 'database', 'salt.sdb')\n    f_inf = os.path.join(__opts__['cachedir'], f'secedit-{UUID}.inf')\n    try:\n        with salt.utils.files.fopen(f_inf, 'w', encoding='utf-16') as fp:\n            fp.write(inf_data)\n        cmd = ['secedit', '/import', '/db', f_sdb, '/cfg', f_inf]\n        retcode = __salt__['cmd.retcode'](cmd)\n        if not retcode == 0:\n            log.debug('Secedit failed to import template data')\n            return False\n        cmd = ['secedit', '/configure', '/db', f_sdb]\n        retcode = __salt__['cmd.retcode'](cmd)\n        if not retcode == 0:\n            log.debug('Secedit failed to apply security database')\n            return False\n        __context__.pop('lgpo.secedit_data', None)\n        return True\n    finally:\n        if __salt__['file.file_exists'](f_inf):\n            __salt__['file.remove'](f_inf)",
            "def _write_secedit_data(inf_data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Helper function to write secedit data to the database\\n    '\n    f_sdb = os.path.join(os.getenv('WINDIR'), 'security', 'database', 'salt.sdb')\n    f_inf = os.path.join(__opts__['cachedir'], f'secedit-{UUID}.inf')\n    try:\n        with salt.utils.files.fopen(f_inf, 'w', encoding='utf-16') as fp:\n            fp.write(inf_data)\n        cmd = ['secedit', '/import', '/db', f_sdb, '/cfg', f_inf]\n        retcode = __salt__['cmd.retcode'](cmd)\n        if not retcode == 0:\n            log.debug('Secedit failed to import template data')\n            return False\n        cmd = ['secedit', '/configure', '/db', f_sdb]\n        retcode = __salt__['cmd.retcode'](cmd)\n        if not retcode == 0:\n            log.debug('Secedit failed to apply security database')\n            return False\n        __context__.pop('lgpo.secedit_data', None)\n        return True\n    finally:\n        if __salt__['file.file_exists'](f_inf):\n            __salt__['file.remove'](f_inf)",
            "def _write_secedit_data(inf_data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Helper function to write secedit data to the database\\n    '\n    f_sdb = os.path.join(os.getenv('WINDIR'), 'security', 'database', 'salt.sdb')\n    f_inf = os.path.join(__opts__['cachedir'], f'secedit-{UUID}.inf')\n    try:\n        with salt.utils.files.fopen(f_inf, 'w', encoding='utf-16') as fp:\n            fp.write(inf_data)\n        cmd = ['secedit', '/import', '/db', f_sdb, '/cfg', f_inf]\n        retcode = __salt__['cmd.retcode'](cmd)\n        if not retcode == 0:\n            log.debug('Secedit failed to import template data')\n            return False\n        cmd = ['secedit', '/configure', '/db', f_sdb]\n        retcode = __salt__['cmd.retcode'](cmd)\n        if not retcode == 0:\n            log.debug('Secedit failed to apply security database')\n            return False\n        __context__.pop('lgpo.secedit_data', None)\n        return True\n    finally:\n        if __salt__['file.file_exists'](f_inf):\n            __salt__['file.remove'](f_inf)"
        ]
    },
    {
        "func_name": "_transform_value",
        "original": "def _transform_value(value, policy, transform_type):\n    \"\"\"\n    helper function to transform the policy value into something that more\n    closely matches how the policy is displayed in the gpedit GUI\n    \"\"\"\n    t_kwargs = {}\n    if 'Transform' in policy:\n        if transform_type in policy['Transform']:\n            _policydata = _policy_info()\n            if transform_type + 'Args' in policy['Transform']:\n                t_kwargs = policy['Transform'][transform_type + 'Args']\n            return getattr(_policydata, policy['Transform'][transform_type])(value, **t_kwargs)\n        else:\n            return value\n    else:\n        if 'Registry' in policy:\n            if value == '(value not set)':\n                return 'Not Defined'\n        return value",
        "mutated": [
            "def _transform_value(value, policy, transform_type):\n    if False:\n        i = 10\n    '\\n    helper function to transform the policy value into something that more\\n    closely matches how the policy is displayed in the gpedit GUI\\n    '\n    t_kwargs = {}\n    if 'Transform' in policy:\n        if transform_type in policy['Transform']:\n            _policydata = _policy_info()\n            if transform_type + 'Args' in policy['Transform']:\n                t_kwargs = policy['Transform'][transform_type + 'Args']\n            return getattr(_policydata, policy['Transform'][transform_type])(value, **t_kwargs)\n        else:\n            return value\n    else:\n        if 'Registry' in policy:\n            if value == '(value not set)':\n                return 'Not Defined'\n        return value",
            "def _transform_value(value, policy, transform_type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    helper function to transform the policy value into something that more\\n    closely matches how the policy is displayed in the gpedit GUI\\n    '\n    t_kwargs = {}\n    if 'Transform' in policy:\n        if transform_type in policy['Transform']:\n            _policydata = _policy_info()\n            if transform_type + 'Args' in policy['Transform']:\n                t_kwargs = policy['Transform'][transform_type + 'Args']\n            return getattr(_policydata, policy['Transform'][transform_type])(value, **t_kwargs)\n        else:\n            return value\n    else:\n        if 'Registry' in policy:\n            if value == '(value not set)':\n                return 'Not Defined'\n        return value",
            "def _transform_value(value, policy, transform_type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    helper function to transform the policy value into something that more\\n    closely matches how the policy is displayed in the gpedit GUI\\n    '\n    t_kwargs = {}\n    if 'Transform' in policy:\n        if transform_type in policy['Transform']:\n            _policydata = _policy_info()\n            if transform_type + 'Args' in policy['Transform']:\n                t_kwargs = policy['Transform'][transform_type + 'Args']\n            return getattr(_policydata, policy['Transform'][transform_type])(value, **t_kwargs)\n        else:\n            return value\n    else:\n        if 'Registry' in policy:\n            if value == '(value not set)':\n                return 'Not Defined'\n        return value",
            "def _transform_value(value, policy, transform_type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    helper function to transform the policy value into something that more\\n    closely matches how the policy is displayed in the gpedit GUI\\n    '\n    t_kwargs = {}\n    if 'Transform' in policy:\n        if transform_type in policy['Transform']:\n            _policydata = _policy_info()\n            if transform_type + 'Args' in policy['Transform']:\n                t_kwargs = policy['Transform'][transform_type + 'Args']\n            return getattr(_policydata, policy['Transform'][transform_type])(value, **t_kwargs)\n        else:\n            return value\n    else:\n        if 'Registry' in policy:\n            if value == '(value not set)':\n                return 'Not Defined'\n        return value",
            "def _transform_value(value, policy, transform_type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    helper function to transform the policy value into something that more\\n    closely matches how the policy is displayed in the gpedit GUI\\n    '\n    t_kwargs = {}\n    if 'Transform' in policy:\n        if transform_type in policy['Transform']:\n            _policydata = _policy_info()\n            if transform_type + 'Args' in policy['Transform']:\n                t_kwargs = policy['Transform'][transform_type + 'Args']\n            return getattr(_policydata, policy['Transform'][transform_type])(value, **t_kwargs)\n        else:\n            return value\n    else:\n        if 'Registry' in policy:\n            if value == '(value not set)':\n                return 'Not Defined'\n        return value"
        ]
    },
    {
        "func_name": "_validateSetting",
        "original": "def _validateSetting(value, policy):\n    \"\"\"\n    helper function to validate specified value is appropriate for the policy\n    if the 'Settings' key is a list, the value will check that it is in the list\n    if the 'Settings' key is a dict we will try to execute the function name\n        from the 'Function' key, passing the value and additional arguments from\n        the 'Args' dict\n    if the 'Settings' key is None, we won't do any validation and just return\n        True\n    if the Policy has 'Children', we'll validate their settings too\n    \"\"\"\n    log.debug('validating %s for policy %s', value, policy)\n    if 'Settings' in policy:\n        if policy['Settings']:\n            if isinstance(policy['Settings'], list):\n                if value not in policy['Settings']:\n                    return False\n            elif isinstance(policy['Settings'], dict):\n                _policydata = _policy_info()\n                if not getattr(_policydata, policy['Settings']['Function'])(value, **policy['Settings']['Args']):\n                    return False\n    else:\n        return True\n    return True",
        "mutated": [
            "def _validateSetting(value, policy):\n    if False:\n        i = 10\n    \"\\n    helper function to validate specified value is appropriate for the policy\\n    if the 'Settings' key is a list, the value will check that it is in the list\\n    if the 'Settings' key is a dict we will try to execute the function name\\n        from the 'Function' key, passing the value and additional arguments from\\n        the 'Args' dict\\n    if the 'Settings' key is None, we won't do any validation and just return\\n        True\\n    if the Policy has 'Children', we'll validate their settings too\\n    \"\n    log.debug('validating %s for policy %s', value, policy)\n    if 'Settings' in policy:\n        if policy['Settings']:\n            if isinstance(policy['Settings'], list):\n                if value not in policy['Settings']:\n                    return False\n            elif isinstance(policy['Settings'], dict):\n                _policydata = _policy_info()\n                if not getattr(_policydata, policy['Settings']['Function'])(value, **policy['Settings']['Args']):\n                    return False\n    else:\n        return True\n    return True",
            "def _validateSetting(value, policy):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    helper function to validate specified value is appropriate for the policy\\n    if the 'Settings' key is a list, the value will check that it is in the list\\n    if the 'Settings' key is a dict we will try to execute the function name\\n        from the 'Function' key, passing the value and additional arguments from\\n        the 'Args' dict\\n    if the 'Settings' key is None, we won't do any validation and just return\\n        True\\n    if the Policy has 'Children', we'll validate their settings too\\n    \"\n    log.debug('validating %s for policy %s', value, policy)\n    if 'Settings' in policy:\n        if policy['Settings']:\n            if isinstance(policy['Settings'], list):\n                if value not in policy['Settings']:\n                    return False\n            elif isinstance(policy['Settings'], dict):\n                _policydata = _policy_info()\n                if not getattr(_policydata, policy['Settings']['Function'])(value, **policy['Settings']['Args']):\n                    return False\n    else:\n        return True\n    return True",
            "def _validateSetting(value, policy):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    helper function to validate specified value is appropriate for the policy\\n    if the 'Settings' key is a list, the value will check that it is in the list\\n    if the 'Settings' key is a dict we will try to execute the function name\\n        from the 'Function' key, passing the value and additional arguments from\\n        the 'Args' dict\\n    if the 'Settings' key is None, we won't do any validation and just return\\n        True\\n    if the Policy has 'Children', we'll validate their settings too\\n    \"\n    log.debug('validating %s for policy %s', value, policy)\n    if 'Settings' in policy:\n        if policy['Settings']:\n            if isinstance(policy['Settings'], list):\n                if value not in policy['Settings']:\n                    return False\n            elif isinstance(policy['Settings'], dict):\n                _policydata = _policy_info()\n                if not getattr(_policydata, policy['Settings']['Function'])(value, **policy['Settings']['Args']):\n                    return False\n    else:\n        return True\n    return True",
            "def _validateSetting(value, policy):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    helper function to validate specified value is appropriate for the policy\\n    if the 'Settings' key is a list, the value will check that it is in the list\\n    if the 'Settings' key is a dict we will try to execute the function name\\n        from the 'Function' key, passing the value and additional arguments from\\n        the 'Args' dict\\n    if the 'Settings' key is None, we won't do any validation and just return\\n        True\\n    if the Policy has 'Children', we'll validate their settings too\\n    \"\n    log.debug('validating %s for policy %s', value, policy)\n    if 'Settings' in policy:\n        if policy['Settings']:\n            if isinstance(policy['Settings'], list):\n                if value not in policy['Settings']:\n                    return False\n            elif isinstance(policy['Settings'], dict):\n                _policydata = _policy_info()\n                if not getattr(_policydata, policy['Settings']['Function'])(value, **policy['Settings']['Args']):\n                    return False\n    else:\n        return True\n    return True",
            "def _validateSetting(value, policy):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    helper function to validate specified value is appropriate for the policy\\n    if the 'Settings' key is a list, the value will check that it is in the list\\n    if the 'Settings' key is a dict we will try to execute the function name\\n        from the 'Function' key, passing the value and additional arguments from\\n        the 'Args' dict\\n    if the 'Settings' key is None, we won't do any validation and just return\\n        True\\n    if the Policy has 'Children', we'll validate their settings too\\n    \"\n    log.debug('validating %s for policy %s', value, policy)\n    if 'Settings' in policy:\n        if policy['Settings']:\n            if isinstance(policy['Settings'], list):\n                if value not in policy['Settings']:\n                    return False\n            elif isinstance(policy['Settings'], dict):\n                _policydata = _policy_info()\n                if not getattr(_policydata, policy['Settings']['Function'])(value, **policy['Settings']['Args']):\n                    return False\n    else:\n        return True\n    return True"
        ]
    },
    {
        "func_name": "_addAccountRights",
        "original": "def _addAccountRights(sidObject, user_right):\n    \"\"\"\n    helper function to add an account right to a user\n    \"\"\"\n    try:\n        if sidObject:\n            _polHandle = win32security.LsaOpenPolicy(None, win32security.POLICY_ALL_ACCESS)\n            user_rights_list = [user_right]\n            _ret = win32security.LsaAddAccountRights(_polHandle, sidObject, user_rights_list)\n        return True\n    except Exception as e:\n        log.exception('Error attempting to add account right, exception was %s', e)\n        return False",
        "mutated": [
            "def _addAccountRights(sidObject, user_right):\n    if False:\n        i = 10\n    '\\n    helper function to add an account right to a user\\n    '\n    try:\n        if sidObject:\n            _polHandle = win32security.LsaOpenPolicy(None, win32security.POLICY_ALL_ACCESS)\n            user_rights_list = [user_right]\n            _ret = win32security.LsaAddAccountRights(_polHandle, sidObject, user_rights_list)\n        return True\n    except Exception as e:\n        log.exception('Error attempting to add account right, exception was %s', e)\n        return False",
            "def _addAccountRights(sidObject, user_right):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    helper function to add an account right to a user\\n    '\n    try:\n        if sidObject:\n            _polHandle = win32security.LsaOpenPolicy(None, win32security.POLICY_ALL_ACCESS)\n            user_rights_list = [user_right]\n            _ret = win32security.LsaAddAccountRights(_polHandle, sidObject, user_rights_list)\n        return True\n    except Exception as e:\n        log.exception('Error attempting to add account right, exception was %s', e)\n        return False",
            "def _addAccountRights(sidObject, user_right):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    helper function to add an account right to a user\\n    '\n    try:\n        if sidObject:\n            _polHandle = win32security.LsaOpenPolicy(None, win32security.POLICY_ALL_ACCESS)\n            user_rights_list = [user_right]\n            _ret = win32security.LsaAddAccountRights(_polHandle, sidObject, user_rights_list)\n        return True\n    except Exception as e:\n        log.exception('Error attempting to add account right, exception was %s', e)\n        return False",
            "def _addAccountRights(sidObject, user_right):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    helper function to add an account right to a user\\n    '\n    try:\n        if sidObject:\n            _polHandle = win32security.LsaOpenPolicy(None, win32security.POLICY_ALL_ACCESS)\n            user_rights_list = [user_right]\n            _ret = win32security.LsaAddAccountRights(_polHandle, sidObject, user_rights_list)\n        return True\n    except Exception as e:\n        log.exception('Error attempting to add account right, exception was %s', e)\n        return False",
            "def _addAccountRights(sidObject, user_right):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    helper function to add an account right to a user\\n    '\n    try:\n        if sidObject:\n            _polHandle = win32security.LsaOpenPolicy(None, win32security.POLICY_ALL_ACCESS)\n            user_rights_list = [user_right]\n            _ret = win32security.LsaAddAccountRights(_polHandle, sidObject, user_rights_list)\n        return True\n    except Exception as e:\n        log.exception('Error attempting to add account right, exception was %s', e)\n        return False"
        ]
    },
    {
        "func_name": "_delAccountRights",
        "original": "def _delAccountRights(sidObject, user_right):\n    \"\"\"\n    helper function to remove an account right from a user\n    \"\"\"\n    try:\n        _polHandle = win32security.LsaOpenPolicy(None, win32security.POLICY_ALL_ACCESS)\n        user_rights_list = [user_right]\n        _ret = win32security.LsaRemoveAccountRights(_polHandle, sidObject, False, user_rights_list)\n        return True\n    except Exception as e:\n        log.exception('Error attempting to delete account right')\n        return False",
        "mutated": [
            "def _delAccountRights(sidObject, user_right):\n    if False:\n        i = 10\n    '\\n    helper function to remove an account right from a user\\n    '\n    try:\n        _polHandle = win32security.LsaOpenPolicy(None, win32security.POLICY_ALL_ACCESS)\n        user_rights_list = [user_right]\n        _ret = win32security.LsaRemoveAccountRights(_polHandle, sidObject, False, user_rights_list)\n        return True\n    except Exception as e:\n        log.exception('Error attempting to delete account right')\n        return False",
            "def _delAccountRights(sidObject, user_right):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    helper function to remove an account right from a user\\n    '\n    try:\n        _polHandle = win32security.LsaOpenPolicy(None, win32security.POLICY_ALL_ACCESS)\n        user_rights_list = [user_right]\n        _ret = win32security.LsaRemoveAccountRights(_polHandle, sidObject, False, user_rights_list)\n        return True\n    except Exception as e:\n        log.exception('Error attempting to delete account right')\n        return False",
            "def _delAccountRights(sidObject, user_right):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    helper function to remove an account right from a user\\n    '\n    try:\n        _polHandle = win32security.LsaOpenPolicy(None, win32security.POLICY_ALL_ACCESS)\n        user_rights_list = [user_right]\n        _ret = win32security.LsaRemoveAccountRights(_polHandle, sidObject, False, user_rights_list)\n        return True\n    except Exception as e:\n        log.exception('Error attempting to delete account right')\n        return False",
            "def _delAccountRights(sidObject, user_right):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    helper function to remove an account right from a user\\n    '\n    try:\n        _polHandle = win32security.LsaOpenPolicy(None, win32security.POLICY_ALL_ACCESS)\n        user_rights_list = [user_right]\n        _ret = win32security.LsaRemoveAccountRights(_polHandle, sidObject, False, user_rights_list)\n        return True\n    except Exception as e:\n        log.exception('Error attempting to delete account right')\n        return False",
            "def _delAccountRights(sidObject, user_right):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    helper function to remove an account right from a user\\n    '\n    try:\n        _polHandle = win32security.LsaOpenPolicy(None, win32security.POLICY_ALL_ACCESS)\n        user_rights_list = [user_right]\n        _ret = win32security.LsaRemoveAccountRights(_polHandle, sidObject, False, user_rights_list)\n        return True\n    except Exception as e:\n        log.exception('Error attempting to delete account right')\n        return False"
        ]
    },
    {
        "func_name": "_getRightsAssignments",
        "original": "def _getRightsAssignments(user_right):\n    \"\"\"\n    helper function to return all the user rights assignments/users\n    \"\"\"\n    sids = []\n    polHandle = win32security.LsaOpenPolicy(None, win32security.POLICY_ALL_ACCESS)\n    sids = win32security.LsaEnumerateAccountsWithUserRight(polHandle, user_right)\n    return sids",
        "mutated": [
            "def _getRightsAssignments(user_right):\n    if False:\n        i = 10\n    '\\n    helper function to return all the user rights assignments/users\\n    '\n    sids = []\n    polHandle = win32security.LsaOpenPolicy(None, win32security.POLICY_ALL_ACCESS)\n    sids = win32security.LsaEnumerateAccountsWithUserRight(polHandle, user_right)\n    return sids",
            "def _getRightsAssignments(user_right):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    helper function to return all the user rights assignments/users\\n    '\n    sids = []\n    polHandle = win32security.LsaOpenPolicy(None, win32security.POLICY_ALL_ACCESS)\n    sids = win32security.LsaEnumerateAccountsWithUserRight(polHandle, user_right)\n    return sids",
            "def _getRightsAssignments(user_right):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    helper function to return all the user rights assignments/users\\n    '\n    sids = []\n    polHandle = win32security.LsaOpenPolicy(None, win32security.POLICY_ALL_ACCESS)\n    sids = win32security.LsaEnumerateAccountsWithUserRight(polHandle, user_right)\n    return sids",
            "def _getRightsAssignments(user_right):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    helper function to return all the user rights assignments/users\\n    '\n    sids = []\n    polHandle = win32security.LsaOpenPolicy(None, win32security.POLICY_ALL_ACCESS)\n    sids = win32security.LsaEnumerateAccountsWithUserRight(polHandle, user_right)\n    return sids",
            "def _getRightsAssignments(user_right):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    helper function to return all the user rights assignments/users\\n    '\n    sids = []\n    polHandle = win32security.LsaOpenPolicy(None, win32security.POLICY_ALL_ACCESS)\n    sids = win32security.LsaEnumerateAccountsWithUserRight(polHandle, user_right)\n    return sids"
        ]
    },
    {
        "func_name": "_getAdmlDisplayName",
        "original": "def _getAdmlDisplayName(adml_xml_data, display_name):\n    \"\"\"\n    helper function to take the 'displayName' attribute of an element and find\n    the value from the ADML data\n\n    adml_xml_data :: XML data of all ADML files to search\n    display_name :: the value of the displayName attribute from the ADMX entry\n                    to search the ADML data for\n    \"\"\"\n    if display_name.startswith('$(') and display_name.endswith(')'):\n        display_name = re.sub('(^\\\\$\\\\(|\\\\)$)', '', display_name)\n        display_name = display_name.split('.')\n        displayname_type = display_name[0]\n        displayname_id = display_name[1]\n        search_results = ADML_DISPLAY_NAME_XPATH(adml_xml_data, displayNameType=displayname_type, displayNameId=displayname_id)\n        if search_results:\n            for result in search_results:\n                return result.text.strip()\n    return None",
        "mutated": [
            "def _getAdmlDisplayName(adml_xml_data, display_name):\n    if False:\n        i = 10\n    \"\\n    helper function to take the 'displayName' attribute of an element and find\\n    the value from the ADML data\\n\\n    adml_xml_data :: XML data of all ADML files to search\\n    display_name :: the value of the displayName attribute from the ADMX entry\\n                    to search the ADML data for\\n    \"\n    if display_name.startswith('$(') and display_name.endswith(')'):\n        display_name = re.sub('(^\\\\$\\\\(|\\\\)$)', '', display_name)\n        display_name = display_name.split('.')\n        displayname_type = display_name[0]\n        displayname_id = display_name[1]\n        search_results = ADML_DISPLAY_NAME_XPATH(adml_xml_data, displayNameType=displayname_type, displayNameId=displayname_id)\n        if search_results:\n            for result in search_results:\n                return result.text.strip()\n    return None",
            "def _getAdmlDisplayName(adml_xml_data, display_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    helper function to take the 'displayName' attribute of an element and find\\n    the value from the ADML data\\n\\n    adml_xml_data :: XML data of all ADML files to search\\n    display_name :: the value of the displayName attribute from the ADMX entry\\n                    to search the ADML data for\\n    \"\n    if display_name.startswith('$(') and display_name.endswith(')'):\n        display_name = re.sub('(^\\\\$\\\\(|\\\\)$)', '', display_name)\n        display_name = display_name.split('.')\n        displayname_type = display_name[0]\n        displayname_id = display_name[1]\n        search_results = ADML_DISPLAY_NAME_XPATH(adml_xml_data, displayNameType=displayname_type, displayNameId=displayname_id)\n        if search_results:\n            for result in search_results:\n                return result.text.strip()\n    return None",
            "def _getAdmlDisplayName(adml_xml_data, display_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    helper function to take the 'displayName' attribute of an element and find\\n    the value from the ADML data\\n\\n    adml_xml_data :: XML data of all ADML files to search\\n    display_name :: the value of the displayName attribute from the ADMX entry\\n                    to search the ADML data for\\n    \"\n    if display_name.startswith('$(') and display_name.endswith(')'):\n        display_name = re.sub('(^\\\\$\\\\(|\\\\)$)', '', display_name)\n        display_name = display_name.split('.')\n        displayname_type = display_name[0]\n        displayname_id = display_name[1]\n        search_results = ADML_DISPLAY_NAME_XPATH(adml_xml_data, displayNameType=displayname_type, displayNameId=displayname_id)\n        if search_results:\n            for result in search_results:\n                return result.text.strip()\n    return None",
            "def _getAdmlDisplayName(adml_xml_data, display_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    helper function to take the 'displayName' attribute of an element and find\\n    the value from the ADML data\\n\\n    adml_xml_data :: XML data of all ADML files to search\\n    display_name :: the value of the displayName attribute from the ADMX entry\\n                    to search the ADML data for\\n    \"\n    if display_name.startswith('$(') and display_name.endswith(')'):\n        display_name = re.sub('(^\\\\$\\\\(|\\\\)$)', '', display_name)\n        display_name = display_name.split('.')\n        displayname_type = display_name[0]\n        displayname_id = display_name[1]\n        search_results = ADML_DISPLAY_NAME_XPATH(adml_xml_data, displayNameType=displayname_type, displayNameId=displayname_id)\n        if search_results:\n            for result in search_results:\n                return result.text.strip()\n    return None",
            "def _getAdmlDisplayName(adml_xml_data, display_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    helper function to take the 'displayName' attribute of an element and find\\n    the value from the ADML data\\n\\n    adml_xml_data :: XML data of all ADML files to search\\n    display_name :: the value of the displayName attribute from the ADMX entry\\n                    to search the ADML data for\\n    \"\n    if display_name.startswith('$(') and display_name.endswith(')'):\n        display_name = re.sub('(^\\\\$\\\\(|\\\\)$)', '', display_name)\n        display_name = display_name.split('.')\n        displayname_type = display_name[0]\n        displayname_id = display_name[1]\n        search_results = ADML_DISPLAY_NAME_XPATH(adml_xml_data, displayNameType=displayname_type, displayNameId=displayname_id)\n        if search_results:\n            for result in search_results:\n                return result.text.strip()\n    return None"
        ]
    },
    {
        "func_name": "_getAdmlPresentationRefId",
        "original": "def _getAdmlPresentationRefId(adml_data, ref_id):\n    \"\"\"\n    helper function to check for a presentation label for a policy element\n    \"\"\"\n    search_results = adml_data.xpath(f'//*[@*[local-name() = \"refId\"] = \"{ref_id}\"]')\n    alternate_label = ''\n    if search_results:\n        for result in search_results:\n            the_localname = etree.QName(result.tag).localname\n            if result.text is None:\n                presentation_element = PRESENTATION_ANCESTOR_XPATH(result)\n                if presentation_element:\n                    presentation_element = presentation_element[0]\n                    if TEXT_ELEMENT_XPATH(presentation_element):\n                        for p_item in presentation_element:\n                            if p_item == result:\n                                break\n                            if etree.QName(p_item.tag).localname == 'text':\n                                if getattr(p_item, 'text'):\n                                    alternate_label = getattr(p_item, 'text').rstrip()\n                        if alternate_label.endswith('.'):\n                            alternate_label = ''\n            if the_localname in ['textBox', 'comboBox']:\n                label_items = result.xpath('.//*[local-name() = \"label\"]')\n                for label_item in label_items:\n                    if label_item.text:\n                        return label_item.text.rstrip().rstrip(':')\n            elif the_localname in ['decimalTextBox', 'longDecimalTextBox', 'dropdownList', 'listBox', 'checkBox', 'text', 'multiTextBox']:\n                if result.text:\n                    return result.text.rstrip().rstrip(':').strip()\n                else:\n                    return alternate_label.rstrip(':').strip()\n    return None",
        "mutated": [
            "def _getAdmlPresentationRefId(adml_data, ref_id):\n    if False:\n        i = 10\n    '\\n    helper function to check for a presentation label for a policy element\\n    '\n    search_results = adml_data.xpath(f'//*[@*[local-name() = \"refId\"] = \"{ref_id}\"]')\n    alternate_label = ''\n    if search_results:\n        for result in search_results:\n            the_localname = etree.QName(result.tag).localname\n            if result.text is None:\n                presentation_element = PRESENTATION_ANCESTOR_XPATH(result)\n                if presentation_element:\n                    presentation_element = presentation_element[0]\n                    if TEXT_ELEMENT_XPATH(presentation_element):\n                        for p_item in presentation_element:\n                            if p_item == result:\n                                break\n                            if etree.QName(p_item.tag).localname == 'text':\n                                if getattr(p_item, 'text'):\n                                    alternate_label = getattr(p_item, 'text').rstrip()\n                        if alternate_label.endswith('.'):\n                            alternate_label = ''\n            if the_localname in ['textBox', 'comboBox']:\n                label_items = result.xpath('.//*[local-name() = \"label\"]')\n                for label_item in label_items:\n                    if label_item.text:\n                        return label_item.text.rstrip().rstrip(':')\n            elif the_localname in ['decimalTextBox', 'longDecimalTextBox', 'dropdownList', 'listBox', 'checkBox', 'text', 'multiTextBox']:\n                if result.text:\n                    return result.text.rstrip().rstrip(':').strip()\n                else:\n                    return alternate_label.rstrip(':').strip()\n    return None",
            "def _getAdmlPresentationRefId(adml_data, ref_id):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    helper function to check for a presentation label for a policy element\\n    '\n    search_results = adml_data.xpath(f'//*[@*[local-name() = \"refId\"] = \"{ref_id}\"]')\n    alternate_label = ''\n    if search_results:\n        for result in search_results:\n            the_localname = etree.QName(result.tag).localname\n            if result.text is None:\n                presentation_element = PRESENTATION_ANCESTOR_XPATH(result)\n                if presentation_element:\n                    presentation_element = presentation_element[0]\n                    if TEXT_ELEMENT_XPATH(presentation_element):\n                        for p_item in presentation_element:\n                            if p_item == result:\n                                break\n                            if etree.QName(p_item.tag).localname == 'text':\n                                if getattr(p_item, 'text'):\n                                    alternate_label = getattr(p_item, 'text').rstrip()\n                        if alternate_label.endswith('.'):\n                            alternate_label = ''\n            if the_localname in ['textBox', 'comboBox']:\n                label_items = result.xpath('.//*[local-name() = \"label\"]')\n                for label_item in label_items:\n                    if label_item.text:\n                        return label_item.text.rstrip().rstrip(':')\n            elif the_localname in ['decimalTextBox', 'longDecimalTextBox', 'dropdownList', 'listBox', 'checkBox', 'text', 'multiTextBox']:\n                if result.text:\n                    return result.text.rstrip().rstrip(':').strip()\n                else:\n                    return alternate_label.rstrip(':').strip()\n    return None",
            "def _getAdmlPresentationRefId(adml_data, ref_id):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    helper function to check for a presentation label for a policy element\\n    '\n    search_results = adml_data.xpath(f'//*[@*[local-name() = \"refId\"] = \"{ref_id}\"]')\n    alternate_label = ''\n    if search_results:\n        for result in search_results:\n            the_localname = etree.QName(result.tag).localname\n            if result.text is None:\n                presentation_element = PRESENTATION_ANCESTOR_XPATH(result)\n                if presentation_element:\n                    presentation_element = presentation_element[0]\n                    if TEXT_ELEMENT_XPATH(presentation_element):\n                        for p_item in presentation_element:\n                            if p_item == result:\n                                break\n                            if etree.QName(p_item.tag).localname == 'text':\n                                if getattr(p_item, 'text'):\n                                    alternate_label = getattr(p_item, 'text').rstrip()\n                        if alternate_label.endswith('.'):\n                            alternate_label = ''\n            if the_localname in ['textBox', 'comboBox']:\n                label_items = result.xpath('.//*[local-name() = \"label\"]')\n                for label_item in label_items:\n                    if label_item.text:\n                        return label_item.text.rstrip().rstrip(':')\n            elif the_localname in ['decimalTextBox', 'longDecimalTextBox', 'dropdownList', 'listBox', 'checkBox', 'text', 'multiTextBox']:\n                if result.text:\n                    return result.text.rstrip().rstrip(':').strip()\n                else:\n                    return alternate_label.rstrip(':').strip()\n    return None",
            "def _getAdmlPresentationRefId(adml_data, ref_id):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    helper function to check for a presentation label for a policy element\\n    '\n    search_results = adml_data.xpath(f'//*[@*[local-name() = \"refId\"] = \"{ref_id}\"]')\n    alternate_label = ''\n    if search_results:\n        for result in search_results:\n            the_localname = etree.QName(result.tag).localname\n            if result.text is None:\n                presentation_element = PRESENTATION_ANCESTOR_XPATH(result)\n                if presentation_element:\n                    presentation_element = presentation_element[0]\n                    if TEXT_ELEMENT_XPATH(presentation_element):\n                        for p_item in presentation_element:\n                            if p_item == result:\n                                break\n                            if etree.QName(p_item.tag).localname == 'text':\n                                if getattr(p_item, 'text'):\n                                    alternate_label = getattr(p_item, 'text').rstrip()\n                        if alternate_label.endswith('.'):\n                            alternate_label = ''\n            if the_localname in ['textBox', 'comboBox']:\n                label_items = result.xpath('.//*[local-name() = \"label\"]')\n                for label_item in label_items:\n                    if label_item.text:\n                        return label_item.text.rstrip().rstrip(':')\n            elif the_localname in ['decimalTextBox', 'longDecimalTextBox', 'dropdownList', 'listBox', 'checkBox', 'text', 'multiTextBox']:\n                if result.text:\n                    return result.text.rstrip().rstrip(':').strip()\n                else:\n                    return alternate_label.rstrip(':').strip()\n    return None",
            "def _getAdmlPresentationRefId(adml_data, ref_id):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    helper function to check for a presentation label for a policy element\\n    '\n    search_results = adml_data.xpath(f'//*[@*[local-name() = \"refId\"] = \"{ref_id}\"]')\n    alternate_label = ''\n    if search_results:\n        for result in search_results:\n            the_localname = etree.QName(result.tag).localname\n            if result.text is None:\n                presentation_element = PRESENTATION_ANCESTOR_XPATH(result)\n                if presentation_element:\n                    presentation_element = presentation_element[0]\n                    if TEXT_ELEMENT_XPATH(presentation_element):\n                        for p_item in presentation_element:\n                            if p_item == result:\n                                break\n                            if etree.QName(p_item.tag).localname == 'text':\n                                if getattr(p_item, 'text'):\n                                    alternate_label = getattr(p_item, 'text').rstrip()\n                        if alternate_label.endswith('.'):\n                            alternate_label = ''\n            if the_localname in ['textBox', 'comboBox']:\n                label_items = result.xpath('.//*[local-name() = \"label\"]')\n                for label_item in label_items:\n                    if label_item.text:\n                        return label_item.text.rstrip().rstrip(':')\n            elif the_localname in ['decimalTextBox', 'longDecimalTextBox', 'dropdownList', 'listBox', 'checkBox', 'text', 'multiTextBox']:\n                if result.text:\n                    return result.text.rstrip().rstrip(':').strip()\n                else:\n                    return alternate_label.rstrip(':').strip()\n    return None"
        ]
    },
    {
        "func_name": "_getFullPolicyName",
        "original": "def _getFullPolicyName(policy_item, policy_name, return_full_policy_names, adml_language):\n    \"\"\"\n    helper function to retrieve the full policy name if needed\n    \"\"\"\n    if policy_name in adm_policy_name_map[return_full_policy_names]:\n        return adm_policy_name_map[return_full_policy_names][policy_name]\n    adml_data = _get_policy_resources(language=adml_language)\n    if return_full_policy_names and 'displayName' in policy_item.attrib:\n        fullPolicyName = _getAdmlDisplayName(adml_data, policy_item.attrib['displayName'])\n        if fullPolicyName:\n            adm_policy_name_map[return_full_policy_names][policy_name] = fullPolicyName\n            policy_name = fullPolicyName\n    elif return_full_policy_names and 'id' in policy_item.attrib:\n        fullPolicyName = _getAdmlPresentationRefId(adml_data, policy_item.attrib['id'])\n        if fullPolicyName:\n            adm_policy_name_map[return_full_policy_names][policy_name] = fullPolicyName\n            policy_name = fullPolicyName\n    policy_name = policy_name.rstrip(':').rstrip()\n    return policy_name",
        "mutated": [
            "def _getFullPolicyName(policy_item, policy_name, return_full_policy_names, adml_language):\n    if False:\n        i = 10\n    '\\n    helper function to retrieve the full policy name if needed\\n    '\n    if policy_name in adm_policy_name_map[return_full_policy_names]:\n        return adm_policy_name_map[return_full_policy_names][policy_name]\n    adml_data = _get_policy_resources(language=adml_language)\n    if return_full_policy_names and 'displayName' in policy_item.attrib:\n        fullPolicyName = _getAdmlDisplayName(adml_data, policy_item.attrib['displayName'])\n        if fullPolicyName:\n            adm_policy_name_map[return_full_policy_names][policy_name] = fullPolicyName\n            policy_name = fullPolicyName\n    elif return_full_policy_names and 'id' in policy_item.attrib:\n        fullPolicyName = _getAdmlPresentationRefId(adml_data, policy_item.attrib['id'])\n        if fullPolicyName:\n            adm_policy_name_map[return_full_policy_names][policy_name] = fullPolicyName\n            policy_name = fullPolicyName\n    policy_name = policy_name.rstrip(':').rstrip()\n    return policy_name",
            "def _getFullPolicyName(policy_item, policy_name, return_full_policy_names, adml_language):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    helper function to retrieve the full policy name if needed\\n    '\n    if policy_name in adm_policy_name_map[return_full_policy_names]:\n        return adm_policy_name_map[return_full_policy_names][policy_name]\n    adml_data = _get_policy_resources(language=adml_language)\n    if return_full_policy_names and 'displayName' in policy_item.attrib:\n        fullPolicyName = _getAdmlDisplayName(adml_data, policy_item.attrib['displayName'])\n        if fullPolicyName:\n            adm_policy_name_map[return_full_policy_names][policy_name] = fullPolicyName\n            policy_name = fullPolicyName\n    elif return_full_policy_names and 'id' in policy_item.attrib:\n        fullPolicyName = _getAdmlPresentationRefId(adml_data, policy_item.attrib['id'])\n        if fullPolicyName:\n            adm_policy_name_map[return_full_policy_names][policy_name] = fullPolicyName\n            policy_name = fullPolicyName\n    policy_name = policy_name.rstrip(':').rstrip()\n    return policy_name",
            "def _getFullPolicyName(policy_item, policy_name, return_full_policy_names, adml_language):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    helper function to retrieve the full policy name if needed\\n    '\n    if policy_name in adm_policy_name_map[return_full_policy_names]:\n        return adm_policy_name_map[return_full_policy_names][policy_name]\n    adml_data = _get_policy_resources(language=adml_language)\n    if return_full_policy_names and 'displayName' in policy_item.attrib:\n        fullPolicyName = _getAdmlDisplayName(adml_data, policy_item.attrib['displayName'])\n        if fullPolicyName:\n            adm_policy_name_map[return_full_policy_names][policy_name] = fullPolicyName\n            policy_name = fullPolicyName\n    elif return_full_policy_names and 'id' in policy_item.attrib:\n        fullPolicyName = _getAdmlPresentationRefId(adml_data, policy_item.attrib['id'])\n        if fullPolicyName:\n            adm_policy_name_map[return_full_policy_names][policy_name] = fullPolicyName\n            policy_name = fullPolicyName\n    policy_name = policy_name.rstrip(':').rstrip()\n    return policy_name",
            "def _getFullPolicyName(policy_item, policy_name, return_full_policy_names, adml_language):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    helper function to retrieve the full policy name if needed\\n    '\n    if policy_name in adm_policy_name_map[return_full_policy_names]:\n        return adm_policy_name_map[return_full_policy_names][policy_name]\n    adml_data = _get_policy_resources(language=adml_language)\n    if return_full_policy_names and 'displayName' in policy_item.attrib:\n        fullPolicyName = _getAdmlDisplayName(adml_data, policy_item.attrib['displayName'])\n        if fullPolicyName:\n            adm_policy_name_map[return_full_policy_names][policy_name] = fullPolicyName\n            policy_name = fullPolicyName\n    elif return_full_policy_names and 'id' in policy_item.attrib:\n        fullPolicyName = _getAdmlPresentationRefId(adml_data, policy_item.attrib['id'])\n        if fullPolicyName:\n            adm_policy_name_map[return_full_policy_names][policy_name] = fullPolicyName\n            policy_name = fullPolicyName\n    policy_name = policy_name.rstrip(':').rstrip()\n    return policy_name",
            "def _getFullPolicyName(policy_item, policy_name, return_full_policy_names, adml_language):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    helper function to retrieve the full policy name if needed\\n    '\n    if policy_name in adm_policy_name_map[return_full_policy_names]:\n        return adm_policy_name_map[return_full_policy_names][policy_name]\n    adml_data = _get_policy_resources(language=adml_language)\n    if return_full_policy_names and 'displayName' in policy_item.attrib:\n        fullPolicyName = _getAdmlDisplayName(adml_data, policy_item.attrib['displayName'])\n        if fullPolicyName:\n            adm_policy_name_map[return_full_policy_names][policy_name] = fullPolicyName\n            policy_name = fullPolicyName\n    elif return_full_policy_names and 'id' in policy_item.attrib:\n        fullPolicyName = _getAdmlPresentationRefId(adml_data, policy_item.attrib['id'])\n        if fullPolicyName:\n            adm_policy_name_map[return_full_policy_names][policy_name] = fullPolicyName\n            policy_name = fullPolicyName\n    policy_name = policy_name.rstrip(':').rstrip()\n    return policy_name"
        ]
    },
    {
        "func_name": "_getDataFromRegPolData",
        "original": "def _getDataFromRegPolData(search_string, policy_data, return_value_name=False):\n    \"\"\"\n    helper function to do a search of Policy data from a registry.pol file\n    returns the \"data\" field\n    https://msdn.microsoft.com/en-us/library/aa374407(VS.85).aspx\n    [key;value;type;size;data]\n    \"\"\"\n    value = None\n    values = []\n    encoded_semicolon = ';'.encode('utf-16-le')\n    if return_value_name:\n        values = {}\n    if search_string:\n        registry = Registry()\n        if len(search_string.split(encoded_semicolon)) >= 3:\n            vtype = registry.vtype_reverse[ord(search_string.split(encoded_semicolon)[2].decode('utf-32-le'))]\n        else:\n            vtype = None\n        search_string = re.escape(search_string)\n        matches = re.finditer(search_string, policy_data, re.IGNORECASE)\n        matches = [m for m in matches]\n        if matches:\n            for match in matches:\n                pol_entry = policy_data[match.start():policy_data.index(']'.encode('utf-16-le'), match.end())].split(encoded_semicolon, 4)\n                if len(pol_entry) >= 2:\n                    valueName = pol_entry[1].decode('utf-16-le').rstrip(chr(0))\n                if len(pol_entry) >= 5:\n                    value = encoded_semicolon.join(pol_entry[4:])\n                    if vtype == 'REG_DWORD' or vtype == 'REG_QWORD':\n                        if value:\n                            if vtype == 'REG_DWORD':\n                                for v in struct.unpack(b'I', value):\n                                    value = v\n                            elif vtype == 'REG_QWORD':\n                                for v in struct.unpack(b'Q', value):\n                                    value = v\n                        else:\n                            value = 0\n                    elif vtype == 'REG_MULTI_SZ':\n                        value = value.decode('utf-16-le').rstrip(chr(0)).split(chr(0))\n                    else:\n                        value = value.decode('utf-16-le').rstrip(chr(0))\n                if return_value_name:\n                    log.trace('we want value names and the value')\n                    values[valueName] = value\n                elif len(matches) > 1:\n                    log.trace('we have multiple matches, we will return a list')\n                    values.append(value)\n    if values:\n        value = values\n    return value",
        "mutated": [
            "def _getDataFromRegPolData(search_string, policy_data, return_value_name=False):\n    if False:\n        i = 10\n    '\\n    helper function to do a search of Policy data from a registry.pol file\\n    returns the \"data\" field\\n    https://msdn.microsoft.com/en-us/library/aa374407(VS.85).aspx\\n    [key;value;type;size;data]\\n    '\n    value = None\n    values = []\n    encoded_semicolon = ';'.encode('utf-16-le')\n    if return_value_name:\n        values = {}\n    if search_string:\n        registry = Registry()\n        if len(search_string.split(encoded_semicolon)) >= 3:\n            vtype = registry.vtype_reverse[ord(search_string.split(encoded_semicolon)[2].decode('utf-32-le'))]\n        else:\n            vtype = None\n        search_string = re.escape(search_string)\n        matches = re.finditer(search_string, policy_data, re.IGNORECASE)\n        matches = [m for m in matches]\n        if matches:\n            for match in matches:\n                pol_entry = policy_data[match.start():policy_data.index(']'.encode('utf-16-le'), match.end())].split(encoded_semicolon, 4)\n                if len(pol_entry) >= 2:\n                    valueName = pol_entry[1].decode('utf-16-le').rstrip(chr(0))\n                if len(pol_entry) >= 5:\n                    value = encoded_semicolon.join(pol_entry[4:])\n                    if vtype == 'REG_DWORD' or vtype == 'REG_QWORD':\n                        if value:\n                            if vtype == 'REG_DWORD':\n                                for v in struct.unpack(b'I', value):\n                                    value = v\n                            elif vtype == 'REG_QWORD':\n                                for v in struct.unpack(b'Q', value):\n                                    value = v\n                        else:\n                            value = 0\n                    elif vtype == 'REG_MULTI_SZ':\n                        value = value.decode('utf-16-le').rstrip(chr(0)).split(chr(0))\n                    else:\n                        value = value.decode('utf-16-le').rstrip(chr(0))\n                if return_value_name:\n                    log.trace('we want value names and the value')\n                    values[valueName] = value\n                elif len(matches) > 1:\n                    log.trace('we have multiple matches, we will return a list')\n                    values.append(value)\n    if values:\n        value = values\n    return value",
            "def _getDataFromRegPolData(search_string, policy_data, return_value_name=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    helper function to do a search of Policy data from a registry.pol file\\n    returns the \"data\" field\\n    https://msdn.microsoft.com/en-us/library/aa374407(VS.85).aspx\\n    [key;value;type;size;data]\\n    '\n    value = None\n    values = []\n    encoded_semicolon = ';'.encode('utf-16-le')\n    if return_value_name:\n        values = {}\n    if search_string:\n        registry = Registry()\n        if len(search_string.split(encoded_semicolon)) >= 3:\n            vtype = registry.vtype_reverse[ord(search_string.split(encoded_semicolon)[2].decode('utf-32-le'))]\n        else:\n            vtype = None\n        search_string = re.escape(search_string)\n        matches = re.finditer(search_string, policy_data, re.IGNORECASE)\n        matches = [m for m in matches]\n        if matches:\n            for match in matches:\n                pol_entry = policy_data[match.start():policy_data.index(']'.encode('utf-16-le'), match.end())].split(encoded_semicolon, 4)\n                if len(pol_entry) >= 2:\n                    valueName = pol_entry[1].decode('utf-16-le').rstrip(chr(0))\n                if len(pol_entry) >= 5:\n                    value = encoded_semicolon.join(pol_entry[4:])\n                    if vtype == 'REG_DWORD' or vtype == 'REG_QWORD':\n                        if value:\n                            if vtype == 'REG_DWORD':\n                                for v in struct.unpack(b'I', value):\n                                    value = v\n                            elif vtype == 'REG_QWORD':\n                                for v in struct.unpack(b'Q', value):\n                                    value = v\n                        else:\n                            value = 0\n                    elif vtype == 'REG_MULTI_SZ':\n                        value = value.decode('utf-16-le').rstrip(chr(0)).split(chr(0))\n                    else:\n                        value = value.decode('utf-16-le').rstrip(chr(0))\n                if return_value_name:\n                    log.trace('we want value names and the value')\n                    values[valueName] = value\n                elif len(matches) > 1:\n                    log.trace('we have multiple matches, we will return a list')\n                    values.append(value)\n    if values:\n        value = values\n    return value",
            "def _getDataFromRegPolData(search_string, policy_data, return_value_name=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    helper function to do a search of Policy data from a registry.pol file\\n    returns the \"data\" field\\n    https://msdn.microsoft.com/en-us/library/aa374407(VS.85).aspx\\n    [key;value;type;size;data]\\n    '\n    value = None\n    values = []\n    encoded_semicolon = ';'.encode('utf-16-le')\n    if return_value_name:\n        values = {}\n    if search_string:\n        registry = Registry()\n        if len(search_string.split(encoded_semicolon)) >= 3:\n            vtype = registry.vtype_reverse[ord(search_string.split(encoded_semicolon)[2].decode('utf-32-le'))]\n        else:\n            vtype = None\n        search_string = re.escape(search_string)\n        matches = re.finditer(search_string, policy_data, re.IGNORECASE)\n        matches = [m for m in matches]\n        if matches:\n            for match in matches:\n                pol_entry = policy_data[match.start():policy_data.index(']'.encode('utf-16-le'), match.end())].split(encoded_semicolon, 4)\n                if len(pol_entry) >= 2:\n                    valueName = pol_entry[1].decode('utf-16-le').rstrip(chr(0))\n                if len(pol_entry) >= 5:\n                    value = encoded_semicolon.join(pol_entry[4:])\n                    if vtype == 'REG_DWORD' or vtype == 'REG_QWORD':\n                        if value:\n                            if vtype == 'REG_DWORD':\n                                for v in struct.unpack(b'I', value):\n                                    value = v\n                            elif vtype == 'REG_QWORD':\n                                for v in struct.unpack(b'Q', value):\n                                    value = v\n                        else:\n                            value = 0\n                    elif vtype == 'REG_MULTI_SZ':\n                        value = value.decode('utf-16-le').rstrip(chr(0)).split(chr(0))\n                    else:\n                        value = value.decode('utf-16-le').rstrip(chr(0))\n                if return_value_name:\n                    log.trace('we want value names and the value')\n                    values[valueName] = value\n                elif len(matches) > 1:\n                    log.trace('we have multiple matches, we will return a list')\n                    values.append(value)\n    if values:\n        value = values\n    return value",
            "def _getDataFromRegPolData(search_string, policy_data, return_value_name=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    helper function to do a search of Policy data from a registry.pol file\\n    returns the \"data\" field\\n    https://msdn.microsoft.com/en-us/library/aa374407(VS.85).aspx\\n    [key;value;type;size;data]\\n    '\n    value = None\n    values = []\n    encoded_semicolon = ';'.encode('utf-16-le')\n    if return_value_name:\n        values = {}\n    if search_string:\n        registry = Registry()\n        if len(search_string.split(encoded_semicolon)) >= 3:\n            vtype = registry.vtype_reverse[ord(search_string.split(encoded_semicolon)[2].decode('utf-32-le'))]\n        else:\n            vtype = None\n        search_string = re.escape(search_string)\n        matches = re.finditer(search_string, policy_data, re.IGNORECASE)\n        matches = [m for m in matches]\n        if matches:\n            for match in matches:\n                pol_entry = policy_data[match.start():policy_data.index(']'.encode('utf-16-le'), match.end())].split(encoded_semicolon, 4)\n                if len(pol_entry) >= 2:\n                    valueName = pol_entry[1].decode('utf-16-le').rstrip(chr(0))\n                if len(pol_entry) >= 5:\n                    value = encoded_semicolon.join(pol_entry[4:])\n                    if vtype == 'REG_DWORD' or vtype == 'REG_QWORD':\n                        if value:\n                            if vtype == 'REG_DWORD':\n                                for v in struct.unpack(b'I', value):\n                                    value = v\n                            elif vtype == 'REG_QWORD':\n                                for v in struct.unpack(b'Q', value):\n                                    value = v\n                        else:\n                            value = 0\n                    elif vtype == 'REG_MULTI_SZ':\n                        value = value.decode('utf-16-le').rstrip(chr(0)).split(chr(0))\n                    else:\n                        value = value.decode('utf-16-le').rstrip(chr(0))\n                if return_value_name:\n                    log.trace('we want value names and the value')\n                    values[valueName] = value\n                elif len(matches) > 1:\n                    log.trace('we have multiple matches, we will return a list')\n                    values.append(value)\n    if values:\n        value = values\n    return value",
            "def _getDataFromRegPolData(search_string, policy_data, return_value_name=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    helper function to do a search of Policy data from a registry.pol file\\n    returns the \"data\" field\\n    https://msdn.microsoft.com/en-us/library/aa374407(VS.85).aspx\\n    [key;value;type;size;data]\\n    '\n    value = None\n    values = []\n    encoded_semicolon = ';'.encode('utf-16-le')\n    if return_value_name:\n        values = {}\n    if search_string:\n        registry = Registry()\n        if len(search_string.split(encoded_semicolon)) >= 3:\n            vtype = registry.vtype_reverse[ord(search_string.split(encoded_semicolon)[2].decode('utf-32-le'))]\n        else:\n            vtype = None\n        search_string = re.escape(search_string)\n        matches = re.finditer(search_string, policy_data, re.IGNORECASE)\n        matches = [m for m in matches]\n        if matches:\n            for match in matches:\n                pol_entry = policy_data[match.start():policy_data.index(']'.encode('utf-16-le'), match.end())].split(encoded_semicolon, 4)\n                if len(pol_entry) >= 2:\n                    valueName = pol_entry[1].decode('utf-16-le').rstrip(chr(0))\n                if len(pol_entry) >= 5:\n                    value = encoded_semicolon.join(pol_entry[4:])\n                    if vtype == 'REG_DWORD' or vtype == 'REG_QWORD':\n                        if value:\n                            if vtype == 'REG_DWORD':\n                                for v in struct.unpack(b'I', value):\n                                    value = v\n                            elif vtype == 'REG_QWORD':\n                                for v in struct.unpack(b'Q', value):\n                                    value = v\n                        else:\n                            value = 0\n                    elif vtype == 'REG_MULTI_SZ':\n                        value = value.decode('utf-16-le').rstrip(chr(0)).split(chr(0))\n                    else:\n                        value = value.decode('utf-16-le').rstrip(chr(0))\n                if return_value_name:\n                    log.trace('we want value names and the value')\n                    values[valueName] = value\n                elif len(matches) > 1:\n                    log.trace('we have multiple matches, we will return a list')\n                    values.append(value)\n    if values:\n        value = values\n    return value"
        ]
    },
    {
        "func_name": "_checkListItem",
        "original": "def _checkListItem(policy_element, policy_name, policy_key, xpath_object, policy_file_data, test_items=True):\n    \"\"\"\n    helper function to process an enabled/disabled/true/falseList set\n\n    if test_items is True, it will determine if the policy is enabled or\n    disabled returning True if all items are configured in the registry.pol file\n    and false if they are not\n\n    if test_items is False, the expected strings for the items will be returned\n    as a list\n\n    returns True if the enabled/disabledList is 100% configured in the\n    registry.pol file, otherwise returns False\n    \"\"\"\n    xpath_string = './/*[local-name() = \"decimal\" or local-name() = \"delete\" or local-name() = \"longDecimal\" or local-name() = \"string\"]'\n    value_item_child_xpath = etree.XPath(xpath_string)\n    expected_strings = []\n    for list_element in xpath_object(policy_element):\n        configured_items = 0\n        required_items = 0\n        for item in list_element:\n            required_items = required_items + 1\n            if 'key' in item.attrib:\n                item_key = item.attrib['key']\n            else:\n                item_key = policy_key\n            if 'valueName' in item.attrib:\n                item_valuename = item.attrib['valueName']\n            else:\n                log.error('%s item with attributes %s in policy %s does not have the required \"valueName\" attribute', etree.QName(list_element).localname, item.attrib, policy_element.attrib)\n                break\n            for value_item in value_item_child_xpath(item):\n                search_string = _processValueItem(value_item, item_key, item_valuename, policy_element, item)\n                if test_items:\n                    if search_reg_pol(re.escape(search_string), policy_file_data):\n                        configured_items = configured_items + 1\n                        log.trace('found the search string in the pol file,%s of %s items for policy %s are configured in registry.pol', configured_items, required_items, policy_name)\n                else:\n                    expected_strings.append(search_string)\n        if test_items:\n            if required_items > 0 and required_items == configured_items:\n                log.trace('%s all items are set', policy_name)\n                return True\n    if test_items:\n        return False\n    else:\n        return expected_strings",
        "mutated": [
            "def _checkListItem(policy_element, policy_name, policy_key, xpath_object, policy_file_data, test_items=True):\n    if False:\n        i = 10\n    '\\n    helper function to process an enabled/disabled/true/falseList set\\n\\n    if test_items is True, it will determine if the policy is enabled or\\n    disabled returning True if all items are configured in the registry.pol file\\n    and false if they are not\\n\\n    if test_items is False, the expected strings for the items will be returned\\n    as a list\\n\\n    returns True if the enabled/disabledList is 100% configured in the\\n    registry.pol file, otherwise returns False\\n    '\n    xpath_string = './/*[local-name() = \"decimal\" or local-name() = \"delete\" or local-name() = \"longDecimal\" or local-name() = \"string\"]'\n    value_item_child_xpath = etree.XPath(xpath_string)\n    expected_strings = []\n    for list_element in xpath_object(policy_element):\n        configured_items = 0\n        required_items = 0\n        for item in list_element:\n            required_items = required_items + 1\n            if 'key' in item.attrib:\n                item_key = item.attrib['key']\n            else:\n                item_key = policy_key\n            if 'valueName' in item.attrib:\n                item_valuename = item.attrib['valueName']\n            else:\n                log.error('%s item with attributes %s in policy %s does not have the required \"valueName\" attribute', etree.QName(list_element).localname, item.attrib, policy_element.attrib)\n                break\n            for value_item in value_item_child_xpath(item):\n                search_string = _processValueItem(value_item, item_key, item_valuename, policy_element, item)\n                if test_items:\n                    if search_reg_pol(re.escape(search_string), policy_file_data):\n                        configured_items = configured_items + 1\n                        log.trace('found the search string in the pol file,%s of %s items for policy %s are configured in registry.pol', configured_items, required_items, policy_name)\n                else:\n                    expected_strings.append(search_string)\n        if test_items:\n            if required_items > 0 and required_items == configured_items:\n                log.trace('%s all items are set', policy_name)\n                return True\n    if test_items:\n        return False\n    else:\n        return expected_strings",
            "def _checkListItem(policy_element, policy_name, policy_key, xpath_object, policy_file_data, test_items=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    helper function to process an enabled/disabled/true/falseList set\\n\\n    if test_items is True, it will determine if the policy is enabled or\\n    disabled returning True if all items are configured in the registry.pol file\\n    and false if they are not\\n\\n    if test_items is False, the expected strings for the items will be returned\\n    as a list\\n\\n    returns True if the enabled/disabledList is 100% configured in the\\n    registry.pol file, otherwise returns False\\n    '\n    xpath_string = './/*[local-name() = \"decimal\" or local-name() = \"delete\" or local-name() = \"longDecimal\" or local-name() = \"string\"]'\n    value_item_child_xpath = etree.XPath(xpath_string)\n    expected_strings = []\n    for list_element in xpath_object(policy_element):\n        configured_items = 0\n        required_items = 0\n        for item in list_element:\n            required_items = required_items + 1\n            if 'key' in item.attrib:\n                item_key = item.attrib['key']\n            else:\n                item_key = policy_key\n            if 'valueName' in item.attrib:\n                item_valuename = item.attrib['valueName']\n            else:\n                log.error('%s item with attributes %s in policy %s does not have the required \"valueName\" attribute', etree.QName(list_element).localname, item.attrib, policy_element.attrib)\n                break\n            for value_item in value_item_child_xpath(item):\n                search_string = _processValueItem(value_item, item_key, item_valuename, policy_element, item)\n                if test_items:\n                    if search_reg_pol(re.escape(search_string), policy_file_data):\n                        configured_items = configured_items + 1\n                        log.trace('found the search string in the pol file,%s of %s items for policy %s are configured in registry.pol', configured_items, required_items, policy_name)\n                else:\n                    expected_strings.append(search_string)\n        if test_items:\n            if required_items > 0 and required_items == configured_items:\n                log.trace('%s all items are set', policy_name)\n                return True\n    if test_items:\n        return False\n    else:\n        return expected_strings",
            "def _checkListItem(policy_element, policy_name, policy_key, xpath_object, policy_file_data, test_items=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    helper function to process an enabled/disabled/true/falseList set\\n\\n    if test_items is True, it will determine if the policy is enabled or\\n    disabled returning True if all items are configured in the registry.pol file\\n    and false if they are not\\n\\n    if test_items is False, the expected strings for the items will be returned\\n    as a list\\n\\n    returns True if the enabled/disabledList is 100% configured in the\\n    registry.pol file, otherwise returns False\\n    '\n    xpath_string = './/*[local-name() = \"decimal\" or local-name() = \"delete\" or local-name() = \"longDecimal\" or local-name() = \"string\"]'\n    value_item_child_xpath = etree.XPath(xpath_string)\n    expected_strings = []\n    for list_element in xpath_object(policy_element):\n        configured_items = 0\n        required_items = 0\n        for item in list_element:\n            required_items = required_items + 1\n            if 'key' in item.attrib:\n                item_key = item.attrib['key']\n            else:\n                item_key = policy_key\n            if 'valueName' in item.attrib:\n                item_valuename = item.attrib['valueName']\n            else:\n                log.error('%s item with attributes %s in policy %s does not have the required \"valueName\" attribute', etree.QName(list_element).localname, item.attrib, policy_element.attrib)\n                break\n            for value_item in value_item_child_xpath(item):\n                search_string = _processValueItem(value_item, item_key, item_valuename, policy_element, item)\n                if test_items:\n                    if search_reg_pol(re.escape(search_string), policy_file_data):\n                        configured_items = configured_items + 1\n                        log.trace('found the search string in the pol file,%s of %s items for policy %s are configured in registry.pol', configured_items, required_items, policy_name)\n                else:\n                    expected_strings.append(search_string)\n        if test_items:\n            if required_items > 0 and required_items == configured_items:\n                log.trace('%s all items are set', policy_name)\n                return True\n    if test_items:\n        return False\n    else:\n        return expected_strings",
            "def _checkListItem(policy_element, policy_name, policy_key, xpath_object, policy_file_data, test_items=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    helper function to process an enabled/disabled/true/falseList set\\n\\n    if test_items is True, it will determine if the policy is enabled or\\n    disabled returning True if all items are configured in the registry.pol file\\n    and false if they are not\\n\\n    if test_items is False, the expected strings for the items will be returned\\n    as a list\\n\\n    returns True if the enabled/disabledList is 100% configured in the\\n    registry.pol file, otherwise returns False\\n    '\n    xpath_string = './/*[local-name() = \"decimal\" or local-name() = \"delete\" or local-name() = \"longDecimal\" or local-name() = \"string\"]'\n    value_item_child_xpath = etree.XPath(xpath_string)\n    expected_strings = []\n    for list_element in xpath_object(policy_element):\n        configured_items = 0\n        required_items = 0\n        for item in list_element:\n            required_items = required_items + 1\n            if 'key' in item.attrib:\n                item_key = item.attrib['key']\n            else:\n                item_key = policy_key\n            if 'valueName' in item.attrib:\n                item_valuename = item.attrib['valueName']\n            else:\n                log.error('%s item with attributes %s in policy %s does not have the required \"valueName\" attribute', etree.QName(list_element).localname, item.attrib, policy_element.attrib)\n                break\n            for value_item in value_item_child_xpath(item):\n                search_string = _processValueItem(value_item, item_key, item_valuename, policy_element, item)\n                if test_items:\n                    if search_reg_pol(re.escape(search_string), policy_file_data):\n                        configured_items = configured_items + 1\n                        log.trace('found the search string in the pol file,%s of %s items for policy %s are configured in registry.pol', configured_items, required_items, policy_name)\n                else:\n                    expected_strings.append(search_string)\n        if test_items:\n            if required_items > 0 and required_items == configured_items:\n                log.trace('%s all items are set', policy_name)\n                return True\n    if test_items:\n        return False\n    else:\n        return expected_strings",
            "def _checkListItem(policy_element, policy_name, policy_key, xpath_object, policy_file_data, test_items=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    helper function to process an enabled/disabled/true/falseList set\\n\\n    if test_items is True, it will determine if the policy is enabled or\\n    disabled returning True if all items are configured in the registry.pol file\\n    and false if they are not\\n\\n    if test_items is False, the expected strings for the items will be returned\\n    as a list\\n\\n    returns True if the enabled/disabledList is 100% configured in the\\n    registry.pol file, otherwise returns False\\n    '\n    xpath_string = './/*[local-name() = \"decimal\" or local-name() = \"delete\" or local-name() = \"longDecimal\" or local-name() = \"string\"]'\n    value_item_child_xpath = etree.XPath(xpath_string)\n    expected_strings = []\n    for list_element in xpath_object(policy_element):\n        configured_items = 0\n        required_items = 0\n        for item in list_element:\n            required_items = required_items + 1\n            if 'key' in item.attrib:\n                item_key = item.attrib['key']\n            else:\n                item_key = policy_key\n            if 'valueName' in item.attrib:\n                item_valuename = item.attrib['valueName']\n            else:\n                log.error('%s item with attributes %s in policy %s does not have the required \"valueName\" attribute', etree.QName(list_element).localname, item.attrib, policy_element.attrib)\n                break\n            for value_item in value_item_child_xpath(item):\n                search_string = _processValueItem(value_item, item_key, item_valuename, policy_element, item)\n                if test_items:\n                    if search_reg_pol(re.escape(search_string), policy_file_data):\n                        configured_items = configured_items + 1\n                        log.trace('found the search string in the pol file,%s of %s items for policy %s are configured in registry.pol', configured_items, required_items, policy_name)\n                else:\n                    expected_strings.append(search_string)\n        if test_items:\n            if required_items > 0 and required_items == configured_items:\n                log.trace('%s all items are set', policy_name)\n                return True\n    if test_items:\n        return False\n    else:\n        return expected_strings"
        ]
    },
    {
        "func_name": "_checkValueItemParent",
        "original": "def _checkValueItemParent(policy_element, policy_name, policy_key, policy_valueName, xpath_object, policy_file_data, check_deleted=False, test_item=True):\n    \"\"\"\n    helper function to process the parent of a value item object\n    if test_item is True, it will determine if the policy is enabled/disabled\n    returns True if the value is configured in the registry.pol file, otherwise returns False\n\n    if test_item is False, the expected search string will be returned\n\n    value type parents:\n        boolean: https://msdn.microsoft.com/en-us/library/dn606009(v=vs.85).aspx\n        enabledValue: https://msdn.microsoft.com/en-us/library/dn606006(v=vs.85).aspx\n        disabledValue: https://msdn.microsoft.com/en-us/library/dn606001(v=vs.85).aspx\n\n    \"\"\"\n    for element in xpath_object(policy_element):\n        for value_item in element:\n            search_string = _processValueItem(value_item, policy_key, policy_valueName, policy_element, element, check_deleted=check_deleted)\n            if not test_item:\n                return search_string\n            if search_reg_pol(re.escape(search_string), policy_file_data):\n                log.trace('found the search string in the pol file, %s is configured', policy_name)\n                return True\n    return False",
        "mutated": [
            "def _checkValueItemParent(policy_element, policy_name, policy_key, policy_valueName, xpath_object, policy_file_data, check_deleted=False, test_item=True):\n    if False:\n        i = 10\n    '\\n    helper function to process the parent of a value item object\\n    if test_item is True, it will determine if the policy is enabled/disabled\\n    returns True if the value is configured in the registry.pol file, otherwise returns False\\n\\n    if test_item is False, the expected search string will be returned\\n\\n    value type parents:\\n        boolean: https://msdn.microsoft.com/en-us/library/dn606009(v=vs.85).aspx\\n        enabledValue: https://msdn.microsoft.com/en-us/library/dn606006(v=vs.85).aspx\\n        disabledValue: https://msdn.microsoft.com/en-us/library/dn606001(v=vs.85).aspx\\n\\n    '\n    for element in xpath_object(policy_element):\n        for value_item in element:\n            search_string = _processValueItem(value_item, policy_key, policy_valueName, policy_element, element, check_deleted=check_deleted)\n            if not test_item:\n                return search_string\n            if search_reg_pol(re.escape(search_string), policy_file_data):\n                log.trace('found the search string in the pol file, %s is configured', policy_name)\n                return True\n    return False",
            "def _checkValueItemParent(policy_element, policy_name, policy_key, policy_valueName, xpath_object, policy_file_data, check_deleted=False, test_item=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    helper function to process the parent of a value item object\\n    if test_item is True, it will determine if the policy is enabled/disabled\\n    returns True if the value is configured in the registry.pol file, otherwise returns False\\n\\n    if test_item is False, the expected search string will be returned\\n\\n    value type parents:\\n        boolean: https://msdn.microsoft.com/en-us/library/dn606009(v=vs.85).aspx\\n        enabledValue: https://msdn.microsoft.com/en-us/library/dn606006(v=vs.85).aspx\\n        disabledValue: https://msdn.microsoft.com/en-us/library/dn606001(v=vs.85).aspx\\n\\n    '\n    for element in xpath_object(policy_element):\n        for value_item in element:\n            search_string = _processValueItem(value_item, policy_key, policy_valueName, policy_element, element, check_deleted=check_deleted)\n            if not test_item:\n                return search_string\n            if search_reg_pol(re.escape(search_string), policy_file_data):\n                log.trace('found the search string in the pol file, %s is configured', policy_name)\n                return True\n    return False",
            "def _checkValueItemParent(policy_element, policy_name, policy_key, policy_valueName, xpath_object, policy_file_data, check_deleted=False, test_item=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    helper function to process the parent of a value item object\\n    if test_item is True, it will determine if the policy is enabled/disabled\\n    returns True if the value is configured in the registry.pol file, otherwise returns False\\n\\n    if test_item is False, the expected search string will be returned\\n\\n    value type parents:\\n        boolean: https://msdn.microsoft.com/en-us/library/dn606009(v=vs.85).aspx\\n        enabledValue: https://msdn.microsoft.com/en-us/library/dn606006(v=vs.85).aspx\\n        disabledValue: https://msdn.microsoft.com/en-us/library/dn606001(v=vs.85).aspx\\n\\n    '\n    for element in xpath_object(policy_element):\n        for value_item in element:\n            search_string = _processValueItem(value_item, policy_key, policy_valueName, policy_element, element, check_deleted=check_deleted)\n            if not test_item:\n                return search_string\n            if search_reg_pol(re.escape(search_string), policy_file_data):\n                log.trace('found the search string in the pol file, %s is configured', policy_name)\n                return True\n    return False",
            "def _checkValueItemParent(policy_element, policy_name, policy_key, policy_valueName, xpath_object, policy_file_data, check_deleted=False, test_item=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    helper function to process the parent of a value item object\\n    if test_item is True, it will determine if the policy is enabled/disabled\\n    returns True if the value is configured in the registry.pol file, otherwise returns False\\n\\n    if test_item is False, the expected search string will be returned\\n\\n    value type parents:\\n        boolean: https://msdn.microsoft.com/en-us/library/dn606009(v=vs.85).aspx\\n        enabledValue: https://msdn.microsoft.com/en-us/library/dn606006(v=vs.85).aspx\\n        disabledValue: https://msdn.microsoft.com/en-us/library/dn606001(v=vs.85).aspx\\n\\n    '\n    for element in xpath_object(policy_element):\n        for value_item in element:\n            search_string = _processValueItem(value_item, policy_key, policy_valueName, policy_element, element, check_deleted=check_deleted)\n            if not test_item:\n                return search_string\n            if search_reg_pol(re.escape(search_string), policy_file_data):\n                log.trace('found the search string in the pol file, %s is configured', policy_name)\n                return True\n    return False",
            "def _checkValueItemParent(policy_element, policy_name, policy_key, policy_valueName, xpath_object, policy_file_data, check_deleted=False, test_item=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    helper function to process the parent of a value item object\\n    if test_item is True, it will determine if the policy is enabled/disabled\\n    returns True if the value is configured in the registry.pol file, otherwise returns False\\n\\n    if test_item is False, the expected search string will be returned\\n\\n    value type parents:\\n        boolean: https://msdn.microsoft.com/en-us/library/dn606009(v=vs.85).aspx\\n        enabledValue: https://msdn.microsoft.com/en-us/library/dn606006(v=vs.85).aspx\\n        disabledValue: https://msdn.microsoft.com/en-us/library/dn606001(v=vs.85).aspx\\n\\n    '\n    for element in xpath_object(policy_element):\n        for value_item in element:\n            search_string = _processValueItem(value_item, policy_key, policy_valueName, policy_element, element, check_deleted=check_deleted)\n            if not test_item:\n                return search_string\n            if search_reg_pol(re.escape(search_string), policy_file_data):\n                log.trace('found the search string in the pol file, %s is configured', policy_name)\n                return True\n    return False"
        ]
    },
    {
        "func_name": "_encode_string",
        "original": "def _encode_string(value):\n    encoded_null = chr(0).encode('utf-16-le')\n    if value is None:\n        return encoded_null\n    elif not isinstance(value, str):\n        raise TypeError(f'Value {repr(value)} is not a string type\\nType: {type(value)}')\n    return b''.join([value.encode('utf-16-le'), encoded_null])",
        "mutated": [
            "def _encode_string(value):\n    if False:\n        i = 10\n    encoded_null = chr(0).encode('utf-16-le')\n    if value is None:\n        return encoded_null\n    elif not isinstance(value, str):\n        raise TypeError(f'Value {repr(value)} is not a string type\\nType: {type(value)}')\n    return b''.join([value.encode('utf-16-le'), encoded_null])",
            "def _encode_string(value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    encoded_null = chr(0).encode('utf-16-le')\n    if value is None:\n        return encoded_null\n    elif not isinstance(value, str):\n        raise TypeError(f'Value {repr(value)} is not a string type\\nType: {type(value)}')\n    return b''.join([value.encode('utf-16-le'), encoded_null])",
            "def _encode_string(value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    encoded_null = chr(0).encode('utf-16-le')\n    if value is None:\n        return encoded_null\n    elif not isinstance(value, str):\n        raise TypeError(f'Value {repr(value)} is not a string type\\nType: {type(value)}')\n    return b''.join([value.encode('utf-16-le'), encoded_null])",
            "def _encode_string(value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    encoded_null = chr(0).encode('utf-16-le')\n    if value is None:\n        return encoded_null\n    elif not isinstance(value, str):\n        raise TypeError(f'Value {repr(value)} is not a string type\\nType: {type(value)}')\n    return b''.join([value.encode('utf-16-le'), encoded_null])",
            "def _encode_string(value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    encoded_null = chr(0).encode('utf-16-le')\n    if value is None:\n        return encoded_null\n    elif not isinstance(value, str):\n        raise TypeError(f'Value {repr(value)} is not a string type\\nType: {type(value)}')\n    return b''.join([value.encode('utf-16-le'), encoded_null])"
        ]
    },
    {
        "func_name": "_buildKnownDataSearchString",
        "original": "def _buildKnownDataSearchString(reg_key, reg_valueName, reg_vtype, reg_data, check_deleted=False):\n    \"\"\"\n    helper function similar to _processValueItem to build a search string for a\n    known key/value/type/data\n    \"\"\"\n    registry = Registry()\n    this_element_value = None\n    encoded_semicolon = ';'.encode('utf-16-le')\n    encoded_null = chr(0).encode('utf-16-le')\n    if reg_key:\n        reg_key = reg_key.encode('utf-16-le')\n    if reg_valueName:\n        reg_valueName = reg_valueName.encode('utf-16-le')\n    if reg_data and (not check_deleted):\n        if reg_vtype == 'REG_DWORD':\n            this_element_value = struct.pack(b'I', int(reg_data))\n        elif reg_vtype == 'REG_QWORD':\n            this_element_value = struct.pack(b'Q', int(reg_data))\n        elif reg_vtype == 'REG_SZ':\n            this_element_value = _encode_string(reg_data)\n    if check_deleted:\n        reg_vtype = 'REG_SZ'\n        expected_string = b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, '**del.'.encode('utf-16-le'), reg_valueName, encoded_null, encoded_semicolon, chr(registry.vtype[reg_vtype]).encode('utf-32-le'), encoded_semicolon, chr(len(f' {chr(0)}'.encode('utf-16-le'))).encode('utf-32-le'), encoded_semicolon, ' '.encode('utf-16-le'), encoded_null, ']'.encode('utf-16-le')])\n    else:\n        expected_string = b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, reg_valueName, encoded_null, encoded_semicolon, chr(registry.vtype[reg_vtype]).encode('utf-32-le'), encoded_semicolon, chr(len(this_element_value)).encode('utf-32-le'), encoded_semicolon, this_element_value, ']'.encode('utf-16-le')])\n    return expected_string",
        "mutated": [
            "def _buildKnownDataSearchString(reg_key, reg_valueName, reg_vtype, reg_data, check_deleted=False):\n    if False:\n        i = 10\n    '\\n    helper function similar to _processValueItem to build a search string for a\\n    known key/value/type/data\\n    '\n    registry = Registry()\n    this_element_value = None\n    encoded_semicolon = ';'.encode('utf-16-le')\n    encoded_null = chr(0).encode('utf-16-le')\n    if reg_key:\n        reg_key = reg_key.encode('utf-16-le')\n    if reg_valueName:\n        reg_valueName = reg_valueName.encode('utf-16-le')\n    if reg_data and (not check_deleted):\n        if reg_vtype == 'REG_DWORD':\n            this_element_value = struct.pack(b'I', int(reg_data))\n        elif reg_vtype == 'REG_QWORD':\n            this_element_value = struct.pack(b'Q', int(reg_data))\n        elif reg_vtype == 'REG_SZ':\n            this_element_value = _encode_string(reg_data)\n    if check_deleted:\n        reg_vtype = 'REG_SZ'\n        expected_string = b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, '**del.'.encode('utf-16-le'), reg_valueName, encoded_null, encoded_semicolon, chr(registry.vtype[reg_vtype]).encode('utf-32-le'), encoded_semicolon, chr(len(f' {chr(0)}'.encode('utf-16-le'))).encode('utf-32-le'), encoded_semicolon, ' '.encode('utf-16-le'), encoded_null, ']'.encode('utf-16-le')])\n    else:\n        expected_string = b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, reg_valueName, encoded_null, encoded_semicolon, chr(registry.vtype[reg_vtype]).encode('utf-32-le'), encoded_semicolon, chr(len(this_element_value)).encode('utf-32-le'), encoded_semicolon, this_element_value, ']'.encode('utf-16-le')])\n    return expected_string",
            "def _buildKnownDataSearchString(reg_key, reg_valueName, reg_vtype, reg_data, check_deleted=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    helper function similar to _processValueItem to build a search string for a\\n    known key/value/type/data\\n    '\n    registry = Registry()\n    this_element_value = None\n    encoded_semicolon = ';'.encode('utf-16-le')\n    encoded_null = chr(0).encode('utf-16-le')\n    if reg_key:\n        reg_key = reg_key.encode('utf-16-le')\n    if reg_valueName:\n        reg_valueName = reg_valueName.encode('utf-16-le')\n    if reg_data and (not check_deleted):\n        if reg_vtype == 'REG_DWORD':\n            this_element_value = struct.pack(b'I', int(reg_data))\n        elif reg_vtype == 'REG_QWORD':\n            this_element_value = struct.pack(b'Q', int(reg_data))\n        elif reg_vtype == 'REG_SZ':\n            this_element_value = _encode_string(reg_data)\n    if check_deleted:\n        reg_vtype = 'REG_SZ'\n        expected_string = b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, '**del.'.encode('utf-16-le'), reg_valueName, encoded_null, encoded_semicolon, chr(registry.vtype[reg_vtype]).encode('utf-32-le'), encoded_semicolon, chr(len(f' {chr(0)}'.encode('utf-16-le'))).encode('utf-32-le'), encoded_semicolon, ' '.encode('utf-16-le'), encoded_null, ']'.encode('utf-16-le')])\n    else:\n        expected_string = b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, reg_valueName, encoded_null, encoded_semicolon, chr(registry.vtype[reg_vtype]).encode('utf-32-le'), encoded_semicolon, chr(len(this_element_value)).encode('utf-32-le'), encoded_semicolon, this_element_value, ']'.encode('utf-16-le')])\n    return expected_string",
            "def _buildKnownDataSearchString(reg_key, reg_valueName, reg_vtype, reg_data, check_deleted=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    helper function similar to _processValueItem to build a search string for a\\n    known key/value/type/data\\n    '\n    registry = Registry()\n    this_element_value = None\n    encoded_semicolon = ';'.encode('utf-16-le')\n    encoded_null = chr(0).encode('utf-16-le')\n    if reg_key:\n        reg_key = reg_key.encode('utf-16-le')\n    if reg_valueName:\n        reg_valueName = reg_valueName.encode('utf-16-le')\n    if reg_data and (not check_deleted):\n        if reg_vtype == 'REG_DWORD':\n            this_element_value = struct.pack(b'I', int(reg_data))\n        elif reg_vtype == 'REG_QWORD':\n            this_element_value = struct.pack(b'Q', int(reg_data))\n        elif reg_vtype == 'REG_SZ':\n            this_element_value = _encode_string(reg_data)\n    if check_deleted:\n        reg_vtype = 'REG_SZ'\n        expected_string = b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, '**del.'.encode('utf-16-le'), reg_valueName, encoded_null, encoded_semicolon, chr(registry.vtype[reg_vtype]).encode('utf-32-le'), encoded_semicolon, chr(len(f' {chr(0)}'.encode('utf-16-le'))).encode('utf-32-le'), encoded_semicolon, ' '.encode('utf-16-le'), encoded_null, ']'.encode('utf-16-le')])\n    else:\n        expected_string = b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, reg_valueName, encoded_null, encoded_semicolon, chr(registry.vtype[reg_vtype]).encode('utf-32-le'), encoded_semicolon, chr(len(this_element_value)).encode('utf-32-le'), encoded_semicolon, this_element_value, ']'.encode('utf-16-le')])\n    return expected_string",
            "def _buildKnownDataSearchString(reg_key, reg_valueName, reg_vtype, reg_data, check_deleted=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    helper function similar to _processValueItem to build a search string for a\\n    known key/value/type/data\\n    '\n    registry = Registry()\n    this_element_value = None\n    encoded_semicolon = ';'.encode('utf-16-le')\n    encoded_null = chr(0).encode('utf-16-le')\n    if reg_key:\n        reg_key = reg_key.encode('utf-16-le')\n    if reg_valueName:\n        reg_valueName = reg_valueName.encode('utf-16-le')\n    if reg_data and (not check_deleted):\n        if reg_vtype == 'REG_DWORD':\n            this_element_value = struct.pack(b'I', int(reg_data))\n        elif reg_vtype == 'REG_QWORD':\n            this_element_value = struct.pack(b'Q', int(reg_data))\n        elif reg_vtype == 'REG_SZ':\n            this_element_value = _encode_string(reg_data)\n    if check_deleted:\n        reg_vtype = 'REG_SZ'\n        expected_string = b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, '**del.'.encode('utf-16-le'), reg_valueName, encoded_null, encoded_semicolon, chr(registry.vtype[reg_vtype]).encode('utf-32-le'), encoded_semicolon, chr(len(f' {chr(0)}'.encode('utf-16-le'))).encode('utf-32-le'), encoded_semicolon, ' '.encode('utf-16-le'), encoded_null, ']'.encode('utf-16-le')])\n    else:\n        expected_string = b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, reg_valueName, encoded_null, encoded_semicolon, chr(registry.vtype[reg_vtype]).encode('utf-32-le'), encoded_semicolon, chr(len(this_element_value)).encode('utf-32-le'), encoded_semicolon, this_element_value, ']'.encode('utf-16-le')])\n    return expected_string",
            "def _buildKnownDataSearchString(reg_key, reg_valueName, reg_vtype, reg_data, check_deleted=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    helper function similar to _processValueItem to build a search string for a\\n    known key/value/type/data\\n    '\n    registry = Registry()\n    this_element_value = None\n    encoded_semicolon = ';'.encode('utf-16-le')\n    encoded_null = chr(0).encode('utf-16-le')\n    if reg_key:\n        reg_key = reg_key.encode('utf-16-le')\n    if reg_valueName:\n        reg_valueName = reg_valueName.encode('utf-16-le')\n    if reg_data and (not check_deleted):\n        if reg_vtype == 'REG_DWORD':\n            this_element_value = struct.pack(b'I', int(reg_data))\n        elif reg_vtype == 'REG_QWORD':\n            this_element_value = struct.pack(b'Q', int(reg_data))\n        elif reg_vtype == 'REG_SZ':\n            this_element_value = _encode_string(reg_data)\n    if check_deleted:\n        reg_vtype = 'REG_SZ'\n        expected_string = b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, '**del.'.encode('utf-16-le'), reg_valueName, encoded_null, encoded_semicolon, chr(registry.vtype[reg_vtype]).encode('utf-32-le'), encoded_semicolon, chr(len(f' {chr(0)}'.encode('utf-16-le'))).encode('utf-32-le'), encoded_semicolon, ' '.encode('utf-16-le'), encoded_null, ']'.encode('utf-16-le')])\n    else:\n        expected_string = b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, reg_valueName, encoded_null, encoded_semicolon, chr(registry.vtype[reg_vtype]).encode('utf-32-le'), encoded_semicolon, chr(len(this_element_value)).encode('utf-32-le'), encoded_semicolon, this_element_value, ']'.encode('utf-16-le')])\n    return expected_string"
        ]
    },
    {
        "func_name": "_processValueItem",
        "original": "def _processValueItem(element, reg_key, reg_valuename, policy, parent_element, check_deleted=False, this_element_value=None):\n    \"\"\"\n    helper function to process a value type item and generate the expected\n    string in the Registry.pol file\n\n    element - the element to process\n    reg_key - the registry key associated with the element (some inherit from\n              their parent policy)\n    reg_valuename - the registry valueName associated with the element (some\n                    inherit from their parent policy)\n    policy - the parent policy element\n    parent_element - the parent element (primarily passed in to differentiate\n                     children of \"elements\" objects\n    check_deleted - if the returned expected string should be for a deleted\n                    value\n    this_element_value - a specific value to place into the expected string\n                         returned for \"elements\" children whose values are\n                         specified by the user\n    \"\"\"\n    registry = Registry()\n    expected_string = None\n    this_vtype = 'REG_SZ'\n    encoded_semicolon = ';'.encode('utf-16-le')\n    encoded_null = chr(0).encode('utf-16-le')\n    if reg_key:\n        reg_key = reg_key.encode('utf-16-le')\n    if reg_valuename:\n        reg_valuename = reg_valuename.encode('utf-16-le')\n    if etree.QName(element).localname == 'decimal' and etree.QName(parent_element).localname != 'elements':\n        this_vtype = 'REG_DWORD'\n        if 'value' in element.attrib:\n            this_element_value = struct.pack(b'I', int(element.attrib['value']))\n        else:\n            log.error('The %s child %s element for the policy with attributes: %s does not have the required \"value\" attribute. The element attributes are: %s', etree.QName(parent_element).localname, etree.QName(element).localname, policy.attrib, element.attrib)\n            return None\n    elif etree.QName(element).localname == 'longDecimal' and etree.QName(parent_element).localname != 'elements':\n        this_vtype = 'REG_QWORD'\n        if 'value' in element.attrib:\n            this_element_value = struct.pack(b'Q', int(element.attrib['value']))\n        else:\n            log.error('The %s child %s element for the policy with attributes: %s does not have the required \"value\" attribute. The element attributes are: %s', etree.QName(parent_element).localname, etree.QName(element).localname, policy.attrib, element.attrib)\n            return None\n    elif etree.QName(element).localname == 'string':\n        this_vtype = 'REG_SZ'\n        this_element_value = _encode_string(element.text)\n    elif etree.QName(parent_element).localname == 'elements':\n        standard_element_expected_string = True\n        if etree.QName(element).localname == 'boolean':\n            if this_element_value is False:\n                check_deleted = True\n            if not check_deleted:\n                this_vtype = 'REG_DWORD'\n            this_element_value = struct.pack('I', 1)\n            standard_element_expected_string = False\n        elif etree.QName(element).localname == 'decimal':\n            this_vtype = 'REG_DWORD'\n            requested_val = this_element_value\n            if this_element_value is not None:\n                this_element_value = struct.pack(b'I', int(this_element_value))\n            if 'storeAsText' in element.attrib:\n                if element.attrib['storeAsText'].lower() == 'true':\n                    this_vtype = 'REG_SZ'\n                    if requested_val is not None:\n                        this_element_value = str(requested_val).encode('utf-16-le')\n            if check_deleted:\n                this_vtype = 'REG_SZ'\n        elif etree.QName(element).localname == 'longDecimal':\n            this_vtype = 'REG_QWORD'\n            requested_val = this_element_value\n            if this_element_value is not None:\n                this_element_value = struct.pack(b'Q', int(this_element_value))\n            if 'storeAsText' in element.attrib:\n                if element.attrib['storeAsText'].lower() == 'true':\n                    this_vtype = 'REG_SZ'\n                    if requested_val is not None:\n                        this_element_value = str(requested_val).encode('utf-16-le')\n        elif etree.QName(element).localname == 'text':\n            this_vtype = 'REG_SZ'\n            if 'expandable' in element.attrib:\n                if element.attrib['expandable'].lower() == 'true':\n                    this_vtype = 'REG_EXPAND_SZ'\n            if this_element_value is not None:\n                this_element_value = _encode_string(this_element_value)\n        elif etree.QName(element).localname == 'multiText':\n            this_vtype = 'REG_MULTI_SZ' if not check_deleted else 'REG_SZ'\n            if this_element_value is not None:\n                this_element_value = '{0}{1}{1}'.format(chr(0).join(this_element_value), chr(0))\n        elif etree.QName(element).localname == 'list':\n            standard_element_expected_string = False\n            del_keys = b''\n            element_valuenames = []\n            element_values = this_element_value\n            if this_element_value is not None:\n                element_valuenames = [str(z) for z in range(1, len(this_element_value) + 1)]\n            if 'additive' in element.attrib:\n                if element.attrib['additive'].lower() == 'false':\n                    del_keys = b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, '**delvals.'.encode('utf-16-le'), encoded_null, encoded_semicolon, chr(registry.vtype[this_vtype]).encode('utf-32-le'), encoded_semicolon, chr(len(f' {chr(0)}'.encode('utf-16-le'))).encode('utf-32-le'), encoded_semicolon, ' '.encode('utf-16-le'), encoded_null, ']'.encode('utf-16-le')])\n            if 'expandable' in element.attrib:\n                this_vtype = 'REG_EXPAND_SZ'\n            if element.attrib.get('explicitValue', 'false').lower() == 'true':\n                if this_element_value is not None:\n                    element_valuenames = [str(k) for k in this_element_value.keys()]\n                    element_values = [str(v) for v in this_element_value.values()]\n            elif 'valuePrefix' in element.attrib:\n                if element.attrib['valuePrefix'] != '':\n                    if this_element_value is not None:\n                        element_valuenames = ['{}{}'.format(element.attrib['valuePrefix'], k) for k in element_valuenames]\n            elif element_values is not None:\n                element_valuenames = [str(z) for z in element_values]\n            if not check_deleted:\n                if this_element_value is not None:\n                    log.trace('_processValueItem has an explicit element_value of %s', this_element_value)\n                    expected_string = del_keys\n                    log.trace('element_valuenames == %s and element_values == %s', element_valuenames, element_values)\n                    for (i, item) in enumerate(element_valuenames):\n                        expected_string = expected_string + b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, element_valuenames[i].encode('utf-16-le'), encoded_null, encoded_semicolon, chr(registry.vtype[this_vtype]).encode('utf-32-le'), encoded_semicolon, chr(len(f'{element_values[i]}{chr(0)}'.encode('utf-16-le'))).encode('utf-32-le'), encoded_semicolon, _encode_string(element_values[i]), ']'.encode('utf-16-le')])\n                else:\n                    expected_string = del_keys + b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon])\n            else:\n                expected_string = b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, '**delvals.'.encode('utf-16-le'), encoded_null, encoded_semicolon, chr(registry.vtype[this_vtype]).encode('utf-32-le'), encoded_semicolon, chr(len(f' {chr(0)}'.encode('utf-16-le'))).encode('utf-32-le'), encoded_semicolon, ' '.encode('utf-16-le'), encoded_null, ']'.encode('utf-16-le')])\n        elif etree.QName(element).localname == 'enum':\n            if this_element_value is not None:\n                pass\n        if standard_element_expected_string and (not check_deleted):\n            if this_element_value is not None:\n                if isinstance(this_element_value, str):\n                    log.debug('Converting %s to bytes', this_element_value)\n                    this_element_value = this_element_value.encode('utf-32-le')\n                expected_string = b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, reg_valuename, encoded_null, encoded_semicolon, chr(registry.vtype[this_vtype]).encode('utf-32-le'), encoded_semicolon, chr(len(this_element_value)).encode('utf-32-le'), encoded_semicolon, this_element_value, ']'.encode('utf-16-le')])\n            else:\n                expected_string = b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, reg_valuename, encoded_null, encoded_semicolon, chr(registry.vtype[this_vtype]).encode('utf-32-le'), encoded_semicolon])\n    if not expected_string:\n        if etree.QName(element).localname == 'delete' or check_deleted:\n            expected_string = b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, '**del.'.encode('utf-16-le'), reg_valuename, encoded_null, encoded_semicolon, chr(registry.vtype[this_vtype]).encode('utf-32-le'), encoded_semicolon, chr(len(f' {chr(0)}'.encode('utf-16-le'))).encode('utf-32-le'), encoded_semicolon, ' '.encode('utf-16-le'), encoded_null, ']'.encode('utf-16-le')])\n        else:\n            expected_string = b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, reg_valuename, encoded_null, encoded_semicolon, chr(registry.vtype[this_vtype]).encode('utf-32-le'), encoded_semicolon, chr(len(this_element_value)).encode('utf-32-le'), encoded_semicolon, this_element_value, ']'.encode('utf-16-le')])\n    return expected_string",
        "mutated": [
            "def _processValueItem(element, reg_key, reg_valuename, policy, parent_element, check_deleted=False, this_element_value=None):\n    if False:\n        i = 10\n    '\\n    helper function to process a value type item and generate the expected\\n    string in the Registry.pol file\\n\\n    element - the element to process\\n    reg_key - the registry key associated with the element (some inherit from\\n              their parent policy)\\n    reg_valuename - the registry valueName associated with the element (some\\n                    inherit from their parent policy)\\n    policy - the parent policy element\\n    parent_element - the parent element (primarily passed in to differentiate\\n                     children of \"elements\" objects\\n    check_deleted - if the returned expected string should be for a deleted\\n                    value\\n    this_element_value - a specific value to place into the expected string\\n                         returned for \"elements\" children whose values are\\n                         specified by the user\\n    '\n    registry = Registry()\n    expected_string = None\n    this_vtype = 'REG_SZ'\n    encoded_semicolon = ';'.encode('utf-16-le')\n    encoded_null = chr(0).encode('utf-16-le')\n    if reg_key:\n        reg_key = reg_key.encode('utf-16-le')\n    if reg_valuename:\n        reg_valuename = reg_valuename.encode('utf-16-le')\n    if etree.QName(element).localname == 'decimal' and etree.QName(parent_element).localname != 'elements':\n        this_vtype = 'REG_DWORD'\n        if 'value' in element.attrib:\n            this_element_value = struct.pack(b'I', int(element.attrib['value']))\n        else:\n            log.error('The %s child %s element for the policy with attributes: %s does not have the required \"value\" attribute. The element attributes are: %s', etree.QName(parent_element).localname, etree.QName(element).localname, policy.attrib, element.attrib)\n            return None\n    elif etree.QName(element).localname == 'longDecimal' and etree.QName(parent_element).localname != 'elements':\n        this_vtype = 'REG_QWORD'\n        if 'value' in element.attrib:\n            this_element_value = struct.pack(b'Q', int(element.attrib['value']))\n        else:\n            log.error('The %s child %s element for the policy with attributes: %s does not have the required \"value\" attribute. The element attributes are: %s', etree.QName(parent_element).localname, etree.QName(element).localname, policy.attrib, element.attrib)\n            return None\n    elif etree.QName(element).localname == 'string':\n        this_vtype = 'REG_SZ'\n        this_element_value = _encode_string(element.text)\n    elif etree.QName(parent_element).localname == 'elements':\n        standard_element_expected_string = True\n        if etree.QName(element).localname == 'boolean':\n            if this_element_value is False:\n                check_deleted = True\n            if not check_deleted:\n                this_vtype = 'REG_DWORD'\n            this_element_value = struct.pack('I', 1)\n            standard_element_expected_string = False\n        elif etree.QName(element).localname == 'decimal':\n            this_vtype = 'REG_DWORD'\n            requested_val = this_element_value\n            if this_element_value is not None:\n                this_element_value = struct.pack(b'I', int(this_element_value))\n            if 'storeAsText' in element.attrib:\n                if element.attrib['storeAsText'].lower() == 'true':\n                    this_vtype = 'REG_SZ'\n                    if requested_val is not None:\n                        this_element_value = str(requested_val).encode('utf-16-le')\n            if check_deleted:\n                this_vtype = 'REG_SZ'\n        elif etree.QName(element).localname == 'longDecimal':\n            this_vtype = 'REG_QWORD'\n            requested_val = this_element_value\n            if this_element_value is not None:\n                this_element_value = struct.pack(b'Q', int(this_element_value))\n            if 'storeAsText' in element.attrib:\n                if element.attrib['storeAsText'].lower() == 'true':\n                    this_vtype = 'REG_SZ'\n                    if requested_val is not None:\n                        this_element_value = str(requested_val).encode('utf-16-le')\n        elif etree.QName(element).localname == 'text':\n            this_vtype = 'REG_SZ'\n            if 'expandable' in element.attrib:\n                if element.attrib['expandable'].lower() == 'true':\n                    this_vtype = 'REG_EXPAND_SZ'\n            if this_element_value is not None:\n                this_element_value = _encode_string(this_element_value)\n        elif etree.QName(element).localname == 'multiText':\n            this_vtype = 'REG_MULTI_SZ' if not check_deleted else 'REG_SZ'\n            if this_element_value is not None:\n                this_element_value = '{0}{1}{1}'.format(chr(0).join(this_element_value), chr(0))\n        elif etree.QName(element).localname == 'list':\n            standard_element_expected_string = False\n            del_keys = b''\n            element_valuenames = []\n            element_values = this_element_value\n            if this_element_value is not None:\n                element_valuenames = [str(z) for z in range(1, len(this_element_value) + 1)]\n            if 'additive' in element.attrib:\n                if element.attrib['additive'].lower() == 'false':\n                    del_keys = b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, '**delvals.'.encode('utf-16-le'), encoded_null, encoded_semicolon, chr(registry.vtype[this_vtype]).encode('utf-32-le'), encoded_semicolon, chr(len(f' {chr(0)}'.encode('utf-16-le'))).encode('utf-32-le'), encoded_semicolon, ' '.encode('utf-16-le'), encoded_null, ']'.encode('utf-16-le')])\n            if 'expandable' in element.attrib:\n                this_vtype = 'REG_EXPAND_SZ'\n            if element.attrib.get('explicitValue', 'false').lower() == 'true':\n                if this_element_value is not None:\n                    element_valuenames = [str(k) for k in this_element_value.keys()]\n                    element_values = [str(v) for v in this_element_value.values()]\n            elif 'valuePrefix' in element.attrib:\n                if element.attrib['valuePrefix'] != '':\n                    if this_element_value is not None:\n                        element_valuenames = ['{}{}'.format(element.attrib['valuePrefix'], k) for k in element_valuenames]\n            elif element_values is not None:\n                element_valuenames = [str(z) for z in element_values]\n            if not check_deleted:\n                if this_element_value is not None:\n                    log.trace('_processValueItem has an explicit element_value of %s', this_element_value)\n                    expected_string = del_keys\n                    log.trace('element_valuenames == %s and element_values == %s', element_valuenames, element_values)\n                    for (i, item) in enumerate(element_valuenames):\n                        expected_string = expected_string + b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, element_valuenames[i].encode('utf-16-le'), encoded_null, encoded_semicolon, chr(registry.vtype[this_vtype]).encode('utf-32-le'), encoded_semicolon, chr(len(f'{element_values[i]}{chr(0)}'.encode('utf-16-le'))).encode('utf-32-le'), encoded_semicolon, _encode_string(element_values[i]), ']'.encode('utf-16-le')])\n                else:\n                    expected_string = del_keys + b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon])\n            else:\n                expected_string = b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, '**delvals.'.encode('utf-16-le'), encoded_null, encoded_semicolon, chr(registry.vtype[this_vtype]).encode('utf-32-le'), encoded_semicolon, chr(len(f' {chr(0)}'.encode('utf-16-le'))).encode('utf-32-le'), encoded_semicolon, ' '.encode('utf-16-le'), encoded_null, ']'.encode('utf-16-le')])\n        elif etree.QName(element).localname == 'enum':\n            if this_element_value is not None:\n                pass\n        if standard_element_expected_string and (not check_deleted):\n            if this_element_value is not None:\n                if isinstance(this_element_value, str):\n                    log.debug('Converting %s to bytes', this_element_value)\n                    this_element_value = this_element_value.encode('utf-32-le')\n                expected_string = b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, reg_valuename, encoded_null, encoded_semicolon, chr(registry.vtype[this_vtype]).encode('utf-32-le'), encoded_semicolon, chr(len(this_element_value)).encode('utf-32-le'), encoded_semicolon, this_element_value, ']'.encode('utf-16-le')])\n            else:\n                expected_string = b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, reg_valuename, encoded_null, encoded_semicolon, chr(registry.vtype[this_vtype]).encode('utf-32-le'), encoded_semicolon])\n    if not expected_string:\n        if etree.QName(element).localname == 'delete' or check_deleted:\n            expected_string = b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, '**del.'.encode('utf-16-le'), reg_valuename, encoded_null, encoded_semicolon, chr(registry.vtype[this_vtype]).encode('utf-32-le'), encoded_semicolon, chr(len(f' {chr(0)}'.encode('utf-16-le'))).encode('utf-32-le'), encoded_semicolon, ' '.encode('utf-16-le'), encoded_null, ']'.encode('utf-16-le')])\n        else:\n            expected_string = b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, reg_valuename, encoded_null, encoded_semicolon, chr(registry.vtype[this_vtype]).encode('utf-32-le'), encoded_semicolon, chr(len(this_element_value)).encode('utf-32-le'), encoded_semicolon, this_element_value, ']'.encode('utf-16-le')])\n    return expected_string",
            "def _processValueItem(element, reg_key, reg_valuename, policy, parent_element, check_deleted=False, this_element_value=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    helper function to process a value type item and generate the expected\\n    string in the Registry.pol file\\n\\n    element - the element to process\\n    reg_key - the registry key associated with the element (some inherit from\\n              their parent policy)\\n    reg_valuename - the registry valueName associated with the element (some\\n                    inherit from their parent policy)\\n    policy - the parent policy element\\n    parent_element - the parent element (primarily passed in to differentiate\\n                     children of \"elements\" objects\\n    check_deleted - if the returned expected string should be for a deleted\\n                    value\\n    this_element_value - a specific value to place into the expected string\\n                         returned for \"elements\" children whose values are\\n                         specified by the user\\n    '\n    registry = Registry()\n    expected_string = None\n    this_vtype = 'REG_SZ'\n    encoded_semicolon = ';'.encode('utf-16-le')\n    encoded_null = chr(0).encode('utf-16-le')\n    if reg_key:\n        reg_key = reg_key.encode('utf-16-le')\n    if reg_valuename:\n        reg_valuename = reg_valuename.encode('utf-16-le')\n    if etree.QName(element).localname == 'decimal' and etree.QName(parent_element).localname != 'elements':\n        this_vtype = 'REG_DWORD'\n        if 'value' in element.attrib:\n            this_element_value = struct.pack(b'I', int(element.attrib['value']))\n        else:\n            log.error('The %s child %s element for the policy with attributes: %s does not have the required \"value\" attribute. The element attributes are: %s', etree.QName(parent_element).localname, etree.QName(element).localname, policy.attrib, element.attrib)\n            return None\n    elif etree.QName(element).localname == 'longDecimal' and etree.QName(parent_element).localname != 'elements':\n        this_vtype = 'REG_QWORD'\n        if 'value' in element.attrib:\n            this_element_value = struct.pack(b'Q', int(element.attrib['value']))\n        else:\n            log.error('The %s child %s element for the policy with attributes: %s does not have the required \"value\" attribute. The element attributes are: %s', etree.QName(parent_element).localname, etree.QName(element).localname, policy.attrib, element.attrib)\n            return None\n    elif etree.QName(element).localname == 'string':\n        this_vtype = 'REG_SZ'\n        this_element_value = _encode_string(element.text)\n    elif etree.QName(parent_element).localname == 'elements':\n        standard_element_expected_string = True\n        if etree.QName(element).localname == 'boolean':\n            if this_element_value is False:\n                check_deleted = True\n            if not check_deleted:\n                this_vtype = 'REG_DWORD'\n            this_element_value = struct.pack('I', 1)\n            standard_element_expected_string = False\n        elif etree.QName(element).localname == 'decimal':\n            this_vtype = 'REG_DWORD'\n            requested_val = this_element_value\n            if this_element_value is not None:\n                this_element_value = struct.pack(b'I', int(this_element_value))\n            if 'storeAsText' in element.attrib:\n                if element.attrib['storeAsText'].lower() == 'true':\n                    this_vtype = 'REG_SZ'\n                    if requested_val is not None:\n                        this_element_value = str(requested_val).encode('utf-16-le')\n            if check_deleted:\n                this_vtype = 'REG_SZ'\n        elif etree.QName(element).localname == 'longDecimal':\n            this_vtype = 'REG_QWORD'\n            requested_val = this_element_value\n            if this_element_value is not None:\n                this_element_value = struct.pack(b'Q', int(this_element_value))\n            if 'storeAsText' in element.attrib:\n                if element.attrib['storeAsText'].lower() == 'true':\n                    this_vtype = 'REG_SZ'\n                    if requested_val is not None:\n                        this_element_value = str(requested_val).encode('utf-16-le')\n        elif etree.QName(element).localname == 'text':\n            this_vtype = 'REG_SZ'\n            if 'expandable' in element.attrib:\n                if element.attrib['expandable'].lower() == 'true':\n                    this_vtype = 'REG_EXPAND_SZ'\n            if this_element_value is not None:\n                this_element_value = _encode_string(this_element_value)\n        elif etree.QName(element).localname == 'multiText':\n            this_vtype = 'REG_MULTI_SZ' if not check_deleted else 'REG_SZ'\n            if this_element_value is not None:\n                this_element_value = '{0}{1}{1}'.format(chr(0).join(this_element_value), chr(0))\n        elif etree.QName(element).localname == 'list':\n            standard_element_expected_string = False\n            del_keys = b''\n            element_valuenames = []\n            element_values = this_element_value\n            if this_element_value is not None:\n                element_valuenames = [str(z) for z in range(1, len(this_element_value) + 1)]\n            if 'additive' in element.attrib:\n                if element.attrib['additive'].lower() == 'false':\n                    del_keys = b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, '**delvals.'.encode('utf-16-le'), encoded_null, encoded_semicolon, chr(registry.vtype[this_vtype]).encode('utf-32-le'), encoded_semicolon, chr(len(f' {chr(0)}'.encode('utf-16-le'))).encode('utf-32-le'), encoded_semicolon, ' '.encode('utf-16-le'), encoded_null, ']'.encode('utf-16-le')])\n            if 'expandable' in element.attrib:\n                this_vtype = 'REG_EXPAND_SZ'\n            if element.attrib.get('explicitValue', 'false').lower() == 'true':\n                if this_element_value is not None:\n                    element_valuenames = [str(k) for k in this_element_value.keys()]\n                    element_values = [str(v) for v in this_element_value.values()]\n            elif 'valuePrefix' in element.attrib:\n                if element.attrib['valuePrefix'] != '':\n                    if this_element_value is not None:\n                        element_valuenames = ['{}{}'.format(element.attrib['valuePrefix'], k) for k in element_valuenames]\n            elif element_values is not None:\n                element_valuenames = [str(z) for z in element_values]\n            if not check_deleted:\n                if this_element_value is not None:\n                    log.trace('_processValueItem has an explicit element_value of %s', this_element_value)\n                    expected_string = del_keys\n                    log.trace('element_valuenames == %s and element_values == %s', element_valuenames, element_values)\n                    for (i, item) in enumerate(element_valuenames):\n                        expected_string = expected_string + b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, element_valuenames[i].encode('utf-16-le'), encoded_null, encoded_semicolon, chr(registry.vtype[this_vtype]).encode('utf-32-le'), encoded_semicolon, chr(len(f'{element_values[i]}{chr(0)}'.encode('utf-16-le'))).encode('utf-32-le'), encoded_semicolon, _encode_string(element_values[i]), ']'.encode('utf-16-le')])\n                else:\n                    expected_string = del_keys + b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon])\n            else:\n                expected_string = b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, '**delvals.'.encode('utf-16-le'), encoded_null, encoded_semicolon, chr(registry.vtype[this_vtype]).encode('utf-32-le'), encoded_semicolon, chr(len(f' {chr(0)}'.encode('utf-16-le'))).encode('utf-32-le'), encoded_semicolon, ' '.encode('utf-16-le'), encoded_null, ']'.encode('utf-16-le')])\n        elif etree.QName(element).localname == 'enum':\n            if this_element_value is not None:\n                pass\n        if standard_element_expected_string and (not check_deleted):\n            if this_element_value is not None:\n                if isinstance(this_element_value, str):\n                    log.debug('Converting %s to bytes', this_element_value)\n                    this_element_value = this_element_value.encode('utf-32-le')\n                expected_string = b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, reg_valuename, encoded_null, encoded_semicolon, chr(registry.vtype[this_vtype]).encode('utf-32-le'), encoded_semicolon, chr(len(this_element_value)).encode('utf-32-le'), encoded_semicolon, this_element_value, ']'.encode('utf-16-le')])\n            else:\n                expected_string = b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, reg_valuename, encoded_null, encoded_semicolon, chr(registry.vtype[this_vtype]).encode('utf-32-le'), encoded_semicolon])\n    if not expected_string:\n        if etree.QName(element).localname == 'delete' or check_deleted:\n            expected_string = b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, '**del.'.encode('utf-16-le'), reg_valuename, encoded_null, encoded_semicolon, chr(registry.vtype[this_vtype]).encode('utf-32-le'), encoded_semicolon, chr(len(f' {chr(0)}'.encode('utf-16-le'))).encode('utf-32-le'), encoded_semicolon, ' '.encode('utf-16-le'), encoded_null, ']'.encode('utf-16-le')])\n        else:\n            expected_string = b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, reg_valuename, encoded_null, encoded_semicolon, chr(registry.vtype[this_vtype]).encode('utf-32-le'), encoded_semicolon, chr(len(this_element_value)).encode('utf-32-le'), encoded_semicolon, this_element_value, ']'.encode('utf-16-le')])\n    return expected_string",
            "def _processValueItem(element, reg_key, reg_valuename, policy, parent_element, check_deleted=False, this_element_value=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    helper function to process a value type item and generate the expected\\n    string in the Registry.pol file\\n\\n    element - the element to process\\n    reg_key - the registry key associated with the element (some inherit from\\n              their parent policy)\\n    reg_valuename - the registry valueName associated with the element (some\\n                    inherit from their parent policy)\\n    policy - the parent policy element\\n    parent_element - the parent element (primarily passed in to differentiate\\n                     children of \"elements\" objects\\n    check_deleted - if the returned expected string should be for a deleted\\n                    value\\n    this_element_value - a specific value to place into the expected string\\n                         returned for \"elements\" children whose values are\\n                         specified by the user\\n    '\n    registry = Registry()\n    expected_string = None\n    this_vtype = 'REG_SZ'\n    encoded_semicolon = ';'.encode('utf-16-le')\n    encoded_null = chr(0).encode('utf-16-le')\n    if reg_key:\n        reg_key = reg_key.encode('utf-16-le')\n    if reg_valuename:\n        reg_valuename = reg_valuename.encode('utf-16-le')\n    if etree.QName(element).localname == 'decimal' and etree.QName(parent_element).localname != 'elements':\n        this_vtype = 'REG_DWORD'\n        if 'value' in element.attrib:\n            this_element_value = struct.pack(b'I', int(element.attrib['value']))\n        else:\n            log.error('The %s child %s element for the policy with attributes: %s does not have the required \"value\" attribute. The element attributes are: %s', etree.QName(parent_element).localname, etree.QName(element).localname, policy.attrib, element.attrib)\n            return None\n    elif etree.QName(element).localname == 'longDecimal' and etree.QName(parent_element).localname != 'elements':\n        this_vtype = 'REG_QWORD'\n        if 'value' in element.attrib:\n            this_element_value = struct.pack(b'Q', int(element.attrib['value']))\n        else:\n            log.error('The %s child %s element for the policy with attributes: %s does not have the required \"value\" attribute. The element attributes are: %s', etree.QName(parent_element).localname, etree.QName(element).localname, policy.attrib, element.attrib)\n            return None\n    elif etree.QName(element).localname == 'string':\n        this_vtype = 'REG_SZ'\n        this_element_value = _encode_string(element.text)\n    elif etree.QName(parent_element).localname == 'elements':\n        standard_element_expected_string = True\n        if etree.QName(element).localname == 'boolean':\n            if this_element_value is False:\n                check_deleted = True\n            if not check_deleted:\n                this_vtype = 'REG_DWORD'\n            this_element_value = struct.pack('I', 1)\n            standard_element_expected_string = False\n        elif etree.QName(element).localname == 'decimal':\n            this_vtype = 'REG_DWORD'\n            requested_val = this_element_value\n            if this_element_value is not None:\n                this_element_value = struct.pack(b'I', int(this_element_value))\n            if 'storeAsText' in element.attrib:\n                if element.attrib['storeAsText'].lower() == 'true':\n                    this_vtype = 'REG_SZ'\n                    if requested_val is not None:\n                        this_element_value = str(requested_val).encode('utf-16-le')\n            if check_deleted:\n                this_vtype = 'REG_SZ'\n        elif etree.QName(element).localname == 'longDecimal':\n            this_vtype = 'REG_QWORD'\n            requested_val = this_element_value\n            if this_element_value is not None:\n                this_element_value = struct.pack(b'Q', int(this_element_value))\n            if 'storeAsText' in element.attrib:\n                if element.attrib['storeAsText'].lower() == 'true':\n                    this_vtype = 'REG_SZ'\n                    if requested_val is not None:\n                        this_element_value = str(requested_val).encode('utf-16-le')\n        elif etree.QName(element).localname == 'text':\n            this_vtype = 'REG_SZ'\n            if 'expandable' in element.attrib:\n                if element.attrib['expandable'].lower() == 'true':\n                    this_vtype = 'REG_EXPAND_SZ'\n            if this_element_value is not None:\n                this_element_value = _encode_string(this_element_value)\n        elif etree.QName(element).localname == 'multiText':\n            this_vtype = 'REG_MULTI_SZ' if not check_deleted else 'REG_SZ'\n            if this_element_value is not None:\n                this_element_value = '{0}{1}{1}'.format(chr(0).join(this_element_value), chr(0))\n        elif etree.QName(element).localname == 'list':\n            standard_element_expected_string = False\n            del_keys = b''\n            element_valuenames = []\n            element_values = this_element_value\n            if this_element_value is not None:\n                element_valuenames = [str(z) for z in range(1, len(this_element_value) + 1)]\n            if 'additive' in element.attrib:\n                if element.attrib['additive'].lower() == 'false':\n                    del_keys = b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, '**delvals.'.encode('utf-16-le'), encoded_null, encoded_semicolon, chr(registry.vtype[this_vtype]).encode('utf-32-le'), encoded_semicolon, chr(len(f' {chr(0)}'.encode('utf-16-le'))).encode('utf-32-le'), encoded_semicolon, ' '.encode('utf-16-le'), encoded_null, ']'.encode('utf-16-le')])\n            if 'expandable' in element.attrib:\n                this_vtype = 'REG_EXPAND_SZ'\n            if element.attrib.get('explicitValue', 'false').lower() == 'true':\n                if this_element_value is not None:\n                    element_valuenames = [str(k) for k in this_element_value.keys()]\n                    element_values = [str(v) for v in this_element_value.values()]\n            elif 'valuePrefix' in element.attrib:\n                if element.attrib['valuePrefix'] != '':\n                    if this_element_value is not None:\n                        element_valuenames = ['{}{}'.format(element.attrib['valuePrefix'], k) for k in element_valuenames]\n            elif element_values is not None:\n                element_valuenames = [str(z) for z in element_values]\n            if not check_deleted:\n                if this_element_value is not None:\n                    log.trace('_processValueItem has an explicit element_value of %s', this_element_value)\n                    expected_string = del_keys\n                    log.trace('element_valuenames == %s and element_values == %s', element_valuenames, element_values)\n                    for (i, item) in enumerate(element_valuenames):\n                        expected_string = expected_string + b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, element_valuenames[i].encode('utf-16-le'), encoded_null, encoded_semicolon, chr(registry.vtype[this_vtype]).encode('utf-32-le'), encoded_semicolon, chr(len(f'{element_values[i]}{chr(0)}'.encode('utf-16-le'))).encode('utf-32-le'), encoded_semicolon, _encode_string(element_values[i]), ']'.encode('utf-16-le')])\n                else:\n                    expected_string = del_keys + b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon])\n            else:\n                expected_string = b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, '**delvals.'.encode('utf-16-le'), encoded_null, encoded_semicolon, chr(registry.vtype[this_vtype]).encode('utf-32-le'), encoded_semicolon, chr(len(f' {chr(0)}'.encode('utf-16-le'))).encode('utf-32-le'), encoded_semicolon, ' '.encode('utf-16-le'), encoded_null, ']'.encode('utf-16-le')])\n        elif etree.QName(element).localname == 'enum':\n            if this_element_value is not None:\n                pass\n        if standard_element_expected_string and (not check_deleted):\n            if this_element_value is not None:\n                if isinstance(this_element_value, str):\n                    log.debug('Converting %s to bytes', this_element_value)\n                    this_element_value = this_element_value.encode('utf-32-le')\n                expected_string = b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, reg_valuename, encoded_null, encoded_semicolon, chr(registry.vtype[this_vtype]).encode('utf-32-le'), encoded_semicolon, chr(len(this_element_value)).encode('utf-32-le'), encoded_semicolon, this_element_value, ']'.encode('utf-16-le')])\n            else:\n                expected_string = b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, reg_valuename, encoded_null, encoded_semicolon, chr(registry.vtype[this_vtype]).encode('utf-32-le'), encoded_semicolon])\n    if not expected_string:\n        if etree.QName(element).localname == 'delete' or check_deleted:\n            expected_string = b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, '**del.'.encode('utf-16-le'), reg_valuename, encoded_null, encoded_semicolon, chr(registry.vtype[this_vtype]).encode('utf-32-le'), encoded_semicolon, chr(len(f' {chr(0)}'.encode('utf-16-le'))).encode('utf-32-le'), encoded_semicolon, ' '.encode('utf-16-le'), encoded_null, ']'.encode('utf-16-le')])\n        else:\n            expected_string = b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, reg_valuename, encoded_null, encoded_semicolon, chr(registry.vtype[this_vtype]).encode('utf-32-le'), encoded_semicolon, chr(len(this_element_value)).encode('utf-32-le'), encoded_semicolon, this_element_value, ']'.encode('utf-16-le')])\n    return expected_string",
            "def _processValueItem(element, reg_key, reg_valuename, policy, parent_element, check_deleted=False, this_element_value=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    helper function to process a value type item and generate the expected\\n    string in the Registry.pol file\\n\\n    element - the element to process\\n    reg_key - the registry key associated with the element (some inherit from\\n              their parent policy)\\n    reg_valuename - the registry valueName associated with the element (some\\n                    inherit from their parent policy)\\n    policy - the parent policy element\\n    parent_element - the parent element (primarily passed in to differentiate\\n                     children of \"elements\" objects\\n    check_deleted - if the returned expected string should be for a deleted\\n                    value\\n    this_element_value - a specific value to place into the expected string\\n                         returned for \"elements\" children whose values are\\n                         specified by the user\\n    '\n    registry = Registry()\n    expected_string = None\n    this_vtype = 'REG_SZ'\n    encoded_semicolon = ';'.encode('utf-16-le')\n    encoded_null = chr(0).encode('utf-16-le')\n    if reg_key:\n        reg_key = reg_key.encode('utf-16-le')\n    if reg_valuename:\n        reg_valuename = reg_valuename.encode('utf-16-le')\n    if etree.QName(element).localname == 'decimal' and etree.QName(parent_element).localname != 'elements':\n        this_vtype = 'REG_DWORD'\n        if 'value' in element.attrib:\n            this_element_value = struct.pack(b'I', int(element.attrib['value']))\n        else:\n            log.error('The %s child %s element for the policy with attributes: %s does not have the required \"value\" attribute. The element attributes are: %s', etree.QName(parent_element).localname, etree.QName(element).localname, policy.attrib, element.attrib)\n            return None\n    elif etree.QName(element).localname == 'longDecimal' and etree.QName(parent_element).localname != 'elements':\n        this_vtype = 'REG_QWORD'\n        if 'value' in element.attrib:\n            this_element_value = struct.pack(b'Q', int(element.attrib['value']))\n        else:\n            log.error('The %s child %s element for the policy with attributes: %s does not have the required \"value\" attribute. The element attributes are: %s', etree.QName(parent_element).localname, etree.QName(element).localname, policy.attrib, element.attrib)\n            return None\n    elif etree.QName(element).localname == 'string':\n        this_vtype = 'REG_SZ'\n        this_element_value = _encode_string(element.text)\n    elif etree.QName(parent_element).localname == 'elements':\n        standard_element_expected_string = True\n        if etree.QName(element).localname == 'boolean':\n            if this_element_value is False:\n                check_deleted = True\n            if not check_deleted:\n                this_vtype = 'REG_DWORD'\n            this_element_value = struct.pack('I', 1)\n            standard_element_expected_string = False\n        elif etree.QName(element).localname == 'decimal':\n            this_vtype = 'REG_DWORD'\n            requested_val = this_element_value\n            if this_element_value is not None:\n                this_element_value = struct.pack(b'I', int(this_element_value))\n            if 'storeAsText' in element.attrib:\n                if element.attrib['storeAsText'].lower() == 'true':\n                    this_vtype = 'REG_SZ'\n                    if requested_val is not None:\n                        this_element_value = str(requested_val).encode('utf-16-le')\n            if check_deleted:\n                this_vtype = 'REG_SZ'\n        elif etree.QName(element).localname == 'longDecimal':\n            this_vtype = 'REG_QWORD'\n            requested_val = this_element_value\n            if this_element_value is not None:\n                this_element_value = struct.pack(b'Q', int(this_element_value))\n            if 'storeAsText' in element.attrib:\n                if element.attrib['storeAsText'].lower() == 'true':\n                    this_vtype = 'REG_SZ'\n                    if requested_val is not None:\n                        this_element_value = str(requested_val).encode('utf-16-le')\n        elif etree.QName(element).localname == 'text':\n            this_vtype = 'REG_SZ'\n            if 'expandable' in element.attrib:\n                if element.attrib['expandable'].lower() == 'true':\n                    this_vtype = 'REG_EXPAND_SZ'\n            if this_element_value is not None:\n                this_element_value = _encode_string(this_element_value)\n        elif etree.QName(element).localname == 'multiText':\n            this_vtype = 'REG_MULTI_SZ' if not check_deleted else 'REG_SZ'\n            if this_element_value is not None:\n                this_element_value = '{0}{1}{1}'.format(chr(0).join(this_element_value), chr(0))\n        elif etree.QName(element).localname == 'list':\n            standard_element_expected_string = False\n            del_keys = b''\n            element_valuenames = []\n            element_values = this_element_value\n            if this_element_value is not None:\n                element_valuenames = [str(z) for z in range(1, len(this_element_value) + 1)]\n            if 'additive' in element.attrib:\n                if element.attrib['additive'].lower() == 'false':\n                    del_keys = b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, '**delvals.'.encode('utf-16-le'), encoded_null, encoded_semicolon, chr(registry.vtype[this_vtype]).encode('utf-32-le'), encoded_semicolon, chr(len(f' {chr(0)}'.encode('utf-16-le'))).encode('utf-32-le'), encoded_semicolon, ' '.encode('utf-16-le'), encoded_null, ']'.encode('utf-16-le')])\n            if 'expandable' in element.attrib:\n                this_vtype = 'REG_EXPAND_SZ'\n            if element.attrib.get('explicitValue', 'false').lower() == 'true':\n                if this_element_value is not None:\n                    element_valuenames = [str(k) for k in this_element_value.keys()]\n                    element_values = [str(v) for v in this_element_value.values()]\n            elif 'valuePrefix' in element.attrib:\n                if element.attrib['valuePrefix'] != '':\n                    if this_element_value is not None:\n                        element_valuenames = ['{}{}'.format(element.attrib['valuePrefix'], k) for k in element_valuenames]\n            elif element_values is not None:\n                element_valuenames = [str(z) for z in element_values]\n            if not check_deleted:\n                if this_element_value is not None:\n                    log.trace('_processValueItem has an explicit element_value of %s', this_element_value)\n                    expected_string = del_keys\n                    log.trace('element_valuenames == %s and element_values == %s', element_valuenames, element_values)\n                    for (i, item) in enumerate(element_valuenames):\n                        expected_string = expected_string + b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, element_valuenames[i].encode('utf-16-le'), encoded_null, encoded_semicolon, chr(registry.vtype[this_vtype]).encode('utf-32-le'), encoded_semicolon, chr(len(f'{element_values[i]}{chr(0)}'.encode('utf-16-le'))).encode('utf-32-le'), encoded_semicolon, _encode_string(element_values[i]), ']'.encode('utf-16-le')])\n                else:\n                    expected_string = del_keys + b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon])\n            else:\n                expected_string = b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, '**delvals.'.encode('utf-16-le'), encoded_null, encoded_semicolon, chr(registry.vtype[this_vtype]).encode('utf-32-le'), encoded_semicolon, chr(len(f' {chr(0)}'.encode('utf-16-le'))).encode('utf-32-le'), encoded_semicolon, ' '.encode('utf-16-le'), encoded_null, ']'.encode('utf-16-le')])\n        elif etree.QName(element).localname == 'enum':\n            if this_element_value is not None:\n                pass\n        if standard_element_expected_string and (not check_deleted):\n            if this_element_value is not None:\n                if isinstance(this_element_value, str):\n                    log.debug('Converting %s to bytes', this_element_value)\n                    this_element_value = this_element_value.encode('utf-32-le')\n                expected_string = b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, reg_valuename, encoded_null, encoded_semicolon, chr(registry.vtype[this_vtype]).encode('utf-32-le'), encoded_semicolon, chr(len(this_element_value)).encode('utf-32-le'), encoded_semicolon, this_element_value, ']'.encode('utf-16-le')])\n            else:\n                expected_string = b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, reg_valuename, encoded_null, encoded_semicolon, chr(registry.vtype[this_vtype]).encode('utf-32-le'), encoded_semicolon])\n    if not expected_string:\n        if etree.QName(element).localname == 'delete' or check_deleted:\n            expected_string = b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, '**del.'.encode('utf-16-le'), reg_valuename, encoded_null, encoded_semicolon, chr(registry.vtype[this_vtype]).encode('utf-32-le'), encoded_semicolon, chr(len(f' {chr(0)}'.encode('utf-16-le'))).encode('utf-32-le'), encoded_semicolon, ' '.encode('utf-16-le'), encoded_null, ']'.encode('utf-16-le')])\n        else:\n            expected_string = b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, reg_valuename, encoded_null, encoded_semicolon, chr(registry.vtype[this_vtype]).encode('utf-32-le'), encoded_semicolon, chr(len(this_element_value)).encode('utf-32-le'), encoded_semicolon, this_element_value, ']'.encode('utf-16-le')])\n    return expected_string",
            "def _processValueItem(element, reg_key, reg_valuename, policy, parent_element, check_deleted=False, this_element_value=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    helper function to process a value type item and generate the expected\\n    string in the Registry.pol file\\n\\n    element - the element to process\\n    reg_key - the registry key associated with the element (some inherit from\\n              their parent policy)\\n    reg_valuename - the registry valueName associated with the element (some\\n                    inherit from their parent policy)\\n    policy - the parent policy element\\n    parent_element - the parent element (primarily passed in to differentiate\\n                     children of \"elements\" objects\\n    check_deleted - if the returned expected string should be for a deleted\\n                    value\\n    this_element_value - a specific value to place into the expected string\\n                         returned for \"elements\" children whose values are\\n                         specified by the user\\n    '\n    registry = Registry()\n    expected_string = None\n    this_vtype = 'REG_SZ'\n    encoded_semicolon = ';'.encode('utf-16-le')\n    encoded_null = chr(0).encode('utf-16-le')\n    if reg_key:\n        reg_key = reg_key.encode('utf-16-le')\n    if reg_valuename:\n        reg_valuename = reg_valuename.encode('utf-16-le')\n    if etree.QName(element).localname == 'decimal' and etree.QName(parent_element).localname != 'elements':\n        this_vtype = 'REG_DWORD'\n        if 'value' in element.attrib:\n            this_element_value = struct.pack(b'I', int(element.attrib['value']))\n        else:\n            log.error('The %s child %s element for the policy with attributes: %s does not have the required \"value\" attribute. The element attributes are: %s', etree.QName(parent_element).localname, etree.QName(element).localname, policy.attrib, element.attrib)\n            return None\n    elif etree.QName(element).localname == 'longDecimal' and etree.QName(parent_element).localname != 'elements':\n        this_vtype = 'REG_QWORD'\n        if 'value' in element.attrib:\n            this_element_value = struct.pack(b'Q', int(element.attrib['value']))\n        else:\n            log.error('The %s child %s element for the policy with attributes: %s does not have the required \"value\" attribute. The element attributes are: %s', etree.QName(parent_element).localname, etree.QName(element).localname, policy.attrib, element.attrib)\n            return None\n    elif etree.QName(element).localname == 'string':\n        this_vtype = 'REG_SZ'\n        this_element_value = _encode_string(element.text)\n    elif etree.QName(parent_element).localname == 'elements':\n        standard_element_expected_string = True\n        if etree.QName(element).localname == 'boolean':\n            if this_element_value is False:\n                check_deleted = True\n            if not check_deleted:\n                this_vtype = 'REG_DWORD'\n            this_element_value = struct.pack('I', 1)\n            standard_element_expected_string = False\n        elif etree.QName(element).localname == 'decimal':\n            this_vtype = 'REG_DWORD'\n            requested_val = this_element_value\n            if this_element_value is not None:\n                this_element_value = struct.pack(b'I', int(this_element_value))\n            if 'storeAsText' in element.attrib:\n                if element.attrib['storeAsText'].lower() == 'true':\n                    this_vtype = 'REG_SZ'\n                    if requested_val is not None:\n                        this_element_value = str(requested_val).encode('utf-16-le')\n            if check_deleted:\n                this_vtype = 'REG_SZ'\n        elif etree.QName(element).localname == 'longDecimal':\n            this_vtype = 'REG_QWORD'\n            requested_val = this_element_value\n            if this_element_value is not None:\n                this_element_value = struct.pack(b'Q', int(this_element_value))\n            if 'storeAsText' in element.attrib:\n                if element.attrib['storeAsText'].lower() == 'true':\n                    this_vtype = 'REG_SZ'\n                    if requested_val is not None:\n                        this_element_value = str(requested_val).encode('utf-16-le')\n        elif etree.QName(element).localname == 'text':\n            this_vtype = 'REG_SZ'\n            if 'expandable' in element.attrib:\n                if element.attrib['expandable'].lower() == 'true':\n                    this_vtype = 'REG_EXPAND_SZ'\n            if this_element_value is not None:\n                this_element_value = _encode_string(this_element_value)\n        elif etree.QName(element).localname == 'multiText':\n            this_vtype = 'REG_MULTI_SZ' if not check_deleted else 'REG_SZ'\n            if this_element_value is not None:\n                this_element_value = '{0}{1}{1}'.format(chr(0).join(this_element_value), chr(0))\n        elif etree.QName(element).localname == 'list':\n            standard_element_expected_string = False\n            del_keys = b''\n            element_valuenames = []\n            element_values = this_element_value\n            if this_element_value is not None:\n                element_valuenames = [str(z) for z in range(1, len(this_element_value) + 1)]\n            if 'additive' in element.attrib:\n                if element.attrib['additive'].lower() == 'false':\n                    del_keys = b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, '**delvals.'.encode('utf-16-le'), encoded_null, encoded_semicolon, chr(registry.vtype[this_vtype]).encode('utf-32-le'), encoded_semicolon, chr(len(f' {chr(0)}'.encode('utf-16-le'))).encode('utf-32-le'), encoded_semicolon, ' '.encode('utf-16-le'), encoded_null, ']'.encode('utf-16-le')])\n            if 'expandable' in element.attrib:\n                this_vtype = 'REG_EXPAND_SZ'\n            if element.attrib.get('explicitValue', 'false').lower() == 'true':\n                if this_element_value is not None:\n                    element_valuenames = [str(k) for k in this_element_value.keys()]\n                    element_values = [str(v) for v in this_element_value.values()]\n            elif 'valuePrefix' in element.attrib:\n                if element.attrib['valuePrefix'] != '':\n                    if this_element_value is not None:\n                        element_valuenames = ['{}{}'.format(element.attrib['valuePrefix'], k) for k in element_valuenames]\n            elif element_values is not None:\n                element_valuenames = [str(z) for z in element_values]\n            if not check_deleted:\n                if this_element_value is not None:\n                    log.trace('_processValueItem has an explicit element_value of %s', this_element_value)\n                    expected_string = del_keys\n                    log.trace('element_valuenames == %s and element_values == %s', element_valuenames, element_values)\n                    for (i, item) in enumerate(element_valuenames):\n                        expected_string = expected_string + b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, element_valuenames[i].encode('utf-16-le'), encoded_null, encoded_semicolon, chr(registry.vtype[this_vtype]).encode('utf-32-le'), encoded_semicolon, chr(len(f'{element_values[i]}{chr(0)}'.encode('utf-16-le'))).encode('utf-32-le'), encoded_semicolon, _encode_string(element_values[i]), ']'.encode('utf-16-le')])\n                else:\n                    expected_string = del_keys + b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon])\n            else:\n                expected_string = b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, '**delvals.'.encode('utf-16-le'), encoded_null, encoded_semicolon, chr(registry.vtype[this_vtype]).encode('utf-32-le'), encoded_semicolon, chr(len(f' {chr(0)}'.encode('utf-16-le'))).encode('utf-32-le'), encoded_semicolon, ' '.encode('utf-16-le'), encoded_null, ']'.encode('utf-16-le')])\n        elif etree.QName(element).localname == 'enum':\n            if this_element_value is not None:\n                pass\n        if standard_element_expected_string and (not check_deleted):\n            if this_element_value is not None:\n                if isinstance(this_element_value, str):\n                    log.debug('Converting %s to bytes', this_element_value)\n                    this_element_value = this_element_value.encode('utf-32-le')\n                expected_string = b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, reg_valuename, encoded_null, encoded_semicolon, chr(registry.vtype[this_vtype]).encode('utf-32-le'), encoded_semicolon, chr(len(this_element_value)).encode('utf-32-le'), encoded_semicolon, this_element_value, ']'.encode('utf-16-le')])\n            else:\n                expected_string = b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, reg_valuename, encoded_null, encoded_semicolon, chr(registry.vtype[this_vtype]).encode('utf-32-le'), encoded_semicolon])\n    if not expected_string:\n        if etree.QName(element).localname == 'delete' or check_deleted:\n            expected_string = b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, '**del.'.encode('utf-16-le'), reg_valuename, encoded_null, encoded_semicolon, chr(registry.vtype[this_vtype]).encode('utf-32-le'), encoded_semicolon, chr(len(f' {chr(0)}'.encode('utf-16-le'))).encode('utf-32-le'), encoded_semicolon, ' '.encode('utf-16-le'), encoded_null, ']'.encode('utf-16-le')])\n        else:\n            expected_string = b''.join(['['.encode('utf-16-le'), reg_key, encoded_null, encoded_semicolon, reg_valuename, encoded_null, encoded_semicolon, chr(registry.vtype[this_vtype]).encode('utf-32-le'), encoded_semicolon, chr(len(this_element_value)).encode('utf-32-le'), encoded_semicolon, this_element_value, ']'.encode('utf-16-le')])\n    return expected_string"
        ]
    },
    {
        "func_name": "_checkAllAdmxPolicies",
        "original": "def _checkAllAdmxPolicies(policy_class, adml_language='en-US', return_full_policy_names=False, hierarchical_return=False, return_not_configured=False):\n    \"\"\"\n    rewrite of _getAllAdminTemplateSettingsFromRegPolFile where instead of\n    looking only at the contents of the file, we're going to loop through every\n    policy and look in the registry.pol file to determine if it is\n    enabled/disabled/not configured\n    \"\"\"\n    log.trace('POLICY CLASS == %s', policy_class)\n    policy_file_data = read_reg_pol_file(CLASS_INFO[policy_class]['policy_path'])\n    admx_policies = []\n    policy_vals = {}\n    hierarchy = {}\n    full_names = {}\n    admx_policy_definitions = _get_policy_definitions(language=adml_language)\n    adml_policy_resources = _get_policy_resources(language=adml_language)\n    if policy_file_data:\n        log.trace('POLICY CLASS %s has file data', policy_class)\n        policy_filedata_split = re.sub(salt.utils.stringutils.to_bytes(f'\\\\]{chr(0)}$'), b'', re.sub(salt.utils.stringutils.to_bytes(f'^\\\\[{chr(0)}'), b'', re.sub(re.escape(REG_POL_HEADER.encode('utf-16-le')), b'', policy_file_data))).split(']['.encode('utf-16-le'))\n        log.trace('Searching %s policies...', len(policy_filedata_split))\n        start_time = time.time()\n        for policy_item in policy_filedata_split:\n            policy_item_key = policy_item.split(f'{chr(0)};'.encode('utf-16-le'))[0].decode('utf-16-le').lower()\n            if policy_item_key:\n                admx_items = REGKEY_XPATH(admx_policy_definitions, keyvalue=policy_item_key)\n                log.trace('Found %s policies for %s', len(admx_items), policy_item_key)\n                for admx_item in admx_items:\n                    if etree.QName(admx_item).localname == 'policy':\n                        if admx_item not in admx_policies:\n                            admx_policies.append(admx_item)\n                    else:\n                        for policy_item in POLICY_ANCESTOR_XPATH(admx_item):\n                            if policy_item not in admx_policies:\n                                admx_policies.append(policy_item)\n        log.trace('Search complete: %s seconds', time.time() - start_time)\n        if return_not_configured:\n            log.trace('Gathering non configured policies')\n            start_time = time.time()\n            not_configured_policies = ALL_CLASS_POLICY_XPATH(admx_policy_definitions, registry_class=policy_class)\n            for policy_item in admx_policies:\n                if policy_item in not_configured_policies:\n                    not_configured_policies.remove(policy_item)\n            for not_configured_policy in not_configured_policies:\n                not_configured_policy_namespace = not_configured_policy.nsmap[not_configured_policy.prefix]\n                if not_configured_policy_namespace not in policy_vals:\n                    policy_vals[not_configured_policy_namespace] = {}\n                policy_vals[not_configured_policy_namespace][not_configured_policy.attrib['name']] = 'Not Configured'\n                if return_full_policy_names:\n                    if not_configured_policy_namespace not in full_names:\n                        full_names[not_configured_policy_namespace] = {}\n                    full_names[not_configured_policy_namespace][not_configured_policy.attrib['name']] = _getFullPolicyName(policy_item=not_configured_policy, policy_name=not_configured_policy.attrib['name'], return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n                log.trace('building hierarchy for non-configured item %s', not_configured_policy.attrib['name'])\n                if not_configured_policy_namespace not in hierarchy:\n                    hierarchy[not_configured_policy_namespace] = {}\n                hierarchy[not_configured_policy_namespace][not_configured_policy.attrib['name']] = _build_parent_list(policy_definition=not_configured_policy, return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n            log.trace('Gathering complete: %s seconds', time.time() - start_time)\n        log.trace('Examining %s policies...', len(admx_policies))\n        start_time = time.time()\n        for admx_policy in admx_policies:\n            this_valuename = None\n            this_policy_setting = 'Not Configured'\n            element_only_enabled_disabled = True\n            explicit_enable_disable_value_setting = False\n            if 'key' in admx_policy.attrib:\n                this_key = admx_policy.attrib['key']\n            else:\n                log.error('policy item %s does not have the required \"key\" attribute', admx_policy.attrib)\n                break\n            if 'valueName' in admx_policy.attrib:\n                this_valuename = admx_policy.attrib['valueName']\n            if 'name' in admx_policy.attrib:\n                this_policyname = admx_policy.attrib['name']\n            else:\n                log.error('policy item %s does not have the required \"name\" attribute', admx_policy.attrib)\n                break\n            this_policynamespace = admx_policy.nsmap[admx_policy.prefix]\n            if ENABLED_VALUE_XPATH(admx_policy) and this_policy_setting == 'Not Configured':\n                if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(admx_policy):\n                    element_only_enabled_disabled = False\n                    explicit_enable_disable_value_setting = True\n                if _checkValueItemParent(admx_policy, this_policyname, this_key, this_valuename, ENABLED_VALUE_XPATH, policy_file_data):\n                    this_policy_setting = 'Enabled'\n                    log.trace('%s is enabled by detected ENABLED_VALUE_XPATH', this_policyname)\n                    if this_policynamespace not in policy_vals:\n                        policy_vals[this_policynamespace] = {}\n                    policy_vals[this_policynamespace][this_policyname] = this_policy_setting\n            if DISABLED_VALUE_XPATH(admx_policy) and this_policy_setting == 'Not Configured':\n                if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):\n                    element_only_enabled_disabled = False\n                    explicit_enable_disable_value_setting = True\n                if _checkValueItemParent(admx_policy, this_policyname, this_key, this_valuename, DISABLED_VALUE_XPATH, policy_file_data):\n                    this_policy_setting = 'Disabled'\n                    log.trace('%s is disabled by detected DISABLED_VALUE_XPATH', this_policyname)\n                    if this_policynamespace not in policy_vals:\n                        policy_vals[this_policynamespace] = {}\n                    policy_vals[this_policynamespace][this_policyname] = this_policy_setting\n            if ENABLED_LIST_XPATH(admx_policy) and this_policy_setting == 'Not Configured':\n                if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(admx_policy):\n                    element_only_enabled_disabled = False\n                    explicit_enable_disable_value_setting = True\n                if _checkListItem(admx_policy, this_policyname, this_key, ENABLED_LIST_XPATH, policy_file_data):\n                    this_policy_setting = 'Enabled'\n                    log.trace('%s is enabled by detected ENABLED_LIST_XPATH', this_policyname)\n                    if this_policynamespace not in policy_vals:\n                        policy_vals[this_policynamespace] = {}\n                    policy_vals[this_policynamespace][this_policyname] = this_policy_setting\n            if DISABLED_LIST_XPATH(admx_policy) and this_policy_setting == 'Not Configured':\n                if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):\n                    element_only_enabled_disabled = False\n                    explicit_enable_disable_value_setting = True\n                if _checkListItem(admx_policy, this_policyname, this_key, DISABLED_LIST_XPATH, policy_file_data):\n                    this_policy_setting = 'Disabled'\n                    log.trace('%s is disabled by detected DISABLED_LIST_XPATH', this_policyname)\n                    if this_policynamespace not in policy_vals:\n                        policy_vals[this_policynamespace] = {}\n                    policy_vals[this_policynamespace][this_policyname] = this_policy_setting\n            if not explicit_enable_disable_value_setting and this_valuename:\n                if search_reg_pol(re.escape(_buildKnownDataSearchString(this_key, this_valuename, 'REG_DWORD', '1')), policy_file_data):\n                    this_policy_setting = 'Enabled'\n                    log.trace('%s is enabled by no explicit enable/disable list or value', this_policyname)\n                    if this_policynamespace not in policy_vals:\n                        policy_vals[this_policynamespace] = {}\n                    policy_vals[this_policynamespace][this_policyname] = this_policy_setting\n                elif search_reg_pol(re.escape(_buildKnownDataSearchString(this_key, this_valuename, 'REG_DWORD', None, check_deleted=True)), policy_file_data):\n                    this_policy_setting = 'Disabled'\n                    log.trace('%s is disabled by no explicit enable/disable list or value', this_policyname)\n                    if this_policynamespace not in policy_vals:\n                        policy_vals[this_policynamespace] = {}\n                    policy_vals[this_policynamespace][this_policyname] = this_policy_setting\n            if ELEMENTS_XPATH(admx_policy):\n                if element_only_enabled_disabled or this_policy_setting == 'Enabled':\n                    required_elements = {}\n                    configured_elements = {}\n                    policy_disabled_elements = 0\n                    for elements_item in ELEMENTS_XPATH(admx_policy):\n                        for child_item in elements_item:\n                            this_element_name = _getFullPolicyName(policy_item=child_item, policy_name=child_item.attrib['id'], return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n                            required_elements[this_element_name] = None\n                            child_key = child_item.attrib.get('key', this_key)\n                            child_valuename = child_item.attrib.get('valueName', this_valuename)\n                            if etree.QName(child_item).localname == 'boolean':\n                                if len(child_item) > 0:\n                                    if TRUE_VALUE_XPATH(child_item) and this_element_name not in configured_elements:\n                                        if _checkValueItemParent(child_item, this_policyname, child_key, child_valuename, TRUE_VALUE_XPATH, policy_file_data):\n                                            configured_elements[this_element_name] = True\n                                            log.trace('element %s is configured true', child_item.attrib['id'])\n                                    if FALSE_VALUE_XPATH(child_item) and this_element_name not in configured_elements:\n                                        if _checkValueItemParent(child_item, this_policyname, child_key, child_valuename, FALSE_VALUE_XPATH, policy_file_data):\n                                            configured_elements[this_element_name] = False\n                                            policy_disabled_elements = policy_disabled_elements + 1\n                                            log.trace('element %s is configured false', child_item.attrib['id'])\n                                    if TRUE_LIST_XPATH(child_item) and this_element_name not in configured_elements:\n                                        log.trace('checking trueList')\n                                        if _checkListItem(child_item, this_policyname, this_key, TRUE_LIST_XPATH, policy_file_data):\n                                            configured_elements[this_element_name] = True\n                                            log.trace('element %s is configured true', child_item.attrib['id'])\n                                    if FALSE_LIST_XPATH(child_item) and this_element_name not in configured_elements:\n                                        log.trace('checking falseList')\n                                        if _checkListItem(child_item, this_policyname, this_key, FALSE_LIST_XPATH, policy_file_data):\n                                            configured_elements[this_element_name] = False\n                                            policy_disabled_elements = policy_disabled_elements + 1\n                                            log.trace('element %s is configured false', child_item.attrib['id'])\n                                elif search_reg_pol(re.escape(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=True)), policy_file_data):\n                                    configured_elements[this_element_name] = False\n                                    policy_disabled_elements = policy_disabled_elements + 1\n                                    log.trace('element %s is configured false', child_item.attrib['id'])\n                                elif search_reg_pol(re.escape(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=False)), policy_file_data):\n                                    configured_elements[this_element_name] = True\n                                    log.trace('element %s is configured true', child_item.attrib['id'])\n                            elif etree.QName(child_item).localname == 'decimal' or etree.QName(child_item).localname == 'text' or etree.QName(child_item).localname == 'longDecimal' or (etree.QName(child_item).localname == 'multiText'):\n                                if search_reg_pol(re.escape(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=True)), policy_file_data):\n                                    configured_elements[this_element_name] = 'Disabled'\n                                    policy_disabled_elements = policy_disabled_elements + 1\n                                    log.trace('element %s is disabled', child_item.attrib['id'])\n                                elif search_reg_pol(re.escape(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=False)), policy_file_data):\n                                    configured_value = _getDataFromRegPolData(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=False), policy_file_data)\n                                    configured_elements[this_element_name] = configured_value\n                                    log.trace('element %s is enabled, value == %s', child_item.attrib['id'], configured_value)\n                            elif etree.QName(child_item).localname == 'enum':\n                                if search_reg_pol(re.escape(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=True)), policy_file_data):\n                                    log.trace('enum element %s is disabled', child_item.attrib['id'])\n                                    configured_elements[this_element_name] = 'Disabled'\n                                    policy_disabled_elements = policy_disabled_elements + 1\n                                else:\n                                    for enum_item in child_item:\n                                        if _checkValueItemParent(enum_item, child_item.attrib['id'], child_key, child_valuename, VALUE_XPATH, policy_file_data):\n                                            if VALUE_LIST_XPATH(enum_item):\n                                                log.trace('enum item has a valueList')\n                                                if _checkListItem(enum_item, this_policyname, child_key, VALUE_LIST_XPATH, policy_file_data):\n                                                    log.trace('all valueList items exist in file')\n                                                    configured_elements[this_element_name] = _getAdmlDisplayName(adml_policy_resources, enum_item.attrib['displayName'])\n                                                    break\n                                            else:\n                                                configured_elements[this_element_name] = _getAdmlDisplayName(adml_policy_resources, enum_item.attrib['displayName'])\n                                                break\n                            elif etree.QName(child_item).localname == 'list':\n                                return_value_name = False\n                                if 'explicitValue' in child_item.attrib and child_item.attrib['explicitValue'].lower() == 'true':\n                                    log.trace('explicitValue list, we will return value names')\n                                    return_value_name = True\n                                regex_str = ['(?!\\\\*', '\\\\*', 'D', 'e', 'l', 'V', 'a', 'l', 's', '\\\\.', ')']\n                                delvals_regex = '\\x00'.join(regex_str)\n                                delvals_regex = salt.utils.stringutils.to_bytes(delvals_regex)\n                                if search_reg_pol(re.escape(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=False)) + delvals_regex, policy_file_data):\n                                    configured_value = _getDataFromRegPolData(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=False), policy_file_data, return_value_name=return_value_name)\n                                    configured_elements[this_element_name] = configured_value\n                                    log.trace('element %s is enabled values: %s', child_item.attrib['id'], configured_value)\n                                elif search_reg_pol(re.escape(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=True)), policy_file_data):\n                                    configured_elements[this_element_name] = 'Disabled'\n                                    policy_disabled_elements = policy_disabled_elements + 1\n                                    log.trace('element %s is disabled', child_item.attrib['id'])\n                    if element_only_enabled_disabled:\n                        if len(required_elements.keys()) > 0 and len(configured_elements.keys()) == len(required_elements.keys()):\n                            if policy_disabled_elements == len(required_elements.keys()):\n                                log.trace('%s is disabled by all enum elements', this_policyname)\n                                if this_policynamespace not in policy_vals:\n                                    policy_vals[this_policynamespace] = {}\n                                policy_vals[this_policynamespace][this_policyname] = 'Disabled'\n                            else:\n                                if this_policynamespace not in policy_vals:\n                                    policy_vals[this_policynamespace] = {}\n                                policy_vals[this_policynamespace][this_policyname] = configured_elements\n                                log.trace('%s is enabled by enum elements', this_policyname)\n                    elif this_policy_setting == 'Enabled':\n                        if this_policynamespace not in policy_vals:\n                            policy_vals[this_policynamespace] = {}\n                        policy_vals[this_policynamespace][this_policyname] = configured_elements\n            if return_full_policy_names and this_policynamespace in policy_vals and (this_policyname in policy_vals[this_policynamespace]):\n                if this_policynamespace not in full_names:\n                    full_names[this_policynamespace] = {}\n                full_names[this_policynamespace][this_policyname] = _getFullPolicyName(policy_item=admx_policy, policy_name=admx_policy.attrib['name'], return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n                if this_policyname in policy_vals[this_policynamespace][this_policyname]:\n                    full_name = full_names[this_policynamespace][this_policyname]\n                    setting = policy_vals[this_policynamespace][this_policyname].pop(this_policyname)\n                    policy_vals[this_policynamespace][this_policyname][full_name] = setting\n            if this_policynamespace in policy_vals and this_policyname in policy_vals[this_policynamespace]:\n                if this_policynamespace not in hierarchy:\n                    hierarchy[this_policynamespace] = {}\n                hierarchy[this_policynamespace][this_policyname] = _build_parent_list(policy_definition=admx_policy, return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n        log.trace('Examination complete: %s seconds', time.time() - start_time)\n    if policy_vals and return_full_policy_names and (not hierarchical_return):\n        log.debug('Compiling non hierarchical return...')\n        start_time = time.time()\n        unpathed_dict = {}\n        pathed_dict = {}\n        for policy_namespace in list(policy_vals):\n            for policy_item in list(policy_vals[policy_namespace]):\n                if full_names[policy_namespace][policy_item] in policy_vals[policy_namespace]:\n                    full_path_list = hierarchy[policy_namespace][policy_item]\n                    full_path_list.reverse()\n                    full_path_list.append(full_names[policy_namespace][policy_item])\n                    policy_vals['\\\\'.join(full_path_list)] = policy_vals[policy_namespace].pop(policy_item)\n                    pathed_dict[full_names[policy_namespace][policy_item]] = True\n                else:\n                    policy_vals[policy_namespace][full_names[policy_namespace][policy_item]] = policy_vals[policy_namespace].pop(policy_item)\n                    if policy_namespace not in unpathed_dict:\n                        unpathed_dict[policy_namespace] = {}\n                    unpathed_dict[policy_namespace][full_names[policy_namespace][policy_item]] = policy_item\n            if policy_namespace in unpathed_dict:\n                for path_needed in unpathed_dict[policy_namespace]:\n                    full_path_list = hierarchy[policy_namespace][unpathed_dict[policy_namespace][path_needed]]\n                    full_path_list.reverse()\n                    full_path_list.append(path_needed)\n                    log.trace('full_path_list == %s', full_path_list)\n                    policy_vals['\\\\'.join(full_path_list)] = policy_vals[policy_namespace].pop(path_needed)\n        log.trace('Compilation complete: %s seconds', time.time() - start_time)\n    for policy_namespace in list(policy_vals):\n        if policy_vals[policy_namespace] == {}:\n            policy_vals.pop(policy_namespace)\n    if policy_vals and hierarchical_return:\n        if hierarchy:\n            log.debug('Compiling hierarchical return...')\n            start_time = time.time()\n            for policy_namespace in hierarchy:\n                for hierarchy_item in hierarchy[policy_namespace]:\n                    if hierarchy_item in policy_vals[policy_namespace]:\n                        tdict = {}\n                        first_item = True\n                        for item in hierarchy[policy_namespace][hierarchy_item]:\n                            newdict = {}\n                            if first_item:\n                                h_policy_name = hierarchy_item\n                                if return_full_policy_names:\n                                    h_policy_name = full_names[policy_namespace][hierarchy_item]\n                                newdict[item] = {h_policy_name: policy_vals[policy_namespace].pop(hierarchy_item)}\n                                first_item = False\n                            else:\n                                newdict[item] = tdict\n                            tdict = newdict\n                        if tdict:\n                            policy_vals = dictupdate.update(policy_vals, tdict)\n                if policy_namespace in policy_vals and policy_vals[policy_namespace] == {}:\n                    policy_vals.pop(policy_namespace)\n            log.trace('Compilation complete: %s seconds', time.time() - start_time)\n        policy_vals = {CLASS_INFO[policy_class]['lgpo_section']: {'Administrative Templates': policy_vals}}\n    return policy_vals",
        "mutated": [
            "def _checkAllAdmxPolicies(policy_class, adml_language='en-US', return_full_policy_names=False, hierarchical_return=False, return_not_configured=False):\n    if False:\n        i = 10\n    \"\\n    rewrite of _getAllAdminTemplateSettingsFromRegPolFile where instead of\\n    looking only at the contents of the file, we're going to loop through every\\n    policy and look in the registry.pol file to determine if it is\\n    enabled/disabled/not configured\\n    \"\n    log.trace('POLICY CLASS == %s', policy_class)\n    policy_file_data = read_reg_pol_file(CLASS_INFO[policy_class]['policy_path'])\n    admx_policies = []\n    policy_vals = {}\n    hierarchy = {}\n    full_names = {}\n    admx_policy_definitions = _get_policy_definitions(language=adml_language)\n    adml_policy_resources = _get_policy_resources(language=adml_language)\n    if policy_file_data:\n        log.trace('POLICY CLASS %s has file data', policy_class)\n        policy_filedata_split = re.sub(salt.utils.stringutils.to_bytes(f'\\\\]{chr(0)}$'), b'', re.sub(salt.utils.stringutils.to_bytes(f'^\\\\[{chr(0)}'), b'', re.sub(re.escape(REG_POL_HEADER.encode('utf-16-le')), b'', policy_file_data))).split(']['.encode('utf-16-le'))\n        log.trace('Searching %s policies...', len(policy_filedata_split))\n        start_time = time.time()\n        for policy_item in policy_filedata_split:\n            policy_item_key = policy_item.split(f'{chr(0)};'.encode('utf-16-le'))[0].decode('utf-16-le').lower()\n            if policy_item_key:\n                admx_items = REGKEY_XPATH(admx_policy_definitions, keyvalue=policy_item_key)\n                log.trace('Found %s policies for %s', len(admx_items), policy_item_key)\n                for admx_item in admx_items:\n                    if etree.QName(admx_item).localname == 'policy':\n                        if admx_item not in admx_policies:\n                            admx_policies.append(admx_item)\n                    else:\n                        for policy_item in POLICY_ANCESTOR_XPATH(admx_item):\n                            if policy_item not in admx_policies:\n                                admx_policies.append(policy_item)\n        log.trace('Search complete: %s seconds', time.time() - start_time)\n        if return_not_configured:\n            log.trace('Gathering non configured policies')\n            start_time = time.time()\n            not_configured_policies = ALL_CLASS_POLICY_XPATH(admx_policy_definitions, registry_class=policy_class)\n            for policy_item in admx_policies:\n                if policy_item in not_configured_policies:\n                    not_configured_policies.remove(policy_item)\n            for not_configured_policy in not_configured_policies:\n                not_configured_policy_namespace = not_configured_policy.nsmap[not_configured_policy.prefix]\n                if not_configured_policy_namespace not in policy_vals:\n                    policy_vals[not_configured_policy_namespace] = {}\n                policy_vals[not_configured_policy_namespace][not_configured_policy.attrib['name']] = 'Not Configured'\n                if return_full_policy_names:\n                    if not_configured_policy_namespace not in full_names:\n                        full_names[not_configured_policy_namespace] = {}\n                    full_names[not_configured_policy_namespace][not_configured_policy.attrib['name']] = _getFullPolicyName(policy_item=not_configured_policy, policy_name=not_configured_policy.attrib['name'], return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n                log.trace('building hierarchy for non-configured item %s', not_configured_policy.attrib['name'])\n                if not_configured_policy_namespace not in hierarchy:\n                    hierarchy[not_configured_policy_namespace] = {}\n                hierarchy[not_configured_policy_namespace][not_configured_policy.attrib['name']] = _build_parent_list(policy_definition=not_configured_policy, return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n            log.trace('Gathering complete: %s seconds', time.time() - start_time)\n        log.trace('Examining %s policies...', len(admx_policies))\n        start_time = time.time()\n        for admx_policy in admx_policies:\n            this_valuename = None\n            this_policy_setting = 'Not Configured'\n            element_only_enabled_disabled = True\n            explicit_enable_disable_value_setting = False\n            if 'key' in admx_policy.attrib:\n                this_key = admx_policy.attrib['key']\n            else:\n                log.error('policy item %s does not have the required \"key\" attribute', admx_policy.attrib)\n                break\n            if 'valueName' in admx_policy.attrib:\n                this_valuename = admx_policy.attrib['valueName']\n            if 'name' in admx_policy.attrib:\n                this_policyname = admx_policy.attrib['name']\n            else:\n                log.error('policy item %s does not have the required \"name\" attribute', admx_policy.attrib)\n                break\n            this_policynamespace = admx_policy.nsmap[admx_policy.prefix]\n            if ENABLED_VALUE_XPATH(admx_policy) and this_policy_setting == 'Not Configured':\n                if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(admx_policy):\n                    element_only_enabled_disabled = False\n                    explicit_enable_disable_value_setting = True\n                if _checkValueItemParent(admx_policy, this_policyname, this_key, this_valuename, ENABLED_VALUE_XPATH, policy_file_data):\n                    this_policy_setting = 'Enabled'\n                    log.trace('%s is enabled by detected ENABLED_VALUE_XPATH', this_policyname)\n                    if this_policynamespace not in policy_vals:\n                        policy_vals[this_policynamespace] = {}\n                    policy_vals[this_policynamespace][this_policyname] = this_policy_setting\n            if DISABLED_VALUE_XPATH(admx_policy) and this_policy_setting == 'Not Configured':\n                if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):\n                    element_only_enabled_disabled = False\n                    explicit_enable_disable_value_setting = True\n                if _checkValueItemParent(admx_policy, this_policyname, this_key, this_valuename, DISABLED_VALUE_XPATH, policy_file_data):\n                    this_policy_setting = 'Disabled'\n                    log.trace('%s is disabled by detected DISABLED_VALUE_XPATH', this_policyname)\n                    if this_policynamespace not in policy_vals:\n                        policy_vals[this_policynamespace] = {}\n                    policy_vals[this_policynamespace][this_policyname] = this_policy_setting\n            if ENABLED_LIST_XPATH(admx_policy) and this_policy_setting == 'Not Configured':\n                if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(admx_policy):\n                    element_only_enabled_disabled = False\n                    explicit_enable_disable_value_setting = True\n                if _checkListItem(admx_policy, this_policyname, this_key, ENABLED_LIST_XPATH, policy_file_data):\n                    this_policy_setting = 'Enabled'\n                    log.trace('%s is enabled by detected ENABLED_LIST_XPATH', this_policyname)\n                    if this_policynamespace not in policy_vals:\n                        policy_vals[this_policynamespace] = {}\n                    policy_vals[this_policynamespace][this_policyname] = this_policy_setting\n            if DISABLED_LIST_XPATH(admx_policy) and this_policy_setting == 'Not Configured':\n                if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):\n                    element_only_enabled_disabled = False\n                    explicit_enable_disable_value_setting = True\n                if _checkListItem(admx_policy, this_policyname, this_key, DISABLED_LIST_XPATH, policy_file_data):\n                    this_policy_setting = 'Disabled'\n                    log.trace('%s is disabled by detected DISABLED_LIST_XPATH', this_policyname)\n                    if this_policynamespace not in policy_vals:\n                        policy_vals[this_policynamespace] = {}\n                    policy_vals[this_policynamespace][this_policyname] = this_policy_setting\n            if not explicit_enable_disable_value_setting and this_valuename:\n                if search_reg_pol(re.escape(_buildKnownDataSearchString(this_key, this_valuename, 'REG_DWORD', '1')), policy_file_data):\n                    this_policy_setting = 'Enabled'\n                    log.trace('%s is enabled by no explicit enable/disable list or value', this_policyname)\n                    if this_policynamespace not in policy_vals:\n                        policy_vals[this_policynamespace] = {}\n                    policy_vals[this_policynamespace][this_policyname] = this_policy_setting\n                elif search_reg_pol(re.escape(_buildKnownDataSearchString(this_key, this_valuename, 'REG_DWORD', None, check_deleted=True)), policy_file_data):\n                    this_policy_setting = 'Disabled'\n                    log.trace('%s is disabled by no explicit enable/disable list or value', this_policyname)\n                    if this_policynamespace not in policy_vals:\n                        policy_vals[this_policynamespace] = {}\n                    policy_vals[this_policynamespace][this_policyname] = this_policy_setting\n            if ELEMENTS_XPATH(admx_policy):\n                if element_only_enabled_disabled or this_policy_setting == 'Enabled':\n                    required_elements = {}\n                    configured_elements = {}\n                    policy_disabled_elements = 0\n                    for elements_item in ELEMENTS_XPATH(admx_policy):\n                        for child_item in elements_item:\n                            this_element_name = _getFullPolicyName(policy_item=child_item, policy_name=child_item.attrib['id'], return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n                            required_elements[this_element_name] = None\n                            child_key = child_item.attrib.get('key', this_key)\n                            child_valuename = child_item.attrib.get('valueName', this_valuename)\n                            if etree.QName(child_item).localname == 'boolean':\n                                if len(child_item) > 0:\n                                    if TRUE_VALUE_XPATH(child_item) and this_element_name not in configured_elements:\n                                        if _checkValueItemParent(child_item, this_policyname, child_key, child_valuename, TRUE_VALUE_XPATH, policy_file_data):\n                                            configured_elements[this_element_name] = True\n                                            log.trace('element %s is configured true', child_item.attrib['id'])\n                                    if FALSE_VALUE_XPATH(child_item) and this_element_name not in configured_elements:\n                                        if _checkValueItemParent(child_item, this_policyname, child_key, child_valuename, FALSE_VALUE_XPATH, policy_file_data):\n                                            configured_elements[this_element_name] = False\n                                            policy_disabled_elements = policy_disabled_elements + 1\n                                            log.trace('element %s is configured false', child_item.attrib['id'])\n                                    if TRUE_LIST_XPATH(child_item) and this_element_name not in configured_elements:\n                                        log.trace('checking trueList')\n                                        if _checkListItem(child_item, this_policyname, this_key, TRUE_LIST_XPATH, policy_file_data):\n                                            configured_elements[this_element_name] = True\n                                            log.trace('element %s is configured true', child_item.attrib['id'])\n                                    if FALSE_LIST_XPATH(child_item) and this_element_name not in configured_elements:\n                                        log.trace('checking falseList')\n                                        if _checkListItem(child_item, this_policyname, this_key, FALSE_LIST_XPATH, policy_file_data):\n                                            configured_elements[this_element_name] = False\n                                            policy_disabled_elements = policy_disabled_elements + 1\n                                            log.trace('element %s is configured false', child_item.attrib['id'])\n                                elif search_reg_pol(re.escape(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=True)), policy_file_data):\n                                    configured_elements[this_element_name] = False\n                                    policy_disabled_elements = policy_disabled_elements + 1\n                                    log.trace('element %s is configured false', child_item.attrib['id'])\n                                elif search_reg_pol(re.escape(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=False)), policy_file_data):\n                                    configured_elements[this_element_name] = True\n                                    log.trace('element %s is configured true', child_item.attrib['id'])\n                            elif etree.QName(child_item).localname == 'decimal' or etree.QName(child_item).localname == 'text' or etree.QName(child_item).localname == 'longDecimal' or (etree.QName(child_item).localname == 'multiText'):\n                                if search_reg_pol(re.escape(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=True)), policy_file_data):\n                                    configured_elements[this_element_name] = 'Disabled'\n                                    policy_disabled_elements = policy_disabled_elements + 1\n                                    log.trace('element %s is disabled', child_item.attrib['id'])\n                                elif search_reg_pol(re.escape(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=False)), policy_file_data):\n                                    configured_value = _getDataFromRegPolData(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=False), policy_file_data)\n                                    configured_elements[this_element_name] = configured_value\n                                    log.trace('element %s is enabled, value == %s', child_item.attrib['id'], configured_value)\n                            elif etree.QName(child_item).localname == 'enum':\n                                if search_reg_pol(re.escape(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=True)), policy_file_data):\n                                    log.trace('enum element %s is disabled', child_item.attrib['id'])\n                                    configured_elements[this_element_name] = 'Disabled'\n                                    policy_disabled_elements = policy_disabled_elements + 1\n                                else:\n                                    for enum_item in child_item:\n                                        if _checkValueItemParent(enum_item, child_item.attrib['id'], child_key, child_valuename, VALUE_XPATH, policy_file_data):\n                                            if VALUE_LIST_XPATH(enum_item):\n                                                log.trace('enum item has a valueList')\n                                                if _checkListItem(enum_item, this_policyname, child_key, VALUE_LIST_XPATH, policy_file_data):\n                                                    log.trace('all valueList items exist in file')\n                                                    configured_elements[this_element_name] = _getAdmlDisplayName(adml_policy_resources, enum_item.attrib['displayName'])\n                                                    break\n                                            else:\n                                                configured_elements[this_element_name] = _getAdmlDisplayName(adml_policy_resources, enum_item.attrib['displayName'])\n                                                break\n                            elif etree.QName(child_item).localname == 'list':\n                                return_value_name = False\n                                if 'explicitValue' in child_item.attrib and child_item.attrib['explicitValue'].lower() == 'true':\n                                    log.trace('explicitValue list, we will return value names')\n                                    return_value_name = True\n                                regex_str = ['(?!\\\\*', '\\\\*', 'D', 'e', 'l', 'V', 'a', 'l', 's', '\\\\.', ')']\n                                delvals_regex = '\\x00'.join(regex_str)\n                                delvals_regex = salt.utils.stringutils.to_bytes(delvals_regex)\n                                if search_reg_pol(re.escape(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=False)) + delvals_regex, policy_file_data):\n                                    configured_value = _getDataFromRegPolData(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=False), policy_file_data, return_value_name=return_value_name)\n                                    configured_elements[this_element_name] = configured_value\n                                    log.trace('element %s is enabled values: %s', child_item.attrib['id'], configured_value)\n                                elif search_reg_pol(re.escape(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=True)), policy_file_data):\n                                    configured_elements[this_element_name] = 'Disabled'\n                                    policy_disabled_elements = policy_disabled_elements + 1\n                                    log.trace('element %s is disabled', child_item.attrib['id'])\n                    if element_only_enabled_disabled:\n                        if len(required_elements.keys()) > 0 and len(configured_elements.keys()) == len(required_elements.keys()):\n                            if policy_disabled_elements == len(required_elements.keys()):\n                                log.trace('%s is disabled by all enum elements', this_policyname)\n                                if this_policynamespace not in policy_vals:\n                                    policy_vals[this_policynamespace] = {}\n                                policy_vals[this_policynamespace][this_policyname] = 'Disabled'\n                            else:\n                                if this_policynamespace not in policy_vals:\n                                    policy_vals[this_policynamespace] = {}\n                                policy_vals[this_policynamespace][this_policyname] = configured_elements\n                                log.trace('%s is enabled by enum elements', this_policyname)\n                    elif this_policy_setting == 'Enabled':\n                        if this_policynamespace not in policy_vals:\n                            policy_vals[this_policynamespace] = {}\n                        policy_vals[this_policynamespace][this_policyname] = configured_elements\n            if return_full_policy_names and this_policynamespace in policy_vals and (this_policyname in policy_vals[this_policynamespace]):\n                if this_policynamespace not in full_names:\n                    full_names[this_policynamespace] = {}\n                full_names[this_policynamespace][this_policyname] = _getFullPolicyName(policy_item=admx_policy, policy_name=admx_policy.attrib['name'], return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n                if this_policyname in policy_vals[this_policynamespace][this_policyname]:\n                    full_name = full_names[this_policynamespace][this_policyname]\n                    setting = policy_vals[this_policynamespace][this_policyname].pop(this_policyname)\n                    policy_vals[this_policynamespace][this_policyname][full_name] = setting\n            if this_policynamespace in policy_vals and this_policyname in policy_vals[this_policynamespace]:\n                if this_policynamespace not in hierarchy:\n                    hierarchy[this_policynamespace] = {}\n                hierarchy[this_policynamespace][this_policyname] = _build_parent_list(policy_definition=admx_policy, return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n        log.trace('Examination complete: %s seconds', time.time() - start_time)\n    if policy_vals and return_full_policy_names and (not hierarchical_return):\n        log.debug('Compiling non hierarchical return...')\n        start_time = time.time()\n        unpathed_dict = {}\n        pathed_dict = {}\n        for policy_namespace in list(policy_vals):\n            for policy_item in list(policy_vals[policy_namespace]):\n                if full_names[policy_namespace][policy_item] in policy_vals[policy_namespace]:\n                    full_path_list = hierarchy[policy_namespace][policy_item]\n                    full_path_list.reverse()\n                    full_path_list.append(full_names[policy_namespace][policy_item])\n                    policy_vals['\\\\'.join(full_path_list)] = policy_vals[policy_namespace].pop(policy_item)\n                    pathed_dict[full_names[policy_namespace][policy_item]] = True\n                else:\n                    policy_vals[policy_namespace][full_names[policy_namespace][policy_item]] = policy_vals[policy_namespace].pop(policy_item)\n                    if policy_namespace not in unpathed_dict:\n                        unpathed_dict[policy_namespace] = {}\n                    unpathed_dict[policy_namespace][full_names[policy_namespace][policy_item]] = policy_item\n            if policy_namespace in unpathed_dict:\n                for path_needed in unpathed_dict[policy_namespace]:\n                    full_path_list = hierarchy[policy_namespace][unpathed_dict[policy_namespace][path_needed]]\n                    full_path_list.reverse()\n                    full_path_list.append(path_needed)\n                    log.trace('full_path_list == %s', full_path_list)\n                    policy_vals['\\\\'.join(full_path_list)] = policy_vals[policy_namespace].pop(path_needed)\n        log.trace('Compilation complete: %s seconds', time.time() - start_time)\n    for policy_namespace in list(policy_vals):\n        if policy_vals[policy_namespace] == {}:\n            policy_vals.pop(policy_namespace)\n    if policy_vals and hierarchical_return:\n        if hierarchy:\n            log.debug('Compiling hierarchical return...')\n            start_time = time.time()\n            for policy_namespace in hierarchy:\n                for hierarchy_item in hierarchy[policy_namespace]:\n                    if hierarchy_item in policy_vals[policy_namespace]:\n                        tdict = {}\n                        first_item = True\n                        for item in hierarchy[policy_namespace][hierarchy_item]:\n                            newdict = {}\n                            if first_item:\n                                h_policy_name = hierarchy_item\n                                if return_full_policy_names:\n                                    h_policy_name = full_names[policy_namespace][hierarchy_item]\n                                newdict[item] = {h_policy_name: policy_vals[policy_namespace].pop(hierarchy_item)}\n                                first_item = False\n                            else:\n                                newdict[item] = tdict\n                            tdict = newdict\n                        if tdict:\n                            policy_vals = dictupdate.update(policy_vals, tdict)\n                if policy_namespace in policy_vals and policy_vals[policy_namespace] == {}:\n                    policy_vals.pop(policy_namespace)\n            log.trace('Compilation complete: %s seconds', time.time() - start_time)\n        policy_vals = {CLASS_INFO[policy_class]['lgpo_section']: {'Administrative Templates': policy_vals}}\n    return policy_vals",
            "def _checkAllAdmxPolicies(policy_class, adml_language='en-US', return_full_policy_names=False, hierarchical_return=False, return_not_configured=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    rewrite of _getAllAdminTemplateSettingsFromRegPolFile where instead of\\n    looking only at the contents of the file, we're going to loop through every\\n    policy and look in the registry.pol file to determine if it is\\n    enabled/disabled/not configured\\n    \"\n    log.trace('POLICY CLASS == %s', policy_class)\n    policy_file_data = read_reg_pol_file(CLASS_INFO[policy_class]['policy_path'])\n    admx_policies = []\n    policy_vals = {}\n    hierarchy = {}\n    full_names = {}\n    admx_policy_definitions = _get_policy_definitions(language=adml_language)\n    adml_policy_resources = _get_policy_resources(language=adml_language)\n    if policy_file_data:\n        log.trace('POLICY CLASS %s has file data', policy_class)\n        policy_filedata_split = re.sub(salt.utils.stringutils.to_bytes(f'\\\\]{chr(0)}$'), b'', re.sub(salt.utils.stringutils.to_bytes(f'^\\\\[{chr(0)}'), b'', re.sub(re.escape(REG_POL_HEADER.encode('utf-16-le')), b'', policy_file_data))).split(']['.encode('utf-16-le'))\n        log.trace('Searching %s policies...', len(policy_filedata_split))\n        start_time = time.time()\n        for policy_item in policy_filedata_split:\n            policy_item_key = policy_item.split(f'{chr(0)};'.encode('utf-16-le'))[0].decode('utf-16-le').lower()\n            if policy_item_key:\n                admx_items = REGKEY_XPATH(admx_policy_definitions, keyvalue=policy_item_key)\n                log.trace('Found %s policies for %s', len(admx_items), policy_item_key)\n                for admx_item in admx_items:\n                    if etree.QName(admx_item).localname == 'policy':\n                        if admx_item not in admx_policies:\n                            admx_policies.append(admx_item)\n                    else:\n                        for policy_item in POLICY_ANCESTOR_XPATH(admx_item):\n                            if policy_item not in admx_policies:\n                                admx_policies.append(policy_item)\n        log.trace('Search complete: %s seconds', time.time() - start_time)\n        if return_not_configured:\n            log.trace('Gathering non configured policies')\n            start_time = time.time()\n            not_configured_policies = ALL_CLASS_POLICY_XPATH(admx_policy_definitions, registry_class=policy_class)\n            for policy_item in admx_policies:\n                if policy_item in not_configured_policies:\n                    not_configured_policies.remove(policy_item)\n            for not_configured_policy in not_configured_policies:\n                not_configured_policy_namespace = not_configured_policy.nsmap[not_configured_policy.prefix]\n                if not_configured_policy_namespace not in policy_vals:\n                    policy_vals[not_configured_policy_namespace] = {}\n                policy_vals[not_configured_policy_namespace][not_configured_policy.attrib['name']] = 'Not Configured'\n                if return_full_policy_names:\n                    if not_configured_policy_namespace not in full_names:\n                        full_names[not_configured_policy_namespace] = {}\n                    full_names[not_configured_policy_namespace][not_configured_policy.attrib['name']] = _getFullPolicyName(policy_item=not_configured_policy, policy_name=not_configured_policy.attrib['name'], return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n                log.trace('building hierarchy for non-configured item %s', not_configured_policy.attrib['name'])\n                if not_configured_policy_namespace not in hierarchy:\n                    hierarchy[not_configured_policy_namespace] = {}\n                hierarchy[not_configured_policy_namespace][not_configured_policy.attrib['name']] = _build_parent_list(policy_definition=not_configured_policy, return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n            log.trace('Gathering complete: %s seconds', time.time() - start_time)\n        log.trace('Examining %s policies...', len(admx_policies))\n        start_time = time.time()\n        for admx_policy in admx_policies:\n            this_valuename = None\n            this_policy_setting = 'Not Configured'\n            element_only_enabled_disabled = True\n            explicit_enable_disable_value_setting = False\n            if 'key' in admx_policy.attrib:\n                this_key = admx_policy.attrib['key']\n            else:\n                log.error('policy item %s does not have the required \"key\" attribute', admx_policy.attrib)\n                break\n            if 'valueName' in admx_policy.attrib:\n                this_valuename = admx_policy.attrib['valueName']\n            if 'name' in admx_policy.attrib:\n                this_policyname = admx_policy.attrib['name']\n            else:\n                log.error('policy item %s does not have the required \"name\" attribute', admx_policy.attrib)\n                break\n            this_policynamespace = admx_policy.nsmap[admx_policy.prefix]\n            if ENABLED_VALUE_XPATH(admx_policy) and this_policy_setting == 'Not Configured':\n                if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(admx_policy):\n                    element_only_enabled_disabled = False\n                    explicit_enable_disable_value_setting = True\n                if _checkValueItemParent(admx_policy, this_policyname, this_key, this_valuename, ENABLED_VALUE_XPATH, policy_file_data):\n                    this_policy_setting = 'Enabled'\n                    log.trace('%s is enabled by detected ENABLED_VALUE_XPATH', this_policyname)\n                    if this_policynamespace not in policy_vals:\n                        policy_vals[this_policynamespace] = {}\n                    policy_vals[this_policynamespace][this_policyname] = this_policy_setting\n            if DISABLED_VALUE_XPATH(admx_policy) and this_policy_setting == 'Not Configured':\n                if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):\n                    element_only_enabled_disabled = False\n                    explicit_enable_disable_value_setting = True\n                if _checkValueItemParent(admx_policy, this_policyname, this_key, this_valuename, DISABLED_VALUE_XPATH, policy_file_data):\n                    this_policy_setting = 'Disabled'\n                    log.trace('%s is disabled by detected DISABLED_VALUE_XPATH', this_policyname)\n                    if this_policynamespace not in policy_vals:\n                        policy_vals[this_policynamespace] = {}\n                    policy_vals[this_policynamespace][this_policyname] = this_policy_setting\n            if ENABLED_LIST_XPATH(admx_policy) and this_policy_setting == 'Not Configured':\n                if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(admx_policy):\n                    element_only_enabled_disabled = False\n                    explicit_enable_disable_value_setting = True\n                if _checkListItem(admx_policy, this_policyname, this_key, ENABLED_LIST_XPATH, policy_file_data):\n                    this_policy_setting = 'Enabled'\n                    log.trace('%s is enabled by detected ENABLED_LIST_XPATH', this_policyname)\n                    if this_policynamespace not in policy_vals:\n                        policy_vals[this_policynamespace] = {}\n                    policy_vals[this_policynamespace][this_policyname] = this_policy_setting\n            if DISABLED_LIST_XPATH(admx_policy) and this_policy_setting == 'Not Configured':\n                if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):\n                    element_only_enabled_disabled = False\n                    explicit_enable_disable_value_setting = True\n                if _checkListItem(admx_policy, this_policyname, this_key, DISABLED_LIST_XPATH, policy_file_data):\n                    this_policy_setting = 'Disabled'\n                    log.trace('%s is disabled by detected DISABLED_LIST_XPATH', this_policyname)\n                    if this_policynamespace not in policy_vals:\n                        policy_vals[this_policynamespace] = {}\n                    policy_vals[this_policynamespace][this_policyname] = this_policy_setting\n            if not explicit_enable_disable_value_setting and this_valuename:\n                if search_reg_pol(re.escape(_buildKnownDataSearchString(this_key, this_valuename, 'REG_DWORD', '1')), policy_file_data):\n                    this_policy_setting = 'Enabled'\n                    log.trace('%s is enabled by no explicit enable/disable list or value', this_policyname)\n                    if this_policynamespace not in policy_vals:\n                        policy_vals[this_policynamespace] = {}\n                    policy_vals[this_policynamespace][this_policyname] = this_policy_setting\n                elif search_reg_pol(re.escape(_buildKnownDataSearchString(this_key, this_valuename, 'REG_DWORD', None, check_deleted=True)), policy_file_data):\n                    this_policy_setting = 'Disabled'\n                    log.trace('%s is disabled by no explicit enable/disable list or value', this_policyname)\n                    if this_policynamespace not in policy_vals:\n                        policy_vals[this_policynamespace] = {}\n                    policy_vals[this_policynamespace][this_policyname] = this_policy_setting\n            if ELEMENTS_XPATH(admx_policy):\n                if element_only_enabled_disabled or this_policy_setting == 'Enabled':\n                    required_elements = {}\n                    configured_elements = {}\n                    policy_disabled_elements = 0\n                    for elements_item in ELEMENTS_XPATH(admx_policy):\n                        for child_item in elements_item:\n                            this_element_name = _getFullPolicyName(policy_item=child_item, policy_name=child_item.attrib['id'], return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n                            required_elements[this_element_name] = None\n                            child_key = child_item.attrib.get('key', this_key)\n                            child_valuename = child_item.attrib.get('valueName', this_valuename)\n                            if etree.QName(child_item).localname == 'boolean':\n                                if len(child_item) > 0:\n                                    if TRUE_VALUE_XPATH(child_item) and this_element_name not in configured_elements:\n                                        if _checkValueItemParent(child_item, this_policyname, child_key, child_valuename, TRUE_VALUE_XPATH, policy_file_data):\n                                            configured_elements[this_element_name] = True\n                                            log.trace('element %s is configured true', child_item.attrib['id'])\n                                    if FALSE_VALUE_XPATH(child_item) and this_element_name not in configured_elements:\n                                        if _checkValueItemParent(child_item, this_policyname, child_key, child_valuename, FALSE_VALUE_XPATH, policy_file_data):\n                                            configured_elements[this_element_name] = False\n                                            policy_disabled_elements = policy_disabled_elements + 1\n                                            log.trace('element %s is configured false', child_item.attrib['id'])\n                                    if TRUE_LIST_XPATH(child_item) and this_element_name not in configured_elements:\n                                        log.trace('checking trueList')\n                                        if _checkListItem(child_item, this_policyname, this_key, TRUE_LIST_XPATH, policy_file_data):\n                                            configured_elements[this_element_name] = True\n                                            log.trace('element %s is configured true', child_item.attrib['id'])\n                                    if FALSE_LIST_XPATH(child_item) and this_element_name not in configured_elements:\n                                        log.trace('checking falseList')\n                                        if _checkListItem(child_item, this_policyname, this_key, FALSE_LIST_XPATH, policy_file_data):\n                                            configured_elements[this_element_name] = False\n                                            policy_disabled_elements = policy_disabled_elements + 1\n                                            log.trace('element %s is configured false', child_item.attrib['id'])\n                                elif search_reg_pol(re.escape(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=True)), policy_file_data):\n                                    configured_elements[this_element_name] = False\n                                    policy_disabled_elements = policy_disabled_elements + 1\n                                    log.trace('element %s is configured false', child_item.attrib['id'])\n                                elif search_reg_pol(re.escape(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=False)), policy_file_data):\n                                    configured_elements[this_element_name] = True\n                                    log.trace('element %s is configured true', child_item.attrib['id'])\n                            elif etree.QName(child_item).localname == 'decimal' or etree.QName(child_item).localname == 'text' or etree.QName(child_item).localname == 'longDecimal' or (etree.QName(child_item).localname == 'multiText'):\n                                if search_reg_pol(re.escape(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=True)), policy_file_data):\n                                    configured_elements[this_element_name] = 'Disabled'\n                                    policy_disabled_elements = policy_disabled_elements + 1\n                                    log.trace('element %s is disabled', child_item.attrib['id'])\n                                elif search_reg_pol(re.escape(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=False)), policy_file_data):\n                                    configured_value = _getDataFromRegPolData(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=False), policy_file_data)\n                                    configured_elements[this_element_name] = configured_value\n                                    log.trace('element %s is enabled, value == %s', child_item.attrib['id'], configured_value)\n                            elif etree.QName(child_item).localname == 'enum':\n                                if search_reg_pol(re.escape(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=True)), policy_file_data):\n                                    log.trace('enum element %s is disabled', child_item.attrib['id'])\n                                    configured_elements[this_element_name] = 'Disabled'\n                                    policy_disabled_elements = policy_disabled_elements + 1\n                                else:\n                                    for enum_item in child_item:\n                                        if _checkValueItemParent(enum_item, child_item.attrib['id'], child_key, child_valuename, VALUE_XPATH, policy_file_data):\n                                            if VALUE_LIST_XPATH(enum_item):\n                                                log.trace('enum item has a valueList')\n                                                if _checkListItem(enum_item, this_policyname, child_key, VALUE_LIST_XPATH, policy_file_data):\n                                                    log.trace('all valueList items exist in file')\n                                                    configured_elements[this_element_name] = _getAdmlDisplayName(adml_policy_resources, enum_item.attrib['displayName'])\n                                                    break\n                                            else:\n                                                configured_elements[this_element_name] = _getAdmlDisplayName(adml_policy_resources, enum_item.attrib['displayName'])\n                                                break\n                            elif etree.QName(child_item).localname == 'list':\n                                return_value_name = False\n                                if 'explicitValue' in child_item.attrib and child_item.attrib['explicitValue'].lower() == 'true':\n                                    log.trace('explicitValue list, we will return value names')\n                                    return_value_name = True\n                                regex_str = ['(?!\\\\*', '\\\\*', 'D', 'e', 'l', 'V', 'a', 'l', 's', '\\\\.', ')']\n                                delvals_regex = '\\x00'.join(regex_str)\n                                delvals_regex = salt.utils.stringutils.to_bytes(delvals_regex)\n                                if search_reg_pol(re.escape(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=False)) + delvals_regex, policy_file_data):\n                                    configured_value = _getDataFromRegPolData(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=False), policy_file_data, return_value_name=return_value_name)\n                                    configured_elements[this_element_name] = configured_value\n                                    log.trace('element %s is enabled values: %s', child_item.attrib['id'], configured_value)\n                                elif search_reg_pol(re.escape(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=True)), policy_file_data):\n                                    configured_elements[this_element_name] = 'Disabled'\n                                    policy_disabled_elements = policy_disabled_elements + 1\n                                    log.trace('element %s is disabled', child_item.attrib['id'])\n                    if element_only_enabled_disabled:\n                        if len(required_elements.keys()) > 0 and len(configured_elements.keys()) == len(required_elements.keys()):\n                            if policy_disabled_elements == len(required_elements.keys()):\n                                log.trace('%s is disabled by all enum elements', this_policyname)\n                                if this_policynamespace not in policy_vals:\n                                    policy_vals[this_policynamespace] = {}\n                                policy_vals[this_policynamespace][this_policyname] = 'Disabled'\n                            else:\n                                if this_policynamespace not in policy_vals:\n                                    policy_vals[this_policynamespace] = {}\n                                policy_vals[this_policynamespace][this_policyname] = configured_elements\n                                log.trace('%s is enabled by enum elements', this_policyname)\n                    elif this_policy_setting == 'Enabled':\n                        if this_policynamespace not in policy_vals:\n                            policy_vals[this_policynamespace] = {}\n                        policy_vals[this_policynamespace][this_policyname] = configured_elements\n            if return_full_policy_names and this_policynamespace in policy_vals and (this_policyname in policy_vals[this_policynamespace]):\n                if this_policynamespace not in full_names:\n                    full_names[this_policynamespace] = {}\n                full_names[this_policynamespace][this_policyname] = _getFullPolicyName(policy_item=admx_policy, policy_name=admx_policy.attrib['name'], return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n                if this_policyname in policy_vals[this_policynamespace][this_policyname]:\n                    full_name = full_names[this_policynamespace][this_policyname]\n                    setting = policy_vals[this_policynamespace][this_policyname].pop(this_policyname)\n                    policy_vals[this_policynamespace][this_policyname][full_name] = setting\n            if this_policynamespace in policy_vals and this_policyname in policy_vals[this_policynamespace]:\n                if this_policynamespace not in hierarchy:\n                    hierarchy[this_policynamespace] = {}\n                hierarchy[this_policynamespace][this_policyname] = _build_parent_list(policy_definition=admx_policy, return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n        log.trace('Examination complete: %s seconds', time.time() - start_time)\n    if policy_vals and return_full_policy_names and (not hierarchical_return):\n        log.debug('Compiling non hierarchical return...')\n        start_time = time.time()\n        unpathed_dict = {}\n        pathed_dict = {}\n        for policy_namespace in list(policy_vals):\n            for policy_item in list(policy_vals[policy_namespace]):\n                if full_names[policy_namespace][policy_item] in policy_vals[policy_namespace]:\n                    full_path_list = hierarchy[policy_namespace][policy_item]\n                    full_path_list.reverse()\n                    full_path_list.append(full_names[policy_namespace][policy_item])\n                    policy_vals['\\\\'.join(full_path_list)] = policy_vals[policy_namespace].pop(policy_item)\n                    pathed_dict[full_names[policy_namespace][policy_item]] = True\n                else:\n                    policy_vals[policy_namespace][full_names[policy_namespace][policy_item]] = policy_vals[policy_namespace].pop(policy_item)\n                    if policy_namespace not in unpathed_dict:\n                        unpathed_dict[policy_namespace] = {}\n                    unpathed_dict[policy_namespace][full_names[policy_namespace][policy_item]] = policy_item\n            if policy_namespace in unpathed_dict:\n                for path_needed in unpathed_dict[policy_namespace]:\n                    full_path_list = hierarchy[policy_namespace][unpathed_dict[policy_namespace][path_needed]]\n                    full_path_list.reverse()\n                    full_path_list.append(path_needed)\n                    log.trace('full_path_list == %s', full_path_list)\n                    policy_vals['\\\\'.join(full_path_list)] = policy_vals[policy_namespace].pop(path_needed)\n        log.trace('Compilation complete: %s seconds', time.time() - start_time)\n    for policy_namespace in list(policy_vals):\n        if policy_vals[policy_namespace] == {}:\n            policy_vals.pop(policy_namespace)\n    if policy_vals and hierarchical_return:\n        if hierarchy:\n            log.debug('Compiling hierarchical return...')\n            start_time = time.time()\n            for policy_namespace in hierarchy:\n                for hierarchy_item in hierarchy[policy_namespace]:\n                    if hierarchy_item in policy_vals[policy_namespace]:\n                        tdict = {}\n                        first_item = True\n                        for item in hierarchy[policy_namespace][hierarchy_item]:\n                            newdict = {}\n                            if first_item:\n                                h_policy_name = hierarchy_item\n                                if return_full_policy_names:\n                                    h_policy_name = full_names[policy_namespace][hierarchy_item]\n                                newdict[item] = {h_policy_name: policy_vals[policy_namespace].pop(hierarchy_item)}\n                                first_item = False\n                            else:\n                                newdict[item] = tdict\n                            tdict = newdict\n                        if tdict:\n                            policy_vals = dictupdate.update(policy_vals, tdict)\n                if policy_namespace in policy_vals and policy_vals[policy_namespace] == {}:\n                    policy_vals.pop(policy_namespace)\n            log.trace('Compilation complete: %s seconds', time.time() - start_time)\n        policy_vals = {CLASS_INFO[policy_class]['lgpo_section']: {'Administrative Templates': policy_vals}}\n    return policy_vals",
            "def _checkAllAdmxPolicies(policy_class, adml_language='en-US', return_full_policy_names=False, hierarchical_return=False, return_not_configured=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    rewrite of _getAllAdminTemplateSettingsFromRegPolFile where instead of\\n    looking only at the contents of the file, we're going to loop through every\\n    policy and look in the registry.pol file to determine if it is\\n    enabled/disabled/not configured\\n    \"\n    log.trace('POLICY CLASS == %s', policy_class)\n    policy_file_data = read_reg_pol_file(CLASS_INFO[policy_class]['policy_path'])\n    admx_policies = []\n    policy_vals = {}\n    hierarchy = {}\n    full_names = {}\n    admx_policy_definitions = _get_policy_definitions(language=adml_language)\n    adml_policy_resources = _get_policy_resources(language=adml_language)\n    if policy_file_data:\n        log.trace('POLICY CLASS %s has file data', policy_class)\n        policy_filedata_split = re.sub(salt.utils.stringutils.to_bytes(f'\\\\]{chr(0)}$'), b'', re.sub(salt.utils.stringutils.to_bytes(f'^\\\\[{chr(0)}'), b'', re.sub(re.escape(REG_POL_HEADER.encode('utf-16-le')), b'', policy_file_data))).split(']['.encode('utf-16-le'))\n        log.trace('Searching %s policies...', len(policy_filedata_split))\n        start_time = time.time()\n        for policy_item in policy_filedata_split:\n            policy_item_key = policy_item.split(f'{chr(0)};'.encode('utf-16-le'))[0].decode('utf-16-le').lower()\n            if policy_item_key:\n                admx_items = REGKEY_XPATH(admx_policy_definitions, keyvalue=policy_item_key)\n                log.trace('Found %s policies for %s', len(admx_items), policy_item_key)\n                for admx_item in admx_items:\n                    if etree.QName(admx_item).localname == 'policy':\n                        if admx_item not in admx_policies:\n                            admx_policies.append(admx_item)\n                    else:\n                        for policy_item in POLICY_ANCESTOR_XPATH(admx_item):\n                            if policy_item not in admx_policies:\n                                admx_policies.append(policy_item)\n        log.trace('Search complete: %s seconds', time.time() - start_time)\n        if return_not_configured:\n            log.trace('Gathering non configured policies')\n            start_time = time.time()\n            not_configured_policies = ALL_CLASS_POLICY_XPATH(admx_policy_definitions, registry_class=policy_class)\n            for policy_item in admx_policies:\n                if policy_item in not_configured_policies:\n                    not_configured_policies.remove(policy_item)\n            for not_configured_policy in not_configured_policies:\n                not_configured_policy_namespace = not_configured_policy.nsmap[not_configured_policy.prefix]\n                if not_configured_policy_namespace not in policy_vals:\n                    policy_vals[not_configured_policy_namespace] = {}\n                policy_vals[not_configured_policy_namespace][not_configured_policy.attrib['name']] = 'Not Configured'\n                if return_full_policy_names:\n                    if not_configured_policy_namespace not in full_names:\n                        full_names[not_configured_policy_namespace] = {}\n                    full_names[not_configured_policy_namespace][not_configured_policy.attrib['name']] = _getFullPolicyName(policy_item=not_configured_policy, policy_name=not_configured_policy.attrib['name'], return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n                log.trace('building hierarchy for non-configured item %s', not_configured_policy.attrib['name'])\n                if not_configured_policy_namespace not in hierarchy:\n                    hierarchy[not_configured_policy_namespace] = {}\n                hierarchy[not_configured_policy_namespace][not_configured_policy.attrib['name']] = _build_parent_list(policy_definition=not_configured_policy, return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n            log.trace('Gathering complete: %s seconds', time.time() - start_time)\n        log.trace('Examining %s policies...', len(admx_policies))\n        start_time = time.time()\n        for admx_policy in admx_policies:\n            this_valuename = None\n            this_policy_setting = 'Not Configured'\n            element_only_enabled_disabled = True\n            explicit_enable_disable_value_setting = False\n            if 'key' in admx_policy.attrib:\n                this_key = admx_policy.attrib['key']\n            else:\n                log.error('policy item %s does not have the required \"key\" attribute', admx_policy.attrib)\n                break\n            if 'valueName' in admx_policy.attrib:\n                this_valuename = admx_policy.attrib['valueName']\n            if 'name' in admx_policy.attrib:\n                this_policyname = admx_policy.attrib['name']\n            else:\n                log.error('policy item %s does not have the required \"name\" attribute', admx_policy.attrib)\n                break\n            this_policynamespace = admx_policy.nsmap[admx_policy.prefix]\n            if ENABLED_VALUE_XPATH(admx_policy) and this_policy_setting == 'Not Configured':\n                if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(admx_policy):\n                    element_only_enabled_disabled = False\n                    explicit_enable_disable_value_setting = True\n                if _checkValueItemParent(admx_policy, this_policyname, this_key, this_valuename, ENABLED_VALUE_XPATH, policy_file_data):\n                    this_policy_setting = 'Enabled'\n                    log.trace('%s is enabled by detected ENABLED_VALUE_XPATH', this_policyname)\n                    if this_policynamespace not in policy_vals:\n                        policy_vals[this_policynamespace] = {}\n                    policy_vals[this_policynamespace][this_policyname] = this_policy_setting\n            if DISABLED_VALUE_XPATH(admx_policy) and this_policy_setting == 'Not Configured':\n                if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):\n                    element_only_enabled_disabled = False\n                    explicit_enable_disable_value_setting = True\n                if _checkValueItemParent(admx_policy, this_policyname, this_key, this_valuename, DISABLED_VALUE_XPATH, policy_file_data):\n                    this_policy_setting = 'Disabled'\n                    log.trace('%s is disabled by detected DISABLED_VALUE_XPATH', this_policyname)\n                    if this_policynamespace not in policy_vals:\n                        policy_vals[this_policynamespace] = {}\n                    policy_vals[this_policynamespace][this_policyname] = this_policy_setting\n            if ENABLED_LIST_XPATH(admx_policy) and this_policy_setting == 'Not Configured':\n                if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(admx_policy):\n                    element_only_enabled_disabled = False\n                    explicit_enable_disable_value_setting = True\n                if _checkListItem(admx_policy, this_policyname, this_key, ENABLED_LIST_XPATH, policy_file_data):\n                    this_policy_setting = 'Enabled'\n                    log.trace('%s is enabled by detected ENABLED_LIST_XPATH', this_policyname)\n                    if this_policynamespace not in policy_vals:\n                        policy_vals[this_policynamespace] = {}\n                    policy_vals[this_policynamespace][this_policyname] = this_policy_setting\n            if DISABLED_LIST_XPATH(admx_policy) and this_policy_setting == 'Not Configured':\n                if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):\n                    element_only_enabled_disabled = False\n                    explicit_enable_disable_value_setting = True\n                if _checkListItem(admx_policy, this_policyname, this_key, DISABLED_LIST_XPATH, policy_file_data):\n                    this_policy_setting = 'Disabled'\n                    log.trace('%s is disabled by detected DISABLED_LIST_XPATH', this_policyname)\n                    if this_policynamespace not in policy_vals:\n                        policy_vals[this_policynamespace] = {}\n                    policy_vals[this_policynamespace][this_policyname] = this_policy_setting\n            if not explicit_enable_disable_value_setting and this_valuename:\n                if search_reg_pol(re.escape(_buildKnownDataSearchString(this_key, this_valuename, 'REG_DWORD', '1')), policy_file_data):\n                    this_policy_setting = 'Enabled'\n                    log.trace('%s is enabled by no explicit enable/disable list or value', this_policyname)\n                    if this_policynamespace not in policy_vals:\n                        policy_vals[this_policynamespace] = {}\n                    policy_vals[this_policynamespace][this_policyname] = this_policy_setting\n                elif search_reg_pol(re.escape(_buildKnownDataSearchString(this_key, this_valuename, 'REG_DWORD', None, check_deleted=True)), policy_file_data):\n                    this_policy_setting = 'Disabled'\n                    log.trace('%s is disabled by no explicit enable/disable list or value', this_policyname)\n                    if this_policynamespace not in policy_vals:\n                        policy_vals[this_policynamespace] = {}\n                    policy_vals[this_policynamespace][this_policyname] = this_policy_setting\n            if ELEMENTS_XPATH(admx_policy):\n                if element_only_enabled_disabled or this_policy_setting == 'Enabled':\n                    required_elements = {}\n                    configured_elements = {}\n                    policy_disabled_elements = 0\n                    for elements_item in ELEMENTS_XPATH(admx_policy):\n                        for child_item in elements_item:\n                            this_element_name = _getFullPolicyName(policy_item=child_item, policy_name=child_item.attrib['id'], return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n                            required_elements[this_element_name] = None\n                            child_key = child_item.attrib.get('key', this_key)\n                            child_valuename = child_item.attrib.get('valueName', this_valuename)\n                            if etree.QName(child_item).localname == 'boolean':\n                                if len(child_item) > 0:\n                                    if TRUE_VALUE_XPATH(child_item) and this_element_name not in configured_elements:\n                                        if _checkValueItemParent(child_item, this_policyname, child_key, child_valuename, TRUE_VALUE_XPATH, policy_file_data):\n                                            configured_elements[this_element_name] = True\n                                            log.trace('element %s is configured true', child_item.attrib['id'])\n                                    if FALSE_VALUE_XPATH(child_item) and this_element_name not in configured_elements:\n                                        if _checkValueItemParent(child_item, this_policyname, child_key, child_valuename, FALSE_VALUE_XPATH, policy_file_data):\n                                            configured_elements[this_element_name] = False\n                                            policy_disabled_elements = policy_disabled_elements + 1\n                                            log.trace('element %s is configured false', child_item.attrib['id'])\n                                    if TRUE_LIST_XPATH(child_item) and this_element_name not in configured_elements:\n                                        log.trace('checking trueList')\n                                        if _checkListItem(child_item, this_policyname, this_key, TRUE_LIST_XPATH, policy_file_data):\n                                            configured_elements[this_element_name] = True\n                                            log.trace('element %s is configured true', child_item.attrib['id'])\n                                    if FALSE_LIST_XPATH(child_item) and this_element_name not in configured_elements:\n                                        log.trace('checking falseList')\n                                        if _checkListItem(child_item, this_policyname, this_key, FALSE_LIST_XPATH, policy_file_data):\n                                            configured_elements[this_element_name] = False\n                                            policy_disabled_elements = policy_disabled_elements + 1\n                                            log.trace('element %s is configured false', child_item.attrib['id'])\n                                elif search_reg_pol(re.escape(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=True)), policy_file_data):\n                                    configured_elements[this_element_name] = False\n                                    policy_disabled_elements = policy_disabled_elements + 1\n                                    log.trace('element %s is configured false', child_item.attrib['id'])\n                                elif search_reg_pol(re.escape(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=False)), policy_file_data):\n                                    configured_elements[this_element_name] = True\n                                    log.trace('element %s is configured true', child_item.attrib['id'])\n                            elif etree.QName(child_item).localname == 'decimal' or etree.QName(child_item).localname == 'text' or etree.QName(child_item).localname == 'longDecimal' or (etree.QName(child_item).localname == 'multiText'):\n                                if search_reg_pol(re.escape(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=True)), policy_file_data):\n                                    configured_elements[this_element_name] = 'Disabled'\n                                    policy_disabled_elements = policy_disabled_elements + 1\n                                    log.trace('element %s is disabled', child_item.attrib['id'])\n                                elif search_reg_pol(re.escape(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=False)), policy_file_data):\n                                    configured_value = _getDataFromRegPolData(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=False), policy_file_data)\n                                    configured_elements[this_element_name] = configured_value\n                                    log.trace('element %s is enabled, value == %s', child_item.attrib['id'], configured_value)\n                            elif etree.QName(child_item).localname == 'enum':\n                                if search_reg_pol(re.escape(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=True)), policy_file_data):\n                                    log.trace('enum element %s is disabled', child_item.attrib['id'])\n                                    configured_elements[this_element_name] = 'Disabled'\n                                    policy_disabled_elements = policy_disabled_elements + 1\n                                else:\n                                    for enum_item in child_item:\n                                        if _checkValueItemParent(enum_item, child_item.attrib['id'], child_key, child_valuename, VALUE_XPATH, policy_file_data):\n                                            if VALUE_LIST_XPATH(enum_item):\n                                                log.trace('enum item has a valueList')\n                                                if _checkListItem(enum_item, this_policyname, child_key, VALUE_LIST_XPATH, policy_file_data):\n                                                    log.trace('all valueList items exist in file')\n                                                    configured_elements[this_element_name] = _getAdmlDisplayName(adml_policy_resources, enum_item.attrib['displayName'])\n                                                    break\n                                            else:\n                                                configured_elements[this_element_name] = _getAdmlDisplayName(adml_policy_resources, enum_item.attrib['displayName'])\n                                                break\n                            elif etree.QName(child_item).localname == 'list':\n                                return_value_name = False\n                                if 'explicitValue' in child_item.attrib and child_item.attrib['explicitValue'].lower() == 'true':\n                                    log.trace('explicitValue list, we will return value names')\n                                    return_value_name = True\n                                regex_str = ['(?!\\\\*', '\\\\*', 'D', 'e', 'l', 'V', 'a', 'l', 's', '\\\\.', ')']\n                                delvals_regex = '\\x00'.join(regex_str)\n                                delvals_regex = salt.utils.stringutils.to_bytes(delvals_regex)\n                                if search_reg_pol(re.escape(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=False)) + delvals_regex, policy_file_data):\n                                    configured_value = _getDataFromRegPolData(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=False), policy_file_data, return_value_name=return_value_name)\n                                    configured_elements[this_element_name] = configured_value\n                                    log.trace('element %s is enabled values: %s', child_item.attrib['id'], configured_value)\n                                elif search_reg_pol(re.escape(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=True)), policy_file_data):\n                                    configured_elements[this_element_name] = 'Disabled'\n                                    policy_disabled_elements = policy_disabled_elements + 1\n                                    log.trace('element %s is disabled', child_item.attrib['id'])\n                    if element_only_enabled_disabled:\n                        if len(required_elements.keys()) > 0 and len(configured_elements.keys()) == len(required_elements.keys()):\n                            if policy_disabled_elements == len(required_elements.keys()):\n                                log.trace('%s is disabled by all enum elements', this_policyname)\n                                if this_policynamespace not in policy_vals:\n                                    policy_vals[this_policynamespace] = {}\n                                policy_vals[this_policynamespace][this_policyname] = 'Disabled'\n                            else:\n                                if this_policynamespace not in policy_vals:\n                                    policy_vals[this_policynamespace] = {}\n                                policy_vals[this_policynamespace][this_policyname] = configured_elements\n                                log.trace('%s is enabled by enum elements', this_policyname)\n                    elif this_policy_setting == 'Enabled':\n                        if this_policynamespace not in policy_vals:\n                            policy_vals[this_policynamespace] = {}\n                        policy_vals[this_policynamespace][this_policyname] = configured_elements\n            if return_full_policy_names and this_policynamespace in policy_vals and (this_policyname in policy_vals[this_policynamespace]):\n                if this_policynamespace not in full_names:\n                    full_names[this_policynamespace] = {}\n                full_names[this_policynamespace][this_policyname] = _getFullPolicyName(policy_item=admx_policy, policy_name=admx_policy.attrib['name'], return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n                if this_policyname in policy_vals[this_policynamespace][this_policyname]:\n                    full_name = full_names[this_policynamespace][this_policyname]\n                    setting = policy_vals[this_policynamespace][this_policyname].pop(this_policyname)\n                    policy_vals[this_policynamespace][this_policyname][full_name] = setting\n            if this_policynamespace in policy_vals and this_policyname in policy_vals[this_policynamespace]:\n                if this_policynamespace not in hierarchy:\n                    hierarchy[this_policynamespace] = {}\n                hierarchy[this_policynamespace][this_policyname] = _build_parent_list(policy_definition=admx_policy, return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n        log.trace('Examination complete: %s seconds', time.time() - start_time)\n    if policy_vals and return_full_policy_names and (not hierarchical_return):\n        log.debug('Compiling non hierarchical return...')\n        start_time = time.time()\n        unpathed_dict = {}\n        pathed_dict = {}\n        for policy_namespace in list(policy_vals):\n            for policy_item in list(policy_vals[policy_namespace]):\n                if full_names[policy_namespace][policy_item] in policy_vals[policy_namespace]:\n                    full_path_list = hierarchy[policy_namespace][policy_item]\n                    full_path_list.reverse()\n                    full_path_list.append(full_names[policy_namespace][policy_item])\n                    policy_vals['\\\\'.join(full_path_list)] = policy_vals[policy_namespace].pop(policy_item)\n                    pathed_dict[full_names[policy_namespace][policy_item]] = True\n                else:\n                    policy_vals[policy_namespace][full_names[policy_namespace][policy_item]] = policy_vals[policy_namespace].pop(policy_item)\n                    if policy_namespace not in unpathed_dict:\n                        unpathed_dict[policy_namespace] = {}\n                    unpathed_dict[policy_namespace][full_names[policy_namespace][policy_item]] = policy_item\n            if policy_namespace in unpathed_dict:\n                for path_needed in unpathed_dict[policy_namespace]:\n                    full_path_list = hierarchy[policy_namespace][unpathed_dict[policy_namespace][path_needed]]\n                    full_path_list.reverse()\n                    full_path_list.append(path_needed)\n                    log.trace('full_path_list == %s', full_path_list)\n                    policy_vals['\\\\'.join(full_path_list)] = policy_vals[policy_namespace].pop(path_needed)\n        log.trace('Compilation complete: %s seconds', time.time() - start_time)\n    for policy_namespace in list(policy_vals):\n        if policy_vals[policy_namespace] == {}:\n            policy_vals.pop(policy_namespace)\n    if policy_vals and hierarchical_return:\n        if hierarchy:\n            log.debug('Compiling hierarchical return...')\n            start_time = time.time()\n            for policy_namespace in hierarchy:\n                for hierarchy_item in hierarchy[policy_namespace]:\n                    if hierarchy_item in policy_vals[policy_namespace]:\n                        tdict = {}\n                        first_item = True\n                        for item in hierarchy[policy_namespace][hierarchy_item]:\n                            newdict = {}\n                            if first_item:\n                                h_policy_name = hierarchy_item\n                                if return_full_policy_names:\n                                    h_policy_name = full_names[policy_namespace][hierarchy_item]\n                                newdict[item] = {h_policy_name: policy_vals[policy_namespace].pop(hierarchy_item)}\n                                first_item = False\n                            else:\n                                newdict[item] = tdict\n                            tdict = newdict\n                        if tdict:\n                            policy_vals = dictupdate.update(policy_vals, tdict)\n                if policy_namespace in policy_vals and policy_vals[policy_namespace] == {}:\n                    policy_vals.pop(policy_namespace)\n            log.trace('Compilation complete: %s seconds', time.time() - start_time)\n        policy_vals = {CLASS_INFO[policy_class]['lgpo_section']: {'Administrative Templates': policy_vals}}\n    return policy_vals",
            "def _checkAllAdmxPolicies(policy_class, adml_language='en-US', return_full_policy_names=False, hierarchical_return=False, return_not_configured=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    rewrite of _getAllAdminTemplateSettingsFromRegPolFile where instead of\\n    looking only at the contents of the file, we're going to loop through every\\n    policy and look in the registry.pol file to determine if it is\\n    enabled/disabled/not configured\\n    \"\n    log.trace('POLICY CLASS == %s', policy_class)\n    policy_file_data = read_reg_pol_file(CLASS_INFO[policy_class]['policy_path'])\n    admx_policies = []\n    policy_vals = {}\n    hierarchy = {}\n    full_names = {}\n    admx_policy_definitions = _get_policy_definitions(language=adml_language)\n    adml_policy_resources = _get_policy_resources(language=adml_language)\n    if policy_file_data:\n        log.trace('POLICY CLASS %s has file data', policy_class)\n        policy_filedata_split = re.sub(salt.utils.stringutils.to_bytes(f'\\\\]{chr(0)}$'), b'', re.sub(salt.utils.stringutils.to_bytes(f'^\\\\[{chr(0)}'), b'', re.sub(re.escape(REG_POL_HEADER.encode('utf-16-le')), b'', policy_file_data))).split(']['.encode('utf-16-le'))\n        log.trace('Searching %s policies...', len(policy_filedata_split))\n        start_time = time.time()\n        for policy_item in policy_filedata_split:\n            policy_item_key = policy_item.split(f'{chr(0)};'.encode('utf-16-le'))[0].decode('utf-16-le').lower()\n            if policy_item_key:\n                admx_items = REGKEY_XPATH(admx_policy_definitions, keyvalue=policy_item_key)\n                log.trace('Found %s policies for %s', len(admx_items), policy_item_key)\n                for admx_item in admx_items:\n                    if etree.QName(admx_item).localname == 'policy':\n                        if admx_item not in admx_policies:\n                            admx_policies.append(admx_item)\n                    else:\n                        for policy_item in POLICY_ANCESTOR_XPATH(admx_item):\n                            if policy_item not in admx_policies:\n                                admx_policies.append(policy_item)\n        log.trace('Search complete: %s seconds', time.time() - start_time)\n        if return_not_configured:\n            log.trace('Gathering non configured policies')\n            start_time = time.time()\n            not_configured_policies = ALL_CLASS_POLICY_XPATH(admx_policy_definitions, registry_class=policy_class)\n            for policy_item in admx_policies:\n                if policy_item in not_configured_policies:\n                    not_configured_policies.remove(policy_item)\n            for not_configured_policy in not_configured_policies:\n                not_configured_policy_namespace = not_configured_policy.nsmap[not_configured_policy.prefix]\n                if not_configured_policy_namespace not in policy_vals:\n                    policy_vals[not_configured_policy_namespace] = {}\n                policy_vals[not_configured_policy_namespace][not_configured_policy.attrib['name']] = 'Not Configured'\n                if return_full_policy_names:\n                    if not_configured_policy_namespace not in full_names:\n                        full_names[not_configured_policy_namespace] = {}\n                    full_names[not_configured_policy_namespace][not_configured_policy.attrib['name']] = _getFullPolicyName(policy_item=not_configured_policy, policy_name=not_configured_policy.attrib['name'], return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n                log.trace('building hierarchy for non-configured item %s', not_configured_policy.attrib['name'])\n                if not_configured_policy_namespace not in hierarchy:\n                    hierarchy[not_configured_policy_namespace] = {}\n                hierarchy[not_configured_policy_namespace][not_configured_policy.attrib['name']] = _build_parent_list(policy_definition=not_configured_policy, return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n            log.trace('Gathering complete: %s seconds', time.time() - start_time)\n        log.trace('Examining %s policies...', len(admx_policies))\n        start_time = time.time()\n        for admx_policy in admx_policies:\n            this_valuename = None\n            this_policy_setting = 'Not Configured'\n            element_only_enabled_disabled = True\n            explicit_enable_disable_value_setting = False\n            if 'key' in admx_policy.attrib:\n                this_key = admx_policy.attrib['key']\n            else:\n                log.error('policy item %s does not have the required \"key\" attribute', admx_policy.attrib)\n                break\n            if 'valueName' in admx_policy.attrib:\n                this_valuename = admx_policy.attrib['valueName']\n            if 'name' in admx_policy.attrib:\n                this_policyname = admx_policy.attrib['name']\n            else:\n                log.error('policy item %s does not have the required \"name\" attribute', admx_policy.attrib)\n                break\n            this_policynamespace = admx_policy.nsmap[admx_policy.prefix]\n            if ENABLED_VALUE_XPATH(admx_policy) and this_policy_setting == 'Not Configured':\n                if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(admx_policy):\n                    element_only_enabled_disabled = False\n                    explicit_enable_disable_value_setting = True\n                if _checkValueItemParent(admx_policy, this_policyname, this_key, this_valuename, ENABLED_VALUE_XPATH, policy_file_data):\n                    this_policy_setting = 'Enabled'\n                    log.trace('%s is enabled by detected ENABLED_VALUE_XPATH', this_policyname)\n                    if this_policynamespace not in policy_vals:\n                        policy_vals[this_policynamespace] = {}\n                    policy_vals[this_policynamespace][this_policyname] = this_policy_setting\n            if DISABLED_VALUE_XPATH(admx_policy) and this_policy_setting == 'Not Configured':\n                if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):\n                    element_only_enabled_disabled = False\n                    explicit_enable_disable_value_setting = True\n                if _checkValueItemParent(admx_policy, this_policyname, this_key, this_valuename, DISABLED_VALUE_XPATH, policy_file_data):\n                    this_policy_setting = 'Disabled'\n                    log.trace('%s is disabled by detected DISABLED_VALUE_XPATH', this_policyname)\n                    if this_policynamespace not in policy_vals:\n                        policy_vals[this_policynamespace] = {}\n                    policy_vals[this_policynamespace][this_policyname] = this_policy_setting\n            if ENABLED_LIST_XPATH(admx_policy) and this_policy_setting == 'Not Configured':\n                if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(admx_policy):\n                    element_only_enabled_disabled = False\n                    explicit_enable_disable_value_setting = True\n                if _checkListItem(admx_policy, this_policyname, this_key, ENABLED_LIST_XPATH, policy_file_data):\n                    this_policy_setting = 'Enabled'\n                    log.trace('%s is enabled by detected ENABLED_LIST_XPATH', this_policyname)\n                    if this_policynamespace not in policy_vals:\n                        policy_vals[this_policynamespace] = {}\n                    policy_vals[this_policynamespace][this_policyname] = this_policy_setting\n            if DISABLED_LIST_XPATH(admx_policy) and this_policy_setting == 'Not Configured':\n                if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):\n                    element_only_enabled_disabled = False\n                    explicit_enable_disable_value_setting = True\n                if _checkListItem(admx_policy, this_policyname, this_key, DISABLED_LIST_XPATH, policy_file_data):\n                    this_policy_setting = 'Disabled'\n                    log.trace('%s is disabled by detected DISABLED_LIST_XPATH', this_policyname)\n                    if this_policynamespace not in policy_vals:\n                        policy_vals[this_policynamespace] = {}\n                    policy_vals[this_policynamespace][this_policyname] = this_policy_setting\n            if not explicit_enable_disable_value_setting and this_valuename:\n                if search_reg_pol(re.escape(_buildKnownDataSearchString(this_key, this_valuename, 'REG_DWORD', '1')), policy_file_data):\n                    this_policy_setting = 'Enabled'\n                    log.trace('%s is enabled by no explicit enable/disable list or value', this_policyname)\n                    if this_policynamespace not in policy_vals:\n                        policy_vals[this_policynamespace] = {}\n                    policy_vals[this_policynamespace][this_policyname] = this_policy_setting\n                elif search_reg_pol(re.escape(_buildKnownDataSearchString(this_key, this_valuename, 'REG_DWORD', None, check_deleted=True)), policy_file_data):\n                    this_policy_setting = 'Disabled'\n                    log.trace('%s is disabled by no explicit enable/disable list or value', this_policyname)\n                    if this_policynamespace not in policy_vals:\n                        policy_vals[this_policynamespace] = {}\n                    policy_vals[this_policynamespace][this_policyname] = this_policy_setting\n            if ELEMENTS_XPATH(admx_policy):\n                if element_only_enabled_disabled or this_policy_setting == 'Enabled':\n                    required_elements = {}\n                    configured_elements = {}\n                    policy_disabled_elements = 0\n                    for elements_item in ELEMENTS_XPATH(admx_policy):\n                        for child_item in elements_item:\n                            this_element_name = _getFullPolicyName(policy_item=child_item, policy_name=child_item.attrib['id'], return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n                            required_elements[this_element_name] = None\n                            child_key = child_item.attrib.get('key', this_key)\n                            child_valuename = child_item.attrib.get('valueName', this_valuename)\n                            if etree.QName(child_item).localname == 'boolean':\n                                if len(child_item) > 0:\n                                    if TRUE_VALUE_XPATH(child_item) and this_element_name not in configured_elements:\n                                        if _checkValueItemParent(child_item, this_policyname, child_key, child_valuename, TRUE_VALUE_XPATH, policy_file_data):\n                                            configured_elements[this_element_name] = True\n                                            log.trace('element %s is configured true', child_item.attrib['id'])\n                                    if FALSE_VALUE_XPATH(child_item) and this_element_name not in configured_elements:\n                                        if _checkValueItemParent(child_item, this_policyname, child_key, child_valuename, FALSE_VALUE_XPATH, policy_file_data):\n                                            configured_elements[this_element_name] = False\n                                            policy_disabled_elements = policy_disabled_elements + 1\n                                            log.trace('element %s is configured false', child_item.attrib['id'])\n                                    if TRUE_LIST_XPATH(child_item) and this_element_name not in configured_elements:\n                                        log.trace('checking trueList')\n                                        if _checkListItem(child_item, this_policyname, this_key, TRUE_LIST_XPATH, policy_file_data):\n                                            configured_elements[this_element_name] = True\n                                            log.trace('element %s is configured true', child_item.attrib['id'])\n                                    if FALSE_LIST_XPATH(child_item) and this_element_name not in configured_elements:\n                                        log.trace('checking falseList')\n                                        if _checkListItem(child_item, this_policyname, this_key, FALSE_LIST_XPATH, policy_file_data):\n                                            configured_elements[this_element_name] = False\n                                            policy_disabled_elements = policy_disabled_elements + 1\n                                            log.trace('element %s is configured false', child_item.attrib['id'])\n                                elif search_reg_pol(re.escape(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=True)), policy_file_data):\n                                    configured_elements[this_element_name] = False\n                                    policy_disabled_elements = policy_disabled_elements + 1\n                                    log.trace('element %s is configured false', child_item.attrib['id'])\n                                elif search_reg_pol(re.escape(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=False)), policy_file_data):\n                                    configured_elements[this_element_name] = True\n                                    log.trace('element %s is configured true', child_item.attrib['id'])\n                            elif etree.QName(child_item).localname == 'decimal' or etree.QName(child_item).localname == 'text' or etree.QName(child_item).localname == 'longDecimal' or (etree.QName(child_item).localname == 'multiText'):\n                                if search_reg_pol(re.escape(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=True)), policy_file_data):\n                                    configured_elements[this_element_name] = 'Disabled'\n                                    policy_disabled_elements = policy_disabled_elements + 1\n                                    log.trace('element %s is disabled', child_item.attrib['id'])\n                                elif search_reg_pol(re.escape(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=False)), policy_file_data):\n                                    configured_value = _getDataFromRegPolData(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=False), policy_file_data)\n                                    configured_elements[this_element_name] = configured_value\n                                    log.trace('element %s is enabled, value == %s', child_item.attrib['id'], configured_value)\n                            elif etree.QName(child_item).localname == 'enum':\n                                if search_reg_pol(re.escape(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=True)), policy_file_data):\n                                    log.trace('enum element %s is disabled', child_item.attrib['id'])\n                                    configured_elements[this_element_name] = 'Disabled'\n                                    policy_disabled_elements = policy_disabled_elements + 1\n                                else:\n                                    for enum_item in child_item:\n                                        if _checkValueItemParent(enum_item, child_item.attrib['id'], child_key, child_valuename, VALUE_XPATH, policy_file_data):\n                                            if VALUE_LIST_XPATH(enum_item):\n                                                log.trace('enum item has a valueList')\n                                                if _checkListItem(enum_item, this_policyname, child_key, VALUE_LIST_XPATH, policy_file_data):\n                                                    log.trace('all valueList items exist in file')\n                                                    configured_elements[this_element_name] = _getAdmlDisplayName(adml_policy_resources, enum_item.attrib['displayName'])\n                                                    break\n                                            else:\n                                                configured_elements[this_element_name] = _getAdmlDisplayName(adml_policy_resources, enum_item.attrib['displayName'])\n                                                break\n                            elif etree.QName(child_item).localname == 'list':\n                                return_value_name = False\n                                if 'explicitValue' in child_item.attrib and child_item.attrib['explicitValue'].lower() == 'true':\n                                    log.trace('explicitValue list, we will return value names')\n                                    return_value_name = True\n                                regex_str = ['(?!\\\\*', '\\\\*', 'D', 'e', 'l', 'V', 'a', 'l', 's', '\\\\.', ')']\n                                delvals_regex = '\\x00'.join(regex_str)\n                                delvals_regex = salt.utils.stringutils.to_bytes(delvals_regex)\n                                if search_reg_pol(re.escape(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=False)) + delvals_regex, policy_file_data):\n                                    configured_value = _getDataFromRegPolData(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=False), policy_file_data, return_value_name=return_value_name)\n                                    configured_elements[this_element_name] = configured_value\n                                    log.trace('element %s is enabled values: %s', child_item.attrib['id'], configured_value)\n                                elif search_reg_pol(re.escape(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=True)), policy_file_data):\n                                    configured_elements[this_element_name] = 'Disabled'\n                                    policy_disabled_elements = policy_disabled_elements + 1\n                                    log.trace('element %s is disabled', child_item.attrib['id'])\n                    if element_only_enabled_disabled:\n                        if len(required_elements.keys()) > 0 and len(configured_elements.keys()) == len(required_elements.keys()):\n                            if policy_disabled_elements == len(required_elements.keys()):\n                                log.trace('%s is disabled by all enum elements', this_policyname)\n                                if this_policynamespace not in policy_vals:\n                                    policy_vals[this_policynamespace] = {}\n                                policy_vals[this_policynamespace][this_policyname] = 'Disabled'\n                            else:\n                                if this_policynamespace not in policy_vals:\n                                    policy_vals[this_policynamespace] = {}\n                                policy_vals[this_policynamespace][this_policyname] = configured_elements\n                                log.trace('%s is enabled by enum elements', this_policyname)\n                    elif this_policy_setting == 'Enabled':\n                        if this_policynamespace not in policy_vals:\n                            policy_vals[this_policynamespace] = {}\n                        policy_vals[this_policynamespace][this_policyname] = configured_elements\n            if return_full_policy_names and this_policynamespace in policy_vals and (this_policyname in policy_vals[this_policynamespace]):\n                if this_policynamespace not in full_names:\n                    full_names[this_policynamespace] = {}\n                full_names[this_policynamespace][this_policyname] = _getFullPolicyName(policy_item=admx_policy, policy_name=admx_policy.attrib['name'], return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n                if this_policyname in policy_vals[this_policynamespace][this_policyname]:\n                    full_name = full_names[this_policynamespace][this_policyname]\n                    setting = policy_vals[this_policynamespace][this_policyname].pop(this_policyname)\n                    policy_vals[this_policynamespace][this_policyname][full_name] = setting\n            if this_policynamespace in policy_vals and this_policyname in policy_vals[this_policynamespace]:\n                if this_policynamespace not in hierarchy:\n                    hierarchy[this_policynamespace] = {}\n                hierarchy[this_policynamespace][this_policyname] = _build_parent_list(policy_definition=admx_policy, return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n        log.trace('Examination complete: %s seconds', time.time() - start_time)\n    if policy_vals and return_full_policy_names and (not hierarchical_return):\n        log.debug('Compiling non hierarchical return...')\n        start_time = time.time()\n        unpathed_dict = {}\n        pathed_dict = {}\n        for policy_namespace in list(policy_vals):\n            for policy_item in list(policy_vals[policy_namespace]):\n                if full_names[policy_namespace][policy_item] in policy_vals[policy_namespace]:\n                    full_path_list = hierarchy[policy_namespace][policy_item]\n                    full_path_list.reverse()\n                    full_path_list.append(full_names[policy_namespace][policy_item])\n                    policy_vals['\\\\'.join(full_path_list)] = policy_vals[policy_namespace].pop(policy_item)\n                    pathed_dict[full_names[policy_namespace][policy_item]] = True\n                else:\n                    policy_vals[policy_namespace][full_names[policy_namespace][policy_item]] = policy_vals[policy_namespace].pop(policy_item)\n                    if policy_namespace not in unpathed_dict:\n                        unpathed_dict[policy_namespace] = {}\n                    unpathed_dict[policy_namespace][full_names[policy_namespace][policy_item]] = policy_item\n            if policy_namespace in unpathed_dict:\n                for path_needed in unpathed_dict[policy_namespace]:\n                    full_path_list = hierarchy[policy_namespace][unpathed_dict[policy_namespace][path_needed]]\n                    full_path_list.reverse()\n                    full_path_list.append(path_needed)\n                    log.trace('full_path_list == %s', full_path_list)\n                    policy_vals['\\\\'.join(full_path_list)] = policy_vals[policy_namespace].pop(path_needed)\n        log.trace('Compilation complete: %s seconds', time.time() - start_time)\n    for policy_namespace in list(policy_vals):\n        if policy_vals[policy_namespace] == {}:\n            policy_vals.pop(policy_namespace)\n    if policy_vals and hierarchical_return:\n        if hierarchy:\n            log.debug('Compiling hierarchical return...')\n            start_time = time.time()\n            for policy_namespace in hierarchy:\n                for hierarchy_item in hierarchy[policy_namespace]:\n                    if hierarchy_item in policy_vals[policy_namespace]:\n                        tdict = {}\n                        first_item = True\n                        for item in hierarchy[policy_namespace][hierarchy_item]:\n                            newdict = {}\n                            if first_item:\n                                h_policy_name = hierarchy_item\n                                if return_full_policy_names:\n                                    h_policy_name = full_names[policy_namespace][hierarchy_item]\n                                newdict[item] = {h_policy_name: policy_vals[policy_namespace].pop(hierarchy_item)}\n                                first_item = False\n                            else:\n                                newdict[item] = tdict\n                            tdict = newdict\n                        if tdict:\n                            policy_vals = dictupdate.update(policy_vals, tdict)\n                if policy_namespace in policy_vals and policy_vals[policy_namespace] == {}:\n                    policy_vals.pop(policy_namespace)\n            log.trace('Compilation complete: %s seconds', time.time() - start_time)\n        policy_vals = {CLASS_INFO[policy_class]['lgpo_section']: {'Administrative Templates': policy_vals}}\n    return policy_vals",
            "def _checkAllAdmxPolicies(policy_class, adml_language='en-US', return_full_policy_names=False, hierarchical_return=False, return_not_configured=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    rewrite of _getAllAdminTemplateSettingsFromRegPolFile where instead of\\n    looking only at the contents of the file, we're going to loop through every\\n    policy and look in the registry.pol file to determine if it is\\n    enabled/disabled/not configured\\n    \"\n    log.trace('POLICY CLASS == %s', policy_class)\n    policy_file_data = read_reg_pol_file(CLASS_INFO[policy_class]['policy_path'])\n    admx_policies = []\n    policy_vals = {}\n    hierarchy = {}\n    full_names = {}\n    admx_policy_definitions = _get_policy_definitions(language=adml_language)\n    adml_policy_resources = _get_policy_resources(language=adml_language)\n    if policy_file_data:\n        log.trace('POLICY CLASS %s has file data', policy_class)\n        policy_filedata_split = re.sub(salt.utils.stringutils.to_bytes(f'\\\\]{chr(0)}$'), b'', re.sub(salt.utils.stringutils.to_bytes(f'^\\\\[{chr(0)}'), b'', re.sub(re.escape(REG_POL_HEADER.encode('utf-16-le')), b'', policy_file_data))).split(']['.encode('utf-16-le'))\n        log.trace('Searching %s policies...', len(policy_filedata_split))\n        start_time = time.time()\n        for policy_item in policy_filedata_split:\n            policy_item_key = policy_item.split(f'{chr(0)};'.encode('utf-16-le'))[0].decode('utf-16-le').lower()\n            if policy_item_key:\n                admx_items = REGKEY_XPATH(admx_policy_definitions, keyvalue=policy_item_key)\n                log.trace('Found %s policies for %s', len(admx_items), policy_item_key)\n                for admx_item in admx_items:\n                    if etree.QName(admx_item).localname == 'policy':\n                        if admx_item not in admx_policies:\n                            admx_policies.append(admx_item)\n                    else:\n                        for policy_item in POLICY_ANCESTOR_XPATH(admx_item):\n                            if policy_item not in admx_policies:\n                                admx_policies.append(policy_item)\n        log.trace('Search complete: %s seconds', time.time() - start_time)\n        if return_not_configured:\n            log.trace('Gathering non configured policies')\n            start_time = time.time()\n            not_configured_policies = ALL_CLASS_POLICY_XPATH(admx_policy_definitions, registry_class=policy_class)\n            for policy_item in admx_policies:\n                if policy_item in not_configured_policies:\n                    not_configured_policies.remove(policy_item)\n            for not_configured_policy in not_configured_policies:\n                not_configured_policy_namespace = not_configured_policy.nsmap[not_configured_policy.prefix]\n                if not_configured_policy_namespace not in policy_vals:\n                    policy_vals[not_configured_policy_namespace] = {}\n                policy_vals[not_configured_policy_namespace][not_configured_policy.attrib['name']] = 'Not Configured'\n                if return_full_policy_names:\n                    if not_configured_policy_namespace not in full_names:\n                        full_names[not_configured_policy_namespace] = {}\n                    full_names[not_configured_policy_namespace][not_configured_policy.attrib['name']] = _getFullPolicyName(policy_item=not_configured_policy, policy_name=not_configured_policy.attrib['name'], return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n                log.trace('building hierarchy for non-configured item %s', not_configured_policy.attrib['name'])\n                if not_configured_policy_namespace not in hierarchy:\n                    hierarchy[not_configured_policy_namespace] = {}\n                hierarchy[not_configured_policy_namespace][not_configured_policy.attrib['name']] = _build_parent_list(policy_definition=not_configured_policy, return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n            log.trace('Gathering complete: %s seconds', time.time() - start_time)\n        log.trace('Examining %s policies...', len(admx_policies))\n        start_time = time.time()\n        for admx_policy in admx_policies:\n            this_valuename = None\n            this_policy_setting = 'Not Configured'\n            element_only_enabled_disabled = True\n            explicit_enable_disable_value_setting = False\n            if 'key' in admx_policy.attrib:\n                this_key = admx_policy.attrib['key']\n            else:\n                log.error('policy item %s does not have the required \"key\" attribute', admx_policy.attrib)\n                break\n            if 'valueName' in admx_policy.attrib:\n                this_valuename = admx_policy.attrib['valueName']\n            if 'name' in admx_policy.attrib:\n                this_policyname = admx_policy.attrib['name']\n            else:\n                log.error('policy item %s does not have the required \"name\" attribute', admx_policy.attrib)\n                break\n            this_policynamespace = admx_policy.nsmap[admx_policy.prefix]\n            if ENABLED_VALUE_XPATH(admx_policy) and this_policy_setting == 'Not Configured':\n                if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(admx_policy):\n                    element_only_enabled_disabled = False\n                    explicit_enable_disable_value_setting = True\n                if _checkValueItemParent(admx_policy, this_policyname, this_key, this_valuename, ENABLED_VALUE_XPATH, policy_file_data):\n                    this_policy_setting = 'Enabled'\n                    log.trace('%s is enabled by detected ENABLED_VALUE_XPATH', this_policyname)\n                    if this_policynamespace not in policy_vals:\n                        policy_vals[this_policynamespace] = {}\n                    policy_vals[this_policynamespace][this_policyname] = this_policy_setting\n            if DISABLED_VALUE_XPATH(admx_policy) and this_policy_setting == 'Not Configured':\n                if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):\n                    element_only_enabled_disabled = False\n                    explicit_enable_disable_value_setting = True\n                if _checkValueItemParent(admx_policy, this_policyname, this_key, this_valuename, DISABLED_VALUE_XPATH, policy_file_data):\n                    this_policy_setting = 'Disabled'\n                    log.trace('%s is disabled by detected DISABLED_VALUE_XPATH', this_policyname)\n                    if this_policynamespace not in policy_vals:\n                        policy_vals[this_policynamespace] = {}\n                    policy_vals[this_policynamespace][this_policyname] = this_policy_setting\n            if ENABLED_LIST_XPATH(admx_policy) and this_policy_setting == 'Not Configured':\n                if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(admx_policy):\n                    element_only_enabled_disabled = False\n                    explicit_enable_disable_value_setting = True\n                if _checkListItem(admx_policy, this_policyname, this_key, ENABLED_LIST_XPATH, policy_file_data):\n                    this_policy_setting = 'Enabled'\n                    log.trace('%s is enabled by detected ENABLED_LIST_XPATH', this_policyname)\n                    if this_policynamespace not in policy_vals:\n                        policy_vals[this_policynamespace] = {}\n                    policy_vals[this_policynamespace][this_policyname] = this_policy_setting\n            if DISABLED_LIST_XPATH(admx_policy) and this_policy_setting == 'Not Configured':\n                if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):\n                    element_only_enabled_disabled = False\n                    explicit_enable_disable_value_setting = True\n                if _checkListItem(admx_policy, this_policyname, this_key, DISABLED_LIST_XPATH, policy_file_data):\n                    this_policy_setting = 'Disabled'\n                    log.trace('%s is disabled by detected DISABLED_LIST_XPATH', this_policyname)\n                    if this_policynamespace not in policy_vals:\n                        policy_vals[this_policynamespace] = {}\n                    policy_vals[this_policynamespace][this_policyname] = this_policy_setting\n            if not explicit_enable_disable_value_setting and this_valuename:\n                if search_reg_pol(re.escape(_buildKnownDataSearchString(this_key, this_valuename, 'REG_DWORD', '1')), policy_file_data):\n                    this_policy_setting = 'Enabled'\n                    log.trace('%s is enabled by no explicit enable/disable list or value', this_policyname)\n                    if this_policynamespace not in policy_vals:\n                        policy_vals[this_policynamespace] = {}\n                    policy_vals[this_policynamespace][this_policyname] = this_policy_setting\n                elif search_reg_pol(re.escape(_buildKnownDataSearchString(this_key, this_valuename, 'REG_DWORD', None, check_deleted=True)), policy_file_data):\n                    this_policy_setting = 'Disabled'\n                    log.trace('%s is disabled by no explicit enable/disable list or value', this_policyname)\n                    if this_policynamespace not in policy_vals:\n                        policy_vals[this_policynamespace] = {}\n                    policy_vals[this_policynamespace][this_policyname] = this_policy_setting\n            if ELEMENTS_XPATH(admx_policy):\n                if element_only_enabled_disabled or this_policy_setting == 'Enabled':\n                    required_elements = {}\n                    configured_elements = {}\n                    policy_disabled_elements = 0\n                    for elements_item in ELEMENTS_XPATH(admx_policy):\n                        for child_item in elements_item:\n                            this_element_name = _getFullPolicyName(policy_item=child_item, policy_name=child_item.attrib['id'], return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n                            required_elements[this_element_name] = None\n                            child_key = child_item.attrib.get('key', this_key)\n                            child_valuename = child_item.attrib.get('valueName', this_valuename)\n                            if etree.QName(child_item).localname == 'boolean':\n                                if len(child_item) > 0:\n                                    if TRUE_VALUE_XPATH(child_item) and this_element_name not in configured_elements:\n                                        if _checkValueItemParent(child_item, this_policyname, child_key, child_valuename, TRUE_VALUE_XPATH, policy_file_data):\n                                            configured_elements[this_element_name] = True\n                                            log.trace('element %s is configured true', child_item.attrib['id'])\n                                    if FALSE_VALUE_XPATH(child_item) and this_element_name not in configured_elements:\n                                        if _checkValueItemParent(child_item, this_policyname, child_key, child_valuename, FALSE_VALUE_XPATH, policy_file_data):\n                                            configured_elements[this_element_name] = False\n                                            policy_disabled_elements = policy_disabled_elements + 1\n                                            log.trace('element %s is configured false', child_item.attrib['id'])\n                                    if TRUE_LIST_XPATH(child_item) and this_element_name not in configured_elements:\n                                        log.trace('checking trueList')\n                                        if _checkListItem(child_item, this_policyname, this_key, TRUE_LIST_XPATH, policy_file_data):\n                                            configured_elements[this_element_name] = True\n                                            log.trace('element %s is configured true', child_item.attrib['id'])\n                                    if FALSE_LIST_XPATH(child_item) and this_element_name not in configured_elements:\n                                        log.trace('checking falseList')\n                                        if _checkListItem(child_item, this_policyname, this_key, FALSE_LIST_XPATH, policy_file_data):\n                                            configured_elements[this_element_name] = False\n                                            policy_disabled_elements = policy_disabled_elements + 1\n                                            log.trace('element %s is configured false', child_item.attrib['id'])\n                                elif search_reg_pol(re.escape(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=True)), policy_file_data):\n                                    configured_elements[this_element_name] = False\n                                    policy_disabled_elements = policy_disabled_elements + 1\n                                    log.trace('element %s is configured false', child_item.attrib['id'])\n                                elif search_reg_pol(re.escape(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=False)), policy_file_data):\n                                    configured_elements[this_element_name] = True\n                                    log.trace('element %s is configured true', child_item.attrib['id'])\n                            elif etree.QName(child_item).localname == 'decimal' or etree.QName(child_item).localname == 'text' or etree.QName(child_item).localname == 'longDecimal' or (etree.QName(child_item).localname == 'multiText'):\n                                if search_reg_pol(re.escape(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=True)), policy_file_data):\n                                    configured_elements[this_element_name] = 'Disabled'\n                                    policy_disabled_elements = policy_disabled_elements + 1\n                                    log.trace('element %s is disabled', child_item.attrib['id'])\n                                elif search_reg_pol(re.escape(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=False)), policy_file_data):\n                                    configured_value = _getDataFromRegPolData(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=False), policy_file_data)\n                                    configured_elements[this_element_name] = configured_value\n                                    log.trace('element %s is enabled, value == %s', child_item.attrib['id'], configured_value)\n                            elif etree.QName(child_item).localname == 'enum':\n                                if search_reg_pol(re.escape(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=True)), policy_file_data):\n                                    log.trace('enum element %s is disabled', child_item.attrib['id'])\n                                    configured_elements[this_element_name] = 'Disabled'\n                                    policy_disabled_elements = policy_disabled_elements + 1\n                                else:\n                                    for enum_item in child_item:\n                                        if _checkValueItemParent(enum_item, child_item.attrib['id'], child_key, child_valuename, VALUE_XPATH, policy_file_data):\n                                            if VALUE_LIST_XPATH(enum_item):\n                                                log.trace('enum item has a valueList')\n                                                if _checkListItem(enum_item, this_policyname, child_key, VALUE_LIST_XPATH, policy_file_data):\n                                                    log.trace('all valueList items exist in file')\n                                                    configured_elements[this_element_name] = _getAdmlDisplayName(adml_policy_resources, enum_item.attrib['displayName'])\n                                                    break\n                                            else:\n                                                configured_elements[this_element_name] = _getAdmlDisplayName(adml_policy_resources, enum_item.attrib['displayName'])\n                                                break\n                            elif etree.QName(child_item).localname == 'list':\n                                return_value_name = False\n                                if 'explicitValue' in child_item.attrib and child_item.attrib['explicitValue'].lower() == 'true':\n                                    log.trace('explicitValue list, we will return value names')\n                                    return_value_name = True\n                                regex_str = ['(?!\\\\*', '\\\\*', 'D', 'e', 'l', 'V', 'a', 'l', 's', '\\\\.', ')']\n                                delvals_regex = '\\x00'.join(regex_str)\n                                delvals_regex = salt.utils.stringutils.to_bytes(delvals_regex)\n                                if search_reg_pol(re.escape(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=False)) + delvals_regex, policy_file_data):\n                                    configured_value = _getDataFromRegPolData(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=False), policy_file_data, return_value_name=return_value_name)\n                                    configured_elements[this_element_name] = configured_value\n                                    log.trace('element %s is enabled values: %s', child_item.attrib['id'], configured_value)\n                                elif search_reg_pol(re.escape(_processValueItem(child_item, child_key, child_valuename, admx_policy, elements_item, check_deleted=True)), policy_file_data):\n                                    configured_elements[this_element_name] = 'Disabled'\n                                    policy_disabled_elements = policy_disabled_elements + 1\n                                    log.trace('element %s is disabled', child_item.attrib['id'])\n                    if element_only_enabled_disabled:\n                        if len(required_elements.keys()) > 0 and len(configured_elements.keys()) == len(required_elements.keys()):\n                            if policy_disabled_elements == len(required_elements.keys()):\n                                log.trace('%s is disabled by all enum elements', this_policyname)\n                                if this_policynamespace not in policy_vals:\n                                    policy_vals[this_policynamespace] = {}\n                                policy_vals[this_policynamespace][this_policyname] = 'Disabled'\n                            else:\n                                if this_policynamespace not in policy_vals:\n                                    policy_vals[this_policynamespace] = {}\n                                policy_vals[this_policynamespace][this_policyname] = configured_elements\n                                log.trace('%s is enabled by enum elements', this_policyname)\n                    elif this_policy_setting == 'Enabled':\n                        if this_policynamespace not in policy_vals:\n                            policy_vals[this_policynamespace] = {}\n                        policy_vals[this_policynamespace][this_policyname] = configured_elements\n            if return_full_policy_names and this_policynamespace in policy_vals and (this_policyname in policy_vals[this_policynamespace]):\n                if this_policynamespace not in full_names:\n                    full_names[this_policynamespace] = {}\n                full_names[this_policynamespace][this_policyname] = _getFullPolicyName(policy_item=admx_policy, policy_name=admx_policy.attrib['name'], return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n                if this_policyname in policy_vals[this_policynamespace][this_policyname]:\n                    full_name = full_names[this_policynamespace][this_policyname]\n                    setting = policy_vals[this_policynamespace][this_policyname].pop(this_policyname)\n                    policy_vals[this_policynamespace][this_policyname][full_name] = setting\n            if this_policynamespace in policy_vals and this_policyname in policy_vals[this_policynamespace]:\n                if this_policynamespace not in hierarchy:\n                    hierarchy[this_policynamespace] = {}\n                hierarchy[this_policynamespace][this_policyname] = _build_parent_list(policy_definition=admx_policy, return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n        log.trace('Examination complete: %s seconds', time.time() - start_time)\n    if policy_vals and return_full_policy_names and (not hierarchical_return):\n        log.debug('Compiling non hierarchical return...')\n        start_time = time.time()\n        unpathed_dict = {}\n        pathed_dict = {}\n        for policy_namespace in list(policy_vals):\n            for policy_item in list(policy_vals[policy_namespace]):\n                if full_names[policy_namespace][policy_item] in policy_vals[policy_namespace]:\n                    full_path_list = hierarchy[policy_namespace][policy_item]\n                    full_path_list.reverse()\n                    full_path_list.append(full_names[policy_namespace][policy_item])\n                    policy_vals['\\\\'.join(full_path_list)] = policy_vals[policy_namespace].pop(policy_item)\n                    pathed_dict[full_names[policy_namespace][policy_item]] = True\n                else:\n                    policy_vals[policy_namespace][full_names[policy_namespace][policy_item]] = policy_vals[policy_namespace].pop(policy_item)\n                    if policy_namespace not in unpathed_dict:\n                        unpathed_dict[policy_namespace] = {}\n                    unpathed_dict[policy_namespace][full_names[policy_namespace][policy_item]] = policy_item\n            if policy_namespace in unpathed_dict:\n                for path_needed in unpathed_dict[policy_namespace]:\n                    full_path_list = hierarchy[policy_namespace][unpathed_dict[policy_namespace][path_needed]]\n                    full_path_list.reverse()\n                    full_path_list.append(path_needed)\n                    log.trace('full_path_list == %s', full_path_list)\n                    policy_vals['\\\\'.join(full_path_list)] = policy_vals[policy_namespace].pop(path_needed)\n        log.trace('Compilation complete: %s seconds', time.time() - start_time)\n    for policy_namespace in list(policy_vals):\n        if policy_vals[policy_namespace] == {}:\n            policy_vals.pop(policy_namespace)\n    if policy_vals and hierarchical_return:\n        if hierarchy:\n            log.debug('Compiling hierarchical return...')\n            start_time = time.time()\n            for policy_namespace in hierarchy:\n                for hierarchy_item in hierarchy[policy_namespace]:\n                    if hierarchy_item in policy_vals[policy_namespace]:\n                        tdict = {}\n                        first_item = True\n                        for item in hierarchy[policy_namespace][hierarchy_item]:\n                            newdict = {}\n                            if first_item:\n                                h_policy_name = hierarchy_item\n                                if return_full_policy_names:\n                                    h_policy_name = full_names[policy_namespace][hierarchy_item]\n                                newdict[item] = {h_policy_name: policy_vals[policy_namespace].pop(hierarchy_item)}\n                                first_item = False\n                            else:\n                                newdict[item] = tdict\n                            tdict = newdict\n                        if tdict:\n                            policy_vals = dictupdate.update(policy_vals, tdict)\n                if policy_namespace in policy_vals and policy_vals[policy_namespace] == {}:\n                    policy_vals.pop(policy_namespace)\n            log.trace('Compilation complete: %s seconds', time.time() - start_time)\n        policy_vals = {CLASS_INFO[policy_class]['lgpo_section']: {'Administrative Templates': policy_vals}}\n    return policy_vals"
        ]
    },
    {
        "func_name": "_build_parent_list",
        "original": "def _build_parent_list(policy_definition, return_full_policy_names, adml_language):\n    \"\"\"\n    helper function to build a list containing parent elements of the ADMX\n    policy\n    \"\"\"\n    parent_list = []\n    policy_namespace = next(iter(policy_definition.nsmap))\n    parent_category = policy_definition.xpath(f'{policy_namespace}:parentCategory/@ref', namespaces=policy_definition.nsmap)\n    admx_policy_definitions = _get_policy_definitions(language=adml_language)\n    if parent_category:\n        parent_category = parent_category[0]\n        nsmap_xpath = '/policyDefinitions/policyNamespaces/{}:*'.format(policy_namespace)\n        this_namespace_map = _buildElementNsmap(admx_policy_definitions.xpath(nsmap_xpath, namespaces=policy_definition.nsmap))\n        this_namespace_map = dictupdate.update(this_namespace_map, policy_definition.nsmap)\n        parent_list = _admx_policy_parent_walk(path=parent_list, policy_namespace=policy_namespace, parent_category=parent_category, policy_nsmap=this_namespace_map, return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n    return parent_list",
        "mutated": [
            "def _build_parent_list(policy_definition, return_full_policy_names, adml_language):\n    if False:\n        i = 10\n    '\\n    helper function to build a list containing parent elements of the ADMX\\n    policy\\n    '\n    parent_list = []\n    policy_namespace = next(iter(policy_definition.nsmap))\n    parent_category = policy_definition.xpath(f'{policy_namespace}:parentCategory/@ref', namespaces=policy_definition.nsmap)\n    admx_policy_definitions = _get_policy_definitions(language=adml_language)\n    if parent_category:\n        parent_category = parent_category[0]\n        nsmap_xpath = '/policyDefinitions/policyNamespaces/{}:*'.format(policy_namespace)\n        this_namespace_map = _buildElementNsmap(admx_policy_definitions.xpath(nsmap_xpath, namespaces=policy_definition.nsmap))\n        this_namespace_map = dictupdate.update(this_namespace_map, policy_definition.nsmap)\n        parent_list = _admx_policy_parent_walk(path=parent_list, policy_namespace=policy_namespace, parent_category=parent_category, policy_nsmap=this_namespace_map, return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n    return parent_list",
            "def _build_parent_list(policy_definition, return_full_policy_names, adml_language):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    helper function to build a list containing parent elements of the ADMX\\n    policy\\n    '\n    parent_list = []\n    policy_namespace = next(iter(policy_definition.nsmap))\n    parent_category = policy_definition.xpath(f'{policy_namespace}:parentCategory/@ref', namespaces=policy_definition.nsmap)\n    admx_policy_definitions = _get_policy_definitions(language=adml_language)\n    if parent_category:\n        parent_category = parent_category[0]\n        nsmap_xpath = '/policyDefinitions/policyNamespaces/{}:*'.format(policy_namespace)\n        this_namespace_map = _buildElementNsmap(admx_policy_definitions.xpath(nsmap_xpath, namespaces=policy_definition.nsmap))\n        this_namespace_map = dictupdate.update(this_namespace_map, policy_definition.nsmap)\n        parent_list = _admx_policy_parent_walk(path=parent_list, policy_namespace=policy_namespace, parent_category=parent_category, policy_nsmap=this_namespace_map, return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n    return parent_list",
            "def _build_parent_list(policy_definition, return_full_policy_names, adml_language):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    helper function to build a list containing parent elements of the ADMX\\n    policy\\n    '\n    parent_list = []\n    policy_namespace = next(iter(policy_definition.nsmap))\n    parent_category = policy_definition.xpath(f'{policy_namespace}:parentCategory/@ref', namespaces=policy_definition.nsmap)\n    admx_policy_definitions = _get_policy_definitions(language=adml_language)\n    if parent_category:\n        parent_category = parent_category[0]\n        nsmap_xpath = '/policyDefinitions/policyNamespaces/{}:*'.format(policy_namespace)\n        this_namespace_map = _buildElementNsmap(admx_policy_definitions.xpath(nsmap_xpath, namespaces=policy_definition.nsmap))\n        this_namespace_map = dictupdate.update(this_namespace_map, policy_definition.nsmap)\n        parent_list = _admx_policy_parent_walk(path=parent_list, policy_namespace=policy_namespace, parent_category=parent_category, policy_nsmap=this_namespace_map, return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n    return parent_list",
            "def _build_parent_list(policy_definition, return_full_policy_names, adml_language):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    helper function to build a list containing parent elements of the ADMX\\n    policy\\n    '\n    parent_list = []\n    policy_namespace = next(iter(policy_definition.nsmap))\n    parent_category = policy_definition.xpath(f'{policy_namespace}:parentCategory/@ref', namespaces=policy_definition.nsmap)\n    admx_policy_definitions = _get_policy_definitions(language=adml_language)\n    if parent_category:\n        parent_category = parent_category[0]\n        nsmap_xpath = '/policyDefinitions/policyNamespaces/{}:*'.format(policy_namespace)\n        this_namespace_map = _buildElementNsmap(admx_policy_definitions.xpath(nsmap_xpath, namespaces=policy_definition.nsmap))\n        this_namespace_map = dictupdate.update(this_namespace_map, policy_definition.nsmap)\n        parent_list = _admx_policy_parent_walk(path=parent_list, policy_namespace=policy_namespace, parent_category=parent_category, policy_nsmap=this_namespace_map, return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n    return parent_list",
            "def _build_parent_list(policy_definition, return_full_policy_names, adml_language):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    helper function to build a list containing parent elements of the ADMX\\n    policy\\n    '\n    parent_list = []\n    policy_namespace = next(iter(policy_definition.nsmap))\n    parent_category = policy_definition.xpath(f'{policy_namespace}:parentCategory/@ref', namespaces=policy_definition.nsmap)\n    admx_policy_definitions = _get_policy_definitions(language=adml_language)\n    if parent_category:\n        parent_category = parent_category[0]\n        nsmap_xpath = '/policyDefinitions/policyNamespaces/{}:*'.format(policy_namespace)\n        this_namespace_map = _buildElementNsmap(admx_policy_definitions.xpath(nsmap_xpath, namespaces=policy_definition.nsmap))\n        this_namespace_map = dictupdate.update(this_namespace_map, policy_definition.nsmap)\n        parent_list = _admx_policy_parent_walk(path=parent_list, policy_namespace=policy_namespace, parent_category=parent_category, policy_nsmap=this_namespace_map, return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n    return parent_list"
        ]
    },
    {
        "func_name": "_admx_policy_parent_walk",
        "original": "def _admx_policy_parent_walk(path, policy_namespace, parent_category, policy_nsmap, return_full_policy_names, adml_language):\n    \"\"\"\n    helper function to recursively walk up the ADMX namespaces and build the\n    hierarchy for the policy\n    \"\"\"\n    admx_policy_definitions = _get_policy_definitions(language=adml_language)\n    category_xpath_string = '/policyDefinitions/categories/{}:category[@name=\"{}\"]'\n    using_xpath_string = '/policyDefinitions/policyNamespaces/{}:using'\n    if parent_category.find(':') >= 0:\n        policy_namespace = parent_category.split(':')[0]\n        parent_category = parent_category.split(':')[1]\n        using_xpath_string = using_xpath_string.format(policy_namespace)\n        policy_nsmap = dictupdate.update(policy_nsmap, _buildElementNsmap(admx_policy_definitions.xpath(using_xpath_string, namespaces=policy_nsmap)))\n    category_xpath_string = category_xpath_string.format(policy_namespace, parent_category)\n    if admx_policy_definitions.xpath(category_xpath_string, namespaces=policy_nsmap):\n        tparent_category = admx_policy_definitions.xpath(category_xpath_string, namespaces=policy_nsmap)[0]\n        this_parent_name = _getFullPolicyName(policy_item=tparent_category, policy_name=tparent_category.attrib['name'], return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n        path.append(this_parent_name)\n        if tparent_category.xpath(f'{policy_namespace}:parentCategory/@ref', namespaces=policy_nsmap):\n            path = _admx_policy_parent_walk(path=path, policy_namespace=policy_namespace, parent_category=tparent_category.xpath(f'{policy_namespace}:parentCategory/@ref', namespaces=policy_nsmap)[0], policy_nsmap=policy_nsmap, return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n    return path",
        "mutated": [
            "def _admx_policy_parent_walk(path, policy_namespace, parent_category, policy_nsmap, return_full_policy_names, adml_language):\n    if False:\n        i = 10\n    '\\n    helper function to recursively walk up the ADMX namespaces and build the\\n    hierarchy for the policy\\n    '\n    admx_policy_definitions = _get_policy_definitions(language=adml_language)\n    category_xpath_string = '/policyDefinitions/categories/{}:category[@name=\"{}\"]'\n    using_xpath_string = '/policyDefinitions/policyNamespaces/{}:using'\n    if parent_category.find(':') >= 0:\n        policy_namespace = parent_category.split(':')[0]\n        parent_category = parent_category.split(':')[1]\n        using_xpath_string = using_xpath_string.format(policy_namespace)\n        policy_nsmap = dictupdate.update(policy_nsmap, _buildElementNsmap(admx_policy_definitions.xpath(using_xpath_string, namespaces=policy_nsmap)))\n    category_xpath_string = category_xpath_string.format(policy_namespace, parent_category)\n    if admx_policy_definitions.xpath(category_xpath_string, namespaces=policy_nsmap):\n        tparent_category = admx_policy_definitions.xpath(category_xpath_string, namespaces=policy_nsmap)[0]\n        this_parent_name = _getFullPolicyName(policy_item=tparent_category, policy_name=tparent_category.attrib['name'], return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n        path.append(this_parent_name)\n        if tparent_category.xpath(f'{policy_namespace}:parentCategory/@ref', namespaces=policy_nsmap):\n            path = _admx_policy_parent_walk(path=path, policy_namespace=policy_namespace, parent_category=tparent_category.xpath(f'{policy_namespace}:parentCategory/@ref', namespaces=policy_nsmap)[0], policy_nsmap=policy_nsmap, return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n    return path",
            "def _admx_policy_parent_walk(path, policy_namespace, parent_category, policy_nsmap, return_full_policy_names, adml_language):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    helper function to recursively walk up the ADMX namespaces and build the\\n    hierarchy for the policy\\n    '\n    admx_policy_definitions = _get_policy_definitions(language=adml_language)\n    category_xpath_string = '/policyDefinitions/categories/{}:category[@name=\"{}\"]'\n    using_xpath_string = '/policyDefinitions/policyNamespaces/{}:using'\n    if parent_category.find(':') >= 0:\n        policy_namespace = parent_category.split(':')[0]\n        parent_category = parent_category.split(':')[1]\n        using_xpath_string = using_xpath_string.format(policy_namespace)\n        policy_nsmap = dictupdate.update(policy_nsmap, _buildElementNsmap(admx_policy_definitions.xpath(using_xpath_string, namespaces=policy_nsmap)))\n    category_xpath_string = category_xpath_string.format(policy_namespace, parent_category)\n    if admx_policy_definitions.xpath(category_xpath_string, namespaces=policy_nsmap):\n        tparent_category = admx_policy_definitions.xpath(category_xpath_string, namespaces=policy_nsmap)[0]\n        this_parent_name = _getFullPolicyName(policy_item=tparent_category, policy_name=tparent_category.attrib['name'], return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n        path.append(this_parent_name)\n        if tparent_category.xpath(f'{policy_namespace}:parentCategory/@ref', namespaces=policy_nsmap):\n            path = _admx_policy_parent_walk(path=path, policy_namespace=policy_namespace, parent_category=tparent_category.xpath(f'{policy_namespace}:parentCategory/@ref', namespaces=policy_nsmap)[0], policy_nsmap=policy_nsmap, return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n    return path",
            "def _admx_policy_parent_walk(path, policy_namespace, parent_category, policy_nsmap, return_full_policy_names, adml_language):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    helper function to recursively walk up the ADMX namespaces and build the\\n    hierarchy for the policy\\n    '\n    admx_policy_definitions = _get_policy_definitions(language=adml_language)\n    category_xpath_string = '/policyDefinitions/categories/{}:category[@name=\"{}\"]'\n    using_xpath_string = '/policyDefinitions/policyNamespaces/{}:using'\n    if parent_category.find(':') >= 0:\n        policy_namespace = parent_category.split(':')[0]\n        parent_category = parent_category.split(':')[1]\n        using_xpath_string = using_xpath_string.format(policy_namespace)\n        policy_nsmap = dictupdate.update(policy_nsmap, _buildElementNsmap(admx_policy_definitions.xpath(using_xpath_string, namespaces=policy_nsmap)))\n    category_xpath_string = category_xpath_string.format(policy_namespace, parent_category)\n    if admx_policy_definitions.xpath(category_xpath_string, namespaces=policy_nsmap):\n        tparent_category = admx_policy_definitions.xpath(category_xpath_string, namespaces=policy_nsmap)[0]\n        this_parent_name = _getFullPolicyName(policy_item=tparent_category, policy_name=tparent_category.attrib['name'], return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n        path.append(this_parent_name)\n        if tparent_category.xpath(f'{policy_namespace}:parentCategory/@ref', namespaces=policy_nsmap):\n            path = _admx_policy_parent_walk(path=path, policy_namespace=policy_namespace, parent_category=tparent_category.xpath(f'{policy_namespace}:parentCategory/@ref', namespaces=policy_nsmap)[0], policy_nsmap=policy_nsmap, return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n    return path",
            "def _admx_policy_parent_walk(path, policy_namespace, parent_category, policy_nsmap, return_full_policy_names, adml_language):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    helper function to recursively walk up the ADMX namespaces and build the\\n    hierarchy for the policy\\n    '\n    admx_policy_definitions = _get_policy_definitions(language=adml_language)\n    category_xpath_string = '/policyDefinitions/categories/{}:category[@name=\"{}\"]'\n    using_xpath_string = '/policyDefinitions/policyNamespaces/{}:using'\n    if parent_category.find(':') >= 0:\n        policy_namespace = parent_category.split(':')[0]\n        parent_category = parent_category.split(':')[1]\n        using_xpath_string = using_xpath_string.format(policy_namespace)\n        policy_nsmap = dictupdate.update(policy_nsmap, _buildElementNsmap(admx_policy_definitions.xpath(using_xpath_string, namespaces=policy_nsmap)))\n    category_xpath_string = category_xpath_string.format(policy_namespace, parent_category)\n    if admx_policy_definitions.xpath(category_xpath_string, namespaces=policy_nsmap):\n        tparent_category = admx_policy_definitions.xpath(category_xpath_string, namespaces=policy_nsmap)[0]\n        this_parent_name = _getFullPolicyName(policy_item=tparent_category, policy_name=tparent_category.attrib['name'], return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n        path.append(this_parent_name)\n        if tparent_category.xpath(f'{policy_namespace}:parentCategory/@ref', namespaces=policy_nsmap):\n            path = _admx_policy_parent_walk(path=path, policy_namespace=policy_namespace, parent_category=tparent_category.xpath(f'{policy_namespace}:parentCategory/@ref', namespaces=policy_nsmap)[0], policy_nsmap=policy_nsmap, return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n    return path",
            "def _admx_policy_parent_walk(path, policy_namespace, parent_category, policy_nsmap, return_full_policy_names, adml_language):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    helper function to recursively walk up the ADMX namespaces and build the\\n    hierarchy for the policy\\n    '\n    admx_policy_definitions = _get_policy_definitions(language=adml_language)\n    category_xpath_string = '/policyDefinitions/categories/{}:category[@name=\"{}\"]'\n    using_xpath_string = '/policyDefinitions/policyNamespaces/{}:using'\n    if parent_category.find(':') >= 0:\n        policy_namespace = parent_category.split(':')[0]\n        parent_category = parent_category.split(':')[1]\n        using_xpath_string = using_xpath_string.format(policy_namespace)\n        policy_nsmap = dictupdate.update(policy_nsmap, _buildElementNsmap(admx_policy_definitions.xpath(using_xpath_string, namespaces=policy_nsmap)))\n    category_xpath_string = category_xpath_string.format(policy_namespace, parent_category)\n    if admx_policy_definitions.xpath(category_xpath_string, namespaces=policy_nsmap):\n        tparent_category = admx_policy_definitions.xpath(category_xpath_string, namespaces=policy_nsmap)[0]\n        this_parent_name = _getFullPolicyName(policy_item=tparent_category, policy_name=tparent_category.attrib['name'], return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n        path.append(this_parent_name)\n        if tparent_category.xpath(f'{policy_namespace}:parentCategory/@ref', namespaces=policy_nsmap):\n            path = _admx_policy_parent_walk(path=path, policy_namespace=policy_namespace, parent_category=tparent_category.xpath(f'{policy_namespace}:parentCategory/@ref', namespaces=policy_nsmap)[0], policy_nsmap=policy_nsmap, return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n    return path"
        ]
    },
    {
        "func_name": "_regexSearchKeyValueCombo",
        "original": "def _regexSearchKeyValueCombo(policy_data, policy_regpath, policy_regkey):\n    \"\"\"\n    helper function to do a search of Policy data from a registry.pol file\n    for a policy_regpath and policy_regkey combo\n    \"\"\"\n    if policy_data:\n        regex_str = ['(\\\\*', '\\\\*', 'D', 'e', 'l', '\\\\.', '|\\\\*', '\\\\*', 'D', 'e', 'l', 'V', 'a', 'l', 's', '\\\\.', '){0,1}']\n        specialValueRegex = '\\x00'.join(regex_str)\n        specialValueRegex = salt.utils.stringutils.to_bytes(specialValueRegex)\n        _thisSearch = b''.join([salt.utils.stringutils.to_bytes('\\\\['), re.escape(policy_regpath), b'\\x00;\\x00', specialValueRegex, re.escape(policy_regkey.lstrip(b'\\x00')), b'\\x00;'])\n        match = re.search(_thisSearch, policy_data, re.IGNORECASE)\n        if match:\n            return policy_data[match.start():policy_data.index(b']', match.end()) + 2]\n    return None",
        "mutated": [
            "def _regexSearchKeyValueCombo(policy_data, policy_regpath, policy_regkey):\n    if False:\n        i = 10\n    '\\n    helper function to do a search of Policy data from a registry.pol file\\n    for a policy_regpath and policy_regkey combo\\n    '\n    if policy_data:\n        regex_str = ['(\\\\*', '\\\\*', 'D', 'e', 'l', '\\\\.', '|\\\\*', '\\\\*', 'D', 'e', 'l', 'V', 'a', 'l', 's', '\\\\.', '){0,1}']\n        specialValueRegex = '\\x00'.join(regex_str)\n        specialValueRegex = salt.utils.stringutils.to_bytes(specialValueRegex)\n        _thisSearch = b''.join([salt.utils.stringutils.to_bytes('\\\\['), re.escape(policy_regpath), b'\\x00;\\x00', specialValueRegex, re.escape(policy_regkey.lstrip(b'\\x00')), b'\\x00;'])\n        match = re.search(_thisSearch, policy_data, re.IGNORECASE)\n        if match:\n            return policy_data[match.start():policy_data.index(b']', match.end()) + 2]\n    return None",
            "def _regexSearchKeyValueCombo(policy_data, policy_regpath, policy_regkey):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    helper function to do a search of Policy data from a registry.pol file\\n    for a policy_regpath and policy_regkey combo\\n    '\n    if policy_data:\n        regex_str = ['(\\\\*', '\\\\*', 'D', 'e', 'l', '\\\\.', '|\\\\*', '\\\\*', 'D', 'e', 'l', 'V', 'a', 'l', 's', '\\\\.', '){0,1}']\n        specialValueRegex = '\\x00'.join(regex_str)\n        specialValueRegex = salt.utils.stringutils.to_bytes(specialValueRegex)\n        _thisSearch = b''.join([salt.utils.stringutils.to_bytes('\\\\['), re.escape(policy_regpath), b'\\x00;\\x00', specialValueRegex, re.escape(policy_regkey.lstrip(b'\\x00')), b'\\x00;'])\n        match = re.search(_thisSearch, policy_data, re.IGNORECASE)\n        if match:\n            return policy_data[match.start():policy_data.index(b']', match.end()) + 2]\n    return None",
            "def _regexSearchKeyValueCombo(policy_data, policy_regpath, policy_regkey):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    helper function to do a search of Policy data from a registry.pol file\\n    for a policy_regpath and policy_regkey combo\\n    '\n    if policy_data:\n        regex_str = ['(\\\\*', '\\\\*', 'D', 'e', 'l', '\\\\.', '|\\\\*', '\\\\*', 'D', 'e', 'l', 'V', 'a', 'l', 's', '\\\\.', '){0,1}']\n        specialValueRegex = '\\x00'.join(regex_str)\n        specialValueRegex = salt.utils.stringutils.to_bytes(specialValueRegex)\n        _thisSearch = b''.join([salt.utils.stringutils.to_bytes('\\\\['), re.escape(policy_regpath), b'\\x00;\\x00', specialValueRegex, re.escape(policy_regkey.lstrip(b'\\x00')), b'\\x00;'])\n        match = re.search(_thisSearch, policy_data, re.IGNORECASE)\n        if match:\n            return policy_data[match.start():policy_data.index(b']', match.end()) + 2]\n    return None",
            "def _regexSearchKeyValueCombo(policy_data, policy_regpath, policy_regkey):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    helper function to do a search of Policy data from a registry.pol file\\n    for a policy_regpath and policy_regkey combo\\n    '\n    if policy_data:\n        regex_str = ['(\\\\*', '\\\\*', 'D', 'e', 'l', '\\\\.', '|\\\\*', '\\\\*', 'D', 'e', 'l', 'V', 'a', 'l', 's', '\\\\.', '){0,1}']\n        specialValueRegex = '\\x00'.join(regex_str)\n        specialValueRegex = salt.utils.stringutils.to_bytes(specialValueRegex)\n        _thisSearch = b''.join([salt.utils.stringutils.to_bytes('\\\\['), re.escape(policy_regpath), b'\\x00;\\x00', specialValueRegex, re.escape(policy_regkey.lstrip(b'\\x00')), b'\\x00;'])\n        match = re.search(_thisSearch, policy_data, re.IGNORECASE)\n        if match:\n            return policy_data[match.start():policy_data.index(b']', match.end()) + 2]\n    return None",
            "def _regexSearchKeyValueCombo(policy_data, policy_regpath, policy_regkey):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    helper function to do a search of Policy data from a registry.pol file\\n    for a policy_regpath and policy_regkey combo\\n    '\n    if policy_data:\n        regex_str = ['(\\\\*', '\\\\*', 'D', 'e', 'l', '\\\\.', '|\\\\*', '\\\\*', 'D', 'e', 'l', 'V', 'a', 'l', 's', '\\\\.', '){0,1}']\n        specialValueRegex = '\\x00'.join(regex_str)\n        specialValueRegex = salt.utils.stringutils.to_bytes(specialValueRegex)\n        _thisSearch = b''.join([salt.utils.stringutils.to_bytes('\\\\['), re.escape(policy_regpath), b'\\x00;\\x00', specialValueRegex, re.escape(policy_regkey.lstrip(b'\\x00')), b'\\x00;'])\n        match = re.search(_thisSearch, policy_data, re.IGNORECASE)\n        if match:\n            return policy_data[match.start():policy_data.index(b']', match.end()) + 2]\n    return None"
        ]
    },
    {
        "func_name": "_policyFileReplaceOrAppendList",
        "original": "def _policyFileReplaceOrAppendList(string_list, policy_data):\n    \"\"\"\n    helper function to take a list of strings for registry.pol file data and\n    update existing strings or append the strings\n    \"\"\"\n    if not policy_data:\n        policy_data = b''\n    specialValueRegex = salt.utils.stringutils.to_bytes('(\\\\*\\\\*Del\\\\.|\\\\*\\\\*DelVals\\\\.){0,1}')\n    for this_string in string_list:\n        list_item_key = this_string.split(b'\\x00;')[0].lstrip(b'[')\n        list_item_value_name = re.sub(specialValueRegex, b'', this_string.split(b'\\x00;')[1], flags=re.IGNORECASE)\n        log.trace('item value name is %s', list_item_value_name)\n        data_to_replace = _regexSearchKeyValueCombo(policy_data, list_item_key, list_item_value_name)\n        if data_to_replace:\n            log.trace('replacing %s with %s', data_to_replace, this_string)\n            policy_data = policy_data.replace(data_to_replace, this_string)\n        else:\n            log.trace('appending %s', this_string)\n            policy_data = b''.join([policy_data, this_string])\n    return policy_data",
        "mutated": [
            "def _policyFileReplaceOrAppendList(string_list, policy_data):\n    if False:\n        i = 10\n    '\\n    helper function to take a list of strings for registry.pol file data and\\n    update existing strings or append the strings\\n    '\n    if not policy_data:\n        policy_data = b''\n    specialValueRegex = salt.utils.stringutils.to_bytes('(\\\\*\\\\*Del\\\\.|\\\\*\\\\*DelVals\\\\.){0,1}')\n    for this_string in string_list:\n        list_item_key = this_string.split(b'\\x00;')[0].lstrip(b'[')\n        list_item_value_name = re.sub(specialValueRegex, b'', this_string.split(b'\\x00;')[1], flags=re.IGNORECASE)\n        log.trace('item value name is %s', list_item_value_name)\n        data_to_replace = _regexSearchKeyValueCombo(policy_data, list_item_key, list_item_value_name)\n        if data_to_replace:\n            log.trace('replacing %s with %s', data_to_replace, this_string)\n            policy_data = policy_data.replace(data_to_replace, this_string)\n        else:\n            log.trace('appending %s', this_string)\n            policy_data = b''.join([policy_data, this_string])\n    return policy_data",
            "def _policyFileReplaceOrAppendList(string_list, policy_data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    helper function to take a list of strings for registry.pol file data and\\n    update existing strings or append the strings\\n    '\n    if not policy_data:\n        policy_data = b''\n    specialValueRegex = salt.utils.stringutils.to_bytes('(\\\\*\\\\*Del\\\\.|\\\\*\\\\*DelVals\\\\.){0,1}')\n    for this_string in string_list:\n        list_item_key = this_string.split(b'\\x00;')[0].lstrip(b'[')\n        list_item_value_name = re.sub(specialValueRegex, b'', this_string.split(b'\\x00;')[1], flags=re.IGNORECASE)\n        log.trace('item value name is %s', list_item_value_name)\n        data_to_replace = _regexSearchKeyValueCombo(policy_data, list_item_key, list_item_value_name)\n        if data_to_replace:\n            log.trace('replacing %s with %s', data_to_replace, this_string)\n            policy_data = policy_data.replace(data_to_replace, this_string)\n        else:\n            log.trace('appending %s', this_string)\n            policy_data = b''.join([policy_data, this_string])\n    return policy_data",
            "def _policyFileReplaceOrAppendList(string_list, policy_data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    helper function to take a list of strings for registry.pol file data and\\n    update existing strings or append the strings\\n    '\n    if not policy_data:\n        policy_data = b''\n    specialValueRegex = salt.utils.stringutils.to_bytes('(\\\\*\\\\*Del\\\\.|\\\\*\\\\*DelVals\\\\.){0,1}')\n    for this_string in string_list:\n        list_item_key = this_string.split(b'\\x00;')[0].lstrip(b'[')\n        list_item_value_name = re.sub(specialValueRegex, b'', this_string.split(b'\\x00;')[1], flags=re.IGNORECASE)\n        log.trace('item value name is %s', list_item_value_name)\n        data_to_replace = _regexSearchKeyValueCombo(policy_data, list_item_key, list_item_value_name)\n        if data_to_replace:\n            log.trace('replacing %s with %s', data_to_replace, this_string)\n            policy_data = policy_data.replace(data_to_replace, this_string)\n        else:\n            log.trace('appending %s', this_string)\n            policy_data = b''.join([policy_data, this_string])\n    return policy_data",
            "def _policyFileReplaceOrAppendList(string_list, policy_data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    helper function to take a list of strings for registry.pol file data and\\n    update existing strings or append the strings\\n    '\n    if not policy_data:\n        policy_data = b''\n    specialValueRegex = salt.utils.stringutils.to_bytes('(\\\\*\\\\*Del\\\\.|\\\\*\\\\*DelVals\\\\.){0,1}')\n    for this_string in string_list:\n        list_item_key = this_string.split(b'\\x00;')[0].lstrip(b'[')\n        list_item_value_name = re.sub(specialValueRegex, b'', this_string.split(b'\\x00;')[1], flags=re.IGNORECASE)\n        log.trace('item value name is %s', list_item_value_name)\n        data_to_replace = _regexSearchKeyValueCombo(policy_data, list_item_key, list_item_value_name)\n        if data_to_replace:\n            log.trace('replacing %s with %s', data_to_replace, this_string)\n            policy_data = policy_data.replace(data_to_replace, this_string)\n        else:\n            log.trace('appending %s', this_string)\n            policy_data = b''.join([policy_data, this_string])\n    return policy_data",
            "def _policyFileReplaceOrAppendList(string_list, policy_data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    helper function to take a list of strings for registry.pol file data and\\n    update existing strings or append the strings\\n    '\n    if not policy_data:\n        policy_data = b''\n    specialValueRegex = salt.utils.stringutils.to_bytes('(\\\\*\\\\*Del\\\\.|\\\\*\\\\*DelVals\\\\.){0,1}')\n    for this_string in string_list:\n        list_item_key = this_string.split(b'\\x00;')[0].lstrip(b'[')\n        list_item_value_name = re.sub(specialValueRegex, b'', this_string.split(b'\\x00;')[1], flags=re.IGNORECASE)\n        log.trace('item value name is %s', list_item_value_name)\n        data_to_replace = _regexSearchKeyValueCombo(policy_data, list_item_key, list_item_value_name)\n        if data_to_replace:\n            log.trace('replacing %s with %s', data_to_replace, this_string)\n            policy_data = policy_data.replace(data_to_replace, this_string)\n        else:\n            log.trace('appending %s', this_string)\n            policy_data = b''.join([policy_data, this_string])\n    return policy_data"
        ]
    },
    {
        "func_name": "_policyFileReplaceOrAppend",
        "original": "def _policyFileReplaceOrAppend(this_string, policy_data, append_only=False):\n    \"\"\"\n    helper function to take a ADMX policy string for registry.pol file data and\n    update existing string or append the string to the data\n    \"\"\"\n    if not policy_data:\n        policy_data = b''\n    specialValueRegex = salt.utils.stringutils.to_bytes('(\\\\*\\\\*Del\\\\.|\\\\*\\\\*DelVals\\\\.){0,1}')\n    data_to_replace = None\n    if not append_only:\n        item_key = this_string.split(b'\\x00;')[0].lstrip(b'[')\n        item_value_name = re.sub(specialValueRegex, b'', this_string.split(b'\\x00;')[1], flags=re.IGNORECASE)\n        log.trace('item value name is %s', item_value_name)\n        data_to_replace = _regexSearchKeyValueCombo(policy_data, item_key, item_value_name)\n    if data_to_replace:\n        log.trace('replacing %s with %s', data_to_replace, this_string)\n        policy_data = policy_data.replace(data_to_replace, this_string)\n    else:\n        log.trace('appending %s', this_string)\n        policy_data = b''.join([policy_data, this_string])\n    return policy_data",
        "mutated": [
            "def _policyFileReplaceOrAppend(this_string, policy_data, append_only=False):\n    if False:\n        i = 10\n    '\\n    helper function to take a ADMX policy string for registry.pol file data and\\n    update existing string or append the string to the data\\n    '\n    if not policy_data:\n        policy_data = b''\n    specialValueRegex = salt.utils.stringutils.to_bytes('(\\\\*\\\\*Del\\\\.|\\\\*\\\\*DelVals\\\\.){0,1}')\n    data_to_replace = None\n    if not append_only:\n        item_key = this_string.split(b'\\x00;')[0].lstrip(b'[')\n        item_value_name = re.sub(specialValueRegex, b'', this_string.split(b'\\x00;')[1], flags=re.IGNORECASE)\n        log.trace('item value name is %s', item_value_name)\n        data_to_replace = _regexSearchKeyValueCombo(policy_data, item_key, item_value_name)\n    if data_to_replace:\n        log.trace('replacing %s with %s', data_to_replace, this_string)\n        policy_data = policy_data.replace(data_to_replace, this_string)\n    else:\n        log.trace('appending %s', this_string)\n        policy_data = b''.join([policy_data, this_string])\n    return policy_data",
            "def _policyFileReplaceOrAppend(this_string, policy_data, append_only=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    helper function to take a ADMX policy string for registry.pol file data and\\n    update existing string or append the string to the data\\n    '\n    if not policy_data:\n        policy_data = b''\n    specialValueRegex = salt.utils.stringutils.to_bytes('(\\\\*\\\\*Del\\\\.|\\\\*\\\\*DelVals\\\\.){0,1}')\n    data_to_replace = None\n    if not append_only:\n        item_key = this_string.split(b'\\x00;')[0].lstrip(b'[')\n        item_value_name = re.sub(specialValueRegex, b'', this_string.split(b'\\x00;')[1], flags=re.IGNORECASE)\n        log.trace('item value name is %s', item_value_name)\n        data_to_replace = _regexSearchKeyValueCombo(policy_data, item_key, item_value_name)\n    if data_to_replace:\n        log.trace('replacing %s with %s', data_to_replace, this_string)\n        policy_data = policy_data.replace(data_to_replace, this_string)\n    else:\n        log.trace('appending %s', this_string)\n        policy_data = b''.join([policy_data, this_string])\n    return policy_data",
            "def _policyFileReplaceOrAppend(this_string, policy_data, append_only=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    helper function to take a ADMX policy string for registry.pol file data and\\n    update existing string or append the string to the data\\n    '\n    if not policy_data:\n        policy_data = b''\n    specialValueRegex = salt.utils.stringutils.to_bytes('(\\\\*\\\\*Del\\\\.|\\\\*\\\\*DelVals\\\\.){0,1}')\n    data_to_replace = None\n    if not append_only:\n        item_key = this_string.split(b'\\x00;')[0].lstrip(b'[')\n        item_value_name = re.sub(specialValueRegex, b'', this_string.split(b'\\x00;')[1], flags=re.IGNORECASE)\n        log.trace('item value name is %s', item_value_name)\n        data_to_replace = _regexSearchKeyValueCombo(policy_data, item_key, item_value_name)\n    if data_to_replace:\n        log.trace('replacing %s with %s', data_to_replace, this_string)\n        policy_data = policy_data.replace(data_to_replace, this_string)\n    else:\n        log.trace('appending %s', this_string)\n        policy_data = b''.join([policy_data, this_string])\n    return policy_data",
            "def _policyFileReplaceOrAppend(this_string, policy_data, append_only=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    helper function to take a ADMX policy string for registry.pol file data and\\n    update existing string or append the string to the data\\n    '\n    if not policy_data:\n        policy_data = b''\n    specialValueRegex = salt.utils.stringutils.to_bytes('(\\\\*\\\\*Del\\\\.|\\\\*\\\\*DelVals\\\\.){0,1}')\n    data_to_replace = None\n    if not append_only:\n        item_key = this_string.split(b'\\x00;')[0].lstrip(b'[')\n        item_value_name = re.sub(specialValueRegex, b'', this_string.split(b'\\x00;')[1], flags=re.IGNORECASE)\n        log.trace('item value name is %s', item_value_name)\n        data_to_replace = _regexSearchKeyValueCombo(policy_data, item_key, item_value_name)\n    if data_to_replace:\n        log.trace('replacing %s with %s', data_to_replace, this_string)\n        policy_data = policy_data.replace(data_to_replace, this_string)\n    else:\n        log.trace('appending %s', this_string)\n        policy_data = b''.join([policy_data, this_string])\n    return policy_data",
            "def _policyFileReplaceOrAppend(this_string, policy_data, append_only=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    helper function to take a ADMX policy string for registry.pol file data and\\n    update existing string or append the string to the data\\n    '\n    if not policy_data:\n        policy_data = b''\n    specialValueRegex = salt.utils.stringutils.to_bytes('(\\\\*\\\\*Del\\\\.|\\\\*\\\\*DelVals\\\\.){0,1}')\n    data_to_replace = None\n    if not append_only:\n        item_key = this_string.split(b'\\x00;')[0].lstrip(b'[')\n        item_value_name = re.sub(specialValueRegex, b'', this_string.split(b'\\x00;')[1], flags=re.IGNORECASE)\n        log.trace('item value name is %s', item_value_name)\n        data_to_replace = _regexSearchKeyValueCombo(policy_data, item_key, item_value_name)\n    if data_to_replace:\n        log.trace('replacing %s with %s', data_to_replace, this_string)\n        policy_data = policy_data.replace(data_to_replace, this_string)\n    else:\n        log.trace('appending %s', this_string)\n        policy_data = b''.join([policy_data, this_string])\n    return policy_data"
        ]
    },
    {
        "func_name": "_writeAdminTemplateRegPolFile",
        "original": "def _writeAdminTemplateRegPolFile(admtemplate_data, adml_language='en-US', registry_class='Machine'):\n    \"\"\"\n    helper function to prep/write adm template data to the Registry.pol file\n\n    each file begins with REGFILE_SIGNATURE (u'\\\\u5250\\\\u6765') and\n    REGISTRY_FILE_VERSION (u'\\\\x01\\\\00')\n\n    https://msdn.microsoft.com/en-us/library/aa374407(VS.85).aspx\n    +    https://msdn.microsoft.com/en-us/library/cc232696.aspx\n    [Registry Path<NULL>;Reg Value<NULL>;Reg Type;SizeInBytes;Data<NULL>]\n    \"\"\"\n    existing_data = b''\n    policySearchXpath = '//ns1:*[@id = \"{0}\" or @name = \"{0}\"]'\n    admx_policy_definitions = _get_policy_definitions(language=adml_language)\n    adml_policy_resources = _get_policy_resources(language=adml_language)\n    base_policy_settings = _checkAllAdmxPolicies(policy_class=registry_class, adml_language=adml_language, return_full_policy_names=False, hierarchical_return=False, return_not_configured=False)\n    for adm_namespace in admtemplate_data:\n        for adm_policy in admtemplate_data[adm_namespace]:\n            if str(admtemplate_data[adm_namespace][adm_policy]).lower() == 'not configured':\n                if base_policy_settings.get(adm_namespace, {}).pop(adm_policy, None) is not None:\n                    log.trace('Policy \"%s\" removed', adm_policy)\n            else:\n                log.trace('adding %s to base_policy_settings', adm_policy)\n                if adm_namespace not in base_policy_settings:\n                    base_policy_settings[adm_namespace] = {}\n                base_policy_settings[adm_namespace][adm_policy] = admtemplate_data[adm_namespace][adm_policy]\n    for adm_namespace in base_policy_settings:\n        for admPolicy in base_policy_settings[adm_namespace]:\n            log.trace('working on admPolicy %s', admPolicy)\n            explicit_enable_disable_value_setting = False\n            this_key = None\n            this_valuename = None\n            if str(base_policy_settings[adm_namespace][admPolicy]).lower() == 'disabled':\n                log.trace('time to disable %s', admPolicy)\n                this_policy = admx_policy_definitions.xpath(policySearchXpath.format(admPolicy), namespaces={'ns1': adm_namespace})\n                if this_policy:\n                    this_policy = this_policy[0]\n                    if 'class' in this_policy.attrib:\n                        if this_policy.attrib['class'] == registry_class or this_policy.attrib['class'] == 'Both':\n                            if 'key' in this_policy.attrib:\n                                this_key = this_policy.attrib['key']\n                            else:\n                                log.error('policy item %s does not have the required \"key\" attribute', this_policy.attrib)\n                                break\n                            if 'valueName' in this_policy.attrib:\n                                this_valuename = this_policy.attrib['valueName']\n                            if DISABLED_VALUE_XPATH(this_policy):\n                                explicit_enable_disable_value_setting = True\n                                disabled_value_string = _checkValueItemParent(this_policy, admPolicy, this_key, this_valuename, DISABLED_VALUE_XPATH, None, check_deleted=False, test_item=False)\n                                existing_data = _policyFileReplaceOrAppend(disabled_value_string, existing_data)\n                            if DISABLED_LIST_XPATH(this_policy):\n                                explicit_enable_disable_value_setting = True\n                                disabled_list_strings = _checkListItem(this_policy, admPolicy, this_key, DISABLED_LIST_XPATH, None, test_items=False)\n                                log.trace('working with disabledList portion of %s', admPolicy)\n                                existing_data = _policyFileReplaceOrAppendList(disabled_list_strings, existing_data)\n                            if not explicit_enable_disable_value_setting and this_valuename:\n                                disabled_value_string = _buildKnownDataSearchString(this_key, this_valuename, 'REG_DWORD', None, check_deleted=True)\n                                existing_data = _policyFileReplaceOrAppend(disabled_value_string, existing_data)\n                            if ELEMENTS_XPATH(this_policy):\n                                log.trace('checking elements of %s', admPolicy)\n                                for elements_item in ELEMENTS_XPATH(this_policy):\n                                    for child_item in elements_item:\n                                        child_key = this_key\n                                        child_valuename = this_valuename\n                                        if 'key' in child_item.attrib:\n                                            child_key = child_item.attrib['key']\n                                        if 'valueName' in child_item.attrib:\n                                            child_valuename = child_item.attrib['valueName']\n                                        if etree.QName(child_item).localname == 'boolean' and (TRUE_LIST_XPATH(child_item) or FALSE_LIST_XPATH(child_item)):\n                                            temp_dict = {'trueList': TRUE_LIST_XPATH, 'falseList': FALSE_LIST_XPATH}\n                                            for this_list in temp_dict:\n                                                disabled_list_strings = _checkListItem(child_item, admPolicy, child_key, temp_dict[this_list], None, test_items=False)\n                                                log.trace('working with %s portion of %s', admPolicy, this_list)\n                                                existing_data = _policyFileReplaceOrAppendList(disabled_list_strings, existing_data)\n                                        elif etree.QName(child_item).localname == 'boolean' or etree.QName(child_item).localname == 'decimal' or etree.QName(child_item).localname == 'text' or (etree.QName(child_item).localname == 'longDecimal') or (etree.QName(child_item).localname == 'multiText') or (etree.QName(child_item).localname == 'enum'):\n                                            disabled_value_string = _processValueItem(child_item, child_key, child_valuename, this_policy, elements_item, check_deleted=True)\n                                            log.trace('I have disabled value string of %s', disabled_value_string)\n                                            existing_data = _policyFileReplaceOrAppend(disabled_value_string, existing_data)\n                                        elif etree.QName(child_item).localname == 'list':\n                                            disabled_value_string = _processValueItem(child_item, child_key, child_valuename, this_policy, elements_item, check_deleted=True)\n                                            log.trace('I have disabled value string of %s', disabled_value_string)\n                                            existing_data = _policyFileReplaceOrAppend(disabled_value_string, existing_data)\n                        else:\n                            log.error('policy %s was found but it does not appear to be valid for the class %s', admPolicy, registry_class)\n                    else:\n                        log.error('policy item %s does not have the required \"class\" attribute', this_policy.attrib)\n            else:\n                log.trace('time to enable and set the policy \"%s\"', admPolicy)\n                this_policy = admx_policy_definitions.xpath(policySearchXpath.format(admPolicy), namespaces={'ns1': adm_namespace})\n                log.trace('found this_policy == %s', this_policy)\n                if this_policy:\n                    this_policy = this_policy[0]\n                    if 'class' in this_policy.attrib:\n                        if this_policy.attrib['class'] == registry_class or this_policy.attrib['class'] == 'Both':\n                            if 'key' in this_policy.attrib:\n                                this_key = this_policy.attrib['key']\n                            else:\n                                log.error('policy item %s does not have the required \"key\" attribute', this_policy.attrib)\n                                break\n                            if 'valueName' in this_policy.attrib:\n                                this_valuename = this_policy.attrib['valueName']\n                            if ENABLED_VALUE_XPATH(this_policy):\n                                explicit_enable_disable_value_setting = True\n                                enabled_value_string = _checkValueItemParent(this_policy, admPolicy, this_key, this_valuename, ENABLED_VALUE_XPATH, None, check_deleted=False, test_item=False)\n                                existing_data = _policyFileReplaceOrAppend(enabled_value_string, existing_data)\n                            if ENABLED_LIST_XPATH(this_policy):\n                                explicit_enable_disable_value_setting = True\n                                enabled_list_strings = _checkListItem(this_policy, admPolicy, this_key, ENABLED_LIST_XPATH, None, test_items=False)\n                                log.trace('working with enabledList portion of %s', admPolicy)\n                                existing_data = _policyFileReplaceOrAppendList(enabled_list_strings, existing_data)\n                            if not explicit_enable_disable_value_setting and this_valuename:\n                                enabled_value_string = _buildKnownDataSearchString(this_key, this_valuename, 'REG_DWORD', '1', check_deleted=False)\n                                existing_data = _policyFileReplaceOrAppend(enabled_value_string, existing_data)\n                            if ELEMENTS_XPATH(this_policy):\n                                for elements_item in ELEMENTS_XPATH(this_policy):\n                                    for child_item in elements_item:\n                                        child_key = this_key\n                                        child_valuename = this_valuename\n                                        if 'key' in child_item.attrib:\n                                            child_key = child_item.attrib['key']\n                                        if 'valueName' in child_item.attrib:\n                                            child_valuename = child_item.attrib['valueName']\n                                        if child_item.attrib['id'] in base_policy_settings[adm_namespace][admPolicy]:\n                                            if etree.QName(child_item).localname == 'boolean' and (TRUE_LIST_XPATH(child_item) or FALSE_LIST_XPATH(child_item)):\n                                                list_strings = []\n                                                if base_policy_settings[adm_namespace][admPolicy][child_item.attrib['id']]:\n                                                    list_strings = _checkListItem(child_item, admPolicy, child_key, TRUE_LIST_XPATH, None, test_items=False)\n                                                    log.trace('working with trueList portion of %s', admPolicy)\n                                                else:\n                                                    list_strings = _checkListItem(child_item, admPolicy, child_key, FALSE_LIST_XPATH, None, test_items=False)\n                                                existing_data = _policyFileReplaceOrAppendList(list_strings, existing_data)\n                                            elif etree.QName(child_item).localname == 'boolean' and (TRUE_VALUE_XPATH(child_item) or FALSE_VALUE_XPATH(child_item)):\n                                                value_string = ''\n                                                if base_policy_settings[adm_namespace][admPolicy][child_item.attrib['id']]:\n                                                    value_string = _checkValueItemParent(child_item, admPolicy, child_key, child_valuename, TRUE_VALUE_XPATH, None, check_deleted=False, test_item=False)\n                                                else:\n                                                    value_string = _checkValueItemParent(child_item, admPolicy, child_key, child_valuename, FALSE_VALUE_XPATH, None, check_deleted=False, test_item=False)\n                                                existing_data = _policyFileReplaceOrAppend(value_string, existing_data)\n                                            elif etree.QName(child_item).localname == 'boolean' or etree.QName(child_item).localname == 'decimal' or etree.QName(child_item).localname == 'text' or (etree.QName(child_item).localname == 'longDecimal') or (etree.QName(child_item).localname == 'multiText'):\n                                                enabled_value_string = _processValueItem(child_item, child_key, child_valuename, this_policy, elements_item, check_deleted=False, this_element_value=base_policy_settings[adm_namespace][admPolicy][child_item.attrib['id']])\n                                                log.trace('I have enabled value string of %s', enabled_value_string)\n                                                existing_data = _policyFileReplaceOrAppend(enabled_value_string, existing_data)\n                                            elif etree.QName(child_item).localname == 'enum':\n                                                for enum_item in child_item:\n                                                    if base_policy_settings[adm_namespace][admPolicy][child_item.attrib['id']] == _getAdmlDisplayName(adml_policy_resources, enum_item.attrib['displayName']).strip():\n                                                        enabled_value_string = _checkValueItemParent(enum_item, child_item.attrib['id'], child_key, child_valuename, VALUE_XPATH, None, check_deleted=False, test_item=False)\n                                                        existing_data = _policyFileReplaceOrAppend(enabled_value_string, existing_data)\n                                                        if VALUE_LIST_XPATH(enum_item):\n                                                            enabled_list_strings = _checkListItem(enum_item, admPolicy, child_key, VALUE_LIST_XPATH, None, test_items=False)\n                                                            log.trace('working with valueList portion of %s', child_item.attrib['id'])\n                                                            existing_data = _policyFileReplaceOrAppendList(enabled_list_strings, existing_data)\n                                                        break\n                                            elif etree.QName(child_item).localname == 'list':\n                                                enabled_value_string = _processValueItem(child_item, child_key, child_valuename, this_policy, elements_item, check_deleted=False, this_element_value=base_policy_settings[adm_namespace][admPolicy][child_item.attrib['id']])\n                                                log.trace('I have enabled value string of %s', enabled_value_string)\n                                                existing_data = _policyFileReplaceOrAppend(enabled_value_string, existing_data, append_only=True)\n    try:\n        write_reg_pol_data(data_to_write=existing_data, policy_file_path=CLASS_INFO[registry_class]['policy_path'], gpt_extension=CLASS_INFO[registry_class]['gpt_extension_location'], gpt_extension_guid=CLASS_INFO[registry_class]['gpt_extension_guid'])\n    except CommandExecutionError as exc:\n        log.exception('Unhandled exception occurred while attempting to write Adm Template Policy File.\\nException: %s', exc)\n        return False\n    return True",
        "mutated": [
            "def _writeAdminTemplateRegPolFile(admtemplate_data, adml_language='en-US', registry_class='Machine'):\n    if False:\n        i = 10\n    \"\\n    helper function to prep/write adm template data to the Registry.pol file\\n\\n    each file begins with REGFILE_SIGNATURE (u'\\\\u5250\\\\u6765') and\\n    REGISTRY_FILE_VERSION (u'\\\\x01\\\\00')\\n\\n    https://msdn.microsoft.com/en-us/library/aa374407(VS.85).aspx\\n    +    https://msdn.microsoft.com/en-us/library/cc232696.aspx\\n    [Registry Path<NULL>;Reg Value<NULL>;Reg Type;SizeInBytes;Data<NULL>]\\n    \"\n    existing_data = b''\n    policySearchXpath = '//ns1:*[@id = \"{0}\" or @name = \"{0}\"]'\n    admx_policy_definitions = _get_policy_definitions(language=adml_language)\n    adml_policy_resources = _get_policy_resources(language=adml_language)\n    base_policy_settings = _checkAllAdmxPolicies(policy_class=registry_class, adml_language=adml_language, return_full_policy_names=False, hierarchical_return=False, return_not_configured=False)\n    for adm_namespace in admtemplate_data:\n        for adm_policy in admtemplate_data[adm_namespace]:\n            if str(admtemplate_data[adm_namespace][adm_policy]).lower() == 'not configured':\n                if base_policy_settings.get(adm_namespace, {}).pop(adm_policy, None) is not None:\n                    log.trace('Policy \"%s\" removed', adm_policy)\n            else:\n                log.trace('adding %s to base_policy_settings', adm_policy)\n                if adm_namespace not in base_policy_settings:\n                    base_policy_settings[adm_namespace] = {}\n                base_policy_settings[adm_namespace][adm_policy] = admtemplate_data[adm_namespace][adm_policy]\n    for adm_namespace in base_policy_settings:\n        for admPolicy in base_policy_settings[adm_namespace]:\n            log.trace('working on admPolicy %s', admPolicy)\n            explicit_enable_disable_value_setting = False\n            this_key = None\n            this_valuename = None\n            if str(base_policy_settings[adm_namespace][admPolicy]).lower() == 'disabled':\n                log.trace('time to disable %s', admPolicy)\n                this_policy = admx_policy_definitions.xpath(policySearchXpath.format(admPolicy), namespaces={'ns1': adm_namespace})\n                if this_policy:\n                    this_policy = this_policy[0]\n                    if 'class' in this_policy.attrib:\n                        if this_policy.attrib['class'] == registry_class or this_policy.attrib['class'] == 'Both':\n                            if 'key' in this_policy.attrib:\n                                this_key = this_policy.attrib['key']\n                            else:\n                                log.error('policy item %s does not have the required \"key\" attribute', this_policy.attrib)\n                                break\n                            if 'valueName' in this_policy.attrib:\n                                this_valuename = this_policy.attrib['valueName']\n                            if DISABLED_VALUE_XPATH(this_policy):\n                                explicit_enable_disable_value_setting = True\n                                disabled_value_string = _checkValueItemParent(this_policy, admPolicy, this_key, this_valuename, DISABLED_VALUE_XPATH, None, check_deleted=False, test_item=False)\n                                existing_data = _policyFileReplaceOrAppend(disabled_value_string, existing_data)\n                            if DISABLED_LIST_XPATH(this_policy):\n                                explicit_enable_disable_value_setting = True\n                                disabled_list_strings = _checkListItem(this_policy, admPolicy, this_key, DISABLED_LIST_XPATH, None, test_items=False)\n                                log.trace('working with disabledList portion of %s', admPolicy)\n                                existing_data = _policyFileReplaceOrAppendList(disabled_list_strings, existing_data)\n                            if not explicit_enable_disable_value_setting and this_valuename:\n                                disabled_value_string = _buildKnownDataSearchString(this_key, this_valuename, 'REG_DWORD', None, check_deleted=True)\n                                existing_data = _policyFileReplaceOrAppend(disabled_value_string, existing_data)\n                            if ELEMENTS_XPATH(this_policy):\n                                log.trace('checking elements of %s', admPolicy)\n                                for elements_item in ELEMENTS_XPATH(this_policy):\n                                    for child_item in elements_item:\n                                        child_key = this_key\n                                        child_valuename = this_valuename\n                                        if 'key' in child_item.attrib:\n                                            child_key = child_item.attrib['key']\n                                        if 'valueName' in child_item.attrib:\n                                            child_valuename = child_item.attrib['valueName']\n                                        if etree.QName(child_item).localname == 'boolean' and (TRUE_LIST_XPATH(child_item) or FALSE_LIST_XPATH(child_item)):\n                                            temp_dict = {'trueList': TRUE_LIST_XPATH, 'falseList': FALSE_LIST_XPATH}\n                                            for this_list in temp_dict:\n                                                disabled_list_strings = _checkListItem(child_item, admPolicy, child_key, temp_dict[this_list], None, test_items=False)\n                                                log.trace('working with %s portion of %s', admPolicy, this_list)\n                                                existing_data = _policyFileReplaceOrAppendList(disabled_list_strings, existing_data)\n                                        elif etree.QName(child_item).localname == 'boolean' or etree.QName(child_item).localname == 'decimal' or etree.QName(child_item).localname == 'text' or (etree.QName(child_item).localname == 'longDecimal') or (etree.QName(child_item).localname == 'multiText') or (etree.QName(child_item).localname == 'enum'):\n                                            disabled_value_string = _processValueItem(child_item, child_key, child_valuename, this_policy, elements_item, check_deleted=True)\n                                            log.trace('I have disabled value string of %s', disabled_value_string)\n                                            existing_data = _policyFileReplaceOrAppend(disabled_value_string, existing_data)\n                                        elif etree.QName(child_item).localname == 'list':\n                                            disabled_value_string = _processValueItem(child_item, child_key, child_valuename, this_policy, elements_item, check_deleted=True)\n                                            log.trace('I have disabled value string of %s', disabled_value_string)\n                                            existing_data = _policyFileReplaceOrAppend(disabled_value_string, existing_data)\n                        else:\n                            log.error('policy %s was found but it does not appear to be valid for the class %s', admPolicy, registry_class)\n                    else:\n                        log.error('policy item %s does not have the required \"class\" attribute', this_policy.attrib)\n            else:\n                log.trace('time to enable and set the policy \"%s\"', admPolicy)\n                this_policy = admx_policy_definitions.xpath(policySearchXpath.format(admPolicy), namespaces={'ns1': adm_namespace})\n                log.trace('found this_policy == %s', this_policy)\n                if this_policy:\n                    this_policy = this_policy[0]\n                    if 'class' in this_policy.attrib:\n                        if this_policy.attrib['class'] == registry_class or this_policy.attrib['class'] == 'Both':\n                            if 'key' in this_policy.attrib:\n                                this_key = this_policy.attrib['key']\n                            else:\n                                log.error('policy item %s does not have the required \"key\" attribute', this_policy.attrib)\n                                break\n                            if 'valueName' in this_policy.attrib:\n                                this_valuename = this_policy.attrib['valueName']\n                            if ENABLED_VALUE_XPATH(this_policy):\n                                explicit_enable_disable_value_setting = True\n                                enabled_value_string = _checkValueItemParent(this_policy, admPolicy, this_key, this_valuename, ENABLED_VALUE_XPATH, None, check_deleted=False, test_item=False)\n                                existing_data = _policyFileReplaceOrAppend(enabled_value_string, existing_data)\n                            if ENABLED_LIST_XPATH(this_policy):\n                                explicit_enable_disable_value_setting = True\n                                enabled_list_strings = _checkListItem(this_policy, admPolicy, this_key, ENABLED_LIST_XPATH, None, test_items=False)\n                                log.trace('working with enabledList portion of %s', admPolicy)\n                                existing_data = _policyFileReplaceOrAppendList(enabled_list_strings, existing_data)\n                            if not explicit_enable_disable_value_setting and this_valuename:\n                                enabled_value_string = _buildKnownDataSearchString(this_key, this_valuename, 'REG_DWORD', '1', check_deleted=False)\n                                existing_data = _policyFileReplaceOrAppend(enabled_value_string, existing_data)\n                            if ELEMENTS_XPATH(this_policy):\n                                for elements_item in ELEMENTS_XPATH(this_policy):\n                                    for child_item in elements_item:\n                                        child_key = this_key\n                                        child_valuename = this_valuename\n                                        if 'key' in child_item.attrib:\n                                            child_key = child_item.attrib['key']\n                                        if 'valueName' in child_item.attrib:\n                                            child_valuename = child_item.attrib['valueName']\n                                        if child_item.attrib['id'] in base_policy_settings[adm_namespace][admPolicy]:\n                                            if etree.QName(child_item).localname == 'boolean' and (TRUE_LIST_XPATH(child_item) or FALSE_LIST_XPATH(child_item)):\n                                                list_strings = []\n                                                if base_policy_settings[adm_namespace][admPolicy][child_item.attrib['id']]:\n                                                    list_strings = _checkListItem(child_item, admPolicy, child_key, TRUE_LIST_XPATH, None, test_items=False)\n                                                    log.trace('working with trueList portion of %s', admPolicy)\n                                                else:\n                                                    list_strings = _checkListItem(child_item, admPolicy, child_key, FALSE_LIST_XPATH, None, test_items=False)\n                                                existing_data = _policyFileReplaceOrAppendList(list_strings, existing_data)\n                                            elif etree.QName(child_item).localname == 'boolean' and (TRUE_VALUE_XPATH(child_item) or FALSE_VALUE_XPATH(child_item)):\n                                                value_string = ''\n                                                if base_policy_settings[adm_namespace][admPolicy][child_item.attrib['id']]:\n                                                    value_string = _checkValueItemParent(child_item, admPolicy, child_key, child_valuename, TRUE_VALUE_XPATH, None, check_deleted=False, test_item=False)\n                                                else:\n                                                    value_string = _checkValueItemParent(child_item, admPolicy, child_key, child_valuename, FALSE_VALUE_XPATH, None, check_deleted=False, test_item=False)\n                                                existing_data = _policyFileReplaceOrAppend(value_string, existing_data)\n                                            elif etree.QName(child_item).localname == 'boolean' or etree.QName(child_item).localname == 'decimal' or etree.QName(child_item).localname == 'text' or (etree.QName(child_item).localname == 'longDecimal') or (etree.QName(child_item).localname == 'multiText'):\n                                                enabled_value_string = _processValueItem(child_item, child_key, child_valuename, this_policy, elements_item, check_deleted=False, this_element_value=base_policy_settings[adm_namespace][admPolicy][child_item.attrib['id']])\n                                                log.trace('I have enabled value string of %s', enabled_value_string)\n                                                existing_data = _policyFileReplaceOrAppend(enabled_value_string, existing_data)\n                                            elif etree.QName(child_item).localname == 'enum':\n                                                for enum_item in child_item:\n                                                    if base_policy_settings[adm_namespace][admPolicy][child_item.attrib['id']] == _getAdmlDisplayName(adml_policy_resources, enum_item.attrib['displayName']).strip():\n                                                        enabled_value_string = _checkValueItemParent(enum_item, child_item.attrib['id'], child_key, child_valuename, VALUE_XPATH, None, check_deleted=False, test_item=False)\n                                                        existing_data = _policyFileReplaceOrAppend(enabled_value_string, existing_data)\n                                                        if VALUE_LIST_XPATH(enum_item):\n                                                            enabled_list_strings = _checkListItem(enum_item, admPolicy, child_key, VALUE_LIST_XPATH, None, test_items=False)\n                                                            log.trace('working with valueList portion of %s', child_item.attrib['id'])\n                                                            existing_data = _policyFileReplaceOrAppendList(enabled_list_strings, existing_data)\n                                                        break\n                                            elif etree.QName(child_item).localname == 'list':\n                                                enabled_value_string = _processValueItem(child_item, child_key, child_valuename, this_policy, elements_item, check_deleted=False, this_element_value=base_policy_settings[adm_namespace][admPolicy][child_item.attrib['id']])\n                                                log.trace('I have enabled value string of %s', enabled_value_string)\n                                                existing_data = _policyFileReplaceOrAppend(enabled_value_string, existing_data, append_only=True)\n    try:\n        write_reg_pol_data(data_to_write=existing_data, policy_file_path=CLASS_INFO[registry_class]['policy_path'], gpt_extension=CLASS_INFO[registry_class]['gpt_extension_location'], gpt_extension_guid=CLASS_INFO[registry_class]['gpt_extension_guid'])\n    except CommandExecutionError as exc:\n        log.exception('Unhandled exception occurred while attempting to write Adm Template Policy File.\\nException: %s', exc)\n        return False\n    return True",
            "def _writeAdminTemplateRegPolFile(admtemplate_data, adml_language='en-US', registry_class='Machine'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    helper function to prep/write adm template data to the Registry.pol file\\n\\n    each file begins with REGFILE_SIGNATURE (u'\\\\u5250\\\\u6765') and\\n    REGISTRY_FILE_VERSION (u'\\\\x01\\\\00')\\n\\n    https://msdn.microsoft.com/en-us/library/aa374407(VS.85).aspx\\n    +    https://msdn.microsoft.com/en-us/library/cc232696.aspx\\n    [Registry Path<NULL>;Reg Value<NULL>;Reg Type;SizeInBytes;Data<NULL>]\\n    \"\n    existing_data = b''\n    policySearchXpath = '//ns1:*[@id = \"{0}\" or @name = \"{0}\"]'\n    admx_policy_definitions = _get_policy_definitions(language=adml_language)\n    adml_policy_resources = _get_policy_resources(language=adml_language)\n    base_policy_settings = _checkAllAdmxPolicies(policy_class=registry_class, adml_language=adml_language, return_full_policy_names=False, hierarchical_return=False, return_not_configured=False)\n    for adm_namespace in admtemplate_data:\n        for adm_policy in admtemplate_data[adm_namespace]:\n            if str(admtemplate_data[adm_namespace][adm_policy]).lower() == 'not configured':\n                if base_policy_settings.get(adm_namespace, {}).pop(adm_policy, None) is not None:\n                    log.trace('Policy \"%s\" removed', adm_policy)\n            else:\n                log.trace('adding %s to base_policy_settings', adm_policy)\n                if adm_namespace not in base_policy_settings:\n                    base_policy_settings[adm_namespace] = {}\n                base_policy_settings[adm_namespace][adm_policy] = admtemplate_data[adm_namespace][adm_policy]\n    for adm_namespace in base_policy_settings:\n        for admPolicy in base_policy_settings[adm_namespace]:\n            log.trace('working on admPolicy %s', admPolicy)\n            explicit_enable_disable_value_setting = False\n            this_key = None\n            this_valuename = None\n            if str(base_policy_settings[adm_namespace][admPolicy]).lower() == 'disabled':\n                log.trace('time to disable %s', admPolicy)\n                this_policy = admx_policy_definitions.xpath(policySearchXpath.format(admPolicy), namespaces={'ns1': adm_namespace})\n                if this_policy:\n                    this_policy = this_policy[0]\n                    if 'class' in this_policy.attrib:\n                        if this_policy.attrib['class'] == registry_class or this_policy.attrib['class'] == 'Both':\n                            if 'key' in this_policy.attrib:\n                                this_key = this_policy.attrib['key']\n                            else:\n                                log.error('policy item %s does not have the required \"key\" attribute', this_policy.attrib)\n                                break\n                            if 'valueName' in this_policy.attrib:\n                                this_valuename = this_policy.attrib['valueName']\n                            if DISABLED_VALUE_XPATH(this_policy):\n                                explicit_enable_disable_value_setting = True\n                                disabled_value_string = _checkValueItemParent(this_policy, admPolicy, this_key, this_valuename, DISABLED_VALUE_XPATH, None, check_deleted=False, test_item=False)\n                                existing_data = _policyFileReplaceOrAppend(disabled_value_string, existing_data)\n                            if DISABLED_LIST_XPATH(this_policy):\n                                explicit_enable_disable_value_setting = True\n                                disabled_list_strings = _checkListItem(this_policy, admPolicy, this_key, DISABLED_LIST_XPATH, None, test_items=False)\n                                log.trace('working with disabledList portion of %s', admPolicy)\n                                existing_data = _policyFileReplaceOrAppendList(disabled_list_strings, existing_data)\n                            if not explicit_enable_disable_value_setting and this_valuename:\n                                disabled_value_string = _buildKnownDataSearchString(this_key, this_valuename, 'REG_DWORD', None, check_deleted=True)\n                                existing_data = _policyFileReplaceOrAppend(disabled_value_string, existing_data)\n                            if ELEMENTS_XPATH(this_policy):\n                                log.trace('checking elements of %s', admPolicy)\n                                for elements_item in ELEMENTS_XPATH(this_policy):\n                                    for child_item in elements_item:\n                                        child_key = this_key\n                                        child_valuename = this_valuename\n                                        if 'key' in child_item.attrib:\n                                            child_key = child_item.attrib['key']\n                                        if 'valueName' in child_item.attrib:\n                                            child_valuename = child_item.attrib['valueName']\n                                        if etree.QName(child_item).localname == 'boolean' and (TRUE_LIST_XPATH(child_item) or FALSE_LIST_XPATH(child_item)):\n                                            temp_dict = {'trueList': TRUE_LIST_XPATH, 'falseList': FALSE_LIST_XPATH}\n                                            for this_list in temp_dict:\n                                                disabled_list_strings = _checkListItem(child_item, admPolicy, child_key, temp_dict[this_list], None, test_items=False)\n                                                log.trace('working with %s portion of %s', admPolicy, this_list)\n                                                existing_data = _policyFileReplaceOrAppendList(disabled_list_strings, existing_data)\n                                        elif etree.QName(child_item).localname == 'boolean' or etree.QName(child_item).localname == 'decimal' or etree.QName(child_item).localname == 'text' or (etree.QName(child_item).localname == 'longDecimal') or (etree.QName(child_item).localname == 'multiText') or (etree.QName(child_item).localname == 'enum'):\n                                            disabled_value_string = _processValueItem(child_item, child_key, child_valuename, this_policy, elements_item, check_deleted=True)\n                                            log.trace('I have disabled value string of %s', disabled_value_string)\n                                            existing_data = _policyFileReplaceOrAppend(disabled_value_string, existing_data)\n                                        elif etree.QName(child_item).localname == 'list':\n                                            disabled_value_string = _processValueItem(child_item, child_key, child_valuename, this_policy, elements_item, check_deleted=True)\n                                            log.trace('I have disabled value string of %s', disabled_value_string)\n                                            existing_data = _policyFileReplaceOrAppend(disabled_value_string, existing_data)\n                        else:\n                            log.error('policy %s was found but it does not appear to be valid for the class %s', admPolicy, registry_class)\n                    else:\n                        log.error('policy item %s does not have the required \"class\" attribute', this_policy.attrib)\n            else:\n                log.trace('time to enable and set the policy \"%s\"', admPolicy)\n                this_policy = admx_policy_definitions.xpath(policySearchXpath.format(admPolicy), namespaces={'ns1': adm_namespace})\n                log.trace('found this_policy == %s', this_policy)\n                if this_policy:\n                    this_policy = this_policy[0]\n                    if 'class' in this_policy.attrib:\n                        if this_policy.attrib['class'] == registry_class or this_policy.attrib['class'] == 'Both':\n                            if 'key' in this_policy.attrib:\n                                this_key = this_policy.attrib['key']\n                            else:\n                                log.error('policy item %s does not have the required \"key\" attribute', this_policy.attrib)\n                                break\n                            if 'valueName' in this_policy.attrib:\n                                this_valuename = this_policy.attrib['valueName']\n                            if ENABLED_VALUE_XPATH(this_policy):\n                                explicit_enable_disable_value_setting = True\n                                enabled_value_string = _checkValueItemParent(this_policy, admPolicy, this_key, this_valuename, ENABLED_VALUE_XPATH, None, check_deleted=False, test_item=False)\n                                existing_data = _policyFileReplaceOrAppend(enabled_value_string, existing_data)\n                            if ENABLED_LIST_XPATH(this_policy):\n                                explicit_enable_disable_value_setting = True\n                                enabled_list_strings = _checkListItem(this_policy, admPolicy, this_key, ENABLED_LIST_XPATH, None, test_items=False)\n                                log.trace('working with enabledList portion of %s', admPolicy)\n                                existing_data = _policyFileReplaceOrAppendList(enabled_list_strings, existing_data)\n                            if not explicit_enable_disable_value_setting and this_valuename:\n                                enabled_value_string = _buildKnownDataSearchString(this_key, this_valuename, 'REG_DWORD', '1', check_deleted=False)\n                                existing_data = _policyFileReplaceOrAppend(enabled_value_string, existing_data)\n                            if ELEMENTS_XPATH(this_policy):\n                                for elements_item in ELEMENTS_XPATH(this_policy):\n                                    for child_item in elements_item:\n                                        child_key = this_key\n                                        child_valuename = this_valuename\n                                        if 'key' in child_item.attrib:\n                                            child_key = child_item.attrib['key']\n                                        if 'valueName' in child_item.attrib:\n                                            child_valuename = child_item.attrib['valueName']\n                                        if child_item.attrib['id'] in base_policy_settings[adm_namespace][admPolicy]:\n                                            if etree.QName(child_item).localname == 'boolean' and (TRUE_LIST_XPATH(child_item) or FALSE_LIST_XPATH(child_item)):\n                                                list_strings = []\n                                                if base_policy_settings[adm_namespace][admPolicy][child_item.attrib['id']]:\n                                                    list_strings = _checkListItem(child_item, admPolicy, child_key, TRUE_LIST_XPATH, None, test_items=False)\n                                                    log.trace('working with trueList portion of %s', admPolicy)\n                                                else:\n                                                    list_strings = _checkListItem(child_item, admPolicy, child_key, FALSE_LIST_XPATH, None, test_items=False)\n                                                existing_data = _policyFileReplaceOrAppendList(list_strings, existing_data)\n                                            elif etree.QName(child_item).localname == 'boolean' and (TRUE_VALUE_XPATH(child_item) or FALSE_VALUE_XPATH(child_item)):\n                                                value_string = ''\n                                                if base_policy_settings[adm_namespace][admPolicy][child_item.attrib['id']]:\n                                                    value_string = _checkValueItemParent(child_item, admPolicy, child_key, child_valuename, TRUE_VALUE_XPATH, None, check_deleted=False, test_item=False)\n                                                else:\n                                                    value_string = _checkValueItemParent(child_item, admPolicy, child_key, child_valuename, FALSE_VALUE_XPATH, None, check_deleted=False, test_item=False)\n                                                existing_data = _policyFileReplaceOrAppend(value_string, existing_data)\n                                            elif etree.QName(child_item).localname == 'boolean' or etree.QName(child_item).localname == 'decimal' or etree.QName(child_item).localname == 'text' or (etree.QName(child_item).localname == 'longDecimal') or (etree.QName(child_item).localname == 'multiText'):\n                                                enabled_value_string = _processValueItem(child_item, child_key, child_valuename, this_policy, elements_item, check_deleted=False, this_element_value=base_policy_settings[adm_namespace][admPolicy][child_item.attrib['id']])\n                                                log.trace('I have enabled value string of %s', enabled_value_string)\n                                                existing_data = _policyFileReplaceOrAppend(enabled_value_string, existing_data)\n                                            elif etree.QName(child_item).localname == 'enum':\n                                                for enum_item in child_item:\n                                                    if base_policy_settings[adm_namespace][admPolicy][child_item.attrib['id']] == _getAdmlDisplayName(adml_policy_resources, enum_item.attrib['displayName']).strip():\n                                                        enabled_value_string = _checkValueItemParent(enum_item, child_item.attrib['id'], child_key, child_valuename, VALUE_XPATH, None, check_deleted=False, test_item=False)\n                                                        existing_data = _policyFileReplaceOrAppend(enabled_value_string, existing_data)\n                                                        if VALUE_LIST_XPATH(enum_item):\n                                                            enabled_list_strings = _checkListItem(enum_item, admPolicy, child_key, VALUE_LIST_XPATH, None, test_items=False)\n                                                            log.trace('working with valueList portion of %s', child_item.attrib['id'])\n                                                            existing_data = _policyFileReplaceOrAppendList(enabled_list_strings, existing_data)\n                                                        break\n                                            elif etree.QName(child_item).localname == 'list':\n                                                enabled_value_string = _processValueItem(child_item, child_key, child_valuename, this_policy, elements_item, check_deleted=False, this_element_value=base_policy_settings[adm_namespace][admPolicy][child_item.attrib['id']])\n                                                log.trace('I have enabled value string of %s', enabled_value_string)\n                                                existing_data = _policyFileReplaceOrAppend(enabled_value_string, existing_data, append_only=True)\n    try:\n        write_reg_pol_data(data_to_write=existing_data, policy_file_path=CLASS_INFO[registry_class]['policy_path'], gpt_extension=CLASS_INFO[registry_class]['gpt_extension_location'], gpt_extension_guid=CLASS_INFO[registry_class]['gpt_extension_guid'])\n    except CommandExecutionError as exc:\n        log.exception('Unhandled exception occurred while attempting to write Adm Template Policy File.\\nException: %s', exc)\n        return False\n    return True",
            "def _writeAdminTemplateRegPolFile(admtemplate_data, adml_language='en-US', registry_class='Machine'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    helper function to prep/write adm template data to the Registry.pol file\\n\\n    each file begins with REGFILE_SIGNATURE (u'\\\\u5250\\\\u6765') and\\n    REGISTRY_FILE_VERSION (u'\\\\x01\\\\00')\\n\\n    https://msdn.microsoft.com/en-us/library/aa374407(VS.85).aspx\\n    +    https://msdn.microsoft.com/en-us/library/cc232696.aspx\\n    [Registry Path<NULL>;Reg Value<NULL>;Reg Type;SizeInBytes;Data<NULL>]\\n    \"\n    existing_data = b''\n    policySearchXpath = '//ns1:*[@id = \"{0}\" or @name = \"{0}\"]'\n    admx_policy_definitions = _get_policy_definitions(language=adml_language)\n    adml_policy_resources = _get_policy_resources(language=adml_language)\n    base_policy_settings = _checkAllAdmxPolicies(policy_class=registry_class, adml_language=adml_language, return_full_policy_names=False, hierarchical_return=False, return_not_configured=False)\n    for adm_namespace in admtemplate_data:\n        for adm_policy in admtemplate_data[adm_namespace]:\n            if str(admtemplate_data[adm_namespace][adm_policy]).lower() == 'not configured':\n                if base_policy_settings.get(adm_namespace, {}).pop(adm_policy, None) is not None:\n                    log.trace('Policy \"%s\" removed', adm_policy)\n            else:\n                log.trace('adding %s to base_policy_settings', adm_policy)\n                if adm_namespace not in base_policy_settings:\n                    base_policy_settings[adm_namespace] = {}\n                base_policy_settings[adm_namespace][adm_policy] = admtemplate_data[adm_namespace][adm_policy]\n    for adm_namespace in base_policy_settings:\n        for admPolicy in base_policy_settings[adm_namespace]:\n            log.trace('working on admPolicy %s', admPolicy)\n            explicit_enable_disable_value_setting = False\n            this_key = None\n            this_valuename = None\n            if str(base_policy_settings[adm_namespace][admPolicy]).lower() == 'disabled':\n                log.trace('time to disable %s', admPolicy)\n                this_policy = admx_policy_definitions.xpath(policySearchXpath.format(admPolicy), namespaces={'ns1': adm_namespace})\n                if this_policy:\n                    this_policy = this_policy[0]\n                    if 'class' in this_policy.attrib:\n                        if this_policy.attrib['class'] == registry_class or this_policy.attrib['class'] == 'Both':\n                            if 'key' in this_policy.attrib:\n                                this_key = this_policy.attrib['key']\n                            else:\n                                log.error('policy item %s does not have the required \"key\" attribute', this_policy.attrib)\n                                break\n                            if 'valueName' in this_policy.attrib:\n                                this_valuename = this_policy.attrib['valueName']\n                            if DISABLED_VALUE_XPATH(this_policy):\n                                explicit_enable_disable_value_setting = True\n                                disabled_value_string = _checkValueItemParent(this_policy, admPolicy, this_key, this_valuename, DISABLED_VALUE_XPATH, None, check_deleted=False, test_item=False)\n                                existing_data = _policyFileReplaceOrAppend(disabled_value_string, existing_data)\n                            if DISABLED_LIST_XPATH(this_policy):\n                                explicit_enable_disable_value_setting = True\n                                disabled_list_strings = _checkListItem(this_policy, admPolicy, this_key, DISABLED_LIST_XPATH, None, test_items=False)\n                                log.trace('working with disabledList portion of %s', admPolicy)\n                                existing_data = _policyFileReplaceOrAppendList(disabled_list_strings, existing_data)\n                            if not explicit_enable_disable_value_setting and this_valuename:\n                                disabled_value_string = _buildKnownDataSearchString(this_key, this_valuename, 'REG_DWORD', None, check_deleted=True)\n                                existing_data = _policyFileReplaceOrAppend(disabled_value_string, existing_data)\n                            if ELEMENTS_XPATH(this_policy):\n                                log.trace('checking elements of %s', admPolicy)\n                                for elements_item in ELEMENTS_XPATH(this_policy):\n                                    for child_item in elements_item:\n                                        child_key = this_key\n                                        child_valuename = this_valuename\n                                        if 'key' in child_item.attrib:\n                                            child_key = child_item.attrib['key']\n                                        if 'valueName' in child_item.attrib:\n                                            child_valuename = child_item.attrib['valueName']\n                                        if etree.QName(child_item).localname == 'boolean' and (TRUE_LIST_XPATH(child_item) or FALSE_LIST_XPATH(child_item)):\n                                            temp_dict = {'trueList': TRUE_LIST_XPATH, 'falseList': FALSE_LIST_XPATH}\n                                            for this_list in temp_dict:\n                                                disabled_list_strings = _checkListItem(child_item, admPolicy, child_key, temp_dict[this_list], None, test_items=False)\n                                                log.trace('working with %s portion of %s', admPolicy, this_list)\n                                                existing_data = _policyFileReplaceOrAppendList(disabled_list_strings, existing_data)\n                                        elif etree.QName(child_item).localname == 'boolean' or etree.QName(child_item).localname == 'decimal' or etree.QName(child_item).localname == 'text' or (etree.QName(child_item).localname == 'longDecimal') or (etree.QName(child_item).localname == 'multiText') or (etree.QName(child_item).localname == 'enum'):\n                                            disabled_value_string = _processValueItem(child_item, child_key, child_valuename, this_policy, elements_item, check_deleted=True)\n                                            log.trace('I have disabled value string of %s', disabled_value_string)\n                                            existing_data = _policyFileReplaceOrAppend(disabled_value_string, existing_data)\n                                        elif etree.QName(child_item).localname == 'list':\n                                            disabled_value_string = _processValueItem(child_item, child_key, child_valuename, this_policy, elements_item, check_deleted=True)\n                                            log.trace('I have disabled value string of %s', disabled_value_string)\n                                            existing_data = _policyFileReplaceOrAppend(disabled_value_string, existing_data)\n                        else:\n                            log.error('policy %s was found but it does not appear to be valid for the class %s', admPolicy, registry_class)\n                    else:\n                        log.error('policy item %s does not have the required \"class\" attribute', this_policy.attrib)\n            else:\n                log.trace('time to enable and set the policy \"%s\"', admPolicy)\n                this_policy = admx_policy_definitions.xpath(policySearchXpath.format(admPolicy), namespaces={'ns1': adm_namespace})\n                log.trace('found this_policy == %s', this_policy)\n                if this_policy:\n                    this_policy = this_policy[0]\n                    if 'class' in this_policy.attrib:\n                        if this_policy.attrib['class'] == registry_class or this_policy.attrib['class'] == 'Both':\n                            if 'key' in this_policy.attrib:\n                                this_key = this_policy.attrib['key']\n                            else:\n                                log.error('policy item %s does not have the required \"key\" attribute', this_policy.attrib)\n                                break\n                            if 'valueName' in this_policy.attrib:\n                                this_valuename = this_policy.attrib['valueName']\n                            if ENABLED_VALUE_XPATH(this_policy):\n                                explicit_enable_disable_value_setting = True\n                                enabled_value_string = _checkValueItemParent(this_policy, admPolicy, this_key, this_valuename, ENABLED_VALUE_XPATH, None, check_deleted=False, test_item=False)\n                                existing_data = _policyFileReplaceOrAppend(enabled_value_string, existing_data)\n                            if ENABLED_LIST_XPATH(this_policy):\n                                explicit_enable_disable_value_setting = True\n                                enabled_list_strings = _checkListItem(this_policy, admPolicy, this_key, ENABLED_LIST_XPATH, None, test_items=False)\n                                log.trace('working with enabledList portion of %s', admPolicy)\n                                existing_data = _policyFileReplaceOrAppendList(enabled_list_strings, existing_data)\n                            if not explicit_enable_disable_value_setting and this_valuename:\n                                enabled_value_string = _buildKnownDataSearchString(this_key, this_valuename, 'REG_DWORD', '1', check_deleted=False)\n                                existing_data = _policyFileReplaceOrAppend(enabled_value_string, existing_data)\n                            if ELEMENTS_XPATH(this_policy):\n                                for elements_item in ELEMENTS_XPATH(this_policy):\n                                    for child_item in elements_item:\n                                        child_key = this_key\n                                        child_valuename = this_valuename\n                                        if 'key' in child_item.attrib:\n                                            child_key = child_item.attrib['key']\n                                        if 'valueName' in child_item.attrib:\n                                            child_valuename = child_item.attrib['valueName']\n                                        if child_item.attrib['id'] in base_policy_settings[adm_namespace][admPolicy]:\n                                            if etree.QName(child_item).localname == 'boolean' and (TRUE_LIST_XPATH(child_item) or FALSE_LIST_XPATH(child_item)):\n                                                list_strings = []\n                                                if base_policy_settings[adm_namespace][admPolicy][child_item.attrib['id']]:\n                                                    list_strings = _checkListItem(child_item, admPolicy, child_key, TRUE_LIST_XPATH, None, test_items=False)\n                                                    log.trace('working with trueList portion of %s', admPolicy)\n                                                else:\n                                                    list_strings = _checkListItem(child_item, admPolicy, child_key, FALSE_LIST_XPATH, None, test_items=False)\n                                                existing_data = _policyFileReplaceOrAppendList(list_strings, existing_data)\n                                            elif etree.QName(child_item).localname == 'boolean' and (TRUE_VALUE_XPATH(child_item) or FALSE_VALUE_XPATH(child_item)):\n                                                value_string = ''\n                                                if base_policy_settings[adm_namespace][admPolicy][child_item.attrib['id']]:\n                                                    value_string = _checkValueItemParent(child_item, admPolicy, child_key, child_valuename, TRUE_VALUE_XPATH, None, check_deleted=False, test_item=False)\n                                                else:\n                                                    value_string = _checkValueItemParent(child_item, admPolicy, child_key, child_valuename, FALSE_VALUE_XPATH, None, check_deleted=False, test_item=False)\n                                                existing_data = _policyFileReplaceOrAppend(value_string, existing_data)\n                                            elif etree.QName(child_item).localname == 'boolean' or etree.QName(child_item).localname == 'decimal' or etree.QName(child_item).localname == 'text' or (etree.QName(child_item).localname == 'longDecimal') or (etree.QName(child_item).localname == 'multiText'):\n                                                enabled_value_string = _processValueItem(child_item, child_key, child_valuename, this_policy, elements_item, check_deleted=False, this_element_value=base_policy_settings[adm_namespace][admPolicy][child_item.attrib['id']])\n                                                log.trace('I have enabled value string of %s', enabled_value_string)\n                                                existing_data = _policyFileReplaceOrAppend(enabled_value_string, existing_data)\n                                            elif etree.QName(child_item).localname == 'enum':\n                                                for enum_item in child_item:\n                                                    if base_policy_settings[adm_namespace][admPolicy][child_item.attrib['id']] == _getAdmlDisplayName(adml_policy_resources, enum_item.attrib['displayName']).strip():\n                                                        enabled_value_string = _checkValueItemParent(enum_item, child_item.attrib['id'], child_key, child_valuename, VALUE_XPATH, None, check_deleted=False, test_item=False)\n                                                        existing_data = _policyFileReplaceOrAppend(enabled_value_string, existing_data)\n                                                        if VALUE_LIST_XPATH(enum_item):\n                                                            enabled_list_strings = _checkListItem(enum_item, admPolicy, child_key, VALUE_LIST_XPATH, None, test_items=False)\n                                                            log.trace('working with valueList portion of %s', child_item.attrib['id'])\n                                                            existing_data = _policyFileReplaceOrAppendList(enabled_list_strings, existing_data)\n                                                        break\n                                            elif etree.QName(child_item).localname == 'list':\n                                                enabled_value_string = _processValueItem(child_item, child_key, child_valuename, this_policy, elements_item, check_deleted=False, this_element_value=base_policy_settings[adm_namespace][admPolicy][child_item.attrib['id']])\n                                                log.trace('I have enabled value string of %s', enabled_value_string)\n                                                existing_data = _policyFileReplaceOrAppend(enabled_value_string, existing_data, append_only=True)\n    try:\n        write_reg_pol_data(data_to_write=existing_data, policy_file_path=CLASS_INFO[registry_class]['policy_path'], gpt_extension=CLASS_INFO[registry_class]['gpt_extension_location'], gpt_extension_guid=CLASS_INFO[registry_class]['gpt_extension_guid'])\n    except CommandExecutionError as exc:\n        log.exception('Unhandled exception occurred while attempting to write Adm Template Policy File.\\nException: %s', exc)\n        return False\n    return True",
            "def _writeAdminTemplateRegPolFile(admtemplate_data, adml_language='en-US', registry_class='Machine'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    helper function to prep/write adm template data to the Registry.pol file\\n\\n    each file begins with REGFILE_SIGNATURE (u'\\\\u5250\\\\u6765') and\\n    REGISTRY_FILE_VERSION (u'\\\\x01\\\\00')\\n\\n    https://msdn.microsoft.com/en-us/library/aa374407(VS.85).aspx\\n    +    https://msdn.microsoft.com/en-us/library/cc232696.aspx\\n    [Registry Path<NULL>;Reg Value<NULL>;Reg Type;SizeInBytes;Data<NULL>]\\n    \"\n    existing_data = b''\n    policySearchXpath = '//ns1:*[@id = \"{0}\" or @name = \"{0}\"]'\n    admx_policy_definitions = _get_policy_definitions(language=adml_language)\n    adml_policy_resources = _get_policy_resources(language=adml_language)\n    base_policy_settings = _checkAllAdmxPolicies(policy_class=registry_class, adml_language=adml_language, return_full_policy_names=False, hierarchical_return=False, return_not_configured=False)\n    for adm_namespace in admtemplate_data:\n        for adm_policy in admtemplate_data[adm_namespace]:\n            if str(admtemplate_data[adm_namespace][adm_policy]).lower() == 'not configured':\n                if base_policy_settings.get(adm_namespace, {}).pop(adm_policy, None) is not None:\n                    log.trace('Policy \"%s\" removed', adm_policy)\n            else:\n                log.trace('adding %s to base_policy_settings', adm_policy)\n                if adm_namespace not in base_policy_settings:\n                    base_policy_settings[adm_namespace] = {}\n                base_policy_settings[adm_namespace][adm_policy] = admtemplate_data[adm_namespace][adm_policy]\n    for adm_namespace in base_policy_settings:\n        for admPolicy in base_policy_settings[adm_namespace]:\n            log.trace('working on admPolicy %s', admPolicy)\n            explicit_enable_disable_value_setting = False\n            this_key = None\n            this_valuename = None\n            if str(base_policy_settings[adm_namespace][admPolicy]).lower() == 'disabled':\n                log.trace('time to disable %s', admPolicy)\n                this_policy = admx_policy_definitions.xpath(policySearchXpath.format(admPolicy), namespaces={'ns1': adm_namespace})\n                if this_policy:\n                    this_policy = this_policy[0]\n                    if 'class' in this_policy.attrib:\n                        if this_policy.attrib['class'] == registry_class or this_policy.attrib['class'] == 'Both':\n                            if 'key' in this_policy.attrib:\n                                this_key = this_policy.attrib['key']\n                            else:\n                                log.error('policy item %s does not have the required \"key\" attribute', this_policy.attrib)\n                                break\n                            if 'valueName' in this_policy.attrib:\n                                this_valuename = this_policy.attrib['valueName']\n                            if DISABLED_VALUE_XPATH(this_policy):\n                                explicit_enable_disable_value_setting = True\n                                disabled_value_string = _checkValueItemParent(this_policy, admPolicy, this_key, this_valuename, DISABLED_VALUE_XPATH, None, check_deleted=False, test_item=False)\n                                existing_data = _policyFileReplaceOrAppend(disabled_value_string, existing_data)\n                            if DISABLED_LIST_XPATH(this_policy):\n                                explicit_enable_disable_value_setting = True\n                                disabled_list_strings = _checkListItem(this_policy, admPolicy, this_key, DISABLED_LIST_XPATH, None, test_items=False)\n                                log.trace('working with disabledList portion of %s', admPolicy)\n                                existing_data = _policyFileReplaceOrAppendList(disabled_list_strings, existing_data)\n                            if not explicit_enable_disable_value_setting and this_valuename:\n                                disabled_value_string = _buildKnownDataSearchString(this_key, this_valuename, 'REG_DWORD', None, check_deleted=True)\n                                existing_data = _policyFileReplaceOrAppend(disabled_value_string, existing_data)\n                            if ELEMENTS_XPATH(this_policy):\n                                log.trace('checking elements of %s', admPolicy)\n                                for elements_item in ELEMENTS_XPATH(this_policy):\n                                    for child_item in elements_item:\n                                        child_key = this_key\n                                        child_valuename = this_valuename\n                                        if 'key' in child_item.attrib:\n                                            child_key = child_item.attrib['key']\n                                        if 'valueName' in child_item.attrib:\n                                            child_valuename = child_item.attrib['valueName']\n                                        if etree.QName(child_item).localname == 'boolean' and (TRUE_LIST_XPATH(child_item) or FALSE_LIST_XPATH(child_item)):\n                                            temp_dict = {'trueList': TRUE_LIST_XPATH, 'falseList': FALSE_LIST_XPATH}\n                                            for this_list in temp_dict:\n                                                disabled_list_strings = _checkListItem(child_item, admPolicy, child_key, temp_dict[this_list], None, test_items=False)\n                                                log.trace('working with %s portion of %s', admPolicy, this_list)\n                                                existing_data = _policyFileReplaceOrAppendList(disabled_list_strings, existing_data)\n                                        elif etree.QName(child_item).localname == 'boolean' or etree.QName(child_item).localname == 'decimal' or etree.QName(child_item).localname == 'text' or (etree.QName(child_item).localname == 'longDecimal') or (etree.QName(child_item).localname == 'multiText') or (etree.QName(child_item).localname == 'enum'):\n                                            disabled_value_string = _processValueItem(child_item, child_key, child_valuename, this_policy, elements_item, check_deleted=True)\n                                            log.trace('I have disabled value string of %s', disabled_value_string)\n                                            existing_data = _policyFileReplaceOrAppend(disabled_value_string, existing_data)\n                                        elif etree.QName(child_item).localname == 'list':\n                                            disabled_value_string = _processValueItem(child_item, child_key, child_valuename, this_policy, elements_item, check_deleted=True)\n                                            log.trace('I have disabled value string of %s', disabled_value_string)\n                                            existing_data = _policyFileReplaceOrAppend(disabled_value_string, existing_data)\n                        else:\n                            log.error('policy %s was found but it does not appear to be valid for the class %s', admPolicy, registry_class)\n                    else:\n                        log.error('policy item %s does not have the required \"class\" attribute', this_policy.attrib)\n            else:\n                log.trace('time to enable and set the policy \"%s\"', admPolicy)\n                this_policy = admx_policy_definitions.xpath(policySearchXpath.format(admPolicy), namespaces={'ns1': adm_namespace})\n                log.trace('found this_policy == %s', this_policy)\n                if this_policy:\n                    this_policy = this_policy[0]\n                    if 'class' in this_policy.attrib:\n                        if this_policy.attrib['class'] == registry_class or this_policy.attrib['class'] == 'Both':\n                            if 'key' in this_policy.attrib:\n                                this_key = this_policy.attrib['key']\n                            else:\n                                log.error('policy item %s does not have the required \"key\" attribute', this_policy.attrib)\n                                break\n                            if 'valueName' in this_policy.attrib:\n                                this_valuename = this_policy.attrib['valueName']\n                            if ENABLED_VALUE_XPATH(this_policy):\n                                explicit_enable_disable_value_setting = True\n                                enabled_value_string = _checkValueItemParent(this_policy, admPolicy, this_key, this_valuename, ENABLED_VALUE_XPATH, None, check_deleted=False, test_item=False)\n                                existing_data = _policyFileReplaceOrAppend(enabled_value_string, existing_data)\n                            if ENABLED_LIST_XPATH(this_policy):\n                                explicit_enable_disable_value_setting = True\n                                enabled_list_strings = _checkListItem(this_policy, admPolicy, this_key, ENABLED_LIST_XPATH, None, test_items=False)\n                                log.trace('working with enabledList portion of %s', admPolicy)\n                                existing_data = _policyFileReplaceOrAppendList(enabled_list_strings, existing_data)\n                            if not explicit_enable_disable_value_setting and this_valuename:\n                                enabled_value_string = _buildKnownDataSearchString(this_key, this_valuename, 'REG_DWORD', '1', check_deleted=False)\n                                existing_data = _policyFileReplaceOrAppend(enabled_value_string, existing_data)\n                            if ELEMENTS_XPATH(this_policy):\n                                for elements_item in ELEMENTS_XPATH(this_policy):\n                                    for child_item in elements_item:\n                                        child_key = this_key\n                                        child_valuename = this_valuename\n                                        if 'key' in child_item.attrib:\n                                            child_key = child_item.attrib['key']\n                                        if 'valueName' in child_item.attrib:\n                                            child_valuename = child_item.attrib['valueName']\n                                        if child_item.attrib['id'] in base_policy_settings[adm_namespace][admPolicy]:\n                                            if etree.QName(child_item).localname == 'boolean' and (TRUE_LIST_XPATH(child_item) or FALSE_LIST_XPATH(child_item)):\n                                                list_strings = []\n                                                if base_policy_settings[adm_namespace][admPolicy][child_item.attrib['id']]:\n                                                    list_strings = _checkListItem(child_item, admPolicy, child_key, TRUE_LIST_XPATH, None, test_items=False)\n                                                    log.trace('working with trueList portion of %s', admPolicy)\n                                                else:\n                                                    list_strings = _checkListItem(child_item, admPolicy, child_key, FALSE_LIST_XPATH, None, test_items=False)\n                                                existing_data = _policyFileReplaceOrAppendList(list_strings, existing_data)\n                                            elif etree.QName(child_item).localname == 'boolean' and (TRUE_VALUE_XPATH(child_item) or FALSE_VALUE_XPATH(child_item)):\n                                                value_string = ''\n                                                if base_policy_settings[adm_namespace][admPolicy][child_item.attrib['id']]:\n                                                    value_string = _checkValueItemParent(child_item, admPolicy, child_key, child_valuename, TRUE_VALUE_XPATH, None, check_deleted=False, test_item=False)\n                                                else:\n                                                    value_string = _checkValueItemParent(child_item, admPolicy, child_key, child_valuename, FALSE_VALUE_XPATH, None, check_deleted=False, test_item=False)\n                                                existing_data = _policyFileReplaceOrAppend(value_string, existing_data)\n                                            elif etree.QName(child_item).localname == 'boolean' or etree.QName(child_item).localname == 'decimal' or etree.QName(child_item).localname == 'text' or (etree.QName(child_item).localname == 'longDecimal') or (etree.QName(child_item).localname == 'multiText'):\n                                                enabled_value_string = _processValueItem(child_item, child_key, child_valuename, this_policy, elements_item, check_deleted=False, this_element_value=base_policy_settings[adm_namespace][admPolicy][child_item.attrib['id']])\n                                                log.trace('I have enabled value string of %s', enabled_value_string)\n                                                existing_data = _policyFileReplaceOrAppend(enabled_value_string, existing_data)\n                                            elif etree.QName(child_item).localname == 'enum':\n                                                for enum_item in child_item:\n                                                    if base_policy_settings[adm_namespace][admPolicy][child_item.attrib['id']] == _getAdmlDisplayName(adml_policy_resources, enum_item.attrib['displayName']).strip():\n                                                        enabled_value_string = _checkValueItemParent(enum_item, child_item.attrib['id'], child_key, child_valuename, VALUE_XPATH, None, check_deleted=False, test_item=False)\n                                                        existing_data = _policyFileReplaceOrAppend(enabled_value_string, existing_data)\n                                                        if VALUE_LIST_XPATH(enum_item):\n                                                            enabled_list_strings = _checkListItem(enum_item, admPolicy, child_key, VALUE_LIST_XPATH, None, test_items=False)\n                                                            log.trace('working with valueList portion of %s', child_item.attrib['id'])\n                                                            existing_data = _policyFileReplaceOrAppendList(enabled_list_strings, existing_data)\n                                                        break\n                                            elif etree.QName(child_item).localname == 'list':\n                                                enabled_value_string = _processValueItem(child_item, child_key, child_valuename, this_policy, elements_item, check_deleted=False, this_element_value=base_policy_settings[adm_namespace][admPolicy][child_item.attrib['id']])\n                                                log.trace('I have enabled value string of %s', enabled_value_string)\n                                                existing_data = _policyFileReplaceOrAppend(enabled_value_string, existing_data, append_only=True)\n    try:\n        write_reg_pol_data(data_to_write=existing_data, policy_file_path=CLASS_INFO[registry_class]['policy_path'], gpt_extension=CLASS_INFO[registry_class]['gpt_extension_location'], gpt_extension_guid=CLASS_INFO[registry_class]['gpt_extension_guid'])\n    except CommandExecutionError as exc:\n        log.exception('Unhandled exception occurred while attempting to write Adm Template Policy File.\\nException: %s', exc)\n        return False\n    return True",
            "def _writeAdminTemplateRegPolFile(admtemplate_data, adml_language='en-US', registry_class='Machine'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    helper function to prep/write adm template data to the Registry.pol file\\n\\n    each file begins with REGFILE_SIGNATURE (u'\\\\u5250\\\\u6765') and\\n    REGISTRY_FILE_VERSION (u'\\\\x01\\\\00')\\n\\n    https://msdn.microsoft.com/en-us/library/aa374407(VS.85).aspx\\n    +    https://msdn.microsoft.com/en-us/library/cc232696.aspx\\n    [Registry Path<NULL>;Reg Value<NULL>;Reg Type;SizeInBytes;Data<NULL>]\\n    \"\n    existing_data = b''\n    policySearchXpath = '//ns1:*[@id = \"{0}\" or @name = \"{0}\"]'\n    admx_policy_definitions = _get_policy_definitions(language=adml_language)\n    adml_policy_resources = _get_policy_resources(language=adml_language)\n    base_policy_settings = _checkAllAdmxPolicies(policy_class=registry_class, adml_language=adml_language, return_full_policy_names=False, hierarchical_return=False, return_not_configured=False)\n    for adm_namespace in admtemplate_data:\n        for adm_policy in admtemplate_data[adm_namespace]:\n            if str(admtemplate_data[adm_namespace][adm_policy]).lower() == 'not configured':\n                if base_policy_settings.get(adm_namespace, {}).pop(adm_policy, None) is not None:\n                    log.trace('Policy \"%s\" removed', adm_policy)\n            else:\n                log.trace('adding %s to base_policy_settings', adm_policy)\n                if adm_namespace not in base_policy_settings:\n                    base_policy_settings[adm_namespace] = {}\n                base_policy_settings[adm_namespace][adm_policy] = admtemplate_data[adm_namespace][adm_policy]\n    for adm_namespace in base_policy_settings:\n        for admPolicy in base_policy_settings[adm_namespace]:\n            log.trace('working on admPolicy %s', admPolicy)\n            explicit_enable_disable_value_setting = False\n            this_key = None\n            this_valuename = None\n            if str(base_policy_settings[adm_namespace][admPolicy]).lower() == 'disabled':\n                log.trace('time to disable %s', admPolicy)\n                this_policy = admx_policy_definitions.xpath(policySearchXpath.format(admPolicy), namespaces={'ns1': adm_namespace})\n                if this_policy:\n                    this_policy = this_policy[0]\n                    if 'class' in this_policy.attrib:\n                        if this_policy.attrib['class'] == registry_class or this_policy.attrib['class'] == 'Both':\n                            if 'key' in this_policy.attrib:\n                                this_key = this_policy.attrib['key']\n                            else:\n                                log.error('policy item %s does not have the required \"key\" attribute', this_policy.attrib)\n                                break\n                            if 'valueName' in this_policy.attrib:\n                                this_valuename = this_policy.attrib['valueName']\n                            if DISABLED_VALUE_XPATH(this_policy):\n                                explicit_enable_disable_value_setting = True\n                                disabled_value_string = _checkValueItemParent(this_policy, admPolicy, this_key, this_valuename, DISABLED_VALUE_XPATH, None, check_deleted=False, test_item=False)\n                                existing_data = _policyFileReplaceOrAppend(disabled_value_string, existing_data)\n                            if DISABLED_LIST_XPATH(this_policy):\n                                explicit_enable_disable_value_setting = True\n                                disabled_list_strings = _checkListItem(this_policy, admPolicy, this_key, DISABLED_LIST_XPATH, None, test_items=False)\n                                log.trace('working with disabledList portion of %s', admPolicy)\n                                existing_data = _policyFileReplaceOrAppendList(disabled_list_strings, existing_data)\n                            if not explicit_enable_disable_value_setting and this_valuename:\n                                disabled_value_string = _buildKnownDataSearchString(this_key, this_valuename, 'REG_DWORD', None, check_deleted=True)\n                                existing_data = _policyFileReplaceOrAppend(disabled_value_string, existing_data)\n                            if ELEMENTS_XPATH(this_policy):\n                                log.trace('checking elements of %s', admPolicy)\n                                for elements_item in ELEMENTS_XPATH(this_policy):\n                                    for child_item in elements_item:\n                                        child_key = this_key\n                                        child_valuename = this_valuename\n                                        if 'key' in child_item.attrib:\n                                            child_key = child_item.attrib['key']\n                                        if 'valueName' in child_item.attrib:\n                                            child_valuename = child_item.attrib['valueName']\n                                        if etree.QName(child_item).localname == 'boolean' and (TRUE_LIST_XPATH(child_item) or FALSE_LIST_XPATH(child_item)):\n                                            temp_dict = {'trueList': TRUE_LIST_XPATH, 'falseList': FALSE_LIST_XPATH}\n                                            for this_list in temp_dict:\n                                                disabled_list_strings = _checkListItem(child_item, admPolicy, child_key, temp_dict[this_list], None, test_items=False)\n                                                log.trace('working with %s portion of %s', admPolicy, this_list)\n                                                existing_data = _policyFileReplaceOrAppendList(disabled_list_strings, existing_data)\n                                        elif etree.QName(child_item).localname == 'boolean' or etree.QName(child_item).localname == 'decimal' or etree.QName(child_item).localname == 'text' or (etree.QName(child_item).localname == 'longDecimal') or (etree.QName(child_item).localname == 'multiText') or (etree.QName(child_item).localname == 'enum'):\n                                            disabled_value_string = _processValueItem(child_item, child_key, child_valuename, this_policy, elements_item, check_deleted=True)\n                                            log.trace('I have disabled value string of %s', disabled_value_string)\n                                            existing_data = _policyFileReplaceOrAppend(disabled_value_string, existing_data)\n                                        elif etree.QName(child_item).localname == 'list':\n                                            disabled_value_string = _processValueItem(child_item, child_key, child_valuename, this_policy, elements_item, check_deleted=True)\n                                            log.trace('I have disabled value string of %s', disabled_value_string)\n                                            existing_data = _policyFileReplaceOrAppend(disabled_value_string, existing_data)\n                        else:\n                            log.error('policy %s was found but it does not appear to be valid for the class %s', admPolicy, registry_class)\n                    else:\n                        log.error('policy item %s does not have the required \"class\" attribute', this_policy.attrib)\n            else:\n                log.trace('time to enable and set the policy \"%s\"', admPolicy)\n                this_policy = admx_policy_definitions.xpath(policySearchXpath.format(admPolicy), namespaces={'ns1': adm_namespace})\n                log.trace('found this_policy == %s', this_policy)\n                if this_policy:\n                    this_policy = this_policy[0]\n                    if 'class' in this_policy.attrib:\n                        if this_policy.attrib['class'] == registry_class or this_policy.attrib['class'] == 'Both':\n                            if 'key' in this_policy.attrib:\n                                this_key = this_policy.attrib['key']\n                            else:\n                                log.error('policy item %s does not have the required \"key\" attribute', this_policy.attrib)\n                                break\n                            if 'valueName' in this_policy.attrib:\n                                this_valuename = this_policy.attrib['valueName']\n                            if ENABLED_VALUE_XPATH(this_policy):\n                                explicit_enable_disable_value_setting = True\n                                enabled_value_string = _checkValueItemParent(this_policy, admPolicy, this_key, this_valuename, ENABLED_VALUE_XPATH, None, check_deleted=False, test_item=False)\n                                existing_data = _policyFileReplaceOrAppend(enabled_value_string, existing_data)\n                            if ENABLED_LIST_XPATH(this_policy):\n                                explicit_enable_disable_value_setting = True\n                                enabled_list_strings = _checkListItem(this_policy, admPolicy, this_key, ENABLED_LIST_XPATH, None, test_items=False)\n                                log.trace('working with enabledList portion of %s', admPolicy)\n                                existing_data = _policyFileReplaceOrAppendList(enabled_list_strings, existing_data)\n                            if not explicit_enable_disable_value_setting and this_valuename:\n                                enabled_value_string = _buildKnownDataSearchString(this_key, this_valuename, 'REG_DWORD', '1', check_deleted=False)\n                                existing_data = _policyFileReplaceOrAppend(enabled_value_string, existing_data)\n                            if ELEMENTS_XPATH(this_policy):\n                                for elements_item in ELEMENTS_XPATH(this_policy):\n                                    for child_item in elements_item:\n                                        child_key = this_key\n                                        child_valuename = this_valuename\n                                        if 'key' in child_item.attrib:\n                                            child_key = child_item.attrib['key']\n                                        if 'valueName' in child_item.attrib:\n                                            child_valuename = child_item.attrib['valueName']\n                                        if child_item.attrib['id'] in base_policy_settings[adm_namespace][admPolicy]:\n                                            if etree.QName(child_item).localname == 'boolean' and (TRUE_LIST_XPATH(child_item) or FALSE_LIST_XPATH(child_item)):\n                                                list_strings = []\n                                                if base_policy_settings[adm_namespace][admPolicy][child_item.attrib['id']]:\n                                                    list_strings = _checkListItem(child_item, admPolicy, child_key, TRUE_LIST_XPATH, None, test_items=False)\n                                                    log.trace('working with trueList portion of %s', admPolicy)\n                                                else:\n                                                    list_strings = _checkListItem(child_item, admPolicy, child_key, FALSE_LIST_XPATH, None, test_items=False)\n                                                existing_data = _policyFileReplaceOrAppendList(list_strings, existing_data)\n                                            elif etree.QName(child_item).localname == 'boolean' and (TRUE_VALUE_XPATH(child_item) or FALSE_VALUE_XPATH(child_item)):\n                                                value_string = ''\n                                                if base_policy_settings[adm_namespace][admPolicy][child_item.attrib['id']]:\n                                                    value_string = _checkValueItemParent(child_item, admPolicy, child_key, child_valuename, TRUE_VALUE_XPATH, None, check_deleted=False, test_item=False)\n                                                else:\n                                                    value_string = _checkValueItemParent(child_item, admPolicy, child_key, child_valuename, FALSE_VALUE_XPATH, None, check_deleted=False, test_item=False)\n                                                existing_data = _policyFileReplaceOrAppend(value_string, existing_data)\n                                            elif etree.QName(child_item).localname == 'boolean' or etree.QName(child_item).localname == 'decimal' or etree.QName(child_item).localname == 'text' or (etree.QName(child_item).localname == 'longDecimal') or (etree.QName(child_item).localname == 'multiText'):\n                                                enabled_value_string = _processValueItem(child_item, child_key, child_valuename, this_policy, elements_item, check_deleted=False, this_element_value=base_policy_settings[adm_namespace][admPolicy][child_item.attrib['id']])\n                                                log.trace('I have enabled value string of %s', enabled_value_string)\n                                                existing_data = _policyFileReplaceOrAppend(enabled_value_string, existing_data)\n                                            elif etree.QName(child_item).localname == 'enum':\n                                                for enum_item in child_item:\n                                                    if base_policy_settings[adm_namespace][admPolicy][child_item.attrib['id']] == _getAdmlDisplayName(adml_policy_resources, enum_item.attrib['displayName']).strip():\n                                                        enabled_value_string = _checkValueItemParent(enum_item, child_item.attrib['id'], child_key, child_valuename, VALUE_XPATH, None, check_deleted=False, test_item=False)\n                                                        existing_data = _policyFileReplaceOrAppend(enabled_value_string, existing_data)\n                                                        if VALUE_LIST_XPATH(enum_item):\n                                                            enabled_list_strings = _checkListItem(enum_item, admPolicy, child_key, VALUE_LIST_XPATH, None, test_items=False)\n                                                            log.trace('working with valueList portion of %s', child_item.attrib['id'])\n                                                            existing_data = _policyFileReplaceOrAppendList(enabled_list_strings, existing_data)\n                                                        break\n                                            elif etree.QName(child_item).localname == 'list':\n                                                enabled_value_string = _processValueItem(child_item, child_key, child_valuename, this_policy, elements_item, check_deleted=False, this_element_value=base_policy_settings[adm_namespace][admPolicy][child_item.attrib['id']])\n                                                log.trace('I have enabled value string of %s', enabled_value_string)\n                                                existing_data = _policyFileReplaceOrAppend(enabled_value_string, existing_data, append_only=True)\n    try:\n        write_reg_pol_data(data_to_write=existing_data, policy_file_path=CLASS_INFO[registry_class]['policy_path'], gpt_extension=CLASS_INFO[registry_class]['gpt_extension_location'], gpt_extension_guid=CLASS_INFO[registry_class]['gpt_extension_guid'])\n    except CommandExecutionError as exc:\n        log.exception('Unhandled exception occurred while attempting to write Adm Template Policy File.\\nException: %s', exc)\n        return False\n    return True"
        ]
    },
    {
        "func_name": "_getScriptSettingsFromIniFile",
        "original": "def _getScriptSettingsFromIniFile(policy_info):\n    \"\"\"\n    helper function to parse/read a GPO Startup/Shutdown script file\n\n    psscript.ini and script.ini file definitions are here\n        https://msdn.microsoft.com/en-us/library/ff842529.aspx\n        https://msdn.microsoft.com/en-us/library/dd303238.aspx\n    \"\"\"\n    _existingData = None\n    if os.path.isfile(policy_info['ScriptIni']['IniPath']):\n        with salt.utils.files.fopen(policy_info['ScriptIni']['IniPath'], 'rb') as fhr:\n            _existingData = fhr.read()\n        if _existingData:\n            try:\n                _existingData = deserialize(_existingData.decode('utf-16-le').lstrip('\\ufeff'))\n                log.trace('Have deserialized data %s', _existingData)\n            except Exception as error:\n                log.exception('An error occurred attempting to deserialize data for %s', policy_info['Policy'])\n                raise CommandExecutionError(error)\n            if 'Section' in policy_info['ScriptIni'] and policy_info['ScriptIni']['Section'].lower() in [z.lower() for z in _existingData.keys()]:\n                if 'SettingName' in policy_info['ScriptIni']:\n                    log.trace('Need to look for %s', policy_info['ScriptIni']['SettingName'])\n                    if policy_info['ScriptIni']['SettingName'].lower() in [z.lower() for z in _existingData[policy_info['ScriptIni']['Section']].keys()]:\n                        return _existingData[policy_info['ScriptIni']['Section']][policy_info['ScriptIni']['SettingName'].lower()]\n                    else:\n                        return None\n                else:\n                    return _existingData[policy_info['ScriptIni']['Section']]\n            else:\n                return None\n    return None",
        "mutated": [
            "def _getScriptSettingsFromIniFile(policy_info):\n    if False:\n        i = 10\n    '\\n    helper function to parse/read a GPO Startup/Shutdown script file\\n\\n    psscript.ini and script.ini file definitions are here\\n        https://msdn.microsoft.com/en-us/library/ff842529.aspx\\n        https://msdn.microsoft.com/en-us/library/dd303238.aspx\\n    '\n    _existingData = None\n    if os.path.isfile(policy_info['ScriptIni']['IniPath']):\n        with salt.utils.files.fopen(policy_info['ScriptIni']['IniPath'], 'rb') as fhr:\n            _existingData = fhr.read()\n        if _existingData:\n            try:\n                _existingData = deserialize(_existingData.decode('utf-16-le').lstrip('\\ufeff'))\n                log.trace('Have deserialized data %s', _existingData)\n            except Exception as error:\n                log.exception('An error occurred attempting to deserialize data for %s', policy_info['Policy'])\n                raise CommandExecutionError(error)\n            if 'Section' in policy_info['ScriptIni'] and policy_info['ScriptIni']['Section'].lower() in [z.lower() for z in _existingData.keys()]:\n                if 'SettingName' in policy_info['ScriptIni']:\n                    log.trace('Need to look for %s', policy_info['ScriptIni']['SettingName'])\n                    if policy_info['ScriptIni']['SettingName'].lower() in [z.lower() for z in _existingData[policy_info['ScriptIni']['Section']].keys()]:\n                        return _existingData[policy_info['ScriptIni']['Section']][policy_info['ScriptIni']['SettingName'].lower()]\n                    else:\n                        return None\n                else:\n                    return _existingData[policy_info['ScriptIni']['Section']]\n            else:\n                return None\n    return None",
            "def _getScriptSettingsFromIniFile(policy_info):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    helper function to parse/read a GPO Startup/Shutdown script file\\n\\n    psscript.ini and script.ini file definitions are here\\n        https://msdn.microsoft.com/en-us/library/ff842529.aspx\\n        https://msdn.microsoft.com/en-us/library/dd303238.aspx\\n    '\n    _existingData = None\n    if os.path.isfile(policy_info['ScriptIni']['IniPath']):\n        with salt.utils.files.fopen(policy_info['ScriptIni']['IniPath'], 'rb') as fhr:\n            _existingData = fhr.read()\n        if _existingData:\n            try:\n                _existingData = deserialize(_existingData.decode('utf-16-le').lstrip('\\ufeff'))\n                log.trace('Have deserialized data %s', _existingData)\n            except Exception as error:\n                log.exception('An error occurred attempting to deserialize data for %s', policy_info['Policy'])\n                raise CommandExecutionError(error)\n            if 'Section' in policy_info['ScriptIni'] and policy_info['ScriptIni']['Section'].lower() in [z.lower() for z in _existingData.keys()]:\n                if 'SettingName' in policy_info['ScriptIni']:\n                    log.trace('Need to look for %s', policy_info['ScriptIni']['SettingName'])\n                    if policy_info['ScriptIni']['SettingName'].lower() in [z.lower() for z in _existingData[policy_info['ScriptIni']['Section']].keys()]:\n                        return _existingData[policy_info['ScriptIni']['Section']][policy_info['ScriptIni']['SettingName'].lower()]\n                    else:\n                        return None\n                else:\n                    return _existingData[policy_info['ScriptIni']['Section']]\n            else:\n                return None\n    return None",
            "def _getScriptSettingsFromIniFile(policy_info):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    helper function to parse/read a GPO Startup/Shutdown script file\\n\\n    psscript.ini and script.ini file definitions are here\\n        https://msdn.microsoft.com/en-us/library/ff842529.aspx\\n        https://msdn.microsoft.com/en-us/library/dd303238.aspx\\n    '\n    _existingData = None\n    if os.path.isfile(policy_info['ScriptIni']['IniPath']):\n        with salt.utils.files.fopen(policy_info['ScriptIni']['IniPath'], 'rb') as fhr:\n            _existingData = fhr.read()\n        if _existingData:\n            try:\n                _existingData = deserialize(_existingData.decode('utf-16-le').lstrip('\\ufeff'))\n                log.trace('Have deserialized data %s', _existingData)\n            except Exception as error:\n                log.exception('An error occurred attempting to deserialize data for %s', policy_info['Policy'])\n                raise CommandExecutionError(error)\n            if 'Section' in policy_info['ScriptIni'] and policy_info['ScriptIni']['Section'].lower() in [z.lower() for z in _existingData.keys()]:\n                if 'SettingName' in policy_info['ScriptIni']:\n                    log.trace('Need to look for %s', policy_info['ScriptIni']['SettingName'])\n                    if policy_info['ScriptIni']['SettingName'].lower() in [z.lower() for z in _existingData[policy_info['ScriptIni']['Section']].keys()]:\n                        return _existingData[policy_info['ScriptIni']['Section']][policy_info['ScriptIni']['SettingName'].lower()]\n                    else:\n                        return None\n                else:\n                    return _existingData[policy_info['ScriptIni']['Section']]\n            else:\n                return None\n    return None",
            "def _getScriptSettingsFromIniFile(policy_info):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    helper function to parse/read a GPO Startup/Shutdown script file\\n\\n    psscript.ini and script.ini file definitions are here\\n        https://msdn.microsoft.com/en-us/library/ff842529.aspx\\n        https://msdn.microsoft.com/en-us/library/dd303238.aspx\\n    '\n    _existingData = None\n    if os.path.isfile(policy_info['ScriptIni']['IniPath']):\n        with salt.utils.files.fopen(policy_info['ScriptIni']['IniPath'], 'rb') as fhr:\n            _existingData = fhr.read()\n        if _existingData:\n            try:\n                _existingData = deserialize(_existingData.decode('utf-16-le').lstrip('\\ufeff'))\n                log.trace('Have deserialized data %s', _existingData)\n            except Exception as error:\n                log.exception('An error occurred attempting to deserialize data for %s', policy_info['Policy'])\n                raise CommandExecutionError(error)\n            if 'Section' in policy_info['ScriptIni'] and policy_info['ScriptIni']['Section'].lower() in [z.lower() for z in _existingData.keys()]:\n                if 'SettingName' in policy_info['ScriptIni']:\n                    log.trace('Need to look for %s', policy_info['ScriptIni']['SettingName'])\n                    if policy_info['ScriptIni']['SettingName'].lower() in [z.lower() for z in _existingData[policy_info['ScriptIni']['Section']].keys()]:\n                        return _existingData[policy_info['ScriptIni']['Section']][policy_info['ScriptIni']['SettingName'].lower()]\n                    else:\n                        return None\n                else:\n                    return _existingData[policy_info['ScriptIni']['Section']]\n            else:\n                return None\n    return None",
            "def _getScriptSettingsFromIniFile(policy_info):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    helper function to parse/read a GPO Startup/Shutdown script file\\n\\n    psscript.ini and script.ini file definitions are here\\n        https://msdn.microsoft.com/en-us/library/ff842529.aspx\\n        https://msdn.microsoft.com/en-us/library/dd303238.aspx\\n    '\n    _existingData = None\n    if os.path.isfile(policy_info['ScriptIni']['IniPath']):\n        with salt.utils.files.fopen(policy_info['ScriptIni']['IniPath'], 'rb') as fhr:\n            _existingData = fhr.read()\n        if _existingData:\n            try:\n                _existingData = deserialize(_existingData.decode('utf-16-le').lstrip('\\ufeff'))\n                log.trace('Have deserialized data %s', _existingData)\n            except Exception as error:\n                log.exception('An error occurred attempting to deserialize data for %s', policy_info['Policy'])\n                raise CommandExecutionError(error)\n            if 'Section' in policy_info['ScriptIni'] and policy_info['ScriptIni']['Section'].lower() in [z.lower() for z in _existingData.keys()]:\n                if 'SettingName' in policy_info['ScriptIni']:\n                    log.trace('Need to look for %s', policy_info['ScriptIni']['SettingName'])\n                    if policy_info['ScriptIni']['SettingName'].lower() in [z.lower() for z in _existingData[policy_info['ScriptIni']['Section']].keys()]:\n                        return _existingData[policy_info['ScriptIni']['Section']][policy_info['ScriptIni']['SettingName'].lower()]\n                    else:\n                        return None\n                else:\n                    return _existingData[policy_info['ScriptIni']['Section']]\n            else:\n                return None\n    return None"
        ]
    },
    {
        "func_name": "_writeGpoScript",
        "original": "def _writeGpoScript(psscript=False):\n    \"\"\"\n    helper function to write local GPO startup/shutdown script\n\n    scripts are stored in scripts.ini and psscripts.ini files in\n    ``WINDIR\\\\System32\\\\GroupPolicy\\\\Machine|User\\\\Scripts``\n\n    these files have the hidden attribute set\n\n    files have following format:\n        empty line\n        [Startup]\n        0CmdLine=<path to script 0>\n        0Parameters=<script 0 parameters>\n        [Shutdown]\n        0CmdLine=<path to shutdown script 0>\n        0Parameters=<shutdown script 0 parameters>\n\n    Number is incremented for each script added\n\n    psscript file also has the option of a [ScriptsConfig] section, which has\n    the following two parameters:\n        StartExecutePSFirst\n        EndExecutePSFirst\n\n    these can be set to True/False to denote if the powershell startup/shutdown\n    scripts execute first (True) or last (False), if the value isn't set, then\n    it is 'Not Configured' in the GUI\n    \"\"\"\n    _machineScriptPolicyPath = os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'Machine', 'Scripts', 'scripts.ini')\n    _machinePowershellScriptPolicyPath = os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'Machine', 'Scripts', 'psscripts.ini')\n    _userScriptPolicyPath = os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'User', 'Scripts', 'scripts.ini')\n    _userPowershellScriptPolicyPath = os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'User', 'Scripts', 'psscripts.ini')",
        "mutated": [
            "def _writeGpoScript(psscript=False):\n    if False:\n        i = 10\n    \"\\n    helper function to write local GPO startup/shutdown script\\n\\n    scripts are stored in scripts.ini and psscripts.ini files in\\n    ``WINDIR\\\\System32\\\\GroupPolicy\\\\Machine|User\\\\Scripts``\\n\\n    these files have the hidden attribute set\\n\\n    files have following format:\\n        empty line\\n        [Startup]\\n        0CmdLine=<path to script 0>\\n        0Parameters=<script 0 parameters>\\n        [Shutdown]\\n        0CmdLine=<path to shutdown script 0>\\n        0Parameters=<shutdown script 0 parameters>\\n\\n    Number is incremented for each script added\\n\\n    psscript file also has the option of a [ScriptsConfig] section, which has\\n    the following two parameters:\\n        StartExecutePSFirst\\n        EndExecutePSFirst\\n\\n    these can be set to True/False to denote if the powershell startup/shutdown\\n    scripts execute first (True) or last (False), if the value isn't set, then\\n    it is 'Not Configured' in the GUI\\n    \"\n    _machineScriptPolicyPath = os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'Machine', 'Scripts', 'scripts.ini')\n    _machinePowershellScriptPolicyPath = os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'Machine', 'Scripts', 'psscripts.ini')\n    _userScriptPolicyPath = os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'User', 'Scripts', 'scripts.ini')\n    _userPowershellScriptPolicyPath = os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'User', 'Scripts', 'psscripts.ini')",
            "def _writeGpoScript(psscript=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    helper function to write local GPO startup/shutdown script\\n\\n    scripts are stored in scripts.ini and psscripts.ini files in\\n    ``WINDIR\\\\System32\\\\GroupPolicy\\\\Machine|User\\\\Scripts``\\n\\n    these files have the hidden attribute set\\n\\n    files have following format:\\n        empty line\\n        [Startup]\\n        0CmdLine=<path to script 0>\\n        0Parameters=<script 0 parameters>\\n        [Shutdown]\\n        0CmdLine=<path to shutdown script 0>\\n        0Parameters=<shutdown script 0 parameters>\\n\\n    Number is incremented for each script added\\n\\n    psscript file also has the option of a [ScriptsConfig] section, which has\\n    the following two parameters:\\n        StartExecutePSFirst\\n        EndExecutePSFirst\\n\\n    these can be set to True/False to denote if the powershell startup/shutdown\\n    scripts execute first (True) or last (False), if the value isn't set, then\\n    it is 'Not Configured' in the GUI\\n    \"\n    _machineScriptPolicyPath = os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'Machine', 'Scripts', 'scripts.ini')\n    _machinePowershellScriptPolicyPath = os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'Machine', 'Scripts', 'psscripts.ini')\n    _userScriptPolicyPath = os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'User', 'Scripts', 'scripts.ini')\n    _userPowershellScriptPolicyPath = os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'User', 'Scripts', 'psscripts.ini')",
            "def _writeGpoScript(psscript=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    helper function to write local GPO startup/shutdown script\\n\\n    scripts are stored in scripts.ini and psscripts.ini files in\\n    ``WINDIR\\\\System32\\\\GroupPolicy\\\\Machine|User\\\\Scripts``\\n\\n    these files have the hidden attribute set\\n\\n    files have following format:\\n        empty line\\n        [Startup]\\n        0CmdLine=<path to script 0>\\n        0Parameters=<script 0 parameters>\\n        [Shutdown]\\n        0CmdLine=<path to shutdown script 0>\\n        0Parameters=<shutdown script 0 parameters>\\n\\n    Number is incremented for each script added\\n\\n    psscript file also has the option of a [ScriptsConfig] section, which has\\n    the following two parameters:\\n        StartExecutePSFirst\\n        EndExecutePSFirst\\n\\n    these can be set to True/False to denote if the powershell startup/shutdown\\n    scripts execute first (True) or last (False), if the value isn't set, then\\n    it is 'Not Configured' in the GUI\\n    \"\n    _machineScriptPolicyPath = os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'Machine', 'Scripts', 'scripts.ini')\n    _machinePowershellScriptPolicyPath = os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'Machine', 'Scripts', 'psscripts.ini')\n    _userScriptPolicyPath = os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'User', 'Scripts', 'scripts.ini')\n    _userPowershellScriptPolicyPath = os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'User', 'Scripts', 'psscripts.ini')",
            "def _writeGpoScript(psscript=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    helper function to write local GPO startup/shutdown script\\n\\n    scripts are stored in scripts.ini and psscripts.ini files in\\n    ``WINDIR\\\\System32\\\\GroupPolicy\\\\Machine|User\\\\Scripts``\\n\\n    these files have the hidden attribute set\\n\\n    files have following format:\\n        empty line\\n        [Startup]\\n        0CmdLine=<path to script 0>\\n        0Parameters=<script 0 parameters>\\n        [Shutdown]\\n        0CmdLine=<path to shutdown script 0>\\n        0Parameters=<shutdown script 0 parameters>\\n\\n    Number is incremented for each script added\\n\\n    psscript file also has the option of a [ScriptsConfig] section, which has\\n    the following two parameters:\\n        StartExecutePSFirst\\n        EndExecutePSFirst\\n\\n    these can be set to True/False to denote if the powershell startup/shutdown\\n    scripts execute first (True) or last (False), if the value isn't set, then\\n    it is 'Not Configured' in the GUI\\n    \"\n    _machineScriptPolicyPath = os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'Machine', 'Scripts', 'scripts.ini')\n    _machinePowershellScriptPolicyPath = os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'Machine', 'Scripts', 'psscripts.ini')\n    _userScriptPolicyPath = os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'User', 'Scripts', 'scripts.ini')\n    _userPowershellScriptPolicyPath = os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'User', 'Scripts', 'psscripts.ini')",
            "def _writeGpoScript(psscript=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    helper function to write local GPO startup/shutdown script\\n\\n    scripts are stored in scripts.ini and psscripts.ini files in\\n    ``WINDIR\\\\System32\\\\GroupPolicy\\\\Machine|User\\\\Scripts``\\n\\n    these files have the hidden attribute set\\n\\n    files have following format:\\n        empty line\\n        [Startup]\\n        0CmdLine=<path to script 0>\\n        0Parameters=<script 0 parameters>\\n        [Shutdown]\\n        0CmdLine=<path to shutdown script 0>\\n        0Parameters=<shutdown script 0 parameters>\\n\\n    Number is incremented for each script added\\n\\n    psscript file also has the option of a [ScriptsConfig] section, which has\\n    the following two parameters:\\n        StartExecutePSFirst\\n        EndExecutePSFirst\\n\\n    these can be set to True/False to denote if the powershell startup/shutdown\\n    scripts execute first (True) or last (False), if the value isn't set, then\\n    it is 'Not Configured' in the GUI\\n    \"\n    _machineScriptPolicyPath = os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'Machine', 'Scripts', 'scripts.ini')\n    _machinePowershellScriptPolicyPath = os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'Machine', 'Scripts', 'psscripts.ini')\n    _userScriptPolicyPath = os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'User', 'Scripts', 'scripts.ini')\n    _userPowershellScriptPolicyPath = os.path.join(os.getenv('WINDIR'), 'System32', 'GroupPolicy', 'User', 'Scripts', 'psscripts.ini')"
        ]
    },
    {
        "func_name": "_lookup_admin_template",
        "original": "def _lookup_admin_template(policy_name, policy_class, adml_language='en-US'):\n    \"\"\"\n    (success_flag, policy_xml_item, policy_name_list, message)\n    \"\"\"\n    policy_aliases = []\n    admx_policy_definitions = _get_policy_definitions(language=adml_language)\n    adml_policy_resources = _get_policy_resources(language=adml_language)\n    admx_search_results = ADMX_SEARCH_XPATH(admx_policy_definitions, policy_name=policy_name, registry_class=policy_class)\n    if admx_search_results:\n        if len(admx_search_results) == 1:\n            the_policy = admx_search_results[0]\n            policy_display_name = _getFullPolicyName(policy_item=the_policy, policy_name=the_policy.attrib['name'], return_full_policy_names=True, adml_language=adml_language)\n            policy_aliases.append(policy_display_name)\n            policy_aliases.append(the_policy.attrib['name'])\n            full_path_list = _build_parent_list(policy_definition=the_policy, return_full_policy_names=True, adml_language=adml_language)\n            full_path_list.reverse()\n            full_path_list.append(policy_display_name)\n            policy_aliases.append('\\\\'.join(full_path_list))\n            return (True, the_policy, policy_aliases, None)\n        else:\n            policy_aliases = []\n            for the_policy in admx_search_results:\n                policy_display_name = _getFullPolicyName(policy_item=the_policy, policy_name=the_policy.attrib['name'], return_full_policy_names=True, adml_language=adml_language)\n                full_path_list = _build_parent_list(policy_definition=the_policy, return_full_policy_names=True, adml_language=adml_language)\n                full_path_list.append(policy_display_name)\n                policy_aliases.append('\\\\'.join(full_path_list))\n            policies = '\\n - '.join(policy_aliases)\n            msg = 'ADMX policy name/id \"{}\" is used in multiple ADMX files.\\nTry one of the following names:\\n - {}'.format(policy_name, policies)\n            return (False, None, [], msg)\n    else:\n        adml_search_results = ADML_SEARCH_XPATH(adml_policy_resources, policy_name=policy_name)\n        hierarchy = []\n        hierarchy_policy_name = policy_name\n        if not adml_search_results:\n            log.warning('Trying another: %s', policy_name)\n            if '\\\\' in policy_name:\n                hierarchy = policy_name.split('\\\\')\n                policy_name = hierarchy.pop()\n                adml_search_results = ADML_SEARCH_XPATH(adml_policy_resources, policy_name=policy_name)\n        if adml_search_results:\n            multiple_adml_entries = False\n            suggested_policies = ''\n            adml_to_remove = []\n            if len(adml_search_results) > 1:\n                log.trace('multiple ADML entries found matching the policy name %s', policy_name)\n                multiple_adml_entries = True\n                for adml_search_result in adml_search_results:\n                    if not getattr(adml_search_result, 'text', '').strip() == policy_name:\n                        adml_to_remove.append(adml_search_result)\n                    elif hierarchy:\n                        log.trace('we have hierarchy of %s', hierarchy)\n                        display_name_searchval = '$({}.{})'.format(adml_search_result.tag.split('}')[1], adml_search_result.attrib['id'])\n                        policy_search_string = '//{}:policy[@displayName = \"{}\" and (@class = \"Both\" or @class = \"{}\") ]'.format(adml_search_result.prefix, display_name_searchval, policy_class)\n                        admx_results = []\n                        these_admx_search_results = admx_policy_definitions.xpath(policy_search_string, namespaces=adml_search_result.nsmap)\n                        if not these_admx_search_results:\n                            log.trace('No admx was found for the adml entry %s, it will be removed', display_name_searchval)\n                            adml_to_remove.append(adml_search_result)\n                        for search_result in these_admx_search_results:\n                            log.trace('policy_name == %s', policy_name)\n                            this_hierarchy = _build_parent_list(policy_definition=search_result, return_full_policy_names=True, adml_language=adml_language)\n                            this_hierarchy.reverse()\n                            if hierarchy != this_hierarchy:\n                                log.trace(\"hierarchy %s does not match this item's hierarchy of %s\", hierarchy, this_hierarchy)\n                                if len(these_admx_search_results) == 1:\n                                    log.trace('only 1 admx was found and it does not match this adml, it is safe to remove from the list')\n                                    adml_to_remove.append(adml_search_result)\n                            else:\n                                log.trace(\"hierarchy %s matches item's hierarchy of %s\", hierarchy, this_hierarchy)\n                                log.trace('search_result %s added to results', search_result)\n                                admx_results.append(search_result)\n                        if len(admx_results) == 1:\n                            admx_search_results.append(admx_results[0])\n                    else:\n                        display_name_searchval = '$({}.{})'.format(adml_search_result.tag.split('}')[1], adml_search_result.attrib['id'])\n                        these_admx_search_results = ADMX_DISPLAYNAME_SEARCH_XPATH(admx_policy_definitions, display_name=display_name_searchval, registry_class=policy_class)\n                        if not these_admx_search_results:\n                            adml_to_remove.append(adml_search_result)\n            for adml in adml_to_remove:\n                if adml in adml_search_results:\n                    adml_search_results.remove(adml)\n            if len(adml_search_results) == 1 and multiple_adml_entries:\n                multiple_adml_entries = False\n            for adml_search_result in adml_search_results:\n                log.trace('found an ADML entry matching the string! %s -- %s', adml_search_result.tag, adml_search_result.attrib)\n                display_name_searchval = '$({}.{})'.format(adml_search_result.tag.split('}')[1], adml_search_result.attrib['id'])\n                log.trace('searching for displayName == %s', display_name_searchval)\n                if not admx_search_results:\n                    log.trace('search for an admx entry matching display_name %s and registry_class %s', display_name_searchval, policy_class)\n                    admx_search_results = ADMX_DISPLAYNAME_SEARCH_XPATH(admx_policy_definitions, display_name=display_name_searchval, registry_class=policy_class)\n                if admx_search_results:\n                    log.trace('processing admx_search_results of %s', admx_search_results)\n                    log.trace('multiple_adml_entries is %s', multiple_adml_entries)\n                    if (len(admx_search_results) == 1 or hierarchy) and (not multiple_adml_entries):\n                        found = False\n                        for search_result in admx_search_results:\n                            found = False\n                            if hierarchy:\n                                this_hierarchy = _build_parent_list(policy_definition=search_result, return_full_policy_names=True, adml_language=adml_language)\n                                this_hierarchy.reverse()\n                                log.trace('testing %s == %s', hierarchy, this_hierarchy)\n                                if hierarchy == this_hierarchy:\n                                    found = True\n                            else:\n                                found = True\n                            if found:\n                                log.trace('found the ADMX policy matching the display name %s -- %s', search_result, policy_name)\n                                if 'name' in search_result.attrib:\n                                    policy_display_name = _getFullPolicyName(policy_item=search_result, policy_name=search_result.attrib['name'], return_full_policy_names=True, adml_language=adml_language)\n                                    policy_aliases.append(policy_display_name)\n                                    policy_aliases.append(search_result.attrib['name'])\n                                    full_path_list = _build_parent_list(policy_definition=search_result, return_full_policy_names=True, adml_language=adml_language)\n                                    full_path_list.reverse()\n                                    full_path_list.append(policy_display_name)\n                                    policy_aliases.append('\\\\'.join(full_path_list))\n                                    return (True, search_result, policy_aliases, None)\n                                else:\n                                    msg = 'ADMX policy with the display name {} does nothave the required name attribute'\n                                    msg = msg.format(policy_name)\n                                    return (False, None, [], msg)\n                        if not found:\n                            msg = 'Unable to correlate {} to any policy'.format(hierarchy_policy_name)\n                            return (False, None, [], msg)\n                    else:\n                        for possible_policy in admx_search_results:\n                            this_parent_list = _build_parent_list(policy_definition=possible_policy, return_full_policy_names=True, adml_language=adml_language)\n                            this_parent_list.reverse()\n                            this_parent_list.append(policy_name)\n                            if suggested_policies:\n                                suggested_policies = ', '.join([suggested_policies, '\\\\'.join(this_parent_list)])\n                            else:\n                                suggested_policies = '\\\\'.join(this_parent_list)\n            if suggested_policies:\n                msg = 'ADML policy name \"{}\" is used as the display name for multiple policies. These policies matched: {}. You can utilize these long names to specify the correct policy'\n                return (False, None, [], msg.format(policy_name, suggested_policies))\n    return (False, None, [], f'Unable to find {policy_class} policy {policy_name}')",
        "mutated": [
            "def _lookup_admin_template(policy_name, policy_class, adml_language='en-US'):\n    if False:\n        i = 10\n    '\\n    (success_flag, policy_xml_item, policy_name_list, message)\\n    '\n    policy_aliases = []\n    admx_policy_definitions = _get_policy_definitions(language=adml_language)\n    adml_policy_resources = _get_policy_resources(language=adml_language)\n    admx_search_results = ADMX_SEARCH_XPATH(admx_policy_definitions, policy_name=policy_name, registry_class=policy_class)\n    if admx_search_results:\n        if len(admx_search_results) == 1:\n            the_policy = admx_search_results[0]\n            policy_display_name = _getFullPolicyName(policy_item=the_policy, policy_name=the_policy.attrib['name'], return_full_policy_names=True, adml_language=adml_language)\n            policy_aliases.append(policy_display_name)\n            policy_aliases.append(the_policy.attrib['name'])\n            full_path_list = _build_parent_list(policy_definition=the_policy, return_full_policy_names=True, adml_language=adml_language)\n            full_path_list.reverse()\n            full_path_list.append(policy_display_name)\n            policy_aliases.append('\\\\'.join(full_path_list))\n            return (True, the_policy, policy_aliases, None)\n        else:\n            policy_aliases = []\n            for the_policy in admx_search_results:\n                policy_display_name = _getFullPolicyName(policy_item=the_policy, policy_name=the_policy.attrib['name'], return_full_policy_names=True, adml_language=adml_language)\n                full_path_list = _build_parent_list(policy_definition=the_policy, return_full_policy_names=True, adml_language=adml_language)\n                full_path_list.append(policy_display_name)\n                policy_aliases.append('\\\\'.join(full_path_list))\n            policies = '\\n - '.join(policy_aliases)\n            msg = 'ADMX policy name/id \"{}\" is used in multiple ADMX files.\\nTry one of the following names:\\n - {}'.format(policy_name, policies)\n            return (False, None, [], msg)\n    else:\n        adml_search_results = ADML_SEARCH_XPATH(adml_policy_resources, policy_name=policy_name)\n        hierarchy = []\n        hierarchy_policy_name = policy_name\n        if not adml_search_results:\n            log.warning('Trying another: %s', policy_name)\n            if '\\\\' in policy_name:\n                hierarchy = policy_name.split('\\\\')\n                policy_name = hierarchy.pop()\n                adml_search_results = ADML_SEARCH_XPATH(adml_policy_resources, policy_name=policy_name)\n        if adml_search_results:\n            multiple_adml_entries = False\n            suggested_policies = ''\n            adml_to_remove = []\n            if len(adml_search_results) > 1:\n                log.trace('multiple ADML entries found matching the policy name %s', policy_name)\n                multiple_adml_entries = True\n                for adml_search_result in adml_search_results:\n                    if not getattr(adml_search_result, 'text', '').strip() == policy_name:\n                        adml_to_remove.append(adml_search_result)\n                    elif hierarchy:\n                        log.trace('we have hierarchy of %s', hierarchy)\n                        display_name_searchval = '$({}.{})'.format(adml_search_result.tag.split('}')[1], adml_search_result.attrib['id'])\n                        policy_search_string = '//{}:policy[@displayName = \"{}\" and (@class = \"Both\" or @class = \"{}\") ]'.format(adml_search_result.prefix, display_name_searchval, policy_class)\n                        admx_results = []\n                        these_admx_search_results = admx_policy_definitions.xpath(policy_search_string, namespaces=adml_search_result.nsmap)\n                        if not these_admx_search_results:\n                            log.trace('No admx was found for the adml entry %s, it will be removed', display_name_searchval)\n                            adml_to_remove.append(adml_search_result)\n                        for search_result in these_admx_search_results:\n                            log.trace('policy_name == %s', policy_name)\n                            this_hierarchy = _build_parent_list(policy_definition=search_result, return_full_policy_names=True, adml_language=adml_language)\n                            this_hierarchy.reverse()\n                            if hierarchy != this_hierarchy:\n                                log.trace(\"hierarchy %s does not match this item's hierarchy of %s\", hierarchy, this_hierarchy)\n                                if len(these_admx_search_results) == 1:\n                                    log.trace('only 1 admx was found and it does not match this adml, it is safe to remove from the list')\n                                    adml_to_remove.append(adml_search_result)\n                            else:\n                                log.trace(\"hierarchy %s matches item's hierarchy of %s\", hierarchy, this_hierarchy)\n                                log.trace('search_result %s added to results', search_result)\n                                admx_results.append(search_result)\n                        if len(admx_results) == 1:\n                            admx_search_results.append(admx_results[0])\n                    else:\n                        display_name_searchval = '$({}.{})'.format(adml_search_result.tag.split('}')[1], adml_search_result.attrib['id'])\n                        these_admx_search_results = ADMX_DISPLAYNAME_SEARCH_XPATH(admx_policy_definitions, display_name=display_name_searchval, registry_class=policy_class)\n                        if not these_admx_search_results:\n                            adml_to_remove.append(adml_search_result)\n            for adml in adml_to_remove:\n                if adml in adml_search_results:\n                    adml_search_results.remove(adml)\n            if len(adml_search_results) == 1 and multiple_adml_entries:\n                multiple_adml_entries = False\n            for adml_search_result in adml_search_results:\n                log.trace('found an ADML entry matching the string! %s -- %s', adml_search_result.tag, adml_search_result.attrib)\n                display_name_searchval = '$({}.{})'.format(adml_search_result.tag.split('}')[1], adml_search_result.attrib['id'])\n                log.trace('searching for displayName == %s', display_name_searchval)\n                if not admx_search_results:\n                    log.trace('search for an admx entry matching display_name %s and registry_class %s', display_name_searchval, policy_class)\n                    admx_search_results = ADMX_DISPLAYNAME_SEARCH_XPATH(admx_policy_definitions, display_name=display_name_searchval, registry_class=policy_class)\n                if admx_search_results:\n                    log.trace('processing admx_search_results of %s', admx_search_results)\n                    log.trace('multiple_adml_entries is %s', multiple_adml_entries)\n                    if (len(admx_search_results) == 1 or hierarchy) and (not multiple_adml_entries):\n                        found = False\n                        for search_result in admx_search_results:\n                            found = False\n                            if hierarchy:\n                                this_hierarchy = _build_parent_list(policy_definition=search_result, return_full_policy_names=True, adml_language=adml_language)\n                                this_hierarchy.reverse()\n                                log.trace('testing %s == %s', hierarchy, this_hierarchy)\n                                if hierarchy == this_hierarchy:\n                                    found = True\n                            else:\n                                found = True\n                            if found:\n                                log.trace('found the ADMX policy matching the display name %s -- %s', search_result, policy_name)\n                                if 'name' in search_result.attrib:\n                                    policy_display_name = _getFullPolicyName(policy_item=search_result, policy_name=search_result.attrib['name'], return_full_policy_names=True, adml_language=adml_language)\n                                    policy_aliases.append(policy_display_name)\n                                    policy_aliases.append(search_result.attrib['name'])\n                                    full_path_list = _build_parent_list(policy_definition=search_result, return_full_policy_names=True, adml_language=adml_language)\n                                    full_path_list.reverse()\n                                    full_path_list.append(policy_display_name)\n                                    policy_aliases.append('\\\\'.join(full_path_list))\n                                    return (True, search_result, policy_aliases, None)\n                                else:\n                                    msg = 'ADMX policy with the display name {} does nothave the required name attribute'\n                                    msg = msg.format(policy_name)\n                                    return (False, None, [], msg)\n                        if not found:\n                            msg = 'Unable to correlate {} to any policy'.format(hierarchy_policy_name)\n                            return (False, None, [], msg)\n                    else:\n                        for possible_policy in admx_search_results:\n                            this_parent_list = _build_parent_list(policy_definition=possible_policy, return_full_policy_names=True, adml_language=adml_language)\n                            this_parent_list.reverse()\n                            this_parent_list.append(policy_name)\n                            if suggested_policies:\n                                suggested_policies = ', '.join([suggested_policies, '\\\\'.join(this_parent_list)])\n                            else:\n                                suggested_policies = '\\\\'.join(this_parent_list)\n            if suggested_policies:\n                msg = 'ADML policy name \"{}\" is used as the display name for multiple policies. These policies matched: {}. You can utilize these long names to specify the correct policy'\n                return (False, None, [], msg.format(policy_name, suggested_policies))\n    return (False, None, [], f'Unable to find {policy_class} policy {policy_name}')",
            "def _lookup_admin_template(policy_name, policy_class, adml_language='en-US'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    (success_flag, policy_xml_item, policy_name_list, message)\\n    '\n    policy_aliases = []\n    admx_policy_definitions = _get_policy_definitions(language=adml_language)\n    adml_policy_resources = _get_policy_resources(language=adml_language)\n    admx_search_results = ADMX_SEARCH_XPATH(admx_policy_definitions, policy_name=policy_name, registry_class=policy_class)\n    if admx_search_results:\n        if len(admx_search_results) == 1:\n            the_policy = admx_search_results[0]\n            policy_display_name = _getFullPolicyName(policy_item=the_policy, policy_name=the_policy.attrib['name'], return_full_policy_names=True, adml_language=adml_language)\n            policy_aliases.append(policy_display_name)\n            policy_aliases.append(the_policy.attrib['name'])\n            full_path_list = _build_parent_list(policy_definition=the_policy, return_full_policy_names=True, adml_language=adml_language)\n            full_path_list.reverse()\n            full_path_list.append(policy_display_name)\n            policy_aliases.append('\\\\'.join(full_path_list))\n            return (True, the_policy, policy_aliases, None)\n        else:\n            policy_aliases = []\n            for the_policy in admx_search_results:\n                policy_display_name = _getFullPolicyName(policy_item=the_policy, policy_name=the_policy.attrib['name'], return_full_policy_names=True, adml_language=adml_language)\n                full_path_list = _build_parent_list(policy_definition=the_policy, return_full_policy_names=True, adml_language=adml_language)\n                full_path_list.append(policy_display_name)\n                policy_aliases.append('\\\\'.join(full_path_list))\n            policies = '\\n - '.join(policy_aliases)\n            msg = 'ADMX policy name/id \"{}\" is used in multiple ADMX files.\\nTry one of the following names:\\n - {}'.format(policy_name, policies)\n            return (False, None, [], msg)\n    else:\n        adml_search_results = ADML_SEARCH_XPATH(adml_policy_resources, policy_name=policy_name)\n        hierarchy = []\n        hierarchy_policy_name = policy_name\n        if not adml_search_results:\n            log.warning('Trying another: %s', policy_name)\n            if '\\\\' in policy_name:\n                hierarchy = policy_name.split('\\\\')\n                policy_name = hierarchy.pop()\n                adml_search_results = ADML_SEARCH_XPATH(adml_policy_resources, policy_name=policy_name)\n        if adml_search_results:\n            multiple_adml_entries = False\n            suggested_policies = ''\n            adml_to_remove = []\n            if len(adml_search_results) > 1:\n                log.trace('multiple ADML entries found matching the policy name %s', policy_name)\n                multiple_adml_entries = True\n                for adml_search_result in adml_search_results:\n                    if not getattr(adml_search_result, 'text', '').strip() == policy_name:\n                        adml_to_remove.append(adml_search_result)\n                    elif hierarchy:\n                        log.trace('we have hierarchy of %s', hierarchy)\n                        display_name_searchval = '$({}.{})'.format(adml_search_result.tag.split('}')[1], adml_search_result.attrib['id'])\n                        policy_search_string = '//{}:policy[@displayName = \"{}\" and (@class = \"Both\" or @class = \"{}\") ]'.format(adml_search_result.prefix, display_name_searchval, policy_class)\n                        admx_results = []\n                        these_admx_search_results = admx_policy_definitions.xpath(policy_search_string, namespaces=adml_search_result.nsmap)\n                        if not these_admx_search_results:\n                            log.trace('No admx was found for the adml entry %s, it will be removed', display_name_searchval)\n                            adml_to_remove.append(adml_search_result)\n                        for search_result in these_admx_search_results:\n                            log.trace('policy_name == %s', policy_name)\n                            this_hierarchy = _build_parent_list(policy_definition=search_result, return_full_policy_names=True, adml_language=adml_language)\n                            this_hierarchy.reverse()\n                            if hierarchy != this_hierarchy:\n                                log.trace(\"hierarchy %s does not match this item's hierarchy of %s\", hierarchy, this_hierarchy)\n                                if len(these_admx_search_results) == 1:\n                                    log.trace('only 1 admx was found and it does not match this adml, it is safe to remove from the list')\n                                    adml_to_remove.append(adml_search_result)\n                            else:\n                                log.trace(\"hierarchy %s matches item's hierarchy of %s\", hierarchy, this_hierarchy)\n                                log.trace('search_result %s added to results', search_result)\n                                admx_results.append(search_result)\n                        if len(admx_results) == 1:\n                            admx_search_results.append(admx_results[0])\n                    else:\n                        display_name_searchval = '$({}.{})'.format(adml_search_result.tag.split('}')[1], adml_search_result.attrib['id'])\n                        these_admx_search_results = ADMX_DISPLAYNAME_SEARCH_XPATH(admx_policy_definitions, display_name=display_name_searchval, registry_class=policy_class)\n                        if not these_admx_search_results:\n                            adml_to_remove.append(adml_search_result)\n            for adml in adml_to_remove:\n                if adml in adml_search_results:\n                    adml_search_results.remove(adml)\n            if len(adml_search_results) == 1 and multiple_adml_entries:\n                multiple_adml_entries = False\n            for adml_search_result in adml_search_results:\n                log.trace('found an ADML entry matching the string! %s -- %s', adml_search_result.tag, adml_search_result.attrib)\n                display_name_searchval = '$({}.{})'.format(adml_search_result.tag.split('}')[1], adml_search_result.attrib['id'])\n                log.trace('searching for displayName == %s', display_name_searchval)\n                if not admx_search_results:\n                    log.trace('search for an admx entry matching display_name %s and registry_class %s', display_name_searchval, policy_class)\n                    admx_search_results = ADMX_DISPLAYNAME_SEARCH_XPATH(admx_policy_definitions, display_name=display_name_searchval, registry_class=policy_class)\n                if admx_search_results:\n                    log.trace('processing admx_search_results of %s', admx_search_results)\n                    log.trace('multiple_adml_entries is %s', multiple_adml_entries)\n                    if (len(admx_search_results) == 1 or hierarchy) and (not multiple_adml_entries):\n                        found = False\n                        for search_result in admx_search_results:\n                            found = False\n                            if hierarchy:\n                                this_hierarchy = _build_parent_list(policy_definition=search_result, return_full_policy_names=True, adml_language=adml_language)\n                                this_hierarchy.reverse()\n                                log.trace('testing %s == %s', hierarchy, this_hierarchy)\n                                if hierarchy == this_hierarchy:\n                                    found = True\n                            else:\n                                found = True\n                            if found:\n                                log.trace('found the ADMX policy matching the display name %s -- %s', search_result, policy_name)\n                                if 'name' in search_result.attrib:\n                                    policy_display_name = _getFullPolicyName(policy_item=search_result, policy_name=search_result.attrib['name'], return_full_policy_names=True, adml_language=adml_language)\n                                    policy_aliases.append(policy_display_name)\n                                    policy_aliases.append(search_result.attrib['name'])\n                                    full_path_list = _build_parent_list(policy_definition=search_result, return_full_policy_names=True, adml_language=adml_language)\n                                    full_path_list.reverse()\n                                    full_path_list.append(policy_display_name)\n                                    policy_aliases.append('\\\\'.join(full_path_list))\n                                    return (True, search_result, policy_aliases, None)\n                                else:\n                                    msg = 'ADMX policy with the display name {} does nothave the required name attribute'\n                                    msg = msg.format(policy_name)\n                                    return (False, None, [], msg)\n                        if not found:\n                            msg = 'Unable to correlate {} to any policy'.format(hierarchy_policy_name)\n                            return (False, None, [], msg)\n                    else:\n                        for possible_policy in admx_search_results:\n                            this_parent_list = _build_parent_list(policy_definition=possible_policy, return_full_policy_names=True, adml_language=adml_language)\n                            this_parent_list.reverse()\n                            this_parent_list.append(policy_name)\n                            if suggested_policies:\n                                suggested_policies = ', '.join([suggested_policies, '\\\\'.join(this_parent_list)])\n                            else:\n                                suggested_policies = '\\\\'.join(this_parent_list)\n            if suggested_policies:\n                msg = 'ADML policy name \"{}\" is used as the display name for multiple policies. These policies matched: {}. You can utilize these long names to specify the correct policy'\n                return (False, None, [], msg.format(policy_name, suggested_policies))\n    return (False, None, [], f'Unable to find {policy_class} policy {policy_name}')",
            "def _lookup_admin_template(policy_name, policy_class, adml_language='en-US'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    (success_flag, policy_xml_item, policy_name_list, message)\\n    '\n    policy_aliases = []\n    admx_policy_definitions = _get_policy_definitions(language=adml_language)\n    adml_policy_resources = _get_policy_resources(language=adml_language)\n    admx_search_results = ADMX_SEARCH_XPATH(admx_policy_definitions, policy_name=policy_name, registry_class=policy_class)\n    if admx_search_results:\n        if len(admx_search_results) == 1:\n            the_policy = admx_search_results[0]\n            policy_display_name = _getFullPolicyName(policy_item=the_policy, policy_name=the_policy.attrib['name'], return_full_policy_names=True, adml_language=adml_language)\n            policy_aliases.append(policy_display_name)\n            policy_aliases.append(the_policy.attrib['name'])\n            full_path_list = _build_parent_list(policy_definition=the_policy, return_full_policy_names=True, adml_language=adml_language)\n            full_path_list.reverse()\n            full_path_list.append(policy_display_name)\n            policy_aliases.append('\\\\'.join(full_path_list))\n            return (True, the_policy, policy_aliases, None)\n        else:\n            policy_aliases = []\n            for the_policy in admx_search_results:\n                policy_display_name = _getFullPolicyName(policy_item=the_policy, policy_name=the_policy.attrib['name'], return_full_policy_names=True, adml_language=adml_language)\n                full_path_list = _build_parent_list(policy_definition=the_policy, return_full_policy_names=True, adml_language=adml_language)\n                full_path_list.append(policy_display_name)\n                policy_aliases.append('\\\\'.join(full_path_list))\n            policies = '\\n - '.join(policy_aliases)\n            msg = 'ADMX policy name/id \"{}\" is used in multiple ADMX files.\\nTry one of the following names:\\n - {}'.format(policy_name, policies)\n            return (False, None, [], msg)\n    else:\n        adml_search_results = ADML_SEARCH_XPATH(adml_policy_resources, policy_name=policy_name)\n        hierarchy = []\n        hierarchy_policy_name = policy_name\n        if not adml_search_results:\n            log.warning('Trying another: %s', policy_name)\n            if '\\\\' in policy_name:\n                hierarchy = policy_name.split('\\\\')\n                policy_name = hierarchy.pop()\n                adml_search_results = ADML_SEARCH_XPATH(adml_policy_resources, policy_name=policy_name)\n        if adml_search_results:\n            multiple_adml_entries = False\n            suggested_policies = ''\n            adml_to_remove = []\n            if len(adml_search_results) > 1:\n                log.trace('multiple ADML entries found matching the policy name %s', policy_name)\n                multiple_adml_entries = True\n                for adml_search_result in adml_search_results:\n                    if not getattr(adml_search_result, 'text', '').strip() == policy_name:\n                        adml_to_remove.append(adml_search_result)\n                    elif hierarchy:\n                        log.trace('we have hierarchy of %s', hierarchy)\n                        display_name_searchval = '$({}.{})'.format(adml_search_result.tag.split('}')[1], adml_search_result.attrib['id'])\n                        policy_search_string = '//{}:policy[@displayName = \"{}\" and (@class = \"Both\" or @class = \"{}\") ]'.format(adml_search_result.prefix, display_name_searchval, policy_class)\n                        admx_results = []\n                        these_admx_search_results = admx_policy_definitions.xpath(policy_search_string, namespaces=adml_search_result.nsmap)\n                        if not these_admx_search_results:\n                            log.trace('No admx was found for the adml entry %s, it will be removed', display_name_searchval)\n                            adml_to_remove.append(adml_search_result)\n                        for search_result in these_admx_search_results:\n                            log.trace('policy_name == %s', policy_name)\n                            this_hierarchy = _build_parent_list(policy_definition=search_result, return_full_policy_names=True, adml_language=adml_language)\n                            this_hierarchy.reverse()\n                            if hierarchy != this_hierarchy:\n                                log.trace(\"hierarchy %s does not match this item's hierarchy of %s\", hierarchy, this_hierarchy)\n                                if len(these_admx_search_results) == 1:\n                                    log.trace('only 1 admx was found and it does not match this adml, it is safe to remove from the list')\n                                    adml_to_remove.append(adml_search_result)\n                            else:\n                                log.trace(\"hierarchy %s matches item's hierarchy of %s\", hierarchy, this_hierarchy)\n                                log.trace('search_result %s added to results', search_result)\n                                admx_results.append(search_result)\n                        if len(admx_results) == 1:\n                            admx_search_results.append(admx_results[0])\n                    else:\n                        display_name_searchval = '$({}.{})'.format(adml_search_result.tag.split('}')[1], adml_search_result.attrib['id'])\n                        these_admx_search_results = ADMX_DISPLAYNAME_SEARCH_XPATH(admx_policy_definitions, display_name=display_name_searchval, registry_class=policy_class)\n                        if not these_admx_search_results:\n                            adml_to_remove.append(adml_search_result)\n            for adml in adml_to_remove:\n                if adml in adml_search_results:\n                    adml_search_results.remove(adml)\n            if len(adml_search_results) == 1 and multiple_adml_entries:\n                multiple_adml_entries = False\n            for adml_search_result in adml_search_results:\n                log.trace('found an ADML entry matching the string! %s -- %s', adml_search_result.tag, adml_search_result.attrib)\n                display_name_searchval = '$({}.{})'.format(adml_search_result.tag.split('}')[1], adml_search_result.attrib['id'])\n                log.trace('searching for displayName == %s', display_name_searchval)\n                if not admx_search_results:\n                    log.trace('search for an admx entry matching display_name %s and registry_class %s', display_name_searchval, policy_class)\n                    admx_search_results = ADMX_DISPLAYNAME_SEARCH_XPATH(admx_policy_definitions, display_name=display_name_searchval, registry_class=policy_class)\n                if admx_search_results:\n                    log.trace('processing admx_search_results of %s', admx_search_results)\n                    log.trace('multiple_adml_entries is %s', multiple_adml_entries)\n                    if (len(admx_search_results) == 1 or hierarchy) and (not multiple_adml_entries):\n                        found = False\n                        for search_result in admx_search_results:\n                            found = False\n                            if hierarchy:\n                                this_hierarchy = _build_parent_list(policy_definition=search_result, return_full_policy_names=True, adml_language=adml_language)\n                                this_hierarchy.reverse()\n                                log.trace('testing %s == %s', hierarchy, this_hierarchy)\n                                if hierarchy == this_hierarchy:\n                                    found = True\n                            else:\n                                found = True\n                            if found:\n                                log.trace('found the ADMX policy matching the display name %s -- %s', search_result, policy_name)\n                                if 'name' in search_result.attrib:\n                                    policy_display_name = _getFullPolicyName(policy_item=search_result, policy_name=search_result.attrib['name'], return_full_policy_names=True, adml_language=adml_language)\n                                    policy_aliases.append(policy_display_name)\n                                    policy_aliases.append(search_result.attrib['name'])\n                                    full_path_list = _build_parent_list(policy_definition=search_result, return_full_policy_names=True, adml_language=adml_language)\n                                    full_path_list.reverse()\n                                    full_path_list.append(policy_display_name)\n                                    policy_aliases.append('\\\\'.join(full_path_list))\n                                    return (True, search_result, policy_aliases, None)\n                                else:\n                                    msg = 'ADMX policy with the display name {} does nothave the required name attribute'\n                                    msg = msg.format(policy_name)\n                                    return (False, None, [], msg)\n                        if not found:\n                            msg = 'Unable to correlate {} to any policy'.format(hierarchy_policy_name)\n                            return (False, None, [], msg)\n                    else:\n                        for possible_policy in admx_search_results:\n                            this_parent_list = _build_parent_list(policy_definition=possible_policy, return_full_policy_names=True, adml_language=adml_language)\n                            this_parent_list.reverse()\n                            this_parent_list.append(policy_name)\n                            if suggested_policies:\n                                suggested_policies = ', '.join([suggested_policies, '\\\\'.join(this_parent_list)])\n                            else:\n                                suggested_policies = '\\\\'.join(this_parent_list)\n            if suggested_policies:\n                msg = 'ADML policy name \"{}\" is used as the display name for multiple policies. These policies matched: {}. You can utilize these long names to specify the correct policy'\n                return (False, None, [], msg.format(policy_name, suggested_policies))\n    return (False, None, [], f'Unable to find {policy_class} policy {policy_name}')",
            "def _lookup_admin_template(policy_name, policy_class, adml_language='en-US'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    (success_flag, policy_xml_item, policy_name_list, message)\\n    '\n    policy_aliases = []\n    admx_policy_definitions = _get_policy_definitions(language=adml_language)\n    adml_policy_resources = _get_policy_resources(language=adml_language)\n    admx_search_results = ADMX_SEARCH_XPATH(admx_policy_definitions, policy_name=policy_name, registry_class=policy_class)\n    if admx_search_results:\n        if len(admx_search_results) == 1:\n            the_policy = admx_search_results[0]\n            policy_display_name = _getFullPolicyName(policy_item=the_policy, policy_name=the_policy.attrib['name'], return_full_policy_names=True, adml_language=adml_language)\n            policy_aliases.append(policy_display_name)\n            policy_aliases.append(the_policy.attrib['name'])\n            full_path_list = _build_parent_list(policy_definition=the_policy, return_full_policy_names=True, adml_language=adml_language)\n            full_path_list.reverse()\n            full_path_list.append(policy_display_name)\n            policy_aliases.append('\\\\'.join(full_path_list))\n            return (True, the_policy, policy_aliases, None)\n        else:\n            policy_aliases = []\n            for the_policy in admx_search_results:\n                policy_display_name = _getFullPolicyName(policy_item=the_policy, policy_name=the_policy.attrib['name'], return_full_policy_names=True, adml_language=adml_language)\n                full_path_list = _build_parent_list(policy_definition=the_policy, return_full_policy_names=True, adml_language=adml_language)\n                full_path_list.append(policy_display_name)\n                policy_aliases.append('\\\\'.join(full_path_list))\n            policies = '\\n - '.join(policy_aliases)\n            msg = 'ADMX policy name/id \"{}\" is used in multiple ADMX files.\\nTry one of the following names:\\n - {}'.format(policy_name, policies)\n            return (False, None, [], msg)\n    else:\n        adml_search_results = ADML_SEARCH_XPATH(adml_policy_resources, policy_name=policy_name)\n        hierarchy = []\n        hierarchy_policy_name = policy_name\n        if not adml_search_results:\n            log.warning('Trying another: %s', policy_name)\n            if '\\\\' in policy_name:\n                hierarchy = policy_name.split('\\\\')\n                policy_name = hierarchy.pop()\n                adml_search_results = ADML_SEARCH_XPATH(adml_policy_resources, policy_name=policy_name)\n        if adml_search_results:\n            multiple_adml_entries = False\n            suggested_policies = ''\n            adml_to_remove = []\n            if len(adml_search_results) > 1:\n                log.trace('multiple ADML entries found matching the policy name %s', policy_name)\n                multiple_adml_entries = True\n                for adml_search_result in adml_search_results:\n                    if not getattr(adml_search_result, 'text', '').strip() == policy_name:\n                        adml_to_remove.append(adml_search_result)\n                    elif hierarchy:\n                        log.trace('we have hierarchy of %s', hierarchy)\n                        display_name_searchval = '$({}.{})'.format(adml_search_result.tag.split('}')[1], adml_search_result.attrib['id'])\n                        policy_search_string = '//{}:policy[@displayName = \"{}\" and (@class = \"Both\" or @class = \"{}\") ]'.format(adml_search_result.prefix, display_name_searchval, policy_class)\n                        admx_results = []\n                        these_admx_search_results = admx_policy_definitions.xpath(policy_search_string, namespaces=adml_search_result.nsmap)\n                        if not these_admx_search_results:\n                            log.trace('No admx was found for the adml entry %s, it will be removed', display_name_searchval)\n                            adml_to_remove.append(adml_search_result)\n                        for search_result in these_admx_search_results:\n                            log.trace('policy_name == %s', policy_name)\n                            this_hierarchy = _build_parent_list(policy_definition=search_result, return_full_policy_names=True, adml_language=adml_language)\n                            this_hierarchy.reverse()\n                            if hierarchy != this_hierarchy:\n                                log.trace(\"hierarchy %s does not match this item's hierarchy of %s\", hierarchy, this_hierarchy)\n                                if len(these_admx_search_results) == 1:\n                                    log.trace('only 1 admx was found and it does not match this adml, it is safe to remove from the list')\n                                    adml_to_remove.append(adml_search_result)\n                            else:\n                                log.trace(\"hierarchy %s matches item's hierarchy of %s\", hierarchy, this_hierarchy)\n                                log.trace('search_result %s added to results', search_result)\n                                admx_results.append(search_result)\n                        if len(admx_results) == 1:\n                            admx_search_results.append(admx_results[0])\n                    else:\n                        display_name_searchval = '$({}.{})'.format(adml_search_result.tag.split('}')[1], adml_search_result.attrib['id'])\n                        these_admx_search_results = ADMX_DISPLAYNAME_SEARCH_XPATH(admx_policy_definitions, display_name=display_name_searchval, registry_class=policy_class)\n                        if not these_admx_search_results:\n                            adml_to_remove.append(adml_search_result)\n            for adml in adml_to_remove:\n                if adml in adml_search_results:\n                    adml_search_results.remove(adml)\n            if len(adml_search_results) == 1 and multiple_adml_entries:\n                multiple_adml_entries = False\n            for adml_search_result in adml_search_results:\n                log.trace('found an ADML entry matching the string! %s -- %s', adml_search_result.tag, adml_search_result.attrib)\n                display_name_searchval = '$({}.{})'.format(adml_search_result.tag.split('}')[1], adml_search_result.attrib['id'])\n                log.trace('searching for displayName == %s', display_name_searchval)\n                if not admx_search_results:\n                    log.trace('search for an admx entry matching display_name %s and registry_class %s', display_name_searchval, policy_class)\n                    admx_search_results = ADMX_DISPLAYNAME_SEARCH_XPATH(admx_policy_definitions, display_name=display_name_searchval, registry_class=policy_class)\n                if admx_search_results:\n                    log.trace('processing admx_search_results of %s', admx_search_results)\n                    log.trace('multiple_adml_entries is %s', multiple_adml_entries)\n                    if (len(admx_search_results) == 1 or hierarchy) and (not multiple_adml_entries):\n                        found = False\n                        for search_result in admx_search_results:\n                            found = False\n                            if hierarchy:\n                                this_hierarchy = _build_parent_list(policy_definition=search_result, return_full_policy_names=True, adml_language=adml_language)\n                                this_hierarchy.reverse()\n                                log.trace('testing %s == %s', hierarchy, this_hierarchy)\n                                if hierarchy == this_hierarchy:\n                                    found = True\n                            else:\n                                found = True\n                            if found:\n                                log.trace('found the ADMX policy matching the display name %s -- %s', search_result, policy_name)\n                                if 'name' in search_result.attrib:\n                                    policy_display_name = _getFullPolicyName(policy_item=search_result, policy_name=search_result.attrib['name'], return_full_policy_names=True, adml_language=adml_language)\n                                    policy_aliases.append(policy_display_name)\n                                    policy_aliases.append(search_result.attrib['name'])\n                                    full_path_list = _build_parent_list(policy_definition=search_result, return_full_policy_names=True, adml_language=adml_language)\n                                    full_path_list.reverse()\n                                    full_path_list.append(policy_display_name)\n                                    policy_aliases.append('\\\\'.join(full_path_list))\n                                    return (True, search_result, policy_aliases, None)\n                                else:\n                                    msg = 'ADMX policy with the display name {} does nothave the required name attribute'\n                                    msg = msg.format(policy_name)\n                                    return (False, None, [], msg)\n                        if not found:\n                            msg = 'Unable to correlate {} to any policy'.format(hierarchy_policy_name)\n                            return (False, None, [], msg)\n                    else:\n                        for possible_policy in admx_search_results:\n                            this_parent_list = _build_parent_list(policy_definition=possible_policy, return_full_policy_names=True, adml_language=adml_language)\n                            this_parent_list.reverse()\n                            this_parent_list.append(policy_name)\n                            if suggested_policies:\n                                suggested_policies = ', '.join([suggested_policies, '\\\\'.join(this_parent_list)])\n                            else:\n                                suggested_policies = '\\\\'.join(this_parent_list)\n            if suggested_policies:\n                msg = 'ADML policy name \"{}\" is used as the display name for multiple policies. These policies matched: {}. You can utilize these long names to specify the correct policy'\n                return (False, None, [], msg.format(policy_name, suggested_policies))\n    return (False, None, [], f'Unable to find {policy_class} policy {policy_name}')",
            "def _lookup_admin_template(policy_name, policy_class, adml_language='en-US'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    (success_flag, policy_xml_item, policy_name_list, message)\\n    '\n    policy_aliases = []\n    admx_policy_definitions = _get_policy_definitions(language=adml_language)\n    adml_policy_resources = _get_policy_resources(language=adml_language)\n    admx_search_results = ADMX_SEARCH_XPATH(admx_policy_definitions, policy_name=policy_name, registry_class=policy_class)\n    if admx_search_results:\n        if len(admx_search_results) == 1:\n            the_policy = admx_search_results[0]\n            policy_display_name = _getFullPolicyName(policy_item=the_policy, policy_name=the_policy.attrib['name'], return_full_policy_names=True, adml_language=adml_language)\n            policy_aliases.append(policy_display_name)\n            policy_aliases.append(the_policy.attrib['name'])\n            full_path_list = _build_parent_list(policy_definition=the_policy, return_full_policy_names=True, adml_language=adml_language)\n            full_path_list.reverse()\n            full_path_list.append(policy_display_name)\n            policy_aliases.append('\\\\'.join(full_path_list))\n            return (True, the_policy, policy_aliases, None)\n        else:\n            policy_aliases = []\n            for the_policy in admx_search_results:\n                policy_display_name = _getFullPolicyName(policy_item=the_policy, policy_name=the_policy.attrib['name'], return_full_policy_names=True, adml_language=adml_language)\n                full_path_list = _build_parent_list(policy_definition=the_policy, return_full_policy_names=True, adml_language=adml_language)\n                full_path_list.append(policy_display_name)\n                policy_aliases.append('\\\\'.join(full_path_list))\n            policies = '\\n - '.join(policy_aliases)\n            msg = 'ADMX policy name/id \"{}\" is used in multiple ADMX files.\\nTry one of the following names:\\n - {}'.format(policy_name, policies)\n            return (False, None, [], msg)\n    else:\n        adml_search_results = ADML_SEARCH_XPATH(adml_policy_resources, policy_name=policy_name)\n        hierarchy = []\n        hierarchy_policy_name = policy_name\n        if not adml_search_results:\n            log.warning('Trying another: %s', policy_name)\n            if '\\\\' in policy_name:\n                hierarchy = policy_name.split('\\\\')\n                policy_name = hierarchy.pop()\n                adml_search_results = ADML_SEARCH_XPATH(adml_policy_resources, policy_name=policy_name)\n        if adml_search_results:\n            multiple_adml_entries = False\n            suggested_policies = ''\n            adml_to_remove = []\n            if len(adml_search_results) > 1:\n                log.trace('multiple ADML entries found matching the policy name %s', policy_name)\n                multiple_adml_entries = True\n                for adml_search_result in adml_search_results:\n                    if not getattr(adml_search_result, 'text', '').strip() == policy_name:\n                        adml_to_remove.append(adml_search_result)\n                    elif hierarchy:\n                        log.trace('we have hierarchy of %s', hierarchy)\n                        display_name_searchval = '$({}.{})'.format(adml_search_result.tag.split('}')[1], adml_search_result.attrib['id'])\n                        policy_search_string = '//{}:policy[@displayName = \"{}\" and (@class = \"Both\" or @class = \"{}\") ]'.format(adml_search_result.prefix, display_name_searchval, policy_class)\n                        admx_results = []\n                        these_admx_search_results = admx_policy_definitions.xpath(policy_search_string, namespaces=adml_search_result.nsmap)\n                        if not these_admx_search_results:\n                            log.trace('No admx was found for the adml entry %s, it will be removed', display_name_searchval)\n                            adml_to_remove.append(adml_search_result)\n                        for search_result in these_admx_search_results:\n                            log.trace('policy_name == %s', policy_name)\n                            this_hierarchy = _build_parent_list(policy_definition=search_result, return_full_policy_names=True, adml_language=adml_language)\n                            this_hierarchy.reverse()\n                            if hierarchy != this_hierarchy:\n                                log.trace(\"hierarchy %s does not match this item's hierarchy of %s\", hierarchy, this_hierarchy)\n                                if len(these_admx_search_results) == 1:\n                                    log.trace('only 1 admx was found and it does not match this adml, it is safe to remove from the list')\n                                    adml_to_remove.append(adml_search_result)\n                            else:\n                                log.trace(\"hierarchy %s matches item's hierarchy of %s\", hierarchy, this_hierarchy)\n                                log.trace('search_result %s added to results', search_result)\n                                admx_results.append(search_result)\n                        if len(admx_results) == 1:\n                            admx_search_results.append(admx_results[0])\n                    else:\n                        display_name_searchval = '$({}.{})'.format(adml_search_result.tag.split('}')[1], adml_search_result.attrib['id'])\n                        these_admx_search_results = ADMX_DISPLAYNAME_SEARCH_XPATH(admx_policy_definitions, display_name=display_name_searchval, registry_class=policy_class)\n                        if not these_admx_search_results:\n                            adml_to_remove.append(adml_search_result)\n            for adml in adml_to_remove:\n                if adml in adml_search_results:\n                    adml_search_results.remove(adml)\n            if len(adml_search_results) == 1 and multiple_adml_entries:\n                multiple_adml_entries = False\n            for adml_search_result in adml_search_results:\n                log.trace('found an ADML entry matching the string! %s -- %s', adml_search_result.tag, adml_search_result.attrib)\n                display_name_searchval = '$({}.{})'.format(adml_search_result.tag.split('}')[1], adml_search_result.attrib['id'])\n                log.trace('searching for displayName == %s', display_name_searchval)\n                if not admx_search_results:\n                    log.trace('search for an admx entry matching display_name %s and registry_class %s', display_name_searchval, policy_class)\n                    admx_search_results = ADMX_DISPLAYNAME_SEARCH_XPATH(admx_policy_definitions, display_name=display_name_searchval, registry_class=policy_class)\n                if admx_search_results:\n                    log.trace('processing admx_search_results of %s', admx_search_results)\n                    log.trace('multiple_adml_entries is %s', multiple_adml_entries)\n                    if (len(admx_search_results) == 1 or hierarchy) and (not multiple_adml_entries):\n                        found = False\n                        for search_result in admx_search_results:\n                            found = False\n                            if hierarchy:\n                                this_hierarchy = _build_parent_list(policy_definition=search_result, return_full_policy_names=True, adml_language=adml_language)\n                                this_hierarchy.reverse()\n                                log.trace('testing %s == %s', hierarchy, this_hierarchy)\n                                if hierarchy == this_hierarchy:\n                                    found = True\n                            else:\n                                found = True\n                            if found:\n                                log.trace('found the ADMX policy matching the display name %s -- %s', search_result, policy_name)\n                                if 'name' in search_result.attrib:\n                                    policy_display_name = _getFullPolicyName(policy_item=search_result, policy_name=search_result.attrib['name'], return_full_policy_names=True, adml_language=adml_language)\n                                    policy_aliases.append(policy_display_name)\n                                    policy_aliases.append(search_result.attrib['name'])\n                                    full_path_list = _build_parent_list(policy_definition=search_result, return_full_policy_names=True, adml_language=adml_language)\n                                    full_path_list.reverse()\n                                    full_path_list.append(policy_display_name)\n                                    policy_aliases.append('\\\\'.join(full_path_list))\n                                    return (True, search_result, policy_aliases, None)\n                                else:\n                                    msg = 'ADMX policy with the display name {} does nothave the required name attribute'\n                                    msg = msg.format(policy_name)\n                                    return (False, None, [], msg)\n                        if not found:\n                            msg = 'Unable to correlate {} to any policy'.format(hierarchy_policy_name)\n                            return (False, None, [], msg)\n                    else:\n                        for possible_policy in admx_search_results:\n                            this_parent_list = _build_parent_list(policy_definition=possible_policy, return_full_policy_names=True, adml_language=adml_language)\n                            this_parent_list.reverse()\n                            this_parent_list.append(policy_name)\n                            if suggested_policies:\n                                suggested_policies = ', '.join([suggested_policies, '\\\\'.join(this_parent_list)])\n                            else:\n                                suggested_policies = '\\\\'.join(this_parent_list)\n            if suggested_policies:\n                msg = 'ADML policy name \"{}\" is used as the display name for multiple policies. These policies matched: {}. You can utilize these long names to specify the correct policy'\n                return (False, None, [], msg.format(policy_name, suggested_policies))\n    return (False, None, [], f'Unable to find {policy_class} policy {policy_name}')"
        ]
    },
    {
        "func_name": "get_policy_info",
        "original": "def get_policy_info(policy_name, policy_class, adml_language='en-US'):\n    \"\"\"\n    Returns information about a specified policy\n\n    Args:\n        policy_name (str):\n            The name of the policy to lookup\n        policy_class (str):\n            The class of policy, i.e. machine, user, both\n        adml_language (str):\n            The ADML language to use for Administrative Template data lookup\n\n    Returns:\n        dict: Information about the specified policy\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' lgpo.get_policy_info 'Maximum password age' machine\n\n    You can use ``lgpo.get_policy_info`` to get all the possible names that\n    could be used in a state file or from the command line (along with elements\n    that need to be set/etc). The key is to match the text you see in the\n    ``gpedit.msc`` gui exactly, including quotes around words or phrases. The\n    \"full path\" style is really only needed when there are multiple policies\n    that use the same base name. For example, ``Access data sources across\n    domains`` exists in ~10 different paths. If you put that through\n    ``get_policy_info`` you'll get back a message that it is used for multiple\n    policies and you need to be more specific.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt-call --local lgpo.get_policy_info ShellRemoveOrderPrints_2 machine\n\n        local:\n            ----------\n            message:\n            policy_aliases:\n                - Turn off the \"Order Prints\" picture task\n                - ShellRemoveOrderPrints_2\n                - System\\\\Internet Communication Management\\\\Internet Communication settings\\\\Turn off the \"Order Prints\" picture task\n            policy_class:\n                machine\n            policy_elements:\n            policy_found:\n                True\n            policy_name:\n                ShellRemoveOrderPrints_2\n            rights_assignment:\n                False\n\n    Escaping can get tricky in cmd/Powershell. The following is an example of\n    escaping in Powershell using backquotes:\n\n    .. code-block:: bash\n\n        PS>salt-call --local lgpo.get_policy_info \"Turn off the `\\\\`\"Order Prints`\\\\`\" picture task\" machine\n\n        local:\n            ----------\n            message:\n            policy_aliases:\n                - Turn off the \"Order Prints\" picture task\n                - ShellRemoveOrderPrints_2\n                - System\\\\Internet Communication Management\\\\Internet Communication settings\\\\Turn off the \"Order Prints\" picture task\n            policy_class:\n                machine\n            policy_elements:\n            policy_found:\n                True\n            policy_name:\n                Turn off the \"Order Prints\" picture task\n            rights_assignment:\n                False\n\n    This function can then be used to get the options available for specifying\n    Group Policy Objects to be used in state files. Based on the above any of\n    these *should* be usable:\n\n    .. code-block:: bash\n\n        internet_communications_settings:\n          lgpo.set:\n            - computer_policy:\n                Turn off the \"Order Prints\" picture task: Enabled\n\n    .. code-block:: bash\n\n        internet_communications_settings:\n          lgpo.set:\n            - computer_policy:\n                ShellRemoveOrderPrints_2: Enabled\n\n    When using the full path, it might be a good idea to use single quotes\n    around the path:\n\n    .. code-block:: bash\n\n        internet_communications_settings:\n          lgpo.set:\n            - computer_policy:\n                'System\\\\Internet Communication Management\\\\Internet Communication settings\\\\Turn off the \"Order Prints\" picture task': 'Enabled'\n\n    If you struggle to find the policy from ``get_policy_info`` using the name\n    as you see in ``gpedit.msc``, the names such as \"ShellRemoveOrderPrints_2\"\n    come from the ``.admx`` files. If you know nothing about ``.admx/.adml``\n    relationships (ADML holds what you see in the GUI, ADMX holds the more\n    technical details), then this may be a little bit too much info, but here is\n    an example with the above policy using Powershell:\n\n\n    .. code-block:: bash\n\n        PS>Get-ChildItem -Path C:\\\\Windows\\\\PolicyDefinitions -Recurse -Filter *.adml | Select-String \"Order Prints\"\n\n        C:\\\\windows\\\\PolicyDefinitions\\\\en-US\\\\ICM.adml:152:      <string id=\"ShellRemoveOrderPrints\">Turn off the \"Order Prints\" picture task</string>\n        C:\\\\windows\\\\PolicyDefinitions\\\\en-US\\\\ICM.adml:153:      <string id=\"ShellRemoveOrderPrints_Help\">This policy setting specifies whether the \"Order Prints Online\" task is available from Picture Tasks in Windows folders.\n        C:\\\\windows\\\\PolicyDefinitions\\\\en-US\\\\ICM.adml:155:The Order Prints Online Wizard is used to download a list of providers and allow users to order prints online.\n        C:\\\\windows\\\\PolicyDefinitions\\\\en-US\\\\ICM.adml:157:If you enable this policy setting, the task \"Order Prints Online\" is removed from Picture Tasks in File Explorer folders.\n\n    From this grep, we can see id \"ShellRemoveOrderPrints\" is the ID of the\n    string used to describe this policy, then we search for it in the ADMX:\n\n    .. code-block:: bash\n\n        PS>Get-ChildItem -Path C:\\\\Windows\\\\PolicyDefinitions -Recurse -Filter *.admx | Select-String \"ShellRemoveOrderPrints\"\n\n        C:\\\\windows\\\\PolicyDefinitions\\\\ICM.admx:661:    <policy name=\"ShellRemoveOrderPrints_1\" class=\"User\" displayName=\"$(string.ShellRemoveOrderPrints)\" explainText=\"$(string.ShellRemoveOrderPrints_Help)\" key=\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\Explorer\" valueName=\"NoOnlinePrintsWizard\">\n        C:\\\\windows\\\\PolicyDefinitions\\\\ICM.admx:671:    <policy name=\"ShellRemoveOrderPrints_2\" class=\"Machine\" displayName=\"$(string.ShellRemoveOrderPrints)\" explainText=\"$(string.ShellRemoveOrderPrints_Help)\" key=\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\Explorer\" valueName=\"NoOnlinePrintsWizard\">\n\n    Now we have two to pick from. And if you notice the ``class=\"Machine\"`` and\n    ``class=\"User\"`` (which details if it is a computer policy or user policy\n    respectively) the ``ShellRemoveOrderPrints_2`` is the \"short name\" we could\n    use to pass through ``get_policy_info`` to see what the module itself is\n    expecting.\n    \"\"\"\n    ret = {'policy_name': policy_name, 'policy_class': policy_class, 'policy_aliases': [], 'policy_found': False, 'rights_assignment': False, 'policy_elements': [], 'message': 'policy not found'}\n    policy_class = policy_class.title()\n    policy_data = _policy_info()\n    if policy_class not in policy_data.policies.keys():\n        policy_classes = ', '.join(policy_data.policies.keys())\n        ret['message'] = 'The requested policy class \"{}\" is invalid, policy_class should be one of: {}'.format(policy_class, policy_classes)\n        return ret\n    if policy_name in policy_data.policies[policy_class]['policies']:\n        ret['policy_aliases'].append(policy_data.policies[policy_class]['policies'][policy_name]['Policy'])\n        ret['policy_found'] = True\n        ret['message'] = ''\n        if 'LsaRights' in policy_data.policies[policy_class]['policies'][policy_name]:\n            ret['rights_assignment'] = True\n        return ret\n    else:\n        for pol in policy_data.policies[policy_class]['policies']:\n            _p = policy_data.policies[policy_class]['policies'][pol]['Policy']\n            if _p == policy_name:\n                ret['policy_aliases'].append(pol)\n                ret['policy_found'] = True\n                ret['message'] = ''\n                if 'LsaRights' in policy_data.policies[policy_class]['policies'][pol]:\n                    ret['rights_assignment'] = True\n                return ret\n        for pol in policy_data.policies[policy_class]['policies']:\n            _p = policy_data.policies[policy_class]['policies'][pol]['Policy']\n            if _p.lower() == policy_name.lower():\n                ret['policy_aliases'].append(pol)\n                ret['policy_found'] = True\n                ret['message'] = ''\n                if 'LsaRights' in policy_data.policies[policy_class]['policies'][pol]:\n                    ret['rights_assignment'] = True\n                return ret\n    (success, policy_xml_item, policy_name_list, message) = _lookup_admin_template(policy_name=policy_name, policy_class=policy_class, adml_language=adml_language)\n    if success:\n        for elements_item in ELEMENTS_XPATH(policy_xml_item):\n            for child_item in elements_item:\n                this_element_name = _getFullPolicyName(policy_item=child_item, policy_name=child_item.attrib['id'], return_full_policy_names=True, adml_language=adml_language)\n                ret['policy_elements'].append({'element_id': child_item.attrib['id'], 'element_aliases': [child_item.attrib['id'], this_element_name]})\n        ret['policy_aliases'] = policy_name_list\n        ret['policy_found'] = True\n        ret['message'] = ''\n        return ret\n    else:\n        ret['message'] = message\n    return ret",
        "mutated": [
            "def get_policy_info(policy_name, policy_class, adml_language='en-US'):\n    if False:\n        i = 10\n    '\\n    Returns information about a specified policy\\n\\n    Args:\\n        policy_name (str):\\n            The name of the policy to lookup\\n        policy_class (str):\\n            The class of policy, i.e. machine, user, both\\n        adml_language (str):\\n            The ADML language to use for Administrative Template data lookup\\n\\n    Returns:\\n        dict: Information about the specified policy\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' lgpo.get_policy_info \\'Maximum password age\\' machine\\n\\n    You can use ``lgpo.get_policy_info`` to get all the possible names that\\n    could be used in a state file or from the command line (along with elements\\n    that need to be set/etc). The key is to match the text you see in the\\n    ``gpedit.msc`` gui exactly, including quotes around words or phrases. The\\n    \"full path\" style is really only needed when there are multiple policies\\n    that use the same base name. For example, ``Access data sources across\\n    domains`` exists in ~10 different paths. If you put that through\\n    ``get_policy_info`` you\\'ll get back a message that it is used for multiple\\n    policies and you need to be more specific.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt-call --local lgpo.get_policy_info ShellRemoveOrderPrints_2 machine\\n\\n        local:\\n            ----------\\n            message:\\n            policy_aliases:\\n                - Turn off the \"Order Prints\" picture task\\n                - ShellRemoveOrderPrints_2\\n                - System\\\\Internet Communication Management\\\\Internet Communication settings\\\\Turn off the \"Order Prints\" picture task\\n            policy_class:\\n                machine\\n            policy_elements:\\n            policy_found:\\n                True\\n            policy_name:\\n                ShellRemoveOrderPrints_2\\n            rights_assignment:\\n                False\\n\\n    Escaping can get tricky in cmd/Powershell. The following is an example of\\n    escaping in Powershell using backquotes:\\n\\n    .. code-block:: bash\\n\\n        PS>salt-call --local lgpo.get_policy_info \"Turn off the `\\\\`\"Order Prints`\\\\`\" picture task\" machine\\n\\n        local:\\n            ----------\\n            message:\\n            policy_aliases:\\n                - Turn off the \"Order Prints\" picture task\\n                - ShellRemoveOrderPrints_2\\n                - System\\\\Internet Communication Management\\\\Internet Communication settings\\\\Turn off the \"Order Prints\" picture task\\n            policy_class:\\n                machine\\n            policy_elements:\\n            policy_found:\\n                True\\n            policy_name:\\n                Turn off the \"Order Prints\" picture task\\n            rights_assignment:\\n                False\\n\\n    This function can then be used to get the options available for specifying\\n    Group Policy Objects to be used in state files. Based on the above any of\\n    these *should* be usable:\\n\\n    .. code-block:: bash\\n\\n        internet_communications_settings:\\n          lgpo.set:\\n            - computer_policy:\\n                Turn off the \"Order Prints\" picture task: Enabled\\n\\n    .. code-block:: bash\\n\\n        internet_communications_settings:\\n          lgpo.set:\\n            - computer_policy:\\n                ShellRemoveOrderPrints_2: Enabled\\n\\n    When using the full path, it might be a good idea to use single quotes\\n    around the path:\\n\\n    .. code-block:: bash\\n\\n        internet_communications_settings:\\n          lgpo.set:\\n            - computer_policy:\\n                \\'System\\\\Internet Communication Management\\\\Internet Communication settings\\\\Turn off the \"Order Prints\" picture task\\': \\'Enabled\\'\\n\\n    If you struggle to find the policy from ``get_policy_info`` using the name\\n    as you see in ``gpedit.msc``, the names such as \"ShellRemoveOrderPrints_2\"\\n    come from the ``.admx`` files. If you know nothing about ``.admx/.adml``\\n    relationships (ADML holds what you see in the GUI, ADMX holds the more\\n    technical details), then this may be a little bit too much info, but here is\\n    an example with the above policy using Powershell:\\n\\n\\n    .. code-block:: bash\\n\\n        PS>Get-ChildItem -Path C:\\\\Windows\\\\PolicyDefinitions -Recurse -Filter *.adml | Select-String \"Order Prints\"\\n\\n        C:\\\\windows\\\\PolicyDefinitions\\\\en-US\\\\ICM.adml:152:      <string id=\"ShellRemoveOrderPrints\">Turn off the \"Order Prints\" picture task</string>\\n        C:\\\\windows\\\\PolicyDefinitions\\\\en-US\\\\ICM.adml:153:      <string id=\"ShellRemoveOrderPrints_Help\">This policy setting specifies whether the \"Order Prints Online\" task is available from Picture Tasks in Windows folders.\\n        C:\\\\windows\\\\PolicyDefinitions\\\\en-US\\\\ICM.adml:155:The Order Prints Online Wizard is used to download a list of providers and allow users to order prints online.\\n        C:\\\\windows\\\\PolicyDefinitions\\\\en-US\\\\ICM.adml:157:If you enable this policy setting, the task \"Order Prints Online\" is removed from Picture Tasks in File Explorer folders.\\n\\n    From this grep, we can see id \"ShellRemoveOrderPrints\" is the ID of the\\n    string used to describe this policy, then we search for it in the ADMX:\\n\\n    .. code-block:: bash\\n\\n        PS>Get-ChildItem -Path C:\\\\Windows\\\\PolicyDefinitions -Recurse -Filter *.admx | Select-String \"ShellRemoveOrderPrints\"\\n\\n        C:\\\\windows\\\\PolicyDefinitions\\\\ICM.admx:661:    <policy name=\"ShellRemoveOrderPrints_1\" class=\"User\" displayName=\"$(string.ShellRemoveOrderPrints)\" explainText=\"$(string.ShellRemoveOrderPrints_Help)\" key=\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\Explorer\" valueName=\"NoOnlinePrintsWizard\">\\n        C:\\\\windows\\\\PolicyDefinitions\\\\ICM.admx:671:    <policy name=\"ShellRemoveOrderPrints_2\" class=\"Machine\" displayName=\"$(string.ShellRemoveOrderPrints)\" explainText=\"$(string.ShellRemoveOrderPrints_Help)\" key=\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\Explorer\" valueName=\"NoOnlinePrintsWizard\">\\n\\n    Now we have two to pick from. And if you notice the ``class=\"Machine\"`` and\\n    ``class=\"User\"`` (which details if it is a computer policy or user policy\\n    respectively) the ``ShellRemoveOrderPrints_2`` is the \"short name\" we could\\n    use to pass through ``get_policy_info`` to see what the module itself is\\n    expecting.\\n    '\n    ret = {'policy_name': policy_name, 'policy_class': policy_class, 'policy_aliases': [], 'policy_found': False, 'rights_assignment': False, 'policy_elements': [], 'message': 'policy not found'}\n    policy_class = policy_class.title()\n    policy_data = _policy_info()\n    if policy_class not in policy_data.policies.keys():\n        policy_classes = ', '.join(policy_data.policies.keys())\n        ret['message'] = 'The requested policy class \"{}\" is invalid, policy_class should be one of: {}'.format(policy_class, policy_classes)\n        return ret\n    if policy_name in policy_data.policies[policy_class]['policies']:\n        ret['policy_aliases'].append(policy_data.policies[policy_class]['policies'][policy_name]['Policy'])\n        ret['policy_found'] = True\n        ret['message'] = ''\n        if 'LsaRights' in policy_data.policies[policy_class]['policies'][policy_name]:\n            ret['rights_assignment'] = True\n        return ret\n    else:\n        for pol in policy_data.policies[policy_class]['policies']:\n            _p = policy_data.policies[policy_class]['policies'][pol]['Policy']\n            if _p == policy_name:\n                ret['policy_aliases'].append(pol)\n                ret['policy_found'] = True\n                ret['message'] = ''\n                if 'LsaRights' in policy_data.policies[policy_class]['policies'][pol]:\n                    ret['rights_assignment'] = True\n                return ret\n        for pol in policy_data.policies[policy_class]['policies']:\n            _p = policy_data.policies[policy_class]['policies'][pol]['Policy']\n            if _p.lower() == policy_name.lower():\n                ret['policy_aliases'].append(pol)\n                ret['policy_found'] = True\n                ret['message'] = ''\n                if 'LsaRights' in policy_data.policies[policy_class]['policies'][pol]:\n                    ret['rights_assignment'] = True\n                return ret\n    (success, policy_xml_item, policy_name_list, message) = _lookup_admin_template(policy_name=policy_name, policy_class=policy_class, adml_language=adml_language)\n    if success:\n        for elements_item in ELEMENTS_XPATH(policy_xml_item):\n            for child_item in elements_item:\n                this_element_name = _getFullPolicyName(policy_item=child_item, policy_name=child_item.attrib['id'], return_full_policy_names=True, adml_language=adml_language)\n                ret['policy_elements'].append({'element_id': child_item.attrib['id'], 'element_aliases': [child_item.attrib['id'], this_element_name]})\n        ret['policy_aliases'] = policy_name_list\n        ret['policy_found'] = True\n        ret['message'] = ''\n        return ret\n    else:\n        ret['message'] = message\n    return ret",
            "def get_policy_info(policy_name, policy_class, adml_language='en-US'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Returns information about a specified policy\\n\\n    Args:\\n        policy_name (str):\\n            The name of the policy to lookup\\n        policy_class (str):\\n            The class of policy, i.e. machine, user, both\\n        adml_language (str):\\n            The ADML language to use for Administrative Template data lookup\\n\\n    Returns:\\n        dict: Information about the specified policy\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' lgpo.get_policy_info \\'Maximum password age\\' machine\\n\\n    You can use ``lgpo.get_policy_info`` to get all the possible names that\\n    could be used in a state file or from the command line (along with elements\\n    that need to be set/etc). The key is to match the text you see in the\\n    ``gpedit.msc`` gui exactly, including quotes around words or phrases. The\\n    \"full path\" style is really only needed when there are multiple policies\\n    that use the same base name. For example, ``Access data sources across\\n    domains`` exists in ~10 different paths. If you put that through\\n    ``get_policy_info`` you\\'ll get back a message that it is used for multiple\\n    policies and you need to be more specific.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt-call --local lgpo.get_policy_info ShellRemoveOrderPrints_2 machine\\n\\n        local:\\n            ----------\\n            message:\\n            policy_aliases:\\n                - Turn off the \"Order Prints\" picture task\\n                - ShellRemoveOrderPrints_2\\n                - System\\\\Internet Communication Management\\\\Internet Communication settings\\\\Turn off the \"Order Prints\" picture task\\n            policy_class:\\n                machine\\n            policy_elements:\\n            policy_found:\\n                True\\n            policy_name:\\n                ShellRemoveOrderPrints_2\\n            rights_assignment:\\n                False\\n\\n    Escaping can get tricky in cmd/Powershell. The following is an example of\\n    escaping in Powershell using backquotes:\\n\\n    .. code-block:: bash\\n\\n        PS>salt-call --local lgpo.get_policy_info \"Turn off the `\\\\`\"Order Prints`\\\\`\" picture task\" machine\\n\\n        local:\\n            ----------\\n            message:\\n            policy_aliases:\\n                - Turn off the \"Order Prints\" picture task\\n                - ShellRemoveOrderPrints_2\\n                - System\\\\Internet Communication Management\\\\Internet Communication settings\\\\Turn off the \"Order Prints\" picture task\\n            policy_class:\\n                machine\\n            policy_elements:\\n            policy_found:\\n                True\\n            policy_name:\\n                Turn off the \"Order Prints\" picture task\\n            rights_assignment:\\n                False\\n\\n    This function can then be used to get the options available for specifying\\n    Group Policy Objects to be used in state files. Based on the above any of\\n    these *should* be usable:\\n\\n    .. code-block:: bash\\n\\n        internet_communications_settings:\\n          lgpo.set:\\n            - computer_policy:\\n                Turn off the \"Order Prints\" picture task: Enabled\\n\\n    .. code-block:: bash\\n\\n        internet_communications_settings:\\n          lgpo.set:\\n            - computer_policy:\\n                ShellRemoveOrderPrints_2: Enabled\\n\\n    When using the full path, it might be a good idea to use single quotes\\n    around the path:\\n\\n    .. code-block:: bash\\n\\n        internet_communications_settings:\\n          lgpo.set:\\n            - computer_policy:\\n                \\'System\\\\Internet Communication Management\\\\Internet Communication settings\\\\Turn off the \"Order Prints\" picture task\\': \\'Enabled\\'\\n\\n    If you struggle to find the policy from ``get_policy_info`` using the name\\n    as you see in ``gpedit.msc``, the names such as \"ShellRemoveOrderPrints_2\"\\n    come from the ``.admx`` files. If you know nothing about ``.admx/.adml``\\n    relationships (ADML holds what you see in the GUI, ADMX holds the more\\n    technical details), then this may be a little bit too much info, but here is\\n    an example with the above policy using Powershell:\\n\\n\\n    .. code-block:: bash\\n\\n        PS>Get-ChildItem -Path C:\\\\Windows\\\\PolicyDefinitions -Recurse -Filter *.adml | Select-String \"Order Prints\"\\n\\n        C:\\\\windows\\\\PolicyDefinitions\\\\en-US\\\\ICM.adml:152:      <string id=\"ShellRemoveOrderPrints\">Turn off the \"Order Prints\" picture task</string>\\n        C:\\\\windows\\\\PolicyDefinitions\\\\en-US\\\\ICM.adml:153:      <string id=\"ShellRemoveOrderPrints_Help\">This policy setting specifies whether the \"Order Prints Online\" task is available from Picture Tasks in Windows folders.\\n        C:\\\\windows\\\\PolicyDefinitions\\\\en-US\\\\ICM.adml:155:The Order Prints Online Wizard is used to download a list of providers and allow users to order prints online.\\n        C:\\\\windows\\\\PolicyDefinitions\\\\en-US\\\\ICM.adml:157:If you enable this policy setting, the task \"Order Prints Online\" is removed from Picture Tasks in File Explorer folders.\\n\\n    From this grep, we can see id \"ShellRemoveOrderPrints\" is the ID of the\\n    string used to describe this policy, then we search for it in the ADMX:\\n\\n    .. code-block:: bash\\n\\n        PS>Get-ChildItem -Path C:\\\\Windows\\\\PolicyDefinitions -Recurse -Filter *.admx | Select-String \"ShellRemoveOrderPrints\"\\n\\n        C:\\\\windows\\\\PolicyDefinitions\\\\ICM.admx:661:    <policy name=\"ShellRemoveOrderPrints_1\" class=\"User\" displayName=\"$(string.ShellRemoveOrderPrints)\" explainText=\"$(string.ShellRemoveOrderPrints_Help)\" key=\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\Explorer\" valueName=\"NoOnlinePrintsWizard\">\\n        C:\\\\windows\\\\PolicyDefinitions\\\\ICM.admx:671:    <policy name=\"ShellRemoveOrderPrints_2\" class=\"Machine\" displayName=\"$(string.ShellRemoveOrderPrints)\" explainText=\"$(string.ShellRemoveOrderPrints_Help)\" key=\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\Explorer\" valueName=\"NoOnlinePrintsWizard\">\\n\\n    Now we have two to pick from. And if you notice the ``class=\"Machine\"`` and\\n    ``class=\"User\"`` (which details if it is a computer policy or user policy\\n    respectively) the ``ShellRemoveOrderPrints_2`` is the \"short name\" we could\\n    use to pass through ``get_policy_info`` to see what the module itself is\\n    expecting.\\n    '\n    ret = {'policy_name': policy_name, 'policy_class': policy_class, 'policy_aliases': [], 'policy_found': False, 'rights_assignment': False, 'policy_elements': [], 'message': 'policy not found'}\n    policy_class = policy_class.title()\n    policy_data = _policy_info()\n    if policy_class not in policy_data.policies.keys():\n        policy_classes = ', '.join(policy_data.policies.keys())\n        ret['message'] = 'The requested policy class \"{}\" is invalid, policy_class should be one of: {}'.format(policy_class, policy_classes)\n        return ret\n    if policy_name in policy_data.policies[policy_class]['policies']:\n        ret['policy_aliases'].append(policy_data.policies[policy_class]['policies'][policy_name]['Policy'])\n        ret['policy_found'] = True\n        ret['message'] = ''\n        if 'LsaRights' in policy_data.policies[policy_class]['policies'][policy_name]:\n            ret['rights_assignment'] = True\n        return ret\n    else:\n        for pol in policy_data.policies[policy_class]['policies']:\n            _p = policy_data.policies[policy_class]['policies'][pol]['Policy']\n            if _p == policy_name:\n                ret['policy_aliases'].append(pol)\n                ret['policy_found'] = True\n                ret['message'] = ''\n                if 'LsaRights' in policy_data.policies[policy_class]['policies'][pol]:\n                    ret['rights_assignment'] = True\n                return ret\n        for pol in policy_data.policies[policy_class]['policies']:\n            _p = policy_data.policies[policy_class]['policies'][pol]['Policy']\n            if _p.lower() == policy_name.lower():\n                ret['policy_aliases'].append(pol)\n                ret['policy_found'] = True\n                ret['message'] = ''\n                if 'LsaRights' in policy_data.policies[policy_class]['policies'][pol]:\n                    ret['rights_assignment'] = True\n                return ret\n    (success, policy_xml_item, policy_name_list, message) = _lookup_admin_template(policy_name=policy_name, policy_class=policy_class, adml_language=adml_language)\n    if success:\n        for elements_item in ELEMENTS_XPATH(policy_xml_item):\n            for child_item in elements_item:\n                this_element_name = _getFullPolicyName(policy_item=child_item, policy_name=child_item.attrib['id'], return_full_policy_names=True, adml_language=adml_language)\n                ret['policy_elements'].append({'element_id': child_item.attrib['id'], 'element_aliases': [child_item.attrib['id'], this_element_name]})\n        ret['policy_aliases'] = policy_name_list\n        ret['policy_found'] = True\n        ret['message'] = ''\n        return ret\n    else:\n        ret['message'] = message\n    return ret",
            "def get_policy_info(policy_name, policy_class, adml_language='en-US'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Returns information about a specified policy\\n\\n    Args:\\n        policy_name (str):\\n            The name of the policy to lookup\\n        policy_class (str):\\n            The class of policy, i.e. machine, user, both\\n        adml_language (str):\\n            The ADML language to use for Administrative Template data lookup\\n\\n    Returns:\\n        dict: Information about the specified policy\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' lgpo.get_policy_info \\'Maximum password age\\' machine\\n\\n    You can use ``lgpo.get_policy_info`` to get all the possible names that\\n    could be used in a state file or from the command line (along with elements\\n    that need to be set/etc). The key is to match the text you see in the\\n    ``gpedit.msc`` gui exactly, including quotes around words or phrases. The\\n    \"full path\" style is really only needed when there are multiple policies\\n    that use the same base name. For example, ``Access data sources across\\n    domains`` exists in ~10 different paths. If you put that through\\n    ``get_policy_info`` you\\'ll get back a message that it is used for multiple\\n    policies and you need to be more specific.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt-call --local lgpo.get_policy_info ShellRemoveOrderPrints_2 machine\\n\\n        local:\\n            ----------\\n            message:\\n            policy_aliases:\\n                - Turn off the \"Order Prints\" picture task\\n                - ShellRemoveOrderPrints_2\\n                - System\\\\Internet Communication Management\\\\Internet Communication settings\\\\Turn off the \"Order Prints\" picture task\\n            policy_class:\\n                machine\\n            policy_elements:\\n            policy_found:\\n                True\\n            policy_name:\\n                ShellRemoveOrderPrints_2\\n            rights_assignment:\\n                False\\n\\n    Escaping can get tricky in cmd/Powershell. The following is an example of\\n    escaping in Powershell using backquotes:\\n\\n    .. code-block:: bash\\n\\n        PS>salt-call --local lgpo.get_policy_info \"Turn off the `\\\\`\"Order Prints`\\\\`\" picture task\" machine\\n\\n        local:\\n            ----------\\n            message:\\n            policy_aliases:\\n                - Turn off the \"Order Prints\" picture task\\n                - ShellRemoveOrderPrints_2\\n                - System\\\\Internet Communication Management\\\\Internet Communication settings\\\\Turn off the \"Order Prints\" picture task\\n            policy_class:\\n                machine\\n            policy_elements:\\n            policy_found:\\n                True\\n            policy_name:\\n                Turn off the \"Order Prints\" picture task\\n            rights_assignment:\\n                False\\n\\n    This function can then be used to get the options available for specifying\\n    Group Policy Objects to be used in state files. Based on the above any of\\n    these *should* be usable:\\n\\n    .. code-block:: bash\\n\\n        internet_communications_settings:\\n          lgpo.set:\\n            - computer_policy:\\n                Turn off the \"Order Prints\" picture task: Enabled\\n\\n    .. code-block:: bash\\n\\n        internet_communications_settings:\\n          lgpo.set:\\n            - computer_policy:\\n                ShellRemoveOrderPrints_2: Enabled\\n\\n    When using the full path, it might be a good idea to use single quotes\\n    around the path:\\n\\n    .. code-block:: bash\\n\\n        internet_communications_settings:\\n          lgpo.set:\\n            - computer_policy:\\n                \\'System\\\\Internet Communication Management\\\\Internet Communication settings\\\\Turn off the \"Order Prints\" picture task\\': \\'Enabled\\'\\n\\n    If you struggle to find the policy from ``get_policy_info`` using the name\\n    as you see in ``gpedit.msc``, the names such as \"ShellRemoveOrderPrints_2\"\\n    come from the ``.admx`` files. If you know nothing about ``.admx/.adml``\\n    relationships (ADML holds what you see in the GUI, ADMX holds the more\\n    technical details), then this may be a little bit too much info, but here is\\n    an example with the above policy using Powershell:\\n\\n\\n    .. code-block:: bash\\n\\n        PS>Get-ChildItem -Path C:\\\\Windows\\\\PolicyDefinitions -Recurse -Filter *.adml | Select-String \"Order Prints\"\\n\\n        C:\\\\windows\\\\PolicyDefinitions\\\\en-US\\\\ICM.adml:152:      <string id=\"ShellRemoveOrderPrints\">Turn off the \"Order Prints\" picture task</string>\\n        C:\\\\windows\\\\PolicyDefinitions\\\\en-US\\\\ICM.adml:153:      <string id=\"ShellRemoveOrderPrints_Help\">This policy setting specifies whether the \"Order Prints Online\" task is available from Picture Tasks in Windows folders.\\n        C:\\\\windows\\\\PolicyDefinitions\\\\en-US\\\\ICM.adml:155:The Order Prints Online Wizard is used to download a list of providers and allow users to order prints online.\\n        C:\\\\windows\\\\PolicyDefinitions\\\\en-US\\\\ICM.adml:157:If you enable this policy setting, the task \"Order Prints Online\" is removed from Picture Tasks in File Explorer folders.\\n\\n    From this grep, we can see id \"ShellRemoveOrderPrints\" is the ID of the\\n    string used to describe this policy, then we search for it in the ADMX:\\n\\n    .. code-block:: bash\\n\\n        PS>Get-ChildItem -Path C:\\\\Windows\\\\PolicyDefinitions -Recurse -Filter *.admx | Select-String \"ShellRemoveOrderPrints\"\\n\\n        C:\\\\windows\\\\PolicyDefinitions\\\\ICM.admx:661:    <policy name=\"ShellRemoveOrderPrints_1\" class=\"User\" displayName=\"$(string.ShellRemoveOrderPrints)\" explainText=\"$(string.ShellRemoveOrderPrints_Help)\" key=\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\Explorer\" valueName=\"NoOnlinePrintsWizard\">\\n        C:\\\\windows\\\\PolicyDefinitions\\\\ICM.admx:671:    <policy name=\"ShellRemoveOrderPrints_2\" class=\"Machine\" displayName=\"$(string.ShellRemoveOrderPrints)\" explainText=\"$(string.ShellRemoveOrderPrints_Help)\" key=\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\Explorer\" valueName=\"NoOnlinePrintsWizard\">\\n\\n    Now we have two to pick from. And if you notice the ``class=\"Machine\"`` and\\n    ``class=\"User\"`` (which details if it is a computer policy or user policy\\n    respectively) the ``ShellRemoveOrderPrints_2`` is the \"short name\" we could\\n    use to pass through ``get_policy_info`` to see what the module itself is\\n    expecting.\\n    '\n    ret = {'policy_name': policy_name, 'policy_class': policy_class, 'policy_aliases': [], 'policy_found': False, 'rights_assignment': False, 'policy_elements': [], 'message': 'policy not found'}\n    policy_class = policy_class.title()\n    policy_data = _policy_info()\n    if policy_class not in policy_data.policies.keys():\n        policy_classes = ', '.join(policy_data.policies.keys())\n        ret['message'] = 'The requested policy class \"{}\" is invalid, policy_class should be one of: {}'.format(policy_class, policy_classes)\n        return ret\n    if policy_name in policy_data.policies[policy_class]['policies']:\n        ret['policy_aliases'].append(policy_data.policies[policy_class]['policies'][policy_name]['Policy'])\n        ret['policy_found'] = True\n        ret['message'] = ''\n        if 'LsaRights' in policy_data.policies[policy_class]['policies'][policy_name]:\n            ret['rights_assignment'] = True\n        return ret\n    else:\n        for pol in policy_data.policies[policy_class]['policies']:\n            _p = policy_data.policies[policy_class]['policies'][pol]['Policy']\n            if _p == policy_name:\n                ret['policy_aliases'].append(pol)\n                ret['policy_found'] = True\n                ret['message'] = ''\n                if 'LsaRights' in policy_data.policies[policy_class]['policies'][pol]:\n                    ret['rights_assignment'] = True\n                return ret\n        for pol in policy_data.policies[policy_class]['policies']:\n            _p = policy_data.policies[policy_class]['policies'][pol]['Policy']\n            if _p.lower() == policy_name.lower():\n                ret['policy_aliases'].append(pol)\n                ret['policy_found'] = True\n                ret['message'] = ''\n                if 'LsaRights' in policy_data.policies[policy_class]['policies'][pol]:\n                    ret['rights_assignment'] = True\n                return ret\n    (success, policy_xml_item, policy_name_list, message) = _lookup_admin_template(policy_name=policy_name, policy_class=policy_class, adml_language=adml_language)\n    if success:\n        for elements_item in ELEMENTS_XPATH(policy_xml_item):\n            for child_item in elements_item:\n                this_element_name = _getFullPolicyName(policy_item=child_item, policy_name=child_item.attrib['id'], return_full_policy_names=True, adml_language=adml_language)\n                ret['policy_elements'].append({'element_id': child_item.attrib['id'], 'element_aliases': [child_item.attrib['id'], this_element_name]})\n        ret['policy_aliases'] = policy_name_list\n        ret['policy_found'] = True\n        ret['message'] = ''\n        return ret\n    else:\n        ret['message'] = message\n    return ret",
            "def get_policy_info(policy_name, policy_class, adml_language='en-US'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Returns information about a specified policy\\n\\n    Args:\\n        policy_name (str):\\n            The name of the policy to lookup\\n        policy_class (str):\\n            The class of policy, i.e. machine, user, both\\n        adml_language (str):\\n            The ADML language to use for Administrative Template data lookup\\n\\n    Returns:\\n        dict: Information about the specified policy\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' lgpo.get_policy_info \\'Maximum password age\\' machine\\n\\n    You can use ``lgpo.get_policy_info`` to get all the possible names that\\n    could be used in a state file or from the command line (along with elements\\n    that need to be set/etc). The key is to match the text you see in the\\n    ``gpedit.msc`` gui exactly, including quotes around words or phrases. The\\n    \"full path\" style is really only needed when there are multiple policies\\n    that use the same base name. For example, ``Access data sources across\\n    domains`` exists in ~10 different paths. If you put that through\\n    ``get_policy_info`` you\\'ll get back a message that it is used for multiple\\n    policies and you need to be more specific.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt-call --local lgpo.get_policy_info ShellRemoveOrderPrints_2 machine\\n\\n        local:\\n            ----------\\n            message:\\n            policy_aliases:\\n                - Turn off the \"Order Prints\" picture task\\n                - ShellRemoveOrderPrints_2\\n                - System\\\\Internet Communication Management\\\\Internet Communication settings\\\\Turn off the \"Order Prints\" picture task\\n            policy_class:\\n                machine\\n            policy_elements:\\n            policy_found:\\n                True\\n            policy_name:\\n                ShellRemoveOrderPrints_2\\n            rights_assignment:\\n                False\\n\\n    Escaping can get tricky in cmd/Powershell. The following is an example of\\n    escaping in Powershell using backquotes:\\n\\n    .. code-block:: bash\\n\\n        PS>salt-call --local lgpo.get_policy_info \"Turn off the `\\\\`\"Order Prints`\\\\`\" picture task\" machine\\n\\n        local:\\n            ----------\\n            message:\\n            policy_aliases:\\n                - Turn off the \"Order Prints\" picture task\\n                - ShellRemoveOrderPrints_2\\n                - System\\\\Internet Communication Management\\\\Internet Communication settings\\\\Turn off the \"Order Prints\" picture task\\n            policy_class:\\n                machine\\n            policy_elements:\\n            policy_found:\\n                True\\n            policy_name:\\n                Turn off the \"Order Prints\" picture task\\n            rights_assignment:\\n                False\\n\\n    This function can then be used to get the options available for specifying\\n    Group Policy Objects to be used in state files. Based on the above any of\\n    these *should* be usable:\\n\\n    .. code-block:: bash\\n\\n        internet_communications_settings:\\n          lgpo.set:\\n            - computer_policy:\\n                Turn off the \"Order Prints\" picture task: Enabled\\n\\n    .. code-block:: bash\\n\\n        internet_communications_settings:\\n          lgpo.set:\\n            - computer_policy:\\n                ShellRemoveOrderPrints_2: Enabled\\n\\n    When using the full path, it might be a good idea to use single quotes\\n    around the path:\\n\\n    .. code-block:: bash\\n\\n        internet_communications_settings:\\n          lgpo.set:\\n            - computer_policy:\\n                \\'System\\\\Internet Communication Management\\\\Internet Communication settings\\\\Turn off the \"Order Prints\" picture task\\': \\'Enabled\\'\\n\\n    If you struggle to find the policy from ``get_policy_info`` using the name\\n    as you see in ``gpedit.msc``, the names such as \"ShellRemoveOrderPrints_2\"\\n    come from the ``.admx`` files. If you know nothing about ``.admx/.adml``\\n    relationships (ADML holds what you see in the GUI, ADMX holds the more\\n    technical details), then this may be a little bit too much info, but here is\\n    an example with the above policy using Powershell:\\n\\n\\n    .. code-block:: bash\\n\\n        PS>Get-ChildItem -Path C:\\\\Windows\\\\PolicyDefinitions -Recurse -Filter *.adml | Select-String \"Order Prints\"\\n\\n        C:\\\\windows\\\\PolicyDefinitions\\\\en-US\\\\ICM.adml:152:      <string id=\"ShellRemoveOrderPrints\">Turn off the \"Order Prints\" picture task</string>\\n        C:\\\\windows\\\\PolicyDefinitions\\\\en-US\\\\ICM.adml:153:      <string id=\"ShellRemoveOrderPrints_Help\">This policy setting specifies whether the \"Order Prints Online\" task is available from Picture Tasks in Windows folders.\\n        C:\\\\windows\\\\PolicyDefinitions\\\\en-US\\\\ICM.adml:155:The Order Prints Online Wizard is used to download a list of providers and allow users to order prints online.\\n        C:\\\\windows\\\\PolicyDefinitions\\\\en-US\\\\ICM.adml:157:If you enable this policy setting, the task \"Order Prints Online\" is removed from Picture Tasks in File Explorer folders.\\n\\n    From this grep, we can see id \"ShellRemoveOrderPrints\" is the ID of the\\n    string used to describe this policy, then we search for it in the ADMX:\\n\\n    .. code-block:: bash\\n\\n        PS>Get-ChildItem -Path C:\\\\Windows\\\\PolicyDefinitions -Recurse -Filter *.admx | Select-String \"ShellRemoveOrderPrints\"\\n\\n        C:\\\\windows\\\\PolicyDefinitions\\\\ICM.admx:661:    <policy name=\"ShellRemoveOrderPrints_1\" class=\"User\" displayName=\"$(string.ShellRemoveOrderPrints)\" explainText=\"$(string.ShellRemoveOrderPrints_Help)\" key=\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\Explorer\" valueName=\"NoOnlinePrintsWizard\">\\n        C:\\\\windows\\\\PolicyDefinitions\\\\ICM.admx:671:    <policy name=\"ShellRemoveOrderPrints_2\" class=\"Machine\" displayName=\"$(string.ShellRemoveOrderPrints)\" explainText=\"$(string.ShellRemoveOrderPrints_Help)\" key=\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\Explorer\" valueName=\"NoOnlinePrintsWizard\">\\n\\n    Now we have two to pick from. And if you notice the ``class=\"Machine\"`` and\\n    ``class=\"User\"`` (which details if it is a computer policy or user policy\\n    respectively) the ``ShellRemoveOrderPrints_2`` is the \"short name\" we could\\n    use to pass through ``get_policy_info`` to see what the module itself is\\n    expecting.\\n    '\n    ret = {'policy_name': policy_name, 'policy_class': policy_class, 'policy_aliases': [], 'policy_found': False, 'rights_assignment': False, 'policy_elements': [], 'message': 'policy not found'}\n    policy_class = policy_class.title()\n    policy_data = _policy_info()\n    if policy_class not in policy_data.policies.keys():\n        policy_classes = ', '.join(policy_data.policies.keys())\n        ret['message'] = 'The requested policy class \"{}\" is invalid, policy_class should be one of: {}'.format(policy_class, policy_classes)\n        return ret\n    if policy_name in policy_data.policies[policy_class]['policies']:\n        ret['policy_aliases'].append(policy_data.policies[policy_class]['policies'][policy_name]['Policy'])\n        ret['policy_found'] = True\n        ret['message'] = ''\n        if 'LsaRights' in policy_data.policies[policy_class]['policies'][policy_name]:\n            ret['rights_assignment'] = True\n        return ret\n    else:\n        for pol in policy_data.policies[policy_class]['policies']:\n            _p = policy_data.policies[policy_class]['policies'][pol]['Policy']\n            if _p == policy_name:\n                ret['policy_aliases'].append(pol)\n                ret['policy_found'] = True\n                ret['message'] = ''\n                if 'LsaRights' in policy_data.policies[policy_class]['policies'][pol]:\n                    ret['rights_assignment'] = True\n                return ret\n        for pol in policy_data.policies[policy_class]['policies']:\n            _p = policy_data.policies[policy_class]['policies'][pol]['Policy']\n            if _p.lower() == policy_name.lower():\n                ret['policy_aliases'].append(pol)\n                ret['policy_found'] = True\n                ret['message'] = ''\n                if 'LsaRights' in policy_data.policies[policy_class]['policies'][pol]:\n                    ret['rights_assignment'] = True\n                return ret\n    (success, policy_xml_item, policy_name_list, message) = _lookup_admin_template(policy_name=policy_name, policy_class=policy_class, adml_language=adml_language)\n    if success:\n        for elements_item in ELEMENTS_XPATH(policy_xml_item):\n            for child_item in elements_item:\n                this_element_name = _getFullPolicyName(policy_item=child_item, policy_name=child_item.attrib['id'], return_full_policy_names=True, adml_language=adml_language)\n                ret['policy_elements'].append({'element_id': child_item.attrib['id'], 'element_aliases': [child_item.attrib['id'], this_element_name]})\n        ret['policy_aliases'] = policy_name_list\n        ret['policy_found'] = True\n        ret['message'] = ''\n        return ret\n    else:\n        ret['message'] = message\n    return ret",
            "def get_policy_info(policy_name, policy_class, adml_language='en-US'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Returns information about a specified policy\\n\\n    Args:\\n        policy_name (str):\\n            The name of the policy to lookup\\n        policy_class (str):\\n            The class of policy, i.e. machine, user, both\\n        adml_language (str):\\n            The ADML language to use for Administrative Template data lookup\\n\\n    Returns:\\n        dict: Information about the specified policy\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' lgpo.get_policy_info \\'Maximum password age\\' machine\\n\\n    You can use ``lgpo.get_policy_info`` to get all the possible names that\\n    could be used in a state file or from the command line (along with elements\\n    that need to be set/etc). The key is to match the text you see in the\\n    ``gpedit.msc`` gui exactly, including quotes around words or phrases. The\\n    \"full path\" style is really only needed when there are multiple policies\\n    that use the same base name. For example, ``Access data sources across\\n    domains`` exists in ~10 different paths. If you put that through\\n    ``get_policy_info`` you\\'ll get back a message that it is used for multiple\\n    policies and you need to be more specific.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt-call --local lgpo.get_policy_info ShellRemoveOrderPrints_2 machine\\n\\n        local:\\n            ----------\\n            message:\\n            policy_aliases:\\n                - Turn off the \"Order Prints\" picture task\\n                - ShellRemoveOrderPrints_2\\n                - System\\\\Internet Communication Management\\\\Internet Communication settings\\\\Turn off the \"Order Prints\" picture task\\n            policy_class:\\n                machine\\n            policy_elements:\\n            policy_found:\\n                True\\n            policy_name:\\n                ShellRemoveOrderPrints_2\\n            rights_assignment:\\n                False\\n\\n    Escaping can get tricky in cmd/Powershell. The following is an example of\\n    escaping in Powershell using backquotes:\\n\\n    .. code-block:: bash\\n\\n        PS>salt-call --local lgpo.get_policy_info \"Turn off the `\\\\`\"Order Prints`\\\\`\" picture task\" machine\\n\\n        local:\\n            ----------\\n            message:\\n            policy_aliases:\\n                - Turn off the \"Order Prints\" picture task\\n                - ShellRemoveOrderPrints_2\\n                - System\\\\Internet Communication Management\\\\Internet Communication settings\\\\Turn off the \"Order Prints\" picture task\\n            policy_class:\\n                machine\\n            policy_elements:\\n            policy_found:\\n                True\\n            policy_name:\\n                Turn off the \"Order Prints\" picture task\\n            rights_assignment:\\n                False\\n\\n    This function can then be used to get the options available for specifying\\n    Group Policy Objects to be used in state files. Based on the above any of\\n    these *should* be usable:\\n\\n    .. code-block:: bash\\n\\n        internet_communications_settings:\\n          lgpo.set:\\n            - computer_policy:\\n                Turn off the \"Order Prints\" picture task: Enabled\\n\\n    .. code-block:: bash\\n\\n        internet_communications_settings:\\n          lgpo.set:\\n            - computer_policy:\\n                ShellRemoveOrderPrints_2: Enabled\\n\\n    When using the full path, it might be a good idea to use single quotes\\n    around the path:\\n\\n    .. code-block:: bash\\n\\n        internet_communications_settings:\\n          lgpo.set:\\n            - computer_policy:\\n                \\'System\\\\Internet Communication Management\\\\Internet Communication settings\\\\Turn off the \"Order Prints\" picture task\\': \\'Enabled\\'\\n\\n    If you struggle to find the policy from ``get_policy_info`` using the name\\n    as you see in ``gpedit.msc``, the names such as \"ShellRemoveOrderPrints_2\"\\n    come from the ``.admx`` files. If you know nothing about ``.admx/.adml``\\n    relationships (ADML holds what you see in the GUI, ADMX holds the more\\n    technical details), then this may be a little bit too much info, but here is\\n    an example with the above policy using Powershell:\\n\\n\\n    .. code-block:: bash\\n\\n        PS>Get-ChildItem -Path C:\\\\Windows\\\\PolicyDefinitions -Recurse -Filter *.adml | Select-String \"Order Prints\"\\n\\n        C:\\\\windows\\\\PolicyDefinitions\\\\en-US\\\\ICM.adml:152:      <string id=\"ShellRemoveOrderPrints\">Turn off the \"Order Prints\" picture task</string>\\n        C:\\\\windows\\\\PolicyDefinitions\\\\en-US\\\\ICM.adml:153:      <string id=\"ShellRemoveOrderPrints_Help\">This policy setting specifies whether the \"Order Prints Online\" task is available from Picture Tasks in Windows folders.\\n        C:\\\\windows\\\\PolicyDefinitions\\\\en-US\\\\ICM.adml:155:The Order Prints Online Wizard is used to download a list of providers and allow users to order prints online.\\n        C:\\\\windows\\\\PolicyDefinitions\\\\en-US\\\\ICM.adml:157:If you enable this policy setting, the task \"Order Prints Online\" is removed from Picture Tasks in File Explorer folders.\\n\\n    From this grep, we can see id \"ShellRemoveOrderPrints\" is the ID of the\\n    string used to describe this policy, then we search for it in the ADMX:\\n\\n    .. code-block:: bash\\n\\n        PS>Get-ChildItem -Path C:\\\\Windows\\\\PolicyDefinitions -Recurse -Filter *.admx | Select-String \"ShellRemoveOrderPrints\"\\n\\n        C:\\\\windows\\\\PolicyDefinitions\\\\ICM.admx:661:    <policy name=\"ShellRemoveOrderPrints_1\" class=\"User\" displayName=\"$(string.ShellRemoveOrderPrints)\" explainText=\"$(string.ShellRemoveOrderPrints_Help)\" key=\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\Explorer\" valueName=\"NoOnlinePrintsWizard\">\\n        C:\\\\windows\\\\PolicyDefinitions\\\\ICM.admx:671:    <policy name=\"ShellRemoveOrderPrints_2\" class=\"Machine\" displayName=\"$(string.ShellRemoveOrderPrints)\" explainText=\"$(string.ShellRemoveOrderPrints_Help)\" key=\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\Explorer\" valueName=\"NoOnlinePrintsWizard\">\\n\\n    Now we have two to pick from. And if you notice the ``class=\"Machine\"`` and\\n    ``class=\"User\"`` (which details if it is a computer policy or user policy\\n    respectively) the ``ShellRemoveOrderPrints_2`` is the \"short name\" we could\\n    use to pass through ``get_policy_info`` to see what the module itself is\\n    expecting.\\n    '\n    ret = {'policy_name': policy_name, 'policy_class': policy_class, 'policy_aliases': [], 'policy_found': False, 'rights_assignment': False, 'policy_elements': [], 'message': 'policy not found'}\n    policy_class = policy_class.title()\n    policy_data = _policy_info()\n    if policy_class not in policy_data.policies.keys():\n        policy_classes = ', '.join(policy_data.policies.keys())\n        ret['message'] = 'The requested policy class \"{}\" is invalid, policy_class should be one of: {}'.format(policy_class, policy_classes)\n        return ret\n    if policy_name in policy_data.policies[policy_class]['policies']:\n        ret['policy_aliases'].append(policy_data.policies[policy_class]['policies'][policy_name]['Policy'])\n        ret['policy_found'] = True\n        ret['message'] = ''\n        if 'LsaRights' in policy_data.policies[policy_class]['policies'][policy_name]:\n            ret['rights_assignment'] = True\n        return ret\n    else:\n        for pol in policy_data.policies[policy_class]['policies']:\n            _p = policy_data.policies[policy_class]['policies'][pol]['Policy']\n            if _p == policy_name:\n                ret['policy_aliases'].append(pol)\n                ret['policy_found'] = True\n                ret['message'] = ''\n                if 'LsaRights' in policy_data.policies[policy_class]['policies'][pol]:\n                    ret['rights_assignment'] = True\n                return ret\n        for pol in policy_data.policies[policy_class]['policies']:\n            _p = policy_data.policies[policy_class]['policies'][pol]['Policy']\n            if _p.lower() == policy_name.lower():\n                ret['policy_aliases'].append(pol)\n                ret['policy_found'] = True\n                ret['message'] = ''\n                if 'LsaRights' in policy_data.policies[policy_class]['policies'][pol]:\n                    ret['rights_assignment'] = True\n                return ret\n    (success, policy_xml_item, policy_name_list, message) = _lookup_admin_template(policy_name=policy_name, policy_class=policy_class, adml_language=adml_language)\n    if success:\n        for elements_item in ELEMENTS_XPATH(policy_xml_item):\n            for child_item in elements_item:\n                this_element_name = _getFullPolicyName(policy_item=child_item, policy_name=child_item.attrib['id'], return_full_policy_names=True, adml_language=adml_language)\n                ret['policy_elements'].append({'element_id': child_item.attrib['id'], 'element_aliases': [child_item.attrib['id'], this_element_name]})\n        ret['policy_aliases'] = policy_name_list\n        ret['policy_found'] = True\n        ret['message'] = ''\n        return ret\n    else:\n        ret['message'] = message\n    return ret"
        ]
    },
    {
        "func_name": "get",
        "original": "def get(policy_class=None, return_full_policy_names=True, hierarchical_return=False, adml_language='en-US', return_not_configured=False):\n    \"\"\"\n    Get a policy value\n\n    Args:\n\n        policy_class (str):\n            Some policies are both user and computer, by default all policies\n            will be pulled, but this can be used to retrieve only a specific\n            policy class User/USER/user = retrieve user policies\n            Machine/MACHINE/machine/Computer/COMPUTER/computer = retrieve\n            machine/computer policies\n\n        return_full_policy_names (bool):\n            True/False to return the policy name as it is seen in the\n            ``gpedit.msc`` GUI or to only return the policy key/id.\n\n        hierarchical_return (bool):\n            True/False to return the policy data in the hierarchy as seen in the\n            ``gpedit.msc`` GUI. The default of False will return data split only\n            into User/Computer configuration sections\n\n        adml_language (str):\n            The ADML language to use for processing display/descriptive names\n            and enumeration values of ADMX template data, defaults to en-US\n\n        return_not_configured (bool):\n            Include Administrative Template policies that are 'Not Configured'\n            in the return data\n\n    Returns:\n        dict: A dictionary containing the policy values for the specified class\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' lgpo.get machine return_full_policy_names=True\n    \"\"\"\n    vals = {}\n    _policydata = _policy_info()\n    if policy_class is None or policy_class.lower() == 'both':\n        policy_class = _policydata.policies.keys()\n    elif policy_class.lower() not in [z.lower() for z in _policydata.policies]:\n        msg = 'The policy_class {} is not an available policy class, please use one of the following: {}, Both'\n        raise SaltInvocationError(msg.format(policy_class, ', '.join(_policydata.policies.keys())))\n    else:\n        policy_class = [policy_class.title()]\n    for p_class in policy_class:\n        this_class_policy_names = _policydata.policies[p_class]['policies']\n        class_vals = {}\n        for policy_name in this_class_policy_names:\n            _pol = None\n            if policy_name in _policydata.policies[p_class]['policies']:\n                _pol = _policydata.policies[p_class]['policies'][policy_name]\n            else:\n                for policy in _policydata.policies[p_class]['policies']:\n                    _p = _policydata.policies[p_class]['policies'][policy]['Policy']\n                    if _p == policy_name:\n                        _pol = _policydata.policies[p_class]['policies'][policy]\n                        policy_name = policy\n                if _pol is None:\n                    for policy in _policydata.policies[p_class]['policies']:\n                        _p = _policydata.policies[p_class]['policies'][policy]['Policy']\n                        if _p.lower() == policy_name.lower():\n                            _pol = _policydata.policies[p_class]['policies'][policy]\n                            policy_name = policy\n            if _pol:\n                vals_key_name = policy_name\n                class_vals[policy_name] = _get_policy_info_setting(_pol)\n                if return_full_policy_names:\n                    class_vals[_pol['Policy']] = class_vals.pop(policy_name)\n                    vals_key_name = _pol['Policy']\n                if hierarchical_return:\n                    if 'lgpo_section' in _pol:\n                        firstItem = True\n                        tdict = {}\n                        for level in reversed(_pol['lgpo_section']):\n                            newdict = {}\n                            if firstItem:\n                                newdict[level] = {vals_key_name: class_vals.pop(vals_key_name)}\n                                firstItem = False\n                            else:\n                                newdict[level] = tdict\n                            tdict = newdict\n                        if tdict:\n                            class_vals = dictupdate.update(class_vals, tdict)\n            else:\n                raise CommandExecutionError('The specified policy {} is not currently available to be configured via this module'.format(policy_name))\n        class_vals = dictupdate.update(class_vals, _checkAllAdmxPolicies(policy_class=p_class, adml_language=adml_language, return_full_policy_names=return_full_policy_names, hierarchical_return=hierarchical_return, return_not_configured=return_not_configured))\n        if _policydata.policies[p_class]['lgpo_section'] not in class_vals:\n            temp_dict = {_policydata.policies[p_class]['lgpo_section']: class_vals}\n            class_vals = temp_dict\n        vals = dictupdate.update(vals, class_vals)\n    return vals",
        "mutated": [
            "def get(policy_class=None, return_full_policy_names=True, hierarchical_return=False, adml_language='en-US', return_not_configured=False):\n    if False:\n        i = 10\n    \"\\n    Get a policy value\\n\\n    Args:\\n\\n        policy_class (str):\\n            Some policies are both user and computer, by default all policies\\n            will be pulled, but this can be used to retrieve only a specific\\n            policy class User/USER/user = retrieve user policies\\n            Machine/MACHINE/machine/Computer/COMPUTER/computer = retrieve\\n            machine/computer policies\\n\\n        return_full_policy_names (bool):\\n            True/False to return the policy name as it is seen in the\\n            ``gpedit.msc`` GUI or to only return the policy key/id.\\n\\n        hierarchical_return (bool):\\n            True/False to return the policy data in the hierarchy as seen in the\\n            ``gpedit.msc`` GUI. The default of False will return data split only\\n            into User/Computer configuration sections\\n\\n        adml_language (str):\\n            The ADML language to use for processing display/descriptive names\\n            and enumeration values of ADMX template data, defaults to en-US\\n\\n        return_not_configured (bool):\\n            Include Administrative Template policies that are 'Not Configured'\\n            in the return data\\n\\n    Returns:\\n        dict: A dictionary containing the policy values for the specified class\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' lgpo.get machine return_full_policy_names=True\\n    \"\n    vals = {}\n    _policydata = _policy_info()\n    if policy_class is None or policy_class.lower() == 'both':\n        policy_class = _policydata.policies.keys()\n    elif policy_class.lower() not in [z.lower() for z in _policydata.policies]:\n        msg = 'The policy_class {} is not an available policy class, please use one of the following: {}, Both'\n        raise SaltInvocationError(msg.format(policy_class, ', '.join(_policydata.policies.keys())))\n    else:\n        policy_class = [policy_class.title()]\n    for p_class in policy_class:\n        this_class_policy_names = _policydata.policies[p_class]['policies']\n        class_vals = {}\n        for policy_name in this_class_policy_names:\n            _pol = None\n            if policy_name in _policydata.policies[p_class]['policies']:\n                _pol = _policydata.policies[p_class]['policies'][policy_name]\n            else:\n                for policy in _policydata.policies[p_class]['policies']:\n                    _p = _policydata.policies[p_class]['policies'][policy]['Policy']\n                    if _p == policy_name:\n                        _pol = _policydata.policies[p_class]['policies'][policy]\n                        policy_name = policy\n                if _pol is None:\n                    for policy in _policydata.policies[p_class]['policies']:\n                        _p = _policydata.policies[p_class]['policies'][policy]['Policy']\n                        if _p.lower() == policy_name.lower():\n                            _pol = _policydata.policies[p_class]['policies'][policy]\n                            policy_name = policy\n            if _pol:\n                vals_key_name = policy_name\n                class_vals[policy_name] = _get_policy_info_setting(_pol)\n                if return_full_policy_names:\n                    class_vals[_pol['Policy']] = class_vals.pop(policy_name)\n                    vals_key_name = _pol['Policy']\n                if hierarchical_return:\n                    if 'lgpo_section' in _pol:\n                        firstItem = True\n                        tdict = {}\n                        for level in reversed(_pol['lgpo_section']):\n                            newdict = {}\n                            if firstItem:\n                                newdict[level] = {vals_key_name: class_vals.pop(vals_key_name)}\n                                firstItem = False\n                            else:\n                                newdict[level] = tdict\n                            tdict = newdict\n                        if tdict:\n                            class_vals = dictupdate.update(class_vals, tdict)\n            else:\n                raise CommandExecutionError('The specified policy {} is not currently available to be configured via this module'.format(policy_name))\n        class_vals = dictupdate.update(class_vals, _checkAllAdmxPolicies(policy_class=p_class, adml_language=adml_language, return_full_policy_names=return_full_policy_names, hierarchical_return=hierarchical_return, return_not_configured=return_not_configured))\n        if _policydata.policies[p_class]['lgpo_section'] not in class_vals:\n            temp_dict = {_policydata.policies[p_class]['lgpo_section']: class_vals}\n            class_vals = temp_dict\n        vals = dictupdate.update(vals, class_vals)\n    return vals",
            "def get(policy_class=None, return_full_policy_names=True, hierarchical_return=False, adml_language='en-US', return_not_configured=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Get a policy value\\n\\n    Args:\\n\\n        policy_class (str):\\n            Some policies are both user and computer, by default all policies\\n            will be pulled, but this can be used to retrieve only a specific\\n            policy class User/USER/user = retrieve user policies\\n            Machine/MACHINE/machine/Computer/COMPUTER/computer = retrieve\\n            machine/computer policies\\n\\n        return_full_policy_names (bool):\\n            True/False to return the policy name as it is seen in the\\n            ``gpedit.msc`` GUI or to only return the policy key/id.\\n\\n        hierarchical_return (bool):\\n            True/False to return the policy data in the hierarchy as seen in the\\n            ``gpedit.msc`` GUI. The default of False will return data split only\\n            into User/Computer configuration sections\\n\\n        adml_language (str):\\n            The ADML language to use for processing display/descriptive names\\n            and enumeration values of ADMX template data, defaults to en-US\\n\\n        return_not_configured (bool):\\n            Include Administrative Template policies that are 'Not Configured'\\n            in the return data\\n\\n    Returns:\\n        dict: A dictionary containing the policy values for the specified class\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' lgpo.get machine return_full_policy_names=True\\n    \"\n    vals = {}\n    _policydata = _policy_info()\n    if policy_class is None or policy_class.lower() == 'both':\n        policy_class = _policydata.policies.keys()\n    elif policy_class.lower() not in [z.lower() for z in _policydata.policies]:\n        msg = 'The policy_class {} is not an available policy class, please use one of the following: {}, Both'\n        raise SaltInvocationError(msg.format(policy_class, ', '.join(_policydata.policies.keys())))\n    else:\n        policy_class = [policy_class.title()]\n    for p_class in policy_class:\n        this_class_policy_names = _policydata.policies[p_class]['policies']\n        class_vals = {}\n        for policy_name in this_class_policy_names:\n            _pol = None\n            if policy_name in _policydata.policies[p_class]['policies']:\n                _pol = _policydata.policies[p_class]['policies'][policy_name]\n            else:\n                for policy in _policydata.policies[p_class]['policies']:\n                    _p = _policydata.policies[p_class]['policies'][policy]['Policy']\n                    if _p == policy_name:\n                        _pol = _policydata.policies[p_class]['policies'][policy]\n                        policy_name = policy\n                if _pol is None:\n                    for policy in _policydata.policies[p_class]['policies']:\n                        _p = _policydata.policies[p_class]['policies'][policy]['Policy']\n                        if _p.lower() == policy_name.lower():\n                            _pol = _policydata.policies[p_class]['policies'][policy]\n                            policy_name = policy\n            if _pol:\n                vals_key_name = policy_name\n                class_vals[policy_name] = _get_policy_info_setting(_pol)\n                if return_full_policy_names:\n                    class_vals[_pol['Policy']] = class_vals.pop(policy_name)\n                    vals_key_name = _pol['Policy']\n                if hierarchical_return:\n                    if 'lgpo_section' in _pol:\n                        firstItem = True\n                        tdict = {}\n                        for level in reversed(_pol['lgpo_section']):\n                            newdict = {}\n                            if firstItem:\n                                newdict[level] = {vals_key_name: class_vals.pop(vals_key_name)}\n                                firstItem = False\n                            else:\n                                newdict[level] = tdict\n                            tdict = newdict\n                        if tdict:\n                            class_vals = dictupdate.update(class_vals, tdict)\n            else:\n                raise CommandExecutionError('The specified policy {} is not currently available to be configured via this module'.format(policy_name))\n        class_vals = dictupdate.update(class_vals, _checkAllAdmxPolicies(policy_class=p_class, adml_language=adml_language, return_full_policy_names=return_full_policy_names, hierarchical_return=hierarchical_return, return_not_configured=return_not_configured))\n        if _policydata.policies[p_class]['lgpo_section'] not in class_vals:\n            temp_dict = {_policydata.policies[p_class]['lgpo_section']: class_vals}\n            class_vals = temp_dict\n        vals = dictupdate.update(vals, class_vals)\n    return vals",
            "def get(policy_class=None, return_full_policy_names=True, hierarchical_return=False, adml_language='en-US', return_not_configured=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Get a policy value\\n\\n    Args:\\n\\n        policy_class (str):\\n            Some policies are both user and computer, by default all policies\\n            will be pulled, but this can be used to retrieve only a specific\\n            policy class User/USER/user = retrieve user policies\\n            Machine/MACHINE/machine/Computer/COMPUTER/computer = retrieve\\n            machine/computer policies\\n\\n        return_full_policy_names (bool):\\n            True/False to return the policy name as it is seen in the\\n            ``gpedit.msc`` GUI or to only return the policy key/id.\\n\\n        hierarchical_return (bool):\\n            True/False to return the policy data in the hierarchy as seen in the\\n            ``gpedit.msc`` GUI. The default of False will return data split only\\n            into User/Computer configuration sections\\n\\n        adml_language (str):\\n            The ADML language to use for processing display/descriptive names\\n            and enumeration values of ADMX template data, defaults to en-US\\n\\n        return_not_configured (bool):\\n            Include Administrative Template policies that are 'Not Configured'\\n            in the return data\\n\\n    Returns:\\n        dict: A dictionary containing the policy values for the specified class\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' lgpo.get machine return_full_policy_names=True\\n    \"\n    vals = {}\n    _policydata = _policy_info()\n    if policy_class is None or policy_class.lower() == 'both':\n        policy_class = _policydata.policies.keys()\n    elif policy_class.lower() not in [z.lower() for z in _policydata.policies]:\n        msg = 'The policy_class {} is not an available policy class, please use one of the following: {}, Both'\n        raise SaltInvocationError(msg.format(policy_class, ', '.join(_policydata.policies.keys())))\n    else:\n        policy_class = [policy_class.title()]\n    for p_class in policy_class:\n        this_class_policy_names = _policydata.policies[p_class]['policies']\n        class_vals = {}\n        for policy_name in this_class_policy_names:\n            _pol = None\n            if policy_name in _policydata.policies[p_class]['policies']:\n                _pol = _policydata.policies[p_class]['policies'][policy_name]\n            else:\n                for policy in _policydata.policies[p_class]['policies']:\n                    _p = _policydata.policies[p_class]['policies'][policy]['Policy']\n                    if _p == policy_name:\n                        _pol = _policydata.policies[p_class]['policies'][policy]\n                        policy_name = policy\n                if _pol is None:\n                    for policy in _policydata.policies[p_class]['policies']:\n                        _p = _policydata.policies[p_class]['policies'][policy]['Policy']\n                        if _p.lower() == policy_name.lower():\n                            _pol = _policydata.policies[p_class]['policies'][policy]\n                            policy_name = policy\n            if _pol:\n                vals_key_name = policy_name\n                class_vals[policy_name] = _get_policy_info_setting(_pol)\n                if return_full_policy_names:\n                    class_vals[_pol['Policy']] = class_vals.pop(policy_name)\n                    vals_key_name = _pol['Policy']\n                if hierarchical_return:\n                    if 'lgpo_section' in _pol:\n                        firstItem = True\n                        tdict = {}\n                        for level in reversed(_pol['lgpo_section']):\n                            newdict = {}\n                            if firstItem:\n                                newdict[level] = {vals_key_name: class_vals.pop(vals_key_name)}\n                                firstItem = False\n                            else:\n                                newdict[level] = tdict\n                            tdict = newdict\n                        if tdict:\n                            class_vals = dictupdate.update(class_vals, tdict)\n            else:\n                raise CommandExecutionError('The specified policy {} is not currently available to be configured via this module'.format(policy_name))\n        class_vals = dictupdate.update(class_vals, _checkAllAdmxPolicies(policy_class=p_class, adml_language=adml_language, return_full_policy_names=return_full_policy_names, hierarchical_return=hierarchical_return, return_not_configured=return_not_configured))\n        if _policydata.policies[p_class]['lgpo_section'] not in class_vals:\n            temp_dict = {_policydata.policies[p_class]['lgpo_section']: class_vals}\n            class_vals = temp_dict\n        vals = dictupdate.update(vals, class_vals)\n    return vals",
            "def get(policy_class=None, return_full_policy_names=True, hierarchical_return=False, adml_language='en-US', return_not_configured=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Get a policy value\\n\\n    Args:\\n\\n        policy_class (str):\\n            Some policies are both user and computer, by default all policies\\n            will be pulled, but this can be used to retrieve only a specific\\n            policy class User/USER/user = retrieve user policies\\n            Machine/MACHINE/machine/Computer/COMPUTER/computer = retrieve\\n            machine/computer policies\\n\\n        return_full_policy_names (bool):\\n            True/False to return the policy name as it is seen in the\\n            ``gpedit.msc`` GUI or to only return the policy key/id.\\n\\n        hierarchical_return (bool):\\n            True/False to return the policy data in the hierarchy as seen in the\\n            ``gpedit.msc`` GUI. The default of False will return data split only\\n            into User/Computer configuration sections\\n\\n        adml_language (str):\\n            The ADML language to use for processing display/descriptive names\\n            and enumeration values of ADMX template data, defaults to en-US\\n\\n        return_not_configured (bool):\\n            Include Administrative Template policies that are 'Not Configured'\\n            in the return data\\n\\n    Returns:\\n        dict: A dictionary containing the policy values for the specified class\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' lgpo.get machine return_full_policy_names=True\\n    \"\n    vals = {}\n    _policydata = _policy_info()\n    if policy_class is None or policy_class.lower() == 'both':\n        policy_class = _policydata.policies.keys()\n    elif policy_class.lower() not in [z.lower() for z in _policydata.policies]:\n        msg = 'The policy_class {} is not an available policy class, please use one of the following: {}, Both'\n        raise SaltInvocationError(msg.format(policy_class, ', '.join(_policydata.policies.keys())))\n    else:\n        policy_class = [policy_class.title()]\n    for p_class in policy_class:\n        this_class_policy_names = _policydata.policies[p_class]['policies']\n        class_vals = {}\n        for policy_name in this_class_policy_names:\n            _pol = None\n            if policy_name in _policydata.policies[p_class]['policies']:\n                _pol = _policydata.policies[p_class]['policies'][policy_name]\n            else:\n                for policy in _policydata.policies[p_class]['policies']:\n                    _p = _policydata.policies[p_class]['policies'][policy]['Policy']\n                    if _p == policy_name:\n                        _pol = _policydata.policies[p_class]['policies'][policy]\n                        policy_name = policy\n                if _pol is None:\n                    for policy in _policydata.policies[p_class]['policies']:\n                        _p = _policydata.policies[p_class]['policies'][policy]['Policy']\n                        if _p.lower() == policy_name.lower():\n                            _pol = _policydata.policies[p_class]['policies'][policy]\n                            policy_name = policy\n            if _pol:\n                vals_key_name = policy_name\n                class_vals[policy_name] = _get_policy_info_setting(_pol)\n                if return_full_policy_names:\n                    class_vals[_pol['Policy']] = class_vals.pop(policy_name)\n                    vals_key_name = _pol['Policy']\n                if hierarchical_return:\n                    if 'lgpo_section' in _pol:\n                        firstItem = True\n                        tdict = {}\n                        for level in reversed(_pol['lgpo_section']):\n                            newdict = {}\n                            if firstItem:\n                                newdict[level] = {vals_key_name: class_vals.pop(vals_key_name)}\n                                firstItem = False\n                            else:\n                                newdict[level] = tdict\n                            tdict = newdict\n                        if tdict:\n                            class_vals = dictupdate.update(class_vals, tdict)\n            else:\n                raise CommandExecutionError('The specified policy {} is not currently available to be configured via this module'.format(policy_name))\n        class_vals = dictupdate.update(class_vals, _checkAllAdmxPolicies(policy_class=p_class, adml_language=adml_language, return_full_policy_names=return_full_policy_names, hierarchical_return=hierarchical_return, return_not_configured=return_not_configured))\n        if _policydata.policies[p_class]['lgpo_section'] not in class_vals:\n            temp_dict = {_policydata.policies[p_class]['lgpo_section']: class_vals}\n            class_vals = temp_dict\n        vals = dictupdate.update(vals, class_vals)\n    return vals",
            "def get(policy_class=None, return_full_policy_names=True, hierarchical_return=False, adml_language='en-US', return_not_configured=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Get a policy value\\n\\n    Args:\\n\\n        policy_class (str):\\n            Some policies are both user and computer, by default all policies\\n            will be pulled, but this can be used to retrieve only a specific\\n            policy class User/USER/user = retrieve user policies\\n            Machine/MACHINE/machine/Computer/COMPUTER/computer = retrieve\\n            machine/computer policies\\n\\n        return_full_policy_names (bool):\\n            True/False to return the policy name as it is seen in the\\n            ``gpedit.msc`` GUI or to only return the policy key/id.\\n\\n        hierarchical_return (bool):\\n            True/False to return the policy data in the hierarchy as seen in the\\n            ``gpedit.msc`` GUI. The default of False will return data split only\\n            into User/Computer configuration sections\\n\\n        adml_language (str):\\n            The ADML language to use for processing display/descriptive names\\n            and enumeration values of ADMX template data, defaults to en-US\\n\\n        return_not_configured (bool):\\n            Include Administrative Template policies that are 'Not Configured'\\n            in the return data\\n\\n    Returns:\\n        dict: A dictionary containing the policy values for the specified class\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' lgpo.get machine return_full_policy_names=True\\n    \"\n    vals = {}\n    _policydata = _policy_info()\n    if policy_class is None or policy_class.lower() == 'both':\n        policy_class = _policydata.policies.keys()\n    elif policy_class.lower() not in [z.lower() for z in _policydata.policies]:\n        msg = 'The policy_class {} is not an available policy class, please use one of the following: {}, Both'\n        raise SaltInvocationError(msg.format(policy_class, ', '.join(_policydata.policies.keys())))\n    else:\n        policy_class = [policy_class.title()]\n    for p_class in policy_class:\n        this_class_policy_names = _policydata.policies[p_class]['policies']\n        class_vals = {}\n        for policy_name in this_class_policy_names:\n            _pol = None\n            if policy_name in _policydata.policies[p_class]['policies']:\n                _pol = _policydata.policies[p_class]['policies'][policy_name]\n            else:\n                for policy in _policydata.policies[p_class]['policies']:\n                    _p = _policydata.policies[p_class]['policies'][policy]['Policy']\n                    if _p == policy_name:\n                        _pol = _policydata.policies[p_class]['policies'][policy]\n                        policy_name = policy\n                if _pol is None:\n                    for policy in _policydata.policies[p_class]['policies']:\n                        _p = _policydata.policies[p_class]['policies'][policy]['Policy']\n                        if _p.lower() == policy_name.lower():\n                            _pol = _policydata.policies[p_class]['policies'][policy]\n                            policy_name = policy\n            if _pol:\n                vals_key_name = policy_name\n                class_vals[policy_name] = _get_policy_info_setting(_pol)\n                if return_full_policy_names:\n                    class_vals[_pol['Policy']] = class_vals.pop(policy_name)\n                    vals_key_name = _pol['Policy']\n                if hierarchical_return:\n                    if 'lgpo_section' in _pol:\n                        firstItem = True\n                        tdict = {}\n                        for level in reversed(_pol['lgpo_section']):\n                            newdict = {}\n                            if firstItem:\n                                newdict[level] = {vals_key_name: class_vals.pop(vals_key_name)}\n                                firstItem = False\n                            else:\n                                newdict[level] = tdict\n                            tdict = newdict\n                        if tdict:\n                            class_vals = dictupdate.update(class_vals, tdict)\n            else:\n                raise CommandExecutionError('The specified policy {} is not currently available to be configured via this module'.format(policy_name))\n        class_vals = dictupdate.update(class_vals, _checkAllAdmxPolicies(policy_class=p_class, adml_language=adml_language, return_full_policy_names=return_full_policy_names, hierarchical_return=hierarchical_return, return_not_configured=return_not_configured))\n        if _policydata.policies[p_class]['lgpo_section'] not in class_vals:\n            temp_dict = {_policydata.policies[p_class]['lgpo_section']: class_vals}\n            class_vals = temp_dict\n        vals = dictupdate.update(vals, class_vals)\n    return vals"
        ]
    },
    {
        "func_name": "_get_policy_info_setting",
        "original": "def _get_policy_info_setting(policy_definition):\n    \"\"\"\n    Some policies are defined in this module and others by the ADMX/ADML files\n    on the machine. This function loads the current values for policies defined\n    in this module.\n\n    Args:\n        policy_definition (dict):\n            A sub-dict of Policies property of the _policy_info() class.\n            Basically a dictionary that defines the policy\n\n    Returns:\n        The transformed value. The transform is defined in the policy\n        definition. It can be a list, a string, a dictionary, depending on how\n        it's defined\n\n    Usage:\n        policy_data = _policy_info()\n        policy_name = 'RemoteRegistryExactPaths'\n        policy_definition = policy_data.policies['Machine']['policies'][policy_name]\n        policy_value = _get_policy_info_setting(policy_definition)\n    \"\"\"\n    if 'Registry' in policy_definition:\n        value = __utils__['reg.read_value'](policy_definition['Registry']['Hive'], policy_definition['Registry']['Path'], policy_definition['Registry']['Value'])['vdata']\n        log.trace('Value %r found for Regisry policy %s', value, policy_definition['Policy'])\n    elif 'Secedit' in policy_definition:\n        value = _get_secedit_value(option=policy_definition['Secedit']['Option'])\n        log.trace('Value %r found for Secedit policy %s', value, policy_definition['Policy'])\n    elif 'NetSH' in policy_definition:\n        value = _get_netsh_value(profile=policy_definition['NetSH']['Profile'], option=policy_definition['NetSH']['Option'])\n        log.trace('Value %r found for NetSH policy %s', value, policy_definition['Policy'])\n    elif 'AdvAudit' in policy_definition:\n        value = _get_advaudit_value(option=policy_definition['AdvAudit']['Option'])\n        log.trace('Value %r found for AuditPol policy %s', value, policy_definition['Policy'])\n    elif 'NetUserModal' in policy_definition:\n        modal_return = win32net.NetUserModalsGet(None, policy_definition['NetUserModal']['Modal'])\n        value = modal_return[policy_definition['NetUserModal']['Option']]\n        log.trace('Value %r found for NetUserModal policy %s', value, policy_definition['Policy'])\n    elif 'LsaRights' in policy_definition:\n        value = _getRightsAssignments(policy_definition['LsaRights']['Option'])\n        log.trace('Value %r found for LSARights policy %s', value, policy_definition['Policy'])\n    elif 'ScriptIni' in policy_definition:\n        value = _getScriptSettingsFromIniFile(policy_definition)\n        log.trace('Value %r found for ScriptIni policy %s', value, policy_definition['Policy'])\n    else:\n        raise CommandExecutionError('Unknown or missing mechanism in policy_definition\\n{}'.format(policy_definition))\n    value = _transform_value(value=value, policy=policy_definition, transform_type='Get')\n    return value",
        "mutated": [
            "def _get_policy_info_setting(policy_definition):\n    if False:\n        i = 10\n    \"\\n    Some policies are defined in this module and others by the ADMX/ADML files\\n    on the machine. This function loads the current values for policies defined\\n    in this module.\\n\\n    Args:\\n        policy_definition (dict):\\n            A sub-dict of Policies property of the _policy_info() class.\\n            Basically a dictionary that defines the policy\\n\\n    Returns:\\n        The transformed value. The transform is defined in the policy\\n        definition. It can be a list, a string, a dictionary, depending on how\\n        it's defined\\n\\n    Usage:\\n        policy_data = _policy_info()\\n        policy_name = 'RemoteRegistryExactPaths'\\n        policy_definition = policy_data.policies['Machine']['policies'][policy_name]\\n        policy_value = _get_policy_info_setting(policy_definition)\\n    \"\n    if 'Registry' in policy_definition:\n        value = __utils__['reg.read_value'](policy_definition['Registry']['Hive'], policy_definition['Registry']['Path'], policy_definition['Registry']['Value'])['vdata']\n        log.trace('Value %r found for Regisry policy %s', value, policy_definition['Policy'])\n    elif 'Secedit' in policy_definition:\n        value = _get_secedit_value(option=policy_definition['Secedit']['Option'])\n        log.trace('Value %r found for Secedit policy %s', value, policy_definition['Policy'])\n    elif 'NetSH' in policy_definition:\n        value = _get_netsh_value(profile=policy_definition['NetSH']['Profile'], option=policy_definition['NetSH']['Option'])\n        log.trace('Value %r found for NetSH policy %s', value, policy_definition['Policy'])\n    elif 'AdvAudit' in policy_definition:\n        value = _get_advaudit_value(option=policy_definition['AdvAudit']['Option'])\n        log.trace('Value %r found for AuditPol policy %s', value, policy_definition['Policy'])\n    elif 'NetUserModal' in policy_definition:\n        modal_return = win32net.NetUserModalsGet(None, policy_definition['NetUserModal']['Modal'])\n        value = modal_return[policy_definition['NetUserModal']['Option']]\n        log.trace('Value %r found for NetUserModal policy %s', value, policy_definition['Policy'])\n    elif 'LsaRights' in policy_definition:\n        value = _getRightsAssignments(policy_definition['LsaRights']['Option'])\n        log.trace('Value %r found for LSARights policy %s', value, policy_definition['Policy'])\n    elif 'ScriptIni' in policy_definition:\n        value = _getScriptSettingsFromIniFile(policy_definition)\n        log.trace('Value %r found for ScriptIni policy %s', value, policy_definition['Policy'])\n    else:\n        raise CommandExecutionError('Unknown or missing mechanism in policy_definition\\n{}'.format(policy_definition))\n    value = _transform_value(value=value, policy=policy_definition, transform_type='Get')\n    return value",
            "def _get_policy_info_setting(policy_definition):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Some policies are defined in this module and others by the ADMX/ADML files\\n    on the machine. This function loads the current values for policies defined\\n    in this module.\\n\\n    Args:\\n        policy_definition (dict):\\n            A sub-dict of Policies property of the _policy_info() class.\\n            Basically a dictionary that defines the policy\\n\\n    Returns:\\n        The transformed value. The transform is defined in the policy\\n        definition. It can be a list, a string, a dictionary, depending on how\\n        it's defined\\n\\n    Usage:\\n        policy_data = _policy_info()\\n        policy_name = 'RemoteRegistryExactPaths'\\n        policy_definition = policy_data.policies['Machine']['policies'][policy_name]\\n        policy_value = _get_policy_info_setting(policy_definition)\\n    \"\n    if 'Registry' in policy_definition:\n        value = __utils__['reg.read_value'](policy_definition['Registry']['Hive'], policy_definition['Registry']['Path'], policy_definition['Registry']['Value'])['vdata']\n        log.trace('Value %r found for Regisry policy %s', value, policy_definition['Policy'])\n    elif 'Secedit' in policy_definition:\n        value = _get_secedit_value(option=policy_definition['Secedit']['Option'])\n        log.trace('Value %r found for Secedit policy %s', value, policy_definition['Policy'])\n    elif 'NetSH' in policy_definition:\n        value = _get_netsh_value(profile=policy_definition['NetSH']['Profile'], option=policy_definition['NetSH']['Option'])\n        log.trace('Value %r found for NetSH policy %s', value, policy_definition['Policy'])\n    elif 'AdvAudit' in policy_definition:\n        value = _get_advaudit_value(option=policy_definition['AdvAudit']['Option'])\n        log.trace('Value %r found for AuditPol policy %s', value, policy_definition['Policy'])\n    elif 'NetUserModal' in policy_definition:\n        modal_return = win32net.NetUserModalsGet(None, policy_definition['NetUserModal']['Modal'])\n        value = modal_return[policy_definition['NetUserModal']['Option']]\n        log.trace('Value %r found for NetUserModal policy %s', value, policy_definition['Policy'])\n    elif 'LsaRights' in policy_definition:\n        value = _getRightsAssignments(policy_definition['LsaRights']['Option'])\n        log.trace('Value %r found for LSARights policy %s', value, policy_definition['Policy'])\n    elif 'ScriptIni' in policy_definition:\n        value = _getScriptSettingsFromIniFile(policy_definition)\n        log.trace('Value %r found for ScriptIni policy %s', value, policy_definition['Policy'])\n    else:\n        raise CommandExecutionError('Unknown or missing mechanism in policy_definition\\n{}'.format(policy_definition))\n    value = _transform_value(value=value, policy=policy_definition, transform_type='Get')\n    return value",
            "def _get_policy_info_setting(policy_definition):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Some policies are defined in this module and others by the ADMX/ADML files\\n    on the machine. This function loads the current values for policies defined\\n    in this module.\\n\\n    Args:\\n        policy_definition (dict):\\n            A sub-dict of Policies property of the _policy_info() class.\\n            Basically a dictionary that defines the policy\\n\\n    Returns:\\n        The transformed value. The transform is defined in the policy\\n        definition. It can be a list, a string, a dictionary, depending on how\\n        it's defined\\n\\n    Usage:\\n        policy_data = _policy_info()\\n        policy_name = 'RemoteRegistryExactPaths'\\n        policy_definition = policy_data.policies['Machine']['policies'][policy_name]\\n        policy_value = _get_policy_info_setting(policy_definition)\\n    \"\n    if 'Registry' in policy_definition:\n        value = __utils__['reg.read_value'](policy_definition['Registry']['Hive'], policy_definition['Registry']['Path'], policy_definition['Registry']['Value'])['vdata']\n        log.trace('Value %r found for Regisry policy %s', value, policy_definition['Policy'])\n    elif 'Secedit' in policy_definition:\n        value = _get_secedit_value(option=policy_definition['Secedit']['Option'])\n        log.trace('Value %r found for Secedit policy %s', value, policy_definition['Policy'])\n    elif 'NetSH' in policy_definition:\n        value = _get_netsh_value(profile=policy_definition['NetSH']['Profile'], option=policy_definition['NetSH']['Option'])\n        log.trace('Value %r found for NetSH policy %s', value, policy_definition['Policy'])\n    elif 'AdvAudit' in policy_definition:\n        value = _get_advaudit_value(option=policy_definition['AdvAudit']['Option'])\n        log.trace('Value %r found for AuditPol policy %s', value, policy_definition['Policy'])\n    elif 'NetUserModal' in policy_definition:\n        modal_return = win32net.NetUserModalsGet(None, policy_definition['NetUserModal']['Modal'])\n        value = modal_return[policy_definition['NetUserModal']['Option']]\n        log.trace('Value %r found for NetUserModal policy %s', value, policy_definition['Policy'])\n    elif 'LsaRights' in policy_definition:\n        value = _getRightsAssignments(policy_definition['LsaRights']['Option'])\n        log.trace('Value %r found for LSARights policy %s', value, policy_definition['Policy'])\n    elif 'ScriptIni' in policy_definition:\n        value = _getScriptSettingsFromIniFile(policy_definition)\n        log.trace('Value %r found for ScriptIni policy %s', value, policy_definition['Policy'])\n    else:\n        raise CommandExecutionError('Unknown or missing mechanism in policy_definition\\n{}'.format(policy_definition))\n    value = _transform_value(value=value, policy=policy_definition, transform_type='Get')\n    return value",
            "def _get_policy_info_setting(policy_definition):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Some policies are defined in this module and others by the ADMX/ADML files\\n    on the machine. This function loads the current values for policies defined\\n    in this module.\\n\\n    Args:\\n        policy_definition (dict):\\n            A sub-dict of Policies property of the _policy_info() class.\\n            Basically a dictionary that defines the policy\\n\\n    Returns:\\n        The transformed value. The transform is defined in the policy\\n        definition. It can be a list, a string, a dictionary, depending on how\\n        it's defined\\n\\n    Usage:\\n        policy_data = _policy_info()\\n        policy_name = 'RemoteRegistryExactPaths'\\n        policy_definition = policy_data.policies['Machine']['policies'][policy_name]\\n        policy_value = _get_policy_info_setting(policy_definition)\\n    \"\n    if 'Registry' in policy_definition:\n        value = __utils__['reg.read_value'](policy_definition['Registry']['Hive'], policy_definition['Registry']['Path'], policy_definition['Registry']['Value'])['vdata']\n        log.trace('Value %r found for Regisry policy %s', value, policy_definition['Policy'])\n    elif 'Secedit' in policy_definition:\n        value = _get_secedit_value(option=policy_definition['Secedit']['Option'])\n        log.trace('Value %r found for Secedit policy %s', value, policy_definition['Policy'])\n    elif 'NetSH' in policy_definition:\n        value = _get_netsh_value(profile=policy_definition['NetSH']['Profile'], option=policy_definition['NetSH']['Option'])\n        log.trace('Value %r found for NetSH policy %s', value, policy_definition['Policy'])\n    elif 'AdvAudit' in policy_definition:\n        value = _get_advaudit_value(option=policy_definition['AdvAudit']['Option'])\n        log.trace('Value %r found for AuditPol policy %s', value, policy_definition['Policy'])\n    elif 'NetUserModal' in policy_definition:\n        modal_return = win32net.NetUserModalsGet(None, policy_definition['NetUserModal']['Modal'])\n        value = modal_return[policy_definition['NetUserModal']['Option']]\n        log.trace('Value %r found for NetUserModal policy %s', value, policy_definition['Policy'])\n    elif 'LsaRights' in policy_definition:\n        value = _getRightsAssignments(policy_definition['LsaRights']['Option'])\n        log.trace('Value %r found for LSARights policy %s', value, policy_definition['Policy'])\n    elif 'ScriptIni' in policy_definition:\n        value = _getScriptSettingsFromIniFile(policy_definition)\n        log.trace('Value %r found for ScriptIni policy %s', value, policy_definition['Policy'])\n    else:\n        raise CommandExecutionError('Unknown or missing mechanism in policy_definition\\n{}'.format(policy_definition))\n    value = _transform_value(value=value, policy=policy_definition, transform_type='Get')\n    return value",
            "def _get_policy_info_setting(policy_definition):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Some policies are defined in this module and others by the ADMX/ADML files\\n    on the machine. This function loads the current values for policies defined\\n    in this module.\\n\\n    Args:\\n        policy_definition (dict):\\n            A sub-dict of Policies property of the _policy_info() class.\\n            Basically a dictionary that defines the policy\\n\\n    Returns:\\n        The transformed value. The transform is defined in the policy\\n        definition. It can be a list, a string, a dictionary, depending on how\\n        it's defined\\n\\n    Usage:\\n        policy_data = _policy_info()\\n        policy_name = 'RemoteRegistryExactPaths'\\n        policy_definition = policy_data.policies['Machine']['policies'][policy_name]\\n        policy_value = _get_policy_info_setting(policy_definition)\\n    \"\n    if 'Registry' in policy_definition:\n        value = __utils__['reg.read_value'](policy_definition['Registry']['Hive'], policy_definition['Registry']['Path'], policy_definition['Registry']['Value'])['vdata']\n        log.trace('Value %r found for Regisry policy %s', value, policy_definition['Policy'])\n    elif 'Secedit' in policy_definition:\n        value = _get_secedit_value(option=policy_definition['Secedit']['Option'])\n        log.trace('Value %r found for Secedit policy %s', value, policy_definition['Policy'])\n    elif 'NetSH' in policy_definition:\n        value = _get_netsh_value(profile=policy_definition['NetSH']['Profile'], option=policy_definition['NetSH']['Option'])\n        log.trace('Value %r found for NetSH policy %s', value, policy_definition['Policy'])\n    elif 'AdvAudit' in policy_definition:\n        value = _get_advaudit_value(option=policy_definition['AdvAudit']['Option'])\n        log.trace('Value %r found for AuditPol policy %s', value, policy_definition['Policy'])\n    elif 'NetUserModal' in policy_definition:\n        modal_return = win32net.NetUserModalsGet(None, policy_definition['NetUserModal']['Modal'])\n        value = modal_return[policy_definition['NetUserModal']['Option']]\n        log.trace('Value %r found for NetUserModal policy %s', value, policy_definition['Policy'])\n    elif 'LsaRights' in policy_definition:\n        value = _getRightsAssignments(policy_definition['LsaRights']['Option'])\n        log.trace('Value %r found for LSARights policy %s', value, policy_definition['Policy'])\n    elif 'ScriptIni' in policy_definition:\n        value = _getScriptSettingsFromIniFile(policy_definition)\n        log.trace('Value %r found for ScriptIni policy %s', value, policy_definition['Policy'])\n    else:\n        raise CommandExecutionError('Unknown or missing mechanism in policy_definition\\n{}'.format(policy_definition))\n    value = _transform_value(value=value, policy=policy_definition, transform_type='Get')\n    return value"
        ]
    },
    {
        "func_name": "_get_policy_adm_setting",
        "original": "def _get_policy_adm_setting(admx_policy, policy_class, adml_language='en-US', return_full_policy_names=False, hierarchical_return=False):\n    \"\"\"\n    Get the current setting for polices set via the policy templates (ADMX/ADML)\n    files\n\n    Args:\n        admx_policy (obj):\n            The XPath object as returned by the ``_lookup_admin_template``\n            function\n\n        policy_class (str):\n            The policy class. Must be one of ``machine`` or ``user``\n\n        adml_language (str):\n            The language code for the adml file to use for localization. The\n            default is ``en-US``\n\n        return_full_policy_names (bool):\n            Returns the full policy name regardless of what was passed in\n            ``policy_name``\n\n        hierarchical_return (bool):\n            Returns a hierarchical view of the policy showing its parents\n\n    Returns:\n        dict: A dictionary containing the policy settings\n\n    Usage:\n        policy_name = 'AutoUpdateCfg'\n        policy_class = 'machine'\n        adml_language = 'en-US'\n        success, policy_obj, _, _ = _lookup_admin_template(\n            policy_name=policy_name,\n            policy_class=policy_class,\n            adml_language=adml_language)\n        if success:\n            setting = _get_policy_adm_setting(\n                admx_policy=policy_obj,\n                policy_class=policy_class,\n                adml_language=adml_language,\n                return_full_policy_names=return_full_policy_names,\n                hierarchical_return=hierarchical_return\n            )\n    \"\"\"\n    this_key = admx_policy.attrib.get('key', None)\n    this_policy_name = admx_policy.attrib.get('name', None)\n    if this_key is None or this_policy_name is None:\n        raise CommandExecutionError('Policy is missing the required \"key\" or \"name\" attribute:\\n{}'.format(admx_policy.attrib))\n    this_value_name = admx_policy.attrib.get('valueName', None)\n    this_policy_setting = 'Not Configured'\n    this_policy_namespace = admx_policy.nsmap[admx_policy.prefix]\n    element_only_enabled_disabled = True\n    explicit_enable_disable_value_setting = False\n    policy_file_data = read_reg_pol_file(CLASS_INFO[policy_class]['policy_path'])\n    adml_policy_resources = _get_policy_resources(language=adml_language)\n    policy_vals = {}\n    if ENABLED_VALUE_XPATH(admx_policy) and this_policy_setting == 'Not Configured':\n        if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(admx_policy):\n            element_only_enabled_disabled = False\n            explicit_enable_disable_value_setting = True\n            if _checkValueItemParent(policy_element=admx_policy, policy_name=this_policy_name, policy_key=this_key, policy_valueName=this_value_name, xpath_object=ENABLED_VALUE_XPATH, policy_file_data=policy_file_data):\n                log.trace('%s is enabled by detected ENABLED_VALUE_XPATH', this_policy_name)\n                this_policy_setting = 'Enabled'\n                policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n    if DISABLED_VALUE_XPATH(admx_policy) and this_policy_setting == 'Not Configured':\n        if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):\n            element_only_enabled_disabled = False\n            explicit_enable_disable_value_setting = True\n            if _checkValueItemParent(policy_element=admx_policy, policy_name=this_policy_name, policy_key=this_key, policy_valueName=this_value_name, xpath_object=DISABLED_VALUE_XPATH, policy_file_data=policy_file_data):\n                log.trace('%s is disabled by detected DISABLED_VALUE_XPATH', this_policy_name)\n                this_policy_setting = 'Disabled'\n                policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n    if ENABLED_LIST_XPATH(admx_policy):\n        if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(admx_policy):\n            element_only_enabled_disabled = False\n            explicit_enable_disable_value_setting = True\n            if _checkListItem(policy_element=admx_policy, policy_name=this_policy_name, policy_key=this_key, xpath_object=ENABLED_LIST_XPATH, policy_file_data=policy_file_data):\n                log.trace('%s is enabled by detected ENABLED_LIST_XPATH', this_policy_name)\n                this_policy_setting = 'Enabled'\n                policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n    if DISABLED_LIST_XPATH(admx_policy):\n        if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):\n            element_only_enabled_disabled = False\n            explicit_enable_disable_value_setting = True\n            if _checkListItem(policy_element=admx_policy, policy_name=this_policy_name, policy_key=this_key, xpath_object=DISABLED_LIST_XPATH, policy_file_data=policy_file_data):\n                log.trace('%s is disabled by detected DISABLED_LIST_XPATH', this_policy_name)\n                this_policy_setting = 'Disabled'\n                policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n    if not explicit_enable_disable_value_setting and this_value_name:\n        if search_reg_pol(re.escape(_buildKnownDataSearchString(reg_key=this_key, reg_valueName=this_value_name, reg_vtype='REG_DWORD', reg_data='1')), policy_file_data):\n            log.trace('%s is enabled by no explicit enable/disable list or value', this_policy_name)\n            this_policy_setting = 'Enabled'\n            policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n        elif search_reg_pol(re.escape(_buildKnownDataSearchString(reg_key=this_key, reg_valueName=this_value_name, reg_vtype='REG_DWORD', reg_data=None, check_deleted=True)), policy_file_data):\n            log.trace('%s is disabled by no explicit enable/disable list or value', this_policy_name)\n            this_policy_setting = 'Disabled'\n            policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n    full_names = {}\n    hierarchy = {}\n    if ELEMENTS_XPATH(admx_policy):\n        if element_only_enabled_disabled or this_policy_setting == 'Enabled':\n            required_elements = {}\n            configured_elements = {}\n            policy_disabled_elements = 0\n            for elements_item in ELEMENTS_XPATH(admx_policy):\n                for child_item in elements_item:\n                    this_element_name = _getFullPolicyName(policy_item=child_item, policy_name=child_item.attrib['id'], return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n                    required_elements[this_element_name] = None\n                    child_key = child_item.attrib.get('key', this_key)\n                    child_value_name = child_item.attrib.get('valueName', this_value_name)\n                    if etree.QName(child_item).localname == 'boolean':\n                        if len(child_item) > 0:\n                            if TRUE_VALUE_XPATH(child_item) and this_element_name not in configured_elements:\n                                if _checkValueItemParent(policy_element=child_item, policy_name=this_policy_name, policy_key=child_key, policy_valueName=child_value_name, xpath_object=TRUE_VALUE_XPATH, policy_file_data=policy_file_data):\n                                    configured_elements[this_element_name] = True\n                                    log.trace('element %s is configured true', child_item.attrib['id'])\n                            if FALSE_VALUE_XPATH(child_item) and this_element_name not in configured_elements:\n                                if _checkValueItemParent(policy_element=child_item, policy_name=this_policy_name, policy_key=child_key, policy_valueName=child_value_name, xpath_object=FALSE_VALUE_XPATH, policy_file_data=policy_file_data):\n                                    configured_elements[this_element_name] = False\n                                    policy_disabled_elements = policy_disabled_elements + 1\n                                    log.trace('element %s is configured false', child_item.attrib['id'])\n                            if TRUE_LIST_XPATH(child_item) and this_element_name not in configured_elements:\n                                log.trace('checking trueList')\n                                if _checkListItem(policy_element=child_item, policy_name=this_policy_name, policy_key=this_key, xpath_object=TRUE_LIST_XPATH, policy_file_data=policy_file_data):\n                                    configured_elements[this_element_name] = True\n                                    log.trace('element %s is configured true', child_item.attrib['id'])\n                            if FALSE_LIST_XPATH(child_item) and this_element_name not in configured_elements:\n                                log.trace('checking falseList')\n                                if _checkListItem(policy_element=child_item, policy_name=this_policy_name, policy_key=this_key, xpath_object=FALSE_LIST_XPATH, policy_file_data=policy_file_data):\n                                    configured_elements[this_element_name] = False\n                                    policy_disabled_elements = policy_disabled_elements + 1\n                                    log.trace('element %s is configured false', child_item.attrib['id'])\n                        elif search_reg_pol(re.escape(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=True)), policy_file_data):\n                            configured_elements[this_element_name] = False\n                            policy_disabled_elements = policy_disabled_elements + 1\n                            log.trace('element %s is configured false', child_item.attrib['id'])\n                        elif search_reg_pol(re.escape(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=False)), policy_file_data):\n                            configured_elements[this_element_name] = True\n                            log.trace('element %s is configured true', child_item.attrib['id'])\n                    elif etree.QName(child_item).localname in ['decimal', 'text', 'longDecimal', 'multiText']:\n                        if search_reg_pol(re.escape(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=True)), policy_file_data):\n                            configured_elements[this_element_name] = 'Disabled'\n                            policy_disabled_elements = policy_disabled_elements + 1\n                            log.trace('element %s is disabled', child_item.attrib['id'])\n                        elif search_reg_pol(re.escape(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=False)), policy_data=policy_file_data):\n                            configured_value = _getDataFromRegPolData(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=False), policy_data=policy_file_data)\n                            configured_elements[this_element_name] = configured_value\n                            log.trace('element %s is enabled, value == %s', child_item.attrib['id'], configured_value)\n                    elif etree.QName(child_item).localname == 'enum':\n                        if search_reg_pol(re.escape(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=True)), policy_file_data):\n                            log.trace('enum element %s is disabled', child_item.attrib['id'])\n                            configured_elements[this_element_name] = 'Disabled'\n                            policy_disabled_elements = policy_disabled_elements + 1\n                        else:\n                            for enum_item in child_item:\n                                if _checkValueItemParent(policy_element=enum_item, policy_name=child_item.attrib['id'], policy_key=child_key, policy_valueName=child_value_name, xpath_object=VALUE_XPATH, policy_file_data=policy_file_data):\n                                    if VALUE_LIST_XPATH(enum_item):\n                                        log.trace('enum item has a valueList')\n                                        if _checkListItem(policy_element=enum_item, policy_name=this_policy_name, policy_key=child_key, xpath_object=VALUE_LIST_XPATH, policy_file_data=policy_file_data):\n                                            log.trace('all valueList items exist in file')\n                                            configured_elements[this_element_name] = _getAdmlDisplayName(adml_xml_data=adml_policy_resources, display_name=enum_item.attrib['displayName'])\n                                            break\n                                    else:\n                                        configured_elements[this_element_name] = _getAdmlDisplayName(adml_xml_data=adml_policy_resources, display_name=enum_item.attrib['displayName'])\n                                        break\n                    elif etree.QName(child_item).localname == 'list':\n                        return_value_name = False\n                        if 'explicitValue' in child_item.attrib and child_item.attrib['explicitValue'].lower() == 'true':\n                            log.trace('explicitValue list, we will return value names')\n                            return_value_name = True\n                        regex_str = ['(?!\\\\*', '\\\\*', 'D', 'e', 'l', 'V', 'a', 'l', 's', '\\\\.', ')']\n                        delvals_regex = '\\x00'.join(regex_str)\n                        delvals_regex = salt.utils.stringutils.to_bytes(delvals_regex)\n                        if search_reg_pol(re.escape(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=False)) + delvals_regex, policy_data=policy_file_data):\n                            configured_value = _getDataFromRegPolData(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=False), policy_data=policy_file_data, return_value_name=return_value_name)\n                            configured_elements[this_element_name] = configured_value\n                            log.trace('element %s is enabled values: %s', child_item.attrib['id'], configured_value)\n                        elif search_reg_pol(re.escape(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=True)), policy_file_data):\n                            configured_elements[this_element_name] = 'Disabled'\n                            policy_disabled_elements = policy_disabled_elements + 1\n                            log.trace('element %s is disabled', child_item.attrib['id'])\n            if element_only_enabled_disabled:\n                if 0 < len(required_elements.keys()) == len(configured_elements.keys()):\n                    if policy_disabled_elements == len(required_elements.keys()):\n                        log.trace('%s is disabled by all enum elements', this_policy_name)\n                        policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = 'Disabled'\n                    else:\n                        log.trace('%s is enabled by enum elements', this_policy_name)\n                        policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = configured_elements\n                else:\n                    policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n            elif this_policy_setting == 'Enabled':\n                policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = configured_elements\n        else:\n            policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n    else:\n        policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n    if return_full_policy_names and this_policy_namespace in policy_vals and (this_policy_name in policy_vals[this_policy_namespace]):\n        full_names.setdefault(this_policy_namespace, {})\n        full_names[this_policy_namespace][this_policy_name] = _getFullPolicyName(policy_item=admx_policy, policy_name=admx_policy.attrib['name'], return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n        if this_policy_name in policy_vals[this_policy_namespace][this_policy_name]:\n            full_name = full_names[this_policy_namespace][this_policy_name]\n            setting = policy_vals[this_policy_namespace][this_policy_name].pop(this_policy_name)\n            policy_vals[this_policy_namespace][this_policy_name][full_name] = setting\n    if this_policy_namespace in policy_vals and this_policy_name in policy_vals[this_policy_namespace]:\n        hierarchy.setdefault(this_policy_namespace, {})[this_policy_name] = _build_parent_list(policy_definition=admx_policy, return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n    if policy_vals and return_full_policy_names and (not hierarchical_return):\n        log.debug('Compiling non hierarchical return...')\n        unpathed_dict = {}\n        pathed_dict = {}\n        for policy_namespace in list(policy_vals):\n            for policy_item in list(policy_vals[policy_namespace]):\n                full_name = full_names[policy_namespace][policy_item]\n                if full_name in policy_vals[policy_namespace]:\n                    full_path_list = hierarchy[policy_namespace][policy_item]\n                    full_path_list.reverse()\n                    full_path_list.append(full_names[policy_namespace][policy_item])\n                    policy_vals['\\\\'.join(full_path_list)] = policy_vals[policy_namespace].pop(policy_item)\n                    pathed_dict[full_name] = True\n                else:\n                    policy_vals[policy_namespace][full_name] = policy_vals[policy_namespace].pop(policy_item)\n                    unpathed_dict.setdefault(policy_namespace, {})[full_name] = policy_item\n            for path_needed in unpathed_dict.get(policy_namespace, {}):\n                full_path_list = hierarchy[policy_namespace][unpathed_dict[policy_namespace][path_needed]]\n                full_path_list.reverse()\n                full_path_list.append(path_needed)\n                log.trace('full_path_list == %s', full_path_list)\n                policy_vals['\\\\'.join(full_path_list)] = policy_vals[policy_namespace].pop(path_needed)\n    for policy_namespace in list(policy_vals):\n        if policy_vals[policy_namespace] == {}:\n            policy_vals.pop(policy_namespace)\n        elif isinstance(policy_vals[policy_namespace], dict):\n            if this_policy_namespace == policy_namespace and (not hierarchical_return):\n                policy_vals.update(policy_vals[policy_namespace])\n                policy_vals.pop(policy_namespace)\n    if policy_vals and hierarchical_return:\n        if hierarchy:\n            log.debug('Compiling hierarchical return...')\n            for policy_namespace in hierarchy:\n                for hierarchy_item in hierarchy[policy_namespace]:\n                    if hierarchy_item in policy_vals[policy_namespace]:\n                        t_dict = {}\n                        first_item = True\n                        for item in hierarchy[policy_namespace][hierarchy_item]:\n                            new_dict = {}\n                            if first_item:\n                                h_policy_name = hierarchy_item\n                                if return_full_policy_names:\n                                    h_policy_name = full_names[policy_namespace][hierarchy_item]\n                                new_dict[item] = {h_policy_name: policy_vals[policy_namespace].pop(hierarchy_item)}\n                                first_item = False\n                            else:\n                                new_dict[item] = t_dict\n                            t_dict = new_dict\n                        if t_dict:\n                            policy_vals = dictupdate.update(policy_vals, t_dict)\n                if policy_namespace in policy_vals and policy_vals[policy_namespace] == {}:\n                    policy_vals.pop(policy_namespace)\n        policy_vals = {CLASS_INFO[policy_class]['lgpo_section']: {'Administrative Templates': policy_vals}}\n    return policy_vals",
        "mutated": [
            "def _get_policy_adm_setting(admx_policy, policy_class, adml_language='en-US', return_full_policy_names=False, hierarchical_return=False):\n    if False:\n        i = 10\n    \"\\n    Get the current setting for polices set via the policy templates (ADMX/ADML)\\n    files\\n\\n    Args:\\n        admx_policy (obj):\\n            The XPath object as returned by the ``_lookup_admin_template``\\n            function\\n\\n        policy_class (str):\\n            The policy class. Must be one of ``machine`` or ``user``\\n\\n        adml_language (str):\\n            The language code for the adml file to use for localization. The\\n            default is ``en-US``\\n\\n        return_full_policy_names (bool):\\n            Returns the full policy name regardless of what was passed in\\n            ``policy_name``\\n\\n        hierarchical_return (bool):\\n            Returns a hierarchical view of the policy showing its parents\\n\\n    Returns:\\n        dict: A dictionary containing the policy settings\\n\\n    Usage:\\n        policy_name = 'AutoUpdateCfg'\\n        policy_class = 'machine'\\n        adml_language = 'en-US'\\n        success, policy_obj, _, _ = _lookup_admin_template(\\n            policy_name=policy_name,\\n            policy_class=policy_class,\\n            adml_language=adml_language)\\n        if success:\\n            setting = _get_policy_adm_setting(\\n                admx_policy=policy_obj,\\n                policy_class=policy_class,\\n                adml_language=adml_language,\\n                return_full_policy_names=return_full_policy_names,\\n                hierarchical_return=hierarchical_return\\n            )\\n    \"\n    this_key = admx_policy.attrib.get('key', None)\n    this_policy_name = admx_policy.attrib.get('name', None)\n    if this_key is None or this_policy_name is None:\n        raise CommandExecutionError('Policy is missing the required \"key\" or \"name\" attribute:\\n{}'.format(admx_policy.attrib))\n    this_value_name = admx_policy.attrib.get('valueName', None)\n    this_policy_setting = 'Not Configured'\n    this_policy_namespace = admx_policy.nsmap[admx_policy.prefix]\n    element_only_enabled_disabled = True\n    explicit_enable_disable_value_setting = False\n    policy_file_data = read_reg_pol_file(CLASS_INFO[policy_class]['policy_path'])\n    adml_policy_resources = _get_policy_resources(language=adml_language)\n    policy_vals = {}\n    if ENABLED_VALUE_XPATH(admx_policy) and this_policy_setting == 'Not Configured':\n        if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(admx_policy):\n            element_only_enabled_disabled = False\n            explicit_enable_disable_value_setting = True\n            if _checkValueItemParent(policy_element=admx_policy, policy_name=this_policy_name, policy_key=this_key, policy_valueName=this_value_name, xpath_object=ENABLED_VALUE_XPATH, policy_file_data=policy_file_data):\n                log.trace('%s is enabled by detected ENABLED_VALUE_XPATH', this_policy_name)\n                this_policy_setting = 'Enabled'\n                policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n    if DISABLED_VALUE_XPATH(admx_policy) and this_policy_setting == 'Not Configured':\n        if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):\n            element_only_enabled_disabled = False\n            explicit_enable_disable_value_setting = True\n            if _checkValueItemParent(policy_element=admx_policy, policy_name=this_policy_name, policy_key=this_key, policy_valueName=this_value_name, xpath_object=DISABLED_VALUE_XPATH, policy_file_data=policy_file_data):\n                log.trace('%s is disabled by detected DISABLED_VALUE_XPATH', this_policy_name)\n                this_policy_setting = 'Disabled'\n                policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n    if ENABLED_LIST_XPATH(admx_policy):\n        if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(admx_policy):\n            element_only_enabled_disabled = False\n            explicit_enable_disable_value_setting = True\n            if _checkListItem(policy_element=admx_policy, policy_name=this_policy_name, policy_key=this_key, xpath_object=ENABLED_LIST_XPATH, policy_file_data=policy_file_data):\n                log.trace('%s is enabled by detected ENABLED_LIST_XPATH', this_policy_name)\n                this_policy_setting = 'Enabled'\n                policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n    if DISABLED_LIST_XPATH(admx_policy):\n        if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):\n            element_only_enabled_disabled = False\n            explicit_enable_disable_value_setting = True\n            if _checkListItem(policy_element=admx_policy, policy_name=this_policy_name, policy_key=this_key, xpath_object=DISABLED_LIST_XPATH, policy_file_data=policy_file_data):\n                log.trace('%s is disabled by detected DISABLED_LIST_XPATH', this_policy_name)\n                this_policy_setting = 'Disabled'\n                policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n    if not explicit_enable_disable_value_setting and this_value_name:\n        if search_reg_pol(re.escape(_buildKnownDataSearchString(reg_key=this_key, reg_valueName=this_value_name, reg_vtype='REG_DWORD', reg_data='1')), policy_file_data):\n            log.trace('%s is enabled by no explicit enable/disable list or value', this_policy_name)\n            this_policy_setting = 'Enabled'\n            policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n        elif search_reg_pol(re.escape(_buildKnownDataSearchString(reg_key=this_key, reg_valueName=this_value_name, reg_vtype='REG_DWORD', reg_data=None, check_deleted=True)), policy_file_data):\n            log.trace('%s is disabled by no explicit enable/disable list or value', this_policy_name)\n            this_policy_setting = 'Disabled'\n            policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n    full_names = {}\n    hierarchy = {}\n    if ELEMENTS_XPATH(admx_policy):\n        if element_only_enabled_disabled or this_policy_setting == 'Enabled':\n            required_elements = {}\n            configured_elements = {}\n            policy_disabled_elements = 0\n            for elements_item in ELEMENTS_XPATH(admx_policy):\n                for child_item in elements_item:\n                    this_element_name = _getFullPolicyName(policy_item=child_item, policy_name=child_item.attrib['id'], return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n                    required_elements[this_element_name] = None\n                    child_key = child_item.attrib.get('key', this_key)\n                    child_value_name = child_item.attrib.get('valueName', this_value_name)\n                    if etree.QName(child_item).localname == 'boolean':\n                        if len(child_item) > 0:\n                            if TRUE_VALUE_XPATH(child_item) and this_element_name not in configured_elements:\n                                if _checkValueItemParent(policy_element=child_item, policy_name=this_policy_name, policy_key=child_key, policy_valueName=child_value_name, xpath_object=TRUE_VALUE_XPATH, policy_file_data=policy_file_data):\n                                    configured_elements[this_element_name] = True\n                                    log.trace('element %s is configured true', child_item.attrib['id'])\n                            if FALSE_VALUE_XPATH(child_item) and this_element_name not in configured_elements:\n                                if _checkValueItemParent(policy_element=child_item, policy_name=this_policy_name, policy_key=child_key, policy_valueName=child_value_name, xpath_object=FALSE_VALUE_XPATH, policy_file_data=policy_file_data):\n                                    configured_elements[this_element_name] = False\n                                    policy_disabled_elements = policy_disabled_elements + 1\n                                    log.trace('element %s is configured false', child_item.attrib['id'])\n                            if TRUE_LIST_XPATH(child_item) and this_element_name not in configured_elements:\n                                log.trace('checking trueList')\n                                if _checkListItem(policy_element=child_item, policy_name=this_policy_name, policy_key=this_key, xpath_object=TRUE_LIST_XPATH, policy_file_data=policy_file_data):\n                                    configured_elements[this_element_name] = True\n                                    log.trace('element %s is configured true', child_item.attrib['id'])\n                            if FALSE_LIST_XPATH(child_item) and this_element_name not in configured_elements:\n                                log.trace('checking falseList')\n                                if _checkListItem(policy_element=child_item, policy_name=this_policy_name, policy_key=this_key, xpath_object=FALSE_LIST_XPATH, policy_file_data=policy_file_data):\n                                    configured_elements[this_element_name] = False\n                                    policy_disabled_elements = policy_disabled_elements + 1\n                                    log.trace('element %s is configured false', child_item.attrib['id'])\n                        elif search_reg_pol(re.escape(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=True)), policy_file_data):\n                            configured_elements[this_element_name] = False\n                            policy_disabled_elements = policy_disabled_elements + 1\n                            log.trace('element %s is configured false', child_item.attrib['id'])\n                        elif search_reg_pol(re.escape(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=False)), policy_file_data):\n                            configured_elements[this_element_name] = True\n                            log.trace('element %s is configured true', child_item.attrib['id'])\n                    elif etree.QName(child_item).localname in ['decimal', 'text', 'longDecimal', 'multiText']:\n                        if search_reg_pol(re.escape(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=True)), policy_file_data):\n                            configured_elements[this_element_name] = 'Disabled'\n                            policy_disabled_elements = policy_disabled_elements + 1\n                            log.trace('element %s is disabled', child_item.attrib['id'])\n                        elif search_reg_pol(re.escape(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=False)), policy_data=policy_file_data):\n                            configured_value = _getDataFromRegPolData(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=False), policy_data=policy_file_data)\n                            configured_elements[this_element_name] = configured_value\n                            log.trace('element %s is enabled, value == %s', child_item.attrib['id'], configured_value)\n                    elif etree.QName(child_item).localname == 'enum':\n                        if search_reg_pol(re.escape(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=True)), policy_file_data):\n                            log.trace('enum element %s is disabled', child_item.attrib['id'])\n                            configured_elements[this_element_name] = 'Disabled'\n                            policy_disabled_elements = policy_disabled_elements + 1\n                        else:\n                            for enum_item in child_item:\n                                if _checkValueItemParent(policy_element=enum_item, policy_name=child_item.attrib['id'], policy_key=child_key, policy_valueName=child_value_name, xpath_object=VALUE_XPATH, policy_file_data=policy_file_data):\n                                    if VALUE_LIST_XPATH(enum_item):\n                                        log.trace('enum item has a valueList')\n                                        if _checkListItem(policy_element=enum_item, policy_name=this_policy_name, policy_key=child_key, xpath_object=VALUE_LIST_XPATH, policy_file_data=policy_file_data):\n                                            log.trace('all valueList items exist in file')\n                                            configured_elements[this_element_name] = _getAdmlDisplayName(adml_xml_data=adml_policy_resources, display_name=enum_item.attrib['displayName'])\n                                            break\n                                    else:\n                                        configured_elements[this_element_name] = _getAdmlDisplayName(adml_xml_data=adml_policy_resources, display_name=enum_item.attrib['displayName'])\n                                        break\n                    elif etree.QName(child_item).localname == 'list':\n                        return_value_name = False\n                        if 'explicitValue' in child_item.attrib and child_item.attrib['explicitValue'].lower() == 'true':\n                            log.trace('explicitValue list, we will return value names')\n                            return_value_name = True\n                        regex_str = ['(?!\\\\*', '\\\\*', 'D', 'e', 'l', 'V', 'a', 'l', 's', '\\\\.', ')']\n                        delvals_regex = '\\x00'.join(regex_str)\n                        delvals_regex = salt.utils.stringutils.to_bytes(delvals_regex)\n                        if search_reg_pol(re.escape(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=False)) + delvals_regex, policy_data=policy_file_data):\n                            configured_value = _getDataFromRegPolData(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=False), policy_data=policy_file_data, return_value_name=return_value_name)\n                            configured_elements[this_element_name] = configured_value\n                            log.trace('element %s is enabled values: %s', child_item.attrib['id'], configured_value)\n                        elif search_reg_pol(re.escape(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=True)), policy_file_data):\n                            configured_elements[this_element_name] = 'Disabled'\n                            policy_disabled_elements = policy_disabled_elements + 1\n                            log.trace('element %s is disabled', child_item.attrib['id'])\n            if element_only_enabled_disabled:\n                if 0 < len(required_elements.keys()) == len(configured_elements.keys()):\n                    if policy_disabled_elements == len(required_elements.keys()):\n                        log.trace('%s is disabled by all enum elements', this_policy_name)\n                        policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = 'Disabled'\n                    else:\n                        log.trace('%s is enabled by enum elements', this_policy_name)\n                        policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = configured_elements\n                else:\n                    policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n            elif this_policy_setting == 'Enabled':\n                policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = configured_elements\n        else:\n            policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n    else:\n        policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n    if return_full_policy_names and this_policy_namespace in policy_vals and (this_policy_name in policy_vals[this_policy_namespace]):\n        full_names.setdefault(this_policy_namespace, {})\n        full_names[this_policy_namespace][this_policy_name] = _getFullPolicyName(policy_item=admx_policy, policy_name=admx_policy.attrib['name'], return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n        if this_policy_name in policy_vals[this_policy_namespace][this_policy_name]:\n            full_name = full_names[this_policy_namespace][this_policy_name]\n            setting = policy_vals[this_policy_namespace][this_policy_name].pop(this_policy_name)\n            policy_vals[this_policy_namespace][this_policy_name][full_name] = setting\n    if this_policy_namespace in policy_vals and this_policy_name in policy_vals[this_policy_namespace]:\n        hierarchy.setdefault(this_policy_namespace, {})[this_policy_name] = _build_parent_list(policy_definition=admx_policy, return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n    if policy_vals and return_full_policy_names and (not hierarchical_return):\n        log.debug('Compiling non hierarchical return...')\n        unpathed_dict = {}\n        pathed_dict = {}\n        for policy_namespace in list(policy_vals):\n            for policy_item in list(policy_vals[policy_namespace]):\n                full_name = full_names[policy_namespace][policy_item]\n                if full_name in policy_vals[policy_namespace]:\n                    full_path_list = hierarchy[policy_namespace][policy_item]\n                    full_path_list.reverse()\n                    full_path_list.append(full_names[policy_namespace][policy_item])\n                    policy_vals['\\\\'.join(full_path_list)] = policy_vals[policy_namespace].pop(policy_item)\n                    pathed_dict[full_name] = True\n                else:\n                    policy_vals[policy_namespace][full_name] = policy_vals[policy_namespace].pop(policy_item)\n                    unpathed_dict.setdefault(policy_namespace, {})[full_name] = policy_item\n            for path_needed in unpathed_dict.get(policy_namespace, {}):\n                full_path_list = hierarchy[policy_namespace][unpathed_dict[policy_namespace][path_needed]]\n                full_path_list.reverse()\n                full_path_list.append(path_needed)\n                log.trace('full_path_list == %s', full_path_list)\n                policy_vals['\\\\'.join(full_path_list)] = policy_vals[policy_namespace].pop(path_needed)\n    for policy_namespace in list(policy_vals):\n        if policy_vals[policy_namespace] == {}:\n            policy_vals.pop(policy_namespace)\n        elif isinstance(policy_vals[policy_namespace], dict):\n            if this_policy_namespace == policy_namespace and (not hierarchical_return):\n                policy_vals.update(policy_vals[policy_namespace])\n                policy_vals.pop(policy_namespace)\n    if policy_vals and hierarchical_return:\n        if hierarchy:\n            log.debug('Compiling hierarchical return...')\n            for policy_namespace in hierarchy:\n                for hierarchy_item in hierarchy[policy_namespace]:\n                    if hierarchy_item in policy_vals[policy_namespace]:\n                        t_dict = {}\n                        first_item = True\n                        for item in hierarchy[policy_namespace][hierarchy_item]:\n                            new_dict = {}\n                            if first_item:\n                                h_policy_name = hierarchy_item\n                                if return_full_policy_names:\n                                    h_policy_name = full_names[policy_namespace][hierarchy_item]\n                                new_dict[item] = {h_policy_name: policy_vals[policy_namespace].pop(hierarchy_item)}\n                                first_item = False\n                            else:\n                                new_dict[item] = t_dict\n                            t_dict = new_dict\n                        if t_dict:\n                            policy_vals = dictupdate.update(policy_vals, t_dict)\n                if policy_namespace in policy_vals and policy_vals[policy_namespace] == {}:\n                    policy_vals.pop(policy_namespace)\n        policy_vals = {CLASS_INFO[policy_class]['lgpo_section']: {'Administrative Templates': policy_vals}}\n    return policy_vals",
            "def _get_policy_adm_setting(admx_policy, policy_class, adml_language='en-US', return_full_policy_names=False, hierarchical_return=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Get the current setting for polices set via the policy templates (ADMX/ADML)\\n    files\\n\\n    Args:\\n        admx_policy (obj):\\n            The XPath object as returned by the ``_lookup_admin_template``\\n            function\\n\\n        policy_class (str):\\n            The policy class. Must be one of ``machine`` or ``user``\\n\\n        adml_language (str):\\n            The language code for the adml file to use for localization. The\\n            default is ``en-US``\\n\\n        return_full_policy_names (bool):\\n            Returns the full policy name regardless of what was passed in\\n            ``policy_name``\\n\\n        hierarchical_return (bool):\\n            Returns a hierarchical view of the policy showing its parents\\n\\n    Returns:\\n        dict: A dictionary containing the policy settings\\n\\n    Usage:\\n        policy_name = 'AutoUpdateCfg'\\n        policy_class = 'machine'\\n        adml_language = 'en-US'\\n        success, policy_obj, _, _ = _lookup_admin_template(\\n            policy_name=policy_name,\\n            policy_class=policy_class,\\n            adml_language=adml_language)\\n        if success:\\n            setting = _get_policy_adm_setting(\\n                admx_policy=policy_obj,\\n                policy_class=policy_class,\\n                adml_language=adml_language,\\n                return_full_policy_names=return_full_policy_names,\\n                hierarchical_return=hierarchical_return\\n            )\\n    \"\n    this_key = admx_policy.attrib.get('key', None)\n    this_policy_name = admx_policy.attrib.get('name', None)\n    if this_key is None or this_policy_name is None:\n        raise CommandExecutionError('Policy is missing the required \"key\" or \"name\" attribute:\\n{}'.format(admx_policy.attrib))\n    this_value_name = admx_policy.attrib.get('valueName', None)\n    this_policy_setting = 'Not Configured'\n    this_policy_namespace = admx_policy.nsmap[admx_policy.prefix]\n    element_only_enabled_disabled = True\n    explicit_enable_disable_value_setting = False\n    policy_file_data = read_reg_pol_file(CLASS_INFO[policy_class]['policy_path'])\n    adml_policy_resources = _get_policy_resources(language=adml_language)\n    policy_vals = {}\n    if ENABLED_VALUE_XPATH(admx_policy) and this_policy_setting == 'Not Configured':\n        if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(admx_policy):\n            element_only_enabled_disabled = False\n            explicit_enable_disable_value_setting = True\n            if _checkValueItemParent(policy_element=admx_policy, policy_name=this_policy_name, policy_key=this_key, policy_valueName=this_value_name, xpath_object=ENABLED_VALUE_XPATH, policy_file_data=policy_file_data):\n                log.trace('%s is enabled by detected ENABLED_VALUE_XPATH', this_policy_name)\n                this_policy_setting = 'Enabled'\n                policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n    if DISABLED_VALUE_XPATH(admx_policy) and this_policy_setting == 'Not Configured':\n        if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):\n            element_only_enabled_disabled = False\n            explicit_enable_disable_value_setting = True\n            if _checkValueItemParent(policy_element=admx_policy, policy_name=this_policy_name, policy_key=this_key, policy_valueName=this_value_name, xpath_object=DISABLED_VALUE_XPATH, policy_file_data=policy_file_data):\n                log.trace('%s is disabled by detected DISABLED_VALUE_XPATH', this_policy_name)\n                this_policy_setting = 'Disabled'\n                policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n    if ENABLED_LIST_XPATH(admx_policy):\n        if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(admx_policy):\n            element_only_enabled_disabled = False\n            explicit_enable_disable_value_setting = True\n            if _checkListItem(policy_element=admx_policy, policy_name=this_policy_name, policy_key=this_key, xpath_object=ENABLED_LIST_XPATH, policy_file_data=policy_file_data):\n                log.trace('%s is enabled by detected ENABLED_LIST_XPATH', this_policy_name)\n                this_policy_setting = 'Enabled'\n                policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n    if DISABLED_LIST_XPATH(admx_policy):\n        if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):\n            element_only_enabled_disabled = False\n            explicit_enable_disable_value_setting = True\n            if _checkListItem(policy_element=admx_policy, policy_name=this_policy_name, policy_key=this_key, xpath_object=DISABLED_LIST_XPATH, policy_file_data=policy_file_data):\n                log.trace('%s is disabled by detected DISABLED_LIST_XPATH', this_policy_name)\n                this_policy_setting = 'Disabled'\n                policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n    if not explicit_enable_disable_value_setting and this_value_name:\n        if search_reg_pol(re.escape(_buildKnownDataSearchString(reg_key=this_key, reg_valueName=this_value_name, reg_vtype='REG_DWORD', reg_data='1')), policy_file_data):\n            log.trace('%s is enabled by no explicit enable/disable list or value', this_policy_name)\n            this_policy_setting = 'Enabled'\n            policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n        elif search_reg_pol(re.escape(_buildKnownDataSearchString(reg_key=this_key, reg_valueName=this_value_name, reg_vtype='REG_DWORD', reg_data=None, check_deleted=True)), policy_file_data):\n            log.trace('%s is disabled by no explicit enable/disable list or value', this_policy_name)\n            this_policy_setting = 'Disabled'\n            policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n    full_names = {}\n    hierarchy = {}\n    if ELEMENTS_XPATH(admx_policy):\n        if element_only_enabled_disabled or this_policy_setting == 'Enabled':\n            required_elements = {}\n            configured_elements = {}\n            policy_disabled_elements = 0\n            for elements_item in ELEMENTS_XPATH(admx_policy):\n                for child_item in elements_item:\n                    this_element_name = _getFullPolicyName(policy_item=child_item, policy_name=child_item.attrib['id'], return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n                    required_elements[this_element_name] = None\n                    child_key = child_item.attrib.get('key', this_key)\n                    child_value_name = child_item.attrib.get('valueName', this_value_name)\n                    if etree.QName(child_item).localname == 'boolean':\n                        if len(child_item) > 0:\n                            if TRUE_VALUE_XPATH(child_item) and this_element_name not in configured_elements:\n                                if _checkValueItemParent(policy_element=child_item, policy_name=this_policy_name, policy_key=child_key, policy_valueName=child_value_name, xpath_object=TRUE_VALUE_XPATH, policy_file_data=policy_file_data):\n                                    configured_elements[this_element_name] = True\n                                    log.trace('element %s is configured true', child_item.attrib['id'])\n                            if FALSE_VALUE_XPATH(child_item) and this_element_name not in configured_elements:\n                                if _checkValueItemParent(policy_element=child_item, policy_name=this_policy_name, policy_key=child_key, policy_valueName=child_value_name, xpath_object=FALSE_VALUE_XPATH, policy_file_data=policy_file_data):\n                                    configured_elements[this_element_name] = False\n                                    policy_disabled_elements = policy_disabled_elements + 1\n                                    log.trace('element %s is configured false', child_item.attrib['id'])\n                            if TRUE_LIST_XPATH(child_item) and this_element_name not in configured_elements:\n                                log.trace('checking trueList')\n                                if _checkListItem(policy_element=child_item, policy_name=this_policy_name, policy_key=this_key, xpath_object=TRUE_LIST_XPATH, policy_file_data=policy_file_data):\n                                    configured_elements[this_element_name] = True\n                                    log.trace('element %s is configured true', child_item.attrib['id'])\n                            if FALSE_LIST_XPATH(child_item) and this_element_name not in configured_elements:\n                                log.trace('checking falseList')\n                                if _checkListItem(policy_element=child_item, policy_name=this_policy_name, policy_key=this_key, xpath_object=FALSE_LIST_XPATH, policy_file_data=policy_file_data):\n                                    configured_elements[this_element_name] = False\n                                    policy_disabled_elements = policy_disabled_elements + 1\n                                    log.trace('element %s is configured false', child_item.attrib['id'])\n                        elif search_reg_pol(re.escape(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=True)), policy_file_data):\n                            configured_elements[this_element_name] = False\n                            policy_disabled_elements = policy_disabled_elements + 1\n                            log.trace('element %s is configured false', child_item.attrib['id'])\n                        elif search_reg_pol(re.escape(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=False)), policy_file_data):\n                            configured_elements[this_element_name] = True\n                            log.trace('element %s is configured true', child_item.attrib['id'])\n                    elif etree.QName(child_item).localname in ['decimal', 'text', 'longDecimal', 'multiText']:\n                        if search_reg_pol(re.escape(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=True)), policy_file_data):\n                            configured_elements[this_element_name] = 'Disabled'\n                            policy_disabled_elements = policy_disabled_elements + 1\n                            log.trace('element %s is disabled', child_item.attrib['id'])\n                        elif search_reg_pol(re.escape(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=False)), policy_data=policy_file_data):\n                            configured_value = _getDataFromRegPolData(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=False), policy_data=policy_file_data)\n                            configured_elements[this_element_name] = configured_value\n                            log.trace('element %s is enabled, value == %s', child_item.attrib['id'], configured_value)\n                    elif etree.QName(child_item).localname == 'enum':\n                        if search_reg_pol(re.escape(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=True)), policy_file_data):\n                            log.trace('enum element %s is disabled', child_item.attrib['id'])\n                            configured_elements[this_element_name] = 'Disabled'\n                            policy_disabled_elements = policy_disabled_elements + 1\n                        else:\n                            for enum_item in child_item:\n                                if _checkValueItemParent(policy_element=enum_item, policy_name=child_item.attrib['id'], policy_key=child_key, policy_valueName=child_value_name, xpath_object=VALUE_XPATH, policy_file_data=policy_file_data):\n                                    if VALUE_LIST_XPATH(enum_item):\n                                        log.trace('enum item has a valueList')\n                                        if _checkListItem(policy_element=enum_item, policy_name=this_policy_name, policy_key=child_key, xpath_object=VALUE_LIST_XPATH, policy_file_data=policy_file_data):\n                                            log.trace('all valueList items exist in file')\n                                            configured_elements[this_element_name] = _getAdmlDisplayName(adml_xml_data=adml_policy_resources, display_name=enum_item.attrib['displayName'])\n                                            break\n                                    else:\n                                        configured_elements[this_element_name] = _getAdmlDisplayName(adml_xml_data=adml_policy_resources, display_name=enum_item.attrib['displayName'])\n                                        break\n                    elif etree.QName(child_item).localname == 'list':\n                        return_value_name = False\n                        if 'explicitValue' in child_item.attrib and child_item.attrib['explicitValue'].lower() == 'true':\n                            log.trace('explicitValue list, we will return value names')\n                            return_value_name = True\n                        regex_str = ['(?!\\\\*', '\\\\*', 'D', 'e', 'l', 'V', 'a', 'l', 's', '\\\\.', ')']\n                        delvals_regex = '\\x00'.join(regex_str)\n                        delvals_regex = salt.utils.stringutils.to_bytes(delvals_regex)\n                        if search_reg_pol(re.escape(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=False)) + delvals_regex, policy_data=policy_file_data):\n                            configured_value = _getDataFromRegPolData(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=False), policy_data=policy_file_data, return_value_name=return_value_name)\n                            configured_elements[this_element_name] = configured_value\n                            log.trace('element %s is enabled values: %s', child_item.attrib['id'], configured_value)\n                        elif search_reg_pol(re.escape(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=True)), policy_file_data):\n                            configured_elements[this_element_name] = 'Disabled'\n                            policy_disabled_elements = policy_disabled_elements + 1\n                            log.trace('element %s is disabled', child_item.attrib['id'])\n            if element_only_enabled_disabled:\n                if 0 < len(required_elements.keys()) == len(configured_elements.keys()):\n                    if policy_disabled_elements == len(required_elements.keys()):\n                        log.trace('%s is disabled by all enum elements', this_policy_name)\n                        policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = 'Disabled'\n                    else:\n                        log.trace('%s is enabled by enum elements', this_policy_name)\n                        policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = configured_elements\n                else:\n                    policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n            elif this_policy_setting == 'Enabled':\n                policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = configured_elements\n        else:\n            policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n    else:\n        policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n    if return_full_policy_names and this_policy_namespace in policy_vals and (this_policy_name in policy_vals[this_policy_namespace]):\n        full_names.setdefault(this_policy_namespace, {})\n        full_names[this_policy_namespace][this_policy_name] = _getFullPolicyName(policy_item=admx_policy, policy_name=admx_policy.attrib['name'], return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n        if this_policy_name in policy_vals[this_policy_namespace][this_policy_name]:\n            full_name = full_names[this_policy_namespace][this_policy_name]\n            setting = policy_vals[this_policy_namespace][this_policy_name].pop(this_policy_name)\n            policy_vals[this_policy_namespace][this_policy_name][full_name] = setting\n    if this_policy_namespace in policy_vals and this_policy_name in policy_vals[this_policy_namespace]:\n        hierarchy.setdefault(this_policy_namespace, {})[this_policy_name] = _build_parent_list(policy_definition=admx_policy, return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n    if policy_vals and return_full_policy_names and (not hierarchical_return):\n        log.debug('Compiling non hierarchical return...')\n        unpathed_dict = {}\n        pathed_dict = {}\n        for policy_namespace in list(policy_vals):\n            for policy_item in list(policy_vals[policy_namespace]):\n                full_name = full_names[policy_namespace][policy_item]\n                if full_name in policy_vals[policy_namespace]:\n                    full_path_list = hierarchy[policy_namespace][policy_item]\n                    full_path_list.reverse()\n                    full_path_list.append(full_names[policy_namespace][policy_item])\n                    policy_vals['\\\\'.join(full_path_list)] = policy_vals[policy_namespace].pop(policy_item)\n                    pathed_dict[full_name] = True\n                else:\n                    policy_vals[policy_namespace][full_name] = policy_vals[policy_namespace].pop(policy_item)\n                    unpathed_dict.setdefault(policy_namespace, {})[full_name] = policy_item\n            for path_needed in unpathed_dict.get(policy_namespace, {}):\n                full_path_list = hierarchy[policy_namespace][unpathed_dict[policy_namespace][path_needed]]\n                full_path_list.reverse()\n                full_path_list.append(path_needed)\n                log.trace('full_path_list == %s', full_path_list)\n                policy_vals['\\\\'.join(full_path_list)] = policy_vals[policy_namespace].pop(path_needed)\n    for policy_namespace in list(policy_vals):\n        if policy_vals[policy_namespace] == {}:\n            policy_vals.pop(policy_namespace)\n        elif isinstance(policy_vals[policy_namespace], dict):\n            if this_policy_namespace == policy_namespace and (not hierarchical_return):\n                policy_vals.update(policy_vals[policy_namespace])\n                policy_vals.pop(policy_namespace)\n    if policy_vals and hierarchical_return:\n        if hierarchy:\n            log.debug('Compiling hierarchical return...')\n            for policy_namespace in hierarchy:\n                for hierarchy_item in hierarchy[policy_namespace]:\n                    if hierarchy_item in policy_vals[policy_namespace]:\n                        t_dict = {}\n                        first_item = True\n                        for item in hierarchy[policy_namespace][hierarchy_item]:\n                            new_dict = {}\n                            if first_item:\n                                h_policy_name = hierarchy_item\n                                if return_full_policy_names:\n                                    h_policy_name = full_names[policy_namespace][hierarchy_item]\n                                new_dict[item] = {h_policy_name: policy_vals[policy_namespace].pop(hierarchy_item)}\n                                first_item = False\n                            else:\n                                new_dict[item] = t_dict\n                            t_dict = new_dict\n                        if t_dict:\n                            policy_vals = dictupdate.update(policy_vals, t_dict)\n                if policy_namespace in policy_vals and policy_vals[policy_namespace] == {}:\n                    policy_vals.pop(policy_namespace)\n        policy_vals = {CLASS_INFO[policy_class]['lgpo_section']: {'Administrative Templates': policy_vals}}\n    return policy_vals",
            "def _get_policy_adm_setting(admx_policy, policy_class, adml_language='en-US', return_full_policy_names=False, hierarchical_return=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Get the current setting for polices set via the policy templates (ADMX/ADML)\\n    files\\n\\n    Args:\\n        admx_policy (obj):\\n            The XPath object as returned by the ``_lookup_admin_template``\\n            function\\n\\n        policy_class (str):\\n            The policy class. Must be one of ``machine`` or ``user``\\n\\n        adml_language (str):\\n            The language code for the adml file to use for localization. The\\n            default is ``en-US``\\n\\n        return_full_policy_names (bool):\\n            Returns the full policy name regardless of what was passed in\\n            ``policy_name``\\n\\n        hierarchical_return (bool):\\n            Returns a hierarchical view of the policy showing its parents\\n\\n    Returns:\\n        dict: A dictionary containing the policy settings\\n\\n    Usage:\\n        policy_name = 'AutoUpdateCfg'\\n        policy_class = 'machine'\\n        adml_language = 'en-US'\\n        success, policy_obj, _, _ = _lookup_admin_template(\\n            policy_name=policy_name,\\n            policy_class=policy_class,\\n            adml_language=adml_language)\\n        if success:\\n            setting = _get_policy_adm_setting(\\n                admx_policy=policy_obj,\\n                policy_class=policy_class,\\n                adml_language=adml_language,\\n                return_full_policy_names=return_full_policy_names,\\n                hierarchical_return=hierarchical_return\\n            )\\n    \"\n    this_key = admx_policy.attrib.get('key', None)\n    this_policy_name = admx_policy.attrib.get('name', None)\n    if this_key is None or this_policy_name is None:\n        raise CommandExecutionError('Policy is missing the required \"key\" or \"name\" attribute:\\n{}'.format(admx_policy.attrib))\n    this_value_name = admx_policy.attrib.get('valueName', None)\n    this_policy_setting = 'Not Configured'\n    this_policy_namespace = admx_policy.nsmap[admx_policy.prefix]\n    element_only_enabled_disabled = True\n    explicit_enable_disable_value_setting = False\n    policy_file_data = read_reg_pol_file(CLASS_INFO[policy_class]['policy_path'])\n    adml_policy_resources = _get_policy_resources(language=adml_language)\n    policy_vals = {}\n    if ENABLED_VALUE_XPATH(admx_policy) and this_policy_setting == 'Not Configured':\n        if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(admx_policy):\n            element_only_enabled_disabled = False\n            explicit_enable_disable_value_setting = True\n            if _checkValueItemParent(policy_element=admx_policy, policy_name=this_policy_name, policy_key=this_key, policy_valueName=this_value_name, xpath_object=ENABLED_VALUE_XPATH, policy_file_data=policy_file_data):\n                log.trace('%s is enabled by detected ENABLED_VALUE_XPATH', this_policy_name)\n                this_policy_setting = 'Enabled'\n                policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n    if DISABLED_VALUE_XPATH(admx_policy) and this_policy_setting == 'Not Configured':\n        if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):\n            element_only_enabled_disabled = False\n            explicit_enable_disable_value_setting = True\n            if _checkValueItemParent(policy_element=admx_policy, policy_name=this_policy_name, policy_key=this_key, policy_valueName=this_value_name, xpath_object=DISABLED_VALUE_XPATH, policy_file_data=policy_file_data):\n                log.trace('%s is disabled by detected DISABLED_VALUE_XPATH', this_policy_name)\n                this_policy_setting = 'Disabled'\n                policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n    if ENABLED_LIST_XPATH(admx_policy):\n        if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(admx_policy):\n            element_only_enabled_disabled = False\n            explicit_enable_disable_value_setting = True\n            if _checkListItem(policy_element=admx_policy, policy_name=this_policy_name, policy_key=this_key, xpath_object=ENABLED_LIST_XPATH, policy_file_data=policy_file_data):\n                log.trace('%s is enabled by detected ENABLED_LIST_XPATH', this_policy_name)\n                this_policy_setting = 'Enabled'\n                policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n    if DISABLED_LIST_XPATH(admx_policy):\n        if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):\n            element_only_enabled_disabled = False\n            explicit_enable_disable_value_setting = True\n            if _checkListItem(policy_element=admx_policy, policy_name=this_policy_name, policy_key=this_key, xpath_object=DISABLED_LIST_XPATH, policy_file_data=policy_file_data):\n                log.trace('%s is disabled by detected DISABLED_LIST_XPATH', this_policy_name)\n                this_policy_setting = 'Disabled'\n                policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n    if not explicit_enable_disable_value_setting and this_value_name:\n        if search_reg_pol(re.escape(_buildKnownDataSearchString(reg_key=this_key, reg_valueName=this_value_name, reg_vtype='REG_DWORD', reg_data='1')), policy_file_data):\n            log.trace('%s is enabled by no explicit enable/disable list or value', this_policy_name)\n            this_policy_setting = 'Enabled'\n            policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n        elif search_reg_pol(re.escape(_buildKnownDataSearchString(reg_key=this_key, reg_valueName=this_value_name, reg_vtype='REG_DWORD', reg_data=None, check_deleted=True)), policy_file_data):\n            log.trace('%s is disabled by no explicit enable/disable list or value', this_policy_name)\n            this_policy_setting = 'Disabled'\n            policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n    full_names = {}\n    hierarchy = {}\n    if ELEMENTS_XPATH(admx_policy):\n        if element_only_enabled_disabled or this_policy_setting == 'Enabled':\n            required_elements = {}\n            configured_elements = {}\n            policy_disabled_elements = 0\n            for elements_item in ELEMENTS_XPATH(admx_policy):\n                for child_item in elements_item:\n                    this_element_name = _getFullPolicyName(policy_item=child_item, policy_name=child_item.attrib['id'], return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n                    required_elements[this_element_name] = None\n                    child_key = child_item.attrib.get('key', this_key)\n                    child_value_name = child_item.attrib.get('valueName', this_value_name)\n                    if etree.QName(child_item).localname == 'boolean':\n                        if len(child_item) > 0:\n                            if TRUE_VALUE_XPATH(child_item) and this_element_name not in configured_elements:\n                                if _checkValueItemParent(policy_element=child_item, policy_name=this_policy_name, policy_key=child_key, policy_valueName=child_value_name, xpath_object=TRUE_VALUE_XPATH, policy_file_data=policy_file_data):\n                                    configured_elements[this_element_name] = True\n                                    log.trace('element %s is configured true', child_item.attrib['id'])\n                            if FALSE_VALUE_XPATH(child_item) and this_element_name not in configured_elements:\n                                if _checkValueItemParent(policy_element=child_item, policy_name=this_policy_name, policy_key=child_key, policy_valueName=child_value_name, xpath_object=FALSE_VALUE_XPATH, policy_file_data=policy_file_data):\n                                    configured_elements[this_element_name] = False\n                                    policy_disabled_elements = policy_disabled_elements + 1\n                                    log.trace('element %s is configured false', child_item.attrib['id'])\n                            if TRUE_LIST_XPATH(child_item) and this_element_name not in configured_elements:\n                                log.trace('checking trueList')\n                                if _checkListItem(policy_element=child_item, policy_name=this_policy_name, policy_key=this_key, xpath_object=TRUE_LIST_XPATH, policy_file_data=policy_file_data):\n                                    configured_elements[this_element_name] = True\n                                    log.trace('element %s is configured true', child_item.attrib['id'])\n                            if FALSE_LIST_XPATH(child_item) and this_element_name not in configured_elements:\n                                log.trace('checking falseList')\n                                if _checkListItem(policy_element=child_item, policy_name=this_policy_name, policy_key=this_key, xpath_object=FALSE_LIST_XPATH, policy_file_data=policy_file_data):\n                                    configured_elements[this_element_name] = False\n                                    policy_disabled_elements = policy_disabled_elements + 1\n                                    log.trace('element %s is configured false', child_item.attrib['id'])\n                        elif search_reg_pol(re.escape(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=True)), policy_file_data):\n                            configured_elements[this_element_name] = False\n                            policy_disabled_elements = policy_disabled_elements + 1\n                            log.trace('element %s is configured false', child_item.attrib['id'])\n                        elif search_reg_pol(re.escape(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=False)), policy_file_data):\n                            configured_elements[this_element_name] = True\n                            log.trace('element %s is configured true', child_item.attrib['id'])\n                    elif etree.QName(child_item).localname in ['decimal', 'text', 'longDecimal', 'multiText']:\n                        if search_reg_pol(re.escape(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=True)), policy_file_data):\n                            configured_elements[this_element_name] = 'Disabled'\n                            policy_disabled_elements = policy_disabled_elements + 1\n                            log.trace('element %s is disabled', child_item.attrib['id'])\n                        elif search_reg_pol(re.escape(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=False)), policy_data=policy_file_data):\n                            configured_value = _getDataFromRegPolData(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=False), policy_data=policy_file_data)\n                            configured_elements[this_element_name] = configured_value\n                            log.trace('element %s is enabled, value == %s', child_item.attrib['id'], configured_value)\n                    elif etree.QName(child_item).localname == 'enum':\n                        if search_reg_pol(re.escape(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=True)), policy_file_data):\n                            log.trace('enum element %s is disabled', child_item.attrib['id'])\n                            configured_elements[this_element_name] = 'Disabled'\n                            policy_disabled_elements = policy_disabled_elements + 1\n                        else:\n                            for enum_item in child_item:\n                                if _checkValueItemParent(policy_element=enum_item, policy_name=child_item.attrib['id'], policy_key=child_key, policy_valueName=child_value_name, xpath_object=VALUE_XPATH, policy_file_data=policy_file_data):\n                                    if VALUE_LIST_XPATH(enum_item):\n                                        log.trace('enum item has a valueList')\n                                        if _checkListItem(policy_element=enum_item, policy_name=this_policy_name, policy_key=child_key, xpath_object=VALUE_LIST_XPATH, policy_file_data=policy_file_data):\n                                            log.trace('all valueList items exist in file')\n                                            configured_elements[this_element_name] = _getAdmlDisplayName(adml_xml_data=adml_policy_resources, display_name=enum_item.attrib['displayName'])\n                                            break\n                                    else:\n                                        configured_elements[this_element_name] = _getAdmlDisplayName(adml_xml_data=adml_policy_resources, display_name=enum_item.attrib['displayName'])\n                                        break\n                    elif etree.QName(child_item).localname == 'list':\n                        return_value_name = False\n                        if 'explicitValue' in child_item.attrib and child_item.attrib['explicitValue'].lower() == 'true':\n                            log.trace('explicitValue list, we will return value names')\n                            return_value_name = True\n                        regex_str = ['(?!\\\\*', '\\\\*', 'D', 'e', 'l', 'V', 'a', 'l', 's', '\\\\.', ')']\n                        delvals_regex = '\\x00'.join(regex_str)\n                        delvals_regex = salt.utils.stringutils.to_bytes(delvals_regex)\n                        if search_reg_pol(re.escape(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=False)) + delvals_regex, policy_data=policy_file_data):\n                            configured_value = _getDataFromRegPolData(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=False), policy_data=policy_file_data, return_value_name=return_value_name)\n                            configured_elements[this_element_name] = configured_value\n                            log.trace('element %s is enabled values: %s', child_item.attrib['id'], configured_value)\n                        elif search_reg_pol(re.escape(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=True)), policy_file_data):\n                            configured_elements[this_element_name] = 'Disabled'\n                            policy_disabled_elements = policy_disabled_elements + 1\n                            log.trace('element %s is disabled', child_item.attrib['id'])\n            if element_only_enabled_disabled:\n                if 0 < len(required_elements.keys()) == len(configured_elements.keys()):\n                    if policy_disabled_elements == len(required_elements.keys()):\n                        log.trace('%s is disabled by all enum elements', this_policy_name)\n                        policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = 'Disabled'\n                    else:\n                        log.trace('%s is enabled by enum elements', this_policy_name)\n                        policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = configured_elements\n                else:\n                    policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n            elif this_policy_setting == 'Enabled':\n                policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = configured_elements\n        else:\n            policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n    else:\n        policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n    if return_full_policy_names and this_policy_namespace in policy_vals and (this_policy_name in policy_vals[this_policy_namespace]):\n        full_names.setdefault(this_policy_namespace, {})\n        full_names[this_policy_namespace][this_policy_name] = _getFullPolicyName(policy_item=admx_policy, policy_name=admx_policy.attrib['name'], return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n        if this_policy_name in policy_vals[this_policy_namespace][this_policy_name]:\n            full_name = full_names[this_policy_namespace][this_policy_name]\n            setting = policy_vals[this_policy_namespace][this_policy_name].pop(this_policy_name)\n            policy_vals[this_policy_namespace][this_policy_name][full_name] = setting\n    if this_policy_namespace in policy_vals and this_policy_name in policy_vals[this_policy_namespace]:\n        hierarchy.setdefault(this_policy_namespace, {})[this_policy_name] = _build_parent_list(policy_definition=admx_policy, return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n    if policy_vals and return_full_policy_names and (not hierarchical_return):\n        log.debug('Compiling non hierarchical return...')\n        unpathed_dict = {}\n        pathed_dict = {}\n        for policy_namespace in list(policy_vals):\n            for policy_item in list(policy_vals[policy_namespace]):\n                full_name = full_names[policy_namespace][policy_item]\n                if full_name in policy_vals[policy_namespace]:\n                    full_path_list = hierarchy[policy_namespace][policy_item]\n                    full_path_list.reverse()\n                    full_path_list.append(full_names[policy_namespace][policy_item])\n                    policy_vals['\\\\'.join(full_path_list)] = policy_vals[policy_namespace].pop(policy_item)\n                    pathed_dict[full_name] = True\n                else:\n                    policy_vals[policy_namespace][full_name] = policy_vals[policy_namespace].pop(policy_item)\n                    unpathed_dict.setdefault(policy_namespace, {})[full_name] = policy_item\n            for path_needed in unpathed_dict.get(policy_namespace, {}):\n                full_path_list = hierarchy[policy_namespace][unpathed_dict[policy_namespace][path_needed]]\n                full_path_list.reverse()\n                full_path_list.append(path_needed)\n                log.trace('full_path_list == %s', full_path_list)\n                policy_vals['\\\\'.join(full_path_list)] = policy_vals[policy_namespace].pop(path_needed)\n    for policy_namespace in list(policy_vals):\n        if policy_vals[policy_namespace] == {}:\n            policy_vals.pop(policy_namespace)\n        elif isinstance(policy_vals[policy_namespace], dict):\n            if this_policy_namespace == policy_namespace and (not hierarchical_return):\n                policy_vals.update(policy_vals[policy_namespace])\n                policy_vals.pop(policy_namespace)\n    if policy_vals and hierarchical_return:\n        if hierarchy:\n            log.debug('Compiling hierarchical return...')\n            for policy_namespace in hierarchy:\n                for hierarchy_item in hierarchy[policy_namespace]:\n                    if hierarchy_item in policy_vals[policy_namespace]:\n                        t_dict = {}\n                        first_item = True\n                        for item in hierarchy[policy_namespace][hierarchy_item]:\n                            new_dict = {}\n                            if first_item:\n                                h_policy_name = hierarchy_item\n                                if return_full_policy_names:\n                                    h_policy_name = full_names[policy_namespace][hierarchy_item]\n                                new_dict[item] = {h_policy_name: policy_vals[policy_namespace].pop(hierarchy_item)}\n                                first_item = False\n                            else:\n                                new_dict[item] = t_dict\n                            t_dict = new_dict\n                        if t_dict:\n                            policy_vals = dictupdate.update(policy_vals, t_dict)\n                if policy_namespace in policy_vals and policy_vals[policy_namespace] == {}:\n                    policy_vals.pop(policy_namespace)\n        policy_vals = {CLASS_INFO[policy_class]['lgpo_section']: {'Administrative Templates': policy_vals}}\n    return policy_vals",
            "def _get_policy_adm_setting(admx_policy, policy_class, adml_language='en-US', return_full_policy_names=False, hierarchical_return=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Get the current setting for polices set via the policy templates (ADMX/ADML)\\n    files\\n\\n    Args:\\n        admx_policy (obj):\\n            The XPath object as returned by the ``_lookup_admin_template``\\n            function\\n\\n        policy_class (str):\\n            The policy class. Must be one of ``machine`` or ``user``\\n\\n        adml_language (str):\\n            The language code for the adml file to use for localization. The\\n            default is ``en-US``\\n\\n        return_full_policy_names (bool):\\n            Returns the full policy name regardless of what was passed in\\n            ``policy_name``\\n\\n        hierarchical_return (bool):\\n            Returns a hierarchical view of the policy showing its parents\\n\\n    Returns:\\n        dict: A dictionary containing the policy settings\\n\\n    Usage:\\n        policy_name = 'AutoUpdateCfg'\\n        policy_class = 'machine'\\n        adml_language = 'en-US'\\n        success, policy_obj, _, _ = _lookup_admin_template(\\n            policy_name=policy_name,\\n            policy_class=policy_class,\\n            adml_language=adml_language)\\n        if success:\\n            setting = _get_policy_adm_setting(\\n                admx_policy=policy_obj,\\n                policy_class=policy_class,\\n                adml_language=adml_language,\\n                return_full_policy_names=return_full_policy_names,\\n                hierarchical_return=hierarchical_return\\n            )\\n    \"\n    this_key = admx_policy.attrib.get('key', None)\n    this_policy_name = admx_policy.attrib.get('name', None)\n    if this_key is None or this_policy_name is None:\n        raise CommandExecutionError('Policy is missing the required \"key\" or \"name\" attribute:\\n{}'.format(admx_policy.attrib))\n    this_value_name = admx_policy.attrib.get('valueName', None)\n    this_policy_setting = 'Not Configured'\n    this_policy_namespace = admx_policy.nsmap[admx_policy.prefix]\n    element_only_enabled_disabled = True\n    explicit_enable_disable_value_setting = False\n    policy_file_data = read_reg_pol_file(CLASS_INFO[policy_class]['policy_path'])\n    adml_policy_resources = _get_policy_resources(language=adml_language)\n    policy_vals = {}\n    if ENABLED_VALUE_XPATH(admx_policy) and this_policy_setting == 'Not Configured':\n        if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(admx_policy):\n            element_only_enabled_disabled = False\n            explicit_enable_disable_value_setting = True\n            if _checkValueItemParent(policy_element=admx_policy, policy_name=this_policy_name, policy_key=this_key, policy_valueName=this_value_name, xpath_object=ENABLED_VALUE_XPATH, policy_file_data=policy_file_data):\n                log.trace('%s is enabled by detected ENABLED_VALUE_XPATH', this_policy_name)\n                this_policy_setting = 'Enabled'\n                policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n    if DISABLED_VALUE_XPATH(admx_policy) and this_policy_setting == 'Not Configured':\n        if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):\n            element_only_enabled_disabled = False\n            explicit_enable_disable_value_setting = True\n            if _checkValueItemParent(policy_element=admx_policy, policy_name=this_policy_name, policy_key=this_key, policy_valueName=this_value_name, xpath_object=DISABLED_VALUE_XPATH, policy_file_data=policy_file_data):\n                log.trace('%s is disabled by detected DISABLED_VALUE_XPATH', this_policy_name)\n                this_policy_setting = 'Disabled'\n                policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n    if ENABLED_LIST_XPATH(admx_policy):\n        if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(admx_policy):\n            element_only_enabled_disabled = False\n            explicit_enable_disable_value_setting = True\n            if _checkListItem(policy_element=admx_policy, policy_name=this_policy_name, policy_key=this_key, xpath_object=ENABLED_LIST_XPATH, policy_file_data=policy_file_data):\n                log.trace('%s is enabled by detected ENABLED_LIST_XPATH', this_policy_name)\n                this_policy_setting = 'Enabled'\n                policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n    if DISABLED_LIST_XPATH(admx_policy):\n        if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):\n            element_only_enabled_disabled = False\n            explicit_enable_disable_value_setting = True\n            if _checkListItem(policy_element=admx_policy, policy_name=this_policy_name, policy_key=this_key, xpath_object=DISABLED_LIST_XPATH, policy_file_data=policy_file_data):\n                log.trace('%s is disabled by detected DISABLED_LIST_XPATH', this_policy_name)\n                this_policy_setting = 'Disabled'\n                policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n    if not explicit_enable_disable_value_setting and this_value_name:\n        if search_reg_pol(re.escape(_buildKnownDataSearchString(reg_key=this_key, reg_valueName=this_value_name, reg_vtype='REG_DWORD', reg_data='1')), policy_file_data):\n            log.trace('%s is enabled by no explicit enable/disable list or value', this_policy_name)\n            this_policy_setting = 'Enabled'\n            policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n        elif search_reg_pol(re.escape(_buildKnownDataSearchString(reg_key=this_key, reg_valueName=this_value_name, reg_vtype='REG_DWORD', reg_data=None, check_deleted=True)), policy_file_data):\n            log.trace('%s is disabled by no explicit enable/disable list or value', this_policy_name)\n            this_policy_setting = 'Disabled'\n            policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n    full_names = {}\n    hierarchy = {}\n    if ELEMENTS_XPATH(admx_policy):\n        if element_only_enabled_disabled or this_policy_setting == 'Enabled':\n            required_elements = {}\n            configured_elements = {}\n            policy_disabled_elements = 0\n            for elements_item in ELEMENTS_XPATH(admx_policy):\n                for child_item in elements_item:\n                    this_element_name = _getFullPolicyName(policy_item=child_item, policy_name=child_item.attrib['id'], return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n                    required_elements[this_element_name] = None\n                    child_key = child_item.attrib.get('key', this_key)\n                    child_value_name = child_item.attrib.get('valueName', this_value_name)\n                    if etree.QName(child_item).localname == 'boolean':\n                        if len(child_item) > 0:\n                            if TRUE_VALUE_XPATH(child_item) and this_element_name not in configured_elements:\n                                if _checkValueItemParent(policy_element=child_item, policy_name=this_policy_name, policy_key=child_key, policy_valueName=child_value_name, xpath_object=TRUE_VALUE_XPATH, policy_file_data=policy_file_data):\n                                    configured_elements[this_element_name] = True\n                                    log.trace('element %s is configured true', child_item.attrib['id'])\n                            if FALSE_VALUE_XPATH(child_item) and this_element_name not in configured_elements:\n                                if _checkValueItemParent(policy_element=child_item, policy_name=this_policy_name, policy_key=child_key, policy_valueName=child_value_name, xpath_object=FALSE_VALUE_XPATH, policy_file_data=policy_file_data):\n                                    configured_elements[this_element_name] = False\n                                    policy_disabled_elements = policy_disabled_elements + 1\n                                    log.trace('element %s is configured false', child_item.attrib['id'])\n                            if TRUE_LIST_XPATH(child_item) and this_element_name not in configured_elements:\n                                log.trace('checking trueList')\n                                if _checkListItem(policy_element=child_item, policy_name=this_policy_name, policy_key=this_key, xpath_object=TRUE_LIST_XPATH, policy_file_data=policy_file_data):\n                                    configured_elements[this_element_name] = True\n                                    log.trace('element %s is configured true', child_item.attrib['id'])\n                            if FALSE_LIST_XPATH(child_item) and this_element_name not in configured_elements:\n                                log.trace('checking falseList')\n                                if _checkListItem(policy_element=child_item, policy_name=this_policy_name, policy_key=this_key, xpath_object=FALSE_LIST_XPATH, policy_file_data=policy_file_data):\n                                    configured_elements[this_element_name] = False\n                                    policy_disabled_elements = policy_disabled_elements + 1\n                                    log.trace('element %s is configured false', child_item.attrib['id'])\n                        elif search_reg_pol(re.escape(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=True)), policy_file_data):\n                            configured_elements[this_element_name] = False\n                            policy_disabled_elements = policy_disabled_elements + 1\n                            log.trace('element %s is configured false', child_item.attrib['id'])\n                        elif search_reg_pol(re.escape(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=False)), policy_file_data):\n                            configured_elements[this_element_name] = True\n                            log.trace('element %s is configured true', child_item.attrib['id'])\n                    elif etree.QName(child_item).localname in ['decimal', 'text', 'longDecimal', 'multiText']:\n                        if search_reg_pol(re.escape(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=True)), policy_file_data):\n                            configured_elements[this_element_name] = 'Disabled'\n                            policy_disabled_elements = policy_disabled_elements + 1\n                            log.trace('element %s is disabled', child_item.attrib['id'])\n                        elif search_reg_pol(re.escape(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=False)), policy_data=policy_file_data):\n                            configured_value = _getDataFromRegPolData(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=False), policy_data=policy_file_data)\n                            configured_elements[this_element_name] = configured_value\n                            log.trace('element %s is enabled, value == %s', child_item.attrib['id'], configured_value)\n                    elif etree.QName(child_item).localname == 'enum':\n                        if search_reg_pol(re.escape(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=True)), policy_file_data):\n                            log.trace('enum element %s is disabled', child_item.attrib['id'])\n                            configured_elements[this_element_name] = 'Disabled'\n                            policy_disabled_elements = policy_disabled_elements + 1\n                        else:\n                            for enum_item in child_item:\n                                if _checkValueItemParent(policy_element=enum_item, policy_name=child_item.attrib['id'], policy_key=child_key, policy_valueName=child_value_name, xpath_object=VALUE_XPATH, policy_file_data=policy_file_data):\n                                    if VALUE_LIST_XPATH(enum_item):\n                                        log.trace('enum item has a valueList')\n                                        if _checkListItem(policy_element=enum_item, policy_name=this_policy_name, policy_key=child_key, xpath_object=VALUE_LIST_XPATH, policy_file_data=policy_file_data):\n                                            log.trace('all valueList items exist in file')\n                                            configured_elements[this_element_name] = _getAdmlDisplayName(adml_xml_data=adml_policy_resources, display_name=enum_item.attrib['displayName'])\n                                            break\n                                    else:\n                                        configured_elements[this_element_name] = _getAdmlDisplayName(adml_xml_data=adml_policy_resources, display_name=enum_item.attrib['displayName'])\n                                        break\n                    elif etree.QName(child_item).localname == 'list':\n                        return_value_name = False\n                        if 'explicitValue' in child_item.attrib and child_item.attrib['explicitValue'].lower() == 'true':\n                            log.trace('explicitValue list, we will return value names')\n                            return_value_name = True\n                        regex_str = ['(?!\\\\*', '\\\\*', 'D', 'e', 'l', 'V', 'a', 'l', 's', '\\\\.', ')']\n                        delvals_regex = '\\x00'.join(regex_str)\n                        delvals_regex = salt.utils.stringutils.to_bytes(delvals_regex)\n                        if search_reg_pol(re.escape(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=False)) + delvals_regex, policy_data=policy_file_data):\n                            configured_value = _getDataFromRegPolData(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=False), policy_data=policy_file_data, return_value_name=return_value_name)\n                            configured_elements[this_element_name] = configured_value\n                            log.trace('element %s is enabled values: %s', child_item.attrib['id'], configured_value)\n                        elif search_reg_pol(re.escape(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=True)), policy_file_data):\n                            configured_elements[this_element_name] = 'Disabled'\n                            policy_disabled_elements = policy_disabled_elements + 1\n                            log.trace('element %s is disabled', child_item.attrib['id'])\n            if element_only_enabled_disabled:\n                if 0 < len(required_elements.keys()) == len(configured_elements.keys()):\n                    if policy_disabled_elements == len(required_elements.keys()):\n                        log.trace('%s is disabled by all enum elements', this_policy_name)\n                        policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = 'Disabled'\n                    else:\n                        log.trace('%s is enabled by enum elements', this_policy_name)\n                        policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = configured_elements\n                else:\n                    policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n            elif this_policy_setting == 'Enabled':\n                policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = configured_elements\n        else:\n            policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n    else:\n        policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n    if return_full_policy_names and this_policy_namespace in policy_vals and (this_policy_name in policy_vals[this_policy_namespace]):\n        full_names.setdefault(this_policy_namespace, {})\n        full_names[this_policy_namespace][this_policy_name] = _getFullPolicyName(policy_item=admx_policy, policy_name=admx_policy.attrib['name'], return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n        if this_policy_name in policy_vals[this_policy_namespace][this_policy_name]:\n            full_name = full_names[this_policy_namespace][this_policy_name]\n            setting = policy_vals[this_policy_namespace][this_policy_name].pop(this_policy_name)\n            policy_vals[this_policy_namespace][this_policy_name][full_name] = setting\n    if this_policy_namespace in policy_vals and this_policy_name in policy_vals[this_policy_namespace]:\n        hierarchy.setdefault(this_policy_namespace, {})[this_policy_name] = _build_parent_list(policy_definition=admx_policy, return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n    if policy_vals and return_full_policy_names and (not hierarchical_return):\n        log.debug('Compiling non hierarchical return...')\n        unpathed_dict = {}\n        pathed_dict = {}\n        for policy_namespace in list(policy_vals):\n            for policy_item in list(policy_vals[policy_namespace]):\n                full_name = full_names[policy_namespace][policy_item]\n                if full_name in policy_vals[policy_namespace]:\n                    full_path_list = hierarchy[policy_namespace][policy_item]\n                    full_path_list.reverse()\n                    full_path_list.append(full_names[policy_namespace][policy_item])\n                    policy_vals['\\\\'.join(full_path_list)] = policy_vals[policy_namespace].pop(policy_item)\n                    pathed_dict[full_name] = True\n                else:\n                    policy_vals[policy_namespace][full_name] = policy_vals[policy_namespace].pop(policy_item)\n                    unpathed_dict.setdefault(policy_namespace, {})[full_name] = policy_item\n            for path_needed in unpathed_dict.get(policy_namespace, {}):\n                full_path_list = hierarchy[policy_namespace][unpathed_dict[policy_namespace][path_needed]]\n                full_path_list.reverse()\n                full_path_list.append(path_needed)\n                log.trace('full_path_list == %s', full_path_list)\n                policy_vals['\\\\'.join(full_path_list)] = policy_vals[policy_namespace].pop(path_needed)\n    for policy_namespace in list(policy_vals):\n        if policy_vals[policy_namespace] == {}:\n            policy_vals.pop(policy_namespace)\n        elif isinstance(policy_vals[policy_namespace], dict):\n            if this_policy_namespace == policy_namespace and (not hierarchical_return):\n                policy_vals.update(policy_vals[policy_namespace])\n                policy_vals.pop(policy_namespace)\n    if policy_vals and hierarchical_return:\n        if hierarchy:\n            log.debug('Compiling hierarchical return...')\n            for policy_namespace in hierarchy:\n                for hierarchy_item in hierarchy[policy_namespace]:\n                    if hierarchy_item in policy_vals[policy_namespace]:\n                        t_dict = {}\n                        first_item = True\n                        for item in hierarchy[policy_namespace][hierarchy_item]:\n                            new_dict = {}\n                            if first_item:\n                                h_policy_name = hierarchy_item\n                                if return_full_policy_names:\n                                    h_policy_name = full_names[policy_namespace][hierarchy_item]\n                                new_dict[item] = {h_policy_name: policy_vals[policy_namespace].pop(hierarchy_item)}\n                                first_item = False\n                            else:\n                                new_dict[item] = t_dict\n                            t_dict = new_dict\n                        if t_dict:\n                            policy_vals = dictupdate.update(policy_vals, t_dict)\n                if policy_namespace in policy_vals and policy_vals[policy_namespace] == {}:\n                    policy_vals.pop(policy_namespace)\n        policy_vals = {CLASS_INFO[policy_class]['lgpo_section']: {'Administrative Templates': policy_vals}}\n    return policy_vals",
            "def _get_policy_adm_setting(admx_policy, policy_class, adml_language='en-US', return_full_policy_names=False, hierarchical_return=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Get the current setting for polices set via the policy templates (ADMX/ADML)\\n    files\\n\\n    Args:\\n        admx_policy (obj):\\n            The XPath object as returned by the ``_lookup_admin_template``\\n            function\\n\\n        policy_class (str):\\n            The policy class. Must be one of ``machine`` or ``user``\\n\\n        adml_language (str):\\n            The language code for the adml file to use for localization. The\\n            default is ``en-US``\\n\\n        return_full_policy_names (bool):\\n            Returns the full policy name regardless of what was passed in\\n            ``policy_name``\\n\\n        hierarchical_return (bool):\\n            Returns a hierarchical view of the policy showing its parents\\n\\n    Returns:\\n        dict: A dictionary containing the policy settings\\n\\n    Usage:\\n        policy_name = 'AutoUpdateCfg'\\n        policy_class = 'machine'\\n        adml_language = 'en-US'\\n        success, policy_obj, _, _ = _lookup_admin_template(\\n            policy_name=policy_name,\\n            policy_class=policy_class,\\n            adml_language=adml_language)\\n        if success:\\n            setting = _get_policy_adm_setting(\\n                admx_policy=policy_obj,\\n                policy_class=policy_class,\\n                adml_language=adml_language,\\n                return_full_policy_names=return_full_policy_names,\\n                hierarchical_return=hierarchical_return\\n            )\\n    \"\n    this_key = admx_policy.attrib.get('key', None)\n    this_policy_name = admx_policy.attrib.get('name', None)\n    if this_key is None or this_policy_name is None:\n        raise CommandExecutionError('Policy is missing the required \"key\" or \"name\" attribute:\\n{}'.format(admx_policy.attrib))\n    this_value_name = admx_policy.attrib.get('valueName', None)\n    this_policy_setting = 'Not Configured'\n    this_policy_namespace = admx_policy.nsmap[admx_policy.prefix]\n    element_only_enabled_disabled = True\n    explicit_enable_disable_value_setting = False\n    policy_file_data = read_reg_pol_file(CLASS_INFO[policy_class]['policy_path'])\n    adml_policy_resources = _get_policy_resources(language=adml_language)\n    policy_vals = {}\n    if ENABLED_VALUE_XPATH(admx_policy) and this_policy_setting == 'Not Configured':\n        if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(admx_policy):\n            element_only_enabled_disabled = False\n            explicit_enable_disable_value_setting = True\n            if _checkValueItemParent(policy_element=admx_policy, policy_name=this_policy_name, policy_key=this_key, policy_valueName=this_value_name, xpath_object=ENABLED_VALUE_XPATH, policy_file_data=policy_file_data):\n                log.trace('%s is enabled by detected ENABLED_VALUE_XPATH', this_policy_name)\n                this_policy_setting = 'Enabled'\n                policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n    if DISABLED_VALUE_XPATH(admx_policy) and this_policy_setting == 'Not Configured':\n        if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):\n            element_only_enabled_disabled = False\n            explicit_enable_disable_value_setting = True\n            if _checkValueItemParent(policy_element=admx_policy, policy_name=this_policy_name, policy_key=this_key, policy_valueName=this_value_name, xpath_object=DISABLED_VALUE_XPATH, policy_file_data=policy_file_data):\n                log.trace('%s is disabled by detected DISABLED_VALUE_XPATH', this_policy_name)\n                this_policy_setting = 'Disabled'\n                policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n    if ENABLED_LIST_XPATH(admx_policy):\n        if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(admx_policy):\n            element_only_enabled_disabled = False\n            explicit_enable_disable_value_setting = True\n            if _checkListItem(policy_element=admx_policy, policy_name=this_policy_name, policy_key=this_key, xpath_object=ENABLED_LIST_XPATH, policy_file_data=policy_file_data):\n                log.trace('%s is enabled by detected ENABLED_LIST_XPATH', this_policy_name)\n                this_policy_setting = 'Enabled'\n                policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n    if DISABLED_LIST_XPATH(admx_policy):\n        if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):\n            element_only_enabled_disabled = False\n            explicit_enable_disable_value_setting = True\n            if _checkListItem(policy_element=admx_policy, policy_name=this_policy_name, policy_key=this_key, xpath_object=DISABLED_LIST_XPATH, policy_file_data=policy_file_data):\n                log.trace('%s is disabled by detected DISABLED_LIST_XPATH', this_policy_name)\n                this_policy_setting = 'Disabled'\n                policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n    if not explicit_enable_disable_value_setting and this_value_name:\n        if search_reg_pol(re.escape(_buildKnownDataSearchString(reg_key=this_key, reg_valueName=this_value_name, reg_vtype='REG_DWORD', reg_data='1')), policy_file_data):\n            log.trace('%s is enabled by no explicit enable/disable list or value', this_policy_name)\n            this_policy_setting = 'Enabled'\n            policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n        elif search_reg_pol(re.escape(_buildKnownDataSearchString(reg_key=this_key, reg_valueName=this_value_name, reg_vtype='REG_DWORD', reg_data=None, check_deleted=True)), policy_file_data):\n            log.trace('%s is disabled by no explicit enable/disable list or value', this_policy_name)\n            this_policy_setting = 'Disabled'\n            policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n    full_names = {}\n    hierarchy = {}\n    if ELEMENTS_XPATH(admx_policy):\n        if element_only_enabled_disabled or this_policy_setting == 'Enabled':\n            required_elements = {}\n            configured_elements = {}\n            policy_disabled_elements = 0\n            for elements_item in ELEMENTS_XPATH(admx_policy):\n                for child_item in elements_item:\n                    this_element_name = _getFullPolicyName(policy_item=child_item, policy_name=child_item.attrib['id'], return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n                    required_elements[this_element_name] = None\n                    child_key = child_item.attrib.get('key', this_key)\n                    child_value_name = child_item.attrib.get('valueName', this_value_name)\n                    if etree.QName(child_item).localname == 'boolean':\n                        if len(child_item) > 0:\n                            if TRUE_VALUE_XPATH(child_item) and this_element_name not in configured_elements:\n                                if _checkValueItemParent(policy_element=child_item, policy_name=this_policy_name, policy_key=child_key, policy_valueName=child_value_name, xpath_object=TRUE_VALUE_XPATH, policy_file_data=policy_file_data):\n                                    configured_elements[this_element_name] = True\n                                    log.trace('element %s is configured true', child_item.attrib['id'])\n                            if FALSE_VALUE_XPATH(child_item) and this_element_name not in configured_elements:\n                                if _checkValueItemParent(policy_element=child_item, policy_name=this_policy_name, policy_key=child_key, policy_valueName=child_value_name, xpath_object=FALSE_VALUE_XPATH, policy_file_data=policy_file_data):\n                                    configured_elements[this_element_name] = False\n                                    policy_disabled_elements = policy_disabled_elements + 1\n                                    log.trace('element %s is configured false', child_item.attrib['id'])\n                            if TRUE_LIST_XPATH(child_item) and this_element_name not in configured_elements:\n                                log.trace('checking trueList')\n                                if _checkListItem(policy_element=child_item, policy_name=this_policy_name, policy_key=this_key, xpath_object=TRUE_LIST_XPATH, policy_file_data=policy_file_data):\n                                    configured_elements[this_element_name] = True\n                                    log.trace('element %s is configured true', child_item.attrib['id'])\n                            if FALSE_LIST_XPATH(child_item) and this_element_name not in configured_elements:\n                                log.trace('checking falseList')\n                                if _checkListItem(policy_element=child_item, policy_name=this_policy_name, policy_key=this_key, xpath_object=FALSE_LIST_XPATH, policy_file_data=policy_file_data):\n                                    configured_elements[this_element_name] = False\n                                    policy_disabled_elements = policy_disabled_elements + 1\n                                    log.trace('element %s is configured false', child_item.attrib['id'])\n                        elif search_reg_pol(re.escape(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=True)), policy_file_data):\n                            configured_elements[this_element_name] = False\n                            policy_disabled_elements = policy_disabled_elements + 1\n                            log.trace('element %s is configured false', child_item.attrib['id'])\n                        elif search_reg_pol(re.escape(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=False)), policy_file_data):\n                            configured_elements[this_element_name] = True\n                            log.trace('element %s is configured true', child_item.attrib['id'])\n                    elif etree.QName(child_item).localname in ['decimal', 'text', 'longDecimal', 'multiText']:\n                        if search_reg_pol(re.escape(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=True)), policy_file_data):\n                            configured_elements[this_element_name] = 'Disabled'\n                            policy_disabled_elements = policy_disabled_elements + 1\n                            log.trace('element %s is disabled', child_item.attrib['id'])\n                        elif search_reg_pol(re.escape(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=False)), policy_data=policy_file_data):\n                            configured_value = _getDataFromRegPolData(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=False), policy_data=policy_file_data)\n                            configured_elements[this_element_name] = configured_value\n                            log.trace('element %s is enabled, value == %s', child_item.attrib['id'], configured_value)\n                    elif etree.QName(child_item).localname == 'enum':\n                        if search_reg_pol(re.escape(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=True)), policy_file_data):\n                            log.trace('enum element %s is disabled', child_item.attrib['id'])\n                            configured_elements[this_element_name] = 'Disabled'\n                            policy_disabled_elements = policy_disabled_elements + 1\n                        else:\n                            for enum_item in child_item:\n                                if _checkValueItemParent(policy_element=enum_item, policy_name=child_item.attrib['id'], policy_key=child_key, policy_valueName=child_value_name, xpath_object=VALUE_XPATH, policy_file_data=policy_file_data):\n                                    if VALUE_LIST_XPATH(enum_item):\n                                        log.trace('enum item has a valueList')\n                                        if _checkListItem(policy_element=enum_item, policy_name=this_policy_name, policy_key=child_key, xpath_object=VALUE_LIST_XPATH, policy_file_data=policy_file_data):\n                                            log.trace('all valueList items exist in file')\n                                            configured_elements[this_element_name] = _getAdmlDisplayName(adml_xml_data=adml_policy_resources, display_name=enum_item.attrib['displayName'])\n                                            break\n                                    else:\n                                        configured_elements[this_element_name] = _getAdmlDisplayName(adml_xml_data=adml_policy_resources, display_name=enum_item.attrib['displayName'])\n                                        break\n                    elif etree.QName(child_item).localname == 'list':\n                        return_value_name = False\n                        if 'explicitValue' in child_item.attrib and child_item.attrib['explicitValue'].lower() == 'true':\n                            log.trace('explicitValue list, we will return value names')\n                            return_value_name = True\n                        regex_str = ['(?!\\\\*', '\\\\*', 'D', 'e', 'l', 'V', 'a', 'l', 's', '\\\\.', ')']\n                        delvals_regex = '\\x00'.join(regex_str)\n                        delvals_regex = salt.utils.stringutils.to_bytes(delvals_regex)\n                        if search_reg_pol(re.escape(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=False)) + delvals_regex, policy_data=policy_file_data):\n                            configured_value = _getDataFromRegPolData(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=False), policy_data=policy_file_data, return_value_name=return_value_name)\n                            configured_elements[this_element_name] = configured_value\n                            log.trace('element %s is enabled values: %s', child_item.attrib['id'], configured_value)\n                        elif search_reg_pol(re.escape(_processValueItem(element=child_item, reg_key=child_key, reg_valuename=child_value_name, policy=admx_policy, parent_element=elements_item, check_deleted=True)), policy_file_data):\n                            configured_elements[this_element_name] = 'Disabled'\n                            policy_disabled_elements = policy_disabled_elements + 1\n                            log.trace('element %s is disabled', child_item.attrib['id'])\n            if element_only_enabled_disabled:\n                if 0 < len(required_elements.keys()) == len(configured_elements.keys()):\n                    if policy_disabled_elements == len(required_elements.keys()):\n                        log.trace('%s is disabled by all enum elements', this_policy_name)\n                        policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = 'Disabled'\n                    else:\n                        log.trace('%s is enabled by enum elements', this_policy_name)\n                        policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = configured_elements\n                else:\n                    policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n            elif this_policy_setting == 'Enabled':\n                policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = configured_elements\n        else:\n            policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n    else:\n        policy_vals.setdefault(this_policy_namespace, {})[this_policy_name] = this_policy_setting\n    if return_full_policy_names and this_policy_namespace in policy_vals and (this_policy_name in policy_vals[this_policy_namespace]):\n        full_names.setdefault(this_policy_namespace, {})\n        full_names[this_policy_namespace][this_policy_name] = _getFullPolicyName(policy_item=admx_policy, policy_name=admx_policy.attrib['name'], return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n        if this_policy_name in policy_vals[this_policy_namespace][this_policy_name]:\n            full_name = full_names[this_policy_namespace][this_policy_name]\n            setting = policy_vals[this_policy_namespace][this_policy_name].pop(this_policy_name)\n            policy_vals[this_policy_namespace][this_policy_name][full_name] = setting\n    if this_policy_namespace in policy_vals and this_policy_name in policy_vals[this_policy_namespace]:\n        hierarchy.setdefault(this_policy_namespace, {})[this_policy_name] = _build_parent_list(policy_definition=admx_policy, return_full_policy_names=return_full_policy_names, adml_language=adml_language)\n    if policy_vals and return_full_policy_names and (not hierarchical_return):\n        log.debug('Compiling non hierarchical return...')\n        unpathed_dict = {}\n        pathed_dict = {}\n        for policy_namespace in list(policy_vals):\n            for policy_item in list(policy_vals[policy_namespace]):\n                full_name = full_names[policy_namespace][policy_item]\n                if full_name in policy_vals[policy_namespace]:\n                    full_path_list = hierarchy[policy_namespace][policy_item]\n                    full_path_list.reverse()\n                    full_path_list.append(full_names[policy_namespace][policy_item])\n                    policy_vals['\\\\'.join(full_path_list)] = policy_vals[policy_namespace].pop(policy_item)\n                    pathed_dict[full_name] = True\n                else:\n                    policy_vals[policy_namespace][full_name] = policy_vals[policy_namespace].pop(policy_item)\n                    unpathed_dict.setdefault(policy_namespace, {})[full_name] = policy_item\n            for path_needed in unpathed_dict.get(policy_namespace, {}):\n                full_path_list = hierarchy[policy_namespace][unpathed_dict[policy_namespace][path_needed]]\n                full_path_list.reverse()\n                full_path_list.append(path_needed)\n                log.trace('full_path_list == %s', full_path_list)\n                policy_vals['\\\\'.join(full_path_list)] = policy_vals[policy_namespace].pop(path_needed)\n    for policy_namespace in list(policy_vals):\n        if policy_vals[policy_namespace] == {}:\n            policy_vals.pop(policy_namespace)\n        elif isinstance(policy_vals[policy_namespace], dict):\n            if this_policy_namespace == policy_namespace and (not hierarchical_return):\n                policy_vals.update(policy_vals[policy_namespace])\n                policy_vals.pop(policy_namespace)\n    if policy_vals and hierarchical_return:\n        if hierarchy:\n            log.debug('Compiling hierarchical return...')\n            for policy_namespace in hierarchy:\n                for hierarchy_item in hierarchy[policy_namespace]:\n                    if hierarchy_item in policy_vals[policy_namespace]:\n                        t_dict = {}\n                        first_item = True\n                        for item in hierarchy[policy_namespace][hierarchy_item]:\n                            new_dict = {}\n                            if first_item:\n                                h_policy_name = hierarchy_item\n                                if return_full_policy_names:\n                                    h_policy_name = full_names[policy_namespace][hierarchy_item]\n                                new_dict[item] = {h_policy_name: policy_vals[policy_namespace].pop(hierarchy_item)}\n                                first_item = False\n                            else:\n                                new_dict[item] = t_dict\n                            t_dict = new_dict\n                        if t_dict:\n                            policy_vals = dictupdate.update(policy_vals, t_dict)\n                if policy_namespace in policy_vals and policy_vals[policy_namespace] == {}:\n                    policy_vals.pop(policy_namespace)\n        policy_vals = {CLASS_INFO[policy_class]['lgpo_section']: {'Administrative Templates': policy_vals}}\n    return policy_vals"
        ]
    },
    {
        "func_name": "get_policy",
        "original": "def get_policy(policy_name, policy_class, adml_language='en-US', return_value_only=True, return_full_policy_names=True, hierarchical_return=False):\n    \"\"\"\n    Get the current settings for a single policy on the machine\n\n    Args:\n        policy_name (str):\n            The name of the policy to retrieve. Can be the any of the names\n            or alieses returned by ``lgpo.get_policy_info``\n\n        policy_class (str):\n            The policy class. Must be one of ``machine`` or ``user``\n\n        adml_language (str):\n            The language code for the adml file to use for localization. The\n            default is ``en-US``\n\n        return_value_only (bool):\n            ``True`` will return only the value for the policy, without the\n            name of the policy. ``return_full_policy_names`` and\n            ``hierarchical_return`` will be ignored. Default is ``True``\n\n        return_full_policy_names (bool):\n            Returns the full policy name regardless of what was passed in\n            ``policy_name``\n\n            .. note::\n                This setting applies to sub-elements of the policy if they\n                exist. The value passed in ``policy_name`` will always be used\n                as the policy name when this setting is ``False``\n\n        hierarchical_return (bool):\n            Returns a hierarchical view of the policy showing its parents\n\n    Returns:\n        dict: A dictionary containing the policy settings\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        # Using the policy id\n        salt * lgpo.get_policy LockoutDuration machine\n        salt * lgpo.get_policy AutoUpdateCfg machine\n\n        # Using the full name\n        salt * lgpo.get_policy \"Account lockout duration\" machine\n        salt * lgpo.get_policy \"Configure Automatic Updates\" machine\n\n        # Using full path and name\n        salt * lgpo.get_policy \"Windows Components\\\\Windows Update\\\\Configure Automatic Updates\" machine\n    \"\"\"\n    if not policy_name:\n        raise SaltInvocationError('policy_name must be defined')\n    if not policy_class:\n        raise SaltInvocationError('policy_class must be defined')\n    policy_class = policy_class.title()\n    policy_data = _policy_info()\n    if policy_class not in policy_data.policies.keys():\n        policy_classes = ', '.join(policy_data.policies.keys())\n        raise CommandExecutionError('The requested policy class \"{}\" is invalid, policy_class should be one of: {}'.format(policy_class, policy_classes))\n    policy_definition = None\n    if policy_name in policy_data.policies[policy_class]['policies']:\n        policy_definition = policy_data.policies[policy_class]['policies'][policy_name]\n    else:\n        for pol in policy_data.policies[policy_class]['policies']:\n            _p = policy_data.policies[policy_class]['policies'][pol]['Policy']\n            if _p == policy_name:\n                policy_definition = policy_data.policies[policy_class]['policies'][pol]\n                break\n        if policy_definition is None:\n            for pol in policy_data.policies[policy_class]['policies']:\n                _p = policy_data.policies[policy_class]['policies'][pol]['Policy']\n                if _p.lower() == policy_name.lower():\n                    policy_definition = policy_data.policies[policy_class]['policies'][pol]\n                    break\n    if policy_definition:\n        if return_value_only:\n            return _get_policy_info_setting(policy_definition)\n        if return_full_policy_names:\n            key_name = policy_definition['Policy']\n        else:\n            key_name = policy_name\n        setting = {key_name: _get_policy_info_setting(policy_definition)}\n        if hierarchical_return:\n            if 'lgpo_section' in policy_definition:\n                first_item = True\n                t_dict = {}\n                for level in reversed(policy_definition['lgpo_section']):\n                    new_dict = {}\n                    if first_item:\n                        new_dict[level] = {key_name: setting.pop(key_name)}\n                        first_item = False\n                    else:\n                        new_dict[level] = t_dict\n                    t_dict = new_dict\n                if t_dict:\n                    setting = t_dict\n        return setting\n    (success, policy_obj, _, _) = _lookup_admin_template(policy_name=policy_name, policy_class=policy_class, adml_language=adml_language)\n    if success:\n        setting = _get_policy_adm_setting(admx_policy=policy_obj, policy_class=policy_class, adml_language=adml_language, return_full_policy_names=return_full_policy_names, hierarchical_return=hierarchical_return)\n        if return_value_only:\n            for key in setting:\n                return setting[key]\n        return setting",
        "mutated": [
            "def get_policy(policy_name, policy_class, adml_language='en-US', return_value_only=True, return_full_policy_names=True, hierarchical_return=False):\n    if False:\n        i = 10\n    '\\n    Get the current settings for a single policy on the machine\\n\\n    Args:\\n        policy_name (str):\\n            The name of the policy to retrieve. Can be the any of the names\\n            or alieses returned by ``lgpo.get_policy_info``\\n\\n        policy_class (str):\\n            The policy class. Must be one of ``machine`` or ``user``\\n\\n        adml_language (str):\\n            The language code for the adml file to use for localization. The\\n            default is ``en-US``\\n\\n        return_value_only (bool):\\n            ``True`` will return only the value for the policy, without the\\n            name of the policy. ``return_full_policy_names`` and\\n            ``hierarchical_return`` will be ignored. Default is ``True``\\n\\n        return_full_policy_names (bool):\\n            Returns the full policy name regardless of what was passed in\\n            ``policy_name``\\n\\n            .. note::\\n                This setting applies to sub-elements of the policy if they\\n                exist. The value passed in ``policy_name`` will always be used\\n                as the policy name when this setting is ``False``\\n\\n        hierarchical_return (bool):\\n            Returns a hierarchical view of the policy showing its parents\\n\\n    Returns:\\n        dict: A dictionary containing the policy settings\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Using the policy id\\n        salt * lgpo.get_policy LockoutDuration machine\\n        salt * lgpo.get_policy AutoUpdateCfg machine\\n\\n        # Using the full name\\n        salt * lgpo.get_policy \"Account lockout duration\" machine\\n        salt * lgpo.get_policy \"Configure Automatic Updates\" machine\\n\\n        # Using full path and name\\n        salt * lgpo.get_policy \"Windows Components\\\\Windows Update\\\\Configure Automatic Updates\" machine\\n    '\n    if not policy_name:\n        raise SaltInvocationError('policy_name must be defined')\n    if not policy_class:\n        raise SaltInvocationError('policy_class must be defined')\n    policy_class = policy_class.title()\n    policy_data = _policy_info()\n    if policy_class not in policy_data.policies.keys():\n        policy_classes = ', '.join(policy_data.policies.keys())\n        raise CommandExecutionError('The requested policy class \"{}\" is invalid, policy_class should be one of: {}'.format(policy_class, policy_classes))\n    policy_definition = None\n    if policy_name in policy_data.policies[policy_class]['policies']:\n        policy_definition = policy_data.policies[policy_class]['policies'][policy_name]\n    else:\n        for pol in policy_data.policies[policy_class]['policies']:\n            _p = policy_data.policies[policy_class]['policies'][pol]['Policy']\n            if _p == policy_name:\n                policy_definition = policy_data.policies[policy_class]['policies'][pol]\n                break\n        if policy_definition is None:\n            for pol in policy_data.policies[policy_class]['policies']:\n                _p = policy_data.policies[policy_class]['policies'][pol]['Policy']\n                if _p.lower() == policy_name.lower():\n                    policy_definition = policy_data.policies[policy_class]['policies'][pol]\n                    break\n    if policy_definition:\n        if return_value_only:\n            return _get_policy_info_setting(policy_definition)\n        if return_full_policy_names:\n            key_name = policy_definition['Policy']\n        else:\n            key_name = policy_name\n        setting = {key_name: _get_policy_info_setting(policy_definition)}\n        if hierarchical_return:\n            if 'lgpo_section' in policy_definition:\n                first_item = True\n                t_dict = {}\n                for level in reversed(policy_definition['lgpo_section']):\n                    new_dict = {}\n                    if first_item:\n                        new_dict[level] = {key_name: setting.pop(key_name)}\n                        first_item = False\n                    else:\n                        new_dict[level] = t_dict\n                    t_dict = new_dict\n                if t_dict:\n                    setting = t_dict\n        return setting\n    (success, policy_obj, _, _) = _lookup_admin_template(policy_name=policy_name, policy_class=policy_class, adml_language=adml_language)\n    if success:\n        setting = _get_policy_adm_setting(admx_policy=policy_obj, policy_class=policy_class, adml_language=adml_language, return_full_policy_names=return_full_policy_names, hierarchical_return=hierarchical_return)\n        if return_value_only:\n            for key in setting:\n                return setting[key]\n        return setting",
            "def get_policy(policy_name, policy_class, adml_language='en-US', return_value_only=True, return_full_policy_names=True, hierarchical_return=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Get the current settings for a single policy on the machine\\n\\n    Args:\\n        policy_name (str):\\n            The name of the policy to retrieve. Can be the any of the names\\n            or alieses returned by ``lgpo.get_policy_info``\\n\\n        policy_class (str):\\n            The policy class. Must be one of ``machine`` or ``user``\\n\\n        adml_language (str):\\n            The language code for the adml file to use for localization. The\\n            default is ``en-US``\\n\\n        return_value_only (bool):\\n            ``True`` will return only the value for the policy, without the\\n            name of the policy. ``return_full_policy_names`` and\\n            ``hierarchical_return`` will be ignored. Default is ``True``\\n\\n        return_full_policy_names (bool):\\n            Returns the full policy name regardless of what was passed in\\n            ``policy_name``\\n\\n            .. note::\\n                This setting applies to sub-elements of the policy if they\\n                exist. The value passed in ``policy_name`` will always be used\\n                as the policy name when this setting is ``False``\\n\\n        hierarchical_return (bool):\\n            Returns a hierarchical view of the policy showing its parents\\n\\n    Returns:\\n        dict: A dictionary containing the policy settings\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Using the policy id\\n        salt * lgpo.get_policy LockoutDuration machine\\n        salt * lgpo.get_policy AutoUpdateCfg machine\\n\\n        # Using the full name\\n        salt * lgpo.get_policy \"Account lockout duration\" machine\\n        salt * lgpo.get_policy \"Configure Automatic Updates\" machine\\n\\n        # Using full path and name\\n        salt * lgpo.get_policy \"Windows Components\\\\Windows Update\\\\Configure Automatic Updates\" machine\\n    '\n    if not policy_name:\n        raise SaltInvocationError('policy_name must be defined')\n    if not policy_class:\n        raise SaltInvocationError('policy_class must be defined')\n    policy_class = policy_class.title()\n    policy_data = _policy_info()\n    if policy_class not in policy_data.policies.keys():\n        policy_classes = ', '.join(policy_data.policies.keys())\n        raise CommandExecutionError('The requested policy class \"{}\" is invalid, policy_class should be one of: {}'.format(policy_class, policy_classes))\n    policy_definition = None\n    if policy_name in policy_data.policies[policy_class]['policies']:\n        policy_definition = policy_data.policies[policy_class]['policies'][policy_name]\n    else:\n        for pol in policy_data.policies[policy_class]['policies']:\n            _p = policy_data.policies[policy_class]['policies'][pol]['Policy']\n            if _p == policy_name:\n                policy_definition = policy_data.policies[policy_class]['policies'][pol]\n                break\n        if policy_definition is None:\n            for pol in policy_data.policies[policy_class]['policies']:\n                _p = policy_data.policies[policy_class]['policies'][pol]['Policy']\n                if _p.lower() == policy_name.lower():\n                    policy_definition = policy_data.policies[policy_class]['policies'][pol]\n                    break\n    if policy_definition:\n        if return_value_only:\n            return _get_policy_info_setting(policy_definition)\n        if return_full_policy_names:\n            key_name = policy_definition['Policy']\n        else:\n            key_name = policy_name\n        setting = {key_name: _get_policy_info_setting(policy_definition)}\n        if hierarchical_return:\n            if 'lgpo_section' in policy_definition:\n                first_item = True\n                t_dict = {}\n                for level in reversed(policy_definition['lgpo_section']):\n                    new_dict = {}\n                    if first_item:\n                        new_dict[level] = {key_name: setting.pop(key_name)}\n                        first_item = False\n                    else:\n                        new_dict[level] = t_dict\n                    t_dict = new_dict\n                if t_dict:\n                    setting = t_dict\n        return setting\n    (success, policy_obj, _, _) = _lookup_admin_template(policy_name=policy_name, policy_class=policy_class, adml_language=adml_language)\n    if success:\n        setting = _get_policy_adm_setting(admx_policy=policy_obj, policy_class=policy_class, adml_language=adml_language, return_full_policy_names=return_full_policy_names, hierarchical_return=hierarchical_return)\n        if return_value_only:\n            for key in setting:\n                return setting[key]\n        return setting",
            "def get_policy(policy_name, policy_class, adml_language='en-US', return_value_only=True, return_full_policy_names=True, hierarchical_return=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Get the current settings for a single policy on the machine\\n\\n    Args:\\n        policy_name (str):\\n            The name of the policy to retrieve. Can be the any of the names\\n            or alieses returned by ``lgpo.get_policy_info``\\n\\n        policy_class (str):\\n            The policy class. Must be one of ``machine`` or ``user``\\n\\n        adml_language (str):\\n            The language code for the adml file to use for localization. The\\n            default is ``en-US``\\n\\n        return_value_only (bool):\\n            ``True`` will return only the value for the policy, without the\\n            name of the policy. ``return_full_policy_names`` and\\n            ``hierarchical_return`` will be ignored. Default is ``True``\\n\\n        return_full_policy_names (bool):\\n            Returns the full policy name regardless of what was passed in\\n            ``policy_name``\\n\\n            .. note::\\n                This setting applies to sub-elements of the policy if they\\n                exist. The value passed in ``policy_name`` will always be used\\n                as the policy name when this setting is ``False``\\n\\n        hierarchical_return (bool):\\n            Returns a hierarchical view of the policy showing its parents\\n\\n    Returns:\\n        dict: A dictionary containing the policy settings\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Using the policy id\\n        salt * lgpo.get_policy LockoutDuration machine\\n        salt * lgpo.get_policy AutoUpdateCfg machine\\n\\n        # Using the full name\\n        salt * lgpo.get_policy \"Account lockout duration\" machine\\n        salt * lgpo.get_policy \"Configure Automatic Updates\" machine\\n\\n        # Using full path and name\\n        salt * lgpo.get_policy \"Windows Components\\\\Windows Update\\\\Configure Automatic Updates\" machine\\n    '\n    if not policy_name:\n        raise SaltInvocationError('policy_name must be defined')\n    if not policy_class:\n        raise SaltInvocationError('policy_class must be defined')\n    policy_class = policy_class.title()\n    policy_data = _policy_info()\n    if policy_class not in policy_data.policies.keys():\n        policy_classes = ', '.join(policy_data.policies.keys())\n        raise CommandExecutionError('The requested policy class \"{}\" is invalid, policy_class should be one of: {}'.format(policy_class, policy_classes))\n    policy_definition = None\n    if policy_name in policy_data.policies[policy_class]['policies']:\n        policy_definition = policy_data.policies[policy_class]['policies'][policy_name]\n    else:\n        for pol in policy_data.policies[policy_class]['policies']:\n            _p = policy_data.policies[policy_class]['policies'][pol]['Policy']\n            if _p == policy_name:\n                policy_definition = policy_data.policies[policy_class]['policies'][pol]\n                break\n        if policy_definition is None:\n            for pol in policy_data.policies[policy_class]['policies']:\n                _p = policy_data.policies[policy_class]['policies'][pol]['Policy']\n                if _p.lower() == policy_name.lower():\n                    policy_definition = policy_data.policies[policy_class]['policies'][pol]\n                    break\n    if policy_definition:\n        if return_value_only:\n            return _get_policy_info_setting(policy_definition)\n        if return_full_policy_names:\n            key_name = policy_definition['Policy']\n        else:\n            key_name = policy_name\n        setting = {key_name: _get_policy_info_setting(policy_definition)}\n        if hierarchical_return:\n            if 'lgpo_section' in policy_definition:\n                first_item = True\n                t_dict = {}\n                for level in reversed(policy_definition['lgpo_section']):\n                    new_dict = {}\n                    if first_item:\n                        new_dict[level] = {key_name: setting.pop(key_name)}\n                        first_item = False\n                    else:\n                        new_dict[level] = t_dict\n                    t_dict = new_dict\n                if t_dict:\n                    setting = t_dict\n        return setting\n    (success, policy_obj, _, _) = _lookup_admin_template(policy_name=policy_name, policy_class=policy_class, adml_language=adml_language)\n    if success:\n        setting = _get_policy_adm_setting(admx_policy=policy_obj, policy_class=policy_class, adml_language=adml_language, return_full_policy_names=return_full_policy_names, hierarchical_return=hierarchical_return)\n        if return_value_only:\n            for key in setting:\n                return setting[key]\n        return setting",
            "def get_policy(policy_name, policy_class, adml_language='en-US', return_value_only=True, return_full_policy_names=True, hierarchical_return=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Get the current settings for a single policy on the machine\\n\\n    Args:\\n        policy_name (str):\\n            The name of the policy to retrieve. Can be the any of the names\\n            or alieses returned by ``lgpo.get_policy_info``\\n\\n        policy_class (str):\\n            The policy class. Must be one of ``machine`` or ``user``\\n\\n        adml_language (str):\\n            The language code for the adml file to use for localization. The\\n            default is ``en-US``\\n\\n        return_value_only (bool):\\n            ``True`` will return only the value for the policy, without the\\n            name of the policy. ``return_full_policy_names`` and\\n            ``hierarchical_return`` will be ignored. Default is ``True``\\n\\n        return_full_policy_names (bool):\\n            Returns the full policy name regardless of what was passed in\\n            ``policy_name``\\n\\n            .. note::\\n                This setting applies to sub-elements of the policy if they\\n                exist. The value passed in ``policy_name`` will always be used\\n                as the policy name when this setting is ``False``\\n\\n        hierarchical_return (bool):\\n            Returns a hierarchical view of the policy showing its parents\\n\\n    Returns:\\n        dict: A dictionary containing the policy settings\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Using the policy id\\n        salt * lgpo.get_policy LockoutDuration machine\\n        salt * lgpo.get_policy AutoUpdateCfg machine\\n\\n        # Using the full name\\n        salt * lgpo.get_policy \"Account lockout duration\" machine\\n        salt * lgpo.get_policy \"Configure Automatic Updates\" machine\\n\\n        # Using full path and name\\n        salt * lgpo.get_policy \"Windows Components\\\\Windows Update\\\\Configure Automatic Updates\" machine\\n    '\n    if not policy_name:\n        raise SaltInvocationError('policy_name must be defined')\n    if not policy_class:\n        raise SaltInvocationError('policy_class must be defined')\n    policy_class = policy_class.title()\n    policy_data = _policy_info()\n    if policy_class not in policy_data.policies.keys():\n        policy_classes = ', '.join(policy_data.policies.keys())\n        raise CommandExecutionError('The requested policy class \"{}\" is invalid, policy_class should be one of: {}'.format(policy_class, policy_classes))\n    policy_definition = None\n    if policy_name in policy_data.policies[policy_class]['policies']:\n        policy_definition = policy_data.policies[policy_class]['policies'][policy_name]\n    else:\n        for pol in policy_data.policies[policy_class]['policies']:\n            _p = policy_data.policies[policy_class]['policies'][pol]['Policy']\n            if _p == policy_name:\n                policy_definition = policy_data.policies[policy_class]['policies'][pol]\n                break\n        if policy_definition is None:\n            for pol in policy_data.policies[policy_class]['policies']:\n                _p = policy_data.policies[policy_class]['policies'][pol]['Policy']\n                if _p.lower() == policy_name.lower():\n                    policy_definition = policy_data.policies[policy_class]['policies'][pol]\n                    break\n    if policy_definition:\n        if return_value_only:\n            return _get_policy_info_setting(policy_definition)\n        if return_full_policy_names:\n            key_name = policy_definition['Policy']\n        else:\n            key_name = policy_name\n        setting = {key_name: _get_policy_info_setting(policy_definition)}\n        if hierarchical_return:\n            if 'lgpo_section' in policy_definition:\n                first_item = True\n                t_dict = {}\n                for level in reversed(policy_definition['lgpo_section']):\n                    new_dict = {}\n                    if first_item:\n                        new_dict[level] = {key_name: setting.pop(key_name)}\n                        first_item = False\n                    else:\n                        new_dict[level] = t_dict\n                    t_dict = new_dict\n                if t_dict:\n                    setting = t_dict\n        return setting\n    (success, policy_obj, _, _) = _lookup_admin_template(policy_name=policy_name, policy_class=policy_class, adml_language=adml_language)\n    if success:\n        setting = _get_policy_adm_setting(admx_policy=policy_obj, policy_class=policy_class, adml_language=adml_language, return_full_policy_names=return_full_policy_names, hierarchical_return=hierarchical_return)\n        if return_value_only:\n            for key in setting:\n                return setting[key]\n        return setting",
            "def get_policy(policy_name, policy_class, adml_language='en-US', return_value_only=True, return_full_policy_names=True, hierarchical_return=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Get the current settings for a single policy on the machine\\n\\n    Args:\\n        policy_name (str):\\n            The name of the policy to retrieve. Can be the any of the names\\n            or alieses returned by ``lgpo.get_policy_info``\\n\\n        policy_class (str):\\n            The policy class. Must be one of ``machine`` or ``user``\\n\\n        adml_language (str):\\n            The language code for the adml file to use for localization. The\\n            default is ``en-US``\\n\\n        return_value_only (bool):\\n            ``True`` will return only the value for the policy, without the\\n            name of the policy. ``return_full_policy_names`` and\\n            ``hierarchical_return`` will be ignored. Default is ``True``\\n\\n        return_full_policy_names (bool):\\n            Returns the full policy name regardless of what was passed in\\n            ``policy_name``\\n\\n            .. note::\\n                This setting applies to sub-elements of the policy if they\\n                exist. The value passed in ``policy_name`` will always be used\\n                as the policy name when this setting is ``False``\\n\\n        hierarchical_return (bool):\\n            Returns a hierarchical view of the policy showing its parents\\n\\n    Returns:\\n        dict: A dictionary containing the policy settings\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Using the policy id\\n        salt * lgpo.get_policy LockoutDuration machine\\n        salt * lgpo.get_policy AutoUpdateCfg machine\\n\\n        # Using the full name\\n        salt * lgpo.get_policy \"Account lockout duration\" machine\\n        salt * lgpo.get_policy \"Configure Automatic Updates\" machine\\n\\n        # Using full path and name\\n        salt * lgpo.get_policy \"Windows Components\\\\Windows Update\\\\Configure Automatic Updates\" machine\\n    '\n    if not policy_name:\n        raise SaltInvocationError('policy_name must be defined')\n    if not policy_class:\n        raise SaltInvocationError('policy_class must be defined')\n    policy_class = policy_class.title()\n    policy_data = _policy_info()\n    if policy_class not in policy_data.policies.keys():\n        policy_classes = ', '.join(policy_data.policies.keys())\n        raise CommandExecutionError('The requested policy class \"{}\" is invalid, policy_class should be one of: {}'.format(policy_class, policy_classes))\n    policy_definition = None\n    if policy_name in policy_data.policies[policy_class]['policies']:\n        policy_definition = policy_data.policies[policy_class]['policies'][policy_name]\n    else:\n        for pol in policy_data.policies[policy_class]['policies']:\n            _p = policy_data.policies[policy_class]['policies'][pol]['Policy']\n            if _p == policy_name:\n                policy_definition = policy_data.policies[policy_class]['policies'][pol]\n                break\n        if policy_definition is None:\n            for pol in policy_data.policies[policy_class]['policies']:\n                _p = policy_data.policies[policy_class]['policies'][pol]['Policy']\n                if _p.lower() == policy_name.lower():\n                    policy_definition = policy_data.policies[policy_class]['policies'][pol]\n                    break\n    if policy_definition:\n        if return_value_only:\n            return _get_policy_info_setting(policy_definition)\n        if return_full_policy_names:\n            key_name = policy_definition['Policy']\n        else:\n            key_name = policy_name\n        setting = {key_name: _get_policy_info_setting(policy_definition)}\n        if hierarchical_return:\n            if 'lgpo_section' in policy_definition:\n                first_item = True\n                t_dict = {}\n                for level in reversed(policy_definition['lgpo_section']):\n                    new_dict = {}\n                    if first_item:\n                        new_dict[level] = {key_name: setting.pop(key_name)}\n                        first_item = False\n                    else:\n                        new_dict[level] = t_dict\n                    t_dict = new_dict\n                if t_dict:\n                    setting = t_dict\n        return setting\n    (success, policy_obj, _, _) = _lookup_admin_template(policy_name=policy_name, policy_class=policy_class, adml_language=adml_language)\n    if success:\n        setting = _get_policy_adm_setting(admx_policy=policy_obj, policy_class=policy_class, adml_language=adml_language, return_full_policy_names=return_full_policy_names, hierarchical_return=hierarchical_return)\n        if return_value_only:\n            for key in setting:\n                return setting[key]\n        return setting"
        ]
    },
    {
        "func_name": "set_computer_policy",
        "original": "def set_computer_policy(name, setting, cumulative_rights_assignments=True, adml_language='en-US'):\n    \"\"\"\n    Set a single computer policy\n\n    Args:\n        name (str):\n            The name of the policy to configure\n\n        setting (str):\n            The setting to configure the named policy with\n\n        cumulative_rights_assignments (bool): Determine how user rights\n            assignment policies are configured. If True, user right assignment\n            specifications are simply added to the existing policy. If False,\n            only the users specified will get the right (any existing will have\n            the right revoked)\n\n        adml_language (str): The language files to use for looking up\n            Administrative Template policy data (i.e. how the policy is\n            displayed in the GUI).  Defaults to 'en-US' (U.S. English).\n\n    Returns:\n        bool: True if successful, otherwise False\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' lgpo.set_computer_policy LockoutDuration 1440\n    \"\"\"\n    ret = set_(computer_policy={name: setting}, user_policy=None, cumulative_rights_assignments=cumulative_rights_assignments, adml_language=adml_language)\n    return ret",
        "mutated": [
            "def set_computer_policy(name, setting, cumulative_rights_assignments=True, adml_language='en-US'):\n    if False:\n        i = 10\n    \"\\n    Set a single computer policy\\n\\n    Args:\\n        name (str):\\n            The name of the policy to configure\\n\\n        setting (str):\\n            The setting to configure the named policy with\\n\\n        cumulative_rights_assignments (bool): Determine how user rights\\n            assignment policies are configured. If True, user right assignment\\n            specifications are simply added to the existing policy. If False,\\n            only the users specified will get the right (any existing will have\\n            the right revoked)\\n\\n        adml_language (str): The language files to use for looking up\\n            Administrative Template policy data (i.e. how the policy is\\n            displayed in the GUI).  Defaults to 'en-US' (U.S. English).\\n\\n    Returns:\\n        bool: True if successful, otherwise False\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' lgpo.set_computer_policy LockoutDuration 1440\\n    \"\n    ret = set_(computer_policy={name: setting}, user_policy=None, cumulative_rights_assignments=cumulative_rights_assignments, adml_language=adml_language)\n    return ret",
            "def set_computer_policy(name, setting, cumulative_rights_assignments=True, adml_language='en-US'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Set a single computer policy\\n\\n    Args:\\n        name (str):\\n            The name of the policy to configure\\n\\n        setting (str):\\n            The setting to configure the named policy with\\n\\n        cumulative_rights_assignments (bool): Determine how user rights\\n            assignment policies are configured. If True, user right assignment\\n            specifications are simply added to the existing policy. If False,\\n            only the users specified will get the right (any existing will have\\n            the right revoked)\\n\\n        adml_language (str): The language files to use for looking up\\n            Administrative Template policy data (i.e. how the policy is\\n            displayed in the GUI).  Defaults to 'en-US' (U.S. English).\\n\\n    Returns:\\n        bool: True if successful, otherwise False\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' lgpo.set_computer_policy LockoutDuration 1440\\n    \"\n    ret = set_(computer_policy={name: setting}, user_policy=None, cumulative_rights_assignments=cumulative_rights_assignments, adml_language=adml_language)\n    return ret",
            "def set_computer_policy(name, setting, cumulative_rights_assignments=True, adml_language='en-US'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Set a single computer policy\\n\\n    Args:\\n        name (str):\\n            The name of the policy to configure\\n\\n        setting (str):\\n            The setting to configure the named policy with\\n\\n        cumulative_rights_assignments (bool): Determine how user rights\\n            assignment policies are configured. If True, user right assignment\\n            specifications are simply added to the existing policy. If False,\\n            only the users specified will get the right (any existing will have\\n            the right revoked)\\n\\n        adml_language (str): The language files to use for looking up\\n            Administrative Template policy data (i.e. how the policy is\\n            displayed in the GUI).  Defaults to 'en-US' (U.S. English).\\n\\n    Returns:\\n        bool: True if successful, otherwise False\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' lgpo.set_computer_policy LockoutDuration 1440\\n    \"\n    ret = set_(computer_policy={name: setting}, user_policy=None, cumulative_rights_assignments=cumulative_rights_assignments, adml_language=adml_language)\n    return ret",
            "def set_computer_policy(name, setting, cumulative_rights_assignments=True, adml_language='en-US'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Set a single computer policy\\n\\n    Args:\\n        name (str):\\n            The name of the policy to configure\\n\\n        setting (str):\\n            The setting to configure the named policy with\\n\\n        cumulative_rights_assignments (bool): Determine how user rights\\n            assignment policies are configured. If True, user right assignment\\n            specifications are simply added to the existing policy. If False,\\n            only the users specified will get the right (any existing will have\\n            the right revoked)\\n\\n        adml_language (str): The language files to use for looking up\\n            Administrative Template policy data (i.e. how the policy is\\n            displayed in the GUI).  Defaults to 'en-US' (U.S. English).\\n\\n    Returns:\\n        bool: True if successful, otherwise False\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' lgpo.set_computer_policy LockoutDuration 1440\\n    \"\n    ret = set_(computer_policy={name: setting}, user_policy=None, cumulative_rights_assignments=cumulative_rights_assignments, adml_language=adml_language)\n    return ret",
            "def set_computer_policy(name, setting, cumulative_rights_assignments=True, adml_language='en-US'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Set a single computer policy\\n\\n    Args:\\n        name (str):\\n            The name of the policy to configure\\n\\n        setting (str):\\n            The setting to configure the named policy with\\n\\n        cumulative_rights_assignments (bool): Determine how user rights\\n            assignment policies are configured. If True, user right assignment\\n            specifications are simply added to the existing policy. If False,\\n            only the users specified will get the right (any existing will have\\n            the right revoked)\\n\\n        adml_language (str): The language files to use for looking up\\n            Administrative Template policy data (i.e. how the policy is\\n            displayed in the GUI).  Defaults to 'en-US' (U.S. English).\\n\\n    Returns:\\n        bool: True if successful, otherwise False\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' lgpo.set_computer_policy LockoutDuration 1440\\n    \"\n    ret = set_(computer_policy={name: setting}, user_policy=None, cumulative_rights_assignments=cumulative_rights_assignments, adml_language=adml_language)\n    return ret"
        ]
    },
    {
        "func_name": "set_user_policy",
        "original": "def set_user_policy(name, setting, adml_language='en-US'):\n    \"\"\"\n    Set a single user policy\n\n    Args:\n\n        name (str):\n            The name of the policy to configure\n\n        setting (str):\n            The setting to configure the named policy with\n\n        adml_language (str):\n            The language files to use for looking up Administrative Template\n            policy data (i.e. how the policy is displayed in the GUI). Defaults\n            to 'en-US' (U.S. English).\n\n    Returns:\n        bool: True if successful, Otherwise False\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' lgpo.set_user_policy \"Control Panel\\\\Display\\\\Disable the Display Control Panel\" Enabled\n    \"\"\"\n    ret = set_(user_policy={name: setting}, computer_policy=None, cumulative_rights_assignments=True, adml_language=adml_language)\n    return ret",
        "mutated": [
            "def set_user_policy(name, setting, adml_language='en-US'):\n    if False:\n        i = 10\n    '\\n    Set a single user policy\\n\\n    Args:\\n\\n        name (str):\\n            The name of the policy to configure\\n\\n        setting (str):\\n            The setting to configure the named policy with\\n\\n        adml_language (str):\\n            The language files to use for looking up Administrative Template\\n            policy data (i.e. how the policy is displayed in the GUI). Defaults\\n            to \\'en-US\\' (U.S. English).\\n\\n    Returns:\\n        bool: True if successful, Otherwise False\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' lgpo.set_user_policy \"Control Panel\\\\Display\\\\Disable the Display Control Panel\" Enabled\\n    '\n    ret = set_(user_policy={name: setting}, computer_policy=None, cumulative_rights_assignments=True, adml_language=adml_language)\n    return ret",
            "def set_user_policy(name, setting, adml_language='en-US'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Set a single user policy\\n\\n    Args:\\n\\n        name (str):\\n            The name of the policy to configure\\n\\n        setting (str):\\n            The setting to configure the named policy with\\n\\n        adml_language (str):\\n            The language files to use for looking up Administrative Template\\n            policy data (i.e. how the policy is displayed in the GUI). Defaults\\n            to \\'en-US\\' (U.S. English).\\n\\n    Returns:\\n        bool: True if successful, Otherwise False\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' lgpo.set_user_policy \"Control Panel\\\\Display\\\\Disable the Display Control Panel\" Enabled\\n    '\n    ret = set_(user_policy={name: setting}, computer_policy=None, cumulative_rights_assignments=True, adml_language=adml_language)\n    return ret",
            "def set_user_policy(name, setting, adml_language='en-US'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Set a single user policy\\n\\n    Args:\\n\\n        name (str):\\n            The name of the policy to configure\\n\\n        setting (str):\\n            The setting to configure the named policy with\\n\\n        adml_language (str):\\n            The language files to use for looking up Administrative Template\\n            policy data (i.e. how the policy is displayed in the GUI). Defaults\\n            to \\'en-US\\' (U.S. English).\\n\\n    Returns:\\n        bool: True if successful, Otherwise False\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' lgpo.set_user_policy \"Control Panel\\\\Display\\\\Disable the Display Control Panel\" Enabled\\n    '\n    ret = set_(user_policy={name: setting}, computer_policy=None, cumulative_rights_assignments=True, adml_language=adml_language)\n    return ret",
            "def set_user_policy(name, setting, adml_language='en-US'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Set a single user policy\\n\\n    Args:\\n\\n        name (str):\\n            The name of the policy to configure\\n\\n        setting (str):\\n            The setting to configure the named policy with\\n\\n        adml_language (str):\\n            The language files to use for looking up Administrative Template\\n            policy data (i.e. how the policy is displayed in the GUI). Defaults\\n            to \\'en-US\\' (U.S. English).\\n\\n    Returns:\\n        bool: True if successful, Otherwise False\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' lgpo.set_user_policy \"Control Panel\\\\Display\\\\Disable the Display Control Panel\" Enabled\\n    '\n    ret = set_(user_policy={name: setting}, computer_policy=None, cumulative_rights_assignments=True, adml_language=adml_language)\n    return ret",
            "def set_user_policy(name, setting, adml_language='en-US'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Set a single user policy\\n\\n    Args:\\n\\n        name (str):\\n            The name of the policy to configure\\n\\n        setting (str):\\n            The setting to configure the named policy with\\n\\n        adml_language (str):\\n            The language files to use for looking up Administrative Template\\n            policy data (i.e. how the policy is displayed in the GUI). Defaults\\n            to \\'en-US\\' (U.S. English).\\n\\n    Returns:\\n        bool: True if successful, Otherwise False\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' lgpo.set_user_policy \"Control Panel\\\\Display\\\\Disable the Display Control Panel\" Enabled\\n    '\n    ret = set_(user_policy={name: setting}, computer_policy=None, cumulative_rights_assignments=True, adml_language=adml_language)\n    return ret"
        ]
    },
    {
        "func_name": "set_",
        "original": "def set_(computer_policy=None, user_policy=None, cumulative_rights_assignments=True, adml_language='en-US'):\n    \"\"\"\n    Set a local server policy.\n\n    Args:\n\n        computer_policy (dict):\n            A dictionary of \"policyname: value\" pairs of computer policies to\n            set. 'value' should be how it is displayed in the gpedit GUI, i.e.\n            if a setting can be 'Enabled'/'Disabled', then that should be passed\n\n            Administrative Template data may require dicts within dicts, to\n            specify each element of the Administrative Template policy.\n            Administrative Templates policies are always cumulative.\n\n            Policy names can be specified in a number of ways based on the type\n            of policy:\n\n                Windows Settings Policies:\n\n                    These policies can be specified using the GUI display name\n                    or the key name from the _policy_info class in this module.\n                    The GUI display name is also contained in the _policy_info\n                    class in this module.\n\n                Administrative Template Policies:\n\n                    These can be specified using the policy name as displayed in\n                    the GUI (case sensitive). Some policies have the same name,\n                    but a different location (for example, \"Access data sources\n                    across domains\"). These can be differentiated by the \"path\"\n                    in the GUI (for example, \"Windows Components\\\\Internet\n                    Explorer\\\\Internet Control Panel\\\\Security Page\\\\Internet\n                    Zone\\\\Access data sources across domains\").\n\n                    Additionally, policies can be specified using the \"name\" and\n                    \"id\" attributes from the ADMX files.\n\n                    For Administrative Templates that have policy elements, each\n                    element can be specified using the text string as seen in\n                    the GUI or using the ID attribute from the ADMX file. Due to\n                    the way some of the GUI text is laid out, some policy\n                    element names could include descriptive text that appears\n                    lbefore the policy element in the GUI.\n\n                    Use the get_policy_info function for the policy name to view\n                    the element ID/names that the module will accept.\n\n        user_policy (dict):\n            The same setup as the computer_policy, except with data to configure\n            the local user policy.\n\n        cumulative_rights_assignments (bool):\n            Determine how user rights assignment policies are configured.\n\n            If True, user right assignment specifications are simply added to\n            the existing policy\n\n            If False, only the users specified will get the right (any existing\n            will have the right revoked)\n\n        adml_language (str):\n            The language files to use for looking up Administrative Template\n            policy data (i.e. how the policy is displayed in the GUI). Defaults\n            to 'en-US' (U.S. English).\n\n    Returns:\n        bool: True is successful, otherwise False\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' lgpo.set computer_policy=\"{'LockoutDuration': 2, 'RestrictAnonymous': 'Enabled', 'AuditProcessTracking': 'Succes, Failure'}\"\n    \"\"\"\n    if computer_policy and (not isinstance(computer_policy, dict)):\n        raise SaltInvocationError('computer_policy must be specified as a dict')\n    if user_policy and (not isinstance(user_policy, dict)):\n        raise SaltInvocationError('user_policy must be specified as a dict')\n    policies = {'User': user_policy, 'Machine': computer_policy}\n    if policies:\n        adml_policy_resources = _get_policy_resources(language=adml_language)\n        for p_class in policies:\n            _secedits = {}\n            _netshs = {}\n            _advaudits = {}\n            _modal_sets = {}\n            _admTemplateData = {}\n            _regedits = {}\n            _lsarights = {}\n            _policydata = _policy_info()\n            if policies[p_class]:\n                for policy_name in policies[p_class]:\n                    _pol = None\n                    policy_key_name = policy_name\n                    if policy_name in _policydata.policies[p_class]['policies']:\n                        _pol = _policydata.policies[p_class]['policies'][policy_name]\n                    else:\n                        for policy in _policydata.policies[p_class]['policies']:\n                            _p = _policydata.policies[p_class]['policies'][policy]['Policy']\n                            if _p == policy_name:\n                                _pol = _policydata.policies[p_class]['policies'][policy]\n                                policy_key_name = policy\n                        if _pol is None:\n                            for policy in _policydata.policies[p_class]['policies']:\n                                _p = _policydata.policies[p_class]['policies'][policy]['Policy']\n                                if _p.lower() == policy_name.lower():\n                                    _pol = _policydata.policies[p_class]['policies'][policy]\n                                    policy_key_name = policy\n                    if _pol:\n                        _value = _transform_value(value=policies[p_class][policy_name], policy=_policydata.policies[p_class]['policies'][policy_key_name], transform_type='Put')\n                        if not _validateSetting(value=_value, policy=_policydata.policies[p_class]['policies'][policy_key_name]):\n                            raise SaltInvocationError('The specified value {} is not an acceptable setting for policy {}.'.format(policies[p_class][policy_name], policy_name))\n                        if 'Registry' in _pol:\n                            log.trace('%s is a registry policy', policy_name)\n                            _regedits[policy_name] = {'policy': _pol, 'value': _value}\n                        elif 'Secedit' in _pol:\n                            log.trace('%s is a Secedit policy', policy_name)\n                            if _pol['Secedit']['Section'] not in _secedits:\n                                _secedits[_pol['Secedit']['Section']] = []\n                            _secedits[_pol['Secedit']['Section']].append(' '.join([_pol['Secedit']['Option'], '=', str(_value)]))\n                        elif 'NetSH' in _pol:\n                            log.trace('%s is a NetSH policy', policy_name)\n                            _netshs.setdefault(policy_name, {'profile': _pol['NetSH']['Profile'], 'section': _pol['NetSH']['Section'], 'option': _pol['NetSH']['Option'], 'value': str(_value)})\n                        elif 'AdvAudit' in _pol:\n                            _advaudits.setdefault(policy_name, {'option': _pol['AdvAudit']['Option'], 'value': str(_value)})\n                        elif 'NetUserModal' in _pol:\n                            log.trace('%s is a NetUserModal policy', policy_name)\n                            if _pol['NetUserModal']['Modal'] not in _modal_sets:\n                                _modal_sets[_pol['NetUserModal']['Modal']] = {}\n                            _modal_sets[_pol['NetUserModal']['Modal']][_pol['NetUserModal']['Option']] = _value\n                        elif 'LsaRights' in _pol:\n                            log.trace('%s is a LsaRights policy', policy_name)\n                            _lsarights[policy_name] = {'policy': _pol, 'value': _value}\n                    else:\n                        _value = policies[p_class][policy_name]\n                        log.trace('searching for \"%s\" in admx data', policy_name)\n                        (success, the_policy, policy_name_list, msg) = _lookup_admin_template(policy_name=policy_name, policy_class=p_class, adml_language=adml_language)\n                        if success:\n                            policy_name = the_policy.attrib['name']\n                            policy_namespace = the_policy.nsmap[the_policy.prefix]\n                            if policy_namespace not in _admTemplateData:\n                                _admTemplateData[policy_namespace] = {}\n                            _admTemplateData[policy_namespace][policy_name] = _value\n                        else:\n                            raise SaltInvocationError(msg)\n                        if policy_namespace and policy_name in _admTemplateData[policy_namespace] and (the_policy is not None):\n                            log.trace('setting == %s', str(_admTemplateData[policy_namespace][policy_name]).lower())\n                            log.trace(str(_admTemplateData[policy_namespace][policy_name]).lower())\n                            if str(_admTemplateData[policy_namespace][policy_name]).lower() != 'disabled' and str(_admTemplateData[policy_namespace][policy_name]).lower() != 'not configured':\n                                if ELEMENTS_XPATH(the_policy):\n                                    if isinstance(_admTemplateData[policy_namespace][policy_name], dict):\n                                        for elements_item in ELEMENTS_XPATH(the_policy):\n                                            for child_item in elements_item:\n                                                log.trace('checking element %s', child_item.attrib['id'])\n                                                temp_element_name = None\n                                                this_element_name = _getFullPolicyName(policy_item=child_item, policy_name=child_item.attrib['id'], return_full_policy_names=True, adml_language=adml_language)\n                                                log.trace('id attribute == \"%s\"  this_element_name == \"%s\"', child_item.attrib['id'], this_element_name)\n                                                if this_element_name in _admTemplateData[policy_namespace][policy_name]:\n                                                    temp_element_name = this_element_name\n                                                elif child_item.attrib['id'] in _admTemplateData[policy_namespace][policy_name]:\n                                                    temp_element_name = child_item.attrib['id']\n                                                else:\n                                                    raise SaltInvocationError('Element \"{}\" must be included in the policy configuration for policy {}'.format(this_element_name, policy_name))\n                                                if 'required' in child_item.attrib and child_item.attrib['required'].lower() == 'true':\n                                                    if not _admTemplateData[policy_namespace][policy_name][temp_element_name]:\n                                                        raise SaltInvocationError('Element \"{}\" requires a value to be specified'.format(temp_element_name))\n                                                if etree.QName(child_item).localname == 'boolean':\n                                                    if not isinstance(_admTemplateData[policy_namespace][policy_name][temp_element_name], bool):\n                                                        raise SaltInvocationError('Element {} requires a boolean True or False'.format(temp_element_name))\n                                                elif etree.QName(child_item).localname == 'decimal' or etree.QName(child_item).localname == 'longDecimal':\n                                                    min_val = 0\n                                                    max_val = 9999\n                                                    if 'minValue' in child_item.attrib:\n                                                        min_val = int(child_item.attrib['minValue'])\n                                                    if 'maxValue' in child_item.attrib:\n                                                        max_val = int(child_item.attrib['maxValue'])\n                                                    if int(_admTemplateData[policy_namespace][policy_name][temp_element_name]) < min_val or int(_admTemplateData[policy_namespace][policy_name][temp_element_name]) > max_val:\n                                                        raise SaltInvocationError('Element \"{}\" value must be between {} and {}'.format(temp_element_name, min_val, max_val))\n                                                elif etree.QName(child_item).localname == 'enum':\n                                                    found = False\n                                                    for enum_item in child_item:\n                                                        if _admTemplateData[policy_namespace][policy_name][temp_element_name] == _getAdmlDisplayName(adml_policy_resources, enum_item.attrib['displayName']).strip():\n                                                            found = True\n                                                            break\n                                                    if not found:\n                                                        raise SaltInvocationError('Element \"{}\" does not have a valid value'.format(temp_element_name))\n                                                elif etree.QName(child_item).localname == 'list':\n                                                    if 'explicitValue' in child_item.attrib and child_item.attrib['explicitValue'].lower() == 'true':\n                                                        if not isinstance(_admTemplateData[policy_namespace][policy_name][temp_element_name], dict):\n                                                            raise SaltInvocationError('Each list item of element \"{}\" requires a dict value'.format(temp_element_name))\n                                                    elif not isinstance(_admTemplateData[policy_namespace][policy_name][temp_element_name], list):\n                                                        raise SaltInvocationError('Element \"{}\" requires a list value'.format(temp_element_name))\n                                                elif etree.QName(child_item).localname == 'multiText':\n                                                    if not isinstance(_admTemplateData[policy_namespace][policy_name][temp_element_name], list):\n                                                        raise SaltInvocationError('Element \"{}\" requires a list value'.format(temp_element_name))\n                                                _admTemplateData[policy_namespace][policy_name][child_item.attrib['id']] = _admTemplateData[policy_namespace][policy_name].pop(temp_element_name)\n                                    else:\n                                        raise SaltInvocationError('The policy \"{}\" has elements which must be configured'.format(policy_name))\n                                elif str(_admTemplateData[policy_namespace][policy_name]).lower() != 'enabled':\n                                    raise SaltInvocationError('The policy {} must either be \"Enabled\", \"Disabled\", or \"Not Configured\"'.format(policy_name))\n                if _regedits:\n                    for regedit in _regedits:\n                        log.trace('%s is a Registry policy', regedit)\n                        if _regedits[regedit]['value'] is not None and _regedits[regedit]['value'] != '(value not set)':\n                            _ret = __utils__['reg.set_value'](_regedits[regedit]['policy']['Registry']['Hive'], _regedits[regedit]['policy']['Registry']['Path'], _regedits[regedit]['policy']['Registry']['Value'], _regedits[regedit]['value'], _regedits[regedit]['policy']['Registry']['Type'])\n                        else:\n                            _ret = __utils__['reg.read_value'](_regedits[regedit]['policy']['Registry']['Hive'], _regedits[regedit]['policy']['Registry']['Path'], _regedits[regedit]['policy']['Registry']['Value'])\n                            if _ret['success'] and _ret['vdata'] != '(value not set)':\n                                _ret = __utils__['reg.delete_value'](_regedits[regedit]['policy']['Registry']['Hive'], _regedits[regedit]['policy']['Registry']['Path'], _regedits[regedit]['policy']['Registry']['Value'])\n                        if not _ret:\n                            raise CommandExecutionError('Error while attempting to set policy {} via the registry.  Some changes may not be applied as expected'.format(regedit))\n                if _lsarights:\n                    for lsaright in _lsarights:\n                        _existingUsers = None\n                        if not cumulative_rights_assignments:\n                            _existingUsers = _getRightsAssignments(_lsarights[lsaright]['policy']['LsaRights']['Option'])\n                        if _lsarights[lsaright]['value']:\n                            for acct in _lsarights[lsaright]['value']:\n                                _ret = _addAccountRights(acct, _lsarights[lsaright]['policy']['LsaRights']['Option'])\n                                if not _ret:\n                                    raise SaltInvocationError('An error occurred attempting to configure the user right {}.'.format(lsaright))\n                        if _existingUsers:\n                            for acct in _existingUsers:\n                                if acct not in _lsarights[lsaright]['value']:\n                                    _ret = _delAccountRights(acct, _lsarights[lsaright]['policy']['LsaRights']['Option'])\n                                    if not _ret:\n                                        raise SaltInvocationError('An error occurred attempting to remove previously configured users with right {}.'.format(lsaright))\n                if _secedits:\n                    log.trace(_secedits)\n                    ini_data = '\\r\\n'.join(['[Unicode]', 'Unicode=yes'])\n                    _seceditSections = ['System Access', 'Event Audit', 'Registry Values', 'Privilege Rights']\n                    for _seceditSection in _seceditSections:\n                        if _seceditSection in _secedits:\n                            ini_data = '\\r\\n'.join([ini_data, ''.join(['[', _seceditSection, ']']), '\\r\\n'.join(_secedits[_seceditSection])])\n                    ini_data = '\\r\\n'.join([ini_data, '[Version]', 'signature=\"$CHICAGO$\"', 'Revision=1'])\n                    log.trace('ini_data == %s', ini_data)\n                    if not _write_secedit_data(ini_data):\n                        raise CommandExecutionError('Error while attempting to set policies via secedit. Some changes may not be applied as expected')\n                if _netshs:\n                    for setting in _netshs:\n                        log.trace('Setting firewall policy: %s', setting)\n                        log.trace(_netshs[setting])\n                        _set_netsh_value(**_netshs[setting])\n                if _advaudits:\n                    for setting in _advaudits:\n                        log.trace('Setting Advanced Audit policy: %s', setting)\n                        log.trace(_advaudits[setting])\n                        _set_advaudit_value(**_advaudits[setting])\n                if _modal_sets:\n                    log.trace(_modal_sets)\n                    for _modal_set in _modal_sets:\n                        try:\n                            _existingModalData = win32net.NetUserModalsGet(None, _modal_set)\n                            _newModalSetData = dictupdate.update(_existingModalData, _modal_sets[_modal_set])\n                            log.trace('NEW MODAL SET = %s', _newModalSetData)\n                            _ret = win32net.NetUserModalsSet(None, _modal_set, _newModalSetData)\n                        except Exception as exc:\n                            msg = 'An unhandled exception occurred while attempting to set policy via NetUserModalSet\\n{}'.format(exc)\n                            log.exception(msg)\n                            raise CommandExecutionError(msg)\n                if _admTemplateData:\n                    _ret = False\n                    log.trace('going to write some adm template data :: %s', _admTemplateData)\n                    _ret = _writeAdminTemplateRegPolFile(_admTemplateData, adml_language=adml_language, registry_class=p_class)\n                    if not _ret:\n                        raise CommandExecutionError('Error while attempting to write Administrative Template Policy data.  Some changes may not be applied as expected')\n        return True\n    else:\n        raise SaltInvocationError('You have to specify something!')",
        "mutated": [
            "def set_(computer_policy=None, user_policy=None, cumulative_rights_assignments=True, adml_language='en-US'):\n    if False:\n        i = 10\n    '\\n    Set a local server policy.\\n\\n    Args:\\n\\n        computer_policy (dict):\\n            A dictionary of \"policyname: value\" pairs of computer policies to\\n            set. \\'value\\' should be how it is displayed in the gpedit GUI, i.e.\\n            if a setting can be \\'Enabled\\'/\\'Disabled\\', then that should be passed\\n\\n            Administrative Template data may require dicts within dicts, to\\n            specify each element of the Administrative Template policy.\\n            Administrative Templates policies are always cumulative.\\n\\n            Policy names can be specified in a number of ways based on the type\\n            of policy:\\n\\n                Windows Settings Policies:\\n\\n                    These policies can be specified using the GUI display name\\n                    or the key name from the _policy_info class in this module.\\n                    The GUI display name is also contained in the _policy_info\\n                    class in this module.\\n\\n                Administrative Template Policies:\\n\\n                    These can be specified using the policy name as displayed in\\n                    the GUI (case sensitive). Some policies have the same name,\\n                    but a different location (for example, \"Access data sources\\n                    across domains\"). These can be differentiated by the \"path\"\\n                    in the GUI (for example, \"Windows Components\\\\Internet\\n                    Explorer\\\\Internet Control Panel\\\\Security Page\\\\Internet\\n                    Zone\\\\Access data sources across domains\").\\n\\n                    Additionally, policies can be specified using the \"name\" and\\n                    \"id\" attributes from the ADMX files.\\n\\n                    For Administrative Templates that have policy elements, each\\n                    element can be specified using the text string as seen in\\n                    the GUI or using the ID attribute from the ADMX file. Due to\\n                    the way some of the GUI text is laid out, some policy\\n                    element names could include descriptive text that appears\\n                    lbefore the policy element in the GUI.\\n\\n                    Use the get_policy_info function for the policy name to view\\n                    the element ID/names that the module will accept.\\n\\n        user_policy (dict):\\n            The same setup as the computer_policy, except with data to configure\\n            the local user policy.\\n\\n        cumulative_rights_assignments (bool):\\n            Determine how user rights assignment policies are configured.\\n\\n            If True, user right assignment specifications are simply added to\\n            the existing policy\\n\\n            If False, only the users specified will get the right (any existing\\n            will have the right revoked)\\n\\n        adml_language (str):\\n            The language files to use for looking up Administrative Template\\n            policy data (i.e. how the policy is displayed in the GUI). Defaults\\n            to \\'en-US\\' (U.S. English).\\n\\n    Returns:\\n        bool: True is successful, otherwise False\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' lgpo.set computer_policy=\"{\\'LockoutDuration\\': 2, \\'RestrictAnonymous\\': \\'Enabled\\', \\'AuditProcessTracking\\': \\'Succes, Failure\\'}\"\\n    '\n    if computer_policy and (not isinstance(computer_policy, dict)):\n        raise SaltInvocationError('computer_policy must be specified as a dict')\n    if user_policy and (not isinstance(user_policy, dict)):\n        raise SaltInvocationError('user_policy must be specified as a dict')\n    policies = {'User': user_policy, 'Machine': computer_policy}\n    if policies:\n        adml_policy_resources = _get_policy_resources(language=adml_language)\n        for p_class in policies:\n            _secedits = {}\n            _netshs = {}\n            _advaudits = {}\n            _modal_sets = {}\n            _admTemplateData = {}\n            _regedits = {}\n            _lsarights = {}\n            _policydata = _policy_info()\n            if policies[p_class]:\n                for policy_name in policies[p_class]:\n                    _pol = None\n                    policy_key_name = policy_name\n                    if policy_name in _policydata.policies[p_class]['policies']:\n                        _pol = _policydata.policies[p_class]['policies'][policy_name]\n                    else:\n                        for policy in _policydata.policies[p_class]['policies']:\n                            _p = _policydata.policies[p_class]['policies'][policy]['Policy']\n                            if _p == policy_name:\n                                _pol = _policydata.policies[p_class]['policies'][policy]\n                                policy_key_name = policy\n                        if _pol is None:\n                            for policy in _policydata.policies[p_class]['policies']:\n                                _p = _policydata.policies[p_class]['policies'][policy]['Policy']\n                                if _p.lower() == policy_name.lower():\n                                    _pol = _policydata.policies[p_class]['policies'][policy]\n                                    policy_key_name = policy\n                    if _pol:\n                        _value = _transform_value(value=policies[p_class][policy_name], policy=_policydata.policies[p_class]['policies'][policy_key_name], transform_type='Put')\n                        if not _validateSetting(value=_value, policy=_policydata.policies[p_class]['policies'][policy_key_name]):\n                            raise SaltInvocationError('The specified value {} is not an acceptable setting for policy {}.'.format(policies[p_class][policy_name], policy_name))\n                        if 'Registry' in _pol:\n                            log.trace('%s is a registry policy', policy_name)\n                            _regedits[policy_name] = {'policy': _pol, 'value': _value}\n                        elif 'Secedit' in _pol:\n                            log.trace('%s is a Secedit policy', policy_name)\n                            if _pol['Secedit']['Section'] not in _secedits:\n                                _secedits[_pol['Secedit']['Section']] = []\n                            _secedits[_pol['Secedit']['Section']].append(' '.join([_pol['Secedit']['Option'], '=', str(_value)]))\n                        elif 'NetSH' in _pol:\n                            log.trace('%s is a NetSH policy', policy_name)\n                            _netshs.setdefault(policy_name, {'profile': _pol['NetSH']['Profile'], 'section': _pol['NetSH']['Section'], 'option': _pol['NetSH']['Option'], 'value': str(_value)})\n                        elif 'AdvAudit' in _pol:\n                            _advaudits.setdefault(policy_name, {'option': _pol['AdvAudit']['Option'], 'value': str(_value)})\n                        elif 'NetUserModal' in _pol:\n                            log.trace('%s is a NetUserModal policy', policy_name)\n                            if _pol['NetUserModal']['Modal'] not in _modal_sets:\n                                _modal_sets[_pol['NetUserModal']['Modal']] = {}\n                            _modal_sets[_pol['NetUserModal']['Modal']][_pol['NetUserModal']['Option']] = _value\n                        elif 'LsaRights' in _pol:\n                            log.trace('%s is a LsaRights policy', policy_name)\n                            _lsarights[policy_name] = {'policy': _pol, 'value': _value}\n                    else:\n                        _value = policies[p_class][policy_name]\n                        log.trace('searching for \"%s\" in admx data', policy_name)\n                        (success, the_policy, policy_name_list, msg) = _lookup_admin_template(policy_name=policy_name, policy_class=p_class, adml_language=adml_language)\n                        if success:\n                            policy_name = the_policy.attrib['name']\n                            policy_namespace = the_policy.nsmap[the_policy.prefix]\n                            if policy_namespace not in _admTemplateData:\n                                _admTemplateData[policy_namespace] = {}\n                            _admTemplateData[policy_namespace][policy_name] = _value\n                        else:\n                            raise SaltInvocationError(msg)\n                        if policy_namespace and policy_name in _admTemplateData[policy_namespace] and (the_policy is not None):\n                            log.trace('setting == %s', str(_admTemplateData[policy_namespace][policy_name]).lower())\n                            log.trace(str(_admTemplateData[policy_namespace][policy_name]).lower())\n                            if str(_admTemplateData[policy_namespace][policy_name]).lower() != 'disabled' and str(_admTemplateData[policy_namespace][policy_name]).lower() != 'not configured':\n                                if ELEMENTS_XPATH(the_policy):\n                                    if isinstance(_admTemplateData[policy_namespace][policy_name], dict):\n                                        for elements_item in ELEMENTS_XPATH(the_policy):\n                                            for child_item in elements_item:\n                                                log.trace('checking element %s', child_item.attrib['id'])\n                                                temp_element_name = None\n                                                this_element_name = _getFullPolicyName(policy_item=child_item, policy_name=child_item.attrib['id'], return_full_policy_names=True, adml_language=adml_language)\n                                                log.trace('id attribute == \"%s\"  this_element_name == \"%s\"', child_item.attrib['id'], this_element_name)\n                                                if this_element_name in _admTemplateData[policy_namespace][policy_name]:\n                                                    temp_element_name = this_element_name\n                                                elif child_item.attrib['id'] in _admTemplateData[policy_namespace][policy_name]:\n                                                    temp_element_name = child_item.attrib['id']\n                                                else:\n                                                    raise SaltInvocationError('Element \"{}\" must be included in the policy configuration for policy {}'.format(this_element_name, policy_name))\n                                                if 'required' in child_item.attrib and child_item.attrib['required'].lower() == 'true':\n                                                    if not _admTemplateData[policy_namespace][policy_name][temp_element_name]:\n                                                        raise SaltInvocationError('Element \"{}\" requires a value to be specified'.format(temp_element_name))\n                                                if etree.QName(child_item).localname == 'boolean':\n                                                    if not isinstance(_admTemplateData[policy_namespace][policy_name][temp_element_name], bool):\n                                                        raise SaltInvocationError('Element {} requires a boolean True or False'.format(temp_element_name))\n                                                elif etree.QName(child_item).localname == 'decimal' or etree.QName(child_item).localname == 'longDecimal':\n                                                    min_val = 0\n                                                    max_val = 9999\n                                                    if 'minValue' in child_item.attrib:\n                                                        min_val = int(child_item.attrib['minValue'])\n                                                    if 'maxValue' in child_item.attrib:\n                                                        max_val = int(child_item.attrib['maxValue'])\n                                                    if int(_admTemplateData[policy_namespace][policy_name][temp_element_name]) < min_val or int(_admTemplateData[policy_namespace][policy_name][temp_element_name]) > max_val:\n                                                        raise SaltInvocationError('Element \"{}\" value must be between {} and {}'.format(temp_element_name, min_val, max_val))\n                                                elif etree.QName(child_item).localname == 'enum':\n                                                    found = False\n                                                    for enum_item in child_item:\n                                                        if _admTemplateData[policy_namespace][policy_name][temp_element_name] == _getAdmlDisplayName(adml_policy_resources, enum_item.attrib['displayName']).strip():\n                                                            found = True\n                                                            break\n                                                    if not found:\n                                                        raise SaltInvocationError('Element \"{}\" does not have a valid value'.format(temp_element_name))\n                                                elif etree.QName(child_item).localname == 'list':\n                                                    if 'explicitValue' in child_item.attrib and child_item.attrib['explicitValue'].lower() == 'true':\n                                                        if not isinstance(_admTemplateData[policy_namespace][policy_name][temp_element_name], dict):\n                                                            raise SaltInvocationError('Each list item of element \"{}\" requires a dict value'.format(temp_element_name))\n                                                    elif not isinstance(_admTemplateData[policy_namespace][policy_name][temp_element_name], list):\n                                                        raise SaltInvocationError('Element \"{}\" requires a list value'.format(temp_element_name))\n                                                elif etree.QName(child_item).localname == 'multiText':\n                                                    if not isinstance(_admTemplateData[policy_namespace][policy_name][temp_element_name], list):\n                                                        raise SaltInvocationError('Element \"{}\" requires a list value'.format(temp_element_name))\n                                                _admTemplateData[policy_namespace][policy_name][child_item.attrib['id']] = _admTemplateData[policy_namespace][policy_name].pop(temp_element_name)\n                                    else:\n                                        raise SaltInvocationError('The policy \"{}\" has elements which must be configured'.format(policy_name))\n                                elif str(_admTemplateData[policy_namespace][policy_name]).lower() != 'enabled':\n                                    raise SaltInvocationError('The policy {} must either be \"Enabled\", \"Disabled\", or \"Not Configured\"'.format(policy_name))\n                if _regedits:\n                    for regedit in _regedits:\n                        log.trace('%s is a Registry policy', regedit)\n                        if _regedits[regedit]['value'] is not None and _regedits[regedit]['value'] != '(value not set)':\n                            _ret = __utils__['reg.set_value'](_regedits[regedit]['policy']['Registry']['Hive'], _regedits[regedit]['policy']['Registry']['Path'], _regedits[regedit]['policy']['Registry']['Value'], _regedits[regedit]['value'], _regedits[regedit]['policy']['Registry']['Type'])\n                        else:\n                            _ret = __utils__['reg.read_value'](_regedits[regedit]['policy']['Registry']['Hive'], _regedits[regedit]['policy']['Registry']['Path'], _regedits[regedit]['policy']['Registry']['Value'])\n                            if _ret['success'] and _ret['vdata'] != '(value not set)':\n                                _ret = __utils__['reg.delete_value'](_regedits[regedit]['policy']['Registry']['Hive'], _regedits[regedit]['policy']['Registry']['Path'], _regedits[regedit]['policy']['Registry']['Value'])\n                        if not _ret:\n                            raise CommandExecutionError('Error while attempting to set policy {} via the registry.  Some changes may not be applied as expected'.format(regedit))\n                if _lsarights:\n                    for lsaright in _lsarights:\n                        _existingUsers = None\n                        if not cumulative_rights_assignments:\n                            _existingUsers = _getRightsAssignments(_lsarights[lsaright]['policy']['LsaRights']['Option'])\n                        if _lsarights[lsaright]['value']:\n                            for acct in _lsarights[lsaright]['value']:\n                                _ret = _addAccountRights(acct, _lsarights[lsaright]['policy']['LsaRights']['Option'])\n                                if not _ret:\n                                    raise SaltInvocationError('An error occurred attempting to configure the user right {}.'.format(lsaright))\n                        if _existingUsers:\n                            for acct in _existingUsers:\n                                if acct not in _lsarights[lsaright]['value']:\n                                    _ret = _delAccountRights(acct, _lsarights[lsaright]['policy']['LsaRights']['Option'])\n                                    if not _ret:\n                                        raise SaltInvocationError('An error occurred attempting to remove previously configured users with right {}.'.format(lsaright))\n                if _secedits:\n                    log.trace(_secedits)\n                    ini_data = '\\r\\n'.join(['[Unicode]', 'Unicode=yes'])\n                    _seceditSections = ['System Access', 'Event Audit', 'Registry Values', 'Privilege Rights']\n                    for _seceditSection in _seceditSections:\n                        if _seceditSection in _secedits:\n                            ini_data = '\\r\\n'.join([ini_data, ''.join(['[', _seceditSection, ']']), '\\r\\n'.join(_secedits[_seceditSection])])\n                    ini_data = '\\r\\n'.join([ini_data, '[Version]', 'signature=\"$CHICAGO$\"', 'Revision=1'])\n                    log.trace('ini_data == %s', ini_data)\n                    if not _write_secedit_data(ini_data):\n                        raise CommandExecutionError('Error while attempting to set policies via secedit. Some changes may not be applied as expected')\n                if _netshs:\n                    for setting in _netshs:\n                        log.trace('Setting firewall policy: %s', setting)\n                        log.trace(_netshs[setting])\n                        _set_netsh_value(**_netshs[setting])\n                if _advaudits:\n                    for setting in _advaudits:\n                        log.trace('Setting Advanced Audit policy: %s', setting)\n                        log.trace(_advaudits[setting])\n                        _set_advaudit_value(**_advaudits[setting])\n                if _modal_sets:\n                    log.trace(_modal_sets)\n                    for _modal_set in _modal_sets:\n                        try:\n                            _existingModalData = win32net.NetUserModalsGet(None, _modal_set)\n                            _newModalSetData = dictupdate.update(_existingModalData, _modal_sets[_modal_set])\n                            log.trace('NEW MODAL SET = %s', _newModalSetData)\n                            _ret = win32net.NetUserModalsSet(None, _modal_set, _newModalSetData)\n                        except Exception as exc:\n                            msg = 'An unhandled exception occurred while attempting to set policy via NetUserModalSet\\n{}'.format(exc)\n                            log.exception(msg)\n                            raise CommandExecutionError(msg)\n                if _admTemplateData:\n                    _ret = False\n                    log.trace('going to write some adm template data :: %s', _admTemplateData)\n                    _ret = _writeAdminTemplateRegPolFile(_admTemplateData, adml_language=adml_language, registry_class=p_class)\n                    if not _ret:\n                        raise CommandExecutionError('Error while attempting to write Administrative Template Policy data.  Some changes may not be applied as expected')\n        return True\n    else:\n        raise SaltInvocationError('You have to specify something!')",
            "def set_(computer_policy=None, user_policy=None, cumulative_rights_assignments=True, adml_language='en-US'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Set a local server policy.\\n\\n    Args:\\n\\n        computer_policy (dict):\\n            A dictionary of \"policyname: value\" pairs of computer policies to\\n            set. \\'value\\' should be how it is displayed in the gpedit GUI, i.e.\\n            if a setting can be \\'Enabled\\'/\\'Disabled\\', then that should be passed\\n\\n            Administrative Template data may require dicts within dicts, to\\n            specify each element of the Administrative Template policy.\\n            Administrative Templates policies are always cumulative.\\n\\n            Policy names can be specified in a number of ways based on the type\\n            of policy:\\n\\n                Windows Settings Policies:\\n\\n                    These policies can be specified using the GUI display name\\n                    or the key name from the _policy_info class in this module.\\n                    The GUI display name is also contained in the _policy_info\\n                    class in this module.\\n\\n                Administrative Template Policies:\\n\\n                    These can be specified using the policy name as displayed in\\n                    the GUI (case sensitive). Some policies have the same name,\\n                    but a different location (for example, \"Access data sources\\n                    across domains\"). These can be differentiated by the \"path\"\\n                    in the GUI (for example, \"Windows Components\\\\Internet\\n                    Explorer\\\\Internet Control Panel\\\\Security Page\\\\Internet\\n                    Zone\\\\Access data sources across domains\").\\n\\n                    Additionally, policies can be specified using the \"name\" and\\n                    \"id\" attributes from the ADMX files.\\n\\n                    For Administrative Templates that have policy elements, each\\n                    element can be specified using the text string as seen in\\n                    the GUI or using the ID attribute from the ADMX file. Due to\\n                    the way some of the GUI text is laid out, some policy\\n                    element names could include descriptive text that appears\\n                    lbefore the policy element in the GUI.\\n\\n                    Use the get_policy_info function for the policy name to view\\n                    the element ID/names that the module will accept.\\n\\n        user_policy (dict):\\n            The same setup as the computer_policy, except with data to configure\\n            the local user policy.\\n\\n        cumulative_rights_assignments (bool):\\n            Determine how user rights assignment policies are configured.\\n\\n            If True, user right assignment specifications are simply added to\\n            the existing policy\\n\\n            If False, only the users specified will get the right (any existing\\n            will have the right revoked)\\n\\n        adml_language (str):\\n            The language files to use for looking up Administrative Template\\n            policy data (i.e. how the policy is displayed in the GUI). Defaults\\n            to \\'en-US\\' (U.S. English).\\n\\n    Returns:\\n        bool: True is successful, otherwise False\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' lgpo.set computer_policy=\"{\\'LockoutDuration\\': 2, \\'RestrictAnonymous\\': \\'Enabled\\', \\'AuditProcessTracking\\': \\'Succes, Failure\\'}\"\\n    '\n    if computer_policy and (not isinstance(computer_policy, dict)):\n        raise SaltInvocationError('computer_policy must be specified as a dict')\n    if user_policy and (not isinstance(user_policy, dict)):\n        raise SaltInvocationError('user_policy must be specified as a dict')\n    policies = {'User': user_policy, 'Machine': computer_policy}\n    if policies:\n        adml_policy_resources = _get_policy_resources(language=adml_language)\n        for p_class in policies:\n            _secedits = {}\n            _netshs = {}\n            _advaudits = {}\n            _modal_sets = {}\n            _admTemplateData = {}\n            _regedits = {}\n            _lsarights = {}\n            _policydata = _policy_info()\n            if policies[p_class]:\n                for policy_name in policies[p_class]:\n                    _pol = None\n                    policy_key_name = policy_name\n                    if policy_name in _policydata.policies[p_class]['policies']:\n                        _pol = _policydata.policies[p_class]['policies'][policy_name]\n                    else:\n                        for policy in _policydata.policies[p_class]['policies']:\n                            _p = _policydata.policies[p_class]['policies'][policy]['Policy']\n                            if _p == policy_name:\n                                _pol = _policydata.policies[p_class]['policies'][policy]\n                                policy_key_name = policy\n                        if _pol is None:\n                            for policy in _policydata.policies[p_class]['policies']:\n                                _p = _policydata.policies[p_class]['policies'][policy]['Policy']\n                                if _p.lower() == policy_name.lower():\n                                    _pol = _policydata.policies[p_class]['policies'][policy]\n                                    policy_key_name = policy\n                    if _pol:\n                        _value = _transform_value(value=policies[p_class][policy_name], policy=_policydata.policies[p_class]['policies'][policy_key_name], transform_type='Put')\n                        if not _validateSetting(value=_value, policy=_policydata.policies[p_class]['policies'][policy_key_name]):\n                            raise SaltInvocationError('The specified value {} is not an acceptable setting for policy {}.'.format(policies[p_class][policy_name], policy_name))\n                        if 'Registry' in _pol:\n                            log.trace('%s is a registry policy', policy_name)\n                            _regedits[policy_name] = {'policy': _pol, 'value': _value}\n                        elif 'Secedit' in _pol:\n                            log.trace('%s is a Secedit policy', policy_name)\n                            if _pol['Secedit']['Section'] not in _secedits:\n                                _secedits[_pol['Secedit']['Section']] = []\n                            _secedits[_pol['Secedit']['Section']].append(' '.join([_pol['Secedit']['Option'], '=', str(_value)]))\n                        elif 'NetSH' in _pol:\n                            log.trace('%s is a NetSH policy', policy_name)\n                            _netshs.setdefault(policy_name, {'profile': _pol['NetSH']['Profile'], 'section': _pol['NetSH']['Section'], 'option': _pol['NetSH']['Option'], 'value': str(_value)})\n                        elif 'AdvAudit' in _pol:\n                            _advaudits.setdefault(policy_name, {'option': _pol['AdvAudit']['Option'], 'value': str(_value)})\n                        elif 'NetUserModal' in _pol:\n                            log.trace('%s is a NetUserModal policy', policy_name)\n                            if _pol['NetUserModal']['Modal'] not in _modal_sets:\n                                _modal_sets[_pol['NetUserModal']['Modal']] = {}\n                            _modal_sets[_pol['NetUserModal']['Modal']][_pol['NetUserModal']['Option']] = _value\n                        elif 'LsaRights' in _pol:\n                            log.trace('%s is a LsaRights policy', policy_name)\n                            _lsarights[policy_name] = {'policy': _pol, 'value': _value}\n                    else:\n                        _value = policies[p_class][policy_name]\n                        log.trace('searching for \"%s\" in admx data', policy_name)\n                        (success, the_policy, policy_name_list, msg) = _lookup_admin_template(policy_name=policy_name, policy_class=p_class, adml_language=adml_language)\n                        if success:\n                            policy_name = the_policy.attrib['name']\n                            policy_namespace = the_policy.nsmap[the_policy.prefix]\n                            if policy_namespace not in _admTemplateData:\n                                _admTemplateData[policy_namespace] = {}\n                            _admTemplateData[policy_namespace][policy_name] = _value\n                        else:\n                            raise SaltInvocationError(msg)\n                        if policy_namespace and policy_name in _admTemplateData[policy_namespace] and (the_policy is not None):\n                            log.trace('setting == %s', str(_admTemplateData[policy_namespace][policy_name]).lower())\n                            log.trace(str(_admTemplateData[policy_namespace][policy_name]).lower())\n                            if str(_admTemplateData[policy_namespace][policy_name]).lower() != 'disabled' and str(_admTemplateData[policy_namespace][policy_name]).lower() != 'not configured':\n                                if ELEMENTS_XPATH(the_policy):\n                                    if isinstance(_admTemplateData[policy_namespace][policy_name], dict):\n                                        for elements_item in ELEMENTS_XPATH(the_policy):\n                                            for child_item in elements_item:\n                                                log.trace('checking element %s', child_item.attrib['id'])\n                                                temp_element_name = None\n                                                this_element_name = _getFullPolicyName(policy_item=child_item, policy_name=child_item.attrib['id'], return_full_policy_names=True, adml_language=adml_language)\n                                                log.trace('id attribute == \"%s\"  this_element_name == \"%s\"', child_item.attrib['id'], this_element_name)\n                                                if this_element_name in _admTemplateData[policy_namespace][policy_name]:\n                                                    temp_element_name = this_element_name\n                                                elif child_item.attrib['id'] in _admTemplateData[policy_namespace][policy_name]:\n                                                    temp_element_name = child_item.attrib['id']\n                                                else:\n                                                    raise SaltInvocationError('Element \"{}\" must be included in the policy configuration for policy {}'.format(this_element_name, policy_name))\n                                                if 'required' in child_item.attrib and child_item.attrib['required'].lower() == 'true':\n                                                    if not _admTemplateData[policy_namespace][policy_name][temp_element_name]:\n                                                        raise SaltInvocationError('Element \"{}\" requires a value to be specified'.format(temp_element_name))\n                                                if etree.QName(child_item).localname == 'boolean':\n                                                    if not isinstance(_admTemplateData[policy_namespace][policy_name][temp_element_name], bool):\n                                                        raise SaltInvocationError('Element {} requires a boolean True or False'.format(temp_element_name))\n                                                elif etree.QName(child_item).localname == 'decimal' or etree.QName(child_item).localname == 'longDecimal':\n                                                    min_val = 0\n                                                    max_val = 9999\n                                                    if 'minValue' in child_item.attrib:\n                                                        min_val = int(child_item.attrib['minValue'])\n                                                    if 'maxValue' in child_item.attrib:\n                                                        max_val = int(child_item.attrib['maxValue'])\n                                                    if int(_admTemplateData[policy_namespace][policy_name][temp_element_name]) < min_val or int(_admTemplateData[policy_namespace][policy_name][temp_element_name]) > max_val:\n                                                        raise SaltInvocationError('Element \"{}\" value must be between {} and {}'.format(temp_element_name, min_val, max_val))\n                                                elif etree.QName(child_item).localname == 'enum':\n                                                    found = False\n                                                    for enum_item in child_item:\n                                                        if _admTemplateData[policy_namespace][policy_name][temp_element_name] == _getAdmlDisplayName(adml_policy_resources, enum_item.attrib['displayName']).strip():\n                                                            found = True\n                                                            break\n                                                    if not found:\n                                                        raise SaltInvocationError('Element \"{}\" does not have a valid value'.format(temp_element_name))\n                                                elif etree.QName(child_item).localname == 'list':\n                                                    if 'explicitValue' in child_item.attrib and child_item.attrib['explicitValue'].lower() == 'true':\n                                                        if not isinstance(_admTemplateData[policy_namespace][policy_name][temp_element_name], dict):\n                                                            raise SaltInvocationError('Each list item of element \"{}\" requires a dict value'.format(temp_element_name))\n                                                    elif not isinstance(_admTemplateData[policy_namespace][policy_name][temp_element_name], list):\n                                                        raise SaltInvocationError('Element \"{}\" requires a list value'.format(temp_element_name))\n                                                elif etree.QName(child_item).localname == 'multiText':\n                                                    if not isinstance(_admTemplateData[policy_namespace][policy_name][temp_element_name], list):\n                                                        raise SaltInvocationError('Element \"{}\" requires a list value'.format(temp_element_name))\n                                                _admTemplateData[policy_namespace][policy_name][child_item.attrib['id']] = _admTemplateData[policy_namespace][policy_name].pop(temp_element_name)\n                                    else:\n                                        raise SaltInvocationError('The policy \"{}\" has elements which must be configured'.format(policy_name))\n                                elif str(_admTemplateData[policy_namespace][policy_name]).lower() != 'enabled':\n                                    raise SaltInvocationError('The policy {} must either be \"Enabled\", \"Disabled\", or \"Not Configured\"'.format(policy_name))\n                if _regedits:\n                    for regedit in _regedits:\n                        log.trace('%s is a Registry policy', regedit)\n                        if _regedits[regedit]['value'] is not None and _regedits[regedit]['value'] != '(value not set)':\n                            _ret = __utils__['reg.set_value'](_regedits[regedit]['policy']['Registry']['Hive'], _regedits[regedit]['policy']['Registry']['Path'], _regedits[regedit]['policy']['Registry']['Value'], _regedits[regedit]['value'], _regedits[regedit]['policy']['Registry']['Type'])\n                        else:\n                            _ret = __utils__['reg.read_value'](_regedits[regedit]['policy']['Registry']['Hive'], _regedits[regedit]['policy']['Registry']['Path'], _regedits[regedit]['policy']['Registry']['Value'])\n                            if _ret['success'] and _ret['vdata'] != '(value not set)':\n                                _ret = __utils__['reg.delete_value'](_regedits[regedit]['policy']['Registry']['Hive'], _regedits[regedit]['policy']['Registry']['Path'], _regedits[regedit]['policy']['Registry']['Value'])\n                        if not _ret:\n                            raise CommandExecutionError('Error while attempting to set policy {} via the registry.  Some changes may not be applied as expected'.format(regedit))\n                if _lsarights:\n                    for lsaright in _lsarights:\n                        _existingUsers = None\n                        if not cumulative_rights_assignments:\n                            _existingUsers = _getRightsAssignments(_lsarights[lsaright]['policy']['LsaRights']['Option'])\n                        if _lsarights[lsaright]['value']:\n                            for acct in _lsarights[lsaright]['value']:\n                                _ret = _addAccountRights(acct, _lsarights[lsaright]['policy']['LsaRights']['Option'])\n                                if not _ret:\n                                    raise SaltInvocationError('An error occurred attempting to configure the user right {}.'.format(lsaright))\n                        if _existingUsers:\n                            for acct in _existingUsers:\n                                if acct not in _lsarights[lsaright]['value']:\n                                    _ret = _delAccountRights(acct, _lsarights[lsaright]['policy']['LsaRights']['Option'])\n                                    if not _ret:\n                                        raise SaltInvocationError('An error occurred attempting to remove previously configured users with right {}.'.format(lsaright))\n                if _secedits:\n                    log.trace(_secedits)\n                    ini_data = '\\r\\n'.join(['[Unicode]', 'Unicode=yes'])\n                    _seceditSections = ['System Access', 'Event Audit', 'Registry Values', 'Privilege Rights']\n                    for _seceditSection in _seceditSections:\n                        if _seceditSection in _secedits:\n                            ini_data = '\\r\\n'.join([ini_data, ''.join(['[', _seceditSection, ']']), '\\r\\n'.join(_secedits[_seceditSection])])\n                    ini_data = '\\r\\n'.join([ini_data, '[Version]', 'signature=\"$CHICAGO$\"', 'Revision=1'])\n                    log.trace('ini_data == %s', ini_data)\n                    if not _write_secedit_data(ini_data):\n                        raise CommandExecutionError('Error while attempting to set policies via secedit. Some changes may not be applied as expected')\n                if _netshs:\n                    for setting in _netshs:\n                        log.trace('Setting firewall policy: %s', setting)\n                        log.trace(_netshs[setting])\n                        _set_netsh_value(**_netshs[setting])\n                if _advaudits:\n                    for setting in _advaudits:\n                        log.trace('Setting Advanced Audit policy: %s', setting)\n                        log.trace(_advaudits[setting])\n                        _set_advaudit_value(**_advaudits[setting])\n                if _modal_sets:\n                    log.trace(_modal_sets)\n                    for _modal_set in _modal_sets:\n                        try:\n                            _existingModalData = win32net.NetUserModalsGet(None, _modal_set)\n                            _newModalSetData = dictupdate.update(_existingModalData, _modal_sets[_modal_set])\n                            log.trace('NEW MODAL SET = %s', _newModalSetData)\n                            _ret = win32net.NetUserModalsSet(None, _modal_set, _newModalSetData)\n                        except Exception as exc:\n                            msg = 'An unhandled exception occurred while attempting to set policy via NetUserModalSet\\n{}'.format(exc)\n                            log.exception(msg)\n                            raise CommandExecutionError(msg)\n                if _admTemplateData:\n                    _ret = False\n                    log.trace('going to write some adm template data :: %s', _admTemplateData)\n                    _ret = _writeAdminTemplateRegPolFile(_admTemplateData, adml_language=adml_language, registry_class=p_class)\n                    if not _ret:\n                        raise CommandExecutionError('Error while attempting to write Administrative Template Policy data.  Some changes may not be applied as expected')\n        return True\n    else:\n        raise SaltInvocationError('You have to specify something!')",
            "def set_(computer_policy=None, user_policy=None, cumulative_rights_assignments=True, adml_language='en-US'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Set a local server policy.\\n\\n    Args:\\n\\n        computer_policy (dict):\\n            A dictionary of \"policyname: value\" pairs of computer policies to\\n            set. \\'value\\' should be how it is displayed in the gpedit GUI, i.e.\\n            if a setting can be \\'Enabled\\'/\\'Disabled\\', then that should be passed\\n\\n            Administrative Template data may require dicts within dicts, to\\n            specify each element of the Administrative Template policy.\\n            Administrative Templates policies are always cumulative.\\n\\n            Policy names can be specified in a number of ways based on the type\\n            of policy:\\n\\n                Windows Settings Policies:\\n\\n                    These policies can be specified using the GUI display name\\n                    or the key name from the _policy_info class in this module.\\n                    The GUI display name is also contained in the _policy_info\\n                    class in this module.\\n\\n                Administrative Template Policies:\\n\\n                    These can be specified using the policy name as displayed in\\n                    the GUI (case sensitive). Some policies have the same name,\\n                    but a different location (for example, \"Access data sources\\n                    across domains\"). These can be differentiated by the \"path\"\\n                    in the GUI (for example, \"Windows Components\\\\Internet\\n                    Explorer\\\\Internet Control Panel\\\\Security Page\\\\Internet\\n                    Zone\\\\Access data sources across domains\").\\n\\n                    Additionally, policies can be specified using the \"name\" and\\n                    \"id\" attributes from the ADMX files.\\n\\n                    For Administrative Templates that have policy elements, each\\n                    element can be specified using the text string as seen in\\n                    the GUI or using the ID attribute from the ADMX file. Due to\\n                    the way some of the GUI text is laid out, some policy\\n                    element names could include descriptive text that appears\\n                    lbefore the policy element in the GUI.\\n\\n                    Use the get_policy_info function for the policy name to view\\n                    the element ID/names that the module will accept.\\n\\n        user_policy (dict):\\n            The same setup as the computer_policy, except with data to configure\\n            the local user policy.\\n\\n        cumulative_rights_assignments (bool):\\n            Determine how user rights assignment policies are configured.\\n\\n            If True, user right assignment specifications are simply added to\\n            the existing policy\\n\\n            If False, only the users specified will get the right (any existing\\n            will have the right revoked)\\n\\n        adml_language (str):\\n            The language files to use for looking up Administrative Template\\n            policy data (i.e. how the policy is displayed in the GUI). Defaults\\n            to \\'en-US\\' (U.S. English).\\n\\n    Returns:\\n        bool: True is successful, otherwise False\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' lgpo.set computer_policy=\"{\\'LockoutDuration\\': 2, \\'RestrictAnonymous\\': \\'Enabled\\', \\'AuditProcessTracking\\': \\'Succes, Failure\\'}\"\\n    '\n    if computer_policy and (not isinstance(computer_policy, dict)):\n        raise SaltInvocationError('computer_policy must be specified as a dict')\n    if user_policy and (not isinstance(user_policy, dict)):\n        raise SaltInvocationError('user_policy must be specified as a dict')\n    policies = {'User': user_policy, 'Machine': computer_policy}\n    if policies:\n        adml_policy_resources = _get_policy_resources(language=adml_language)\n        for p_class in policies:\n            _secedits = {}\n            _netshs = {}\n            _advaudits = {}\n            _modal_sets = {}\n            _admTemplateData = {}\n            _regedits = {}\n            _lsarights = {}\n            _policydata = _policy_info()\n            if policies[p_class]:\n                for policy_name in policies[p_class]:\n                    _pol = None\n                    policy_key_name = policy_name\n                    if policy_name in _policydata.policies[p_class]['policies']:\n                        _pol = _policydata.policies[p_class]['policies'][policy_name]\n                    else:\n                        for policy in _policydata.policies[p_class]['policies']:\n                            _p = _policydata.policies[p_class]['policies'][policy]['Policy']\n                            if _p == policy_name:\n                                _pol = _policydata.policies[p_class]['policies'][policy]\n                                policy_key_name = policy\n                        if _pol is None:\n                            for policy in _policydata.policies[p_class]['policies']:\n                                _p = _policydata.policies[p_class]['policies'][policy]['Policy']\n                                if _p.lower() == policy_name.lower():\n                                    _pol = _policydata.policies[p_class]['policies'][policy]\n                                    policy_key_name = policy\n                    if _pol:\n                        _value = _transform_value(value=policies[p_class][policy_name], policy=_policydata.policies[p_class]['policies'][policy_key_name], transform_type='Put')\n                        if not _validateSetting(value=_value, policy=_policydata.policies[p_class]['policies'][policy_key_name]):\n                            raise SaltInvocationError('The specified value {} is not an acceptable setting for policy {}.'.format(policies[p_class][policy_name], policy_name))\n                        if 'Registry' in _pol:\n                            log.trace('%s is a registry policy', policy_name)\n                            _regedits[policy_name] = {'policy': _pol, 'value': _value}\n                        elif 'Secedit' in _pol:\n                            log.trace('%s is a Secedit policy', policy_name)\n                            if _pol['Secedit']['Section'] not in _secedits:\n                                _secedits[_pol['Secedit']['Section']] = []\n                            _secedits[_pol['Secedit']['Section']].append(' '.join([_pol['Secedit']['Option'], '=', str(_value)]))\n                        elif 'NetSH' in _pol:\n                            log.trace('%s is a NetSH policy', policy_name)\n                            _netshs.setdefault(policy_name, {'profile': _pol['NetSH']['Profile'], 'section': _pol['NetSH']['Section'], 'option': _pol['NetSH']['Option'], 'value': str(_value)})\n                        elif 'AdvAudit' in _pol:\n                            _advaudits.setdefault(policy_name, {'option': _pol['AdvAudit']['Option'], 'value': str(_value)})\n                        elif 'NetUserModal' in _pol:\n                            log.trace('%s is a NetUserModal policy', policy_name)\n                            if _pol['NetUserModal']['Modal'] not in _modal_sets:\n                                _modal_sets[_pol['NetUserModal']['Modal']] = {}\n                            _modal_sets[_pol['NetUserModal']['Modal']][_pol['NetUserModal']['Option']] = _value\n                        elif 'LsaRights' in _pol:\n                            log.trace('%s is a LsaRights policy', policy_name)\n                            _lsarights[policy_name] = {'policy': _pol, 'value': _value}\n                    else:\n                        _value = policies[p_class][policy_name]\n                        log.trace('searching for \"%s\" in admx data', policy_name)\n                        (success, the_policy, policy_name_list, msg) = _lookup_admin_template(policy_name=policy_name, policy_class=p_class, adml_language=adml_language)\n                        if success:\n                            policy_name = the_policy.attrib['name']\n                            policy_namespace = the_policy.nsmap[the_policy.prefix]\n                            if policy_namespace not in _admTemplateData:\n                                _admTemplateData[policy_namespace] = {}\n                            _admTemplateData[policy_namespace][policy_name] = _value\n                        else:\n                            raise SaltInvocationError(msg)\n                        if policy_namespace and policy_name in _admTemplateData[policy_namespace] and (the_policy is not None):\n                            log.trace('setting == %s', str(_admTemplateData[policy_namespace][policy_name]).lower())\n                            log.trace(str(_admTemplateData[policy_namespace][policy_name]).lower())\n                            if str(_admTemplateData[policy_namespace][policy_name]).lower() != 'disabled' and str(_admTemplateData[policy_namespace][policy_name]).lower() != 'not configured':\n                                if ELEMENTS_XPATH(the_policy):\n                                    if isinstance(_admTemplateData[policy_namespace][policy_name], dict):\n                                        for elements_item in ELEMENTS_XPATH(the_policy):\n                                            for child_item in elements_item:\n                                                log.trace('checking element %s', child_item.attrib['id'])\n                                                temp_element_name = None\n                                                this_element_name = _getFullPolicyName(policy_item=child_item, policy_name=child_item.attrib['id'], return_full_policy_names=True, adml_language=adml_language)\n                                                log.trace('id attribute == \"%s\"  this_element_name == \"%s\"', child_item.attrib['id'], this_element_name)\n                                                if this_element_name in _admTemplateData[policy_namespace][policy_name]:\n                                                    temp_element_name = this_element_name\n                                                elif child_item.attrib['id'] in _admTemplateData[policy_namespace][policy_name]:\n                                                    temp_element_name = child_item.attrib['id']\n                                                else:\n                                                    raise SaltInvocationError('Element \"{}\" must be included in the policy configuration for policy {}'.format(this_element_name, policy_name))\n                                                if 'required' in child_item.attrib and child_item.attrib['required'].lower() == 'true':\n                                                    if not _admTemplateData[policy_namespace][policy_name][temp_element_name]:\n                                                        raise SaltInvocationError('Element \"{}\" requires a value to be specified'.format(temp_element_name))\n                                                if etree.QName(child_item).localname == 'boolean':\n                                                    if not isinstance(_admTemplateData[policy_namespace][policy_name][temp_element_name], bool):\n                                                        raise SaltInvocationError('Element {} requires a boolean True or False'.format(temp_element_name))\n                                                elif etree.QName(child_item).localname == 'decimal' or etree.QName(child_item).localname == 'longDecimal':\n                                                    min_val = 0\n                                                    max_val = 9999\n                                                    if 'minValue' in child_item.attrib:\n                                                        min_val = int(child_item.attrib['minValue'])\n                                                    if 'maxValue' in child_item.attrib:\n                                                        max_val = int(child_item.attrib['maxValue'])\n                                                    if int(_admTemplateData[policy_namespace][policy_name][temp_element_name]) < min_val or int(_admTemplateData[policy_namespace][policy_name][temp_element_name]) > max_val:\n                                                        raise SaltInvocationError('Element \"{}\" value must be between {} and {}'.format(temp_element_name, min_val, max_val))\n                                                elif etree.QName(child_item).localname == 'enum':\n                                                    found = False\n                                                    for enum_item in child_item:\n                                                        if _admTemplateData[policy_namespace][policy_name][temp_element_name] == _getAdmlDisplayName(adml_policy_resources, enum_item.attrib['displayName']).strip():\n                                                            found = True\n                                                            break\n                                                    if not found:\n                                                        raise SaltInvocationError('Element \"{}\" does not have a valid value'.format(temp_element_name))\n                                                elif etree.QName(child_item).localname == 'list':\n                                                    if 'explicitValue' in child_item.attrib and child_item.attrib['explicitValue'].lower() == 'true':\n                                                        if not isinstance(_admTemplateData[policy_namespace][policy_name][temp_element_name], dict):\n                                                            raise SaltInvocationError('Each list item of element \"{}\" requires a dict value'.format(temp_element_name))\n                                                    elif not isinstance(_admTemplateData[policy_namespace][policy_name][temp_element_name], list):\n                                                        raise SaltInvocationError('Element \"{}\" requires a list value'.format(temp_element_name))\n                                                elif etree.QName(child_item).localname == 'multiText':\n                                                    if not isinstance(_admTemplateData[policy_namespace][policy_name][temp_element_name], list):\n                                                        raise SaltInvocationError('Element \"{}\" requires a list value'.format(temp_element_name))\n                                                _admTemplateData[policy_namespace][policy_name][child_item.attrib['id']] = _admTemplateData[policy_namespace][policy_name].pop(temp_element_name)\n                                    else:\n                                        raise SaltInvocationError('The policy \"{}\" has elements which must be configured'.format(policy_name))\n                                elif str(_admTemplateData[policy_namespace][policy_name]).lower() != 'enabled':\n                                    raise SaltInvocationError('The policy {} must either be \"Enabled\", \"Disabled\", or \"Not Configured\"'.format(policy_name))\n                if _regedits:\n                    for regedit in _regedits:\n                        log.trace('%s is a Registry policy', regedit)\n                        if _regedits[regedit]['value'] is not None and _regedits[regedit]['value'] != '(value not set)':\n                            _ret = __utils__['reg.set_value'](_regedits[regedit]['policy']['Registry']['Hive'], _regedits[regedit]['policy']['Registry']['Path'], _regedits[regedit]['policy']['Registry']['Value'], _regedits[regedit]['value'], _regedits[regedit]['policy']['Registry']['Type'])\n                        else:\n                            _ret = __utils__['reg.read_value'](_regedits[regedit]['policy']['Registry']['Hive'], _regedits[regedit]['policy']['Registry']['Path'], _regedits[regedit]['policy']['Registry']['Value'])\n                            if _ret['success'] and _ret['vdata'] != '(value not set)':\n                                _ret = __utils__['reg.delete_value'](_regedits[regedit]['policy']['Registry']['Hive'], _regedits[regedit]['policy']['Registry']['Path'], _regedits[regedit]['policy']['Registry']['Value'])\n                        if not _ret:\n                            raise CommandExecutionError('Error while attempting to set policy {} via the registry.  Some changes may not be applied as expected'.format(regedit))\n                if _lsarights:\n                    for lsaright in _lsarights:\n                        _existingUsers = None\n                        if not cumulative_rights_assignments:\n                            _existingUsers = _getRightsAssignments(_lsarights[lsaright]['policy']['LsaRights']['Option'])\n                        if _lsarights[lsaright]['value']:\n                            for acct in _lsarights[lsaright]['value']:\n                                _ret = _addAccountRights(acct, _lsarights[lsaright]['policy']['LsaRights']['Option'])\n                                if not _ret:\n                                    raise SaltInvocationError('An error occurred attempting to configure the user right {}.'.format(lsaright))\n                        if _existingUsers:\n                            for acct in _existingUsers:\n                                if acct not in _lsarights[lsaright]['value']:\n                                    _ret = _delAccountRights(acct, _lsarights[lsaright]['policy']['LsaRights']['Option'])\n                                    if not _ret:\n                                        raise SaltInvocationError('An error occurred attempting to remove previously configured users with right {}.'.format(lsaright))\n                if _secedits:\n                    log.trace(_secedits)\n                    ini_data = '\\r\\n'.join(['[Unicode]', 'Unicode=yes'])\n                    _seceditSections = ['System Access', 'Event Audit', 'Registry Values', 'Privilege Rights']\n                    for _seceditSection in _seceditSections:\n                        if _seceditSection in _secedits:\n                            ini_data = '\\r\\n'.join([ini_data, ''.join(['[', _seceditSection, ']']), '\\r\\n'.join(_secedits[_seceditSection])])\n                    ini_data = '\\r\\n'.join([ini_data, '[Version]', 'signature=\"$CHICAGO$\"', 'Revision=1'])\n                    log.trace('ini_data == %s', ini_data)\n                    if not _write_secedit_data(ini_data):\n                        raise CommandExecutionError('Error while attempting to set policies via secedit. Some changes may not be applied as expected')\n                if _netshs:\n                    for setting in _netshs:\n                        log.trace('Setting firewall policy: %s', setting)\n                        log.trace(_netshs[setting])\n                        _set_netsh_value(**_netshs[setting])\n                if _advaudits:\n                    for setting in _advaudits:\n                        log.trace('Setting Advanced Audit policy: %s', setting)\n                        log.trace(_advaudits[setting])\n                        _set_advaudit_value(**_advaudits[setting])\n                if _modal_sets:\n                    log.trace(_modal_sets)\n                    for _modal_set in _modal_sets:\n                        try:\n                            _existingModalData = win32net.NetUserModalsGet(None, _modal_set)\n                            _newModalSetData = dictupdate.update(_existingModalData, _modal_sets[_modal_set])\n                            log.trace('NEW MODAL SET = %s', _newModalSetData)\n                            _ret = win32net.NetUserModalsSet(None, _modal_set, _newModalSetData)\n                        except Exception as exc:\n                            msg = 'An unhandled exception occurred while attempting to set policy via NetUserModalSet\\n{}'.format(exc)\n                            log.exception(msg)\n                            raise CommandExecutionError(msg)\n                if _admTemplateData:\n                    _ret = False\n                    log.trace('going to write some adm template data :: %s', _admTemplateData)\n                    _ret = _writeAdminTemplateRegPolFile(_admTemplateData, adml_language=adml_language, registry_class=p_class)\n                    if not _ret:\n                        raise CommandExecutionError('Error while attempting to write Administrative Template Policy data.  Some changes may not be applied as expected')\n        return True\n    else:\n        raise SaltInvocationError('You have to specify something!')",
            "def set_(computer_policy=None, user_policy=None, cumulative_rights_assignments=True, adml_language='en-US'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Set a local server policy.\\n\\n    Args:\\n\\n        computer_policy (dict):\\n            A dictionary of \"policyname: value\" pairs of computer policies to\\n            set. \\'value\\' should be how it is displayed in the gpedit GUI, i.e.\\n            if a setting can be \\'Enabled\\'/\\'Disabled\\', then that should be passed\\n\\n            Administrative Template data may require dicts within dicts, to\\n            specify each element of the Administrative Template policy.\\n            Administrative Templates policies are always cumulative.\\n\\n            Policy names can be specified in a number of ways based on the type\\n            of policy:\\n\\n                Windows Settings Policies:\\n\\n                    These policies can be specified using the GUI display name\\n                    or the key name from the _policy_info class in this module.\\n                    The GUI display name is also contained in the _policy_info\\n                    class in this module.\\n\\n                Administrative Template Policies:\\n\\n                    These can be specified using the policy name as displayed in\\n                    the GUI (case sensitive). Some policies have the same name,\\n                    but a different location (for example, \"Access data sources\\n                    across domains\"). These can be differentiated by the \"path\"\\n                    in the GUI (for example, \"Windows Components\\\\Internet\\n                    Explorer\\\\Internet Control Panel\\\\Security Page\\\\Internet\\n                    Zone\\\\Access data sources across domains\").\\n\\n                    Additionally, policies can be specified using the \"name\" and\\n                    \"id\" attributes from the ADMX files.\\n\\n                    For Administrative Templates that have policy elements, each\\n                    element can be specified using the text string as seen in\\n                    the GUI or using the ID attribute from the ADMX file. Due to\\n                    the way some of the GUI text is laid out, some policy\\n                    element names could include descriptive text that appears\\n                    lbefore the policy element in the GUI.\\n\\n                    Use the get_policy_info function for the policy name to view\\n                    the element ID/names that the module will accept.\\n\\n        user_policy (dict):\\n            The same setup as the computer_policy, except with data to configure\\n            the local user policy.\\n\\n        cumulative_rights_assignments (bool):\\n            Determine how user rights assignment policies are configured.\\n\\n            If True, user right assignment specifications are simply added to\\n            the existing policy\\n\\n            If False, only the users specified will get the right (any existing\\n            will have the right revoked)\\n\\n        adml_language (str):\\n            The language files to use for looking up Administrative Template\\n            policy data (i.e. how the policy is displayed in the GUI). Defaults\\n            to \\'en-US\\' (U.S. English).\\n\\n    Returns:\\n        bool: True is successful, otherwise False\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' lgpo.set computer_policy=\"{\\'LockoutDuration\\': 2, \\'RestrictAnonymous\\': \\'Enabled\\', \\'AuditProcessTracking\\': \\'Succes, Failure\\'}\"\\n    '\n    if computer_policy and (not isinstance(computer_policy, dict)):\n        raise SaltInvocationError('computer_policy must be specified as a dict')\n    if user_policy and (not isinstance(user_policy, dict)):\n        raise SaltInvocationError('user_policy must be specified as a dict')\n    policies = {'User': user_policy, 'Machine': computer_policy}\n    if policies:\n        adml_policy_resources = _get_policy_resources(language=adml_language)\n        for p_class in policies:\n            _secedits = {}\n            _netshs = {}\n            _advaudits = {}\n            _modal_sets = {}\n            _admTemplateData = {}\n            _regedits = {}\n            _lsarights = {}\n            _policydata = _policy_info()\n            if policies[p_class]:\n                for policy_name in policies[p_class]:\n                    _pol = None\n                    policy_key_name = policy_name\n                    if policy_name in _policydata.policies[p_class]['policies']:\n                        _pol = _policydata.policies[p_class]['policies'][policy_name]\n                    else:\n                        for policy in _policydata.policies[p_class]['policies']:\n                            _p = _policydata.policies[p_class]['policies'][policy]['Policy']\n                            if _p == policy_name:\n                                _pol = _policydata.policies[p_class]['policies'][policy]\n                                policy_key_name = policy\n                        if _pol is None:\n                            for policy in _policydata.policies[p_class]['policies']:\n                                _p = _policydata.policies[p_class]['policies'][policy]['Policy']\n                                if _p.lower() == policy_name.lower():\n                                    _pol = _policydata.policies[p_class]['policies'][policy]\n                                    policy_key_name = policy\n                    if _pol:\n                        _value = _transform_value(value=policies[p_class][policy_name], policy=_policydata.policies[p_class]['policies'][policy_key_name], transform_type='Put')\n                        if not _validateSetting(value=_value, policy=_policydata.policies[p_class]['policies'][policy_key_name]):\n                            raise SaltInvocationError('The specified value {} is not an acceptable setting for policy {}.'.format(policies[p_class][policy_name], policy_name))\n                        if 'Registry' in _pol:\n                            log.trace('%s is a registry policy', policy_name)\n                            _regedits[policy_name] = {'policy': _pol, 'value': _value}\n                        elif 'Secedit' in _pol:\n                            log.trace('%s is a Secedit policy', policy_name)\n                            if _pol['Secedit']['Section'] not in _secedits:\n                                _secedits[_pol['Secedit']['Section']] = []\n                            _secedits[_pol['Secedit']['Section']].append(' '.join([_pol['Secedit']['Option'], '=', str(_value)]))\n                        elif 'NetSH' in _pol:\n                            log.trace('%s is a NetSH policy', policy_name)\n                            _netshs.setdefault(policy_name, {'profile': _pol['NetSH']['Profile'], 'section': _pol['NetSH']['Section'], 'option': _pol['NetSH']['Option'], 'value': str(_value)})\n                        elif 'AdvAudit' in _pol:\n                            _advaudits.setdefault(policy_name, {'option': _pol['AdvAudit']['Option'], 'value': str(_value)})\n                        elif 'NetUserModal' in _pol:\n                            log.trace('%s is a NetUserModal policy', policy_name)\n                            if _pol['NetUserModal']['Modal'] not in _modal_sets:\n                                _modal_sets[_pol['NetUserModal']['Modal']] = {}\n                            _modal_sets[_pol['NetUserModal']['Modal']][_pol['NetUserModal']['Option']] = _value\n                        elif 'LsaRights' in _pol:\n                            log.trace('%s is a LsaRights policy', policy_name)\n                            _lsarights[policy_name] = {'policy': _pol, 'value': _value}\n                    else:\n                        _value = policies[p_class][policy_name]\n                        log.trace('searching for \"%s\" in admx data', policy_name)\n                        (success, the_policy, policy_name_list, msg) = _lookup_admin_template(policy_name=policy_name, policy_class=p_class, adml_language=adml_language)\n                        if success:\n                            policy_name = the_policy.attrib['name']\n                            policy_namespace = the_policy.nsmap[the_policy.prefix]\n                            if policy_namespace not in _admTemplateData:\n                                _admTemplateData[policy_namespace] = {}\n                            _admTemplateData[policy_namespace][policy_name] = _value\n                        else:\n                            raise SaltInvocationError(msg)\n                        if policy_namespace and policy_name in _admTemplateData[policy_namespace] and (the_policy is not None):\n                            log.trace('setting == %s', str(_admTemplateData[policy_namespace][policy_name]).lower())\n                            log.trace(str(_admTemplateData[policy_namespace][policy_name]).lower())\n                            if str(_admTemplateData[policy_namespace][policy_name]).lower() != 'disabled' and str(_admTemplateData[policy_namespace][policy_name]).lower() != 'not configured':\n                                if ELEMENTS_XPATH(the_policy):\n                                    if isinstance(_admTemplateData[policy_namespace][policy_name], dict):\n                                        for elements_item in ELEMENTS_XPATH(the_policy):\n                                            for child_item in elements_item:\n                                                log.trace('checking element %s', child_item.attrib['id'])\n                                                temp_element_name = None\n                                                this_element_name = _getFullPolicyName(policy_item=child_item, policy_name=child_item.attrib['id'], return_full_policy_names=True, adml_language=adml_language)\n                                                log.trace('id attribute == \"%s\"  this_element_name == \"%s\"', child_item.attrib['id'], this_element_name)\n                                                if this_element_name in _admTemplateData[policy_namespace][policy_name]:\n                                                    temp_element_name = this_element_name\n                                                elif child_item.attrib['id'] in _admTemplateData[policy_namespace][policy_name]:\n                                                    temp_element_name = child_item.attrib['id']\n                                                else:\n                                                    raise SaltInvocationError('Element \"{}\" must be included in the policy configuration for policy {}'.format(this_element_name, policy_name))\n                                                if 'required' in child_item.attrib and child_item.attrib['required'].lower() == 'true':\n                                                    if not _admTemplateData[policy_namespace][policy_name][temp_element_name]:\n                                                        raise SaltInvocationError('Element \"{}\" requires a value to be specified'.format(temp_element_name))\n                                                if etree.QName(child_item).localname == 'boolean':\n                                                    if not isinstance(_admTemplateData[policy_namespace][policy_name][temp_element_name], bool):\n                                                        raise SaltInvocationError('Element {} requires a boolean True or False'.format(temp_element_name))\n                                                elif etree.QName(child_item).localname == 'decimal' or etree.QName(child_item).localname == 'longDecimal':\n                                                    min_val = 0\n                                                    max_val = 9999\n                                                    if 'minValue' in child_item.attrib:\n                                                        min_val = int(child_item.attrib['minValue'])\n                                                    if 'maxValue' in child_item.attrib:\n                                                        max_val = int(child_item.attrib['maxValue'])\n                                                    if int(_admTemplateData[policy_namespace][policy_name][temp_element_name]) < min_val or int(_admTemplateData[policy_namespace][policy_name][temp_element_name]) > max_val:\n                                                        raise SaltInvocationError('Element \"{}\" value must be between {} and {}'.format(temp_element_name, min_val, max_val))\n                                                elif etree.QName(child_item).localname == 'enum':\n                                                    found = False\n                                                    for enum_item in child_item:\n                                                        if _admTemplateData[policy_namespace][policy_name][temp_element_name] == _getAdmlDisplayName(adml_policy_resources, enum_item.attrib['displayName']).strip():\n                                                            found = True\n                                                            break\n                                                    if not found:\n                                                        raise SaltInvocationError('Element \"{}\" does not have a valid value'.format(temp_element_name))\n                                                elif etree.QName(child_item).localname == 'list':\n                                                    if 'explicitValue' in child_item.attrib and child_item.attrib['explicitValue'].lower() == 'true':\n                                                        if not isinstance(_admTemplateData[policy_namespace][policy_name][temp_element_name], dict):\n                                                            raise SaltInvocationError('Each list item of element \"{}\" requires a dict value'.format(temp_element_name))\n                                                    elif not isinstance(_admTemplateData[policy_namespace][policy_name][temp_element_name], list):\n                                                        raise SaltInvocationError('Element \"{}\" requires a list value'.format(temp_element_name))\n                                                elif etree.QName(child_item).localname == 'multiText':\n                                                    if not isinstance(_admTemplateData[policy_namespace][policy_name][temp_element_name], list):\n                                                        raise SaltInvocationError('Element \"{}\" requires a list value'.format(temp_element_name))\n                                                _admTemplateData[policy_namespace][policy_name][child_item.attrib['id']] = _admTemplateData[policy_namespace][policy_name].pop(temp_element_name)\n                                    else:\n                                        raise SaltInvocationError('The policy \"{}\" has elements which must be configured'.format(policy_name))\n                                elif str(_admTemplateData[policy_namespace][policy_name]).lower() != 'enabled':\n                                    raise SaltInvocationError('The policy {} must either be \"Enabled\", \"Disabled\", or \"Not Configured\"'.format(policy_name))\n                if _regedits:\n                    for regedit in _regedits:\n                        log.trace('%s is a Registry policy', regedit)\n                        if _regedits[regedit]['value'] is not None and _regedits[regedit]['value'] != '(value not set)':\n                            _ret = __utils__['reg.set_value'](_regedits[regedit]['policy']['Registry']['Hive'], _regedits[regedit]['policy']['Registry']['Path'], _regedits[regedit]['policy']['Registry']['Value'], _regedits[regedit]['value'], _regedits[regedit]['policy']['Registry']['Type'])\n                        else:\n                            _ret = __utils__['reg.read_value'](_regedits[regedit]['policy']['Registry']['Hive'], _regedits[regedit]['policy']['Registry']['Path'], _regedits[regedit]['policy']['Registry']['Value'])\n                            if _ret['success'] and _ret['vdata'] != '(value not set)':\n                                _ret = __utils__['reg.delete_value'](_regedits[regedit]['policy']['Registry']['Hive'], _regedits[regedit]['policy']['Registry']['Path'], _regedits[regedit]['policy']['Registry']['Value'])\n                        if not _ret:\n                            raise CommandExecutionError('Error while attempting to set policy {} via the registry.  Some changes may not be applied as expected'.format(regedit))\n                if _lsarights:\n                    for lsaright in _lsarights:\n                        _existingUsers = None\n                        if not cumulative_rights_assignments:\n                            _existingUsers = _getRightsAssignments(_lsarights[lsaright]['policy']['LsaRights']['Option'])\n                        if _lsarights[lsaright]['value']:\n                            for acct in _lsarights[lsaright]['value']:\n                                _ret = _addAccountRights(acct, _lsarights[lsaright]['policy']['LsaRights']['Option'])\n                                if not _ret:\n                                    raise SaltInvocationError('An error occurred attempting to configure the user right {}.'.format(lsaright))\n                        if _existingUsers:\n                            for acct in _existingUsers:\n                                if acct not in _lsarights[lsaright]['value']:\n                                    _ret = _delAccountRights(acct, _lsarights[lsaright]['policy']['LsaRights']['Option'])\n                                    if not _ret:\n                                        raise SaltInvocationError('An error occurred attempting to remove previously configured users with right {}.'.format(lsaright))\n                if _secedits:\n                    log.trace(_secedits)\n                    ini_data = '\\r\\n'.join(['[Unicode]', 'Unicode=yes'])\n                    _seceditSections = ['System Access', 'Event Audit', 'Registry Values', 'Privilege Rights']\n                    for _seceditSection in _seceditSections:\n                        if _seceditSection in _secedits:\n                            ini_data = '\\r\\n'.join([ini_data, ''.join(['[', _seceditSection, ']']), '\\r\\n'.join(_secedits[_seceditSection])])\n                    ini_data = '\\r\\n'.join([ini_data, '[Version]', 'signature=\"$CHICAGO$\"', 'Revision=1'])\n                    log.trace('ini_data == %s', ini_data)\n                    if not _write_secedit_data(ini_data):\n                        raise CommandExecutionError('Error while attempting to set policies via secedit. Some changes may not be applied as expected')\n                if _netshs:\n                    for setting in _netshs:\n                        log.trace('Setting firewall policy: %s', setting)\n                        log.trace(_netshs[setting])\n                        _set_netsh_value(**_netshs[setting])\n                if _advaudits:\n                    for setting in _advaudits:\n                        log.trace('Setting Advanced Audit policy: %s', setting)\n                        log.trace(_advaudits[setting])\n                        _set_advaudit_value(**_advaudits[setting])\n                if _modal_sets:\n                    log.trace(_modal_sets)\n                    for _modal_set in _modal_sets:\n                        try:\n                            _existingModalData = win32net.NetUserModalsGet(None, _modal_set)\n                            _newModalSetData = dictupdate.update(_existingModalData, _modal_sets[_modal_set])\n                            log.trace('NEW MODAL SET = %s', _newModalSetData)\n                            _ret = win32net.NetUserModalsSet(None, _modal_set, _newModalSetData)\n                        except Exception as exc:\n                            msg = 'An unhandled exception occurred while attempting to set policy via NetUserModalSet\\n{}'.format(exc)\n                            log.exception(msg)\n                            raise CommandExecutionError(msg)\n                if _admTemplateData:\n                    _ret = False\n                    log.trace('going to write some adm template data :: %s', _admTemplateData)\n                    _ret = _writeAdminTemplateRegPolFile(_admTemplateData, adml_language=adml_language, registry_class=p_class)\n                    if not _ret:\n                        raise CommandExecutionError('Error while attempting to write Administrative Template Policy data.  Some changes may not be applied as expected')\n        return True\n    else:\n        raise SaltInvocationError('You have to specify something!')",
            "def set_(computer_policy=None, user_policy=None, cumulative_rights_assignments=True, adml_language='en-US'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Set a local server policy.\\n\\n    Args:\\n\\n        computer_policy (dict):\\n            A dictionary of \"policyname: value\" pairs of computer policies to\\n            set. \\'value\\' should be how it is displayed in the gpedit GUI, i.e.\\n            if a setting can be \\'Enabled\\'/\\'Disabled\\', then that should be passed\\n\\n            Administrative Template data may require dicts within dicts, to\\n            specify each element of the Administrative Template policy.\\n            Administrative Templates policies are always cumulative.\\n\\n            Policy names can be specified in a number of ways based on the type\\n            of policy:\\n\\n                Windows Settings Policies:\\n\\n                    These policies can be specified using the GUI display name\\n                    or the key name from the _policy_info class in this module.\\n                    The GUI display name is also contained in the _policy_info\\n                    class in this module.\\n\\n                Administrative Template Policies:\\n\\n                    These can be specified using the policy name as displayed in\\n                    the GUI (case sensitive). Some policies have the same name,\\n                    but a different location (for example, \"Access data sources\\n                    across domains\"). These can be differentiated by the \"path\"\\n                    in the GUI (for example, \"Windows Components\\\\Internet\\n                    Explorer\\\\Internet Control Panel\\\\Security Page\\\\Internet\\n                    Zone\\\\Access data sources across domains\").\\n\\n                    Additionally, policies can be specified using the \"name\" and\\n                    \"id\" attributes from the ADMX files.\\n\\n                    For Administrative Templates that have policy elements, each\\n                    element can be specified using the text string as seen in\\n                    the GUI or using the ID attribute from the ADMX file. Due to\\n                    the way some of the GUI text is laid out, some policy\\n                    element names could include descriptive text that appears\\n                    lbefore the policy element in the GUI.\\n\\n                    Use the get_policy_info function for the policy name to view\\n                    the element ID/names that the module will accept.\\n\\n        user_policy (dict):\\n            The same setup as the computer_policy, except with data to configure\\n            the local user policy.\\n\\n        cumulative_rights_assignments (bool):\\n            Determine how user rights assignment policies are configured.\\n\\n            If True, user right assignment specifications are simply added to\\n            the existing policy\\n\\n            If False, only the users specified will get the right (any existing\\n            will have the right revoked)\\n\\n        adml_language (str):\\n            The language files to use for looking up Administrative Template\\n            policy data (i.e. how the policy is displayed in the GUI). Defaults\\n            to \\'en-US\\' (U.S. English).\\n\\n    Returns:\\n        bool: True is successful, otherwise False\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' lgpo.set computer_policy=\"{\\'LockoutDuration\\': 2, \\'RestrictAnonymous\\': \\'Enabled\\', \\'AuditProcessTracking\\': \\'Succes, Failure\\'}\"\\n    '\n    if computer_policy and (not isinstance(computer_policy, dict)):\n        raise SaltInvocationError('computer_policy must be specified as a dict')\n    if user_policy and (not isinstance(user_policy, dict)):\n        raise SaltInvocationError('user_policy must be specified as a dict')\n    policies = {'User': user_policy, 'Machine': computer_policy}\n    if policies:\n        adml_policy_resources = _get_policy_resources(language=adml_language)\n        for p_class in policies:\n            _secedits = {}\n            _netshs = {}\n            _advaudits = {}\n            _modal_sets = {}\n            _admTemplateData = {}\n            _regedits = {}\n            _lsarights = {}\n            _policydata = _policy_info()\n            if policies[p_class]:\n                for policy_name in policies[p_class]:\n                    _pol = None\n                    policy_key_name = policy_name\n                    if policy_name in _policydata.policies[p_class]['policies']:\n                        _pol = _policydata.policies[p_class]['policies'][policy_name]\n                    else:\n                        for policy in _policydata.policies[p_class]['policies']:\n                            _p = _policydata.policies[p_class]['policies'][policy]['Policy']\n                            if _p == policy_name:\n                                _pol = _policydata.policies[p_class]['policies'][policy]\n                                policy_key_name = policy\n                        if _pol is None:\n                            for policy in _policydata.policies[p_class]['policies']:\n                                _p = _policydata.policies[p_class]['policies'][policy]['Policy']\n                                if _p.lower() == policy_name.lower():\n                                    _pol = _policydata.policies[p_class]['policies'][policy]\n                                    policy_key_name = policy\n                    if _pol:\n                        _value = _transform_value(value=policies[p_class][policy_name], policy=_policydata.policies[p_class]['policies'][policy_key_name], transform_type='Put')\n                        if not _validateSetting(value=_value, policy=_policydata.policies[p_class]['policies'][policy_key_name]):\n                            raise SaltInvocationError('The specified value {} is not an acceptable setting for policy {}.'.format(policies[p_class][policy_name], policy_name))\n                        if 'Registry' in _pol:\n                            log.trace('%s is a registry policy', policy_name)\n                            _regedits[policy_name] = {'policy': _pol, 'value': _value}\n                        elif 'Secedit' in _pol:\n                            log.trace('%s is a Secedit policy', policy_name)\n                            if _pol['Secedit']['Section'] not in _secedits:\n                                _secedits[_pol['Secedit']['Section']] = []\n                            _secedits[_pol['Secedit']['Section']].append(' '.join([_pol['Secedit']['Option'], '=', str(_value)]))\n                        elif 'NetSH' in _pol:\n                            log.trace('%s is a NetSH policy', policy_name)\n                            _netshs.setdefault(policy_name, {'profile': _pol['NetSH']['Profile'], 'section': _pol['NetSH']['Section'], 'option': _pol['NetSH']['Option'], 'value': str(_value)})\n                        elif 'AdvAudit' in _pol:\n                            _advaudits.setdefault(policy_name, {'option': _pol['AdvAudit']['Option'], 'value': str(_value)})\n                        elif 'NetUserModal' in _pol:\n                            log.trace('%s is a NetUserModal policy', policy_name)\n                            if _pol['NetUserModal']['Modal'] not in _modal_sets:\n                                _modal_sets[_pol['NetUserModal']['Modal']] = {}\n                            _modal_sets[_pol['NetUserModal']['Modal']][_pol['NetUserModal']['Option']] = _value\n                        elif 'LsaRights' in _pol:\n                            log.trace('%s is a LsaRights policy', policy_name)\n                            _lsarights[policy_name] = {'policy': _pol, 'value': _value}\n                    else:\n                        _value = policies[p_class][policy_name]\n                        log.trace('searching for \"%s\" in admx data', policy_name)\n                        (success, the_policy, policy_name_list, msg) = _lookup_admin_template(policy_name=policy_name, policy_class=p_class, adml_language=adml_language)\n                        if success:\n                            policy_name = the_policy.attrib['name']\n                            policy_namespace = the_policy.nsmap[the_policy.prefix]\n                            if policy_namespace not in _admTemplateData:\n                                _admTemplateData[policy_namespace] = {}\n                            _admTemplateData[policy_namespace][policy_name] = _value\n                        else:\n                            raise SaltInvocationError(msg)\n                        if policy_namespace and policy_name in _admTemplateData[policy_namespace] and (the_policy is not None):\n                            log.trace('setting == %s', str(_admTemplateData[policy_namespace][policy_name]).lower())\n                            log.trace(str(_admTemplateData[policy_namespace][policy_name]).lower())\n                            if str(_admTemplateData[policy_namespace][policy_name]).lower() != 'disabled' and str(_admTemplateData[policy_namespace][policy_name]).lower() != 'not configured':\n                                if ELEMENTS_XPATH(the_policy):\n                                    if isinstance(_admTemplateData[policy_namespace][policy_name], dict):\n                                        for elements_item in ELEMENTS_XPATH(the_policy):\n                                            for child_item in elements_item:\n                                                log.trace('checking element %s', child_item.attrib['id'])\n                                                temp_element_name = None\n                                                this_element_name = _getFullPolicyName(policy_item=child_item, policy_name=child_item.attrib['id'], return_full_policy_names=True, adml_language=adml_language)\n                                                log.trace('id attribute == \"%s\"  this_element_name == \"%s\"', child_item.attrib['id'], this_element_name)\n                                                if this_element_name in _admTemplateData[policy_namespace][policy_name]:\n                                                    temp_element_name = this_element_name\n                                                elif child_item.attrib['id'] in _admTemplateData[policy_namespace][policy_name]:\n                                                    temp_element_name = child_item.attrib['id']\n                                                else:\n                                                    raise SaltInvocationError('Element \"{}\" must be included in the policy configuration for policy {}'.format(this_element_name, policy_name))\n                                                if 'required' in child_item.attrib and child_item.attrib['required'].lower() == 'true':\n                                                    if not _admTemplateData[policy_namespace][policy_name][temp_element_name]:\n                                                        raise SaltInvocationError('Element \"{}\" requires a value to be specified'.format(temp_element_name))\n                                                if etree.QName(child_item).localname == 'boolean':\n                                                    if not isinstance(_admTemplateData[policy_namespace][policy_name][temp_element_name], bool):\n                                                        raise SaltInvocationError('Element {} requires a boolean True or False'.format(temp_element_name))\n                                                elif etree.QName(child_item).localname == 'decimal' or etree.QName(child_item).localname == 'longDecimal':\n                                                    min_val = 0\n                                                    max_val = 9999\n                                                    if 'minValue' in child_item.attrib:\n                                                        min_val = int(child_item.attrib['minValue'])\n                                                    if 'maxValue' in child_item.attrib:\n                                                        max_val = int(child_item.attrib['maxValue'])\n                                                    if int(_admTemplateData[policy_namespace][policy_name][temp_element_name]) < min_val or int(_admTemplateData[policy_namespace][policy_name][temp_element_name]) > max_val:\n                                                        raise SaltInvocationError('Element \"{}\" value must be between {} and {}'.format(temp_element_name, min_val, max_val))\n                                                elif etree.QName(child_item).localname == 'enum':\n                                                    found = False\n                                                    for enum_item in child_item:\n                                                        if _admTemplateData[policy_namespace][policy_name][temp_element_name] == _getAdmlDisplayName(adml_policy_resources, enum_item.attrib['displayName']).strip():\n                                                            found = True\n                                                            break\n                                                    if not found:\n                                                        raise SaltInvocationError('Element \"{}\" does not have a valid value'.format(temp_element_name))\n                                                elif etree.QName(child_item).localname == 'list':\n                                                    if 'explicitValue' in child_item.attrib and child_item.attrib['explicitValue'].lower() == 'true':\n                                                        if not isinstance(_admTemplateData[policy_namespace][policy_name][temp_element_name], dict):\n                                                            raise SaltInvocationError('Each list item of element \"{}\" requires a dict value'.format(temp_element_name))\n                                                    elif not isinstance(_admTemplateData[policy_namespace][policy_name][temp_element_name], list):\n                                                        raise SaltInvocationError('Element \"{}\" requires a list value'.format(temp_element_name))\n                                                elif etree.QName(child_item).localname == 'multiText':\n                                                    if not isinstance(_admTemplateData[policy_namespace][policy_name][temp_element_name], list):\n                                                        raise SaltInvocationError('Element \"{}\" requires a list value'.format(temp_element_name))\n                                                _admTemplateData[policy_namespace][policy_name][child_item.attrib['id']] = _admTemplateData[policy_namespace][policy_name].pop(temp_element_name)\n                                    else:\n                                        raise SaltInvocationError('The policy \"{}\" has elements which must be configured'.format(policy_name))\n                                elif str(_admTemplateData[policy_namespace][policy_name]).lower() != 'enabled':\n                                    raise SaltInvocationError('The policy {} must either be \"Enabled\", \"Disabled\", or \"Not Configured\"'.format(policy_name))\n                if _regedits:\n                    for regedit in _regedits:\n                        log.trace('%s is a Registry policy', regedit)\n                        if _regedits[regedit]['value'] is not None and _regedits[regedit]['value'] != '(value not set)':\n                            _ret = __utils__['reg.set_value'](_regedits[regedit]['policy']['Registry']['Hive'], _regedits[regedit]['policy']['Registry']['Path'], _regedits[regedit]['policy']['Registry']['Value'], _regedits[regedit]['value'], _regedits[regedit]['policy']['Registry']['Type'])\n                        else:\n                            _ret = __utils__['reg.read_value'](_regedits[regedit]['policy']['Registry']['Hive'], _regedits[regedit]['policy']['Registry']['Path'], _regedits[regedit]['policy']['Registry']['Value'])\n                            if _ret['success'] and _ret['vdata'] != '(value not set)':\n                                _ret = __utils__['reg.delete_value'](_regedits[regedit]['policy']['Registry']['Hive'], _regedits[regedit]['policy']['Registry']['Path'], _regedits[regedit]['policy']['Registry']['Value'])\n                        if not _ret:\n                            raise CommandExecutionError('Error while attempting to set policy {} via the registry.  Some changes may not be applied as expected'.format(regedit))\n                if _lsarights:\n                    for lsaright in _lsarights:\n                        _existingUsers = None\n                        if not cumulative_rights_assignments:\n                            _existingUsers = _getRightsAssignments(_lsarights[lsaright]['policy']['LsaRights']['Option'])\n                        if _lsarights[lsaright]['value']:\n                            for acct in _lsarights[lsaright]['value']:\n                                _ret = _addAccountRights(acct, _lsarights[lsaright]['policy']['LsaRights']['Option'])\n                                if not _ret:\n                                    raise SaltInvocationError('An error occurred attempting to configure the user right {}.'.format(lsaright))\n                        if _existingUsers:\n                            for acct in _existingUsers:\n                                if acct not in _lsarights[lsaright]['value']:\n                                    _ret = _delAccountRights(acct, _lsarights[lsaright]['policy']['LsaRights']['Option'])\n                                    if not _ret:\n                                        raise SaltInvocationError('An error occurred attempting to remove previously configured users with right {}.'.format(lsaright))\n                if _secedits:\n                    log.trace(_secedits)\n                    ini_data = '\\r\\n'.join(['[Unicode]', 'Unicode=yes'])\n                    _seceditSections = ['System Access', 'Event Audit', 'Registry Values', 'Privilege Rights']\n                    for _seceditSection in _seceditSections:\n                        if _seceditSection in _secedits:\n                            ini_data = '\\r\\n'.join([ini_data, ''.join(['[', _seceditSection, ']']), '\\r\\n'.join(_secedits[_seceditSection])])\n                    ini_data = '\\r\\n'.join([ini_data, '[Version]', 'signature=\"$CHICAGO$\"', 'Revision=1'])\n                    log.trace('ini_data == %s', ini_data)\n                    if not _write_secedit_data(ini_data):\n                        raise CommandExecutionError('Error while attempting to set policies via secedit. Some changes may not be applied as expected')\n                if _netshs:\n                    for setting in _netshs:\n                        log.trace('Setting firewall policy: %s', setting)\n                        log.trace(_netshs[setting])\n                        _set_netsh_value(**_netshs[setting])\n                if _advaudits:\n                    for setting in _advaudits:\n                        log.trace('Setting Advanced Audit policy: %s', setting)\n                        log.trace(_advaudits[setting])\n                        _set_advaudit_value(**_advaudits[setting])\n                if _modal_sets:\n                    log.trace(_modal_sets)\n                    for _modal_set in _modal_sets:\n                        try:\n                            _existingModalData = win32net.NetUserModalsGet(None, _modal_set)\n                            _newModalSetData = dictupdate.update(_existingModalData, _modal_sets[_modal_set])\n                            log.trace('NEW MODAL SET = %s', _newModalSetData)\n                            _ret = win32net.NetUserModalsSet(None, _modal_set, _newModalSetData)\n                        except Exception as exc:\n                            msg = 'An unhandled exception occurred while attempting to set policy via NetUserModalSet\\n{}'.format(exc)\n                            log.exception(msg)\n                            raise CommandExecutionError(msg)\n                if _admTemplateData:\n                    _ret = False\n                    log.trace('going to write some adm template data :: %s', _admTemplateData)\n                    _ret = _writeAdminTemplateRegPolFile(_admTemplateData, adml_language=adml_language, registry_class=p_class)\n                    if not _ret:\n                        raise CommandExecutionError('Error while attempting to write Administrative Template Policy data.  Some changes may not be applied as expected')\n        return True\n    else:\n        raise SaltInvocationError('You have to specify something!')"
        ]
    }
]