"""Functions for solving linear parabolic PDEs."""
import tensorflow.compat.v2 as tf
from tf_quant_finance import utils
from tf_quant_finance.math.pde.steppers.douglas_adi import douglas_adi_step
from tf_quant_finance.math.pde.steppers.oscillation_damped_crank_nicolson import oscillation_damped_crank_nicolson_step

def solve_backward(start_time, end_time, coord_grid, values_grid, num_steps=None, start_step_count=0, time_step=None, one_step_fn=None, boundary_conditions=None, values_transform_fn=None, second_order_coeff_fn=None, first_order_coeff_fn=None, zeroth_order_coeff_fn=None, inner_second_order_coeff_fn=None, inner_first_order_coeff_fn=None, maximum_steps=None, swap_memory=True, dtype=None, name=None):
    if False:
        return 10
    "Evolves a grid of function values backwards in time according to a PDE.\n\n  Evolves a discretized solution of following second order linear\n  partial differential equation:\n\n  ```None\n    dV/dt + Sum[a_ij d2(A_ij V)/dx_i dx_j, 0 <= i, j <=n-1] +\n       Sum[b_i d(B_i V)/dx_i, 0 <= i <= n-1] + c V = 0.\n  ```\n  from time `t0` to time `t1<t0` (i.e. backwards in time). Here `a_ij`,\n  `A_ij`, `b_i`, `B_i` and `c` are coefficients that may depend on spatial\n  variables `x` and time `t`.\n\n  The solution `V(t,x)` is assumed to be discretized on an `n`-dimensional\n  rectangular grid. A rectangular grid, G, in n-dimensions may be described\n  by specifying the coordinates of the points along each axis. For example,\n  a 2 x 4 grid in two dimensions can be specified by taking the cartesian\n  product of [1, 3] and [5, 6, 7, 8] to yield the grid points with\n  coordinates: `[(1, 5), (1, 6), (1, 7), (1, 8), (3, 5) ... (3, 8)]`.\n\n  This function allows batching of solutions. In this context, batching means\n  the ability to represent and evolve multiple independent functions `V`\n  (e.g. V1, V2 ...) simultaneously. A single discretized solution is specified\n  by stating its values at each grid point. This can be represented as a\n  `Tensor` of shape [d1, d2, ... dn] where di is the grid size along the `i`th\n  axis. A batch of such solutions is represented by a `Tensor` of shape:\n  `B + [d1, d2, ... dn]` where `B` is the batch shape. This method only requires\n  that the input parameter `values_grid` be broadcastable with shape\n  `B + [d1, ... dn]`.\n\n  The evolution of the solution from `t0` to `t1` is done by discretizing the\n  differential equation to a difference equation along the spatial and\n  temporal axes. The temporal discretization is given by a (sequence of)\n  time steps [dt_1, dt_2, ... dt_k] such that the sum of the time steps is\n  equal to the total time step `t0 - t1`. If a uniform time step is used,\n  it may equivalently be specified by stating the number of steps (n_steps)\n  to take. This method provides both options via the `time_step`\n  and `num_steps` parameters.\n\n  The mapping between the arguments of this method and the above\n  equation are described in the Args section below.\n\n  #### Example. European call option pricing.\n  ```python\n  import tensorflow.compat.v2 as tf\n  import tf_quant_finance as tff\n  pde = tff.math.pde\n\n  num_equations = 2  # Number of PDE\n  num_grid_points = 1024  # Number of grid points\n  dtype = tf.float64\n\n  # Build a log-uniform grid\n  s_min = 0\n  s_max = 200\n  grid = pde.grids.uniform_grid(minimums=[s_min],\n                                maximums=[s_max],\n                                sizes=[num_grid_points],\n                                dtype=dtype)\n\n  # Specify volatilities and interest rates for the options\n  strike = tf.constant([[50], [100]], dtype)\n  volatility = tf.constant([[0.3], [0.15]], dtype)\n  rate = tf.constant([[0.01], [0.03]], dtype)\n  expiry = 1.0\n\n  # For batching multiple PDEs, we need to stack the grid values\n  # so that final_values[i] is the grid for the ith strike.\n  s = grid[0]\n  final_value_grid = tf.nn.relu(s - strike)\n\n  # Define parabolic equation coefficients. In this case the coefficients\n  # can be computed exactly but the same functions as below can be used to\n  # get approximate values for general case.\n  # We again need to use `tf.meshgrid` to batch the coefficients.\n  def second_order_coeff_fn(t, grid):\n    del t\n    s = grid[0]\n    return [[volatility**2 * s**2 / 2]]\n\n  def first_order_coeff_fn(t, grid):\n    del t\n    s = grid[0]\n    return [rate * s]\n\n  def zeroth_order_coeff_fn(t, grid):\n    del t, grid\n    return -rate\n\n  @pde.boundary_conditions.dirichlet\n  def lower_boundary_fn(t, grid):\n    del t, grid\n    return 0\n\n  @pde.boundary_conditions.dirichlet\n  def upper_boundary_fn(t, grid):\n    del grid\n    return tf.squeeze(s_max - strike * tf.exp(-rate * (expiry - t)))\n\n\n  # Estimate European call option price:\n  estimate = pde.fd_solvers.solve_backward(\n    start_time=expiry,\n    end_time=0,\n    coord_grid=grid,\n    values_grid=final_value_grid,\n    time_step=0.01,\n    boundary_conditions=[(lower_boundary_fn, upper_boundary_fn)],\n    second_order_coeff_fn=second_order_coeff_fn,\n    first_order_coeff_fn=first_order_coeff_fn,\n    zeroth_order_coeff_fn=zeroth_order_coeff_fn,\n    dtype=dtype)[0]\n\n  # Extract estimates for some of the grid locations and compare to the\n  # true option price:\n  value_grid_first_option = estimate[0, :]\n  value_grid_second_option = estimate[1, :]\n\n  # As an alternative, user can use a default BC for the lower bound by setting\n  # lower_boundary_fn to `None`, which corresponds to\n  # `V_t - r V_s - rV = 0`.\n  # Estimate European call option price using default BC for the lower bound:\n  estimate_with_default_bc = pde.fd_solvers.solve_backward(\n    start_time=expiry,\n    end_time=0,\n    coord_grid=grid,\n    values_grid=final_value_grid,\n    time_step=0.01,\n    boundary_conditions=[(None, upper_boundary_fn)],\n    second_order_coeff_fn=second_order_coeff_fn,\n    first_order_coeff_fn=first_order_coeff_fn,\n    zeroth_order_coeff_fn=zeroth_order_coeff_fn,\n    dtype=dtype)[0]\n  ```\n\n  See more examples in `pde_solvers.pdf`.\n\n  Args:\n    start_time: Real positive scalar `Tensor`. The start time of the grid.\n      Corresponds to time `t0` above.\n    end_time: Real scalar `Tensor` smaller than the `start_time` and greater\n      than zero. The time to step back to. Corresponds to time `t1` above.\n    coord_grid: List of `n` rank 1 real `Tensor`s. `n` is the dimension of the\n      domain. The i-th `Tensor` has shape either `[d_i]` or `B + [d_i]` where\n      `d_i` is the size of the grid along axis `i` and `B` is a batch shape. The\n      coordinates of the grid points. Corresponds to the spatial grid `G` above.\n    values_grid: Real `Tensor` containing the function values at time\n      `start_time` which have to be evolved to time `end_time`. The shape of the\n      `Tensor` must broadcast with `B + [d_1, d_2, ..., d_n]`. `B` is the batch\n      dimensions (one or more), which allow multiple functions (with potentially\n      different boundary/final conditions and PDE coefficients) to be evolved\n      simultaneously.\n    num_steps: Positive int scalar `Tensor`. The number of time steps to take\n      when moving from `start_time` to `end_time`. Either this argument or the\n      `time_step` argument must be supplied (but not both). If num steps is\n      `k>=1`, uniform time steps of size `(t0 - t1)/k` are taken to evolve the\n      solution from `t0` to `t1`. Corresponds to the `n_steps` parameter above.\n    start_step_count: A scalar integer `Tensor`. Number of steps performed so\n      far.\n    time_step: The time step to take. Either this argument or the `num_steps`\n      argument must be supplied (but not both). The type of this argument may\n      be one of the following (in order of generality):\n        (a) None in which case `num_steps` must be supplied.\n        (b) A positive real scalar `Tensor`. The maximum time step to take.\n          If the value of this argument is `dt`, then the total number of steps\n          taken is N = (t0 - t1) / dt rounded up to the nearest integer. The\n          first N-1 steps are of size dt and the last step is of size\n          `t0 - t1 - (N-1) * dt`.\n        (c) A callable accepting the current time and returning the size of the\n          step to take. The input and the output are real scalar `Tensor`s.\n    one_step_fn: The transition kernel. A callable that consumes the following\n      arguments by keyword:\n        1. 'time': Current time\n        2. 'next_time': The next time to step to. For the backwards in time\n          evolution, this time will be smaller than the current time.\n        3. 'coord_grid': The coordinate grid.\n        4. 'values_grid': The values grid.\n        5. 'second_order_coeff_fn': Callable returning the coefficients of the\n          second order terms of the PDE. See the spec of the\n          `second_order_coeff_fn` argument below.\n        6. 'first_order_coeff_fn': Callable returning the coefficients of the\n          first order terms of the PDE. See the spec of the\n          `first_order_coeff_fn` argument below.\n        7. 'zeroth_order_coeff_fn': Callable returning the coefficient of the\n          zeroth order term of the PDE. See the spec of the\n          `zeroth_order_coeff_fn` argument below.\n        8. 'num_steps_performed': A scalar integer `Tensor`. Number of steps\n          performed so far.\n       The callable should return a sequence of two `Tensor`s. The first one\n       is a `Tensor` of the same `dtype` and `shape` as `coord_grid` and\n       represents a new coordinate grid after one iteration. The second `Tensor`\n       is of the same shape and `dtype` as`values_grid` and represents an\n       approximate solution of the equation after one iteration.\n       Default value: None, which means Crank-Nicolson scheme with oscillation\n       damping is used for 1D problems, and Douglas ADI scheme with `theta=0.5`\n       - for multidimensional problems.\n    boundary_conditions: The boundary conditions. Only rectangular boundary\n      conditions are supported. A list of tuples of size `n` (space dimension\n      of the PDE). The elements of the Tuple can be either a Python Callable or\n      `None` representing the boundary conditions at the minimum and maximum\n      values of the spatial variable indexed by the position in the list. E.g.,\n      for `n=2`, the length of `boundary_conditions` should be 2,\n      `boundary_conditions[0][0]` describes the boundary `(y_min, x)`, and\n      `boundary_conditions[1][0]`- the boundary `(y, x_min)`. `None` values mean\n      that the second order terms for that dimension on the boundary are assumed\n      to be zero, i.e., if `boundary_conditions[k][0]` is None,\n      'dV/dt + Sum[a_ij d2(A_ij V)/dx_i dx_j, 1 <= i, j <= n, i!=k+1, j!=k+1] +\n         Sum[b_i d(B_i V)/dx_i, 1 <= i <= n] + c V = 0.'\n      For not `None` values, the boundary conditions are accepted in the form\n      `alpha(t, x) V + beta(t, x) V_n = gamma(t, x)`, where `V_n` is the\n      derivative with respect to the exterior normal to the boundary.\n      Each callable receives the current time `t` and the `coord_grid` at the\n      current time, and should return a tuple of `alpha`, `beta`, and `gamma`.\n      Each can be a number, a zero-rank `Tensor` or a `Tensor` whose shape is\n      the grid shape with the corresponding dimension removed.\n      For example, for a two-dimensional grid of shape `(b, ny, nx)`, where `b`\n      is the batch size, `boundary_conditions[0][i]` with `i = 0, 1` should\n      return a tuple of either numbers, zero-rank tensors or tensors of shape\n      `(b, nx)`. Similarly for `boundary_conditions[1][i]`, except the tensor\n      shape should be `(b, ny)`. `alpha` and `beta` can also be `None` in case\n      of Neumann and Dirichlet conditions, respectively.\n      Default value: `None`. Unlike setting `None` to individual elements of\n      `boundary_conditions`, setting the entire `boundary_conditions` object to\n      `None` means Dirichlet conditions with zero value on all boundaries are\n      applied.\n    values_transform_fn: An optional callable applied to transform the solution\n      values at each time step. The callable is invoked after the time step has\n      been performed. The callable should accept the time of the grid, the\n      coordinate grid, and the values grid and should return a tuple of the\n      the coordinate grid and updated value grid.\n    second_order_coeff_fn: Callable returning the coefficients of the second\n      order terms of the PDE (i.e. `a_{ij}(t, x)` above) at given time `t`.\n      The callable accepts the following arguments:\n        `t`: The time at which the coefficient should be evaluated.\n        `coord_grid`: a `Tensor` representing a grid of locations `r` at which\n          the coefficient should be evaluated.\n      Returns the object `a` such that `a[i][j]` is defined and\n      `a[i][j]=a_{ij}(r, t)`, where `0 <= i < n_dims` and `i <= j < n_dims`.\n      For example, the object may be a list of lists or a rank 2 Tensor.\n      `a[i][j]` is assumed to be symmetrical, and only the elements with\n      `j >= i` will be used, so elements with `j < i` can be `None`.\n      Each `a[i][j]` should be a Number, a `Tensor` broadcastable to the shape\n      of `coord_grid`, or `None` if corresponding term is absent in the\n      equation. Also, the callable itself may be None, meaning there are no\n      second-order derivatives in the equation.\n      For example, for a 2D equation with the following second order terms\n      ```\n      a_xx V_xx + 2 a_xy V_xy + a_yy V_yy\n      ```\n       the callable may return either\n      `[[a_yy, a_xy], [a_xy, a_xx]]` or `[[a_yy, a_xy], [None, a_xx]]`.\n      Default value: None. If both `second_order_coeff_fn` and\n        `inner_second_order_coeff_fn` are None, it means the second-order term\n        is absent. If only one of them is `None`, it is assumed to be `1`.\n    first_order_coeff_fn: Callable returning the coefficients of the\n      first order terms of the PDE (i.e. `mu_i(t, r)` above) evaluated at given\n      time `t`.\n      The callable accepts the following arguments:\n        `t`: The time at which the coefficient should be evaluated.\n        `locations_grid`: a `Tensor` representing a grid of locations `r` at\n          which the coefficient should be evaluated.\n      Returns a list or an 1D `Tensor`, `i`-th element of which represents\n      `b_i(t, r)`. Each element is a `Tensor` broadcastable to the shape of\n      `locations_grid`, or None if corresponding term is absent in the\n      equation. The callable itself may be None, meaning there are no\n      first-order derivatives in the equation.\n      Default value: None. If both `first_order_coeff_fn` and\n        `inner_first_order_coeff_fn` are None, it means the first-order term is\n        absent. If only one of them is `None`, it is assumed to be `1`.\n    zeroth_order_coeff_fn: Callable returning the coefficient of the\n      zeroth order term of the PDE (i.e. `c(t, r)` above) evaluated at given\n      time `t`.\n      The callable accepts the following arguments:\n        `t`: The time at which the coefficient should be evaluated.\n        `locations_grid`: a `Tensor` representing a grid of locations `r` at\n          which the coefficient should be evaluated.\n      Should return a `Tensor` broadcastable to the shape of `locations_grid`.\n      May return None or be None if the shift term is absent in the equation.\n      Default value: None, meaning absent zeroth order term.\n    inner_second_order_coeff_fn: Callable returning the coefficients under the\n      second derivatives (i.e. `A_ij(t, x)` above) at given time `t`. The\n      requirements are the same as for `second_order_coeff_fn`.\n    inner_first_order_coeff_fn: Callable returning the coefficients under the\n      first derivatives (i.e. `B_i(t, x)` above) at given time `t`. The\n      requirements are the same as for `first_order_coeff_fn`.\n    maximum_steps: Optional int `Tensor`. The maximum number of time steps that\n      might be taken. This argument is only used if the `num_steps` is not used\n      and `time_step` is a callable otherwise it is ignored. It is useful to\n      supply this argument to ensure that the time stepping loop can be\n      optimized. If the argument is supplied and used, the time loop with\n      execute at most these many steps so it is important to ensure that this\n      parameter is an upper bound on the number of expected steps.\n    swap_memory: Whether GPU-CPU memory swap is enabled for this op. See\n      equivalent flag in `tf.while_loop` documentation for more details. Useful\n      when computing a gradient of the op.\n    dtype: The dtype to use.\n      Default value: None, which means dtype will be inferred from\n      `values_grid`.\n    name: The name to give to the ops.\n      Default value: None which means `solve_backward` is used.\n\n  Returns:\n    The final values grid, final coordinate grid, final time and number of steps\n    performed.\n\n  Raises:\n    ValueError if neither num steps nor time steps are provided or if both\n    are provided.\n  "
    values_grid = tf.convert_to_tensor(values_grid, dtype=dtype)
    start_time = tf.convert_to_tensor(start_time, dtype=values_grid.dtype, name='start_time')
    end_time = tf.math.maximum(tf.math.minimum(tf.convert_to_tensor(end_time, dtype=values_grid.dtype, name='end_time'), start_time), 0)
    return _solve(_time_direction_backward_fn, start_time, end_time, coord_grid, values_grid, num_steps, start_step_count, time_step, one_step_fn, boundary_conditions, values_transform_fn, second_order_coeff_fn, first_order_coeff_fn, zeroth_order_coeff_fn, inner_second_order_coeff_fn, inner_first_order_coeff_fn, maximum_steps, swap_memory, name or 'solve_backward')

def solve_forward(start_time, end_time, coord_grid, values_grid, num_steps=None, start_step_count=0, time_step=None, one_step_fn=None, boundary_conditions=None, values_transform_fn=None, second_order_coeff_fn=None, first_order_coeff_fn=None, zeroth_order_coeff_fn=None, inner_second_order_coeff_fn=None, inner_first_order_coeff_fn=None, maximum_steps=None, swap_memory=True, dtype=None, name=None):
    if False:
        while True:
            i = 10
    "Evolves a grid of function values forward in time according to a PDE.\n\n  Evolves a discretized solution of following second order linear\n  partial differential equation:\n\n  ```None\n    dV/dt + Sum[a_ij d2(A_ij V)/dx_i dx_j, 1 <= i, j <=n] +\n       Sum[b_i d(B_i V)/dx_i, 1 <= i <= n] + c V = 0.\n  ```\n  from time `t0` to time `t1 > t0` (i.e. forward in time). Here `a_ij`,\n  `A_ij`, `b_i`, `B_i` and `c` are coefficients that may depend on spatial\n  variables `x` and time `t`.\n\n  See more details in `solve_backwards()`: other than the forward time\n  direction, the specification is the same.\n\n  Args:\n    start_time: Real scalar `Tensor`. The start time of the grid.\n      Corresponds to time `t0` above.\n    end_time: Real scalar `Tensor` larger than the `start_time`.\n       The time to evolve forward to. Corresponds to time `t1` above.\n    coord_grid: List of `n` rank 1 real `Tensor`s. `n` is the dimension of the\n      domain. The i-th `Tensor` has shape either `[d_i]` or ` B + [d_i]` where\n      `d_i` is the size of the grid along axis `i` and `B` is a batch shape. The\n      coordinates of the grid points. Corresponds to the spatial grid `G` above.\n    values_grid: Real `Tensor` containing the function values at time\n      `start_time` which have to be evolved to time `end_time`. The shape of the\n      `Tensor` must broadcast with `B + [d_1, d_2, ..., d_n]`. `b` is the batch\n      dimensions (one or more), which allow multiple functions (with potentially\n      different boundary/final conditions and PDE coefficients) to be evolved\n      simultaneously.\n    num_steps: Positive int scalar `Tensor`. The number of time steps to take\n      when moving from `start_time` to `end_time`. Either this argument or the\n      `time_step` argument must be supplied (but not both). If num steps is\n      `k>=1`, uniform time steps of size `(t1 - t0)/k` are taken to evolve the\n      solution from `t0` to `t1`. Corresponds to the `n_steps` parameter above.\n    start_step_count: A scalar integer `Tensor`. Number of steps performed so\n      far.\n    time_step: The time step to take. Either this argument or the `num_steps`\n      argument must be supplied (but not both). The type of this argument may\n      be one of the following (in order of generality):\n        (a) None in which case `num_steps` must be supplied.\n        (b) A positive real scalar `Tensor`. The maximum time step to take.\n          If the value of this argument is `dt`, then the total number of steps\n          taken is N = (t1 - t0) / dt rounded up to the nearest integer. The\n          first N-1 steps are of size dt and the last step is of size\n          `t1 - t0 - (N-1) * dt`.\n        (c) A callable accepting the current time and returning the size of the\n          step to take. The input and the output are real scalar `Tensor`s.\n    one_step_fn: The transition kernel. A callable that consumes the following\n      arguments by keyword:\n        1. 'time': Current time\n        2. 'next_time': The next time to step to. For the backwards in time\n          evolution, this time will be smaller than the current time.\n        3. 'coord_grid': The coordinate grid.\n        4. 'values_grid': The values grid.\n        5. 'second_order_coeff_fn': Callable returning the coefficients of the\n          second order terms of the PDE. See the spec of the\n          `second_order_coeff_fn` argument below.\n        6. 'first_order_coeff_fn': Callable returning the coefficients of the\n          first order terms of the PDE. See the spec of the\n          `first_order_coeff_fn` argument below.\n        7. 'zeroth_order_coeff_fn': Callable returning the coefficient of the\n          zeroth order term of the PDE. See the spec of the\n          `zeroth_order_coeff_fn` argument below.\n        8. 'num_steps_performed': A scalar integer `Tensor`. Number of steps\n          performed so far.\n       The callable should return a sequence of two `Tensor`s. The first one\n       is a `Tensor` of the same `dtype` and `shape` as `coord_grid` and\n       represents a new coordinate grid after one iteration. The second `Tensor`\n       is of the same shape and `dtype` as`values_grid` and represents an\n       approximate solution of the equation after one iteration.\n       Default value: None, which means Crank-Nicolson scheme with oscillation\n       damping is used for 1D problems, and Douglas ADI scheme with `theta=0.5`\n       - for multidimensional problems.\n    boundary_conditions: The boundary conditions. Only rectangular boundary\n      conditions are supported. A list of tuples of size `n` (space dimension\n      of the PDE). The elements of the Tuple can be either a Python Callable or\n      `None` representing the boundary conditions at the minimum and maximum\n      values of the spatial variable indexed by the position in the list. E.g.,\n      for `n=2`, the length of `boundary_conditions` should be 2,\n      `boundary_conditions[0][0]` describes the boundary `(y_min, x)`, and\n      `boundary_conditions[1][0]`- the boundary `(y, x_min)`. `None` values mean\n      that the second order terms for that dimension on the boundary are assumed\n      to be zero, i.e., if `boundary_conditions[k][0]` is None,\n      'dV/dt + Sum[a_ij d2(A_ij V)/dx_i dx_j, 1 <= i, j <=n, i!=k+1, j!=k+1] +\n         Sum[b_i d(B_i V)/dx_i, 1 <= i <= n] + c V = 0.'\n      For not `None` values, the boundary conditions are accepted in the form\n      `alpha(t, x) V + beta(t, x) V_n = gamma(t, x)`, where `V_n` is the\n      derivative with respect to the exterior normal to the boundary.\n      Each callable receives the current time `t` and the `coord_grid` at the\n      current time, and should return a tuple of `alpha`, `beta`, and `gamma`.\n      Each can be a number, a zero-rank `Tensor` or a `Tensor` whose shape is\n      the grid shape with the corresponding dimension removed.\n      For example, for a two-dimensional grid of shape `(b, ny, nx)`, where `b`\n      is the batch size, `boundary_conditions[0][i]` with `i = 0, 1` should\n      return a tuple of either numbers, zero-rank tensors or tensors of shape\n      `(b, nx)`. Similarly for `boundary_conditions[1][i]`, except the tensor\n      shape should be `(b, ny)`. `alpha` and `beta` can also be `None` in case\n      of Neumann and Dirichlet conditions, respectively.\n      Default value: `None`. Unlike setting `None` to individual elements of\n      `boundary_conditions`, setting the entire `boundary_conditions` object to\n      `None` means Dirichlet conditions with zero value on all boundaries are\n      applied.\n    values_transform_fn: An optional callable applied to transform the solution\n      values at each time step. The callable is invoked after the time step has\n      been performed. The callable should accept the time of the grid, the\n      coordinate grid and the values grid and should return the values grid. All\n      input arguments to be passed by keyword.\n      It returns the updated value grid and the coordinate grid, which may be\n      updated as well.\n    second_order_coeff_fn: Callable returning the coefficients of the second\n      order terms of the PDE (i.e. `a_{ij}(t, x)` above) at given time `t`.\n      The callable accepts the following arguments:\n        `t`: The time at which the coefficient should be evaluated.\n        `coord_grid`: a `Tensor` representing a grid of locations `r` at which\n          the coefficient should be evaluated.\n      Returns the object `a` such that `a[i][j]` is defined and\n      `a[i][j]=a_{ij}(r, t)`, where `0 <= i < n_dims` and `i <= j < n_dims`.\n      For example, the object may be a list of lists or a rank 2 Tensor.\n      `a[i][j]` is assumed to be symmetrical, and only the elements with\n      `j >= i` will be used, so elements with `j < i` can be `None`.\n      Each `a[i][j]` should be a Number, a `Tensor` broadcastable to the shape\n      of `coord_grid`, or `None` if corresponding term is absent in the\n      equation. Also, the callable itself may be None, meaning there are no\n      second-order derivatives in the equation.\n      For example, for a 2D equation with the following second order terms\n      ```\n      a_xx V_xx + 2 a_xy V_xy + a_yy V_yy\n      ```\n       the callable may return either\n      `[[a_yy, a_xy], [a_xy, a_xx]]` or `[[a_yy, a_xy], [None, a_xx]]`.\n      Default value: None. If both `second_order_coeff_fn` and\n        `inner_second_order_coeff_fn` are None, it means the second-order term\n        is absent. If only one of them is `None`, it is assumed to be `1`.\n    first_order_coeff_fn: Callable returning the coefficients of the\n      first order terms of the PDE (i.e. `mu_i(t, r)` above) evaluated at given\n      time `t`.\n      The callable accepts the following arguments:\n        `t`: The time at which the coefficient should be evaluated.\n        `locations_grid`: a `Tensor` representing a grid of locations `r` at\n          which the coefficient should be evaluated.\n      Returns a list or an 1D `Tensor`, `i`-th element of which represents\n      `b_i(t, r)`. Each element is a `Tensor` broadcastable to the shape of\n      `locations_grid`, or None if corresponding term is absent in the\n      equation. The callable itself may be None, meaning there are no\n      first-order derivatives in the equation.\n      Default value: None. If both `first_order_coeff_fn` and\n        `inner_first_order_coeff_fn` are None, it means the first-order term is\n        absent. If only one of them is `None`, it is assumed to be `1`.\n    zeroth_order_coeff_fn: Callable returning the coefficient of the\n      zeroth order term of the PDE (i.e. `c(t, r)` above) evaluated at given\n      time `t`.\n      The callable accepts the following arguments:\n        `t`: The time at which the coefficient should be evaluated.\n        `locations_grid`: a `Tensor` representing a grid of locations `r` at\n          which the coefficient should be evaluated.\n      Should return a `Tensor` broadcastable to the shape of `locations_grid`.\n      May return None or be None if the shift term is absent in the equation.\n      Default value: None, meaning absent zeroth order term.\n    inner_second_order_coeff_fn: Callable returning the coefficients under the\n      second derivatives (i.e. `A_ij(t, x)` above) at given time `t`. The\n      requirements are the same as for `second_order_coeff_fn`.\n    inner_first_order_coeff_fn: Callable returning the coefficients under the\n      first derivatives (i.e. `B_i(t, x)` above) at given time `t`. The\n      requirements are the same as for `first_order_coeff_fn`.\n    maximum_steps: Optional int `Tensor`. The maximum number of time steps that\n      might be taken. This argument is only used if the `num_steps` is not used\n      and `time_step` is a callable otherwise it is ignored. It is useful to\n      supply this argument to ensure that the time stepping loop can be\n      optimized. If the argument is supplied and used, the time loop with\n      execute at most these many steps so it is important to ensure that this\n      parameter is an upper bound on the number of expected steps.\n    swap_memory: Whether GPU-CPU memory swap is enabled for this op. See\n      equivalent flag in `tf.while_loop` documentation for more details. Useful\n      when computing a gradient of the op.\n    dtype: The dtype to use.\n      Default value: None, which means dtype will be inferred from\n      `values_grid`.\n    name: The name to give to the ops.\n      Default value: None which means `solve_forward` is used.\n\n  Returns:\n    The final values grid, final coordinate grid, final time and number of steps\n    performed.\n\n  Raises:\n    ValueError if neither num steps nor time steps are provided or if both\n    are provided.\n  "
    values_grid = tf.convert_to_tensor(values_grid, dtype=dtype)
    start_time = tf.convert_to_tensor(start_time, dtype=values_grid.dtype, name='start_time')
    end_time = tf.math.maximum(tf.convert_to_tensor(end_time, dtype=values_grid.dtype, name='end_time'), start_time)
    return _solve(_time_direction_forward_fn, start_time, end_time, coord_grid, values_grid, num_steps, start_step_count, time_step, one_step_fn, boundary_conditions, values_transform_fn, second_order_coeff_fn, first_order_coeff_fn, zeroth_order_coeff_fn, inner_second_order_coeff_fn, inner_first_order_coeff_fn, maximum_steps, swap_memory, name or 'solve_forward')

def _solve(time_direction_fn, start_time, end_time, coord_grid, values_grid, num_steps=None, start_step_count=0, time_step=None, one_step_fn=None, boundary_conditions=None, values_transform_fn=None, second_order_coeff_fn=None, first_order_coeff_fn=None, zeroth_order_coeff_fn=None, inner_second_order_coeff_fn=None, inner_first_order_coeff_fn=None, maximum_steps=None, swap_memory=True, name=None):
    if False:
        i = 10
        return i + 15
    'Common code for solve_backward and solve_forward.'
    if (num_steps is None) == (time_step is None):
        raise ValueError('Exactly one of num_steps or time_step should be supplied.')
    coord_grid = [tf.convert_to_tensor(dim_grid, dtype=values_grid.dtype) for dim_grid in coord_grid]
    coord_grid = list(utils.broadcast_common_batch_shape(*coord_grid))
    n_dims = len(coord_grid)
    if one_step_fn is None:
        if n_dims == 1:
            one_step_fn = oscillation_damped_crank_nicolson_step()
        else:
            one_step_fn = douglas_adi_step(theta=0.5)
    if boundary_conditions is None:

        def zero_dirichlet(t, grid):
            if False:
                while True:
                    i = 10
            del t, grid
            return (1, None, tf.constant(0, dtype=values_grid.dtype))
        boundary_conditions = [(zero_dirichlet, zero_dirichlet)] * n_dims
    with tf.compat.v1.name_scope(name, default_name='solve', values=[start_time, end_time, coord_grid, values_grid, num_steps, time_step]):
        (time_step_fn, est_max_steps) = _get_time_steps_info(start_time, end_time, num_steps, time_step, time_direction_fn)
        if est_max_steps is None and maximum_steps is not None:
            est_max_steps = maximum_steps

        def loop_cond(should_stop, time, x_grid, f_grid, steps_performed):
            if False:
                i = 10
                return i + 15
            del time, x_grid, f_grid, steps_performed
            return tf.logical_not(should_stop)

        def loop_body(should_stop, time, x_grid, f_grid, steps_performed):
            if False:
                while True:
                    i = 10
            'Propagates the grid in time.'
            del should_stop
            (next_should_stop, t_next) = time_step_fn(time)
            (next_xs, next_fs) = one_step_fn(time=time, next_time=t_next, coord_grid=x_grid, value_grid=f_grid, boundary_conditions=boundary_conditions, second_order_coeff_fn=second_order_coeff_fn, first_order_coeff_fn=first_order_coeff_fn, zeroth_order_coeff_fn=zeroth_order_coeff_fn, inner_second_order_coeff_fn=inner_second_order_coeff_fn, inner_first_order_coeff_fn=inner_first_order_coeff_fn, num_steps_performed=steps_performed)
            if values_transform_fn is not None:
                (next_xs, next_fs) = values_transform_fn(t_next, next_xs, next_fs)
            return (next_should_stop, t_next, next_xs, next_fs, steps_performed + 1)
        should_already_stop = start_time == end_time
        initial_args = (should_already_stop, start_time, coord_grid, values_grid, start_step_count)
        (_, final_time, final_coords, final_values, steps_performed) = tf.while_loop(loop_cond, loop_body, initial_args, swap_memory=swap_memory, maximum_iterations=est_max_steps)
        return (final_values, final_coords, final_time, steps_performed)

def _is_callable(var_or_fn):
    if False:
        while True:
            i = 10
    'Returns whether an object is callable or not.'
    if hasattr(var_or_fn, '__call__'):
        return True
    try:
        return callable(var_or_fn)
    except NameError:
        return False

def _get_time_steps_info(start_time, end_time, num_steps, time_step, time_direction_fn):
    if False:
        while True:
            i = 10
    'Creates a callable to step through time and estimates the max steps.'
    dt = None
    estimated_max_steps = None
    interval = tf.math.abs(end_time - start_time)
    if num_steps is not None:
        dt = interval / tf.cast(num_steps, dtype=start_time.dtype)
        estimated_max_steps = num_steps
    if time_step is not None and (not _is_callable(time_step)):
        dt = time_step
        estimated_max_steps = tf.cast(tf.math.ceil(interval / dt), dtype=tf.int32)
    if dt is not None:
        raw_time_step_fn = lambda _: dt
    else:
        raw_time_step_fn = time_step

    def time_step_fn(t):
        if False:
            i = 10
            return i + 15
        dt = raw_time_step_fn(t)
        (should_stop, t_next) = time_direction_fn(t, dt, end_time)
        return (should_stop, t_next)
    return (time_step_fn, estimated_max_steps)

def _time_direction_forward_fn(t, dt, end_time):
    if False:
        while True:
            i = 10
    t_next = tf.math.minimum(end_time, t + dt)
    return (t_next >= end_time, t_next)

def _time_direction_backward_fn(t, dt, end_time):
    if False:
        return 10
    t_next = tf.math.maximum(end_time, t - dt)
    return (t_next <= end_time, t_next)
__all__ = ['solve_backward', 'solve_forward']