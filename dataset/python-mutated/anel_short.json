[
    {
        "func_name": "sum_outer_product_loop",
        "original": "def sum_outer_product_loop(x, group_iter):\n    \"\"\"sum outerproduct dot(x_i, x_i.T) over individuals\n\n    loop version\n\n    \"\"\"\n    mom = 0\n    for g in group_iter():\n        x_g = x[g]\n        mom += np.outer(x_g, x_g)\n    return mom",
        "mutated": [
            "def sum_outer_product_loop(x, group_iter):\n    if False:\n        i = 10\n    'sum outerproduct dot(x_i, x_i.T) over individuals\\n\\n    loop version\\n\\n    '\n    mom = 0\n    for g in group_iter():\n        x_g = x[g]\n        mom += np.outer(x_g, x_g)\n    return mom",
            "def sum_outer_product_loop(x, group_iter):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'sum outerproduct dot(x_i, x_i.T) over individuals\\n\\n    loop version\\n\\n    '\n    mom = 0\n    for g in group_iter():\n        x_g = x[g]\n        mom += np.outer(x_g, x_g)\n    return mom",
            "def sum_outer_product_loop(x, group_iter):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'sum outerproduct dot(x_i, x_i.T) over individuals\\n\\n    loop version\\n\\n    '\n    mom = 0\n    for g in group_iter():\n        x_g = x[g]\n        mom += np.outer(x_g, x_g)\n    return mom",
            "def sum_outer_product_loop(x, group_iter):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'sum outerproduct dot(x_i, x_i.T) over individuals\\n\\n    loop version\\n\\n    '\n    mom = 0\n    for g in group_iter():\n        x_g = x[g]\n        mom += np.outer(x_g, x_g)\n    return mom",
            "def sum_outer_product_loop(x, group_iter):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'sum outerproduct dot(x_i, x_i.T) over individuals\\n\\n    loop version\\n\\n    '\n    mom = 0\n    for g in group_iter():\n        x_g = x[g]\n        mom += np.outer(x_g, x_g)\n    return mom"
        ]
    },
    {
        "func_name": "sum_outer_product_balanced",
        "original": "def sum_outer_product_balanced(x, n_groups):\n    \"\"\"sum outerproduct dot(x_i, x_i.T) over individuals\n\n    where x_i is (nobs_i, 1), and result is (nobs_i, nobs_i)\n\n    reshape-dot version, for x.ndim=1 only\n\n    \"\"\"\n    xrs = x.reshape(-1, n_groups, order='F')\n    return np.dot(xrs, xrs.T)",
        "mutated": [
            "def sum_outer_product_balanced(x, n_groups):\n    if False:\n        i = 10\n    'sum outerproduct dot(x_i, x_i.T) over individuals\\n\\n    where x_i is (nobs_i, 1), and result is (nobs_i, nobs_i)\\n\\n    reshape-dot version, for x.ndim=1 only\\n\\n    '\n    xrs = x.reshape(-1, n_groups, order='F')\n    return np.dot(xrs, xrs.T)",
            "def sum_outer_product_balanced(x, n_groups):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'sum outerproduct dot(x_i, x_i.T) over individuals\\n\\n    where x_i is (nobs_i, 1), and result is (nobs_i, nobs_i)\\n\\n    reshape-dot version, for x.ndim=1 only\\n\\n    '\n    xrs = x.reshape(-1, n_groups, order='F')\n    return np.dot(xrs, xrs.T)",
            "def sum_outer_product_balanced(x, n_groups):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'sum outerproduct dot(x_i, x_i.T) over individuals\\n\\n    where x_i is (nobs_i, 1), and result is (nobs_i, nobs_i)\\n\\n    reshape-dot version, for x.ndim=1 only\\n\\n    '\n    xrs = x.reshape(-1, n_groups, order='F')\n    return np.dot(xrs, xrs.T)",
            "def sum_outer_product_balanced(x, n_groups):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'sum outerproduct dot(x_i, x_i.T) over individuals\\n\\n    where x_i is (nobs_i, 1), and result is (nobs_i, nobs_i)\\n\\n    reshape-dot version, for x.ndim=1 only\\n\\n    '\n    xrs = x.reshape(-1, n_groups, order='F')\n    return np.dot(xrs, xrs.T)",
            "def sum_outer_product_balanced(x, n_groups):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'sum outerproduct dot(x_i, x_i.T) over individuals\\n\\n    where x_i is (nobs_i, 1), and result is (nobs_i, nobs_i)\\n\\n    reshape-dot version, for x.ndim=1 only\\n\\n    '\n    xrs = x.reshape(-1, n_groups, order='F')\n    return np.dot(xrs, xrs.T)"
        ]
    },
    {
        "func_name": "whiten_individuals_loop",
        "original": "def whiten_individuals_loop(x, transform, group_iter):\n    \"\"\"apply linear transform for each individual\n\n    loop version\n    \"\"\"\n    x_new = []\n    for g in group_iter():\n        x_g = x[g]\n        x_new.append(np.dot(transform, x_g))\n    return np.concatenate(x_new)",
        "mutated": [
            "def whiten_individuals_loop(x, transform, group_iter):\n    if False:\n        i = 10\n    'apply linear transform for each individual\\n\\n    loop version\\n    '\n    x_new = []\n    for g in group_iter():\n        x_g = x[g]\n        x_new.append(np.dot(transform, x_g))\n    return np.concatenate(x_new)",
            "def whiten_individuals_loop(x, transform, group_iter):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'apply linear transform for each individual\\n\\n    loop version\\n    '\n    x_new = []\n    for g in group_iter():\n        x_g = x[g]\n        x_new.append(np.dot(transform, x_g))\n    return np.concatenate(x_new)",
            "def whiten_individuals_loop(x, transform, group_iter):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'apply linear transform for each individual\\n\\n    loop version\\n    '\n    x_new = []\n    for g in group_iter():\n        x_g = x[g]\n        x_new.append(np.dot(transform, x_g))\n    return np.concatenate(x_new)",
            "def whiten_individuals_loop(x, transform, group_iter):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'apply linear transform for each individual\\n\\n    loop version\\n    '\n    x_new = []\n    for g in group_iter():\n        x_g = x[g]\n        x_new.append(np.dot(transform, x_g))\n    return np.concatenate(x_new)",
            "def whiten_individuals_loop(x, transform, group_iter):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'apply linear transform for each individual\\n\\n    loop version\\n    '\n    x_new = []\n    for g in group_iter():\n        x_g = x[g]\n        x_new.append(np.dot(transform, x_g))\n    return np.concatenate(x_new)"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, endog, exog, group):\n    self.endog = endog\n    self.exog = exog\n    self.group = GroupSorted(group)\n    self.n_groups = self.group.n_groups",
        "mutated": [
            "def __init__(self, endog, exog, group):\n    if False:\n        i = 10\n    self.endog = endog\n    self.exog = exog\n    self.group = GroupSorted(group)\n    self.n_groups = self.group.n_groups",
            "def __init__(self, endog, exog, group):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.endog = endog\n    self.exog = exog\n    self.group = GroupSorted(group)\n    self.n_groups = self.group.n_groups",
            "def __init__(self, endog, exog, group):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.endog = endog\n    self.exog = exog\n    self.group = GroupSorted(group)\n    self.n_groups = self.group.n_groups",
            "def __init__(self, endog, exog, group):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.endog = endog\n    self.exog = exog\n    self.group = GroupSorted(group)\n    self.n_groups = self.group.n_groups",
            "def __init__(self, endog, exog, group):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.endog = endog\n    self.exog = exog\n    self.group = GroupSorted(group)\n    self.n_groups = self.group.n_groups"
        ]
    },
    {
        "func_name": "fit_ols",
        "original": "def fit_ols(self):\n    self.res_pooled = OLS(self.endog, self.exog).fit()\n    return self.res_pooled",
        "mutated": [
            "def fit_ols(self):\n    if False:\n        i = 10\n    self.res_pooled = OLS(self.endog, self.exog).fit()\n    return self.res_pooled",
            "def fit_ols(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.res_pooled = OLS(self.endog, self.exog).fit()\n    return self.res_pooled",
            "def fit_ols(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.res_pooled = OLS(self.endog, self.exog).fit()\n    return self.res_pooled",
            "def fit_ols(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.res_pooled = OLS(self.endog, self.exog).fit()\n    return self.res_pooled",
            "def fit_ols(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.res_pooled = OLS(self.endog, self.exog).fit()\n    return self.res_pooled"
        ]
    },
    {
        "func_name": "get_within_cov",
        "original": "def get_within_cov(self, resid):\n    mom = sum_outer_product_loop(resid, self.group.group_iter)\n    return mom / self.n_groups",
        "mutated": [
            "def get_within_cov(self, resid):\n    if False:\n        i = 10\n    mom = sum_outer_product_loop(resid, self.group.group_iter)\n    return mom / self.n_groups",
            "def get_within_cov(self, resid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    mom = sum_outer_product_loop(resid, self.group.group_iter)\n    return mom / self.n_groups",
            "def get_within_cov(self, resid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    mom = sum_outer_product_loop(resid, self.group.group_iter)\n    return mom / self.n_groups",
            "def get_within_cov(self, resid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    mom = sum_outer_product_loop(resid, self.group.group_iter)\n    return mom / self.n_groups",
            "def get_within_cov(self, resid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    mom = sum_outer_product_loop(resid, self.group.group_iter)\n    return mom / self.n_groups"
        ]
    },
    {
        "func_name": "whiten_groups",
        "original": "def whiten_groups(self, x, cholsigmainv_i):\n    wx = whiten_individuals_loop(x, cholsigmainv_i, self.group.group_iter)\n    return wx",
        "mutated": [
            "def whiten_groups(self, x, cholsigmainv_i):\n    if False:\n        i = 10\n    wx = whiten_individuals_loop(x, cholsigmainv_i, self.group.group_iter)\n    return wx",
            "def whiten_groups(self, x, cholsigmainv_i):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    wx = whiten_individuals_loop(x, cholsigmainv_i, self.group.group_iter)\n    return wx",
            "def whiten_groups(self, x, cholsigmainv_i):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    wx = whiten_individuals_loop(x, cholsigmainv_i, self.group.group_iter)\n    return wx",
            "def whiten_groups(self, x, cholsigmainv_i):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    wx = whiten_individuals_loop(x, cholsigmainv_i, self.group.group_iter)\n    return wx",
            "def whiten_groups(self, x, cholsigmainv_i):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    wx = whiten_individuals_loop(x, cholsigmainv_i, self.group.group_iter)\n    return wx"
        ]
    },
    {
        "func_name": "fit",
        "original": "def fit(self):\n    res_pooled = self.fit_ols()\n    sigma_i = self.get_within_cov(res_pooled.resid)\n    self.cholsigmainv_i = np.linalg.cholesky(np.linalg.pinv(sigma_i)).T\n    wendog = self.whiten_groups(self.endog, self.cholsigmainv_i)\n    wexog = self.whiten_groups(self.exog, self.cholsigmainv_i)\n    self.res1 = OLS(wendog, wexog).fit()\n    return self.res1",
        "mutated": [
            "def fit(self):\n    if False:\n        i = 10\n    res_pooled = self.fit_ols()\n    sigma_i = self.get_within_cov(res_pooled.resid)\n    self.cholsigmainv_i = np.linalg.cholesky(np.linalg.pinv(sigma_i)).T\n    wendog = self.whiten_groups(self.endog, self.cholsigmainv_i)\n    wexog = self.whiten_groups(self.exog, self.cholsigmainv_i)\n    self.res1 = OLS(wendog, wexog).fit()\n    return self.res1",
            "def fit(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    res_pooled = self.fit_ols()\n    sigma_i = self.get_within_cov(res_pooled.resid)\n    self.cholsigmainv_i = np.linalg.cholesky(np.linalg.pinv(sigma_i)).T\n    wendog = self.whiten_groups(self.endog, self.cholsigmainv_i)\n    wexog = self.whiten_groups(self.exog, self.cholsigmainv_i)\n    self.res1 = OLS(wendog, wexog).fit()\n    return self.res1",
            "def fit(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    res_pooled = self.fit_ols()\n    sigma_i = self.get_within_cov(res_pooled.resid)\n    self.cholsigmainv_i = np.linalg.cholesky(np.linalg.pinv(sigma_i)).T\n    wendog = self.whiten_groups(self.endog, self.cholsigmainv_i)\n    wexog = self.whiten_groups(self.exog, self.cholsigmainv_i)\n    self.res1 = OLS(wendog, wexog).fit()\n    return self.res1",
            "def fit(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    res_pooled = self.fit_ols()\n    sigma_i = self.get_within_cov(res_pooled.resid)\n    self.cholsigmainv_i = np.linalg.cholesky(np.linalg.pinv(sigma_i)).T\n    wendog = self.whiten_groups(self.endog, self.cholsigmainv_i)\n    wexog = self.whiten_groups(self.exog, self.cholsigmainv_i)\n    self.res1 = OLS(wendog, wexog).fit()\n    return self.res1",
            "def fit(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    res_pooled = self.fit_ols()\n    sigma_i = self.get_within_cov(res_pooled.resid)\n    self.cholsigmainv_i = np.linalg.cholesky(np.linalg.pinv(sigma_i)).T\n    wendog = self.whiten_groups(self.endog, self.cholsigmainv_i)\n    wexog = self.whiten_groups(self.exog, self.cholsigmainv_i)\n    self.res1 = OLS(wendog, wexog).fit()\n    return self.res1"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, endog, exog, group, sigma_i=None):\n    self.group = GroupSorted(group)\n    self.n_groups = self.group.n_groups\n    nobs_i = len(endog) / self.n_groups\n    if sigma_i is None:\n        sigma_i = np.eye(int(nobs_i))\n    self.cholsigmainv_i = np.linalg.cholesky(np.linalg.pinv(sigma_i)).T\n    super(self.__class__, self).__init__(endog, exog, sigma=None)",
        "mutated": [
            "def __init__(self, endog, exog, group, sigma_i=None):\n    if False:\n        i = 10\n    self.group = GroupSorted(group)\n    self.n_groups = self.group.n_groups\n    nobs_i = len(endog) / self.n_groups\n    if sigma_i is None:\n        sigma_i = np.eye(int(nobs_i))\n    self.cholsigmainv_i = np.linalg.cholesky(np.linalg.pinv(sigma_i)).T\n    super(self.__class__, self).__init__(endog, exog, sigma=None)",
            "def __init__(self, endog, exog, group, sigma_i=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.group = GroupSorted(group)\n    self.n_groups = self.group.n_groups\n    nobs_i = len(endog) / self.n_groups\n    if sigma_i is None:\n        sigma_i = np.eye(int(nobs_i))\n    self.cholsigmainv_i = np.linalg.cholesky(np.linalg.pinv(sigma_i)).T\n    super(self.__class__, self).__init__(endog, exog, sigma=None)",
            "def __init__(self, endog, exog, group, sigma_i=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.group = GroupSorted(group)\n    self.n_groups = self.group.n_groups\n    nobs_i = len(endog) / self.n_groups\n    if sigma_i is None:\n        sigma_i = np.eye(int(nobs_i))\n    self.cholsigmainv_i = np.linalg.cholesky(np.linalg.pinv(sigma_i)).T\n    super(self.__class__, self).__init__(endog, exog, sigma=None)",
            "def __init__(self, endog, exog, group, sigma_i=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.group = GroupSorted(group)\n    self.n_groups = self.group.n_groups\n    nobs_i = len(endog) / self.n_groups\n    if sigma_i is None:\n        sigma_i = np.eye(int(nobs_i))\n    self.cholsigmainv_i = np.linalg.cholesky(np.linalg.pinv(sigma_i)).T\n    super(self.__class__, self).__init__(endog, exog, sigma=None)",
            "def __init__(self, endog, exog, group, sigma_i=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.group = GroupSorted(group)\n    self.n_groups = self.group.n_groups\n    nobs_i = len(endog) / self.n_groups\n    if sigma_i is None:\n        sigma_i = np.eye(int(nobs_i))\n    self.cholsigmainv_i = np.linalg.cholesky(np.linalg.pinv(sigma_i)).T\n    super(self.__class__, self).__init__(endog, exog, sigma=None)"
        ]
    },
    {
        "func_name": "get_within_cov",
        "original": "def get_within_cov(self, resid):\n    mom = sum_outer_product_loop(resid, self.group.group_iter)\n    return mom / self.n_groups",
        "mutated": [
            "def get_within_cov(self, resid):\n    if False:\n        i = 10\n    mom = sum_outer_product_loop(resid, self.group.group_iter)\n    return mom / self.n_groups",
            "def get_within_cov(self, resid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    mom = sum_outer_product_loop(resid, self.group.group_iter)\n    return mom / self.n_groups",
            "def get_within_cov(self, resid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    mom = sum_outer_product_loop(resid, self.group.group_iter)\n    return mom / self.n_groups",
            "def get_within_cov(self, resid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    mom = sum_outer_product_loop(resid, self.group.group_iter)\n    return mom / self.n_groups",
            "def get_within_cov(self, resid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    mom = sum_outer_product_loop(resid, self.group.group_iter)\n    return mom / self.n_groups"
        ]
    },
    {
        "func_name": "whiten_groups",
        "original": "def whiten_groups(self, x, cholsigmainv_i):\n    wx = whiten_individuals_loop(x, cholsigmainv_i, self.group.group_iter)\n    return wx",
        "mutated": [
            "def whiten_groups(self, x, cholsigmainv_i):\n    if False:\n        i = 10\n    wx = whiten_individuals_loop(x, cholsigmainv_i, self.group.group_iter)\n    return wx",
            "def whiten_groups(self, x, cholsigmainv_i):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    wx = whiten_individuals_loop(x, cholsigmainv_i, self.group.group_iter)\n    return wx",
            "def whiten_groups(self, x, cholsigmainv_i):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    wx = whiten_individuals_loop(x, cholsigmainv_i, self.group.group_iter)\n    return wx",
            "def whiten_groups(self, x, cholsigmainv_i):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    wx = whiten_individuals_loop(x, cholsigmainv_i, self.group.group_iter)\n    return wx",
            "def whiten_groups(self, x, cholsigmainv_i):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    wx = whiten_individuals_loop(x, cholsigmainv_i, self.group.group_iter)\n    return wx"
        ]
    },
    {
        "func_name": "_fit_ols",
        "original": "def _fit_ols(self):\n    self.res_pooled = OLS(self.endog, self.exog).fit()\n    return self.res_pooled",
        "mutated": [
            "def _fit_ols(self):\n    if False:\n        i = 10\n    self.res_pooled = OLS(self.endog, self.exog).fit()\n    return self.res_pooled",
            "def _fit_ols(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.res_pooled = OLS(self.endog, self.exog).fit()\n    return self.res_pooled",
            "def _fit_ols(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.res_pooled = OLS(self.endog, self.exog).fit()\n    return self.res_pooled",
            "def _fit_ols(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.res_pooled = OLS(self.endog, self.exog).fit()\n    return self.res_pooled",
            "def _fit_ols(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.res_pooled = OLS(self.endog, self.exog).fit()\n    return self.res_pooled"
        ]
    },
    {
        "func_name": "_fit_old",
        "original": "def _fit_old(self):\n    res_pooled = self._fit_ols()\n    sigma_i = self.get_within_cov(res_pooled.resid)\n    self.cholsigmainv_i = np.linalg.cholesky(np.linalg.pinv(sigma_i)).T\n    wendog = self.whiten_groups(self.endog, self.cholsigmainv_i)\n    wexog = self.whiten_groups(self.exog, self.cholsigmainv_i)\n    self.res1 = OLS(wendog, wexog).fit()\n    return self.res1",
        "mutated": [
            "def _fit_old(self):\n    if False:\n        i = 10\n    res_pooled = self._fit_ols()\n    sigma_i = self.get_within_cov(res_pooled.resid)\n    self.cholsigmainv_i = np.linalg.cholesky(np.linalg.pinv(sigma_i)).T\n    wendog = self.whiten_groups(self.endog, self.cholsigmainv_i)\n    wexog = self.whiten_groups(self.exog, self.cholsigmainv_i)\n    self.res1 = OLS(wendog, wexog).fit()\n    return self.res1",
            "def _fit_old(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    res_pooled = self._fit_ols()\n    sigma_i = self.get_within_cov(res_pooled.resid)\n    self.cholsigmainv_i = np.linalg.cholesky(np.linalg.pinv(sigma_i)).T\n    wendog = self.whiten_groups(self.endog, self.cholsigmainv_i)\n    wexog = self.whiten_groups(self.exog, self.cholsigmainv_i)\n    self.res1 = OLS(wendog, wexog).fit()\n    return self.res1",
            "def _fit_old(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    res_pooled = self._fit_ols()\n    sigma_i = self.get_within_cov(res_pooled.resid)\n    self.cholsigmainv_i = np.linalg.cholesky(np.linalg.pinv(sigma_i)).T\n    wendog = self.whiten_groups(self.endog, self.cholsigmainv_i)\n    wexog = self.whiten_groups(self.exog, self.cholsigmainv_i)\n    self.res1 = OLS(wendog, wexog).fit()\n    return self.res1",
            "def _fit_old(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    res_pooled = self._fit_ols()\n    sigma_i = self.get_within_cov(res_pooled.resid)\n    self.cholsigmainv_i = np.linalg.cholesky(np.linalg.pinv(sigma_i)).T\n    wendog = self.whiten_groups(self.endog, self.cholsigmainv_i)\n    wexog = self.whiten_groups(self.exog, self.cholsigmainv_i)\n    self.res1 = OLS(wendog, wexog).fit()\n    return self.res1",
            "def _fit_old(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    res_pooled = self._fit_ols()\n    sigma_i = self.get_within_cov(res_pooled.resid)\n    self.cholsigmainv_i = np.linalg.cholesky(np.linalg.pinv(sigma_i)).T\n    wendog = self.whiten_groups(self.endog, self.cholsigmainv_i)\n    wexog = self.whiten_groups(self.exog, self.cholsigmainv_i)\n    self.res1 = OLS(wendog, wexog).fit()\n    return self.res1"
        ]
    },
    {
        "func_name": "whiten",
        "original": "def whiten(self, x):\n    wx = whiten_individuals_loop(x, self.cholsigmainv_i, self.group.group_iter)\n    return wx",
        "mutated": [
            "def whiten(self, x):\n    if False:\n        i = 10\n    wx = whiten_individuals_loop(x, self.cholsigmainv_i, self.group.group_iter)\n    return wx",
            "def whiten(self, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    wx = whiten_individuals_loop(x, self.cholsigmainv_i, self.group.group_iter)\n    return wx",
            "def whiten(self, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    wx = whiten_individuals_loop(x, self.cholsigmainv_i, self.group.group_iter)\n    return wx",
            "def whiten(self, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    wx = whiten_individuals_loop(x, self.cholsigmainv_i, self.group.group_iter)\n    return wx",
            "def whiten(self, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    wx = whiten_individuals_loop(x, self.cholsigmainv_i, self.group.group_iter)\n    return wx"
        ]
    },
    {
        "func_name": "fit_iterative",
        "original": "def fit_iterative(self, maxiter=3):\n    \"\"\"\n        Perform an iterative two-step procedure to estimate the GLS model.\n\n        Parameters\n        ----------\n        maxiter : int, optional\n            the number of iterations\n\n        Notes\n        -----\n        maxiter=1: returns the estimated based on given weights\n        maxiter=2: performs a second estimation with the updated weights,\n                   this is 2-step estimation\n        maxiter>2: iteratively estimate and update the weights\n\n        TODO: possible extension stop iteration if change in parameter\n            estimates is smaller than x_tol\n\n        Repeated calls to fit_iterative, will do one redundant pinv_wexog\n        calculation. Calling fit_iterative(maxiter) once does not do any\n        redundant recalculations (whitening or calculating pinv_wexog).\n        \"\"\"\n    if maxiter < 1:\n        raise ValueError('maxiter needs to be at least 1')\n    import collections\n    self.history = collections.defaultdict(list)\n    for i in range(maxiter):\n        if hasattr(self, 'pinv_wexog'):\n            del self.pinv_wexog\n        results = self.fit()\n        self.history['self_params'].append(results.params)\n        if not i == maxiter - 1:\n            self.results_old = results\n            sigma_i = self.get_within_cov(results.resid)\n            self.cholsigmainv_i = np.linalg.cholesky(np.linalg.pinv(sigma_i)).T\n            self.initialize()\n    return results",
        "mutated": [
            "def fit_iterative(self, maxiter=3):\n    if False:\n        i = 10\n    '\\n        Perform an iterative two-step procedure to estimate the GLS model.\\n\\n        Parameters\\n        ----------\\n        maxiter : int, optional\\n            the number of iterations\\n\\n        Notes\\n        -----\\n        maxiter=1: returns the estimated based on given weights\\n        maxiter=2: performs a second estimation with the updated weights,\\n                   this is 2-step estimation\\n        maxiter>2: iteratively estimate and update the weights\\n\\n        TODO: possible extension stop iteration if change in parameter\\n            estimates is smaller than x_tol\\n\\n        Repeated calls to fit_iterative, will do one redundant pinv_wexog\\n        calculation. Calling fit_iterative(maxiter) once does not do any\\n        redundant recalculations (whitening or calculating pinv_wexog).\\n        '\n    if maxiter < 1:\n        raise ValueError('maxiter needs to be at least 1')\n    import collections\n    self.history = collections.defaultdict(list)\n    for i in range(maxiter):\n        if hasattr(self, 'pinv_wexog'):\n            del self.pinv_wexog\n        results = self.fit()\n        self.history['self_params'].append(results.params)\n        if not i == maxiter - 1:\n            self.results_old = results\n            sigma_i = self.get_within_cov(results.resid)\n            self.cholsigmainv_i = np.linalg.cholesky(np.linalg.pinv(sigma_i)).T\n            self.initialize()\n    return results",
            "def fit_iterative(self, maxiter=3):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Perform an iterative two-step procedure to estimate the GLS model.\\n\\n        Parameters\\n        ----------\\n        maxiter : int, optional\\n            the number of iterations\\n\\n        Notes\\n        -----\\n        maxiter=1: returns the estimated based on given weights\\n        maxiter=2: performs a second estimation with the updated weights,\\n                   this is 2-step estimation\\n        maxiter>2: iteratively estimate and update the weights\\n\\n        TODO: possible extension stop iteration if change in parameter\\n            estimates is smaller than x_tol\\n\\n        Repeated calls to fit_iterative, will do one redundant pinv_wexog\\n        calculation. Calling fit_iterative(maxiter) once does not do any\\n        redundant recalculations (whitening or calculating pinv_wexog).\\n        '\n    if maxiter < 1:\n        raise ValueError('maxiter needs to be at least 1')\n    import collections\n    self.history = collections.defaultdict(list)\n    for i in range(maxiter):\n        if hasattr(self, 'pinv_wexog'):\n            del self.pinv_wexog\n        results = self.fit()\n        self.history['self_params'].append(results.params)\n        if not i == maxiter - 1:\n            self.results_old = results\n            sigma_i = self.get_within_cov(results.resid)\n            self.cholsigmainv_i = np.linalg.cholesky(np.linalg.pinv(sigma_i)).T\n            self.initialize()\n    return results",
            "def fit_iterative(self, maxiter=3):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Perform an iterative two-step procedure to estimate the GLS model.\\n\\n        Parameters\\n        ----------\\n        maxiter : int, optional\\n            the number of iterations\\n\\n        Notes\\n        -----\\n        maxiter=1: returns the estimated based on given weights\\n        maxiter=2: performs a second estimation with the updated weights,\\n                   this is 2-step estimation\\n        maxiter>2: iteratively estimate and update the weights\\n\\n        TODO: possible extension stop iteration if change in parameter\\n            estimates is smaller than x_tol\\n\\n        Repeated calls to fit_iterative, will do one redundant pinv_wexog\\n        calculation. Calling fit_iterative(maxiter) once does not do any\\n        redundant recalculations (whitening or calculating pinv_wexog).\\n        '\n    if maxiter < 1:\n        raise ValueError('maxiter needs to be at least 1')\n    import collections\n    self.history = collections.defaultdict(list)\n    for i in range(maxiter):\n        if hasattr(self, 'pinv_wexog'):\n            del self.pinv_wexog\n        results = self.fit()\n        self.history['self_params'].append(results.params)\n        if not i == maxiter - 1:\n            self.results_old = results\n            sigma_i = self.get_within_cov(results.resid)\n            self.cholsigmainv_i = np.linalg.cholesky(np.linalg.pinv(sigma_i)).T\n            self.initialize()\n    return results",
            "def fit_iterative(self, maxiter=3):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Perform an iterative two-step procedure to estimate the GLS model.\\n\\n        Parameters\\n        ----------\\n        maxiter : int, optional\\n            the number of iterations\\n\\n        Notes\\n        -----\\n        maxiter=1: returns the estimated based on given weights\\n        maxiter=2: performs a second estimation with the updated weights,\\n                   this is 2-step estimation\\n        maxiter>2: iteratively estimate and update the weights\\n\\n        TODO: possible extension stop iteration if change in parameter\\n            estimates is smaller than x_tol\\n\\n        Repeated calls to fit_iterative, will do one redundant pinv_wexog\\n        calculation. Calling fit_iterative(maxiter) once does not do any\\n        redundant recalculations (whitening or calculating pinv_wexog).\\n        '\n    if maxiter < 1:\n        raise ValueError('maxiter needs to be at least 1')\n    import collections\n    self.history = collections.defaultdict(list)\n    for i in range(maxiter):\n        if hasattr(self, 'pinv_wexog'):\n            del self.pinv_wexog\n        results = self.fit()\n        self.history['self_params'].append(results.params)\n        if not i == maxiter - 1:\n            self.results_old = results\n            sigma_i = self.get_within_cov(results.resid)\n            self.cholsigmainv_i = np.linalg.cholesky(np.linalg.pinv(sigma_i)).T\n            self.initialize()\n    return results",
            "def fit_iterative(self, maxiter=3):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Perform an iterative two-step procedure to estimate the GLS model.\\n\\n        Parameters\\n        ----------\\n        maxiter : int, optional\\n            the number of iterations\\n\\n        Notes\\n        -----\\n        maxiter=1: returns the estimated based on given weights\\n        maxiter=2: performs a second estimation with the updated weights,\\n                   this is 2-step estimation\\n        maxiter>2: iteratively estimate and update the weights\\n\\n        TODO: possible extension stop iteration if change in parameter\\n            estimates is smaller than x_tol\\n\\n        Repeated calls to fit_iterative, will do one redundant pinv_wexog\\n        calculation. Calling fit_iterative(maxiter) once does not do any\\n        redundant recalculations (whitening or calculating pinv_wexog).\\n        '\n    if maxiter < 1:\n        raise ValueError('maxiter needs to be at least 1')\n    import collections\n    self.history = collections.defaultdict(list)\n    for i in range(maxiter):\n        if hasattr(self, 'pinv_wexog'):\n            del self.pinv_wexog\n        results = self.fit()\n        self.history['self_params'].append(results.params)\n        if not i == maxiter - 1:\n            self.results_old = results\n            sigma_i = self.get_within_cov(results.resid)\n            self.cholsigmainv_i = np.linalg.cholesky(np.linalg.pinv(sigma_i)).T\n            self.initialize()\n    return results"
        ]
    }
]