[
    {
        "func_name": "full_shape",
        "original": "def full_shape(inner_shape):\n    return array_ops.concat([outer_dimensions, inner_shape], 0)",
        "mutated": [
            "def full_shape(inner_shape):\n    if False:\n        i = 10\n    return array_ops.concat([outer_dimensions, inner_shape], 0)",
            "def full_shape(inner_shape):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return array_ops.concat([outer_dimensions, inner_shape], 0)",
            "def full_shape(inner_shape):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return array_ops.concat([outer_dimensions, inner_shape], 0)",
            "def full_shape(inner_shape):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return array_ops.concat([outer_dimensions, inner_shape], 0)",
            "def full_shape(inner_shape):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return array_ops.concat([outer_dimensions, inner_shape], 0)"
        ]
    },
    {
        "func_name": "overlap_and_add",
        "original": "@tf_export('signal.overlap_and_add')\n@dispatch.add_dispatch_support\ndef overlap_and_add(signal, frame_step, name=None):\n    \"\"\"Reconstructs a signal from a framed representation.\n\n  Adds potentially overlapping frames of a signal with shape\n  `[..., frames, frame_length]`, offsetting subsequent frames by `frame_step`.\n  The resulting tensor has shape `[..., output_size]` where\n\n      output_size = (frames - 1) * frame_step + frame_length\n\n  Args:\n    signal: A [..., frames, frame_length] `Tensor`. All dimensions may be\n      unknown, and rank must be at least 2.\n    frame_step: An integer or scalar `Tensor` denoting overlap offsets. Must be\n      less than or equal to `frame_length`.\n    name: An optional name for the operation.\n\n  Returns:\n    A `Tensor` with shape `[..., output_size]` containing the overlap-added\n    frames of `signal`'s inner-most two dimensions.\n\n  Raises:\n    ValueError: If `signal`'s rank is less than 2, or `frame_step` is not a\n      scalar integer.\n  \"\"\"\n    with ops.name_scope(name, 'overlap_and_add', [signal, frame_step]):\n        signal = ops.convert_to_tensor(signal, name='signal')\n        signal.shape.with_rank_at_least(2)\n        frame_step = ops.convert_to_tensor(frame_step, name='frame_step')\n        frame_step.shape.assert_has_rank(0)\n        if not frame_step.dtype.is_integer:\n            raise ValueError('frame_step must be an integer. Got %s' % frame_step.dtype)\n        frame_step_static = tensor_util.constant_value(frame_step)\n        frame_step_is_static = frame_step_static is not None\n        frame_step = frame_step_static if frame_step_is_static else frame_step\n        signal_shape = array_ops.shape(signal)\n        signal_shape_static = tensor_util.constant_value(signal_shape)\n        if signal_shape_static is not None:\n            signal_shape = signal_shape_static\n        outer_dimensions = signal_shape[:-2]\n        outer_rank = array_ops.size(outer_dimensions)\n        outer_rank_static = tensor_util.constant_value(outer_rank)\n        if outer_rank_static is not None:\n            outer_rank = outer_rank_static\n\n        def full_shape(inner_shape):\n            return array_ops.concat([outer_dimensions, inner_shape], 0)\n        frame_length = signal_shape[-1]\n        frames = signal_shape[-2]\n        output_length = frame_length + frame_step * (frames - 1)\n        if frame_step_is_static and signal.shape.dims is not None and (frame_step == signal.shape.dims[-1].value):\n            output_shape = full_shape([output_length])\n            return array_ops.reshape(signal, output_shape, name='fast_path')\n        segments = -(-frame_length // frame_step)\n        paddings = [[0, segments], [0, segments * frame_step - frame_length]]\n        outer_paddings = array_ops.zeros([outer_rank, 2], dtypes.int32)\n        paddings = array_ops.concat([outer_paddings, paddings], 0)\n        signal = array_ops.pad(signal, paddings)\n        shape = full_shape([frames + segments, segments, frame_step])\n        signal = array_ops.reshape(signal, shape)\n        perm = array_ops.concat([math_ops.range(outer_rank), outer_rank + [1, 0, 2]], 0)\n        perm_static = tensor_util.constant_value(perm)\n        perm = perm_static if perm_static is not None else perm\n        signal = array_ops.transpose(signal, perm)\n        shape = full_shape([(frames + segments) * segments, frame_step])\n        signal = array_ops.reshape(signal, shape)\n        signal = signal[..., :(frames + segments - 1) * segments, :]\n        shape = full_shape([segments, frames + segments - 1, frame_step])\n        signal = array_ops.reshape(signal, shape)\n        signal = math_ops.reduce_sum(signal, -3)\n        shape = full_shape([(frames + segments - 1) * frame_step])\n        signal = array_ops.reshape(signal, shape)\n        signal = signal[..., :output_length]\n        return signal",
        "mutated": [
            "@tf_export('signal.overlap_and_add')\n@dispatch.add_dispatch_support\ndef overlap_and_add(signal, frame_step, name=None):\n    if False:\n        i = 10\n    \"Reconstructs a signal from a framed representation.\\n\\n  Adds potentially overlapping frames of a signal with shape\\n  `[..., frames, frame_length]`, offsetting subsequent frames by `frame_step`.\\n  The resulting tensor has shape `[..., output_size]` where\\n\\n      output_size = (frames - 1) * frame_step + frame_length\\n\\n  Args:\\n    signal: A [..., frames, frame_length] `Tensor`. All dimensions may be\\n      unknown, and rank must be at least 2.\\n    frame_step: An integer or scalar `Tensor` denoting overlap offsets. Must be\\n      less than or equal to `frame_length`.\\n    name: An optional name for the operation.\\n\\n  Returns:\\n    A `Tensor` with shape `[..., output_size]` containing the overlap-added\\n    frames of `signal`'s inner-most two dimensions.\\n\\n  Raises:\\n    ValueError: If `signal`'s rank is less than 2, or `frame_step` is not a\\n      scalar integer.\\n  \"\n    with ops.name_scope(name, 'overlap_and_add', [signal, frame_step]):\n        signal = ops.convert_to_tensor(signal, name='signal')\n        signal.shape.with_rank_at_least(2)\n        frame_step = ops.convert_to_tensor(frame_step, name='frame_step')\n        frame_step.shape.assert_has_rank(0)\n        if not frame_step.dtype.is_integer:\n            raise ValueError('frame_step must be an integer. Got %s' % frame_step.dtype)\n        frame_step_static = tensor_util.constant_value(frame_step)\n        frame_step_is_static = frame_step_static is not None\n        frame_step = frame_step_static if frame_step_is_static else frame_step\n        signal_shape = array_ops.shape(signal)\n        signal_shape_static = tensor_util.constant_value(signal_shape)\n        if signal_shape_static is not None:\n            signal_shape = signal_shape_static\n        outer_dimensions = signal_shape[:-2]\n        outer_rank = array_ops.size(outer_dimensions)\n        outer_rank_static = tensor_util.constant_value(outer_rank)\n        if outer_rank_static is not None:\n            outer_rank = outer_rank_static\n\n        def full_shape(inner_shape):\n            return array_ops.concat([outer_dimensions, inner_shape], 0)\n        frame_length = signal_shape[-1]\n        frames = signal_shape[-2]\n        output_length = frame_length + frame_step * (frames - 1)\n        if frame_step_is_static and signal.shape.dims is not None and (frame_step == signal.shape.dims[-1].value):\n            output_shape = full_shape([output_length])\n            return array_ops.reshape(signal, output_shape, name='fast_path')\n        segments = -(-frame_length // frame_step)\n        paddings = [[0, segments], [0, segments * frame_step - frame_length]]\n        outer_paddings = array_ops.zeros([outer_rank, 2], dtypes.int32)\n        paddings = array_ops.concat([outer_paddings, paddings], 0)\n        signal = array_ops.pad(signal, paddings)\n        shape = full_shape([frames + segments, segments, frame_step])\n        signal = array_ops.reshape(signal, shape)\n        perm = array_ops.concat([math_ops.range(outer_rank), outer_rank + [1, 0, 2]], 0)\n        perm_static = tensor_util.constant_value(perm)\n        perm = perm_static if perm_static is not None else perm\n        signal = array_ops.transpose(signal, perm)\n        shape = full_shape([(frames + segments) * segments, frame_step])\n        signal = array_ops.reshape(signal, shape)\n        signal = signal[..., :(frames + segments - 1) * segments, :]\n        shape = full_shape([segments, frames + segments - 1, frame_step])\n        signal = array_ops.reshape(signal, shape)\n        signal = math_ops.reduce_sum(signal, -3)\n        shape = full_shape([(frames + segments - 1) * frame_step])\n        signal = array_ops.reshape(signal, shape)\n        signal = signal[..., :output_length]\n        return signal",
            "@tf_export('signal.overlap_and_add')\n@dispatch.add_dispatch_support\ndef overlap_and_add(signal, frame_step, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Reconstructs a signal from a framed representation.\\n\\n  Adds potentially overlapping frames of a signal with shape\\n  `[..., frames, frame_length]`, offsetting subsequent frames by `frame_step`.\\n  The resulting tensor has shape `[..., output_size]` where\\n\\n      output_size = (frames - 1) * frame_step + frame_length\\n\\n  Args:\\n    signal: A [..., frames, frame_length] `Tensor`. All dimensions may be\\n      unknown, and rank must be at least 2.\\n    frame_step: An integer or scalar `Tensor` denoting overlap offsets. Must be\\n      less than or equal to `frame_length`.\\n    name: An optional name for the operation.\\n\\n  Returns:\\n    A `Tensor` with shape `[..., output_size]` containing the overlap-added\\n    frames of `signal`'s inner-most two dimensions.\\n\\n  Raises:\\n    ValueError: If `signal`'s rank is less than 2, or `frame_step` is not a\\n      scalar integer.\\n  \"\n    with ops.name_scope(name, 'overlap_and_add', [signal, frame_step]):\n        signal = ops.convert_to_tensor(signal, name='signal')\n        signal.shape.with_rank_at_least(2)\n        frame_step = ops.convert_to_tensor(frame_step, name='frame_step')\n        frame_step.shape.assert_has_rank(0)\n        if not frame_step.dtype.is_integer:\n            raise ValueError('frame_step must be an integer. Got %s' % frame_step.dtype)\n        frame_step_static = tensor_util.constant_value(frame_step)\n        frame_step_is_static = frame_step_static is not None\n        frame_step = frame_step_static if frame_step_is_static else frame_step\n        signal_shape = array_ops.shape(signal)\n        signal_shape_static = tensor_util.constant_value(signal_shape)\n        if signal_shape_static is not None:\n            signal_shape = signal_shape_static\n        outer_dimensions = signal_shape[:-2]\n        outer_rank = array_ops.size(outer_dimensions)\n        outer_rank_static = tensor_util.constant_value(outer_rank)\n        if outer_rank_static is not None:\n            outer_rank = outer_rank_static\n\n        def full_shape(inner_shape):\n            return array_ops.concat([outer_dimensions, inner_shape], 0)\n        frame_length = signal_shape[-1]\n        frames = signal_shape[-2]\n        output_length = frame_length + frame_step * (frames - 1)\n        if frame_step_is_static and signal.shape.dims is not None and (frame_step == signal.shape.dims[-1].value):\n            output_shape = full_shape([output_length])\n            return array_ops.reshape(signal, output_shape, name='fast_path')\n        segments = -(-frame_length // frame_step)\n        paddings = [[0, segments], [0, segments * frame_step - frame_length]]\n        outer_paddings = array_ops.zeros([outer_rank, 2], dtypes.int32)\n        paddings = array_ops.concat([outer_paddings, paddings], 0)\n        signal = array_ops.pad(signal, paddings)\n        shape = full_shape([frames + segments, segments, frame_step])\n        signal = array_ops.reshape(signal, shape)\n        perm = array_ops.concat([math_ops.range(outer_rank), outer_rank + [1, 0, 2]], 0)\n        perm_static = tensor_util.constant_value(perm)\n        perm = perm_static if perm_static is not None else perm\n        signal = array_ops.transpose(signal, perm)\n        shape = full_shape([(frames + segments) * segments, frame_step])\n        signal = array_ops.reshape(signal, shape)\n        signal = signal[..., :(frames + segments - 1) * segments, :]\n        shape = full_shape([segments, frames + segments - 1, frame_step])\n        signal = array_ops.reshape(signal, shape)\n        signal = math_ops.reduce_sum(signal, -3)\n        shape = full_shape([(frames + segments - 1) * frame_step])\n        signal = array_ops.reshape(signal, shape)\n        signal = signal[..., :output_length]\n        return signal",
            "@tf_export('signal.overlap_and_add')\n@dispatch.add_dispatch_support\ndef overlap_and_add(signal, frame_step, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Reconstructs a signal from a framed representation.\\n\\n  Adds potentially overlapping frames of a signal with shape\\n  `[..., frames, frame_length]`, offsetting subsequent frames by `frame_step`.\\n  The resulting tensor has shape `[..., output_size]` where\\n\\n      output_size = (frames - 1) * frame_step + frame_length\\n\\n  Args:\\n    signal: A [..., frames, frame_length] `Tensor`. All dimensions may be\\n      unknown, and rank must be at least 2.\\n    frame_step: An integer or scalar `Tensor` denoting overlap offsets. Must be\\n      less than or equal to `frame_length`.\\n    name: An optional name for the operation.\\n\\n  Returns:\\n    A `Tensor` with shape `[..., output_size]` containing the overlap-added\\n    frames of `signal`'s inner-most two dimensions.\\n\\n  Raises:\\n    ValueError: If `signal`'s rank is less than 2, or `frame_step` is not a\\n      scalar integer.\\n  \"\n    with ops.name_scope(name, 'overlap_and_add', [signal, frame_step]):\n        signal = ops.convert_to_tensor(signal, name='signal')\n        signal.shape.with_rank_at_least(2)\n        frame_step = ops.convert_to_tensor(frame_step, name='frame_step')\n        frame_step.shape.assert_has_rank(0)\n        if not frame_step.dtype.is_integer:\n            raise ValueError('frame_step must be an integer. Got %s' % frame_step.dtype)\n        frame_step_static = tensor_util.constant_value(frame_step)\n        frame_step_is_static = frame_step_static is not None\n        frame_step = frame_step_static if frame_step_is_static else frame_step\n        signal_shape = array_ops.shape(signal)\n        signal_shape_static = tensor_util.constant_value(signal_shape)\n        if signal_shape_static is not None:\n            signal_shape = signal_shape_static\n        outer_dimensions = signal_shape[:-2]\n        outer_rank = array_ops.size(outer_dimensions)\n        outer_rank_static = tensor_util.constant_value(outer_rank)\n        if outer_rank_static is not None:\n            outer_rank = outer_rank_static\n\n        def full_shape(inner_shape):\n            return array_ops.concat([outer_dimensions, inner_shape], 0)\n        frame_length = signal_shape[-1]\n        frames = signal_shape[-2]\n        output_length = frame_length + frame_step * (frames - 1)\n        if frame_step_is_static and signal.shape.dims is not None and (frame_step == signal.shape.dims[-1].value):\n            output_shape = full_shape([output_length])\n            return array_ops.reshape(signal, output_shape, name='fast_path')\n        segments = -(-frame_length // frame_step)\n        paddings = [[0, segments], [0, segments * frame_step - frame_length]]\n        outer_paddings = array_ops.zeros([outer_rank, 2], dtypes.int32)\n        paddings = array_ops.concat([outer_paddings, paddings], 0)\n        signal = array_ops.pad(signal, paddings)\n        shape = full_shape([frames + segments, segments, frame_step])\n        signal = array_ops.reshape(signal, shape)\n        perm = array_ops.concat([math_ops.range(outer_rank), outer_rank + [1, 0, 2]], 0)\n        perm_static = tensor_util.constant_value(perm)\n        perm = perm_static if perm_static is not None else perm\n        signal = array_ops.transpose(signal, perm)\n        shape = full_shape([(frames + segments) * segments, frame_step])\n        signal = array_ops.reshape(signal, shape)\n        signal = signal[..., :(frames + segments - 1) * segments, :]\n        shape = full_shape([segments, frames + segments - 1, frame_step])\n        signal = array_ops.reshape(signal, shape)\n        signal = math_ops.reduce_sum(signal, -3)\n        shape = full_shape([(frames + segments - 1) * frame_step])\n        signal = array_ops.reshape(signal, shape)\n        signal = signal[..., :output_length]\n        return signal",
            "@tf_export('signal.overlap_and_add')\n@dispatch.add_dispatch_support\ndef overlap_and_add(signal, frame_step, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Reconstructs a signal from a framed representation.\\n\\n  Adds potentially overlapping frames of a signal with shape\\n  `[..., frames, frame_length]`, offsetting subsequent frames by `frame_step`.\\n  The resulting tensor has shape `[..., output_size]` where\\n\\n      output_size = (frames - 1) * frame_step + frame_length\\n\\n  Args:\\n    signal: A [..., frames, frame_length] `Tensor`. All dimensions may be\\n      unknown, and rank must be at least 2.\\n    frame_step: An integer or scalar `Tensor` denoting overlap offsets. Must be\\n      less than or equal to `frame_length`.\\n    name: An optional name for the operation.\\n\\n  Returns:\\n    A `Tensor` with shape `[..., output_size]` containing the overlap-added\\n    frames of `signal`'s inner-most two dimensions.\\n\\n  Raises:\\n    ValueError: If `signal`'s rank is less than 2, or `frame_step` is not a\\n      scalar integer.\\n  \"\n    with ops.name_scope(name, 'overlap_and_add', [signal, frame_step]):\n        signal = ops.convert_to_tensor(signal, name='signal')\n        signal.shape.with_rank_at_least(2)\n        frame_step = ops.convert_to_tensor(frame_step, name='frame_step')\n        frame_step.shape.assert_has_rank(0)\n        if not frame_step.dtype.is_integer:\n            raise ValueError('frame_step must be an integer. Got %s' % frame_step.dtype)\n        frame_step_static = tensor_util.constant_value(frame_step)\n        frame_step_is_static = frame_step_static is not None\n        frame_step = frame_step_static if frame_step_is_static else frame_step\n        signal_shape = array_ops.shape(signal)\n        signal_shape_static = tensor_util.constant_value(signal_shape)\n        if signal_shape_static is not None:\n            signal_shape = signal_shape_static\n        outer_dimensions = signal_shape[:-2]\n        outer_rank = array_ops.size(outer_dimensions)\n        outer_rank_static = tensor_util.constant_value(outer_rank)\n        if outer_rank_static is not None:\n            outer_rank = outer_rank_static\n\n        def full_shape(inner_shape):\n            return array_ops.concat([outer_dimensions, inner_shape], 0)\n        frame_length = signal_shape[-1]\n        frames = signal_shape[-2]\n        output_length = frame_length + frame_step * (frames - 1)\n        if frame_step_is_static and signal.shape.dims is not None and (frame_step == signal.shape.dims[-1].value):\n            output_shape = full_shape([output_length])\n            return array_ops.reshape(signal, output_shape, name='fast_path')\n        segments = -(-frame_length // frame_step)\n        paddings = [[0, segments], [0, segments * frame_step - frame_length]]\n        outer_paddings = array_ops.zeros([outer_rank, 2], dtypes.int32)\n        paddings = array_ops.concat([outer_paddings, paddings], 0)\n        signal = array_ops.pad(signal, paddings)\n        shape = full_shape([frames + segments, segments, frame_step])\n        signal = array_ops.reshape(signal, shape)\n        perm = array_ops.concat([math_ops.range(outer_rank), outer_rank + [1, 0, 2]], 0)\n        perm_static = tensor_util.constant_value(perm)\n        perm = perm_static if perm_static is not None else perm\n        signal = array_ops.transpose(signal, perm)\n        shape = full_shape([(frames + segments) * segments, frame_step])\n        signal = array_ops.reshape(signal, shape)\n        signal = signal[..., :(frames + segments - 1) * segments, :]\n        shape = full_shape([segments, frames + segments - 1, frame_step])\n        signal = array_ops.reshape(signal, shape)\n        signal = math_ops.reduce_sum(signal, -3)\n        shape = full_shape([(frames + segments - 1) * frame_step])\n        signal = array_ops.reshape(signal, shape)\n        signal = signal[..., :output_length]\n        return signal",
            "@tf_export('signal.overlap_and_add')\n@dispatch.add_dispatch_support\ndef overlap_and_add(signal, frame_step, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Reconstructs a signal from a framed representation.\\n\\n  Adds potentially overlapping frames of a signal with shape\\n  `[..., frames, frame_length]`, offsetting subsequent frames by `frame_step`.\\n  The resulting tensor has shape `[..., output_size]` where\\n\\n      output_size = (frames - 1) * frame_step + frame_length\\n\\n  Args:\\n    signal: A [..., frames, frame_length] `Tensor`. All dimensions may be\\n      unknown, and rank must be at least 2.\\n    frame_step: An integer or scalar `Tensor` denoting overlap offsets. Must be\\n      less than or equal to `frame_length`.\\n    name: An optional name for the operation.\\n\\n  Returns:\\n    A `Tensor` with shape `[..., output_size]` containing the overlap-added\\n    frames of `signal`'s inner-most two dimensions.\\n\\n  Raises:\\n    ValueError: If `signal`'s rank is less than 2, or `frame_step` is not a\\n      scalar integer.\\n  \"\n    with ops.name_scope(name, 'overlap_and_add', [signal, frame_step]):\n        signal = ops.convert_to_tensor(signal, name='signal')\n        signal.shape.with_rank_at_least(2)\n        frame_step = ops.convert_to_tensor(frame_step, name='frame_step')\n        frame_step.shape.assert_has_rank(0)\n        if not frame_step.dtype.is_integer:\n            raise ValueError('frame_step must be an integer. Got %s' % frame_step.dtype)\n        frame_step_static = tensor_util.constant_value(frame_step)\n        frame_step_is_static = frame_step_static is not None\n        frame_step = frame_step_static if frame_step_is_static else frame_step\n        signal_shape = array_ops.shape(signal)\n        signal_shape_static = tensor_util.constant_value(signal_shape)\n        if signal_shape_static is not None:\n            signal_shape = signal_shape_static\n        outer_dimensions = signal_shape[:-2]\n        outer_rank = array_ops.size(outer_dimensions)\n        outer_rank_static = tensor_util.constant_value(outer_rank)\n        if outer_rank_static is not None:\n            outer_rank = outer_rank_static\n\n        def full_shape(inner_shape):\n            return array_ops.concat([outer_dimensions, inner_shape], 0)\n        frame_length = signal_shape[-1]\n        frames = signal_shape[-2]\n        output_length = frame_length + frame_step * (frames - 1)\n        if frame_step_is_static and signal.shape.dims is not None and (frame_step == signal.shape.dims[-1].value):\n            output_shape = full_shape([output_length])\n            return array_ops.reshape(signal, output_shape, name='fast_path')\n        segments = -(-frame_length // frame_step)\n        paddings = [[0, segments], [0, segments * frame_step - frame_length]]\n        outer_paddings = array_ops.zeros([outer_rank, 2], dtypes.int32)\n        paddings = array_ops.concat([outer_paddings, paddings], 0)\n        signal = array_ops.pad(signal, paddings)\n        shape = full_shape([frames + segments, segments, frame_step])\n        signal = array_ops.reshape(signal, shape)\n        perm = array_ops.concat([math_ops.range(outer_rank), outer_rank + [1, 0, 2]], 0)\n        perm_static = tensor_util.constant_value(perm)\n        perm = perm_static if perm_static is not None else perm\n        signal = array_ops.transpose(signal, perm)\n        shape = full_shape([(frames + segments) * segments, frame_step])\n        signal = array_ops.reshape(signal, shape)\n        signal = signal[..., :(frames + segments - 1) * segments, :]\n        shape = full_shape([segments, frames + segments - 1, frame_step])\n        signal = array_ops.reshape(signal, shape)\n        signal = math_ops.reduce_sum(signal, -3)\n        shape = full_shape([(frames + segments - 1) * frame_step])\n        signal = array_ops.reshape(signal, shape)\n        signal = signal[..., :output_length]\n        return signal"
        ]
    }
]