[
    {
        "func_name": "make_homeserver",
        "original": "def make_homeserver(self, reactor: MemoryReactor, clock: Clock) -> HomeServer:\n    self.mock_federation_transport_client = mock.Mock(spec=['get_room_state_ids', 'get_room_state', 'get_event', 'backfill'])\n    self.mock_federation_transport_client.get_room_state_ids = mock.AsyncMock()\n    self.mock_federation_transport_client.get_room_state = mock.AsyncMock()\n    self.mock_federation_transport_client.get_event = mock.AsyncMock()\n    self.mock_federation_transport_client.backfill = mock.AsyncMock()\n    return super().setup_test_homeserver(federation_transport_client=self.mock_federation_transport_client)",
        "mutated": [
            "def make_homeserver(self, reactor: MemoryReactor, clock: Clock) -> HomeServer:\n    if False:\n        i = 10\n    self.mock_federation_transport_client = mock.Mock(spec=['get_room_state_ids', 'get_room_state', 'get_event', 'backfill'])\n    self.mock_federation_transport_client.get_room_state_ids = mock.AsyncMock()\n    self.mock_federation_transport_client.get_room_state = mock.AsyncMock()\n    self.mock_federation_transport_client.get_event = mock.AsyncMock()\n    self.mock_federation_transport_client.backfill = mock.AsyncMock()\n    return super().setup_test_homeserver(federation_transport_client=self.mock_federation_transport_client)",
            "def make_homeserver(self, reactor: MemoryReactor, clock: Clock) -> HomeServer:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.mock_federation_transport_client = mock.Mock(spec=['get_room_state_ids', 'get_room_state', 'get_event', 'backfill'])\n    self.mock_federation_transport_client.get_room_state_ids = mock.AsyncMock()\n    self.mock_federation_transport_client.get_room_state = mock.AsyncMock()\n    self.mock_federation_transport_client.get_event = mock.AsyncMock()\n    self.mock_federation_transport_client.backfill = mock.AsyncMock()\n    return super().setup_test_homeserver(federation_transport_client=self.mock_federation_transport_client)",
            "def make_homeserver(self, reactor: MemoryReactor, clock: Clock) -> HomeServer:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.mock_federation_transport_client = mock.Mock(spec=['get_room_state_ids', 'get_room_state', 'get_event', 'backfill'])\n    self.mock_federation_transport_client.get_room_state_ids = mock.AsyncMock()\n    self.mock_federation_transport_client.get_room_state = mock.AsyncMock()\n    self.mock_federation_transport_client.get_event = mock.AsyncMock()\n    self.mock_federation_transport_client.backfill = mock.AsyncMock()\n    return super().setup_test_homeserver(federation_transport_client=self.mock_federation_transport_client)",
            "def make_homeserver(self, reactor: MemoryReactor, clock: Clock) -> HomeServer:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.mock_federation_transport_client = mock.Mock(spec=['get_room_state_ids', 'get_room_state', 'get_event', 'backfill'])\n    self.mock_federation_transport_client.get_room_state_ids = mock.AsyncMock()\n    self.mock_federation_transport_client.get_room_state = mock.AsyncMock()\n    self.mock_federation_transport_client.get_event = mock.AsyncMock()\n    self.mock_federation_transport_client.backfill = mock.AsyncMock()\n    return super().setup_test_homeserver(federation_transport_client=self.mock_federation_transport_client)",
            "def make_homeserver(self, reactor: MemoryReactor, clock: Clock) -> HomeServer:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.mock_federation_transport_client = mock.Mock(spec=['get_room_state_ids', 'get_room_state', 'get_event', 'backfill'])\n    self.mock_federation_transport_client.get_room_state_ids = mock.AsyncMock()\n    self.mock_federation_transport_client.get_room_state = mock.AsyncMock()\n    self.mock_federation_transport_client.get_event = mock.AsyncMock()\n    self.mock_federation_transport_client.backfill = mock.AsyncMock()\n    return super().setup_test_homeserver(federation_transport_client=self.mock_federation_transport_client)"
        ]
    },
    {
        "func_name": "test_process_pulled_event_with_missing_state",
        "original": "def test_process_pulled_event_with_missing_state(self) -> None:\n    \"\"\"Ensure that we correctly handle pulled events with lots of missing state\n\n        In this test, we pretend we are processing a \"pulled\" event (eg, via backfill\n        or get_missing_events). The pulled event has a prev_event we haven't previously\n        seen, so the server requests the state at that prev_event. There is a lot\n        of state we don't have, so we expect the server to make a /state request.\n\n        We check that the pulled event is correctly persisted, and that the state is\n        as we expect.\n        \"\"\"\n    return self._test_process_pulled_event_with_missing_state(False)",
        "mutated": [
            "def test_process_pulled_event_with_missing_state(self) -> None:\n    if False:\n        i = 10\n    'Ensure that we correctly handle pulled events with lots of missing state\\n\\n        In this test, we pretend we are processing a \"pulled\" event (eg, via backfill\\n        or get_missing_events). The pulled event has a prev_event we haven\\'t previously\\n        seen, so the server requests the state at that prev_event. There is a lot\\n        of state we don\\'t have, so we expect the server to make a /state request.\\n\\n        We check that the pulled event is correctly persisted, and that the state is\\n        as we expect.\\n        '\n    return self._test_process_pulled_event_with_missing_state(False)",
            "def test_process_pulled_event_with_missing_state(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Ensure that we correctly handle pulled events with lots of missing state\\n\\n        In this test, we pretend we are processing a \"pulled\" event (eg, via backfill\\n        or get_missing_events). The pulled event has a prev_event we haven\\'t previously\\n        seen, so the server requests the state at that prev_event. There is a lot\\n        of state we don\\'t have, so we expect the server to make a /state request.\\n\\n        We check that the pulled event is correctly persisted, and that the state is\\n        as we expect.\\n        '\n    return self._test_process_pulled_event_with_missing_state(False)",
            "def test_process_pulled_event_with_missing_state(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Ensure that we correctly handle pulled events with lots of missing state\\n\\n        In this test, we pretend we are processing a \"pulled\" event (eg, via backfill\\n        or get_missing_events). The pulled event has a prev_event we haven\\'t previously\\n        seen, so the server requests the state at that prev_event. There is a lot\\n        of state we don\\'t have, so we expect the server to make a /state request.\\n\\n        We check that the pulled event is correctly persisted, and that the state is\\n        as we expect.\\n        '\n    return self._test_process_pulled_event_with_missing_state(False)",
            "def test_process_pulled_event_with_missing_state(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Ensure that we correctly handle pulled events with lots of missing state\\n\\n        In this test, we pretend we are processing a \"pulled\" event (eg, via backfill\\n        or get_missing_events). The pulled event has a prev_event we haven\\'t previously\\n        seen, so the server requests the state at that prev_event. There is a lot\\n        of state we don\\'t have, so we expect the server to make a /state request.\\n\\n        We check that the pulled event is correctly persisted, and that the state is\\n        as we expect.\\n        '\n    return self._test_process_pulled_event_with_missing_state(False)",
            "def test_process_pulled_event_with_missing_state(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Ensure that we correctly handle pulled events with lots of missing state\\n\\n        In this test, we pretend we are processing a \"pulled\" event (eg, via backfill\\n        or get_missing_events). The pulled event has a prev_event we haven\\'t previously\\n        seen, so the server requests the state at that prev_event. There is a lot\\n        of state we don\\'t have, so we expect the server to make a /state request.\\n\\n        We check that the pulled event is correctly persisted, and that the state is\\n        as we expect.\\n        '\n    return self._test_process_pulled_event_with_missing_state(False)"
        ]
    },
    {
        "func_name": "test_process_pulled_event_with_missing_state_where_prev_is_outlier",
        "original": "def test_process_pulled_event_with_missing_state_where_prev_is_outlier(self) -> None:\n    \"\"\"Ensure that we correctly handle pulled events with lots of missing state\n\n        A slight modification to test_process_pulled_event_with_missing_state. Again\n        we have a \"pulled\" event which refers to a prev_event with lots of state,\n        but in this case we already have the prev_event (as an outlier, obviously -\n        if it were a regular event, we wouldn't need to request the state).\n        \"\"\"\n    return self._test_process_pulled_event_with_missing_state(True)",
        "mutated": [
            "def test_process_pulled_event_with_missing_state_where_prev_is_outlier(self) -> None:\n    if False:\n        i = 10\n    'Ensure that we correctly handle pulled events with lots of missing state\\n\\n        A slight modification to test_process_pulled_event_with_missing_state. Again\\n        we have a \"pulled\" event which refers to a prev_event with lots of state,\\n        but in this case we already have the prev_event (as an outlier, obviously -\\n        if it were a regular event, we wouldn\\'t need to request the state).\\n        '\n    return self._test_process_pulled_event_with_missing_state(True)",
            "def test_process_pulled_event_with_missing_state_where_prev_is_outlier(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Ensure that we correctly handle pulled events with lots of missing state\\n\\n        A slight modification to test_process_pulled_event_with_missing_state. Again\\n        we have a \"pulled\" event which refers to a prev_event with lots of state,\\n        but in this case we already have the prev_event (as an outlier, obviously -\\n        if it were a regular event, we wouldn\\'t need to request the state).\\n        '\n    return self._test_process_pulled_event_with_missing_state(True)",
            "def test_process_pulled_event_with_missing_state_where_prev_is_outlier(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Ensure that we correctly handle pulled events with lots of missing state\\n\\n        A slight modification to test_process_pulled_event_with_missing_state. Again\\n        we have a \"pulled\" event which refers to a prev_event with lots of state,\\n        but in this case we already have the prev_event (as an outlier, obviously -\\n        if it were a regular event, we wouldn\\'t need to request the state).\\n        '\n    return self._test_process_pulled_event_with_missing_state(True)",
            "def test_process_pulled_event_with_missing_state_where_prev_is_outlier(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Ensure that we correctly handle pulled events with lots of missing state\\n\\n        A slight modification to test_process_pulled_event_with_missing_state. Again\\n        we have a \"pulled\" event which refers to a prev_event with lots of state,\\n        but in this case we already have the prev_event (as an outlier, obviously -\\n        if it were a regular event, we wouldn\\'t need to request the state).\\n        '\n    return self._test_process_pulled_event_with_missing_state(True)",
            "def test_process_pulled_event_with_missing_state_where_prev_is_outlier(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Ensure that we correctly handle pulled events with lots of missing state\\n\\n        A slight modification to test_process_pulled_event_with_missing_state. Again\\n        we have a \"pulled\" event which refers to a prev_event with lots of state,\\n        but in this case we already have the prev_event (as an outlier, obviously -\\n        if it were a regular event, we wouldn\\'t need to request the state).\\n        '\n    return self._test_process_pulled_event_with_missing_state(True)"
        ]
    },
    {
        "func_name": "_test_process_pulled_event_with_missing_state",
        "original": "def _test_process_pulled_event_with_missing_state(self, prev_exists_as_outlier: bool) -> None:\n    OTHER_USER = f'@user:{self.OTHER_SERVER_NAME}'\n    main_store = self.hs.get_datastores().main\n    state_storage_controller = self.hs.get_storage_controllers().state\n    user_id = self.register_user('kermit', 'test')\n    tok = self.login('kermit', 'test')\n    room_id = self.helper.create_room_as(room_creator=user_id, tok=tok)\n    room_version = self.get_success(main_store.get_room_version(room_id))\n    self.helper.send_state(room_id, 'm.room.power_levels', {'events_default': 0, 'state_default': 0}, tok=tok)\n    member_event = self.get_success(event_injection.inject_member_event(self.hs, room_id, OTHER_USER, 'join'))\n    initial_state_map = self.get_success(main_store.get_partial_current_state_ids(room_id))\n    auth_event_ids = [initial_state_map['m.room.create', ''], initial_state_map['m.room.power_levels', ''], member_event.event_id]\n    state_events = [make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'test_state_type', 'state_key': f'state_{i}', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [member_event.event_id], 'auth_events': auth_event_ids, 'origin_server_ts': 1, 'depth': 10, 'content': {'body': f'state_{i}'}}), room_version) for i in range(1, 10)]\n    state_at_prev_event = state_events + self.get_success(main_store.get_events_as_list(initial_state_map.values()))\n    prev_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'test_regular_type', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [], 'auth_events': auth_event_ids, 'origin_server_ts': 1, 'depth': 11, 'content': {'body': 'missing_prev'}}), room_version)\n    if prev_exists_as_outlier:\n        prev_event.internal_metadata.outlier = True\n        persistence = self.hs.get_storage_controllers().persistence\n        assert persistence is not None\n        self.get_success(persistence.persist_event(prev_event, EventContext.for_outlier(self.hs.get_storage_controllers())))\n    else:\n\n        async def get_event(destination: str, event_id: str, timeout: Optional[int]=None) -> JsonDict:\n            self.assertEqual(destination, self.OTHER_SERVER_NAME)\n            self.assertEqual(event_id, prev_event.event_id)\n            return {'pdus': [prev_event.get_pdu_json()]}\n        self.mock_federation_transport_client.get_event.side_effect = get_event\n    pulled_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'test_regular_type', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [prev_event.event_id], 'auth_events': auth_event_ids, 'origin_server_ts': 1, 'depth': 12, 'content': {'body': 'pulled'}}), room_version)\n    self.mock_federation_transport_client.get_room_state_ids.return_value = {'pdu_ids': [e.event_id for e in state_at_prev_event], 'auth_chain_ids': []}\n    self.mock_federation_transport_client.get_room_state.return_value = StateRequestResponse(auth_events=[], state=state_at_prev_event)\n    self.reactor.advance(60000)\n    with LoggingContext('test'):\n        self.get_success(self.hs.get_federation_event_handler()._process_pulled_event(self.OTHER_SERVER_NAME, pulled_event, backfilled=False))\n    persisted = self.get_success(main_store.get_event(pulled_event.event_id))\n    self.assertIsNotNone(persisted, 'pulled event was not persisted at all')\n    self.assertFalse(persisted.internal_metadata.is_outlier(), 'pulled event was an outlier')\n    state = self.get_success(state_storage_controller.get_state_ids_for_event(pulled_event.event_id))\n    expected_state = {(e.type, e.state_key): e.event_id for e in state_at_prev_event}\n    self.assertEqual(state, expected_state)\n    if prev_exists_as_outlier:\n        self.mock_federation_transport_client.get_event.assert_not_called()",
        "mutated": [
            "def _test_process_pulled_event_with_missing_state(self, prev_exists_as_outlier: bool) -> None:\n    if False:\n        i = 10\n    OTHER_USER = f'@user:{self.OTHER_SERVER_NAME}'\n    main_store = self.hs.get_datastores().main\n    state_storage_controller = self.hs.get_storage_controllers().state\n    user_id = self.register_user('kermit', 'test')\n    tok = self.login('kermit', 'test')\n    room_id = self.helper.create_room_as(room_creator=user_id, tok=tok)\n    room_version = self.get_success(main_store.get_room_version(room_id))\n    self.helper.send_state(room_id, 'm.room.power_levels', {'events_default': 0, 'state_default': 0}, tok=tok)\n    member_event = self.get_success(event_injection.inject_member_event(self.hs, room_id, OTHER_USER, 'join'))\n    initial_state_map = self.get_success(main_store.get_partial_current_state_ids(room_id))\n    auth_event_ids = [initial_state_map['m.room.create', ''], initial_state_map['m.room.power_levels', ''], member_event.event_id]\n    state_events = [make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'test_state_type', 'state_key': f'state_{i}', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [member_event.event_id], 'auth_events': auth_event_ids, 'origin_server_ts': 1, 'depth': 10, 'content': {'body': f'state_{i}'}}), room_version) for i in range(1, 10)]\n    state_at_prev_event = state_events + self.get_success(main_store.get_events_as_list(initial_state_map.values()))\n    prev_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'test_regular_type', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [], 'auth_events': auth_event_ids, 'origin_server_ts': 1, 'depth': 11, 'content': {'body': 'missing_prev'}}), room_version)\n    if prev_exists_as_outlier:\n        prev_event.internal_metadata.outlier = True\n        persistence = self.hs.get_storage_controllers().persistence\n        assert persistence is not None\n        self.get_success(persistence.persist_event(prev_event, EventContext.for_outlier(self.hs.get_storage_controllers())))\n    else:\n\n        async def get_event(destination: str, event_id: str, timeout: Optional[int]=None) -> JsonDict:\n            self.assertEqual(destination, self.OTHER_SERVER_NAME)\n            self.assertEqual(event_id, prev_event.event_id)\n            return {'pdus': [prev_event.get_pdu_json()]}\n        self.mock_federation_transport_client.get_event.side_effect = get_event\n    pulled_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'test_regular_type', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [prev_event.event_id], 'auth_events': auth_event_ids, 'origin_server_ts': 1, 'depth': 12, 'content': {'body': 'pulled'}}), room_version)\n    self.mock_federation_transport_client.get_room_state_ids.return_value = {'pdu_ids': [e.event_id for e in state_at_prev_event], 'auth_chain_ids': []}\n    self.mock_federation_transport_client.get_room_state.return_value = StateRequestResponse(auth_events=[], state=state_at_prev_event)\n    self.reactor.advance(60000)\n    with LoggingContext('test'):\n        self.get_success(self.hs.get_federation_event_handler()._process_pulled_event(self.OTHER_SERVER_NAME, pulled_event, backfilled=False))\n    persisted = self.get_success(main_store.get_event(pulled_event.event_id))\n    self.assertIsNotNone(persisted, 'pulled event was not persisted at all')\n    self.assertFalse(persisted.internal_metadata.is_outlier(), 'pulled event was an outlier')\n    state = self.get_success(state_storage_controller.get_state_ids_for_event(pulled_event.event_id))\n    expected_state = {(e.type, e.state_key): e.event_id for e in state_at_prev_event}\n    self.assertEqual(state, expected_state)\n    if prev_exists_as_outlier:\n        self.mock_federation_transport_client.get_event.assert_not_called()",
            "def _test_process_pulled_event_with_missing_state(self, prev_exists_as_outlier: bool) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    OTHER_USER = f'@user:{self.OTHER_SERVER_NAME}'\n    main_store = self.hs.get_datastores().main\n    state_storage_controller = self.hs.get_storage_controllers().state\n    user_id = self.register_user('kermit', 'test')\n    tok = self.login('kermit', 'test')\n    room_id = self.helper.create_room_as(room_creator=user_id, tok=tok)\n    room_version = self.get_success(main_store.get_room_version(room_id))\n    self.helper.send_state(room_id, 'm.room.power_levels', {'events_default': 0, 'state_default': 0}, tok=tok)\n    member_event = self.get_success(event_injection.inject_member_event(self.hs, room_id, OTHER_USER, 'join'))\n    initial_state_map = self.get_success(main_store.get_partial_current_state_ids(room_id))\n    auth_event_ids = [initial_state_map['m.room.create', ''], initial_state_map['m.room.power_levels', ''], member_event.event_id]\n    state_events = [make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'test_state_type', 'state_key': f'state_{i}', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [member_event.event_id], 'auth_events': auth_event_ids, 'origin_server_ts': 1, 'depth': 10, 'content': {'body': f'state_{i}'}}), room_version) for i in range(1, 10)]\n    state_at_prev_event = state_events + self.get_success(main_store.get_events_as_list(initial_state_map.values()))\n    prev_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'test_regular_type', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [], 'auth_events': auth_event_ids, 'origin_server_ts': 1, 'depth': 11, 'content': {'body': 'missing_prev'}}), room_version)\n    if prev_exists_as_outlier:\n        prev_event.internal_metadata.outlier = True\n        persistence = self.hs.get_storage_controllers().persistence\n        assert persistence is not None\n        self.get_success(persistence.persist_event(prev_event, EventContext.for_outlier(self.hs.get_storage_controllers())))\n    else:\n\n        async def get_event(destination: str, event_id: str, timeout: Optional[int]=None) -> JsonDict:\n            self.assertEqual(destination, self.OTHER_SERVER_NAME)\n            self.assertEqual(event_id, prev_event.event_id)\n            return {'pdus': [prev_event.get_pdu_json()]}\n        self.mock_federation_transport_client.get_event.side_effect = get_event\n    pulled_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'test_regular_type', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [prev_event.event_id], 'auth_events': auth_event_ids, 'origin_server_ts': 1, 'depth': 12, 'content': {'body': 'pulled'}}), room_version)\n    self.mock_federation_transport_client.get_room_state_ids.return_value = {'pdu_ids': [e.event_id for e in state_at_prev_event], 'auth_chain_ids': []}\n    self.mock_federation_transport_client.get_room_state.return_value = StateRequestResponse(auth_events=[], state=state_at_prev_event)\n    self.reactor.advance(60000)\n    with LoggingContext('test'):\n        self.get_success(self.hs.get_federation_event_handler()._process_pulled_event(self.OTHER_SERVER_NAME, pulled_event, backfilled=False))\n    persisted = self.get_success(main_store.get_event(pulled_event.event_id))\n    self.assertIsNotNone(persisted, 'pulled event was not persisted at all')\n    self.assertFalse(persisted.internal_metadata.is_outlier(), 'pulled event was an outlier')\n    state = self.get_success(state_storage_controller.get_state_ids_for_event(pulled_event.event_id))\n    expected_state = {(e.type, e.state_key): e.event_id for e in state_at_prev_event}\n    self.assertEqual(state, expected_state)\n    if prev_exists_as_outlier:\n        self.mock_federation_transport_client.get_event.assert_not_called()",
            "def _test_process_pulled_event_with_missing_state(self, prev_exists_as_outlier: bool) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    OTHER_USER = f'@user:{self.OTHER_SERVER_NAME}'\n    main_store = self.hs.get_datastores().main\n    state_storage_controller = self.hs.get_storage_controllers().state\n    user_id = self.register_user('kermit', 'test')\n    tok = self.login('kermit', 'test')\n    room_id = self.helper.create_room_as(room_creator=user_id, tok=tok)\n    room_version = self.get_success(main_store.get_room_version(room_id))\n    self.helper.send_state(room_id, 'm.room.power_levels', {'events_default': 0, 'state_default': 0}, tok=tok)\n    member_event = self.get_success(event_injection.inject_member_event(self.hs, room_id, OTHER_USER, 'join'))\n    initial_state_map = self.get_success(main_store.get_partial_current_state_ids(room_id))\n    auth_event_ids = [initial_state_map['m.room.create', ''], initial_state_map['m.room.power_levels', ''], member_event.event_id]\n    state_events = [make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'test_state_type', 'state_key': f'state_{i}', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [member_event.event_id], 'auth_events': auth_event_ids, 'origin_server_ts': 1, 'depth': 10, 'content': {'body': f'state_{i}'}}), room_version) for i in range(1, 10)]\n    state_at_prev_event = state_events + self.get_success(main_store.get_events_as_list(initial_state_map.values()))\n    prev_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'test_regular_type', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [], 'auth_events': auth_event_ids, 'origin_server_ts': 1, 'depth': 11, 'content': {'body': 'missing_prev'}}), room_version)\n    if prev_exists_as_outlier:\n        prev_event.internal_metadata.outlier = True\n        persistence = self.hs.get_storage_controllers().persistence\n        assert persistence is not None\n        self.get_success(persistence.persist_event(prev_event, EventContext.for_outlier(self.hs.get_storage_controllers())))\n    else:\n\n        async def get_event(destination: str, event_id: str, timeout: Optional[int]=None) -> JsonDict:\n            self.assertEqual(destination, self.OTHER_SERVER_NAME)\n            self.assertEqual(event_id, prev_event.event_id)\n            return {'pdus': [prev_event.get_pdu_json()]}\n        self.mock_federation_transport_client.get_event.side_effect = get_event\n    pulled_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'test_regular_type', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [prev_event.event_id], 'auth_events': auth_event_ids, 'origin_server_ts': 1, 'depth': 12, 'content': {'body': 'pulled'}}), room_version)\n    self.mock_federation_transport_client.get_room_state_ids.return_value = {'pdu_ids': [e.event_id for e in state_at_prev_event], 'auth_chain_ids': []}\n    self.mock_federation_transport_client.get_room_state.return_value = StateRequestResponse(auth_events=[], state=state_at_prev_event)\n    self.reactor.advance(60000)\n    with LoggingContext('test'):\n        self.get_success(self.hs.get_federation_event_handler()._process_pulled_event(self.OTHER_SERVER_NAME, pulled_event, backfilled=False))\n    persisted = self.get_success(main_store.get_event(pulled_event.event_id))\n    self.assertIsNotNone(persisted, 'pulled event was not persisted at all')\n    self.assertFalse(persisted.internal_metadata.is_outlier(), 'pulled event was an outlier')\n    state = self.get_success(state_storage_controller.get_state_ids_for_event(pulled_event.event_id))\n    expected_state = {(e.type, e.state_key): e.event_id for e in state_at_prev_event}\n    self.assertEqual(state, expected_state)\n    if prev_exists_as_outlier:\n        self.mock_federation_transport_client.get_event.assert_not_called()",
            "def _test_process_pulled_event_with_missing_state(self, prev_exists_as_outlier: bool) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    OTHER_USER = f'@user:{self.OTHER_SERVER_NAME}'\n    main_store = self.hs.get_datastores().main\n    state_storage_controller = self.hs.get_storage_controllers().state\n    user_id = self.register_user('kermit', 'test')\n    tok = self.login('kermit', 'test')\n    room_id = self.helper.create_room_as(room_creator=user_id, tok=tok)\n    room_version = self.get_success(main_store.get_room_version(room_id))\n    self.helper.send_state(room_id, 'm.room.power_levels', {'events_default': 0, 'state_default': 0}, tok=tok)\n    member_event = self.get_success(event_injection.inject_member_event(self.hs, room_id, OTHER_USER, 'join'))\n    initial_state_map = self.get_success(main_store.get_partial_current_state_ids(room_id))\n    auth_event_ids = [initial_state_map['m.room.create', ''], initial_state_map['m.room.power_levels', ''], member_event.event_id]\n    state_events = [make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'test_state_type', 'state_key': f'state_{i}', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [member_event.event_id], 'auth_events': auth_event_ids, 'origin_server_ts': 1, 'depth': 10, 'content': {'body': f'state_{i}'}}), room_version) for i in range(1, 10)]\n    state_at_prev_event = state_events + self.get_success(main_store.get_events_as_list(initial_state_map.values()))\n    prev_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'test_regular_type', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [], 'auth_events': auth_event_ids, 'origin_server_ts': 1, 'depth': 11, 'content': {'body': 'missing_prev'}}), room_version)\n    if prev_exists_as_outlier:\n        prev_event.internal_metadata.outlier = True\n        persistence = self.hs.get_storage_controllers().persistence\n        assert persistence is not None\n        self.get_success(persistence.persist_event(prev_event, EventContext.for_outlier(self.hs.get_storage_controllers())))\n    else:\n\n        async def get_event(destination: str, event_id: str, timeout: Optional[int]=None) -> JsonDict:\n            self.assertEqual(destination, self.OTHER_SERVER_NAME)\n            self.assertEqual(event_id, prev_event.event_id)\n            return {'pdus': [prev_event.get_pdu_json()]}\n        self.mock_federation_transport_client.get_event.side_effect = get_event\n    pulled_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'test_regular_type', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [prev_event.event_id], 'auth_events': auth_event_ids, 'origin_server_ts': 1, 'depth': 12, 'content': {'body': 'pulled'}}), room_version)\n    self.mock_federation_transport_client.get_room_state_ids.return_value = {'pdu_ids': [e.event_id for e in state_at_prev_event], 'auth_chain_ids': []}\n    self.mock_federation_transport_client.get_room_state.return_value = StateRequestResponse(auth_events=[], state=state_at_prev_event)\n    self.reactor.advance(60000)\n    with LoggingContext('test'):\n        self.get_success(self.hs.get_federation_event_handler()._process_pulled_event(self.OTHER_SERVER_NAME, pulled_event, backfilled=False))\n    persisted = self.get_success(main_store.get_event(pulled_event.event_id))\n    self.assertIsNotNone(persisted, 'pulled event was not persisted at all')\n    self.assertFalse(persisted.internal_metadata.is_outlier(), 'pulled event was an outlier')\n    state = self.get_success(state_storage_controller.get_state_ids_for_event(pulled_event.event_id))\n    expected_state = {(e.type, e.state_key): e.event_id for e in state_at_prev_event}\n    self.assertEqual(state, expected_state)\n    if prev_exists_as_outlier:\n        self.mock_federation_transport_client.get_event.assert_not_called()",
            "def _test_process_pulled_event_with_missing_state(self, prev_exists_as_outlier: bool) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    OTHER_USER = f'@user:{self.OTHER_SERVER_NAME}'\n    main_store = self.hs.get_datastores().main\n    state_storage_controller = self.hs.get_storage_controllers().state\n    user_id = self.register_user('kermit', 'test')\n    tok = self.login('kermit', 'test')\n    room_id = self.helper.create_room_as(room_creator=user_id, tok=tok)\n    room_version = self.get_success(main_store.get_room_version(room_id))\n    self.helper.send_state(room_id, 'm.room.power_levels', {'events_default': 0, 'state_default': 0}, tok=tok)\n    member_event = self.get_success(event_injection.inject_member_event(self.hs, room_id, OTHER_USER, 'join'))\n    initial_state_map = self.get_success(main_store.get_partial_current_state_ids(room_id))\n    auth_event_ids = [initial_state_map['m.room.create', ''], initial_state_map['m.room.power_levels', ''], member_event.event_id]\n    state_events = [make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'test_state_type', 'state_key': f'state_{i}', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [member_event.event_id], 'auth_events': auth_event_ids, 'origin_server_ts': 1, 'depth': 10, 'content': {'body': f'state_{i}'}}), room_version) for i in range(1, 10)]\n    state_at_prev_event = state_events + self.get_success(main_store.get_events_as_list(initial_state_map.values()))\n    prev_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'test_regular_type', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [], 'auth_events': auth_event_ids, 'origin_server_ts': 1, 'depth': 11, 'content': {'body': 'missing_prev'}}), room_version)\n    if prev_exists_as_outlier:\n        prev_event.internal_metadata.outlier = True\n        persistence = self.hs.get_storage_controllers().persistence\n        assert persistence is not None\n        self.get_success(persistence.persist_event(prev_event, EventContext.for_outlier(self.hs.get_storage_controllers())))\n    else:\n\n        async def get_event(destination: str, event_id: str, timeout: Optional[int]=None) -> JsonDict:\n            self.assertEqual(destination, self.OTHER_SERVER_NAME)\n            self.assertEqual(event_id, prev_event.event_id)\n            return {'pdus': [prev_event.get_pdu_json()]}\n        self.mock_federation_transport_client.get_event.side_effect = get_event\n    pulled_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'test_regular_type', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [prev_event.event_id], 'auth_events': auth_event_ids, 'origin_server_ts': 1, 'depth': 12, 'content': {'body': 'pulled'}}), room_version)\n    self.mock_federation_transport_client.get_room_state_ids.return_value = {'pdu_ids': [e.event_id for e in state_at_prev_event], 'auth_chain_ids': []}\n    self.mock_federation_transport_client.get_room_state.return_value = StateRequestResponse(auth_events=[], state=state_at_prev_event)\n    self.reactor.advance(60000)\n    with LoggingContext('test'):\n        self.get_success(self.hs.get_federation_event_handler()._process_pulled_event(self.OTHER_SERVER_NAME, pulled_event, backfilled=False))\n    persisted = self.get_success(main_store.get_event(pulled_event.event_id))\n    self.assertIsNotNone(persisted, 'pulled event was not persisted at all')\n    self.assertFalse(persisted.internal_metadata.is_outlier(), 'pulled event was an outlier')\n    state = self.get_success(state_storage_controller.get_state_ids_for_event(pulled_event.event_id))\n    expected_state = {(e.type, e.state_key): e.event_id for e in state_at_prev_event}\n    self.assertEqual(state, expected_state)\n    if prev_exists_as_outlier:\n        self.mock_federation_transport_client.get_event.assert_not_called()"
        ]
    },
    {
        "func_name": "test_process_pulled_event_records_failed_backfill_attempts",
        "original": "def test_process_pulled_event_records_failed_backfill_attempts(self) -> None:\n    \"\"\"\n        Test to make sure that failed backfill attempts for an event are\n        recorded in the `event_failed_pull_attempts` table.\n\n        In this test, we pretend we are processing a \"pulled\" event via\n        backfill. The pulled event has a fake `prev_event` which our server has\n        obviously never seen before so it attempts to request the state at that\n        `prev_event` which expectedly fails because it's a fake event. Because\n        the server can't fetch the state at the missing `prev_event`, the\n        \"pulled\" event fails the history check and is fails to process.\n\n        We check that we correctly record the number of failed pull attempts\n        of the pulled event and as a sanity check, that the \"pulled\" event isn't\n        persisted.\n        \"\"\"\n    OTHER_USER = f'@user:{self.OTHER_SERVER_NAME}'\n    main_store = self.hs.get_datastores().main\n    user_id = self.register_user('kermit', 'test')\n    tok = self.login('kermit', 'test')\n    room_id = self.helper.create_room_as(room_creator=user_id, tok=tok)\n    room_version = self.get_success(main_store.get_room_version(room_id))\n    self.mock_federation_transport_client.get_room_state_ids.return_value = {'pdu_ids': [], 'auth_chain_ids': []}\n    self.mock_federation_transport_client.get_room_state.return_value = StateRequestResponse(auth_events=[], state=[])\n    pulled_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'test_regular_type', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': ['$fake_prev_event'], 'auth_events': [], 'origin_server_ts': 1, 'depth': 12, 'content': {'body': 'pulled'}}), room_version)\n    with LoggingContext('test'):\n        self.get_success(self.hs.get_federation_event_handler()._process_pulled_event(self.OTHER_SERVER_NAME, pulled_event, backfilled=True))\n    backfill_num_attempts = self.get_success(main_store.db_pool.simple_select_one_onecol(table='event_failed_pull_attempts', keyvalues={'event_id': pulled_event.event_id}, retcol='num_attempts'))\n    self.assertEqual(backfill_num_attempts, 1)\n    with LoggingContext('test'):\n        self.get_success(self.hs.get_federation_event_handler()._process_pulled_event(self.OTHER_SERVER_NAME, pulled_event, backfilled=True))\n    backfill_num_attempts = self.get_success(main_store.db_pool.simple_select_one_onecol(table='event_failed_pull_attempts', keyvalues={'event_id': pulled_event.event_id}, retcol='num_attempts'))\n    self.assertEqual(backfill_num_attempts, 2)\n    persisted = self.get_success(main_store.get_event(pulled_event.event_id, allow_none=True))\n    self.assertIsNone(persisted, 'pulled event that fails the history check should not be persisted at all')",
        "mutated": [
            "def test_process_pulled_event_records_failed_backfill_attempts(self) -> None:\n    if False:\n        i = 10\n    '\\n        Test to make sure that failed backfill attempts for an event are\\n        recorded in the `event_failed_pull_attempts` table.\\n\\n        In this test, we pretend we are processing a \"pulled\" event via\\n        backfill. The pulled event has a fake `prev_event` which our server has\\n        obviously never seen before so it attempts to request the state at that\\n        `prev_event` which expectedly fails because it\\'s a fake event. Because\\n        the server can\\'t fetch the state at the missing `prev_event`, the\\n        \"pulled\" event fails the history check and is fails to process.\\n\\n        We check that we correctly record the number of failed pull attempts\\n        of the pulled event and as a sanity check, that the \"pulled\" event isn\\'t\\n        persisted.\\n        '\n    OTHER_USER = f'@user:{self.OTHER_SERVER_NAME}'\n    main_store = self.hs.get_datastores().main\n    user_id = self.register_user('kermit', 'test')\n    tok = self.login('kermit', 'test')\n    room_id = self.helper.create_room_as(room_creator=user_id, tok=tok)\n    room_version = self.get_success(main_store.get_room_version(room_id))\n    self.mock_federation_transport_client.get_room_state_ids.return_value = {'pdu_ids': [], 'auth_chain_ids': []}\n    self.mock_federation_transport_client.get_room_state.return_value = StateRequestResponse(auth_events=[], state=[])\n    pulled_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'test_regular_type', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': ['$fake_prev_event'], 'auth_events': [], 'origin_server_ts': 1, 'depth': 12, 'content': {'body': 'pulled'}}), room_version)\n    with LoggingContext('test'):\n        self.get_success(self.hs.get_federation_event_handler()._process_pulled_event(self.OTHER_SERVER_NAME, pulled_event, backfilled=True))\n    backfill_num_attempts = self.get_success(main_store.db_pool.simple_select_one_onecol(table='event_failed_pull_attempts', keyvalues={'event_id': pulled_event.event_id}, retcol='num_attempts'))\n    self.assertEqual(backfill_num_attempts, 1)\n    with LoggingContext('test'):\n        self.get_success(self.hs.get_federation_event_handler()._process_pulled_event(self.OTHER_SERVER_NAME, pulled_event, backfilled=True))\n    backfill_num_attempts = self.get_success(main_store.db_pool.simple_select_one_onecol(table='event_failed_pull_attempts', keyvalues={'event_id': pulled_event.event_id}, retcol='num_attempts'))\n    self.assertEqual(backfill_num_attempts, 2)\n    persisted = self.get_success(main_store.get_event(pulled_event.event_id, allow_none=True))\n    self.assertIsNone(persisted, 'pulled event that fails the history check should not be persisted at all')",
            "def test_process_pulled_event_records_failed_backfill_attempts(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Test to make sure that failed backfill attempts for an event are\\n        recorded in the `event_failed_pull_attempts` table.\\n\\n        In this test, we pretend we are processing a \"pulled\" event via\\n        backfill. The pulled event has a fake `prev_event` which our server has\\n        obviously never seen before so it attempts to request the state at that\\n        `prev_event` which expectedly fails because it\\'s a fake event. Because\\n        the server can\\'t fetch the state at the missing `prev_event`, the\\n        \"pulled\" event fails the history check and is fails to process.\\n\\n        We check that we correctly record the number of failed pull attempts\\n        of the pulled event and as a sanity check, that the \"pulled\" event isn\\'t\\n        persisted.\\n        '\n    OTHER_USER = f'@user:{self.OTHER_SERVER_NAME}'\n    main_store = self.hs.get_datastores().main\n    user_id = self.register_user('kermit', 'test')\n    tok = self.login('kermit', 'test')\n    room_id = self.helper.create_room_as(room_creator=user_id, tok=tok)\n    room_version = self.get_success(main_store.get_room_version(room_id))\n    self.mock_federation_transport_client.get_room_state_ids.return_value = {'pdu_ids': [], 'auth_chain_ids': []}\n    self.mock_federation_transport_client.get_room_state.return_value = StateRequestResponse(auth_events=[], state=[])\n    pulled_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'test_regular_type', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': ['$fake_prev_event'], 'auth_events': [], 'origin_server_ts': 1, 'depth': 12, 'content': {'body': 'pulled'}}), room_version)\n    with LoggingContext('test'):\n        self.get_success(self.hs.get_federation_event_handler()._process_pulled_event(self.OTHER_SERVER_NAME, pulled_event, backfilled=True))\n    backfill_num_attempts = self.get_success(main_store.db_pool.simple_select_one_onecol(table='event_failed_pull_attempts', keyvalues={'event_id': pulled_event.event_id}, retcol='num_attempts'))\n    self.assertEqual(backfill_num_attempts, 1)\n    with LoggingContext('test'):\n        self.get_success(self.hs.get_federation_event_handler()._process_pulled_event(self.OTHER_SERVER_NAME, pulled_event, backfilled=True))\n    backfill_num_attempts = self.get_success(main_store.db_pool.simple_select_one_onecol(table='event_failed_pull_attempts', keyvalues={'event_id': pulled_event.event_id}, retcol='num_attempts'))\n    self.assertEqual(backfill_num_attempts, 2)\n    persisted = self.get_success(main_store.get_event(pulled_event.event_id, allow_none=True))\n    self.assertIsNone(persisted, 'pulled event that fails the history check should not be persisted at all')",
            "def test_process_pulled_event_records_failed_backfill_attempts(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Test to make sure that failed backfill attempts for an event are\\n        recorded in the `event_failed_pull_attempts` table.\\n\\n        In this test, we pretend we are processing a \"pulled\" event via\\n        backfill. The pulled event has a fake `prev_event` which our server has\\n        obviously never seen before so it attempts to request the state at that\\n        `prev_event` which expectedly fails because it\\'s a fake event. Because\\n        the server can\\'t fetch the state at the missing `prev_event`, the\\n        \"pulled\" event fails the history check and is fails to process.\\n\\n        We check that we correctly record the number of failed pull attempts\\n        of the pulled event and as a sanity check, that the \"pulled\" event isn\\'t\\n        persisted.\\n        '\n    OTHER_USER = f'@user:{self.OTHER_SERVER_NAME}'\n    main_store = self.hs.get_datastores().main\n    user_id = self.register_user('kermit', 'test')\n    tok = self.login('kermit', 'test')\n    room_id = self.helper.create_room_as(room_creator=user_id, tok=tok)\n    room_version = self.get_success(main_store.get_room_version(room_id))\n    self.mock_federation_transport_client.get_room_state_ids.return_value = {'pdu_ids': [], 'auth_chain_ids': []}\n    self.mock_federation_transport_client.get_room_state.return_value = StateRequestResponse(auth_events=[], state=[])\n    pulled_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'test_regular_type', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': ['$fake_prev_event'], 'auth_events': [], 'origin_server_ts': 1, 'depth': 12, 'content': {'body': 'pulled'}}), room_version)\n    with LoggingContext('test'):\n        self.get_success(self.hs.get_federation_event_handler()._process_pulled_event(self.OTHER_SERVER_NAME, pulled_event, backfilled=True))\n    backfill_num_attempts = self.get_success(main_store.db_pool.simple_select_one_onecol(table='event_failed_pull_attempts', keyvalues={'event_id': pulled_event.event_id}, retcol='num_attempts'))\n    self.assertEqual(backfill_num_attempts, 1)\n    with LoggingContext('test'):\n        self.get_success(self.hs.get_federation_event_handler()._process_pulled_event(self.OTHER_SERVER_NAME, pulled_event, backfilled=True))\n    backfill_num_attempts = self.get_success(main_store.db_pool.simple_select_one_onecol(table='event_failed_pull_attempts', keyvalues={'event_id': pulled_event.event_id}, retcol='num_attempts'))\n    self.assertEqual(backfill_num_attempts, 2)\n    persisted = self.get_success(main_store.get_event(pulled_event.event_id, allow_none=True))\n    self.assertIsNone(persisted, 'pulled event that fails the history check should not be persisted at all')",
            "def test_process_pulled_event_records_failed_backfill_attempts(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Test to make sure that failed backfill attempts for an event are\\n        recorded in the `event_failed_pull_attempts` table.\\n\\n        In this test, we pretend we are processing a \"pulled\" event via\\n        backfill. The pulled event has a fake `prev_event` which our server has\\n        obviously never seen before so it attempts to request the state at that\\n        `prev_event` which expectedly fails because it\\'s a fake event. Because\\n        the server can\\'t fetch the state at the missing `prev_event`, the\\n        \"pulled\" event fails the history check and is fails to process.\\n\\n        We check that we correctly record the number of failed pull attempts\\n        of the pulled event and as a sanity check, that the \"pulled\" event isn\\'t\\n        persisted.\\n        '\n    OTHER_USER = f'@user:{self.OTHER_SERVER_NAME}'\n    main_store = self.hs.get_datastores().main\n    user_id = self.register_user('kermit', 'test')\n    tok = self.login('kermit', 'test')\n    room_id = self.helper.create_room_as(room_creator=user_id, tok=tok)\n    room_version = self.get_success(main_store.get_room_version(room_id))\n    self.mock_federation_transport_client.get_room_state_ids.return_value = {'pdu_ids': [], 'auth_chain_ids': []}\n    self.mock_federation_transport_client.get_room_state.return_value = StateRequestResponse(auth_events=[], state=[])\n    pulled_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'test_regular_type', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': ['$fake_prev_event'], 'auth_events': [], 'origin_server_ts': 1, 'depth': 12, 'content': {'body': 'pulled'}}), room_version)\n    with LoggingContext('test'):\n        self.get_success(self.hs.get_federation_event_handler()._process_pulled_event(self.OTHER_SERVER_NAME, pulled_event, backfilled=True))\n    backfill_num_attempts = self.get_success(main_store.db_pool.simple_select_one_onecol(table='event_failed_pull_attempts', keyvalues={'event_id': pulled_event.event_id}, retcol='num_attempts'))\n    self.assertEqual(backfill_num_attempts, 1)\n    with LoggingContext('test'):\n        self.get_success(self.hs.get_federation_event_handler()._process_pulled_event(self.OTHER_SERVER_NAME, pulled_event, backfilled=True))\n    backfill_num_attempts = self.get_success(main_store.db_pool.simple_select_one_onecol(table='event_failed_pull_attempts', keyvalues={'event_id': pulled_event.event_id}, retcol='num_attempts'))\n    self.assertEqual(backfill_num_attempts, 2)\n    persisted = self.get_success(main_store.get_event(pulled_event.event_id, allow_none=True))\n    self.assertIsNone(persisted, 'pulled event that fails the history check should not be persisted at all')",
            "def test_process_pulled_event_records_failed_backfill_attempts(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Test to make sure that failed backfill attempts for an event are\\n        recorded in the `event_failed_pull_attempts` table.\\n\\n        In this test, we pretend we are processing a \"pulled\" event via\\n        backfill. The pulled event has a fake `prev_event` which our server has\\n        obviously never seen before so it attempts to request the state at that\\n        `prev_event` which expectedly fails because it\\'s a fake event. Because\\n        the server can\\'t fetch the state at the missing `prev_event`, the\\n        \"pulled\" event fails the history check and is fails to process.\\n\\n        We check that we correctly record the number of failed pull attempts\\n        of the pulled event and as a sanity check, that the \"pulled\" event isn\\'t\\n        persisted.\\n        '\n    OTHER_USER = f'@user:{self.OTHER_SERVER_NAME}'\n    main_store = self.hs.get_datastores().main\n    user_id = self.register_user('kermit', 'test')\n    tok = self.login('kermit', 'test')\n    room_id = self.helper.create_room_as(room_creator=user_id, tok=tok)\n    room_version = self.get_success(main_store.get_room_version(room_id))\n    self.mock_federation_transport_client.get_room_state_ids.return_value = {'pdu_ids': [], 'auth_chain_ids': []}\n    self.mock_federation_transport_client.get_room_state.return_value = StateRequestResponse(auth_events=[], state=[])\n    pulled_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'test_regular_type', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': ['$fake_prev_event'], 'auth_events': [], 'origin_server_ts': 1, 'depth': 12, 'content': {'body': 'pulled'}}), room_version)\n    with LoggingContext('test'):\n        self.get_success(self.hs.get_federation_event_handler()._process_pulled_event(self.OTHER_SERVER_NAME, pulled_event, backfilled=True))\n    backfill_num_attempts = self.get_success(main_store.db_pool.simple_select_one_onecol(table='event_failed_pull_attempts', keyvalues={'event_id': pulled_event.event_id}, retcol='num_attempts'))\n    self.assertEqual(backfill_num_attempts, 1)\n    with LoggingContext('test'):\n        self.get_success(self.hs.get_federation_event_handler()._process_pulled_event(self.OTHER_SERVER_NAME, pulled_event, backfilled=True))\n    backfill_num_attempts = self.get_success(main_store.db_pool.simple_select_one_onecol(table='event_failed_pull_attempts', keyvalues={'event_id': pulled_event.event_id}, retcol='num_attempts'))\n    self.assertEqual(backfill_num_attempts, 2)\n    persisted = self.get_success(main_store.get_event(pulled_event.event_id, allow_none=True))\n    self.assertIsNone(persisted, 'pulled event that fails the history check should not be persisted at all')"
        ]
    },
    {
        "func_name": "test_process_pulled_event_clears_backfill_attempts_after_being_successfully_persisted",
        "original": "def test_process_pulled_event_clears_backfill_attempts_after_being_successfully_persisted(self) -> None:\n    \"\"\"\n        Test to make sure that failed pull attempts\n        (`event_failed_pull_attempts` table) for an event are cleared after the\n        event is successfully persisted.\n\n        In this test, we pretend we are processing a \"pulled\" event via\n        backfill. The pulled event succesfully processes and the backward\n        extremeties are updated along with clearing out any failed pull attempts\n        for those old extremities.\n\n        We check that we correctly cleared failed pull attempts of the\n        pulled event.\n        \"\"\"\n    OTHER_USER = f'@user:{self.OTHER_SERVER_NAME}'\n    main_store = self.hs.get_datastores().main\n    user_id = self.register_user('kermit', 'test')\n    tok = self.login('kermit', 'test')\n    room_id = self.helper.create_room_as(room_creator=user_id, tok=tok)\n    room_version = self.get_success(main_store.get_room_version(room_id))\n    self.helper.send_state(room_id, 'm.room.power_levels', {'events_default': 0, 'state_default': 0}, tok=tok)\n    member_event = self.get_success(event_injection.inject_member_event(self.hs, room_id, OTHER_USER, 'join'))\n    initial_state_map = self.get_success(main_store.get_partial_current_state_ids(room_id))\n    auth_event_ids = [initial_state_map['m.room.create', ''], initial_state_map['m.room.power_levels', ''], member_event.event_id]\n    pulled_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'test_regular_type', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [member_event.event_id], 'auth_events': auth_event_ids, 'origin_server_ts': 1, 'depth': 12, 'content': {'body': 'pulled'}}), room_version)\n    self.get_success(main_store.record_event_failed_pull_attempt(pulled_event.room_id, pulled_event.event_id, 'fake cause'))\n    backfill_num_attempts = self.get_success(main_store.db_pool.simple_select_one_onecol(table='event_failed_pull_attempts', keyvalues={'event_id': pulled_event.event_id}, retcol='num_attempts'))\n    self.assertEqual(backfill_num_attempts, 1)\n    with LoggingContext('test'):\n        self.get_success(self.hs.get_federation_event_handler()._process_pulled_event(self.OTHER_SERVER_NAME, pulled_event, backfilled=True))\n    backfill_num_attempts = self.get_success(main_store.db_pool.simple_select_one_onecol(table='event_failed_pull_attempts', keyvalues={'event_id': pulled_event.event_id}, retcol='num_attempts', allow_none=True))\n    self.assertIsNone(backfill_num_attempts)\n    persisted = self.get_success(main_store.get_event(pulled_event.event_id, allow_none=True))\n    self.assertIsNotNone(persisted, 'pulled event was not persisted at all')",
        "mutated": [
            "def test_process_pulled_event_clears_backfill_attempts_after_being_successfully_persisted(self) -> None:\n    if False:\n        i = 10\n    '\\n        Test to make sure that failed pull attempts\\n        (`event_failed_pull_attempts` table) for an event are cleared after the\\n        event is successfully persisted.\\n\\n        In this test, we pretend we are processing a \"pulled\" event via\\n        backfill. The pulled event succesfully processes and the backward\\n        extremeties are updated along with clearing out any failed pull attempts\\n        for those old extremities.\\n\\n        We check that we correctly cleared failed pull attempts of the\\n        pulled event.\\n        '\n    OTHER_USER = f'@user:{self.OTHER_SERVER_NAME}'\n    main_store = self.hs.get_datastores().main\n    user_id = self.register_user('kermit', 'test')\n    tok = self.login('kermit', 'test')\n    room_id = self.helper.create_room_as(room_creator=user_id, tok=tok)\n    room_version = self.get_success(main_store.get_room_version(room_id))\n    self.helper.send_state(room_id, 'm.room.power_levels', {'events_default': 0, 'state_default': 0}, tok=tok)\n    member_event = self.get_success(event_injection.inject_member_event(self.hs, room_id, OTHER_USER, 'join'))\n    initial_state_map = self.get_success(main_store.get_partial_current_state_ids(room_id))\n    auth_event_ids = [initial_state_map['m.room.create', ''], initial_state_map['m.room.power_levels', ''], member_event.event_id]\n    pulled_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'test_regular_type', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [member_event.event_id], 'auth_events': auth_event_ids, 'origin_server_ts': 1, 'depth': 12, 'content': {'body': 'pulled'}}), room_version)\n    self.get_success(main_store.record_event_failed_pull_attempt(pulled_event.room_id, pulled_event.event_id, 'fake cause'))\n    backfill_num_attempts = self.get_success(main_store.db_pool.simple_select_one_onecol(table='event_failed_pull_attempts', keyvalues={'event_id': pulled_event.event_id}, retcol='num_attempts'))\n    self.assertEqual(backfill_num_attempts, 1)\n    with LoggingContext('test'):\n        self.get_success(self.hs.get_federation_event_handler()._process_pulled_event(self.OTHER_SERVER_NAME, pulled_event, backfilled=True))\n    backfill_num_attempts = self.get_success(main_store.db_pool.simple_select_one_onecol(table='event_failed_pull_attempts', keyvalues={'event_id': pulled_event.event_id}, retcol='num_attempts', allow_none=True))\n    self.assertIsNone(backfill_num_attempts)\n    persisted = self.get_success(main_store.get_event(pulled_event.event_id, allow_none=True))\n    self.assertIsNotNone(persisted, 'pulled event was not persisted at all')",
            "def test_process_pulled_event_clears_backfill_attempts_after_being_successfully_persisted(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Test to make sure that failed pull attempts\\n        (`event_failed_pull_attempts` table) for an event are cleared after the\\n        event is successfully persisted.\\n\\n        In this test, we pretend we are processing a \"pulled\" event via\\n        backfill. The pulled event succesfully processes and the backward\\n        extremeties are updated along with clearing out any failed pull attempts\\n        for those old extremities.\\n\\n        We check that we correctly cleared failed pull attempts of the\\n        pulled event.\\n        '\n    OTHER_USER = f'@user:{self.OTHER_SERVER_NAME}'\n    main_store = self.hs.get_datastores().main\n    user_id = self.register_user('kermit', 'test')\n    tok = self.login('kermit', 'test')\n    room_id = self.helper.create_room_as(room_creator=user_id, tok=tok)\n    room_version = self.get_success(main_store.get_room_version(room_id))\n    self.helper.send_state(room_id, 'm.room.power_levels', {'events_default': 0, 'state_default': 0}, tok=tok)\n    member_event = self.get_success(event_injection.inject_member_event(self.hs, room_id, OTHER_USER, 'join'))\n    initial_state_map = self.get_success(main_store.get_partial_current_state_ids(room_id))\n    auth_event_ids = [initial_state_map['m.room.create', ''], initial_state_map['m.room.power_levels', ''], member_event.event_id]\n    pulled_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'test_regular_type', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [member_event.event_id], 'auth_events': auth_event_ids, 'origin_server_ts': 1, 'depth': 12, 'content': {'body': 'pulled'}}), room_version)\n    self.get_success(main_store.record_event_failed_pull_attempt(pulled_event.room_id, pulled_event.event_id, 'fake cause'))\n    backfill_num_attempts = self.get_success(main_store.db_pool.simple_select_one_onecol(table='event_failed_pull_attempts', keyvalues={'event_id': pulled_event.event_id}, retcol='num_attempts'))\n    self.assertEqual(backfill_num_attempts, 1)\n    with LoggingContext('test'):\n        self.get_success(self.hs.get_federation_event_handler()._process_pulled_event(self.OTHER_SERVER_NAME, pulled_event, backfilled=True))\n    backfill_num_attempts = self.get_success(main_store.db_pool.simple_select_one_onecol(table='event_failed_pull_attempts', keyvalues={'event_id': pulled_event.event_id}, retcol='num_attempts', allow_none=True))\n    self.assertIsNone(backfill_num_attempts)\n    persisted = self.get_success(main_store.get_event(pulled_event.event_id, allow_none=True))\n    self.assertIsNotNone(persisted, 'pulled event was not persisted at all')",
            "def test_process_pulled_event_clears_backfill_attempts_after_being_successfully_persisted(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Test to make sure that failed pull attempts\\n        (`event_failed_pull_attempts` table) for an event are cleared after the\\n        event is successfully persisted.\\n\\n        In this test, we pretend we are processing a \"pulled\" event via\\n        backfill. The pulled event succesfully processes and the backward\\n        extremeties are updated along with clearing out any failed pull attempts\\n        for those old extremities.\\n\\n        We check that we correctly cleared failed pull attempts of the\\n        pulled event.\\n        '\n    OTHER_USER = f'@user:{self.OTHER_SERVER_NAME}'\n    main_store = self.hs.get_datastores().main\n    user_id = self.register_user('kermit', 'test')\n    tok = self.login('kermit', 'test')\n    room_id = self.helper.create_room_as(room_creator=user_id, tok=tok)\n    room_version = self.get_success(main_store.get_room_version(room_id))\n    self.helper.send_state(room_id, 'm.room.power_levels', {'events_default': 0, 'state_default': 0}, tok=tok)\n    member_event = self.get_success(event_injection.inject_member_event(self.hs, room_id, OTHER_USER, 'join'))\n    initial_state_map = self.get_success(main_store.get_partial_current_state_ids(room_id))\n    auth_event_ids = [initial_state_map['m.room.create', ''], initial_state_map['m.room.power_levels', ''], member_event.event_id]\n    pulled_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'test_regular_type', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [member_event.event_id], 'auth_events': auth_event_ids, 'origin_server_ts': 1, 'depth': 12, 'content': {'body': 'pulled'}}), room_version)\n    self.get_success(main_store.record_event_failed_pull_attempt(pulled_event.room_id, pulled_event.event_id, 'fake cause'))\n    backfill_num_attempts = self.get_success(main_store.db_pool.simple_select_one_onecol(table='event_failed_pull_attempts', keyvalues={'event_id': pulled_event.event_id}, retcol='num_attempts'))\n    self.assertEqual(backfill_num_attempts, 1)\n    with LoggingContext('test'):\n        self.get_success(self.hs.get_federation_event_handler()._process_pulled_event(self.OTHER_SERVER_NAME, pulled_event, backfilled=True))\n    backfill_num_attempts = self.get_success(main_store.db_pool.simple_select_one_onecol(table='event_failed_pull_attempts', keyvalues={'event_id': pulled_event.event_id}, retcol='num_attempts', allow_none=True))\n    self.assertIsNone(backfill_num_attempts)\n    persisted = self.get_success(main_store.get_event(pulled_event.event_id, allow_none=True))\n    self.assertIsNotNone(persisted, 'pulled event was not persisted at all')",
            "def test_process_pulled_event_clears_backfill_attempts_after_being_successfully_persisted(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Test to make sure that failed pull attempts\\n        (`event_failed_pull_attempts` table) for an event are cleared after the\\n        event is successfully persisted.\\n\\n        In this test, we pretend we are processing a \"pulled\" event via\\n        backfill. The pulled event succesfully processes and the backward\\n        extremeties are updated along with clearing out any failed pull attempts\\n        for those old extremities.\\n\\n        We check that we correctly cleared failed pull attempts of the\\n        pulled event.\\n        '\n    OTHER_USER = f'@user:{self.OTHER_SERVER_NAME}'\n    main_store = self.hs.get_datastores().main\n    user_id = self.register_user('kermit', 'test')\n    tok = self.login('kermit', 'test')\n    room_id = self.helper.create_room_as(room_creator=user_id, tok=tok)\n    room_version = self.get_success(main_store.get_room_version(room_id))\n    self.helper.send_state(room_id, 'm.room.power_levels', {'events_default': 0, 'state_default': 0}, tok=tok)\n    member_event = self.get_success(event_injection.inject_member_event(self.hs, room_id, OTHER_USER, 'join'))\n    initial_state_map = self.get_success(main_store.get_partial_current_state_ids(room_id))\n    auth_event_ids = [initial_state_map['m.room.create', ''], initial_state_map['m.room.power_levels', ''], member_event.event_id]\n    pulled_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'test_regular_type', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [member_event.event_id], 'auth_events': auth_event_ids, 'origin_server_ts': 1, 'depth': 12, 'content': {'body': 'pulled'}}), room_version)\n    self.get_success(main_store.record_event_failed_pull_attempt(pulled_event.room_id, pulled_event.event_id, 'fake cause'))\n    backfill_num_attempts = self.get_success(main_store.db_pool.simple_select_one_onecol(table='event_failed_pull_attempts', keyvalues={'event_id': pulled_event.event_id}, retcol='num_attempts'))\n    self.assertEqual(backfill_num_attempts, 1)\n    with LoggingContext('test'):\n        self.get_success(self.hs.get_federation_event_handler()._process_pulled_event(self.OTHER_SERVER_NAME, pulled_event, backfilled=True))\n    backfill_num_attempts = self.get_success(main_store.db_pool.simple_select_one_onecol(table='event_failed_pull_attempts', keyvalues={'event_id': pulled_event.event_id}, retcol='num_attempts', allow_none=True))\n    self.assertIsNone(backfill_num_attempts)\n    persisted = self.get_success(main_store.get_event(pulled_event.event_id, allow_none=True))\n    self.assertIsNotNone(persisted, 'pulled event was not persisted at all')",
            "def test_process_pulled_event_clears_backfill_attempts_after_being_successfully_persisted(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Test to make sure that failed pull attempts\\n        (`event_failed_pull_attempts` table) for an event are cleared after the\\n        event is successfully persisted.\\n\\n        In this test, we pretend we are processing a \"pulled\" event via\\n        backfill. The pulled event succesfully processes and the backward\\n        extremeties are updated along with clearing out any failed pull attempts\\n        for those old extremities.\\n\\n        We check that we correctly cleared failed pull attempts of the\\n        pulled event.\\n        '\n    OTHER_USER = f'@user:{self.OTHER_SERVER_NAME}'\n    main_store = self.hs.get_datastores().main\n    user_id = self.register_user('kermit', 'test')\n    tok = self.login('kermit', 'test')\n    room_id = self.helper.create_room_as(room_creator=user_id, tok=tok)\n    room_version = self.get_success(main_store.get_room_version(room_id))\n    self.helper.send_state(room_id, 'm.room.power_levels', {'events_default': 0, 'state_default': 0}, tok=tok)\n    member_event = self.get_success(event_injection.inject_member_event(self.hs, room_id, OTHER_USER, 'join'))\n    initial_state_map = self.get_success(main_store.get_partial_current_state_ids(room_id))\n    auth_event_ids = [initial_state_map['m.room.create', ''], initial_state_map['m.room.power_levels', ''], member_event.event_id]\n    pulled_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'test_regular_type', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [member_event.event_id], 'auth_events': auth_event_ids, 'origin_server_ts': 1, 'depth': 12, 'content': {'body': 'pulled'}}), room_version)\n    self.get_success(main_store.record_event_failed_pull_attempt(pulled_event.room_id, pulled_event.event_id, 'fake cause'))\n    backfill_num_attempts = self.get_success(main_store.db_pool.simple_select_one_onecol(table='event_failed_pull_attempts', keyvalues={'event_id': pulled_event.event_id}, retcol='num_attempts'))\n    self.assertEqual(backfill_num_attempts, 1)\n    with LoggingContext('test'):\n        self.get_success(self.hs.get_federation_event_handler()._process_pulled_event(self.OTHER_SERVER_NAME, pulled_event, backfilled=True))\n    backfill_num_attempts = self.get_success(main_store.db_pool.simple_select_one_onecol(table='event_failed_pull_attempts', keyvalues={'event_id': pulled_event.event_id}, retcol='num_attempts', allow_none=True))\n    self.assertIsNone(backfill_num_attempts)\n    persisted = self.get_success(main_store.get_event(pulled_event.event_id, allow_none=True))\n    self.assertIsNotNone(persisted, 'pulled event was not persisted at all')"
        ]
    },
    {
        "func_name": "test_backfill_signature_failure_does_not_fetch_same_prev_event_later",
        "original": "def test_backfill_signature_failure_does_not_fetch_same_prev_event_later(self) -> None:\n    \"\"\"\n        Test to make sure we backoff and don't try to fetch a missing prev_event when we\n        already know it has a invalid signature from checking the signatures of all of\n        the events in the backfill response.\n        \"\"\"\n    OTHER_USER = f'@user:{self.OTHER_SERVER_NAME}'\n    main_store = self.hs.get_datastores().main\n    user_id = self.register_user('kermit', 'test')\n    tok = self.login('kermit', 'test')\n    room_id = self.helper.create_room_as(room_creator=user_id, tok=tok)\n    room_version = self.get_success(main_store.get_room_version(room_id))\n    self.helper.send_state(room_id, 'm.room.power_levels', {'events_default': 0, 'state_default': 0}, tok=tok)\n    member_event = self.get_success(event_injection.inject_member_event(self.hs, room_id, OTHER_USER, 'join'))\n    initial_state_map = self.get_success(main_store.get_partial_current_state_ids(room_id))\n    auth_event_ids = [initial_state_map['m.room.create', ''], initial_state_map['m.room.power_levels', ''], member_event.event_id]\n    pulled_event_without_signatures = make_event_from_dict({'type': 'test_regular_type', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [member_event.event_id], 'auth_events': auth_event_ids, 'origin_server_ts': 1, 'depth': 12, 'content': {'body': 'pulled_event_without_signatures'}}, room_version)\n    pulled_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'test_regular_type', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [member_event.event_id, pulled_event_without_signatures.event_id], 'auth_events': auth_event_ids, 'origin_server_ts': 1, 'depth': 12, 'content': {'body': 'pulled_event'}}), room_version)\n    self.mock_federation_transport_client.backfill.return_value = {'origin': self.OTHER_SERVER_NAME, 'origin_server_ts': 123, 'pdus': [pulled_event_without_signatures.get_pdu_json(), pulled_event.get_pdu_json()]}\n    event_endpoint_requested_count = 0\n    room_state_ids_endpoint_requested_count = 0\n    room_state_endpoint_requested_count = 0\n\n    async def get_event(destination: str, event_id: str, timeout: Optional[int]=None) -> None:\n        nonlocal event_endpoint_requested_count\n        event_endpoint_requested_count += 1\n\n    async def get_room_state_ids(destination: str, room_id: str, event_id: str) -> None:\n        nonlocal room_state_ids_endpoint_requested_count\n        room_state_ids_endpoint_requested_count += 1\n\n    async def get_room_state(room_version: RoomVersion, destination: str, room_id: str, event_id: str) -> None:\n        nonlocal room_state_endpoint_requested_count\n        room_state_endpoint_requested_count += 1\n    self.mock_federation_transport_client.get_event.side_effect = get_event\n    self.mock_federation_transport_client.get_room_state_ids.side_effect = get_room_state_ids\n    self.mock_federation_transport_client.get_room_state.side_effect = get_room_state\n    with LoggingContext('test'):\n        self.get_success(self.hs.get_federation_event_handler().backfill(self.OTHER_SERVER_NAME, room_id, limit=1, extremities=['$some_extremity']))\n    if event_endpoint_requested_count > 0:\n        self.fail(f\"We don't expect an outbound request to /event in the happy path but if the logic is sneaking around what we expect, make sure to fail the test. We don't expect it because the signature failure should cause us to backoff and not asking about pulled_event_without_signatures={pulled_event_without_signatures.event_id} again\")\n    if room_state_ids_endpoint_requested_count > 0:\n        self.fail(f\"We don't expect an outbound request to /state_ids in the happy path but if the logic is sneaking around what we expect, make sure to fail the test. We don't expect it because the signature failure should cause us to backoff and not asking about pulled_event_without_signatures={pulled_event_without_signatures.event_id} again\")\n    if room_state_endpoint_requested_count > 0:\n        self.fail(f\"We don't expect an outbound request to /state in the happy path but if the logic is sneaking around what we expect, make sure to fail the test. We don't expect it because the signature failure should cause us to backoff and not asking about pulled_event_without_signatures={pulled_event_without_signatures.event_id} again\")\n    backfill_num_attempts_for_event_without_signatures = self.get_success(main_store.db_pool.simple_select_one_onecol(table='event_failed_pull_attempts', keyvalues={'event_id': pulled_event_without_signatures.event_id}, retcol='num_attempts'))\n    self.assertEqual(backfill_num_attempts_for_event_without_signatures, 1)\n    self.get_failure(main_store.db_pool.simple_select_one_onecol(table='event_failed_pull_attempts', keyvalues={'event_id': pulled_event.event_id}, retcol='num_attempts'), StoreError)",
        "mutated": [
            "def test_backfill_signature_failure_does_not_fetch_same_prev_event_later(self) -> None:\n    if False:\n        i = 10\n    \"\\n        Test to make sure we backoff and don't try to fetch a missing prev_event when we\\n        already know it has a invalid signature from checking the signatures of all of\\n        the events in the backfill response.\\n        \"\n    OTHER_USER = f'@user:{self.OTHER_SERVER_NAME}'\n    main_store = self.hs.get_datastores().main\n    user_id = self.register_user('kermit', 'test')\n    tok = self.login('kermit', 'test')\n    room_id = self.helper.create_room_as(room_creator=user_id, tok=tok)\n    room_version = self.get_success(main_store.get_room_version(room_id))\n    self.helper.send_state(room_id, 'm.room.power_levels', {'events_default': 0, 'state_default': 0}, tok=tok)\n    member_event = self.get_success(event_injection.inject_member_event(self.hs, room_id, OTHER_USER, 'join'))\n    initial_state_map = self.get_success(main_store.get_partial_current_state_ids(room_id))\n    auth_event_ids = [initial_state_map['m.room.create', ''], initial_state_map['m.room.power_levels', ''], member_event.event_id]\n    pulled_event_without_signatures = make_event_from_dict({'type': 'test_regular_type', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [member_event.event_id], 'auth_events': auth_event_ids, 'origin_server_ts': 1, 'depth': 12, 'content': {'body': 'pulled_event_without_signatures'}}, room_version)\n    pulled_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'test_regular_type', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [member_event.event_id, pulled_event_without_signatures.event_id], 'auth_events': auth_event_ids, 'origin_server_ts': 1, 'depth': 12, 'content': {'body': 'pulled_event'}}), room_version)\n    self.mock_federation_transport_client.backfill.return_value = {'origin': self.OTHER_SERVER_NAME, 'origin_server_ts': 123, 'pdus': [pulled_event_without_signatures.get_pdu_json(), pulled_event.get_pdu_json()]}\n    event_endpoint_requested_count = 0\n    room_state_ids_endpoint_requested_count = 0\n    room_state_endpoint_requested_count = 0\n\n    async def get_event(destination: str, event_id: str, timeout: Optional[int]=None) -> None:\n        nonlocal event_endpoint_requested_count\n        event_endpoint_requested_count += 1\n\n    async def get_room_state_ids(destination: str, room_id: str, event_id: str) -> None:\n        nonlocal room_state_ids_endpoint_requested_count\n        room_state_ids_endpoint_requested_count += 1\n\n    async def get_room_state(room_version: RoomVersion, destination: str, room_id: str, event_id: str) -> None:\n        nonlocal room_state_endpoint_requested_count\n        room_state_endpoint_requested_count += 1\n    self.mock_federation_transport_client.get_event.side_effect = get_event\n    self.mock_federation_transport_client.get_room_state_ids.side_effect = get_room_state_ids\n    self.mock_federation_transport_client.get_room_state.side_effect = get_room_state\n    with LoggingContext('test'):\n        self.get_success(self.hs.get_federation_event_handler().backfill(self.OTHER_SERVER_NAME, room_id, limit=1, extremities=['$some_extremity']))\n    if event_endpoint_requested_count > 0:\n        self.fail(f\"We don't expect an outbound request to /event in the happy path but if the logic is sneaking around what we expect, make sure to fail the test. We don't expect it because the signature failure should cause us to backoff and not asking about pulled_event_without_signatures={pulled_event_without_signatures.event_id} again\")\n    if room_state_ids_endpoint_requested_count > 0:\n        self.fail(f\"We don't expect an outbound request to /state_ids in the happy path but if the logic is sneaking around what we expect, make sure to fail the test. We don't expect it because the signature failure should cause us to backoff and not asking about pulled_event_without_signatures={pulled_event_without_signatures.event_id} again\")\n    if room_state_endpoint_requested_count > 0:\n        self.fail(f\"We don't expect an outbound request to /state in the happy path but if the logic is sneaking around what we expect, make sure to fail the test. We don't expect it because the signature failure should cause us to backoff and not asking about pulled_event_without_signatures={pulled_event_without_signatures.event_id} again\")\n    backfill_num_attempts_for_event_without_signatures = self.get_success(main_store.db_pool.simple_select_one_onecol(table='event_failed_pull_attempts', keyvalues={'event_id': pulled_event_without_signatures.event_id}, retcol='num_attempts'))\n    self.assertEqual(backfill_num_attempts_for_event_without_signatures, 1)\n    self.get_failure(main_store.db_pool.simple_select_one_onecol(table='event_failed_pull_attempts', keyvalues={'event_id': pulled_event.event_id}, retcol='num_attempts'), StoreError)",
            "def test_backfill_signature_failure_does_not_fetch_same_prev_event_later(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n        Test to make sure we backoff and don't try to fetch a missing prev_event when we\\n        already know it has a invalid signature from checking the signatures of all of\\n        the events in the backfill response.\\n        \"\n    OTHER_USER = f'@user:{self.OTHER_SERVER_NAME}'\n    main_store = self.hs.get_datastores().main\n    user_id = self.register_user('kermit', 'test')\n    tok = self.login('kermit', 'test')\n    room_id = self.helper.create_room_as(room_creator=user_id, tok=tok)\n    room_version = self.get_success(main_store.get_room_version(room_id))\n    self.helper.send_state(room_id, 'm.room.power_levels', {'events_default': 0, 'state_default': 0}, tok=tok)\n    member_event = self.get_success(event_injection.inject_member_event(self.hs, room_id, OTHER_USER, 'join'))\n    initial_state_map = self.get_success(main_store.get_partial_current_state_ids(room_id))\n    auth_event_ids = [initial_state_map['m.room.create', ''], initial_state_map['m.room.power_levels', ''], member_event.event_id]\n    pulled_event_without_signatures = make_event_from_dict({'type': 'test_regular_type', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [member_event.event_id], 'auth_events': auth_event_ids, 'origin_server_ts': 1, 'depth': 12, 'content': {'body': 'pulled_event_without_signatures'}}, room_version)\n    pulled_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'test_regular_type', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [member_event.event_id, pulled_event_without_signatures.event_id], 'auth_events': auth_event_ids, 'origin_server_ts': 1, 'depth': 12, 'content': {'body': 'pulled_event'}}), room_version)\n    self.mock_federation_transport_client.backfill.return_value = {'origin': self.OTHER_SERVER_NAME, 'origin_server_ts': 123, 'pdus': [pulled_event_without_signatures.get_pdu_json(), pulled_event.get_pdu_json()]}\n    event_endpoint_requested_count = 0\n    room_state_ids_endpoint_requested_count = 0\n    room_state_endpoint_requested_count = 0\n\n    async def get_event(destination: str, event_id: str, timeout: Optional[int]=None) -> None:\n        nonlocal event_endpoint_requested_count\n        event_endpoint_requested_count += 1\n\n    async def get_room_state_ids(destination: str, room_id: str, event_id: str) -> None:\n        nonlocal room_state_ids_endpoint_requested_count\n        room_state_ids_endpoint_requested_count += 1\n\n    async def get_room_state(room_version: RoomVersion, destination: str, room_id: str, event_id: str) -> None:\n        nonlocal room_state_endpoint_requested_count\n        room_state_endpoint_requested_count += 1\n    self.mock_federation_transport_client.get_event.side_effect = get_event\n    self.mock_federation_transport_client.get_room_state_ids.side_effect = get_room_state_ids\n    self.mock_federation_transport_client.get_room_state.side_effect = get_room_state\n    with LoggingContext('test'):\n        self.get_success(self.hs.get_federation_event_handler().backfill(self.OTHER_SERVER_NAME, room_id, limit=1, extremities=['$some_extremity']))\n    if event_endpoint_requested_count > 0:\n        self.fail(f\"We don't expect an outbound request to /event in the happy path but if the logic is sneaking around what we expect, make sure to fail the test. We don't expect it because the signature failure should cause us to backoff and not asking about pulled_event_without_signatures={pulled_event_without_signatures.event_id} again\")\n    if room_state_ids_endpoint_requested_count > 0:\n        self.fail(f\"We don't expect an outbound request to /state_ids in the happy path but if the logic is sneaking around what we expect, make sure to fail the test. We don't expect it because the signature failure should cause us to backoff and not asking about pulled_event_without_signatures={pulled_event_without_signatures.event_id} again\")\n    if room_state_endpoint_requested_count > 0:\n        self.fail(f\"We don't expect an outbound request to /state in the happy path but if the logic is sneaking around what we expect, make sure to fail the test. We don't expect it because the signature failure should cause us to backoff and not asking about pulled_event_without_signatures={pulled_event_without_signatures.event_id} again\")\n    backfill_num_attempts_for_event_without_signatures = self.get_success(main_store.db_pool.simple_select_one_onecol(table='event_failed_pull_attempts', keyvalues={'event_id': pulled_event_without_signatures.event_id}, retcol='num_attempts'))\n    self.assertEqual(backfill_num_attempts_for_event_without_signatures, 1)\n    self.get_failure(main_store.db_pool.simple_select_one_onecol(table='event_failed_pull_attempts', keyvalues={'event_id': pulled_event.event_id}, retcol='num_attempts'), StoreError)",
            "def test_backfill_signature_failure_does_not_fetch_same_prev_event_later(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n        Test to make sure we backoff and don't try to fetch a missing prev_event when we\\n        already know it has a invalid signature from checking the signatures of all of\\n        the events in the backfill response.\\n        \"\n    OTHER_USER = f'@user:{self.OTHER_SERVER_NAME}'\n    main_store = self.hs.get_datastores().main\n    user_id = self.register_user('kermit', 'test')\n    tok = self.login('kermit', 'test')\n    room_id = self.helper.create_room_as(room_creator=user_id, tok=tok)\n    room_version = self.get_success(main_store.get_room_version(room_id))\n    self.helper.send_state(room_id, 'm.room.power_levels', {'events_default': 0, 'state_default': 0}, tok=tok)\n    member_event = self.get_success(event_injection.inject_member_event(self.hs, room_id, OTHER_USER, 'join'))\n    initial_state_map = self.get_success(main_store.get_partial_current_state_ids(room_id))\n    auth_event_ids = [initial_state_map['m.room.create', ''], initial_state_map['m.room.power_levels', ''], member_event.event_id]\n    pulled_event_without_signatures = make_event_from_dict({'type': 'test_regular_type', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [member_event.event_id], 'auth_events': auth_event_ids, 'origin_server_ts': 1, 'depth': 12, 'content': {'body': 'pulled_event_without_signatures'}}, room_version)\n    pulled_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'test_regular_type', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [member_event.event_id, pulled_event_without_signatures.event_id], 'auth_events': auth_event_ids, 'origin_server_ts': 1, 'depth': 12, 'content': {'body': 'pulled_event'}}), room_version)\n    self.mock_federation_transport_client.backfill.return_value = {'origin': self.OTHER_SERVER_NAME, 'origin_server_ts': 123, 'pdus': [pulled_event_without_signatures.get_pdu_json(), pulled_event.get_pdu_json()]}\n    event_endpoint_requested_count = 0\n    room_state_ids_endpoint_requested_count = 0\n    room_state_endpoint_requested_count = 0\n\n    async def get_event(destination: str, event_id: str, timeout: Optional[int]=None) -> None:\n        nonlocal event_endpoint_requested_count\n        event_endpoint_requested_count += 1\n\n    async def get_room_state_ids(destination: str, room_id: str, event_id: str) -> None:\n        nonlocal room_state_ids_endpoint_requested_count\n        room_state_ids_endpoint_requested_count += 1\n\n    async def get_room_state(room_version: RoomVersion, destination: str, room_id: str, event_id: str) -> None:\n        nonlocal room_state_endpoint_requested_count\n        room_state_endpoint_requested_count += 1\n    self.mock_federation_transport_client.get_event.side_effect = get_event\n    self.mock_federation_transport_client.get_room_state_ids.side_effect = get_room_state_ids\n    self.mock_federation_transport_client.get_room_state.side_effect = get_room_state\n    with LoggingContext('test'):\n        self.get_success(self.hs.get_federation_event_handler().backfill(self.OTHER_SERVER_NAME, room_id, limit=1, extremities=['$some_extremity']))\n    if event_endpoint_requested_count > 0:\n        self.fail(f\"We don't expect an outbound request to /event in the happy path but if the logic is sneaking around what we expect, make sure to fail the test. We don't expect it because the signature failure should cause us to backoff and not asking about pulled_event_without_signatures={pulled_event_without_signatures.event_id} again\")\n    if room_state_ids_endpoint_requested_count > 0:\n        self.fail(f\"We don't expect an outbound request to /state_ids in the happy path but if the logic is sneaking around what we expect, make sure to fail the test. We don't expect it because the signature failure should cause us to backoff and not asking about pulled_event_without_signatures={pulled_event_without_signatures.event_id} again\")\n    if room_state_endpoint_requested_count > 0:\n        self.fail(f\"We don't expect an outbound request to /state in the happy path but if the logic is sneaking around what we expect, make sure to fail the test. We don't expect it because the signature failure should cause us to backoff and not asking about pulled_event_without_signatures={pulled_event_without_signatures.event_id} again\")\n    backfill_num_attempts_for_event_without_signatures = self.get_success(main_store.db_pool.simple_select_one_onecol(table='event_failed_pull_attempts', keyvalues={'event_id': pulled_event_without_signatures.event_id}, retcol='num_attempts'))\n    self.assertEqual(backfill_num_attempts_for_event_without_signatures, 1)\n    self.get_failure(main_store.db_pool.simple_select_one_onecol(table='event_failed_pull_attempts', keyvalues={'event_id': pulled_event.event_id}, retcol='num_attempts'), StoreError)",
            "def test_backfill_signature_failure_does_not_fetch_same_prev_event_later(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n        Test to make sure we backoff and don't try to fetch a missing prev_event when we\\n        already know it has a invalid signature from checking the signatures of all of\\n        the events in the backfill response.\\n        \"\n    OTHER_USER = f'@user:{self.OTHER_SERVER_NAME}'\n    main_store = self.hs.get_datastores().main\n    user_id = self.register_user('kermit', 'test')\n    tok = self.login('kermit', 'test')\n    room_id = self.helper.create_room_as(room_creator=user_id, tok=tok)\n    room_version = self.get_success(main_store.get_room_version(room_id))\n    self.helper.send_state(room_id, 'm.room.power_levels', {'events_default': 0, 'state_default': 0}, tok=tok)\n    member_event = self.get_success(event_injection.inject_member_event(self.hs, room_id, OTHER_USER, 'join'))\n    initial_state_map = self.get_success(main_store.get_partial_current_state_ids(room_id))\n    auth_event_ids = [initial_state_map['m.room.create', ''], initial_state_map['m.room.power_levels', ''], member_event.event_id]\n    pulled_event_without_signatures = make_event_from_dict({'type': 'test_regular_type', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [member_event.event_id], 'auth_events': auth_event_ids, 'origin_server_ts': 1, 'depth': 12, 'content': {'body': 'pulled_event_without_signatures'}}, room_version)\n    pulled_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'test_regular_type', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [member_event.event_id, pulled_event_without_signatures.event_id], 'auth_events': auth_event_ids, 'origin_server_ts': 1, 'depth': 12, 'content': {'body': 'pulled_event'}}), room_version)\n    self.mock_federation_transport_client.backfill.return_value = {'origin': self.OTHER_SERVER_NAME, 'origin_server_ts': 123, 'pdus': [pulled_event_without_signatures.get_pdu_json(), pulled_event.get_pdu_json()]}\n    event_endpoint_requested_count = 0\n    room_state_ids_endpoint_requested_count = 0\n    room_state_endpoint_requested_count = 0\n\n    async def get_event(destination: str, event_id: str, timeout: Optional[int]=None) -> None:\n        nonlocal event_endpoint_requested_count\n        event_endpoint_requested_count += 1\n\n    async def get_room_state_ids(destination: str, room_id: str, event_id: str) -> None:\n        nonlocal room_state_ids_endpoint_requested_count\n        room_state_ids_endpoint_requested_count += 1\n\n    async def get_room_state(room_version: RoomVersion, destination: str, room_id: str, event_id: str) -> None:\n        nonlocal room_state_endpoint_requested_count\n        room_state_endpoint_requested_count += 1\n    self.mock_federation_transport_client.get_event.side_effect = get_event\n    self.mock_federation_transport_client.get_room_state_ids.side_effect = get_room_state_ids\n    self.mock_federation_transport_client.get_room_state.side_effect = get_room_state\n    with LoggingContext('test'):\n        self.get_success(self.hs.get_federation_event_handler().backfill(self.OTHER_SERVER_NAME, room_id, limit=1, extremities=['$some_extremity']))\n    if event_endpoint_requested_count > 0:\n        self.fail(f\"We don't expect an outbound request to /event in the happy path but if the logic is sneaking around what we expect, make sure to fail the test. We don't expect it because the signature failure should cause us to backoff and not asking about pulled_event_without_signatures={pulled_event_without_signatures.event_id} again\")\n    if room_state_ids_endpoint_requested_count > 0:\n        self.fail(f\"We don't expect an outbound request to /state_ids in the happy path but if the logic is sneaking around what we expect, make sure to fail the test. We don't expect it because the signature failure should cause us to backoff and not asking about pulled_event_without_signatures={pulled_event_without_signatures.event_id} again\")\n    if room_state_endpoint_requested_count > 0:\n        self.fail(f\"We don't expect an outbound request to /state in the happy path but if the logic is sneaking around what we expect, make sure to fail the test. We don't expect it because the signature failure should cause us to backoff and not asking about pulled_event_without_signatures={pulled_event_without_signatures.event_id} again\")\n    backfill_num_attempts_for_event_without_signatures = self.get_success(main_store.db_pool.simple_select_one_onecol(table='event_failed_pull_attempts', keyvalues={'event_id': pulled_event_without_signatures.event_id}, retcol='num_attempts'))\n    self.assertEqual(backfill_num_attempts_for_event_without_signatures, 1)\n    self.get_failure(main_store.db_pool.simple_select_one_onecol(table='event_failed_pull_attempts', keyvalues={'event_id': pulled_event.event_id}, retcol='num_attempts'), StoreError)",
            "def test_backfill_signature_failure_does_not_fetch_same_prev_event_later(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n        Test to make sure we backoff and don't try to fetch a missing prev_event when we\\n        already know it has a invalid signature from checking the signatures of all of\\n        the events in the backfill response.\\n        \"\n    OTHER_USER = f'@user:{self.OTHER_SERVER_NAME}'\n    main_store = self.hs.get_datastores().main\n    user_id = self.register_user('kermit', 'test')\n    tok = self.login('kermit', 'test')\n    room_id = self.helper.create_room_as(room_creator=user_id, tok=tok)\n    room_version = self.get_success(main_store.get_room_version(room_id))\n    self.helper.send_state(room_id, 'm.room.power_levels', {'events_default': 0, 'state_default': 0}, tok=tok)\n    member_event = self.get_success(event_injection.inject_member_event(self.hs, room_id, OTHER_USER, 'join'))\n    initial_state_map = self.get_success(main_store.get_partial_current_state_ids(room_id))\n    auth_event_ids = [initial_state_map['m.room.create', ''], initial_state_map['m.room.power_levels', ''], member_event.event_id]\n    pulled_event_without_signatures = make_event_from_dict({'type': 'test_regular_type', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [member_event.event_id], 'auth_events': auth_event_ids, 'origin_server_ts': 1, 'depth': 12, 'content': {'body': 'pulled_event_without_signatures'}}, room_version)\n    pulled_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'test_regular_type', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [member_event.event_id, pulled_event_without_signatures.event_id], 'auth_events': auth_event_ids, 'origin_server_ts': 1, 'depth': 12, 'content': {'body': 'pulled_event'}}), room_version)\n    self.mock_federation_transport_client.backfill.return_value = {'origin': self.OTHER_SERVER_NAME, 'origin_server_ts': 123, 'pdus': [pulled_event_without_signatures.get_pdu_json(), pulled_event.get_pdu_json()]}\n    event_endpoint_requested_count = 0\n    room_state_ids_endpoint_requested_count = 0\n    room_state_endpoint_requested_count = 0\n\n    async def get_event(destination: str, event_id: str, timeout: Optional[int]=None) -> None:\n        nonlocal event_endpoint_requested_count\n        event_endpoint_requested_count += 1\n\n    async def get_room_state_ids(destination: str, room_id: str, event_id: str) -> None:\n        nonlocal room_state_ids_endpoint_requested_count\n        room_state_ids_endpoint_requested_count += 1\n\n    async def get_room_state(room_version: RoomVersion, destination: str, room_id: str, event_id: str) -> None:\n        nonlocal room_state_endpoint_requested_count\n        room_state_endpoint_requested_count += 1\n    self.mock_federation_transport_client.get_event.side_effect = get_event\n    self.mock_federation_transport_client.get_room_state_ids.side_effect = get_room_state_ids\n    self.mock_federation_transport_client.get_room_state.side_effect = get_room_state\n    with LoggingContext('test'):\n        self.get_success(self.hs.get_federation_event_handler().backfill(self.OTHER_SERVER_NAME, room_id, limit=1, extremities=['$some_extremity']))\n    if event_endpoint_requested_count > 0:\n        self.fail(f\"We don't expect an outbound request to /event in the happy path but if the logic is sneaking around what we expect, make sure to fail the test. We don't expect it because the signature failure should cause us to backoff and not asking about pulled_event_without_signatures={pulled_event_without_signatures.event_id} again\")\n    if room_state_ids_endpoint_requested_count > 0:\n        self.fail(f\"We don't expect an outbound request to /state_ids in the happy path but if the logic is sneaking around what we expect, make sure to fail the test. We don't expect it because the signature failure should cause us to backoff and not asking about pulled_event_without_signatures={pulled_event_without_signatures.event_id} again\")\n    if room_state_endpoint_requested_count > 0:\n        self.fail(f\"We don't expect an outbound request to /state in the happy path but if the logic is sneaking around what we expect, make sure to fail the test. We don't expect it because the signature failure should cause us to backoff and not asking about pulled_event_without_signatures={pulled_event_without_signatures.event_id} again\")\n    backfill_num_attempts_for_event_without_signatures = self.get_success(main_store.db_pool.simple_select_one_onecol(table='event_failed_pull_attempts', keyvalues={'event_id': pulled_event_without_signatures.event_id}, retcol='num_attempts'))\n    self.assertEqual(backfill_num_attempts_for_event_without_signatures, 1)\n    self.get_failure(main_store.db_pool.simple_select_one_onecol(table='event_failed_pull_attempts', keyvalues={'event_id': pulled_event.event_id}, retcol='num_attempts'), StoreError)"
        ]
    },
    {
        "func_name": "test_backfill_process_previously_failed_pull_attempt_event_in_the_background",
        "original": "def test_backfill_process_previously_failed_pull_attempt_event_in_the_background(self) -> None:\n    \"\"\"\n        Sanity check that events are still processed even if it is in the background\n        for events that already have failed pull attempts.\n        \"\"\"\n    OTHER_USER = f'@user:{self.OTHER_SERVER_NAME}'\n    main_store = self.hs.get_datastores().main\n    user_id = self.register_user('kermit', 'test')\n    tok = self.login('kermit', 'test')\n    room_id = self.helper.create_room_as(room_creator=user_id, tok=tok)\n    room_version = self.get_success(main_store.get_room_version(room_id))\n    self.helper.send_state(room_id, 'm.room.power_levels', {'events_default': 0, 'state_default': 0}, tok=tok)\n    member_event = self.get_success(event_injection.inject_member_event(self.hs, room_id, OTHER_USER, 'join'))\n    initial_state_map = self.get_success(main_store.get_partial_current_state_ids(room_id))\n    auth_event_ids = [initial_state_map['m.room.create', ''], initial_state_map['m.room.power_levels', ''], member_event.event_id]\n    pulled_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'test_regular_type', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [member_event.event_id], 'auth_events': auth_event_ids, 'origin_server_ts': 1, 'depth': 12, 'content': {'body': 'pulled_event'}}), room_version)\n    self.get_success(main_store.record_event_failed_pull_attempt(room_id, pulled_event.event_id, 'fake cause'))\n    self.mock_federation_transport_client.backfill.return_value = {'origin': self.OTHER_SERVER_NAME, 'origin_server_ts': 123, 'pdus': [pulled_event.get_pdu_json()]}\n    with LoggingContext('test'):\n        self.get_success(self.hs.get_federation_event_handler().backfill(self.OTHER_SERVER_NAME, room_id, limit=1, extremities=['$some_extremity']))\n    self.reactor.pump((0.1,))\n    self.get_success(main_store.get_event(pulled_event.event_id, allow_none=False))",
        "mutated": [
            "def test_backfill_process_previously_failed_pull_attempt_event_in_the_background(self) -> None:\n    if False:\n        i = 10\n    '\\n        Sanity check that events are still processed even if it is in the background\\n        for events that already have failed pull attempts.\\n        '\n    OTHER_USER = f'@user:{self.OTHER_SERVER_NAME}'\n    main_store = self.hs.get_datastores().main\n    user_id = self.register_user('kermit', 'test')\n    tok = self.login('kermit', 'test')\n    room_id = self.helper.create_room_as(room_creator=user_id, tok=tok)\n    room_version = self.get_success(main_store.get_room_version(room_id))\n    self.helper.send_state(room_id, 'm.room.power_levels', {'events_default': 0, 'state_default': 0}, tok=tok)\n    member_event = self.get_success(event_injection.inject_member_event(self.hs, room_id, OTHER_USER, 'join'))\n    initial_state_map = self.get_success(main_store.get_partial_current_state_ids(room_id))\n    auth_event_ids = [initial_state_map['m.room.create', ''], initial_state_map['m.room.power_levels', ''], member_event.event_id]\n    pulled_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'test_regular_type', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [member_event.event_id], 'auth_events': auth_event_ids, 'origin_server_ts': 1, 'depth': 12, 'content': {'body': 'pulled_event'}}), room_version)\n    self.get_success(main_store.record_event_failed_pull_attempt(room_id, pulled_event.event_id, 'fake cause'))\n    self.mock_federation_transport_client.backfill.return_value = {'origin': self.OTHER_SERVER_NAME, 'origin_server_ts': 123, 'pdus': [pulled_event.get_pdu_json()]}\n    with LoggingContext('test'):\n        self.get_success(self.hs.get_federation_event_handler().backfill(self.OTHER_SERVER_NAME, room_id, limit=1, extremities=['$some_extremity']))\n    self.reactor.pump((0.1,))\n    self.get_success(main_store.get_event(pulled_event.event_id, allow_none=False))",
            "def test_backfill_process_previously_failed_pull_attempt_event_in_the_background(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Sanity check that events are still processed even if it is in the background\\n        for events that already have failed pull attempts.\\n        '\n    OTHER_USER = f'@user:{self.OTHER_SERVER_NAME}'\n    main_store = self.hs.get_datastores().main\n    user_id = self.register_user('kermit', 'test')\n    tok = self.login('kermit', 'test')\n    room_id = self.helper.create_room_as(room_creator=user_id, tok=tok)\n    room_version = self.get_success(main_store.get_room_version(room_id))\n    self.helper.send_state(room_id, 'm.room.power_levels', {'events_default': 0, 'state_default': 0}, tok=tok)\n    member_event = self.get_success(event_injection.inject_member_event(self.hs, room_id, OTHER_USER, 'join'))\n    initial_state_map = self.get_success(main_store.get_partial_current_state_ids(room_id))\n    auth_event_ids = [initial_state_map['m.room.create', ''], initial_state_map['m.room.power_levels', ''], member_event.event_id]\n    pulled_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'test_regular_type', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [member_event.event_id], 'auth_events': auth_event_ids, 'origin_server_ts': 1, 'depth': 12, 'content': {'body': 'pulled_event'}}), room_version)\n    self.get_success(main_store.record_event_failed_pull_attempt(room_id, pulled_event.event_id, 'fake cause'))\n    self.mock_federation_transport_client.backfill.return_value = {'origin': self.OTHER_SERVER_NAME, 'origin_server_ts': 123, 'pdus': [pulled_event.get_pdu_json()]}\n    with LoggingContext('test'):\n        self.get_success(self.hs.get_federation_event_handler().backfill(self.OTHER_SERVER_NAME, room_id, limit=1, extremities=['$some_extremity']))\n    self.reactor.pump((0.1,))\n    self.get_success(main_store.get_event(pulled_event.event_id, allow_none=False))",
            "def test_backfill_process_previously_failed_pull_attempt_event_in_the_background(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Sanity check that events are still processed even if it is in the background\\n        for events that already have failed pull attempts.\\n        '\n    OTHER_USER = f'@user:{self.OTHER_SERVER_NAME}'\n    main_store = self.hs.get_datastores().main\n    user_id = self.register_user('kermit', 'test')\n    tok = self.login('kermit', 'test')\n    room_id = self.helper.create_room_as(room_creator=user_id, tok=tok)\n    room_version = self.get_success(main_store.get_room_version(room_id))\n    self.helper.send_state(room_id, 'm.room.power_levels', {'events_default': 0, 'state_default': 0}, tok=tok)\n    member_event = self.get_success(event_injection.inject_member_event(self.hs, room_id, OTHER_USER, 'join'))\n    initial_state_map = self.get_success(main_store.get_partial_current_state_ids(room_id))\n    auth_event_ids = [initial_state_map['m.room.create', ''], initial_state_map['m.room.power_levels', ''], member_event.event_id]\n    pulled_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'test_regular_type', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [member_event.event_id], 'auth_events': auth_event_ids, 'origin_server_ts': 1, 'depth': 12, 'content': {'body': 'pulled_event'}}), room_version)\n    self.get_success(main_store.record_event_failed_pull_attempt(room_id, pulled_event.event_id, 'fake cause'))\n    self.mock_federation_transport_client.backfill.return_value = {'origin': self.OTHER_SERVER_NAME, 'origin_server_ts': 123, 'pdus': [pulled_event.get_pdu_json()]}\n    with LoggingContext('test'):\n        self.get_success(self.hs.get_federation_event_handler().backfill(self.OTHER_SERVER_NAME, room_id, limit=1, extremities=['$some_extremity']))\n    self.reactor.pump((0.1,))\n    self.get_success(main_store.get_event(pulled_event.event_id, allow_none=False))",
            "def test_backfill_process_previously_failed_pull_attempt_event_in_the_background(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Sanity check that events are still processed even if it is in the background\\n        for events that already have failed pull attempts.\\n        '\n    OTHER_USER = f'@user:{self.OTHER_SERVER_NAME}'\n    main_store = self.hs.get_datastores().main\n    user_id = self.register_user('kermit', 'test')\n    tok = self.login('kermit', 'test')\n    room_id = self.helper.create_room_as(room_creator=user_id, tok=tok)\n    room_version = self.get_success(main_store.get_room_version(room_id))\n    self.helper.send_state(room_id, 'm.room.power_levels', {'events_default': 0, 'state_default': 0}, tok=tok)\n    member_event = self.get_success(event_injection.inject_member_event(self.hs, room_id, OTHER_USER, 'join'))\n    initial_state_map = self.get_success(main_store.get_partial_current_state_ids(room_id))\n    auth_event_ids = [initial_state_map['m.room.create', ''], initial_state_map['m.room.power_levels', ''], member_event.event_id]\n    pulled_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'test_regular_type', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [member_event.event_id], 'auth_events': auth_event_ids, 'origin_server_ts': 1, 'depth': 12, 'content': {'body': 'pulled_event'}}), room_version)\n    self.get_success(main_store.record_event_failed_pull_attempt(room_id, pulled_event.event_id, 'fake cause'))\n    self.mock_federation_transport_client.backfill.return_value = {'origin': self.OTHER_SERVER_NAME, 'origin_server_ts': 123, 'pdus': [pulled_event.get_pdu_json()]}\n    with LoggingContext('test'):\n        self.get_success(self.hs.get_federation_event_handler().backfill(self.OTHER_SERVER_NAME, room_id, limit=1, extremities=['$some_extremity']))\n    self.reactor.pump((0.1,))\n    self.get_success(main_store.get_event(pulled_event.event_id, allow_none=False))",
            "def test_backfill_process_previously_failed_pull_attempt_event_in_the_background(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Sanity check that events are still processed even if it is in the background\\n        for events that already have failed pull attempts.\\n        '\n    OTHER_USER = f'@user:{self.OTHER_SERVER_NAME}'\n    main_store = self.hs.get_datastores().main\n    user_id = self.register_user('kermit', 'test')\n    tok = self.login('kermit', 'test')\n    room_id = self.helper.create_room_as(room_creator=user_id, tok=tok)\n    room_version = self.get_success(main_store.get_room_version(room_id))\n    self.helper.send_state(room_id, 'm.room.power_levels', {'events_default': 0, 'state_default': 0}, tok=tok)\n    member_event = self.get_success(event_injection.inject_member_event(self.hs, room_id, OTHER_USER, 'join'))\n    initial_state_map = self.get_success(main_store.get_partial_current_state_ids(room_id))\n    auth_event_ids = [initial_state_map['m.room.create', ''], initial_state_map['m.room.power_levels', ''], member_event.event_id]\n    pulled_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'test_regular_type', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [member_event.event_id], 'auth_events': auth_event_ids, 'origin_server_ts': 1, 'depth': 12, 'content': {'body': 'pulled_event'}}), room_version)\n    self.get_success(main_store.record_event_failed_pull_attempt(room_id, pulled_event.event_id, 'fake cause'))\n    self.mock_federation_transport_client.backfill.return_value = {'origin': self.OTHER_SERVER_NAME, 'origin_server_ts': 123, 'pdus': [pulled_event.get_pdu_json()]}\n    with LoggingContext('test'):\n        self.get_success(self.hs.get_federation_event_handler().backfill(self.OTHER_SERVER_NAME, room_id, limit=1, extremities=['$some_extremity']))\n    self.reactor.pump((0.1,))\n    self.get_success(main_store.get_event(pulled_event.event_id, allow_none=False))"
        ]
    },
    {
        "func_name": "test_process_pulled_event_with_rejected_missing_state",
        "original": "def test_process_pulled_event_with_rejected_missing_state(self) -> None:\n    \"\"\"Ensure that we correctly handle pulled events with missing state containing a\n        rejected state event\n\n        In this test, we pretend we are processing a \"pulled\" event (eg, via backfill\n        or get_missing_events). The pulled event has a prev_event we haven't previously\n        seen, so the server requests the state at that prev_event. We expect the server\n        to make a /state request.\n\n        We simulate a remote server whose /state includes a rejected kick event for a\n        local user. Notably, the kick event is rejected only because it cites a rejected\n        auth event and would otherwise be accepted based on the room state. During state\n        resolution, we re-run auth and can potentially introduce such rejected events\n        into the state if we are not careful.\n\n        We check that the pulled event is correctly persisted, and that the state\n        afterwards does not include the rejected kick.\n        \"\"\"\n    OTHER_USER = f'@user:{self.OTHER_SERVER_NAME}'\n    main_store = self.hs.get_datastores().main\n    kermit_user_id = self.register_user('kermit', 'test')\n    kermit_tok = self.login('kermit', 'test')\n    room_id = self.helper.create_room_as(room_creator=kermit_user_id, tok=kermit_tok)\n    room_version = self.get_success(main_store.get_room_version(room_id))\n    bert_user_id = self.register_user('bert', 'test')\n    bert_tok = self.login('bert', 'test')\n    self.helper.join(room_id, user=bert_user_id, tok=bert_tok)\n    self.helper.send_state(room_id, 'm.room.power_levels', {'users': {kermit_user_id: 100, OTHER_USER: 100}}, tok=kermit_tok)\n    other_member_event = self.get_success(event_injection.inject_member_event(self.hs, room_id, OTHER_USER, 'join'))\n    initial_state_map = self.get_success(main_store.get_partial_current_state_ids(room_id))\n    create_event = self.get_success(main_store.get_event(initial_state_map['m.room.create', '']))\n    bert_member_event = self.get_success(main_store.get_event(initial_state_map['m.room.member', bert_user_id]))\n    power_levels_event = self.get_success(main_store.get_event(initial_state_map['m.room.power_levels', '']))\n    next_depth = 100\n    next_timestamp = other_member_event.origin_server_ts + 100\n    rejected_power_levels_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'm.room.power_levels', 'state_key': '', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [other_member_event.event_id], 'auth_events': [initial_state_map['m.room.create', ''], initial_state_map['m.room.power_levels', ''], other_member_event.event_id, other_member_event.event_id], 'origin_server_ts': next_timestamp, 'depth': next_depth, 'content': power_levels_event.content}), room_version)\n    next_depth += 1\n    next_timestamp += 100\n    with LoggingContext('send_rejected_power_levels_event'):\n        self.get_success(self.hs.get_federation_event_handler()._process_pulled_event(self.OTHER_SERVER_NAME, rejected_power_levels_event, backfilled=False))\n        self.assertEqual(self.get_success(main_store.get_rejection_reason(rejected_power_levels_event.event_id)), 'auth_error')\n    rejected_kick_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'm.room.member', 'state_key': bert_user_id, 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [rejected_power_levels_event.event_id], 'auth_events': [initial_state_map['m.room.create', ''], rejected_power_levels_event.event_id, initial_state_map['m.room.member', bert_user_id], initial_state_map['m.room.member', OTHER_USER]], 'origin_server_ts': next_timestamp, 'depth': next_depth, 'content': {'membership': 'leave'}}), room_version)\n    next_depth += 1\n    next_timestamp += 100\n    self.get_failure(check_state_independent_auth_rules(main_store, rejected_kick_event), AuthError)\n    check_state_dependent_auth_rules(rejected_kick_event, [create_event, power_levels_event, other_member_event, bert_member_event])\n    self.assertEqual(self.get_success(_mainline_sort(self.clock, room_id, event_ids=[bert_member_event.event_id, rejected_kick_event.event_id], resolved_power_event_id=power_levels_event.event_id, event_map={bert_member_event.event_id: bert_member_event, rejected_kick_event.event_id: rejected_kick_event}, state_res_store=StateResolutionStore(main_store))), [bert_member_event.event_id, rejected_kick_event.event_id], \"The rejected kick event will not be applied after bert's join event during state resolution. The test setup is incorrect.\")\n    with LoggingContext('send_rejected_kick_event'):\n        self.get_success(self.hs.get_federation_event_handler()._process_pulled_event(self.OTHER_SERVER_NAME, rejected_kick_event, backfilled=False))\n        self.assertEqual(self.get_success(main_store.get_rejection_reason(rejected_kick_event.event_id)), 'auth_error')\n    self.reactor.advance(100)\n    new_power_levels_event = self.get_success(main_store.get_event(self.helper.send_state(room_id, 'm.room.power_levels', {'users': {kermit_user_id: 100, OTHER_USER: 100, bert_user_id: 1}}, tok=kermit_tok)['event_id']))\n    self.assertEqual(self.get_success(_reverse_topological_power_sort(self.clock, room_id, event_ids=[new_power_levels_event.event_id, rejected_power_levels_event.event_id], event_map={}, state_res_store=StateResolutionStore(main_store), full_conflicted_set=set())), [rejected_power_levels_event.event_id, new_power_levels_event.event_id], 'The power levels events will not have the desired ordering during state resolution. The test setup is incorrect.')\n    missing_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'm.room.message', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [rejected_kick_event.event_id], 'auth_events': [initial_state_map['m.room.create', ''], initial_state_map['m.room.power_levels', ''], initial_state_map['m.room.member', OTHER_USER]], 'origin_server_ts': next_timestamp, 'depth': next_depth, 'content': {'msgtype': 'm.text', 'body': 'foo'}}), room_version)\n    next_depth += 1\n    next_timestamp += 100\n    pulled_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'm.room.message', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [new_power_levels_event.event_id, missing_event.event_id], 'auth_events': [initial_state_map['m.room.create', ''], new_power_levels_event.event_id, initial_state_map['m.room.member', OTHER_USER]], 'origin_server_ts': next_timestamp, 'depth': next_depth, 'content': {'msgtype': 'm.text', 'body': 'bar'}}), room_version)\n    next_depth += 1\n    next_timestamp += 100\n    state_before_missing_event = self.get_success(main_store.get_events_as_list(initial_state_map.values()))\n    state_before_missing_event = [event for event in state_before_missing_event if event.event_id != bert_member_event.event_id]\n    state_before_missing_event.append(rejected_kick_event)\n    self.reactor.advance(60000)\n    with LoggingContext('send_pulled_event'):\n\n        async def get_event(destination: str, event_id: str, timeout: Optional[int]=None) -> JsonDict:\n            self.assertEqual(destination, self.OTHER_SERVER_NAME)\n            self.assertEqual(event_id, missing_event.event_id)\n            return {'pdus': [missing_event.get_pdu_json()]}\n\n        async def get_room_state_ids(destination: str, room_id: str, event_id: str) -> JsonDict:\n            self.assertEqual(destination, self.OTHER_SERVER_NAME)\n            self.assertEqual(event_id, missing_event.event_id)\n            return {'pdu_ids': [event.event_id for event in state_before_missing_event], 'auth_chain_ids': []}\n\n        async def get_room_state(room_version: RoomVersion, destination: str, room_id: str, event_id: str) -> StateRequestResponse:\n            self.assertEqual(destination, self.OTHER_SERVER_NAME)\n            self.assertEqual(event_id, missing_event.event_id)\n            return StateRequestResponse(state=state_before_missing_event, auth_events=[])\n        self.mock_federation_transport_client.get_event.side_effect = get_event\n        self.mock_federation_transport_client.get_room_state_ids.side_effect = get_room_state_ids\n        self.mock_federation_transport_client.get_room_state.side_effect = get_room_state\n        self.get_success(self.hs.get_federation_event_handler()._process_pulled_event(self.OTHER_SERVER_NAME, pulled_event, backfilled=False))\n        self.assertIsNone(self.get_success(main_store.get_rejection_reason(pulled_event.event_id)), 'Pulled event was unexpectedly rejected, likely due to a problem with the test setup.')\n        self.assertEqual({pulled_event.event_id}, self.get_success(main_store.have_events_in_timeline([pulled_event.event_id])), 'Pulled event was not persisted, likely due to a problem with the test setup.')\n        new_state_map = self.get_success(main_store.get_partial_current_state_ids(room_id))\n        self.assertEqual(new_state_map['m.room.member', bert_user_id], bert_member_event.event_id, 'Rejected kick event unexpectedly became part of room state.')",
        "mutated": [
            "def test_process_pulled_event_with_rejected_missing_state(self) -> None:\n    if False:\n        i = 10\n    'Ensure that we correctly handle pulled events with missing state containing a\\n        rejected state event\\n\\n        In this test, we pretend we are processing a \"pulled\" event (eg, via backfill\\n        or get_missing_events). The pulled event has a prev_event we haven\\'t previously\\n        seen, so the server requests the state at that prev_event. We expect the server\\n        to make a /state request.\\n\\n        We simulate a remote server whose /state includes a rejected kick event for a\\n        local user. Notably, the kick event is rejected only because it cites a rejected\\n        auth event and would otherwise be accepted based on the room state. During state\\n        resolution, we re-run auth and can potentially introduce such rejected events\\n        into the state if we are not careful.\\n\\n        We check that the pulled event is correctly persisted, and that the state\\n        afterwards does not include the rejected kick.\\n        '\n    OTHER_USER = f'@user:{self.OTHER_SERVER_NAME}'\n    main_store = self.hs.get_datastores().main\n    kermit_user_id = self.register_user('kermit', 'test')\n    kermit_tok = self.login('kermit', 'test')\n    room_id = self.helper.create_room_as(room_creator=kermit_user_id, tok=kermit_tok)\n    room_version = self.get_success(main_store.get_room_version(room_id))\n    bert_user_id = self.register_user('bert', 'test')\n    bert_tok = self.login('bert', 'test')\n    self.helper.join(room_id, user=bert_user_id, tok=bert_tok)\n    self.helper.send_state(room_id, 'm.room.power_levels', {'users': {kermit_user_id: 100, OTHER_USER: 100}}, tok=kermit_tok)\n    other_member_event = self.get_success(event_injection.inject_member_event(self.hs, room_id, OTHER_USER, 'join'))\n    initial_state_map = self.get_success(main_store.get_partial_current_state_ids(room_id))\n    create_event = self.get_success(main_store.get_event(initial_state_map['m.room.create', '']))\n    bert_member_event = self.get_success(main_store.get_event(initial_state_map['m.room.member', bert_user_id]))\n    power_levels_event = self.get_success(main_store.get_event(initial_state_map['m.room.power_levels', '']))\n    next_depth = 100\n    next_timestamp = other_member_event.origin_server_ts + 100\n    rejected_power_levels_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'm.room.power_levels', 'state_key': '', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [other_member_event.event_id], 'auth_events': [initial_state_map['m.room.create', ''], initial_state_map['m.room.power_levels', ''], other_member_event.event_id, other_member_event.event_id], 'origin_server_ts': next_timestamp, 'depth': next_depth, 'content': power_levels_event.content}), room_version)\n    next_depth += 1\n    next_timestamp += 100\n    with LoggingContext('send_rejected_power_levels_event'):\n        self.get_success(self.hs.get_federation_event_handler()._process_pulled_event(self.OTHER_SERVER_NAME, rejected_power_levels_event, backfilled=False))\n        self.assertEqual(self.get_success(main_store.get_rejection_reason(rejected_power_levels_event.event_id)), 'auth_error')\n    rejected_kick_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'm.room.member', 'state_key': bert_user_id, 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [rejected_power_levels_event.event_id], 'auth_events': [initial_state_map['m.room.create', ''], rejected_power_levels_event.event_id, initial_state_map['m.room.member', bert_user_id], initial_state_map['m.room.member', OTHER_USER]], 'origin_server_ts': next_timestamp, 'depth': next_depth, 'content': {'membership': 'leave'}}), room_version)\n    next_depth += 1\n    next_timestamp += 100\n    self.get_failure(check_state_independent_auth_rules(main_store, rejected_kick_event), AuthError)\n    check_state_dependent_auth_rules(rejected_kick_event, [create_event, power_levels_event, other_member_event, bert_member_event])\n    self.assertEqual(self.get_success(_mainline_sort(self.clock, room_id, event_ids=[bert_member_event.event_id, rejected_kick_event.event_id], resolved_power_event_id=power_levels_event.event_id, event_map={bert_member_event.event_id: bert_member_event, rejected_kick_event.event_id: rejected_kick_event}, state_res_store=StateResolutionStore(main_store))), [bert_member_event.event_id, rejected_kick_event.event_id], \"The rejected kick event will not be applied after bert's join event during state resolution. The test setup is incorrect.\")\n    with LoggingContext('send_rejected_kick_event'):\n        self.get_success(self.hs.get_federation_event_handler()._process_pulled_event(self.OTHER_SERVER_NAME, rejected_kick_event, backfilled=False))\n        self.assertEqual(self.get_success(main_store.get_rejection_reason(rejected_kick_event.event_id)), 'auth_error')\n    self.reactor.advance(100)\n    new_power_levels_event = self.get_success(main_store.get_event(self.helper.send_state(room_id, 'm.room.power_levels', {'users': {kermit_user_id: 100, OTHER_USER: 100, bert_user_id: 1}}, tok=kermit_tok)['event_id']))\n    self.assertEqual(self.get_success(_reverse_topological_power_sort(self.clock, room_id, event_ids=[new_power_levels_event.event_id, rejected_power_levels_event.event_id], event_map={}, state_res_store=StateResolutionStore(main_store), full_conflicted_set=set())), [rejected_power_levels_event.event_id, new_power_levels_event.event_id], 'The power levels events will not have the desired ordering during state resolution. The test setup is incorrect.')\n    missing_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'm.room.message', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [rejected_kick_event.event_id], 'auth_events': [initial_state_map['m.room.create', ''], initial_state_map['m.room.power_levels', ''], initial_state_map['m.room.member', OTHER_USER]], 'origin_server_ts': next_timestamp, 'depth': next_depth, 'content': {'msgtype': 'm.text', 'body': 'foo'}}), room_version)\n    next_depth += 1\n    next_timestamp += 100\n    pulled_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'm.room.message', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [new_power_levels_event.event_id, missing_event.event_id], 'auth_events': [initial_state_map['m.room.create', ''], new_power_levels_event.event_id, initial_state_map['m.room.member', OTHER_USER]], 'origin_server_ts': next_timestamp, 'depth': next_depth, 'content': {'msgtype': 'm.text', 'body': 'bar'}}), room_version)\n    next_depth += 1\n    next_timestamp += 100\n    state_before_missing_event = self.get_success(main_store.get_events_as_list(initial_state_map.values()))\n    state_before_missing_event = [event for event in state_before_missing_event if event.event_id != bert_member_event.event_id]\n    state_before_missing_event.append(rejected_kick_event)\n    self.reactor.advance(60000)\n    with LoggingContext('send_pulled_event'):\n\n        async def get_event(destination: str, event_id: str, timeout: Optional[int]=None) -> JsonDict:\n            self.assertEqual(destination, self.OTHER_SERVER_NAME)\n            self.assertEqual(event_id, missing_event.event_id)\n            return {'pdus': [missing_event.get_pdu_json()]}\n\n        async def get_room_state_ids(destination: str, room_id: str, event_id: str) -> JsonDict:\n            self.assertEqual(destination, self.OTHER_SERVER_NAME)\n            self.assertEqual(event_id, missing_event.event_id)\n            return {'pdu_ids': [event.event_id for event in state_before_missing_event], 'auth_chain_ids': []}\n\n        async def get_room_state(room_version: RoomVersion, destination: str, room_id: str, event_id: str) -> StateRequestResponse:\n            self.assertEqual(destination, self.OTHER_SERVER_NAME)\n            self.assertEqual(event_id, missing_event.event_id)\n            return StateRequestResponse(state=state_before_missing_event, auth_events=[])\n        self.mock_federation_transport_client.get_event.side_effect = get_event\n        self.mock_federation_transport_client.get_room_state_ids.side_effect = get_room_state_ids\n        self.mock_federation_transport_client.get_room_state.side_effect = get_room_state\n        self.get_success(self.hs.get_federation_event_handler()._process_pulled_event(self.OTHER_SERVER_NAME, pulled_event, backfilled=False))\n        self.assertIsNone(self.get_success(main_store.get_rejection_reason(pulled_event.event_id)), 'Pulled event was unexpectedly rejected, likely due to a problem with the test setup.')\n        self.assertEqual({pulled_event.event_id}, self.get_success(main_store.have_events_in_timeline([pulled_event.event_id])), 'Pulled event was not persisted, likely due to a problem with the test setup.')\n        new_state_map = self.get_success(main_store.get_partial_current_state_ids(room_id))\n        self.assertEqual(new_state_map['m.room.member', bert_user_id], bert_member_event.event_id, 'Rejected kick event unexpectedly became part of room state.')",
            "def test_process_pulled_event_with_rejected_missing_state(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Ensure that we correctly handle pulled events with missing state containing a\\n        rejected state event\\n\\n        In this test, we pretend we are processing a \"pulled\" event (eg, via backfill\\n        or get_missing_events). The pulled event has a prev_event we haven\\'t previously\\n        seen, so the server requests the state at that prev_event. We expect the server\\n        to make a /state request.\\n\\n        We simulate a remote server whose /state includes a rejected kick event for a\\n        local user. Notably, the kick event is rejected only because it cites a rejected\\n        auth event and would otherwise be accepted based on the room state. During state\\n        resolution, we re-run auth and can potentially introduce such rejected events\\n        into the state if we are not careful.\\n\\n        We check that the pulled event is correctly persisted, and that the state\\n        afterwards does not include the rejected kick.\\n        '\n    OTHER_USER = f'@user:{self.OTHER_SERVER_NAME}'\n    main_store = self.hs.get_datastores().main\n    kermit_user_id = self.register_user('kermit', 'test')\n    kermit_tok = self.login('kermit', 'test')\n    room_id = self.helper.create_room_as(room_creator=kermit_user_id, tok=kermit_tok)\n    room_version = self.get_success(main_store.get_room_version(room_id))\n    bert_user_id = self.register_user('bert', 'test')\n    bert_tok = self.login('bert', 'test')\n    self.helper.join(room_id, user=bert_user_id, tok=bert_tok)\n    self.helper.send_state(room_id, 'm.room.power_levels', {'users': {kermit_user_id: 100, OTHER_USER: 100}}, tok=kermit_tok)\n    other_member_event = self.get_success(event_injection.inject_member_event(self.hs, room_id, OTHER_USER, 'join'))\n    initial_state_map = self.get_success(main_store.get_partial_current_state_ids(room_id))\n    create_event = self.get_success(main_store.get_event(initial_state_map['m.room.create', '']))\n    bert_member_event = self.get_success(main_store.get_event(initial_state_map['m.room.member', bert_user_id]))\n    power_levels_event = self.get_success(main_store.get_event(initial_state_map['m.room.power_levels', '']))\n    next_depth = 100\n    next_timestamp = other_member_event.origin_server_ts + 100\n    rejected_power_levels_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'm.room.power_levels', 'state_key': '', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [other_member_event.event_id], 'auth_events': [initial_state_map['m.room.create', ''], initial_state_map['m.room.power_levels', ''], other_member_event.event_id, other_member_event.event_id], 'origin_server_ts': next_timestamp, 'depth': next_depth, 'content': power_levels_event.content}), room_version)\n    next_depth += 1\n    next_timestamp += 100\n    with LoggingContext('send_rejected_power_levels_event'):\n        self.get_success(self.hs.get_federation_event_handler()._process_pulled_event(self.OTHER_SERVER_NAME, rejected_power_levels_event, backfilled=False))\n        self.assertEqual(self.get_success(main_store.get_rejection_reason(rejected_power_levels_event.event_id)), 'auth_error')\n    rejected_kick_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'm.room.member', 'state_key': bert_user_id, 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [rejected_power_levels_event.event_id], 'auth_events': [initial_state_map['m.room.create', ''], rejected_power_levels_event.event_id, initial_state_map['m.room.member', bert_user_id], initial_state_map['m.room.member', OTHER_USER]], 'origin_server_ts': next_timestamp, 'depth': next_depth, 'content': {'membership': 'leave'}}), room_version)\n    next_depth += 1\n    next_timestamp += 100\n    self.get_failure(check_state_independent_auth_rules(main_store, rejected_kick_event), AuthError)\n    check_state_dependent_auth_rules(rejected_kick_event, [create_event, power_levels_event, other_member_event, bert_member_event])\n    self.assertEqual(self.get_success(_mainline_sort(self.clock, room_id, event_ids=[bert_member_event.event_id, rejected_kick_event.event_id], resolved_power_event_id=power_levels_event.event_id, event_map={bert_member_event.event_id: bert_member_event, rejected_kick_event.event_id: rejected_kick_event}, state_res_store=StateResolutionStore(main_store))), [bert_member_event.event_id, rejected_kick_event.event_id], \"The rejected kick event will not be applied after bert's join event during state resolution. The test setup is incorrect.\")\n    with LoggingContext('send_rejected_kick_event'):\n        self.get_success(self.hs.get_federation_event_handler()._process_pulled_event(self.OTHER_SERVER_NAME, rejected_kick_event, backfilled=False))\n        self.assertEqual(self.get_success(main_store.get_rejection_reason(rejected_kick_event.event_id)), 'auth_error')\n    self.reactor.advance(100)\n    new_power_levels_event = self.get_success(main_store.get_event(self.helper.send_state(room_id, 'm.room.power_levels', {'users': {kermit_user_id: 100, OTHER_USER: 100, bert_user_id: 1}}, tok=kermit_tok)['event_id']))\n    self.assertEqual(self.get_success(_reverse_topological_power_sort(self.clock, room_id, event_ids=[new_power_levels_event.event_id, rejected_power_levels_event.event_id], event_map={}, state_res_store=StateResolutionStore(main_store), full_conflicted_set=set())), [rejected_power_levels_event.event_id, new_power_levels_event.event_id], 'The power levels events will not have the desired ordering during state resolution. The test setup is incorrect.')\n    missing_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'm.room.message', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [rejected_kick_event.event_id], 'auth_events': [initial_state_map['m.room.create', ''], initial_state_map['m.room.power_levels', ''], initial_state_map['m.room.member', OTHER_USER]], 'origin_server_ts': next_timestamp, 'depth': next_depth, 'content': {'msgtype': 'm.text', 'body': 'foo'}}), room_version)\n    next_depth += 1\n    next_timestamp += 100\n    pulled_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'm.room.message', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [new_power_levels_event.event_id, missing_event.event_id], 'auth_events': [initial_state_map['m.room.create', ''], new_power_levels_event.event_id, initial_state_map['m.room.member', OTHER_USER]], 'origin_server_ts': next_timestamp, 'depth': next_depth, 'content': {'msgtype': 'm.text', 'body': 'bar'}}), room_version)\n    next_depth += 1\n    next_timestamp += 100\n    state_before_missing_event = self.get_success(main_store.get_events_as_list(initial_state_map.values()))\n    state_before_missing_event = [event for event in state_before_missing_event if event.event_id != bert_member_event.event_id]\n    state_before_missing_event.append(rejected_kick_event)\n    self.reactor.advance(60000)\n    with LoggingContext('send_pulled_event'):\n\n        async def get_event(destination: str, event_id: str, timeout: Optional[int]=None) -> JsonDict:\n            self.assertEqual(destination, self.OTHER_SERVER_NAME)\n            self.assertEqual(event_id, missing_event.event_id)\n            return {'pdus': [missing_event.get_pdu_json()]}\n\n        async def get_room_state_ids(destination: str, room_id: str, event_id: str) -> JsonDict:\n            self.assertEqual(destination, self.OTHER_SERVER_NAME)\n            self.assertEqual(event_id, missing_event.event_id)\n            return {'pdu_ids': [event.event_id for event in state_before_missing_event], 'auth_chain_ids': []}\n\n        async def get_room_state(room_version: RoomVersion, destination: str, room_id: str, event_id: str) -> StateRequestResponse:\n            self.assertEqual(destination, self.OTHER_SERVER_NAME)\n            self.assertEqual(event_id, missing_event.event_id)\n            return StateRequestResponse(state=state_before_missing_event, auth_events=[])\n        self.mock_federation_transport_client.get_event.side_effect = get_event\n        self.mock_federation_transport_client.get_room_state_ids.side_effect = get_room_state_ids\n        self.mock_federation_transport_client.get_room_state.side_effect = get_room_state\n        self.get_success(self.hs.get_federation_event_handler()._process_pulled_event(self.OTHER_SERVER_NAME, pulled_event, backfilled=False))\n        self.assertIsNone(self.get_success(main_store.get_rejection_reason(pulled_event.event_id)), 'Pulled event was unexpectedly rejected, likely due to a problem with the test setup.')\n        self.assertEqual({pulled_event.event_id}, self.get_success(main_store.have_events_in_timeline([pulled_event.event_id])), 'Pulled event was not persisted, likely due to a problem with the test setup.')\n        new_state_map = self.get_success(main_store.get_partial_current_state_ids(room_id))\n        self.assertEqual(new_state_map['m.room.member', bert_user_id], bert_member_event.event_id, 'Rejected kick event unexpectedly became part of room state.')",
            "def test_process_pulled_event_with_rejected_missing_state(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Ensure that we correctly handle pulled events with missing state containing a\\n        rejected state event\\n\\n        In this test, we pretend we are processing a \"pulled\" event (eg, via backfill\\n        or get_missing_events). The pulled event has a prev_event we haven\\'t previously\\n        seen, so the server requests the state at that prev_event. We expect the server\\n        to make a /state request.\\n\\n        We simulate a remote server whose /state includes a rejected kick event for a\\n        local user. Notably, the kick event is rejected only because it cites a rejected\\n        auth event and would otherwise be accepted based on the room state. During state\\n        resolution, we re-run auth and can potentially introduce such rejected events\\n        into the state if we are not careful.\\n\\n        We check that the pulled event is correctly persisted, and that the state\\n        afterwards does not include the rejected kick.\\n        '\n    OTHER_USER = f'@user:{self.OTHER_SERVER_NAME}'\n    main_store = self.hs.get_datastores().main\n    kermit_user_id = self.register_user('kermit', 'test')\n    kermit_tok = self.login('kermit', 'test')\n    room_id = self.helper.create_room_as(room_creator=kermit_user_id, tok=kermit_tok)\n    room_version = self.get_success(main_store.get_room_version(room_id))\n    bert_user_id = self.register_user('bert', 'test')\n    bert_tok = self.login('bert', 'test')\n    self.helper.join(room_id, user=bert_user_id, tok=bert_tok)\n    self.helper.send_state(room_id, 'm.room.power_levels', {'users': {kermit_user_id: 100, OTHER_USER: 100}}, tok=kermit_tok)\n    other_member_event = self.get_success(event_injection.inject_member_event(self.hs, room_id, OTHER_USER, 'join'))\n    initial_state_map = self.get_success(main_store.get_partial_current_state_ids(room_id))\n    create_event = self.get_success(main_store.get_event(initial_state_map['m.room.create', '']))\n    bert_member_event = self.get_success(main_store.get_event(initial_state_map['m.room.member', bert_user_id]))\n    power_levels_event = self.get_success(main_store.get_event(initial_state_map['m.room.power_levels', '']))\n    next_depth = 100\n    next_timestamp = other_member_event.origin_server_ts + 100\n    rejected_power_levels_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'm.room.power_levels', 'state_key': '', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [other_member_event.event_id], 'auth_events': [initial_state_map['m.room.create', ''], initial_state_map['m.room.power_levels', ''], other_member_event.event_id, other_member_event.event_id], 'origin_server_ts': next_timestamp, 'depth': next_depth, 'content': power_levels_event.content}), room_version)\n    next_depth += 1\n    next_timestamp += 100\n    with LoggingContext('send_rejected_power_levels_event'):\n        self.get_success(self.hs.get_federation_event_handler()._process_pulled_event(self.OTHER_SERVER_NAME, rejected_power_levels_event, backfilled=False))\n        self.assertEqual(self.get_success(main_store.get_rejection_reason(rejected_power_levels_event.event_id)), 'auth_error')\n    rejected_kick_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'm.room.member', 'state_key': bert_user_id, 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [rejected_power_levels_event.event_id], 'auth_events': [initial_state_map['m.room.create', ''], rejected_power_levels_event.event_id, initial_state_map['m.room.member', bert_user_id], initial_state_map['m.room.member', OTHER_USER]], 'origin_server_ts': next_timestamp, 'depth': next_depth, 'content': {'membership': 'leave'}}), room_version)\n    next_depth += 1\n    next_timestamp += 100\n    self.get_failure(check_state_independent_auth_rules(main_store, rejected_kick_event), AuthError)\n    check_state_dependent_auth_rules(rejected_kick_event, [create_event, power_levels_event, other_member_event, bert_member_event])\n    self.assertEqual(self.get_success(_mainline_sort(self.clock, room_id, event_ids=[bert_member_event.event_id, rejected_kick_event.event_id], resolved_power_event_id=power_levels_event.event_id, event_map={bert_member_event.event_id: bert_member_event, rejected_kick_event.event_id: rejected_kick_event}, state_res_store=StateResolutionStore(main_store))), [bert_member_event.event_id, rejected_kick_event.event_id], \"The rejected kick event will not be applied after bert's join event during state resolution. The test setup is incorrect.\")\n    with LoggingContext('send_rejected_kick_event'):\n        self.get_success(self.hs.get_federation_event_handler()._process_pulled_event(self.OTHER_SERVER_NAME, rejected_kick_event, backfilled=False))\n        self.assertEqual(self.get_success(main_store.get_rejection_reason(rejected_kick_event.event_id)), 'auth_error')\n    self.reactor.advance(100)\n    new_power_levels_event = self.get_success(main_store.get_event(self.helper.send_state(room_id, 'm.room.power_levels', {'users': {kermit_user_id: 100, OTHER_USER: 100, bert_user_id: 1}}, tok=kermit_tok)['event_id']))\n    self.assertEqual(self.get_success(_reverse_topological_power_sort(self.clock, room_id, event_ids=[new_power_levels_event.event_id, rejected_power_levels_event.event_id], event_map={}, state_res_store=StateResolutionStore(main_store), full_conflicted_set=set())), [rejected_power_levels_event.event_id, new_power_levels_event.event_id], 'The power levels events will not have the desired ordering during state resolution. The test setup is incorrect.')\n    missing_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'm.room.message', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [rejected_kick_event.event_id], 'auth_events': [initial_state_map['m.room.create', ''], initial_state_map['m.room.power_levels', ''], initial_state_map['m.room.member', OTHER_USER]], 'origin_server_ts': next_timestamp, 'depth': next_depth, 'content': {'msgtype': 'm.text', 'body': 'foo'}}), room_version)\n    next_depth += 1\n    next_timestamp += 100\n    pulled_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'm.room.message', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [new_power_levels_event.event_id, missing_event.event_id], 'auth_events': [initial_state_map['m.room.create', ''], new_power_levels_event.event_id, initial_state_map['m.room.member', OTHER_USER]], 'origin_server_ts': next_timestamp, 'depth': next_depth, 'content': {'msgtype': 'm.text', 'body': 'bar'}}), room_version)\n    next_depth += 1\n    next_timestamp += 100\n    state_before_missing_event = self.get_success(main_store.get_events_as_list(initial_state_map.values()))\n    state_before_missing_event = [event for event in state_before_missing_event if event.event_id != bert_member_event.event_id]\n    state_before_missing_event.append(rejected_kick_event)\n    self.reactor.advance(60000)\n    with LoggingContext('send_pulled_event'):\n\n        async def get_event(destination: str, event_id: str, timeout: Optional[int]=None) -> JsonDict:\n            self.assertEqual(destination, self.OTHER_SERVER_NAME)\n            self.assertEqual(event_id, missing_event.event_id)\n            return {'pdus': [missing_event.get_pdu_json()]}\n\n        async def get_room_state_ids(destination: str, room_id: str, event_id: str) -> JsonDict:\n            self.assertEqual(destination, self.OTHER_SERVER_NAME)\n            self.assertEqual(event_id, missing_event.event_id)\n            return {'pdu_ids': [event.event_id for event in state_before_missing_event], 'auth_chain_ids': []}\n\n        async def get_room_state(room_version: RoomVersion, destination: str, room_id: str, event_id: str) -> StateRequestResponse:\n            self.assertEqual(destination, self.OTHER_SERVER_NAME)\n            self.assertEqual(event_id, missing_event.event_id)\n            return StateRequestResponse(state=state_before_missing_event, auth_events=[])\n        self.mock_federation_transport_client.get_event.side_effect = get_event\n        self.mock_federation_transport_client.get_room_state_ids.side_effect = get_room_state_ids\n        self.mock_federation_transport_client.get_room_state.side_effect = get_room_state\n        self.get_success(self.hs.get_federation_event_handler()._process_pulled_event(self.OTHER_SERVER_NAME, pulled_event, backfilled=False))\n        self.assertIsNone(self.get_success(main_store.get_rejection_reason(pulled_event.event_id)), 'Pulled event was unexpectedly rejected, likely due to a problem with the test setup.')\n        self.assertEqual({pulled_event.event_id}, self.get_success(main_store.have_events_in_timeline([pulled_event.event_id])), 'Pulled event was not persisted, likely due to a problem with the test setup.')\n        new_state_map = self.get_success(main_store.get_partial_current_state_ids(room_id))\n        self.assertEqual(new_state_map['m.room.member', bert_user_id], bert_member_event.event_id, 'Rejected kick event unexpectedly became part of room state.')",
            "def test_process_pulled_event_with_rejected_missing_state(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Ensure that we correctly handle pulled events with missing state containing a\\n        rejected state event\\n\\n        In this test, we pretend we are processing a \"pulled\" event (eg, via backfill\\n        or get_missing_events). The pulled event has a prev_event we haven\\'t previously\\n        seen, so the server requests the state at that prev_event. We expect the server\\n        to make a /state request.\\n\\n        We simulate a remote server whose /state includes a rejected kick event for a\\n        local user. Notably, the kick event is rejected only because it cites a rejected\\n        auth event and would otherwise be accepted based on the room state. During state\\n        resolution, we re-run auth and can potentially introduce such rejected events\\n        into the state if we are not careful.\\n\\n        We check that the pulled event is correctly persisted, and that the state\\n        afterwards does not include the rejected kick.\\n        '\n    OTHER_USER = f'@user:{self.OTHER_SERVER_NAME}'\n    main_store = self.hs.get_datastores().main\n    kermit_user_id = self.register_user('kermit', 'test')\n    kermit_tok = self.login('kermit', 'test')\n    room_id = self.helper.create_room_as(room_creator=kermit_user_id, tok=kermit_tok)\n    room_version = self.get_success(main_store.get_room_version(room_id))\n    bert_user_id = self.register_user('bert', 'test')\n    bert_tok = self.login('bert', 'test')\n    self.helper.join(room_id, user=bert_user_id, tok=bert_tok)\n    self.helper.send_state(room_id, 'm.room.power_levels', {'users': {kermit_user_id: 100, OTHER_USER: 100}}, tok=kermit_tok)\n    other_member_event = self.get_success(event_injection.inject_member_event(self.hs, room_id, OTHER_USER, 'join'))\n    initial_state_map = self.get_success(main_store.get_partial_current_state_ids(room_id))\n    create_event = self.get_success(main_store.get_event(initial_state_map['m.room.create', '']))\n    bert_member_event = self.get_success(main_store.get_event(initial_state_map['m.room.member', bert_user_id]))\n    power_levels_event = self.get_success(main_store.get_event(initial_state_map['m.room.power_levels', '']))\n    next_depth = 100\n    next_timestamp = other_member_event.origin_server_ts + 100\n    rejected_power_levels_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'm.room.power_levels', 'state_key': '', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [other_member_event.event_id], 'auth_events': [initial_state_map['m.room.create', ''], initial_state_map['m.room.power_levels', ''], other_member_event.event_id, other_member_event.event_id], 'origin_server_ts': next_timestamp, 'depth': next_depth, 'content': power_levels_event.content}), room_version)\n    next_depth += 1\n    next_timestamp += 100\n    with LoggingContext('send_rejected_power_levels_event'):\n        self.get_success(self.hs.get_federation_event_handler()._process_pulled_event(self.OTHER_SERVER_NAME, rejected_power_levels_event, backfilled=False))\n        self.assertEqual(self.get_success(main_store.get_rejection_reason(rejected_power_levels_event.event_id)), 'auth_error')\n    rejected_kick_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'm.room.member', 'state_key': bert_user_id, 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [rejected_power_levels_event.event_id], 'auth_events': [initial_state_map['m.room.create', ''], rejected_power_levels_event.event_id, initial_state_map['m.room.member', bert_user_id], initial_state_map['m.room.member', OTHER_USER]], 'origin_server_ts': next_timestamp, 'depth': next_depth, 'content': {'membership': 'leave'}}), room_version)\n    next_depth += 1\n    next_timestamp += 100\n    self.get_failure(check_state_independent_auth_rules(main_store, rejected_kick_event), AuthError)\n    check_state_dependent_auth_rules(rejected_kick_event, [create_event, power_levels_event, other_member_event, bert_member_event])\n    self.assertEqual(self.get_success(_mainline_sort(self.clock, room_id, event_ids=[bert_member_event.event_id, rejected_kick_event.event_id], resolved_power_event_id=power_levels_event.event_id, event_map={bert_member_event.event_id: bert_member_event, rejected_kick_event.event_id: rejected_kick_event}, state_res_store=StateResolutionStore(main_store))), [bert_member_event.event_id, rejected_kick_event.event_id], \"The rejected kick event will not be applied after bert's join event during state resolution. The test setup is incorrect.\")\n    with LoggingContext('send_rejected_kick_event'):\n        self.get_success(self.hs.get_federation_event_handler()._process_pulled_event(self.OTHER_SERVER_NAME, rejected_kick_event, backfilled=False))\n        self.assertEqual(self.get_success(main_store.get_rejection_reason(rejected_kick_event.event_id)), 'auth_error')\n    self.reactor.advance(100)\n    new_power_levels_event = self.get_success(main_store.get_event(self.helper.send_state(room_id, 'm.room.power_levels', {'users': {kermit_user_id: 100, OTHER_USER: 100, bert_user_id: 1}}, tok=kermit_tok)['event_id']))\n    self.assertEqual(self.get_success(_reverse_topological_power_sort(self.clock, room_id, event_ids=[new_power_levels_event.event_id, rejected_power_levels_event.event_id], event_map={}, state_res_store=StateResolutionStore(main_store), full_conflicted_set=set())), [rejected_power_levels_event.event_id, new_power_levels_event.event_id], 'The power levels events will not have the desired ordering during state resolution. The test setup is incorrect.')\n    missing_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'm.room.message', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [rejected_kick_event.event_id], 'auth_events': [initial_state_map['m.room.create', ''], initial_state_map['m.room.power_levels', ''], initial_state_map['m.room.member', OTHER_USER]], 'origin_server_ts': next_timestamp, 'depth': next_depth, 'content': {'msgtype': 'm.text', 'body': 'foo'}}), room_version)\n    next_depth += 1\n    next_timestamp += 100\n    pulled_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'm.room.message', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [new_power_levels_event.event_id, missing_event.event_id], 'auth_events': [initial_state_map['m.room.create', ''], new_power_levels_event.event_id, initial_state_map['m.room.member', OTHER_USER]], 'origin_server_ts': next_timestamp, 'depth': next_depth, 'content': {'msgtype': 'm.text', 'body': 'bar'}}), room_version)\n    next_depth += 1\n    next_timestamp += 100\n    state_before_missing_event = self.get_success(main_store.get_events_as_list(initial_state_map.values()))\n    state_before_missing_event = [event for event in state_before_missing_event if event.event_id != bert_member_event.event_id]\n    state_before_missing_event.append(rejected_kick_event)\n    self.reactor.advance(60000)\n    with LoggingContext('send_pulled_event'):\n\n        async def get_event(destination: str, event_id: str, timeout: Optional[int]=None) -> JsonDict:\n            self.assertEqual(destination, self.OTHER_SERVER_NAME)\n            self.assertEqual(event_id, missing_event.event_id)\n            return {'pdus': [missing_event.get_pdu_json()]}\n\n        async def get_room_state_ids(destination: str, room_id: str, event_id: str) -> JsonDict:\n            self.assertEqual(destination, self.OTHER_SERVER_NAME)\n            self.assertEqual(event_id, missing_event.event_id)\n            return {'pdu_ids': [event.event_id for event in state_before_missing_event], 'auth_chain_ids': []}\n\n        async def get_room_state(room_version: RoomVersion, destination: str, room_id: str, event_id: str) -> StateRequestResponse:\n            self.assertEqual(destination, self.OTHER_SERVER_NAME)\n            self.assertEqual(event_id, missing_event.event_id)\n            return StateRequestResponse(state=state_before_missing_event, auth_events=[])\n        self.mock_federation_transport_client.get_event.side_effect = get_event\n        self.mock_federation_transport_client.get_room_state_ids.side_effect = get_room_state_ids\n        self.mock_federation_transport_client.get_room_state.side_effect = get_room_state\n        self.get_success(self.hs.get_federation_event_handler()._process_pulled_event(self.OTHER_SERVER_NAME, pulled_event, backfilled=False))\n        self.assertIsNone(self.get_success(main_store.get_rejection_reason(pulled_event.event_id)), 'Pulled event was unexpectedly rejected, likely due to a problem with the test setup.')\n        self.assertEqual({pulled_event.event_id}, self.get_success(main_store.have_events_in_timeline([pulled_event.event_id])), 'Pulled event was not persisted, likely due to a problem with the test setup.')\n        new_state_map = self.get_success(main_store.get_partial_current_state_ids(room_id))\n        self.assertEqual(new_state_map['m.room.member', bert_user_id], bert_member_event.event_id, 'Rejected kick event unexpectedly became part of room state.')",
            "def test_process_pulled_event_with_rejected_missing_state(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Ensure that we correctly handle pulled events with missing state containing a\\n        rejected state event\\n\\n        In this test, we pretend we are processing a \"pulled\" event (eg, via backfill\\n        or get_missing_events). The pulled event has a prev_event we haven\\'t previously\\n        seen, so the server requests the state at that prev_event. We expect the server\\n        to make a /state request.\\n\\n        We simulate a remote server whose /state includes a rejected kick event for a\\n        local user. Notably, the kick event is rejected only because it cites a rejected\\n        auth event and would otherwise be accepted based on the room state. During state\\n        resolution, we re-run auth and can potentially introduce such rejected events\\n        into the state if we are not careful.\\n\\n        We check that the pulled event is correctly persisted, and that the state\\n        afterwards does not include the rejected kick.\\n        '\n    OTHER_USER = f'@user:{self.OTHER_SERVER_NAME}'\n    main_store = self.hs.get_datastores().main\n    kermit_user_id = self.register_user('kermit', 'test')\n    kermit_tok = self.login('kermit', 'test')\n    room_id = self.helper.create_room_as(room_creator=kermit_user_id, tok=kermit_tok)\n    room_version = self.get_success(main_store.get_room_version(room_id))\n    bert_user_id = self.register_user('bert', 'test')\n    bert_tok = self.login('bert', 'test')\n    self.helper.join(room_id, user=bert_user_id, tok=bert_tok)\n    self.helper.send_state(room_id, 'm.room.power_levels', {'users': {kermit_user_id: 100, OTHER_USER: 100}}, tok=kermit_tok)\n    other_member_event = self.get_success(event_injection.inject_member_event(self.hs, room_id, OTHER_USER, 'join'))\n    initial_state_map = self.get_success(main_store.get_partial_current_state_ids(room_id))\n    create_event = self.get_success(main_store.get_event(initial_state_map['m.room.create', '']))\n    bert_member_event = self.get_success(main_store.get_event(initial_state_map['m.room.member', bert_user_id]))\n    power_levels_event = self.get_success(main_store.get_event(initial_state_map['m.room.power_levels', '']))\n    next_depth = 100\n    next_timestamp = other_member_event.origin_server_ts + 100\n    rejected_power_levels_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'm.room.power_levels', 'state_key': '', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [other_member_event.event_id], 'auth_events': [initial_state_map['m.room.create', ''], initial_state_map['m.room.power_levels', ''], other_member_event.event_id, other_member_event.event_id], 'origin_server_ts': next_timestamp, 'depth': next_depth, 'content': power_levels_event.content}), room_version)\n    next_depth += 1\n    next_timestamp += 100\n    with LoggingContext('send_rejected_power_levels_event'):\n        self.get_success(self.hs.get_federation_event_handler()._process_pulled_event(self.OTHER_SERVER_NAME, rejected_power_levels_event, backfilled=False))\n        self.assertEqual(self.get_success(main_store.get_rejection_reason(rejected_power_levels_event.event_id)), 'auth_error')\n    rejected_kick_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'm.room.member', 'state_key': bert_user_id, 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [rejected_power_levels_event.event_id], 'auth_events': [initial_state_map['m.room.create', ''], rejected_power_levels_event.event_id, initial_state_map['m.room.member', bert_user_id], initial_state_map['m.room.member', OTHER_USER]], 'origin_server_ts': next_timestamp, 'depth': next_depth, 'content': {'membership': 'leave'}}), room_version)\n    next_depth += 1\n    next_timestamp += 100\n    self.get_failure(check_state_independent_auth_rules(main_store, rejected_kick_event), AuthError)\n    check_state_dependent_auth_rules(rejected_kick_event, [create_event, power_levels_event, other_member_event, bert_member_event])\n    self.assertEqual(self.get_success(_mainline_sort(self.clock, room_id, event_ids=[bert_member_event.event_id, rejected_kick_event.event_id], resolved_power_event_id=power_levels_event.event_id, event_map={bert_member_event.event_id: bert_member_event, rejected_kick_event.event_id: rejected_kick_event}, state_res_store=StateResolutionStore(main_store))), [bert_member_event.event_id, rejected_kick_event.event_id], \"The rejected kick event will not be applied after bert's join event during state resolution. The test setup is incorrect.\")\n    with LoggingContext('send_rejected_kick_event'):\n        self.get_success(self.hs.get_federation_event_handler()._process_pulled_event(self.OTHER_SERVER_NAME, rejected_kick_event, backfilled=False))\n        self.assertEqual(self.get_success(main_store.get_rejection_reason(rejected_kick_event.event_id)), 'auth_error')\n    self.reactor.advance(100)\n    new_power_levels_event = self.get_success(main_store.get_event(self.helper.send_state(room_id, 'm.room.power_levels', {'users': {kermit_user_id: 100, OTHER_USER: 100, bert_user_id: 1}}, tok=kermit_tok)['event_id']))\n    self.assertEqual(self.get_success(_reverse_topological_power_sort(self.clock, room_id, event_ids=[new_power_levels_event.event_id, rejected_power_levels_event.event_id], event_map={}, state_res_store=StateResolutionStore(main_store), full_conflicted_set=set())), [rejected_power_levels_event.event_id, new_power_levels_event.event_id], 'The power levels events will not have the desired ordering during state resolution. The test setup is incorrect.')\n    missing_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'm.room.message', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [rejected_kick_event.event_id], 'auth_events': [initial_state_map['m.room.create', ''], initial_state_map['m.room.power_levels', ''], initial_state_map['m.room.member', OTHER_USER]], 'origin_server_ts': next_timestamp, 'depth': next_depth, 'content': {'msgtype': 'm.text', 'body': 'foo'}}), room_version)\n    next_depth += 1\n    next_timestamp += 100\n    pulled_event = make_event_from_dict(self.add_hashes_and_signatures_from_other_server({'type': 'm.room.message', 'room_id': room_id, 'sender': OTHER_USER, 'prev_events': [new_power_levels_event.event_id, missing_event.event_id], 'auth_events': [initial_state_map['m.room.create', ''], new_power_levels_event.event_id, initial_state_map['m.room.member', OTHER_USER]], 'origin_server_ts': next_timestamp, 'depth': next_depth, 'content': {'msgtype': 'm.text', 'body': 'bar'}}), room_version)\n    next_depth += 1\n    next_timestamp += 100\n    state_before_missing_event = self.get_success(main_store.get_events_as_list(initial_state_map.values()))\n    state_before_missing_event = [event for event in state_before_missing_event if event.event_id != bert_member_event.event_id]\n    state_before_missing_event.append(rejected_kick_event)\n    self.reactor.advance(60000)\n    with LoggingContext('send_pulled_event'):\n\n        async def get_event(destination: str, event_id: str, timeout: Optional[int]=None) -> JsonDict:\n            self.assertEqual(destination, self.OTHER_SERVER_NAME)\n            self.assertEqual(event_id, missing_event.event_id)\n            return {'pdus': [missing_event.get_pdu_json()]}\n\n        async def get_room_state_ids(destination: str, room_id: str, event_id: str) -> JsonDict:\n            self.assertEqual(destination, self.OTHER_SERVER_NAME)\n            self.assertEqual(event_id, missing_event.event_id)\n            return {'pdu_ids': [event.event_id for event in state_before_missing_event], 'auth_chain_ids': []}\n\n        async def get_room_state(room_version: RoomVersion, destination: str, room_id: str, event_id: str) -> StateRequestResponse:\n            self.assertEqual(destination, self.OTHER_SERVER_NAME)\n            self.assertEqual(event_id, missing_event.event_id)\n            return StateRequestResponse(state=state_before_missing_event, auth_events=[])\n        self.mock_federation_transport_client.get_event.side_effect = get_event\n        self.mock_federation_transport_client.get_room_state_ids.side_effect = get_room_state_ids\n        self.mock_federation_transport_client.get_room_state.side_effect = get_room_state\n        self.get_success(self.hs.get_federation_event_handler()._process_pulled_event(self.OTHER_SERVER_NAME, pulled_event, backfilled=False))\n        self.assertIsNone(self.get_success(main_store.get_rejection_reason(pulled_event.event_id)), 'Pulled event was unexpectedly rejected, likely due to a problem with the test setup.')\n        self.assertEqual({pulled_event.event_id}, self.get_success(main_store.have_events_in_timeline([pulled_event.event_id])), 'Pulled event was not persisted, likely due to a problem with the test setup.')\n        new_state_map = self.get_success(main_store.get_partial_current_state_ids(room_id))\n        self.assertEqual(new_state_map['m.room.member', bert_user_id], bert_member_event.event_id, 'Rejected kick event unexpectedly became part of room state.')"
        ]
    }
]