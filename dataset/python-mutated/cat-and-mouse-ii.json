[
    {
        "func_name": "parents",
        "original": "def parents(m, c, t):\n    if t == CAT:\n        for nm in graph[m, MOUSE ^ CAT ^ t]:\n            yield (nm, c, MOUSE ^ CAT ^ t)\n    else:\n        for nc in graph[c, MOUSE ^ CAT ^ t]:\n            yield (m, nc, MOUSE ^ CAT ^ t)",
        "mutated": [
            "def parents(m, c, t):\n    if False:\n        i = 10\n    if t == CAT:\n        for nm in graph[m, MOUSE ^ CAT ^ t]:\n            yield (nm, c, MOUSE ^ CAT ^ t)\n    else:\n        for nc in graph[c, MOUSE ^ CAT ^ t]:\n            yield (m, nc, MOUSE ^ CAT ^ t)",
            "def parents(m, c, t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if t == CAT:\n        for nm in graph[m, MOUSE ^ CAT ^ t]:\n            yield (nm, c, MOUSE ^ CAT ^ t)\n    else:\n        for nc in graph[c, MOUSE ^ CAT ^ t]:\n            yield (m, nc, MOUSE ^ CAT ^ t)",
            "def parents(m, c, t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if t == CAT:\n        for nm in graph[m, MOUSE ^ CAT ^ t]:\n            yield (nm, c, MOUSE ^ CAT ^ t)\n    else:\n        for nc in graph[c, MOUSE ^ CAT ^ t]:\n            yield (m, nc, MOUSE ^ CAT ^ t)",
            "def parents(m, c, t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if t == CAT:\n        for nm in graph[m, MOUSE ^ CAT ^ t]:\n            yield (nm, c, MOUSE ^ CAT ^ t)\n    else:\n        for nc in graph[c, MOUSE ^ CAT ^ t]:\n            yield (m, nc, MOUSE ^ CAT ^ t)",
            "def parents(m, c, t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if t == CAT:\n        for nm in graph[m, MOUSE ^ CAT ^ t]:\n            yield (nm, c, MOUSE ^ CAT ^ t)\n    else:\n        for nc in graph[c, MOUSE ^ CAT ^ t]:\n            yield (m, nc, MOUSE ^ CAT ^ t)"
        ]
    },
    {
        "func_name": "canMouseWin",
        "original": "def canMouseWin(self, grid, catJump, mouseJump):\n    \"\"\"\n        :type grid: List[str]\n        :type catJump: int\n        :type mouseJump: int\n        :rtype: bool\n        \"\"\"\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    (DRAW, MOUSE, CAT) = range(3)\n\n    def parents(m, c, t):\n        if t == CAT:\n            for nm in graph[m, MOUSE ^ CAT ^ t]:\n                yield (nm, c, MOUSE ^ CAT ^ t)\n        else:\n            for nc in graph[c, MOUSE ^ CAT ^ t]:\n                yield (m, nc, MOUSE ^ CAT ^ t)\n    (R, C) = (len(grid), len(grid[0]))\n    N = R * C\n    WALLS = set()\n    (FOOD, MOUSE_START, CAT_START) = [-1] * 3\n    for r in xrange(R):\n        for c in xrange(C):\n            if grid[r][c] == 'M':\n                MOUSE_START = r * C + c\n            elif grid[r][c] == 'C':\n                CAT_START = r * C + c\n            elif grid[r][c] == 'F':\n                FOOD = r * C + c\n            elif grid[r][c] == '#':\n                WALLS.add(r * C + c)\n    graph = collections.defaultdict(set)\n    jump = {MOUSE: mouseJump, CAT: catJump}\n    for r in xrange(R):\n        for c in xrange(C):\n            if grid[r][c] == '#':\n                continue\n            pos = r * C + c\n            for t in [MOUSE, CAT]:\n                for (dr, dc) in directions:\n                    for d in xrange(jump[t] + 1):\n                        (nr, nc) = (r + dr * d, c + dc * d)\n                        if not (0 <= nr < R and 0 <= nc < C and (grid[nr][nc] != '#')):\n                            break\n                        graph[pos, t].add(nr * C + nc)\n    degree = {}\n    for m in xrange(N):\n        for c in xrange(N):\n            degree[m, c, MOUSE] = len(graph[m, MOUSE])\n            degree[m, c, CAT] = len(graph[c, CAT])\n    color = collections.defaultdict(int)\n    q = collections.deque()\n    for i in xrange(N):\n        if i in WALLS or i == FOOD:\n            continue\n        color[FOOD, i, CAT] = MOUSE\n        q.append((FOOD, i, CAT, MOUSE))\n        color[i, FOOD, MOUSE] = CAT\n        q.append((i, FOOD, MOUSE, CAT))\n        for t in [MOUSE, CAT]:\n            color[i, i, t] = CAT\n            q.append((i, i, t, CAT))\n    while q:\n        (i, j, t, c) = q.popleft()\n        for (ni, nj, nt) in parents(i, j, t):\n            if color[ni, nj, nt] != DRAW:\n                continue\n            if nt == c:\n                color[ni, nj, nt] = c\n                q.append((ni, nj, nt, c))\n                continue\n            degree[ni, nj, nt] -= 1\n            if not degree[ni, nj, nt]:\n                color[ni, nj, nt] = c\n                q.append((ni, nj, nt, c))\n    return color[MOUSE_START, CAT_START, MOUSE] == MOUSE",
        "mutated": [
            "def canMouseWin(self, grid, catJump, mouseJump):\n    if False:\n        i = 10\n    '\\n        :type grid: List[str]\\n        :type catJump: int\\n        :type mouseJump: int\\n        :rtype: bool\\n        '\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    (DRAW, MOUSE, CAT) = range(3)\n\n    def parents(m, c, t):\n        if t == CAT:\n            for nm in graph[m, MOUSE ^ CAT ^ t]:\n                yield (nm, c, MOUSE ^ CAT ^ t)\n        else:\n            for nc in graph[c, MOUSE ^ CAT ^ t]:\n                yield (m, nc, MOUSE ^ CAT ^ t)\n    (R, C) = (len(grid), len(grid[0]))\n    N = R * C\n    WALLS = set()\n    (FOOD, MOUSE_START, CAT_START) = [-1] * 3\n    for r in xrange(R):\n        for c in xrange(C):\n            if grid[r][c] == 'M':\n                MOUSE_START = r * C + c\n            elif grid[r][c] == 'C':\n                CAT_START = r * C + c\n            elif grid[r][c] == 'F':\n                FOOD = r * C + c\n            elif grid[r][c] == '#':\n                WALLS.add(r * C + c)\n    graph = collections.defaultdict(set)\n    jump = {MOUSE: mouseJump, CAT: catJump}\n    for r in xrange(R):\n        for c in xrange(C):\n            if grid[r][c] == '#':\n                continue\n            pos = r * C + c\n            for t in [MOUSE, CAT]:\n                for (dr, dc) in directions:\n                    for d in xrange(jump[t] + 1):\n                        (nr, nc) = (r + dr * d, c + dc * d)\n                        if not (0 <= nr < R and 0 <= nc < C and (grid[nr][nc] != '#')):\n                            break\n                        graph[pos, t].add(nr * C + nc)\n    degree = {}\n    for m in xrange(N):\n        for c in xrange(N):\n            degree[m, c, MOUSE] = len(graph[m, MOUSE])\n            degree[m, c, CAT] = len(graph[c, CAT])\n    color = collections.defaultdict(int)\n    q = collections.deque()\n    for i in xrange(N):\n        if i in WALLS or i == FOOD:\n            continue\n        color[FOOD, i, CAT] = MOUSE\n        q.append((FOOD, i, CAT, MOUSE))\n        color[i, FOOD, MOUSE] = CAT\n        q.append((i, FOOD, MOUSE, CAT))\n        for t in [MOUSE, CAT]:\n            color[i, i, t] = CAT\n            q.append((i, i, t, CAT))\n    while q:\n        (i, j, t, c) = q.popleft()\n        for (ni, nj, nt) in parents(i, j, t):\n            if color[ni, nj, nt] != DRAW:\n                continue\n            if nt == c:\n                color[ni, nj, nt] = c\n                q.append((ni, nj, nt, c))\n                continue\n            degree[ni, nj, nt] -= 1\n            if not degree[ni, nj, nt]:\n                color[ni, nj, nt] = c\n                q.append((ni, nj, nt, c))\n    return color[MOUSE_START, CAT_START, MOUSE] == MOUSE",
            "def canMouseWin(self, grid, catJump, mouseJump):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :type grid: List[str]\\n        :type catJump: int\\n        :type mouseJump: int\\n        :rtype: bool\\n        '\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    (DRAW, MOUSE, CAT) = range(3)\n\n    def parents(m, c, t):\n        if t == CAT:\n            for nm in graph[m, MOUSE ^ CAT ^ t]:\n                yield (nm, c, MOUSE ^ CAT ^ t)\n        else:\n            for nc in graph[c, MOUSE ^ CAT ^ t]:\n                yield (m, nc, MOUSE ^ CAT ^ t)\n    (R, C) = (len(grid), len(grid[0]))\n    N = R * C\n    WALLS = set()\n    (FOOD, MOUSE_START, CAT_START) = [-1] * 3\n    for r in xrange(R):\n        for c in xrange(C):\n            if grid[r][c] == 'M':\n                MOUSE_START = r * C + c\n            elif grid[r][c] == 'C':\n                CAT_START = r * C + c\n            elif grid[r][c] == 'F':\n                FOOD = r * C + c\n            elif grid[r][c] == '#':\n                WALLS.add(r * C + c)\n    graph = collections.defaultdict(set)\n    jump = {MOUSE: mouseJump, CAT: catJump}\n    for r in xrange(R):\n        for c in xrange(C):\n            if grid[r][c] == '#':\n                continue\n            pos = r * C + c\n            for t in [MOUSE, CAT]:\n                for (dr, dc) in directions:\n                    for d in xrange(jump[t] + 1):\n                        (nr, nc) = (r + dr * d, c + dc * d)\n                        if not (0 <= nr < R and 0 <= nc < C and (grid[nr][nc] != '#')):\n                            break\n                        graph[pos, t].add(nr * C + nc)\n    degree = {}\n    for m in xrange(N):\n        for c in xrange(N):\n            degree[m, c, MOUSE] = len(graph[m, MOUSE])\n            degree[m, c, CAT] = len(graph[c, CAT])\n    color = collections.defaultdict(int)\n    q = collections.deque()\n    for i in xrange(N):\n        if i in WALLS or i == FOOD:\n            continue\n        color[FOOD, i, CAT] = MOUSE\n        q.append((FOOD, i, CAT, MOUSE))\n        color[i, FOOD, MOUSE] = CAT\n        q.append((i, FOOD, MOUSE, CAT))\n        for t in [MOUSE, CAT]:\n            color[i, i, t] = CAT\n            q.append((i, i, t, CAT))\n    while q:\n        (i, j, t, c) = q.popleft()\n        for (ni, nj, nt) in parents(i, j, t):\n            if color[ni, nj, nt] != DRAW:\n                continue\n            if nt == c:\n                color[ni, nj, nt] = c\n                q.append((ni, nj, nt, c))\n                continue\n            degree[ni, nj, nt] -= 1\n            if not degree[ni, nj, nt]:\n                color[ni, nj, nt] = c\n                q.append((ni, nj, nt, c))\n    return color[MOUSE_START, CAT_START, MOUSE] == MOUSE",
            "def canMouseWin(self, grid, catJump, mouseJump):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :type grid: List[str]\\n        :type catJump: int\\n        :type mouseJump: int\\n        :rtype: bool\\n        '\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    (DRAW, MOUSE, CAT) = range(3)\n\n    def parents(m, c, t):\n        if t == CAT:\n            for nm in graph[m, MOUSE ^ CAT ^ t]:\n                yield (nm, c, MOUSE ^ CAT ^ t)\n        else:\n            for nc in graph[c, MOUSE ^ CAT ^ t]:\n                yield (m, nc, MOUSE ^ CAT ^ t)\n    (R, C) = (len(grid), len(grid[0]))\n    N = R * C\n    WALLS = set()\n    (FOOD, MOUSE_START, CAT_START) = [-1] * 3\n    for r in xrange(R):\n        for c in xrange(C):\n            if grid[r][c] == 'M':\n                MOUSE_START = r * C + c\n            elif grid[r][c] == 'C':\n                CAT_START = r * C + c\n            elif grid[r][c] == 'F':\n                FOOD = r * C + c\n            elif grid[r][c] == '#':\n                WALLS.add(r * C + c)\n    graph = collections.defaultdict(set)\n    jump = {MOUSE: mouseJump, CAT: catJump}\n    for r in xrange(R):\n        for c in xrange(C):\n            if grid[r][c] == '#':\n                continue\n            pos = r * C + c\n            for t in [MOUSE, CAT]:\n                for (dr, dc) in directions:\n                    for d in xrange(jump[t] + 1):\n                        (nr, nc) = (r + dr * d, c + dc * d)\n                        if not (0 <= nr < R and 0 <= nc < C and (grid[nr][nc] != '#')):\n                            break\n                        graph[pos, t].add(nr * C + nc)\n    degree = {}\n    for m in xrange(N):\n        for c in xrange(N):\n            degree[m, c, MOUSE] = len(graph[m, MOUSE])\n            degree[m, c, CAT] = len(graph[c, CAT])\n    color = collections.defaultdict(int)\n    q = collections.deque()\n    for i in xrange(N):\n        if i in WALLS or i == FOOD:\n            continue\n        color[FOOD, i, CAT] = MOUSE\n        q.append((FOOD, i, CAT, MOUSE))\n        color[i, FOOD, MOUSE] = CAT\n        q.append((i, FOOD, MOUSE, CAT))\n        for t in [MOUSE, CAT]:\n            color[i, i, t] = CAT\n            q.append((i, i, t, CAT))\n    while q:\n        (i, j, t, c) = q.popleft()\n        for (ni, nj, nt) in parents(i, j, t):\n            if color[ni, nj, nt] != DRAW:\n                continue\n            if nt == c:\n                color[ni, nj, nt] = c\n                q.append((ni, nj, nt, c))\n                continue\n            degree[ni, nj, nt] -= 1\n            if not degree[ni, nj, nt]:\n                color[ni, nj, nt] = c\n                q.append((ni, nj, nt, c))\n    return color[MOUSE_START, CAT_START, MOUSE] == MOUSE",
            "def canMouseWin(self, grid, catJump, mouseJump):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :type grid: List[str]\\n        :type catJump: int\\n        :type mouseJump: int\\n        :rtype: bool\\n        '\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    (DRAW, MOUSE, CAT) = range(3)\n\n    def parents(m, c, t):\n        if t == CAT:\n            for nm in graph[m, MOUSE ^ CAT ^ t]:\n                yield (nm, c, MOUSE ^ CAT ^ t)\n        else:\n            for nc in graph[c, MOUSE ^ CAT ^ t]:\n                yield (m, nc, MOUSE ^ CAT ^ t)\n    (R, C) = (len(grid), len(grid[0]))\n    N = R * C\n    WALLS = set()\n    (FOOD, MOUSE_START, CAT_START) = [-1] * 3\n    for r in xrange(R):\n        for c in xrange(C):\n            if grid[r][c] == 'M':\n                MOUSE_START = r * C + c\n            elif grid[r][c] == 'C':\n                CAT_START = r * C + c\n            elif grid[r][c] == 'F':\n                FOOD = r * C + c\n            elif grid[r][c] == '#':\n                WALLS.add(r * C + c)\n    graph = collections.defaultdict(set)\n    jump = {MOUSE: mouseJump, CAT: catJump}\n    for r in xrange(R):\n        for c in xrange(C):\n            if grid[r][c] == '#':\n                continue\n            pos = r * C + c\n            for t in [MOUSE, CAT]:\n                for (dr, dc) in directions:\n                    for d in xrange(jump[t] + 1):\n                        (nr, nc) = (r + dr * d, c + dc * d)\n                        if not (0 <= nr < R and 0 <= nc < C and (grid[nr][nc] != '#')):\n                            break\n                        graph[pos, t].add(nr * C + nc)\n    degree = {}\n    for m in xrange(N):\n        for c in xrange(N):\n            degree[m, c, MOUSE] = len(graph[m, MOUSE])\n            degree[m, c, CAT] = len(graph[c, CAT])\n    color = collections.defaultdict(int)\n    q = collections.deque()\n    for i in xrange(N):\n        if i in WALLS or i == FOOD:\n            continue\n        color[FOOD, i, CAT] = MOUSE\n        q.append((FOOD, i, CAT, MOUSE))\n        color[i, FOOD, MOUSE] = CAT\n        q.append((i, FOOD, MOUSE, CAT))\n        for t in [MOUSE, CAT]:\n            color[i, i, t] = CAT\n            q.append((i, i, t, CAT))\n    while q:\n        (i, j, t, c) = q.popleft()\n        for (ni, nj, nt) in parents(i, j, t):\n            if color[ni, nj, nt] != DRAW:\n                continue\n            if nt == c:\n                color[ni, nj, nt] = c\n                q.append((ni, nj, nt, c))\n                continue\n            degree[ni, nj, nt] -= 1\n            if not degree[ni, nj, nt]:\n                color[ni, nj, nt] = c\n                q.append((ni, nj, nt, c))\n    return color[MOUSE_START, CAT_START, MOUSE] == MOUSE",
            "def canMouseWin(self, grid, catJump, mouseJump):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :type grid: List[str]\\n        :type catJump: int\\n        :type mouseJump: int\\n        :rtype: bool\\n        '\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    (DRAW, MOUSE, CAT) = range(3)\n\n    def parents(m, c, t):\n        if t == CAT:\n            for nm in graph[m, MOUSE ^ CAT ^ t]:\n                yield (nm, c, MOUSE ^ CAT ^ t)\n        else:\n            for nc in graph[c, MOUSE ^ CAT ^ t]:\n                yield (m, nc, MOUSE ^ CAT ^ t)\n    (R, C) = (len(grid), len(grid[0]))\n    N = R * C\n    WALLS = set()\n    (FOOD, MOUSE_START, CAT_START) = [-1] * 3\n    for r in xrange(R):\n        for c in xrange(C):\n            if grid[r][c] == 'M':\n                MOUSE_START = r * C + c\n            elif grid[r][c] == 'C':\n                CAT_START = r * C + c\n            elif grid[r][c] == 'F':\n                FOOD = r * C + c\n            elif grid[r][c] == '#':\n                WALLS.add(r * C + c)\n    graph = collections.defaultdict(set)\n    jump = {MOUSE: mouseJump, CAT: catJump}\n    for r in xrange(R):\n        for c in xrange(C):\n            if grid[r][c] == '#':\n                continue\n            pos = r * C + c\n            for t in [MOUSE, CAT]:\n                for (dr, dc) in directions:\n                    for d in xrange(jump[t] + 1):\n                        (nr, nc) = (r + dr * d, c + dc * d)\n                        if not (0 <= nr < R and 0 <= nc < C and (grid[nr][nc] != '#')):\n                            break\n                        graph[pos, t].add(nr * C + nc)\n    degree = {}\n    for m in xrange(N):\n        for c in xrange(N):\n            degree[m, c, MOUSE] = len(graph[m, MOUSE])\n            degree[m, c, CAT] = len(graph[c, CAT])\n    color = collections.defaultdict(int)\n    q = collections.deque()\n    for i in xrange(N):\n        if i in WALLS or i == FOOD:\n            continue\n        color[FOOD, i, CAT] = MOUSE\n        q.append((FOOD, i, CAT, MOUSE))\n        color[i, FOOD, MOUSE] = CAT\n        q.append((i, FOOD, MOUSE, CAT))\n        for t in [MOUSE, CAT]:\n            color[i, i, t] = CAT\n            q.append((i, i, t, CAT))\n    while q:\n        (i, j, t, c) = q.popleft()\n        for (ni, nj, nt) in parents(i, j, t):\n            if color[ni, nj, nt] != DRAW:\n                continue\n            if nt == c:\n                color[ni, nj, nt] = c\n                q.append((ni, nj, nt, c))\n                continue\n            degree[ni, nj, nt] -= 1\n            if not degree[ni, nj, nt]:\n                color[ni, nj, nt] = c\n                q.append((ni, nj, nt, c))\n    return color[MOUSE_START, CAT_START, MOUSE] == MOUSE"
        ]
    },
    {
        "func_name": "parents",
        "original": "def parents(m, c, t):\n    if t == CAT:\n        for nm in graph[m, MOUSE ^ CAT ^ t]:\n            yield (nm, c, MOUSE ^ CAT ^ t)\n    else:\n        for nc in graph[c, MOUSE ^ CAT ^ t]:\n            yield (m, nc, MOUSE ^ CAT ^ t)",
        "mutated": [
            "def parents(m, c, t):\n    if False:\n        i = 10\n    if t == CAT:\n        for nm in graph[m, MOUSE ^ CAT ^ t]:\n            yield (nm, c, MOUSE ^ CAT ^ t)\n    else:\n        for nc in graph[c, MOUSE ^ CAT ^ t]:\n            yield (m, nc, MOUSE ^ CAT ^ t)",
            "def parents(m, c, t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if t == CAT:\n        for nm in graph[m, MOUSE ^ CAT ^ t]:\n            yield (nm, c, MOUSE ^ CAT ^ t)\n    else:\n        for nc in graph[c, MOUSE ^ CAT ^ t]:\n            yield (m, nc, MOUSE ^ CAT ^ t)",
            "def parents(m, c, t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if t == CAT:\n        for nm in graph[m, MOUSE ^ CAT ^ t]:\n            yield (nm, c, MOUSE ^ CAT ^ t)\n    else:\n        for nc in graph[c, MOUSE ^ CAT ^ t]:\n            yield (m, nc, MOUSE ^ CAT ^ t)",
            "def parents(m, c, t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if t == CAT:\n        for nm in graph[m, MOUSE ^ CAT ^ t]:\n            yield (nm, c, MOUSE ^ CAT ^ t)\n    else:\n        for nc in graph[c, MOUSE ^ CAT ^ t]:\n            yield (m, nc, MOUSE ^ CAT ^ t)",
            "def parents(m, c, t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if t == CAT:\n        for nm in graph[m, MOUSE ^ CAT ^ t]:\n            yield (nm, c, MOUSE ^ CAT ^ t)\n    else:\n        for nc in graph[c, MOUSE ^ CAT ^ t]:\n            yield (m, nc, MOUSE ^ CAT ^ t)"
        ]
    },
    {
        "func_name": "canMouseWin",
        "original": "def canMouseWin(self, grid, catJump, mouseJump):\n    \"\"\"\n        :type grid: List[str]\n        :type catJump: int\n        :type mouseJump: int\n        :rtype: bool\n        \"\"\"\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    (DRAW, MOUSE, CAT) = range(3)\n\n    def parents(m, c, t):\n        if t == CAT:\n            for nm in graph[m, MOUSE ^ CAT ^ t]:\n                yield (nm, c, MOUSE ^ CAT ^ t)\n        else:\n            for nc in graph[c, MOUSE ^ CAT ^ t]:\n                yield (m, nc, MOUSE ^ CAT ^ t)\n    (R, C) = (len(grid), len(grid[0]))\n    N = R * C\n    WALLS = set()\n    (FOOD, MOUSE_START, CAT_START) = [-1] * 3\n    for r in xrange(R):\n        for c in xrange(C):\n            if grid[r][c] == 'M':\n                MOUSE_START = r * C + c\n            elif grid[r][c] == 'C':\n                CAT_START = r * C + c\n            elif grid[r][c] == 'F':\n                FOOD = r * C + c\n            elif grid[r][c] == '#':\n                WALLS.add(r * C + c)\n    graph = collections.defaultdict(set)\n    jump = {MOUSE: mouseJump, CAT: catJump}\n    for r in xrange(R):\n        for c in xrange(C):\n            if grid[r][c] == '#':\n                continue\n            pos = r * C + c\n            for t in [MOUSE, CAT]:\n                for (dr, dc) in directions:\n                    for d in xrange(jump[t] + 1):\n                        (nr, nc) = (r + dr * d, c + dc * d)\n                        if not (0 <= nr < R and 0 <= nc < C and (grid[nr][nc] != '#')):\n                            break\n                        graph[pos, t].add(nr * C + nc)\n    degree = {}\n    for m in xrange(N):\n        for c in xrange(N):\n            degree[m, c, CAT] = len(graph[c, CAT])\n    color = collections.defaultdict(int)\n    q1 = collections.deque()\n    for i in xrange(N):\n        if i in WALLS or i == FOOD:\n            continue\n        color[FOOD, i, CAT] = MOUSE\n        q1.append((FOOD, i, CAT))\n        color[i, FOOD, MOUSE] = CAT\n        for t in [MOUSE, CAT]:\n            color[i, i, t] = CAT\n    while q1:\n        (i, j, t) = q1.popleft()\n        for (ni, nj, nt) in parents(i, j, t):\n            if color[ni, nj, nt] != DRAW:\n                continue\n            if t == CAT:\n                color[ni, nj, nt] = MOUSE\n                q1.append((ni, nj, nt))\n                continue\n            degree[ni, nj, nt] -= 1\n            if not degree[ni, nj, nt]:\n                color[ni, nj, nt] = MOUSE\n                q1.append((ni, nj, nt))\n    return color[MOUSE_START, CAT_START, MOUSE] == MOUSE",
        "mutated": [
            "def canMouseWin(self, grid, catJump, mouseJump):\n    if False:\n        i = 10\n    '\\n        :type grid: List[str]\\n        :type catJump: int\\n        :type mouseJump: int\\n        :rtype: bool\\n        '\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    (DRAW, MOUSE, CAT) = range(3)\n\n    def parents(m, c, t):\n        if t == CAT:\n            for nm in graph[m, MOUSE ^ CAT ^ t]:\n                yield (nm, c, MOUSE ^ CAT ^ t)\n        else:\n            for nc in graph[c, MOUSE ^ CAT ^ t]:\n                yield (m, nc, MOUSE ^ CAT ^ t)\n    (R, C) = (len(grid), len(grid[0]))\n    N = R * C\n    WALLS = set()\n    (FOOD, MOUSE_START, CAT_START) = [-1] * 3\n    for r in xrange(R):\n        for c in xrange(C):\n            if grid[r][c] == 'M':\n                MOUSE_START = r * C + c\n            elif grid[r][c] == 'C':\n                CAT_START = r * C + c\n            elif grid[r][c] == 'F':\n                FOOD = r * C + c\n            elif grid[r][c] == '#':\n                WALLS.add(r * C + c)\n    graph = collections.defaultdict(set)\n    jump = {MOUSE: mouseJump, CAT: catJump}\n    for r in xrange(R):\n        for c in xrange(C):\n            if grid[r][c] == '#':\n                continue\n            pos = r * C + c\n            for t in [MOUSE, CAT]:\n                for (dr, dc) in directions:\n                    for d in xrange(jump[t] + 1):\n                        (nr, nc) = (r + dr * d, c + dc * d)\n                        if not (0 <= nr < R and 0 <= nc < C and (grid[nr][nc] != '#')):\n                            break\n                        graph[pos, t].add(nr * C + nc)\n    degree = {}\n    for m in xrange(N):\n        for c in xrange(N):\n            degree[m, c, CAT] = len(graph[c, CAT])\n    color = collections.defaultdict(int)\n    q1 = collections.deque()\n    for i in xrange(N):\n        if i in WALLS or i == FOOD:\n            continue\n        color[FOOD, i, CAT] = MOUSE\n        q1.append((FOOD, i, CAT))\n        color[i, FOOD, MOUSE] = CAT\n        for t in [MOUSE, CAT]:\n            color[i, i, t] = CAT\n    while q1:\n        (i, j, t) = q1.popleft()\n        for (ni, nj, nt) in parents(i, j, t):\n            if color[ni, nj, nt] != DRAW:\n                continue\n            if t == CAT:\n                color[ni, nj, nt] = MOUSE\n                q1.append((ni, nj, nt))\n                continue\n            degree[ni, nj, nt] -= 1\n            if not degree[ni, nj, nt]:\n                color[ni, nj, nt] = MOUSE\n                q1.append((ni, nj, nt))\n    return color[MOUSE_START, CAT_START, MOUSE] == MOUSE",
            "def canMouseWin(self, grid, catJump, mouseJump):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :type grid: List[str]\\n        :type catJump: int\\n        :type mouseJump: int\\n        :rtype: bool\\n        '\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    (DRAW, MOUSE, CAT) = range(3)\n\n    def parents(m, c, t):\n        if t == CAT:\n            for nm in graph[m, MOUSE ^ CAT ^ t]:\n                yield (nm, c, MOUSE ^ CAT ^ t)\n        else:\n            for nc in graph[c, MOUSE ^ CAT ^ t]:\n                yield (m, nc, MOUSE ^ CAT ^ t)\n    (R, C) = (len(grid), len(grid[0]))\n    N = R * C\n    WALLS = set()\n    (FOOD, MOUSE_START, CAT_START) = [-1] * 3\n    for r in xrange(R):\n        for c in xrange(C):\n            if grid[r][c] == 'M':\n                MOUSE_START = r * C + c\n            elif grid[r][c] == 'C':\n                CAT_START = r * C + c\n            elif grid[r][c] == 'F':\n                FOOD = r * C + c\n            elif grid[r][c] == '#':\n                WALLS.add(r * C + c)\n    graph = collections.defaultdict(set)\n    jump = {MOUSE: mouseJump, CAT: catJump}\n    for r in xrange(R):\n        for c in xrange(C):\n            if grid[r][c] == '#':\n                continue\n            pos = r * C + c\n            for t in [MOUSE, CAT]:\n                for (dr, dc) in directions:\n                    for d in xrange(jump[t] + 1):\n                        (nr, nc) = (r + dr * d, c + dc * d)\n                        if not (0 <= nr < R and 0 <= nc < C and (grid[nr][nc] != '#')):\n                            break\n                        graph[pos, t].add(nr * C + nc)\n    degree = {}\n    for m in xrange(N):\n        for c in xrange(N):\n            degree[m, c, CAT] = len(graph[c, CAT])\n    color = collections.defaultdict(int)\n    q1 = collections.deque()\n    for i in xrange(N):\n        if i in WALLS or i == FOOD:\n            continue\n        color[FOOD, i, CAT] = MOUSE\n        q1.append((FOOD, i, CAT))\n        color[i, FOOD, MOUSE] = CAT\n        for t in [MOUSE, CAT]:\n            color[i, i, t] = CAT\n    while q1:\n        (i, j, t) = q1.popleft()\n        for (ni, nj, nt) in parents(i, j, t):\n            if color[ni, nj, nt] != DRAW:\n                continue\n            if t == CAT:\n                color[ni, nj, nt] = MOUSE\n                q1.append((ni, nj, nt))\n                continue\n            degree[ni, nj, nt] -= 1\n            if not degree[ni, nj, nt]:\n                color[ni, nj, nt] = MOUSE\n                q1.append((ni, nj, nt))\n    return color[MOUSE_START, CAT_START, MOUSE] == MOUSE",
            "def canMouseWin(self, grid, catJump, mouseJump):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :type grid: List[str]\\n        :type catJump: int\\n        :type mouseJump: int\\n        :rtype: bool\\n        '\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    (DRAW, MOUSE, CAT) = range(3)\n\n    def parents(m, c, t):\n        if t == CAT:\n            for nm in graph[m, MOUSE ^ CAT ^ t]:\n                yield (nm, c, MOUSE ^ CAT ^ t)\n        else:\n            for nc in graph[c, MOUSE ^ CAT ^ t]:\n                yield (m, nc, MOUSE ^ CAT ^ t)\n    (R, C) = (len(grid), len(grid[0]))\n    N = R * C\n    WALLS = set()\n    (FOOD, MOUSE_START, CAT_START) = [-1] * 3\n    for r in xrange(R):\n        for c in xrange(C):\n            if grid[r][c] == 'M':\n                MOUSE_START = r * C + c\n            elif grid[r][c] == 'C':\n                CAT_START = r * C + c\n            elif grid[r][c] == 'F':\n                FOOD = r * C + c\n            elif grid[r][c] == '#':\n                WALLS.add(r * C + c)\n    graph = collections.defaultdict(set)\n    jump = {MOUSE: mouseJump, CAT: catJump}\n    for r in xrange(R):\n        for c in xrange(C):\n            if grid[r][c] == '#':\n                continue\n            pos = r * C + c\n            for t in [MOUSE, CAT]:\n                for (dr, dc) in directions:\n                    for d in xrange(jump[t] + 1):\n                        (nr, nc) = (r + dr * d, c + dc * d)\n                        if not (0 <= nr < R and 0 <= nc < C and (grid[nr][nc] != '#')):\n                            break\n                        graph[pos, t].add(nr * C + nc)\n    degree = {}\n    for m in xrange(N):\n        for c in xrange(N):\n            degree[m, c, CAT] = len(graph[c, CAT])\n    color = collections.defaultdict(int)\n    q1 = collections.deque()\n    for i in xrange(N):\n        if i in WALLS or i == FOOD:\n            continue\n        color[FOOD, i, CAT] = MOUSE\n        q1.append((FOOD, i, CAT))\n        color[i, FOOD, MOUSE] = CAT\n        for t in [MOUSE, CAT]:\n            color[i, i, t] = CAT\n    while q1:\n        (i, j, t) = q1.popleft()\n        for (ni, nj, nt) in parents(i, j, t):\n            if color[ni, nj, nt] != DRAW:\n                continue\n            if t == CAT:\n                color[ni, nj, nt] = MOUSE\n                q1.append((ni, nj, nt))\n                continue\n            degree[ni, nj, nt] -= 1\n            if not degree[ni, nj, nt]:\n                color[ni, nj, nt] = MOUSE\n                q1.append((ni, nj, nt))\n    return color[MOUSE_START, CAT_START, MOUSE] == MOUSE",
            "def canMouseWin(self, grid, catJump, mouseJump):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :type grid: List[str]\\n        :type catJump: int\\n        :type mouseJump: int\\n        :rtype: bool\\n        '\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    (DRAW, MOUSE, CAT) = range(3)\n\n    def parents(m, c, t):\n        if t == CAT:\n            for nm in graph[m, MOUSE ^ CAT ^ t]:\n                yield (nm, c, MOUSE ^ CAT ^ t)\n        else:\n            for nc in graph[c, MOUSE ^ CAT ^ t]:\n                yield (m, nc, MOUSE ^ CAT ^ t)\n    (R, C) = (len(grid), len(grid[0]))\n    N = R * C\n    WALLS = set()\n    (FOOD, MOUSE_START, CAT_START) = [-1] * 3\n    for r in xrange(R):\n        for c in xrange(C):\n            if grid[r][c] == 'M':\n                MOUSE_START = r * C + c\n            elif grid[r][c] == 'C':\n                CAT_START = r * C + c\n            elif grid[r][c] == 'F':\n                FOOD = r * C + c\n            elif grid[r][c] == '#':\n                WALLS.add(r * C + c)\n    graph = collections.defaultdict(set)\n    jump = {MOUSE: mouseJump, CAT: catJump}\n    for r in xrange(R):\n        for c in xrange(C):\n            if grid[r][c] == '#':\n                continue\n            pos = r * C + c\n            for t in [MOUSE, CAT]:\n                for (dr, dc) in directions:\n                    for d in xrange(jump[t] + 1):\n                        (nr, nc) = (r + dr * d, c + dc * d)\n                        if not (0 <= nr < R and 0 <= nc < C and (grid[nr][nc] != '#')):\n                            break\n                        graph[pos, t].add(nr * C + nc)\n    degree = {}\n    for m in xrange(N):\n        for c in xrange(N):\n            degree[m, c, CAT] = len(graph[c, CAT])\n    color = collections.defaultdict(int)\n    q1 = collections.deque()\n    for i in xrange(N):\n        if i in WALLS or i == FOOD:\n            continue\n        color[FOOD, i, CAT] = MOUSE\n        q1.append((FOOD, i, CAT))\n        color[i, FOOD, MOUSE] = CAT\n        for t in [MOUSE, CAT]:\n            color[i, i, t] = CAT\n    while q1:\n        (i, j, t) = q1.popleft()\n        for (ni, nj, nt) in parents(i, j, t):\n            if color[ni, nj, nt] != DRAW:\n                continue\n            if t == CAT:\n                color[ni, nj, nt] = MOUSE\n                q1.append((ni, nj, nt))\n                continue\n            degree[ni, nj, nt] -= 1\n            if not degree[ni, nj, nt]:\n                color[ni, nj, nt] = MOUSE\n                q1.append((ni, nj, nt))\n    return color[MOUSE_START, CAT_START, MOUSE] == MOUSE",
            "def canMouseWin(self, grid, catJump, mouseJump):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :type grid: List[str]\\n        :type catJump: int\\n        :type mouseJump: int\\n        :rtype: bool\\n        '\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    (DRAW, MOUSE, CAT) = range(3)\n\n    def parents(m, c, t):\n        if t == CAT:\n            for nm in graph[m, MOUSE ^ CAT ^ t]:\n                yield (nm, c, MOUSE ^ CAT ^ t)\n        else:\n            for nc in graph[c, MOUSE ^ CAT ^ t]:\n                yield (m, nc, MOUSE ^ CAT ^ t)\n    (R, C) = (len(grid), len(grid[0]))\n    N = R * C\n    WALLS = set()\n    (FOOD, MOUSE_START, CAT_START) = [-1] * 3\n    for r in xrange(R):\n        for c in xrange(C):\n            if grid[r][c] == 'M':\n                MOUSE_START = r * C + c\n            elif grid[r][c] == 'C':\n                CAT_START = r * C + c\n            elif grid[r][c] == 'F':\n                FOOD = r * C + c\n            elif grid[r][c] == '#':\n                WALLS.add(r * C + c)\n    graph = collections.defaultdict(set)\n    jump = {MOUSE: mouseJump, CAT: catJump}\n    for r in xrange(R):\n        for c in xrange(C):\n            if grid[r][c] == '#':\n                continue\n            pos = r * C + c\n            for t in [MOUSE, CAT]:\n                for (dr, dc) in directions:\n                    for d in xrange(jump[t] + 1):\n                        (nr, nc) = (r + dr * d, c + dc * d)\n                        if not (0 <= nr < R and 0 <= nc < C and (grid[nr][nc] != '#')):\n                            break\n                        graph[pos, t].add(nr * C + nc)\n    degree = {}\n    for m in xrange(N):\n        for c in xrange(N):\n            degree[m, c, CAT] = len(graph[c, CAT])\n    color = collections.defaultdict(int)\n    q1 = collections.deque()\n    for i in xrange(N):\n        if i in WALLS or i == FOOD:\n            continue\n        color[FOOD, i, CAT] = MOUSE\n        q1.append((FOOD, i, CAT))\n        color[i, FOOD, MOUSE] = CAT\n        for t in [MOUSE, CAT]:\n            color[i, i, t] = CAT\n    while q1:\n        (i, j, t) = q1.popleft()\n        for (ni, nj, nt) in parents(i, j, t):\n            if color[ni, nj, nt] != DRAW:\n                continue\n            if t == CAT:\n                color[ni, nj, nt] = MOUSE\n                q1.append((ni, nj, nt))\n                continue\n            degree[ni, nj, nt] -= 1\n            if not degree[ni, nj, nt]:\n                color[ni, nj, nt] = MOUSE\n                q1.append((ni, nj, nt))\n    return color[MOUSE_START, CAT_START, MOUSE] == MOUSE"
        ]
    }
]