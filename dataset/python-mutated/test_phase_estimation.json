[
    {
        "func_name": "assertPhaseEstimationIsCorrect",
        "original": "def assertPhaseEstimationIsCorrect(self, pec: QuantumCircuit, eigenstate: QuantumCircuit, phase_as_binary: str):\n    \"\"\"Assert that the phase estimation circuit implements the correct transformation.\n\n        Applying the phase estimation circuit on a target register which holds the eigenstate\n        :math:`|u\\\\rangle` (say the last register), the final state should be\n\n        .. math::\n\n            |\\\\phi_1\\\\rangle \\\\cdots |\\\\phi_t\\\\rangle |u\\\\rangle\n\n        where the eigenvalue is written as :math:`e^{2\\\\pi i \\\\phi}` and the angle is represented\n        in binary fraction, i.e. :math:`\\\\phi = 0.\\\\phi_1 \\\\ldots \\\\phi_t`.\n\n        Args:\n            pec: The circuit implementing the phase estimation circuit.\n            eigenstate: The eigenstate as circuit.\n            phase_as_binary: The phase of the eigenvalue in a binary fraction. E.g. if the\n                phase is 0.25, the binary fraction is '01' as 0.01 = 0 * 0.5 + 1 * 0.25 = 0.25.\n        \"\"\"\n    eigenstate_as_vector = Statevector.from_instruction(eigenstate).data\n    reference = eigenstate_as_vector\n    (zero, one) = ([1, 0], [0, 1])\n    for qubit in phase_as_binary[::-1]:\n        reference = np.kron(reference, zero if qubit == '0' else one)\n    circuit = QuantumCircuit(pec.num_qubits)\n    circuit.compose(eigenstate, list(range(pec.num_qubits - eigenstate.num_qubits, pec.num_qubits)), inplace=True)\n    circuit.compose(pec, inplace=True)\n    backend = BasicAer.get_backend('statevector_simulator')\n    actual = execute(circuit, backend).result().get_statevector()\n    np.testing.assert_almost_equal(reference, actual)",
        "mutated": [
            "def assertPhaseEstimationIsCorrect(self, pec: QuantumCircuit, eigenstate: QuantumCircuit, phase_as_binary: str):\n    if False:\n        i = 10\n    \"Assert that the phase estimation circuit implements the correct transformation.\\n\\n        Applying the phase estimation circuit on a target register which holds the eigenstate\\n        :math:`|u\\\\rangle` (say the last register), the final state should be\\n\\n        .. math::\\n\\n            |\\\\phi_1\\\\rangle \\\\cdots |\\\\phi_t\\\\rangle |u\\\\rangle\\n\\n        where the eigenvalue is written as :math:`e^{2\\\\pi i \\\\phi}` and the angle is represented\\n        in binary fraction, i.e. :math:`\\\\phi = 0.\\\\phi_1 \\\\ldots \\\\phi_t`.\\n\\n        Args:\\n            pec: The circuit implementing the phase estimation circuit.\\n            eigenstate: The eigenstate as circuit.\\n            phase_as_binary: The phase of the eigenvalue in a binary fraction. E.g. if the\\n                phase is 0.25, the binary fraction is '01' as 0.01 = 0 * 0.5 + 1 * 0.25 = 0.25.\\n        \"\n    eigenstate_as_vector = Statevector.from_instruction(eigenstate).data\n    reference = eigenstate_as_vector\n    (zero, one) = ([1, 0], [0, 1])\n    for qubit in phase_as_binary[::-1]:\n        reference = np.kron(reference, zero if qubit == '0' else one)\n    circuit = QuantumCircuit(pec.num_qubits)\n    circuit.compose(eigenstate, list(range(pec.num_qubits - eigenstate.num_qubits, pec.num_qubits)), inplace=True)\n    circuit.compose(pec, inplace=True)\n    backend = BasicAer.get_backend('statevector_simulator')\n    actual = execute(circuit, backend).result().get_statevector()\n    np.testing.assert_almost_equal(reference, actual)",
            "def assertPhaseEstimationIsCorrect(self, pec: QuantumCircuit, eigenstate: QuantumCircuit, phase_as_binary: str):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Assert that the phase estimation circuit implements the correct transformation.\\n\\n        Applying the phase estimation circuit on a target register which holds the eigenstate\\n        :math:`|u\\\\rangle` (say the last register), the final state should be\\n\\n        .. math::\\n\\n            |\\\\phi_1\\\\rangle \\\\cdots |\\\\phi_t\\\\rangle |u\\\\rangle\\n\\n        where the eigenvalue is written as :math:`e^{2\\\\pi i \\\\phi}` and the angle is represented\\n        in binary fraction, i.e. :math:`\\\\phi = 0.\\\\phi_1 \\\\ldots \\\\phi_t`.\\n\\n        Args:\\n            pec: The circuit implementing the phase estimation circuit.\\n            eigenstate: The eigenstate as circuit.\\n            phase_as_binary: The phase of the eigenvalue in a binary fraction. E.g. if the\\n                phase is 0.25, the binary fraction is '01' as 0.01 = 0 * 0.5 + 1 * 0.25 = 0.25.\\n        \"\n    eigenstate_as_vector = Statevector.from_instruction(eigenstate).data\n    reference = eigenstate_as_vector\n    (zero, one) = ([1, 0], [0, 1])\n    for qubit in phase_as_binary[::-1]:\n        reference = np.kron(reference, zero if qubit == '0' else one)\n    circuit = QuantumCircuit(pec.num_qubits)\n    circuit.compose(eigenstate, list(range(pec.num_qubits - eigenstate.num_qubits, pec.num_qubits)), inplace=True)\n    circuit.compose(pec, inplace=True)\n    backend = BasicAer.get_backend('statevector_simulator')\n    actual = execute(circuit, backend).result().get_statevector()\n    np.testing.assert_almost_equal(reference, actual)",
            "def assertPhaseEstimationIsCorrect(self, pec: QuantumCircuit, eigenstate: QuantumCircuit, phase_as_binary: str):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Assert that the phase estimation circuit implements the correct transformation.\\n\\n        Applying the phase estimation circuit on a target register which holds the eigenstate\\n        :math:`|u\\\\rangle` (say the last register), the final state should be\\n\\n        .. math::\\n\\n            |\\\\phi_1\\\\rangle \\\\cdots |\\\\phi_t\\\\rangle |u\\\\rangle\\n\\n        where the eigenvalue is written as :math:`e^{2\\\\pi i \\\\phi}` and the angle is represented\\n        in binary fraction, i.e. :math:`\\\\phi = 0.\\\\phi_1 \\\\ldots \\\\phi_t`.\\n\\n        Args:\\n            pec: The circuit implementing the phase estimation circuit.\\n            eigenstate: The eigenstate as circuit.\\n            phase_as_binary: The phase of the eigenvalue in a binary fraction. E.g. if the\\n                phase is 0.25, the binary fraction is '01' as 0.01 = 0 * 0.5 + 1 * 0.25 = 0.25.\\n        \"\n    eigenstate_as_vector = Statevector.from_instruction(eigenstate).data\n    reference = eigenstate_as_vector\n    (zero, one) = ([1, 0], [0, 1])\n    for qubit in phase_as_binary[::-1]:\n        reference = np.kron(reference, zero if qubit == '0' else one)\n    circuit = QuantumCircuit(pec.num_qubits)\n    circuit.compose(eigenstate, list(range(pec.num_qubits - eigenstate.num_qubits, pec.num_qubits)), inplace=True)\n    circuit.compose(pec, inplace=True)\n    backend = BasicAer.get_backend('statevector_simulator')\n    actual = execute(circuit, backend).result().get_statevector()\n    np.testing.assert_almost_equal(reference, actual)",
            "def assertPhaseEstimationIsCorrect(self, pec: QuantumCircuit, eigenstate: QuantumCircuit, phase_as_binary: str):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Assert that the phase estimation circuit implements the correct transformation.\\n\\n        Applying the phase estimation circuit on a target register which holds the eigenstate\\n        :math:`|u\\\\rangle` (say the last register), the final state should be\\n\\n        .. math::\\n\\n            |\\\\phi_1\\\\rangle \\\\cdots |\\\\phi_t\\\\rangle |u\\\\rangle\\n\\n        where the eigenvalue is written as :math:`e^{2\\\\pi i \\\\phi}` and the angle is represented\\n        in binary fraction, i.e. :math:`\\\\phi = 0.\\\\phi_1 \\\\ldots \\\\phi_t`.\\n\\n        Args:\\n            pec: The circuit implementing the phase estimation circuit.\\n            eigenstate: The eigenstate as circuit.\\n            phase_as_binary: The phase of the eigenvalue in a binary fraction. E.g. if the\\n                phase is 0.25, the binary fraction is '01' as 0.01 = 0 * 0.5 + 1 * 0.25 = 0.25.\\n        \"\n    eigenstate_as_vector = Statevector.from_instruction(eigenstate).data\n    reference = eigenstate_as_vector\n    (zero, one) = ([1, 0], [0, 1])\n    for qubit in phase_as_binary[::-1]:\n        reference = np.kron(reference, zero if qubit == '0' else one)\n    circuit = QuantumCircuit(pec.num_qubits)\n    circuit.compose(eigenstate, list(range(pec.num_qubits - eigenstate.num_qubits, pec.num_qubits)), inplace=True)\n    circuit.compose(pec, inplace=True)\n    backend = BasicAer.get_backend('statevector_simulator')\n    actual = execute(circuit, backend).result().get_statevector()\n    np.testing.assert_almost_equal(reference, actual)",
            "def assertPhaseEstimationIsCorrect(self, pec: QuantumCircuit, eigenstate: QuantumCircuit, phase_as_binary: str):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Assert that the phase estimation circuit implements the correct transformation.\\n\\n        Applying the phase estimation circuit on a target register which holds the eigenstate\\n        :math:`|u\\\\rangle` (say the last register), the final state should be\\n\\n        .. math::\\n\\n            |\\\\phi_1\\\\rangle \\\\cdots |\\\\phi_t\\\\rangle |u\\\\rangle\\n\\n        where the eigenvalue is written as :math:`e^{2\\\\pi i \\\\phi}` and the angle is represented\\n        in binary fraction, i.e. :math:`\\\\phi = 0.\\\\phi_1 \\\\ldots \\\\phi_t`.\\n\\n        Args:\\n            pec: The circuit implementing the phase estimation circuit.\\n            eigenstate: The eigenstate as circuit.\\n            phase_as_binary: The phase of the eigenvalue in a binary fraction. E.g. if the\\n                phase is 0.25, the binary fraction is '01' as 0.01 = 0 * 0.5 + 1 * 0.25 = 0.25.\\n        \"\n    eigenstate_as_vector = Statevector.from_instruction(eigenstate).data\n    reference = eigenstate_as_vector\n    (zero, one) = ([1, 0], [0, 1])\n    for qubit in phase_as_binary[::-1]:\n        reference = np.kron(reference, zero if qubit == '0' else one)\n    circuit = QuantumCircuit(pec.num_qubits)\n    circuit.compose(eigenstate, list(range(pec.num_qubits - eigenstate.num_qubits, pec.num_qubits)), inplace=True)\n    circuit.compose(pec, inplace=True)\n    backend = BasicAer.get_backend('statevector_simulator')\n    actual = execute(circuit, backend).result().get_statevector()\n    np.testing.assert_almost_equal(reference, actual)"
        ]
    },
    {
        "func_name": "test_phase_estimation",
        "original": "def test_phase_estimation(self):\n    \"\"\"Test the standard phase estimation circuit.\"\"\"\n    with self.subTest('U=S, psi=|1>'):\n        unitary = QuantumCircuit(1)\n        unitary.s(0)\n        eigenstate = QuantumCircuit(1)\n        eigenstate.x(0)\n        phase_as_binary = '0100'\n        pec = PhaseEstimation(4, unitary)\n        self.assertPhaseEstimationIsCorrect(pec, eigenstate, phase_as_binary)\n    with self.subTest('U=SZ, psi=|11>'):\n        unitary = QuantumCircuit(2)\n        unitary.z(0)\n        unitary.s(1)\n        eigenstate = QuantumCircuit(2)\n        eigenstate.x([0, 1])\n        phase_as_binary = '110'\n        pec = PhaseEstimation(3, unitary)\n        self.assertPhaseEstimationIsCorrect(pec, eigenstate, phase_as_binary)\n    with self.subTest('a 3-q unitary'):\n        unitary = QuantumCircuit(3)\n        unitary.x([0, 1, 2])\n        unitary.cz(0, 1)\n        unitary.h(2)\n        unitary.ccx(0, 1, 2)\n        unitary.h(2)\n        eigenstate = QuantumCircuit(3)\n        eigenstate.h(0)\n        eigenstate.cx(0, 1)\n        eigenstate.cx(0, 2)\n        phase_as_binary = '00'\n        pec = PhaseEstimation(2, unitary)\n        self.assertPhaseEstimationIsCorrect(pec, eigenstate, phase_as_binary)",
        "mutated": [
            "def test_phase_estimation(self):\n    if False:\n        i = 10\n    'Test the standard phase estimation circuit.'\n    with self.subTest('U=S, psi=|1>'):\n        unitary = QuantumCircuit(1)\n        unitary.s(0)\n        eigenstate = QuantumCircuit(1)\n        eigenstate.x(0)\n        phase_as_binary = '0100'\n        pec = PhaseEstimation(4, unitary)\n        self.assertPhaseEstimationIsCorrect(pec, eigenstate, phase_as_binary)\n    with self.subTest('U=SZ, psi=|11>'):\n        unitary = QuantumCircuit(2)\n        unitary.z(0)\n        unitary.s(1)\n        eigenstate = QuantumCircuit(2)\n        eigenstate.x([0, 1])\n        phase_as_binary = '110'\n        pec = PhaseEstimation(3, unitary)\n        self.assertPhaseEstimationIsCorrect(pec, eigenstate, phase_as_binary)\n    with self.subTest('a 3-q unitary'):\n        unitary = QuantumCircuit(3)\n        unitary.x([0, 1, 2])\n        unitary.cz(0, 1)\n        unitary.h(2)\n        unitary.ccx(0, 1, 2)\n        unitary.h(2)\n        eigenstate = QuantumCircuit(3)\n        eigenstate.h(0)\n        eigenstate.cx(0, 1)\n        eigenstate.cx(0, 2)\n        phase_as_binary = '00'\n        pec = PhaseEstimation(2, unitary)\n        self.assertPhaseEstimationIsCorrect(pec, eigenstate, phase_as_binary)",
            "def test_phase_estimation(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test the standard phase estimation circuit.'\n    with self.subTest('U=S, psi=|1>'):\n        unitary = QuantumCircuit(1)\n        unitary.s(0)\n        eigenstate = QuantumCircuit(1)\n        eigenstate.x(0)\n        phase_as_binary = '0100'\n        pec = PhaseEstimation(4, unitary)\n        self.assertPhaseEstimationIsCorrect(pec, eigenstate, phase_as_binary)\n    with self.subTest('U=SZ, psi=|11>'):\n        unitary = QuantumCircuit(2)\n        unitary.z(0)\n        unitary.s(1)\n        eigenstate = QuantumCircuit(2)\n        eigenstate.x([0, 1])\n        phase_as_binary = '110'\n        pec = PhaseEstimation(3, unitary)\n        self.assertPhaseEstimationIsCorrect(pec, eigenstate, phase_as_binary)\n    with self.subTest('a 3-q unitary'):\n        unitary = QuantumCircuit(3)\n        unitary.x([0, 1, 2])\n        unitary.cz(0, 1)\n        unitary.h(2)\n        unitary.ccx(0, 1, 2)\n        unitary.h(2)\n        eigenstate = QuantumCircuit(3)\n        eigenstate.h(0)\n        eigenstate.cx(0, 1)\n        eigenstate.cx(0, 2)\n        phase_as_binary = '00'\n        pec = PhaseEstimation(2, unitary)\n        self.assertPhaseEstimationIsCorrect(pec, eigenstate, phase_as_binary)",
            "def test_phase_estimation(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test the standard phase estimation circuit.'\n    with self.subTest('U=S, psi=|1>'):\n        unitary = QuantumCircuit(1)\n        unitary.s(0)\n        eigenstate = QuantumCircuit(1)\n        eigenstate.x(0)\n        phase_as_binary = '0100'\n        pec = PhaseEstimation(4, unitary)\n        self.assertPhaseEstimationIsCorrect(pec, eigenstate, phase_as_binary)\n    with self.subTest('U=SZ, psi=|11>'):\n        unitary = QuantumCircuit(2)\n        unitary.z(0)\n        unitary.s(1)\n        eigenstate = QuantumCircuit(2)\n        eigenstate.x([0, 1])\n        phase_as_binary = '110'\n        pec = PhaseEstimation(3, unitary)\n        self.assertPhaseEstimationIsCorrect(pec, eigenstate, phase_as_binary)\n    with self.subTest('a 3-q unitary'):\n        unitary = QuantumCircuit(3)\n        unitary.x([0, 1, 2])\n        unitary.cz(0, 1)\n        unitary.h(2)\n        unitary.ccx(0, 1, 2)\n        unitary.h(2)\n        eigenstate = QuantumCircuit(3)\n        eigenstate.h(0)\n        eigenstate.cx(0, 1)\n        eigenstate.cx(0, 2)\n        phase_as_binary = '00'\n        pec = PhaseEstimation(2, unitary)\n        self.assertPhaseEstimationIsCorrect(pec, eigenstate, phase_as_binary)",
            "def test_phase_estimation(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test the standard phase estimation circuit.'\n    with self.subTest('U=S, psi=|1>'):\n        unitary = QuantumCircuit(1)\n        unitary.s(0)\n        eigenstate = QuantumCircuit(1)\n        eigenstate.x(0)\n        phase_as_binary = '0100'\n        pec = PhaseEstimation(4, unitary)\n        self.assertPhaseEstimationIsCorrect(pec, eigenstate, phase_as_binary)\n    with self.subTest('U=SZ, psi=|11>'):\n        unitary = QuantumCircuit(2)\n        unitary.z(0)\n        unitary.s(1)\n        eigenstate = QuantumCircuit(2)\n        eigenstate.x([0, 1])\n        phase_as_binary = '110'\n        pec = PhaseEstimation(3, unitary)\n        self.assertPhaseEstimationIsCorrect(pec, eigenstate, phase_as_binary)\n    with self.subTest('a 3-q unitary'):\n        unitary = QuantumCircuit(3)\n        unitary.x([0, 1, 2])\n        unitary.cz(0, 1)\n        unitary.h(2)\n        unitary.ccx(0, 1, 2)\n        unitary.h(2)\n        eigenstate = QuantumCircuit(3)\n        eigenstate.h(0)\n        eigenstate.cx(0, 1)\n        eigenstate.cx(0, 2)\n        phase_as_binary = '00'\n        pec = PhaseEstimation(2, unitary)\n        self.assertPhaseEstimationIsCorrect(pec, eigenstate, phase_as_binary)",
            "def test_phase_estimation(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test the standard phase estimation circuit.'\n    with self.subTest('U=S, psi=|1>'):\n        unitary = QuantumCircuit(1)\n        unitary.s(0)\n        eigenstate = QuantumCircuit(1)\n        eigenstate.x(0)\n        phase_as_binary = '0100'\n        pec = PhaseEstimation(4, unitary)\n        self.assertPhaseEstimationIsCorrect(pec, eigenstate, phase_as_binary)\n    with self.subTest('U=SZ, psi=|11>'):\n        unitary = QuantumCircuit(2)\n        unitary.z(0)\n        unitary.s(1)\n        eigenstate = QuantumCircuit(2)\n        eigenstate.x([0, 1])\n        phase_as_binary = '110'\n        pec = PhaseEstimation(3, unitary)\n        self.assertPhaseEstimationIsCorrect(pec, eigenstate, phase_as_binary)\n    with self.subTest('a 3-q unitary'):\n        unitary = QuantumCircuit(3)\n        unitary.x([0, 1, 2])\n        unitary.cz(0, 1)\n        unitary.h(2)\n        unitary.ccx(0, 1, 2)\n        unitary.h(2)\n        eigenstate = QuantumCircuit(3)\n        eigenstate.h(0)\n        eigenstate.cx(0, 1)\n        eigenstate.cx(0, 2)\n        phase_as_binary = '00'\n        pec = PhaseEstimation(2, unitary)\n        self.assertPhaseEstimationIsCorrect(pec, eigenstate, phase_as_binary)"
        ]
    },
    {
        "func_name": "test_phase_estimation_iqft_setting",
        "original": "def test_phase_estimation_iqft_setting(self):\n    \"\"\"Test default and custom setting of the QFT circuit.\"\"\"\n    unitary = QuantumCircuit(1)\n    unitary.s(0)\n    with self.subTest('default QFT'):\n        pec = PhaseEstimation(3, unitary)\n        expected_qft = QFT(3, inverse=True, do_swaps=False)\n        self.assertEqual(pec.decompose().data[-1].operation.definition, expected_qft.decompose())\n    with self.subTest('custom QFT'):\n        iqft = QFT(3, approximation_degree=2).inverse()\n        pec = PhaseEstimation(3, unitary, iqft=iqft)\n        self.assertEqual(pec.decompose().data[-1].operation.definition, iqft.decompose())",
        "mutated": [
            "def test_phase_estimation_iqft_setting(self):\n    if False:\n        i = 10\n    'Test default and custom setting of the QFT circuit.'\n    unitary = QuantumCircuit(1)\n    unitary.s(0)\n    with self.subTest('default QFT'):\n        pec = PhaseEstimation(3, unitary)\n        expected_qft = QFT(3, inverse=True, do_swaps=False)\n        self.assertEqual(pec.decompose().data[-1].operation.definition, expected_qft.decompose())\n    with self.subTest('custom QFT'):\n        iqft = QFT(3, approximation_degree=2).inverse()\n        pec = PhaseEstimation(3, unitary, iqft=iqft)\n        self.assertEqual(pec.decompose().data[-1].operation.definition, iqft.decompose())",
            "def test_phase_estimation_iqft_setting(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test default and custom setting of the QFT circuit.'\n    unitary = QuantumCircuit(1)\n    unitary.s(0)\n    with self.subTest('default QFT'):\n        pec = PhaseEstimation(3, unitary)\n        expected_qft = QFT(3, inverse=True, do_swaps=False)\n        self.assertEqual(pec.decompose().data[-1].operation.definition, expected_qft.decompose())\n    with self.subTest('custom QFT'):\n        iqft = QFT(3, approximation_degree=2).inverse()\n        pec = PhaseEstimation(3, unitary, iqft=iqft)\n        self.assertEqual(pec.decompose().data[-1].operation.definition, iqft.decompose())",
            "def test_phase_estimation_iqft_setting(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test default and custom setting of the QFT circuit.'\n    unitary = QuantumCircuit(1)\n    unitary.s(0)\n    with self.subTest('default QFT'):\n        pec = PhaseEstimation(3, unitary)\n        expected_qft = QFT(3, inverse=True, do_swaps=False)\n        self.assertEqual(pec.decompose().data[-1].operation.definition, expected_qft.decompose())\n    with self.subTest('custom QFT'):\n        iqft = QFT(3, approximation_degree=2).inverse()\n        pec = PhaseEstimation(3, unitary, iqft=iqft)\n        self.assertEqual(pec.decompose().data[-1].operation.definition, iqft.decompose())",
            "def test_phase_estimation_iqft_setting(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test default and custom setting of the QFT circuit.'\n    unitary = QuantumCircuit(1)\n    unitary.s(0)\n    with self.subTest('default QFT'):\n        pec = PhaseEstimation(3, unitary)\n        expected_qft = QFT(3, inverse=True, do_swaps=False)\n        self.assertEqual(pec.decompose().data[-1].operation.definition, expected_qft.decompose())\n    with self.subTest('custom QFT'):\n        iqft = QFT(3, approximation_degree=2).inverse()\n        pec = PhaseEstimation(3, unitary, iqft=iqft)\n        self.assertEqual(pec.decompose().data[-1].operation.definition, iqft.decompose())",
            "def test_phase_estimation_iqft_setting(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test default and custom setting of the QFT circuit.'\n    unitary = QuantumCircuit(1)\n    unitary.s(0)\n    with self.subTest('default QFT'):\n        pec = PhaseEstimation(3, unitary)\n        expected_qft = QFT(3, inverse=True, do_swaps=False)\n        self.assertEqual(pec.decompose().data[-1].operation.definition, expected_qft.decompose())\n    with self.subTest('custom QFT'):\n        iqft = QFT(3, approximation_degree=2).inverse()\n        pec = PhaseEstimation(3, unitary, iqft=iqft)\n        self.assertEqual(pec.decompose().data[-1].operation.definition, iqft.decompose())"
        ]
    }
]