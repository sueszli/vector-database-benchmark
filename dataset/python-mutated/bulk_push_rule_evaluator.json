[
    {
        "func_name": "_should_count_as_unread",
        "original": "def _should_count_as_unread(event: EventBase, context: EventContext) -> bool:\n    if context.rejected or event.internal_metadata.is_soft_failed():\n        return False\n    if not event.is_state() and event.type == EventTypes.Message and (event.content.get('msgtype') == 'm.notice'):\n        return False\n    relates_to = relation_from_event(event)\n    if relates_to and relates_to.rel_type == RelationTypes.REPLACE:\n        return False\n    body = event.content.get('body')\n    if isinstance(body, str) and body:\n        return True\n    if event.is_state() and event.type in STATE_EVENT_TYPES_TO_MARK_UNREAD:\n        return True\n    if not event.is_state() and event.type == EventTypes.Encrypted:\n        return True\n    return False",
        "mutated": [
            "def _should_count_as_unread(event: EventBase, context: EventContext) -> bool:\n    if False:\n        i = 10\n    if context.rejected or event.internal_metadata.is_soft_failed():\n        return False\n    if not event.is_state() and event.type == EventTypes.Message and (event.content.get('msgtype') == 'm.notice'):\n        return False\n    relates_to = relation_from_event(event)\n    if relates_to and relates_to.rel_type == RelationTypes.REPLACE:\n        return False\n    body = event.content.get('body')\n    if isinstance(body, str) and body:\n        return True\n    if event.is_state() and event.type in STATE_EVENT_TYPES_TO_MARK_UNREAD:\n        return True\n    if not event.is_state() and event.type == EventTypes.Encrypted:\n        return True\n    return False",
            "def _should_count_as_unread(event: EventBase, context: EventContext) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if context.rejected or event.internal_metadata.is_soft_failed():\n        return False\n    if not event.is_state() and event.type == EventTypes.Message and (event.content.get('msgtype') == 'm.notice'):\n        return False\n    relates_to = relation_from_event(event)\n    if relates_to and relates_to.rel_type == RelationTypes.REPLACE:\n        return False\n    body = event.content.get('body')\n    if isinstance(body, str) and body:\n        return True\n    if event.is_state() and event.type in STATE_EVENT_TYPES_TO_MARK_UNREAD:\n        return True\n    if not event.is_state() and event.type == EventTypes.Encrypted:\n        return True\n    return False",
            "def _should_count_as_unread(event: EventBase, context: EventContext) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if context.rejected or event.internal_metadata.is_soft_failed():\n        return False\n    if not event.is_state() and event.type == EventTypes.Message and (event.content.get('msgtype') == 'm.notice'):\n        return False\n    relates_to = relation_from_event(event)\n    if relates_to and relates_to.rel_type == RelationTypes.REPLACE:\n        return False\n    body = event.content.get('body')\n    if isinstance(body, str) and body:\n        return True\n    if event.is_state() and event.type in STATE_EVENT_TYPES_TO_MARK_UNREAD:\n        return True\n    if not event.is_state() and event.type == EventTypes.Encrypted:\n        return True\n    return False",
            "def _should_count_as_unread(event: EventBase, context: EventContext) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if context.rejected or event.internal_metadata.is_soft_failed():\n        return False\n    if not event.is_state() and event.type == EventTypes.Message and (event.content.get('msgtype') == 'm.notice'):\n        return False\n    relates_to = relation_from_event(event)\n    if relates_to and relates_to.rel_type == RelationTypes.REPLACE:\n        return False\n    body = event.content.get('body')\n    if isinstance(body, str) and body:\n        return True\n    if event.is_state() and event.type in STATE_EVENT_TYPES_TO_MARK_UNREAD:\n        return True\n    if not event.is_state() and event.type == EventTypes.Encrypted:\n        return True\n    return False",
            "def _should_count_as_unread(event: EventBase, context: EventContext) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if context.rejected or event.internal_metadata.is_soft_failed():\n        return False\n    if not event.is_state() and event.type == EventTypes.Message and (event.content.get('msgtype') == 'm.notice'):\n        return False\n    relates_to = relation_from_event(event)\n    if relates_to and relates_to.rel_type == RelationTypes.REPLACE:\n        return False\n    body = event.content.get('body')\n    if isinstance(body, str) and body:\n        return True\n    if event.is_state() and event.type in STATE_EVENT_TYPES_TO_MARK_UNREAD:\n        return True\n    if not event.is_state() and event.type == EventTypes.Encrypted:\n        return True\n    return False"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, hs: 'HomeServer'):\n    self.hs = hs\n    self.store = hs.get_datastores().main\n    self.clock = hs.get_clock()\n    self._event_auth_handler = hs.get_event_auth_handler()\n    self.should_calculate_push_rules = self.hs.config.push.enable_push\n    self._related_event_match_enabled = self.hs.config.experimental.msc3664_enabled\n    self.room_push_rule_cache_metrics = register_cache('cache', 'room_push_rule_cache', cache=[], resizable=False)",
        "mutated": [
            "def __init__(self, hs: 'HomeServer'):\n    if False:\n        i = 10\n    self.hs = hs\n    self.store = hs.get_datastores().main\n    self.clock = hs.get_clock()\n    self._event_auth_handler = hs.get_event_auth_handler()\n    self.should_calculate_push_rules = self.hs.config.push.enable_push\n    self._related_event_match_enabled = self.hs.config.experimental.msc3664_enabled\n    self.room_push_rule_cache_metrics = register_cache('cache', 'room_push_rule_cache', cache=[], resizable=False)",
            "def __init__(self, hs: 'HomeServer'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.hs = hs\n    self.store = hs.get_datastores().main\n    self.clock = hs.get_clock()\n    self._event_auth_handler = hs.get_event_auth_handler()\n    self.should_calculate_push_rules = self.hs.config.push.enable_push\n    self._related_event_match_enabled = self.hs.config.experimental.msc3664_enabled\n    self.room_push_rule_cache_metrics = register_cache('cache', 'room_push_rule_cache', cache=[], resizable=False)",
            "def __init__(self, hs: 'HomeServer'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.hs = hs\n    self.store = hs.get_datastores().main\n    self.clock = hs.get_clock()\n    self._event_auth_handler = hs.get_event_auth_handler()\n    self.should_calculate_push_rules = self.hs.config.push.enable_push\n    self._related_event_match_enabled = self.hs.config.experimental.msc3664_enabled\n    self.room_push_rule_cache_metrics = register_cache('cache', 'room_push_rule_cache', cache=[], resizable=False)",
            "def __init__(self, hs: 'HomeServer'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.hs = hs\n    self.store = hs.get_datastores().main\n    self.clock = hs.get_clock()\n    self._event_auth_handler = hs.get_event_auth_handler()\n    self.should_calculate_push_rules = self.hs.config.push.enable_push\n    self._related_event_match_enabled = self.hs.config.experimental.msc3664_enabled\n    self.room_push_rule_cache_metrics = register_cache('cache', 'room_push_rule_cache', cache=[], resizable=False)",
            "def __init__(self, hs: 'HomeServer'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.hs = hs\n    self.store = hs.get_datastores().main\n    self.clock = hs.get_clock()\n    self._event_auth_handler = hs.get_event_auth_handler()\n    self.should_calculate_push_rules = self.hs.config.push.enable_push\n    self._related_event_match_enabled = self.hs.config.experimental.msc3664_enabled\n    self.room_push_rule_cache_metrics = register_cache('cache', 'room_push_rule_cache', cache=[], resizable=False)"
        ]
    },
    {
        "func_name": "_is_simple_value",
        "original": "def _is_simple_value(value: Any) -> bool:\n    return isinstance(value, (bool, str)) or type(value) is int or value is None",
        "mutated": [
            "def _is_simple_value(value: Any) -> bool:\n    if False:\n        i = 10\n    return isinstance(value, (bool, str)) or type(value) is int or value is None",
            "def _is_simple_value(value: Any) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return isinstance(value, (bool, str)) or type(value) is int or value is None",
            "def _is_simple_value(value: Any) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return isinstance(value, (bool, str)) or type(value) is int or value is None",
            "def _is_simple_value(value: Any) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return isinstance(value, (bool, str)) or type(value) is int or value is None",
            "def _is_simple_value(value: Any) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return isinstance(value, (bool, str)) or type(value) is int or value is None"
        ]
    },
    {
        "func_name": "_flatten_dict",
        "original": "def _flatten_dict(d: Union[EventBase, Mapping[str, Any]], prefix: Optional[List[str]]=None, result: Optional[Dict[str, JsonValue]]=None) -> Dict[str, JsonValue]:\n    \"\"\"\n    Given a JSON dictionary (or event) which might contain sub dictionaries,\n    flatten it into a single layer dictionary by combining the keys & sub-keys.\n\n    String, integer, boolean, null or lists of those values are kept. All others are dropped.\n\n    Transforms:\n\n        {\"foo\": {\"bar\": \"test\"}}\n\n    To:\n\n        {\"foo.bar\": \"test\"}\n\n    Args:\n        d: The event or content to continue flattening.\n        prefix: The key prefix (from outer dictionaries).\n        result: The result to mutate.\n\n    Returns:\n        The resulting dictionary.\n    \"\"\"\n    if prefix is None:\n        prefix = []\n    if result is None:\n        result = {}\n    for (key, value) in d.items():\n        key = key.replace('\\\\', '\\\\\\\\').replace('.', '\\\\.')\n        if _is_simple_value(value):\n            result['.'.join(prefix + [key])] = value\n        elif isinstance(value, (list, tuple)):\n            result['.'.join(prefix + [key])] = [v for v in value if _is_simple_value(v)]\n        elif isinstance(value, Mapping):\n            _flatten_dict(value, prefix=prefix + [key], result=result)\n    if isinstance(d, EventBase) and PushRuleRoomFlag.EXTENSIBLE_EVENTS in d.room_version.msc3931_push_features:\n        markup = d.get('content').get('m.markup')\n        if d.room_version.identifier.startswith('org.matrix.msc1767.'):\n            markup = d.get('content').get('org.matrix.msc1767.markup')\n        if markup is not None and isinstance(markup, list):\n            text = ''\n            for rep in markup:\n                if not isinstance(rep, dict):\n                    break\n                if rep.get('mimetype', 'text/plain') == 'text/plain':\n                    rep_text = rep.get('body')\n                    if rep_text is not None and isinstance(rep_text, str):\n                        text = rep_text.lower()\n                        break\n            result['content.body'] = text\n    return result",
        "mutated": [
            "def _flatten_dict(d: Union[EventBase, Mapping[str, Any]], prefix: Optional[List[str]]=None, result: Optional[Dict[str, JsonValue]]=None) -> Dict[str, JsonValue]:\n    if False:\n        i = 10\n    '\\n    Given a JSON dictionary (or event) which might contain sub dictionaries,\\n    flatten it into a single layer dictionary by combining the keys & sub-keys.\\n\\n    String, integer, boolean, null or lists of those values are kept. All others are dropped.\\n\\n    Transforms:\\n\\n        {\"foo\": {\"bar\": \"test\"}}\\n\\n    To:\\n\\n        {\"foo.bar\": \"test\"}\\n\\n    Args:\\n        d: The event or content to continue flattening.\\n        prefix: The key prefix (from outer dictionaries).\\n        result: The result to mutate.\\n\\n    Returns:\\n        The resulting dictionary.\\n    '\n    if prefix is None:\n        prefix = []\n    if result is None:\n        result = {}\n    for (key, value) in d.items():\n        key = key.replace('\\\\', '\\\\\\\\').replace('.', '\\\\.')\n        if _is_simple_value(value):\n            result['.'.join(prefix + [key])] = value\n        elif isinstance(value, (list, tuple)):\n            result['.'.join(prefix + [key])] = [v for v in value if _is_simple_value(v)]\n        elif isinstance(value, Mapping):\n            _flatten_dict(value, prefix=prefix + [key], result=result)\n    if isinstance(d, EventBase) and PushRuleRoomFlag.EXTENSIBLE_EVENTS in d.room_version.msc3931_push_features:\n        markup = d.get('content').get('m.markup')\n        if d.room_version.identifier.startswith('org.matrix.msc1767.'):\n            markup = d.get('content').get('org.matrix.msc1767.markup')\n        if markup is not None and isinstance(markup, list):\n            text = ''\n            for rep in markup:\n                if not isinstance(rep, dict):\n                    break\n                if rep.get('mimetype', 'text/plain') == 'text/plain':\n                    rep_text = rep.get('body')\n                    if rep_text is not None and isinstance(rep_text, str):\n                        text = rep_text.lower()\n                        break\n            result['content.body'] = text\n    return result",
            "def _flatten_dict(d: Union[EventBase, Mapping[str, Any]], prefix: Optional[List[str]]=None, result: Optional[Dict[str, JsonValue]]=None) -> Dict[str, JsonValue]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Given a JSON dictionary (or event) which might contain sub dictionaries,\\n    flatten it into a single layer dictionary by combining the keys & sub-keys.\\n\\n    String, integer, boolean, null or lists of those values are kept. All others are dropped.\\n\\n    Transforms:\\n\\n        {\"foo\": {\"bar\": \"test\"}}\\n\\n    To:\\n\\n        {\"foo.bar\": \"test\"}\\n\\n    Args:\\n        d: The event or content to continue flattening.\\n        prefix: The key prefix (from outer dictionaries).\\n        result: The result to mutate.\\n\\n    Returns:\\n        The resulting dictionary.\\n    '\n    if prefix is None:\n        prefix = []\n    if result is None:\n        result = {}\n    for (key, value) in d.items():\n        key = key.replace('\\\\', '\\\\\\\\').replace('.', '\\\\.')\n        if _is_simple_value(value):\n            result['.'.join(prefix + [key])] = value\n        elif isinstance(value, (list, tuple)):\n            result['.'.join(prefix + [key])] = [v for v in value if _is_simple_value(v)]\n        elif isinstance(value, Mapping):\n            _flatten_dict(value, prefix=prefix + [key], result=result)\n    if isinstance(d, EventBase) and PushRuleRoomFlag.EXTENSIBLE_EVENTS in d.room_version.msc3931_push_features:\n        markup = d.get('content').get('m.markup')\n        if d.room_version.identifier.startswith('org.matrix.msc1767.'):\n            markup = d.get('content').get('org.matrix.msc1767.markup')\n        if markup is not None and isinstance(markup, list):\n            text = ''\n            for rep in markup:\n                if not isinstance(rep, dict):\n                    break\n                if rep.get('mimetype', 'text/plain') == 'text/plain':\n                    rep_text = rep.get('body')\n                    if rep_text is not None and isinstance(rep_text, str):\n                        text = rep_text.lower()\n                        break\n            result['content.body'] = text\n    return result",
            "def _flatten_dict(d: Union[EventBase, Mapping[str, Any]], prefix: Optional[List[str]]=None, result: Optional[Dict[str, JsonValue]]=None) -> Dict[str, JsonValue]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Given a JSON dictionary (or event) which might contain sub dictionaries,\\n    flatten it into a single layer dictionary by combining the keys & sub-keys.\\n\\n    String, integer, boolean, null or lists of those values are kept. All others are dropped.\\n\\n    Transforms:\\n\\n        {\"foo\": {\"bar\": \"test\"}}\\n\\n    To:\\n\\n        {\"foo.bar\": \"test\"}\\n\\n    Args:\\n        d: The event or content to continue flattening.\\n        prefix: The key prefix (from outer dictionaries).\\n        result: The result to mutate.\\n\\n    Returns:\\n        The resulting dictionary.\\n    '\n    if prefix is None:\n        prefix = []\n    if result is None:\n        result = {}\n    for (key, value) in d.items():\n        key = key.replace('\\\\', '\\\\\\\\').replace('.', '\\\\.')\n        if _is_simple_value(value):\n            result['.'.join(prefix + [key])] = value\n        elif isinstance(value, (list, tuple)):\n            result['.'.join(prefix + [key])] = [v for v in value if _is_simple_value(v)]\n        elif isinstance(value, Mapping):\n            _flatten_dict(value, prefix=prefix + [key], result=result)\n    if isinstance(d, EventBase) and PushRuleRoomFlag.EXTENSIBLE_EVENTS in d.room_version.msc3931_push_features:\n        markup = d.get('content').get('m.markup')\n        if d.room_version.identifier.startswith('org.matrix.msc1767.'):\n            markup = d.get('content').get('org.matrix.msc1767.markup')\n        if markup is not None and isinstance(markup, list):\n            text = ''\n            for rep in markup:\n                if not isinstance(rep, dict):\n                    break\n                if rep.get('mimetype', 'text/plain') == 'text/plain':\n                    rep_text = rep.get('body')\n                    if rep_text is not None and isinstance(rep_text, str):\n                        text = rep_text.lower()\n                        break\n            result['content.body'] = text\n    return result",
            "def _flatten_dict(d: Union[EventBase, Mapping[str, Any]], prefix: Optional[List[str]]=None, result: Optional[Dict[str, JsonValue]]=None) -> Dict[str, JsonValue]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Given a JSON dictionary (or event) which might contain sub dictionaries,\\n    flatten it into a single layer dictionary by combining the keys & sub-keys.\\n\\n    String, integer, boolean, null or lists of those values are kept. All others are dropped.\\n\\n    Transforms:\\n\\n        {\"foo\": {\"bar\": \"test\"}}\\n\\n    To:\\n\\n        {\"foo.bar\": \"test\"}\\n\\n    Args:\\n        d: The event or content to continue flattening.\\n        prefix: The key prefix (from outer dictionaries).\\n        result: The result to mutate.\\n\\n    Returns:\\n        The resulting dictionary.\\n    '\n    if prefix is None:\n        prefix = []\n    if result is None:\n        result = {}\n    for (key, value) in d.items():\n        key = key.replace('\\\\', '\\\\\\\\').replace('.', '\\\\.')\n        if _is_simple_value(value):\n            result['.'.join(prefix + [key])] = value\n        elif isinstance(value, (list, tuple)):\n            result['.'.join(prefix + [key])] = [v for v in value if _is_simple_value(v)]\n        elif isinstance(value, Mapping):\n            _flatten_dict(value, prefix=prefix + [key], result=result)\n    if isinstance(d, EventBase) and PushRuleRoomFlag.EXTENSIBLE_EVENTS in d.room_version.msc3931_push_features:\n        markup = d.get('content').get('m.markup')\n        if d.room_version.identifier.startswith('org.matrix.msc1767.'):\n            markup = d.get('content').get('org.matrix.msc1767.markup')\n        if markup is not None and isinstance(markup, list):\n            text = ''\n            for rep in markup:\n                if not isinstance(rep, dict):\n                    break\n                if rep.get('mimetype', 'text/plain') == 'text/plain':\n                    rep_text = rep.get('body')\n                    if rep_text is not None and isinstance(rep_text, str):\n                        text = rep_text.lower()\n                        break\n            result['content.body'] = text\n    return result",
            "def _flatten_dict(d: Union[EventBase, Mapping[str, Any]], prefix: Optional[List[str]]=None, result: Optional[Dict[str, JsonValue]]=None) -> Dict[str, JsonValue]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Given a JSON dictionary (or event) which might contain sub dictionaries,\\n    flatten it into a single layer dictionary by combining the keys & sub-keys.\\n\\n    String, integer, boolean, null or lists of those values are kept. All others are dropped.\\n\\n    Transforms:\\n\\n        {\"foo\": {\"bar\": \"test\"}}\\n\\n    To:\\n\\n        {\"foo.bar\": \"test\"}\\n\\n    Args:\\n        d: The event or content to continue flattening.\\n        prefix: The key prefix (from outer dictionaries).\\n        result: The result to mutate.\\n\\n    Returns:\\n        The resulting dictionary.\\n    '\n    if prefix is None:\n        prefix = []\n    if result is None:\n        result = {}\n    for (key, value) in d.items():\n        key = key.replace('\\\\', '\\\\\\\\').replace('.', '\\\\.')\n        if _is_simple_value(value):\n            result['.'.join(prefix + [key])] = value\n        elif isinstance(value, (list, tuple)):\n            result['.'.join(prefix + [key])] = [v for v in value if _is_simple_value(v)]\n        elif isinstance(value, Mapping):\n            _flatten_dict(value, prefix=prefix + [key], result=result)\n    if isinstance(d, EventBase) and PushRuleRoomFlag.EXTENSIBLE_EVENTS in d.room_version.msc3931_push_features:\n        markup = d.get('content').get('m.markup')\n        if d.room_version.identifier.startswith('org.matrix.msc1767.'):\n            markup = d.get('content').get('org.matrix.msc1767.markup')\n        if markup is not None and isinstance(markup, list):\n            text = ''\n            for rep in markup:\n                if not isinstance(rep, dict):\n                    break\n                if rep.get('mimetype', 'text/plain') == 'text/plain':\n                    rep_text = rep.get('body')\n                    if rep_text is not None and isinstance(rep_text, str):\n                        text = rep_text.lower()\n                        break\n            result['content.body'] = text\n    return result"
        ]
    }
]