[
    {
        "func_name": "get_idx_from_placements",
        "original": "def get_idx_from_placements(placements, current_rank) -> int:\n    \"\"\"\n    Return the position of the current rank in the given placements.\n\n    Args:\n        placements(List[Union[_remote_device, str]]):\n            Specifies the placement of each shard of the Tensor. The size of\n            the list represents the number of shards to be created. This could\n            be a list of\n            :class:`torch.distributed._remote_device`'s. This list\n            could also contain a string which represents remote\n            device as accepted by\n            :class:`torch.distributed._remote_device`\n        current_rank (int): number of current device.\n\n    Returns:\n        A int which contains the position of current device in the placement list.\n    \"\"\"\n    for (idx, placement) in enumerate(placements):\n        if current_rank == placement.rank():\n            return idx\n    raise RuntimeError('current_rank not in the placement.')",
        "mutated": [
            "def get_idx_from_placements(placements, current_rank) -> int:\n    if False:\n        i = 10\n    \"\\n    Return the position of the current rank in the given placements.\\n\\n    Args:\\n        placements(List[Union[_remote_device, str]]):\\n            Specifies the placement of each shard of the Tensor. The size of\\n            the list represents the number of shards to be created. This could\\n            be a list of\\n            :class:`torch.distributed._remote_device`'s. This list\\n            could also contain a string which represents remote\\n            device as accepted by\\n            :class:`torch.distributed._remote_device`\\n        current_rank (int): number of current device.\\n\\n    Returns:\\n        A int which contains the position of current device in the placement list.\\n    \"\n    for (idx, placement) in enumerate(placements):\n        if current_rank == placement.rank():\n            return idx\n    raise RuntimeError('current_rank not in the placement.')",
            "def get_idx_from_placements(placements, current_rank) -> int:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Return the position of the current rank in the given placements.\\n\\n    Args:\\n        placements(List[Union[_remote_device, str]]):\\n            Specifies the placement of each shard of the Tensor. The size of\\n            the list represents the number of shards to be created. This could\\n            be a list of\\n            :class:`torch.distributed._remote_device`'s. This list\\n            could also contain a string which represents remote\\n            device as accepted by\\n            :class:`torch.distributed._remote_device`\\n        current_rank (int): number of current device.\\n\\n    Returns:\\n        A int which contains the position of current device in the placement list.\\n    \"\n    for (idx, placement) in enumerate(placements):\n        if current_rank == placement.rank():\n            return idx\n    raise RuntimeError('current_rank not in the placement.')",
            "def get_idx_from_placements(placements, current_rank) -> int:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Return the position of the current rank in the given placements.\\n\\n    Args:\\n        placements(List[Union[_remote_device, str]]):\\n            Specifies the placement of each shard of the Tensor. The size of\\n            the list represents the number of shards to be created. This could\\n            be a list of\\n            :class:`torch.distributed._remote_device`'s. This list\\n            could also contain a string which represents remote\\n            device as accepted by\\n            :class:`torch.distributed._remote_device`\\n        current_rank (int): number of current device.\\n\\n    Returns:\\n        A int which contains the position of current device in the placement list.\\n    \"\n    for (idx, placement) in enumerate(placements):\n        if current_rank == placement.rank():\n            return idx\n    raise RuntimeError('current_rank not in the placement.')",
            "def get_idx_from_placements(placements, current_rank) -> int:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Return the position of the current rank in the given placements.\\n\\n    Args:\\n        placements(List[Union[_remote_device, str]]):\\n            Specifies the placement of each shard of the Tensor. The size of\\n            the list represents the number of shards to be created. This could\\n            be a list of\\n            :class:`torch.distributed._remote_device`'s. This list\\n            could also contain a string which represents remote\\n            device as accepted by\\n            :class:`torch.distributed._remote_device`\\n        current_rank (int): number of current device.\\n\\n    Returns:\\n        A int which contains the position of current device in the placement list.\\n    \"\n    for (idx, placement) in enumerate(placements):\n        if current_rank == placement.rank():\n            return idx\n    raise RuntimeError('current_rank not in the placement.')",
            "def get_idx_from_placements(placements, current_rank) -> int:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Return the position of the current rank in the given placements.\\n\\n    Args:\\n        placements(List[Union[_remote_device, str]]):\\n            Specifies the placement of each shard of the Tensor. The size of\\n            the list represents the number of shards to be created. This could\\n            be a list of\\n            :class:`torch.distributed._remote_device`'s. This list\\n            could also contain a string which represents remote\\n            device as accepted by\\n            :class:`torch.distributed._remote_device`\\n        current_rank (int): number of current device.\\n\\n    Returns:\\n        A int which contains the position of current device in the placement list.\\n    \"\n    for (idx, placement) in enumerate(placements):\n        if current_rank == placement.rank():\n            return idx\n    raise RuntimeError('current_rank not in the placement.')"
        ]
    },
    {
        "func_name": "build_reshard_metadata",
        "original": "def build_reshard_metadata(st_size: torch.Size, sharding_spec: shard_spec.ShardingSpec, world_size: int) -> Tuple[List[ShardMetadata], List[int]]:\n    \"\"\"\n    Based the given sharding spec, we calculate the offset and local shard size.\n    We then build a ShardMetadata on top of the calculation result.\n\n    Args:\n        st_size (torch.Size): The size of the sharded tensor.\n        sharding_spec (:class:`torch.distributed._shard.sharding_spec.ShardingSpec`): The\n            specification describing how the tensor is sharded.\n        world_size (int): number of ranks.\n\n    Returns:\n        A Tuple of the followings:\n            A List[`ShardMetadata`] which contains the metadata for the shard, including\n                offsets, lengths and device placement.\n            A List[int] which contains the ranks in the order of placement.\n    \"\"\"\n    shard_dim = int(sharding_spec.dim)\n    shards_metadata = [None] * world_size\n    ranks = []\n    offsets = [0] * len(st_size)\n    split_size = get_split_size(st_size[shard_dim], world_size)\n    for (idx, placement) in enumerate(sharding_spec.placements):\n        ranks.append(placement.rank())\n        sharded_dim_size = get_chunked_dim_size(st_size[shard_dim], split_size, idx)\n        local_tensor_size = list(st_size)\n        local_tensor_size[shard_dim] = sharded_dim_size\n        shards_metadata[placement.rank()] = ShardMetadata(shard_offsets=copy.deepcopy(offsets), shard_sizes=local_tensor_size, placement=placement)\n        offsets[shard_dim] += sharded_dim_size\n    return (shards_metadata, ranks)",
        "mutated": [
            "def build_reshard_metadata(st_size: torch.Size, sharding_spec: shard_spec.ShardingSpec, world_size: int) -> Tuple[List[ShardMetadata], List[int]]:\n    if False:\n        i = 10\n    '\\n    Based the given sharding spec, we calculate the offset and local shard size.\\n    We then build a ShardMetadata on top of the calculation result.\\n\\n    Args:\\n        st_size (torch.Size): The size of the sharded tensor.\\n        sharding_spec (:class:`torch.distributed._shard.sharding_spec.ShardingSpec`): The\\n            specification describing how the tensor is sharded.\\n        world_size (int): number of ranks.\\n\\n    Returns:\\n        A Tuple of the followings:\\n            A List[`ShardMetadata`] which contains the metadata for the shard, including\\n                offsets, lengths and device placement.\\n            A List[int] which contains the ranks in the order of placement.\\n    '\n    shard_dim = int(sharding_spec.dim)\n    shards_metadata = [None] * world_size\n    ranks = []\n    offsets = [0] * len(st_size)\n    split_size = get_split_size(st_size[shard_dim], world_size)\n    for (idx, placement) in enumerate(sharding_spec.placements):\n        ranks.append(placement.rank())\n        sharded_dim_size = get_chunked_dim_size(st_size[shard_dim], split_size, idx)\n        local_tensor_size = list(st_size)\n        local_tensor_size[shard_dim] = sharded_dim_size\n        shards_metadata[placement.rank()] = ShardMetadata(shard_offsets=copy.deepcopy(offsets), shard_sizes=local_tensor_size, placement=placement)\n        offsets[shard_dim] += sharded_dim_size\n    return (shards_metadata, ranks)",
            "def build_reshard_metadata(st_size: torch.Size, sharding_spec: shard_spec.ShardingSpec, world_size: int) -> Tuple[List[ShardMetadata], List[int]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Based the given sharding spec, we calculate the offset and local shard size.\\n    We then build a ShardMetadata on top of the calculation result.\\n\\n    Args:\\n        st_size (torch.Size): The size of the sharded tensor.\\n        sharding_spec (:class:`torch.distributed._shard.sharding_spec.ShardingSpec`): The\\n            specification describing how the tensor is sharded.\\n        world_size (int): number of ranks.\\n\\n    Returns:\\n        A Tuple of the followings:\\n            A List[`ShardMetadata`] which contains the metadata for the shard, including\\n                offsets, lengths and device placement.\\n            A List[int] which contains the ranks in the order of placement.\\n    '\n    shard_dim = int(sharding_spec.dim)\n    shards_metadata = [None] * world_size\n    ranks = []\n    offsets = [0] * len(st_size)\n    split_size = get_split_size(st_size[shard_dim], world_size)\n    for (idx, placement) in enumerate(sharding_spec.placements):\n        ranks.append(placement.rank())\n        sharded_dim_size = get_chunked_dim_size(st_size[shard_dim], split_size, idx)\n        local_tensor_size = list(st_size)\n        local_tensor_size[shard_dim] = sharded_dim_size\n        shards_metadata[placement.rank()] = ShardMetadata(shard_offsets=copy.deepcopy(offsets), shard_sizes=local_tensor_size, placement=placement)\n        offsets[shard_dim] += sharded_dim_size\n    return (shards_metadata, ranks)",
            "def build_reshard_metadata(st_size: torch.Size, sharding_spec: shard_spec.ShardingSpec, world_size: int) -> Tuple[List[ShardMetadata], List[int]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Based the given sharding spec, we calculate the offset and local shard size.\\n    We then build a ShardMetadata on top of the calculation result.\\n\\n    Args:\\n        st_size (torch.Size): The size of the sharded tensor.\\n        sharding_spec (:class:`torch.distributed._shard.sharding_spec.ShardingSpec`): The\\n            specification describing how the tensor is sharded.\\n        world_size (int): number of ranks.\\n\\n    Returns:\\n        A Tuple of the followings:\\n            A List[`ShardMetadata`] which contains the metadata for the shard, including\\n                offsets, lengths and device placement.\\n            A List[int] which contains the ranks in the order of placement.\\n    '\n    shard_dim = int(sharding_spec.dim)\n    shards_metadata = [None] * world_size\n    ranks = []\n    offsets = [0] * len(st_size)\n    split_size = get_split_size(st_size[shard_dim], world_size)\n    for (idx, placement) in enumerate(sharding_spec.placements):\n        ranks.append(placement.rank())\n        sharded_dim_size = get_chunked_dim_size(st_size[shard_dim], split_size, idx)\n        local_tensor_size = list(st_size)\n        local_tensor_size[shard_dim] = sharded_dim_size\n        shards_metadata[placement.rank()] = ShardMetadata(shard_offsets=copy.deepcopy(offsets), shard_sizes=local_tensor_size, placement=placement)\n        offsets[shard_dim] += sharded_dim_size\n    return (shards_metadata, ranks)",
            "def build_reshard_metadata(st_size: torch.Size, sharding_spec: shard_spec.ShardingSpec, world_size: int) -> Tuple[List[ShardMetadata], List[int]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Based the given sharding spec, we calculate the offset and local shard size.\\n    We then build a ShardMetadata on top of the calculation result.\\n\\n    Args:\\n        st_size (torch.Size): The size of the sharded tensor.\\n        sharding_spec (:class:`torch.distributed._shard.sharding_spec.ShardingSpec`): The\\n            specification describing how the tensor is sharded.\\n        world_size (int): number of ranks.\\n\\n    Returns:\\n        A Tuple of the followings:\\n            A List[`ShardMetadata`] which contains the metadata for the shard, including\\n                offsets, lengths and device placement.\\n            A List[int] which contains the ranks in the order of placement.\\n    '\n    shard_dim = int(sharding_spec.dim)\n    shards_metadata = [None] * world_size\n    ranks = []\n    offsets = [0] * len(st_size)\n    split_size = get_split_size(st_size[shard_dim], world_size)\n    for (idx, placement) in enumerate(sharding_spec.placements):\n        ranks.append(placement.rank())\n        sharded_dim_size = get_chunked_dim_size(st_size[shard_dim], split_size, idx)\n        local_tensor_size = list(st_size)\n        local_tensor_size[shard_dim] = sharded_dim_size\n        shards_metadata[placement.rank()] = ShardMetadata(shard_offsets=copy.deepcopy(offsets), shard_sizes=local_tensor_size, placement=placement)\n        offsets[shard_dim] += sharded_dim_size\n    return (shards_metadata, ranks)",
            "def build_reshard_metadata(st_size: torch.Size, sharding_spec: shard_spec.ShardingSpec, world_size: int) -> Tuple[List[ShardMetadata], List[int]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Based the given sharding spec, we calculate the offset and local shard size.\\n    We then build a ShardMetadata on top of the calculation result.\\n\\n    Args:\\n        st_size (torch.Size): The size of the sharded tensor.\\n        sharding_spec (:class:`torch.distributed._shard.sharding_spec.ShardingSpec`): The\\n            specification describing how the tensor is sharded.\\n        world_size (int): number of ranks.\\n\\n    Returns:\\n        A Tuple of the followings:\\n            A List[`ShardMetadata`] which contains the metadata for the shard, including\\n                offsets, lengths and device placement.\\n            A List[int] which contains the ranks in the order of placement.\\n    '\n    shard_dim = int(sharding_spec.dim)\n    shards_metadata = [None] * world_size\n    ranks = []\n    offsets = [0] * len(st_size)\n    split_size = get_split_size(st_size[shard_dim], world_size)\n    for (idx, placement) in enumerate(sharding_spec.placements):\n        ranks.append(placement.rank())\n        sharded_dim_size = get_chunked_dim_size(st_size[shard_dim], split_size, idx)\n        local_tensor_size = list(st_size)\n        local_tensor_size[shard_dim] = sharded_dim_size\n        shards_metadata[placement.rank()] = ShardMetadata(shard_offsets=copy.deepcopy(offsets), shard_sizes=local_tensor_size, placement=placement)\n        offsets[shard_dim] += sharded_dim_size\n    return (shards_metadata, ranks)"
        ]
    },
    {
        "func_name": "reshuffle_local_shard",
        "original": "def reshuffle_local_shard(local_shard: torch.Tensor, st_size: torch.Size, sharding_spec: shard_spec.ShardingSpec, resharding_spec: shard_spec.ShardingSpec, pg: ProcessGroup) -> Tuple[List[Shard], List[ShardMetadata]]:\n    \"\"\"\n    Reshuffle the local shard directly when the reshard dim is same as the original\n    sharding dim. Logically we do this in two step:\n    1. To collect all shards based on original sharding spec.\n    2. Reshard the tensor based on the given resharding spec.\n\n    In reality, we consolidate the two steps into one by sending the local tensor to\n    the new shard directly based on the resharding spec.\n\n    Args:\n        local_shard (Tensor): Local tensor stored in the current rank.\n        st_size (torch.Size): The size of the sharded tensor.\n        sharding_spec (:class:`torch.distributed._shard.sharding_spec.ShardingSpec`): The\n            specification describing how the tensor is sharded originally.\n        resharding_spec (:class:`torch.distributed._shard.sharding_spec.ShardingSpec`): The\n            specification describing how the tensor will be resharded.\n        pg (ProcessGroup): The process group to aggregate on.\n\n    Returns:\n        A Tuple of the followings:\n            A List[`Shard`] which contains the local tensor and its metadata.\n            A List[`ShardMetadata`] which contains the metadata for the shard, including\n                offsets, lengths and device placement.\n    \"\"\"\n    current_rank = dist.get_rank(pg)\n    world_size = dist.get_world_size(pg)\n    (shards_metadata, ranks) = build_reshard_metadata(st_size, resharding_spec, world_size)\n    reshard_dim = int(resharding_spec.dim)\n    split_size = get_split_size(st_size[reshard_dim], world_size)\n    input_split_sizes = [0] * world_size\n    idx = get_idx_from_placements(sharding_spec.placements, current_rank)\n    new_rank = resharding_spec.placements[idx].rank()\n    input_split_sizes[new_rank] = local_shard.size(reshard_dim)\n    output_split_sizes = [0] * world_size\n    new_idx = ranks.index(current_rank)\n    sharded_dim_size = get_chunked_dim_size(st_size[reshard_dim], split_size, new_idx)\n    output_split_sizes[new_rank] = sharded_dim_size\n    local_shard = local_shard.transpose(0, reshard_dim).contiguous()\n    gathered_input_size = list(local_shard.size())\n    gathered_input_size[0] = sharded_dim_size\n    gathered_input = torch.empty(gathered_input_size, device=local_shard.device, dtype=local_shard.dtype)\n    local_shard = all_to_all_single(gathered_input, local_shard, input_split_sizes=input_split_sizes, output_split_sizes=output_split_sizes, group=pg)\n    local_tensor = local_shard.transpose(0, reshard_dim).contiguous()\n    local_shards = [Shard(local_tensor, shards_metadata[current_rank])]\n    return (local_shards, shards_metadata)",
        "mutated": [
            "def reshuffle_local_shard(local_shard: torch.Tensor, st_size: torch.Size, sharding_spec: shard_spec.ShardingSpec, resharding_spec: shard_spec.ShardingSpec, pg: ProcessGroup) -> Tuple[List[Shard], List[ShardMetadata]]:\n    if False:\n        i = 10\n    '\\n    Reshuffle the local shard directly when the reshard dim is same as the original\\n    sharding dim. Logically we do this in two step:\\n    1. To collect all shards based on original sharding spec.\\n    2. Reshard the tensor based on the given resharding spec.\\n\\n    In reality, we consolidate the two steps into one by sending the local tensor to\\n    the new shard directly based on the resharding spec.\\n\\n    Args:\\n        local_shard (Tensor): Local tensor stored in the current rank.\\n        st_size (torch.Size): The size of the sharded tensor.\\n        sharding_spec (:class:`torch.distributed._shard.sharding_spec.ShardingSpec`): The\\n            specification describing how the tensor is sharded originally.\\n        resharding_spec (:class:`torch.distributed._shard.sharding_spec.ShardingSpec`): The\\n            specification describing how the tensor will be resharded.\\n        pg (ProcessGroup): The process group to aggregate on.\\n\\n    Returns:\\n        A Tuple of the followings:\\n            A List[`Shard`] which contains the local tensor and its metadata.\\n            A List[`ShardMetadata`] which contains the metadata for the shard, including\\n                offsets, lengths and device placement.\\n    '\n    current_rank = dist.get_rank(pg)\n    world_size = dist.get_world_size(pg)\n    (shards_metadata, ranks) = build_reshard_metadata(st_size, resharding_spec, world_size)\n    reshard_dim = int(resharding_spec.dim)\n    split_size = get_split_size(st_size[reshard_dim], world_size)\n    input_split_sizes = [0] * world_size\n    idx = get_idx_from_placements(sharding_spec.placements, current_rank)\n    new_rank = resharding_spec.placements[idx].rank()\n    input_split_sizes[new_rank] = local_shard.size(reshard_dim)\n    output_split_sizes = [0] * world_size\n    new_idx = ranks.index(current_rank)\n    sharded_dim_size = get_chunked_dim_size(st_size[reshard_dim], split_size, new_idx)\n    output_split_sizes[new_rank] = sharded_dim_size\n    local_shard = local_shard.transpose(0, reshard_dim).contiguous()\n    gathered_input_size = list(local_shard.size())\n    gathered_input_size[0] = sharded_dim_size\n    gathered_input = torch.empty(gathered_input_size, device=local_shard.device, dtype=local_shard.dtype)\n    local_shard = all_to_all_single(gathered_input, local_shard, input_split_sizes=input_split_sizes, output_split_sizes=output_split_sizes, group=pg)\n    local_tensor = local_shard.transpose(0, reshard_dim).contiguous()\n    local_shards = [Shard(local_tensor, shards_metadata[current_rank])]\n    return (local_shards, shards_metadata)",
            "def reshuffle_local_shard(local_shard: torch.Tensor, st_size: torch.Size, sharding_spec: shard_spec.ShardingSpec, resharding_spec: shard_spec.ShardingSpec, pg: ProcessGroup) -> Tuple[List[Shard], List[ShardMetadata]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Reshuffle the local shard directly when the reshard dim is same as the original\\n    sharding dim. Logically we do this in two step:\\n    1. To collect all shards based on original sharding spec.\\n    2. Reshard the tensor based on the given resharding spec.\\n\\n    In reality, we consolidate the two steps into one by sending the local tensor to\\n    the new shard directly based on the resharding spec.\\n\\n    Args:\\n        local_shard (Tensor): Local tensor stored in the current rank.\\n        st_size (torch.Size): The size of the sharded tensor.\\n        sharding_spec (:class:`torch.distributed._shard.sharding_spec.ShardingSpec`): The\\n            specification describing how the tensor is sharded originally.\\n        resharding_spec (:class:`torch.distributed._shard.sharding_spec.ShardingSpec`): The\\n            specification describing how the tensor will be resharded.\\n        pg (ProcessGroup): The process group to aggregate on.\\n\\n    Returns:\\n        A Tuple of the followings:\\n            A List[`Shard`] which contains the local tensor and its metadata.\\n            A List[`ShardMetadata`] which contains the metadata for the shard, including\\n                offsets, lengths and device placement.\\n    '\n    current_rank = dist.get_rank(pg)\n    world_size = dist.get_world_size(pg)\n    (shards_metadata, ranks) = build_reshard_metadata(st_size, resharding_spec, world_size)\n    reshard_dim = int(resharding_spec.dim)\n    split_size = get_split_size(st_size[reshard_dim], world_size)\n    input_split_sizes = [0] * world_size\n    idx = get_idx_from_placements(sharding_spec.placements, current_rank)\n    new_rank = resharding_spec.placements[idx].rank()\n    input_split_sizes[new_rank] = local_shard.size(reshard_dim)\n    output_split_sizes = [0] * world_size\n    new_idx = ranks.index(current_rank)\n    sharded_dim_size = get_chunked_dim_size(st_size[reshard_dim], split_size, new_idx)\n    output_split_sizes[new_rank] = sharded_dim_size\n    local_shard = local_shard.transpose(0, reshard_dim).contiguous()\n    gathered_input_size = list(local_shard.size())\n    gathered_input_size[0] = sharded_dim_size\n    gathered_input = torch.empty(gathered_input_size, device=local_shard.device, dtype=local_shard.dtype)\n    local_shard = all_to_all_single(gathered_input, local_shard, input_split_sizes=input_split_sizes, output_split_sizes=output_split_sizes, group=pg)\n    local_tensor = local_shard.transpose(0, reshard_dim).contiguous()\n    local_shards = [Shard(local_tensor, shards_metadata[current_rank])]\n    return (local_shards, shards_metadata)",
            "def reshuffle_local_shard(local_shard: torch.Tensor, st_size: torch.Size, sharding_spec: shard_spec.ShardingSpec, resharding_spec: shard_spec.ShardingSpec, pg: ProcessGroup) -> Tuple[List[Shard], List[ShardMetadata]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Reshuffle the local shard directly when the reshard dim is same as the original\\n    sharding dim. Logically we do this in two step:\\n    1. To collect all shards based on original sharding spec.\\n    2. Reshard the tensor based on the given resharding spec.\\n\\n    In reality, we consolidate the two steps into one by sending the local tensor to\\n    the new shard directly based on the resharding spec.\\n\\n    Args:\\n        local_shard (Tensor): Local tensor stored in the current rank.\\n        st_size (torch.Size): The size of the sharded tensor.\\n        sharding_spec (:class:`torch.distributed._shard.sharding_spec.ShardingSpec`): The\\n            specification describing how the tensor is sharded originally.\\n        resharding_spec (:class:`torch.distributed._shard.sharding_spec.ShardingSpec`): The\\n            specification describing how the tensor will be resharded.\\n        pg (ProcessGroup): The process group to aggregate on.\\n\\n    Returns:\\n        A Tuple of the followings:\\n            A List[`Shard`] which contains the local tensor and its metadata.\\n            A List[`ShardMetadata`] which contains the metadata for the shard, including\\n                offsets, lengths and device placement.\\n    '\n    current_rank = dist.get_rank(pg)\n    world_size = dist.get_world_size(pg)\n    (shards_metadata, ranks) = build_reshard_metadata(st_size, resharding_spec, world_size)\n    reshard_dim = int(resharding_spec.dim)\n    split_size = get_split_size(st_size[reshard_dim], world_size)\n    input_split_sizes = [0] * world_size\n    idx = get_idx_from_placements(sharding_spec.placements, current_rank)\n    new_rank = resharding_spec.placements[idx].rank()\n    input_split_sizes[new_rank] = local_shard.size(reshard_dim)\n    output_split_sizes = [0] * world_size\n    new_idx = ranks.index(current_rank)\n    sharded_dim_size = get_chunked_dim_size(st_size[reshard_dim], split_size, new_idx)\n    output_split_sizes[new_rank] = sharded_dim_size\n    local_shard = local_shard.transpose(0, reshard_dim).contiguous()\n    gathered_input_size = list(local_shard.size())\n    gathered_input_size[0] = sharded_dim_size\n    gathered_input = torch.empty(gathered_input_size, device=local_shard.device, dtype=local_shard.dtype)\n    local_shard = all_to_all_single(gathered_input, local_shard, input_split_sizes=input_split_sizes, output_split_sizes=output_split_sizes, group=pg)\n    local_tensor = local_shard.transpose(0, reshard_dim).contiguous()\n    local_shards = [Shard(local_tensor, shards_metadata[current_rank])]\n    return (local_shards, shards_metadata)",
            "def reshuffle_local_shard(local_shard: torch.Tensor, st_size: torch.Size, sharding_spec: shard_spec.ShardingSpec, resharding_spec: shard_spec.ShardingSpec, pg: ProcessGroup) -> Tuple[List[Shard], List[ShardMetadata]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Reshuffle the local shard directly when the reshard dim is same as the original\\n    sharding dim. Logically we do this in two step:\\n    1. To collect all shards based on original sharding spec.\\n    2. Reshard the tensor based on the given resharding spec.\\n\\n    In reality, we consolidate the two steps into one by sending the local tensor to\\n    the new shard directly based on the resharding spec.\\n\\n    Args:\\n        local_shard (Tensor): Local tensor stored in the current rank.\\n        st_size (torch.Size): The size of the sharded tensor.\\n        sharding_spec (:class:`torch.distributed._shard.sharding_spec.ShardingSpec`): The\\n            specification describing how the tensor is sharded originally.\\n        resharding_spec (:class:`torch.distributed._shard.sharding_spec.ShardingSpec`): The\\n            specification describing how the tensor will be resharded.\\n        pg (ProcessGroup): The process group to aggregate on.\\n\\n    Returns:\\n        A Tuple of the followings:\\n            A List[`Shard`] which contains the local tensor and its metadata.\\n            A List[`ShardMetadata`] which contains the metadata for the shard, including\\n                offsets, lengths and device placement.\\n    '\n    current_rank = dist.get_rank(pg)\n    world_size = dist.get_world_size(pg)\n    (shards_metadata, ranks) = build_reshard_metadata(st_size, resharding_spec, world_size)\n    reshard_dim = int(resharding_spec.dim)\n    split_size = get_split_size(st_size[reshard_dim], world_size)\n    input_split_sizes = [0] * world_size\n    idx = get_idx_from_placements(sharding_spec.placements, current_rank)\n    new_rank = resharding_spec.placements[idx].rank()\n    input_split_sizes[new_rank] = local_shard.size(reshard_dim)\n    output_split_sizes = [0] * world_size\n    new_idx = ranks.index(current_rank)\n    sharded_dim_size = get_chunked_dim_size(st_size[reshard_dim], split_size, new_idx)\n    output_split_sizes[new_rank] = sharded_dim_size\n    local_shard = local_shard.transpose(0, reshard_dim).contiguous()\n    gathered_input_size = list(local_shard.size())\n    gathered_input_size[0] = sharded_dim_size\n    gathered_input = torch.empty(gathered_input_size, device=local_shard.device, dtype=local_shard.dtype)\n    local_shard = all_to_all_single(gathered_input, local_shard, input_split_sizes=input_split_sizes, output_split_sizes=output_split_sizes, group=pg)\n    local_tensor = local_shard.transpose(0, reshard_dim).contiguous()\n    local_shards = [Shard(local_tensor, shards_metadata[current_rank])]\n    return (local_shards, shards_metadata)",
            "def reshuffle_local_shard(local_shard: torch.Tensor, st_size: torch.Size, sharding_spec: shard_spec.ShardingSpec, resharding_spec: shard_spec.ShardingSpec, pg: ProcessGroup) -> Tuple[List[Shard], List[ShardMetadata]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Reshuffle the local shard directly when the reshard dim is same as the original\\n    sharding dim. Logically we do this in two step:\\n    1. To collect all shards based on original sharding spec.\\n    2. Reshard the tensor based on the given resharding spec.\\n\\n    In reality, we consolidate the two steps into one by sending the local tensor to\\n    the new shard directly based on the resharding spec.\\n\\n    Args:\\n        local_shard (Tensor): Local tensor stored in the current rank.\\n        st_size (torch.Size): The size of the sharded tensor.\\n        sharding_spec (:class:`torch.distributed._shard.sharding_spec.ShardingSpec`): The\\n            specification describing how the tensor is sharded originally.\\n        resharding_spec (:class:`torch.distributed._shard.sharding_spec.ShardingSpec`): The\\n            specification describing how the tensor will be resharded.\\n        pg (ProcessGroup): The process group to aggregate on.\\n\\n    Returns:\\n        A Tuple of the followings:\\n            A List[`Shard`] which contains the local tensor and its metadata.\\n            A List[`ShardMetadata`] which contains the metadata for the shard, including\\n                offsets, lengths and device placement.\\n    '\n    current_rank = dist.get_rank(pg)\n    world_size = dist.get_world_size(pg)\n    (shards_metadata, ranks) = build_reshard_metadata(st_size, resharding_spec, world_size)\n    reshard_dim = int(resharding_spec.dim)\n    split_size = get_split_size(st_size[reshard_dim], world_size)\n    input_split_sizes = [0] * world_size\n    idx = get_idx_from_placements(sharding_spec.placements, current_rank)\n    new_rank = resharding_spec.placements[idx].rank()\n    input_split_sizes[new_rank] = local_shard.size(reshard_dim)\n    output_split_sizes = [0] * world_size\n    new_idx = ranks.index(current_rank)\n    sharded_dim_size = get_chunked_dim_size(st_size[reshard_dim], split_size, new_idx)\n    output_split_sizes[new_rank] = sharded_dim_size\n    local_shard = local_shard.transpose(0, reshard_dim).contiguous()\n    gathered_input_size = list(local_shard.size())\n    gathered_input_size[0] = sharded_dim_size\n    gathered_input = torch.empty(gathered_input_size, device=local_shard.device, dtype=local_shard.dtype)\n    local_shard = all_to_all_single(gathered_input, local_shard, input_split_sizes=input_split_sizes, output_split_sizes=output_split_sizes, group=pg)\n    local_tensor = local_shard.transpose(0, reshard_dim).contiguous()\n    local_shards = [Shard(local_tensor, shards_metadata[current_rank])]\n    return (local_shards, shards_metadata)"
        ]
    },
    {
        "func_name": "reshard_local_shard",
        "original": "def reshard_local_shard(local_tensor: torch.Tensor, st_size: torch.Size, sharding_spec: shard_spec.ShardingSpec, resharding_spec: shard_spec.ShardingSpec, pg: ProcessGroup) -> Tuple[List[Shard], List[ShardMetadata]]:\n    \"\"\"\n    Reshard a sharded tensor given the ``resharding_spec``. When the reshard dim is\n    different from the original sharding dim, we need to do two steps logically:\n    1. To collect all shards based on original sharding spec.\n    2. Reshard the tensor based on the given resharding spec.\n\n    In reality, we consolidate the two steps into one by sending each rank the new\n    shard based on the resharding spec.\n\n    Args:\n        local_tensor (Tensor): Local tensor stored in the current rank.\n        st_size (torch.Size): The size of the sharded tensor.\n        sharding_spec (:class:`torch.distributed._shard.sharding_spec.ShardingSpec`): The\n            specification describing how the tensor is sharded originally.\n        resharding_spec (:class:`torch.distributed._shard.sharding_spec.ShardingSpec`): The\n            specification describing how the tensor will be resharded.\n        pg (ProcessGroup): The process group to aggregate on.\n\n    Returns:\n        A Tuple of the followings:\n            A List[`Shard`] which contains the local tensor and its metadata.\n            A List[`ShardMetadata`] which contains the metadata for the shard, including\n                offsets, lengths and device placement.\n    \"\"\"\n    current_rank = dist.get_rank(pg)\n    world_size = dist.get_world_size(pg)\n    current_sharding_dim = int(sharding_spec.dim)\n    reshard_dim = int(resharding_spec.dim)\n    (shards_metadata, ranks) = build_reshard_metadata(st_size, resharding_spec, world_size)\n    input_split_sizes = []\n    for metadata in shards_metadata:\n        input_split_sizes.append(metadata.shard_sizes[reshard_dim])\n    rearrange_input = any((ranks[i] > ranks[i + 1] for i in range(len(ranks) - 1)))\n    if rearrange_input:\n        indices: List[int] = []\n        for metadata in shards_metadata:\n            offset_start_idx = metadata.shard_offsets[reshard_dim]\n            split_size = metadata.shard_sizes[reshard_dim]\n            indices += range(offset_start_idx, offset_start_idx + split_size)\n        local_tensor = local_tensor.index_select(reshard_dim, torch.tensor(indices, device=local_tensor.device))\n    output_tensor_list = [torch.tensor(1)] * world_size\n    split_size = get_split_size(st_size[current_sharding_dim], world_size)\n    rearrange_output_list = False\n    indices = []\n    for (idx, placement) in enumerate(sharding_spec.placements):\n        sharded_dim_size = get_chunked_dim_size(st_size[current_sharding_dim], split_size, idx)\n        output_tensor_size = list(st_size)\n        output_tensor_size[current_sharding_dim] = sharded_dim_size\n        output_tensor_size[reshard_dim] = input_split_sizes[current_rank]\n        output_tensor_list[placement.rank()] = torch.empty(output_tensor_size, device=local_tensor.device, dtype=local_tensor.dtype)\n        indices.append(placement.rank())\n        if idx != placement.rank():\n            rearrange_output_list = True\n    input_tensor_tuple = torch.split(local_tensor, input_split_sizes, dim=reshard_dim)\n    input_tensor_list = [tensor.contiguous() for tensor in input_tensor_tuple]\n    output_tensor_list = all_to_all(output_tensor_list, input_tensor_list, group=pg)\n    if rearrange_output_list:\n        output_tensor_list = [output_tensor_list[idx] for idx in indices]\n    local_tensor = torch.cat(output_tensor_list, dim=current_sharding_dim)\n    local_shards = [Shard(local_tensor, shards_metadata[current_rank])]\n    return (local_shards, shards_metadata)",
        "mutated": [
            "def reshard_local_shard(local_tensor: torch.Tensor, st_size: torch.Size, sharding_spec: shard_spec.ShardingSpec, resharding_spec: shard_spec.ShardingSpec, pg: ProcessGroup) -> Tuple[List[Shard], List[ShardMetadata]]:\n    if False:\n        i = 10\n    '\\n    Reshard a sharded tensor given the ``resharding_spec``. When the reshard dim is\\n    different from the original sharding dim, we need to do two steps logically:\\n    1. To collect all shards based on original sharding spec.\\n    2. Reshard the tensor based on the given resharding spec.\\n\\n    In reality, we consolidate the two steps into one by sending each rank the new\\n    shard based on the resharding spec.\\n\\n    Args:\\n        local_tensor (Tensor): Local tensor stored in the current rank.\\n        st_size (torch.Size): The size of the sharded tensor.\\n        sharding_spec (:class:`torch.distributed._shard.sharding_spec.ShardingSpec`): The\\n            specification describing how the tensor is sharded originally.\\n        resharding_spec (:class:`torch.distributed._shard.sharding_spec.ShardingSpec`): The\\n            specification describing how the tensor will be resharded.\\n        pg (ProcessGroup): The process group to aggregate on.\\n\\n    Returns:\\n        A Tuple of the followings:\\n            A List[`Shard`] which contains the local tensor and its metadata.\\n            A List[`ShardMetadata`] which contains the metadata for the shard, including\\n                offsets, lengths and device placement.\\n    '\n    current_rank = dist.get_rank(pg)\n    world_size = dist.get_world_size(pg)\n    current_sharding_dim = int(sharding_spec.dim)\n    reshard_dim = int(resharding_spec.dim)\n    (shards_metadata, ranks) = build_reshard_metadata(st_size, resharding_spec, world_size)\n    input_split_sizes = []\n    for metadata in shards_metadata:\n        input_split_sizes.append(metadata.shard_sizes[reshard_dim])\n    rearrange_input = any((ranks[i] > ranks[i + 1] for i in range(len(ranks) - 1)))\n    if rearrange_input:\n        indices: List[int] = []\n        for metadata in shards_metadata:\n            offset_start_idx = metadata.shard_offsets[reshard_dim]\n            split_size = metadata.shard_sizes[reshard_dim]\n            indices += range(offset_start_idx, offset_start_idx + split_size)\n        local_tensor = local_tensor.index_select(reshard_dim, torch.tensor(indices, device=local_tensor.device))\n    output_tensor_list = [torch.tensor(1)] * world_size\n    split_size = get_split_size(st_size[current_sharding_dim], world_size)\n    rearrange_output_list = False\n    indices = []\n    for (idx, placement) in enumerate(sharding_spec.placements):\n        sharded_dim_size = get_chunked_dim_size(st_size[current_sharding_dim], split_size, idx)\n        output_tensor_size = list(st_size)\n        output_tensor_size[current_sharding_dim] = sharded_dim_size\n        output_tensor_size[reshard_dim] = input_split_sizes[current_rank]\n        output_tensor_list[placement.rank()] = torch.empty(output_tensor_size, device=local_tensor.device, dtype=local_tensor.dtype)\n        indices.append(placement.rank())\n        if idx != placement.rank():\n            rearrange_output_list = True\n    input_tensor_tuple = torch.split(local_tensor, input_split_sizes, dim=reshard_dim)\n    input_tensor_list = [tensor.contiguous() for tensor in input_tensor_tuple]\n    output_tensor_list = all_to_all(output_tensor_list, input_tensor_list, group=pg)\n    if rearrange_output_list:\n        output_tensor_list = [output_tensor_list[idx] for idx in indices]\n    local_tensor = torch.cat(output_tensor_list, dim=current_sharding_dim)\n    local_shards = [Shard(local_tensor, shards_metadata[current_rank])]\n    return (local_shards, shards_metadata)",
            "def reshard_local_shard(local_tensor: torch.Tensor, st_size: torch.Size, sharding_spec: shard_spec.ShardingSpec, resharding_spec: shard_spec.ShardingSpec, pg: ProcessGroup) -> Tuple[List[Shard], List[ShardMetadata]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Reshard a sharded tensor given the ``resharding_spec``. When the reshard dim is\\n    different from the original sharding dim, we need to do two steps logically:\\n    1. To collect all shards based on original sharding spec.\\n    2. Reshard the tensor based on the given resharding spec.\\n\\n    In reality, we consolidate the two steps into one by sending each rank the new\\n    shard based on the resharding spec.\\n\\n    Args:\\n        local_tensor (Tensor): Local tensor stored in the current rank.\\n        st_size (torch.Size): The size of the sharded tensor.\\n        sharding_spec (:class:`torch.distributed._shard.sharding_spec.ShardingSpec`): The\\n            specification describing how the tensor is sharded originally.\\n        resharding_spec (:class:`torch.distributed._shard.sharding_spec.ShardingSpec`): The\\n            specification describing how the tensor will be resharded.\\n        pg (ProcessGroup): The process group to aggregate on.\\n\\n    Returns:\\n        A Tuple of the followings:\\n            A List[`Shard`] which contains the local tensor and its metadata.\\n            A List[`ShardMetadata`] which contains the metadata for the shard, including\\n                offsets, lengths and device placement.\\n    '\n    current_rank = dist.get_rank(pg)\n    world_size = dist.get_world_size(pg)\n    current_sharding_dim = int(sharding_spec.dim)\n    reshard_dim = int(resharding_spec.dim)\n    (shards_metadata, ranks) = build_reshard_metadata(st_size, resharding_spec, world_size)\n    input_split_sizes = []\n    for metadata in shards_metadata:\n        input_split_sizes.append(metadata.shard_sizes[reshard_dim])\n    rearrange_input = any((ranks[i] > ranks[i + 1] for i in range(len(ranks) - 1)))\n    if rearrange_input:\n        indices: List[int] = []\n        for metadata in shards_metadata:\n            offset_start_idx = metadata.shard_offsets[reshard_dim]\n            split_size = metadata.shard_sizes[reshard_dim]\n            indices += range(offset_start_idx, offset_start_idx + split_size)\n        local_tensor = local_tensor.index_select(reshard_dim, torch.tensor(indices, device=local_tensor.device))\n    output_tensor_list = [torch.tensor(1)] * world_size\n    split_size = get_split_size(st_size[current_sharding_dim], world_size)\n    rearrange_output_list = False\n    indices = []\n    for (idx, placement) in enumerate(sharding_spec.placements):\n        sharded_dim_size = get_chunked_dim_size(st_size[current_sharding_dim], split_size, idx)\n        output_tensor_size = list(st_size)\n        output_tensor_size[current_sharding_dim] = sharded_dim_size\n        output_tensor_size[reshard_dim] = input_split_sizes[current_rank]\n        output_tensor_list[placement.rank()] = torch.empty(output_tensor_size, device=local_tensor.device, dtype=local_tensor.dtype)\n        indices.append(placement.rank())\n        if idx != placement.rank():\n            rearrange_output_list = True\n    input_tensor_tuple = torch.split(local_tensor, input_split_sizes, dim=reshard_dim)\n    input_tensor_list = [tensor.contiguous() for tensor in input_tensor_tuple]\n    output_tensor_list = all_to_all(output_tensor_list, input_tensor_list, group=pg)\n    if rearrange_output_list:\n        output_tensor_list = [output_tensor_list[idx] for idx in indices]\n    local_tensor = torch.cat(output_tensor_list, dim=current_sharding_dim)\n    local_shards = [Shard(local_tensor, shards_metadata[current_rank])]\n    return (local_shards, shards_metadata)",
            "def reshard_local_shard(local_tensor: torch.Tensor, st_size: torch.Size, sharding_spec: shard_spec.ShardingSpec, resharding_spec: shard_spec.ShardingSpec, pg: ProcessGroup) -> Tuple[List[Shard], List[ShardMetadata]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Reshard a sharded tensor given the ``resharding_spec``. When the reshard dim is\\n    different from the original sharding dim, we need to do two steps logically:\\n    1. To collect all shards based on original sharding spec.\\n    2. Reshard the tensor based on the given resharding spec.\\n\\n    In reality, we consolidate the two steps into one by sending each rank the new\\n    shard based on the resharding spec.\\n\\n    Args:\\n        local_tensor (Tensor): Local tensor stored in the current rank.\\n        st_size (torch.Size): The size of the sharded tensor.\\n        sharding_spec (:class:`torch.distributed._shard.sharding_spec.ShardingSpec`): The\\n            specification describing how the tensor is sharded originally.\\n        resharding_spec (:class:`torch.distributed._shard.sharding_spec.ShardingSpec`): The\\n            specification describing how the tensor will be resharded.\\n        pg (ProcessGroup): The process group to aggregate on.\\n\\n    Returns:\\n        A Tuple of the followings:\\n            A List[`Shard`] which contains the local tensor and its metadata.\\n            A List[`ShardMetadata`] which contains the metadata for the shard, including\\n                offsets, lengths and device placement.\\n    '\n    current_rank = dist.get_rank(pg)\n    world_size = dist.get_world_size(pg)\n    current_sharding_dim = int(sharding_spec.dim)\n    reshard_dim = int(resharding_spec.dim)\n    (shards_metadata, ranks) = build_reshard_metadata(st_size, resharding_spec, world_size)\n    input_split_sizes = []\n    for metadata in shards_metadata:\n        input_split_sizes.append(metadata.shard_sizes[reshard_dim])\n    rearrange_input = any((ranks[i] > ranks[i + 1] for i in range(len(ranks) - 1)))\n    if rearrange_input:\n        indices: List[int] = []\n        for metadata in shards_metadata:\n            offset_start_idx = metadata.shard_offsets[reshard_dim]\n            split_size = metadata.shard_sizes[reshard_dim]\n            indices += range(offset_start_idx, offset_start_idx + split_size)\n        local_tensor = local_tensor.index_select(reshard_dim, torch.tensor(indices, device=local_tensor.device))\n    output_tensor_list = [torch.tensor(1)] * world_size\n    split_size = get_split_size(st_size[current_sharding_dim], world_size)\n    rearrange_output_list = False\n    indices = []\n    for (idx, placement) in enumerate(sharding_spec.placements):\n        sharded_dim_size = get_chunked_dim_size(st_size[current_sharding_dim], split_size, idx)\n        output_tensor_size = list(st_size)\n        output_tensor_size[current_sharding_dim] = sharded_dim_size\n        output_tensor_size[reshard_dim] = input_split_sizes[current_rank]\n        output_tensor_list[placement.rank()] = torch.empty(output_tensor_size, device=local_tensor.device, dtype=local_tensor.dtype)\n        indices.append(placement.rank())\n        if idx != placement.rank():\n            rearrange_output_list = True\n    input_tensor_tuple = torch.split(local_tensor, input_split_sizes, dim=reshard_dim)\n    input_tensor_list = [tensor.contiguous() for tensor in input_tensor_tuple]\n    output_tensor_list = all_to_all(output_tensor_list, input_tensor_list, group=pg)\n    if rearrange_output_list:\n        output_tensor_list = [output_tensor_list[idx] for idx in indices]\n    local_tensor = torch.cat(output_tensor_list, dim=current_sharding_dim)\n    local_shards = [Shard(local_tensor, shards_metadata[current_rank])]\n    return (local_shards, shards_metadata)",
            "def reshard_local_shard(local_tensor: torch.Tensor, st_size: torch.Size, sharding_spec: shard_spec.ShardingSpec, resharding_spec: shard_spec.ShardingSpec, pg: ProcessGroup) -> Tuple[List[Shard], List[ShardMetadata]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Reshard a sharded tensor given the ``resharding_spec``. When the reshard dim is\\n    different from the original sharding dim, we need to do two steps logically:\\n    1. To collect all shards based on original sharding spec.\\n    2. Reshard the tensor based on the given resharding spec.\\n\\n    In reality, we consolidate the two steps into one by sending each rank the new\\n    shard based on the resharding spec.\\n\\n    Args:\\n        local_tensor (Tensor): Local tensor stored in the current rank.\\n        st_size (torch.Size): The size of the sharded tensor.\\n        sharding_spec (:class:`torch.distributed._shard.sharding_spec.ShardingSpec`): The\\n            specification describing how the tensor is sharded originally.\\n        resharding_spec (:class:`torch.distributed._shard.sharding_spec.ShardingSpec`): The\\n            specification describing how the tensor will be resharded.\\n        pg (ProcessGroup): The process group to aggregate on.\\n\\n    Returns:\\n        A Tuple of the followings:\\n            A List[`Shard`] which contains the local tensor and its metadata.\\n            A List[`ShardMetadata`] which contains the metadata for the shard, including\\n                offsets, lengths and device placement.\\n    '\n    current_rank = dist.get_rank(pg)\n    world_size = dist.get_world_size(pg)\n    current_sharding_dim = int(sharding_spec.dim)\n    reshard_dim = int(resharding_spec.dim)\n    (shards_metadata, ranks) = build_reshard_metadata(st_size, resharding_spec, world_size)\n    input_split_sizes = []\n    for metadata in shards_metadata:\n        input_split_sizes.append(metadata.shard_sizes[reshard_dim])\n    rearrange_input = any((ranks[i] > ranks[i + 1] for i in range(len(ranks) - 1)))\n    if rearrange_input:\n        indices: List[int] = []\n        for metadata in shards_metadata:\n            offset_start_idx = metadata.shard_offsets[reshard_dim]\n            split_size = metadata.shard_sizes[reshard_dim]\n            indices += range(offset_start_idx, offset_start_idx + split_size)\n        local_tensor = local_tensor.index_select(reshard_dim, torch.tensor(indices, device=local_tensor.device))\n    output_tensor_list = [torch.tensor(1)] * world_size\n    split_size = get_split_size(st_size[current_sharding_dim], world_size)\n    rearrange_output_list = False\n    indices = []\n    for (idx, placement) in enumerate(sharding_spec.placements):\n        sharded_dim_size = get_chunked_dim_size(st_size[current_sharding_dim], split_size, idx)\n        output_tensor_size = list(st_size)\n        output_tensor_size[current_sharding_dim] = sharded_dim_size\n        output_tensor_size[reshard_dim] = input_split_sizes[current_rank]\n        output_tensor_list[placement.rank()] = torch.empty(output_tensor_size, device=local_tensor.device, dtype=local_tensor.dtype)\n        indices.append(placement.rank())\n        if idx != placement.rank():\n            rearrange_output_list = True\n    input_tensor_tuple = torch.split(local_tensor, input_split_sizes, dim=reshard_dim)\n    input_tensor_list = [tensor.contiguous() for tensor in input_tensor_tuple]\n    output_tensor_list = all_to_all(output_tensor_list, input_tensor_list, group=pg)\n    if rearrange_output_list:\n        output_tensor_list = [output_tensor_list[idx] for idx in indices]\n    local_tensor = torch.cat(output_tensor_list, dim=current_sharding_dim)\n    local_shards = [Shard(local_tensor, shards_metadata[current_rank])]\n    return (local_shards, shards_metadata)",
            "def reshard_local_shard(local_tensor: torch.Tensor, st_size: torch.Size, sharding_spec: shard_spec.ShardingSpec, resharding_spec: shard_spec.ShardingSpec, pg: ProcessGroup) -> Tuple[List[Shard], List[ShardMetadata]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Reshard a sharded tensor given the ``resharding_spec``. When the reshard dim is\\n    different from the original sharding dim, we need to do two steps logically:\\n    1. To collect all shards based on original sharding spec.\\n    2. Reshard the tensor based on the given resharding spec.\\n\\n    In reality, we consolidate the two steps into one by sending each rank the new\\n    shard based on the resharding spec.\\n\\n    Args:\\n        local_tensor (Tensor): Local tensor stored in the current rank.\\n        st_size (torch.Size): The size of the sharded tensor.\\n        sharding_spec (:class:`torch.distributed._shard.sharding_spec.ShardingSpec`): The\\n            specification describing how the tensor is sharded originally.\\n        resharding_spec (:class:`torch.distributed._shard.sharding_spec.ShardingSpec`): The\\n            specification describing how the tensor will be resharded.\\n        pg (ProcessGroup): The process group to aggregate on.\\n\\n    Returns:\\n        A Tuple of the followings:\\n            A List[`Shard`] which contains the local tensor and its metadata.\\n            A List[`ShardMetadata`] which contains the metadata for the shard, including\\n                offsets, lengths and device placement.\\n    '\n    current_rank = dist.get_rank(pg)\n    world_size = dist.get_world_size(pg)\n    current_sharding_dim = int(sharding_spec.dim)\n    reshard_dim = int(resharding_spec.dim)\n    (shards_metadata, ranks) = build_reshard_metadata(st_size, resharding_spec, world_size)\n    input_split_sizes = []\n    for metadata in shards_metadata:\n        input_split_sizes.append(metadata.shard_sizes[reshard_dim])\n    rearrange_input = any((ranks[i] > ranks[i + 1] for i in range(len(ranks) - 1)))\n    if rearrange_input:\n        indices: List[int] = []\n        for metadata in shards_metadata:\n            offset_start_idx = metadata.shard_offsets[reshard_dim]\n            split_size = metadata.shard_sizes[reshard_dim]\n            indices += range(offset_start_idx, offset_start_idx + split_size)\n        local_tensor = local_tensor.index_select(reshard_dim, torch.tensor(indices, device=local_tensor.device))\n    output_tensor_list = [torch.tensor(1)] * world_size\n    split_size = get_split_size(st_size[current_sharding_dim], world_size)\n    rearrange_output_list = False\n    indices = []\n    for (idx, placement) in enumerate(sharding_spec.placements):\n        sharded_dim_size = get_chunked_dim_size(st_size[current_sharding_dim], split_size, idx)\n        output_tensor_size = list(st_size)\n        output_tensor_size[current_sharding_dim] = sharded_dim_size\n        output_tensor_size[reshard_dim] = input_split_sizes[current_rank]\n        output_tensor_list[placement.rank()] = torch.empty(output_tensor_size, device=local_tensor.device, dtype=local_tensor.dtype)\n        indices.append(placement.rank())\n        if idx != placement.rank():\n            rearrange_output_list = True\n    input_tensor_tuple = torch.split(local_tensor, input_split_sizes, dim=reshard_dim)\n    input_tensor_list = [tensor.contiguous() for tensor in input_tensor_tuple]\n    output_tensor_list = all_to_all(output_tensor_list, input_tensor_list, group=pg)\n    if rearrange_output_list:\n        output_tensor_list = [output_tensor_list[idx] for idx in indices]\n    local_tensor = torch.cat(output_tensor_list, dim=current_sharding_dim)\n    local_shards = [Shard(local_tensor, shards_metadata[current_rank])]\n    return (local_shards, shards_metadata)"
        ]
    }
]