[
    {
        "func_name": "system",
        "original": "def system(cmd):\n    try:\n        output = subprocess.check_output(cmd, stderr=subprocess.STDOUT)\n        return (0, output)\n    except subprocess.CalledProcessError as er:\n        return (-1, er.output)",
        "mutated": [
            "def system(cmd):\n    if False:\n        i = 10\n    try:\n        output = subprocess.check_output(cmd, stderr=subprocess.STDOUT)\n        return (0, output)\n    except subprocess.CalledProcessError as er:\n        return (-1, er.output)",
            "def system(cmd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    try:\n        output = subprocess.check_output(cmd, stderr=subprocess.STDOUT)\n        return (0, output)\n    except subprocess.CalledProcessError as er:\n        return (-1, er.output)",
            "def system(cmd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    try:\n        output = subprocess.check_output(cmd, stderr=subprocess.STDOUT)\n        return (0, output)\n    except subprocess.CalledProcessError as er:\n        return (-1, er.output)",
            "def system(cmd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    try:\n        output = subprocess.check_output(cmd, stderr=subprocess.STDOUT)\n        return (0, output)\n    except subprocess.CalledProcessError as er:\n        return (-1, er.output)",
            "def system(cmd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    try:\n        output = subprocess.check_output(cmd, stderr=subprocess.STDOUT)\n        return (0, output)\n    except subprocess.CalledProcessError as er:\n        return (-1, er.output)"
        ]
    },
    {
        "func_name": "get_timestamp",
        "original": "def get_timestamp(path, default=None):\n    try:\n        stat = os.stat(path)\n        return stat.st_mtime\n    except OSError:\n        if default is None:\n            raise FreezeError('cannot stat {}'.format(path))\n        return default",
        "mutated": [
            "def get_timestamp(path, default=None):\n    if False:\n        i = 10\n    try:\n        stat = os.stat(path)\n        return stat.st_mtime\n    except OSError:\n        if default is None:\n            raise FreezeError('cannot stat {}'.format(path))\n        return default",
            "def get_timestamp(path, default=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    try:\n        stat = os.stat(path)\n        return stat.st_mtime\n    except OSError:\n        if default is None:\n            raise FreezeError('cannot stat {}'.format(path))\n        return default",
            "def get_timestamp(path, default=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    try:\n        stat = os.stat(path)\n        return stat.st_mtime\n    except OSError:\n        if default is None:\n            raise FreezeError('cannot stat {}'.format(path))\n        return default",
            "def get_timestamp(path, default=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    try:\n        stat = os.stat(path)\n        return stat.st_mtime\n    except OSError:\n        if default is None:\n            raise FreezeError('cannot stat {}'.format(path))\n        return default",
            "def get_timestamp(path, default=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    try:\n        stat = os.stat(path)\n        return stat.st_mtime\n    except OSError:\n        if default is None:\n            raise FreezeError('cannot stat {}'.format(path))\n        return default"
        ]
    },
    {
        "func_name": "mkdir",
        "original": "def mkdir(filename):\n    path = os.path.dirname(filename)\n    if not os.path.isdir(path):\n        os.makedirs(path)",
        "mutated": [
            "def mkdir(filename):\n    if False:\n        i = 10\n    path = os.path.dirname(filename)\n    if not os.path.isdir(path):\n        os.makedirs(path)",
            "def mkdir(filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    path = os.path.dirname(filename)\n    if not os.path.isdir(path):\n        os.makedirs(path)",
            "def mkdir(filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    path = os.path.dirname(filename)\n    if not os.path.isdir(path):\n        os.makedirs(path)",
            "def mkdir(filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    path = os.path.dirname(filename)\n    if not os.path.isdir(path):\n        os.makedirs(path)",
            "def mkdir(filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    path = os.path.dirname(filename)\n    if not os.path.isdir(path):\n        os.makedirs(path)"
        ]
    },
    {
        "func_name": "generate_frozen_str_content",
        "original": "def generate_frozen_str_content(modules):\n    output = [b'#include <stdint.h>\\n', b'#define MP_FROZEN_STR_NAMES \\\\\\n']\n    for (_, target_path) in modules:\n        print('STR', target_path)\n        output.append(b'\"%s\\\\0\" \\\\\\n' % target_path.encode())\n    output.append(b'\\n')\n    output.append(b'const uint32_t mp_frozen_str_sizes[] = { ')\n    for (full_path, _) in modules:\n        st = os.stat(full_path)\n        output.append(b'%d, ' % st.st_size)\n    output.append(b'0 };\\n')\n    output.append(b'const char mp_frozen_str_content[] = {\\n')\n    for (full_path, _) in modules:\n        with open(full_path, 'rb') as f:\n            data = f.read()\n            data = bytearray(data)\n            esc_dict = {ord('\\n'): b'\\\\n', ord('\\r'): b'\\\\r', ord('\"'): b'\\\\\"', ord('\\\\'): b'\\\\\\\\'}\n            output.append(b'\"')\n            break_str = False\n            for c in data:\n                try:\n                    output.append(esc_dict[c])\n                except KeyError:\n                    if 32 <= c <= 126:\n                        if break_str:\n                            output.append(b'\" \"')\n                            break_str = False\n                        output.append(chr(c).encode())\n                    else:\n                        output.append(b'\\\\x%02x' % c)\n                        break_str = True\n            output.append(b'\\\\0\"\\n')\n    output.append(b'\"\\\\0\"\\n};\\n\\n')\n    return b''.join(output)",
        "mutated": [
            "def generate_frozen_str_content(modules):\n    if False:\n        i = 10\n    output = [b'#include <stdint.h>\\n', b'#define MP_FROZEN_STR_NAMES \\\\\\n']\n    for (_, target_path) in modules:\n        print('STR', target_path)\n        output.append(b'\"%s\\\\0\" \\\\\\n' % target_path.encode())\n    output.append(b'\\n')\n    output.append(b'const uint32_t mp_frozen_str_sizes[] = { ')\n    for (full_path, _) in modules:\n        st = os.stat(full_path)\n        output.append(b'%d, ' % st.st_size)\n    output.append(b'0 };\\n')\n    output.append(b'const char mp_frozen_str_content[] = {\\n')\n    for (full_path, _) in modules:\n        with open(full_path, 'rb') as f:\n            data = f.read()\n            data = bytearray(data)\n            esc_dict = {ord('\\n'): b'\\\\n', ord('\\r'): b'\\\\r', ord('\"'): b'\\\\\"', ord('\\\\'): b'\\\\\\\\'}\n            output.append(b'\"')\n            break_str = False\n            for c in data:\n                try:\n                    output.append(esc_dict[c])\n                except KeyError:\n                    if 32 <= c <= 126:\n                        if break_str:\n                            output.append(b'\" \"')\n                            break_str = False\n                        output.append(chr(c).encode())\n                    else:\n                        output.append(b'\\\\x%02x' % c)\n                        break_str = True\n            output.append(b'\\\\0\"\\n')\n    output.append(b'\"\\\\0\"\\n};\\n\\n')\n    return b''.join(output)",
            "def generate_frozen_str_content(modules):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    output = [b'#include <stdint.h>\\n', b'#define MP_FROZEN_STR_NAMES \\\\\\n']\n    for (_, target_path) in modules:\n        print('STR', target_path)\n        output.append(b'\"%s\\\\0\" \\\\\\n' % target_path.encode())\n    output.append(b'\\n')\n    output.append(b'const uint32_t mp_frozen_str_sizes[] = { ')\n    for (full_path, _) in modules:\n        st = os.stat(full_path)\n        output.append(b'%d, ' % st.st_size)\n    output.append(b'0 };\\n')\n    output.append(b'const char mp_frozen_str_content[] = {\\n')\n    for (full_path, _) in modules:\n        with open(full_path, 'rb') as f:\n            data = f.read()\n            data = bytearray(data)\n            esc_dict = {ord('\\n'): b'\\\\n', ord('\\r'): b'\\\\r', ord('\"'): b'\\\\\"', ord('\\\\'): b'\\\\\\\\'}\n            output.append(b'\"')\n            break_str = False\n            for c in data:\n                try:\n                    output.append(esc_dict[c])\n                except KeyError:\n                    if 32 <= c <= 126:\n                        if break_str:\n                            output.append(b'\" \"')\n                            break_str = False\n                        output.append(chr(c).encode())\n                    else:\n                        output.append(b'\\\\x%02x' % c)\n                        break_str = True\n            output.append(b'\\\\0\"\\n')\n    output.append(b'\"\\\\0\"\\n};\\n\\n')\n    return b''.join(output)",
            "def generate_frozen_str_content(modules):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    output = [b'#include <stdint.h>\\n', b'#define MP_FROZEN_STR_NAMES \\\\\\n']\n    for (_, target_path) in modules:\n        print('STR', target_path)\n        output.append(b'\"%s\\\\0\" \\\\\\n' % target_path.encode())\n    output.append(b'\\n')\n    output.append(b'const uint32_t mp_frozen_str_sizes[] = { ')\n    for (full_path, _) in modules:\n        st = os.stat(full_path)\n        output.append(b'%d, ' % st.st_size)\n    output.append(b'0 };\\n')\n    output.append(b'const char mp_frozen_str_content[] = {\\n')\n    for (full_path, _) in modules:\n        with open(full_path, 'rb') as f:\n            data = f.read()\n            data = bytearray(data)\n            esc_dict = {ord('\\n'): b'\\\\n', ord('\\r'): b'\\\\r', ord('\"'): b'\\\\\"', ord('\\\\'): b'\\\\\\\\'}\n            output.append(b'\"')\n            break_str = False\n            for c in data:\n                try:\n                    output.append(esc_dict[c])\n                except KeyError:\n                    if 32 <= c <= 126:\n                        if break_str:\n                            output.append(b'\" \"')\n                            break_str = False\n                        output.append(chr(c).encode())\n                    else:\n                        output.append(b'\\\\x%02x' % c)\n                        break_str = True\n            output.append(b'\\\\0\"\\n')\n    output.append(b'\"\\\\0\"\\n};\\n\\n')\n    return b''.join(output)",
            "def generate_frozen_str_content(modules):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    output = [b'#include <stdint.h>\\n', b'#define MP_FROZEN_STR_NAMES \\\\\\n']\n    for (_, target_path) in modules:\n        print('STR', target_path)\n        output.append(b'\"%s\\\\0\" \\\\\\n' % target_path.encode())\n    output.append(b'\\n')\n    output.append(b'const uint32_t mp_frozen_str_sizes[] = { ')\n    for (full_path, _) in modules:\n        st = os.stat(full_path)\n        output.append(b'%d, ' % st.st_size)\n    output.append(b'0 };\\n')\n    output.append(b'const char mp_frozen_str_content[] = {\\n')\n    for (full_path, _) in modules:\n        with open(full_path, 'rb') as f:\n            data = f.read()\n            data = bytearray(data)\n            esc_dict = {ord('\\n'): b'\\\\n', ord('\\r'): b'\\\\r', ord('\"'): b'\\\\\"', ord('\\\\'): b'\\\\\\\\'}\n            output.append(b'\"')\n            break_str = False\n            for c in data:\n                try:\n                    output.append(esc_dict[c])\n                except KeyError:\n                    if 32 <= c <= 126:\n                        if break_str:\n                            output.append(b'\" \"')\n                            break_str = False\n                        output.append(chr(c).encode())\n                    else:\n                        output.append(b'\\\\x%02x' % c)\n                        break_str = True\n            output.append(b'\\\\0\"\\n')\n    output.append(b'\"\\\\0\"\\n};\\n\\n')\n    return b''.join(output)",
            "def generate_frozen_str_content(modules):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    output = [b'#include <stdint.h>\\n', b'#define MP_FROZEN_STR_NAMES \\\\\\n']\n    for (_, target_path) in modules:\n        print('STR', target_path)\n        output.append(b'\"%s\\\\0\" \\\\\\n' % target_path.encode())\n    output.append(b'\\n')\n    output.append(b'const uint32_t mp_frozen_str_sizes[] = { ')\n    for (full_path, _) in modules:\n        st = os.stat(full_path)\n        output.append(b'%d, ' % st.st_size)\n    output.append(b'0 };\\n')\n    output.append(b'const char mp_frozen_str_content[] = {\\n')\n    for (full_path, _) in modules:\n        with open(full_path, 'rb') as f:\n            data = f.read()\n            data = bytearray(data)\n            esc_dict = {ord('\\n'): b'\\\\n', ord('\\r'): b'\\\\r', ord('\"'): b'\\\\\"', ord('\\\\'): b'\\\\\\\\'}\n            output.append(b'\"')\n            break_str = False\n            for c in data:\n                try:\n                    output.append(esc_dict[c])\n                except KeyError:\n                    if 32 <= c <= 126:\n                        if break_str:\n                            output.append(b'\" \"')\n                            break_str = False\n                        output.append(chr(c).encode())\n                    else:\n                        output.append(b'\\\\x%02x' % c)\n                        break_str = True\n            output.append(b'\\\\0\"\\n')\n    output.append(b'\"\\\\0\"\\n};\\n\\n')\n    return b''.join(output)"
        ]
    },
    {
        "func_name": "main",
        "original": "def main():\n    import argparse\n    cmd_parser = argparse.ArgumentParser(description='A tool to generate frozen content in MicroPython firmware images.')\n    cmd_parser.add_argument('-o', '--output', help='output path')\n    cmd_parser.add_argument('-b', '--build-dir', help='output path')\n    cmd_parser.add_argument('-f', '--mpy-cross-flags', default='', help='flags to pass to mpy-cross')\n    cmd_parser.add_argument('-v', '--var', action='append', help='variables to substitute')\n    cmd_parser.add_argument('--mpy-tool-flags', default='', help='flags to pass to mpy-tool')\n    cmd_parser.add_argument('files', nargs='+', help='input manifest list')\n    args = cmd_parser.parse_args()\n    for var in args.var:\n        (name, value) = var.split('=', 1)\n        if os.path.exists(value):\n            value = os.path.abspath(value)\n        VARS[name] = value\n    if 'MPY_DIR' not in VARS or 'PORT_DIR' not in VARS:\n        print('MPY_DIR and PORT_DIR variables must be specified')\n        sys.exit(1)\n    MPY_CROSS = VARS['MPY_DIR'] + '/mpy-cross/build/mpy-cross'\n    if sys.platform == 'win32':\n        MPY_CROSS += '.exe'\n    MPY_CROSS = os.getenv('MICROPY_MPYCROSS', MPY_CROSS)\n    MPY_TOOL = VARS['MPY_DIR'] + '/tools/mpy-tool.py'\n    if not os.path.exists(MPY_CROSS):\n        print('mpy-cross not found at {}, please build it first'.format(MPY_CROSS))\n        sys.exit(1)\n    manifest = manifestfile.ManifestFile(manifestfile.MODE_FREEZE, VARS)\n    for input_manifest in args.files:\n        try:\n            manifest.execute(input_manifest)\n        except manifestfile.ManifestFileError as er:\n            print('freeze error executing \"{}\": {}'.format(input_manifest, er.args[0]))\n            sys.exit(1)\n    str_paths = []\n    mpy_files = []\n    ts_newest = 0\n    for result in manifest.files():\n        if result.kind == manifestfile.KIND_FREEZE_AS_STR:\n            str_paths.append((result.full_path, result.target_path))\n            ts_outfile = result.timestamp\n        elif result.kind == manifestfile.KIND_FREEZE_AS_MPY:\n            outfile = '{}/frozen_mpy/{}.mpy'.format(args.build_dir, result.target_path[:-3])\n            ts_outfile = get_timestamp(outfile, 0)\n            if result.timestamp >= ts_outfile:\n                print('MPY', result.target_path)\n                mkdir(outfile)\n                with manifestfile.tagged_py_file(result.full_path, result.metadata) as tagged_path:\n                    try:\n                        mpy_cross.compile(tagged_path, dest=outfile, src_path=result.target_path, opt=result.opt, mpy_cross=MPY_CROSS, extra_args=args.mpy_cross_flags.split())\n                    except mpy_cross.CrossCompileError as ex:\n                        print('error compiling {}:'.format(result.target_path))\n                        print(ex.args[0])\n                        raise SystemExit(1)\n                ts_outfile = get_timestamp(outfile)\n            mpy_files.append(outfile)\n        else:\n            assert result.kind == manifestfile.KIND_FREEZE_MPY\n            mpy_files.append(result.full_path)\n            ts_outfile = result.timestamp\n        ts_newest = max(ts_newest, ts_outfile)\n    if ts_newest < get_timestamp(args.output, 0):\n        return\n    output_str = generate_frozen_str_content(str_paths)\n    if mpy_files:\n        (res, output_mpy) = system([sys.executable, MPY_TOOL, '-f', '-q', args.build_dir + '/genhdr/qstrdefs.preprocessed.h'] + args.mpy_tool_flags.split() + mpy_files)\n        if res != 0:\n            print('error freezing mpy {}:'.format(mpy_files))\n            print(output_mpy.decode())\n            sys.exit(1)\n    else:\n        output_mpy = b'#include \"py/emitglue.h\"\\nextern const qstr_pool_t mp_qstr_const_pool;\\nconst qstr_pool_t mp_qstr_frozen_const_pool = {\\n    (qstr_pool_t*)&mp_qstr_const_pool, MP_QSTRnumber_of, 0, 0\\n};\\nconst char mp_frozen_names[] = { MP_FROZEN_STR_NAMES \"\\\\0\"};\\nconst mp_raw_code_t *const mp_frozen_mpy_content[] = {NULL};\\n'\n    print('GEN', args.output)\n    mkdir(args.output)\n    with open(args.output, 'wb') as f:\n        f.write(b'//\\n// Content for MICROPY_MODULE_FROZEN_STR\\n//\\n')\n        f.write(output_str)\n        f.write(b'//\\n// Content for MICROPY_MODULE_FROZEN_MPY\\n//\\n')\n        f.write(output_mpy)",
        "mutated": [
            "def main():\n    if False:\n        i = 10\n    import argparse\n    cmd_parser = argparse.ArgumentParser(description='A tool to generate frozen content in MicroPython firmware images.')\n    cmd_parser.add_argument('-o', '--output', help='output path')\n    cmd_parser.add_argument('-b', '--build-dir', help='output path')\n    cmd_parser.add_argument('-f', '--mpy-cross-flags', default='', help='flags to pass to mpy-cross')\n    cmd_parser.add_argument('-v', '--var', action='append', help='variables to substitute')\n    cmd_parser.add_argument('--mpy-tool-flags', default='', help='flags to pass to mpy-tool')\n    cmd_parser.add_argument('files', nargs='+', help='input manifest list')\n    args = cmd_parser.parse_args()\n    for var in args.var:\n        (name, value) = var.split('=', 1)\n        if os.path.exists(value):\n            value = os.path.abspath(value)\n        VARS[name] = value\n    if 'MPY_DIR' not in VARS or 'PORT_DIR' not in VARS:\n        print('MPY_DIR and PORT_DIR variables must be specified')\n        sys.exit(1)\n    MPY_CROSS = VARS['MPY_DIR'] + '/mpy-cross/build/mpy-cross'\n    if sys.platform == 'win32':\n        MPY_CROSS += '.exe'\n    MPY_CROSS = os.getenv('MICROPY_MPYCROSS', MPY_CROSS)\n    MPY_TOOL = VARS['MPY_DIR'] + '/tools/mpy-tool.py'\n    if not os.path.exists(MPY_CROSS):\n        print('mpy-cross not found at {}, please build it first'.format(MPY_CROSS))\n        sys.exit(1)\n    manifest = manifestfile.ManifestFile(manifestfile.MODE_FREEZE, VARS)\n    for input_manifest in args.files:\n        try:\n            manifest.execute(input_manifest)\n        except manifestfile.ManifestFileError as er:\n            print('freeze error executing \"{}\": {}'.format(input_manifest, er.args[0]))\n            sys.exit(1)\n    str_paths = []\n    mpy_files = []\n    ts_newest = 0\n    for result in manifest.files():\n        if result.kind == manifestfile.KIND_FREEZE_AS_STR:\n            str_paths.append((result.full_path, result.target_path))\n            ts_outfile = result.timestamp\n        elif result.kind == manifestfile.KIND_FREEZE_AS_MPY:\n            outfile = '{}/frozen_mpy/{}.mpy'.format(args.build_dir, result.target_path[:-3])\n            ts_outfile = get_timestamp(outfile, 0)\n            if result.timestamp >= ts_outfile:\n                print('MPY', result.target_path)\n                mkdir(outfile)\n                with manifestfile.tagged_py_file(result.full_path, result.metadata) as tagged_path:\n                    try:\n                        mpy_cross.compile(tagged_path, dest=outfile, src_path=result.target_path, opt=result.opt, mpy_cross=MPY_CROSS, extra_args=args.mpy_cross_flags.split())\n                    except mpy_cross.CrossCompileError as ex:\n                        print('error compiling {}:'.format(result.target_path))\n                        print(ex.args[0])\n                        raise SystemExit(1)\n                ts_outfile = get_timestamp(outfile)\n            mpy_files.append(outfile)\n        else:\n            assert result.kind == manifestfile.KIND_FREEZE_MPY\n            mpy_files.append(result.full_path)\n            ts_outfile = result.timestamp\n        ts_newest = max(ts_newest, ts_outfile)\n    if ts_newest < get_timestamp(args.output, 0):\n        return\n    output_str = generate_frozen_str_content(str_paths)\n    if mpy_files:\n        (res, output_mpy) = system([sys.executable, MPY_TOOL, '-f', '-q', args.build_dir + '/genhdr/qstrdefs.preprocessed.h'] + args.mpy_tool_flags.split() + mpy_files)\n        if res != 0:\n            print('error freezing mpy {}:'.format(mpy_files))\n            print(output_mpy.decode())\n            sys.exit(1)\n    else:\n        output_mpy = b'#include \"py/emitglue.h\"\\nextern const qstr_pool_t mp_qstr_const_pool;\\nconst qstr_pool_t mp_qstr_frozen_const_pool = {\\n    (qstr_pool_t*)&mp_qstr_const_pool, MP_QSTRnumber_of, 0, 0\\n};\\nconst char mp_frozen_names[] = { MP_FROZEN_STR_NAMES \"\\\\0\"};\\nconst mp_raw_code_t *const mp_frozen_mpy_content[] = {NULL};\\n'\n    print('GEN', args.output)\n    mkdir(args.output)\n    with open(args.output, 'wb') as f:\n        f.write(b'//\\n// Content for MICROPY_MODULE_FROZEN_STR\\n//\\n')\n        f.write(output_str)\n        f.write(b'//\\n// Content for MICROPY_MODULE_FROZEN_MPY\\n//\\n')\n        f.write(output_mpy)",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    import argparse\n    cmd_parser = argparse.ArgumentParser(description='A tool to generate frozen content in MicroPython firmware images.')\n    cmd_parser.add_argument('-o', '--output', help='output path')\n    cmd_parser.add_argument('-b', '--build-dir', help='output path')\n    cmd_parser.add_argument('-f', '--mpy-cross-flags', default='', help='flags to pass to mpy-cross')\n    cmd_parser.add_argument('-v', '--var', action='append', help='variables to substitute')\n    cmd_parser.add_argument('--mpy-tool-flags', default='', help='flags to pass to mpy-tool')\n    cmd_parser.add_argument('files', nargs='+', help='input manifest list')\n    args = cmd_parser.parse_args()\n    for var in args.var:\n        (name, value) = var.split('=', 1)\n        if os.path.exists(value):\n            value = os.path.abspath(value)\n        VARS[name] = value\n    if 'MPY_DIR' not in VARS or 'PORT_DIR' not in VARS:\n        print('MPY_DIR and PORT_DIR variables must be specified')\n        sys.exit(1)\n    MPY_CROSS = VARS['MPY_DIR'] + '/mpy-cross/build/mpy-cross'\n    if sys.platform == 'win32':\n        MPY_CROSS += '.exe'\n    MPY_CROSS = os.getenv('MICROPY_MPYCROSS', MPY_CROSS)\n    MPY_TOOL = VARS['MPY_DIR'] + '/tools/mpy-tool.py'\n    if not os.path.exists(MPY_CROSS):\n        print('mpy-cross not found at {}, please build it first'.format(MPY_CROSS))\n        sys.exit(1)\n    manifest = manifestfile.ManifestFile(manifestfile.MODE_FREEZE, VARS)\n    for input_manifest in args.files:\n        try:\n            manifest.execute(input_manifest)\n        except manifestfile.ManifestFileError as er:\n            print('freeze error executing \"{}\": {}'.format(input_manifest, er.args[0]))\n            sys.exit(1)\n    str_paths = []\n    mpy_files = []\n    ts_newest = 0\n    for result in manifest.files():\n        if result.kind == manifestfile.KIND_FREEZE_AS_STR:\n            str_paths.append((result.full_path, result.target_path))\n            ts_outfile = result.timestamp\n        elif result.kind == manifestfile.KIND_FREEZE_AS_MPY:\n            outfile = '{}/frozen_mpy/{}.mpy'.format(args.build_dir, result.target_path[:-3])\n            ts_outfile = get_timestamp(outfile, 0)\n            if result.timestamp >= ts_outfile:\n                print('MPY', result.target_path)\n                mkdir(outfile)\n                with manifestfile.tagged_py_file(result.full_path, result.metadata) as tagged_path:\n                    try:\n                        mpy_cross.compile(tagged_path, dest=outfile, src_path=result.target_path, opt=result.opt, mpy_cross=MPY_CROSS, extra_args=args.mpy_cross_flags.split())\n                    except mpy_cross.CrossCompileError as ex:\n                        print('error compiling {}:'.format(result.target_path))\n                        print(ex.args[0])\n                        raise SystemExit(1)\n                ts_outfile = get_timestamp(outfile)\n            mpy_files.append(outfile)\n        else:\n            assert result.kind == manifestfile.KIND_FREEZE_MPY\n            mpy_files.append(result.full_path)\n            ts_outfile = result.timestamp\n        ts_newest = max(ts_newest, ts_outfile)\n    if ts_newest < get_timestamp(args.output, 0):\n        return\n    output_str = generate_frozen_str_content(str_paths)\n    if mpy_files:\n        (res, output_mpy) = system([sys.executable, MPY_TOOL, '-f', '-q', args.build_dir + '/genhdr/qstrdefs.preprocessed.h'] + args.mpy_tool_flags.split() + mpy_files)\n        if res != 0:\n            print('error freezing mpy {}:'.format(mpy_files))\n            print(output_mpy.decode())\n            sys.exit(1)\n    else:\n        output_mpy = b'#include \"py/emitglue.h\"\\nextern const qstr_pool_t mp_qstr_const_pool;\\nconst qstr_pool_t mp_qstr_frozen_const_pool = {\\n    (qstr_pool_t*)&mp_qstr_const_pool, MP_QSTRnumber_of, 0, 0\\n};\\nconst char mp_frozen_names[] = { MP_FROZEN_STR_NAMES \"\\\\0\"};\\nconst mp_raw_code_t *const mp_frozen_mpy_content[] = {NULL};\\n'\n    print('GEN', args.output)\n    mkdir(args.output)\n    with open(args.output, 'wb') as f:\n        f.write(b'//\\n// Content for MICROPY_MODULE_FROZEN_STR\\n//\\n')\n        f.write(output_str)\n        f.write(b'//\\n// Content for MICROPY_MODULE_FROZEN_MPY\\n//\\n')\n        f.write(output_mpy)",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    import argparse\n    cmd_parser = argparse.ArgumentParser(description='A tool to generate frozen content in MicroPython firmware images.')\n    cmd_parser.add_argument('-o', '--output', help='output path')\n    cmd_parser.add_argument('-b', '--build-dir', help='output path')\n    cmd_parser.add_argument('-f', '--mpy-cross-flags', default='', help='flags to pass to mpy-cross')\n    cmd_parser.add_argument('-v', '--var', action='append', help='variables to substitute')\n    cmd_parser.add_argument('--mpy-tool-flags', default='', help='flags to pass to mpy-tool')\n    cmd_parser.add_argument('files', nargs='+', help='input manifest list')\n    args = cmd_parser.parse_args()\n    for var in args.var:\n        (name, value) = var.split('=', 1)\n        if os.path.exists(value):\n            value = os.path.abspath(value)\n        VARS[name] = value\n    if 'MPY_DIR' not in VARS or 'PORT_DIR' not in VARS:\n        print('MPY_DIR and PORT_DIR variables must be specified')\n        sys.exit(1)\n    MPY_CROSS = VARS['MPY_DIR'] + '/mpy-cross/build/mpy-cross'\n    if sys.platform == 'win32':\n        MPY_CROSS += '.exe'\n    MPY_CROSS = os.getenv('MICROPY_MPYCROSS', MPY_CROSS)\n    MPY_TOOL = VARS['MPY_DIR'] + '/tools/mpy-tool.py'\n    if not os.path.exists(MPY_CROSS):\n        print('mpy-cross not found at {}, please build it first'.format(MPY_CROSS))\n        sys.exit(1)\n    manifest = manifestfile.ManifestFile(manifestfile.MODE_FREEZE, VARS)\n    for input_manifest in args.files:\n        try:\n            manifest.execute(input_manifest)\n        except manifestfile.ManifestFileError as er:\n            print('freeze error executing \"{}\": {}'.format(input_manifest, er.args[0]))\n            sys.exit(1)\n    str_paths = []\n    mpy_files = []\n    ts_newest = 0\n    for result in manifest.files():\n        if result.kind == manifestfile.KIND_FREEZE_AS_STR:\n            str_paths.append((result.full_path, result.target_path))\n            ts_outfile = result.timestamp\n        elif result.kind == manifestfile.KIND_FREEZE_AS_MPY:\n            outfile = '{}/frozen_mpy/{}.mpy'.format(args.build_dir, result.target_path[:-3])\n            ts_outfile = get_timestamp(outfile, 0)\n            if result.timestamp >= ts_outfile:\n                print('MPY', result.target_path)\n                mkdir(outfile)\n                with manifestfile.tagged_py_file(result.full_path, result.metadata) as tagged_path:\n                    try:\n                        mpy_cross.compile(tagged_path, dest=outfile, src_path=result.target_path, opt=result.opt, mpy_cross=MPY_CROSS, extra_args=args.mpy_cross_flags.split())\n                    except mpy_cross.CrossCompileError as ex:\n                        print('error compiling {}:'.format(result.target_path))\n                        print(ex.args[0])\n                        raise SystemExit(1)\n                ts_outfile = get_timestamp(outfile)\n            mpy_files.append(outfile)\n        else:\n            assert result.kind == manifestfile.KIND_FREEZE_MPY\n            mpy_files.append(result.full_path)\n            ts_outfile = result.timestamp\n        ts_newest = max(ts_newest, ts_outfile)\n    if ts_newest < get_timestamp(args.output, 0):\n        return\n    output_str = generate_frozen_str_content(str_paths)\n    if mpy_files:\n        (res, output_mpy) = system([sys.executable, MPY_TOOL, '-f', '-q', args.build_dir + '/genhdr/qstrdefs.preprocessed.h'] + args.mpy_tool_flags.split() + mpy_files)\n        if res != 0:\n            print('error freezing mpy {}:'.format(mpy_files))\n            print(output_mpy.decode())\n            sys.exit(1)\n    else:\n        output_mpy = b'#include \"py/emitglue.h\"\\nextern const qstr_pool_t mp_qstr_const_pool;\\nconst qstr_pool_t mp_qstr_frozen_const_pool = {\\n    (qstr_pool_t*)&mp_qstr_const_pool, MP_QSTRnumber_of, 0, 0\\n};\\nconst char mp_frozen_names[] = { MP_FROZEN_STR_NAMES \"\\\\0\"};\\nconst mp_raw_code_t *const mp_frozen_mpy_content[] = {NULL};\\n'\n    print('GEN', args.output)\n    mkdir(args.output)\n    with open(args.output, 'wb') as f:\n        f.write(b'//\\n// Content for MICROPY_MODULE_FROZEN_STR\\n//\\n')\n        f.write(output_str)\n        f.write(b'//\\n// Content for MICROPY_MODULE_FROZEN_MPY\\n//\\n')\n        f.write(output_mpy)",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    import argparse\n    cmd_parser = argparse.ArgumentParser(description='A tool to generate frozen content in MicroPython firmware images.')\n    cmd_parser.add_argument('-o', '--output', help='output path')\n    cmd_parser.add_argument('-b', '--build-dir', help='output path')\n    cmd_parser.add_argument('-f', '--mpy-cross-flags', default='', help='flags to pass to mpy-cross')\n    cmd_parser.add_argument('-v', '--var', action='append', help='variables to substitute')\n    cmd_parser.add_argument('--mpy-tool-flags', default='', help='flags to pass to mpy-tool')\n    cmd_parser.add_argument('files', nargs='+', help='input manifest list')\n    args = cmd_parser.parse_args()\n    for var in args.var:\n        (name, value) = var.split('=', 1)\n        if os.path.exists(value):\n            value = os.path.abspath(value)\n        VARS[name] = value\n    if 'MPY_DIR' not in VARS or 'PORT_DIR' not in VARS:\n        print('MPY_DIR and PORT_DIR variables must be specified')\n        sys.exit(1)\n    MPY_CROSS = VARS['MPY_DIR'] + '/mpy-cross/build/mpy-cross'\n    if sys.platform == 'win32':\n        MPY_CROSS += '.exe'\n    MPY_CROSS = os.getenv('MICROPY_MPYCROSS', MPY_CROSS)\n    MPY_TOOL = VARS['MPY_DIR'] + '/tools/mpy-tool.py'\n    if not os.path.exists(MPY_CROSS):\n        print('mpy-cross not found at {}, please build it first'.format(MPY_CROSS))\n        sys.exit(1)\n    manifest = manifestfile.ManifestFile(manifestfile.MODE_FREEZE, VARS)\n    for input_manifest in args.files:\n        try:\n            manifest.execute(input_manifest)\n        except manifestfile.ManifestFileError as er:\n            print('freeze error executing \"{}\": {}'.format(input_manifest, er.args[0]))\n            sys.exit(1)\n    str_paths = []\n    mpy_files = []\n    ts_newest = 0\n    for result in manifest.files():\n        if result.kind == manifestfile.KIND_FREEZE_AS_STR:\n            str_paths.append((result.full_path, result.target_path))\n            ts_outfile = result.timestamp\n        elif result.kind == manifestfile.KIND_FREEZE_AS_MPY:\n            outfile = '{}/frozen_mpy/{}.mpy'.format(args.build_dir, result.target_path[:-3])\n            ts_outfile = get_timestamp(outfile, 0)\n            if result.timestamp >= ts_outfile:\n                print('MPY', result.target_path)\n                mkdir(outfile)\n                with manifestfile.tagged_py_file(result.full_path, result.metadata) as tagged_path:\n                    try:\n                        mpy_cross.compile(tagged_path, dest=outfile, src_path=result.target_path, opt=result.opt, mpy_cross=MPY_CROSS, extra_args=args.mpy_cross_flags.split())\n                    except mpy_cross.CrossCompileError as ex:\n                        print('error compiling {}:'.format(result.target_path))\n                        print(ex.args[0])\n                        raise SystemExit(1)\n                ts_outfile = get_timestamp(outfile)\n            mpy_files.append(outfile)\n        else:\n            assert result.kind == manifestfile.KIND_FREEZE_MPY\n            mpy_files.append(result.full_path)\n            ts_outfile = result.timestamp\n        ts_newest = max(ts_newest, ts_outfile)\n    if ts_newest < get_timestamp(args.output, 0):\n        return\n    output_str = generate_frozen_str_content(str_paths)\n    if mpy_files:\n        (res, output_mpy) = system([sys.executable, MPY_TOOL, '-f', '-q', args.build_dir + '/genhdr/qstrdefs.preprocessed.h'] + args.mpy_tool_flags.split() + mpy_files)\n        if res != 0:\n            print('error freezing mpy {}:'.format(mpy_files))\n            print(output_mpy.decode())\n            sys.exit(1)\n    else:\n        output_mpy = b'#include \"py/emitglue.h\"\\nextern const qstr_pool_t mp_qstr_const_pool;\\nconst qstr_pool_t mp_qstr_frozen_const_pool = {\\n    (qstr_pool_t*)&mp_qstr_const_pool, MP_QSTRnumber_of, 0, 0\\n};\\nconst char mp_frozen_names[] = { MP_FROZEN_STR_NAMES \"\\\\0\"};\\nconst mp_raw_code_t *const mp_frozen_mpy_content[] = {NULL};\\n'\n    print('GEN', args.output)\n    mkdir(args.output)\n    with open(args.output, 'wb') as f:\n        f.write(b'//\\n// Content for MICROPY_MODULE_FROZEN_STR\\n//\\n')\n        f.write(output_str)\n        f.write(b'//\\n// Content for MICROPY_MODULE_FROZEN_MPY\\n//\\n')\n        f.write(output_mpy)",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    import argparse\n    cmd_parser = argparse.ArgumentParser(description='A tool to generate frozen content in MicroPython firmware images.')\n    cmd_parser.add_argument('-o', '--output', help='output path')\n    cmd_parser.add_argument('-b', '--build-dir', help='output path')\n    cmd_parser.add_argument('-f', '--mpy-cross-flags', default='', help='flags to pass to mpy-cross')\n    cmd_parser.add_argument('-v', '--var', action='append', help='variables to substitute')\n    cmd_parser.add_argument('--mpy-tool-flags', default='', help='flags to pass to mpy-tool')\n    cmd_parser.add_argument('files', nargs='+', help='input manifest list')\n    args = cmd_parser.parse_args()\n    for var in args.var:\n        (name, value) = var.split('=', 1)\n        if os.path.exists(value):\n            value = os.path.abspath(value)\n        VARS[name] = value\n    if 'MPY_DIR' not in VARS or 'PORT_DIR' not in VARS:\n        print('MPY_DIR and PORT_DIR variables must be specified')\n        sys.exit(1)\n    MPY_CROSS = VARS['MPY_DIR'] + '/mpy-cross/build/mpy-cross'\n    if sys.platform == 'win32':\n        MPY_CROSS += '.exe'\n    MPY_CROSS = os.getenv('MICROPY_MPYCROSS', MPY_CROSS)\n    MPY_TOOL = VARS['MPY_DIR'] + '/tools/mpy-tool.py'\n    if not os.path.exists(MPY_CROSS):\n        print('mpy-cross not found at {}, please build it first'.format(MPY_CROSS))\n        sys.exit(1)\n    manifest = manifestfile.ManifestFile(manifestfile.MODE_FREEZE, VARS)\n    for input_manifest in args.files:\n        try:\n            manifest.execute(input_manifest)\n        except manifestfile.ManifestFileError as er:\n            print('freeze error executing \"{}\": {}'.format(input_manifest, er.args[0]))\n            sys.exit(1)\n    str_paths = []\n    mpy_files = []\n    ts_newest = 0\n    for result in manifest.files():\n        if result.kind == manifestfile.KIND_FREEZE_AS_STR:\n            str_paths.append((result.full_path, result.target_path))\n            ts_outfile = result.timestamp\n        elif result.kind == manifestfile.KIND_FREEZE_AS_MPY:\n            outfile = '{}/frozen_mpy/{}.mpy'.format(args.build_dir, result.target_path[:-3])\n            ts_outfile = get_timestamp(outfile, 0)\n            if result.timestamp >= ts_outfile:\n                print('MPY', result.target_path)\n                mkdir(outfile)\n                with manifestfile.tagged_py_file(result.full_path, result.metadata) as tagged_path:\n                    try:\n                        mpy_cross.compile(tagged_path, dest=outfile, src_path=result.target_path, opt=result.opt, mpy_cross=MPY_CROSS, extra_args=args.mpy_cross_flags.split())\n                    except mpy_cross.CrossCompileError as ex:\n                        print('error compiling {}:'.format(result.target_path))\n                        print(ex.args[0])\n                        raise SystemExit(1)\n                ts_outfile = get_timestamp(outfile)\n            mpy_files.append(outfile)\n        else:\n            assert result.kind == manifestfile.KIND_FREEZE_MPY\n            mpy_files.append(result.full_path)\n            ts_outfile = result.timestamp\n        ts_newest = max(ts_newest, ts_outfile)\n    if ts_newest < get_timestamp(args.output, 0):\n        return\n    output_str = generate_frozen_str_content(str_paths)\n    if mpy_files:\n        (res, output_mpy) = system([sys.executable, MPY_TOOL, '-f', '-q', args.build_dir + '/genhdr/qstrdefs.preprocessed.h'] + args.mpy_tool_flags.split() + mpy_files)\n        if res != 0:\n            print('error freezing mpy {}:'.format(mpy_files))\n            print(output_mpy.decode())\n            sys.exit(1)\n    else:\n        output_mpy = b'#include \"py/emitglue.h\"\\nextern const qstr_pool_t mp_qstr_const_pool;\\nconst qstr_pool_t mp_qstr_frozen_const_pool = {\\n    (qstr_pool_t*)&mp_qstr_const_pool, MP_QSTRnumber_of, 0, 0\\n};\\nconst char mp_frozen_names[] = { MP_FROZEN_STR_NAMES \"\\\\0\"};\\nconst mp_raw_code_t *const mp_frozen_mpy_content[] = {NULL};\\n'\n    print('GEN', args.output)\n    mkdir(args.output)\n    with open(args.output, 'wb') as f:\n        f.write(b'//\\n// Content for MICROPY_MODULE_FROZEN_STR\\n//\\n')\n        f.write(output_str)\n        f.write(b'//\\n// Content for MICROPY_MODULE_FROZEN_MPY\\n//\\n')\n        f.write(output_mpy)"
        ]
    }
]