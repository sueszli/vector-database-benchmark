[
    {
        "func_name": "setUp",
        "original": "def setUp(self):\n    self.prices = np.array([0.42919881, 0.98046542, 0.59045074, 1.34909391, 0.79491583, 1.81768802, 0.93210461, 2.13625342, 1.05114573, 2.40921088, 1.12941064, 2.58857507, 1.37029637, 3.15081683])\n    self.expiries = np.array([0.5, 0.5, 1.0, 1.0, 2.0, 2.0, 3.0, 3.0, 4.0, 4.0, 5.0, 5.0, 10.0, 10.0])\n    self.float_leg_start_times = np.array([[0.5, 1.0, 1.5, 2.0, 2.5, 2.5, 2.5, 2.5, 2.5, 2.5], [0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0], [1.0, 1.5, 2.0, 2.5, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0], [1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 5.5], [2.0, 2.5, 3.0, 3.5, 4.0, 4.0, 4.0, 4.0, 4.0, 4.0], [2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 5.5, 6.0, 6.5], [3.0, 3.5, 4.0, 4.5, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0], [3.0, 3.5, 4.0, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5], [4.0, 4.5, 5.0, 5.5, 6.0, 6.0, 6.0, 6.0, 6.0, 6.0], [4.0, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0, 8.5], [5.0, 5.5, 6.0, 6.5, 7.0, 7.0, 7.0, 7.0, 7.0, 7.0], [5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0, 8.5, 9.0, 9.5], [10.0, 10.5, 11.0, 11.5, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0], [10.0, 10.5, 11.0, 11.5, 12.0, 12.5, 13.0, 13.5, 14.0, 14.5]])\n    self.float_leg_end_times = self.float_leg_start_times + 0.5\n    max_maturities = np.array([2.5, 5.5, 3.0, 6.0, 4.0, 7.0, 5.0, 8.0, 6.0, 9.0, 7.0, 10.0, 12.0, 15.0])\n    for i in range(self.float_leg_end_times.shape[0]):\n        self.float_leg_end_times[i] = np.clip(self.float_leg_end_times[i], 0.0, max_maturities[i])\n    self.fixed_leg_payment_times = self.float_leg_end_times\n    self.float_leg_daycount_fractions = self.float_leg_end_times - self.float_leg_start_times\n    self.fixed_leg_daycount_fractions = self.float_leg_daycount_fractions\n    self.fixed_leg_coupon = 0.01 * np.ones_like(self.fixed_leg_payment_times)\n    super(HJMCalibrationTest, self).setUp()",
        "mutated": [
            "def setUp(self):\n    if False:\n        i = 10\n    self.prices = np.array([0.42919881, 0.98046542, 0.59045074, 1.34909391, 0.79491583, 1.81768802, 0.93210461, 2.13625342, 1.05114573, 2.40921088, 1.12941064, 2.58857507, 1.37029637, 3.15081683])\n    self.expiries = np.array([0.5, 0.5, 1.0, 1.0, 2.0, 2.0, 3.0, 3.0, 4.0, 4.0, 5.0, 5.0, 10.0, 10.0])\n    self.float_leg_start_times = np.array([[0.5, 1.0, 1.5, 2.0, 2.5, 2.5, 2.5, 2.5, 2.5, 2.5], [0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0], [1.0, 1.5, 2.0, 2.5, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0], [1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 5.5], [2.0, 2.5, 3.0, 3.5, 4.0, 4.0, 4.0, 4.0, 4.0, 4.0], [2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 5.5, 6.0, 6.5], [3.0, 3.5, 4.0, 4.5, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0], [3.0, 3.5, 4.0, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5], [4.0, 4.5, 5.0, 5.5, 6.0, 6.0, 6.0, 6.0, 6.0, 6.0], [4.0, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0, 8.5], [5.0, 5.5, 6.0, 6.5, 7.0, 7.0, 7.0, 7.0, 7.0, 7.0], [5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0, 8.5, 9.0, 9.5], [10.0, 10.5, 11.0, 11.5, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0], [10.0, 10.5, 11.0, 11.5, 12.0, 12.5, 13.0, 13.5, 14.0, 14.5]])\n    self.float_leg_end_times = self.float_leg_start_times + 0.5\n    max_maturities = np.array([2.5, 5.5, 3.0, 6.0, 4.0, 7.0, 5.0, 8.0, 6.0, 9.0, 7.0, 10.0, 12.0, 15.0])\n    for i in range(self.float_leg_end_times.shape[0]):\n        self.float_leg_end_times[i] = np.clip(self.float_leg_end_times[i], 0.0, max_maturities[i])\n    self.fixed_leg_payment_times = self.float_leg_end_times\n    self.float_leg_daycount_fractions = self.float_leg_end_times - self.float_leg_start_times\n    self.fixed_leg_daycount_fractions = self.float_leg_daycount_fractions\n    self.fixed_leg_coupon = 0.01 * np.ones_like(self.fixed_leg_payment_times)\n    super(HJMCalibrationTest, self).setUp()",
            "def setUp(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.prices = np.array([0.42919881, 0.98046542, 0.59045074, 1.34909391, 0.79491583, 1.81768802, 0.93210461, 2.13625342, 1.05114573, 2.40921088, 1.12941064, 2.58857507, 1.37029637, 3.15081683])\n    self.expiries = np.array([0.5, 0.5, 1.0, 1.0, 2.0, 2.0, 3.0, 3.0, 4.0, 4.0, 5.0, 5.0, 10.0, 10.0])\n    self.float_leg_start_times = np.array([[0.5, 1.0, 1.5, 2.0, 2.5, 2.5, 2.5, 2.5, 2.5, 2.5], [0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0], [1.0, 1.5, 2.0, 2.5, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0], [1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 5.5], [2.0, 2.5, 3.0, 3.5, 4.0, 4.0, 4.0, 4.0, 4.0, 4.0], [2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 5.5, 6.0, 6.5], [3.0, 3.5, 4.0, 4.5, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0], [3.0, 3.5, 4.0, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5], [4.0, 4.5, 5.0, 5.5, 6.0, 6.0, 6.0, 6.0, 6.0, 6.0], [4.0, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0, 8.5], [5.0, 5.5, 6.0, 6.5, 7.0, 7.0, 7.0, 7.0, 7.0, 7.0], [5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0, 8.5, 9.0, 9.5], [10.0, 10.5, 11.0, 11.5, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0], [10.0, 10.5, 11.0, 11.5, 12.0, 12.5, 13.0, 13.5, 14.0, 14.5]])\n    self.float_leg_end_times = self.float_leg_start_times + 0.5\n    max_maturities = np.array([2.5, 5.5, 3.0, 6.0, 4.0, 7.0, 5.0, 8.0, 6.0, 9.0, 7.0, 10.0, 12.0, 15.0])\n    for i in range(self.float_leg_end_times.shape[0]):\n        self.float_leg_end_times[i] = np.clip(self.float_leg_end_times[i], 0.0, max_maturities[i])\n    self.fixed_leg_payment_times = self.float_leg_end_times\n    self.float_leg_daycount_fractions = self.float_leg_end_times - self.float_leg_start_times\n    self.fixed_leg_daycount_fractions = self.float_leg_daycount_fractions\n    self.fixed_leg_coupon = 0.01 * np.ones_like(self.fixed_leg_payment_times)\n    super(HJMCalibrationTest, self).setUp()",
            "def setUp(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.prices = np.array([0.42919881, 0.98046542, 0.59045074, 1.34909391, 0.79491583, 1.81768802, 0.93210461, 2.13625342, 1.05114573, 2.40921088, 1.12941064, 2.58857507, 1.37029637, 3.15081683])\n    self.expiries = np.array([0.5, 0.5, 1.0, 1.0, 2.0, 2.0, 3.0, 3.0, 4.0, 4.0, 5.0, 5.0, 10.0, 10.0])\n    self.float_leg_start_times = np.array([[0.5, 1.0, 1.5, 2.0, 2.5, 2.5, 2.5, 2.5, 2.5, 2.5], [0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0], [1.0, 1.5, 2.0, 2.5, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0], [1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 5.5], [2.0, 2.5, 3.0, 3.5, 4.0, 4.0, 4.0, 4.0, 4.0, 4.0], [2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 5.5, 6.0, 6.5], [3.0, 3.5, 4.0, 4.5, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0], [3.0, 3.5, 4.0, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5], [4.0, 4.5, 5.0, 5.5, 6.0, 6.0, 6.0, 6.0, 6.0, 6.0], [4.0, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0, 8.5], [5.0, 5.5, 6.0, 6.5, 7.0, 7.0, 7.0, 7.0, 7.0, 7.0], [5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0, 8.5, 9.0, 9.5], [10.0, 10.5, 11.0, 11.5, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0], [10.0, 10.5, 11.0, 11.5, 12.0, 12.5, 13.0, 13.5, 14.0, 14.5]])\n    self.float_leg_end_times = self.float_leg_start_times + 0.5\n    max_maturities = np.array([2.5, 5.5, 3.0, 6.0, 4.0, 7.0, 5.0, 8.0, 6.0, 9.0, 7.0, 10.0, 12.0, 15.0])\n    for i in range(self.float_leg_end_times.shape[0]):\n        self.float_leg_end_times[i] = np.clip(self.float_leg_end_times[i], 0.0, max_maturities[i])\n    self.fixed_leg_payment_times = self.float_leg_end_times\n    self.float_leg_daycount_fractions = self.float_leg_end_times - self.float_leg_start_times\n    self.fixed_leg_daycount_fractions = self.float_leg_daycount_fractions\n    self.fixed_leg_coupon = 0.01 * np.ones_like(self.fixed_leg_payment_times)\n    super(HJMCalibrationTest, self).setUp()",
            "def setUp(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.prices = np.array([0.42919881, 0.98046542, 0.59045074, 1.34909391, 0.79491583, 1.81768802, 0.93210461, 2.13625342, 1.05114573, 2.40921088, 1.12941064, 2.58857507, 1.37029637, 3.15081683])\n    self.expiries = np.array([0.5, 0.5, 1.0, 1.0, 2.0, 2.0, 3.0, 3.0, 4.0, 4.0, 5.0, 5.0, 10.0, 10.0])\n    self.float_leg_start_times = np.array([[0.5, 1.0, 1.5, 2.0, 2.5, 2.5, 2.5, 2.5, 2.5, 2.5], [0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0], [1.0, 1.5, 2.0, 2.5, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0], [1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 5.5], [2.0, 2.5, 3.0, 3.5, 4.0, 4.0, 4.0, 4.0, 4.0, 4.0], [2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 5.5, 6.0, 6.5], [3.0, 3.5, 4.0, 4.5, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0], [3.0, 3.5, 4.0, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5], [4.0, 4.5, 5.0, 5.5, 6.0, 6.0, 6.0, 6.0, 6.0, 6.0], [4.0, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0, 8.5], [5.0, 5.5, 6.0, 6.5, 7.0, 7.0, 7.0, 7.0, 7.0, 7.0], [5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0, 8.5, 9.0, 9.5], [10.0, 10.5, 11.0, 11.5, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0], [10.0, 10.5, 11.0, 11.5, 12.0, 12.5, 13.0, 13.5, 14.0, 14.5]])\n    self.float_leg_end_times = self.float_leg_start_times + 0.5\n    max_maturities = np.array([2.5, 5.5, 3.0, 6.0, 4.0, 7.0, 5.0, 8.0, 6.0, 9.0, 7.0, 10.0, 12.0, 15.0])\n    for i in range(self.float_leg_end_times.shape[0]):\n        self.float_leg_end_times[i] = np.clip(self.float_leg_end_times[i], 0.0, max_maturities[i])\n    self.fixed_leg_payment_times = self.float_leg_end_times\n    self.float_leg_daycount_fractions = self.float_leg_end_times - self.float_leg_start_times\n    self.fixed_leg_daycount_fractions = self.float_leg_daycount_fractions\n    self.fixed_leg_coupon = 0.01 * np.ones_like(self.fixed_leg_payment_times)\n    super(HJMCalibrationTest, self).setUp()",
            "def setUp(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.prices = np.array([0.42919881, 0.98046542, 0.59045074, 1.34909391, 0.79491583, 1.81768802, 0.93210461, 2.13625342, 1.05114573, 2.40921088, 1.12941064, 2.58857507, 1.37029637, 3.15081683])\n    self.expiries = np.array([0.5, 0.5, 1.0, 1.0, 2.0, 2.0, 3.0, 3.0, 4.0, 4.0, 5.0, 5.0, 10.0, 10.0])\n    self.float_leg_start_times = np.array([[0.5, 1.0, 1.5, 2.0, 2.5, 2.5, 2.5, 2.5, 2.5, 2.5], [0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0], [1.0, 1.5, 2.0, 2.5, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0], [1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 5.5], [2.0, 2.5, 3.0, 3.5, 4.0, 4.0, 4.0, 4.0, 4.0, 4.0], [2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 5.5, 6.0, 6.5], [3.0, 3.5, 4.0, 4.5, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0], [3.0, 3.5, 4.0, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5], [4.0, 4.5, 5.0, 5.5, 6.0, 6.0, 6.0, 6.0, 6.0, 6.0], [4.0, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0, 8.5], [5.0, 5.5, 6.0, 6.5, 7.0, 7.0, 7.0, 7.0, 7.0, 7.0], [5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0, 8.5, 9.0, 9.5], [10.0, 10.5, 11.0, 11.5, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0], [10.0, 10.5, 11.0, 11.5, 12.0, 12.5, 13.0, 13.5, 14.0, 14.5]])\n    self.float_leg_end_times = self.float_leg_start_times + 0.5\n    max_maturities = np.array([2.5, 5.5, 3.0, 6.0, 4.0, 7.0, 5.0, 8.0, 6.0, 9.0, 7.0, 10.0, 12.0, 15.0])\n    for i in range(self.float_leg_end_times.shape[0]):\n        self.float_leg_end_times[i] = np.clip(self.float_leg_end_times[i], 0.0, max_maturities[i])\n    self.fixed_leg_payment_times = self.float_leg_end_times\n    self.float_leg_daycount_fractions = self.float_leg_end_times - self.float_leg_start_times\n    self.fixed_leg_daycount_fractions = self.float_leg_daycount_fractions\n    self.fixed_leg_coupon = 0.01 * np.ones_like(self.fixed_leg_payment_times)\n    super(HJMCalibrationTest, self).setUp()"
        ]
    },
    {
        "func_name": "_fn",
        "original": "def _fn():\n    ((calib_mr, calib_vol, calib_corr), _, _) = tff.models.hjm.calibration_from_swaptions(prices=self.prices[:num_instruments], expiries=self.expiries[:num_instruments], floating_leg_start_times=self.float_leg_start_times[:num_instruments, :], floating_leg_end_times=self.float_leg_end_times[:num_instruments, :], fixed_leg_payment_times=self.fixed_leg_payment_times[:num_instruments, :], floating_leg_daycount_fractions=self.float_leg_daycount_fractions[:num_instruments, :], fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions[:num_instruments, :], fixed_leg_coupon=self.fixed_leg_coupon[:num_instruments, :], reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=num_hjm_factors, mean_reversion=mr0, volatility=vol0, optimizer_fn=optimizer_fn, volatility_based_calibration=vol_based_calib, swaption_valuation_method=valuation_method, num_samples=num_samples, random_type=random_type, seed=seed, time_step=time_step, num_time_steps=num_time_steps, times=times, curve_times=curve_times, time_step_finite_difference=time_step, num_grid_points_finite_difference=41, maximum_iterations=max_iter, dtype=dtype)\n    return (calib_mr, calib_vol, calib_corr)",
        "mutated": [
            "def _fn():\n    if False:\n        i = 10\n    ((calib_mr, calib_vol, calib_corr), _, _) = tff.models.hjm.calibration_from_swaptions(prices=self.prices[:num_instruments], expiries=self.expiries[:num_instruments], floating_leg_start_times=self.float_leg_start_times[:num_instruments, :], floating_leg_end_times=self.float_leg_end_times[:num_instruments, :], fixed_leg_payment_times=self.fixed_leg_payment_times[:num_instruments, :], floating_leg_daycount_fractions=self.float_leg_daycount_fractions[:num_instruments, :], fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions[:num_instruments, :], fixed_leg_coupon=self.fixed_leg_coupon[:num_instruments, :], reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=num_hjm_factors, mean_reversion=mr0, volatility=vol0, optimizer_fn=optimizer_fn, volatility_based_calibration=vol_based_calib, swaption_valuation_method=valuation_method, num_samples=num_samples, random_type=random_type, seed=seed, time_step=time_step, num_time_steps=num_time_steps, times=times, curve_times=curve_times, time_step_finite_difference=time_step, num_grid_points_finite_difference=41, maximum_iterations=max_iter, dtype=dtype)\n    return (calib_mr, calib_vol, calib_corr)",
            "def _fn():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ((calib_mr, calib_vol, calib_corr), _, _) = tff.models.hjm.calibration_from_swaptions(prices=self.prices[:num_instruments], expiries=self.expiries[:num_instruments], floating_leg_start_times=self.float_leg_start_times[:num_instruments, :], floating_leg_end_times=self.float_leg_end_times[:num_instruments, :], fixed_leg_payment_times=self.fixed_leg_payment_times[:num_instruments, :], floating_leg_daycount_fractions=self.float_leg_daycount_fractions[:num_instruments, :], fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions[:num_instruments, :], fixed_leg_coupon=self.fixed_leg_coupon[:num_instruments, :], reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=num_hjm_factors, mean_reversion=mr0, volatility=vol0, optimizer_fn=optimizer_fn, volatility_based_calibration=vol_based_calib, swaption_valuation_method=valuation_method, num_samples=num_samples, random_type=random_type, seed=seed, time_step=time_step, num_time_steps=num_time_steps, times=times, curve_times=curve_times, time_step_finite_difference=time_step, num_grid_points_finite_difference=41, maximum_iterations=max_iter, dtype=dtype)\n    return (calib_mr, calib_vol, calib_corr)",
            "def _fn():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ((calib_mr, calib_vol, calib_corr), _, _) = tff.models.hjm.calibration_from_swaptions(prices=self.prices[:num_instruments], expiries=self.expiries[:num_instruments], floating_leg_start_times=self.float_leg_start_times[:num_instruments, :], floating_leg_end_times=self.float_leg_end_times[:num_instruments, :], fixed_leg_payment_times=self.fixed_leg_payment_times[:num_instruments, :], floating_leg_daycount_fractions=self.float_leg_daycount_fractions[:num_instruments, :], fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions[:num_instruments, :], fixed_leg_coupon=self.fixed_leg_coupon[:num_instruments, :], reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=num_hjm_factors, mean_reversion=mr0, volatility=vol0, optimizer_fn=optimizer_fn, volatility_based_calibration=vol_based_calib, swaption_valuation_method=valuation_method, num_samples=num_samples, random_type=random_type, seed=seed, time_step=time_step, num_time_steps=num_time_steps, times=times, curve_times=curve_times, time_step_finite_difference=time_step, num_grid_points_finite_difference=41, maximum_iterations=max_iter, dtype=dtype)\n    return (calib_mr, calib_vol, calib_corr)",
            "def _fn():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ((calib_mr, calib_vol, calib_corr), _, _) = tff.models.hjm.calibration_from_swaptions(prices=self.prices[:num_instruments], expiries=self.expiries[:num_instruments], floating_leg_start_times=self.float_leg_start_times[:num_instruments, :], floating_leg_end_times=self.float_leg_end_times[:num_instruments, :], fixed_leg_payment_times=self.fixed_leg_payment_times[:num_instruments, :], floating_leg_daycount_fractions=self.float_leg_daycount_fractions[:num_instruments, :], fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions[:num_instruments, :], fixed_leg_coupon=self.fixed_leg_coupon[:num_instruments, :], reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=num_hjm_factors, mean_reversion=mr0, volatility=vol0, optimizer_fn=optimizer_fn, volatility_based_calibration=vol_based_calib, swaption_valuation_method=valuation_method, num_samples=num_samples, random_type=random_type, seed=seed, time_step=time_step, num_time_steps=num_time_steps, times=times, curve_times=curve_times, time_step_finite_difference=time_step, num_grid_points_finite_difference=41, maximum_iterations=max_iter, dtype=dtype)\n    return (calib_mr, calib_vol, calib_corr)",
            "def _fn():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ((calib_mr, calib_vol, calib_corr), _, _) = tff.models.hjm.calibration_from_swaptions(prices=self.prices[:num_instruments], expiries=self.expiries[:num_instruments], floating_leg_start_times=self.float_leg_start_times[:num_instruments, :], floating_leg_end_times=self.float_leg_end_times[:num_instruments, :], fixed_leg_payment_times=self.fixed_leg_payment_times[:num_instruments, :], floating_leg_daycount_fractions=self.float_leg_daycount_fractions[:num_instruments, :], fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions[:num_instruments, :], fixed_leg_coupon=self.fixed_leg_coupon[:num_instruments, :], reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=num_hjm_factors, mean_reversion=mr0, volatility=vol0, optimizer_fn=optimizer_fn, volatility_based_calibration=vol_based_calib, swaption_valuation_method=valuation_method, num_samples=num_samples, random_type=random_type, seed=seed, time_step=time_step, num_time_steps=num_time_steps, times=times, curve_times=curve_times, time_step_finite_difference=time_step, num_grid_points_finite_difference=41, maximum_iterations=max_iter, dtype=dtype)\n    return (calib_mr, calib_vol, calib_corr)"
        ]
    },
    {
        "func_name": "test_calibration",
        "original": "@parameterized.named_parameters({'testcase_name': 'two_factor_price', 'optimizer_fn': None, 'vol_based_calib': False, 'num_hjm_factors': 2, 'time_step': 0.25, 'num_time_steps': None, 'num_instruments': 14, 'max_iter': 10}, {'testcase_name': 'two_factor_vol', 'optimizer_fn': None, 'vol_based_calib': True, 'num_hjm_factors': 2, 'time_step': 0.25, 'num_time_steps': None, 'num_instruments': 14, 'max_iter': 10}, {'testcase_name': 'two_factor_bfgs', 'optimizer_fn': tfp.optimizer.bfgs_minimize, 'vol_based_calib': False, 'num_hjm_factors': 2, 'time_step': 0.25, 'num_time_steps': None, 'num_instruments': 14, 'max_iter': 10}, {'testcase_name': 'three_factor_price', 'optimizer_fn': None, 'vol_based_calib': False, 'num_hjm_factors': 3, 'time_step': 0.25, 'num_time_steps': None, 'num_instruments': 14, 'max_iter': 10}, {'testcase_name': 'three_factor_vol', 'optimizer_fn': None, 'vol_based_calib': True, 'num_hjm_factors': 3, 'time_step': 0.25, 'num_time_steps': None, 'num_instruments': 14, 'max_iter': 10})\ndef test_calibration(self, optimizer_fn, vol_based_calib, num_hjm_factors, time_step, num_time_steps, num_instruments, max_iter):\n    \"\"\"Tests calibration with constant parameters.\"\"\"\n    dtype = tf.float64\n    mr0 = [0.01, 0.05]\n    if num_hjm_factors == 3:\n        mr0 = [0.01, 0.05, 0.1]\n    vol0 = [0.005, 0.007]\n    if num_hjm_factors == 3:\n        vol0 = [0.002, 0.003, 0.008]\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    times = np.unique(np.reshape(self.expiries[:num_instruments], [-1]))\n    curve_times = None\n    random_type = tff.math.random.RandomType.STATELESS_ANTITHETIC\n    seed = [0, 0]\n    num_samples = 500\n    valuation_method = tff.models.ValuationMethod.MONTE_CARLO\n\n    def _fn():\n        ((calib_mr, calib_vol, calib_corr), _, _) = tff.models.hjm.calibration_from_swaptions(prices=self.prices[:num_instruments], expiries=self.expiries[:num_instruments], floating_leg_start_times=self.float_leg_start_times[:num_instruments, :], floating_leg_end_times=self.float_leg_end_times[:num_instruments, :], fixed_leg_payment_times=self.fixed_leg_payment_times[:num_instruments, :], floating_leg_daycount_fractions=self.float_leg_daycount_fractions[:num_instruments, :], fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions[:num_instruments, :], fixed_leg_coupon=self.fixed_leg_coupon[:num_instruments, :], reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=num_hjm_factors, mean_reversion=mr0, volatility=vol0, optimizer_fn=optimizer_fn, volatility_based_calibration=vol_based_calib, swaption_valuation_method=valuation_method, num_samples=num_samples, random_type=random_type, seed=seed, time_step=time_step, num_time_steps=num_time_steps, times=times, curve_times=curve_times, time_step_finite_difference=time_step, num_grid_points_finite_difference=41, maximum_iterations=max_iter, dtype=dtype)\n        return (calib_mr, calib_vol, calib_corr)\n    (calib_mr, calib_vol, calib_corr) = self.evaluate(_fn())\n    prices = tff.models.hjm.swaption_price(expiries=self.expiries[:num_instruments], fixed_leg_payment_times=self.fixed_leg_payment_times[:num_instruments, :], fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions[:num_instruments, :], fixed_leg_coupon=self.fixed_leg_coupon[:num_instruments, :], reference_rate_fn=zero_rate_fn, num_hjm_factors=num_hjm_factors, notional=100.0, mean_reversion=calib_mr, volatility=calib_vol, corr_matrix=calib_corr, num_samples=num_samples, random_type=random_type, seed=seed, time_step=time_step, num_time_steps=num_time_steps, times=times, curve_times=curve_times, time_step_finite_difference=time_step, num_grid_points_finite_difference=101, valuation_method=valuation_method, dtype=dtype)\n    prices = self.evaluate(prices)\n    self.assertAllClose(prices, self.prices[:num_instruments], rtol=0.1, atol=0.1)",
        "mutated": [
            "@parameterized.named_parameters({'testcase_name': 'two_factor_price', 'optimizer_fn': None, 'vol_based_calib': False, 'num_hjm_factors': 2, 'time_step': 0.25, 'num_time_steps': None, 'num_instruments': 14, 'max_iter': 10}, {'testcase_name': 'two_factor_vol', 'optimizer_fn': None, 'vol_based_calib': True, 'num_hjm_factors': 2, 'time_step': 0.25, 'num_time_steps': None, 'num_instruments': 14, 'max_iter': 10}, {'testcase_name': 'two_factor_bfgs', 'optimizer_fn': tfp.optimizer.bfgs_minimize, 'vol_based_calib': False, 'num_hjm_factors': 2, 'time_step': 0.25, 'num_time_steps': None, 'num_instruments': 14, 'max_iter': 10}, {'testcase_name': 'three_factor_price', 'optimizer_fn': None, 'vol_based_calib': False, 'num_hjm_factors': 3, 'time_step': 0.25, 'num_time_steps': None, 'num_instruments': 14, 'max_iter': 10}, {'testcase_name': 'three_factor_vol', 'optimizer_fn': None, 'vol_based_calib': True, 'num_hjm_factors': 3, 'time_step': 0.25, 'num_time_steps': None, 'num_instruments': 14, 'max_iter': 10})\ndef test_calibration(self, optimizer_fn, vol_based_calib, num_hjm_factors, time_step, num_time_steps, num_instruments, max_iter):\n    if False:\n        i = 10\n    'Tests calibration with constant parameters.'\n    dtype = tf.float64\n    mr0 = [0.01, 0.05]\n    if num_hjm_factors == 3:\n        mr0 = [0.01, 0.05, 0.1]\n    vol0 = [0.005, 0.007]\n    if num_hjm_factors == 3:\n        vol0 = [0.002, 0.003, 0.008]\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    times = np.unique(np.reshape(self.expiries[:num_instruments], [-1]))\n    curve_times = None\n    random_type = tff.math.random.RandomType.STATELESS_ANTITHETIC\n    seed = [0, 0]\n    num_samples = 500\n    valuation_method = tff.models.ValuationMethod.MONTE_CARLO\n\n    def _fn():\n        ((calib_mr, calib_vol, calib_corr), _, _) = tff.models.hjm.calibration_from_swaptions(prices=self.prices[:num_instruments], expiries=self.expiries[:num_instruments], floating_leg_start_times=self.float_leg_start_times[:num_instruments, :], floating_leg_end_times=self.float_leg_end_times[:num_instruments, :], fixed_leg_payment_times=self.fixed_leg_payment_times[:num_instruments, :], floating_leg_daycount_fractions=self.float_leg_daycount_fractions[:num_instruments, :], fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions[:num_instruments, :], fixed_leg_coupon=self.fixed_leg_coupon[:num_instruments, :], reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=num_hjm_factors, mean_reversion=mr0, volatility=vol0, optimizer_fn=optimizer_fn, volatility_based_calibration=vol_based_calib, swaption_valuation_method=valuation_method, num_samples=num_samples, random_type=random_type, seed=seed, time_step=time_step, num_time_steps=num_time_steps, times=times, curve_times=curve_times, time_step_finite_difference=time_step, num_grid_points_finite_difference=41, maximum_iterations=max_iter, dtype=dtype)\n        return (calib_mr, calib_vol, calib_corr)\n    (calib_mr, calib_vol, calib_corr) = self.evaluate(_fn())\n    prices = tff.models.hjm.swaption_price(expiries=self.expiries[:num_instruments], fixed_leg_payment_times=self.fixed_leg_payment_times[:num_instruments, :], fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions[:num_instruments, :], fixed_leg_coupon=self.fixed_leg_coupon[:num_instruments, :], reference_rate_fn=zero_rate_fn, num_hjm_factors=num_hjm_factors, notional=100.0, mean_reversion=calib_mr, volatility=calib_vol, corr_matrix=calib_corr, num_samples=num_samples, random_type=random_type, seed=seed, time_step=time_step, num_time_steps=num_time_steps, times=times, curve_times=curve_times, time_step_finite_difference=time_step, num_grid_points_finite_difference=101, valuation_method=valuation_method, dtype=dtype)\n    prices = self.evaluate(prices)\n    self.assertAllClose(prices, self.prices[:num_instruments], rtol=0.1, atol=0.1)",
            "@parameterized.named_parameters({'testcase_name': 'two_factor_price', 'optimizer_fn': None, 'vol_based_calib': False, 'num_hjm_factors': 2, 'time_step': 0.25, 'num_time_steps': None, 'num_instruments': 14, 'max_iter': 10}, {'testcase_name': 'two_factor_vol', 'optimizer_fn': None, 'vol_based_calib': True, 'num_hjm_factors': 2, 'time_step': 0.25, 'num_time_steps': None, 'num_instruments': 14, 'max_iter': 10}, {'testcase_name': 'two_factor_bfgs', 'optimizer_fn': tfp.optimizer.bfgs_minimize, 'vol_based_calib': False, 'num_hjm_factors': 2, 'time_step': 0.25, 'num_time_steps': None, 'num_instruments': 14, 'max_iter': 10}, {'testcase_name': 'three_factor_price', 'optimizer_fn': None, 'vol_based_calib': False, 'num_hjm_factors': 3, 'time_step': 0.25, 'num_time_steps': None, 'num_instruments': 14, 'max_iter': 10}, {'testcase_name': 'three_factor_vol', 'optimizer_fn': None, 'vol_based_calib': True, 'num_hjm_factors': 3, 'time_step': 0.25, 'num_time_steps': None, 'num_instruments': 14, 'max_iter': 10})\ndef test_calibration(self, optimizer_fn, vol_based_calib, num_hjm_factors, time_step, num_time_steps, num_instruments, max_iter):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests calibration with constant parameters.'\n    dtype = tf.float64\n    mr0 = [0.01, 0.05]\n    if num_hjm_factors == 3:\n        mr0 = [0.01, 0.05, 0.1]\n    vol0 = [0.005, 0.007]\n    if num_hjm_factors == 3:\n        vol0 = [0.002, 0.003, 0.008]\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    times = np.unique(np.reshape(self.expiries[:num_instruments], [-1]))\n    curve_times = None\n    random_type = tff.math.random.RandomType.STATELESS_ANTITHETIC\n    seed = [0, 0]\n    num_samples = 500\n    valuation_method = tff.models.ValuationMethod.MONTE_CARLO\n\n    def _fn():\n        ((calib_mr, calib_vol, calib_corr), _, _) = tff.models.hjm.calibration_from_swaptions(prices=self.prices[:num_instruments], expiries=self.expiries[:num_instruments], floating_leg_start_times=self.float_leg_start_times[:num_instruments, :], floating_leg_end_times=self.float_leg_end_times[:num_instruments, :], fixed_leg_payment_times=self.fixed_leg_payment_times[:num_instruments, :], floating_leg_daycount_fractions=self.float_leg_daycount_fractions[:num_instruments, :], fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions[:num_instruments, :], fixed_leg_coupon=self.fixed_leg_coupon[:num_instruments, :], reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=num_hjm_factors, mean_reversion=mr0, volatility=vol0, optimizer_fn=optimizer_fn, volatility_based_calibration=vol_based_calib, swaption_valuation_method=valuation_method, num_samples=num_samples, random_type=random_type, seed=seed, time_step=time_step, num_time_steps=num_time_steps, times=times, curve_times=curve_times, time_step_finite_difference=time_step, num_grid_points_finite_difference=41, maximum_iterations=max_iter, dtype=dtype)\n        return (calib_mr, calib_vol, calib_corr)\n    (calib_mr, calib_vol, calib_corr) = self.evaluate(_fn())\n    prices = tff.models.hjm.swaption_price(expiries=self.expiries[:num_instruments], fixed_leg_payment_times=self.fixed_leg_payment_times[:num_instruments, :], fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions[:num_instruments, :], fixed_leg_coupon=self.fixed_leg_coupon[:num_instruments, :], reference_rate_fn=zero_rate_fn, num_hjm_factors=num_hjm_factors, notional=100.0, mean_reversion=calib_mr, volatility=calib_vol, corr_matrix=calib_corr, num_samples=num_samples, random_type=random_type, seed=seed, time_step=time_step, num_time_steps=num_time_steps, times=times, curve_times=curve_times, time_step_finite_difference=time_step, num_grid_points_finite_difference=101, valuation_method=valuation_method, dtype=dtype)\n    prices = self.evaluate(prices)\n    self.assertAllClose(prices, self.prices[:num_instruments], rtol=0.1, atol=0.1)",
            "@parameterized.named_parameters({'testcase_name': 'two_factor_price', 'optimizer_fn': None, 'vol_based_calib': False, 'num_hjm_factors': 2, 'time_step': 0.25, 'num_time_steps': None, 'num_instruments': 14, 'max_iter': 10}, {'testcase_name': 'two_factor_vol', 'optimizer_fn': None, 'vol_based_calib': True, 'num_hjm_factors': 2, 'time_step': 0.25, 'num_time_steps': None, 'num_instruments': 14, 'max_iter': 10}, {'testcase_name': 'two_factor_bfgs', 'optimizer_fn': tfp.optimizer.bfgs_minimize, 'vol_based_calib': False, 'num_hjm_factors': 2, 'time_step': 0.25, 'num_time_steps': None, 'num_instruments': 14, 'max_iter': 10}, {'testcase_name': 'three_factor_price', 'optimizer_fn': None, 'vol_based_calib': False, 'num_hjm_factors': 3, 'time_step': 0.25, 'num_time_steps': None, 'num_instruments': 14, 'max_iter': 10}, {'testcase_name': 'three_factor_vol', 'optimizer_fn': None, 'vol_based_calib': True, 'num_hjm_factors': 3, 'time_step': 0.25, 'num_time_steps': None, 'num_instruments': 14, 'max_iter': 10})\ndef test_calibration(self, optimizer_fn, vol_based_calib, num_hjm_factors, time_step, num_time_steps, num_instruments, max_iter):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests calibration with constant parameters.'\n    dtype = tf.float64\n    mr0 = [0.01, 0.05]\n    if num_hjm_factors == 3:\n        mr0 = [0.01, 0.05, 0.1]\n    vol0 = [0.005, 0.007]\n    if num_hjm_factors == 3:\n        vol0 = [0.002, 0.003, 0.008]\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    times = np.unique(np.reshape(self.expiries[:num_instruments], [-1]))\n    curve_times = None\n    random_type = tff.math.random.RandomType.STATELESS_ANTITHETIC\n    seed = [0, 0]\n    num_samples = 500\n    valuation_method = tff.models.ValuationMethod.MONTE_CARLO\n\n    def _fn():\n        ((calib_mr, calib_vol, calib_corr), _, _) = tff.models.hjm.calibration_from_swaptions(prices=self.prices[:num_instruments], expiries=self.expiries[:num_instruments], floating_leg_start_times=self.float_leg_start_times[:num_instruments, :], floating_leg_end_times=self.float_leg_end_times[:num_instruments, :], fixed_leg_payment_times=self.fixed_leg_payment_times[:num_instruments, :], floating_leg_daycount_fractions=self.float_leg_daycount_fractions[:num_instruments, :], fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions[:num_instruments, :], fixed_leg_coupon=self.fixed_leg_coupon[:num_instruments, :], reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=num_hjm_factors, mean_reversion=mr0, volatility=vol0, optimizer_fn=optimizer_fn, volatility_based_calibration=vol_based_calib, swaption_valuation_method=valuation_method, num_samples=num_samples, random_type=random_type, seed=seed, time_step=time_step, num_time_steps=num_time_steps, times=times, curve_times=curve_times, time_step_finite_difference=time_step, num_grid_points_finite_difference=41, maximum_iterations=max_iter, dtype=dtype)\n        return (calib_mr, calib_vol, calib_corr)\n    (calib_mr, calib_vol, calib_corr) = self.evaluate(_fn())\n    prices = tff.models.hjm.swaption_price(expiries=self.expiries[:num_instruments], fixed_leg_payment_times=self.fixed_leg_payment_times[:num_instruments, :], fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions[:num_instruments, :], fixed_leg_coupon=self.fixed_leg_coupon[:num_instruments, :], reference_rate_fn=zero_rate_fn, num_hjm_factors=num_hjm_factors, notional=100.0, mean_reversion=calib_mr, volatility=calib_vol, corr_matrix=calib_corr, num_samples=num_samples, random_type=random_type, seed=seed, time_step=time_step, num_time_steps=num_time_steps, times=times, curve_times=curve_times, time_step_finite_difference=time_step, num_grid_points_finite_difference=101, valuation_method=valuation_method, dtype=dtype)\n    prices = self.evaluate(prices)\n    self.assertAllClose(prices, self.prices[:num_instruments], rtol=0.1, atol=0.1)",
            "@parameterized.named_parameters({'testcase_name': 'two_factor_price', 'optimizer_fn': None, 'vol_based_calib': False, 'num_hjm_factors': 2, 'time_step': 0.25, 'num_time_steps': None, 'num_instruments': 14, 'max_iter': 10}, {'testcase_name': 'two_factor_vol', 'optimizer_fn': None, 'vol_based_calib': True, 'num_hjm_factors': 2, 'time_step': 0.25, 'num_time_steps': None, 'num_instruments': 14, 'max_iter': 10}, {'testcase_name': 'two_factor_bfgs', 'optimizer_fn': tfp.optimizer.bfgs_minimize, 'vol_based_calib': False, 'num_hjm_factors': 2, 'time_step': 0.25, 'num_time_steps': None, 'num_instruments': 14, 'max_iter': 10}, {'testcase_name': 'three_factor_price', 'optimizer_fn': None, 'vol_based_calib': False, 'num_hjm_factors': 3, 'time_step': 0.25, 'num_time_steps': None, 'num_instruments': 14, 'max_iter': 10}, {'testcase_name': 'three_factor_vol', 'optimizer_fn': None, 'vol_based_calib': True, 'num_hjm_factors': 3, 'time_step': 0.25, 'num_time_steps': None, 'num_instruments': 14, 'max_iter': 10})\ndef test_calibration(self, optimizer_fn, vol_based_calib, num_hjm_factors, time_step, num_time_steps, num_instruments, max_iter):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests calibration with constant parameters.'\n    dtype = tf.float64\n    mr0 = [0.01, 0.05]\n    if num_hjm_factors == 3:\n        mr0 = [0.01, 0.05, 0.1]\n    vol0 = [0.005, 0.007]\n    if num_hjm_factors == 3:\n        vol0 = [0.002, 0.003, 0.008]\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    times = np.unique(np.reshape(self.expiries[:num_instruments], [-1]))\n    curve_times = None\n    random_type = tff.math.random.RandomType.STATELESS_ANTITHETIC\n    seed = [0, 0]\n    num_samples = 500\n    valuation_method = tff.models.ValuationMethod.MONTE_CARLO\n\n    def _fn():\n        ((calib_mr, calib_vol, calib_corr), _, _) = tff.models.hjm.calibration_from_swaptions(prices=self.prices[:num_instruments], expiries=self.expiries[:num_instruments], floating_leg_start_times=self.float_leg_start_times[:num_instruments, :], floating_leg_end_times=self.float_leg_end_times[:num_instruments, :], fixed_leg_payment_times=self.fixed_leg_payment_times[:num_instruments, :], floating_leg_daycount_fractions=self.float_leg_daycount_fractions[:num_instruments, :], fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions[:num_instruments, :], fixed_leg_coupon=self.fixed_leg_coupon[:num_instruments, :], reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=num_hjm_factors, mean_reversion=mr0, volatility=vol0, optimizer_fn=optimizer_fn, volatility_based_calibration=vol_based_calib, swaption_valuation_method=valuation_method, num_samples=num_samples, random_type=random_type, seed=seed, time_step=time_step, num_time_steps=num_time_steps, times=times, curve_times=curve_times, time_step_finite_difference=time_step, num_grid_points_finite_difference=41, maximum_iterations=max_iter, dtype=dtype)\n        return (calib_mr, calib_vol, calib_corr)\n    (calib_mr, calib_vol, calib_corr) = self.evaluate(_fn())\n    prices = tff.models.hjm.swaption_price(expiries=self.expiries[:num_instruments], fixed_leg_payment_times=self.fixed_leg_payment_times[:num_instruments, :], fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions[:num_instruments, :], fixed_leg_coupon=self.fixed_leg_coupon[:num_instruments, :], reference_rate_fn=zero_rate_fn, num_hjm_factors=num_hjm_factors, notional=100.0, mean_reversion=calib_mr, volatility=calib_vol, corr_matrix=calib_corr, num_samples=num_samples, random_type=random_type, seed=seed, time_step=time_step, num_time_steps=num_time_steps, times=times, curve_times=curve_times, time_step_finite_difference=time_step, num_grid_points_finite_difference=101, valuation_method=valuation_method, dtype=dtype)\n    prices = self.evaluate(prices)\n    self.assertAllClose(prices, self.prices[:num_instruments], rtol=0.1, atol=0.1)",
            "@parameterized.named_parameters({'testcase_name': 'two_factor_price', 'optimizer_fn': None, 'vol_based_calib': False, 'num_hjm_factors': 2, 'time_step': 0.25, 'num_time_steps': None, 'num_instruments': 14, 'max_iter': 10}, {'testcase_name': 'two_factor_vol', 'optimizer_fn': None, 'vol_based_calib': True, 'num_hjm_factors': 2, 'time_step': 0.25, 'num_time_steps': None, 'num_instruments': 14, 'max_iter': 10}, {'testcase_name': 'two_factor_bfgs', 'optimizer_fn': tfp.optimizer.bfgs_minimize, 'vol_based_calib': False, 'num_hjm_factors': 2, 'time_step': 0.25, 'num_time_steps': None, 'num_instruments': 14, 'max_iter': 10}, {'testcase_name': 'three_factor_price', 'optimizer_fn': None, 'vol_based_calib': False, 'num_hjm_factors': 3, 'time_step': 0.25, 'num_time_steps': None, 'num_instruments': 14, 'max_iter': 10}, {'testcase_name': 'three_factor_vol', 'optimizer_fn': None, 'vol_based_calib': True, 'num_hjm_factors': 3, 'time_step': 0.25, 'num_time_steps': None, 'num_instruments': 14, 'max_iter': 10})\ndef test_calibration(self, optimizer_fn, vol_based_calib, num_hjm_factors, time_step, num_time_steps, num_instruments, max_iter):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests calibration with constant parameters.'\n    dtype = tf.float64\n    mr0 = [0.01, 0.05]\n    if num_hjm_factors == 3:\n        mr0 = [0.01, 0.05, 0.1]\n    vol0 = [0.005, 0.007]\n    if num_hjm_factors == 3:\n        vol0 = [0.002, 0.003, 0.008]\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    times = np.unique(np.reshape(self.expiries[:num_instruments], [-1]))\n    curve_times = None\n    random_type = tff.math.random.RandomType.STATELESS_ANTITHETIC\n    seed = [0, 0]\n    num_samples = 500\n    valuation_method = tff.models.ValuationMethod.MONTE_CARLO\n\n    def _fn():\n        ((calib_mr, calib_vol, calib_corr), _, _) = tff.models.hjm.calibration_from_swaptions(prices=self.prices[:num_instruments], expiries=self.expiries[:num_instruments], floating_leg_start_times=self.float_leg_start_times[:num_instruments, :], floating_leg_end_times=self.float_leg_end_times[:num_instruments, :], fixed_leg_payment_times=self.fixed_leg_payment_times[:num_instruments, :], floating_leg_daycount_fractions=self.float_leg_daycount_fractions[:num_instruments, :], fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions[:num_instruments, :], fixed_leg_coupon=self.fixed_leg_coupon[:num_instruments, :], reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=num_hjm_factors, mean_reversion=mr0, volatility=vol0, optimizer_fn=optimizer_fn, volatility_based_calibration=vol_based_calib, swaption_valuation_method=valuation_method, num_samples=num_samples, random_type=random_type, seed=seed, time_step=time_step, num_time_steps=num_time_steps, times=times, curve_times=curve_times, time_step_finite_difference=time_step, num_grid_points_finite_difference=41, maximum_iterations=max_iter, dtype=dtype)\n        return (calib_mr, calib_vol, calib_corr)\n    (calib_mr, calib_vol, calib_corr) = self.evaluate(_fn())\n    prices = tff.models.hjm.swaption_price(expiries=self.expiries[:num_instruments], fixed_leg_payment_times=self.fixed_leg_payment_times[:num_instruments, :], fixed_leg_daycount_fractions=self.fixed_leg_daycount_fractions[:num_instruments, :], fixed_leg_coupon=self.fixed_leg_coupon[:num_instruments, :], reference_rate_fn=zero_rate_fn, num_hjm_factors=num_hjm_factors, notional=100.0, mean_reversion=calib_mr, volatility=calib_vol, corr_matrix=calib_corr, num_samples=num_samples, random_type=random_type, seed=seed, time_step=time_step, num_time_steps=num_time_steps, times=times, curve_times=curve_times, time_step_finite_difference=time_step, num_grid_points_finite_difference=101, valuation_method=valuation_method, dtype=dtype)\n    prices = self.evaluate(prices)\n    self.assertAllClose(prices, self.prices[:num_instruments], rtol=0.1, atol=0.1)"
        ]
    },
    {
        "func_name": "zero_rate_fn",
        "original": "def zero_rate_fn(t):\n    rates = 0.01 * tf.ones_like(tf.expand_dims(t, axis=0), dtype=dtype)\n    return tf.concat([rates, rates], axis=0)",
        "mutated": [
            "def zero_rate_fn(t):\n    if False:\n        i = 10\n    rates = 0.01 * tf.ones_like(tf.expand_dims(t, axis=0), dtype=dtype)\n    return tf.concat([rates, rates], axis=0)",
            "def zero_rate_fn(t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    rates = 0.01 * tf.ones_like(tf.expand_dims(t, axis=0), dtype=dtype)\n    return tf.concat([rates, rates], axis=0)",
            "def zero_rate_fn(t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    rates = 0.01 * tf.ones_like(tf.expand_dims(t, axis=0), dtype=dtype)\n    return tf.concat([rates, rates], axis=0)",
            "def zero_rate_fn(t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    rates = 0.01 * tf.ones_like(tf.expand_dims(t, axis=0), dtype=dtype)\n    return tf.concat([rates, rates], axis=0)",
            "def zero_rate_fn(t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    rates = 0.01 * tf.ones_like(tf.expand_dims(t, axis=0), dtype=dtype)\n    return tf.concat([rates, rates], axis=0)"
        ]
    },
    {
        "func_name": "_fn",
        "original": "def _fn():\n    (calibration_result, _, _) = tff.models.hjm.calibration_from_swaptions(prices=prices_2d, expiries=expiries_2d, floating_leg_start_times=float_leg_start_times_2d, floating_leg_end_times=float_leg_end_times_2d, fixed_leg_payment_times=fixed_leg_payment_times_2d, floating_leg_daycount_fractions=float_leg_daycount_fractions_2d, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions_2d, fixed_leg_coupon=fixed_leg_coupon_2d, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=2, mean_reversion=mr0, volatility=vol0, volatility_based_calibration=vol_based_calib, calibrate_correlation=False, swaption_valuation_method=valuation_method, num_samples=num_samples, random_type=random_type, seed=seed, time_step=0.25, num_time_steps=None, times=times, curve_times=curve_times, maximum_iterations=10, dtype=dtype)\n    (calib_mr, calib_vol) = (calibration_result.mean_reversion, calibration_result.volatility)\n    return (calib_mr, calib_vol)",
        "mutated": [
            "def _fn():\n    if False:\n        i = 10\n    (calibration_result, _, _) = tff.models.hjm.calibration_from_swaptions(prices=prices_2d, expiries=expiries_2d, floating_leg_start_times=float_leg_start_times_2d, floating_leg_end_times=float_leg_end_times_2d, fixed_leg_payment_times=fixed_leg_payment_times_2d, floating_leg_daycount_fractions=float_leg_daycount_fractions_2d, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions_2d, fixed_leg_coupon=fixed_leg_coupon_2d, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=2, mean_reversion=mr0, volatility=vol0, volatility_based_calibration=vol_based_calib, calibrate_correlation=False, swaption_valuation_method=valuation_method, num_samples=num_samples, random_type=random_type, seed=seed, time_step=0.25, num_time_steps=None, times=times, curve_times=curve_times, maximum_iterations=10, dtype=dtype)\n    (calib_mr, calib_vol) = (calibration_result.mean_reversion, calibration_result.volatility)\n    return (calib_mr, calib_vol)",
            "def _fn():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (calibration_result, _, _) = tff.models.hjm.calibration_from_swaptions(prices=prices_2d, expiries=expiries_2d, floating_leg_start_times=float_leg_start_times_2d, floating_leg_end_times=float_leg_end_times_2d, fixed_leg_payment_times=fixed_leg_payment_times_2d, floating_leg_daycount_fractions=float_leg_daycount_fractions_2d, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions_2d, fixed_leg_coupon=fixed_leg_coupon_2d, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=2, mean_reversion=mr0, volatility=vol0, volatility_based_calibration=vol_based_calib, calibrate_correlation=False, swaption_valuation_method=valuation_method, num_samples=num_samples, random_type=random_type, seed=seed, time_step=0.25, num_time_steps=None, times=times, curve_times=curve_times, maximum_iterations=10, dtype=dtype)\n    (calib_mr, calib_vol) = (calibration_result.mean_reversion, calibration_result.volatility)\n    return (calib_mr, calib_vol)",
            "def _fn():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (calibration_result, _, _) = tff.models.hjm.calibration_from_swaptions(prices=prices_2d, expiries=expiries_2d, floating_leg_start_times=float_leg_start_times_2d, floating_leg_end_times=float_leg_end_times_2d, fixed_leg_payment_times=fixed_leg_payment_times_2d, floating_leg_daycount_fractions=float_leg_daycount_fractions_2d, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions_2d, fixed_leg_coupon=fixed_leg_coupon_2d, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=2, mean_reversion=mr0, volatility=vol0, volatility_based_calibration=vol_based_calib, calibrate_correlation=False, swaption_valuation_method=valuation_method, num_samples=num_samples, random_type=random_type, seed=seed, time_step=0.25, num_time_steps=None, times=times, curve_times=curve_times, maximum_iterations=10, dtype=dtype)\n    (calib_mr, calib_vol) = (calibration_result.mean_reversion, calibration_result.volatility)\n    return (calib_mr, calib_vol)",
            "def _fn():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (calibration_result, _, _) = tff.models.hjm.calibration_from_swaptions(prices=prices_2d, expiries=expiries_2d, floating_leg_start_times=float_leg_start_times_2d, floating_leg_end_times=float_leg_end_times_2d, fixed_leg_payment_times=fixed_leg_payment_times_2d, floating_leg_daycount_fractions=float_leg_daycount_fractions_2d, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions_2d, fixed_leg_coupon=fixed_leg_coupon_2d, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=2, mean_reversion=mr0, volatility=vol0, volatility_based_calibration=vol_based_calib, calibrate_correlation=False, swaption_valuation_method=valuation_method, num_samples=num_samples, random_type=random_type, seed=seed, time_step=0.25, num_time_steps=None, times=times, curve_times=curve_times, maximum_iterations=10, dtype=dtype)\n    (calib_mr, calib_vol) = (calibration_result.mean_reversion, calibration_result.volatility)\n    return (calib_mr, calib_vol)",
            "def _fn():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (calibration_result, _, _) = tff.models.hjm.calibration_from_swaptions(prices=prices_2d, expiries=expiries_2d, floating_leg_start_times=float_leg_start_times_2d, floating_leg_end_times=float_leg_end_times_2d, fixed_leg_payment_times=fixed_leg_payment_times_2d, floating_leg_daycount_fractions=float_leg_daycount_fractions_2d, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions_2d, fixed_leg_coupon=fixed_leg_coupon_2d, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=2, mean_reversion=mr0, volatility=vol0, volatility_based_calibration=vol_based_calib, calibrate_correlation=False, swaption_valuation_method=valuation_method, num_samples=num_samples, random_type=random_type, seed=seed, time_step=0.25, num_time_steps=None, times=times, curve_times=curve_times, maximum_iterations=10, dtype=dtype)\n    (calib_mr, calib_vol) = (calibration_result.mean_reversion, calibration_result.volatility)\n    return (calib_mr, calib_vol)"
        ]
    },
    {
        "func_name": "test_calibration_batch",
        "original": "@parameterized.named_parameters({'testcase_name': 'vol_based', 'vol_based_calib': True}, {'testcase_name': 'price_based', 'vol_based_calib': False})\ndef test_calibration_batch(self, vol_based_calib):\n    \"\"\"Tests calibration for a batch of models.\"\"\"\n    dtype = tf.float64\n    mr0 = [[0.01, 0.05], [0.1, 0.2]]\n    vol0 = [[0.005, 0.007], [0.01, 0.015]]\n\n    def zero_rate_fn(t):\n        rates = 0.01 * tf.ones_like(tf.expand_dims(t, axis=0), dtype=dtype)\n        return tf.concat([rates, rates], axis=0)\n    times = np.unique(np.reshape(self.expiries, [-1]))\n    curve_times = None\n    random_type = tff.math.random.RandomType.STATELESS_ANTITHETIC\n    seed = [0, 0]\n    num_samples = 500\n    valuation_method = tff.models.ValuationMethod.MONTE_CARLO\n    prices_2d = np.repeat(np.expand_dims(self.prices, axis=0), 2, axis=0)\n    expiries_2d = np.repeat(np.expand_dims(self.expiries, axis=0), 2, axis=0)\n    float_leg_start_times_2d = np.repeat(np.expand_dims(self.float_leg_start_times, axis=0), 2, axis=0)\n    float_leg_end_times_2d = np.repeat(np.expand_dims(self.float_leg_end_times, axis=0), 2, axis=0)\n    fixed_leg_payment_times_2d = np.repeat(np.expand_dims(self.fixed_leg_payment_times, axis=0), 2, axis=0)\n    float_leg_daycount_fractions_2d = np.repeat(np.expand_dims(self.float_leg_daycount_fractions, axis=0), 2, axis=0)\n    fixed_leg_daycount_fractions_2d = np.repeat(np.expand_dims(self.fixed_leg_daycount_fractions, axis=0), 2, axis=0)\n    fixed_leg_coupon_2d = np.repeat(np.expand_dims(self.fixed_leg_coupon, axis=0), 2, axis=0)\n\n    def _fn():\n        (calibration_result, _, _) = tff.models.hjm.calibration_from_swaptions(prices=prices_2d, expiries=expiries_2d, floating_leg_start_times=float_leg_start_times_2d, floating_leg_end_times=float_leg_end_times_2d, fixed_leg_payment_times=fixed_leg_payment_times_2d, floating_leg_daycount_fractions=float_leg_daycount_fractions_2d, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions_2d, fixed_leg_coupon=fixed_leg_coupon_2d, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=2, mean_reversion=mr0, volatility=vol0, volatility_based_calibration=vol_based_calib, calibrate_correlation=False, swaption_valuation_method=valuation_method, num_samples=num_samples, random_type=random_type, seed=seed, time_step=0.25, num_time_steps=None, times=times, curve_times=curve_times, maximum_iterations=10, dtype=dtype)\n        (calib_mr, calib_vol) = (calibration_result.mean_reversion, calibration_result.volatility)\n        return (calib_mr, calib_vol)\n    (calib_mr, calib_vol) = self.evaluate(_fn())\n    with self.subTest('MR-Shape'):\n        self.assertAllEqual(calib_mr.shape, [2, 2])\n    with self.subTest('Vol-Shape'):\n        self.assertAllEqual(calib_vol.shape, [2, 2])\n    prices = tff.models.hjm.swaption_price(expiries=expiries_2d, fixed_leg_payment_times=fixed_leg_payment_times_2d, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions_2d, fixed_leg_coupon=fixed_leg_coupon_2d, reference_rate_fn=zero_rate_fn, num_hjm_factors=2, notional=100.0, mean_reversion=calib_mr, volatility=calib_vol, corr_matrix=None, num_samples=num_samples, random_type=random_type, seed=seed, time_step=0.25, times=times, curve_times=curve_times, valuation_method=valuation_method, dtype=dtype)\n    prices = self.evaluate(prices)\n    with self.subTest('CalibratedPrices'):\n        self.assertAllClose(prices, prices_2d, rtol=0.1, atol=0.1)",
        "mutated": [
            "@parameterized.named_parameters({'testcase_name': 'vol_based', 'vol_based_calib': True}, {'testcase_name': 'price_based', 'vol_based_calib': False})\ndef test_calibration_batch(self, vol_based_calib):\n    if False:\n        i = 10\n    'Tests calibration for a batch of models.'\n    dtype = tf.float64\n    mr0 = [[0.01, 0.05], [0.1, 0.2]]\n    vol0 = [[0.005, 0.007], [0.01, 0.015]]\n\n    def zero_rate_fn(t):\n        rates = 0.01 * tf.ones_like(tf.expand_dims(t, axis=0), dtype=dtype)\n        return tf.concat([rates, rates], axis=0)\n    times = np.unique(np.reshape(self.expiries, [-1]))\n    curve_times = None\n    random_type = tff.math.random.RandomType.STATELESS_ANTITHETIC\n    seed = [0, 0]\n    num_samples = 500\n    valuation_method = tff.models.ValuationMethod.MONTE_CARLO\n    prices_2d = np.repeat(np.expand_dims(self.prices, axis=0), 2, axis=0)\n    expiries_2d = np.repeat(np.expand_dims(self.expiries, axis=0), 2, axis=0)\n    float_leg_start_times_2d = np.repeat(np.expand_dims(self.float_leg_start_times, axis=0), 2, axis=0)\n    float_leg_end_times_2d = np.repeat(np.expand_dims(self.float_leg_end_times, axis=0), 2, axis=0)\n    fixed_leg_payment_times_2d = np.repeat(np.expand_dims(self.fixed_leg_payment_times, axis=0), 2, axis=0)\n    float_leg_daycount_fractions_2d = np.repeat(np.expand_dims(self.float_leg_daycount_fractions, axis=0), 2, axis=0)\n    fixed_leg_daycount_fractions_2d = np.repeat(np.expand_dims(self.fixed_leg_daycount_fractions, axis=0), 2, axis=0)\n    fixed_leg_coupon_2d = np.repeat(np.expand_dims(self.fixed_leg_coupon, axis=0), 2, axis=0)\n\n    def _fn():\n        (calibration_result, _, _) = tff.models.hjm.calibration_from_swaptions(prices=prices_2d, expiries=expiries_2d, floating_leg_start_times=float_leg_start_times_2d, floating_leg_end_times=float_leg_end_times_2d, fixed_leg_payment_times=fixed_leg_payment_times_2d, floating_leg_daycount_fractions=float_leg_daycount_fractions_2d, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions_2d, fixed_leg_coupon=fixed_leg_coupon_2d, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=2, mean_reversion=mr0, volatility=vol0, volatility_based_calibration=vol_based_calib, calibrate_correlation=False, swaption_valuation_method=valuation_method, num_samples=num_samples, random_type=random_type, seed=seed, time_step=0.25, num_time_steps=None, times=times, curve_times=curve_times, maximum_iterations=10, dtype=dtype)\n        (calib_mr, calib_vol) = (calibration_result.mean_reversion, calibration_result.volatility)\n        return (calib_mr, calib_vol)\n    (calib_mr, calib_vol) = self.evaluate(_fn())\n    with self.subTest('MR-Shape'):\n        self.assertAllEqual(calib_mr.shape, [2, 2])\n    with self.subTest('Vol-Shape'):\n        self.assertAllEqual(calib_vol.shape, [2, 2])\n    prices = tff.models.hjm.swaption_price(expiries=expiries_2d, fixed_leg_payment_times=fixed_leg_payment_times_2d, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions_2d, fixed_leg_coupon=fixed_leg_coupon_2d, reference_rate_fn=zero_rate_fn, num_hjm_factors=2, notional=100.0, mean_reversion=calib_mr, volatility=calib_vol, corr_matrix=None, num_samples=num_samples, random_type=random_type, seed=seed, time_step=0.25, times=times, curve_times=curve_times, valuation_method=valuation_method, dtype=dtype)\n    prices = self.evaluate(prices)\n    with self.subTest('CalibratedPrices'):\n        self.assertAllClose(prices, prices_2d, rtol=0.1, atol=0.1)",
            "@parameterized.named_parameters({'testcase_name': 'vol_based', 'vol_based_calib': True}, {'testcase_name': 'price_based', 'vol_based_calib': False})\ndef test_calibration_batch(self, vol_based_calib):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests calibration for a batch of models.'\n    dtype = tf.float64\n    mr0 = [[0.01, 0.05], [0.1, 0.2]]\n    vol0 = [[0.005, 0.007], [0.01, 0.015]]\n\n    def zero_rate_fn(t):\n        rates = 0.01 * tf.ones_like(tf.expand_dims(t, axis=0), dtype=dtype)\n        return tf.concat([rates, rates], axis=0)\n    times = np.unique(np.reshape(self.expiries, [-1]))\n    curve_times = None\n    random_type = tff.math.random.RandomType.STATELESS_ANTITHETIC\n    seed = [0, 0]\n    num_samples = 500\n    valuation_method = tff.models.ValuationMethod.MONTE_CARLO\n    prices_2d = np.repeat(np.expand_dims(self.prices, axis=0), 2, axis=0)\n    expiries_2d = np.repeat(np.expand_dims(self.expiries, axis=0), 2, axis=0)\n    float_leg_start_times_2d = np.repeat(np.expand_dims(self.float_leg_start_times, axis=0), 2, axis=0)\n    float_leg_end_times_2d = np.repeat(np.expand_dims(self.float_leg_end_times, axis=0), 2, axis=0)\n    fixed_leg_payment_times_2d = np.repeat(np.expand_dims(self.fixed_leg_payment_times, axis=0), 2, axis=0)\n    float_leg_daycount_fractions_2d = np.repeat(np.expand_dims(self.float_leg_daycount_fractions, axis=0), 2, axis=0)\n    fixed_leg_daycount_fractions_2d = np.repeat(np.expand_dims(self.fixed_leg_daycount_fractions, axis=0), 2, axis=0)\n    fixed_leg_coupon_2d = np.repeat(np.expand_dims(self.fixed_leg_coupon, axis=0), 2, axis=0)\n\n    def _fn():\n        (calibration_result, _, _) = tff.models.hjm.calibration_from_swaptions(prices=prices_2d, expiries=expiries_2d, floating_leg_start_times=float_leg_start_times_2d, floating_leg_end_times=float_leg_end_times_2d, fixed_leg_payment_times=fixed_leg_payment_times_2d, floating_leg_daycount_fractions=float_leg_daycount_fractions_2d, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions_2d, fixed_leg_coupon=fixed_leg_coupon_2d, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=2, mean_reversion=mr0, volatility=vol0, volatility_based_calibration=vol_based_calib, calibrate_correlation=False, swaption_valuation_method=valuation_method, num_samples=num_samples, random_type=random_type, seed=seed, time_step=0.25, num_time_steps=None, times=times, curve_times=curve_times, maximum_iterations=10, dtype=dtype)\n        (calib_mr, calib_vol) = (calibration_result.mean_reversion, calibration_result.volatility)\n        return (calib_mr, calib_vol)\n    (calib_mr, calib_vol) = self.evaluate(_fn())\n    with self.subTest('MR-Shape'):\n        self.assertAllEqual(calib_mr.shape, [2, 2])\n    with self.subTest('Vol-Shape'):\n        self.assertAllEqual(calib_vol.shape, [2, 2])\n    prices = tff.models.hjm.swaption_price(expiries=expiries_2d, fixed_leg_payment_times=fixed_leg_payment_times_2d, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions_2d, fixed_leg_coupon=fixed_leg_coupon_2d, reference_rate_fn=zero_rate_fn, num_hjm_factors=2, notional=100.0, mean_reversion=calib_mr, volatility=calib_vol, corr_matrix=None, num_samples=num_samples, random_type=random_type, seed=seed, time_step=0.25, times=times, curve_times=curve_times, valuation_method=valuation_method, dtype=dtype)\n    prices = self.evaluate(prices)\n    with self.subTest('CalibratedPrices'):\n        self.assertAllClose(prices, prices_2d, rtol=0.1, atol=0.1)",
            "@parameterized.named_parameters({'testcase_name': 'vol_based', 'vol_based_calib': True}, {'testcase_name': 'price_based', 'vol_based_calib': False})\ndef test_calibration_batch(self, vol_based_calib):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests calibration for a batch of models.'\n    dtype = tf.float64\n    mr0 = [[0.01, 0.05], [0.1, 0.2]]\n    vol0 = [[0.005, 0.007], [0.01, 0.015]]\n\n    def zero_rate_fn(t):\n        rates = 0.01 * tf.ones_like(tf.expand_dims(t, axis=0), dtype=dtype)\n        return tf.concat([rates, rates], axis=0)\n    times = np.unique(np.reshape(self.expiries, [-1]))\n    curve_times = None\n    random_type = tff.math.random.RandomType.STATELESS_ANTITHETIC\n    seed = [0, 0]\n    num_samples = 500\n    valuation_method = tff.models.ValuationMethod.MONTE_CARLO\n    prices_2d = np.repeat(np.expand_dims(self.prices, axis=0), 2, axis=0)\n    expiries_2d = np.repeat(np.expand_dims(self.expiries, axis=0), 2, axis=0)\n    float_leg_start_times_2d = np.repeat(np.expand_dims(self.float_leg_start_times, axis=0), 2, axis=0)\n    float_leg_end_times_2d = np.repeat(np.expand_dims(self.float_leg_end_times, axis=0), 2, axis=0)\n    fixed_leg_payment_times_2d = np.repeat(np.expand_dims(self.fixed_leg_payment_times, axis=0), 2, axis=0)\n    float_leg_daycount_fractions_2d = np.repeat(np.expand_dims(self.float_leg_daycount_fractions, axis=0), 2, axis=0)\n    fixed_leg_daycount_fractions_2d = np.repeat(np.expand_dims(self.fixed_leg_daycount_fractions, axis=0), 2, axis=0)\n    fixed_leg_coupon_2d = np.repeat(np.expand_dims(self.fixed_leg_coupon, axis=0), 2, axis=0)\n\n    def _fn():\n        (calibration_result, _, _) = tff.models.hjm.calibration_from_swaptions(prices=prices_2d, expiries=expiries_2d, floating_leg_start_times=float_leg_start_times_2d, floating_leg_end_times=float_leg_end_times_2d, fixed_leg_payment_times=fixed_leg_payment_times_2d, floating_leg_daycount_fractions=float_leg_daycount_fractions_2d, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions_2d, fixed_leg_coupon=fixed_leg_coupon_2d, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=2, mean_reversion=mr0, volatility=vol0, volatility_based_calibration=vol_based_calib, calibrate_correlation=False, swaption_valuation_method=valuation_method, num_samples=num_samples, random_type=random_type, seed=seed, time_step=0.25, num_time_steps=None, times=times, curve_times=curve_times, maximum_iterations=10, dtype=dtype)\n        (calib_mr, calib_vol) = (calibration_result.mean_reversion, calibration_result.volatility)\n        return (calib_mr, calib_vol)\n    (calib_mr, calib_vol) = self.evaluate(_fn())\n    with self.subTest('MR-Shape'):\n        self.assertAllEqual(calib_mr.shape, [2, 2])\n    with self.subTest('Vol-Shape'):\n        self.assertAllEqual(calib_vol.shape, [2, 2])\n    prices = tff.models.hjm.swaption_price(expiries=expiries_2d, fixed_leg_payment_times=fixed_leg_payment_times_2d, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions_2d, fixed_leg_coupon=fixed_leg_coupon_2d, reference_rate_fn=zero_rate_fn, num_hjm_factors=2, notional=100.0, mean_reversion=calib_mr, volatility=calib_vol, corr_matrix=None, num_samples=num_samples, random_type=random_type, seed=seed, time_step=0.25, times=times, curve_times=curve_times, valuation_method=valuation_method, dtype=dtype)\n    prices = self.evaluate(prices)\n    with self.subTest('CalibratedPrices'):\n        self.assertAllClose(prices, prices_2d, rtol=0.1, atol=0.1)",
            "@parameterized.named_parameters({'testcase_name': 'vol_based', 'vol_based_calib': True}, {'testcase_name': 'price_based', 'vol_based_calib': False})\ndef test_calibration_batch(self, vol_based_calib):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests calibration for a batch of models.'\n    dtype = tf.float64\n    mr0 = [[0.01, 0.05], [0.1, 0.2]]\n    vol0 = [[0.005, 0.007], [0.01, 0.015]]\n\n    def zero_rate_fn(t):\n        rates = 0.01 * tf.ones_like(tf.expand_dims(t, axis=0), dtype=dtype)\n        return tf.concat([rates, rates], axis=0)\n    times = np.unique(np.reshape(self.expiries, [-1]))\n    curve_times = None\n    random_type = tff.math.random.RandomType.STATELESS_ANTITHETIC\n    seed = [0, 0]\n    num_samples = 500\n    valuation_method = tff.models.ValuationMethod.MONTE_CARLO\n    prices_2d = np.repeat(np.expand_dims(self.prices, axis=0), 2, axis=0)\n    expiries_2d = np.repeat(np.expand_dims(self.expiries, axis=0), 2, axis=0)\n    float_leg_start_times_2d = np.repeat(np.expand_dims(self.float_leg_start_times, axis=0), 2, axis=0)\n    float_leg_end_times_2d = np.repeat(np.expand_dims(self.float_leg_end_times, axis=0), 2, axis=0)\n    fixed_leg_payment_times_2d = np.repeat(np.expand_dims(self.fixed_leg_payment_times, axis=0), 2, axis=0)\n    float_leg_daycount_fractions_2d = np.repeat(np.expand_dims(self.float_leg_daycount_fractions, axis=0), 2, axis=0)\n    fixed_leg_daycount_fractions_2d = np.repeat(np.expand_dims(self.fixed_leg_daycount_fractions, axis=0), 2, axis=0)\n    fixed_leg_coupon_2d = np.repeat(np.expand_dims(self.fixed_leg_coupon, axis=0), 2, axis=0)\n\n    def _fn():\n        (calibration_result, _, _) = tff.models.hjm.calibration_from_swaptions(prices=prices_2d, expiries=expiries_2d, floating_leg_start_times=float_leg_start_times_2d, floating_leg_end_times=float_leg_end_times_2d, fixed_leg_payment_times=fixed_leg_payment_times_2d, floating_leg_daycount_fractions=float_leg_daycount_fractions_2d, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions_2d, fixed_leg_coupon=fixed_leg_coupon_2d, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=2, mean_reversion=mr0, volatility=vol0, volatility_based_calibration=vol_based_calib, calibrate_correlation=False, swaption_valuation_method=valuation_method, num_samples=num_samples, random_type=random_type, seed=seed, time_step=0.25, num_time_steps=None, times=times, curve_times=curve_times, maximum_iterations=10, dtype=dtype)\n        (calib_mr, calib_vol) = (calibration_result.mean_reversion, calibration_result.volatility)\n        return (calib_mr, calib_vol)\n    (calib_mr, calib_vol) = self.evaluate(_fn())\n    with self.subTest('MR-Shape'):\n        self.assertAllEqual(calib_mr.shape, [2, 2])\n    with self.subTest('Vol-Shape'):\n        self.assertAllEqual(calib_vol.shape, [2, 2])\n    prices = tff.models.hjm.swaption_price(expiries=expiries_2d, fixed_leg_payment_times=fixed_leg_payment_times_2d, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions_2d, fixed_leg_coupon=fixed_leg_coupon_2d, reference_rate_fn=zero_rate_fn, num_hjm_factors=2, notional=100.0, mean_reversion=calib_mr, volatility=calib_vol, corr_matrix=None, num_samples=num_samples, random_type=random_type, seed=seed, time_step=0.25, times=times, curve_times=curve_times, valuation_method=valuation_method, dtype=dtype)\n    prices = self.evaluate(prices)\n    with self.subTest('CalibratedPrices'):\n        self.assertAllClose(prices, prices_2d, rtol=0.1, atol=0.1)",
            "@parameterized.named_parameters({'testcase_name': 'vol_based', 'vol_based_calib': True}, {'testcase_name': 'price_based', 'vol_based_calib': False})\ndef test_calibration_batch(self, vol_based_calib):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests calibration for a batch of models.'\n    dtype = tf.float64\n    mr0 = [[0.01, 0.05], [0.1, 0.2]]\n    vol0 = [[0.005, 0.007], [0.01, 0.015]]\n\n    def zero_rate_fn(t):\n        rates = 0.01 * tf.ones_like(tf.expand_dims(t, axis=0), dtype=dtype)\n        return tf.concat([rates, rates], axis=0)\n    times = np.unique(np.reshape(self.expiries, [-1]))\n    curve_times = None\n    random_type = tff.math.random.RandomType.STATELESS_ANTITHETIC\n    seed = [0, 0]\n    num_samples = 500\n    valuation_method = tff.models.ValuationMethod.MONTE_CARLO\n    prices_2d = np.repeat(np.expand_dims(self.prices, axis=0), 2, axis=0)\n    expiries_2d = np.repeat(np.expand_dims(self.expiries, axis=0), 2, axis=0)\n    float_leg_start_times_2d = np.repeat(np.expand_dims(self.float_leg_start_times, axis=0), 2, axis=0)\n    float_leg_end_times_2d = np.repeat(np.expand_dims(self.float_leg_end_times, axis=0), 2, axis=0)\n    fixed_leg_payment_times_2d = np.repeat(np.expand_dims(self.fixed_leg_payment_times, axis=0), 2, axis=0)\n    float_leg_daycount_fractions_2d = np.repeat(np.expand_dims(self.float_leg_daycount_fractions, axis=0), 2, axis=0)\n    fixed_leg_daycount_fractions_2d = np.repeat(np.expand_dims(self.fixed_leg_daycount_fractions, axis=0), 2, axis=0)\n    fixed_leg_coupon_2d = np.repeat(np.expand_dims(self.fixed_leg_coupon, axis=0), 2, axis=0)\n\n    def _fn():\n        (calibration_result, _, _) = tff.models.hjm.calibration_from_swaptions(prices=prices_2d, expiries=expiries_2d, floating_leg_start_times=float_leg_start_times_2d, floating_leg_end_times=float_leg_end_times_2d, fixed_leg_payment_times=fixed_leg_payment_times_2d, floating_leg_daycount_fractions=float_leg_daycount_fractions_2d, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions_2d, fixed_leg_coupon=fixed_leg_coupon_2d, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=2, mean_reversion=mr0, volatility=vol0, volatility_based_calibration=vol_based_calib, calibrate_correlation=False, swaption_valuation_method=valuation_method, num_samples=num_samples, random_type=random_type, seed=seed, time_step=0.25, num_time_steps=None, times=times, curve_times=curve_times, maximum_iterations=10, dtype=dtype)\n        (calib_mr, calib_vol) = (calibration_result.mean_reversion, calibration_result.volatility)\n        return (calib_mr, calib_vol)\n    (calib_mr, calib_vol) = self.evaluate(_fn())\n    with self.subTest('MR-Shape'):\n        self.assertAllEqual(calib_mr.shape, [2, 2])\n    with self.subTest('Vol-Shape'):\n        self.assertAllEqual(calib_vol.shape, [2, 2])\n    prices = tff.models.hjm.swaption_price(expiries=expiries_2d, fixed_leg_payment_times=fixed_leg_payment_times_2d, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions_2d, fixed_leg_coupon=fixed_leg_coupon_2d, reference_rate_fn=zero_rate_fn, num_hjm_factors=2, notional=100.0, mean_reversion=calib_mr, volatility=calib_vol, corr_matrix=None, num_samples=num_samples, random_type=random_type, seed=seed, time_step=0.25, times=times, curve_times=curve_times, valuation_method=valuation_method, dtype=dtype)\n    prices = self.evaluate(prices)\n    with self.subTest('CalibratedPrices'):\n        self.assertAllClose(prices, prices_2d, rtol=0.1, atol=0.1)"
        ]
    }
]