def update_param(name, param):
    if False:
        while True:
            i = 10
    if name == 'data_leakage_handling':
        param['values'] = ['leave_one_out', 'k_fold', 'none', 'LeaveOneOut', 'KFold', 'None']
        return param
    return None
extensions = dict(validate_params='\nif (!missing(columns_to_encode))\n  columns_to_encode <- lapply(columns_to_encode, function(x) if(is.character(x) & length(x) == 1) list(x) else x)\n', set_required_params='\nargs <- .verify_dataxy(training_frame, x, y)\nif( !missing(fold_column) && !is.null(fold_column)) args$x_ignore <- args$x_ignore[!( fold_column == args$x_ignore )]\nparms$ignored_columns <- args$x_ignore\nparms$response_column <- args$y\nparms$training_frame <- training_frame\n    ', ellipsis_param='\nvarargs <- list(...)\nfor (arg in names(varargs)) {\n   if (arg == \'k\') {\n      warning("argument \'k\' is deprecated; please use \'inflection_point\' instead.")\n      if (missing(inflection_point)) inflection_point <- varargs$k else warning("ignoring \'k\' as \'inflection_point\' was also provided.")\n   } else if (arg == \'f\') {\n      warning("argument \'f\' is deprecated; please use \'smoothing\' instead.")\n      if (missing(smoothing)) smoothing <- varargs$f else warning("ignoring \'f\' as \'smoothing\' was also provided.")\n   } else if (arg == \'noise_level\') {\n      warning("argument \'noise_level\' is deprecated; please use \'noise\' instead.")\n      if (missing(noise)) noise <- varargs$noise_level else warning("ignoring \'noise_level\' as \'noise\' was also provided.")\n   } else {\n      stop(paste("unused argument", arg, "=", varargs[[arg]]))\n   }\n}\n')
doc = dict(preamble='\n Transformation of a categorical variable with a mean value of the target variable\n', params=dict(_ellipsis_='Mainly used for backwards compatibility, to allow deprecated parameters.'), examples='\nlibrary(h2o)\nh2o.init()\n#Import the titanic dataset\nf <- "https://s3.amazonaws.com/h2o-public-test-data/smalldata/gbm_test/titanic.csv"\ntitanic <- h2o.importFile(f)\n\n# Set response as a factor\nresponse <- "survived"\ntitanic[response] <- as.factor(titanic[response])\n\n# Split the dataset into train and test\nsplits <- h2o.splitFrame(data = titanic, ratios = .8, seed = 1234)\ntrain <- splits[[1]]\ntest <- splits[[2]]\n\n# Choose which columns to encode\nencode_columns <- c("home.dest", "cabin", "embarked")\n\n# Train a TE model\nte_model <- h2o.targetencoder(x = encode_columns,\n                              y = response, \n                              training_frame = train,\n                              fold_column = "pclass", \n                              data_leakage_handling = "KFold")\n\n# New target encoded train and test sets\ntrain_te <- h2o.transform(te_model, train)\ntest_te <- h2o.transform(te_model, test)\n')