[
    {
        "func_name": "sequenceReconstruction",
        "original": "def sequenceReconstruction(self, org, seqs):\n    \"\"\"\n        :type org: List[int]\n        :type seqs: List[List[int]]\n        :rtype: bool\n        \"\"\"\n    if not seqs:\n        return False\n    pos = [0] * (len(org) + 1)\n    for i in xrange(len(org)):\n        pos[org[i]] = i\n    is_matched = [False] * (len(org) + 1)\n    cnt_to_match = len(org) - 1\n    for seq in seqs:\n        for i in xrange(len(seq)):\n            if not 0 < seq[i] <= len(org):\n                return False\n            if i == 0:\n                continue\n            if pos[seq[i - 1]] >= pos[seq[i]]:\n                return False\n            if is_matched[seq[i - 1]] == False and pos[seq[i - 1]] + 1 == pos[seq[i]]:\n                is_matched[seq[i - 1]] = True\n                cnt_to_match -= 1\n    return cnt_to_match == 0",
        "mutated": [
            "def sequenceReconstruction(self, org, seqs):\n    if False:\n        i = 10\n    '\\n        :type org: List[int]\\n        :type seqs: List[List[int]]\\n        :rtype: bool\\n        '\n    if not seqs:\n        return False\n    pos = [0] * (len(org) + 1)\n    for i in xrange(len(org)):\n        pos[org[i]] = i\n    is_matched = [False] * (len(org) + 1)\n    cnt_to_match = len(org) - 1\n    for seq in seqs:\n        for i in xrange(len(seq)):\n            if not 0 < seq[i] <= len(org):\n                return False\n            if i == 0:\n                continue\n            if pos[seq[i - 1]] >= pos[seq[i]]:\n                return False\n            if is_matched[seq[i - 1]] == False and pos[seq[i - 1]] + 1 == pos[seq[i]]:\n                is_matched[seq[i - 1]] = True\n                cnt_to_match -= 1\n    return cnt_to_match == 0",
            "def sequenceReconstruction(self, org, seqs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :type org: List[int]\\n        :type seqs: List[List[int]]\\n        :rtype: bool\\n        '\n    if not seqs:\n        return False\n    pos = [0] * (len(org) + 1)\n    for i in xrange(len(org)):\n        pos[org[i]] = i\n    is_matched = [False] * (len(org) + 1)\n    cnt_to_match = len(org) - 1\n    for seq in seqs:\n        for i in xrange(len(seq)):\n            if not 0 < seq[i] <= len(org):\n                return False\n            if i == 0:\n                continue\n            if pos[seq[i - 1]] >= pos[seq[i]]:\n                return False\n            if is_matched[seq[i - 1]] == False and pos[seq[i - 1]] + 1 == pos[seq[i]]:\n                is_matched[seq[i - 1]] = True\n                cnt_to_match -= 1\n    return cnt_to_match == 0",
            "def sequenceReconstruction(self, org, seqs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :type org: List[int]\\n        :type seqs: List[List[int]]\\n        :rtype: bool\\n        '\n    if not seqs:\n        return False\n    pos = [0] * (len(org) + 1)\n    for i in xrange(len(org)):\n        pos[org[i]] = i\n    is_matched = [False] * (len(org) + 1)\n    cnt_to_match = len(org) - 1\n    for seq in seqs:\n        for i in xrange(len(seq)):\n            if not 0 < seq[i] <= len(org):\n                return False\n            if i == 0:\n                continue\n            if pos[seq[i - 1]] >= pos[seq[i]]:\n                return False\n            if is_matched[seq[i - 1]] == False and pos[seq[i - 1]] + 1 == pos[seq[i]]:\n                is_matched[seq[i - 1]] = True\n                cnt_to_match -= 1\n    return cnt_to_match == 0",
            "def sequenceReconstruction(self, org, seqs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :type org: List[int]\\n        :type seqs: List[List[int]]\\n        :rtype: bool\\n        '\n    if not seqs:\n        return False\n    pos = [0] * (len(org) + 1)\n    for i in xrange(len(org)):\n        pos[org[i]] = i\n    is_matched = [False] * (len(org) + 1)\n    cnt_to_match = len(org) - 1\n    for seq in seqs:\n        for i in xrange(len(seq)):\n            if not 0 < seq[i] <= len(org):\n                return False\n            if i == 0:\n                continue\n            if pos[seq[i - 1]] >= pos[seq[i]]:\n                return False\n            if is_matched[seq[i - 1]] == False and pos[seq[i - 1]] + 1 == pos[seq[i]]:\n                is_matched[seq[i - 1]] = True\n                cnt_to_match -= 1\n    return cnt_to_match == 0",
            "def sequenceReconstruction(self, org, seqs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :type org: List[int]\\n        :type seqs: List[List[int]]\\n        :rtype: bool\\n        '\n    if not seqs:\n        return False\n    pos = [0] * (len(org) + 1)\n    for i in xrange(len(org)):\n        pos[org[i]] = i\n    is_matched = [False] * (len(org) + 1)\n    cnt_to_match = len(org) - 1\n    for seq in seqs:\n        for i in xrange(len(seq)):\n            if not 0 < seq[i] <= len(org):\n                return False\n            if i == 0:\n                continue\n            if pos[seq[i - 1]] >= pos[seq[i]]:\n                return False\n            if is_matched[seq[i - 1]] == False and pos[seq[i - 1]] + 1 == pos[seq[i]]:\n                is_matched[seq[i - 1]] = True\n                cnt_to_match -= 1\n    return cnt_to_match == 0"
        ]
    },
    {
        "func_name": "sequenceReconstruction",
        "original": "def sequenceReconstruction(self, org, seqs):\n    \"\"\"\n        :type org: List[int]\n        :type seqs: List[List[int]]\n        :rtype: bool\n        \"\"\"\n    graph = collections.defaultdict(set)\n    indegree = collections.defaultdict(int)\n    integer_set = set()\n    for seq in seqs:\n        for i in seq:\n            integer_set.add(i)\n        if len(seq) == 1:\n            if seq[0] not in indegree:\n                indegree[seq[0]] = 0\n            continue\n        for i in xrange(len(seq) - 1):\n            if seq[i] not in indegree:\n                indegree[seq[i]] = 0\n            if seq[i + 1] not in graph[seq[i]]:\n                graph[seq[i]].add(seq[i + 1])\n                indegree[seq[i + 1]] += 1\n    cnt_of_zero_indegree = 0\n    res = []\n    q = []\n    for i in indegree:\n        if indegree[i] == 0:\n            cnt_of_zero_indegree += 1\n            if cnt_of_zero_indegree > 1:\n                return False\n            q.append(i)\n    while q:\n        i = q.pop()\n        res.append(i)\n        cnt_of_zero_indegree = 0\n        for j in graph[i]:\n            indegree[j] -= 1\n            if indegree[j] == 0:\n                cnt_of_zero_indegree += 1\n                if cnt_of_zero_indegree > 1:\n                    return False\n                q.append(j)\n    return res == org and len(org) == len(integer_set)",
        "mutated": [
            "def sequenceReconstruction(self, org, seqs):\n    if False:\n        i = 10\n    '\\n        :type org: List[int]\\n        :type seqs: List[List[int]]\\n        :rtype: bool\\n        '\n    graph = collections.defaultdict(set)\n    indegree = collections.defaultdict(int)\n    integer_set = set()\n    for seq in seqs:\n        for i in seq:\n            integer_set.add(i)\n        if len(seq) == 1:\n            if seq[0] not in indegree:\n                indegree[seq[0]] = 0\n            continue\n        for i in xrange(len(seq) - 1):\n            if seq[i] not in indegree:\n                indegree[seq[i]] = 0\n            if seq[i + 1] not in graph[seq[i]]:\n                graph[seq[i]].add(seq[i + 1])\n                indegree[seq[i + 1]] += 1\n    cnt_of_zero_indegree = 0\n    res = []\n    q = []\n    for i in indegree:\n        if indegree[i] == 0:\n            cnt_of_zero_indegree += 1\n            if cnt_of_zero_indegree > 1:\n                return False\n            q.append(i)\n    while q:\n        i = q.pop()\n        res.append(i)\n        cnt_of_zero_indegree = 0\n        for j in graph[i]:\n            indegree[j] -= 1\n            if indegree[j] == 0:\n                cnt_of_zero_indegree += 1\n                if cnt_of_zero_indegree > 1:\n                    return False\n                q.append(j)\n    return res == org and len(org) == len(integer_set)",
            "def sequenceReconstruction(self, org, seqs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :type org: List[int]\\n        :type seqs: List[List[int]]\\n        :rtype: bool\\n        '\n    graph = collections.defaultdict(set)\n    indegree = collections.defaultdict(int)\n    integer_set = set()\n    for seq in seqs:\n        for i in seq:\n            integer_set.add(i)\n        if len(seq) == 1:\n            if seq[0] not in indegree:\n                indegree[seq[0]] = 0\n            continue\n        for i in xrange(len(seq) - 1):\n            if seq[i] not in indegree:\n                indegree[seq[i]] = 0\n            if seq[i + 1] not in graph[seq[i]]:\n                graph[seq[i]].add(seq[i + 1])\n                indegree[seq[i + 1]] += 1\n    cnt_of_zero_indegree = 0\n    res = []\n    q = []\n    for i in indegree:\n        if indegree[i] == 0:\n            cnt_of_zero_indegree += 1\n            if cnt_of_zero_indegree > 1:\n                return False\n            q.append(i)\n    while q:\n        i = q.pop()\n        res.append(i)\n        cnt_of_zero_indegree = 0\n        for j in graph[i]:\n            indegree[j] -= 1\n            if indegree[j] == 0:\n                cnt_of_zero_indegree += 1\n                if cnt_of_zero_indegree > 1:\n                    return False\n                q.append(j)\n    return res == org and len(org) == len(integer_set)",
            "def sequenceReconstruction(self, org, seqs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :type org: List[int]\\n        :type seqs: List[List[int]]\\n        :rtype: bool\\n        '\n    graph = collections.defaultdict(set)\n    indegree = collections.defaultdict(int)\n    integer_set = set()\n    for seq in seqs:\n        for i in seq:\n            integer_set.add(i)\n        if len(seq) == 1:\n            if seq[0] not in indegree:\n                indegree[seq[0]] = 0\n            continue\n        for i in xrange(len(seq) - 1):\n            if seq[i] not in indegree:\n                indegree[seq[i]] = 0\n            if seq[i + 1] not in graph[seq[i]]:\n                graph[seq[i]].add(seq[i + 1])\n                indegree[seq[i + 1]] += 1\n    cnt_of_zero_indegree = 0\n    res = []\n    q = []\n    for i in indegree:\n        if indegree[i] == 0:\n            cnt_of_zero_indegree += 1\n            if cnt_of_zero_indegree > 1:\n                return False\n            q.append(i)\n    while q:\n        i = q.pop()\n        res.append(i)\n        cnt_of_zero_indegree = 0\n        for j in graph[i]:\n            indegree[j] -= 1\n            if indegree[j] == 0:\n                cnt_of_zero_indegree += 1\n                if cnt_of_zero_indegree > 1:\n                    return False\n                q.append(j)\n    return res == org and len(org) == len(integer_set)",
            "def sequenceReconstruction(self, org, seqs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :type org: List[int]\\n        :type seqs: List[List[int]]\\n        :rtype: bool\\n        '\n    graph = collections.defaultdict(set)\n    indegree = collections.defaultdict(int)\n    integer_set = set()\n    for seq in seqs:\n        for i in seq:\n            integer_set.add(i)\n        if len(seq) == 1:\n            if seq[0] not in indegree:\n                indegree[seq[0]] = 0\n            continue\n        for i in xrange(len(seq) - 1):\n            if seq[i] not in indegree:\n                indegree[seq[i]] = 0\n            if seq[i + 1] not in graph[seq[i]]:\n                graph[seq[i]].add(seq[i + 1])\n                indegree[seq[i + 1]] += 1\n    cnt_of_zero_indegree = 0\n    res = []\n    q = []\n    for i in indegree:\n        if indegree[i] == 0:\n            cnt_of_zero_indegree += 1\n            if cnt_of_zero_indegree > 1:\n                return False\n            q.append(i)\n    while q:\n        i = q.pop()\n        res.append(i)\n        cnt_of_zero_indegree = 0\n        for j in graph[i]:\n            indegree[j] -= 1\n            if indegree[j] == 0:\n                cnt_of_zero_indegree += 1\n                if cnt_of_zero_indegree > 1:\n                    return False\n                q.append(j)\n    return res == org and len(org) == len(integer_set)",
            "def sequenceReconstruction(self, org, seqs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :type org: List[int]\\n        :type seqs: List[List[int]]\\n        :rtype: bool\\n        '\n    graph = collections.defaultdict(set)\n    indegree = collections.defaultdict(int)\n    integer_set = set()\n    for seq in seqs:\n        for i in seq:\n            integer_set.add(i)\n        if len(seq) == 1:\n            if seq[0] not in indegree:\n                indegree[seq[0]] = 0\n            continue\n        for i in xrange(len(seq) - 1):\n            if seq[i] not in indegree:\n                indegree[seq[i]] = 0\n            if seq[i + 1] not in graph[seq[i]]:\n                graph[seq[i]].add(seq[i + 1])\n                indegree[seq[i + 1]] += 1\n    cnt_of_zero_indegree = 0\n    res = []\n    q = []\n    for i in indegree:\n        if indegree[i] == 0:\n            cnt_of_zero_indegree += 1\n            if cnt_of_zero_indegree > 1:\n                return False\n            q.append(i)\n    while q:\n        i = q.pop()\n        res.append(i)\n        cnt_of_zero_indegree = 0\n        for j in graph[i]:\n            indegree[j] -= 1\n            if indegree[j] == 0:\n                cnt_of_zero_indegree += 1\n                if cnt_of_zero_indegree > 1:\n                    return False\n                q.append(j)\n    return res == org and len(org) == len(integer_set)"
        ]
    }
]