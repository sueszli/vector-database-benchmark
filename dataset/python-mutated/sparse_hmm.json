[
    {
        "func_name": "unpack_edges",
        "original": "def unpack_edges(self, edges, starts, ends):\n    \"\"\"Unpack the edges for a sparse hidden Markov model.\n\n\tThis function takes in a SparseHMM object and sets of edges and adds the\n\tedges to the model. It is designed to allow the model to be initialized\n\teither through passing in the edges initially or created through the\n\t`add_edge` API. Doing this is slightly more complicated than in the\n\tDenseHMM case because we use an underlying sparse representation to store\n\tthe edges and so cannot as easily simply modify a random element in each\n\tcall to `add_edge`. \n\n\n\tParameters\n\t----------\n\tself: SparseHMM\n\t\tA torchegranate sparse HMM.\n\n\tedges: list\n\t\tA list of 3-ples that consist of the parent distribution, the child\n\t\tdistribution, and the probability on that edge.\n\n\tstarts: list, tuple, numpy.ndarray, torch.tensor\n\t\tA vector of probabilities indicating the probability of starting in\n\t\teach state. Must sum to 1.0.\n\n\tends: list, tuple, numpy.ndarray, torch.tensor\n\t\tA vector of probabilities indicating the probability of ending at\n\t\teach state. Does not have to sum to 1.0.\n\t\"\"\"\n    self.n_edges = len(edges)\n    n = len(self.distributions)\n    self.starts = None\n    if starts is not None:\n        self.starts = torch.log(_check_parameter(_cast_as_parameter(starts), 'starts', ndim=1, shape=(n,), min_value=0.0, max_value=1.0, value_sum=1.0))\n    if ends is None:\n        self.ends = torch.empty(n, dtype=self.dtype, device=self.device) - inf\n    else:\n        self.ends = torch.log(_check_parameter(_cast_as_parameter(ends), 'ends', ndim=1, shape=(n,), min_value=0.0, max_value=1.0))\n    _edge_idx_starts = torch.empty(self.n_edges, dtype=torch.int64, device=self.device)\n    _edge_idx_ends = torch.empty(self.n_edges, dtype=torch.int64, device=self.device)\n    _edge_log_probs = torch.empty(self.n_edges, dtype=self.dtype, device=self.device)\n    idx = 0\n    for edge in edges:\n        if not hasattr(edge, '__len__') or len(edge) != 3:\n            raise ValueError('Each edge must have three elements.')\n        (ni, nj, probability) = edge\n        if not isinstance(ni, Distribution):\n            raise ValueError('First element must be a distribution.')\n        if not isinstance(nj, Distribution):\n            raise ValueError('Second element must be a distribution.')\n        if not isinstance(probability, float):\n            raise ValueError('Third element must be a float.')\n        if probability < 0 or probability > 1:\n            raise ValueError('Third element must be between 0 and 1.')\n        if ni is self.start:\n            if self.starts is None:\n                self.starts = torch.zeros(n, dtype=self.dtype, device=self.device) - inf\n            j = self.distributions.index(nj)\n            self.starts[j] = math.log(probability)\n        elif nj is self.end:\n            i = self.distributions.index(ni)\n            self.ends[i] = math.log(probability)\n        else:\n            i = self.distributions.index(ni)\n            j = self.distributions.index(nj)\n            _edge_idx_starts[idx] = i\n            _edge_idx_ends[idx] = j\n            _edge_log_probs[idx] = math.log(probability)\n            idx += 1\n    self._edge_idx_starts = _cast_as_parameter(_edge_idx_starts[:idx])\n    self._edge_idx_ends = _cast_as_parameter(_edge_idx_ends[:idx])\n    self._edge_log_probs = _cast_as_parameter(_edge_log_probs[:idx])\n    self.n_edges = idx\n    self.edges = self._edge_log_probs\n    if idx == 0:\n        raise ValueError('Must pass in edges to a sparse model, cannot ' + 'be uniformly initialized or it would be a dense model.')\n    self._edge_keymap = {}\n    for i in range(idx):\n        start = self._edge_idx_starts[i].item()\n        end = self._edge_idx_ends[i].item()\n        self._edge_keymap[start, end] = i\n    if self.starts is None:\n        self.starts = torch.log(torch.ones(n, dtype=self.dtype, device=self.device) / n)\n    self.starts = _cast_as_parameter(self.starts)\n    self.ends = _cast_as_parameter(self.ends)",
        "mutated": [
            "def unpack_edges(self, edges, starts, ends):\n    if False:\n        i = 10\n    'Unpack the edges for a sparse hidden Markov model.\\n\\n\\tThis function takes in a SparseHMM object and sets of edges and adds the\\n\\tedges to the model. It is designed to allow the model to be initialized\\n\\teither through passing in the edges initially or created through the\\n\\t`add_edge` API. Doing this is slightly more complicated than in the\\n\\tDenseHMM case because we use an underlying sparse representation to store\\n\\tthe edges and so cannot as easily simply modify a random element in each\\n\\tcall to `add_edge`. \\n\\n\\n\\tParameters\\n\\t----------\\n\\tself: SparseHMM\\n\\t\\tA torchegranate sparse HMM.\\n\\n\\tedges: list\\n\\t\\tA list of 3-ples that consist of the parent distribution, the child\\n\\t\\tdistribution, and the probability on that edge.\\n\\n\\tstarts: list, tuple, numpy.ndarray, torch.tensor\\n\\t\\tA vector of probabilities indicating the probability of starting in\\n\\t\\teach state. Must sum to 1.0.\\n\\n\\tends: list, tuple, numpy.ndarray, torch.tensor\\n\\t\\tA vector of probabilities indicating the probability of ending at\\n\\t\\teach state. Does not have to sum to 1.0.\\n\\t'\n    self.n_edges = len(edges)\n    n = len(self.distributions)\n    self.starts = None\n    if starts is not None:\n        self.starts = torch.log(_check_parameter(_cast_as_parameter(starts), 'starts', ndim=1, shape=(n,), min_value=0.0, max_value=1.0, value_sum=1.0))\n    if ends is None:\n        self.ends = torch.empty(n, dtype=self.dtype, device=self.device) - inf\n    else:\n        self.ends = torch.log(_check_parameter(_cast_as_parameter(ends), 'ends', ndim=1, shape=(n,), min_value=0.0, max_value=1.0))\n    _edge_idx_starts = torch.empty(self.n_edges, dtype=torch.int64, device=self.device)\n    _edge_idx_ends = torch.empty(self.n_edges, dtype=torch.int64, device=self.device)\n    _edge_log_probs = torch.empty(self.n_edges, dtype=self.dtype, device=self.device)\n    idx = 0\n    for edge in edges:\n        if not hasattr(edge, '__len__') or len(edge) != 3:\n            raise ValueError('Each edge must have three elements.')\n        (ni, nj, probability) = edge\n        if not isinstance(ni, Distribution):\n            raise ValueError('First element must be a distribution.')\n        if not isinstance(nj, Distribution):\n            raise ValueError('Second element must be a distribution.')\n        if not isinstance(probability, float):\n            raise ValueError('Third element must be a float.')\n        if probability < 0 or probability > 1:\n            raise ValueError('Third element must be between 0 and 1.')\n        if ni is self.start:\n            if self.starts is None:\n                self.starts = torch.zeros(n, dtype=self.dtype, device=self.device) - inf\n            j = self.distributions.index(nj)\n            self.starts[j] = math.log(probability)\n        elif nj is self.end:\n            i = self.distributions.index(ni)\n            self.ends[i] = math.log(probability)\n        else:\n            i = self.distributions.index(ni)\n            j = self.distributions.index(nj)\n            _edge_idx_starts[idx] = i\n            _edge_idx_ends[idx] = j\n            _edge_log_probs[idx] = math.log(probability)\n            idx += 1\n    self._edge_idx_starts = _cast_as_parameter(_edge_idx_starts[:idx])\n    self._edge_idx_ends = _cast_as_parameter(_edge_idx_ends[:idx])\n    self._edge_log_probs = _cast_as_parameter(_edge_log_probs[:idx])\n    self.n_edges = idx\n    self.edges = self._edge_log_probs\n    if idx == 0:\n        raise ValueError('Must pass in edges to a sparse model, cannot ' + 'be uniformly initialized or it would be a dense model.')\n    self._edge_keymap = {}\n    for i in range(idx):\n        start = self._edge_idx_starts[i].item()\n        end = self._edge_idx_ends[i].item()\n        self._edge_keymap[start, end] = i\n    if self.starts is None:\n        self.starts = torch.log(torch.ones(n, dtype=self.dtype, device=self.device) / n)\n    self.starts = _cast_as_parameter(self.starts)\n    self.ends = _cast_as_parameter(self.ends)",
            "def unpack_edges(self, edges, starts, ends):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Unpack the edges for a sparse hidden Markov model.\\n\\n\\tThis function takes in a SparseHMM object and sets of edges and adds the\\n\\tedges to the model. It is designed to allow the model to be initialized\\n\\teither through passing in the edges initially or created through the\\n\\t`add_edge` API. Doing this is slightly more complicated than in the\\n\\tDenseHMM case because we use an underlying sparse representation to store\\n\\tthe edges and so cannot as easily simply modify a random element in each\\n\\tcall to `add_edge`. \\n\\n\\n\\tParameters\\n\\t----------\\n\\tself: SparseHMM\\n\\t\\tA torchegranate sparse HMM.\\n\\n\\tedges: list\\n\\t\\tA list of 3-ples that consist of the parent distribution, the child\\n\\t\\tdistribution, and the probability on that edge.\\n\\n\\tstarts: list, tuple, numpy.ndarray, torch.tensor\\n\\t\\tA vector of probabilities indicating the probability of starting in\\n\\t\\teach state. Must sum to 1.0.\\n\\n\\tends: list, tuple, numpy.ndarray, torch.tensor\\n\\t\\tA vector of probabilities indicating the probability of ending at\\n\\t\\teach state. Does not have to sum to 1.0.\\n\\t'\n    self.n_edges = len(edges)\n    n = len(self.distributions)\n    self.starts = None\n    if starts is not None:\n        self.starts = torch.log(_check_parameter(_cast_as_parameter(starts), 'starts', ndim=1, shape=(n,), min_value=0.0, max_value=1.0, value_sum=1.0))\n    if ends is None:\n        self.ends = torch.empty(n, dtype=self.dtype, device=self.device) - inf\n    else:\n        self.ends = torch.log(_check_parameter(_cast_as_parameter(ends), 'ends', ndim=1, shape=(n,), min_value=0.0, max_value=1.0))\n    _edge_idx_starts = torch.empty(self.n_edges, dtype=torch.int64, device=self.device)\n    _edge_idx_ends = torch.empty(self.n_edges, dtype=torch.int64, device=self.device)\n    _edge_log_probs = torch.empty(self.n_edges, dtype=self.dtype, device=self.device)\n    idx = 0\n    for edge in edges:\n        if not hasattr(edge, '__len__') or len(edge) != 3:\n            raise ValueError('Each edge must have three elements.')\n        (ni, nj, probability) = edge\n        if not isinstance(ni, Distribution):\n            raise ValueError('First element must be a distribution.')\n        if not isinstance(nj, Distribution):\n            raise ValueError('Second element must be a distribution.')\n        if not isinstance(probability, float):\n            raise ValueError('Third element must be a float.')\n        if probability < 0 or probability > 1:\n            raise ValueError('Third element must be between 0 and 1.')\n        if ni is self.start:\n            if self.starts is None:\n                self.starts = torch.zeros(n, dtype=self.dtype, device=self.device) - inf\n            j = self.distributions.index(nj)\n            self.starts[j] = math.log(probability)\n        elif nj is self.end:\n            i = self.distributions.index(ni)\n            self.ends[i] = math.log(probability)\n        else:\n            i = self.distributions.index(ni)\n            j = self.distributions.index(nj)\n            _edge_idx_starts[idx] = i\n            _edge_idx_ends[idx] = j\n            _edge_log_probs[idx] = math.log(probability)\n            idx += 1\n    self._edge_idx_starts = _cast_as_parameter(_edge_idx_starts[:idx])\n    self._edge_idx_ends = _cast_as_parameter(_edge_idx_ends[:idx])\n    self._edge_log_probs = _cast_as_parameter(_edge_log_probs[:idx])\n    self.n_edges = idx\n    self.edges = self._edge_log_probs\n    if idx == 0:\n        raise ValueError('Must pass in edges to a sparse model, cannot ' + 'be uniformly initialized or it would be a dense model.')\n    self._edge_keymap = {}\n    for i in range(idx):\n        start = self._edge_idx_starts[i].item()\n        end = self._edge_idx_ends[i].item()\n        self._edge_keymap[start, end] = i\n    if self.starts is None:\n        self.starts = torch.log(torch.ones(n, dtype=self.dtype, device=self.device) / n)\n    self.starts = _cast_as_parameter(self.starts)\n    self.ends = _cast_as_parameter(self.ends)",
            "def unpack_edges(self, edges, starts, ends):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Unpack the edges for a sparse hidden Markov model.\\n\\n\\tThis function takes in a SparseHMM object and sets of edges and adds the\\n\\tedges to the model. It is designed to allow the model to be initialized\\n\\teither through passing in the edges initially or created through the\\n\\t`add_edge` API. Doing this is slightly more complicated than in the\\n\\tDenseHMM case because we use an underlying sparse representation to store\\n\\tthe edges and so cannot as easily simply modify a random element in each\\n\\tcall to `add_edge`. \\n\\n\\n\\tParameters\\n\\t----------\\n\\tself: SparseHMM\\n\\t\\tA torchegranate sparse HMM.\\n\\n\\tedges: list\\n\\t\\tA list of 3-ples that consist of the parent distribution, the child\\n\\t\\tdistribution, and the probability on that edge.\\n\\n\\tstarts: list, tuple, numpy.ndarray, torch.tensor\\n\\t\\tA vector of probabilities indicating the probability of starting in\\n\\t\\teach state. Must sum to 1.0.\\n\\n\\tends: list, tuple, numpy.ndarray, torch.tensor\\n\\t\\tA vector of probabilities indicating the probability of ending at\\n\\t\\teach state. Does not have to sum to 1.0.\\n\\t'\n    self.n_edges = len(edges)\n    n = len(self.distributions)\n    self.starts = None\n    if starts is not None:\n        self.starts = torch.log(_check_parameter(_cast_as_parameter(starts), 'starts', ndim=1, shape=(n,), min_value=0.0, max_value=1.0, value_sum=1.0))\n    if ends is None:\n        self.ends = torch.empty(n, dtype=self.dtype, device=self.device) - inf\n    else:\n        self.ends = torch.log(_check_parameter(_cast_as_parameter(ends), 'ends', ndim=1, shape=(n,), min_value=0.0, max_value=1.0))\n    _edge_idx_starts = torch.empty(self.n_edges, dtype=torch.int64, device=self.device)\n    _edge_idx_ends = torch.empty(self.n_edges, dtype=torch.int64, device=self.device)\n    _edge_log_probs = torch.empty(self.n_edges, dtype=self.dtype, device=self.device)\n    idx = 0\n    for edge in edges:\n        if not hasattr(edge, '__len__') or len(edge) != 3:\n            raise ValueError('Each edge must have three elements.')\n        (ni, nj, probability) = edge\n        if not isinstance(ni, Distribution):\n            raise ValueError('First element must be a distribution.')\n        if not isinstance(nj, Distribution):\n            raise ValueError('Second element must be a distribution.')\n        if not isinstance(probability, float):\n            raise ValueError('Third element must be a float.')\n        if probability < 0 or probability > 1:\n            raise ValueError('Third element must be between 0 and 1.')\n        if ni is self.start:\n            if self.starts is None:\n                self.starts = torch.zeros(n, dtype=self.dtype, device=self.device) - inf\n            j = self.distributions.index(nj)\n            self.starts[j] = math.log(probability)\n        elif nj is self.end:\n            i = self.distributions.index(ni)\n            self.ends[i] = math.log(probability)\n        else:\n            i = self.distributions.index(ni)\n            j = self.distributions.index(nj)\n            _edge_idx_starts[idx] = i\n            _edge_idx_ends[idx] = j\n            _edge_log_probs[idx] = math.log(probability)\n            idx += 1\n    self._edge_idx_starts = _cast_as_parameter(_edge_idx_starts[:idx])\n    self._edge_idx_ends = _cast_as_parameter(_edge_idx_ends[:idx])\n    self._edge_log_probs = _cast_as_parameter(_edge_log_probs[:idx])\n    self.n_edges = idx\n    self.edges = self._edge_log_probs\n    if idx == 0:\n        raise ValueError('Must pass in edges to a sparse model, cannot ' + 'be uniformly initialized or it would be a dense model.')\n    self._edge_keymap = {}\n    for i in range(idx):\n        start = self._edge_idx_starts[i].item()\n        end = self._edge_idx_ends[i].item()\n        self._edge_keymap[start, end] = i\n    if self.starts is None:\n        self.starts = torch.log(torch.ones(n, dtype=self.dtype, device=self.device) / n)\n    self.starts = _cast_as_parameter(self.starts)\n    self.ends = _cast_as_parameter(self.ends)",
            "def unpack_edges(self, edges, starts, ends):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Unpack the edges for a sparse hidden Markov model.\\n\\n\\tThis function takes in a SparseHMM object and sets of edges and adds the\\n\\tedges to the model. It is designed to allow the model to be initialized\\n\\teither through passing in the edges initially or created through the\\n\\t`add_edge` API. Doing this is slightly more complicated than in the\\n\\tDenseHMM case because we use an underlying sparse representation to store\\n\\tthe edges and so cannot as easily simply modify a random element in each\\n\\tcall to `add_edge`. \\n\\n\\n\\tParameters\\n\\t----------\\n\\tself: SparseHMM\\n\\t\\tA torchegranate sparse HMM.\\n\\n\\tedges: list\\n\\t\\tA list of 3-ples that consist of the parent distribution, the child\\n\\t\\tdistribution, and the probability on that edge.\\n\\n\\tstarts: list, tuple, numpy.ndarray, torch.tensor\\n\\t\\tA vector of probabilities indicating the probability of starting in\\n\\t\\teach state. Must sum to 1.0.\\n\\n\\tends: list, tuple, numpy.ndarray, torch.tensor\\n\\t\\tA vector of probabilities indicating the probability of ending at\\n\\t\\teach state. Does not have to sum to 1.0.\\n\\t'\n    self.n_edges = len(edges)\n    n = len(self.distributions)\n    self.starts = None\n    if starts is not None:\n        self.starts = torch.log(_check_parameter(_cast_as_parameter(starts), 'starts', ndim=1, shape=(n,), min_value=0.0, max_value=1.0, value_sum=1.0))\n    if ends is None:\n        self.ends = torch.empty(n, dtype=self.dtype, device=self.device) - inf\n    else:\n        self.ends = torch.log(_check_parameter(_cast_as_parameter(ends), 'ends', ndim=1, shape=(n,), min_value=0.0, max_value=1.0))\n    _edge_idx_starts = torch.empty(self.n_edges, dtype=torch.int64, device=self.device)\n    _edge_idx_ends = torch.empty(self.n_edges, dtype=torch.int64, device=self.device)\n    _edge_log_probs = torch.empty(self.n_edges, dtype=self.dtype, device=self.device)\n    idx = 0\n    for edge in edges:\n        if not hasattr(edge, '__len__') or len(edge) != 3:\n            raise ValueError('Each edge must have three elements.')\n        (ni, nj, probability) = edge\n        if not isinstance(ni, Distribution):\n            raise ValueError('First element must be a distribution.')\n        if not isinstance(nj, Distribution):\n            raise ValueError('Second element must be a distribution.')\n        if not isinstance(probability, float):\n            raise ValueError('Third element must be a float.')\n        if probability < 0 or probability > 1:\n            raise ValueError('Third element must be between 0 and 1.')\n        if ni is self.start:\n            if self.starts is None:\n                self.starts = torch.zeros(n, dtype=self.dtype, device=self.device) - inf\n            j = self.distributions.index(nj)\n            self.starts[j] = math.log(probability)\n        elif nj is self.end:\n            i = self.distributions.index(ni)\n            self.ends[i] = math.log(probability)\n        else:\n            i = self.distributions.index(ni)\n            j = self.distributions.index(nj)\n            _edge_idx_starts[idx] = i\n            _edge_idx_ends[idx] = j\n            _edge_log_probs[idx] = math.log(probability)\n            idx += 1\n    self._edge_idx_starts = _cast_as_parameter(_edge_idx_starts[:idx])\n    self._edge_idx_ends = _cast_as_parameter(_edge_idx_ends[:idx])\n    self._edge_log_probs = _cast_as_parameter(_edge_log_probs[:idx])\n    self.n_edges = idx\n    self.edges = self._edge_log_probs\n    if idx == 0:\n        raise ValueError('Must pass in edges to a sparse model, cannot ' + 'be uniformly initialized or it would be a dense model.')\n    self._edge_keymap = {}\n    for i in range(idx):\n        start = self._edge_idx_starts[i].item()\n        end = self._edge_idx_ends[i].item()\n        self._edge_keymap[start, end] = i\n    if self.starts is None:\n        self.starts = torch.log(torch.ones(n, dtype=self.dtype, device=self.device) / n)\n    self.starts = _cast_as_parameter(self.starts)\n    self.ends = _cast_as_parameter(self.ends)",
            "def unpack_edges(self, edges, starts, ends):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Unpack the edges for a sparse hidden Markov model.\\n\\n\\tThis function takes in a SparseHMM object and sets of edges and adds the\\n\\tedges to the model. It is designed to allow the model to be initialized\\n\\teither through passing in the edges initially or created through the\\n\\t`add_edge` API. Doing this is slightly more complicated than in the\\n\\tDenseHMM case because we use an underlying sparse representation to store\\n\\tthe edges and so cannot as easily simply modify a random element in each\\n\\tcall to `add_edge`. \\n\\n\\n\\tParameters\\n\\t----------\\n\\tself: SparseHMM\\n\\t\\tA torchegranate sparse HMM.\\n\\n\\tedges: list\\n\\t\\tA list of 3-ples that consist of the parent distribution, the child\\n\\t\\tdistribution, and the probability on that edge.\\n\\n\\tstarts: list, tuple, numpy.ndarray, torch.tensor\\n\\t\\tA vector of probabilities indicating the probability of starting in\\n\\t\\teach state. Must sum to 1.0.\\n\\n\\tends: list, tuple, numpy.ndarray, torch.tensor\\n\\t\\tA vector of probabilities indicating the probability of ending at\\n\\t\\teach state. Does not have to sum to 1.0.\\n\\t'\n    self.n_edges = len(edges)\n    n = len(self.distributions)\n    self.starts = None\n    if starts is not None:\n        self.starts = torch.log(_check_parameter(_cast_as_parameter(starts), 'starts', ndim=1, shape=(n,), min_value=0.0, max_value=1.0, value_sum=1.0))\n    if ends is None:\n        self.ends = torch.empty(n, dtype=self.dtype, device=self.device) - inf\n    else:\n        self.ends = torch.log(_check_parameter(_cast_as_parameter(ends), 'ends', ndim=1, shape=(n,), min_value=0.0, max_value=1.0))\n    _edge_idx_starts = torch.empty(self.n_edges, dtype=torch.int64, device=self.device)\n    _edge_idx_ends = torch.empty(self.n_edges, dtype=torch.int64, device=self.device)\n    _edge_log_probs = torch.empty(self.n_edges, dtype=self.dtype, device=self.device)\n    idx = 0\n    for edge in edges:\n        if not hasattr(edge, '__len__') or len(edge) != 3:\n            raise ValueError('Each edge must have three elements.')\n        (ni, nj, probability) = edge\n        if not isinstance(ni, Distribution):\n            raise ValueError('First element must be a distribution.')\n        if not isinstance(nj, Distribution):\n            raise ValueError('Second element must be a distribution.')\n        if not isinstance(probability, float):\n            raise ValueError('Third element must be a float.')\n        if probability < 0 or probability > 1:\n            raise ValueError('Third element must be between 0 and 1.')\n        if ni is self.start:\n            if self.starts is None:\n                self.starts = torch.zeros(n, dtype=self.dtype, device=self.device) - inf\n            j = self.distributions.index(nj)\n            self.starts[j] = math.log(probability)\n        elif nj is self.end:\n            i = self.distributions.index(ni)\n            self.ends[i] = math.log(probability)\n        else:\n            i = self.distributions.index(ni)\n            j = self.distributions.index(nj)\n            _edge_idx_starts[idx] = i\n            _edge_idx_ends[idx] = j\n            _edge_log_probs[idx] = math.log(probability)\n            idx += 1\n    self._edge_idx_starts = _cast_as_parameter(_edge_idx_starts[:idx])\n    self._edge_idx_ends = _cast_as_parameter(_edge_idx_ends[:idx])\n    self._edge_log_probs = _cast_as_parameter(_edge_log_probs[:idx])\n    self.n_edges = idx\n    self.edges = self._edge_log_probs\n    if idx == 0:\n        raise ValueError('Must pass in edges to a sparse model, cannot ' + 'be uniformly initialized or it would be a dense model.')\n    self._edge_keymap = {}\n    for i in range(idx):\n        start = self._edge_idx_starts[i].item()\n        end = self._edge_idx_ends[i].item()\n        self._edge_keymap[start, end] = i\n    if self.starts is None:\n        self.starts = torch.log(torch.ones(n, dtype=self.dtype, device=self.device) / n)\n    self.starts = _cast_as_parameter(self.starts)\n    self.ends = _cast_as_parameter(self.ends)"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, distributions=None, edges=None, starts=None, ends=None, init='random', max_iter=1000, tol=0.1, sample_length=None, return_sample_paths=False, inertia=0.0, frozen=False, check_data=True, random_state=None, verbose=False):\n    super().__init__(distributions=distributions, starts=starts, ends=ends, init=init, max_iter=max_iter, tol=tol, sample_length=sample_length, return_sample_paths=return_sample_paths, inertia=inertia, frozen=frozen, check_data=check_data, random_state=random_state, verbose=verbose)\n    self.name = 'SparseHMM'\n    if edges is not None:\n        unpack_edges(self, edges, starts, ends)\n        self.n_edges = len(edges)\n    self._initialized = False\n    if self.distributions is not None:\n        if self.ends is not None:\n            if self.starts is not None:\n                if all((d._initialized for d in self.distributions)):\n                    self._initialized = True\n                    self.distributions = torch.nn.ModuleList(self.distributions)\n    self._reset_cache()",
        "mutated": [
            "def __init__(self, distributions=None, edges=None, starts=None, ends=None, init='random', max_iter=1000, tol=0.1, sample_length=None, return_sample_paths=False, inertia=0.0, frozen=False, check_data=True, random_state=None, verbose=False):\n    if False:\n        i = 10\n    super().__init__(distributions=distributions, starts=starts, ends=ends, init=init, max_iter=max_iter, tol=tol, sample_length=sample_length, return_sample_paths=return_sample_paths, inertia=inertia, frozen=frozen, check_data=check_data, random_state=random_state, verbose=verbose)\n    self.name = 'SparseHMM'\n    if edges is not None:\n        unpack_edges(self, edges, starts, ends)\n        self.n_edges = len(edges)\n    self._initialized = False\n    if self.distributions is not None:\n        if self.ends is not None:\n            if self.starts is not None:\n                if all((d._initialized for d in self.distributions)):\n                    self._initialized = True\n                    self.distributions = torch.nn.ModuleList(self.distributions)\n    self._reset_cache()",
            "def __init__(self, distributions=None, edges=None, starts=None, ends=None, init='random', max_iter=1000, tol=0.1, sample_length=None, return_sample_paths=False, inertia=0.0, frozen=False, check_data=True, random_state=None, verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super().__init__(distributions=distributions, starts=starts, ends=ends, init=init, max_iter=max_iter, tol=tol, sample_length=sample_length, return_sample_paths=return_sample_paths, inertia=inertia, frozen=frozen, check_data=check_data, random_state=random_state, verbose=verbose)\n    self.name = 'SparseHMM'\n    if edges is not None:\n        unpack_edges(self, edges, starts, ends)\n        self.n_edges = len(edges)\n    self._initialized = False\n    if self.distributions is not None:\n        if self.ends is not None:\n            if self.starts is not None:\n                if all((d._initialized for d in self.distributions)):\n                    self._initialized = True\n                    self.distributions = torch.nn.ModuleList(self.distributions)\n    self._reset_cache()",
            "def __init__(self, distributions=None, edges=None, starts=None, ends=None, init='random', max_iter=1000, tol=0.1, sample_length=None, return_sample_paths=False, inertia=0.0, frozen=False, check_data=True, random_state=None, verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super().__init__(distributions=distributions, starts=starts, ends=ends, init=init, max_iter=max_iter, tol=tol, sample_length=sample_length, return_sample_paths=return_sample_paths, inertia=inertia, frozen=frozen, check_data=check_data, random_state=random_state, verbose=verbose)\n    self.name = 'SparseHMM'\n    if edges is not None:\n        unpack_edges(self, edges, starts, ends)\n        self.n_edges = len(edges)\n    self._initialized = False\n    if self.distributions is not None:\n        if self.ends is not None:\n            if self.starts is not None:\n                if all((d._initialized for d in self.distributions)):\n                    self._initialized = True\n                    self.distributions = torch.nn.ModuleList(self.distributions)\n    self._reset_cache()",
            "def __init__(self, distributions=None, edges=None, starts=None, ends=None, init='random', max_iter=1000, tol=0.1, sample_length=None, return_sample_paths=False, inertia=0.0, frozen=False, check_data=True, random_state=None, verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super().__init__(distributions=distributions, starts=starts, ends=ends, init=init, max_iter=max_iter, tol=tol, sample_length=sample_length, return_sample_paths=return_sample_paths, inertia=inertia, frozen=frozen, check_data=check_data, random_state=random_state, verbose=verbose)\n    self.name = 'SparseHMM'\n    if edges is not None:\n        unpack_edges(self, edges, starts, ends)\n        self.n_edges = len(edges)\n    self._initialized = False\n    if self.distributions is not None:\n        if self.ends is not None:\n            if self.starts is not None:\n                if all((d._initialized for d in self.distributions)):\n                    self._initialized = True\n                    self.distributions = torch.nn.ModuleList(self.distributions)\n    self._reset_cache()",
            "def __init__(self, distributions=None, edges=None, starts=None, ends=None, init='random', max_iter=1000, tol=0.1, sample_length=None, return_sample_paths=False, inertia=0.0, frozen=False, check_data=True, random_state=None, verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super().__init__(distributions=distributions, starts=starts, ends=ends, init=init, max_iter=max_iter, tol=tol, sample_length=sample_length, return_sample_paths=return_sample_paths, inertia=inertia, frozen=frozen, check_data=check_data, random_state=random_state, verbose=verbose)\n    self.name = 'SparseHMM'\n    if edges is not None:\n        unpack_edges(self, edges, starts, ends)\n        self.n_edges = len(edges)\n    self._initialized = False\n    if self.distributions is not None:\n        if self.ends is not None:\n            if self.starts is not None:\n                if all((d._initialized for d in self.distributions)):\n                    self._initialized = True\n                    self.distributions = torch.nn.ModuleList(self.distributions)\n    self._reset_cache()"
        ]
    },
    {
        "func_name": "_initialize",
        "original": "def _initialize(self, X=None, sample_weight=None):\n    \"\"\"Initialize the probability distribution.\n\n\t\tThis method is meant to only be called internally. It initializes the\n\t\tparameters of the distribution and stores its dimensionality. For more\n\t\tcomplex methods, this function will do more.\n\n\n\t\tParameters\n\t\t----------\n\t\tX: list, numpy.ndarray, torch.Tensor, shape=(-1, len, self.d), optional\n\t\t\tThe data to use to initialize the model. Default is None.\n\n\t\tsample_weight: list, tuple, numpy.ndarray, torch.Tensor, optional\n\t\t\tA set of weights for the examples. This can be either of shape\n\t\t\t(-1, len) or a vector of shape (-1,). If None, defaults to ones.\n\t\t\tDefault is None.\n\t\t\"\"\"\n    n = self.n_distributions\n    if not hasattr(self, '_edge_log_probs'):\n        unpack_edges(self, self.edges, self.starts, self.ends)\n        self.n_edges = len(self.edges)\n    self.distributions = torch.nn.ModuleList(self.distributions)\n    super()._initialize(X, sample_weight=sample_weight)",
        "mutated": [
            "def _initialize(self, X=None, sample_weight=None):\n    if False:\n        i = 10\n    'Initialize the probability distribution.\\n\\n\\t\\tThis method is meant to only be called internally. It initializes the\\n\\t\\tparameters of the distribution and stores its dimensionality. For more\\n\\t\\tcomplex methods, this function will do more.\\n\\n\\n\\t\\tParameters\\n\\t\\t----------\\n\\t\\tX: list, numpy.ndarray, torch.Tensor, shape=(-1, len, self.d), optional\\n\\t\\t\\tThe data to use to initialize the model. Default is None.\\n\\n\\t\\tsample_weight: list, tuple, numpy.ndarray, torch.Tensor, optional\\n\\t\\t\\tA set of weights for the examples. This can be either of shape\\n\\t\\t\\t(-1, len) or a vector of shape (-1,). If None, defaults to ones.\\n\\t\\t\\tDefault is None.\\n\\t\\t'\n    n = self.n_distributions\n    if not hasattr(self, '_edge_log_probs'):\n        unpack_edges(self, self.edges, self.starts, self.ends)\n        self.n_edges = len(self.edges)\n    self.distributions = torch.nn.ModuleList(self.distributions)\n    super()._initialize(X, sample_weight=sample_weight)",
            "def _initialize(self, X=None, sample_weight=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Initialize the probability distribution.\\n\\n\\t\\tThis method is meant to only be called internally. It initializes the\\n\\t\\tparameters of the distribution and stores its dimensionality. For more\\n\\t\\tcomplex methods, this function will do more.\\n\\n\\n\\t\\tParameters\\n\\t\\t----------\\n\\t\\tX: list, numpy.ndarray, torch.Tensor, shape=(-1, len, self.d), optional\\n\\t\\t\\tThe data to use to initialize the model. Default is None.\\n\\n\\t\\tsample_weight: list, tuple, numpy.ndarray, torch.Tensor, optional\\n\\t\\t\\tA set of weights for the examples. This can be either of shape\\n\\t\\t\\t(-1, len) or a vector of shape (-1,). If None, defaults to ones.\\n\\t\\t\\tDefault is None.\\n\\t\\t'\n    n = self.n_distributions\n    if not hasattr(self, '_edge_log_probs'):\n        unpack_edges(self, self.edges, self.starts, self.ends)\n        self.n_edges = len(self.edges)\n    self.distributions = torch.nn.ModuleList(self.distributions)\n    super()._initialize(X, sample_weight=sample_weight)",
            "def _initialize(self, X=None, sample_weight=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Initialize the probability distribution.\\n\\n\\t\\tThis method is meant to only be called internally. It initializes the\\n\\t\\tparameters of the distribution and stores its dimensionality. For more\\n\\t\\tcomplex methods, this function will do more.\\n\\n\\n\\t\\tParameters\\n\\t\\t----------\\n\\t\\tX: list, numpy.ndarray, torch.Tensor, shape=(-1, len, self.d), optional\\n\\t\\t\\tThe data to use to initialize the model. Default is None.\\n\\n\\t\\tsample_weight: list, tuple, numpy.ndarray, torch.Tensor, optional\\n\\t\\t\\tA set of weights for the examples. This can be either of shape\\n\\t\\t\\t(-1, len) or a vector of shape (-1,). If None, defaults to ones.\\n\\t\\t\\tDefault is None.\\n\\t\\t'\n    n = self.n_distributions\n    if not hasattr(self, '_edge_log_probs'):\n        unpack_edges(self, self.edges, self.starts, self.ends)\n        self.n_edges = len(self.edges)\n    self.distributions = torch.nn.ModuleList(self.distributions)\n    super()._initialize(X, sample_weight=sample_weight)",
            "def _initialize(self, X=None, sample_weight=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Initialize the probability distribution.\\n\\n\\t\\tThis method is meant to only be called internally. It initializes the\\n\\t\\tparameters of the distribution and stores its dimensionality. For more\\n\\t\\tcomplex methods, this function will do more.\\n\\n\\n\\t\\tParameters\\n\\t\\t----------\\n\\t\\tX: list, numpy.ndarray, torch.Tensor, shape=(-1, len, self.d), optional\\n\\t\\t\\tThe data to use to initialize the model. Default is None.\\n\\n\\t\\tsample_weight: list, tuple, numpy.ndarray, torch.Tensor, optional\\n\\t\\t\\tA set of weights for the examples. This can be either of shape\\n\\t\\t\\t(-1, len) or a vector of shape (-1,). If None, defaults to ones.\\n\\t\\t\\tDefault is None.\\n\\t\\t'\n    n = self.n_distributions\n    if not hasattr(self, '_edge_log_probs'):\n        unpack_edges(self, self.edges, self.starts, self.ends)\n        self.n_edges = len(self.edges)\n    self.distributions = torch.nn.ModuleList(self.distributions)\n    super()._initialize(X, sample_weight=sample_weight)",
            "def _initialize(self, X=None, sample_weight=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Initialize the probability distribution.\\n\\n\\t\\tThis method is meant to only be called internally. It initializes the\\n\\t\\tparameters of the distribution and stores its dimensionality. For more\\n\\t\\tcomplex methods, this function will do more.\\n\\n\\n\\t\\tParameters\\n\\t\\t----------\\n\\t\\tX: list, numpy.ndarray, torch.Tensor, shape=(-1, len, self.d), optional\\n\\t\\t\\tThe data to use to initialize the model. Default is None.\\n\\n\\t\\tsample_weight: list, tuple, numpy.ndarray, torch.Tensor, optional\\n\\t\\t\\tA set of weights for the examples. This can be either of shape\\n\\t\\t\\t(-1, len) or a vector of shape (-1,). If None, defaults to ones.\\n\\t\\t\\tDefault is None.\\n\\t\\t'\n    n = self.n_distributions\n    if not hasattr(self, '_edge_log_probs'):\n        unpack_edges(self, self.edges, self.starts, self.ends)\n        self.n_edges = len(self.edges)\n    self.distributions = torch.nn.ModuleList(self.distributions)\n    super()._initialize(X, sample_weight=sample_weight)"
        ]
    },
    {
        "func_name": "_reset_cache",
        "original": "def _reset_cache(self):\n    \"\"\"Reset the internally stored statistics.\n\n\t\tThis method is meant to only be called internally. It resets the\n\t\tstored statistics used to update the model parameters as well as\n\t\trecalculates the cached values meant to speed up log probability\n\t\tcalculations.\n\t\t\"\"\"\n    if self._initialized == False:\n        return\n    for node in self.distributions:\n        node._reset_cache()\n    self.register_buffer('_xw_sum', torch.zeros(self.n_edges, dtype=self.dtype, device=self.device))\n    self.register_buffer('_xw_starts_sum', torch.zeros(self.n_distributions, dtype=self.dtype, device=self.device))\n    self.register_buffer('_xw_ends_sum', torch.zeros(self.n_distributions, dtype=self.dtype, device=self.device))",
        "mutated": [
            "def _reset_cache(self):\n    if False:\n        i = 10\n    'Reset the internally stored statistics.\\n\\n\\t\\tThis method is meant to only be called internally. It resets the\\n\\t\\tstored statistics used to update the model parameters as well as\\n\\t\\trecalculates the cached values meant to speed up log probability\\n\\t\\tcalculations.\\n\\t\\t'\n    if self._initialized == False:\n        return\n    for node in self.distributions:\n        node._reset_cache()\n    self.register_buffer('_xw_sum', torch.zeros(self.n_edges, dtype=self.dtype, device=self.device))\n    self.register_buffer('_xw_starts_sum', torch.zeros(self.n_distributions, dtype=self.dtype, device=self.device))\n    self.register_buffer('_xw_ends_sum', torch.zeros(self.n_distributions, dtype=self.dtype, device=self.device))",
            "def _reset_cache(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Reset the internally stored statistics.\\n\\n\\t\\tThis method is meant to only be called internally. It resets the\\n\\t\\tstored statistics used to update the model parameters as well as\\n\\t\\trecalculates the cached values meant to speed up log probability\\n\\t\\tcalculations.\\n\\t\\t'\n    if self._initialized == False:\n        return\n    for node in self.distributions:\n        node._reset_cache()\n    self.register_buffer('_xw_sum', torch.zeros(self.n_edges, dtype=self.dtype, device=self.device))\n    self.register_buffer('_xw_starts_sum', torch.zeros(self.n_distributions, dtype=self.dtype, device=self.device))\n    self.register_buffer('_xw_ends_sum', torch.zeros(self.n_distributions, dtype=self.dtype, device=self.device))",
            "def _reset_cache(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Reset the internally stored statistics.\\n\\n\\t\\tThis method is meant to only be called internally. It resets the\\n\\t\\tstored statistics used to update the model parameters as well as\\n\\t\\trecalculates the cached values meant to speed up log probability\\n\\t\\tcalculations.\\n\\t\\t'\n    if self._initialized == False:\n        return\n    for node in self.distributions:\n        node._reset_cache()\n    self.register_buffer('_xw_sum', torch.zeros(self.n_edges, dtype=self.dtype, device=self.device))\n    self.register_buffer('_xw_starts_sum', torch.zeros(self.n_distributions, dtype=self.dtype, device=self.device))\n    self.register_buffer('_xw_ends_sum', torch.zeros(self.n_distributions, dtype=self.dtype, device=self.device))",
            "def _reset_cache(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Reset the internally stored statistics.\\n\\n\\t\\tThis method is meant to only be called internally. It resets the\\n\\t\\tstored statistics used to update the model parameters as well as\\n\\t\\trecalculates the cached values meant to speed up log probability\\n\\t\\tcalculations.\\n\\t\\t'\n    if self._initialized == False:\n        return\n    for node in self.distributions:\n        node._reset_cache()\n    self.register_buffer('_xw_sum', torch.zeros(self.n_edges, dtype=self.dtype, device=self.device))\n    self.register_buffer('_xw_starts_sum', torch.zeros(self.n_distributions, dtype=self.dtype, device=self.device))\n    self.register_buffer('_xw_ends_sum', torch.zeros(self.n_distributions, dtype=self.dtype, device=self.device))",
            "def _reset_cache(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Reset the internally stored statistics.\\n\\n\\t\\tThis method is meant to only be called internally. It resets the\\n\\t\\tstored statistics used to update the model parameters as well as\\n\\t\\trecalculates the cached values meant to speed up log probability\\n\\t\\tcalculations.\\n\\t\\t'\n    if self._initialized == False:\n        return\n    for node in self.distributions:\n        node._reset_cache()\n    self.register_buffer('_xw_sum', torch.zeros(self.n_edges, dtype=self.dtype, device=self.device))\n    self.register_buffer('_xw_starts_sum', torch.zeros(self.n_distributions, dtype=self.dtype, device=self.device))\n    self.register_buffer('_xw_ends_sum', torch.zeros(self.n_distributions, dtype=self.dtype, device=self.device))"
        ]
    },
    {
        "func_name": "sample",
        "original": "def sample(self, n):\n    \"\"\"Sample from the probability distribution.\n\n\t\tThis method will return `n` samples generated from the underlying\n\t\tprobability distribution. Because a HMM describes variable length\n\t\tsequences, a list will be returned where each element is one of\n\t\tthe generated sequences.\n\n\n\t\tParameters\n\t\t----------\n\t\tn: int\n\t\t\tThe number of samples to generate.\n\t\t\n\n\t\tReturns\n\t\t-------\n\t\tX: list of torch.tensor, shape=(n,)\n\t\t\tA list of randomly generated samples, where each sample of\n\t\t\tsize (length, self.d).\n\t\t\"\"\"\n    if self.sample_length is None and self.ends is None:\n        raise ValueError('Must specify a length or have explicit ' + 'end probabilities.')\n    (distributions, emissions) = ([], [])\n    (edge_ends, edge_probs) = ([], [])\n    for idx in range(self.n_distributions):\n        idxs = self._edge_idx_starts == idx\n        _ends = numpy.concatenate([self._edge_idx_ends[idxs].numpy(), [self.n_distributions]])\n        _probs = numpy.concatenate([torch.exp(self._edge_log_probs[idxs]).numpy(), [numpy.exp(self.ends[idx])]])\n        edge_ends.append(_ends)\n        edge_probs.append(_probs)\n    starts = torch.exp(self.starts).numpy()\n    for _ in range(n):\n        node_i = self.random_state.choice(self.n_distributions, p=starts)\n        emission_i = self.distributions[node_i].sample(n=1)\n        (distributions_, emissions_) = ([node_i], [emission_i])\n        for i in range(1, self.sample_length or int(100000000.0)):\n            node_i = self.random_state.choice(edge_ends[node_i], p=edge_probs[node_i])\n            if node_i == self.n_distributions:\n                break\n            emission_i = self.distributions[node_i].sample(n=1)\n            distributions_.append(node_i)\n            emissions_.append(emission_i)\n        distributions.append(distributions_)\n        emissions.append(torch.vstack(emissions_))\n    if self.return_sample_paths == True:\n        return (emissions, distributions)\n    return emissions",
        "mutated": [
            "def sample(self, n):\n    if False:\n        i = 10\n    'Sample from the probability distribution.\\n\\n\\t\\tThis method will return `n` samples generated from the underlying\\n\\t\\tprobability distribution. Because a HMM describes variable length\\n\\t\\tsequences, a list will be returned where each element is one of\\n\\t\\tthe generated sequences.\\n\\n\\n\\t\\tParameters\\n\\t\\t----------\\n\\t\\tn: int\\n\\t\\t\\tThe number of samples to generate.\\n\\t\\t\\n\\n\\t\\tReturns\\n\\t\\t-------\\n\\t\\tX: list of torch.tensor, shape=(n,)\\n\\t\\t\\tA list of randomly generated samples, where each sample of\\n\\t\\t\\tsize (length, self.d).\\n\\t\\t'\n    if self.sample_length is None and self.ends is None:\n        raise ValueError('Must specify a length or have explicit ' + 'end probabilities.')\n    (distributions, emissions) = ([], [])\n    (edge_ends, edge_probs) = ([], [])\n    for idx in range(self.n_distributions):\n        idxs = self._edge_idx_starts == idx\n        _ends = numpy.concatenate([self._edge_idx_ends[idxs].numpy(), [self.n_distributions]])\n        _probs = numpy.concatenate([torch.exp(self._edge_log_probs[idxs]).numpy(), [numpy.exp(self.ends[idx])]])\n        edge_ends.append(_ends)\n        edge_probs.append(_probs)\n    starts = torch.exp(self.starts).numpy()\n    for _ in range(n):\n        node_i = self.random_state.choice(self.n_distributions, p=starts)\n        emission_i = self.distributions[node_i].sample(n=1)\n        (distributions_, emissions_) = ([node_i], [emission_i])\n        for i in range(1, self.sample_length or int(100000000.0)):\n            node_i = self.random_state.choice(edge_ends[node_i], p=edge_probs[node_i])\n            if node_i == self.n_distributions:\n                break\n            emission_i = self.distributions[node_i].sample(n=1)\n            distributions_.append(node_i)\n            emissions_.append(emission_i)\n        distributions.append(distributions_)\n        emissions.append(torch.vstack(emissions_))\n    if self.return_sample_paths == True:\n        return (emissions, distributions)\n    return emissions",
            "def sample(self, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Sample from the probability distribution.\\n\\n\\t\\tThis method will return `n` samples generated from the underlying\\n\\t\\tprobability distribution. Because a HMM describes variable length\\n\\t\\tsequences, a list will be returned where each element is one of\\n\\t\\tthe generated sequences.\\n\\n\\n\\t\\tParameters\\n\\t\\t----------\\n\\t\\tn: int\\n\\t\\t\\tThe number of samples to generate.\\n\\t\\t\\n\\n\\t\\tReturns\\n\\t\\t-------\\n\\t\\tX: list of torch.tensor, shape=(n,)\\n\\t\\t\\tA list of randomly generated samples, where each sample of\\n\\t\\t\\tsize (length, self.d).\\n\\t\\t'\n    if self.sample_length is None and self.ends is None:\n        raise ValueError('Must specify a length or have explicit ' + 'end probabilities.')\n    (distributions, emissions) = ([], [])\n    (edge_ends, edge_probs) = ([], [])\n    for idx in range(self.n_distributions):\n        idxs = self._edge_idx_starts == idx\n        _ends = numpy.concatenate([self._edge_idx_ends[idxs].numpy(), [self.n_distributions]])\n        _probs = numpy.concatenate([torch.exp(self._edge_log_probs[idxs]).numpy(), [numpy.exp(self.ends[idx])]])\n        edge_ends.append(_ends)\n        edge_probs.append(_probs)\n    starts = torch.exp(self.starts).numpy()\n    for _ in range(n):\n        node_i = self.random_state.choice(self.n_distributions, p=starts)\n        emission_i = self.distributions[node_i].sample(n=1)\n        (distributions_, emissions_) = ([node_i], [emission_i])\n        for i in range(1, self.sample_length or int(100000000.0)):\n            node_i = self.random_state.choice(edge_ends[node_i], p=edge_probs[node_i])\n            if node_i == self.n_distributions:\n                break\n            emission_i = self.distributions[node_i].sample(n=1)\n            distributions_.append(node_i)\n            emissions_.append(emission_i)\n        distributions.append(distributions_)\n        emissions.append(torch.vstack(emissions_))\n    if self.return_sample_paths == True:\n        return (emissions, distributions)\n    return emissions",
            "def sample(self, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Sample from the probability distribution.\\n\\n\\t\\tThis method will return `n` samples generated from the underlying\\n\\t\\tprobability distribution. Because a HMM describes variable length\\n\\t\\tsequences, a list will be returned where each element is one of\\n\\t\\tthe generated sequences.\\n\\n\\n\\t\\tParameters\\n\\t\\t----------\\n\\t\\tn: int\\n\\t\\t\\tThe number of samples to generate.\\n\\t\\t\\n\\n\\t\\tReturns\\n\\t\\t-------\\n\\t\\tX: list of torch.tensor, shape=(n,)\\n\\t\\t\\tA list of randomly generated samples, where each sample of\\n\\t\\t\\tsize (length, self.d).\\n\\t\\t'\n    if self.sample_length is None and self.ends is None:\n        raise ValueError('Must specify a length or have explicit ' + 'end probabilities.')\n    (distributions, emissions) = ([], [])\n    (edge_ends, edge_probs) = ([], [])\n    for idx in range(self.n_distributions):\n        idxs = self._edge_idx_starts == idx\n        _ends = numpy.concatenate([self._edge_idx_ends[idxs].numpy(), [self.n_distributions]])\n        _probs = numpy.concatenate([torch.exp(self._edge_log_probs[idxs]).numpy(), [numpy.exp(self.ends[idx])]])\n        edge_ends.append(_ends)\n        edge_probs.append(_probs)\n    starts = torch.exp(self.starts).numpy()\n    for _ in range(n):\n        node_i = self.random_state.choice(self.n_distributions, p=starts)\n        emission_i = self.distributions[node_i].sample(n=1)\n        (distributions_, emissions_) = ([node_i], [emission_i])\n        for i in range(1, self.sample_length or int(100000000.0)):\n            node_i = self.random_state.choice(edge_ends[node_i], p=edge_probs[node_i])\n            if node_i == self.n_distributions:\n                break\n            emission_i = self.distributions[node_i].sample(n=1)\n            distributions_.append(node_i)\n            emissions_.append(emission_i)\n        distributions.append(distributions_)\n        emissions.append(torch.vstack(emissions_))\n    if self.return_sample_paths == True:\n        return (emissions, distributions)\n    return emissions",
            "def sample(self, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Sample from the probability distribution.\\n\\n\\t\\tThis method will return `n` samples generated from the underlying\\n\\t\\tprobability distribution. Because a HMM describes variable length\\n\\t\\tsequences, a list will be returned where each element is one of\\n\\t\\tthe generated sequences.\\n\\n\\n\\t\\tParameters\\n\\t\\t----------\\n\\t\\tn: int\\n\\t\\t\\tThe number of samples to generate.\\n\\t\\t\\n\\n\\t\\tReturns\\n\\t\\t-------\\n\\t\\tX: list of torch.tensor, shape=(n,)\\n\\t\\t\\tA list of randomly generated samples, where each sample of\\n\\t\\t\\tsize (length, self.d).\\n\\t\\t'\n    if self.sample_length is None and self.ends is None:\n        raise ValueError('Must specify a length or have explicit ' + 'end probabilities.')\n    (distributions, emissions) = ([], [])\n    (edge_ends, edge_probs) = ([], [])\n    for idx in range(self.n_distributions):\n        idxs = self._edge_idx_starts == idx\n        _ends = numpy.concatenate([self._edge_idx_ends[idxs].numpy(), [self.n_distributions]])\n        _probs = numpy.concatenate([torch.exp(self._edge_log_probs[idxs]).numpy(), [numpy.exp(self.ends[idx])]])\n        edge_ends.append(_ends)\n        edge_probs.append(_probs)\n    starts = torch.exp(self.starts).numpy()\n    for _ in range(n):\n        node_i = self.random_state.choice(self.n_distributions, p=starts)\n        emission_i = self.distributions[node_i].sample(n=1)\n        (distributions_, emissions_) = ([node_i], [emission_i])\n        for i in range(1, self.sample_length or int(100000000.0)):\n            node_i = self.random_state.choice(edge_ends[node_i], p=edge_probs[node_i])\n            if node_i == self.n_distributions:\n                break\n            emission_i = self.distributions[node_i].sample(n=1)\n            distributions_.append(node_i)\n            emissions_.append(emission_i)\n        distributions.append(distributions_)\n        emissions.append(torch.vstack(emissions_))\n    if self.return_sample_paths == True:\n        return (emissions, distributions)\n    return emissions",
            "def sample(self, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Sample from the probability distribution.\\n\\n\\t\\tThis method will return `n` samples generated from the underlying\\n\\t\\tprobability distribution. Because a HMM describes variable length\\n\\t\\tsequences, a list will be returned where each element is one of\\n\\t\\tthe generated sequences.\\n\\n\\n\\t\\tParameters\\n\\t\\t----------\\n\\t\\tn: int\\n\\t\\t\\tThe number of samples to generate.\\n\\t\\t\\n\\n\\t\\tReturns\\n\\t\\t-------\\n\\t\\tX: list of torch.tensor, shape=(n,)\\n\\t\\t\\tA list of randomly generated samples, where each sample of\\n\\t\\t\\tsize (length, self.d).\\n\\t\\t'\n    if self.sample_length is None and self.ends is None:\n        raise ValueError('Must specify a length or have explicit ' + 'end probabilities.')\n    (distributions, emissions) = ([], [])\n    (edge_ends, edge_probs) = ([], [])\n    for idx in range(self.n_distributions):\n        idxs = self._edge_idx_starts == idx\n        _ends = numpy.concatenate([self._edge_idx_ends[idxs].numpy(), [self.n_distributions]])\n        _probs = numpy.concatenate([torch.exp(self._edge_log_probs[idxs]).numpy(), [numpy.exp(self.ends[idx])]])\n        edge_ends.append(_ends)\n        edge_probs.append(_probs)\n    starts = torch.exp(self.starts).numpy()\n    for _ in range(n):\n        node_i = self.random_state.choice(self.n_distributions, p=starts)\n        emission_i = self.distributions[node_i].sample(n=1)\n        (distributions_, emissions_) = ([node_i], [emission_i])\n        for i in range(1, self.sample_length or int(100000000.0)):\n            node_i = self.random_state.choice(edge_ends[node_i], p=edge_probs[node_i])\n            if node_i == self.n_distributions:\n                break\n            emission_i = self.distributions[node_i].sample(n=1)\n            distributions_.append(node_i)\n            emissions_.append(emission_i)\n        distributions.append(distributions_)\n        emissions.append(torch.vstack(emissions_))\n    if self.return_sample_paths == True:\n        return (emissions, distributions)\n    return emissions"
        ]
    },
    {
        "func_name": "forward",
        "original": "def forward(self, X=None, emissions=None, priors=None):\n    \"\"\"Run the forward algorithm on some data.\n\n\t\tRuns the forward algorithm on a batch of sequences. This is not to be\n\t\tconfused with a \"forward pass\" when talking about neural networks. The\n\t\tforward algorithm is a dynamic programming algorithm that begins at the\n\t\tstart state and returns the probability, over all paths through the\n\t\tmodel, that result in the alignment of symbol i to node j.\n\n\t\t\n\t\tParameters\n\t\t----------\n\t\tX: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, d)\n\t\t\tA set of examples to evaluate. Does not need to be passed in if\n\t\t\temissions are. \n\n\t\temissions: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, n_distributions)\n\t\t\tPrecalculated emission log probabilities. These are the\n\t\t\tprobabilities of each observation under each probability \n\t\t\tdistribution. When running some algorithms it is more efficient\n\t\t\tto precalculate these and pass them into each call.\n\n\t\tpriors: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, self.k)\n\t\t\tPrior probabilities of assigning each symbol to each node. If not\n\t\t\tprovided, do not include in the calculations (conceptually\n\t\t\tequivalent to a uniform probability, but without scaling the\n\t\t\tprobabilities). This can be used to assign labels to observatons\n\t\t\tby setting one of the probabilities for an observation to 1.0.\n\t\t\tNote that this can be used to assign hard labels, but does not\n\t\t\thave the same semantics for soft labels, in that it only\n\t\t\tinfluences the initial estimate of an observation being generated\n\t\t\tby a component, not gives a target. Default is None.\n\n\n\t\tReturns\n\t\t-------\n\t\tf: torch.Tensor, shape=(-1, -1, self.n_distributions)\n\t\t\tThe log probabilities calculated by the forward algorithm.\n\t\t\"\"\"\n    emissions = _check_inputs(self, X, emissions, priors)\n    (n, l, _) = emissions.shape\n    f = torch.full((l, n, self.n_distributions), -inf, dtype=torch.float32, device=self.device)\n    f[0] = self.starts + emissions[:, 0]\n    for i in range(1, l):\n        p = f[i - 1, :, self._edge_idx_starts]\n        p += self._edge_log_probs.expand(n, -1)\n        alpha = torch.max(p, dim=1, keepdims=True).values\n        p = torch.exp(p - alpha)\n        z = torch.zeros_like(f[i])\n        z.scatter_add_(1, self._edge_idx_ends.expand(n, -1), p)\n        f[i] = alpha + torch.log(z) + emissions[:, i]\n    f = f.permute(1, 0, 2)\n    return f",
        "mutated": [
            "def forward(self, X=None, emissions=None, priors=None):\n    if False:\n        i = 10\n    'Run the forward algorithm on some data.\\n\\n\\t\\tRuns the forward algorithm on a batch of sequences. This is not to be\\n\\t\\tconfused with a \"forward pass\" when talking about neural networks. The\\n\\t\\tforward algorithm is a dynamic programming algorithm that begins at the\\n\\t\\tstart state and returns the probability, over all paths through the\\n\\t\\tmodel, that result in the alignment of symbol i to node j.\\n\\n\\t\\t\\n\\t\\tParameters\\n\\t\\t----------\\n\\t\\tX: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, d)\\n\\t\\t\\tA set of examples to evaluate. Does not need to be passed in if\\n\\t\\t\\temissions are. \\n\\n\\t\\temissions: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, n_distributions)\\n\\t\\t\\tPrecalculated emission log probabilities. These are the\\n\\t\\t\\tprobabilities of each observation under each probability \\n\\t\\t\\tdistribution. When running some algorithms it is more efficient\\n\\t\\t\\tto precalculate these and pass them into each call.\\n\\n\\t\\tpriors: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, self.k)\\n\\t\\t\\tPrior probabilities of assigning each symbol to each node. If not\\n\\t\\t\\tprovided, do not include in the calculations (conceptually\\n\\t\\t\\tequivalent to a uniform probability, but without scaling the\\n\\t\\t\\tprobabilities). This can be used to assign labels to observatons\\n\\t\\t\\tby setting one of the probabilities for an observation to 1.0.\\n\\t\\t\\tNote that this can be used to assign hard labels, but does not\\n\\t\\t\\thave the same semantics for soft labels, in that it only\\n\\t\\t\\tinfluences the initial estimate of an observation being generated\\n\\t\\t\\tby a component, not gives a target. Default is None.\\n\\n\\n\\t\\tReturns\\n\\t\\t-------\\n\\t\\tf: torch.Tensor, shape=(-1, -1, self.n_distributions)\\n\\t\\t\\tThe log probabilities calculated by the forward algorithm.\\n\\t\\t'\n    emissions = _check_inputs(self, X, emissions, priors)\n    (n, l, _) = emissions.shape\n    f = torch.full((l, n, self.n_distributions), -inf, dtype=torch.float32, device=self.device)\n    f[0] = self.starts + emissions[:, 0]\n    for i in range(1, l):\n        p = f[i - 1, :, self._edge_idx_starts]\n        p += self._edge_log_probs.expand(n, -1)\n        alpha = torch.max(p, dim=1, keepdims=True).values\n        p = torch.exp(p - alpha)\n        z = torch.zeros_like(f[i])\n        z.scatter_add_(1, self._edge_idx_ends.expand(n, -1), p)\n        f[i] = alpha + torch.log(z) + emissions[:, i]\n    f = f.permute(1, 0, 2)\n    return f",
            "def forward(self, X=None, emissions=None, priors=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Run the forward algorithm on some data.\\n\\n\\t\\tRuns the forward algorithm on a batch of sequences. This is not to be\\n\\t\\tconfused with a \"forward pass\" when talking about neural networks. The\\n\\t\\tforward algorithm is a dynamic programming algorithm that begins at the\\n\\t\\tstart state and returns the probability, over all paths through the\\n\\t\\tmodel, that result in the alignment of symbol i to node j.\\n\\n\\t\\t\\n\\t\\tParameters\\n\\t\\t----------\\n\\t\\tX: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, d)\\n\\t\\t\\tA set of examples to evaluate. Does not need to be passed in if\\n\\t\\t\\temissions are. \\n\\n\\t\\temissions: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, n_distributions)\\n\\t\\t\\tPrecalculated emission log probabilities. These are the\\n\\t\\t\\tprobabilities of each observation under each probability \\n\\t\\t\\tdistribution. When running some algorithms it is more efficient\\n\\t\\t\\tto precalculate these and pass them into each call.\\n\\n\\t\\tpriors: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, self.k)\\n\\t\\t\\tPrior probabilities of assigning each symbol to each node. If not\\n\\t\\t\\tprovided, do not include in the calculations (conceptually\\n\\t\\t\\tequivalent to a uniform probability, but without scaling the\\n\\t\\t\\tprobabilities). This can be used to assign labels to observatons\\n\\t\\t\\tby setting one of the probabilities for an observation to 1.0.\\n\\t\\t\\tNote that this can be used to assign hard labels, but does not\\n\\t\\t\\thave the same semantics for soft labels, in that it only\\n\\t\\t\\tinfluences the initial estimate of an observation being generated\\n\\t\\t\\tby a component, not gives a target. Default is None.\\n\\n\\n\\t\\tReturns\\n\\t\\t-------\\n\\t\\tf: torch.Tensor, shape=(-1, -1, self.n_distributions)\\n\\t\\t\\tThe log probabilities calculated by the forward algorithm.\\n\\t\\t'\n    emissions = _check_inputs(self, X, emissions, priors)\n    (n, l, _) = emissions.shape\n    f = torch.full((l, n, self.n_distributions), -inf, dtype=torch.float32, device=self.device)\n    f[0] = self.starts + emissions[:, 0]\n    for i in range(1, l):\n        p = f[i - 1, :, self._edge_idx_starts]\n        p += self._edge_log_probs.expand(n, -1)\n        alpha = torch.max(p, dim=1, keepdims=True).values\n        p = torch.exp(p - alpha)\n        z = torch.zeros_like(f[i])\n        z.scatter_add_(1, self._edge_idx_ends.expand(n, -1), p)\n        f[i] = alpha + torch.log(z) + emissions[:, i]\n    f = f.permute(1, 0, 2)\n    return f",
            "def forward(self, X=None, emissions=None, priors=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Run the forward algorithm on some data.\\n\\n\\t\\tRuns the forward algorithm on a batch of sequences. This is not to be\\n\\t\\tconfused with a \"forward pass\" when talking about neural networks. The\\n\\t\\tforward algorithm is a dynamic programming algorithm that begins at the\\n\\t\\tstart state and returns the probability, over all paths through the\\n\\t\\tmodel, that result in the alignment of symbol i to node j.\\n\\n\\t\\t\\n\\t\\tParameters\\n\\t\\t----------\\n\\t\\tX: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, d)\\n\\t\\t\\tA set of examples to evaluate. Does not need to be passed in if\\n\\t\\t\\temissions are. \\n\\n\\t\\temissions: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, n_distributions)\\n\\t\\t\\tPrecalculated emission log probabilities. These are the\\n\\t\\t\\tprobabilities of each observation under each probability \\n\\t\\t\\tdistribution. When running some algorithms it is more efficient\\n\\t\\t\\tto precalculate these and pass them into each call.\\n\\n\\t\\tpriors: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, self.k)\\n\\t\\t\\tPrior probabilities of assigning each symbol to each node. If not\\n\\t\\t\\tprovided, do not include in the calculations (conceptually\\n\\t\\t\\tequivalent to a uniform probability, but without scaling the\\n\\t\\t\\tprobabilities). This can be used to assign labels to observatons\\n\\t\\t\\tby setting one of the probabilities for an observation to 1.0.\\n\\t\\t\\tNote that this can be used to assign hard labels, but does not\\n\\t\\t\\thave the same semantics for soft labels, in that it only\\n\\t\\t\\tinfluences the initial estimate of an observation being generated\\n\\t\\t\\tby a component, not gives a target. Default is None.\\n\\n\\n\\t\\tReturns\\n\\t\\t-------\\n\\t\\tf: torch.Tensor, shape=(-1, -1, self.n_distributions)\\n\\t\\t\\tThe log probabilities calculated by the forward algorithm.\\n\\t\\t'\n    emissions = _check_inputs(self, X, emissions, priors)\n    (n, l, _) = emissions.shape\n    f = torch.full((l, n, self.n_distributions), -inf, dtype=torch.float32, device=self.device)\n    f[0] = self.starts + emissions[:, 0]\n    for i in range(1, l):\n        p = f[i - 1, :, self._edge_idx_starts]\n        p += self._edge_log_probs.expand(n, -1)\n        alpha = torch.max(p, dim=1, keepdims=True).values\n        p = torch.exp(p - alpha)\n        z = torch.zeros_like(f[i])\n        z.scatter_add_(1, self._edge_idx_ends.expand(n, -1), p)\n        f[i] = alpha + torch.log(z) + emissions[:, i]\n    f = f.permute(1, 0, 2)\n    return f",
            "def forward(self, X=None, emissions=None, priors=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Run the forward algorithm on some data.\\n\\n\\t\\tRuns the forward algorithm on a batch of sequences. This is not to be\\n\\t\\tconfused with a \"forward pass\" when talking about neural networks. The\\n\\t\\tforward algorithm is a dynamic programming algorithm that begins at the\\n\\t\\tstart state and returns the probability, over all paths through the\\n\\t\\tmodel, that result in the alignment of symbol i to node j.\\n\\n\\t\\t\\n\\t\\tParameters\\n\\t\\t----------\\n\\t\\tX: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, d)\\n\\t\\t\\tA set of examples to evaluate. Does not need to be passed in if\\n\\t\\t\\temissions are. \\n\\n\\t\\temissions: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, n_distributions)\\n\\t\\t\\tPrecalculated emission log probabilities. These are the\\n\\t\\t\\tprobabilities of each observation under each probability \\n\\t\\t\\tdistribution. When running some algorithms it is more efficient\\n\\t\\t\\tto precalculate these and pass them into each call.\\n\\n\\t\\tpriors: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, self.k)\\n\\t\\t\\tPrior probabilities of assigning each symbol to each node. If not\\n\\t\\t\\tprovided, do not include in the calculations (conceptually\\n\\t\\t\\tequivalent to a uniform probability, but without scaling the\\n\\t\\t\\tprobabilities). This can be used to assign labels to observatons\\n\\t\\t\\tby setting one of the probabilities for an observation to 1.0.\\n\\t\\t\\tNote that this can be used to assign hard labels, but does not\\n\\t\\t\\thave the same semantics for soft labels, in that it only\\n\\t\\t\\tinfluences the initial estimate of an observation being generated\\n\\t\\t\\tby a component, not gives a target. Default is None.\\n\\n\\n\\t\\tReturns\\n\\t\\t-------\\n\\t\\tf: torch.Tensor, shape=(-1, -1, self.n_distributions)\\n\\t\\t\\tThe log probabilities calculated by the forward algorithm.\\n\\t\\t'\n    emissions = _check_inputs(self, X, emissions, priors)\n    (n, l, _) = emissions.shape\n    f = torch.full((l, n, self.n_distributions), -inf, dtype=torch.float32, device=self.device)\n    f[0] = self.starts + emissions[:, 0]\n    for i in range(1, l):\n        p = f[i - 1, :, self._edge_idx_starts]\n        p += self._edge_log_probs.expand(n, -1)\n        alpha = torch.max(p, dim=1, keepdims=True).values\n        p = torch.exp(p - alpha)\n        z = torch.zeros_like(f[i])\n        z.scatter_add_(1, self._edge_idx_ends.expand(n, -1), p)\n        f[i] = alpha + torch.log(z) + emissions[:, i]\n    f = f.permute(1, 0, 2)\n    return f",
            "def forward(self, X=None, emissions=None, priors=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Run the forward algorithm on some data.\\n\\n\\t\\tRuns the forward algorithm on a batch of sequences. This is not to be\\n\\t\\tconfused with a \"forward pass\" when talking about neural networks. The\\n\\t\\tforward algorithm is a dynamic programming algorithm that begins at the\\n\\t\\tstart state and returns the probability, over all paths through the\\n\\t\\tmodel, that result in the alignment of symbol i to node j.\\n\\n\\t\\t\\n\\t\\tParameters\\n\\t\\t----------\\n\\t\\tX: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, d)\\n\\t\\t\\tA set of examples to evaluate. Does not need to be passed in if\\n\\t\\t\\temissions are. \\n\\n\\t\\temissions: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, n_distributions)\\n\\t\\t\\tPrecalculated emission log probabilities. These are the\\n\\t\\t\\tprobabilities of each observation under each probability \\n\\t\\t\\tdistribution. When running some algorithms it is more efficient\\n\\t\\t\\tto precalculate these and pass them into each call.\\n\\n\\t\\tpriors: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, self.k)\\n\\t\\t\\tPrior probabilities of assigning each symbol to each node. If not\\n\\t\\t\\tprovided, do not include in the calculations (conceptually\\n\\t\\t\\tequivalent to a uniform probability, but without scaling the\\n\\t\\t\\tprobabilities). This can be used to assign labels to observatons\\n\\t\\t\\tby setting one of the probabilities for an observation to 1.0.\\n\\t\\t\\tNote that this can be used to assign hard labels, but does not\\n\\t\\t\\thave the same semantics for soft labels, in that it only\\n\\t\\t\\tinfluences the initial estimate of an observation being generated\\n\\t\\t\\tby a component, not gives a target. Default is None.\\n\\n\\n\\t\\tReturns\\n\\t\\t-------\\n\\t\\tf: torch.Tensor, shape=(-1, -1, self.n_distributions)\\n\\t\\t\\tThe log probabilities calculated by the forward algorithm.\\n\\t\\t'\n    emissions = _check_inputs(self, X, emissions, priors)\n    (n, l, _) = emissions.shape\n    f = torch.full((l, n, self.n_distributions), -inf, dtype=torch.float32, device=self.device)\n    f[0] = self.starts + emissions[:, 0]\n    for i in range(1, l):\n        p = f[i - 1, :, self._edge_idx_starts]\n        p += self._edge_log_probs.expand(n, -1)\n        alpha = torch.max(p, dim=1, keepdims=True).values\n        p = torch.exp(p - alpha)\n        z = torch.zeros_like(f[i])\n        z.scatter_add_(1, self._edge_idx_ends.expand(n, -1), p)\n        f[i] = alpha + torch.log(z) + emissions[:, i]\n    f = f.permute(1, 0, 2)\n    return f"
        ]
    },
    {
        "func_name": "backward",
        "original": "def backward(self, X=None, emissions=None, priors=None):\n    \"\"\"Run the backward algorithm on some data.\n\n\t\tRuns the backward algorithm on a batch of sequences. This is not to be\n\t\tconfused with a \"backward pass\" when talking about neural networks. The\n\t\tbackward algorithm is a dynamic programming algorithm that begins at end\n\t\tof the sequence and returns the probability, over all paths through the\n\t\tmodel, that result in the alignment of symbol i to node j, working\n\t\tbackwards.\n\n\t\t\n\t\tParameters\n\t\t----------\n\t\tX: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, d)\n\t\t\tA set of examples to evaluate. Does not need to be passed in if\n\t\t\temissions are. \n\n\t\temissions: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, n_distributions)\n\t\t\tPrecalculated emission log probabilities. These are the\n\t\t\tprobabilities of each observation under each probability \n\t\t\tdistribution. When running some algorithms it is more efficient\n\t\t\tto precalculate these and pass them into each call.\n\n\t\tpriors: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, self.k)\n\t\t\tPrior probabilities of assigning each symbol to each node. If not\n\t\t\tprovided, do not include in the calculations (conceptually\n\t\t\tequivalent to a uniform probability, but without scaling the\n\t\t\tprobabilities). This can be used to assign labels to observatons\n\t\t\tby setting one of the probabilities for an observation to 1.0.\n\t\t\tNote that this can be used to assign hard labels, but does not\n\t\t\thave the same semantics for soft labels, in that it only\n\t\t\tinfluences the initial estimate of an observation being generated\n\t\t\tby a component, not gives a target. Default is None.\n\n\n\t\tReturns\n\t\t-------\n\t\tb: torch.Tensor, shape=(-1, length, self.n_distributions)\n\t\t\tThe log probabilities calculated by the backward algorithm.\n\t\t\"\"\"\n    emissions = _check_inputs(self, X, emissions, priors)\n    (n, l, _) = emissions.shape\n    b = torch.full((l, n, self.n_distributions), -inf, dtype=torch.float32, device=self.device)\n    b[-1] = self.ends\n    for i in range(l - 2, -1, -1):\n        p = b[i + 1, :, self._edge_idx_ends]\n        p += emissions[:, i + 1, self._edge_idx_ends]\n        p += self._edge_log_probs.expand(n, -1)\n        alpha = torch.max(p, dim=1, keepdims=True).values\n        p = torch.exp(p - alpha)\n        z = torch.zeros_like(b[i])\n        z.scatter_add_(1, self._edge_idx_starts.expand(n, -1), p)\n        b[i] = alpha + torch.log(z)\n    b = b.permute(1, 0, 2)\n    return b",
        "mutated": [
            "def backward(self, X=None, emissions=None, priors=None):\n    if False:\n        i = 10\n    'Run the backward algorithm on some data.\\n\\n\\t\\tRuns the backward algorithm on a batch of sequences. This is not to be\\n\\t\\tconfused with a \"backward pass\" when talking about neural networks. The\\n\\t\\tbackward algorithm is a dynamic programming algorithm that begins at end\\n\\t\\tof the sequence and returns the probability, over all paths through the\\n\\t\\tmodel, that result in the alignment of symbol i to node j, working\\n\\t\\tbackwards.\\n\\n\\t\\t\\n\\t\\tParameters\\n\\t\\t----------\\n\\t\\tX: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, d)\\n\\t\\t\\tA set of examples to evaluate. Does not need to be passed in if\\n\\t\\t\\temissions are. \\n\\n\\t\\temissions: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, n_distributions)\\n\\t\\t\\tPrecalculated emission log probabilities. These are the\\n\\t\\t\\tprobabilities of each observation under each probability \\n\\t\\t\\tdistribution. When running some algorithms it is more efficient\\n\\t\\t\\tto precalculate these and pass them into each call.\\n\\n\\t\\tpriors: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, self.k)\\n\\t\\t\\tPrior probabilities of assigning each symbol to each node. If not\\n\\t\\t\\tprovided, do not include in the calculations (conceptually\\n\\t\\t\\tequivalent to a uniform probability, but without scaling the\\n\\t\\t\\tprobabilities). This can be used to assign labels to observatons\\n\\t\\t\\tby setting one of the probabilities for an observation to 1.0.\\n\\t\\t\\tNote that this can be used to assign hard labels, but does not\\n\\t\\t\\thave the same semantics for soft labels, in that it only\\n\\t\\t\\tinfluences the initial estimate of an observation being generated\\n\\t\\t\\tby a component, not gives a target. Default is None.\\n\\n\\n\\t\\tReturns\\n\\t\\t-------\\n\\t\\tb: torch.Tensor, shape=(-1, length, self.n_distributions)\\n\\t\\t\\tThe log probabilities calculated by the backward algorithm.\\n\\t\\t'\n    emissions = _check_inputs(self, X, emissions, priors)\n    (n, l, _) = emissions.shape\n    b = torch.full((l, n, self.n_distributions), -inf, dtype=torch.float32, device=self.device)\n    b[-1] = self.ends\n    for i in range(l - 2, -1, -1):\n        p = b[i + 1, :, self._edge_idx_ends]\n        p += emissions[:, i + 1, self._edge_idx_ends]\n        p += self._edge_log_probs.expand(n, -1)\n        alpha = torch.max(p, dim=1, keepdims=True).values\n        p = torch.exp(p - alpha)\n        z = torch.zeros_like(b[i])\n        z.scatter_add_(1, self._edge_idx_starts.expand(n, -1), p)\n        b[i] = alpha + torch.log(z)\n    b = b.permute(1, 0, 2)\n    return b",
            "def backward(self, X=None, emissions=None, priors=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Run the backward algorithm on some data.\\n\\n\\t\\tRuns the backward algorithm on a batch of sequences. This is not to be\\n\\t\\tconfused with a \"backward pass\" when talking about neural networks. The\\n\\t\\tbackward algorithm is a dynamic programming algorithm that begins at end\\n\\t\\tof the sequence and returns the probability, over all paths through the\\n\\t\\tmodel, that result in the alignment of symbol i to node j, working\\n\\t\\tbackwards.\\n\\n\\t\\t\\n\\t\\tParameters\\n\\t\\t----------\\n\\t\\tX: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, d)\\n\\t\\t\\tA set of examples to evaluate. Does not need to be passed in if\\n\\t\\t\\temissions are. \\n\\n\\t\\temissions: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, n_distributions)\\n\\t\\t\\tPrecalculated emission log probabilities. These are the\\n\\t\\t\\tprobabilities of each observation under each probability \\n\\t\\t\\tdistribution. When running some algorithms it is more efficient\\n\\t\\t\\tto precalculate these and pass them into each call.\\n\\n\\t\\tpriors: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, self.k)\\n\\t\\t\\tPrior probabilities of assigning each symbol to each node. If not\\n\\t\\t\\tprovided, do not include in the calculations (conceptually\\n\\t\\t\\tequivalent to a uniform probability, but without scaling the\\n\\t\\t\\tprobabilities). This can be used to assign labels to observatons\\n\\t\\t\\tby setting one of the probabilities for an observation to 1.0.\\n\\t\\t\\tNote that this can be used to assign hard labels, but does not\\n\\t\\t\\thave the same semantics for soft labels, in that it only\\n\\t\\t\\tinfluences the initial estimate of an observation being generated\\n\\t\\t\\tby a component, not gives a target. Default is None.\\n\\n\\n\\t\\tReturns\\n\\t\\t-------\\n\\t\\tb: torch.Tensor, shape=(-1, length, self.n_distributions)\\n\\t\\t\\tThe log probabilities calculated by the backward algorithm.\\n\\t\\t'\n    emissions = _check_inputs(self, X, emissions, priors)\n    (n, l, _) = emissions.shape\n    b = torch.full((l, n, self.n_distributions), -inf, dtype=torch.float32, device=self.device)\n    b[-1] = self.ends\n    for i in range(l - 2, -1, -1):\n        p = b[i + 1, :, self._edge_idx_ends]\n        p += emissions[:, i + 1, self._edge_idx_ends]\n        p += self._edge_log_probs.expand(n, -1)\n        alpha = torch.max(p, dim=1, keepdims=True).values\n        p = torch.exp(p - alpha)\n        z = torch.zeros_like(b[i])\n        z.scatter_add_(1, self._edge_idx_starts.expand(n, -1), p)\n        b[i] = alpha + torch.log(z)\n    b = b.permute(1, 0, 2)\n    return b",
            "def backward(self, X=None, emissions=None, priors=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Run the backward algorithm on some data.\\n\\n\\t\\tRuns the backward algorithm on a batch of sequences. This is not to be\\n\\t\\tconfused with a \"backward pass\" when talking about neural networks. The\\n\\t\\tbackward algorithm is a dynamic programming algorithm that begins at end\\n\\t\\tof the sequence and returns the probability, over all paths through the\\n\\t\\tmodel, that result in the alignment of symbol i to node j, working\\n\\t\\tbackwards.\\n\\n\\t\\t\\n\\t\\tParameters\\n\\t\\t----------\\n\\t\\tX: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, d)\\n\\t\\t\\tA set of examples to evaluate. Does not need to be passed in if\\n\\t\\t\\temissions are. \\n\\n\\t\\temissions: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, n_distributions)\\n\\t\\t\\tPrecalculated emission log probabilities. These are the\\n\\t\\t\\tprobabilities of each observation under each probability \\n\\t\\t\\tdistribution. When running some algorithms it is more efficient\\n\\t\\t\\tto precalculate these and pass them into each call.\\n\\n\\t\\tpriors: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, self.k)\\n\\t\\t\\tPrior probabilities of assigning each symbol to each node. If not\\n\\t\\t\\tprovided, do not include in the calculations (conceptually\\n\\t\\t\\tequivalent to a uniform probability, but without scaling the\\n\\t\\t\\tprobabilities). This can be used to assign labels to observatons\\n\\t\\t\\tby setting one of the probabilities for an observation to 1.0.\\n\\t\\t\\tNote that this can be used to assign hard labels, but does not\\n\\t\\t\\thave the same semantics for soft labels, in that it only\\n\\t\\t\\tinfluences the initial estimate of an observation being generated\\n\\t\\t\\tby a component, not gives a target. Default is None.\\n\\n\\n\\t\\tReturns\\n\\t\\t-------\\n\\t\\tb: torch.Tensor, shape=(-1, length, self.n_distributions)\\n\\t\\t\\tThe log probabilities calculated by the backward algorithm.\\n\\t\\t'\n    emissions = _check_inputs(self, X, emissions, priors)\n    (n, l, _) = emissions.shape\n    b = torch.full((l, n, self.n_distributions), -inf, dtype=torch.float32, device=self.device)\n    b[-1] = self.ends\n    for i in range(l - 2, -1, -1):\n        p = b[i + 1, :, self._edge_idx_ends]\n        p += emissions[:, i + 1, self._edge_idx_ends]\n        p += self._edge_log_probs.expand(n, -1)\n        alpha = torch.max(p, dim=1, keepdims=True).values\n        p = torch.exp(p - alpha)\n        z = torch.zeros_like(b[i])\n        z.scatter_add_(1, self._edge_idx_starts.expand(n, -1), p)\n        b[i] = alpha + torch.log(z)\n    b = b.permute(1, 0, 2)\n    return b",
            "def backward(self, X=None, emissions=None, priors=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Run the backward algorithm on some data.\\n\\n\\t\\tRuns the backward algorithm on a batch of sequences. This is not to be\\n\\t\\tconfused with a \"backward pass\" when talking about neural networks. The\\n\\t\\tbackward algorithm is a dynamic programming algorithm that begins at end\\n\\t\\tof the sequence and returns the probability, over all paths through the\\n\\t\\tmodel, that result in the alignment of symbol i to node j, working\\n\\t\\tbackwards.\\n\\n\\t\\t\\n\\t\\tParameters\\n\\t\\t----------\\n\\t\\tX: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, d)\\n\\t\\t\\tA set of examples to evaluate. Does not need to be passed in if\\n\\t\\t\\temissions are. \\n\\n\\t\\temissions: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, n_distributions)\\n\\t\\t\\tPrecalculated emission log probabilities. These are the\\n\\t\\t\\tprobabilities of each observation under each probability \\n\\t\\t\\tdistribution. When running some algorithms it is more efficient\\n\\t\\t\\tto precalculate these and pass them into each call.\\n\\n\\t\\tpriors: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, self.k)\\n\\t\\t\\tPrior probabilities of assigning each symbol to each node. If not\\n\\t\\t\\tprovided, do not include in the calculations (conceptually\\n\\t\\t\\tequivalent to a uniform probability, but without scaling the\\n\\t\\t\\tprobabilities). This can be used to assign labels to observatons\\n\\t\\t\\tby setting one of the probabilities for an observation to 1.0.\\n\\t\\t\\tNote that this can be used to assign hard labels, but does not\\n\\t\\t\\thave the same semantics for soft labels, in that it only\\n\\t\\t\\tinfluences the initial estimate of an observation being generated\\n\\t\\t\\tby a component, not gives a target. Default is None.\\n\\n\\n\\t\\tReturns\\n\\t\\t-------\\n\\t\\tb: torch.Tensor, shape=(-1, length, self.n_distributions)\\n\\t\\t\\tThe log probabilities calculated by the backward algorithm.\\n\\t\\t'\n    emissions = _check_inputs(self, X, emissions, priors)\n    (n, l, _) = emissions.shape\n    b = torch.full((l, n, self.n_distributions), -inf, dtype=torch.float32, device=self.device)\n    b[-1] = self.ends\n    for i in range(l - 2, -1, -1):\n        p = b[i + 1, :, self._edge_idx_ends]\n        p += emissions[:, i + 1, self._edge_idx_ends]\n        p += self._edge_log_probs.expand(n, -1)\n        alpha = torch.max(p, dim=1, keepdims=True).values\n        p = torch.exp(p - alpha)\n        z = torch.zeros_like(b[i])\n        z.scatter_add_(1, self._edge_idx_starts.expand(n, -1), p)\n        b[i] = alpha + torch.log(z)\n    b = b.permute(1, 0, 2)\n    return b",
            "def backward(self, X=None, emissions=None, priors=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Run the backward algorithm on some data.\\n\\n\\t\\tRuns the backward algorithm on a batch of sequences. This is not to be\\n\\t\\tconfused with a \"backward pass\" when talking about neural networks. The\\n\\t\\tbackward algorithm is a dynamic programming algorithm that begins at end\\n\\t\\tof the sequence and returns the probability, over all paths through the\\n\\t\\tmodel, that result in the alignment of symbol i to node j, working\\n\\t\\tbackwards.\\n\\n\\t\\t\\n\\t\\tParameters\\n\\t\\t----------\\n\\t\\tX: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, d)\\n\\t\\t\\tA set of examples to evaluate. Does not need to be passed in if\\n\\t\\t\\temissions are. \\n\\n\\t\\temissions: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, n_distributions)\\n\\t\\t\\tPrecalculated emission log probabilities. These are the\\n\\t\\t\\tprobabilities of each observation under each probability \\n\\t\\t\\tdistribution. When running some algorithms it is more efficient\\n\\t\\t\\tto precalculate these and pass them into each call.\\n\\n\\t\\tpriors: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, self.k)\\n\\t\\t\\tPrior probabilities of assigning each symbol to each node. If not\\n\\t\\t\\tprovided, do not include in the calculations (conceptually\\n\\t\\t\\tequivalent to a uniform probability, but without scaling the\\n\\t\\t\\tprobabilities). This can be used to assign labels to observatons\\n\\t\\t\\tby setting one of the probabilities for an observation to 1.0.\\n\\t\\t\\tNote that this can be used to assign hard labels, but does not\\n\\t\\t\\thave the same semantics for soft labels, in that it only\\n\\t\\t\\tinfluences the initial estimate of an observation being generated\\n\\t\\t\\tby a component, not gives a target. Default is None.\\n\\n\\n\\t\\tReturns\\n\\t\\t-------\\n\\t\\tb: torch.Tensor, shape=(-1, length, self.n_distributions)\\n\\t\\t\\tThe log probabilities calculated by the backward algorithm.\\n\\t\\t'\n    emissions = _check_inputs(self, X, emissions, priors)\n    (n, l, _) = emissions.shape\n    b = torch.full((l, n, self.n_distributions), -inf, dtype=torch.float32, device=self.device)\n    b[-1] = self.ends\n    for i in range(l - 2, -1, -1):\n        p = b[i + 1, :, self._edge_idx_ends]\n        p += emissions[:, i + 1, self._edge_idx_ends]\n        p += self._edge_log_probs.expand(n, -1)\n        alpha = torch.max(p, dim=1, keepdims=True).values\n        p = torch.exp(p - alpha)\n        z = torch.zeros_like(b[i])\n        z.scatter_add_(1, self._edge_idx_starts.expand(n, -1), p)\n        b[i] = alpha + torch.log(z)\n    b = b.permute(1, 0, 2)\n    return b"
        ]
    },
    {
        "func_name": "forward_backward",
        "original": "def forward_backward(self, X=None, emissions=None, priors=None):\n    \"\"\"Run the forward-backward algorithm on some data.\n\n\t\tRuns the forward-backward algorithm on a batch of sequences. This\n\t\talgorithm combines the best of the forward and the backward algorithm.\n\t\tIt combines the probability of starting at the beginning of the sequence\n\t\tand working your way to each observation with the probability of\n\t\tstarting at the end of the sequence and working your way backward to it.\n\n\t\tA number of statistics can be calculated using this information. These\n\t\tstatistics are powerful inference tools but are also used during the\n\t\tBaum-Welch training process. \n\n\t\t\n\t\tParameters\n\t\t----------\n\t\tX: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, d)\n\t\t\tA set of examples to evaluate. Does not need to be passed in if\n\t\t\temissions are. \n\n\t\temissions: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, n_distributions)\n\t\t\tPrecalculated emission log probabilities. These are the\n\t\t\tprobabilities of each observation under each probability \n\t\t\tdistribution. When running some algorithms it is more efficient\n\t\t\tto precalculate these and pass them into each call.\n\n\t\tpriors: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, self.k)\n\t\t\tPrior probabilities of assigning each symbol to each node. If not\n\t\t\tprovided, do not include in the calculations (conceptually\n\t\t\tequivalent to a uniform probability, but without scaling the\n\t\t\tprobabilities). This can be used to assign labels to observatons\n\t\t\tby setting one of the probabilities for an observation to 1.0.\n\t\t\tNote that this can be used to assign hard labels, but does not\n\t\t\thave the same semantics for soft labels, in that it only\n\t\t\tinfluences the initial estimate of an observation being generated\n\t\t\tby a component, not gives a target. Default is None.\n\n\n\t\tReturns\n\t\t-------\n\t\ttransitions: torch.Tensor, shape=(-1, n, n)\n\t\t\tThe expected number of transitions across each edge that occur\n\t\t\tfor each example. The returned transitions follow the structure\n\t\t\tof the transition matrix and so will be dense or sparse as\n\t\t\tappropriate.\n\n\t\tresponsibility: torch.Tensor, shape=(-1, -1, n)\n\t\t\tThe posterior probabilities of each observation belonging to each\n\t\t\tstate given that one starts at the beginning of the sequence,\n\t\t\taligns observations across all paths to get to the current\n\t\t\tobservation, and then proceeds to align all remaining observations\n\t\t\tuntil the end of the sequence.\n\n\t\tstarts: torch.Tensor, shape=(-1, n)\n\t\t\tThe probabilities of starting at each node given the \n\t\t\tforward-backward algorithm.\n\n\t\tends: torch.Tensor, shape=(-1, n)\n\t\t\tThe probabilities of ending at each node given the forward-backward\n\t\t\talgorithm.\n\n\t\tlogp: torch.Tensor, shape=(-1,)\n\t\t\tThe log probabilities of each sequence given the model.\n\t\t\"\"\"\n    emissions = _check_inputs(self, X, emissions, priors)\n    (n, l, _) = emissions.shape\n    f = self.forward(emissions=emissions)\n    b = self.backward(emissions=emissions)\n    logp = torch.logsumexp(f[:, -1] + self.ends, dim=1)\n    t = f[:, :-1, self._edge_idx_starts] + b[:, 1:, self._edge_idx_ends]\n    t += emissions[:, 1:, self._edge_idx_ends]\n    t += self._edge_log_probs.expand(n, l - 1, -1)\n    t = torch.exp(torch.logsumexp(t, dim=1).T - logp).T\n    starts = self.starts + emissions[:, 0] + b[:, 0]\n    starts = torch.exp(starts.T - torch.logsumexp(starts, dim=-1)).T\n    ends = self.ends + f[:, -1]\n    ends = torch.exp(ends.T - torch.logsumexp(ends, dim=-1)).T\n    r = f + b\n    r = r - torch.logsumexp(r, dim=2).reshape(n, -1, 1)\n    return (t, r, starts, ends, logp)",
        "mutated": [
            "def forward_backward(self, X=None, emissions=None, priors=None):\n    if False:\n        i = 10\n    'Run the forward-backward algorithm on some data.\\n\\n\\t\\tRuns the forward-backward algorithm on a batch of sequences. This\\n\\t\\talgorithm combines the best of the forward and the backward algorithm.\\n\\t\\tIt combines the probability of starting at the beginning of the sequence\\n\\t\\tand working your way to each observation with the probability of\\n\\t\\tstarting at the end of the sequence and working your way backward to it.\\n\\n\\t\\tA number of statistics can be calculated using this information. These\\n\\t\\tstatistics are powerful inference tools but are also used during the\\n\\t\\tBaum-Welch training process. \\n\\n\\t\\t\\n\\t\\tParameters\\n\\t\\t----------\\n\\t\\tX: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, d)\\n\\t\\t\\tA set of examples to evaluate. Does not need to be passed in if\\n\\t\\t\\temissions are. \\n\\n\\t\\temissions: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, n_distributions)\\n\\t\\t\\tPrecalculated emission log probabilities. These are the\\n\\t\\t\\tprobabilities of each observation under each probability \\n\\t\\t\\tdistribution. When running some algorithms it is more efficient\\n\\t\\t\\tto precalculate these and pass them into each call.\\n\\n\\t\\tpriors: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, self.k)\\n\\t\\t\\tPrior probabilities of assigning each symbol to each node. If not\\n\\t\\t\\tprovided, do not include in the calculations (conceptually\\n\\t\\t\\tequivalent to a uniform probability, but without scaling the\\n\\t\\t\\tprobabilities). This can be used to assign labels to observatons\\n\\t\\t\\tby setting one of the probabilities for an observation to 1.0.\\n\\t\\t\\tNote that this can be used to assign hard labels, but does not\\n\\t\\t\\thave the same semantics for soft labels, in that it only\\n\\t\\t\\tinfluences the initial estimate of an observation being generated\\n\\t\\t\\tby a component, not gives a target. Default is None.\\n\\n\\n\\t\\tReturns\\n\\t\\t-------\\n\\t\\ttransitions: torch.Tensor, shape=(-1, n, n)\\n\\t\\t\\tThe expected number of transitions across each edge that occur\\n\\t\\t\\tfor each example. The returned transitions follow the structure\\n\\t\\t\\tof the transition matrix and so will be dense or sparse as\\n\\t\\t\\tappropriate.\\n\\n\\t\\tresponsibility: torch.Tensor, shape=(-1, -1, n)\\n\\t\\t\\tThe posterior probabilities of each observation belonging to each\\n\\t\\t\\tstate given that one starts at the beginning of the sequence,\\n\\t\\t\\taligns observations across all paths to get to the current\\n\\t\\t\\tobservation, and then proceeds to align all remaining observations\\n\\t\\t\\tuntil the end of the sequence.\\n\\n\\t\\tstarts: torch.Tensor, shape=(-1, n)\\n\\t\\t\\tThe probabilities of starting at each node given the \\n\\t\\t\\tforward-backward algorithm.\\n\\n\\t\\tends: torch.Tensor, shape=(-1, n)\\n\\t\\t\\tThe probabilities of ending at each node given the forward-backward\\n\\t\\t\\talgorithm.\\n\\n\\t\\tlogp: torch.Tensor, shape=(-1,)\\n\\t\\t\\tThe log probabilities of each sequence given the model.\\n\\t\\t'\n    emissions = _check_inputs(self, X, emissions, priors)\n    (n, l, _) = emissions.shape\n    f = self.forward(emissions=emissions)\n    b = self.backward(emissions=emissions)\n    logp = torch.logsumexp(f[:, -1] + self.ends, dim=1)\n    t = f[:, :-1, self._edge_idx_starts] + b[:, 1:, self._edge_idx_ends]\n    t += emissions[:, 1:, self._edge_idx_ends]\n    t += self._edge_log_probs.expand(n, l - 1, -1)\n    t = torch.exp(torch.logsumexp(t, dim=1).T - logp).T\n    starts = self.starts + emissions[:, 0] + b[:, 0]\n    starts = torch.exp(starts.T - torch.logsumexp(starts, dim=-1)).T\n    ends = self.ends + f[:, -1]\n    ends = torch.exp(ends.T - torch.logsumexp(ends, dim=-1)).T\n    r = f + b\n    r = r - torch.logsumexp(r, dim=2).reshape(n, -1, 1)\n    return (t, r, starts, ends, logp)",
            "def forward_backward(self, X=None, emissions=None, priors=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Run the forward-backward algorithm on some data.\\n\\n\\t\\tRuns the forward-backward algorithm on a batch of sequences. This\\n\\t\\talgorithm combines the best of the forward and the backward algorithm.\\n\\t\\tIt combines the probability of starting at the beginning of the sequence\\n\\t\\tand working your way to each observation with the probability of\\n\\t\\tstarting at the end of the sequence and working your way backward to it.\\n\\n\\t\\tA number of statistics can be calculated using this information. These\\n\\t\\tstatistics are powerful inference tools but are also used during the\\n\\t\\tBaum-Welch training process. \\n\\n\\t\\t\\n\\t\\tParameters\\n\\t\\t----------\\n\\t\\tX: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, d)\\n\\t\\t\\tA set of examples to evaluate. Does not need to be passed in if\\n\\t\\t\\temissions are. \\n\\n\\t\\temissions: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, n_distributions)\\n\\t\\t\\tPrecalculated emission log probabilities. These are the\\n\\t\\t\\tprobabilities of each observation under each probability \\n\\t\\t\\tdistribution. When running some algorithms it is more efficient\\n\\t\\t\\tto precalculate these and pass them into each call.\\n\\n\\t\\tpriors: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, self.k)\\n\\t\\t\\tPrior probabilities of assigning each symbol to each node. If not\\n\\t\\t\\tprovided, do not include in the calculations (conceptually\\n\\t\\t\\tequivalent to a uniform probability, but without scaling the\\n\\t\\t\\tprobabilities). This can be used to assign labels to observatons\\n\\t\\t\\tby setting one of the probabilities for an observation to 1.0.\\n\\t\\t\\tNote that this can be used to assign hard labels, but does not\\n\\t\\t\\thave the same semantics for soft labels, in that it only\\n\\t\\t\\tinfluences the initial estimate of an observation being generated\\n\\t\\t\\tby a component, not gives a target. Default is None.\\n\\n\\n\\t\\tReturns\\n\\t\\t-------\\n\\t\\ttransitions: torch.Tensor, shape=(-1, n, n)\\n\\t\\t\\tThe expected number of transitions across each edge that occur\\n\\t\\t\\tfor each example. The returned transitions follow the structure\\n\\t\\t\\tof the transition matrix and so will be dense or sparse as\\n\\t\\t\\tappropriate.\\n\\n\\t\\tresponsibility: torch.Tensor, shape=(-1, -1, n)\\n\\t\\t\\tThe posterior probabilities of each observation belonging to each\\n\\t\\t\\tstate given that one starts at the beginning of the sequence,\\n\\t\\t\\taligns observations across all paths to get to the current\\n\\t\\t\\tobservation, and then proceeds to align all remaining observations\\n\\t\\t\\tuntil the end of the sequence.\\n\\n\\t\\tstarts: torch.Tensor, shape=(-1, n)\\n\\t\\t\\tThe probabilities of starting at each node given the \\n\\t\\t\\tforward-backward algorithm.\\n\\n\\t\\tends: torch.Tensor, shape=(-1, n)\\n\\t\\t\\tThe probabilities of ending at each node given the forward-backward\\n\\t\\t\\talgorithm.\\n\\n\\t\\tlogp: torch.Tensor, shape=(-1,)\\n\\t\\t\\tThe log probabilities of each sequence given the model.\\n\\t\\t'\n    emissions = _check_inputs(self, X, emissions, priors)\n    (n, l, _) = emissions.shape\n    f = self.forward(emissions=emissions)\n    b = self.backward(emissions=emissions)\n    logp = torch.logsumexp(f[:, -1] + self.ends, dim=1)\n    t = f[:, :-1, self._edge_idx_starts] + b[:, 1:, self._edge_idx_ends]\n    t += emissions[:, 1:, self._edge_idx_ends]\n    t += self._edge_log_probs.expand(n, l - 1, -1)\n    t = torch.exp(torch.logsumexp(t, dim=1).T - logp).T\n    starts = self.starts + emissions[:, 0] + b[:, 0]\n    starts = torch.exp(starts.T - torch.logsumexp(starts, dim=-1)).T\n    ends = self.ends + f[:, -1]\n    ends = torch.exp(ends.T - torch.logsumexp(ends, dim=-1)).T\n    r = f + b\n    r = r - torch.logsumexp(r, dim=2).reshape(n, -1, 1)\n    return (t, r, starts, ends, logp)",
            "def forward_backward(self, X=None, emissions=None, priors=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Run the forward-backward algorithm on some data.\\n\\n\\t\\tRuns the forward-backward algorithm on a batch of sequences. This\\n\\t\\talgorithm combines the best of the forward and the backward algorithm.\\n\\t\\tIt combines the probability of starting at the beginning of the sequence\\n\\t\\tand working your way to each observation with the probability of\\n\\t\\tstarting at the end of the sequence and working your way backward to it.\\n\\n\\t\\tA number of statistics can be calculated using this information. These\\n\\t\\tstatistics are powerful inference tools but are also used during the\\n\\t\\tBaum-Welch training process. \\n\\n\\t\\t\\n\\t\\tParameters\\n\\t\\t----------\\n\\t\\tX: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, d)\\n\\t\\t\\tA set of examples to evaluate. Does not need to be passed in if\\n\\t\\t\\temissions are. \\n\\n\\t\\temissions: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, n_distributions)\\n\\t\\t\\tPrecalculated emission log probabilities. These are the\\n\\t\\t\\tprobabilities of each observation under each probability \\n\\t\\t\\tdistribution. When running some algorithms it is more efficient\\n\\t\\t\\tto precalculate these and pass them into each call.\\n\\n\\t\\tpriors: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, self.k)\\n\\t\\t\\tPrior probabilities of assigning each symbol to each node. If not\\n\\t\\t\\tprovided, do not include in the calculations (conceptually\\n\\t\\t\\tequivalent to a uniform probability, but without scaling the\\n\\t\\t\\tprobabilities). This can be used to assign labels to observatons\\n\\t\\t\\tby setting one of the probabilities for an observation to 1.0.\\n\\t\\t\\tNote that this can be used to assign hard labels, but does not\\n\\t\\t\\thave the same semantics for soft labels, in that it only\\n\\t\\t\\tinfluences the initial estimate of an observation being generated\\n\\t\\t\\tby a component, not gives a target. Default is None.\\n\\n\\n\\t\\tReturns\\n\\t\\t-------\\n\\t\\ttransitions: torch.Tensor, shape=(-1, n, n)\\n\\t\\t\\tThe expected number of transitions across each edge that occur\\n\\t\\t\\tfor each example. The returned transitions follow the structure\\n\\t\\t\\tof the transition matrix and so will be dense or sparse as\\n\\t\\t\\tappropriate.\\n\\n\\t\\tresponsibility: torch.Tensor, shape=(-1, -1, n)\\n\\t\\t\\tThe posterior probabilities of each observation belonging to each\\n\\t\\t\\tstate given that one starts at the beginning of the sequence,\\n\\t\\t\\taligns observations across all paths to get to the current\\n\\t\\t\\tobservation, and then proceeds to align all remaining observations\\n\\t\\t\\tuntil the end of the sequence.\\n\\n\\t\\tstarts: torch.Tensor, shape=(-1, n)\\n\\t\\t\\tThe probabilities of starting at each node given the \\n\\t\\t\\tforward-backward algorithm.\\n\\n\\t\\tends: torch.Tensor, shape=(-1, n)\\n\\t\\t\\tThe probabilities of ending at each node given the forward-backward\\n\\t\\t\\talgorithm.\\n\\n\\t\\tlogp: torch.Tensor, shape=(-1,)\\n\\t\\t\\tThe log probabilities of each sequence given the model.\\n\\t\\t'\n    emissions = _check_inputs(self, X, emissions, priors)\n    (n, l, _) = emissions.shape\n    f = self.forward(emissions=emissions)\n    b = self.backward(emissions=emissions)\n    logp = torch.logsumexp(f[:, -1] + self.ends, dim=1)\n    t = f[:, :-1, self._edge_idx_starts] + b[:, 1:, self._edge_idx_ends]\n    t += emissions[:, 1:, self._edge_idx_ends]\n    t += self._edge_log_probs.expand(n, l - 1, -1)\n    t = torch.exp(torch.logsumexp(t, dim=1).T - logp).T\n    starts = self.starts + emissions[:, 0] + b[:, 0]\n    starts = torch.exp(starts.T - torch.logsumexp(starts, dim=-1)).T\n    ends = self.ends + f[:, -1]\n    ends = torch.exp(ends.T - torch.logsumexp(ends, dim=-1)).T\n    r = f + b\n    r = r - torch.logsumexp(r, dim=2).reshape(n, -1, 1)\n    return (t, r, starts, ends, logp)",
            "def forward_backward(self, X=None, emissions=None, priors=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Run the forward-backward algorithm on some data.\\n\\n\\t\\tRuns the forward-backward algorithm on a batch of sequences. This\\n\\t\\talgorithm combines the best of the forward and the backward algorithm.\\n\\t\\tIt combines the probability of starting at the beginning of the sequence\\n\\t\\tand working your way to each observation with the probability of\\n\\t\\tstarting at the end of the sequence and working your way backward to it.\\n\\n\\t\\tA number of statistics can be calculated using this information. These\\n\\t\\tstatistics are powerful inference tools but are also used during the\\n\\t\\tBaum-Welch training process. \\n\\n\\t\\t\\n\\t\\tParameters\\n\\t\\t----------\\n\\t\\tX: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, d)\\n\\t\\t\\tA set of examples to evaluate. Does not need to be passed in if\\n\\t\\t\\temissions are. \\n\\n\\t\\temissions: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, n_distributions)\\n\\t\\t\\tPrecalculated emission log probabilities. These are the\\n\\t\\t\\tprobabilities of each observation under each probability \\n\\t\\t\\tdistribution. When running some algorithms it is more efficient\\n\\t\\t\\tto precalculate these and pass them into each call.\\n\\n\\t\\tpriors: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, self.k)\\n\\t\\t\\tPrior probabilities of assigning each symbol to each node. If not\\n\\t\\t\\tprovided, do not include in the calculations (conceptually\\n\\t\\t\\tequivalent to a uniform probability, but without scaling the\\n\\t\\t\\tprobabilities). This can be used to assign labels to observatons\\n\\t\\t\\tby setting one of the probabilities for an observation to 1.0.\\n\\t\\t\\tNote that this can be used to assign hard labels, but does not\\n\\t\\t\\thave the same semantics for soft labels, in that it only\\n\\t\\t\\tinfluences the initial estimate of an observation being generated\\n\\t\\t\\tby a component, not gives a target. Default is None.\\n\\n\\n\\t\\tReturns\\n\\t\\t-------\\n\\t\\ttransitions: torch.Tensor, shape=(-1, n, n)\\n\\t\\t\\tThe expected number of transitions across each edge that occur\\n\\t\\t\\tfor each example. The returned transitions follow the structure\\n\\t\\t\\tof the transition matrix and so will be dense or sparse as\\n\\t\\t\\tappropriate.\\n\\n\\t\\tresponsibility: torch.Tensor, shape=(-1, -1, n)\\n\\t\\t\\tThe posterior probabilities of each observation belonging to each\\n\\t\\t\\tstate given that one starts at the beginning of the sequence,\\n\\t\\t\\taligns observations across all paths to get to the current\\n\\t\\t\\tobservation, and then proceeds to align all remaining observations\\n\\t\\t\\tuntil the end of the sequence.\\n\\n\\t\\tstarts: torch.Tensor, shape=(-1, n)\\n\\t\\t\\tThe probabilities of starting at each node given the \\n\\t\\t\\tforward-backward algorithm.\\n\\n\\t\\tends: torch.Tensor, shape=(-1, n)\\n\\t\\t\\tThe probabilities of ending at each node given the forward-backward\\n\\t\\t\\talgorithm.\\n\\n\\t\\tlogp: torch.Tensor, shape=(-1,)\\n\\t\\t\\tThe log probabilities of each sequence given the model.\\n\\t\\t'\n    emissions = _check_inputs(self, X, emissions, priors)\n    (n, l, _) = emissions.shape\n    f = self.forward(emissions=emissions)\n    b = self.backward(emissions=emissions)\n    logp = torch.logsumexp(f[:, -1] + self.ends, dim=1)\n    t = f[:, :-1, self._edge_idx_starts] + b[:, 1:, self._edge_idx_ends]\n    t += emissions[:, 1:, self._edge_idx_ends]\n    t += self._edge_log_probs.expand(n, l - 1, -1)\n    t = torch.exp(torch.logsumexp(t, dim=1).T - logp).T\n    starts = self.starts + emissions[:, 0] + b[:, 0]\n    starts = torch.exp(starts.T - torch.logsumexp(starts, dim=-1)).T\n    ends = self.ends + f[:, -1]\n    ends = torch.exp(ends.T - torch.logsumexp(ends, dim=-1)).T\n    r = f + b\n    r = r - torch.logsumexp(r, dim=2).reshape(n, -1, 1)\n    return (t, r, starts, ends, logp)",
            "def forward_backward(self, X=None, emissions=None, priors=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Run the forward-backward algorithm on some data.\\n\\n\\t\\tRuns the forward-backward algorithm on a batch of sequences. This\\n\\t\\talgorithm combines the best of the forward and the backward algorithm.\\n\\t\\tIt combines the probability of starting at the beginning of the sequence\\n\\t\\tand working your way to each observation with the probability of\\n\\t\\tstarting at the end of the sequence and working your way backward to it.\\n\\n\\t\\tA number of statistics can be calculated using this information. These\\n\\t\\tstatistics are powerful inference tools but are also used during the\\n\\t\\tBaum-Welch training process. \\n\\n\\t\\t\\n\\t\\tParameters\\n\\t\\t----------\\n\\t\\tX: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, d)\\n\\t\\t\\tA set of examples to evaluate. Does not need to be passed in if\\n\\t\\t\\temissions are. \\n\\n\\t\\temissions: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, n_distributions)\\n\\t\\t\\tPrecalculated emission log probabilities. These are the\\n\\t\\t\\tprobabilities of each observation under each probability \\n\\t\\t\\tdistribution. When running some algorithms it is more efficient\\n\\t\\t\\tto precalculate these and pass them into each call.\\n\\n\\t\\tpriors: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, self.k)\\n\\t\\t\\tPrior probabilities of assigning each symbol to each node. If not\\n\\t\\t\\tprovided, do not include in the calculations (conceptually\\n\\t\\t\\tequivalent to a uniform probability, but without scaling the\\n\\t\\t\\tprobabilities). This can be used to assign labels to observatons\\n\\t\\t\\tby setting one of the probabilities for an observation to 1.0.\\n\\t\\t\\tNote that this can be used to assign hard labels, but does not\\n\\t\\t\\thave the same semantics for soft labels, in that it only\\n\\t\\t\\tinfluences the initial estimate of an observation being generated\\n\\t\\t\\tby a component, not gives a target. Default is None.\\n\\n\\n\\t\\tReturns\\n\\t\\t-------\\n\\t\\ttransitions: torch.Tensor, shape=(-1, n, n)\\n\\t\\t\\tThe expected number of transitions across each edge that occur\\n\\t\\t\\tfor each example. The returned transitions follow the structure\\n\\t\\t\\tof the transition matrix and so will be dense or sparse as\\n\\t\\t\\tappropriate.\\n\\n\\t\\tresponsibility: torch.Tensor, shape=(-1, -1, n)\\n\\t\\t\\tThe posterior probabilities of each observation belonging to each\\n\\t\\t\\tstate given that one starts at the beginning of the sequence,\\n\\t\\t\\taligns observations across all paths to get to the current\\n\\t\\t\\tobservation, and then proceeds to align all remaining observations\\n\\t\\t\\tuntil the end of the sequence.\\n\\n\\t\\tstarts: torch.Tensor, shape=(-1, n)\\n\\t\\t\\tThe probabilities of starting at each node given the \\n\\t\\t\\tforward-backward algorithm.\\n\\n\\t\\tends: torch.Tensor, shape=(-1, n)\\n\\t\\t\\tThe probabilities of ending at each node given the forward-backward\\n\\t\\t\\talgorithm.\\n\\n\\t\\tlogp: torch.Tensor, shape=(-1,)\\n\\t\\t\\tThe log probabilities of each sequence given the model.\\n\\t\\t'\n    emissions = _check_inputs(self, X, emissions, priors)\n    (n, l, _) = emissions.shape\n    f = self.forward(emissions=emissions)\n    b = self.backward(emissions=emissions)\n    logp = torch.logsumexp(f[:, -1] + self.ends, dim=1)\n    t = f[:, :-1, self._edge_idx_starts] + b[:, 1:, self._edge_idx_ends]\n    t += emissions[:, 1:, self._edge_idx_ends]\n    t += self._edge_log_probs.expand(n, l - 1, -1)\n    t = torch.exp(torch.logsumexp(t, dim=1).T - logp).T\n    starts = self.starts + emissions[:, 0] + b[:, 0]\n    starts = torch.exp(starts.T - torch.logsumexp(starts, dim=-1)).T\n    ends = self.ends + f[:, -1]\n    ends = torch.exp(ends.T - torch.logsumexp(ends, dim=-1)).T\n    r = f + b\n    r = r - torch.logsumexp(r, dim=2).reshape(n, -1, 1)\n    return (t, r, starts, ends, logp)"
        ]
    },
    {
        "func_name": "summarize",
        "original": "def summarize(self, X, sample_weight=None, emissions=None, priors=None):\n    \"\"\"Extract the sufficient statistics from a batch of data.\n\n\t\tThis method calculates the sufficient statistics from optionally\n\t\tweighted data and adds them to the stored cache. The examples must be\n\t\tgiven in a 2D format. Sample weights can either be provided as one\n\t\tvalue per example or as a 2D matrix of weights for each feature in\n\t\teach example.\n\n\n\t\tParameters\n\t\t----------\n\t\tX: list, tuple, numpy.ndarray, torch.Tensor, shape=(-1, self.d)\n\t\t\tA set of examples to summarize.\n\n\t\tsample_weight: list, tuple, numpy.ndarray, torch.Tensor, optional\n\t\t\tA set of weights for the examples. This can be either of shape\n\t\t\t(-1, self.d) or a vector of shape (-1,). Default is ones.\n\n\t\temissions: torch.Tensor, shape=(-1, -1, self.n_distributions)\n\t\t\tPrecalculated emission log probabilities. These are the\n\t\t\tprobabilities of each observation under each probability \n\t\t\tdistribution. When running some algorithms it is more efficient\n\t\t\tto precalculate these and pass them into each call.\t\n\n\t\tpriors: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, self.k)\n\t\t\tPrior probabilities of assigning each symbol to each node. If not\n\t\t\tprovided, do not include in the calculations (conceptually\n\t\t\tequivalent to a uniform probability, but without scaling the\n\t\t\tprobabilities). This can be used to assign labels to observatons\n\t\t\tby setting one of the probabilities for an observation to 1.0.\n\t\t\tNote that this can be used to assign hard labels, but does not\n\t\t\thave the same semantics for soft labels, in that it only\n\t\t\tinfluences the initial estimate of an observation being generated\n\t\t\tby a component, not gives a target. Default is None.\n\t\t\"\"\"\n    (X, emissions, sample_weight) = super().summarize(X, sample_weight=sample_weight, emissions=emissions, priors=priors)\n    (t, r, starts, ends, logps) = self.forward_backward(emissions=emissions)\n    self._xw_starts_sum += torch.sum(starts * sample_weight, dim=0)\n    self._xw_ends_sum += torch.sum(ends * sample_weight, dim=0)\n    self._xw_sum += torch.sum(t * sample_weight, dim=0)\n    X = X.reshape(-1, X.shape[-1])\n    r = torch.exp(r) * sample_weight.unsqueeze(1)\n    for (i, node) in enumerate(self.distributions):\n        w = r[:, :, i].reshape(-1, 1)\n        node.summarize(X, sample_weight=w)\n    return logps",
        "mutated": [
            "def summarize(self, X, sample_weight=None, emissions=None, priors=None):\n    if False:\n        i = 10\n    'Extract the sufficient statistics from a batch of data.\\n\\n\\t\\tThis method calculates the sufficient statistics from optionally\\n\\t\\tweighted data and adds them to the stored cache. The examples must be\\n\\t\\tgiven in a 2D format. Sample weights can either be provided as one\\n\\t\\tvalue per example or as a 2D matrix of weights for each feature in\\n\\t\\teach example.\\n\\n\\n\\t\\tParameters\\n\\t\\t----------\\n\\t\\tX: list, tuple, numpy.ndarray, torch.Tensor, shape=(-1, self.d)\\n\\t\\t\\tA set of examples to summarize.\\n\\n\\t\\tsample_weight: list, tuple, numpy.ndarray, torch.Tensor, optional\\n\\t\\t\\tA set of weights for the examples. This can be either of shape\\n\\t\\t\\t(-1, self.d) or a vector of shape (-1,). Default is ones.\\n\\n\\t\\temissions: torch.Tensor, shape=(-1, -1, self.n_distributions)\\n\\t\\t\\tPrecalculated emission log probabilities. These are the\\n\\t\\t\\tprobabilities of each observation under each probability \\n\\t\\t\\tdistribution. When running some algorithms it is more efficient\\n\\t\\t\\tto precalculate these and pass them into each call.\\t\\n\\n\\t\\tpriors: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, self.k)\\n\\t\\t\\tPrior probabilities of assigning each symbol to each node. If not\\n\\t\\t\\tprovided, do not include in the calculations (conceptually\\n\\t\\t\\tequivalent to a uniform probability, but without scaling the\\n\\t\\t\\tprobabilities). This can be used to assign labels to observatons\\n\\t\\t\\tby setting one of the probabilities for an observation to 1.0.\\n\\t\\t\\tNote that this can be used to assign hard labels, but does not\\n\\t\\t\\thave the same semantics for soft labels, in that it only\\n\\t\\t\\tinfluences the initial estimate of an observation being generated\\n\\t\\t\\tby a component, not gives a target. Default is None.\\n\\t\\t'\n    (X, emissions, sample_weight) = super().summarize(X, sample_weight=sample_weight, emissions=emissions, priors=priors)\n    (t, r, starts, ends, logps) = self.forward_backward(emissions=emissions)\n    self._xw_starts_sum += torch.sum(starts * sample_weight, dim=0)\n    self._xw_ends_sum += torch.sum(ends * sample_weight, dim=0)\n    self._xw_sum += torch.sum(t * sample_weight, dim=0)\n    X = X.reshape(-1, X.shape[-1])\n    r = torch.exp(r) * sample_weight.unsqueeze(1)\n    for (i, node) in enumerate(self.distributions):\n        w = r[:, :, i].reshape(-1, 1)\n        node.summarize(X, sample_weight=w)\n    return logps",
            "def summarize(self, X, sample_weight=None, emissions=None, priors=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Extract the sufficient statistics from a batch of data.\\n\\n\\t\\tThis method calculates the sufficient statistics from optionally\\n\\t\\tweighted data and adds them to the stored cache. The examples must be\\n\\t\\tgiven in a 2D format. Sample weights can either be provided as one\\n\\t\\tvalue per example or as a 2D matrix of weights for each feature in\\n\\t\\teach example.\\n\\n\\n\\t\\tParameters\\n\\t\\t----------\\n\\t\\tX: list, tuple, numpy.ndarray, torch.Tensor, shape=(-1, self.d)\\n\\t\\t\\tA set of examples to summarize.\\n\\n\\t\\tsample_weight: list, tuple, numpy.ndarray, torch.Tensor, optional\\n\\t\\t\\tA set of weights for the examples. This can be either of shape\\n\\t\\t\\t(-1, self.d) or a vector of shape (-1,). Default is ones.\\n\\n\\t\\temissions: torch.Tensor, shape=(-1, -1, self.n_distributions)\\n\\t\\t\\tPrecalculated emission log probabilities. These are the\\n\\t\\t\\tprobabilities of each observation under each probability \\n\\t\\t\\tdistribution. When running some algorithms it is more efficient\\n\\t\\t\\tto precalculate these and pass them into each call.\\t\\n\\n\\t\\tpriors: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, self.k)\\n\\t\\t\\tPrior probabilities of assigning each symbol to each node. If not\\n\\t\\t\\tprovided, do not include in the calculations (conceptually\\n\\t\\t\\tequivalent to a uniform probability, but without scaling the\\n\\t\\t\\tprobabilities). This can be used to assign labels to observatons\\n\\t\\t\\tby setting one of the probabilities for an observation to 1.0.\\n\\t\\t\\tNote that this can be used to assign hard labels, but does not\\n\\t\\t\\thave the same semantics for soft labels, in that it only\\n\\t\\t\\tinfluences the initial estimate of an observation being generated\\n\\t\\t\\tby a component, not gives a target. Default is None.\\n\\t\\t'\n    (X, emissions, sample_weight) = super().summarize(X, sample_weight=sample_weight, emissions=emissions, priors=priors)\n    (t, r, starts, ends, logps) = self.forward_backward(emissions=emissions)\n    self._xw_starts_sum += torch.sum(starts * sample_weight, dim=0)\n    self._xw_ends_sum += torch.sum(ends * sample_weight, dim=0)\n    self._xw_sum += torch.sum(t * sample_weight, dim=0)\n    X = X.reshape(-1, X.shape[-1])\n    r = torch.exp(r) * sample_weight.unsqueeze(1)\n    for (i, node) in enumerate(self.distributions):\n        w = r[:, :, i].reshape(-1, 1)\n        node.summarize(X, sample_weight=w)\n    return logps",
            "def summarize(self, X, sample_weight=None, emissions=None, priors=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Extract the sufficient statistics from a batch of data.\\n\\n\\t\\tThis method calculates the sufficient statistics from optionally\\n\\t\\tweighted data and adds them to the stored cache. The examples must be\\n\\t\\tgiven in a 2D format. Sample weights can either be provided as one\\n\\t\\tvalue per example or as a 2D matrix of weights for each feature in\\n\\t\\teach example.\\n\\n\\n\\t\\tParameters\\n\\t\\t----------\\n\\t\\tX: list, tuple, numpy.ndarray, torch.Tensor, shape=(-1, self.d)\\n\\t\\t\\tA set of examples to summarize.\\n\\n\\t\\tsample_weight: list, tuple, numpy.ndarray, torch.Tensor, optional\\n\\t\\t\\tA set of weights for the examples. This can be either of shape\\n\\t\\t\\t(-1, self.d) or a vector of shape (-1,). Default is ones.\\n\\n\\t\\temissions: torch.Tensor, shape=(-1, -1, self.n_distributions)\\n\\t\\t\\tPrecalculated emission log probabilities. These are the\\n\\t\\t\\tprobabilities of each observation under each probability \\n\\t\\t\\tdistribution. When running some algorithms it is more efficient\\n\\t\\t\\tto precalculate these and pass them into each call.\\t\\n\\n\\t\\tpriors: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, self.k)\\n\\t\\t\\tPrior probabilities of assigning each symbol to each node. If not\\n\\t\\t\\tprovided, do not include in the calculations (conceptually\\n\\t\\t\\tequivalent to a uniform probability, but without scaling the\\n\\t\\t\\tprobabilities). This can be used to assign labels to observatons\\n\\t\\t\\tby setting one of the probabilities for an observation to 1.0.\\n\\t\\t\\tNote that this can be used to assign hard labels, but does not\\n\\t\\t\\thave the same semantics for soft labels, in that it only\\n\\t\\t\\tinfluences the initial estimate of an observation being generated\\n\\t\\t\\tby a component, not gives a target. Default is None.\\n\\t\\t'\n    (X, emissions, sample_weight) = super().summarize(X, sample_weight=sample_weight, emissions=emissions, priors=priors)\n    (t, r, starts, ends, logps) = self.forward_backward(emissions=emissions)\n    self._xw_starts_sum += torch.sum(starts * sample_weight, dim=0)\n    self._xw_ends_sum += torch.sum(ends * sample_weight, dim=0)\n    self._xw_sum += torch.sum(t * sample_weight, dim=0)\n    X = X.reshape(-1, X.shape[-1])\n    r = torch.exp(r) * sample_weight.unsqueeze(1)\n    for (i, node) in enumerate(self.distributions):\n        w = r[:, :, i].reshape(-1, 1)\n        node.summarize(X, sample_weight=w)\n    return logps",
            "def summarize(self, X, sample_weight=None, emissions=None, priors=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Extract the sufficient statistics from a batch of data.\\n\\n\\t\\tThis method calculates the sufficient statistics from optionally\\n\\t\\tweighted data and adds them to the stored cache. The examples must be\\n\\t\\tgiven in a 2D format. Sample weights can either be provided as one\\n\\t\\tvalue per example or as a 2D matrix of weights for each feature in\\n\\t\\teach example.\\n\\n\\n\\t\\tParameters\\n\\t\\t----------\\n\\t\\tX: list, tuple, numpy.ndarray, torch.Tensor, shape=(-1, self.d)\\n\\t\\t\\tA set of examples to summarize.\\n\\n\\t\\tsample_weight: list, tuple, numpy.ndarray, torch.Tensor, optional\\n\\t\\t\\tA set of weights for the examples. This can be either of shape\\n\\t\\t\\t(-1, self.d) or a vector of shape (-1,). Default is ones.\\n\\n\\t\\temissions: torch.Tensor, shape=(-1, -1, self.n_distributions)\\n\\t\\t\\tPrecalculated emission log probabilities. These are the\\n\\t\\t\\tprobabilities of each observation under each probability \\n\\t\\t\\tdistribution. When running some algorithms it is more efficient\\n\\t\\t\\tto precalculate these and pass them into each call.\\t\\n\\n\\t\\tpriors: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, self.k)\\n\\t\\t\\tPrior probabilities of assigning each symbol to each node. If not\\n\\t\\t\\tprovided, do not include in the calculations (conceptually\\n\\t\\t\\tequivalent to a uniform probability, but without scaling the\\n\\t\\t\\tprobabilities). This can be used to assign labels to observatons\\n\\t\\t\\tby setting one of the probabilities for an observation to 1.0.\\n\\t\\t\\tNote that this can be used to assign hard labels, but does not\\n\\t\\t\\thave the same semantics for soft labels, in that it only\\n\\t\\t\\tinfluences the initial estimate of an observation being generated\\n\\t\\t\\tby a component, not gives a target. Default is None.\\n\\t\\t'\n    (X, emissions, sample_weight) = super().summarize(X, sample_weight=sample_weight, emissions=emissions, priors=priors)\n    (t, r, starts, ends, logps) = self.forward_backward(emissions=emissions)\n    self._xw_starts_sum += torch.sum(starts * sample_weight, dim=0)\n    self._xw_ends_sum += torch.sum(ends * sample_weight, dim=0)\n    self._xw_sum += torch.sum(t * sample_weight, dim=0)\n    X = X.reshape(-1, X.shape[-1])\n    r = torch.exp(r) * sample_weight.unsqueeze(1)\n    for (i, node) in enumerate(self.distributions):\n        w = r[:, :, i].reshape(-1, 1)\n        node.summarize(X, sample_weight=w)\n    return logps",
            "def summarize(self, X, sample_weight=None, emissions=None, priors=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Extract the sufficient statistics from a batch of data.\\n\\n\\t\\tThis method calculates the sufficient statistics from optionally\\n\\t\\tweighted data and adds them to the stored cache. The examples must be\\n\\t\\tgiven in a 2D format. Sample weights can either be provided as one\\n\\t\\tvalue per example or as a 2D matrix of weights for each feature in\\n\\t\\teach example.\\n\\n\\n\\t\\tParameters\\n\\t\\t----------\\n\\t\\tX: list, tuple, numpy.ndarray, torch.Tensor, shape=(-1, self.d)\\n\\t\\t\\tA set of examples to summarize.\\n\\n\\t\\tsample_weight: list, tuple, numpy.ndarray, torch.Tensor, optional\\n\\t\\t\\tA set of weights for the examples. This can be either of shape\\n\\t\\t\\t(-1, self.d) or a vector of shape (-1,). Default is ones.\\n\\n\\t\\temissions: torch.Tensor, shape=(-1, -1, self.n_distributions)\\n\\t\\t\\tPrecalculated emission log probabilities. These are the\\n\\t\\t\\tprobabilities of each observation under each probability \\n\\t\\t\\tdistribution. When running some algorithms it is more efficient\\n\\t\\t\\tto precalculate these and pass them into each call.\\t\\n\\n\\t\\tpriors: list, numpy.ndarray, torch.Tensor, shape=(-1, -1, self.k)\\n\\t\\t\\tPrior probabilities of assigning each symbol to each node. If not\\n\\t\\t\\tprovided, do not include in the calculations (conceptually\\n\\t\\t\\tequivalent to a uniform probability, but without scaling the\\n\\t\\t\\tprobabilities). This can be used to assign labels to observatons\\n\\t\\t\\tby setting one of the probabilities for an observation to 1.0.\\n\\t\\t\\tNote that this can be used to assign hard labels, but does not\\n\\t\\t\\thave the same semantics for soft labels, in that it only\\n\\t\\t\\tinfluences the initial estimate of an observation being generated\\n\\t\\t\\tby a component, not gives a target. Default is None.\\n\\t\\t'\n    (X, emissions, sample_weight) = super().summarize(X, sample_weight=sample_weight, emissions=emissions, priors=priors)\n    (t, r, starts, ends, logps) = self.forward_backward(emissions=emissions)\n    self._xw_starts_sum += torch.sum(starts * sample_weight, dim=0)\n    self._xw_ends_sum += torch.sum(ends * sample_weight, dim=0)\n    self._xw_sum += torch.sum(t * sample_weight, dim=0)\n    X = X.reshape(-1, X.shape[-1])\n    r = torch.exp(r) * sample_weight.unsqueeze(1)\n    for (i, node) in enumerate(self.distributions):\n        w = r[:, :, i].reshape(-1, 1)\n        node.summarize(X, sample_weight=w)\n    return logps"
        ]
    },
    {
        "func_name": "from_summaries",
        "original": "def from_summaries(self):\n    \"\"\"Update the model parameters given the extracted statistics.\n\n\t\tThis method uses calculated statistics from calls to the `summarize`\n\t\tmethod to update the distribution parameters. Hyperparameters for the\n\t\tupdate are passed in at initialization time.\n\n\t\tNote: Internally, a call to `fit` is just a successive call to the\n\t\t`summarize` method followed by the `from_summaries` method.\n\t\t\"\"\"\n    for node in self.distributions:\n        node.from_summaries()\n    if self.frozen:\n        return\n    node_out_count = torch.clone(self._xw_ends_sum)\n    for (start, count) in zip(self._edge_idx_starts, self._xw_sum):\n        node_out_count[start] += count\n    ends = torch.log(self._xw_ends_sum / node_out_count)\n    starts = torch.log(self._xw_starts_sum / self._xw_starts_sum.sum())\n    _edge_log_probs = torch.empty_like(self._edge_log_probs)\n    for i in range(self.n_edges):\n        t = self._xw_sum[i]\n        t_sum = node_out_count[self._edge_idx_starts[i]]\n        _edge_log_probs[i] = torch.log(t / t_sum)\n    _update_parameter(self.ends, ends, inertia=self.inertia)\n    _update_parameter(self.starts, starts, inertia=self.inertia)\n    _update_parameter(self._edge_log_probs, _edge_log_probs, inertia=self.inertia)\n    self._reset_cache()",
        "mutated": [
            "def from_summaries(self):\n    if False:\n        i = 10\n    'Update the model parameters given the extracted statistics.\\n\\n\\t\\tThis method uses calculated statistics from calls to the `summarize`\\n\\t\\tmethod to update the distribution parameters. Hyperparameters for the\\n\\t\\tupdate are passed in at initialization time.\\n\\n\\t\\tNote: Internally, a call to `fit` is just a successive call to the\\n\\t\\t`summarize` method followed by the `from_summaries` method.\\n\\t\\t'\n    for node in self.distributions:\n        node.from_summaries()\n    if self.frozen:\n        return\n    node_out_count = torch.clone(self._xw_ends_sum)\n    for (start, count) in zip(self._edge_idx_starts, self._xw_sum):\n        node_out_count[start] += count\n    ends = torch.log(self._xw_ends_sum / node_out_count)\n    starts = torch.log(self._xw_starts_sum / self._xw_starts_sum.sum())\n    _edge_log_probs = torch.empty_like(self._edge_log_probs)\n    for i in range(self.n_edges):\n        t = self._xw_sum[i]\n        t_sum = node_out_count[self._edge_idx_starts[i]]\n        _edge_log_probs[i] = torch.log(t / t_sum)\n    _update_parameter(self.ends, ends, inertia=self.inertia)\n    _update_parameter(self.starts, starts, inertia=self.inertia)\n    _update_parameter(self._edge_log_probs, _edge_log_probs, inertia=self.inertia)\n    self._reset_cache()",
            "def from_summaries(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Update the model parameters given the extracted statistics.\\n\\n\\t\\tThis method uses calculated statistics from calls to the `summarize`\\n\\t\\tmethod to update the distribution parameters. Hyperparameters for the\\n\\t\\tupdate are passed in at initialization time.\\n\\n\\t\\tNote: Internally, a call to `fit` is just a successive call to the\\n\\t\\t`summarize` method followed by the `from_summaries` method.\\n\\t\\t'\n    for node in self.distributions:\n        node.from_summaries()\n    if self.frozen:\n        return\n    node_out_count = torch.clone(self._xw_ends_sum)\n    for (start, count) in zip(self._edge_idx_starts, self._xw_sum):\n        node_out_count[start] += count\n    ends = torch.log(self._xw_ends_sum / node_out_count)\n    starts = torch.log(self._xw_starts_sum / self._xw_starts_sum.sum())\n    _edge_log_probs = torch.empty_like(self._edge_log_probs)\n    for i in range(self.n_edges):\n        t = self._xw_sum[i]\n        t_sum = node_out_count[self._edge_idx_starts[i]]\n        _edge_log_probs[i] = torch.log(t / t_sum)\n    _update_parameter(self.ends, ends, inertia=self.inertia)\n    _update_parameter(self.starts, starts, inertia=self.inertia)\n    _update_parameter(self._edge_log_probs, _edge_log_probs, inertia=self.inertia)\n    self._reset_cache()",
            "def from_summaries(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Update the model parameters given the extracted statistics.\\n\\n\\t\\tThis method uses calculated statistics from calls to the `summarize`\\n\\t\\tmethod to update the distribution parameters. Hyperparameters for the\\n\\t\\tupdate are passed in at initialization time.\\n\\n\\t\\tNote: Internally, a call to `fit` is just a successive call to the\\n\\t\\t`summarize` method followed by the `from_summaries` method.\\n\\t\\t'\n    for node in self.distributions:\n        node.from_summaries()\n    if self.frozen:\n        return\n    node_out_count = torch.clone(self._xw_ends_sum)\n    for (start, count) in zip(self._edge_idx_starts, self._xw_sum):\n        node_out_count[start] += count\n    ends = torch.log(self._xw_ends_sum / node_out_count)\n    starts = torch.log(self._xw_starts_sum / self._xw_starts_sum.sum())\n    _edge_log_probs = torch.empty_like(self._edge_log_probs)\n    for i in range(self.n_edges):\n        t = self._xw_sum[i]\n        t_sum = node_out_count[self._edge_idx_starts[i]]\n        _edge_log_probs[i] = torch.log(t / t_sum)\n    _update_parameter(self.ends, ends, inertia=self.inertia)\n    _update_parameter(self.starts, starts, inertia=self.inertia)\n    _update_parameter(self._edge_log_probs, _edge_log_probs, inertia=self.inertia)\n    self._reset_cache()",
            "def from_summaries(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Update the model parameters given the extracted statistics.\\n\\n\\t\\tThis method uses calculated statistics from calls to the `summarize`\\n\\t\\tmethod to update the distribution parameters. Hyperparameters for the\\n\\t\\tupdate are passed in at initialization time.\\n\\n\\t\\tNote: Internally, a call to `fit` is just a successive call to the\\n\\t\\t`summarize` method followed by the `from_summaries` method.\\n\\t\\t'\n    for node in self.distributions:\n        node.from_summaries()\n    if self.frozen:\n        return\n    node_out_count = torch.clone(self._xw_ends_sum)\n    for (start, count) in zip(self._edge_idx_starts, self._xw_sum):\n        node_out_count[start] += count\n    ends = torch.log(self._xw_ends_sum / node_out_count)\n    starts = torch.log(self._xw_starts_sum / self._xw_starts_sum.sum())\n    _edge_log_probs = torch.empty_like(self._edge_log_probs)\n    for i in range(self.n_edges):\n        t = self._xw_sum[i]\n        t_sum = node_out_count[self._edge_idx_starts[i]]\n        _edge_log_probs[i] = torch.log(t / t_sum)\n    _update_parameter(self.ends, ends, inertia=self.inertia)\n    _update_parameter(self.starts, starts, inertia=self.inertia)\n    _update_parameter(self._edge_log_probs, _edge_log_probs, inertia=self.inertia)\n    self._reset_cache()",
            "def from_summaries(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Update the model parameters given the extracted statistics.\\n\\n\\t\\tThis method uses calculated statistics from calls to the `summarize`\\n\\t\\tmethod to update the distribution parameters. Hyperparameters for the\\n\\t\\tupdate are passed in at initialization time.\\n\\n\\t\\tNote: Internally, a call to `fit` is just a successive call to the\\n\\t\\t`summarize` method followed by the `from_summaries` method.\\n\\t\\t'\n    for node in self.distributions:\n        node.from_summaries()\n    if self.frozen:\n        return\n    node_out_count = torch.clone(self._xw_ends_sum)\n    for (start, count) in zip(self._edge_idx_starts, self._xw_sum):\n        node_out_count[start] += count\n    ends = torch.log(self._xw_ends_sum / node_out_count)\n    starts = torch.log(self._xw_starts_sum / self._xw_starts_sum.sum())\n    _edge_log_probs = torch.empty_like(self._edge_log_probs)\n    for i in range(self.n_edges):\n        t = self._xw_sum[i]\n        t_sum = node_out_count[self._edge_idx_starts[i]]\n        _edge_log_probs[i] = torch.log(t / t_sum)\n    _update_parameter(self.ends, ends, inertia=self.inertia)\n    _update_parameter(self.starts, starts, inertia=self.inertia)\n    _update_parameter(self._edge_log_probs, _edge_log_probs, inertia=self.inertia)\n    self._reset_cache()"
        ]
    }
]