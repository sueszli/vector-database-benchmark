[
    {
        "func_name": "assign",
        "original": "def assign(self, bboxes, gt_bboxes, gt_bboxes_ignore=None, gt_labels=None):\n    \"\"\"Assign boxes to either a ground truth boxes or a negative boxes.\"\"\"",
        "mutated": [
            "def assign(self, bboxes, gt_bboxes, gt_bboxes_ignore=None, gt_labels=None):\n    if False:\n        i = 10\n    'Assign boxes to either a ground truth boxes or a negative boxes.'",
            "def assign(self, bboxes, gt_bboxes, gt_bboxes_ignore=None, gt_labels=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Assign boxes to either a ground truth boxes or a negative boxes.'",
            "def assign(self, bboxes, gt_bboxes, gt_bboxes_ignore=None, gt_labels=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Assign boxes to either a ground truth boxes or a negative boxes.'",
            "def assign(self, bboxes, gt_bboxes, gt_bboxes_ignore=None, gt_labels=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Assign boxes to either a ground truth boxes or a negative boxes.'",
            "def assign(self, bboxes, gt_bboxes, gt_bboxes_ignore=None, gt_labels=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Assign boxes to either a ground truth boxes or a negative boxes.'"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, num_gts, gt_inds, max_overlaps, labels=None):\n    self.num_gts = num_gts\n    self.gt_inds = gt_inds\n    self.max_overlaps = max_overlaps\n    self.labels = labels\n    self._extra_properties = {}",
        "mutated": [
            "def __init__(self, num_gts, gt_inds, max_overlaps, labels=None):\n    if False:\n        i = 10\n    self.num_gts = num_gts\n    self.gt_inds = gt_inds\n    self.max_overlaps = max_overlaps\n    self.labels = labels\n    self._extra_properties = {}",
            "def __init__(self, num_gts, gt_inds, max_overlaps, labels=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.num_gts = num_gts\n    self.gt_inds = gt_inds\n    self.max_overlaps = max_overlaps\n    self.labels = labels\n    self._extra_properties = {}",
            "def __init__(self, num_gts, gt_inds, max_overlaps, labels=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.num_gts = num_gts\n    self.gt_inds = gt_inds\n    self.max_overlaps = max_overlaps\n    self.labels = labels\n    self._extra_properties = {}",
            "def __init__(self, num_gts, gt_inds, max_overlaps, labels=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.num_gts = num_gts\n    self.gt_inds = gt_inds\n    self.max_overlaps = max_overlaps\n    self.labels = labels\n    self._extra_properties = {}",
            "def __init__(self, num_gts, gt_inds, max_overlaps, labels=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.num_gts = num_gts\n    self.gt_inds = gt_inds\n    self.max_overlaps = max_overlaps\n    self.labels = labels\n    self._extra_properties = {}"
        ]
    },
    {
        "func_name": "num_preds",
        "original": "@property\ndef num_preds(self):\n    \"\"\"int: the number of predictions in this assignment\"\"\"\n    return len(self.gt_inds)",
        "mutated": [
            "@property\ndef num_preds(self):\n    if False:\n        i = 10\n    'int: the number of predictions in this assignment'\n    return len(self.gt_inds)",
            "@property\ndef num_preds(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'int: the number of predictions in this assignment'\n    return len(self.gt_inds)",
            "@property\ndef num_preds(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'int: the number of predictions in this assignment'\n    return len(self.gt_inds)",
            "@property\ndef num_preds(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'int: the number of predictions in this assignment'\n    return len(self.gt_inds)",
            "@property\ndef num_preds(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'int: the number of predictions in this assignment'\n    return len(self.gt_inds)"
        ]
    },
    {
        "func_name": "set_extra_property",
        "original": "def set_extra_property(self, key, value):\n    \"\"\"Set user-defined new property.\"\"\"\n    assert key not in self.info\n    self._extra_properties[key] = value",
        "mutated": [
            "def set_extra_property(self, key, value):\n    if False:\n        i = 10\n    'Set user-defined new property.'\n    assert key not in self.info\n    self._extra_properties[key] = value",
            "def set_extra_property(self, key, value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Set user-defined new property.'\n    assert key not in self.info\n    self._extra_properties[key] = value",
            "def set_extra_property(self, key, value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Set user-defined new property.'\n    assert key not in self.info\n    self._extra_properties[key] = value",
            "def set_extra_property(self, key, value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Set user-defined new property.'\n    assert key not in self.info\n    self._extra_properties[key] = value",
            "def set_extra_property(self, key, value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Set user-defined new property.'\n    assert key not in self.info\n    self._extra_properties[key] = value"
        ]
    },
    {
        "func_name": "get_extra_property",
        "original": "def get_extra_property(self, key):\n    \"\"\"Get user-defined property.\"\"\"\n    return self._extra_properties.get(key, None)",
        "mutated": [
            "def get_extra_property(self, key):\n    if False:\n        i = 10\n    'Get user-defined property.'\n    return self._extra_properties.get(key, None)",
            "def get_extra_property(self, key):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Get user-defined property.'\n    return self._extra_properties.get(key, None)",
            "def get_extra_property(self, key):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Get user-defined property.'\n    return self._extra_properties.get(key, None)",
            "def get_extra_property(self, key):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Get user-defined property.'\n    return self._extra_properties.get(key, None)",
            "def get_extra_property(self, key):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Get user-defined property.'\n    return self._extra_properties.get(key, None)"
        ]
    },
    {
        "func_name": "info",
        "original": "@property\ndef info(self):\n    \"\"\"dict: a dictionary of info about the object\"\"\"\n    basic_info = {'num_gts': self.num_gts, 'num_preds': self.num_preds, 'gt_inds': self.gt_inds, 'max_overlaps': self.max_overlaps, 'labels': self.labels}\n    basic_info.update(self._extra_properties)\n    return basic_info",
        "mutated": [
            "@property\ndef info(self):\n    if False:\n        i = 10\n    'dict: a dictionary of info about the object'\n    basic_info = {'num_gts': self.num_gts, 'num_preds': self.num_preds, 'gt_inds': self.gt_inds, 'max_overlaps': self.max_overlaps, 'labels': self.labels}\n    basic_info.update(self._extra_properties)\n    return basic_info",
            "@property\ndef info(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'dict: a dictionary of info about the object'\n    basic_info = {'num_gts': self.num_gts, 'num_preds': self.num_preds, 'gt_inds': self.gt_inds, 'max_overlaps': self.max_overlaps, 'labels': self.labels}\n    basic_info.update(self._extra_properties)\n    return basic_info",
            "@property\ndef info(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'dict: a dictionary of info about the object'\n    basic_info = {'num_gts': self.num_gts, 'num_preds': self.num_preds, 'gt_inds': self.gt_inds, 'max_overlaps': self.max_overlaps, 'labels': self.labels}\n    basic_info.update(self._extra_properties)\n    return basic_info",
            "@property\ndef info(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'dict: a dictionary of info about the object'\n    basic_info = {'num_gts': self.num_gts, 'num_preds': self.num_preds, 'gt_inds': self.gt_inds, 'max_overlaps': self.max_overlaps, 'labels': self.labels}\n    basic_info.update(self._extra_properties)\n    return basic_info",
            "@property\ndef info(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'dict: a dictionary of info about the object'\n    basic_info = {'num_gts': self.num_gts, 'num_preds': self.num_preds, 'gt_inds': self.gt_inds, 'max_overlaps': self.max_overlaps, 'labels': self.labels}\n    basic_info.update(self._extra_properties)\n    return basic_info"
        ]
    },
    {
        "func_name": "random",
        "original": "@classmethod\ndef random(cls, **kwargs):\n    \"\"\"Create random AssignResult for tests or debugging.\n        Args:\n            num_preds: number of predicted boxes\n            num_gts: number of true boxes\n            p_ignore (float): probability of a predicted box assinged to an\n                ignored truth\n            p_assigned (float): probability of a predicted box not being\n                assigned\n            p_use_label (float | bool): with labels or not\n            rng (None | int | numpy.random.RandomState): seed or state\n        Returns:\n            :obj:`AssignResult`: Randomly generated assign results.\n        Example:\n            >>> from mmdet.core.bbox.assigners.assign_result import *  # NOQA\n            >>> self = AssignResult.random()\n            >>> print(self.info)\n        \"\"\"\n    from mmdet.core.bbox import demodata\n    rng = demodata.ensure_rng(kwargs.get('rng', None))\n    num_gts = kwargs.get('num_gts', None)\n    num_preds = kwargs.get('num_preds', None)\n    p_ignore = kwargs.get('p_ignore', 0.3)\n    p_assigned = kwargs.get('p_assigned', 0.7)\n    p_use_label = kwargs.get('p_use_label', 0.5)\n    num_classes = kwargs.get('p_use_label', 3)\n    if num_gts is None:\n        num_gts = rng.randint(0, 8)\n    if num_preds is None:\n        num_preds = rng.randint(0, 16)\n    if num_gts == 0:\n        max_overlaps = torch.zeros(num_preds, dtype=torch.float32)\n        gt_inds = torch.zeros(num_preds, dtype=torch.int64)\n        if p_use_label is True or p_use_label < rng.rand():\n            labels = torch.zeros(num_preds, dtype=torch.int64)\n        else:\n            labels = None\n    else:\n        import numpy as np\n        max_overlaps = torch.from_numpy(rng.rand(num_preds))\n        is_assigned = torch.from_numpy(rng.rand(num_preds) < p_assigned)\n        n_assigned = min(num_preds, min(num_gts, is_assigned.sum()))\n        assigned_idxs = np.where(is_assigned)[0]\n        rng.shuffle(assigned_idxs)\n        assigned_idxs = assigned_idxs[0:n_assigned]\n        assigned_idxs.sort()\n        is_assigned[:] = 0\n        is_assigned[assigned_idxs] = True\n        is_ignore = torch.from_numpy(rng.rand(num_preds) < p_ignore) & is_assigned\n        gt_inds = torch.zeros(num_preds, dtype=torch.int64)\n        true_idxs = np.arange(num_gts)\n        rng.shuffle(true_idxs)\n        true_idxs = torch.from_numpy(true_idxs)\n        gt_inds[is_assigned] = true_idxs[:n_assigned]\n        gt_inds = torch.from_numpy(rng.randint(1, num_gts + 1, size=num_preds))\n        gt_inds[is_ignore] = -1\n        gt_inds[~is_assigned] = 0\n        max_overlaps[~is_assigned] = 0\n        if p_use_label is True or p_use_label < rng.rand():\n            if num_classes == 0:\n                labels = torch.zeros(num_preds, dtype=torch.int64)\n            else:\n                labels = torch.from_numpy(rng.randint(0, num_classes, size=num_preds))\n                labels[~is_assigned] = 0\n        else:\n            labels = None\n    self = cls(num_gts, gt_inds, max_overlaps, labels)\n    return self",
        "mutated": [
            "@classmethod\ndef random(cls, **kwargs):\n    if False:\n        i = 10\n    'Create random AssignResult for tests or debugging.\\n        Args:\\n            num_preds: number of predicted boxes\\n            num_gts: number of true boxes\\n            p_ignore (float): probability of a predicted box assinged to an\\n                ignored truth\\n            p_assigned (float): probability of a predicted box not being\\n                assigned\\n            p_use_label (float | bool): with labels or not\\n            rng (None | int | numpy.random.RandomState): seed or state\\n        Returns:\\n            :obj:`AssignResult`: Randomly generated assign results.\\n        Example:\\n            >>> from mmdet.core.bbox.assigners.assign_result import *  # NOQA\\n            >>> self = AssignResult.random()\\n            >>> print(self.info)\\n        '\n    from mmdet.core.bbox import demodata\n    rng = demodata.ensure_rng(kwargs.get('rng', None))\n    num_gts = kwargs.get('num_gts', None)\n    num_preds = kwargs.get('num_preds', None)\n    p_ignore = kwargs.get('p_ignore', 0.3)\n    p_assigned = kwargs.get('p_assigned', 0.7)\n    p_use_label = kwargs.get('p_use_label', 0.5)\n    num_classes = kwargs.get('p_use_label', 3)\n    if num_gts is None:\n        num_gts = rng.randint(0, 8)\n    if num_preds is None:\n        num_preds = rng.randint(0, 16)\n    if num_gts == 0:\n        max_overlaps = torch.zeros(num_preds, dtype=torch.float32)\n        gt_inds = torch.zeros(num_preds, dtype=torch.int64)\n        if p_use_label is True or p_use_label < rng.rand():\n            labels = torch.zeros(num_preds, dtype=torch.int64)\n        else:\n            labels = None\n    else:\n        import numpy as np\n        max_overlaps = torch.from_numpy(rng.rand(num_preds))\n        is_assigned = torch.from_numpy(rng.rand(num_preds) < p_assigned)\n        n_assigned = min(num_preds, min(num_gts, is_assigned.sum()))\n        assigned_idxs = np.where(is_assigned)[0]\n        rng.shuffle(assigned_idxs)\n        assigned_idxs = assigned_idxs[0:n_assigned]\n        assigned_idxs.sort()\n        is_assigned[:] = 0\n        is_assigned[assigned_idxs] = True\n        is_ignore = torch.from_numpy(rng.rand(num_preds) < p_ignore) & is_assigned\n        gt_inds = torch.zeros(num_preds, dtype=torch.int64)\n        true_idxs = np.arange(num_gts)\n        rng.shuffle(true_idxs)\n        true_idxs = torch.from_numpy(true_idxs)\n        gt_inds[is_assigned] = true_idxs[:n_assigned]\n        gt_inds = torch.from_numpy(rng.randint(1, num_gts + 1, size=num_preds))\n        gt_inds[is_ignore] = -1\n        gt_inds[~is_assigned] = 0\n        max_overlaps[~is_assigned] = 0\n        if p_use_label is True or p_use_label < rng.rand():\n            if num_classes == 0:\n                labels = torch.zeros(num_preds, dtype=torch.int64)\n            else:\n                labels = torch.from_numpy(rng.randint(0, num_classes, size=num_preds))\n                labels[~is_assigned] = 0\n        else:\n            labels = None\n    self = cls(num_gts, gt_inds, max_overlaps, labels)\n    return self",
            "@classmethod\ndef random(cls, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Create random AssignResult for tests or debugging.\\n        Args:\\n            num_preds: number of predicted boxes\\n            num_gts: number of true boxes\\n            p_ignore (float): probability of a predicted box assinged to an\\n                ignored truth\\n            p_assigned (float): probability of a predicted box not being\\n                assigned\\n            p_use_label (float | bool): with labels or not\\n            rng (None | int | numpy.random.RandomState): seed or state\\n        Returns:\\n            :obj:`AssignResult`: Randomly generated assign results.\\n        Example:\\n            >>> from mmdet.core.bbox.assigners.assign_result import *  # NOQA\\n            >>> self = AssignResult.random()\\n            >>> print(self.info)\\n        '\n    from mmdet.core.bbox import demodata\n    rng = demodata.ensure_rng(kwargs.get('rng', None))\n    num_gts = kwargs.get('num_gts', None)\n    num_preds = kwargs.get('num_preds', None)\n    p_ignore = kwargs.get('p_ignore', 0.3)\n    p_assigned = kwargs.get('p_assigned', 0.7)\n    p_use_label = kwargs.get('p_use_label', 0.5)\n    num_classes = kwargs.get('p_use_label', 3)\n    if num_gts is None:\n        num_gts = rng.randint(0, 8)\n    if num_preds is None:\n        num_preds = rng.randint(0, 16)\n    if num_gts == 0:\n        max_overlaps = torch.zeros(num_preds, dtype=torch.float32)\n        gt_inds = torch.zeros(num_preds, dtype=torch.int64)\n        if p_use_label is True or p_use_label < rng.rand():\n            labels = torch.zeros(num_preds, dtype=torch.int64)\n        else:\n            labels = None\n    else:\n        import numpy as np\n        max_overlaps = torch.from_numpy(rng.rand(num_preds))\n        is_assigned = torch.from_numpy(rng.rand(num_preds) < p_assigned)\n        n_assigned = min(num_preds, min(num_gts, is_assigned.sum()))\n        assigned_idxs = np.where(is_assigned)[0]\n        rng.shuffle(assigned_idxs)\n        assigned_idxs = assigned_idxs[0:n_assigned]\n        assigned_idxs.sort()\n        is_assigned[:] = 0\n        is_assigned[assigned_idxs] = True\n        is_ignore = torch.from_numpy(rng.rand(num_preds) < p_ignore) & is_assigned\n        gt_inds = torch.zeros(num_preds, dtype=torch.int64)\n        true_idxs = np.arange(num_gts)\n        rng.shuffle(true_idxs)\n        true_idxs = torch.from_numpy(true_idxs)\n        gt_inds[is_assigned] = true_idxs[:n_assigned]\n        gt_inds = torch.from_numpy(rng.randint(1, num_gts + 1, size=num_preds))\n        gt_inds[is_ignore] = -1\n        gt_inds[~is_assigned] = 0\n        max_overlaps[~is_assigned] = 0\n        if p_use_label is True or p_use_label < rng.rand():\n            if num_classes == 0:\n                labels = torch.zeros(num_preds, dtype=torch.int64)\n            else:\n                labels = torch.from_numpy(rng.randint(0, num_classes, size=num_preds))\n                labels[~is_assigned] = 0\n        else:\n            labels = None\n    self = cls(num_gts, gt_inds, max_overlaps, labels)\n    return self",
            "@classmethod\ndef random(cls, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Create random AssignResult for tests or debugging.\\n        Args:\\n            num_preds: number of predicted boxes\\n            num_gts: number of true boxes\\n            p_ignore (float): probability of a predicted box assinged to an\\n                ignored truth\\n            p_assigned (float): probability of a predicted box not being\\n                assigned\\n            p_use_label (float | bool): with labels or not\\n            rng (None | int | numpy.random.RandomState): seed or state\\n        Returns:\\n            :obj:`AssignResult`: Randomly generated assign results.\\n        Example:\\n            >>> from mmdet.core.bbox.assigners.assign_result import *  # NOQA\\n            >>> self = AssignResult.random()\\n            >>> print(self.info)\\n        '\n    from mmdet.core.bbox import demodata\n    rng = demodata.ensure_rng(kwargs.get('rng', None))\n    num_gts = kwargs.get('num_gts', None)\n    num_preds = kwargs.get('num_preds', None)\n    p_ignore = kwargs.get('p_ignore', 0.3)\n    p_assigned = kwargs.get('p_assigned', 0.7)\n    p_use_label = kwargs.get('p_use_label', 0.5)\n    num_classes = kwargs.get('p_use_label', 3)\n    if num_gts is None:\n        num_gts = rng.randint(0, 8)\n    if num_preds is None:\n        num_preds = rng.randint(0, 16)\n    if num_gts == 0:\n        max_overlaps = torch.zeros(num_preds, dtype=torch.float32)\n        gt_inds = torch.zeros(num_preds, dtype=torch.int64)\n        if p_use_label is True or p_use_label < rng.rand():\n            labels = torch.zeros(num_preds, dtype=torch.int64)\n        else:\n            labels = None\n    else:\n        import numpy as np\n        max_overlaps = torch.from_numpy(rng.rand(num_preds))\n        is_assigned = torch.from_numpy(rng.rand(num_preds) < p_assigned)\n        n_assigned = min(num_preds, min(num_gts, is_assigned.sum()))\n        assigned_idxs = np.where(is_assigned)[0]\n        rng.shuffle(assigned_idxs)\n        assigned_idxs = assigned_idxs[0:n_assigned]\n        assigned_idxs.sort()\n        is_assigned[:] = 0\n        is_assigned[assigned_idxs] = True\n        is_ignore = torch.from_numpy(rng.rand(num_preds) < p_ignore) & is_assigned\n        gt_inds = torch.zeros(num_preds, dtype=torch.int64)\n        true_idxs = np.arange(num_gts)\n        rng.shuffle(true_idxs)\n        true_idxs = torch.from_numpy(true_idxs)\n        gt_inds[is_assigned] = true_idxs[:n_assigned]\n        gt_inds = torch.from_numpy(rng.randint(1, num_gts + 1, size=num_preds))\n        gt_inds[is_ignore] = -1\n        gt_inds[~is_assigned] = 0\n        max_overlaps[~is_assigned] = 0\n        if p_use_label is True or p_use_label < rng.rand():\n            if num_classes == 0:\n                labels = torch.zeros(num_preds, dtype=torch.int64)\n            else:\n                labels = torch.from_numpy(rng.randint(0, num_classes, size=num_preds))\n                labels[~is_assigned] = 0\n        else:\n            labels = None\n    self = cls(num_gts, gt_inds, max_overlaps, labels)\n    return self",
            "@classmethod\ndef random(cls, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Create random AssignResult for tests or debugging.\\n        Args:\\n            num_preds: number of predicted boxes\\n            num_gts: number of true boxes\\n            p_ignore (float): probability of a predicted box assinged to an\\n                ignored truth\\n            p_assigned (float): probability of a predicted box not being\\n                assigned\\n            p_use_label (float | bool): with labels or not\\n            rng (None | int | numpy.random.RandomState): seed or state\\n        Returns:\\n            :obj:`AssignResult`: Randomly generated assign results.\\n        Example:\\n            >>> from mmdet.core.bbox.assigners.assign_result import *  # NOQA\\n            >>> self = AssignResult.random()\\n            >>> print(self.info)\\n        '\n    from mmdet.core.bbox import demodata\n    rng = demodata.ensure_rng(kwargs.get('rng', None))\n    num_gts = kwargs.get('num_gts', None)\n    num_preds = kwargs.get('num_preds', None)\n    p_ignore = kwargs.get('p_ignore', 0.3)\n    p_assigned = kwargs.get('p_assigned', 0.7)\n    p_use_label = kwargs.get('p_use_label', 0.5)\n    num_classes = kwargs.get('p_use_label', 3)\n    if num_gts is None:\n        num_gts = rng.randint(0, 8)\n    if num_preds is None:\n        num_preds = rng.randint(0, 16)\n    if num_gts == 0:\n        max_overlaps = torch.zeros(num_preds, dtype=torch.float32)\n        gt_inds = torch.zeros(num_preds, dtype=torch.int64)\n        if p_use_label is True or p_use_label < rng.rand():\n            labels = torch.zeros(num_preds, dtype=torch.int64)\n        else:\n            labels = None\n    else:\n        import numpy as np\n        max_overlaps = torch.from_numpy(rng.rand(num_preds))\n        is_assigned = torch.from_numpy(rng.rand(num_preds) < p_assigned)\n        n_assigned = min(num_preds, min(num_gts, is_assigned.sum()))\n        assigned_idxs = np.where(is_assigned)[0]\n        rng.shuffle(assigned_idxs)\n        assigned_idxs = assigned_idxs[0:n_assigned]\n        assigned_idxs.sort()\n        is_assigned[:] = 0\n        is_assigned[assigned_idxs] = True\n        is_ignore = torch.from_numpy(rng.rand(num_preds) < p_ignore) & is_assigned\n        gt_inds = torch.zeros(num_preds, dtype=torch.int64)\n        true_idxs = np.arange(num_gts)\n        rng.shuffle(true_idxs)\n        true_idxs = torch.from_numpy(true_idxs)\n        gt_inds[is_assigned] = true_idxs[:n_assigned]\n        gt_inds = torch.from_numpy(rng.randint(1, num_gts + 1, size=num_preds))\n        gt_inds[is_ignore] = -1\n        gt_inds[~is_assigned] = 0\n        max_overlaps[~is_assigned] = 0\n        if p_use_label is True or p_use_label < rng.rand():\n            if num_classes == 0:\n                labels = torch.zeros(num_preds, dtype=torch.int64)\n            else:\n                labels = torch.from_numpy(rng.randint(0, num_classes, size=num_preds))\n                labels[~is_assigned] = 0\n        else:\n            labels = None\n    self = cls(num_gts, gt_inds, max_overlaps, labels)\n    return self",
            "@classmethod\ndef random(cls, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Create random AssignResult for tests or debugging.\\n        Args:\\n            num_preds: number of predicted boxes\\n            num_gts: number of true boxes\\n            p_ignore (float): probability of a predicted box assinged to an\\n                ignored truth\\n            p_assigned (float): probability of a predicted box not being\\n                assigned\\n            p_use_label (float | bool): with labels or not\\n            rng (None | int | numpy.random.RandomState): seed or state\\n        Returns:\\n            :obj:`AssignResult`: Randomly generated assign results.\\n        Example:\\n            >>> from mmdet.core.bbox.assigners.assign_result import *  # NOQA\\n            >>> self = AssignResult.random()\\n            >>> print(self.info)\\n        '\n    from mmdet.core.bbox import demodata\n    rng = demodata.ensure_rng(kwargs.get('rng', None))\n    num_gts = kwargs.get('num_gts', None)\n    num_preds = kwargs.get('num_preds', None)\n    p_ignore = kwargs.get('p_ignore', 0.3)\n    p_assigned = kwargs.get('p_assigned', 0.7)\n    p_use_label = kwargs.get('p_use_label', 0.5)\n    num_classes = kwargs.get('p_use_label', 3)\n    if num_gts is None:\n        num_gts = rng.randint(0, 8)\n    if num_preds is None:\n        num_preds = rng.randint(0, 16)\n    if num_gts == 0:\n        max_overlaps = torch.zeros(num_preds, dtype=torch.float32)\n        gt_inds = torch.zeros(num_preds, dtype=torch.int64)\n        if p_use_label is True or p_use_label < rng.rand():\n            labels = torch.zeros(num_preds, dtype=torch.int64)\n        else:\n            labels = None\n    else:\n        import numpy as np\n        max_overlaps = torch.from_numpy(rng.rand(num_preds))\n        is_assigned = torch.from_numpy(rng.rand(num_preds) < p_assigned)\n        n_assigned = min(num_preds, min(num_gts, is_assigned.sum()))\n        assigned_idxs = np.where(is_assigned)[0]\n        rng.shuffle(assigned_idxs)\n        assigned_idxs = assigned_idxs[0:n_assigned]\n        assigned_idxs.sort()\n        is_assigned[:] = 0\n        is_assigned[assigned_idxs] = True\n        is_ignore = torch.from_numpy(rng.rand(num_preds) < p_ignore) & is_assigned\n        gt_inds = torch.zeros(num_preds, dtype=torch.int64)\n        true_idxs = np.arange(num_gts)\n        rng.shuffle(true_idxs)\n        true_idxs = torch.from_numpy(true_idxs)\n        gt_inds[is_assigned] = true_idxs[:n_assigned]\n        gt_inds = torch.from_numpy(rng.randint(1, num_gts + 1, size=num_preds))\n        gt_inds[is_ignore] = -1\n        gt_inds[~is_assigned] = 0\n        max_overlaps[~is_assigned] = 0\n        if p_use_label is True or p_use_label < rng.rand():\n            if num_classes == 0:\n                labels = torch.zeros(num_preds, dtype=torch.int64)\n            else:\n                labels = torch.from_numpy(rng.randint(0, num_classes, size=num_preds))\n                labels[~is_assigned] = 0\n        else:\n            labels = None\n    self = cls(num_gts, gt_inds, max_overlaps, labels)\n    return self"
        ]
    },
    {
        "func_name": "add_gt_",
        "original": "def add_gt_(self, gt_labels):\n    \"\"\"Add ground truth as assigned results.\n        Args:\n            gt_labels (torch.Tensor): Labels of gt boxes\n        \"\"\"\n    self_inds = torch.arange(1, len(gt_labels) + 1, dtype=torch.long, device=gt_labels.device)\n    self.gt_inds = torch.cat([self_inds, self.gt_inds])\n    self.max_overlaps = torch.cat([self.max_overlaps.new_ones(len(gt_labels)), self.max_overlaps])\n    if self.labels is not None:\n        self.labels = torch.cat([gt_labels, self.labels])",
        "mutated": [
            "def add_gt_(self, gt_labels):\n    if False:\n        i = 10\n    'Add ground truth as assigned results.\\n        Args:\\n            gt_labels (torch.Tensor): Labels of gt boxes\\n        '\n    self_inds = torch.arange(1, len(gt_labels) + 1, dtype=torch.long, device=gt_labels.device)\n    self.gt_inds = torch.cat([self_inds, self.gt_inds])\n    self.max_overlaps = torch.cat([self.max_overlaps.new_ones(len(gt_labels)), self.max_overlaps])\n    if self.labels is not None:\n        self.labels = torch.cat([gt_labels, self.labels])",
            "def add_gt_(self, gt_labels):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Add ground truth as assigned results.\\n        Args:\\n            gt_labels (torch.Tensor): Labels of gt boxes\\n        '\n    self_inds = torch.arange(1, len(gt_labels) + 1, dtype=torch.long, device=gt_labels.device)\n    self.gt_inds = torch.cat([self_inds, self.gt_inds])\n    self.max_overlaps = torch.cat([self.max_overlaps.new_ones(len(gt_labels)), self.max_overlaps])\n    if self.labels is not None:\n        self.labels = torch.cat([gt_labels, self.labels])",
            "def add_gt_(self, gt_labels):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Add ground truth as assigned results.\\n        Args:\\n            gt_labels (torch.Tensor): Labels of gt boxes\\n        '\n    self_inds = torch.arange(1, len(gt_labels) + 1, dtype=torch.long, device=gt_labels.device)\n    self.gt_inds = torch.cat([self_inds, self.gt_inds])\n    self.max_overlaps = torch.cat([self.max_overlaps.new_ones(len(gt_labels)), self.max_overlaps])\n    if self.labels is not None:\n        self.labels = torch.cat([gt_labels, self.labels])",
            "def add_gt_(self, gt_labels):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Add ground truth as assigned results.\\n        Args:\\n            gt_labels (torch.Tensor): Labels of gt boxes\\n        '\n    self_inds = torch.arange(1, len(gt_labels) + 1, dtype=torch.long, device=gt_labels.device)\n    self.gt_inds = torch.cat([self_inds, self.gt_inds])\n    self.max_overlaps = torch.cat([self.max_overlaps.new_ones(len(gt_labels)), self.max_overlaps])\n    if self.labels is not None:\n        self.labels = torch.cat([gt_labels, self.labels])",
            "def add_gt_(self, gt_labels):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Add ground truth as assigned results.\\n        Args:\\n            gt_labels (torch.Tensor): Labels of gt boxes\\n        '\n    self_inds = torch.arange(1, len(gt_labels) + 1, dtype=torch.long, device=gt_labels.device)\n    self.gt_inds = torch.cat([self_inds, self.gt_inds])\n    self.max_overlaps = torch.cat([self.max_overlaps.new_ones(len(gt_labels)), self.max_overlaps])\n    if self.labels is not None:\n        self.labels = torch.cat([gt_labels, self.labels])"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, center_radius=2.5, candidate_topk=10, iou_weight=3.0, cls_weight=1.0):\n    self.center_radius = center_radius\n    self.candidate_topk = candidate_topk\n    self.iou_weight = iou_weight\n    self.cls_weight = cls_weight",
        "mutated": [
            "def __init__(self, center_radius=2.5, candidate_topk=10, iou_weight=3.0, cls_weight=1.0):\n    if False:\n        i = 10\n    self.center_radius = center_radius\n    self.candidate_topk = candidate_topk\n    self.iou_weight = iou_weight\n    self.cls_weight = cls_weight",
            "def __init__(self, center_radius=2.5, candidate_topk=10, iou_weight=3.0, cls_weight=1.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.center_radius = center_radius\n    self.candidate_topk = candidate_topk\n    self.iou_weight = iou_weight\n    self.cls_weight = cls_weight",
            "def __init__(self, center_radius=2.5, candidate_topk=10, iou_weight=3.0, cls_weight=1.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.center_radius = center_radius\n    self.candidate_topk = candidate_topk\n    self.iou_weight = iou_weight\n    self.cls_weight = cls_weight",
            "def __init__(self, center_radius=2.5, candidate_topk=10, iou_weight=3.0, cls_weight=1.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.center_radius = center_radius\n    self.candidate_topk = candidate_topk\n    self.iou_weight = iou_weight\n    self.cls_weight = cls_weight",
            "def __init__(self, center_radius=2.5, candidate_topk=10, iou_weight=3.0, cls_weight=1.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.center_radius = center_radius\n    self.candidate_topk = candidate_topk\n    self.iou_weight = iou_weight\n    self.cls_weight = cls_weight"
        ]
    },
    {
        "func_name": "assign",
        "original": "def assign(self, pred_scores, priors, decoded_bboxes, gt_bboxes, gt_labels, gt_bboxes_ignore=None, eps=1e-07):\n    \"\"\"Assign gt to priors using SimOTA. It will switch to CPU mode when\n        GPU is out of memory.\n        Args:\n            pred_scores (Tensor): Classification scores of one image,\n                a 2D-Tensor with shape [num_priors, num_classes]\n            priors (Tensor): All priors of one image, a 2D-Tensor with shape\n                [num_priors, 4] in [cx, xy, stride_w, stride_y] format.\n            decoded_bboxes (Tensor): Predicted bboxes, a 2D-Tensor with shape\n                [num_priors, 4] in [tl_x, tl_y, br_x, br_y] format.\n            gt_bboxes (Tensor): Ground truth bboxes of one image, a 2D-Tensor\n                with shape [num_gts, 4] in [tl_x, tl_y, br_x, br_y] format.\n            gt_labels (Tensor): Ground truth labels of one image, a Tensor\n                with shape [num_gts].\n            gt_bboxes_ignore (Tensor, optional): Ground truth bboxes that are\n                labelled as `ignored`, e.g., crowd boxes in COCO.\n            eps (float): A value added to the denominator for numerical\n                stability. Default 1e-7.\n        Returns:\n            assign_result (obj:`AssignResult`): The assigned result.\n        \"\"\"\n    try:\n        assign_result = self._assign(pred_scores, priors, decoded_bboxes, gt_bboxes, gt_labels, gt_bboxes_ignore, eps)\n        return assign_result\n    except RuntimeError:\n        origin_device = pred_scores.device\n        warnings.warn('OOM RuntimeError is raised due to the huge memory cost during label assignment. CPU mode is applied in this batch. If you want to avoid this issue, try to reduce the batch size or image size.')\n        torch.cuda.empty_cache()\n        pred_scores = pred_scores.cpu()\n        priors = priors.cpu()\n        decoded_bboxes = decoded_bboxes.cpu()\n        gt_bboxes = gt_bboxes.cpu().float()\n        gt_labels = gt_labels.cpu()\n        assign_result = self._assign(pred_scores, priors, decoded_bboxes, gt_bboxes, gt_labels, gt_bboxes_ignore, eps)\n        assign_result.gt_inds = assign_result.gt_inds.to(origin_device)\n        assign_result.max_overlaps = assign_result.max_overlaps.to(origin_device)\n        assign_result.labels = assign_result.labels.to(origin_device)\n        return assign_result",
        "mutated": [
            "def assign(self, pred_scores, priors, decoded_bboxes, gt_bboxes, gt_labels, gt_bboxes_ignore=None, eps=1e-07):\n    if False:\n        i = 10\n    'Assign gt to priors using SimOTA. It will switch to CPU mode when\\n        GPU is out of memory.\\n        Args:\\n            pred_scores (Tensor): Classification scores of one image,\\n                a 2D-Tensor with shape [num_priors, num_classes]\\n            priors (Tensor): All priors of one image, a 2D-Tensor with shape\\n                [num_priors, 4] in [cx, xy, stride_w, stride_y] format.\\n            decoded_bboxes (Tensor): Predicted bboxes, a 2D-Tensor with shape\\n                [num_priors, 4] in [tl_x, tl_y, br_x, br_y] format.\\n            gt_bboxes (Tensor): Ground truth bboxes of one image, a 2D-Tensor\\n                with shape [num_gts, 4] in [tl_x, tl_y, br_x, br_y] format.\\n            gt_labels (Tensor): Ground truth labels of one image, a Tensor\\n                with shape [num_gts].\\n            gt_bboxes_ignore (Tensor, optional): Ground truth bboxes that are\\n                labelled as `ignored`, e.g., crowd boxes in COCO.\\n            eps (float): A value added to the denominator for numerical\\n                stability. Default 1e-7.\\n        Returns:\\n            assign_result (obj:`AssignResult`): The assigned result.\\n        '\n    try:\n        assign_result = self._assign(pred_scores, priors, decoded_bboxes, gt_bboxes, gt_labels, gt_bboxes_ignore, eps)\n        return assign_result\n    except RuntimeError:\n        origin_device = pred_scores.device\n        warnings.warn('OOM RuntimeError is raised due to the huge memory cost during label assignment. CPU mode is applied in this batch. If you want to avoid this issue, try to reduce the batch size or image size.')\n        torch.cuda.empty_cache()\n        pred_scores = pred_scores.cpu()\n        priors = priors.cpu()\n        decoded_bboxes = decoded_bboxes.cpu()\n        gt_bboxes = gt_bboxes.cpu().float()\n        gt_labels = gt_labels.cpu()\n        assign_result = self._assign(pred_scores, priors, decoded_bboxes, gt_bboxes, gt_labels, gt_bboxes_ignore, eps)\n        assign_result.gt_inds = assign_result.gt_inds.to(origin_device)\n        assign_result.max_overlaps = assign_result.max_overlaps.to(origin_device)\n        assign_result.labels = assign_result.labels.to(origin_device)\n        return assign_result",
            "def assign(self, pred_scores, priors, decoded_bboxes, gt_bboxes, gt_labels, gt_bboxes_ignore=None, eps=1e-07):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Assign gt to priors using SimOTA. It will switch to CPU mode when\\n        GPU is out of memory.\\n        Args:\\n            pred_scores (Tensor): Classification scores of one image,\\n                a 2D-Tensor with shape [num_priors, num_classes]\\n            priors (Tensor): All priors of one image, a 2D-Tensor with shape\\n                [num_priors, 4] in [cx, xy, stride_w, stride_y] format.\\n            decoded_bboxes (Tensor): Predicted bboxes, a 2D-Tensor with shape\\n                [num_priors, 4] in [tl_x, tl_y, br_x, br_y] format.\\n            gt_bboxes (Tensor): Ground truth bboxes of one image, a 2D-Tensor\\n                with shape [num_gts, 4] in [tl_x, tl_y, br_x, br_y] format.\\n            gt_labels (Tensor): Ground truth labels of one image, a Tensor\\n                with shape [num_gts].\\n            gt_bboxes_ignore (Tensor, optional): Ground truth bboxes that are\\n                labelled as `ignored`, e.g., crowd boxes in COCO.\\n            eps (float): A value added to the denominator for numerical\\n                stability. Default 1e-7.\\n        Returns:\\n            assign_result (obj:`AssignResult`): The assigned result.\\n        '\n    try:\n        assign_result = self._assign(pred_scores, priors, decoded_bboxes, gt_bboxes, gt_labels, gt_bboxes_ignore, eps)\n        return assign_result\n    except RuntimeError:\n        origin_device = pred_scores.device\n        warnings.warn('OOM RuntimeError is raised due to the huge memory cost during label assignment. CPU mode is applied in this batch. If you want to avoid this issue, try to reduce the batch size or image size.')\n        torch.cuda.empty_cache()\n        pred_scores = pred_scores.cpu()\n        priors = priors.cpu()\n        decoded_bboxes = decoded_bboxes.cpu()\n        gt_bboxes = gt_bboxes.cpu().float()\n        gt_labels = gt_labels.cpu()\n        assign_result = self._assign(pred_scores, priors, decoded_bboxes, gt_bboxes, gt_labels, gt_bboxes_ignore, eps)\n        assign_result.gt_inds = assign_result.gt_inds.to(origin_device)\n        assign_result.max_overlaps = assign_result.max_overlaps.to(origin_device)\n        assign_result.labels = assign_result.labels.to(origin_device)\n        return assign_result",
            "def assign(self, pred_scores, priors, decoded_bboxes, gt_bboxes, gt_labels, gt_bboxes_ignore=None, eps=1e-07):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Assign gt to priors using SimOTA. It will switch to CPU mode when\\n        GPU is out of memory.\\n        Args:\\n            pred_scores (Tensor): Classification scores of one image,\\n                a 2D-Tensor with shape [num_priors, num_classes]\\n            priors (Tensor): All priors of one image, a 2D-Tensor with shape\\n                [num_priors, 4] in [cx, xy, stride_w, stride_y] format.\\n            decoded_bboxes (Tensor): Predicted bboxes, a 2D-Tensor with shape\\n                [num_priors, 4] in [tl_x, tl_y, br_x, br_y] format.\\n            gt_bboxes (Tensor): Ground truth bboxes of one image, a 2D-Tensor\\n                with shape [num_gts, 4] in [tl_x, tl_y, br_x, br_y] format.\\n            gt_labels (Tensor): Ground truth labels of one image, a Tensor\\n                with shape [num_gts].\\n            gt_bboxes_ignore (Tensor, optional): Ground truth bboxes that are\\n                labelled as `ignored`, e.g., crowd boxes in COCO.\\n            eps (float): A value added to the denominator for numerical\\n                stability. Default 1e-7.\\n        Returns:\\n            assign_result (obj:`AssignResult`): The assigned result.\\n        '\n    try:\n        assign_result = self._assign(pred_scores, priors, decoded_bboxes, gt_bboxes, gt_labels, gt_bboxes_ignore, eps)\n        return assign_result\n    except RuntimeError:\n        origin_device = pred_scores.device\n        warnings.warn('OOM RuntimeError is raised due to the huge memory cost during label assignment. CPU mode is applied in this batch. If you want to avoid this issue, try to reduce the batch size or image size.')\n        torch.cuda.empty_cache()\n        pred_scores = pred_scores.cpu()\n        priors = priors.cpu()\n        decoded_bboxes = decoded_bboxes.cpu()\n        gt_bboxes = gt_bboxes.cpu().float()\n        gt_labels = gt_labels.cpu()\n        assign_result = self._assign(pred_scores, priors, decoded_bboxes, gt_bboxes, gt_labels, gt_bboxes_ignore, eps)\n        assign_result.gt_inds = assign_result.gt_inds.to(origin_device)\n        assign_result.max_overlaps = assign_result.max_overlaps.to(origin_device)\n        assign_result.labels = assign_result.labels.to(origin_device)\n        return assign_result",
            "def assign(self, pred_scores, priors, decoded_bboxes, gt_bboxes, gt_labels, gt_bboxes_ignore=None, eps=1e-07):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Assign gt to priors using SimOTA. It will switch to CPU mode when\\n        GPU is out of memory.\\n        Args:\\n            pred_scores (Tensor): Classification scores of one image,\\n                a 2D-Tensor with shape [num_priors, num_classes]\\n            priors (Tensor): All priors of one image, a 2D-Tensor with shape\\n                [num_priors, 4] in [cx, xy, stride_w, stride_y] format.\\n            decoded_bboxes (Tensor): Predicted bboxes, a 2D-Tensor with shape\\n                [num_priors, 4] in [tl_x, tl_y, br_x, br_y] format.\\n            gt_bboxes (Tensor): Ground truth bboxes of one image, a 2D-Tensor\\n                with shape [num_gts, 4] in [tl_x, tl_y, br_x, br_y] format.\\n            gt_labels (Tensor): Ground truth labels of one image, a Tensor\\n                with shape [num_gts].\\n            gt_bboxes_ignore (Tensor, optional): Ground truth bboxes that are\\n                labelled as `ignored`, e.g., crowd boxes in COCO.\\n            eps (float): A value added to the denominator for numerical\\n                stability. Default 1e-7.\\n        Returns:\\n            assign_result (obj:`AssignResult`): The assigned result.\\n        '\n    try:\n        assign_result = self._assign(pred_scores, priors, decoded_bboxes, gt_bboxes, gt_labels, gt_bboxes_ignore, eps)\n        return assign_result\n    except RuntimeError:\n        origin_device = pred_scores.device\n        warnings.warn('OOM RuntimeError is raised due to the huge memory cost during label assignment. CPU mode is applied in this batch. If you want to avoid this issue, try to reduce the batch size or image size.')\n        torch.cuda.empty_cache()\n        pred_scores = pred_scores.cpu()\n        priors = priors.cpu()\n        decoded_bboxes = decoded_bboxes.cpu()\n        gt_bboxes = gt_bboxes.cpu().float()\n        gt_labels = gt_labels.cpu()\n        assign_result = self._assign(pred_scores, priors, decoded_bboxes, gt_bboxes, gt_labels, gt_bboxes_ignore, eps)\n        assign_result.gt_inds = assign_result.gt_inds.to(origin_device)\n        assign_result.max_overlaps = assign_result.max_overlaps.to(origin_device)\n        assign_result.labels = assign_result.labels.to(origin_device)\n        return assign_result",
            "def assign(self, pred_scores, priors, decoded_bboxes, gt_bboxes, gt_labels, gt_bboxes_ignore=None, eps=1e-07):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Assign gt to priors using SimOTA. It will switch to CPU mode when\\n        GPU is out of memory.\\n        Args:\\n            pred_scores (Tensor): Classification scores of one image,\\n                a 2D-Tensor with shape [num_priors, num_classes]\\n            priors (Tensor): All priors of one image, a 2D-Tensor with shape\\n                [num_priors, 4] in [cx, xy, stride_w, stride_y] format.\\n            decoded_bboxes (Tensor): Predicted bboxes, a 2D-Tensor with shape\\n                [num_priors, 4] in [tl_x, tl_y, br_x, br_y] format.\\n            gt_bboxes (Tensor): Ground truth bboxes of one image, a 2D-Tensor\\n                with shape [num_gts, 4] in [tl_x, tl_y, br_x, br_y] format.\\n            gt_labels (Tensor): Ground truth labels of one image, a Tensor\\n                with shape [num_gts].\\n            gt_bboxes_ignore (Tensor, optional): Ground truth bboxes that are\\n                labelled as `ignored`, e.g., crowd boxes in COCO.\\n            eps (float): A value added to the denominator for numerical\\n                stability. Default 1e-7.\\n        Returns:\\n            assign_result (obj:`AssignResult`): The assigned result.\\n        '\n    try:\n        assign_result = self._assign(pred_scores, priors, decoded_bboxes, gt_bboxes, gt_labels, gt_bboxes_ignore, eps)\n        return assign_result\n    except RuntimeError:\n        origin_device = pred_scores.device\n        warnings.warn('OOM RuntimeError is raised due to the huge memory cost during label assignment. CPU mode is applied in this batch. If you want to avoid this issue, try to reduce the batch size or image size.')\n        torch.cuda.empty_cache()\n        pred_scores = pred_scores.cpu()\n        priors = priors.cpu()\n        decoded_bboxes = decoded_bboxes.cpu()\n        gt_bboxes = gt_bboxes.cpu().float()\n        gt_labels = gt_labels.cpu()\n        assign_result = self._assign(pred_scores, priors, decoded_bboxes, gt_bboxes, gt_labels, gt_bboxes_ignore, eps)\n        assign_result.gt_inds = assign_result.gt_inds.to(origin_device)\n        assign_result.max_overlaps = assign_result.max_overlaps.to(origin_device)\n        assign_result.labels = assign_result.labels.to(origin_device)\n        return assign_result"
        ]
    },
    {
        "func_name": "_assign",
        "original": "def _assign(self, pred_scores, priors, decoded_bboxes, gt_bboxes, gt_labels, gt_bboxes_ignore=None, eps=1e-07):\n    \"\"\"Assign gt to priors using SimOTA.\n        Args:\n            pred_scores (Tensor): Classification scores of one image,\n                a 2D-Tensor with shape [num_priors, num_classes]\n            priors (Tensor): All priors of one image, a 2D-Tensor with shape\n                [num_priors, 4] in [cx, xy, stride_w, stride_y] format.\n            decoded_bboxes (Tensor): Predicted bboxes, a 2D-Tensor with shape\n                [num_priors, 4] in [tl_x, tl_y, br_x, br_y] format.\n            gt_bboxes (Tensor): Ground truth bboxes of one image, a 2D-Tensor\n                with shape [num_gts, 4] in [tl_x, tl_y, br_x, br_y] format.\n            gt_labels (Tensor): Ground truth labels of one image, a Tensor\n                with shape [num_gts].\n            gt_bboxes_ignore (Tensor, optional): Ground truth bboxes that are\n                labelled as `ignored`, e.g., crowd boxes in COCO.\n            eps (float): A value added to the denominator for numerical\n                stability. Default 1e-7.\n        Returns:\n            :obj:`AssignResult`: The assigned result.\n        \"\"\"\n    INF = 100000000\n    num_gt = gt_bboxes.size(0)\n    num_bboxes = decoded_bboxes.size(0)\n    assigned_gt_inds = decoded_bboxes.new_full((num_bboxes,), 0, dtype=torch.long)\n    (valid_mask, is_in_boxes_and_center) = self.get_in_gt_and_in_center_info(priors, gt_bboxes)\n    valid_decoded_bbox = decoded_bboxes[valid_mask]\n    valid_pred_scores = pred_scores[valid_mask]\n    num_valid = valid_decoded_bbox.size(0)\n    if num_gt == 0 or num_bboxes == 0 or num_valid == 0:\n        max_overlaps = decoded_bboxes.new_zeros((num_bboxes,))\n        if num_gt == 0:\n            assigned_gt_inds[:] = 0\n        if gt_labels is None:\n            assigned_labels = None\n        else:\n            assigned_labels = decoded_bboxes.new_full((num_bboxes,), -1, dtype=torch.long)\n        return AssignResult(num_gt, assigned_gt_inds, max_overlaps, labels=assigned_labels)\n    pairwise_ious = bbox_overlaps(valid_decoded_bbox, gt_bboxes)\n    iou_cost = -torch.log(pairwise_ious + eps)\n    iou_cost = iou_cost * self.iou_weight\n    gt_onehot_label = F.one_hot(gt_labels.to(torch.int64), pred_scores.shape[-1]).float().unsqueeze(0).repeat(num_valid, 1, 1)\n    valid_pred_scores = valid_pred_scores.unsqueeze(1).repeat(1, num_gt, 1)\n    soft_label = gt_onehot_label * pairwise_ious[..., None]\n    scale_factor = soft_label - valid_pred_scores\n    cls_cost = F.binary_cross_entropy(valid_pred_scores, soft_label, reduction='none') * scale_factor.abs().pow(2.0)\n    cls_cost = cls_cost.sum(dim=-1)\n    cls_cost = cls_cost * self.cls_weight\n    cost_matrix = cls_cost + iou_cost + ~is_in_boxes_and_center * INF\n    (matched_pred_ious, matched_gt_inds) = self.dynamic_k_matching(cost_matrix, pairwise_ious, num_gt, valid_mask)\n    assigned_gt_inds[valid_mask] = matched_gt_inds + 1\n    assigned_labels = assigned_gt_inds.new_full((num_bboxes,), -1)\n    assigned_labels[valid_mask] = gt_labels[matched_gt_inds].long()\n    max_overlaps = assigned_gt_inds.new_full((num_bboxes,), -INF, dtype=torch.float32)\n    max_overlaps[valid_mask] = matched_pred_ious\n    return AssignResult(num_gt, assigned_gt_inds, max_overlaps, labels=assigned_labels)",
        "mutated": [
            "def _assign(self, pred_scores, priors, decoded_bboxes, gt_bboxes, gt_labels, gt_bboxes_ignore=None, eps=1e-07):\n    if False:\n        i = 10\n    'Assign gt to priors using SimOTA.\\n        Args:\\n            pred_scores (Tensor): Classification scores of one image,\\n                a 2D-Tensor with shape [num_priors, num_classes]\\n            priors (Tensor): All priors of one image, a 2D-Tensor with shape\\n                [num_priors, 4] in [cx, xy, stride_w, stride_y] format.\\n            decoded_bboxes (Tensor): Predicted bboxes, a 2D-Tensor with shape\\n                [num_priors, 4] in [tl_x, tl_y, br_x, br_y] format.\\n            gt_bboxes (Tensor): Ground truth bboxes of one image, a 2D-Tensor\\n                with shape [num_gts, 4] in [tl_x, tl_y, br_x, br_y] format.\\n            gt_labels (Tensor): Ground truth labels of one image, a Tensor\\n                with shape [num_gts].\\n            gt_bboxes_ignore (Tensor, optional): Ground truth bboxes that are\\n                labelled as `ignored`, e.g., crowd boxes in COCO.\\n            eps (float): A value added to the denominator for numerical\\n                stability. Default 1e-7.\\n        Returns:\\n            :obj:`AssignResult`: The assigned result.\\n        '\n    INF = 100000000\n    num_gt = gt_bboxes.size(0)\n    num_bboxes = decoded_bboxes.size(0)\n    assigned_gt_inds = decoded_bboxes.new_full((num_bboxes,), 0, dtype=torch.long)\n    (valid_mask, is_in_boxes_and_center) = self.get_in_gt_and_in_center_info(priors, gt_bboxes)\n    valid_decoded_bbox = decoded_bboxes[valid_mask]\n    valid_pred_scores = pred_scores[valid_mask]\n    num_valid = valid_decoded_bbox.size(0)\n    if num_gt == 0 or num_bboxes == 0 or num_valid == 0:\n        max_overlaps = decoded_bboxes.new_zeros((num_bboxes,))\n        if num_gt == 0:\n            assigned_gt_inds[:] = 0\n        if gt_labels is None:\n            assigned_labels = None\n        else:\n            assigned_labels = decoded_bboxes.new_full((num_bboxes,), -1, dtype=torch.long)\n        return AssignResult(num_gt, assigned_gt_inds, max_overlaps, labels=assigned_labels)\n    pairwise_ious = bbox_overlaps(valid_decoded_bbox, gt_bboxes)\n    iou_cost = -torch.log(pairwise_ious + eps)\n    iou_cost = iou_cost * self.iou_weight\n    gt_onehot_label = F.one_hot(gt_labels.to(torch.int64), pred_scores.shape[-1]).float().unsqueeze(0).repeat(num_valid, 1, 1)\n    valid_pred_scores = valid_pred_scores.unsqueeze(1).repeat(1, num_gt, 1)\n    soft_label = gt_onehot_label * pairwise_ious[..., None]\n    scale_factor = soft_label - valid_pred_scores\n    cls_cost = F.binary_cross_entropy(valid_pred_scores, soft_label, reduction='none') * scale_factor.abs().pow(2.0)\n    cls_cost = cls_cost.sum(dim=-1)\n    cls_cost = cls_cost * self.cls_weight\n    cost_matrix = cls_cost + iou_cost + ~is_in_boxes_and_center * INF\n    (matched_pred_ious, matched_gt_inds) = self.dynamic_k_matching(cost_matrix, pairwise_ious, num_gt, valid_mask)\n    assigned_gt_inds[valid_mask] = matched_gt_inds + 1\n    assigned_labels = assigned_gt_inds.new_full((num_bboxes,), -1)\n    assigned_labels[valid_mask] = gt_labels[matched_gt_inds].long()\n    max_overlaps = assigned_gt_inds.new_full((num_bboxes,), -INF, dtype=torch.float32)\n    max_overlaps[valid_mask] = matched_pred_ious\n    return AssignResult(num_gt, assigned_gt_inds, max_overlaps, labels=assigned_labels)",
            "def _assign(self, pred_scores, priors, decoded_bboxes, gt_bboxes, gt_labels, gt_bboxes_ignore=None, eps=1e-07):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Assign gt to priors using SimOTA.\\n        Args:\\n            pred_scores (Tensor): Classification scores of one image,\\n                a 2D-Tensor with shape [num_priors, num_classes]\\n            priors (Tensor): All priors of one image, a 2D-Tensor with shape\\n                [num_priors, 4] in [cx, xy, stride_w, stride_y] format.\\n            decoded_bboxes (Tensor): Predicted bboxes, a 2D-Tensor with shape\\n                [num_priors, 4] in [tl_x, tl_y, br_x, br_y] format.\\n            gt_bboxes (Tensor): Ground truth bboxes of one image, a 2D-Tensor\\n                with shape [num_gts, 4] in [tl_x, tl_y, br_x, br_y] format.\\n            gt_labels (Tensor): Ground truth labels of one image, a Tensor\\n                with shape [num_gts].\\n            gt_bboxes_ignore (Tensor, optional): Ground truth bboxes that are\\n                labelled as `ignored`, e.g., crowd boxes in COCO.\\n            eps (float): A value added to the denominator for numerical\\n                stability. Default 1e-7.\\n        Returns:\\n            :obj:`AssignResult`: The assigned result.\\n        '\n    INF = 100000000\n    num_gt = gt_bboxes.size(0)\n    num_bboxes = decoded_bboxes.size(0)\n    assigned_gt_inds = decoded_bboxes.new_full((num_bboxes,), 0, dtype=torch.long)\n    (valid_mask, is_in_boxes_and_center) = self.get_in_gt_and_in_center_info(priors, gt_bboxes)\n    valid_decoded_bbox = decoded_bboxes[valid_mask]\n    valid_pred_scores = pred_scores[valid_mask]\n    num_valid = valid_decoded_bbox.size(0)\n    if num_gt == 0 or num_bboxes == 0 or num_valid == 0:\n        max_overlaps = decoded_bboxes.new_zeros((num_bboxes,))\n        if num_gt == 0:\n            assigned_gt_inds[:] = 0\n        if gt_labels is None:\n            assigned_labels = None\n        else:\n            assigned_labels = decoded_bboxes.new_full((num_bboxes,), -1, dtype=torch.long)\n        return AssignResult(num_gt, assigned_gt_inds, max_overlaps, labels=assigned_labels)\n    pairwise_ious = bbox_overlaps(valid_decoded_bbox, gt_bboxes)\n    iou_cost = -torch.log(pairwise_ious + eps)\n    iou_cost = iou_cost * self.iou_weight\n    gt_onehot_label = F.one_hot(gt_labels.to(torch.int64), pred_scores.shape[-1]).float().unsqueeze(0).repeat(num_valid, 1, 1)\n    valid_pred_scores = valid_pred_scores.unsqueeze(1).repeat(1, num_gt, 1)\n    soft_label = gt_onehot_label * pairwise_ious[..., None]\n    scale_factor = soft_label - valid_pred_scores\n    cls_cost = F.binary_cross_entropy(valid_pred_scores, soft_label, reduction='none') * scale_factor.abs().pow(2.0)\n    cls_cost = cls_cost.sum(dim=-1)\n    cls_cost = cls_cost * self.cls_weight\n    cost_matrix = cls_cost + iou_cost + ~is_in_boxes_and_center * INF\n    (matched_pred_ious, matched_gt_inds) = self.dynamic_k_matching(cost_matrix, pairwise_ious, num_gt, valid_mask)\n    assigned_gt_inds[valid_mask] = matched_gt_inds + 1\n    assigned_labels = assigned_gt_inds.new_full((num_bboxes,), -1)\n    assigned_labels[valid_mask] = gt_labels[matched_gt_inds].long()\n    max_overlaps = assigned_gt_inds.new_full((num_bboxes,), -INF, dtype=torch.float32)\n    max_overlaps[valid_mask] = matched_pred_ious\n    return AssignResult(num_gt, assigned_gt_inds, max_overlaps, labels=assigned_labels)",
            "def _assign(self, pred_scores, priors, decoded_bboxes, gt_bboxes, gt_labels, gt_bboxes_ignore=None, eps=1e-07):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Assign gt to priors using SimOTA.\\n        Args:\\n            pred_scores (Tensor): Classification scores of one image,\\n                a 2D-Tensor with shape [num_priors, num_classes]\\n            priors (Tensor): All priors of one image, a 2D-Tensor with shape\\n                [num_priors, 4] in [cx, xy, stride_w, stride_y] format.\\n            decoded_bboxes (Tensor): Predicted bboxes, a 2D-Tensor with shape\\n                [num_priors, 4] in [tl_x, tl_y, br_x, br_y] format.\\n            gt_bboxes (Tensor): Ground truth bboxes of one image, a 2D-Tensor\\n                with shape [num_gts, 4] in [tl_x, tl_y, br_x, br_y] format.\\n            gt_labels (Tensor): Ground truth labels of one image, a Tensor\\n                with shape [num_gts].\\n            gt_bboxes_ignore (Tensor, optional): Ground truth bboxes that are\\n                labelled as `ignored`, e.g., crowd boxes in COCO.\\n            eps (float): A value added to the denominator for numerical\\n                stability. Default 1e-7.\\n        Returns:\\n            :obj:`AssignResult`: The assigned result.\\n        '\n    INF = 100000000\n    num_gt = gt_bboxes.size(0)\n    num_bboxes = decoded_bboxes.size(0)\n    assigned_gt_inds = decoded_bboxes.new_full((num_bboxes,), 0, dtype=torch.long)\n    (valid_mask, is_in_boxes_and_center) = self.get_in_gt_and_in_center_info(priors, gt_bboxes)\n    valid_decoded_bbox = decoded_bboxes[valid_mask]\n    valid_pred_scores = pred_scores[valid_mask]\n    num_valid = valid_decoded_bbox.size(0)\n    if num_gt == 0 or num_bboxes == 0 or num_valid == 0:\n        max_overlaps = decoded_bboxes.new_zeros((num_bboxes,))\n        if num_gt == 0:\n            assigned_gt_inds[:] = 0\n        if gt_labels is None:\n            assigned_labels = None\n        else:\n            assigned_labels = decoded_bboxes.new_full((num_bboxes,), -1, dtype=torch.long)\n        return AssignResult(num_gt, assigned_gt_inds, max_overlaps, labels=assigned_labels)\n    pairwise_ious = bbox_overlaps(valid_decoded_bbox, gt_bboxes)\n    iou_cost = -torch.log(pairwise_ious + eps)\n    iou_cost = iou_cost * self.iou_weight\n    gt_onehot_label = F.one_hot(gt_labels.to(torch.int64), pred_scores.shape[-1]).float().unsqueeze(0).repeat(num_valid, 1, 1)\n    valid_pred_scores = valid_pred_scores.unsqueeze(1).repeat(1, num_gt, 1)\n    soft_label = gt_onehot_label * pairwise_ious[..., None]\n    scale_factor = soft_label - valid_pred_scores\n    cls_cost = F.binary_cross_entropy(valid_pred_scores, soft_label, reduction='none') * scale_factor.abs().pow(2.0)\n    cls_cost = cls_cost.sum(dim=-1)\n    cls_cost = cls_cost * self.cls_weight\n    cost_matrix = cls_cost + iou_cost + ~is_in_boxes_and_center * INF\n    (matched_pred_ious, matched_gt_inds) = self.dynamic_k_matching(cost_matrix, pairwise_ious, num_gt, valid_mask)\n    assigned_gt_inds[valid_mask] = matched_gt_inds + 1\n    assigned_labels = assigned_gt_inds.new_full((num_bboxes,), -1)\n    assigned_labels[valid_mask] = gt_labels[matched_gt_inds].long()\n    max_overlaps = assigned_gt_inds.new_full((num_bboxes,), -INF, dtype=torch.float32)\n    max_overlaps[valid_mask] = matched_pred_ious\n    return AssignResult(num_gt, assigned_gt_inds, max_overlaps, labels=assigned_labels)",
            "def _assign(self, pred_scores, priors, decoded_bboxes, gt_bboxes, gt_labels, gt_bboxes_ignore=None, eps=1e-07):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Assign gt to priors using SimOTA.\\n        Args:\\n            pred_scores (Tensor): Classification scores of one image,\\n                a 2D-Tensor with shape [num_priors, num_classes]\\n            priors (Tensor): All priors of one image, a 2D-Tensor with shape\\n                [num_priors, 4] in [cx, xy, stride_w, stride_y] format.\\n            decoded_bboxes (Tensor): Predicted bboxes, a 2D-Tensor with shape\\n                [num_priors, 4] in [tl_x, tl_y, br_x, br_y] format.\\n            gt_bboxes (Tensor): Ground truth bboxes of one image, a 2D-Tensor\\n                with shape [num_gts, 4] in [tl_x, tl_y, br_x, br_y] format.\\n            gt_labels (Tensor): Ground truth labels of one image, a Tensor\\n                with shape [num_gts].\\n            gt_bboxes_ignore (Tensor, optional): Ground truth bboxes that are\\n                labelled as `ignored`, e.g., crowd boxes in COCO.\\n            eps (float): A value added to the denominator for numerical\\n                stability. Default 1e-7.\\n        Returns:\\n            :obj:`AssignResult`: The assigned result.\\n        '\n    INF = 100000000\n    num_gt = gt_bboxes.size(0)\n    num_bboxes = decoded_bboxes.size(0)\n    assigned_gt_inds = decoded_bboxes.new_full((num_bboxes,), 0, dtype=torch.long)\n    (valid_mask, is_in_boxes_and_center) = self.get_in_gt_and_in_center_info(priors, gt_bboxes)\n    valid_decoded_bbox = decoded_bboxes[valid_mask]\n    valid_pred_scores = pred_scores[valid_mask]\n    num_valid = valid_decoded_bbox.size(0)\n    if num_gt == 0 or num_bboxes == 0 or num_valid == 0:\n        max_overlaps = decoded_bboxes.new_zeros((num_bboxes,))\n        if num_gt == 0:\n            assigned_gt_inds[:] = 0\n        if gt_labels is None:\n            assigned_labels = None\n        else:\n            assigned_labels = decoded_bboxes.new_full((num_bboxes,), -1, dtype=torch.long)\n        return AssignResult(num_gt, assigned_gt_inds, max_overlaps, labels=assigned_labels)\n    pairwise_ious = bbox_overlaps(valid_decoded_bbox, gt_bboxes)\n    iou_cost = -torch.log(pairwise_ious + eps)\n    iou_cost = iou_cost * self.iou_weight\n    gt_onehot_label = F.one_hot(gt_labels.to(torch.int64), pred_scores.shape[-1]).float().unsqueeze(0).repeat(num_valid, 1, 1)\n    valid_pred_scores = valid_pred_scores.unsqueeze(1).repeat(1, num_gt, 1)\n    soft_label = gt_onehot_label * pairwise_ious[..., None]\n    scale_factor = soft_label - valid_pred_scores\n    cls_cost = F.binary_cross_entropy(valid_pred_scores, soft_label, reduction='none') * scale_factor.abs().pow(2.0)\n    cls_cost = cls_cost.sum(dim=-1)\n    cls_cost = cls_cost * self.cls_weight\n    cost_matrix = cls_cost + iou_cost + ~is_in_boxes_and_center * INF\n    (matched_pred_ious, matched_gt_inds) = self.dynamic_k_matching(cost_matrix, pairwise_ious, num_gt, valid_mask)\n    assigned_gt_inds[valid_mask] = matched_gt_inds + 1\n    assigned_labels = assigned_gt_inds.new_full((num_bboxes,), -1)\n    assigned_labels[valid_mask] = gt_labels[matched_gt_inds].long()\n    max_overlaps = assigned_gt_inds.new_full((num_bboxes,), -INF, dtype=torch.float32)\n    max_overlaps[valid_mask] = matched_pred_ious\n    return AssignResult(num_gt, assigned_gt_inds, max_overlaps, labels=assigned_labels)",
            "def _assign(self, pred_scores, priors, decoded_bboxes, gt_bboxes, gt_labels, gt_bboxes_ignore=None, eps=1e-07):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Assign gt to priors using SimOTA.\\n        Args:\\n            pred_scores (Tensor): Classification scores of one image,\\n                a 2D-Tensor with shape [num_priors, num_classes]\\n            priors (Tensor): All priors of one image, a 2D-Tensor with shape\\n                [num_priors, 4] in [cx, xy, stride_w, stride_y] format.\\n            decoded_bboxes (Tensor): Predicted bboxes, a 2D-Tensor with shape\\n                [num_priors, 4] in [tl_x, tl_y, br_x, br_y] format.\\n            gt_bboxes (Tensor): Ground truth bboxes of one image, a 2D-Tensor\\n                with shape [num_gts, 4] in [tl_x, tl_y, br_x, br_y] format.\\n            gt_labels (Tensor): Ground truth labels of one image, a Tensor\\n                with shape [num_gts].\\n            gt_bboxes_ignore (Tensor, optional): Ground truth bboxes that are\\n                labelled as `ignored`, e.g., crowd boxes in COCO.\\n            eps (float): A value added to the denominator for numerical\\n                stability. Default 1e-7.\\n        Returns:\\n            :obj:`AssignResult`: The assigned result.\\n        '\n    INF = 100000000\n    num_gt = gt_bboxes.size(0)\n    num_bboxes = decoded_bboxes.size(0)\n    assigned_gt_inds = decoded_bboxes.new_full((num_bboxes,), 0, dtype=torch.long)\n    (valid_mask, is_in_boxes_and_center) = self.get_in_gt_and_in_center_info(priors, gt_bboxes)\n    valid_decoded_bbox = decoded_bboxes[valid_mask]\n    valid_pred_scores = pred_scores[valid_mask]\n    num_valid = valid_decoded_bbox.size(0)\n    if num_gt == 0 or num_bboxes == 0 or num_valid == 0:\n        max_overlaps = decoded_bboxes.new_zeros((num_bboxes,))\n        if num_gt == 0:\n            assigned_gt_inds[:] = 0\n        if gt_labels is None:\n            assigned_labels = None\n        else:\n            assigned_labels = decoded_bboxes.new_full((num_bboxes,), -1, dtype=torch.long)\n        return AssignResult(num_gt, assigned_gt_inds, max_overlaps, labels=assigned_labels)\n    pairwise_ious = bbox_overlaps(valid_decoded_bbox, gt_bboxes)\n    iou_cost = -torch.log(pairwise_ious + eps)\n    iou_cost = iou_cost * self.iou_weight\n    gt_onehot_label = F.one_hot(gt_labels.to(torch.int64), pred_scores.shape[-1]).float().unsqueeze(0).repeat(num_valid, 1, 1)\n    valid_pred_scores = valid_pred_scores.unsqueeze(1).repeat(1, num_gt, 1)\n    soft_label = gt_onehot_label * pairwise_ious[..., None]\n    scale_factor = soft_label - valid_pred_scores\n    cls_cost = F.binary_cross_entropy(valid_pred_scores, soft_label, reduction='none') * scale_factor.abs().pow(2.0)\n    cls_cost = cls_cost.sum(dim=-1)\n    cls_cost = cls_cost * self.cls_weight\n    cost_matrix = cls_cost + iou_cost + ~is_in_boxes_and_center * INF\n    (matched_pred_ious, matched_gt_inds) = self.dynamic_k_matching(cost_matrix, pairwise_ious, num_gt, valid_mask)\n    assigned_gt_inds[valid_mask] = matched_gt_inds + 1\n    assigned_labels = assigned_gt_inds.new_full((num_bboxes,), -1)\n    assigned_labels[valid_mask] = gt_labels[matched_gt_inds].long()\n    max_overlaps = assigned_gt_inds.new_full((num_bboxes,), -INF, dtype=torch.float32)\n    max_overlaps[valid_mask] = matched_pred_ious\n    return AssignResult(num_gt, assigned_gt_inds, max_overlaps, labels=assigned_labels)"
        ]
    },
    {
        "func_name": "get_in_gt_and_in_center_info",
        "original": "def get_in_gt_and_in_center_info(self, priors, gt_bboxes):\n    num_gt = gt_bboxes.size(0)\n    repeated_x = priors[:, 0].unsqueeze(1).repeat(1, num_gt)\n    repeated_y = priors[:, 1].unsqueeze(1).repeat(1, num_gt)\n    repeated_stride_x = priors[:, 2].unsqueeze(1).repeat(1, num_gt)\n    repeated_stride_y = priors[:, 3].unsqueeze(1).repeat(1, num_gt)\n    l_ = repeated_x - gt_bboxes[:, 0]\n    t_ = repeated_y - gt_bboxes[:, 1]\n    r_ = gt_bboxes[:, 2] - repeated_x\n    b_ = gt_bboxes[:, 3] - repeated_y\n    deltas = torch.stack([l_, t_, r_, b_], dim=1)\n    is_in_gts = deltas.min(dim=1).values > 0\n    is_in_gts_all = is_in_gts.sum(dim=1) > 0\n    gt_cxs = (gt_bboxes[:, 0] + gt_bboxes[:, 2]) / 2.0\n    gt_cys = (gt_bboxes[:, 1] + gt_bboxes[:, 3]) / 2.0\n    ct_box_l = gt_cxs - self.center_radius * repeated_stride_x\n    ct_box_t = gt_cys - self.center_radius * repeated_stride_y\n    ct_box_r = gt_cxs + self.center_radius * repeated_stride_x\n    ct_box_b = gt_cys + self.center_radius * repeated_stride_y\n    cl_ = repeated_x - ct_box_l\n    ct_ = repeated_y - ct_box_t\n    cr_ = ct_box_r - repeated_x\n    cb_ = ct_box_b - repeated_y\n    ct_deltas = torch.stack([cl_, ct_, cr_, cb_], dim=1)\n    is_in_cts = ct_deltas.min(dim=1).values > 0\n    is_in_cts_all = is_in_cts.sum(dim=1) > 0\n    is_in_gts_or_centers = is_in_gts_all | is_in_cts_all\n    is_in_boxes_and_centers = is_in_gts[is_in_gts_or_centers, :] & is_in_cts[is_in_gts_or_centers, :]\n    return (is_in_gts_or_centers, is_in_boxes_and_centers)",
        "mutated": [
            "def get_in_gt_and_in_center_info(self, priors, gt_bboxes):\n    if False:\n        i = 10\n    num_gt = gt_bboxes.size(0)\n    repeated_x = priors[:, 0].unsqueeze(1).repeat(1, num_gt)\n    repeated_y = priors[:, 1].unsqueeze(1).repeat(1, num_gt)\n    repeated_stride_x = priors[:, 2].unsqueeze(1).repeat(1, num_gt)\n    repeated_stride_y = priors[:, 3].unsqueeze(1).repeat(1, num_gt)\n    l_ = repeated_x - gt_bboxes[:, 0]\n    t_ = repeated_y - gt_bboxes[:, 1]\n    r_ = gt_bboxes[:, 2] - repeated_x\n    b_ = gt_bboxes[:, 3] - repeated_y\n    deltas = torch.stack([l_, t_, r_, b_], dim=1)\n    is_in_gts = deltas.min(dim=1).values > 0\n    is_in_gts_all = is_in_gts.sum(dim=1) > 0\n    gt_cxs = (gt_bboxes[:, 0] + gt_bboxes[:, 2]) / 2.0\n    gt_cys = (gt_bboxes[:, 1] + gt_bboxes[:, 3]) / 2.0\n    ct_box_l = gt_cxs - self.center_radius * repeated_stride_x\n    ct_box_t = gt_cys - self.center_radius * repeated_stride_y\n    ct_box_r = gt_cxs + self.center_radius * repeated_stride_x\n    ct_box_b = gt_cys + self.center_radius * repeated_stride_y\n    cl_ = repeated_x - ct_box_l\n    ct_ = repeated_y - ct_box_t\n    cr_ = ct_box_r - repeated_x\n    cb_ = ct_box_b - repeated_y\n    ct_deltas = torch.stack([cl_, ct_, cr_, cb_], dim=1)\n    is_in_cts = ct_deltas.min(dim=1).values > 0\n    is_in_cts_all = is_in_cts.sum(dim=1) > 0\n    is_in_gts_or_centers = is_in_gts_all | is_in_cts_all\n    is_in_boxes_and_centers = is_in_gts[is_in_gts_or_centers, :] & is_in_cts[is_in_gts_or_centers, :]\n    return (is_in_gts_or_centers, is_in_boxes_and_centers)",
            "def get_in_gt_and_in_center_info(self, priors, gt_bboxes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    num_gt = gt_bboxes.size(0)\n    repeated_x = priors[:, 0].unsqueeze(1).repeat(1, num_gt)\n    repeated_y = priors[:, 1].unsqueeze(1).repeat(1, num_gt)\n    repeated_stride_x = priors[:, 2].unsqueeze(1).repeat(1, num_gt)\n    repeated_stride_y = priors[:, 3].unsqueeze(1).repeat(1, num_gt)\n    l_ = repeated_x - gt_bboxes[:, 0]\n    t_ = repeated_y - gt_bboxes[:, 1]\n    r_ = gt_bboxes[:, 2] - repeated_x\n    b_ = gt_bboxes[:, 3] - repeated_y\n    deltas = torch.stack([l_, t_, r_, b_], dim=1)\n    is_in_gts = deltas.min(dim=1).values > 0\n    is_in_gts_all = is_in_gts.sum(dim=1) > 0\n    gt_cxs = (gt_bboxes[:, 0] + gt_bboxes[:, 2]) / 2.0\n    gt_cys = (gt_bboxes[:, 1] + gt_bboxes[:, 3]) / 2.0\n    ct_box_l = gt_cxs - self.center_radius * repeated_stride_x\n    ct_box_t = gt_cys - self.center_radius * repeated_stride_y\n    ct_box_r = gt_cxs + self.center_radius * repeated_stride_x\n    ct_box_b = gt_cys + self.center_radius * repeated_stride_y\n    cl_ = repeated_x - ct_box_l\n    ct_ = repeated_y - ct_box_t\n    cr_ = ct_box_r - repeated_x\n    cb_ = ct_box_b - repeated_y\n    ct_deltas = torch.stack([cl_, ct_, cr_, cb_], dim=1)\n    is_in_cts = ct_deltas.min(dim=1).values > 0\n    is_in_cts_all = is_in_cts.sum(dim=1) > 0\n    is_in_gts_or_centers = is_in_gts_all | is_in_cts_all\n    is_in_boxes_and_centers = is_in_gts[is_in_gts_or_centers, :] & is_in_cts[is_in_gts_or_centers, :]\n    return (is_in_gts_or_centers, is_in_boxes_and_centers)",
            "def get_in_gt_and_in_center_info(self, priors, gt_bboxes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    num_gt = gt_bboxes.size(0)\n    repeated_x = priors[:, 0].unsqueeze(1).repeat(1, num_gt)\n    repeated_y = priors[:, 1].unsqueeze(1).repeat(1, num_gt)\n    repeated_stride_x = priors[:, 2].unsqueeze(1).repeat(1, num_gt)\n    repeated_stride_y = priors[:, 3].unsqueeze(1).repeat(1, num_gt)\n    l_ = repeated_x - gt_bboxes[:, 0]\n    t_ = repeated_y - gt_bboxes[:, 1]\n    r_ = gt_bboxes[:, 2] - repeated_x\n    b_ = gt_bboxes[:, 3] - repeated_y\n    deltas = torch.stack([l_, t_, r_, b_], dim=1)\n    is_in_gts = deltas.min(dim=1).values > 0\n    is_in_gts_all = is_in_gts.sum(dim=1) > 0\n    gt_cxs = (gt_bboxes[:, 0] + gt_bboxes[:, 2]) / 2.0\n    gt_cys = (gt_bboxes[:, 1] + gt_bboxes[:, 3]) / 2.0\n    ct_box_l = gt_cxs - self.center_radius * repeated_stride_x\n    ct_box_t = gt_cys - self.center_radius * repeated_stride_y\n    ct_box_r = gt_cxs + self.center_radius * repeated_stride_x\n    ct_box_b = gt_cys + self.center_radius * repeated_stride_y\n    cl_ = repeated_x - ct_box_l\n    ct_ = repeated_y - ct_box_t\n    cr_ = ct_box_r - repeated_x\n    cb_ = ct_box_b - repeated_y\n    ct_deltas = torch.stack([cl_, ct_, cr_, cb_], dim=1)\n    is_in_cts = ct_deltas.min(dim=1).values > 0\n    is_in_cts_all = is_in_cts.sum(dim=1) > 0\n    is_in_gts_or_centers = is_in_gts_all | is_in_cts_all\n    is_in_boxes_and_centers = is_in_gts[is_in_gts_or_centers, :] & is_in_cts[is_in_gts_or_centers, :]\n    return (is_in_gts_or_centers, is_in_boxes_and_centers)",
            "def get_in_gt_and_in_center_info(self, priors, gt_bboxes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    num_gt = gt_bboxes.size(0)\n    repeated_x = priors[:, 0].unsqueeze(1).repeat(1, num_gt)\n    repeated_y = priors[:, 1].unsqueeze(1).repeat(1, num_gt)\n    repeated_stride_x = priors[:, 2].unsqueeze(1).repeat(1, num_gt)\n    repeated_stride_y = priors[:, 3].unsqueeze(1).repeat(1, num_gt)\n    l_ = repeated_x - gt_bboxes[:, 0]\n    t_ = repeated_y - gt_bboxes[:, 1]\n    r_ = gt_bboxes[:, 2] - repeated_x\n    b_ = gt_bboxes[:, 3] - repeated_y\n    deltas = torch.stack([l_, t_, r_, b_], dim=1)\n    is_in_gts = deltas.min(dim=1).values > 0\n    is_in_gts_all = is_in_gts.sum(dim=1) > 0\n    gt_cxs = (gt_bboxes[:, 0] + gt_bboxes[:, 2]) / 2.0\n    gt_cys = (gt_bboxes[:, 1] + gt_bboxes[:, 3]) / 2.0\n    ct_box_l = gt_cxs - self.center_radius * repeated_stride_x\n    ct_box_t = gt_cys - self.center_radius * repeated_stride_y\n    ct_box_r = gt_cxs + self.center_radius * repeated_stride_x\n    ct_box_b = gt_cys + self.center_radius * repeated_stride_y\n    cl_ = repeated_x - ct_box_l\n    ct_ = repeated_y - ct_box_t\n    cr_ = ct_box_r - repeated_x\n    cb_ = ct_box_b - repeated_y\n    ct_deltas = torch.stack([cl_, ct_, cr_, cb_], dim=1)\n    is_in_cts = ct_deltas.min(dim=1).values > 0\n    is_in_cts_all = is_in_cts.sum(dim=1) > 0\n    is_in_gts_or_centers = is_in_gts_all | is_in_cts_all\n    is_in_boxes_and_centers = is_in_gts[is_in_gts_or_centers, :] & is_in_cts[is_in_gts_or_centers, :]\n    return (is_in_gts_or_centers, is_in_boxes_and_centers)",
            "def get_in_gt_and_in_center_info(self, priors, gt_bboxes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    num_gt = gt_bboxes.size(0)\n    repeated_x = priors[:, 0].unsqueeze(1).repeat(1, num_gt)\n    repeated_y = priors[:, 1].unsqueeze(1).repeat(1, num_gt)\n    repeated_stride_x = priors[:, 2].unsqueeze(1).repeat(1, num_gt)\n    repeated_stride_y = priors[:, 3].unsqueeze(1).repeat(1, num_gt)\n    l_ = repeated_x - gt_bboxes[:, 0]\n    t_ = repeated_y - gt_bboxes[:, 1]\n    r_ = gt_bboxes[:, 2] - repeated_x\n    b_ = gt_bboxes[:, 3] - repeated_y\n    deltas = torch.stack([l_, t_, r_, b_], dim=1)\n    is_in_gts = deltas.min(dim=1).values > 0\n    is_in_gts_all = is_in_gts.sum(dim=1) > 0\n    gt_cxs = (gt_bboxes[:, 0] + gt_bboxes[:, 2]) / 2.0\n    gt_cys = (gt_bboxes[:, 1] + gt_bboxes[:, 3]) / 2.0\n    ct_box_l = gt_cxs - self.center_radius * repeated_stride_x\n    ct_box_t = gt_cys - self.center_radius * repeated_stride_y\n    ct_box_r = gt_cxs + self.center_radius * repeated_stride_x\n    ct_box_b = gt_cys + self.center_radius * repeated_stride_y\n    cl_ = repeated_x - ct_box_l\n    ct_ = repeated_y - ct_box_t\n    cr_ = ct_box_r - repeated_x\n    cb_ = ct_box_b - repeated_y\n    ct_deltas = torch.stack([cl_, ct_, cr_, cb_], dim=1)\n    is_in_cts = ct_deltas.min(dim=1).values > 0\n    is_in_cts_all = is_in_cts.sum(dim=1) > 0\n    is_in_gts_or_centers = is_in_gts_all | is_in_cts_all\n    is_in_boxes_and_centers = is_in_gts[is_in_gts_or_centers, :] & is_in_cts[is_in_gts_or_centers, :]\n    return (is_in_gts_or_centers, is_in_boxes_and_centers)"
        ]
    },
    {
        "func_name": "dynamic_k_matching",
        "original": "def dynamic_k_matching(self, cost, pairwise_ious, num_gt, valid_mask):\n    matching_matrix = torch.zeros_like(cost)\n    candidate_topk = min(self.candidate_topk, pairwise_ious.size(0))\n    (topk_ious, _) = torch.topk(pairwise_ious, candidate_topk, dim=0)\n    dynamic_ks = torch.clamp(topk_ious.sum(0).int(), min=1)\n    for gt_idx in range(num_gt):\n        (_, pos_idx) = torch.topk(cost[:, gt_idx], k=dynamic_ks[gt_idx].item(), largest=False)\n        matching_matrix[:, gt_idx][pos_idx] = 1.0\n    del topk_ious, dynamic_ks, pos_idx\n    prior_match_gt_mask = matching_matrix.sum(1) > 1\n    if prior_match_gt_mask.sum() > 0:\n        (cost_min, cost_argmin) = torch.min(cost[prior_match_gt_mask, :], dim=1)\n        matching_matrix[prior_match_gt_mask, :] *= 0.0\n        matching_matrix[prior_match_gt_mask, cost_argmin] = 1.0\n    fg_mask_inboxes = matching_matrix.sum(1) > 0.0\n    valid_mask[valid_mask.clone()] = fg_mask_inboxes\n    matched_gt_inds = matching_matrix[fg_mask_inboxes, :].argmax(1)\n    matched_pred_ious = (matching_matrix * pairwise_ious).sum(1)[fg_mask_inboxes]\n    return (matched_pred_ious, matched_gt_inds)",
        "mutated": [
            "def dynamic_k_matching(self, cost, pairwise_ious, num_gt, valid_mask):\n    if False:\n        i = 10\n    matching_matrix = torch.zeros_like(cost)\n    candidate_topk = min(self.candidate_topk, pairwise_ious.size(0))\n    (topk_ious, _) = torch.topk(pairwise_ious, candidate_topk, dim=0)\n    dynamic_ks = torch.clamp(topk_ious.sum(0).int(), min=1)\n    for gt_idx in range(num_gt):\n        (_, pos_idx) = torch.topk(cost[:, gt_idx], k=dynamic_ks[gt_idx].item(), largest=False)\n        matching_matrix[:, gt_idx][pos_idx] = 1.0\n    del topk_ious, dynamic_ks, pos_idx\n    prior_match_gt_mask = matching_matrix.sum(1) > 1\n    if prior_match_gt_mask.sum() > 0:\n        (cost_min, cost_argmin) = torch.min(cost[prior_match_gt_mask, :], dim=1)\n        matching_matrix[prior_match_gt_mask, :] *= 0.0\n        matching_matrix[prior_match_gt_mask, cost_argmin] = 1.0\n    fg_mask_inboxes = matching_matrix.sum(1) > 0.0\n    valid_mask[valid_mask.clone()] = fg_mask_inboxes\n    matched_gt_inds = matching_matrix[fg_mask_inboxes, :].argmax(1)\n    matched_pred_ious = (matching_matrix * pairwise_ious).sum(1)[fg_mask_inboxes]\n    return (matched_pred_ious, matched_gt_inds)",
            "def dynamic_k_matching(self, cost, pairwise_ious, num_gt, valid_mask):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    matching_matrix = torch.zeros_like(cost)\n    candidate_topk = min(self.candidate_topk, pairwise_ious.size(0))\n    (topk_ious, _) = torch.topk(pairwise_ious, candidate_topk, dim=0)\n    dynamic_ks = torch.clamp(topk_ious.sum(0).int(), min=1)\n    for gt_idx in range(num_gt):\n        (_, pos_idx) = torch.topk(cost[:, gt_idx], k=dynamic_ks[gt_idx].item(), largest=False)\n        matching_matrix[:, gt_idx][pos_idx] = 1.0\n    del topk_ious, dynamic_ks, pos_idx\n    prior_match_gt_mask = matching_matrix.sum(1) > 1\n    if prior_match_gt_mask.sum() > 0:\n        (cost_min, cost_argmin) = torch.min(cost[prior_match_gt_mask, :], dim=1)\n        matching_matrix[prior_match_gt_mask, :] *= 0.0\n        matching_matrix[prior_match_gt_mask, cost_argmin] = 1.0\n    fg_mask_inboxes = matching_matrix.sum(1) > 0.0\n    valid_mask[valid_mask.clone()] = fg_mask_inboxes\n    matched_gt_inds = matching_matrix[fg_mask_inboxes, :].argmax(1)\n    matched_pred_ious = (matching_matrix * pairwise_ious).sum(1)[fg_mask_inboxes]\n    return (matched_pred_ious, matched_gt_inds)",
            "def dynamic_k_matching(self, cost, pairwise_ious, num_gt, valid_mask):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    matching_matrix = torch.zeros_like(cost)\n    candidate_topk = min(self.candidate_topk, pairwise_ious.size(0))\n    (topk_ious, _) = torch.topk(pairwise_ious, candidate_topk, dim=0)\n    dynamic_ks = torch.clamp(topk_ious.sum(0).int(), min=1)\n    for gt_idx in range(num_gt):\n        (_, pos_idx) = torch.topk(cost[:, gt_idx], k=dynamic_ks[gt_idx].item(), largest=False)\n        matching_matrix[:, gt_idx][pos_idx] = 1.0\n    del topk_ious, dynamic_ks, pos_idx\n    prior_match_gt_mask = matching_matrix.sum(1) > 1\n    if prior_match_gt_mask.sum() > 0:\n        (cost_min, cost_argmin) = torch.min(cost[prior_match_gt_mask, :], dim=1)\n        matching_matrix[prior_match_gt_mask, :] *= 0.0\n        matching_matrix[prior_match_gt_mask, cost_argmin] = 1.0\n    fg_mask_inboxes = matching_matrix.sum(1) > 0.0\n    valid_mask[valid_mask.clone()] = fg_mask_inboxes\n    matched_gt_inds = matching_matrix[fg_mask_inboxes, :].argmax(1)\n    matched_pred_ious = (matching_matrix * pairwise_ious).sum(1)[fg_mask_inboxes]\n    return (matched_pred_ious, matched_gt_inds)",
            "def dynamic_k_matching(self, cost, pairwise_ious, num_gt, valid_mask):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    matching_matrix = torch.zeros_like(cost)\n    candidate_topk = min(self.candidate_topk, pairwise_ious.size(0))\n    (topk_ious, _) = torch.topk(pairwise_ious, candidate_topk, dim=0)\n    dynamic_ks = torch.clamp(topk_ious.sum(0).int(), min=1)\n    for gt_idx in range(num_gt):\n        (_, pos_idx) = torch.topk(cost[:, gt_idx], k=dynamic_ks[gt_idx].item(), largest=False)\n        matching_matrix[:, gt_idx][pos_idx] = 1.0\n    del topk_ious, dynamic_ks, pos_idx\n    prior_match_gt_mask = matching_matrix.sum(1) > 1\n    if prior_match_gt_mask.sum() > 0:\n        (cost_min, cost_argmin) = torch.min(cost[prior_match_gt_mask, :], dim=1)\n        matching_matrix[prior_match_gt_mask, :] *= 0.0\n        matching_matrix[prior_match_gt_mask, cost_argmin] = 1.0\n    fg_mask_inboxes = matching_matrix.sum(1) > 0.0\n    valid_mask[valid_mask.clone()] = fg_mask_inboxes\n    matched_gt_inds = matching_matrix[fg_mask_inboxes, :].argmax(1)\n    matched_pred_ious = (matching_matrix * pairwise_ious).sum(1)[fg_mask_inboxes]\n    return (matched_pred_ious, matched_gt_inds)",
            "def dynamic_k_matching(self, cost, pairwise_ious, num_gt, valid_mask):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    matching_matrix = torch.zeros_like(cost)\n    candidate_topk = min(self.candidate_topk, pairwise_ious.size(0))\n    (topk_ious, _) = torch.topk(pairwise_ious, candidate_topk, dim=0)\n    dynamic_ks = torch.clamp(topk_ious.sum(0).int(), min=1)\n    for gt_idx in range(num_gt):\n        (_, pos_idx) = torch.topk(cost[:, gt_idx], k=dynamic_ks[gt_idx].item(), largest=False)\n        matching_matrix[:, gt_idx][pos_idx] = 1.0\n    del topk_ious, dynamic_ks, pos_idx\n    prior_match_gt_mask = matching_matrix.sum(1) > 1\n    if prior_match_gt_mask.sum() > 0:\n        (cost_min, cost_argmin) = torch.min(cost[prior_match_gt_mask, :], dim=1)\n        matching_matrix[prior_match_gt_mask, :] *= 0.0\n        matching_matrix[prior_match_gt_mask, cost_argmin] = 1.0\n    fg_mask_inboxes = matching_matrix.sum(1) > 0.0\n    valid_mask[valid_mask.clone()] = fg_mask_inboxes\n    matched_gt_inds = matching_matrix[fg_mask_inboxes, :].argmax(1)\n    matched_pred_ious = (matching_matrix * pairwise_ious).sum(1)[fg_mask_inboxes]\n    return (matched_pred_ious, matched_gt_inds)"
        ]
    }
]