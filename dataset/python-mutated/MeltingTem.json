[
    {
        "func_name": "make_table",
        "original": "def make_table(oldtable=None, values=None):\n    \"\"\"Return a table with thermodynamic parameters (as dictionary).\n\n    Arguments:\n     - oldtable: An existing dictionary with thermodynamic parameters.\n     - values: A dictionary with new or updated values.\n\n    E.g., to replace the initiation parameters in the Sugimoto '96 dataset with\n    the initiation parameters from Allawi & SantaLucia '97:\n\n    >>> from Bio.SeqUtils.MeltingTemp import make_table, DNA_NN2\n    >>> table = DNA_NN2                               # Sugimoto '96\n    >>> table['init_A/T']\n    (0, 0)\n    >>> newtable = make_table(oldtable=DNA_NN2, values={'init': (0, 0),\n    ...                       'init_A/T': (2.3, 4.1),\n    ...                       'init_G/C': (0.1, -2.8)})\n    >>> print(\"%0.1f, %0.1f\" % newtable['init_A/T'])\n    2.3, 4.1\n\n    \"\"\"\n    if oldtable is None:\n        table = {'init': (0, 0), 'init_A/T': (0, 0), 'init_G/C': (0, 0), 'init_oneG/C': (0, 0), 'init_allA/T': (0, 0), 'init_5T/A': (0, 0), 'sym': (0, 0), 'AA/TT': (0, 0), 'AT/TA': (0, 0), 'TA/AT': (0, 0), 'CA/GT': (0, 0), 'GT/CA': (0, 0), 'CT/GA': (0, 0), 'GA/CT': (0, 0), 'CG/GC': (0, 0), 'GC/CG': (0, 0), 'GG/CC': (0, 0)}\n    else:\n        table = oldtable.copy()\n    if values:\n        table.update(values)\n    return table",
        "mutated": [
            "def make_table(oldtable=None, values=None):\n    if False:\n        i = 10\n    'Return a table with thermodynamic parameters (as dictionary).\\n\\n    Arguments:\\n     - oldtable: An existing dictionary with thermodynamic parameters.\\n     - values: A dictionary with new or updated values.\\n\\n    E.g., to replace the initiation parameters in the Sugimoto \\'96 dataset with\\n    the initiation parameters from Allawi & SantaLucia \\'97:\\n\\n    >>> from Bio.SeqUtils.MeltingTemp import make_table, DNA_NN2\\n    >>> table = DNA_NN2                               # Sugimoto \\'96\\n    >>> table[\\'init_A/T\\']\\n    (0, 0)\\n    >>> newtable = make_table(oldtable=DNA_NN2, values={\\'init\\': (0, 0),\\n    ...                       \\'init_A/T\\': (2.3, 4.1),\\n    ...                       \\'init_G/C\\': (0.1, -2.8)})\\n    >>> print(\"%0.1f, %0.1f\" % newtable[\\'init_A/T\\'])\\n    2.3, 4.1\\n\\n    '\n    if oldtable is None:\n        table = {'init': (0, 0), 'init_A/T': (0, 0), 'init_G/C': (0, 0), 'init_oneG/C': (0, 0), 'init_allA/T': (0, 0), 'init_5T/A': (0, 0), 'sym': (0, 0), 'AA/TT': (0, 0), 'AT/TA': (0, 0), 'TA/AT': (0, 0), 'CA/GT': (0, 0), 'GT/CA': (0, 0), 'CT/GA': (0, 0), 'GA/CT': (0, 0), 'CG/GC': (0, 0), 'GC/CG': (0, 0), 'GG/CC': (0, 0)}\n    else:\n        table = oldtable.copy()\n    if values:\n        table.update(values)\n    return table",
            "def make_table(oldtable=None, values=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Return a table with thermodynamic parameters (as dictionary).\\n\\n    Arguments:\\n     - oldtable: An existing dictionary with thermodynamic parameters.\\n     - values: A dictionary with new or updated values.\\n\\n    E.g., to replace the initiation parameters in the Sugimoto \\'96 dataset with\\n    the initiation parameters from Allawi & SantaLucia \\'97:\\n\\n    >>> from Bio.SeqUtils.MeltingTemp import make_table, DNA_NN2\\n    >>> table = DNA_NN2                               # Sugimoto \\'96\\n    >>> table[\\'init_A/T\\']\\n    (0, 0)\\n    >>> newtable = make_table(oldtable=DNA_NN2, values={\\'init\\': (0, 0),\\n    ...                       \\'init_A/T\\': (2.3, 4.1),\\n    ...                       \\'init_G/C\\': (0.1, -2.8)})\\n    >>> print(\"%0.1f, %0.1f\" % newtable[\\'init_A/T\\'])\\n    2.3, 4.1\\n\\n    '\n    if oldtable is None:\n        table = {'init': (0, 0), 'init_A/T': (0, 0), 'init_G/C': (0, 0), 'init_oneG/C': (0, 0), 'init_allA/T': (0, 0), 'init_5T/A': (0, 0), 'sym': (0, 0), 'AA/TT': (0, 0), 'AT/TA': (0, 0), 'TA/AT': (0, 0), 'CA/GT': (0, 0), 'GT/CA': (0, 0), 'CT/GA': (0, 0), 'GA/CT': (0, 0), 'CG/GC': (0, 0), 'GC/CG': (0, 0), 'GG/CC': (0, 0)}\n    else:\n        table = oldtable.copy()\n    if values:\n        table.update(values)\n    return table",
            "def make_table(oldtable=None, values=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Return a table with thermodynamic parameters (as dictionary).\\n\\n    Arguments:\\n     - oldtable: An existing dictionary with thermodynamic parameters.\\n     - values: A dictionary with new or updated values.\\n\\n    E.g., to replace the initiation parameters in the Sugimoto \\'96 dataset with\\n    the initiation parameters from Allawi & SantaLucia \\'97:\\n\\n    >>> from Bio.SeqUtils.MeltingTemp import make_table, DNA_NN2\\n    >>> table = DNA_NN2                               # Sugimoto \\'96\\n    >>> table[\\'init_A/T\\']\\n    (0, 0)\\n    >>> newtable = make_table(oldtable=DNA_NN2, values={\\'init\\': (0, 0),\\n    ...                       \\'init_A/T\\': (2.3, 4.1),\\n    ...                       \\'init_G/C\\': (0.1, -2.8)})\\n    >>> print(\"%0.1f, %0.1f\" % newtable[\\'init_A/T\\'])\\n    2.3, 4.1\\n\\n    '\n    if oldtable is None:\n        table = {'init': (0, 0), 'init_A/T': (0, 0), 'init_G/C': (0, 0), 'init_oneG/C': (0, 0), 'init_allA/T': (0, 0), 'init_5T/A': (0, 0), 'sym': (0, 0), 'AA/TT': (0, 0), 'AT/TA': (0, 0), 'TA/AT': (0, 0), 'CA/GT': (0, 0), 'GT/CA': (0, 0), 'CT/GA': (0, 0), 'GA/CT': (0, 0), 'CG/GC': (0, 0), 'GC/CG': (0, 0), 'GG/CC': (0, 0)}\n    else:\n        table = oldtable.copy()\n    if values:\n        table.update(values)\n    return table",
            "def make_table(oldtable=None, values=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Return a table with thermodynamic parameters (as dictionary).\\n\\n    Arguments:\\n     - oldtable: An existing dictionary with thermodynamic parameters.\\n     - values: A dictionary with new or updated values.\\n\\n    E.g., to replace the initiation parameters in the Sugimoto \\'96 dataset with\\n    the initiation parameters from Allawi & SantaLucia \\'97:\\n\\n    >>> from Bio.SeqUtils.MeltingTemp import make_table, DNA_NN2\\n    >>> table = DNA_NN2                               # Sugimoto \\'96\\n    >>> table[\\'init_A/T\\']\\n    (0, 0)\\n    >>> newtable = make_table(oldtable=DNA_NN2, values={\\'init\\': (0, 0),\\n    ...                       \\'init_A/T\\': (2.3, 4.1),\\n    ...                       \\'init_G/C\\': (0.1, -2.8)})\\n    >>> print(\"%0.1f, %0.1f\" % newtable[\\'init_A/T\\'])\\n    2.3, 4.1\\n\\n    '\n    if oldtable is None:\n        table = {'init': (0, 0), 'init_A/T': (0, 0), 'init_G/C': (0, 0), 'init_oneG/C': (0, 0), 'init_allA/T': (0, 0), 'init_5T/A': (0, 0), 'sym': (0, 0), 'AA/TT': (0, 0), 'AT/TA': (0, 0), 'TA/AT': (0, 0), 'CA/GT': (0, 0), 'GT/CA': (0, 0), 'CT/GA': (0, 0), 'GA/CT': (0, 0), 'CG/GC': (0, 0), 'GC/CG': (0, 0), 'GG/CC': (0, 0)}\n    else:\n        table = oldtable.copy()\n    if values:\n        table.update(values)\n    return table",
            "def make_table(oldtable=None, values=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Return a table with thermodynamic parameters (as dictionary).\\n\\n    Arguments:\\n     - oldtable: An existing dictionary with thermodynamic parameters.\\n     - values: A dictionary with new or updated values.\\n\\n    E.g., to replace the initiation parameters in the Sugimoto \\'96 dataset with\\n    the initiation parameters from Allawi & SantaLucia \\'97:\\n\\n    >>> from Bio.SeqUtils.MeltingTemp import make_table, DNA_NN2\\n    >>> table = DNA_NN2                               # Sugimoto \\'96\\n    >>> table[\\'init_A/T\\']\\n    (0, 0)\\n    >>> newtable = make_table(oldtable=DNA_NN2, values={\\'init\\': (0, 0),\\n    ...                       \\'init_A/T\\': (2.3, 4.1),\\n    ...                       \\'init_G/C\\': (0.1, -2.8)})\\n    >>> print(\"%0.1f, %0.1f\" % newtable[\\'init_A/T\\'])\\n    2.3, 4.1\\n\\n    '\n    if oldtable is None:\n        table = {'init': (0, 0), 'init_A/T': (0, 0), 'init_G/C': (0, 0), 'init_oneG/C': (0, 0), 'init_allA/T': (0, 0), 'init_5T/A': (0, 0), 'sym': (0, 0), 'AA/TT': (0, 0), 'AT/TA': (0, 0), 'TA/AT': (0, 0), 'CA/GT': (0, 0), 'GT/CA': (0, 0), 'CT/GA': (0, 0), 'GA/CT': (0, 0), 'CG/GC': (0, 0), 'GC/CG': (0, 0), 'GG/CC': (0, 0)}\n    else:\n        table = oldtable.copy()\n    if values:\n        table.update(values)\n    return table"
        ]
    },
    {
        "func_name": "_check",
        "original": "def _check(seq, method):\n    \"\"\"Return a sequence which fulfills the requirements of the given method (PRIVATE).\n\n    All Tm methods in this package require the sequence in uppercase format.\n    Most methods make use of the length of the sequence (directly or\n    indirectly), which can only be expressed as len(seq) if the sequence does\n    not contain whitespaces and other non-base characters. RNA sequences are\n    backtranscribed to DNA. This method is PRIVATE.\n\n    Arguments:\n     - seq: The sequence as given by the user (passed as string).\n     - method: Tm_Wallace, Tm_GC or Tm_NN.\n\n    >>> from Bio.SeqUtils import MeltingTemp as mt\n    >>> mt._check('10 ACGTTGCAAG tccatggtac', 'Tm_NN')\n    'ACGTTGCAAGTCCATGGTAC'\n\n    \"\"\"\n    seq = ''.join(seq.split()).upper()\n    seq = str(Seq.Seq(seq).back_transcribe())\n    if method == 'Tm_Wallace':\n        return seq\n    if method == 'Tm_GC':\n        baseset = ('A', 'B', 'C', 'D', 'G', 'H', 'I', 'K', 'M', 'N', 'R', 'S', 'T', 'V', 'W', 'X', 'Y')\n    if method == 'Tm_NN':\n        baseset = ('A', 'C', 'G', 'T', 'I')\n    seq = ''.join([base for base in seq if base in baseset])\n    return seq",
        "mutated": [
            "def _check(seq, method):\n    if False:\n        i = 10\n    \"Return a sequence which fulfills the requirements of the given method (PRIVATE).\\n\\n    All Tm methods in this package require the sequence in uppercase format.\\n    Most methods make use of the length of the sequence (directly or\\n    indirectly), which can only be expressed as len(seq) if the sequence does\\n    not contain whitespaces and other non-base characters. RNA sequences are\\n    backtranscribed to DNA. This method is PRIVATE.\\n\\n    Arguments:\\n     - seq: The sequence as given by the user (passed as string).\\n     - method: Tm_Wallace, Tm_GC or Tm_NN.\\n\\n    >>> from Bio.SeqUtils import MeltingTemp as mt\\n    >>> mt._check('10 ACGTTGCAAG tccatggtac', 'Tm_NN')\\n    'ACGTTGCAAGTCCATGGTAC'\\n\\n    \"\n    seq = ''.join(seq.split()).upper()\n    seq = str(Seq.Seq(seq).back_transcribe())\n    if method == 'Tm_Wallace':\n        return seq\n    if method == 'Tm_GC':\n        baseset = ('A', 'B', 'C', 'D', 'G', 'H', 'I', 'K', 'M', 'N', 'R', 'S', 'T', 'V', 'W', 'X', 'Y')\n    if method == 'Tm_NN':\n        baseset = ('A', 'C', 'G', 'T', 'I')\n    seq = ''.join([base for base in seq if base in baseset])\n    return seq",
            "def _check(seq, method):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Return a sequence which fulfills the requirements of the given method (PRIVATE).\\n\\n    All Tm methods in this package require the sequence in uppercase format.\\n    Most methods make use of the length of the sequence (directly or\\n    indirectly), which can only be expressed as len(seq) if the sequence does\\n    not contain whitespaces and other non-base characters. RNA sequences are\\n    backtranscribed to DNA. This method is PRIVATE.\\n\\n    Arguments:\\n     - seq: The sequence as given by the user (passed as string).\\n     - method: Tm_Wallace, Tm_GC or Tm_NN.\\n\\n    >>> from Bio.SeqUtils import MeltingTemp as mt\\n    >>> mt._check('10 ACGTTGCAAG tccatggtac', 'Tm_NN')\\n    'ACGTTGCAAGTCCATGGTAC'\\n\\n    \"\n    seq = ''.join(seq.split()).upper()\n    seq = str(Seq.Seq(seq).back_transcribe())\n    if method == 'Tm_Wallace':\n        return seq\n    if method == 'Tm_GC':\n        baseset = ('A', 'B', 'C', 'D', 'G', 'H', 'I', 'K', 'M', 'N', 'R', 'S', 'T', 'V', 'W', 'X', 'Y')\n    if method == 'Tm_NN':\n        baseset = ('A', 'C', 'G', 'T', 'I')\n    seq = ''.join([base for base in seq if base in baseset])\n    return seq",
            "def _check(seq, method):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Return a sequence which fulfills the requirements of the given method (PRIVATE).\\n\\n    All Tm methods in this package require the sequence in uppercase format.\\n    Most methods make use of the length of the sequence (directly or\\n    indirectly), which can only be expressed as len(seq) if the sequence does\\n    not contain whitespaces and other non-base characters. RNA sequences are\\n    backtranscribed to DNA. This method is PRIVATE.\\n\\n    Arguments:\\n     - seq: The sequence as given by the user (passed as string).\\n     - method: Tm_Wallace, Tm_GC or Tm_NN.\\n\\n    >>> from Bio.SeqUtils import MeltingTemp as mt\\n    >>> mt._check('10 ACGTTGCAAG tccatggtac', 'Tm_NN')\\n    'ACGTTGCAAGTCCATGGTAC'\\n\\n    \"\n    seq = ''.join(seq.split()).upper()\n    seq = str(Seq.Seq(seq).back_transcribe())\n    if method == 'Tm_Wallace':\n        return seq\n    if method == 'Tm_GC':\n        baseset = ('A', 'B', 'C', 'D', 'G', 'H', 'I', 'K', 'M', 'N', 'R', 'S', 'T', 'V', 'W', 'X', 'Y')\n    if method == 'Tm_NN':\n        baseset = ('A', 'C', 'G', 'T', 'I')\n    seq = ''.join([base for base in seq if base in baseset])\n    return seq",
            "def _check(seq, method):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Return a sequence which fulfills the requirements of the given method (PRIVATE).\\n\\n    All Tm methods in this package require the sequence in uppercase format.\\n    Most methods make use of the length of the sequence (directly or\\n    indirectly), which can only be expressed as len(seq) if the sequence does\\n    not contain whitespaces and other non-base characters. RNA sequences are\\n    backtranscribed to DNA. This method is PRIVATE.\\n\\n    Arguments:\\n     - seq: The sequence as given by the user (passed as string).\\n     - method: Tm_Wallace, Tm_GC or Tm_NN.\\n\\n    >>> from Bio.SeqUtils import MeltingTemp as mt\\n    >>> mt._check('10 ACGTTGCAAG tccatggtac', 'Tm_NN')\\n    'ACGTTGCAAGTCCATGGTAC'\\n\\n    \"\n    seq = ''.join(seq.split()).upper()\n    seq = str(Seq.Seq(seq).back_transcribe())\n    if method == 'Tm_Wallace':\n        return seq\n    if method == 'Tm_GC':\n        baseset = ('A', 'B', 'C', 'D', 'G', 'H', 'I', 'K', 'M', 'N', 'R', 'S', 'T', 'V', 'W', 'X', 'Y')\n    if method == 'Tm_NN':\n        baseset = ('A', 'C', 'G', 'T', 'I')\n    seq = ''.join([base for base in seq if base in baseset])\n    return seq",
            "def _check(seq, method):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Return a sequence which fulfills the requirements of the given method (PRIVATE).\\n\\n    All Tm methods in this package require the sequence in uppercase format.\\n    Most methods make use of the length of the sequence (directly or\\n    indirectly), which can only be expressed as len(seq) if the sequence does\\n    not contain whitespaces and other non-base characters. RNA sequences are\\n    backtranscribed to DNA. This method is PRIVATE.\\n\\n    Arguments:\\n     - seq: The sequence as given by the user (passed as string).\\n     - method: Tm_Wallace, Tm_GC or Tm_NN.\\n\\n    >>> from Bio.SeqUtils import MeltingTemp as mt\\n    >>> mt._check('10 ACGTTGCAAG tccatggtac', 'Tm_NN')\\n    'ACGTTGCAAGTCCATGGTAC'\\n\\n    \"\n    seq = ''.join(seq.split()).upper()\n    seq = str(Seq.Seq(seq).back_transcribe())\n    if method == 'Tm_Wallace':\n        return seq\n    if method == 'Tm_GC':\n        baseset = ('A', 'B', 'C', 'D', 'G', 'H', 'I', 'K', 'M', 'N', 'R', 'S', 'T', 'V', 'W', 'X', 'Y')\n    if method == 'Tm_NN':\n        baseset = ('A', 'C', 'G', 'T', 'I')\n    seq = ''.join([base for base in seq if base in baseset])\n    return seq"
        ]
    },
    {
        "func_name": "salt_correction",
        "original": "def salt_correction(Na=0, K=0, Tris=0, Mg=0, dNTPs=0, method=1, seq=None):\n    \"\"\"Calculate a term to correct Tm for salt ions.\n\n    Depending on the Tm calculation, the term will correct Tm or entropy. To\n    calculate corrected Tm values, different operations need to be applied:\n\n     - methods 1-4: Tm(new) = Tm(old) + corr\n     - method 5: deltaS(new) = deltaS(old) + corr\n     - methods 6+7: Tm(new) = 1/(1/Tm(old) + corr)\n\n    Arguments:\n     - Na, K, Tris, Mg, dNTPS: Millimolar concentration of respective ion. To\n       have a simple 'salt correction', just pass Na. If any of K, Tris, Mg and\n       dNTPS is non-zero, a 'sodium-equivalent' concentration is calculated\n       according to von Ahsen et al. (2001, Clin Chem 47: 1956-1961):\n       [Na_eq] = [Na+] + [K+] + [Tris]/2 + 120*([Mg2+] - [dNTPs])^0.5\n       If [dNTPs] >= [Mg2+]: [Na_eq] = [Na+] + [K+] + [Tris]/2\n     - method: Which method to be applied. Methods 1-4 correct Tm, method 5\n       corrects deltaS, methods 6 and 7 correct 1/Tm. The methods are:\n\n       1. 16.6 x log[Na+]\n          (Schildkraut & Lifson (1965), Biopolymers 3: 195-208)\n       2. 16.6 x log([Na+]/(1.0 + 0.7*[Na+]))\n          (Wetmur (1991), Crit Rev Biochem Mol Biol 126: 227-259)\n       3. 12.5 x log(Na+]\n          (SantaLucia et al. (1996), Biochemistry 35: 3555-3562\n       4. 11.7 x log[Na+]\n          (SantaLucia (1998), Proc Natl Acad Sci USA 95: 1460-1465\n       5. Correction for deltaS: 0.368 x (N-1) x ln[Na+]\n          (SantaLucia (1998), Proc Natl Acad Sci USA 95: 1460-1465)\n       6. (4.29(%GC)-3.95)x1e-5 x ln[Na+] + 9.40e-6 x ln[Na+]^2\n          (Owczarzy et al. (2004), Biochemistry 43: 3537-3554)\n       7. Complex formula with decision tree and 7 empirical constants.\n          Mg2+ is corrected for dNTPs binding (if present)\n          (Owczarzy et al. (2008), Biochemistry 47: 5336-5353)\n\n    Examples\n    --------\n    >>> from Bio.SeqUtils.MeltingTemp import salt_correction\n    >>> print('%0.2f' % salt_correction(Na=50, method=1))\n    -21.60\n    >>> print('%0.2f' % salt_correction(Na=50, method=2))\n    -21.85\n    >>> print('%0.2f' % salt_correction(Na=100, Tris=20, method=2))\n    -16.45\n    >>> print('%0.2f' % salt_correction(Na=100, Tris=20, Mg=1.5, method=2))\n    -10.99\n\n    \"\"\"\n    if method in (5, 6, 7) and (not seq):\n        raise ValueError('sequence is missing (is needed to calculate GC content or sequence length).')\n    corr = 0\n    if not method:\n        return corr\n    Mon = Na + K + Tris / 2.0\n    mg = Mg * 0.001\n    if sum((K, Mg, Tris, dNTPs)) > 0 and method != 7 and (dNTPs < Mg):\n        Mon += 120 * math.sqrt(Mg - dNTPs)\n    mon = Mon * 0.001\n    if method in range(1, 7) and (not mon):\n        raise ValueError('Total ion concentration of zero is not allowed in this method.')\n    if method == 1:\n        corr = 16.6 * math.log10(mon)\n    if method == 2:\n        corr = 16.6 * math.log10(mon / (1.0 + 0.7 * mon))\n    if method == 3:\n        corr = 12.5 * math.log10(mon)\n    if method == 4:\n        corr = 11.7 * math.log10(mon)\n    if method == 5:\n        corr = 0.368 * (len(seq) - 1) * math.log(mon)\n    if method == 6:\n        corr = (4.29 * SeqUtils.gc_fraction(seq, 'ignore') - 3.95) * 1e-05 * math.log(mon) + 9.4e-06 * math.log(mon) ** 2\n    if method == 7:\n        (a, b, c, d) = (3.92, -0.911, 6.26, 1.42)\n        (e, f, g) = (-48.2, 52.5, 8.31)\n        if dNTPs > 0:\n            dntps = dNTPs * 0.001\n            ka = 30000.0\n            mg = (-(ka * dntps - ka * mg + 1.0) + math.sqrt((ka * dntps - ka * mg + 1.0) ** 2 + 4.0 * ka * mg)) / (2.0 * ka)\n        if Mon > 0:\n            R = math.sqrt(mg) / mon\n            if R < 0.22:\n                corr = (4.29 * SeqUtils.gc_fraction(seq, 'ignore') - 3.95) * 1e-05 * math.log(mon) + 9.4e-06 * math.log(mon) ** 2\n                return corr\n            elif R < 6.0:\n                a = 3.92 * (0.843 - 0.352 * math.sqrt(mon) * math.log(mon))\n                d = 1.42 * (1.279 - 0.00403 * math.log(mon) - 0.00803 * math.log(mon) ** 2)\n                g = 8.31 * (0.486 - 0.258 * math.log(mon) + 0.00525 * math.log(mon) ** 3)\n        corr = (a + b * math.log(mg) + SeqUtils.gc_fraction(seq, 'ignore') * (c + d * math.log(mg)) + 1 / (2.0 * (len(seq) - 1)) * (e + f * math.log(mg) + g * math.log(mg) ** 2)) * 1e-05\n    if method > 7:\n        raise ValueError(\"Allowed values for parameter 'method' are 1-7.\")\n    return corr",
        "mutated": [
            "def salt_correction(Na=0, K=0, Tris=0, Mg=0, dNTPs=0, method=1, seq=None):\n    if False:\n        i = 10\n    \"Calculate a term to correct Tm for salt ions.\\n\\n    Depending on the Tm calculation, the term will correct Tm or entropy. To\\n    calculate corrected Tm values, different operations need to be applied:\\n\\n     - methods 1-4: Tm(new) = Tm(old) + corr\\n     - method 5: deltaS(new) = deltaS(old) + corr\\n     - methods 6+7: Tm(new) = 1/(1/Tm(old) + corr)\\n\\n    Arguments:\\n     - Na, K, Tris, Mg, dNTPS: Millimolar concentration of respective ion. To\\n       have a simple 'salt correction', just pass Na. If any of K, Tris, Mg and\\n       dNTPS is non-zero, a 'sodium-equivalent' concentration is calculated\\n       according to von Ahsen et al. (2001, Clin Chem 47: 1956-1961):\\n       [Na_eq] = [Na+] + [K+] + [Tris]/2 + 120*([Mg2+] - [dNTPs])^0.5\\n       If [dNTPs] >= [Mg2+]: [Na_eq] = [Na+] + [K+] + [Tris]/2\\n     - method: Which method to be applied. Methods 1-4 correct Tm, method 5\\n       corrects deltaS, methods 6 and 7 correct 1/Tm. The methods are:\\n\\n       1. 16.6 x log[Na+]\\n          (Schildkraut & Lifson (1965), Biopolymers 3: 195-208)\\n       2. 16.6 x log([Na+]/(1.0 + 0.7*[Na+]))\\n          (Wetmur (1991), Crit Rev Biochem Mol Biol 126: 227-259)\\n       3. 12.5 x log(Na+]\\n          (SantaLucia et al. (1996), Biochemistry 35: 3555-3562\\n       4. 11.7 x log[Na+]\\n          (SantaLucia (1998), Proc Natl Acad Sci USA 95: 1460-1465\\n       5. Correction for deltaS: 0.368 x (N-1) x ln[Na+]\\n          (SantaLucia (1998), Proc Natl Acad Sci USA 95: 1460-1465)\\n       6. (4.29(%GC)-3.95)x1e-5 x ln[Na+] + 9.40e-6 x ln[Na+]^2\\n          (Owczarzy et al. (2004), Biochemistry 43: 3537-3554)\\n       7. Complex formula with decision tree and 7 empirical constants.\\n          Mg2+ is corrected for dNTPs binding (if present)\\n          (Owczarzy et al. (2008), Biochemistry 47: 5336-5353)\\n\\n    Examples\\n    --------\\n    >>> from Bio.SeqUtils.MeltingTemp import salt_correction\\n    >>> print('%0.2f' % salt_correction(Na=50, method=1))\\n    -21.60\\n    >>> print('%0.2f' % salt_correction(Na=50, method=2))\\n    -21.85\\n    >>> print('%0.2f' % salt_correction(Na=100, Tris=20, method=2))\\n    -16.45\\n    >>> print('%0.2f' % salt_correction(Na=100, Tris=20, Mg=1.5, method=2))\\n    -10.99\\n\\n    \"\n    if method in (5, 6, 7) and (not seq):\n        raise ValueError('sequence is missing (is needed to calculate GC content or sequence length).')\n    corr = 0\n    if not method:\n        return corr\n    Mon = Na + K + Tris / 2.0\n    mg = Mg * 0.001\n    if sum((K, Mg, Tris, dNTPs)) > 0 and method != 7 and (dNTPs < Mg):\n        Mon += 120 * math.sqrt(Mg - dNTPs)\n    mon = Mon * 0.001\n    if method in range(1, 7) and (not mon):\n        raise ValueError('Total ion concentration of zero is not allowed in this method.')\n    if method == 1:\n        corr = 16.6 * math.log10(mon)\n    if method == 2:\n        corr = 16.6 * math.log10(mon / (1.0 + 0.7 * mon))\n    if method == 3:\n        corr = 12.5 * math.log10(mon)\n    if method == 4:\n        corr = 11.7 * math.log10(mon)\n    if method == 5:\n        corr = 0.368 * (len(seq) - 1) * math.log(mon)\n    if method == 6:\n        corr = (4.29 * SeqUtils.gc_fraction(seq, 'ignore') - 3.95) * 1e-05 * math.log(mon) + 9.4e-06 * math.log(mon) ** 2\n    if method == 7:\n        (a, b, c, d) = (3.92, -0.911, 6.26, 1.42)\n        (e, f, g) = (-48.2, 52.5, 8.31)\n        if dNTPs > 0:\n            dntps = dNTPs * 0.001\n            ka = 30000.0\n            mg = (-(ka * dntps - ka * mg + 1.0) + math.sqrt((ka * dntps - ka * mg + 1.0) ** 2 + 4.0 * ka * mg)) / (2.0 * ka)\n        if Mon > 0:\n            R = math.sqrt(mg) / mon\n            if R < 0.22:\n                corr = (4.29 * SeqUtils.gc_fraction(seq, 'ignore') - 3.95) * 1e-05 * math.log(mon) + 9.4e-06 * math.log(mon) ** 2\n                return corr\n            elif R < 6.0:\n                a = 3.92 * (0.843 - 0.352 * math.sqrt(mon) * math.log(mon))\n                d = 1.42 * (1.279 - 0.00403 * math.log(mon) - 0.00803 * math.log(mon) ** 2)\n                g = 8.31 * (0.486 - 0.258 * math.log(mon) + 0.00525 * math.log(mon) ** 3)\n        corr = (a + b * math.log(mg) + SeqUtils.gc_fraction(seq, 'ignore') * (c + d * math.log(mg)) + 1 / (2.0 * (len(seq) - 1)) * (e + f * math.log(mg) + g * math.log(mg) ** 2)) * 1e-05\n    if method > 7:\n        raise ValueError(\"Allowed values for parameter 'method' are 1-7.\")\n    return corr",
            "def salt_correction(Na=0, K=0, Tris=0, Mg=0, dNTPs=0, method=1, seq=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Calculate a term to correct Tm for salt ions.\\n\\n    Depending on the Tm calculation, the term will correct Tm or entropy. To\\n    calculate corrected Tm values, different operations need to be applied:\\n\\n     - methods 1-4: Tm(new) = Tm(old) + corr\\n     - method 5: deltaS(new) = deltaS(old) + corr\\n     - methods 6+7: Tm(new) = 1/(1/Tm(old) + corr)\\n\\n    Arguments:\\n     - Na, K, Tris, Mg, dNTPS: Millimolar concentration of respective ion. To\\n       have a simple 'salt correction', just pass Na. If any of K, Tris, Mg and\\n       dNTPS is non-zero, a 'sodium-equivalent' concentration is calculated\\n       according to von Ahsen et al. (2001, Clin Chem 47: 1956-1961):\\n       [Na_eq] = [Na+] + [K+] + [Tris]/2 + 120*([Mg2+] - [dNTPs])^0.5\\n       If [dNTPs] >= [Mg2+]: [Na_eq] = [Na+] + [K+] + [Tris]/2\\n     - method: Which method to be applied. Methods 1-4 correct Tm, method 5\\n       corrects deltaS, methods 6 and 7 correct 1/Tm. The methods are:\\n\\n       1. 16.6 x log[Na+]\\n          (Schildkraut & Lifson (1965), Biopolymers 3: 195-208)\\n       2. 16.6 x log([Na+]/(1.0 + 0.7*[Na+]))\\n          (Wetmur (1991), Crit Rev Biochem Mol Biol 126: 227-259)\\n       3. 12.5 x log(Na+]\\n          (SantaLucia et al. (1996), Biochemistry 35: 3555-3562\\n       4. 11.7 x log[Na+]\\n          (SantaLucia (1998), Proc Natl Acad Sci USA 95: 1460-1465\\n       5. Correction for deltaS: 0.368 x (N-1) x ln[Na+]\\n          (SantaLucia (1998), Proc Natl Acad Sci USA 95: 1460-1465)\\n       6. (4.29(%GC)-3.95)x1e-5 x ln[Na+] + 9.40e-6 x ln[Na+]^2\\n          (Owczarzy et al. (2004), Biochemistry 43: 3537-3554)\\n       7. Complex formula with decision tree and 7 empirical constants.\\n          Mg2+ is corrected for dNTPs binding (if present)\\n          (Owczarzy et al. (2008), Biochemistry 47: 5336-5353)\\n\\n    Examples\\n    --------\\n    >>> from Bio.SeqUtils.MeltingTemp import salt_correction\\n    >>> print('%0.2f' % salt_correction(Na=50, method=1))\\n    -21.60\\n    >>> print('%0.2f' % salt_correction(Na=50, method=2))\\n    -21.85\\n    >>> print('%0.2f' % salt_correction(Na=100, Tris=20, method=2))\\n    -16.45\\n    >>> print('%0.2f' % salt_correction(Na=100, Tris=20, Mg=1.5, method=2))\\n    -10.99\\n\\n    \"\n    if method in (5, 6, 7) and (not seq):\n        raise ValueError('sequence is missing (is needed to calculate GC content or sequence length).')\n    corr = 0\n    if not method:\n        return corr\n    Mon = Na + K + Tris / 2.0\n    mg = Mg * 0.001\n    if sum((K, Mg, Tris, dNTPs)) > 0 and method != 7 and (dNTPs < Mg):\n        Mon += 120 * math.sqrt(Mg - dNTPs)\n    mon = Mon * 0.001\n    if method in range(1, 7) and (not mon):\n        raise ValueError('Total ion concentration of zero is not allowed in this method.')\n    if method == 1:\n        corr = 16.6 * math.log10(mon)\n    if method == 2:\n        corr = 16.6 * math.log10(mon / (1.0 + 0.7 * mon))\n    if method == 3:\n        corr = 12.5 * math.log10(mon)\n    if method == 4:\n        corr = 11.7 * math.log10(mon)\n    if method == 5:\n        corr = 0.368 * (len(seq) - 1) * math.log(mon)\n    if method == 6:\n        corr = (4.29 * SeqUtils.gc_fraction(seq, 'ignore') - 3.95) * 1e-05 * math.log(mon) + 9.4e-06 * math.log(mon) ** 2\n    if method == 7:\n        (a, b, c, d) = (3.92, -0.911, 6.26, 1.42)\n        (e, f, g) = (-48.2, 52.5, 8.31)\n        if dNTPs > 0:\n            dntps = dNTPs * 0.001\n            ka = 30000.0\n            mg = (-(ka * dntps - ka * mg + 1.0) + math.sqrt((ka * dntps - ka * mg + 1.0) ** 2 + 4.0 * ka * mg)) / (2.0 * ka)\n        if Mon > 0:\n            R = math.sqrt(mg) / mon\n            if R < 0.22:\n                corr = (4.29 * SeqUtils.gc_fraction(seq, 'ignore') - 3.95) * 1e-05 * math.log(mon) + 9.4e-06 * math.log(mon) ** 2\n                return corr\n            elif R < 6.0:\n                a = 3.92 * (0.843 - 0.352 * math.sqrt(mon) * math.log(mon))\n                d = 1.42 * (1.279 - 0.00403 * math.log(mon) - 0.00803 * math.log(mon) ** 2)\n                g = 8.31 * (0.486 - 0.258 * math.log(mon) + 0.00525 * math.log(mon) ** 3)\n        corr = (a + b * math.log(mg) + SeqUtils.gc_fraction(seq, 'ignore') * (c + d * math.log(mg)) + 1 / (2.0 * (len(seq) - 1)) * (e + f * math.log(mg) + g * math.log(mg) ** 2)) * 1e-05\n    if method > 7:\n        raise ValueError(\"Allowed values for parameter 'method' are 1-7.\")\n    return corr",
            "def salt_correction(Na=0, K=0, Tris=0, Mg=0, dNTPs=0, method=1, seq=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Calculate a term to correct Tm for salt ions.\\n\\n    Depending on the Tm calculation, the term will correct Tm or entropy. To\\n    calculate corrected Tm values, different operations need to be applied:\\n\\n     - methods 1-4: Tm(new) = Tm(old) + corr\\n     - method 5: deltaS(new) = deltaS(old) + corr\\n     - methods 6+7: Tm(new) = 1/(1/Tm(old) + corr)\\n\\n    Arguments:\\n     - Na, K, Tris, Mg, dNTPS: Millimolar concentration of respective ion. To\\n       have a simple 'salt correction', just pass Na. If any of K, Tris, Mg and\\n       dNTPS is non-zero, a 'sodium-equivalent' concentration is calculated\\n       according to von Ahsen et al. (2001, Clin Chem 47: 1956-1961):\\n       [Na_eq] = [Na+] + [K+] + [Tris]/2 + 120*([Mg2+] - [dNTPs])^0.5\\n       If [dNTPs] >= [Mg2+]: [Na_eq] = [Na+] + [K+] + [Tris]/2\\n     - method: Which method to be applied. Methods 1-4 correct Tm, method 5\\n       corrects deltaS, methods 6 and 7 correct 1/Tm. The methods are:\\n\\n       1. 16.6 x log[Na+]\\n          (Schildkraut & Lifson (1965), Biopolymers 3: 195-208)\\n       2. 16.6 x log([Na+]/(1.0 + 0.7*[Na+]))\\n          (Wetmur (1991), Crit Rev Biochem Mol Biol 126: 227-259)\\n       3. 12.5 x log(Na+]\\n          (SantaLucia et al. (1996), Biochemistry 35: 3555-3562\\n       4. 11.7 x log[Na+]\\n          (SantaLucia (1998), Proc Natl Acad Sci USA 95: 1460-1465\\n       5. Correction for deltaS: 0.368 x (N-1) x ln[Na+]\\n          (SantaLucia (1998), Proc Natl Acad Sci USA 95: 1460-1465)\\n       6. (4.29(%GC)-3.95)x1e-5 x ln[Na+] + 9.40e-6 x ln[Na+]^2\\n          (Owczarzy et al. (2004), Biochemistry 43: 3537-3554)\\n       7. Complex formula with decision tree and 7 empirical constants.\\n          Mg2+ is corrected for dNTPs binding (if present)\\n          (Owczarzy et al. (2008), Biochemistry 47: 5336-5353)\\n\\n    Examples\\n    --------\\n    >>> from Bio.SeqUtils.MeltingTemp import salt_correction\\n    >>> print('%0.2f' % salt_correction(Na=50, method=1))\\n    -21.60\\n    >>> print('%0.2f' % salt_correction(Na=50, method=2))\\n    -21.85\\n    >>> print('%0.2f' % salt_correction(Na=100, Tris=20, method=2))\\n    -16.45\\n    >>> print('%0.2f' % salt_correction(Na=100, Tris=20, Mg=1.5, method=2))\\n    -10.99\\n\\n    \"\n    if method in (5, 6, 7) and (not seq):\n        raise ValueError('sequence is missing (is needed to calculate GC content or sequence length).')\n    corr = 0\n    if not method:\n        return corr\n    Mon = Na + K + Tris / 2.0\n    mg = Mg * 0.001\n    if sum((K, Mg, Tris, dNTPs)) > 0 and method != 7 and (dNTPs < Mg):\n        Mon += 120 * math.sqrt(Mg - dNTPs)\n    mon = Mon * 0.001\n    if method in range(1, 7) and (not mon):\n        raise ValueError('Total ion concentration of zero is not allowed in this method.')\n    if method == 1:\n        corr = 16.6 * math.log10(mon)\n    if method == 2:\n        corr = 16.6 * math.log10(mon / (1.0 + 0.7 * mon))\n    if method == 3:\n        corr = 12.5 * math.log10(mon)\n    if method == 4:\n        corr = 11.7 * math.log10(mon)\n    if method == 5:\n        corr = 0.368 * (len(seq) - 1) * math.log(mon)\n    if method == 6:\n        corr = (4.29 * SeqUtils.gc_fraction(seq, 'ignore') - 3.95) * 1e-05 * math.log(mon) + 9.4e-06 * math.log(mon) ** 2\n    if method == 7:\n        (a, b, c, d) = (3.92, -0.911, 6.26, 1.42)\n        (e, f, g) = (-48.2, 52.5, 8.31)\n        if dNTPs > 0:\n            dntps = dNTPs * 0.001\n            ka = 30000.0\n            mg = (-(ka * dntps - ka * mg + 1.0) + math.sqrt((ka * dntps - ka * mg + 1.0) ** 2 + 4.0 * ka * mg)) / (2.0 * ka)\n        if Mon > 0:\n            R = math.sqrt(mg) / mon\n            if R < 0.22:\n                corr = (4.29 * SeqUtils.gc_fraction(seq, 'ignore') - 3.95) * 1e-05 * math.log(mon) + 9.4e-06 * math.log(mon) ** 2\n                return corr\n            elif R < 6.0:\n                a = 3.92 * (0.843 - 0.352 * math.sqrt(mon) * math.log(mon))\n                d = 1.42 * (1.279 - 0.00403 * math.log(mon) - 0.00803 * math.log(mon) ** 2)\n                g = 8.31 * (0.486 - 0.258 * math.log(mon) + 0.00525 * math.log(mon) ** 3)\n        corr = (a + b * math.log(mg) + SeqUtils.gc_fraction(seq, 'ignore') * (c + d * math.log(mg)) + 1 / (2.0 * (len(seq) - 1)) * (e + f * math.log(mg) + g * math.log(mg) ** 2)) * 1e-05\n    if method > 7:\n        raise ValueError(\"Allowed values for parameter 'method' are 1-7.\")\n    return corr",
            "def salt_correction(Na=0, K=0, Tris=0, Mg=0, dNTPs=0, method=1, seq=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Calculate a term to correct Tm for salt ions.\\n\\n    Depending on the Tm calculation, the term will correct Tm or entropy. To\\n    calculate corrected Tm values, different operations need to be applied:\\n\\n     - methods 1-4: Tm(new) = Tm(old) + corr\\n     - method 5: deltaS(new) = deltaS(old) + corr\\n     - methods 6+7: Tm(new) = 1/(1/Tm(old) + corr)\\n\\n    Arguments:\\n     - Na, K, Tris, Mg, dNTPS: Millimolar concentration of respective ion. To\\n       have a simple 'salt correction', just pass Na. If any of K, Tris, Mg and\\n       dNTPS is non-zero, a 'sodium-equivalent' concentration is calculated\\n       according to von Ahsen et al. (2001, Clin Chem 47: 1956-1961):\\n       [Na_eq] = [Na+] + [K+] + [Tris]/2 + 120*([Mg2+] - [dNTPs])^0.5\\n       If [dNTPs] >= [Mg2+]: [Na_eq] = [Na+] + [K+] + [Tris]/2\\n     - method: Which method to be applied. Methods 1-4 correct Tm, method 5\\n       corrects deltaS, methods 6 and 7 correct 1/Tm. The methods are:\\n\\n       1. 16.6 x log[Na+]\\n          (Schildkraut & Lifson (1965), Biopolymers 3: 195-208)\\n       2. 16.6 x log([Na+]/(1.0 + 0.7*[Na+]))\\n          (Wetmur (1991), Crit Rev Biochem Mol Biol 126: 227-259)\\n       3. 12.5 x log(Na+]\\n          (SantaLucia et al. (1996), Biochemistry 35: 3555-3562\\n       4. 11.7 x log[Na+]\\n          (SantaLucia (1998), Proc Natl Acad Sci USA 95: 1460-1465\\n       5. Correction for deltaS: 0.368 x (N-1) x ln[Na+]\\n          (SantaLucia (1998), Proc Natl Acad Sci USA 95: 1460-1465)\\n       6. (4.29(%GC)-3.95)x1e-5 x ln[Na+] + 9.40e-6 x ln[Na+]^2\\n          (Owczarzy et al. (2004), Biochemistry 43: 3537-3554)\\n       7. Complex formula with decision tree and 7 empirical constants.\\n          Mg2+ is corrected for dNTPs binding (if present)\\n          (Owczarzy et al. (2008), Biochemistry 47: 5336-5353)\\n\\n    Examples\\n    --------\\n    >>> from Bio.SeqUtils.MeltingTemp import salt_correction\\n    >>> print('%0.2f' % salt_correction(Na=50, method=1))\\n    -21.60\\n    >>> print('%0.2f' % salt_correction(Na=50, method=2))\\n    -21.85\\n    >>> print('%0.2f' % salt_correction(Na=100, Tris=20, method=2))\\n    -16.45\\n    >>> print('%0.2f' % salt_correction(Na=100, Tris=20, Mg=1.5, method=2))\\n    -10.99\\n\\n    \"\n    if method in (5, 6, 7) and (not seq):\n        raise ValueError('sequence is missing (is needed to calculate GC content or sequence length).')\n    corr = 0\n    if not method:\n        return corr\n    Mon = Na + K + Tris / 2.0\n    mg = Mg * 0.001\n    if sum((K, Mg, Tris, dNTPs)) > 0 and method != 7 and (dNTPs < Mg):\n        Mon += 120 * math.sqrt(Mg - dNTPs)\n    mon = Mon * 0.001\n    if method in range(1, 7) and (not mon):\n        raise ValueError('Total ion concentration of zero is not allowed in this method.')\n    if method == 1:\n        corr = 16.6 * math.log10(mon)\n    if method == 2:\n        corr = 16.6 * math.log10(mon / (1.0 + 0.7 * mon))\n    if method == 3:\n        corr = 12.5 * math.log10(mon)\n    if method == 4:\n        corr = 11.7 * math.log10(mon)\n    if method == 5:\n        corr = 0.368 * (len(seq) - 1) * math.log(mon)\n    if method == 6:\n        corr = (4.29 * SeqUtils.gc_fraction(seq, 'ignore') - 3.95) * 1e-05 * math.log(mon) + 9.4e-06 * math.log(mon) ** 2\n    if method == 7:\n        (a, b, c, d) = (3.92, -0.911, 6.26, 1.42)\n        (e, f, g) = (-48.2, 52.5, 8.31)\n        if dNTPs > 0:\n            dntps = dNTPs * 0.001\n            ka = 30000.0\n            mg = (-(ka * dntps - ka * mg + 1.0) + math.sqrt((ka * dntps - ka * mg + 1.0) ** 2 + 4.0 * ka * mg)) / (2.0 * ka)\n        if Mon > 0:\n            R = math.sqrt(mg) / mon\n            if R < 0.22:\n                corr = (4.29 * SeqUtils.gc_fraction(seq, 'ignore') - 3.95) * 1e-05 * math.log(mon) + 9.4e-06 * math.log(mon) ** 2\n                return corr\n            elif R < 6.0:\n                a = 3.92 * (0.843 - 0.352 * math.sqrt(mon) * math.log(mon))\n                d = 1.42 * (1.279 - 0.00403 * math.log(mon) - 0.00803 * math.log(mon) ** 2)\n                g = 8.31 * (0.486 - 0.258 * math.log(mon) + 0.00525 * math.log(mon) ** 3)\n        corr = (a + b * math.log(mg) + SeqUtils.gc_fraction(seq, 'ignore') * (c + d * math.log(mg)) + 1 / (2.0 * (len(seq) - 1)) * (e + f * math.log(mg) + g * math.log(mg) ** 2)) * 1e-05\n    if method > 7:\n        raise ValueError(\"Allowed values for parameter 'method' are 1-7.\")\n    return corr",
            "def salt_correction(Na=0, K=0, Tris=0, Mg=0, dNTPs=0, method=1, seq=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Calculate a term to correct Tm for salt ions.\\n\\n    Depending on the Tm calculation, the term will correct Tm or entropy. To\\n    calculate corrected Tm values, different operations need to be applied:\\n\\n     - methods 1-4: Tm(new) = Tm(old) + corr\\n     - method 5: deltaS(new) = deltaS(old) + corr\\n     - methods 6+7: Tm(new) = 1/(1/Tm(old) + corr)\\n\\n    Arguments:\\n     - Na, K, Tris, Mg, dNTPS: Millimolar concentration of respective ion. To\\n       have a simple 'salt correction', just pass Na. If any of K, Tris, Mg and\\n       dNTPS is non-zero, a 'sodium-equivalent' concentration is calculated\\n       according to von Ahsen et al. (2001, Clin Chem 47: 1956-1961):\\n       [Na_eq] = [Na+] + [K+] + [Tris]/2 + 120*([Mg2+] - [dNTPs])^0.5\\n       If [dNTPs] >= [Mg2+]: [Na_eq] = [Na+] + [K+] + [Tris]/2\\n     - method: Which method to be applied. Methods 1-4 correct Tm, method 5\\n       corrects deltaS, methods 6 and 7 correct 1/Tm. The methods are:\\n\\n       1. 16.6 x log[Na+]\\n          (Schildkraut & Lifson (1965), Biopolymers 3: 195-208)\\n       2. 16.6 x log([Na+]/(1.0 + 0.7*[Na+]))\\n          (Wetmur (1991), Crit Rev Biochem Mol Biol 126: 227-259)\\n       3. 12.5 x log(Na+]\\n          (SantaLucia et al. (1996), Biochemistry 35: 3555-3562\\n       4. 11.7 x log[Na+]\\n          (SantaLucia (1998), Proc Natl Acad Sci USA 95: 1460-1465\\n       5. Correction for deltaS: 0.368 x (N-1) x ln[Na+]\\n          (SantaLucia (1998), Proc Natl Acad Sci USA 95: 1460-1465)\\n       6. (4.29(%GC)-3.95)x1e-5 x ln[Na+] + 9.40e-6 x ln[Na+]^2\\n          (Owczarzy et al. (2004), Biochemistry 43: 3537-3554)\\n       7. Complex formula with decision tree and 7 empirical constants.\\n          Mg2+ is corrected for dNTPs binding (if present)\\n          (Owczarzy et al. (2008), Biochemistry 47: 5336-5353)\\n\\n    Examples\\n    --------\\n    >>> from Bio.SeqUtils.MeltingTemp import salt_correction\\n    >>> print('%0.2f' % salt_correction(Na=50, method=1))\\n    -21.60\\n    >>> print('%0.2f' % salt_correction(Na=50, method=2))\\n    -21.85\\n    >>> print('%0.2f' % salt_correction(Na=100, Tris=20, method=2))\\n    -16.45\\n    >>> print('%0.2f' % salt_correction(Na=100, Tris=20, Mg=1.5, method=2))\\n    -10.99\\n\\n    \"\n    if method in (5, 6, 7) and (not seq):\n        raise ValueError('sequence is missing (is needed to calculate GC content or sequence length).')\n    corr = 0\n    if not method:\n        return corr\n    Mon = Na + K + Tris / 2.0\n    mg = Mg * 0.001\n    if sum((K, Mg, Tris, dNTPs)) > 0 and method != 7 and (dNTPs < Mg):\n        Mon += 120 * math.sqrt(Mg - dNTPs)\n    mon = Mon * 0.001\n    if method in range(1, 7) and (not mon):\n        raise ValueError('Total ion concentration of zero is not allowed in this method.')\n    if method == 1:\n        corr = 16.6 * math.log10(mon)\n    if method == 2:\n        corr = 16.6 * math.log10(mon / (1.0 + 0.7 * mon))\n    if method == 3:\n        corr = 12.5 * math.log10(mon)\n    if method == 4:\n        corr = 11.7 * math.log10(mon)\n    if method == 5:\n        corr = 0.368 * (len(seq) - 1) * math.log(mon)\n    if method == 6:\n        corr = (4.29 * SeqUtils.gc_fraction(seq, 'ignore') - 3.95) * 1e-05 * math.log(mon) + 9.4e-06 * math.log(mon) ** 2\n    if method == 7:\n        (a, b, c, d) = (3.92, -0.911, 6.26, 1.42)\n        (e, f, g) = (-48.2, 52.5, 8.31)\n        if dNTPs > 0:\n            dntps = dNTPs * 0.001\n            ka = 30000.0\n            mg = (-(ka * dntps - ka * mg + 1.0) + math.sqrt((ka * dntps - ka * mg + 1.0) ** 2 + 4.0 * ka * mg)) / (2.0 * ka)\n        if Mon > 0:\n            R = math.sqrt(mg) / mon\n            if R < 0.22:\n                corr = (4.29 * SeqUtils.gc_fraction(seq, 'ignore') - 3.95) * 1e-05 * math.log(mon) + 9.4e-06 * math.log(mon) ** 2\n                return corr\n            elif R < 6.0:\n                a = 3.92 * (0.843 - 0.352 * math.sqrt(mon) * math.log(mon))\n                d = 1.42 * (1.279 - 0.00403 * math.log(mon) - 0.00803 * math.log(mon) ** 2)\n                g = 8.31 * (0.486 - 0.258 * math.log(mon) + 0.00525 * math.log(mon) ** 3)\n        corr = (a + b * math.log(mg) + SeqUtils.gc_fraction(seq, 'ignore') * (c + d * math.log(mg)) + 1 / (2.0 * (len(seq) - 1)) * (e + f * math.log(mg) + g * math.log(mg) ** 2)) * 1e-05\n    if method > 7:\n        raise ValueError(\"Allowed values for parameter 'method' are 1-7.\")\n    return corr"
        ]
    },
    {
        "func_name": "chem_correction",
        "original": "def chem_correction(melting_temp, DMSO=0, fmd=0, DMSOfactor=0.75, fmdfactor=0.65, fmdmethod=1, GC=None):\n    \"\"\"Correct a given Tm for DMSO and formamide.\n\n    Please note that these corrections are +/- rough approximations.\n\n    Arguments:\n     - melting_temp: Melting temperature.\n     - DMSO: Percent DMSO.\n     - fmd: Formamide concentration in %(fmdmethod=1) or molar (fmdmethod=2).\n     - DMSOfactor: How much should Tm decreases per percent DMSO. Default=0.65\n       (von Ahsen et al. 2001). Other published values are 0.5, 0.6 and 0.675.\n     - fmdfactor: How much should Tm decrease per percent formamide.\n       Default=0.65. Several papers report factors between 0.6 and 0.72.\n     - fmdmethod:\n\n         1. Tm = Tm - factor(%formamide) (Default)\n         2. Tm = Tm + (0.453(f(GC)) - 2.88) x [formamide]\n\n       Here f(GC) is fraction of GC.\n       Note (again) that in fmdmethod=1 formamide concentration is given in %,\n       while in fmdmethod=2 it is given in molar.\n     - GC: GC content in percent.\n\n    Examples:\n        >>> from Bio.SeqUtils import MeltingTemp as mt\n        >>> mt.chem_correction(70)\n        70\n        >>> print('%0.2f' % mt.chem_correction(70, DMSO=3))\n        67.75\n        >>> print('%0.2f' % mt.chem_correction(70, fmd=5))\n        66.75\n        >>> print('%0.2f' % mt.chem_correction(70, fmdmethod=2, fmd=1.25,\n        ...                                    GC=50))\n        66.68\n\n    \"\"\"\n    if DMSO:\n        melting_temp -= DMSOfactor * DMSO\n    if fmd:\n        if fmdmethod == 1:\n            melting_temp -= fmdfactor * fmd\n        if fmdmethod == 2:\n            if GC is None or GC < 0:\n                raise ValueError(\"'GC' is missing or negative\")\n            melting_temp += (0.453 * (GC / 100.0) - 2.88) * fmd\n        if fmdmethod not in (1, 2):\n            raise ValueError(\"'fmdmethod' must be 1 or 2\")\n    return melting_temp",
        "mutated": [
            "def chem_correction(melting_temp, DMSO=0, fmd=0, DMSOfactor=0.75, fmdfactor=0.65, fmdmethod=1, GC=None):\n    if False:\n        i = 10\n    \"Correct a given Tm for DMSO and formamide.\\n\\n    Please note that these corrections are +/- rough approximations.\\n\\n    Arguments:\\n     - melting_temp: Melting temperature.\\n     - DMSO: Percent DMSO.\\n     - fmd: Formamide concentration in %(fmdmethod=1) or molar (fmdmethod=2).\\n     - DMSOfactor: How much should Tm decreases per percent DMSO. Default=0.65\\n       (von Ahsen et al. 2001). Other published values are 0.5, 0.6 and 0.675.\\n     - fmdfactor: How much should Tm decrease per percent formamide.\\n       Default=0.65. Several papers report factors between 0.6 and 0.72.\\n     - fmdmethod:\\n\\n         1. Tm = Tm - factor(%formamide) (Default)\\n         2. Tm = Tm + (0.453(f(GC)) - 2.88) x [formamide]\\n\\n       Here f(GC) is fraction of GC.\\n       Note (again) that in fmdmethod=1 formamide concentration is given in %,\\n       while in fmdmethod=2 it is given in molar.\\n     - GC: GC content in percent.\\n\\n    Examples:\\n        >>> from Bio.SeqUtils import MeltingTemp as mt\\n        >>> mt.chem_correction(70)\\n        70\\n        >>> print('%0.2f' % mt.chem_correction(70, DMSO=3))\\n        67.75\\n        >>> print('%0.2f' % mt.chem_correction(70, fmd=5))\\n        66.75\\n        >>> print('%0.2f' % mt.chem_correction(70, fmdmethod=2, fmd=1.25,\\n        ...                                    GC=50))\\n        66.68\\n\\n    \"\n    if DMSO:\n        melting_temp -= DMSOfactor * DMSO\n    if fmd:\n        if fmdmethod == 1:\n            melting_temp -= fmdfactor * fmd\n        if fmdmethod == 2:\n            if GC is None or GC < 0:\n                raise ValueError(\"'GC' is missing or negative\")\n            melting_temp += (0.453 * (GC / 100.0) - 2.88) * fmd\n        if fmdmethod not in (1, 2):\n            raise ValueError(\"'fmdmethod' must be 1 or 2\")\n    return melting_temp",
            "def chem_correction(melting_temp, DMSO=0, fmd=0, DMSOfactor=0.75, fmdfactor=0.65, fmdmethod=1, GC=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Correct a given Tm for DMSO and formamide.\\n\\n    Please note that these corrections are +/- rough approximations.\\n\\n    Arguments:\\n     - melting_temp: Melting temperature.\\n     - DMSO: Percent DMSO.\\n     - fmd: Formamide concentration in %(fmdmethod=1) or molar (fmdmethod=2).\\n     - DMSOfactor: How much should Tm decreases per percent DMSO. Default=0.65\\n       (von Ahsen et al. 2001). Other published values are 0.5, 0.6 and 0.675.\\n     - fmdfactor: How much should Tm decrease per percent formamide.\\n       Default=0.65. Several papers report factors between 0.6 and 0.72.\\n     - fmdmethod:\\n\\n         1. Tm = Tm - factor(%formamide) (Default)\\n         2. Tm = Tm + (0.453(f(GC)) - 2.88) x [formamide]\\n\\n       Here f(GC) is fraction of GC.\\n       Note (again) that in fmdmethod=1 formamide concentration is given in %,\\n       while in fmdmethod=2 it is given in molar.\\n     - GC: GC content in percent.\\n\\n    Examples:\\n        >>> from Bio.SeqUtils import MeltingTemp as mt\\n        >>> mt.chem_correction(70)\\n        70\\n        >>> print('%0.2f' % mt.chem_correction(70, DMSO=3))\\n        67.75\\n        >>> print('%0.2f' % mt.chem_correction(70, fmd=5))\\n        66.75\\n        >>> print('%0.2f' % mt.chem_correction(70, fmdmethod=2, fmd=1.25,\\n        ...                                    GC=50))\\n        66.68\\n\\n    \"\n    if DMSO:\n        melting_temp -= DMSOfactor * DMSO\n    if fmd:\n        if fmdmethod == 1:\n            melting_temp -= fmdfactor * fmd\n        if fmdmethod == 2:\n            if GC is None or GC < 0:\n                raise ValueError(\"'GC' is missing or negative\")\n            melting_temp += (0.453 * (GC / 100.0) - 2.88) * fmd\n        if fmdmethod not in (1, 2):\n            raise ValueError(\"'fmdmethod' must be 1 or 2\")\n    return melting_temp",
            "def chem_correction(melting_temp, DMSO=0, fmd=0, DMSOfactor=0.75, fmdfactor=0.65, fmdmethod=1, GC=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Correct a given Tm for DMSO and formamide.\\n\\n    Please note that these corrections are +/- rough approximations.\\n\\n    Arguments:\\n     - melting_temp: Melting temperature.\\n     - DMSO: Percent DMSO.\\n     - fmd: Formamide concentration in %(fmdmethod=1) or molar (fmdmethod=2).\\n     - DMSOfactor: How much should Tm decreases per percent DMSO. Default=0.65\\n       (von Ahsen et al. 2001). Other published values are 0.5, 0.6 and 0.675.\\n     - fmdfactor: How much should Tm decrease per percent formamide.\\n       Default=0.65. Several papers report factors between 0.6 and 0.72.\\n     - fmdmethod:\\n\\n         1. Tm = Tm - factor(%formamide) (Default)\\n         2. Tm = Tm + (0.453(f(GC)) - 2.88) x [formamide]\\n\\n       Here f(GC) is fraction of GC.\\n       Note (again) that in fmdmethod=1 formamide concentration is given in %,\\n       while in fmdmethod=2 it is given in molar.\\n     - GC: GC content in percent.\\n\\n    Examples:\\n        >>> from Bio.SeqUtils import MeltingTemp as mt\\n        >>> mt.chem_correction(70)\\n        70\\n        >>> print('%0.2f' % mt.chem_correction(70, DMSO=3))\\n        67.75\\n        >>> print('%0.2f' % mt.chem_correction(70, fmd=5))\\n        66.75\\n        >>> print('%0.2f' % mt.chem_correction(70, fmdmethod=2, fmd=1.25,\\n        ...                                    GC=50))\\n        66.68\\n\\n    \"\n    if DMSO:\n        melting_temp -= DMSOfactor * DMSO\n    if fmd:\n        if fmdmethod == 1:\n            melting_temp -= fmdfactor * fmd\n        if fmdmethod == 2:\n            if GC is None or GC < 0:\n                raise ValueError(\"'GC' is missing or negative\")\n            melting_temp += (0.453 * (GC / 100.0) - 2.88) * fmd\n        if fmdmethod not in (1, 2):\n            raise ValueError(\"'fmdmethod' must be 1 or 2\")\n    return melting_temp",
            "def chem_correction(melting_temp, DMSO=0, fmd=0, DMSOfactor=0.75, fmdfactor=0.65, fmdmethod=1, GC=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Correct a given Tm for DMSO and formamide.\\n\\n    Please note that these corrections are +/- rough approximations.\\n\\n    Arguments:\\n     - melting_temp: Melting temperature.\\n     - DMSO: Percent DMSO.\\n     - fmd: Formamide concentration in %(fmdmethod=1) or molar (fmdmethod=2).\\n     - DMSOfactor: How much should Tm decreases per percent DMSO. Default=0.65\\n       (von Ahsen et al. 2001). Other published values are 0.5, 0.6 and 0.675.\\n     - fmdfactor: How much should Tm decrease per percent formamide.\\n       Default=0.65. Several papers report factors between 0.6 and 0.72.\\n     - fmdmethod:\\n\\n         1. Tm = Tm - factor(%formamide) (Default)\\n         2. Tm = Tm + (0.453(f(GC)) - 2.88) x [formamide]\\n\\n       Here f(GC) is fraction of GC.\\n       Note (again) that in fmdmethod=1 formamide concentration is given in %,\\n       while in fmdmethod=2 it is given in molar.\\n     - GC: GC content in percent.\\n\\n    Examples:\\n        >>> from Bio.SeqUtils import MeltingTemp as mt\\n        >>> mt.chem_correction(70)\\n        70\\n        >>> print('%0.2f' % mt.chem_correction(70, DMSO=3))\\n        67.75\\n        >>> print('%0.2f' % mt.chem_correction(70, fmd=5))\\n        66.75\\n        >>> print('%0.2f' % mt.chem_correction(70, fmdmethod=2, fmd=1.25,\\n        ...                                    GC=50))\\n        66.68\\n\\n    \"\n    if DMSO:\n        melting_temp -= DMSOfactor * DMSO\n    if fmd:\n        if fmdmethod == 1:\n            melting_temp -= fmdfactor * fmd\n        if fmdmethod == 2:\n            if GC is None or GC < 0:\n                raise ValueError(\"'GC' is missing or negative\")\n            melting_temp += (0.453 * (GC / 100.0) - 2.88) * fmd\n        if fmdmethod not in (1, 2):\n            raise ValueError(\"'fmdmethod' must be 1 or 2\")\n    return melting_temp",
            "def chem_correction(melting_temp, DMSO=0, fmd=0, DMSOfactor=0.75, fmdfactor=0.65, fmdmethod=1, GC=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Correct a given Tm for DMSO and formamide.\\n\\n    Please note that these corrections are +/- rough approximations.\\n\\n    Arguments:\\n     - melting_temp: Melting temperature.\\n     - DMSO: Percent DMSO.\\n     - fmd: Formamide concentration in %(fmdmethod=1) or molar (fmdmethod=2).\\n     - DMSOfactor: How much should Tm decreases per percent DMSO. Default=0.65\\n       (von Ahsen et al. 2001). Other published values are 0.5, 0.6 and 0.675.\\n     - fmdfactor: How much should Tm decrease per percent formamide.\\n       Default=0.65. Several papers report factors between 0.6 and 0.72.\\n     - fmdmethod:\\n\\n         1. Tm = Tm - factor(%formamide) (Default)\\n         2. Tm = Tm + (0.453(f(GC)) - 2.88) x [formamide]\\n\\n       Here f(GC) is fraction of GC.\\n       Note (again) that in fmdmethod=1 formamide concentration is given in %,\\n       while in fmdmethod=2 it is given in molar.\\n     - GC: GC content in percent.\\n\\n    Examples:\\n        >>> from Bio.SeqUtils import MeltingTemp as mt\\n        >>> mt.chem_correction(70)\\n        70\\n        >>> print('%0.2f' % mt.chem_correction(70, DMSO=3))\\n        67.75\\n        >>> print('%0.2f' % mt.chem_correction(70, fmd=5))\\n        66.75\\n        >>> print('%0.2f' % mt.chem_correction(70, fmdmethod=2, fmd=1.25,\\n        ...                                    GC=50))\\n        66.68\\n\\n    \"\n    if DMSO:\n        melting_temp -= DMSOfactor * DMSO\n    if fmd:\n        if fmdmethod == 1:\n            melting_temp -= fmdfactor * fmd\n        if fmdmethod == 2:\n            if GC is None or GC < 0:\n                raise ValueError(\"'GC' is missing or negative\")\n            melting_temp += (0.453 * (GC / 100.0) - 2.88) * fmd\n        if fmdmethod not in (1, 2):\n            raise ValueError(\"'fmdmethod' must be 1 or 2\")\n    return melting_temp"
        ]
    },
    {
        "func_name": "Tm_Wallace",
        "original": "def Tm_Wallace(seq, check=True, strict=True):\n    \"\"\"Calculate and return the Tm using the 'Wallace rule'.\n\n    Tm = 4 degC * (G + C) + 2 degC * (A+T)\n\n    The Wallace rule (Thein & Wallace 1986, in Human genetic diseases: a\n    practical approach, 33-50) is often used as rule of thumb for approximate\n    Tm calculations for primers of 14 to 20 nt length.\n\n    Non-DNA characters (e.g., E, F, J, !, 1, etc) are ignored by this method.\n\n    Examples:\n        >>> from Bio.SeqUtils import MeltingTemp as mt\n        >>> mt.Tm_Wallace('ACGTTGCAATGCCGTA')\n        48.0\n        >>> mt.Tm_Wallace('ACGT TGCA ATGC CGTA')\n        48.0\n        >>> mt.Tm_Wallace('1ACGT2TGCA3ATGC4CGTA')\n        48.0\n\n    \"\"\"\n    seq = str(seq)\n    if check:\n        seq = _check(seq, 'Tm_Wallace')\n    melting_temp = 2 * sum(map(seq.count, ('A', 'T', 'W'))) + 4 * sum(map(seq.count, ('C', 'G', 'S')))\n    tmp = 3 * sum(map(seq.count, ('K', 'M', 'N', 'R', 'Y'))) + 10 / 3.0 * sum(map(seq.count, ('B', 'V'))) + 8 / 3.0 * sum(map(seq.count, ('D', 'H')))\n    if strict and tmp:\n        raise ValueError('ambiguous bases B, D, H, K, M, N, R, V, Y not allowed when strict=True')\n    else:\n        melting_temp += tmp\n    return melting_temp",
        "mutated": [
            "def Tm_Wallace(seq, check=True, strict=True):\n    if False:\n        i = 10\n    \"Calculate and return the Tm using the 'Wallace rule'.\\n\\n    Tm = 4 degC * (G + C) + 2 degC * (A+T)\\n\\n    The Wallace rule (Thein & Wallace 1986, in Human genetic diseases: a\\n    practical approach, 33-50) is often used as rule of thumb for approximate\\n    Tm calculations for primers of 14 to 20 nt length.\\n\\n    Non-DNA characters (e.g., E, F, J, !, 1, etc) are ignored by this method.\\n\\n    Examples:\\n        >>> from Bio.SeqUtils import MeltingTemp as mt\\n        >>> mt.Tm_Wallace('ACGTTGCAATGCCGTA')\\n        48.0\\n        >>> mt.Tm_Wallace('ACGT TGCA ATGC CGTA')\\n        48.0\\n        >>> mt.Tm_Wallace('1ACGT2TGCA3ATGC4CGTA')\\n        48.0\\n\\n    \"\n    seq = str(seq)\n    if check:\n        seq = _check(seq, 'Tm_Wallace')\n    melting_temp = 2 * sum(map(seq.count, ('A', 'T', 'W'))) + 4 * sum(map(seq.count, ('C', 'G', 'S')))\n    tmp = 3 * sum(map(seq.count, ('K', 'M', 'N', 'R', 'Y'))) + 10 / 3.0 * sum(map(seq.count, ('B', 'V'))) + 8 / 3.0 * sum(map(seq.count, ('D', 'H')))\n    if strict and tmp:\n        raise ValueError('ambiguous bases B, D, H, K, M, N, R, V, Y not allowed when strict=True')\n    else:\n        melting_temp += tmp\n    return melting_temp",
            "def Tm_Wallace(seq, check=True, strict=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Calculate and return the Tm using the 'Wallace rule'.\\n\\n    Tm = 4 degC * (G + C) + 2 degC * (A+T)\\n\\n    The Wallace rule (Thein & Wallace 1986, in Human genetic diseases: a\\n    practical approach, 33-50) is often used as rule of thumb for approximate\\n    Tm calculations for primers of 14 to 20 nt length.\\n\\n    Non-DNA characters (e.g., E, F, J, !, 1, etc) are ignored by this method.\\n\\n    Examples:\\n        >>> from Bio.SeqUtils import MeltingTemp as mt\\n        >>> mt.Tm_Wallace('ACGTTGCAATGCCGTA')\\n        48.0\\n        >>> mt.Tm_Wallace('ACGT TGCA ATGC CGTA')\\n        48.0\\n        >>> mt.Tm_Wallace('1ACGT2TGCA3ATGC4CGTA')\\n        48.0\\n\\n    \"\n    seq = str(seq)\n    if check:\n        seq = _check(seq, 'Tm_Wallace')\n    melting_temp = 2 * sum(map(seq.count, ('A', 'T', 'W'))) + 4 * sum(map(seq.count, ('C', 'G', 'S')))\n    tmp = 3 * sum(map(seq.count, ('K', 'M', 'N', 'R', 'Y'))) + 10 / 3.0 * sum(map(seq.count, ('B', 'V'))) + 8 / 3.0 * sum(map(seq.count, ('D', 'H')))\n    if strict and tmp:\n        raise ValueError('ambiguous bases B, D, H, K, M, N, R, V, Y not allowed when strict=True')\n    else:\n        melting_temp += tmp\n    return melting_temp",
            "def Tm_Wallace(seq, check=True, strict=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Calculate and return the Tm using the 'Wallace rule'.\\n\\n    Tm = 4 degC * (G + C) + 2 degC * (A+T)\\n\\n    The Wallace rule (Thein & Wallace 1986, in Human genetic diseases: a\\n    practical approach, 33-50) is often used as rule of thumb for approximate\\n    Tm calculations for primers of 14 to 20 nt length.\\n\\n    Non-DNA characters (e.g., E, F, J, !, 1, etc) are ignored by this method.\\n\\n    Examples:\\n        >>> from Bio.SeqUtils import MeltingTemp as mt\\n        >>> mt.Tm_Wallace('ACGTTGCAATGCCGTA')\\n        48.0\\n        >>> mt.Tm_Wallace('ACGT TGCA ATGC CGTA')\\n        48.0\\n        >>> mt.Tm_Wallace('1ACGT2TGCA3ATGC4CGTA')\\n        48.0\\n\\n    \"\n    seq = str(seq)\n    if check:\n        seq = _check(seq, 'Tm_Wallace')\n    melting_temp = 2 * sum(map(seq.count, ('A', 'T', 'W'))) + 4 * sum(map(seq.count, ('C', 'G', 'S')))\n    tmp = 3 * sum(map(seq.count, ('K', 'M', 'N', 'R', 'Y'))) + 10 / 3.0 * sum(map(seq.count, ('B', 'V'))) + 8 / 3.0 * sum(map(seq.count, ('D', 'H')))\n    if strict and tmp:\n        raise ValueError('ambiguous bases B, D, H, K, M, N, R, V, Y not allowed when strict=True')\n    else:\n        melting_temp += tmp\n    return melting_temp",
            "def Tm_Wallace(seq, check=True, strict=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Calculate and return the Tm using the 'Wallace rule'.\\n\\n    Tm = 4 degC * (G + C) + 2 degC * (A+T)\\n\\n    The Wallace rule (Thein & Wallace 1986, in Human genetic diseases: a\\n    practical approach, 33-50) is often used as rule of thumb for approximate\\n    Tm calculations for primers of 14 to 20 nt length.\\n\\n    Non-DNA characters (e.g., E, F, J, !, 1, etc) are ignored by this method.\\n\\n    Examples:\\n        >>> from Bio.SeqUtils import MeltingTemp as mt\\n        >>> mt.Tm_Wallace('ACGTTGCAATGCCGTA')\\n        48.0\\n        >>> mt.Tm_Wallace('ACGT TGCA ATGC CGTA')\\n        48.0\\n        >>> mt.Tm_Wallace('1ACGT2TGCA3ATGC4CGTA')\\n        48.0\\n\\n    \"\n    seq = str(seq)\n    if check:\n        seq = _check(seq, 'Tm_Wallace')\n    melting_temp = 2 * sum(map(seq.count, ('A', 'T', 'W'))) + 4 * sum(map(seq.count, ('C', 'G', 'S')))\n    tmp = 3 * sum(map(seq.count, ('K', 'M', 'N', 'R', 'Y'))) + 10 / 3.0 * sum(map(seq.count, ('B', 'V'))) + 8 / 3.0 * sum(map(seq.count, ('D', 'H')))\n    if strict and tmp:\n        raise ValueError('ambiguous bases B, D, H, K, M, N, R, V, Y not allowed when strict=True')\n    else:\n        melting_temp += tmp\n    return melting_temp",
            "def Tm_Wallace(seq, check=True, strict=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Calculate and return the Tm using the 'Wallace rule'.\\n\\n    Tm = 4 degC * (G + C) + 2 degC * (A+T)\\n\\n    The Wallace rule (Thein & Wallace 1986, in Human genetic diseases: a\\n    practical approach, 33-50) is often used as rule of thumb for approximate\\n    Tm calculations for primers of 14 to 20 nt length.\\n\\n    Non-DNA characters (e.g., E, F, J, !, 1, etc) are ignored by this method.\\n\\n    Examples:\\n        >>> from Bio.SeqUtils import MeltingTemp as mt\\n        >>> mt.Tm_Wallace('ACGTTGCAATGCCGTA')\\n        48.0\\n        >>> mt.Tm_Wallace('ACGT TGCA ATGC CGTA')\\n        48.0\\n        >>> mt.Tm_Wallace('1ACGT2TGCA3ATGC4CGTA')\\n        48.0\\n\\n    \"\n    seq = str(seq)\n    if check:\n        seq = _check(seq, 'Tm_Wallace')\n    melting_temp = 2 * sum(map(seq.count, ('A', 'T', 'W'))) + 4 * sum(map(seq.count, ('C', 'G', 'S')))\n    tmp = 3 * sum(map(seq.count, ('K', 'M', 'N', 'R', 'Y'))) + 10 / 3.0 * sum(map(seq.count, ('B', 'V'))) + 8 / 3.0 * sum(map(seq.count, ('D', 'H')))\n    if strict and tmp:\n        raise ValueError('ambiguous bases B, D, H, K, M, N, R, V, Y not allowed when strict=True')\n    else:\n        melting_temp += tmp\n    return melting_temp"
        ]
    },
    {
        "func_name": "Tm_GC",
        "original": "def Tm_GC(seq, check=True, strict=True, valueset=7, userset=None, Na=50, K=0, Tris=0, Mg=0, dNTPs=0, saltcorr=0, mismatch=True):\n    \"\"\"Return the Tm using empirical formulas based on GC content.\n\n    General format: Tm = A + B(%GC) - C/N + salt correction - D(%mismatch)\n\n    A, B, C, D: empirical constants, N: primer length\n    D (amount of decrease in Tm per % mismatch) is often 1, but sometimes other\n    values have been used (0.6-1.5). Use 'X' to indicate the mismatch position\n    in the sequence. Note that this mismatch correction is a rough estimate.\n\n    >>> from Bio.SeqUtils import MeltingTemp as mt\n    >>> print(\"%0.2f\" % mt.Tm_GC('CTGCTGATXGCACGAGGTTATGG', valueset=2))\n    69.20\n\n    Arguments:\n     - valueset: A few often cited variants are included:\n\n        1. Tm = 69.3 + 0.41(%GC) - 650/N\n           (Marmur & Doty 1962, J Mol Biol 5: 109-118; Chester & Marshak 1993),\n           Anal Biochem 209: 284-290)\n        2. Tm = 81.5 + 0.41(%GC) - 675/N - %mismatch\n           'QuikChange' formula. Recommended (by the manufacturer) for the\n           design of primers for QuikChange mutagenesis.\n        3. Tm = 81.5 + 0.41(%GC) - 675/N + 16.6 x log[Na+]\n           (Marmur & Doty 1962, J Mol Biol 5: 109-118; Schildkraut & Lifson\n           1965, Biopolymers 3: 195-208)\n        4. Tm = 81.5 + 0.41(%GC) - 500/N + 16.6 x log([Na+]/(1.0 + 0.7 x\n           [Na+])) - %mismatch\n           (Wetmur 1991, Crit Rev Biochem Mol Biol 126: 227-259). This is the\n           standard formula in approximative mode of MELTING 4.3.\n        5. Tm = 78 + 0.7(%GC) - 500/N + 16.6 x log([Na+]/(1.0 + 0.7 x [Na+]))\n           - %mismatch\n           (Wetmur 1991, Crit Rev Biochem Mol Biol 126: 227-259). For RNA.\n        6. Tm = 67 + 0.8(%GC) - 500/N + 16.6 x log([Na+]/(1.0 + 0.7 x [Na+]))\n           - %mismatch\n           (Wetmur 1991, Crit Rev Biochem Mol Biol 126: 227-259). For RNA/DNA\n           hybrids.\n        7. Tm = 81.5 + 0.41(%GC) - 600/N + 16.6 x log[Na+]\n           Used by Primer3Plus to calculate the product Tm. Default set.\n        8. Tm = 77.1 + 0.41(%GC) - 528/N + 11.7 x log[Na+]\n           (von Ahsen et al. 2001, Clin Chem 47: 1956-1961). Recommended 'as a\n           tradeoff between accuracy and ease of use'.\n\n     - userset: Tuple of four values for A, B, C, and D. Usersets override\n       valuesets.\n     - Na, K, Tris, Mg, dNTPs: Concentration of the respective ions [mM]. If\n       any of K, Tris, Mg and dNTPS is non-zero, a 'sodium-equivalent'\n       concentration is calculated and used for salt correction (von Ahsen et\n       al., 2001).\n     - saltcorr: Type of salt correction (see method salt_correction).\n       Default=0. 0 or None means no salt correction.\n     - mismatch: If 'True' (default) every 'X' in the sequence is counted as\n       mismatch.\n\n    \"\"\"\n    if saltcorr == 5:\n        raise ValueError('salt-correction method 5 not applicable to Tm_GC')\n    seq = str(seq)\n    if check:\n        seq = _check(seq, 'Tm_GC')\n    if strict and any((x in seq for x in 'KMNRYBVDH')):\n        raise ValueError(\"ambiguous bases B, D, H, K, M, N, R, V, Y not allowed when 'strict=True'\")\n    percent_gc = SeqUtils.gc_fraction(seq, 'weighted') * 100\n    if mismatch:\n        percent_gc -= seq.count('X') * 50.0 / len(seq)\n    if userset:\n        (A, B, C, D) = userset\n    else:\n        if valueset == 1:\n            (A, B, C, D) = (69.3, 0.41, 650, 1)\n            saltcorr = 0\n        if valueset == 2:\n            (A, B, C, D) = (81.5, 0.41, 675, 1)\n            saltcorr = 0\n        if valueset == 3:\n            (A, B, C, D) = (81.5, 0.41, 675, 1)\n            saltcorr = 1\n        if valueset == 4:\n            (A, B, C, D) = (81.5, 0.41, 500, 1)\n            saltcorr = 2\n        if valueset == 5:\n            (A, B, C, D) = (78.0, 0.7, 500, 1)\n            saltcorr = 2\n        if valueset == 6:\n            (A, B, C, D) = (67.0, 0.8, 500, 1)\n            saltcorr = 2\n        if valueset == 7:\n            (A, B, C, D) = (81.5, 0.41, 600, 1)\n            saltcorr = 1\n        if valueset == 8:\n            (A, B, C, D) = (77.1, 0.41, 528, 1)\n            saltcorr = 4\n    if valueset > 8:\n        raise ValueError(\"allowed values for parameter 'valueset' are 0-8.\")\n    melting_temp = A + B * percent_gc - C / len(seq)\n    if saltcorr:\n        melting_temp += salt_correction(Na=Na, K=K, Tris=Tris, Mg=Mg, dNTPs=dNTPs, seq=seq, method=saltcorr)\n    if mismatch:\n        melting_temp -= D * (seq.count('X') * 100.0 / len(seq))\n    return melting_temp",
        "mutated": [
            "def Tm_GC(seq, check=True, strict=True, valueset=7, userset=None, Na=50, K=0, Tris=0, Mg=0, dNTPs=0, saltcorr=0, mismatch=True):\n    if False:\n        i = 10\n    'Return the Tm using empirical formulas based on GC content.\\n\\n    General format: Tm = A + B(%GC) - C/N + salt correction - D(%mismatch)\\n\\n    A, B, C, D: empirical constants, N: primer length\\n    D (amount of decrease in Tm per % mismatch) is often 1, but sometimes other\\n    values have been used (0.6-1.5). Use \\'X\\' to indicate the mismatch position\\n    in the sequence. Note that this mismatch correction is a rough estimate.\\n\\n    >>> from Bio.SeqUtils import MeltingTemp as mt\\n    >>> print(\"%0.2f\" % mt.Tm_GC(\\'CTGCTGATXGCACGAGGTTATGG\\', valueset=2))\\n    69.20\\n\\n    Arguments:\\n     - valueset: A few often cited variants are included:\\n\\n        1. Tm = 69.3 + 0.41(%GC) - 650/N\\n           (Marmur & Doty 1962, J Mol Biol 5: 109-118; Chester & Marshak 1993),\\n           Anal Biochem 209: 284-290)\\n        2. Tm = 81.5 + 0.41(%GC) - 675/N - %mismatch\\n           \\'QuikChange\\' formula. Recommended (by the manufacturer) for the\\n           design of primers for QuikChange mutagenesis.\\n        3. Tm = 81.5 + 0.41(%GC) - 675/N + 16.6 x log[Na+]\\n           (Marmur & Doty 1962, J Mol Biol 5: 109-118; Schildkraut & Lifson\\n           1965, Biopolymers 3: 195-208)\\n        4. Tm = 81.5 + 0.41(%GC) - 500/N + 16.6 x log([Na+]/(1.0 + 0.7 x\\n           [Na+])) - %mismatch\\n           (Wetmur 1991, Crit Rev Biochem Mol Biol 126: 227-259). This is the\\n           standard formula in approximative mode of MELTING 4.3.\\n        5. Tm = 78 + 0.7(%GC) - 500/N + 16.6 x log([Na+]/(1.0 + 0.7 x [Na+]))\\n           - %mismatch\\n           (Wetmur 1991, Crit Rev Biochem Mol Biol 126: 227-259). For RNA.\\n        6. Tm = 67 + 0.8(%GC) - 500/N + 16.6 x log([Na+]/(1.0 + 0.7 x [Na+]))\\n           - %mismatch\\n           (Wetmur 1991, Crit Rev Biochem Mol Biol 126: 227-259). For RNA/DNA\\n           hybrids.\\n        7. Tm = 81.5 + 0.41(%GC) - 600/N + 16.6 x log[Na+]\\n           Used by Primer3Plus to calculate the product Tm. Default set.\\n        8. Tm = 77.1 + 0.41(%GC) - 528/N + 11.7 x log[Na+]\\n           (von Ahsen et al. 2001, Clin Chem 47: 1956-1961). Recommended \\'as a\\n           tradeoff between accuracy and ease of use\\'.\\n\\n     - userset: Tuple of four values for A, B, C, and D. Usersets override\\n       valuesets.\\n     - Na, K, Tris, Mg, dNTPs: Concentration of the respective ions [mM]. If\\n       any of K, Tris, Mg and dNTPS is non-zero, a \\'sodium-equivalent\\'\\n       concentration is calculated and used for salt correction (von Ahsen et\\n       al., 2001).\\n     - saltcorr: Type of salt correction (see method salt_correction).\\n       Default=0. 0 or None means no salt correction.\\n     - mismatch: If \\'True\\' (default) every \\'X\\' in the sequence is counted as\\n       mismatch.\\n\\n    '\n    if saltcorr == 5:\n        raise ValueError('salt-correction method 5 not applicable to Tm_GC')\n    seq = str(seq)\n    if check:\n        seq = _check(seq, 'Tm_GC')\n    if strict and any((x in seq for x in 'KMNRYBVDH')):\n        raise ValueError(\"ambiguous bases B, D, H, K, M, N, R, V, Y not allowed when 'strict=True'\")\n    percent_gc = SeqUtils.gc_fraction(seq, 'weighted') * 100\n    if mismatch:\n        percent_gc -= seq.count('X') * 50.0 / len(seq)\n    if userset:\n        (A, B, C, D) = userset\n    else:\n        if valueset == 1:\n            (A, B, C, D) = (69.3, 0.41, 650, 1)\n            saltcorr = 0\n        if valueset == 2:\n            (A, B, C, D) = (81.5, 0.41, 675, 1)\n            saltcorr = 0\n        if valueset == 3:\n            (A, B, C, D) = (81.5, 0.41, 675, 1)\n            saltcorr = 1\n        if valueset == 4:\n            (A, B, C, D) = (81.5, 0.41, 500, 1)\n            saltcorr = 2\n        if valueset == 5:\n            (A, B, C, D) = (78.0, 0.7, 500, 1)\n            saltcorr = 2\n        if valueset == 6:\n            (A, B, C, D) = (67.0, 0.8, 500, 1)\n            saltcorr = 2\n        if valueset == 7:\n            (A, B, C, D) = (81.5, 0.41, 600, 1)\n            saltcorr = 1\n        if valueset == 8:\n            (A, B, C, D) = (77.1, 0.41, 528, 1)\n            saltcorr = 4\n    if valueset > 8:\n        raise ValueError(\"allowed values for parameter 'valueset' are 0-8.\")\n    melting_temp = A + B * percent_gc - C / len(seq)\n    if saltcorr:\n        melting_temp += salt_correction(Na=Na, K=K, Tris=Tris, Mg=Mg, dNTPs=dNTPs, seq=seq, method=saltcorr)\n    if mismatch:\n        melting_temp -= D * (seq.count('X') * 100.0 / len(seq))\n    return melting_temp",
            "def Tm_GC(seq, check=True, strict=True, valueset=7, userset=None, Na=50, K=0, Tris=0, Mg=0, dNTPs=0, saltcorr=0, mismatch=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Return the Tm using empirical formulas based on GC content.\\n\\n    General format: Tm = A + B(%GC) - C/N + salt correction - D(%mismatch)\\n\\n    A, B, C, D: empirical constants, N: primer length\\n    D (amount of decrease in Tm per % mismatch) is often 1, but sometimes other\\n    values have been used (0.6-1.5). Use \\'X\\' to indicate the mismatch position\\n    in the sequence. Note that this mismatch correction is a rough estimate.\\n\\n    >>> from Bio.SeqUtils import MeltingTemp as mt\\n    >>> print(\"%0.2f\" % mt.Tm_GC(\\'CTGCTGATXGCACGAGGTTATGG\\', valueset=2))\\n    69.20\\n\\n    Arguments:\\n     - valueset: A few often cited variants are included:\\n\\n        1. Tm = 69.3 + 0.41(%GC) - 650/N\\n           (Marmur & Doty 1962, J Mol Biol 5: 109-118; Chester & Marshak 1993),\\n           Anal Biochem 209: 284-290)\\n        2. Tm = 81.5 + 0.41(%GC) - 675/N - %mismatch\\n           \\'QuikChange\\' formula. Recommended (by the manufacturer) for the\\n           design of primers for QuikChange mutagenesis.\\n        3. Tm = 81.5 + 0.41(%GC) - 675/N + 16.6 x log[Na+]\\n           (Marmur & Doty 1962, J Mol Biol 5: 109-118; Schildkraut & Lifson\\n           1965, Biopolymers 3: 195-208)\\n        4. Tm = 81.5 + 0.41(%GC) - 500/N + 16.6 x log([Na+]/(1.0 + 0.7 x\\n           [Na+])) - %mismatch\\n           (Wetmur 1991, Crit Rev Biochem Mol Biol 126: 227-259). This is the\\n           standard formula in approximative mode of MELTING 4.3.\\n        5. Tm = 78 + 0.7(%GC) - 500/N + 16.6 x log([Na+]/(1.0 + 0.7 x [Na+]))\\n           - %mismatch\\n           (Wetmur 1991, Crit Rev Biochem Mol Biol 126: 227-259). For RNA.\\n        6. Tm = 67 + 0.8(%GC) - 500/N + 16.6 x log([Na+]/(1.0 + 0.7 x [Na+]))\\n           - %mismatch\\n           (Wetmur 1991, Crit Rev Biochem Mol Biol 126: 227-259). For RNA/DNA\\n           hybrids.\\n        7. Tm = 81.5 + 0.41(%GC) - 600/N + 16.6 x log[Na+]\\n           Used by Primer3Plus to calculate the product Tm. Default set.\\n        8. Tm = 77.1 + 0.41(%GC) - 528/N + 11.7 x log[Na+]\\n           (von Ahsen et al. 2001, Clin Chem 47: 1956-1961). Recommended \\'as a\\n           tradeoff between accuracy and ease of use\\'.\\n\\n     - userset: Tuple of four values for A, B, C, and D. Usersets override\\n       valuesets.\\n     - Na, K, Tris, Mg, dNTPs: Concentration of the respective ions [mM]. If\\n       any of K, Tris, Mg and dNTPS is non-zero, a \\'sodium-equivalent\\'\\n       concentration is calculated and used for salt correction (von Ahsen et\\n       al., 2001).\\n     - saltcorr: Type of salt correction (see method salt_correction).\\n       Default=0. 0 or None means no salt correction.\\n     - mismatch: If \\'True\\' (default) every \\'X\\' in the sequence is counted as\\n       mismatch.\\n\\n    '\n    if saltcorr == 5:\n        raise ValueError('salt-correction method 5 not applicable to Tm_GC')\n    seq = str(seq)\n    if check:\n        seq = _check(seq, 'Tm_GC')\n    if strict and any((x in seq for x in 'KMNRYBVDH')):\n        raise ValueError(\"ambiguous bases B, D, H, K, M, N, R, V, Y not allowed when 'strict=True'\")\n    percent_gc = SeqUtils.gc_fraction(seq, 'weighted') * 100\n    if mismatch:\n        percent_gc -= seq.count('X') * 50.0 / len(seq)\n    if userset:\n        (A, B, C, D) = userset\n    else:\n        if valueset == 1:\n            (A, B, C, D) = (69.3, 0.41, 650, 1)\n            saltcorr = 0\n        if valueset == 2:\n            (A, B, C, D) = (81.5, 0.41, 675, 1)\n            saltcorr = 0\n        if valueset == 3:\n            (A, B, C, D) = (81.5, 0.41, 675, 1)\n            saltcorr = 1\n        if valueset == 4:\n            (A, B, C, D) = (81.5, 0.41, 500, 1)\n            saltcorr = 2\n        if valueset == 5:\n            (A, B, C, D) = (78.0, 0.7, 500, 1)\n            saltcorr = 2\n        if valueset == 6:\n            (A, B, C, D) = (67.0, 0.8, 500, 1)\n            saltcorr = 2\n        if valueset == 7:\n            (A, B, C, D) = (81.5, 0.41, 600, 1)\n            saltcorr = 1\n        if valueset == 8:\n            (A, B, C, D) = (77.1, 0.41, 528, 1)\n            saltcorr = 4\n    if valueset > 8:\n        raise ValueError(\"allowed values for parameter 'valueset' are 0-8.\")\n    melting_temp = A + B * percent_gc - C / len(seq)\n    if saltcorr:\n        melting_temp += salt_correction(Na=Na, K=K, Tris=Tris, Mg=Mg, dNTPs=dNTPs, seq=seq, method=saltcorr)\n    if mismatch:\n        melting_temp -= D * (seq.count('X') * 100.0 / len(seq))\n    return melting_temp",
            "def Tm_GC(seq, check=True, strict=True, valueset=7, userset=None, Na=50, K=0, Tris=0, Mg=0, dNTPs=0, saltcorr=0, mismatch=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Return the Tm using empirical formulas based on GC content.\\n\\n    General format: Tm = A + B(%GC) - C/N + salt correction - D(%mismatch)\\n\\n    A, B, C, D: empirical constants, N: primer length\\n    D (amount of decrease in Tm per % mismatch) is often 1, but sometimes other\\n    values have been used (0.6-1.5). Use \\'X\\' to indicate the mismatch position\\n    in the sequence. Note that this mismatch correction is a rough estimate.\\n\\n    >>> from Bio.SeqUtils import MeltingTemp as mt\\n    >>> print(\"%0.2f\" % mt.Tm_GC(\\'CTGCTGATXGCACGAGGTTATGG\\', valueset=2))\\n    69.20\\n\\n    Arguments:\\n     - valueset: A few often cited variants are included:\\n\\n        1. Tm = 69.3 + 0.41(%GC) - 650/N\\n           (Marmur & Doty 1962, J Mol Biol 5: 109-118; Chester & Marshak 1993),\\n           Anal Biochem 209: 284-290)\\n        2. Tm = 81.5 + 0.41(%GC) - 675/N - %mismatch\\n           \\'QuikChange\\' formula. Recommended (by the manufacturer) for the\\n           design of primers for QuikChange mutagenesis.\\n        3. Tm = 81.5 + 0.41(%GC) - 675/N + 16.6 x log[Na+]\\n           (Marmur & Doty 1962, J Mol Biol 5: 109-118; Schildkraut & Lifson\\n           1965, Biopolymers 3: 195-208)\\n        4. Tm = 81.5 + 0.41(%GC) - 500/N + 16.6 x log([Na+]/(1.0 + 0.7 x\\n           [Na+])) - %mismatch\\n           (Wetmur 1991, Crit Rev Biochem Mol Biol 126: 227-259). This is the\\n           standard formula in approximative mode of MELTING 4.3.\\n        5. Tm = 78 + 0.7(%GC) - 500/N + 16.6 x log([Na+]/(1.0 + 0.7 x [Na+]))\\n           - %mismatch\\n           (Wetmur 1991, Crit Rev Biochem Mol Biol 126: 227-259). For RNA.\\n        6. Tm = 67 + 0.8(%GC) - 500/N + 16.6 x log([Na+]/(1.0 + 0.7 x [Na+]))\\n           - %mismatch\\n           (Wetmur 1991, Crit Rev Biochem Mol Biol 126: 227-259). For RNA/DNA\\n           hybrids.\\n        7. Tm = 81.5 + 0.41(%GC) - 600/N + 16.6 x log[Na+]\\n           Used by Primer3Plus to calculate the product Tm. Default set.\\n        8. Tm = 77.1 + 0.41(%GC) - 528/N + 11.7 x log[Na+]\\n           (von Ahsen et al. 2001, Clin Chem 47: 1956-1961). Recommended \\'as a\\n           tradeoff between accuracy and ease of use\\'.\\n\\n     - userset: Tuple of four values for A, B, C, and D. Usersets override\\n       valuesets.\\n     - Na, K, Tris, Mg, dNTPs: Concentration of the respective ions [mM]. If\\n       any of K, Tris, Mg and dNTPS is non-zero, a \\'sodium-equivalent\\'\\n       concentration is calculated and used for salt correction (von Ahsen et\\n       al., 2001).\\n     - saltcorr: Type of salt correction (see method salt_correction).\\n       Default=0. 0 or None means no salt correction.\\n     - mismatch: If \\'True\\' (default) every \\'X\\' in the sequence is counted as\\n       mismatch.\\n\\n    '\n    if saltcorr == 5:\n        raise ValueError('salt-correction method 5 not applicable to Tm_GC')\n    seq = str(seq)\n    if check:\n        seq = _check(seq, 'Tm_GC')\n    if strict and any((x in seq for x in 'KMNRYBVDH')):\n        raise ValueError(\"ambiguous bases B, D, H, K, M, N, R, V, Y not allowed when 'strict=True'\")\n    percent_gc = SeqUtils.gc_fraction(seq, 'weighted') * 100\n    if mismatch:\n        percent_gc -= seq.count('X') * 50.0 / len(seq)\n    if userset:\n        (A, B, C, D) = userset\n    else:\n        if valueset == 1:\n            (A, B, C, D) = (69.3, 0.41, 650, 1)\n            saltcorr = 0\n        if valueset == 2:\n            (A, B, C, D) = (81.5, 0.41, 675, 1)\n            saltcorr = 0\n        if valueset == 3:\n            (A, B, C, D) = (81.5, 0.41, 675, 1)\n            saltcorr = 1\n        if valueset == 4:\n            (A, B, C, D) = (81.5, 0.41, 500, 1)\n            saltcorr = 2\n        if valueset == 5:\n            (A, B, C, D) = (78.0, 0.7, 500, 1)\n            saltcorr = 2\n        if valueset == 6:\n            (A, B, C, D) = (67.0, 0.8, 500, 1)\n            saltcorr = 2\n        if valueset == 7:\n            (A, B, C, D) = (81.5, 0.41, 600, 1)\n            saltcorr = 1\n        if valueset == 8:\n            (A, B, C, D) = (77.1, 0.41, 528, 1)\n            saltcorr = 4\n    if valueset > 8:\n        raise ValueError(\"allowed values for parameter 'valueset' are 0-8.\")\n    melting_temp = A + B * percent_gc - C / len(seq)\n    if saltcorr:\n        melting_temp += salt_correction(Na=Na, K=K, Tris=Tris, Mg=Mg, dNTPs=dNTPs, seq=seq, method=saltcorr)\n    if mismatch:\n        melting_temp -= D * (seq.count('X') * 100.0 / len(seq))\n    return melting_temp",
            "def Tm_GC(seq, check=True, strict=True, valueset=7, userset=None, Na=50, K=0, Tris=0, Mg=0, dNTPs=0, saltcorr=0, mismatch=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Return the Tm using empirical formulas based on GC content.\\n\\n    General format: Tm = A + B(%GC) - C/N + salt correction - D(%mismatch)\\n\\n    A, B, C, D: empirical constants, N: primer length\\n    D (amount of decrease in Tm per % mismatch) is often 1, but sometimes other\\n    values have been used (0.6-1.5). Use \\'X\\' to indicate the mismatch position\\n    in the sequence. Note that this mismatch correction is a rough estimate.\\n\\n    >>> from Bio.SeqUtils import MeltingTemp as mt\\n    >>> print(\"%0.2f\" % mt.Tm_GC(\\'CTGCTGATXGCACGAGGTTATGG\\', valueset=2))\\n    69.20\\n\\n    Arguments:\\n     - valueset: A few often cited variants are included:\\n\\n        1. Tm = 69.3 + 0.41(%GC) - 650/N\\n           (Marmur & Doty 1962, J Mol Biol 5: 109-118; Chester & Marshak 1993),\\n           Anal Biochem 209: 284-290)\\n        2. Tm = 81.5 + 0.41(%GC) - 675/N - %mismatch\\n           \\'QuikChange\\' formula. Recommended (by the manufacturer) for the\\n           design of primers for QuikChange mutagenesis.\\n        3. Tm = 81.5 + 0.41(%GC) - 675/N + 16.6 x log[Na+]\\n           (Marmur & Doty 1962, J Mol Biol 5: 109-118; Schildkraut & Lifson\\n           1965, Biopolymers 3: 195-208)\\n        4. Tm = 81.5 + 0.41(%GC) - 500/N + 16.6 x log([Na+]/(1.0 + 0.7 x\\n           [Na+])) - %mismatch\\n           (Wetmur 1991, Crit Rev Biochem Mol Biol 126: 227-259). This is the\\n           standard formula in approximative mode of MELTING 4.3.\\n        5. Tm = 78 + 0.7(%GC) - 500/N + 16.6 x log([Na+]/(1.0 + 0.7 x [Na+]))\\n           - %mismatch\\n           (Wetmur 1991, Crit Rev Biochem Mol Biol 126: 227-259). For RNA.\\n        6. Tm = 67 + 0.8(%GC) - 500/N + 16.6 x log([Na+]/(1.0 + 0.7 x [Na+]))\\n           - %mismatch\\n           (Wetmur 1991, Crit Rev Biochem Mol Biol 126: 227-259). For RNA/DNA\\n           hybrids.\\n        7. Tm = 81.5 + 0.41(%GC) - 600/N + 16.6 x log[Na+]\\n           Used by Primer3Plus to calculate the product Tm. Default set.\\n        8. Tm = 77.1 + 0.41(%GC) - 528/N + 11.7 x log[Na+]\\n           (von Ahsen et al. 2001, Clin Chem 47: 1956-1961). Recommended \\'as a\\n           tradeoff between accuracy and ease of use\\'.\\n\\n     - userset: Tuple of four values for A, B, C, and D. Usersets override\\n       valuesets.\\n     - Na, K, Tris, Mg, dNTPs: Concentration of the respective ions [mM]. If\\n       any of K, Tris, Mg and dNTPS is non-zero, a \\'sodium-equivalent\\'\\n       concentration is calculated and used for salt correction (von Ahsen et\\n       al., 2001).\\n     - saltcorr: Type of salt correction (see method salt_correction).\\n       Default=0. 0 or None means no salt correction.\\n     - mismatch: If \\'True\\' (default) every \\'X\\' in the sequence is counted as\\n       mismatch.\\n\\n    '\n    if saltcorr == 5:\n        raise ValueError('salt-correction method 5 not applicable to Tm_GC')\n    seq = str(seq)\n    if check:\n        seq = _check(seq, 'Tm_GC')\n    if strict and any((x in seq for x in 'KMNRYBVDH')):\n        raise ValueError(\"ambiguous bases B, D, H, K, M, N, R, V, Y not allowed when 'strict=True'\")\n    percent_gc = SeqUtils.gc_fraction(seq, 'weighted') * 100\n    if mismatch:\n        percent_gc -= seq.count('X') * 50.0 / len(seq)\n    if userset:\n        (A, B, C, D) = userset\n    else:\n        if valueset == 1:\n            (A, B, C, D) = (69.3, 0.41, 650, 1)\n            saltcorr = 0\n        if valueset == 2:\n            (A, B, C, D) = (81.5, 0.41, 675, 1)\n            saltcorr = 0\n        if valueset == 3:\n            (A, B, C, D) = (81.5, 0.41, 675, 1)\n            saltcorr = 1\n        if valueset == 4:\n            (A, B, C, D) = (81.5, 0.41, 500, 1)\n            saltcorr = 2\n        if valueset == 5:\n            (A, B, C, D) = (78.0, 0.7, 500, 1)\n            saltcorr = 2\n        if valueset == 6:\n            (A, B, C, D) = (67.0, 0.8, 500, 1)\n            saltcorr = 2\n        if valueset == 7:\n            (A, B, C, D) = (81.5, 0.41, 600, 1)\n            saltcorr = 1\n        if valueset == 8:\n            (A, B, C, D) = (77.1, 0.41, 528, 1)\n            saltcorr = 4\n    if valueset > 8:\n        raise ValueError(\"allowed values for parameter 'valueset' are 0-8.\")\n    melting_temp = A + B * percent_gc - C / len(seq)\n    if saltcorr:\n        melting_temp += salt_correction(Na=Na, K=K, Tris=Tris, Mg=Mg, dNTPs=dNTPs, seq=seq, method=saltcorr)\n    if mismatch:\n        melting_temp -= D * (seq.count('X') * 100.0 / len(seq))\n    return melting_temp",
            "def Tm_GC(seq, check=True, strict=True, valueset=7, userset=None, Na=50, K=0, Tris=0, Mg=0, dNTPs=0, saltcorr=0, mismatch=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Return the Tm using empirical formulas based on GC content.\\n\\n    General format: Tm = A + B(%GC) - C/N + salt correction - D(%mismatch)\\n\\n    A, B, C, D: empirical constants, N: primer length\\n    D (amount of decrease in Tm per % mismatch) is often 1, but sometimes other\\n    values have been used (0.6-1.5). Use \\'X\\' to indicate the mismatch position\\n    in the sequence. Note that this mismatch correction is a rough estimate.\\n\\n    >>> from Bio.SeqUtils import MeltingTemp as mt\\n    >>> print(\"%0.2f\" % mt.Tm_GC(\\'CTGCTGATXGCACGAGGTTATGG\\', valueset=2))\\n    69.20\\n\\n    Arguments:\\n     - valueset: A few often cited variants are included:\\n\\n        1. Tm = 69.3 + 0.41(%GC) - 650/N\\n           (Marmur & Doty 1962, J Mol Biol 5: 109-118; Chester & Marshak 1993),\\n           Anal Biochem 209: 284-290)\\n        2. Tm = 81.5 + 0.41(%GC) - 675/N - %mismatch\\n           \\'QuikChange\\' formula. Recommended (by the manufacturer) for the\\n           design of primers for QuikChange mutagenesis.\\n        3. Tm = 81.5 + 0.41(%GC) - 675/N + 16.6 x log[Na+]\\n           (Marmur & Doty 1962, J Mol Biol 5: 109-118; Schildkraut & Lifson\\n           1965, Biopolymers 3: 195-208)\\n        4. Tm = 81.5 + 0.41(%GC) - 500/N + 16.6 x log([Na+]/(1.0 + 0.7 x\\n           [Na+])) - %mismatch\\n           (Wetmur 1991, Crit Rev Biochem Mol Biol 126: 227-259). This is the\\n           standard formula in approximative mode of MELTING 4.3.\\n        5. Tm = 78 + 0.7(%GC) - 500/N + 16.6 x log([Na+]/(1.0 + 0.7 x [Na+]))\\n           - %mismatch\\n           (Wetmur 1991, Crit Rev Biochem Mol Biol 126: 227-259). For RNA.\\n        6. Tm = 67 + 0.8(%GC) - 500/N + 16.6 x log([Na+]/(1.0 + 0.7 x [Na+]))\\n           - %mismatch\\n           (Wetmur 1991, Crit Rev Biochem Mol Biol 126: 227-259). For RNA/DNA\\n           hybrids.\\n        7. Tm = 81.5 + 0.41(%GC) - 600/N + 16.6 x log[Na+]\\n           Used by Primer3Plus to calculate the product Tm. Default set.\\n        8. Tm = 77.1 + 0.41(%GC) - 528/N + 11.7 x log[Na+]\\n           (von Ahsen et al. 2001, Clin Chem 47: 1956-1961). Recommended \\'as a\\n           tradeoff between accuracy and ease of use\\'.\\n\\n     - userset: Tuple of four values for A, B, C, and D. Usersets override\\n       valuesets.\\n     - Na, K, Tris, Mg, dNTPs: Concentration of the respective ions [mM]. If\\n       any of K, Tris, Mg and dNTPS is non-zero, a \\'sodium-equivalent\\'\\n       concentration is calculated and used for salt correction (von Ahsen et\\n       al., 2001).\\n     - saltcorr: Type of salt correction (see method salt_correction).\\n       Default=0. 0 or None means no salt correction.\\n     - mismatch: If \\'True\\' (default) every \\'X\\' in the sequence is counted as\\n       mismatch.\\n\\n    '\n    if saltcorr == 5:\n        raise ValueError('salt-correction method 5 not applicable to Tm_GC')\n    seq = str(seq)\n    if check:\n        seq = _check(seq, 'Tm_GC')\n    if strict and any((x in seq for x in 'KMNRYBVDH')):\n        raise ValueError(\"ambiguous bases B, D, H, K, M, N, R, V, Y not allowed when 'strict=True'\")\n    percent_gc = SeqUtils.gc_fraction(seq, 'weighted') * 100\n    if mismatch:\n        percent_gc -= seq.count('X') * 50.0 / len(seq)\n    if userset:\n        (A, B, C, D) = userset\n    else:\n        if valueset == 1:\n            (A, B, C, D) = (69.3, 0.41, 650, 1)\n            saltcorr = 0\n        if valueset == 2:\n            (A, B, C, D) = (81.5, 0.41, 675, 1)\n            saltcorr = 0\n        if valueset == 3:\n            (A, B, C, D) = (81.5, 0.41, 675, 1)\n            saltcorr = 1\n        if valueset == 4:\n            (A, B, C, D) = (81.5, 0.41, 500, 1)\n            saltcorr = 2\n        if valueset == 5:\n            (A, B, C, D) = (78.0, 0.7, 500, 1)\n            saltcorr = 2\n        if valueset == 6:\n            (A, B, C, D) = (67.0, 0.8, 500, 1)\n            saltcorr = 2\n        if valueset == 7:\n            (A, B, C, D) = (81.5, 0.41, 600, 1)\n            saltcorr = 1\n        if valueset == 8:\n            (A, B, C, D) = (77.1, 0.41, 528, 1)\n            saltcorr = 4\n    if valueset > 8:\n        raise ValueError(\"allowed values for parameter 'valueset' are 0-8.\")\n    melting_temp = A + B * percent_gc - C / len(seq)\n    if saltcorr:\n        melting_temp += salt_correction(Na=Na, K=K, Tris=Tris, Mg=Mg, dNTPs=dNTPs, seq=seq, method=saltcorr)\n    if mismatch:\n        melting_temp -= D * (seq.count('X') * 100.0 / len(seq))\n    return melting_temp"
        ]
    },
    {
        "func_name": "_key_error",
        "original": "def _key_error(neighbors, strict):\n    \"\"\"Throw an error or a warning if there is no data for the neighbors (PRIVATE).\"\"\"\n    if strict:\n        raise ValueError(f'no thermodynamic data for neighbors {neighbors!r} available')\n    else:\n        warnings.warn('no themodynamic data for neighbors %r available. Calculation will be wrong' % neighbors, BiopythonWarning)",
        "mutated": [
            "def _key_error(neighbors, strict):\n    if False:\n        i = 10\n    'Throw an error or a warning if there is no data for the neighbors (PRIVATE).'\n    if strict:\n        raise ValueError(f'no thermodynamic data for neighbors {neighbors!r} available')\n    else:\n        warnings.warn('no themodynamic data for neighbors %r available. Calculation will be wrong' % neighbors, BiopythonWarning)",
            "def _key_error(neighbors, strict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Throw an error or a warning if there is no data for the neighbors (PRIVATE).'\n    if strict:\n        raise ValueError(f'no thermodynamic data for neighbors {neighbors!r} available')\n    else:\n        warnings.warn('no themodynamic data for neighbors %r available. Calculation will be wrong' % neighbors, BiopythonWarning)",
            "def _key_error(neighbors, strict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Throw an error or a warning if there is no data for the neighbors (PRIVATE).'\n    if strict:\n        raise ValueError(f'no thermodynamic data for neighbors {neighbors!r} available')\n    else:\n        warnings.warn('no themodynamic data for neighbors %r available. Calculation will be wrong' % neighbors, BiopythonWarning)",
            "def _key_error(neighbors, strict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Throw an error or a warning if there is no data for the neighbors (PRIVATE).'\n    if strict:\n        raise ValueError(f'no thermodynamic data for neighbors {neighbors!r} available')\n    else:\n        warnings.warn('no themodynamic data for neighbors %r available. Calculation will be wrong' % neighbors, BiopythonWarning)",
            "def _key_error(neighbors, strict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Throw an error or a warning if there is no data for the neighbors (PRIVATE).'\n    if strict:\n        raise ValueError(f'no thermodynamic data for neighbors {neighbors!r} available')\n    else:\n        warnings.warn('no themodynamic data for neighbors %r available. Calculation will be wrong' % neighbors, BiopythonWarning)"
        ]
    },
    {
        "func_name": "Tm_NN",
        "original": "def Tm_NN(seq, check=True, strict=True, c_seq=None, shift=0, nn_table=None, tmm_table=None, imm_table=None, de_table=None, dnac1=25, dnac2=25, selfcomp=False, Na=50, K=0, Tris=0, Mg=0, dNTPs=0, saltcorr=5):\n    \"\"\"Return the Tm using nearest neighbor thermodynamics.\n\n    Arguments:\n     - seq: The primer/probe sequence as string or Biopython sequence object.\n       For RNA/DNA hybridizations seq must be the RNA sequence.\n     - c_seq: Complementary sequence. The sequence of the template/target in\n       3'->5' direction. c_seq is necessary for mismatch correction and\n       dangling-ends correction. Both corrections will automatically be\n       applied if mismatches or dangling ends are present. Default=None.\n     - shift: Shift of the primer/probe sequence on the template/target\n       sequence, e.g.::\n\n                           shift=0       shift=1        shift= -1\n        Primer (seq):      5' ATGC...    5'  ATGC...    5' ATGC...\n        Template (c_seq):  3' TACG...    3' CTACG...    3'  ACG...\n\n       The shift parameter is necessary to align seq and c_seq if they have\n       different lengths or if they should have dangling ends. Default=0\n     - table: Thermodynamic NN values, eight tables are implemented:\n       For DNA/DNA hybridizations:\n\n        - DNA_NN1: values from Breslauer et al. (1986)\n        - DNA_NN2: values from Sugimoto et al. (1996)\n        - DNA_NN3: values from Allawi & SantaLucia (1997) (default)\n        - DNA_NN4: values from SantaLucia & Hicks (2004)\n\n       For RNA/RNA hybridizations:\n\n        - RNA_NN1: values from Freier et al. (1986)\n        - RNA_NN2: values from Xia et al. (1998)\n        - RNA_NN3: values from Chen et al. (2012)\n\n       For RNA/DNA hybridizations:\n\n        - R_DNA_NN1: values from Sugimoto et al. (1995)\n          Note that ``seq`` must be the RNA sequence.\n\n       Use the module's maketable method to make a new table or to update one\n       one of the implemented tables.\n     - tmm_table: Thermodynamic values for terminal mismatches.\n       Default: DNA_TMM1 (SantaLucia & Peyret, 2001)\n     - imm_table: Thermodynamic values for internal mismatches, may include\n       insosine mismatches. Default: DNA_IMM1 (Allawi & SantaLucia, 1997-1998;\n       Peyret et al., 1999; Watkins & SantaLucia, 2005)\n     - de_table: Thermodynamic values for dangling ends:\n\n        - DNA_DE1: for DNA. Values from Bommarito et al. (2000) (default)\n        - RNA_DE1: for RNA. Values from Turner & Mathews (2010)\n\n     - dnac1: Concentration of the higher concentrated strand [nM]. Typically\n       this will be the primer (for PCR) or the probe. Default=25.\n     - dnac2: Concentration of the lower concentrated strand [nM]. In PCR this\n       is the template strand which concentration is typically very low and may\n       be ignored (dnac2=0). In oligo/oligo hybridization experiments, dnac1\n       equals dnac1. Default=25.\n       MELTING and Primer3Plus use k = [Oligo(Total)]/4 by default. To mimic\n       this behaviour, you have to divide [Oligo(Total)] by 2 and assign this\n       concentration to dnac1 and dnac2. E.g., Total oligo concentration of\n       50 nM in Primer3Plus means dnac1=25, dnac2=25.\n     - selfcomp: Is the sequence self-complementary? Default=False. If 'True'\n       the primer is thought binding to itself, thus dnac2 is not considered.\n     - Na, K, Tris, Mg, dNTPs: See method 'Tm_GC' for details. Defaults: Na=50,\n       K=0, Tris=0, Mg=0, dNTPs=0.\n     - saltcorr: See method 'Tm_GC'. Default=5. 0 means no salt correction.\n\n    \"\"\"\n    if not nn_table:\n        nn_table = DNA_NN3\n    if not tmm_table:\n        tmm_table = DNA_TMM1\n    if not imm_table:\n        imm_table = DNA_IMM1\n    if not de_table:\n        de_table = DNA_DE1\n    seq = str(seq)\n    if not c_seq:\n        c_seq = Seq.Seq(seq).complement()\n    c_seq = str(c_seq)\n    if check:\n        seq = _check(seq, 'Tm_NN')\n        c_seq = _check(c_seq, 'Tm_NN')\n    tmp_seq = seq\n    tmp_cseq = c_seq\n    delta_h = 0\n    delta_s = 0\n    d_h = 0\n    d_s = 1\n    if shift or len(seq) != len(c_seq):\n        if shift > 0:\n            tmp_seq = '.' * shift + seq\n        if shift < 0:\n            tmp_cseq = '.' * abs(shift) + c_seq\n        if len(tmp_cseq) > len(tmp_seq):\n            tmp_seq += (len(tmp_cseq) - len(tmp_seq)) * '.'\n        if len(tmp_cseq) < len(tmp_seq):\n            tmp_cseq += (len(tmp_seq) - len(tmp_cseq)) * '.'\n        while tmp_seq.startswith('..') or tmp_cseq.startswith('..'):\n            tmp_seq = tmp_seq[1:]\n            tmp_cseq = tmp_cseq[1:]\n        while tmp_seq.endswith('..') or tmp_cseq.endswith('..'):\n            tmp_seq = tmp_seq[:-1]\n            tmp_cseq = tmp_cseq[:-1]\n        if tmp_seq.startswith('.') or tmp_cseq.startswith('.'):\n            left_de = tmp_seq[:2] + '/' + tmp_cseq[:2]\n            try:\n                delta_h += de_table[left_de][d_h]\n                delta_s += de_table[left_de][d_s]\n            except KeyError:\n                _key_error(left_de, strict)\n            tmp_seq = tmp_seq[1:]\n            tmp_cseq = tmp_cseq[1:]\n        if tmp_seq.endswith('.') or tmp_cseq.endswith('.'):\n            right_de = tmp_cseq[-2:][::-1] + '/' + tmp_seq[-2:][::-1]\n            try:\n                delta_h += de_table[right_de][d_h]\n                delta_s += de_table[right_de][d_s]\n            except KeyError:\n                _key_error(right_de, strict)\n            tmp_seq = tmp_seq[:-1]\n            tmp_cseq = tmp_cseq[:-1]\n    left_tmm = tmp_cseq[:2][::-1] + '/' + tmp_seq[:2][::-1]\n    if left_tmm in tmm_table:\n        delta_h += tmm_table[left_tmm][d_h]\n        delta_s += tmm_table[left_tmm][d_s]\n        tmp_seq = tmp_seq[1:]\n        tmp_cseq = tmp_cseq[1:]\n    right_tmm = tmp_seq[-2:] + '/' + tmp_cseq[-2:]\n    if right_tmm in tmm_table:\n        delta_h += tmm_table[right_tmm][d_h]\n        delta_s += tmm_table[right_tmm][d_s]\n        tmp_seq = tmp_seq[:-1]\n        tmp_cseq = tmp_cseq[:-1]\n    delta_h += nn_table['init'][d_h]\n    delta_s += nn_table['init'][d_s]\n    if SeqUtils.gc_fraction(seq, 'ignore') == 0:\n        delta_h += nn_table['init_allA/T'][d_h]\n        delta_s += nn_table['init_allA/T'][d_s]\n    else:\n        delta_h += nn_table['init_oneG/C'][d_h]\n        delta_s += nn_table['init_oneG/C'][d_s]\n    if seq.startswith('T'):\n        delta_h += nn_table['init_5T/A'][d_h]\n        delta_s += nn_table['init_5T/A'][d_s]\n    if seq.endswith('A'):\n        delta_h += nn_table['init_5T/A'][d_h]\n        delta_s += nn_table['init_5T/A'][d_s]\n    ends = seq[0] + seq[-1]\n    AT = ends.count('A') + ends.count('T')\n    GC = ends.count('G') + ends.count('C')\n    delta_h += nn_table['init_A/T'][d_h] * AT\n    delta_s += nn_table['init_A/T'][d_s] * AT\n    delta_h += nn_table['init_G/C'][d_h] * GC\n    delta_s += nn_table['init_G/C'][d_s] * GC\n    for basenumber in range(len(tmp_seq) - 1):\n        neighbors = tmp_seq[basenumber:basenumber + 2] + '/' + tmp_cseq[basenumber:basenumber + 2]\n        if neighbors in imm_table:\n            delta_h += imm_table[neighbors][d_h]\n            delta_s += imm_table[neighbors][d_s]\n        elif neighbors[::-1] in imm_table:\n            delta_h += imm_table[neighbors[::-1]][d_h]\n            delta_s += imm_table[neighbors[::-1]][d_s]\n        elif neighbors in nn_table:\n            delta_h += nn_table[neighbors][d_h]\n            delta_s += nn_table[neighbors][d_s]\n        elif neighbors[::-1] in nn_table:\n            delta_h += nn_table[neighbors[::-1]][d_h]\n            delta_s += nn_table[neighbors[::-1]][d_s]\n        else:\n            _key_error(neighbors, strict)\n    k = (dnac1 - dnac2 / 2.0) * 1e-09\n    if selfcomp:\n        k = dnac1 * 1e-09\n        delta_h += nn_table['sym'][d_h]\n        delta_s += nn_table['sym'][d_s]\n    R = 1.987\n    if saltcorr:\n        corr = salt_correction(Na=Na, K=K, Tris=Tris, Mg=Mg, dNTPs=dNTPs, method=saltcorr, seq=seq)\n    if saltcorr == 5:\n        delta_s += corr\n    melting_temp = 1000 * delta_h / (delta_s + R * math.log(k)) - 273.15\n    if saltcorr in (1, 2, 3, 4):\n        melting_temp += corr\n    if saltcorr in (6, 7):\n        melting_temp = 1 / (1 / (melting_temp + 273.15) + corr) - 273.15\n    return melting_temp",
        "mutated": [
            "def Tm_NN(seq, check=True, strict=True, c_seq=None, shift=0, nn_table=None, tmm_table=None, imm_table=None, de_table=None, dnac1=25, dnac2=25, selfcomp=False, Na=50, K=0, Tris=0, Mg=0, dNTPs=0, saltcorr=5):\n    if False:\n        i = 10\n    \"Return the Tm using nearest neighbor thermodynamics.\\n\\n    Arguments:\\n     - seq: The primer/probe sequence as string or Biopython sequence object.\\n       For RNA/DNA hybridizations seq must be the RNA sequence.\\n     - c_seq: Complementary sequence. The sequence of the template/target in\\n       3'->5' direction. c_seq is necessary for mismatch correction and\\n       dangling-ends correction. Both corrections will automatically be\\n       applied if mismatches or dangling ends are present. Default=None.\\n     - shift: Shift of the primer/probe sequence on the template/target\\n       sequence, e.g.::\\n\\n                           shift=0       shift=1        shift= -1\\n        Primer (seq):      5' ATGC...    5'  ATGC...    5' ATGC...\\n        Template (c_seq):  3' TACG...    3' CTACG...    3'  ACG...\\n\\n       The shift parameter is necessary to align seq and c_seq if they have\\n       different lengths or if they should have dangling ends. Default=0\\n     - table: Thermodynamic NN values, eight tables are implemented:\\n       For DNA/DNA hybridizations:\\n\\n        - DNA_NN1: values from Breslauer et al. (1986)\\n        - DNA_NN2: values from Sugimoto et al. (1996)\\n        - DNA_NN3: values from Allawi & SantaLucia (1997) (default)\\n        - DNA_NN4: values from SantaLucia & Hicks (2004)\\n\\n       For RNA/RNA hybridizations:\\n\\n        - RNA_NN1: values from Freier et al. (1986)\\n        - RNA_NN2: values from Xia et al. (1998)\\n        - RNA_NN3: values from Chen et al. (2012)\\n\\n       For RNA/DNA hybridizations:\\n\\n        - R_DNA_NN1: values from Sugimoto et al. (1995)\\n          Note that ``seq`` must be the RNA sequence.\\n\\n       Use the module's maketable method to make a new table or to update one\\n       one of the implemented tables.\\n     - tmm_table: Thermodynamic values for terminal mismatches.\\n       Default: DNA_TMM1 (SantaLucia & Peyret, 2001)\\n     - imm_table: Thermodynamic values for internal mismatches, may include\\n       insosine mismatches. Default: DNA_IMM1 (Allawi & SantaLucia, 1997-1998;\\n       Peyret et al., 1999; Watkins & SantaLucia, 2005)\\n     - de_table: Thermodynamic values for dangling ends:\\n\\n        - DNA_DE1: for DNA. Values from Bommarito et al. (2000) (default)\\n        - RNA_DE1: for RNA. Values from Turner & Mathews (2010)\\n\\n     - dnac1: Concentration of the higher concentrated strand [nM]. Typically\\n       this will be the primer (for PCR) or the probe. Default=25.\\n     - dnac2: Concentration of the lower concentrated strand [nM]. In PCR this\\n       is the template strand which concentration is typically very low and may\\n       be ignored (dnac2=0). In oligo/oligo hybridization experiments, dnac1\\n       equals dnac1. Default=25.\\n       MELTING and Primer3Plus use k = [Oligo(Total)]/4 by default. To mimic\\n       this behaviour, you have to divide [Oligo(Total)] by 2 and assign this\\n       concentration to dnac1 and dnac2. E.g., Total oligo concentration of\\n       50 nM in Primer3Plus means dnac1=25, dnac2=25.\\n     - selfcomp: Is the sequence self-complementary? Default=False. If 'True'\\n       the primer is thought binding to itself, thus dnac2 is not considered.\\n     - Na, K, Tris, Mg, dNTPs: See method 'Tm_GC' for details. Defaults: Na=50,\\n       K=0, Tris=0, Mg=0, dNTPs=0.\\n     - saltcorr: See method 'Tm_GC'. Default=5. 0 means no salt correction.\\n\\n    \"\n    if not nn_table:\n        nn_table = DNA_NN3\n    if not tmm_table:\n        tmm_table = DNA_TMM1\n    if not imm_table:\n        imm_table = DNA_IMM1\n    if not de_table:\n        de_table = DNA_DE1\n    seq = str(seq)\n    if not c_seq:\n        c_seq = Seq.Seq(seq).complement()\n    c_seq = str(c_seq)\n    if check:\n        seq = _check(seq, 'Tm_NN')\n        c_seq = _check(c_seq, 'Tm_NN')\n    tmp_seq = seq\n    tmp_cseq = c_seq\n    delta_h = 0\n    delta_s = 0\n    d_h = 0\n    d_s = 1\n    if shift or len(seq) != len(c_seq):\n        if shift > 0:\n            tmp_seq = '.' * shift + seq\n        if shift < 0:\n            tmp_cseq = '.' * abs(shift) + c_seq\n        if len(tmp_cseq) > len(tmp_seq):\n            tmp_seq += (len(tmp_cseq) - len(tmp_seq)) * '.'\n        if len(tmp_cseq) < len(tmp_seq):\n            tmp_cseq += (len(tmp_seq) - len(tmp_cseq)) * '.'\n        while tmp_seq.startswith('..') or tmp_cseq.startswith('..'):\n            tmp_seq = tmp_seq[1:]\n            tmp_cseq = tmp_cseq[1:]\n        while tmp_seq.endswith('..') or tmp_cseq.endswith('..'):\n            tmp_seq = tmp_seq[:-1]\n            tmp_cseq = tmp_cseq[:-1]\n        if tmp_seq.startswith('.') or tmp_cseq.startswith('.'):\n            left_de = tmp_seq[:2] + '/' + tmp_cseq[:2]\n            try:\n                delta_h += de_table[left_de][d_h]\n                delta_s += de_table[left_de][d_s]\n            except KeyError:\n                _key_error(left_de, strict)\n            tmp_seq = tmp_seq[1:]\n            tmp_cseq = tmp_cseq[1:]\n        if tmp_seq.endswith('.') or tmp_cseq.endswith('.'):\n            right_de = tmp_cseq[-2:][::-1] + '/' + tmp_seq[-2:][::-1]\n            try:\n                delta_h += de_table[right_de][d_h]\n                delta_s += de_table[right_de][d_s]\n            except KeyError:\n                _key_error(right_de, strict)\n            tmp_seq = tmp_seq[:-1]\n            tmp_cseq = tmp_cseq[:-1]\n    left_tmm = tmp_cseq[:2][::-1] + '/' + tmp_seq[:2][::-1]\n    if left_tmm in tmm_table:\n        delta_h += tmm_table[left_tmm][d_h]\n        delta_s += tmm_table[left_tmm][d_s]\n        tmp_seq = tmp_seq[1:]\n        tmp_cseq = tmp_cseq[1:]\n    right_tmm = tmp_seq[-2:] + '/' + tmp_cseq[-2:]\n    if right_tmm in tmm_table:\n        delta_h += tmm_table[right_tmm][d_h]\n        delta_s += tmm_table[right_tmm][d_s]\n        tmp_seq = tmp_seq[:-1]\n        tmp_cseq = tmp_cseq[:-1]\n    delta_h += nn_table['init'][d_h]\n    delta_s += nn_table['init'][d_s]\n    if SeqUtils.gc_fraction(seq, 'ignore') == 0:\n        delta_h += nn_table['init_allA/T'][d_h]\n        delta_s += nn_table['init_allA/T'][d_s]\n    else:\n        delta_h += nn_table['init_oneG/C'][d_h]\n        delta_s += nn_table['init_oneG/C'][d_s]\n    if seq.startswith('T'):\n        delta_h += nn_table['init_5T/A'][d_h]\n        delta_s += nn_table['init_5T/A'][d_s]\n    if seq.endswith('A'):\n        delta_h += nn_table['init_5T/A'][d_h]\n        delta_s += nn_table['init_5T/A'][d_s]\n    ends = seq[0] + seq[-1]\n    AT = ends.count('A') + ends.count('T')\n    GC = ends.count('G') + ends.count('C')\n    delta_h += nn_table['init_A/T'][d_h] * AT\n    delta_s += nn_table['init_A/T'][d_s] * AT\n    delta_h += nn_table['init_G/C'][d_h] * GC\n    delta_s += nn_table['init_G/C'][d_s] * GC\n    for basenumber in range(len(tmp_seq) - 1):\n        neighbors = tmp_seq[basenumber:basenumber + 2] + '/' + tmp_cseq[basenumber:basenumber + 2]\n        if neighbors in imm_table:\n            delta_h += imm_table[neighbors][d_h]\n            delta_s += imm_table[neighbors][d_s]\n        elif neighbors[::-1] in imm_table:\n            delta_h += imm_table[neighbors[::-1]][d_h]\n            delta_s += imm_table[neighbors[::-1]][d_s]\n        elif neighbors in nn_table:\n            delta_h += nn_table[neighbors][d_h]\n            delta_s += nn_table[neighbors][d_s]\n        elif neighbors[::-1] in nn_table:\n            delta_h += nn_table[neighbors[::-1]][d_h]\n            delta_s += nn_table[neighbors[::-1]][d_s]\n        else:\n            _key_error(neighbors, strict)\n    k = (dnac1 - dnac2 / 2.0) * 1e-09\n    if selfcomp:\n        k = dnac1 * 1e-09\n        delta_h += nn_table['sym'][d_h]\n        delta_s += nn_table['sym'][d_s]\n    R = 1.987\n    if saltcorr:\n        corr = salt_correction(Na=Na, K=K, Tris=Tris, Mg=Mg, dNTPs=dNTPs, method=saltcorr, seq=seq)\n    if saltcorr == 5:\n        delta_s += corr\n    melting_temp = 1000 * delta_h / (delta_s + R * math.log(k)) - 273.15\n    if saltcorr in (1, 2, 3, 4):\n        melting_temp += corr\n    if saltcorr in (6, 7):\n        melting_temp = 1 / (1 / (melting_temp + 273.15) + corr) - 273.15\n    return melting_temp",
            "def Tm_NN(seq, check=True, strict=True, c_seq=None, shift=0, nn_table=None, tmm_table=None, imm_table=None, de_table=None, dnac1=25, dnac2=25, selfcomp=False, Na=50, K=0, Tris=0, Mg=0, dNTPs=0, saltcorr=5):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Return the Tm using nearest neighbor thermodynamics.\\n\\n    Arguments:\\n     - seq: The primer/probe sequence as string or Biopython sequence object.\\n       For RNA/DNA hybridizations seq must be the RNA sequence.\\n     - c_seq: Complementary sequence. The sequence of the template/target in\\n       3'->5' direction. c_seq is necessary for mismatch correction and\\n       dangling-ends correction. Both corrections will automatically be\\n       applied if mismatches or dangling ends are present. Default=None.\\n     - shift: Shift of the primer/probe sequence on the template/target\\n       sequence, e.g.::\\n\\n                           shift=0       shift=1        shift= -1\\n        Primer (seq):      5' ATGC...    5'  ATGC...    5' ATGC...\\n        Template (c_seq):  3' TACG...    3' CTACG...    3'  ACG...\\n\\n       The shift parameter is necessary to align seq and c_seq if they have\\n       different lengths or if they should have dangling ends. Default=0\\n     - table: Thermodynamic NN values, eight tables are implemented:\\n       For DNA/DNA hybridizations:\\n\\n        - DNA_NN1: values from Breslauer et al. (1986)\\n        - DNA_NN2: values from Sugimoto et al. (1996)\\n        - DNA_NN3: values from Allawi & SantaLucia (1997) (default)\\n        - DNA_NN4: values from SantaLucia & Hicks (2004)\\n\\n       For RNA/RNA hybridizations:\\n\\n        - RNA_NN1: values from Freier et al. (1986)\\n        - RNA_NN2: values from Xia et al. (1998)\\n        - RNA_NN3: values from Chen et al. (2012)\\n\\n       For RNA/DNA hybridizations:\\n\\n        - R_DNA_NN1: values from Sugimoto et al. (1995)\\n          Note that ``seq`` must be the RNA sequence.\\n\\n       Use the module's maketable method to make a new table or to update one\\n       one of the implemented tables.\\n     - tmm_table: Thermodynamic values for terminal mismatches.\\n       Default: DNA_TMM1 (SantaLucia & Peyret, 2001)\\n     - imm_table: Thermodynamic values for internal mismatches, may include\\n       insosine mismatches. Default: DNA_IMM1 (Allawi & SantaLucia, 1997-1998;\\n       Peyret et al., 1999; Watkins & SantaLucia, 2005)\\n     - de_table: Thermodynamic values for dangling ends:\\n\\n        - DNA_DE1: for DNA. Values from Bommarito et al. (2000) (default)\\n        - RNA_DE1: for RNA. Values from Turner & Mathews (2010)\\n\\n     - dnac1: Concentration of the higher concentrated strand [nM]. Typically\\n       this will be the primer (for PCR) or the probe. Default=25.\\n     - dnac2: Concentration of the lower concentrated strand [nM]. In PCR this\\n       is the template strand which concentration is typically very low and may\\n       be ignored (dnac2=0). In oligo/oligo hybridization experiments, dnac1\\n       equals dnac1. Default=25.\\n       MELTING and Primer3Plus use k = [Oligo(Total)]/4 by default. To mimic\\n       this behaviour, you have to divide [Oligo(Total)] by 2 and assign this\\n       concentration to dnac1 and dnac2. E.g., Total oligo concentration of\\n       50 nM in Primer3Plus means dnac1=25, dnac2=25.\\n     - selfcomp: Is the sequence self-complementary? Default=False. If 'True'\\n       the primer is thought binding to itself, thus dnac2 is not considered.\\n     - Na, K, Tris, Mg, dNTPs: See method 'Tm_GC' for details. Defaults: Na=50,\\n       K=0, Tris=0, Mg=0, dNTPs=0.\\n     - saltcorr: See method 'Tm_GC'. Default=5. 0 means no salt correction.\\n\\n    \"\n    if not nn_table:\n        nn_table = DNA_NN3\n    if not tmm_table:\n        tmm_table = DNA_TMM1\n    if not imm_table:\n        imm_table = DNA_IMM1\n    if not de_table:\n        de_table = DNA_DE1\n    seq = str(seq)\n    if not c_seq:\n        c_seq = Seq.Seq(seq).complement()\n    c_seq = str(c_seq)\n    if check:\n        seq = _check(seq, 'Tm_NN')\n        c_seq = _check(c_seq, 'Tm_NN')\n    tmp_seq = seq\n    tmp_cseq = c_seq\n    delta_h = 0\n    delta_s = 0\n    d_h = 0\n    d_s = 1\n    if shift or len(seq) != len(c_seq):\n        if shift > 0:\n            tmp_seq = '.' * shift + seq\n        if shift < 0:\n            tmp_cseq = '.' * abs(shift) + c_seq\n        if len(tmp_cseq) > len(tmp_seq):\n            tmp_seq += (len(tmp_cseq) - len(tmp_seq)) * '.'\n        if len(tmp_cseq) < len(tmp_seq):\n            tmp_cseq += (len(tmp_seq) - len(tmp_cseq)) * '.'\n        while tmp_seq.startswith('..') or tmp_cseq.startswith('..'):\n            tmp_seq = tmp_seq[1:]\n            tmp_cseq = tmp_cseq[1:]\n        while tmp_seq.endswith('..') or tmp_cseq.endswith('..'):\n            tmp_seq = tmp_seq[:-1]\n            tmp_cseq = tmp_cseq[:-1]\n        if tmp_seq.startswith('.') or tmp_cseq.startswith('.'):\n            left_de = tmp_seq[:2] + '/' + tmp_cseq[:2]\n            try:\n                delta_h += de_table[left_de][d_h]\n                delta_s += de_table[left_de][d_s]\n            except KeyError:\n                _key_error(left_de, strict)\n            tmp_seq = tmp_seq[1:]\n            tmp_cseq = tmp_cseq[1:]\n        if tmp_seq.endswith('.') or tmp_cseq.endswith('.'):\n            right_de = tmp_cseq[-2:][::-1] + '/' + tmp_seq[-2:][::-1]\n            try:\n                delta_h += de_table[right_de][d_h]\n                delta_s += de_table[right_de][d_s]\n            except KeyError:\n                _key_error(right_de, strict)\n            tmp_seq = tmp_seq[:-1]\n            tmp_cseq = tmp_cseq[:-1]\n    left_tmm = tmp_cseq[:2][::-1] + '/' + tmp_seq[:2][::-1]\n    if left_tmm in tmm_table:\n        delta_h += tmm_table[left_tmm][d_h]\n        delta_s += tmm_table[left_tmm][d_s]\n        tmp_seq = tmp_seq[1:]\n        tmp_cseq = tmp_cseq[1:]\n    right_tmm = tmp_seq[-2:] + '/' + tmp_cseq[-2:]\n    if right_tmm in tmm_table:\n        delta_h += tmm_table[right_tmm][d_h]\n        delta_s += tmm_table[right_tmm][d_s]\n        tmp_seq = tmp_seq[:-1]\n        tmp_cseq = tmp_cseq[:-1]\n    delta_h += nn_table['init'][d_h]\n    delta_s += nn_table['init'][d_s]\n    if SeqUtils.gc_fraction(seq, 'ignore') == 0:\n        delta_h += nn_table['init_allA/T'][d_h]\n        delta_s += nn_table['init_allA/T'][d_s]\n    else:\n        delta_h += nn_table['init_oneG/C'][d_h]\n        delta_s += nn_table['init_oneG/C'][d_s]\n    if seq.startswith('T'):\n        delta_h += nn_table['init_5T/A'][d_h]\n        delta_s += nn_table['init_5T/A'][d_s]\n    if seq.endswith('A'):\n        delta_h += nn_table['init_5T/A'][d_h]\n        delta_s += nn_table['init_5T/A'][d_s]\n    ends = seq[0] + seq[-1]\n    AT = ends.count('A') + ends.count('T')\n    GC = ends.count('G') + ends.count('C')\n    delta_h += nn_table['init_A/T'][d_h] * AT\n    delta_s += nn_table['init_A/T'][d_s] * AT\n    delta_h += nn_table['init_G/C'][d_h] * GC\n    delta_s += nn_table['init_G/C'][d_s] * GC\n    for basenumber in range(len(tmp_seq) - 1):\n        neighbors = tmp_seq[basenumber:basenumber + 2] + '/' + tmp_cseq[basenumber:basenumber + 2]\n        if neighbors in imm_table:\n            delta_h += imm_table[neighbors][d_h]\n            delta_s += imm_table[neighbors][d_s]\n        elif neighbors[::-1] in imm_table:\n            delta_h += imm_table[neighbors[::-1]][d_h]\n            delta_s += imm_table[neighbors[::-1]][d_s]\n        elif neighbors in nn_table:\n            delta_h += nn_table[neighbors][d_h]\n            delta_s += nn_table[neighbors][d_s]\n        elif neighbors[::-1] in nn_table:\n            delta_h += nn_table[neighbors[::-1]][d_h]\n            delta_s += nn_table[neighbors[::-1]][d_s]\n        else:\n            _key_error(neighbors, strict)\n    k = (dnac1 - dnac2 / 2.0) * 1e-09\n    if selfcomp:\n        k = dnac1 * 1e-09\n        delta_h += nn_table['sym'][d_h]\n        delta_s += nn_table['sym'][d_s]\n    R = 1.987\n    if saltcorr:\n        corr = salt_correction(Na=Na, K=K, Tris=Tris, Mg=Mg, dNTPs=dNTPs, method=saltcorr, seq=seq)\n    if saltcorr == 5:\n        delta_s += corr\n    melting_temp = 1000 * delta_h / (delta_s + R * math.log(k)) - 273.15\n    if saltcorr in (1, 2, 3, 4):\n        melting_temp += corr\n    if saltcorr in (6, 7):\n        melting_temp = 1 / (1 / (melting_temp + 273.15) + corr) - 273.15\n    return melting_temp",
            "def Tm_NN(seq, check=True, strict=True, c_seq=None, shift=0, nn_table=None, tmm_table=None, imm_table=None, de_table=None, dnac1=25, dnac2=25, selfcomp=False, Na=50, K=0, Tris=0, Mg=0, dNTPs=0, saltcorr=5):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Return the Tm using nearest neighbor thermodynamics.\\n\\n    Arguments:\\n     - seq: The primer/probe sequence as string or Biopython sequence object.\\n       For RNA/DNA hybridizations seq must be the RNA sequence.\\n     - c_seq: Complementary sequence. The sequence of the template/target in\\n       3'->5' direction. c_seq is necessary for mismatch correction and\\n       dangling-ends correction. Both corrections will automatically be\\n       applied if mismatches or dangling ends are present. Default=None.\\n     - shift: Shift of the primer/probe sequence on the template/target\\n       sequence, e.g.::\\n\\n                           shift=0       shift=1        shift= -1\\n        Primer (seq):      5' ATGC...    5'  ATGC...    5' ATGC...\\n        Template (c_seq):  3' TACG...    3' CTACG...    3'  ACG...\\n\\n       The shift parameter is necessary to align seq and c_seq if they have\\n       different lengths or if they should have dangling ends. Default=0\\n     - table: Thermodynamic NN values, eight tables are implemented:\\n       For DNA/DNA hybridizations:\\n\\n        - DNA_NN1: values from Breslauer et al. (1986)\\n        - DNA_NN2: values from Sugimoto et al. (1996)\\n        - DNA_NN3: values from Allawi & SantaLucia (1997) (default)\\n        - DNA_NN4: values from SantaLucia & Hicks (2004)\\n\\n       For RNA/RNA hybridizations:\\n\\n        - RNA_NN1: values from Freier et al. (1986)\\n        - RNA_NN2: values from Xia et al. (1998)\\n        - RNA_NN3: values from Chen et al. (2012)\\n\\n       For RNA/DNA hybridizations:\\n\\n        - R_DNA_NN1: values from Sugimoto et al. (1995)\\n          Note that ``seq`` must be the RNA sequence.\\n\\n       Use the module's maketable method to make a new table or to update one\\n       one of the implemented tables.\\n     - tmm_table: Thermodynamic values for terminal mismatches.\\n       Default: DNA_TMM1 (SantaLucia & Peyret, 2001)\\n     - imm_table: Thermodynamic values for internal mismatches, may include\\n       insosine mismatches. Default: DNA_IMM1 (Allawi & SantaLucia, 1997-1998;\\n       Peyret et al., 1999; Watkins & SantaLucia, 2005)\\n     - de_table: Thermodynamic values for dangling ends:\\n\\n        - DNA_DE1: for DNA. Values from Bommarito et al. (2000) (default)\\n        - RNA_DE1: for RNA. Values from Turner & Mathews (2010)\\n\\n     - dnac1: Concentration of the higher concentrated strand [nM]. Typically\\n       this will be the primer (for PCR) or the probe. Default=25.\\n     - dnac2: Concentration of the lower concentrated strand [nM]. In PCR this\\n       is the template strand which concentration is typically very low and may\\n       be ignored (dnac2=0). In oligo/oligo hybridization experiments, dnac1\\n       equals dnac1. Default=25.\\n       MELTING and Primer3Plus use k = [Oligo(Total)]/4 by default. To mimic\\n       this behaviour, you have to divide [Oligo(Total)] by 2 and assign this\\n       concentration to dnac1 and dnac2. E.g., Total oligo concentration of\\n       50 nM in Primer3Plus means dnac1=25, dnac2=25.\\n     - selfcomp: Is the sequence self-complementary? Default=False. If 'True'\\n       the primer is thought binding to itself, thus dnac2 is not considered.\\n     - Na, K, Tris, Mg, dNTPs: See method 'Tm_GC' for details. Defaults: Na=50,\\n       K=0, Tris=0, Mg=0, dNTPs=0.\\n     - saltcorr: See method 'Tm_GC'. Default=5. 0 means no salt correction.\\n\\n    \"\n    if not nn_table:\n        nn_table = DNA_NN3\n    if not tmm_table:\n        tmm_table = DNA_TMM1\n    if not imm_table:\n        imm_table = DNA_IMM1\n    if not de_table:\n        de_table = DNA_DE1\n    seq = str(seq)\n    if not c_seq:\n        c_seq = Seq.Seq(seq).complement()\n    c_seq = str(c_seq)\n    if check:\n        seq = _check(seq, 'Tm_NN')\n        c_seq = _check(c_seq, 'Tm_NN')\n    tmp_seq = seq\n    tmp_cseq = c_seq\n    delta_h = 0\n    delta_s = 0\n    d_h = 0\n    d_s = 1\n    if shift or len(seq) != len(c_seq):\n        if shift > 0:\n            tmp_seq = '.' * shift + seq\n        if shift < 0:\n            tmp_cseq = '.' * abs(shift) + c_seq\n        if len(tmp_cseq) > len(tmp_seq):\n            tmp_seq += (len(tmp_cseq) - len(tmp_seq)) * '.'\n        if len(tmp_cseq) < len(tmp_seq):\n            tmp_cseq += (len(tmp_seq) - len(tmp_cseq)) * '.'\n        while tmp_seq.startswith('..') or tmp_cseq.startswith('..'):\n            tmp_seq = tmp_seq[1:]\n            tmp_cseq = tmp_cseq[1:]\n        while tmp_seq.endswith('..') or tmp_cseq.endswith('..'):\n            tmp_seq = tmp_seq[:-1]\n            tmp_cseq = tmp_cseq[:-1]\n        if tmp_seq.startswith('.') or tmp_cseq.startswith('.'):\n            left_de = tmp_seq[:2] + '/' + tmp_cseq[:2]\n            try:\n                delta_h += de_table[left_de][d_h]\n                delta_s += de_table[left_de][d_s]\n            except KeyError:\n                _key_error(left_de, strict)\n            tmp_seq = tmp_seq[1:]\n            tmp_cseq = tmp_cseq[1:]\n        if tmp_seq.endswith('.') or tmp_cseq.endswith('.'):\n            right_de = tmp_cseq[-2:][::-1] + '/' + tmp_seq[-2:][::-1]\n            try:\n                delta_h += de_table[right_de][d_h]\n                delta_s += de_table[right_de][d_s]\n            except KeyError:\n                _key_error(right_de, strict)\n            tmp_seq = tmp_seq[:-1]\n            tmp_cseq = tmp_cseq[:-1]\n    left_tmm = tmp_cseq[:2][::-1] + '/' + tmp_seq[:2][::-1]\n    if left_tmm in tmm_table:\n        delta_h += tmm_table[left_tmm][d_h]\n        delta_s += tmm_table[left_tmm][d_s]\n        tmp_seq = tmp_seq[1:]\n        tmp_cseq = tmp_cseq[1:]\n    right_tmm = tmp_seq[-2:] + '/' + tmp_cseq[-2:]\n    if right_tmm in tmm_table:\n        delta_h += tmm_table[right_tmm][d_h]\n        delta_s += tmm_table[right_tmm][d_s]\n        tmp_seq = tmp_seq[:-1]\n        tmp_cseq = tmp_cseq[:-1]\n    delta_h += nn_table['init'][d_h]\n    delta_s += nn_table['init'][d_s]\n    if SeqUtils.gc_fraction(seq, 'ignore') == 0:\n        delta_h += nn_table['init_allA/T'][d_h]\n        delta_s += nn_table['init_allA/T'][d_s]\n    else:\n        delta_h += nn_table['init_oneG/C'][d_h]\n        delta_s += nn_table['init_oneG/C'][d_s]\n    if seq.startswith('T'):\n        delta_h += nn_table['init_5T/A'][d_h]\n        delta_s += nn_table['init_5T/A'][d_s]\n    if seq.endswith('A'):\n        delta_h += nn_table['init_5T/A'][d_h]\n        delta_s += nn_table['init_5T/A'][d_s]\n    ends = seq[0] + seq[-1]\n    AT = ends.count('A') + ends.count('T')\n    GC = ends.count('G') + ends.count('C')\n    delta_h += nn_table['init_A/T'][d_h] * AT\n    delta_s += nn_table['init_A/T'][d_s] * AT\n    delta_h += nn_table['init_G/C'][d_h] * GC\n    delta_s += nn_table['init_G/C'][d_s] * GC\n    for basenumber in range(len(tmp_seq) - 1):\n        neighbors = tmp_seq[basenumber:basenumber + 2] + '/' + tmp_cseq[basenumber:basenumber + 2]\n        if neighbors in imm_table:\n            delta_h += imm_table[neighbors][d_h]\n            delta_s += imm_table[neighbors][d_s]\n        elif neighbors[::-1] in imm_table:\n            delta_h += imm_table[neighbors[::-1]][d_h]\n            delta_s += imm_table[neighbors[::-1]][d_s]\n        elif neighbors in nn_table:\n            delta_h += nn_table[neighbors][d_h]\n            delta_s += nn_table[neighbors][d_s]\n        elif neighbors[::-1] in nn_table:\n            delta_h += nn_table[neighbors[::-1]][d_h]\n            delta_s += nn_table[neighbors[::-1]][d_s]\n        else:\n            _key_error(neighbors, strict)\n    k = (dnac1 - dnac2 / 2.0) * 1e-09\n    if selfcomp:\n        k = dnac1 * 1e-09\n        delta_h += nn_table['sym'][d_h]\n        delta_s += nn_table['sym'][d_s]\n    R = 1.987\n    if saltcorr:\n        corr = salt_correction(Na=Na, K=K, Tris=Tris, Mg=Mg, dNTPs=dNTPs, method=saltcorr, seq=seq)\n    if saltcorr == 5:\n        delta_s += corr\n    melting_temp = 1000 * delta_h / (delta_s + R * math.log(k)) - 273.15\n    if saltcorr in (1, 2, 3, 4):\n        melting_temp += corr\n    if saltcorr in (6, 7):\n        melting_temp = 1 / (1 / (melting_temp + 273.15) + corr) - 273.15\n    return melting_temp",
            "def Tm_NN(seq, check=True, strict=True, c_seq=None, shift=0, nn_table=None, tmm_table=None, imm_table=None, de_table=None, dnac1=25, dnac2=25, selfcomp=False, Na=50, K=0, Tris=0, Mg=0, dNTPs=0, saltcorr=5):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Return the Tm using nearest neighbor thermodynamics.\\n\\n    Arguments:\\n     - seq: The primer/probe sequence as string or Biopython sequence object.\\n       For RNA/DNA hybridizations seq must be the RNA sequence.\\n     - c_seq: Complementary sequence. The sequence of the template/target in\\n       3'->5' direction. c_seq is necessary for mismatch correction and\\n       dangling-ends correction. Both corrections will automatically be\\n       applied if mismatches or dangling ends are present. Default=None.\\n     - shift: Shift of the primer/probe sequence on the template/target\\n       sequence, e.g.::\\n\\n                           shift=0       shift=1        shift= -1\\n        Primer (seq):      5' ATGC...    5'  ATGC...    5' ATGC...\\n        Template (c_seq):  3' TACG...    3' CTACG...    3'  ACG...\\n\\n       The shift parameter is necessary to align seq and c_seq if they have\\n       different lengths or if they should have dangling ends. Default=0\\n     - table: Thermodynamic NN values, eight tables are implemented:\\n       For DNA/DNA hybridizations:\\n\\n        - DNA_NN1: values from Breslauer et al. (1986)\\n        - DNA_NN2: values from Sugimoto et al. (1996)\\n        - DNA_NN3: values from Allawi & SantaLucia (1997) (default)\\n        - DNA_NN4: values from SantaLucia & Hicks (2004)\\n\\n       For RNA/RNA hybridizations:\\n\\n        - RNA_NN1: values from Freier et al. (1986)\\n        - RNA_NN2: values from Xia et al. (1998)\\n        - RNA_NN3: values from Chen et al. (2012)\\n\\n       For RNA/DNA hybridizations:\\n\\n        - R_DNA_NN1: values from Sugimoto et al. (1995)\\n          Note that ``seq`` must be the RNA sequence.\\n\\n       Use the module's maketable method to make a new table or to update one\\n       one of the implemented tables.\\n     - tmm_table: Thermodynamic values for terminal mismatches.\\n       Default: DNA_TMM1 (SantaLucia & Peyret, 2001)\\n     - imm_table: Thermodynamic values for internal mismatches, may include\\n       insosine mismatches. Default: DNA_IMM1 (Allawi & SantaLucia, 1997-1998;\\n       Peyret et al., 1999; Watkins & SantaLucia, 2005)\\n     - de_table: Thermodynamic values for dangling ends:\\n\\n        - DNA_DE1: for DNA. Values from Bommarito et al. (2000) (default)\\n        - RNA_DE1: for RNA. Values from Turner & Mathews (2010)\\n\\n     - dnac1: Concentration of the higher concentrated strand [nM]. Typically\\n       this will be the primer (for PCR) or the probe. Default=25.\\n     - dnac2: Concentration of the lower concentrated strand [nM]. In PCR this\\n       is the template strand which concentration is typically very low and may\\n       be ignored (dnac2=0). In oligo/oligo hybridization experiments, dnac1\\n       equals dnac1. Default=25.\\n       MELTING and Primer3Plus use k = [Oligo(Total)]/4 by default. To mimic\\n       this behaviour, you have to divide [Oligo(Total)] by 2 and assign this\\n       concentration to dnac1 and dnac2. E.g., Total oligo concentration of\\n       50 nM in Primer3Plus means dnac1=25, dnac2=25.\\n     - selfcomp: Is the sequence self-complementary? Default=False. If 'True'\\n       the primer is thought binding to itself, thus dnac2 is not considered.\\n     - Na, K, Tris, Mg, dNTPs: See method 'Tm_GC' for details. Defaults: Na=50,\\n       K=0, Tris=0, Mg=0, dNTPs=0.\\n     - saltcorr: See method 'Tm_GC'. Default=5. 0 means no salt correction.\\n\\n    \"\n    if not nn_table:\n        nn_table = DNA_NN3\n    if not tmm_table:\n        tmm_table = DNA_TMM1\n    if not imm_table:\n        imm_table = DNA_IMM1\n    if not de_table:\n        de_table = DNA_DE1\n    seq = str(seq)\n    if not c_seq:\n        c_seq = Seq.Seq(seq).complement()\n    c_seq = str(c_seq)\n    if check:\n        seq = _check(seq, 'Tm_NN')\n        c_seq = _check(c_seq, 'Tm_NN')\n    tmp_seq = seq\n    tmp_cseq = c_seq\n    delta_h = 0\n    delta_s = 0\n    d_h = 0\n    d_s = 1\n    if shift or len(seq) != len(c_seq):\n        if shift > 0:\n            tmp_seq = '.' * shift + seq\n        if shift < 0:\n            tmp_cseq = '.' * abs(shift) + c_seq\n        if len(tmp_cseq) > len(tmp_seq):\n            tmp_seq += (len(tmp_cseq) - len(tmp_seq)) * '.'\n        if len(tmp_cseq) < len(tmp_seq):\n            tmp_cseq += (len(tmp_seq) - len(tmp_cseq)) * '.'\n        while tmp_seq.startswith('..') or tmp_cseq.startswith('..'):\n            tmp_seq = tmp_seq[1:]\n            tmp_cseq = tmp_cseq[1:]\n        while tmp_seq.endswith('..') or tmp_cseq.endswith('..'):\n            tmp_seq = tmp_seq[:-1]\n            tmp_cseq = tmp_cseq[:-1]\n        if tmp_seq.startswith('.') or tmp_cseq.startswith('.'):\n            left_de = tmp_seq[:2] + '/' + tmp_cseq[:2]\n            try:\n                delta_h += de_table[left_de][d_h]\n                delta_s += de_table[left_de][d_s]\n            except KeyError:\n                _key_error(left_de, strict)\n            tmp_seq = tmp_seq[1:]\n            tmp_cseq = tmp_cseq[1:]\n        if tmp_seq.endswith('.') or tmp_cseq.endswith('.'):\n            right_de = tmp_cseq[-2:][::-1] + '/' + tmp_seq[-2:][::-1]\n            try:\n                delta_h += de_table[right_de][d_h]\n                delta_s += de_table[right_de][d_s]\n            except KeyError:\n                _key_error(right_de, strict)\n            tmp_seq = tmp_seq[:-1]\n            tmp_cseq = tmp_cseq[:-1]\n    left_tmm = tmp_cseq[:2][::-1] + '/' + tmp_seq[:2][::-1]\n    if left_tmm in tmm_table:\n        delta_h += tmm_table[left_tmm][d_h]\n        delta_s += tmm_table[left_tmm][d_s]\n        tmp_seq = tmp_seq[1:]\n        tmp_cseq = tmp_cseq[1:]\n    right_tmm = tmp_seq[-2:] + '/' + tmp_cseq[-2:]\n    if right_tmm in tmm_table:\n        delta_h += tmm_table[right_tmm][d_h]\n        delta_s += tmm_table[right_tmm][d_s]\n        tmp_seq = tmp_seq[:-1]\n        tmp_cseq = tmp_cseq[:-1]\n    delta_h += nn_table['init'][d_h]\n    delta_s += nn_table['init'][d_s]\n    if SeqUtils.gc_fraction(seq, 'ignore') == 0:\n        delta_h += nn_table['init_allA/T'][d_h]\n        delta_s += nn_table['init_allA/T'][d_s]\n    else:\n        delta_h += nn_table['init_oneG/C'][d_h]\n        delta_s += nn_table['init_oneG/C'][d_s]\n    if seq.startswith('T'):\n        delta_h += nn_table['init_5T/A'][d_h]\n        delta_s += nn_table['init_5T/A'][d_s]\n    if seq.endswith('A'):\n        delta_h += nn_table['init_5T/A'][d_h]\n        delta_s += nn_table['init_5T/A'][d_s]\n    ends = seq[0] + seq[-1]\n    AT = ends.count('A') + ends.count('T')\n    GC = ends.count('G') + ends.count('C')\n    delta_h += nn_table['init_A/T'][d_h] * AT\n    delta_s += nn_table['init_A/T'][d_s] * AT\n    delta_h += nn_table['init_G/C'][d_h] * GC\n    delta_s += nn_table['init_G/C'][d_s] * GC\n    for basenumber in range(len(tmp_seq) - 1):\n        neighbors = tmp_seq[basenumber:basenumber + 2] + '/' + tmp_cseq[basenumber:basenumber + 2]\n        if neighbors in imm_table:\n            delta_h += imm_table[neighbors][d_h]\n            delta_s += imm_table[neighbors][d_s]\n        elif neighbors[::-1] in imm_table:\n            delta_h += imm_table[neighbors[::-1]][d_h]\n            delta_s += imm_table[neighbors[::-1]][d_s]\n        elif neighbors in nn_table:\n            delta_h += nn_table[neighbors][d_h]\n            delta_s += nn_table[neighbors][d_s]\n        elif neighbors[::-1] in nn_table:\n            delta_h += nn_table[neighbors[::-1]][d_h]\n            delta_s += nn_table[neighbors[::-1]][d_s]\n        else:\n            _key_error(neighbors, strict)\n    k = (dnac1 - dnac2 / 2.0) * 1e-09\n    if selfcomp:\n        k = dnac1 * 1e-09\n        delta_h += nn_table['sym'][d_h]\n        delta_s += nn_table['sym'][d_s]\n    R = 1.987\n    if saltcorr:\n        corr = salt_correction(Na=Na, K=K, Tris=Tris, Mg=Mg, dNTPs=dNTPs, method=saltcorr, seq=seq)\n    if saltcorr == 5:\n        delta_s += corr\n    melting_temp = 1000 * delta_h / (delta_s + R * math.log(k)) - 273.15\n    if saltcorr in (1, 2, 3, 4):\n        melting_temp += corr\n    if saltcorr in (6, 7):\n        melting_temp = 1 / (1 / (melting_temp + 273.15) + corr) - 273.15\n    return melting_temp",
            "def Tm_NN(seq, check=True, strict=True, c_seq=None, shift=0, nn_table=None, tmm_table=None, imm_table=None, de_table=None, dnac1=25, dnac2=25, selfcomp=False, Na=50, K=0, Tris=0, Mg=0, dNTPs=0, saltcorr=5):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Return the Tm using nearest neighbor thermodynamics.\\n\\n    Arguments:\\n     - seq: The primer/probe sequence as string or Biopython sequence object.\\n       For RNA/DNA hybridizations seq must be the RNA sequence.\\n     - c_seq: Complementary sequence. The sequence of the template/target in\\n       3'->5' direction. c_seq is necessary for mismatch correction and\\n       dangling-ends correction. Both corrections will automatically be\\n       applied if mismatches or dangling ends are present. Default=None.\\n     - shift: Shift of the primer/probe sequence on the template/target\\n       sequence, e.g.::\\n\\n                           shift=0       shift=1        shift= -1\\n        Primer (seq):      5' ATGC...    5'  ATGC...    5' ATGC...\\n        Template (c_seq):  3' TACG...    3' CTACG...    3'  ACG...\\n\\n       The shift parameter is necessary to align seq and c_seq if they have\\n       different lengths or if they should have dangling ends. Default=0\\n     - table: Thermodynamic NN values, eight tables are implemented:\\n       For DNA/DNA hybridizations:\\n\\n        - DNA_NN1: values from Breslauer et al. (1986)\\n        - DNA_NN2: values from Sugimoto et al. (1996)\\n        - DNA_NN3: values from Allawi & SantaLucia (1997) (default)\\n        - DNA_NN4: values from SantaLucia & Hicks (2004)\\n\\n       For RNA/RNA hybridizations:\\n\\n        - RNA_NN1: values from Freier et al. (1986)\\n        - RNA_NN2: values from Xia et al. (1998)\\n        - RNA_NN3: values from Chen et al. (2012)\\n\\n       For RNA/DNA hybridizations:\\n\\n        - R_DNA_NN1: values from Sugimoto et al. (1995)\\n          Note that ``seq`` must be the RNA sequence.\\n\\n       Use the module's maketable method to make a new table or to update one\\n       one of the implemented tables.\\n     - tmm_table: Thermodynamic values for terminal mismatches.\\n       Default: DNA_TMM1 (SantaLucia & Peyret, 2001)\\n     - imm_table: Thermodynamic values for internal mismatches, may include\\n       insosine mismatches. Default: DNA_IMM1 (Allawi & SantaLucia, 1997-1998;\\n       Peyret et al., 1999; Watkins & SantaLucia, 2005)\\n     - de_table: Thermodynamic values for dangling ends:\\n\\n        - DNA_DE1: for DNA. Values from Bommarito et al. (2000) (default)\\n        - RNA_DE1: for RNA. Values from Turner & Mathews (2010)\\n\\n     - dnac1: Concentration of the higher concentrated strand [nM]. Typically\\n       this will be the primer (for PCR) or the probe. Default=25.\\n     - dnac2: Concentration of the lower concentrated strand [nM]. In PCR this\\n       is the template strand which concentration is typically very low and may\\n       be ignored (dnac2=0). In oligo/oligo hybridization experiments, dnac1\\n       equals dnac1. Default=25.\\n       MELTING and Primer3Plus use k = [Oligo(Total)]/4 by default. To mimic\\n       this behaviour, you have to divide [Oligo(Total)] by 2 and assign this\\n       concentration to dnac1 and dnac2. E.g., Total oligo concentration of\\n       50 nM in Primer3Plus means dnac1=25, dnac2=25.\\n     - selfcomp: Is the sequence self-complementary? Default=False. If 'True'\\n       the primer is thought binding to itself, thus dnac2 is not considered.\\n     - Na, K, Tris, Mg, dNTPs: See method 'Tm_GC' for details. Defaults: Na=50,\\n       K=0, Tris=0, Mg=0, dNTPs=0.\\n     - saltcorr: See method 'Tm_GC'. Default=5. 0 means no salt correction.\\n\\n    \"\n    if not nn_table:\n        nn_table = DNA_NN3\n    if not tmm_table:\n        tmm_table = DNA_TMM1\n    if not imm_table:\n        imm_table = DNA_IMM1\n    if not de_table:\n        de_table = DNA_DE1\n    seq = str(seq)\n    if not c_seq:\n        c_seq = Seq.Seq(seq).complement()\n    c_seq = str(c_seq)\n    if check:\n        seq = _check(seq, 'Tm_NN')\n        c_seq = _check(c_seq, 'Tm_NN')\n    tmp_seq = seq\n    tmp_cseq = c_seq\n    delta_h = 0\n    delta_s = 0\n    d_h = 0\n    d_s = 1\n    if shift or len(seq) != len(c_seq):\n        if shift > 0:\n            tmp_seq = '.' * shift + seq\n        if shift < 0:\n            tmp_cseq = '.' * abs(shift) + c_seq\n        if len(tmp_cseq) > len(tmp_seq):\n            tmp_seq += (len(tmp_cseq) - len(tmp_seq)) * '.'\n        if len(tmp_cseq) < len(tmp_seq):\n            tmp_cseq += (len(tmp_seq) - len(tmp_cseq)) * '.'\n        while tmp_seq.startswith('..') or tmp_cseq.startswith('..'):\n            tmp_seq = tmp_seq[1:]\n            tmp_cseq = tmp_cseq[1:]\n        while tmp_seq.endswith('..') or tmp_cseq.endswith('..'):\n            tmp_seq = tmp_seq[:-1]\n            tmp_cseq = tmp_cseq[:-1]\n        if tmp_seq.startswith('.') or tmp_cseq.startswith('.'):\n            left_de = tmp_seq[:2] + '/' + tmp_cseq[:2]\n            try:\n                delta_h += de_table[left_de][d_h]\n                delta_s += de_table[left_de][d_s]\n            except KeyError:\n                _key_error(left_de, strict)\n            tmp_seq = tmp_seq[1:]\n            tmp_cseq = tmp_cseq[1:]\n        if tmp_seq.endswith('.') or tmp_cseq.endswith('.'):\n            right_de = tmp_cseq[-2:][::-1] + '/' + tmp_seq[-2:][::-1]\n            try:\n                delta_h += de_table[right_de][d_h]\n                delta_s += de_table[right_de][d_s]\n            except KeyError:\n                _key_error(right_de, strict)\n            tmp_seq = tmp_seq[:-1]\n            tmp_cseq = tmp_cseq[:-1]\n    left_tmm = tmp_cseq[:2][::-1] + '/' + tmp_seq[:2][::-1]\n    if left_tmm in tmm_table:\n        delta_h += tmm_table[left_tmm][d_h]\n        delta_s += tmm_table[left_tmm][d_s]\n        tmp_seq = tmp_seq[1:]\n        tmp_cseq = tmp_cseq[1:]\n    right_tmm = tmp_seq[-2:] + '/' + tmp_cseq[-2:]\n    if right_tmm in tmm_table:\n        delta_h += tmm_table[right_tmm][d_h]\n        delta_s += tmm_table[right_tmm][d_s]\n        tmp_seq = tmp_seq[:-1]\n        tmp_cseq = tmp_cseq[:-1]\n    delta_h += nn_table['init'][d_h]\n    delta_s += nn_table['init'][d_s]\n    if SeqUtils.gc_fraction(seq, 'ignore') == 0:\n        delta_h += nn_table['init_allA/T'][d_h]\n        delta_s += nn_table['init_allA/T'][d_s]\n    else:\n        delta_h += nn_table['init_oneG/C'][d_h]\n        delta_s += nn_table['init_oneG/C'][d_s]\n    if seq.startswith('T'):\n        delta_h += nn_table['init_5T/A'][d_h]\n        delta_s += nn_table['init_5T/A'][d_s]\n    if seq.endswith('A'):\n        delta_h += nn_table['init_5T/A'][d_h]\n        delta_s += nn_table['init_5T/A'][d_s]\n    ends = seq[0] + seq[-1]\n    AT = ends.count('A') + ends.count('T')\n    GC = ends.count('G') + ends.count('C')\n    delta_h += nn_table['init_A/T'][d_h] * AT\n    delta_s += nn_table['init_A/T'][d_s] * AT\n    delta_h += nn_table['init_G/C'][d_h] * GC\n    delta_s += nn_table['init_G/C'][d_s] * GC\n    for basenumber in range(len(tmp_seq) - 1):\n        neighbors = tmp_seq[basenumber:basenumber + 2] + '/' + tmp_cseq[basenumber:basenumber + 2]\n        if neighbors in imm_table:\n            delta_h += imm_table[neighbors][d_h]\n            delta_s += imm_table[neighbors][d_s]\n        elif neighbors[::-1] in imm_table:\n            delta_h += imm_table[neighbors[::-1]][d_h]\n            delta_s += imm_table[neighbors[::-1]][d_s]\n        elif neighbors in nn_table:\n            delta_h += nn_table[neighbors][d_h]\n            delta_s += nn_table[neighbors][d_s]\n        elif neighbors[::-1] in nn_table:\n            delta_h += nn_table[neighbors[::-1]][d_h]\n            delta_s += nn_table[neighbors[::-1]][d_s]\n        else:\n            _key_error(neighbors, strict)\n    k = (dnac1 - dnac2 / 2.0) * 1e-09\n    if selfcomp:\n        k = dnac1 * 1e-09\n        delta_h += nn_table['sym'][d_h]\n        delta_s += nn_table['sym'][d_s]\n    R = 1.987\n    if saltcorr:\n        corr = salt_correction(Na=Na, K=K, Tris=Tris, Mg=Mg, dNTPs=dNTPs, method=saltcorr, seq=seq)\n    if saltcorr == 5:\n        delta_s += corr\n    melting_temp = 1000 * delta_h / (delta_s + R * math.log(k)) - 273.15\n    if saltcorr in (1, 2, 3, 4):\n        melting_temp += corr\n    if saltcorr in (6, 7):\n        melting_temp = 1 / (1 / (melting_temp + 273.15) + corr) - 273.15\n    return melting_temp"
        ]
    }
]