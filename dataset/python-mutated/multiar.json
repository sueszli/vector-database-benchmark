[
    {
        "func_name": "addmm",
        "original": "@dygraph_only\ndef addmm(input, x, y, beta=1.0, alpha=1.0, name=None):\n    \"\"\"\n    Note:\n        This API is only supported from ``CUDA 11.0`` .\n\n    Applies matrix multiplication for `x` and `y` , `input` is added to\n    the final result. The equation is:\n\n    ..  math::\n\n        out = alpha * x * y + beta * input\n\n    The supported input/output Tensor layout are as follows:\n\n    Note:\n        input[SparseCsrTensor] + x[SparseCsrTensor] @ y[SparseCsrTensor] -> out[SparseCsrTensor]\n        input[DenseTensor] + x[SparseCsrTensor] @ y[DenseTensor] -> out[DenseTensor]\n        input[SparseCooTensor] + x[SparseCooTensor] @ y[SparseCooTensor] -> out[SparseCooTensor]\n        input[DenseTensor] + x[SparseCooTensor] @ y[DenseTensor] -> out[DenseTensor]\n\n    It supports backward propagation.\n\n    Dimensions `input` , `x` , `y` must be same and >= 2D. Automatic broadcasting of Tensor is not supported.\n\n    Args:\n        input (SparseTensor|DenseTensor): The input tensor. Shape is [*, M, N]. The data type can be float32 or float64.\n        x (SparseTensor): The input SparseTensor. Shape is [*, M, K]. The data type can be float32 or float64.\n        y (SparseTensor|DenseTensor): The input tensor. Shape is [*, K, N]. The data type can be float32 or float64.\n        beta (float, optional): Coefficient of `input` . Default: 1.0\n        alpha (float, optional): Coefficient of `x * y` . Default: 1.0\n        name (str, optional): Name for the operation (optional, default is None). For more information, please refer to :ref:`api_guide_Name`.\n\n    Returns:\n        SparseTensor|DenseTensor: Tensor type, date type and shape is the same with `input` .\n\n    Examples:\n\n        .. code-block:: python\n\n            >>> # doctest: +REQUIRES(env:GPU)\n            >>> import paddle\n            >>> paddle.device.set_device('gpu')\n\n            >>> # dense + csr @ dense -> dense\n            >>> input = paddle.rand([3, 2])\n            >>> crows = [0, 1, 2, 3]\n            >>> cols = [1, 2, 0]\n            >>> values = [1., 2., 3.]\n            >>> x = paddle.sparse.sparse_csr_tensor(crows, cols, values, [3, 3])\n            >>> y = paddle.rand([3, 2])\n            >>> out = paddle.sparse.addmm(input, x, y, 3.0, 2.0)\n\n            >>> # dense + coo @ dense -> dense\n            >>> input = paddle.rand([3, 2])\n            >>> indices = [[0, 1, 2], [1, 2, 0]]\n            >>> values = [1., 2., 3.]\n            >>> x = paddle.sparse.sparse_coo_tensor(indices, values, [3, 3])\n            >>> y = paddle.rand([3, 2])\n            >>> out = paddle.sparse.addmm(input, x, y, 3.0, 2.0)\n\n    \"\"\"\n    return _C_ops.sparse_addmm(input, x, y, beta, alpha)",
        "mutated": [
            "@dygraph_only\ndef addmm(input, x, y, beta=1.0, alpha=1.0, name=None):\n    if False:\n        i = 10\n    \"\\n    Note:\\n        This API is only supported from ``CUDA 11.0`` .\\n\\n    Applies matrix multiplication for `x` and `y` , `input` is added to\\n    the final result. The equation is:\\n\\n    ..  math::\\n\\n        out = alpha * x * y + beta * input\\n\\n    The supported input/output Tensor layout are as follows:\\n\\n    Note:\\n        input[SparseCsrTensor] + x[SparseCsrTensor] @ y[SparseCsrTensor] -> out[SparseCsrTensor]\\n        input[DenseTensor] + x[SparseCsrTensor] @ y[DenseTensor] -> out[DenseTensor]\\n        input[SparseCooTensor] + x[SparseCooTensor] @ y[SparseCooTensor] -> out[SparseCooTensor]\\n        input[DenseTensor] + x[SparseCooTensor] @ y[DenseTensor] -> out[DenseTensor]\\n\\n    It supports backward propagation.\\n\\n    Dimensions `input` , `x` , `y` must be same and >= 2D. Automatic broadcasting of Tensor is not supported.\\n\\n    Args:\\n        input (SparseTensor|DenseTensor): The input tensor. Shape is [*, M, N]. The data type can be float32 or float64.\\n        x (SparseTensor): The input SparseTensor. Shape is [*, M, K]. The data type can be float32 or float64.\\n        y (SparseTensor|DenseTensor): The input tensor. Shape is [*, K, N]. The data type can be float32 or float64.\\n        beta (float, optional): Coefficient of `input` . Default: 1.0\\n        alpha (float, optional): Coefficient of `x * y` . Default: 1.0\\n        name (str, optional): Name for the operation (optional, default is None). For more information, please refer to :ref:`api_guide_Name`.\\n\\n    Returns:\\n        SparseTensor|DenseTensor: Tensor type, date type and shape is the same with `input` .\\n\\n    Examples:\\n\\n        .. code-block:: python\\n\\n            >>> # doctest: +REQUIRES(env:GPU)\\n            >>> import paddle\\n            >>> paddle.device.set_device('gpu')\\n\\n            >>> # dense + csr @ dense -> dense\\n            >>> input = paddle.rand([3, 2])\\n            >>> crows = [0, 1, 2, 3]\\n            >>> cols = [1, 2, 0]\\n            >>> values = [1., 2., 3.]\\n            >>> x = paddle.sparse.sparse_csr_tensor(crows, cols, values, [3, 3])\\n            >>> y = paddle.rand([3, 2])\\n            >>> out = paddle.sparse.addmm(input, x, y, 3.0, 2.0)\\n\\n            >>> # dense + coo @ dense -> dense\\n            >>> input = paddle.rand([3, 2])\\n            >>> indices = [[0, 1, 2], [1, 2, 0]]\\n            >>> values = [1., 2., 3.]\\n            >>> x = paddle.sparse.sparse_coo_tensor(indices, values, [3, 3])\\n            >>> y = paddle.rand([3, 2])\\n            >>> out = paddle.sparse.addmm(input, x, y, 3.0, 2.0)\\n\\n    \"\n    return _C_ops.sparse_addmm(input, x, y, beta, alpha)",
            "@dygraph_only\ndef addmm(input, x, y, beta=1.0, alpha=1.0, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Note:\\n        This API is only supported from ``CUDA 11.0`` .\\n\\n    Applies matrix multiplication for `x` and `y` , `input` is added to\\n    the final result. The equation is:\\n\\n    ..  math::\\n\\n        out = alpha * x * y + beta * input\\n\\n    The supported input/output Tensor layout are as follows:\\n\\n    Note:\\n        input[SparseCsrTensor] + x[SparseCsrTensor] @ y[SparseCsrTensor] -> out[SparseCsrTensor]\\n        input[DenseTensor] + x[SparseCsrTensor] @ y[DenseTensor] -> out[DenseTensor]\\n        input[SparseCooTensor] + x[SparseCooTensor] @ y[SparseCooTensor] -> out[SparseCooTensor]\\n        input[DenseTensor] + x[SparseCooTensor] @ y[DenseTensor] -> out[DenseTensor]\\n\\n    It supports backward propagation.\\n\\n    Dimensions `input` , `x` , `y` must be same and >= 2D. Automatic broadcasting of Tensor is not supported.\\n\\n    Args:\\n        input (SparseTensor|DenseTensor): The input tensor. Shape is [*, M, N]. The data type can be float32 or float64.\\n        x (SparseTensor): The input SparseTensor. Shape is [*, M, K]. The data type can be float32 or float64.\\n        y (SparseTensor|DenseTensor): The input tensor. Shape is [*, K, N]. The data type can be float32 or float64.\\n        beta (float, optional): Coefficient of `input` . Default: 1.0\\n        alpha (float, optional): Coefficient of `x * y` . Default: 1.0\\n        name (str, optional): Name for the operation (optional, default is None). For more information, please refer to :ref:`api_guide_Name`.\\n\\n    Returns:\\n        SparseTensor|DenseTensor: Tensor type, date type and shape is the same with `input` .\\n\\n    Examples:\\n\\n        .. code-block:: python\\n\\n            >>> # doctest: +REQUIRES(env:GPU)\\n            >>> import paddle\\n            >>> paddle.device.set_device('gpu')\\n\\n            >>> # dense + csr @ dense -> dense\\n            >>> input = paddle.rand([3, 2])\\n            >>> crows = [0, 1, 2, 3]\\n            >>> cols = [1, 2, 0]\\n            >>> values = [1., 2., 3.]\\n            >>> x = paddle.sparse.sparse_csr_tensor(crows, cols, values, [3, 3])\\n            >>> y = paddle.rand([3, 2])\\n            >>> out = paddle.sparse.addmm(input, x, y, 3.0, 2.0)\\n\\n            >>> # dense + coo @ dense -> dense\\n            >>> input = paddle.rand([3, 2])\\n            >>> indices = [[0, 1, 2], [1, 2, 0]]\\n            >>> values = [1., 2., 3.]\\n            >>> x = paddle.sparse.sparse_coo_tensor(indices, values, [3, 3])\\n            >>> y = paddle.rand([3, 2])\\n            >>> out = paddle.sparse.addmm(input, x, y, 3.0, 2.0)\\n\\n    \"\n    return _C_ops.sparse_addmm(input, x, y, beta, alpha)",
            "@dygraph_only\ndef addmm(input, x, y, beta=1.0, alpha=1.0, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Note:\\n        This API is only supported from ``CUDA 11.0`` .\\n\\n    Applies matrix multiplication for `x` and `y` , `input` is added to\\n    the final result. The equation is:\\n\\n    ..  math::\\n\\n        out = alpha * x * y + beta * input\\n\\n    The supported input/output Tensor layout are as follows:\\n\\n    Note:\\n        input[SparseCsrTensor] + x[SparseCsrTensor] @ y[SparseCsrTensor] -> out[SparseCsrTensor]\\n        input[DenseTensor] + x[SparseCsrTensor] @ y[DenseTensor] -> out[DenseTensor]\\n        input[SparseCooTensor] + x[SparseCooTensor] @ y[SparseCooTensor] -> out[SparseCooTensor]\\n        input[DenseTensor] + x[SparseCooTensor] @ y[DenseTensor] -> out[DenseTensor]\\n\\n    It supports backward propagation.\\n\\n    Dimensions `input` , `x` , `y` must be same and >= 2D. Automatic broadcasting of Tensor is not supported.\\n\\n    Args:\\n        input (SparseTensor|DenseTensor): The input tensor. Shape is [*, M, N]. The data type can be float32 or float64.\\n        x (SparseTensor): The input SparseTensor. Shape is [*, M, K]. The data type can be float32 or float64.\\n        y (SparseTensor|DenseTensor): The input tensor. Shape is [*, K, N]. The data type can be float32 or float64.\\n        beta (float, optional): Coefficient of `input` . Default: 1.0\\n        alpha (float, optional): Coefficient of `x * y` . Default: 1.0\\n        name (str, optional): Name for the operation (optional, default is None). For more information, please refer to :ref:`api_guide_Name`.\\n\\n    Returns:\\n        SparseTensor|DenseTensor: Tensor type, date type and shape is the same with `input` .\\n\\n    Examples:\\n\\n        .. code-block:: python\\n\\n            >>> # doctest: +REQUIRES(env:GPU)\\n            >>> import paddle\\n            >>> paddle.device.set_device('gpu')\\n\\n            >>> # dense + csr @ dense -> dense\\n            >>> input = paddle.rand([3, 2])\\n            >>> crows = [0, 1, 2, 3]\\n            >>> cols = [1, 2, 0]\\n            >>> values = [1., 2., 3.]\\n            >>> x = paddle.sparse.sparse_csr_tensor(crows, cols, values, [3, 3])\\n            >>> y = paddle.rand([3, 2])\\n            >>> out = paddle.sparse.addmm(input, x, y, 3.0, 2.0)\\n\\n            >>> # dense + coo @ dense -> dense\\n            >>> input = paddle.rand([3, 2])\\n            >>> indices = [[0, 1, 2], [1, 2, 0]]\\n            >>> values = [1., 2., 3.]\\n            >>> x = paddle.sparse.sparse_coo_tensor(indices, values, [3, 3])\\n            >>> y = paddle.rand([3, 2])\\n            >>> out = paddle.sparse.addmm(input, x, y, 3.0, 2.0)\\n\\n    \"\n    return _C_ops.sparse_addmm(input, x, y, beta, alpha)",
            "@dygraph_only\ndef addmm(input, x, y, beta=1.0, alpha=1.0, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Note:\\n        This API is only supported from ``CUDA 11.0`` .\\n\\n    Applies matrix multiplication for `x` and `y` , `input` is added to\\n    the final result. The equation is:\\n\\n    ..  math::\\n\\n        out = alpha * x * y + beta * input\\n\\n    The supported input/output Tensor layout are as follows:\\n\\n    Note:\\n        input[SparseCsrTensor] + x[SparseCsrTensor] @ y[SparseCsrTensor] -> out[SparseCsrTensor]\\n        input[DenseTensor] + x[SparseCsrTensor] @ y[DenseTensor] -> out[DenseTensor]\\n        input[SparseCooTensor] + x[SparseCooTensor] @ y[SparseCooTensor] -> out[SparseCooTensor]\\n        input[DenseTensor] + x[SparseCooTensor] @ y[DenseTensor] -> out[DenseTensor]\\n\\n    It supports backward propagation.\\n\\n    Dimensions `input` , `x` , `y` must be same and >= 2D. Automatic broadcasting of Tensor is not supported.\\n\\n    Args:\\n        input (SparseTensor|DenseTensor): The input tensor. Shape is [*, M, N]. The data type can be float32 or float64.\\n        x (SparseTensor): The input SparseTensor. Shape is [*, M, K]. The data type can be float32 or float64.\\n        y (SparseTensor|DenseTensor): The input tensor. Shape is [*, K, N]. The data type can be float32 or float64.\\n        beta (float, optional): Coefficient of `input` . Default: 1.0\\n        alpha (float, optional): Coefficient of `x * y` . Default: 1.0\\n        name (str, optional): Name for the operation (optional, default is None). For more information, please refer to :ref:`api_guide_Name`.\\n\\n    Returns:\\n        SparseTensor|DenseTensor: Tensor type, date type and shape is the same with `input` .\\n\\n    Examples:\\n\\n        .. code-block:: python\\n\\n            >>> # doctest: +REQUIRES(env:GPU)\\n            >>> import paddle\\n            >>> paddle.device.set_device('gpu')\\n\\n            >>> # dense + csr @ dense -> dense\\n            >>> input = paddle.rand([3, 2])\\n            >>> crows = [0, 1, 2, 3]\\n            >>> cols = [1, 2, 0]\\n            >>> values = [1., 2., 3.]\\n            >>> x = paddle.sparse.sparse_csr_tensor(crows, cols, values, [3, 3])\\n            >>> y = paddle.rand([3, 2])\\n            >>> out = paddle.sparse.addmm(input, x, y, 3.0, 2.0)\\n\\n            >>> # dense + coo @ dense -> dense\\n            >>> input = paddle.rand([3, 2])\\n            >>> indices = [[0, 1, 2], [1, 2, 0]]\\n            >>> values = [1., 2., 3.]\\n            >>> x = paddle.sparse.sparse_coo_tensor(indices, values, [3, 3])\\n            >>> y = paddle.rand([3, 2])\\n            >>> out = paddle.sparse.addmm(input, x, y, 3.0, 2.0)\\n\\n    \"\n    return _C_ops.sparse_addmm(input, x, y, beta, alpha)",
            "@dygraph_only\ndef addmm(input, x, y, beta=1.0, alpha=1.0, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Note:\\n        This API is only supported from ``CUDA 11.0`` .\\n\\n    Applies matrix multiplication for `x` and `y` , `input` is added to\\n    the final result. The equation is:\\n\\n    ..  math::\\n\\n        out = alpha * x * y + beta * input\\n\\n    The supported input/output Tensor layout are as follows:\\n\\n    Note:\\n        input[SparseCsrTensor] + x[SparseCsrTensor] @ y[SparseCsrTensor] -> out[SparseCsrTensor]\\n        input[DenseTensor] + x[SparseCsrTensor] @ y[DenseTensor] -> out[DenseTensor]\\n        input[SparseCooTensor] + x[SparseCooTensor] @ y[SparseCooTensor] -> out[SparseCooTensor]\\n        input[DenseTensor] + x[SparseCooTensor] @ y[DenseTensor] -> out[DenseTensor]\\n\\n    It supports backward propagation.\\n\\n    Dimensions `input` , `x` , `y` must be same and >= 2D. Automatic broadcasting of Tensor is not supported.\\n\\n    Args:\\n        input (SparseTensor|DenseTensor): The input tensor. Shape is [*, M, N]. The data type can be float32 or float64.\\n        x (SparseTensor): The input SparseTensor. Shape is [*, M, K]. The data type can be float32 or float64.\\n        y (SparseTensor|DenseTensor): The input tensor. Shape is [*, K, N]. The data type can be float32 or float64.\\n        beta (float, optional): Coefficient of `input` . Default: 1.0\\n        alpha (float, optional): Coefficient of `x * y` . Default: 1.0\\n        name (str, optional): Name for the operation (optional, default is None). For more information, please refer to :ref:`api_guide_Name`.\\n\\n    Returns:\\n        SparseTensor|DenseTensor: Tensor type, date type and shape is the same with `input` .\\n\\n    Examples:\\n\\n        .. code-block:: python\\n\\n            >>> # doctest: +REQUIRES(env:GPU)\\n            >>> import paddle\\n            >>> paddle.device.set_device('gpu')\\n\\n            >>> # dense + csr @ dense -> dense\\n            >>> input = paddle.rand([3, 2])\\n            >>> crows = [0, 1, 2, 3]\\n            >>> cols = [1, 2, 0]\\n            >>> values = [1., 2., 3.]\\n            >>> x = paddle.sparse.sparse_csr_tensor(crows, cols, values, [3, 3])\\n            >>> y = paddle.rand([3, 2])\\n            >>> out = paddle.sparse.addmm(input, x, y, 3.0, 2.0)\\n\\n            >>> # dense + coo @ dense -> dense\\n            >>> input = paddle.rand([3, 2])\\n            >>> indices = [[0, 1, 2], [1, 2, 0]]\\n            >>> values = [1., 2., 3.]\\n            >>> x = paddle.sparse.sparse_coo_tensor(indices, values, [3, 3])\\n            >>> y = paddle.rand([3, 2])\\n            >>> out = paddle.sparse.addmm(input, x, y, 3.0, 2.0)\\n\\n    \"\n    return _C_ops.sparse_addmm(input, x, y, beta, alpha)"
        ]
    }
]