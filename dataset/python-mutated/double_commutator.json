[
    {
        "func_name": "double_commutator",
        "original": "def double_commutator(a: OperatorTypeT, b: OperatorTypeT, c: OperatorTypeT, *, commutator: bool=True) -> OperatorTypeT:\n    \"\"\"Compute symmetric double commutator of a, b and c.\n\n    See also Equation (13.6.18) in [1].\n\n    If `commutator` is `True`, it returns\n\n    .. math::\n\n         [[A, B], C]/2 + [A, [B, C]]/2\n         = (2ABC + 2CBA - BAC - CAB - ACB - BCA)/2.\n\n    If `commutator` is `False`, it returns\n\n    .. math::\n         \\\\lbrace[A, B], C\\\\rbrace/2 + \\\\lbrace A, [B, C]\\\\rbrace/2\n         = (2ABC - 2CBA - BAC + CAB - ACB + BCA)/2.\n\n    Args:\n        a: Operator a.\n        b: Operator b.\n        c: Operator c.\n        commutator: If ``True`` compute the double commutator,\n            if ``False`` the double anti-commutator.\n\n    Returns:\n        The double commutator\n\n    References:\n\n        [1]: R. McWeeny.\n            Methods of Molecular Quantum Mechanics.\n            2nd Edition, Academic Press, 1992.\n            ISBN 0-12-486552-6.\n    \"\"\"\n    sign_num = -1 if commutator else 1\n    ab = a @ b\n    ba = b @ a\n    ac = a @ c\n    ca = c @ a\n    abc = ab @ c\n    cba = c @ ba\n    bac = ba @ c\n    cab = c @ ab\n    acb = ac @ b\n    bca = b @ ca\n    res = abc - sign_num * cba + 0.5 * (-bac + sign_num * cab - acb + sign_num * bca)\n    return res",
        "mutated": [
            "def double_commutator(a: OperatorTypeT, b: OperatorTypeT, c: OperatorTypeT, *, commutator: bool=True) -> OperatorTypeT:\n    if False:\n        i = 10\n    'Compute symmetric double commutator of a, b and c.\\n\\n    See also Equation (13.6.18) in [1].\\n\\n    If `commutator` is `True`, it returns\\n\\n    .. math::\\n\\n         [[A, B], C]/2 + [A, [B, C]]/2\\n         = (2ABC + 2CBA - BAC - CAB - ACB - BCA)/2.\\n\\n    If `commutator` is `False`, it returns\\n\\n    .. math::\\n         \\\\lbrace[A, B], C\\\\rbrace/2 + \\\\lbrace A, [B, C]\\\\rbrace/2\\n         = (2ABC - 2CBA - BAC + CAB - ACB + BCA)/2.\\n\\n    Args:\\n        a: Operator a.\\n        b: Operator b.\\n        c: Operator c.\\n        commutator: If ``True`` compute the double commutator,\\n            if ``False`` the double anti-commutator.\\n\\n    Returns:\\n        The double commutator\\n\\n    References:\\n\\n        [1]: R. McWeeny.\\n            Methods of Molecular Quantum Mechanics.\\n            2nd Edition, Academic Press, 1992.\\n            ISBN 0-12-486552-6.\\n    '\n    sign_num = -1 if commutator else 1\n    ab = a @ b\n    ba = b @ a\n    ac = a @ c\n    ca = c @ a\n    abc = ab @ c\n    cba = c @ ba\n    bac = ba @ c\n    cab = c @ ab\n    acb = ac @ b\n    bca = b @ ca\n    res = abc - sign_num * cba + 0.5 * (-bac + sign_num * cab - acb + sign_num * bca)\n    return res",
            "def double_commutator(a: OperatorTypeT, b: OperatorTypeT, c: OperatorTypeT, *, commutator: bool=True) -> OperatorTypeT:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Compute symmetric double commutator of a, b and c.\\n\\n    See also Equation (13.6.18) in [1].\\n\\n    If `commutator` is `True`, it returns\\n\\n    .. math::\\n\\n         [[A, B], C]/2 + [A, [B, C]]/2\\n         = (2ABC + 2CBA - BAC - CAB - ACB - BCA)/2.\\n\\n    If `commutator` is `False`, it returns\\n\\n    .. math::\\n         \\\\lbrace[A, B], C\\\\rbrace/2 + \\\\lbrace A, [B, C]\\\\rbrace/2\\n         = (2ABC - 2CBA - BAC + CAB - ACB + BCA)/2.\\n\\n    Args:\\n        a: Operator a.\\n        b: Operator b.\\n        c: Operator c.\\n        commutator: If ``True`` compute the double commutator,\\n            if ``False`` the double anti-commutator.\\n\\n    Returns:\\n        The double commutator\\n\\n    References:\\n\\n        [1]: R. McWeeny.\\n            Methods of Molecular Quantum Mechanics.\\n            2nd Edition, Academic Press, 1992.\\n            ISBN 0-12-486552-6.\\n    '\n    sign_num = -1 if commutator else 1\n    ab = a @ b\n    ba = b @ a\n    ac = a @ c\n    ca = c @ a\n    abc = ab @ c\n    cba = c @ ba\n    bac = ba @ c\n    cab = c @ ab\n    acb = ac @ b\n    bca = b @ ca\n    res = abc - sign_num * cba + 0.5 * (-bac + sign_num * cab - acb + sign_num * bca)\n    return res",
            "def double_commutator(a: OperatorTypeT, b: OperatorTypeT, c: OperatorTypeT, *, commutator: bool=True) -> OperatorTypeT:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Compute symmetric double commutator of a, b and c.\\n\\n    See also Equation (13.6.18) in [1].\\n\\n    If `commutator` is `True`, it returns\\n\\n    .. math::\\n\\n         [[A, B], C]/2 + [A, [B, C]]/2\\n         = (2ABC + 2CBA - BAC - CAB - ACB - BCA)/2.\\n\\n    If `commutator` is `False`, it returns\\n\\n    .. math::\\n         \\\\lbrace[A, B], C\\\\rbrace/2 + \\\\lbrace A, [B, C]\\\\rbrace/2\\n         = (2ABC - 2CBA - BAC + CAB - ACB + BCA)/2.\\n\\n    Args:\\n        a: Operator a.\\n        b: Operator b.\\n        c: Operator c.\\n        commutator: If ``True`` compute the double commutator,\\n            if ``False`` the double anti-commutator.\\n\\n    Returns:\\n        The double commutator\\n\\n    References:\\n\\n        [1]: R. McWeeny.\\n            Methods of Molecular Quantum Mechanics.\\n            2nd Edition, Academic Press, 1992.\\n            ISBN 0-12-486552-6.\\n    '\n    sign_num = -1 if commutator else 1\n    ab = a @ b\n    ba = b @ a\n    ac = a @ c\n    ca = c @ a\n    abc = ab @ c\n    cba = c @ ba\n    bac = ba @ c\n    cab = c @ ab\n    acb = ac @ b\n    bca = b @ ca\n    res = abc - sign_num * cba + 0.5 * (-bac + sign_num * cab - acb + sign_num * bca)\n    return res",
            "def double_commutator(a: OperatorTypeT, b: OperatorTypeT, c: OperatorTypeT, *, commutator: bool=True) -> OperatorTypeT:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Compute symmetric double commutator of a, b and c.\\n\\n    See also Equation (13.6.18) in [1].\\n\\n    If `commutator` is `True`, it returns\\n\\n    .. math::\\n\\n         [[A, B], C]/2 + [A, [B, C]]/2\\n         = (2ABC + 2CBA - BAC - CAB - ACB - BCA)/2.\\n\\n    If `commutator` is `False`, it returns\\n\\n    .. math::\\n         \\\\lbrace[A, B], C\\\\rbrace/2 + \\\\lbrace A, [B, C]\\\\rbrace/2\\n         = (2ABC - 2CBA - BAC + CAB - ACB + BCA)/2.\\n\\n    Args:\\n        a: Operator a.\\n        b: Operator b.\\n        c: Operator c.\\n        commutator: If ``True`` compute the double commutator,\\n            if ``False`` the double anti-commutator.\\n\\n    Returns:\\n        The double commutator\\n\\n    References:\\n\\n        [1]: R. McWeeny.\\n            Methods of Molecular Quantum Mechanics.\\n            2nd Edition, Academic Press, 1992.\\n            ISBN 0-12-486552-6.\\n    '\n    sign_num = -1 if commutator else 1\n    ab = a @ b\n    ba = b @ a\n    ac = a @ c\n    ca = c @ a\n    abc = ab @ c\n    cba = c @ ba\n    bac = ba @ c\n    cab = c @ ab\n    acb = ac @ b\n    bca = b @ ca\n    res = abc - sign_num * cba + 0.5 * (-bac + sign_num * cab - acb + sign_num * bca)\n    return res",
            "def double_commutator(a: OperatorTypeT, b: OperatorTypeT, c: OperatorTypeT, *, commutator: bool=True) -> OperatorTypeT:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Compute symmetric double commutator of a, b and c.\\n\\n    See also Equation (13.6.18) in [1].\\n\\n    If `commutator` is `True`, it returns\\n\\n    .. math::\\n\\n         [[A, B], C]/2 + [A, [B, C]]/2\\n         = (2ABC + 2CBA - BAC - CAB - ACB - BCA)/2.\\n\\n    If `commutator` is `False`, it returns\\n\\n    .. math::\\n         \\\\lbrace[A, B], C\\\\rbrace/2 + \\\\lbrace A, [B, C]\\\\rbrace/2\\n         = (2ABC - 2CBA - BAC + CAB - ACB + BCA)/2.\\n\\n    Args:\\n        a: Operator a.\\n        b: Operator b.\\n        c: Operator c.\\n        commutator: If ``True`` compute the double commutator,\\n            if ``False`` the double anti-commutator.\\n\\n    Returns:\\n        The double commutator\\n\\n    References:\\n\\n        [1]: R. McWeeny.\\n            Methods of Molecular Quantum Mechanics.\\n            2nd Edition, Academic Press, 1992.\\n            ISBN 0-12-486552-6.\\n    '\n    sign_num = -1 if commutator else 1\n    ab = a @ b\n    ba = b @ a\n    ac = a @ c\n    ca = c @ a\n    abc = ab @ c\n    cba = c @ ba\n    bac = ba @ c\n    cab = c @ ab\n    acb = ac @ b\n    bca = b @ ca\n    res = abc - sign_num * cba + 0.5 * (-bac + sign_num * cab - acb + sign_num * bca)\n    return res"
        ]
    }
]