[
    {
        "func_name": "parampack_concat_lower",
        "original": "@register_lower_rule(mops.ParamPackConcat)\ndef parampack_concat_lower(ctx, *args: Union[HLOTensor, Sequence[HLOTensor]]):\n    flattened = []\n    for (arg, var_in) in zip(args[:-1], ctx.vars_in[:-1]):\n        ishape_1d = (int(np.prod(var_in.shape)),)\n        flattened.append(arg.reshape(ishape_1d))\n    concated = concat(flattened, 0)\n    return concated",
        "mutated": [
            "@register_lower_rule(mops.ParamPackConcat)\ndef parampack_concat_lower(ctx, *args: Union[HLOTensor, Sequence[HLOTensor]]):\n    if False:\n        i = 10\n    flattened = []\n    for (arg, var_in) in zip(args[:-1], ctx.vars_in[:-1]):\n        ishape_1d = (int(np.prod(var_in.shape)),)\n        flattened.append(arg.reshape(ishape_1d))\n    concated = concat(flattened, 0)\n    return concated",
            "@register_lower_rule(mops.ParamPackConcat)\ndef parampack_concat_lower(ctx, *args: Union[HLOTensor, Sequence[HLOTensor]]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    flattened = []\n    for (arg, var_in) in zip(args[:-1], ctx.vars_in[:-1]):\n        ishape_1d = (int(np.prod(var_in.shape)),)\n        flattened.append(arg.reshape(ishape_1d))\n    concated = concat(flattened, 0)\n    return concated",
            "@register_lower_rule(mops.ParamPackConcat)\ndef parampack_concat_lower(ctx, *args: Union[HLOTensor, Sequence[HLOTensor]]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    flattened = []\n    for (arg, var_in) in zip(args[:-1], ctx.vars_in[:-1]):\n        ishape_1d = (int(np.prod(var_in.shape)),)\n        flattened.append(arg.reshape(ishape_1d))\n    concated = concat(flattened, 0)\n    return concated",
            "@register_lower_rule(mops.ParamPackConcat)\ndef parampack_concat_lower(ctx, *args: Union[HLOTensor, Sequence[HLOTensor]]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    flattened = []\n    for (arg, var_in) in zip(args[:-1], ctx.vars_in[:-1]):\n        ishape_1d = (int(np.prod(var_in.shape)),)\n        flattened.append(arg.reshape(ishape_1d))\n    concated = concat(flattened, 0)\n    return concated",
            "@register_lower_rule(mops.ParamPackConcat)\ndef parampack_concat_lower(ctx, *args: Union[HLOTensor, Sequence[HLOTensor]]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    flattened = []\n    for (arg, var_in) in zip(args[:-1], ctx.vars_in[:-1]):\n        ishape_1d = (int(np.prod(var_in.shape)),)\n        flattened.append(arg.reshape(ishape_1d))\n    concated = concat(flattened, 0)\n    return concated"
        ]
    },
    {
        "func_name": "parampack_split_lower",
        "original": "@register_lower_rule(mops.ParamPackSplit)\ndef parampack_split_lower(ctx, *args: Union[HLOTensor, Sequence[HLOTensor]]):\n    (offsets, shapes, var_outs) = (ctx.op.offsets, ctx.op.shapes, ctx.vars_out)\n    assert len(offsets) // 2 == len(shapes) == len(var_outs), 'error params'\n    for (var_out, shape) in zip(var_outs, shapes):\n        assert tuple(var_out.shape) == tuple(shape), f'{var_out.shape} .vs {shape}'\n    sections = [np.prod(shape) for shape in shapes]\n    for (i, section) in enumerate(sections):\n        assert section == offsets[2 * i + 1] - offsets[2 * i], 'error offsets'\n    pieces = split(args[0], sections, axis=0)\n    outputs = [piece.reshape(var_out.shape) for (piece, var_out) in zip(pieces, var_outs)]\n    return outputs",
        "mutated": [
            "@register_lower_rule(mops.ParamPackSplit)\ndef parampack_split_lower(ctx, *args: Union[HLOTensor, Sequence[HLOTensor]]):\n    if False:\n        i = 10\n    (offsets, shapes, var_outs) = (ctx.op.offsets, ctx.op.shapes, ctx.vars_out)\n    assert len(offsets) // 2 == len(shapes) == len(var_outs), 'error params'\n    for (var_out, shape) in zip(var_outs, shapes):\n        assert tuple(var_out.shape) == tuple(shape), f'{var_out.shape} .vs {shape}'\n    sections = [np.prod(shape) for shape in shapes]\n    for (i, section) in enumerate(sections):\n        assert section == offsets[2 * i + 1] - offsets[2 * i], 'error offsets'\n    pieces = split(args[0], sections, axis=0)\n    outputs = [piece.reshape(var_out.shape) for (piece, var_out) in zip(pieces, var_outs)]\n    return outputs",
            "@register_lower_rule(mops.ParamPackSplit)\ndef parampack_split_lower(ctx, *args: Union[HLOTensor, Sequence[HLOTensor]]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (offsets, shapes, var_outs) = (ctx.op.offsets, ctx.op.shapes, ctx.vars_out)\n    assert len(offsets) // 2 == len(shapes) == len(var_outs), 'error params'\n    for (var_out, shape) in zip(var_outs, shapes):\n        assert tuple(var_out.shape) == tuple(shape), f'{var_out.shape} .vs {shape}'\n    sections = [np.prod(shape) for shape in shapes]\n    for (i, section) in enumerate(sections):\n        assert section == offsets[2 * i + 1] - offsets[2 * i], 'error offsets'\n    pieces = split(args[0], sections, axis=0)\n    outputs = [piece.reshape(var_out.shape) for (piece, var_out) in zip(pieces, var_outs)]\n    return outputs",
            "@register_lower_rule(mops.ParamPackSplit)\ndef parampack_split_lower(ctx, *args: Union[HLOTensor, Sequence[HLOTensor]]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (offsets, shapes, var_outs) = (ctx.op.offsets, ctx.op.shapes, ctx.vars_out)\n    assert len(offsets) // 2 == len(shapes) == len(var_outs), 'error params'\n    for (var_out, shape) in zip(var_outs, shapes):\n        assert tuple(var_out.shape) == tuple(shape), f'{var_out.shape} .vs {shape}'\n    sections = [np.prod(shape) for shape in shapes]\n    for (i, section) in enumerate(sections):\n        assert section == offsets[2 * i + 1] - offsets[2 * i], 'error offsets'\n    pieces = split(args[0], sections, axis=0)\n    outputs = [piece.reshape(var_out.shape) for (piece, var_out) in zip(pieces, var_outs)]\n    return outputs",
            "@register_lower_rule(mops.ParamPackSplit)\ndef parampack_split_lower(ctx, *args: Union[HLOTensor, Sequence[HLOTensor]]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (offsets, shapes, var_outs) = (ctx.op.offsets, ctx.op.shapes, ctx.vars_out)\n    assert len(offsets) // 2 == len(shapes) == len(var_outs), 'error params'\n    for (var_out, shape) in zip(var_outs, shapes):\n        assert tuple(var_out.shape) == tuple(shape), f'{var_out.shape} .vs {shape}'\n    sections = [np.prod(shape) for shape in shapes]\n    for (i, section) in enumerate(sections):\n        assert section == offsets[2 * i + 1] - offsets[2 * i], 'error offsets'\n    pieces = split(args[0], sections, axis=0)\n    outputs = [piece.reshape(var_out.shape) for (piece, var_out) in zip(pieces, var_outs)]\n    return outputs",
            "@register_lower_rule(mops.ParamPackSplit)\ndef parampack_split_lower(ctx, *args: Union[HLOTensor, Sequence[HLOTensor]]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (offsets, shapes, var_outs) = (ctx.op.offsets, ctx.op.shapes, ctx.vars_out)\n    assert len(offsets) // 2 == len(shapes) == len(var_outs), 'error params'\n    for (var_out, shape) in zip(var_outs, shapes):\n        assert tuple(var_out.shape) == tuple(shape), f'{var_out.shape} .vs {shape}'\n    sections = [np.prod(shape) for shape in shapes]\n    for (i, section) in enumerate(sections):\n        assert section == offsets[2 * i + 1] - offsets[2 * i], 'error offsets'\n    pieces = split(args[0], sections, axis=0)\n    outputs = [piece.reshape(var_out.shape) for (piece, var_out) in zip(pieces, var_outs)]\n    return outputs"
        ]
    },
    {
        "func_name": "_replica_groups_hlo",
        "original": "def _replica_groups_hlo(replica_groups: Sequence[Sequence[int]]):\n    groups = np.array(list(itertools.zip_longest(*replica_groups, fillvalue=-1)), dtype=np.int64).T\n    return ir.DenseIntElementsAttr.get(np.ascontiguousarray(groups))",
        "mutated": [
            "def _replica_groups_hlo(replica_groups: Sequence[Sequence[int]]):\n    if False:\n        i = 10\n    groups = np.array(list(itertools.zip_longest(*replica_groups, fillvalue=-1)), dtype=np.int64).T\n    return ir.DenseIntElementsAttr.get(np.ascontiguousarray(groups))",
            "def _replica_groups_hlo(replica_groups: Sequence[Sequence[int]]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    groups = np.array(list(itertools.zip_longest(*replica_groups, fillvalue=-1)), dtype=np.int64).T\n    return ir.DenseIntElementsAttr.get(np.ascontiguousarray(groups))",
            "def _replica_groups_hlo(replica_groups: Sequence[Sequence[int]]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    groups = np.array(list(itertools.zip_longest(*replica_groups, fillvalue=-1)), dtype=np.int64).T\n    return ir.DenseIntElementsAttr.get(np.ascontiguousarray(groups))",
            "def _replica_groups_hlo(replica_groups: Sequence[Sequence[int]]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    groups = np.array(list(itertools.zip_longest(*replica_groups, fillvalue=-1)), dtype=np.int64).T\n    return ir.DenseIntElementsAttr.get(np.ascontiguousarray(groups))",
            "def _replica_groups_hlo(replica_groups: Sequence[Sequence[int]]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    groups = np.array(list(itertools.zip_longest(*replica_groups, fillvalue=-1)), dtype=np.int64).T\n    return ir.DenseIntElementsAttr.get(np.ascontiguousarray(groups))"
        ]
    },
    {
        "func_name": "_all_reduce",
        "original": "def _all_reduce(reducer, inp, world_size):\n\n    def _replica_groups_hlo(replica_groups: Sequence[Sequence[int]]):\n        groups = np.array(list(itertools.zip_longest(*replica_groups, fillvalue=-1)), dtype=np.int64).T\n        return ir.DenseIntElementsAttr.get(np.ascontiguousarray(groups))\n    replica_groups = _replica_groups_hlo([[i for i in range(world_size)]])\n    hlo_cfgs = {}\n    all_reduce_op = hlo.AllReduceOp(inp.tensor.type, inp.tensor, replica_groups=replica_groups, **hlo_cfgs)\n    scalar_type = ir_utils.make_ir_type_according_meta(tuple(), inp.dtype)\n    reducer_region = all_reduce_op.regions[0].blocks.append(scalar_type, scalar_type)\n    with ir.InsertionPoint(reducer_region):\n        reducer_ret = reducer(*reducer_region.arguments)\n        hlo.ReturnOp(reducer_ret.results)\n    return HLOTensor(all_reduce_op.results)",
        "mutated": [
            "def _all_reduce(reducer, inp, world_size):\n    if False:\n        i = 10\n\n    def _replica_groups_hlo(replica_groups: Sequence[Sequence[int]]):\n        groups = np.array(list(itertools.zip_longest(*replica_groups, fillvalue=-1)), dtype=np.int64).T\n        return ir.DenseIntElementsAttr.get(np.ascontiguousarray(groups))\n    replica_groups = _replica_groups_hlo([[i for i in range(world_size)]])\n    hlo_cfgs = {}\n    all_reduce_op = hlo.AllReduceOp(inp.tensor.type, inp.tensor, replica_groups=replica_groups, **hlo_cfgs)\n    scalar_type = ir_utils.make_ir_type_according_meta(tuple(), inp.dtype)\n    reducer_region = all_reduce_op.regions[0].blocks.append(scalar_type, scalar_type)\n    with ir.InsertionPoint(reducer_region):\n        reducer_ret = reducer(*reducer_region.arguments)\n        hlo.ReturnOp(reducer_ret.results)\n    return HLOTensor(all_reduce_op.results)",
            "def _all_reduce(reducer, inp, world_size):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    def _replica_groups_hlo(replica_groups: Sequence[Sequence[int]]):\n        groups = np.array(list(itertools.zip_longest(*replica_groups, fillvalue=-1)), dtype=np.int64).T\n        return ir.DenseIntElementsAttr.get(np.ascontiguousarray(groups))\n    replica_groups = _replica_groups_hlo([[i for i in range(world_size)]])\n    hlo_cfgs = {}\n    all_reduce_op = hlo.AllReduceOp(inp.tensor.type, inp.tensor, replica_groups=replica_groups, **hlo_cfgs)\n    scalar_type = ir_utils.make_ir_type_according_meta(tuple(), inp.dtype)\n    reducer_region = all_reduce_op.regions[0].blocks.append(scalar_type, scalar_type)\n    with ir.InsertionPoint(reducer_region):\n        reducer_ret = reducer(*reducer_region.arguments)\n        hlo.ReturnOp(reducer_ret.results)\n    return HLOTensor(all_reduce_op.results)",
            "def _all_reduce(reducer, inp, world_size):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    def _replica_groups_hlo(replica_groups: Sequence[Sequence[int]]):\n        groups = np.array(list(itertools.zip_longest(*replica_groups, fillvalue=-1)), dtype=np.int64).T\n        return ir.DenseIntElementsAttr.get(np.ascontiguousarray(groups))\n    replica_groups = _replica_groups_hlo([[i for i in range(world_size)]])\n    hlo_cfgs = {}\n    all_reduce_op = hlo.AllReduceOp(inp.tensor.type, inp.tensor, replica_groups=replica_groups, **hlo_cfgs)\n    scalar_type = ir_utils.make_ir_type_according_meta(tuple(), inp.dtype)\n    reducer_region = all_reduce_op.regions[0].blocks.append(scalar_type, scalar_type)\n    with ir.InsertionPoint(reducer_region):\n        reducer_ret = reducer(*reducer_region.arguments)\n        hlo.ReturnOp(reducer_ret.results)\n    return HLOTensor(all_reduce_op.results)",
            "def _all_reduce(reducer, inp, world_size):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    def _replica_groups_hlo(replica_groups: Sequence[Sequence[int]]):\n        groups = np.array(list(itertools.zip_longest(*replica_groups, fillvalue=-1)), dtype=np.int64).T\n        return ir.DenseIntElementsAttr.get(np.ascontiguousarray(groups))\n    replica_groups = _replica_groups_hlo([[i for i in range(world_size)]])\n    hlo_cfgs = {}\n    all_reduce_op = hlo.AllReduceOp(inp.tensor.type, inp.tensor, replica_groups=replica_groups, **hlo_cfgs)\n    scalar_type = ir_utils.make_ir_type_according_meta(tuple(), inp.dtype)\n    reducer_region = all_reduce_op.regions[0].blocks.append(scalar_type, scalar_type)\n    with ir.InsertionPoint(reducer_region):\n        reducer_ret = reducer(*reducer_region.arguments)\n        hlo.ReturnOp(reducer_ret.results)\n    return HLOTensor(all_reduce_op.results)",
            "def _all_reduce(reducer, inp, world_size):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    def _replica_groups_hlo(replica_groups: Sequence[Sequence[int]]):\n        groups = np.array(list(itertools.zip_longest(*replica_groups, fillvalue=-1)), dtype=np.int64).T\n        return ir.DenseIntElementsAttr.get(np.ascontiguousarray(groups))\n    replica_groups = _replica_groups_hlo([[i for i in range(world_size)]])\n    hlo_cfgs = {}\n    all_reduce_op = hlo.AllReduceOp(inp.tensor.type, inp.tensor, replica_groups=replica_groups, **hlo_cfgs)\n    scalar_type = ir_utils.make_ir_type_according_meta(tuple(), inp.dtype)\n    reducer_region = all_reduce_op.regions[0].blocks.append(scalar_type, scalar_type)\n    with ir.InsertionPoint(reducer_region):\n        reducer_ret = reducer(*reducer_region.arguments)\n        hlo.ReturnOp(reducer_ret.results)\n    return HLOTensor(all_reduce_op.results)"
        ]
    },
    {
        "func_name": "collective_comm_lower",
        "original": "@register_lower_rule(mops.CollectiveComm)\ndef collective_comm_lower(ctx, *args: Union[HLOTensor, Sequence[HLOTensor]]):\n    assert len(args) == 1, 'collective comm only support one input'\n    if ctx.op.mode == mops.CollectiveComm.Mode.ALL_REDUCE_SUM:\n        ret = all_reduce_sum(args[0], ctx.op.nr_devices)\n    elif ctx.op.mode == mops.CollectiveComm.Mode.ALL_REDUCE_PROD:\n        ret = all_reduce_prod(args[0], ctx.op.nr_devices)\n    elif ctx.op.mode == mops.CollectiveComm.Mode.ALL_REDUCE_MIN:\n        ret = all_reduce_min(args[0], ctx.op.nr_devices)\n    elif ctx.op.mode == mops.CollectiveComm.Mode.ALL_REDUCE_MAX:\n        ret = all_reduce_max(args[0], ctx.op.nr_devices)\n    else:\n        assert False, f'not support mode{ctx.op.mode}'\n    return ret",
        "mutated": [
            "@register_lower_rule(mops.CollectiveComm)\ndef collective_comm_lower(ctx, *args: Union[HLOTensor, Sequence[HLOTensor]]):\n    if False:\n        i = 10\n    assert len(args) == 1, 'collective comm only support one input'\n    if ctx.op.mode == mops.CollectiveComm.Mode.ALL_REDUCE_SUM:\n        ret = all_reduce_sum(args[0], ctx.op.nr_devices)\n    elif ctx.op.mode == mops.CollectiveComm.Mode.ALL_REDUCE_PROD:\n        ret = all_reduce_prod(args[0], ctx.op.nr_devices)\n    elif ctx.op.mode == mops.CollectiveComm.Mode.ALL_REDUCE_MIN:\n        ret = all_reduce_min(args[0], ctx.op.nr_devices)\n    elif ctx.op.mode == mops.CollectiveComm.Mode.ALL_REDUCE_MAX:\n        ret = all_reduce_max(args[0], ctx.op.nr_devices)\n    else:\n        assert False, f'not support mode{ctx.op.mode}'\n    return ret",
            "@register_lower_rule(mops.CollectiveComm)\ndef collective_comm_lower(ctx, *args: Union[HLOTensor, Sequence[HLOTensor]]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    assert len(args) == 1, 'collective comm only support one input'\n    if ctx.op.mode == mops.CollectiveComm.Mode.ALL_REDUCE_SUM:\n        ret = all_reduce_sum(args[0], ctx.op.nr_devices)\n    elif ctx.op.mode == mops.CollectiveComm.Mode.ALL_REDUCE_PROD:\n        ret = all_reduce_prod(args[0], ctx.op.nr_devices)\n    elif ctx.op.mode == mops.CollectiveComm.Mode.ALL_REDUCE_MIN:\n        ret = all_reduce_min(args[0], ctx.op.nr_devices)\n    elif ctx.op.mode == mops.CollectiveComm.Mode.ALL_REDUCE_MAX:\n        ret = all_reduce_max(args[0], ctx.op.nr_devices)\n    else:\n        assert False, f'not support mode{ctx.op.mode}'\n    return ret",
            "@register_lower_rule(mops.CollectiveComm)\ndef collective_comm_lower(ctx, *args: Union[HLOTensor, Sequence[HLOTensor]]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    assert len(args) == 1, 'collective comm only support one input'\n    if ctx.op.mode == mops.CollectiveComm.Mode.ALL_REDUCE_SUM:\n        ret = all_reduce_sum(args[0], ctx.op.nr_devices)\n    elif ctx.op.mode == mops.CollectiveComm.Mode.ALL_REDUCE_PROD:\n        ret = all_reduce_prod(args[0], ctx.op.nr_devices)\n    elif ctx.op.mode == mops.CollectiveComm.Mode.ALL_REDUCE_MIN:\n        ret = all_reduce_min(args[0], ctx.op.nr_devices)\n    elif ctx.op.mode == mops.CollectiveComm.Mode.ALL_REDUCE_MAX:\n        ret = all_reduce_max(args[0], ctx.op.nr_devices)\n    else:\n        assert False, f'not support mode{ctx.op.mode}'\n    return ret",
            "@register_lower_rule(mops.CollectiveComm)\ndef collective_comm_lower(ctx, *args: Union[HLOTensor, Sequence[HLOTensor]]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    assert len(args) == 1, 'collective comm only support one input'\n    if ctx.op.mode == mops.CollectiveComm.Mode.ALL_REDUCE_SUM:\n        ret = all_reduce_sum(args[0], ctx.op.nr_devices)\n    elif ctx.op.mode == mops.CollectiveComm.Mode.ALL_REDUCE_PROD:\n        ret = all_reduce_prod(args[0], ctx.op.nr_devices)\n    elif ctx.op.mode == mops.CollectiveComm.Mode.ALL_REDUCE_MIN:\n        ret = all_reduce_min(args[0], ctx.op.nr_devices)\n    elif ctx.op.mode == mops.CollectiveComm.Mode.ALL_REDUCE_MAX:\n        ret = all_reduce_max(args[0], ctx.op.nr_devices)\n    else:\n        assert False, f'not support mode{ctx.op.mode}'\n    return ret",
            "@register_lower_rule(mops.CollectiveComm)\ndef collective_comm_lower(ctx, *args: Union[HLOTensor, Sequence[HLOTensor]]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    assert len(args) == 1, 'collective comm only support one input'\n    if ctx.op.mode == mops.CollectiveComm.Mode.ALL_REDUCE_SUM:\n        ret = all_reduce_sum(args[0], ctx.op.nr_devices)\n    elif ctx.op.mode == mops.CollectiveComm.Mode.ALL_REDUCE_PROD:\n        ret = all_reduce_prod(args[0], ctx.op.nr_devices)\n    elif ctx.op.mode == mops.CollectiveComm.Mode.ALL_REDUCE_MIN:\n        ret = all_reduce_min(args[0], ctx.op.nr_devices)\n    elif ctx.op.mode == mops.CollectiveComm.Mode.ALL_REDUCE_MAX:\n        ret = all_reduce_max(args[0], ctx.op.nr_devices)\n    else:\n        assert False, f'not support mode{ctx.op.mode}'\n    return ret"
        ]
    }
]