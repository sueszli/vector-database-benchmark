[
    {
        "func_name": "main_demo",
        "original": "def main_demo() -> None:\n    \"\"\"Generic Events\n\n    Most UI elements come with predefined events.\n    For example, a `ui.button` like \"A\" in the demo has an `on_click` parameter that expects a coroutine or function.\n    But you can also use the `on` method to register a generic event handler like for \"B\".\n    This allows you to register handlers for any event that is supported by JavaScript and Quasar.\n\n    For example, you can register a handler for the `mousemove` event like for \"C\", even though there is no `on_mousemove` parameter for `ui.button`.\n    Some events, like `mousemove`, are fired very often.\n    To avoid performance issues, you can use the `throttle` parameter to only call the handler every `throttle` seconds (\"D\").\n\n    The generic event handler can be synchronous or asynchronous and optionally takes `GenericEventArguments` as argument (\"E\").\n    You can also specify which attributes of the JavaScript or Quasar event should be passed to the handler (\"F\").\n    This can reduce the amount of data that needs to be transferred between the server and the client.\n\n    Here you can find more information about the events that are supported:\n\n    - https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement#events for HTML elements\n    - https://quasar.dev/vue-components for Quasar-based elements (see the \"Events\" tab on the individual component page)\n    \"\"\"\n    with ui.row():\n        ui.button('A', on_click=lambda : ui.notify('You clicked the button A.'))\n        ui.button('B').on('click', lambda : ui.notify('You clicked the button B.'))\n    with ui.row():\n        ui.button('C').on('mousemove', lambda : ui.notify('You moved on button C.'))\n        ui.button('D').on('mousemove', lambda : ui.notify('You moved on button D.'), throttle=0.5)\n    with ui.row():\n        ui.button('E').on('mousedown', lambda e: ui.notify(e))\n        ui.button('F').on('mousedown', lambda e: ui.notify(e), ['ctrlKey', 'shiftKey'])",
        "mutated": [
            "def main_demo() -> None:\n    if False:\n        i = 10\n    'Generic Events\\n\\n    Most UI elements come with predefined events.\\n    For example, a `ui.button` like \"A\" in the demo has an `on_click` parameter that expects a coroutine or function.\\n    But you can also use the `on` method to register a generic event handler like for \"B\".\\n    This allows you to register handlers for any event that is supported by JavaScript and Quasar.\\n\\n    For example, you can register a handler for the `mousemove` event like for \"C\", even though there is no `on_mousemove` parameter for `ui.button`.\\n    Some events, like `mousemove`, are fired very often.\\n    To avoid performance issues, you can use the `throttle` parameter to only call the handler every `throttle` seconds (\"D\").\\n\\n    The generic event handler can be synchronous or asynchronous and optionally takes `GenericEventArguments` as argument (\"E\").\\n    You can also specify which attributes of the JavaScript or Quasar event should be passed to the handler (\"F\").\\n    This can reduce the amount of data that needs to be transferred between the server and the client.\\n\\n    Here you can find more information about the events that are supported:\\n\\n    - https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement#events for HTML elements\\n    - https://quasar.dev/vue-components for Quasar-based elements (see the \"Events\" tab on the individual component page)\\n    '\n    with ui.row():\n        ui.button('A', on_click=lambda : ui.notify('You clicked the button A.'))\n        ui.button('B').on('click', lambda : ui.notify('You clicked the button B.'))\n    with ui.row():\n        ui.button('C').on('mousemove', lambda : ui.notify('You moved on button C.'))\n        ui.button('D').on('mousemove', lambda : ui.notify('You moved on button D.'), throttle=0.5)\n    with ui.row():\n        ui.button('E').on('mousedown', lambda e: ui.notify(e))\n        ui.button('F').on('mousedown', lambda e: ui.notify(e), ['ctrlKey', 'shiftKey'])",
            "def main_demo() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Generic Events\\n\\n    Most UI elements come with predefined events.\\n    For example, a `ui.button` like \"A\" in the demo has an `on_click` parameter that expects a coroutine or function.\\n    But you can also use the `on` method to register a generic event handler like for \"B\".\\n    This allows you to register handlers for any event that is supported by JavaScript and Quasar.\\n\\n    For example, you can register a handler for the `mousemove` event like for \"C\", even though there is no `on_mousemove` parameter for `ui.button`.\\n    Some events, like `mousemove`, are fired very often.\\n    To avoid performance issues, you can use the `throttle` parameter to only call the handler every `throttle` seconds (\"D\").\\n\\n    The generic event handler can be synchronous or asynchronous and optionally takes `GenericEventArguments` as argument (\"E\").\\n    You can also specify which attributes of the JavaScript or Quasar event should be passed to the handler (\"F\").\\n    This can reduce the amount of data that needs to be transferred between the server and the client.\\n\\n    Here you can find more information about the events that are supported:\\n\\n    - https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement#events for HTML elements\\n    - https://quasar.dev/vue-components for Quasar-based elements (see the \"Events\" tab on the individual component page)\\n    '\n    with ui.row():\n        ui.button('A', on_click=lambda : ui.notify('You clicked the button A.'))\n        ui.button('B').on('click', lambda : ui.notify('You clicked the button B.'))\n    with ui.row():\n        ui.button('C').on('mousemove', lambda : ui.notify('You moved on button C.'))\n        ui.button('D').on('mousemove', lambda : ui.notify('You moved on button D.'), throttle=0.5)\n    with ui.row():\n        ui.button('E').on('mousedown', lambda e: ui.notify(e))\n        ui.button('F').on('mousedown', lambda e: ui.notify(e), ['ctrlKey', 'shiftKey'])",
            "def main_demo() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Generic Events\\n\\n    Most UI elements come with predefined events.\\n    For example, a `ui.button` like \"A\" in the demo has an `on_click` parameter that expects a coroutine or function.\\n    But you can also use the `on` method to register a generic event handler like for \"B\".\\n    This allows you to register handlers for any event that is supported by JavaScript and Quasar.\\n\\n    For example, you can register a handler for the `mousemove` event like for \"C\", even though there is no `on_mousemove` parameter for `ui.button`.\\n    Some events, like `mousemove`, are fired very often.\\n    To avoid performance issues, you can use the `throttle` parameter to only call the handler every `throttle` seconds (\"D\").\\n\\n    The generic event handler can be synchronous or asynchronous and optionally takes `GenericEventArguments` as argument (\"E\").\\n    You can also specify which attributes of the JavaScript or Quasar event should be passed to the handler (\"F\").\\n    This can reduce the amount of data that needs to be transferred between the server and the client.\\n\\n    Here you can find more information about the events that are supported:\\n\\n    - https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement#events for HTML elements\\n    - https://quasar.dev/vue-components for Quasar-based elements (see the \"Events\" tab on the individual component page)\\n    '\n    with ui.row():\n        ui.button('A', on_click=lambda : ui.notify('You clicked the button A.'))\n        ui.button('B').on('click', lambda : ui.notify('You clicked the button B.'))\n    with ui.row():\n        ui.button('C').on('mousemove', lambda : ui.notify('You moved on button C.'))\n        ui.button('D').on('mousemove', lambda : ui.notify('You moved on button D.'), throttle=0.5)\n    with ui.row():\n        ui.button('E').on('mousedown', lambda e: ui.notify(e))\n        ui.button('F').on('mousedown', lambda e: ui.notify(e), ['ctrlKey', 'shiftKey'])",
            "def main_demo() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Generic Events\\n\\n    Most UI elements come with predefined events.\\n    For example, a `ui.button` like \"A\" in the demo has an `on_click` parameter that expects a coroutine or function.\\n    But you can also use the `on` method to register a generic event handler like for \"B\".\\n    This allows you to register handlers for any event that is supported by JavaScript and Quasar.\\n\\n    For example, you can register a handler for the `mousemove` event like for \"C\", even though there is no `on_mousemove` parameter for `ui.button`.\\n    Some events, like `mousemove`, are fired very often.\\n    To avoid performance issues, you can use the `throttle` parameter to only call the handler every `throttle` seconds (\"D\").\\n\\n    The generic event handler can be synchronous or asynchronous and optionally takes `GenericEventArguments` as argument (\"E\").\\n    You can also specify which attributes of the JavaScript or Quasar event should be passed to the handler (\"F\").\\n    This can reduce the amount of data that needs to be transferred between the server and the client.\\n\\n    Here you can find more information about the events that are supported:\\n\\n    - https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement#events for HTML elements\\n    - https://quasar.dev/vue-components for Quasar-based elements (see the \"Events\" tab on the individual component page)\\n    '\n    with ui.row():\n        ui.button('A', on_click=lambda : ui.notify('You clicked the button A.'))\n        ui.button('B').on('click', lambda : ui.notify('You clicked the button B.'))\n    with ui.row():\n        ui.button('C').on('mousemove', lambda : ui.notify('You moved on button C.'))\n        ui.button('D').on('mousemove', lambda : ui.notify('You moved on button D.'), throttle=0.5)\n    with ui.row():\n        ui.button('E').on('mousedown', lambda e: ui.notify(e))\n        ui.button('F').on('mousedown', lambda e: ui.notify(e), ['ctrlKey', 'shiftKey'])",
            "def main_demo() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Generic Events\\n\\n    Most UI elements come with predefined events.\\n    For example, a `ui.button` like \"A\" in the demo has an `on_click` parameter that expects a coroutine or function.\\n    But you can also use the `on` method to register a generic event handler like for \"B\".\\n    This allows you to register handlers for any event that is supported by JavaScript and Quasar.\\n\\n    For example, you can register a handler for the `mousemove` event like for \"C\", even though there is no `on_mousemove` parameter for `ui.button`.\\n    Some events, like `mousemove`, are fired very often.\\n    To avoid performance issues, you can use the `throttle` parameter to only call the handler every `throttle` seconds (\"D\").\\n\\n    The generic event handler can be synchronous or asynchronous and optionally takes `GenericEventArguments` as argument (\"E\").\\n    You can also specify which attributes of the JavaScript or Quasar event should be passed to the handler (\"F\").\\n    This can reduce the amount of data that needs to be transferred between the server and the client.\\n\\n    Here you can find more information about the events that are supported:\\n\\n    - https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement#events for HTML elements\\n    - https://quasar.dev/vue-components for Quasar-based elements (see the \"Events\" tab on the individual component page)\\n    '\n    with ui.row():\n        ui.button('A', on_click=lambda : ui.notify('You clicked the button A.'))\n        ui.button('B').on('click', lambda : ui.notify('You clicked the button B.'))\n    with ui.row():\n        ui.button('C').on('mousemove', lambda : ui.notify('You moved on button C.'))\n        ui.button('D').on('mousemove', lambda : ui.notify('You moved on button D.'), throttle=0.5)\n    with ui.row():\n        ui.button('E').on('mousedown', lambda e: ui.notify(e))\n        ui.button('F').on('mousedown', lambda e: ui.notify(e), ['ctrlKey', 'shiftKey'])"
        ]
    },
    {
        "func_name": "event_attributes",
        "original": "@text_demo('Specifying event attributes', '\\n        **A list of strings** names the attributes of the JavaScript event object:\\n            ```py\\n            ui.button().on(\\'click\\', handle_click, [\\'clientX\\', \\'clientY\\'])\\n            ```\\n\\n        **An empty list** requests _no_ attributes:\\n            ```py\\n            ui.button().on(\\'click\\', handle_click, [])\\n            ```\\n\\n        **The value `None`** represents _all_ attributes (the default):\\n            ```py\\n            ui.button().on(\\'click\\', handle_click, None)\\n            ```\\n\\n        **If the event is called with multiple arguments** like QTable\\'s \"row-click\" `(evt, row, index) => void`,\\n            you can define a list of argument definitions:\\n            ```py\\n            ui.table(...).on(\\'rowClick\\', handle_click, [[], [\\'name\\'], None])\\n            ```\\n            In this example the \"row-click\" event will omit all arguments of the first `evt` argument,\\n            send only the \"name\" attribute of the `row` argument and send the full `index`.\\n\\n        If the retrieved list of event arguments has length 1, the argument is automatically unpacked.\\n        So you can write\\n        ```py\\n        ui.button().on(\\'click\\', lambda e: print(e.args[\\'clientX\\'], flush=True))\\n        ```\\n        instead of\\n        ```py\\n        ui.button().on(\\'click\\', lambda e: print(e.args[0][\\'clientX\\'], flush=True))\\n        ```\\n\\n        Note that by default all JSON-serializable attributes of all arguments are sent.\\n        This is to simplify registering for new events and discovering their attributes.\\n        If bandwidth is an issue, the arguments should be limited to what is actually needed on the server.\\n    ')\ndef event_attributes() -> None:\n    columns = [{'name': 'name', 'label': 'Name', 'field': 'name'}, {'name': 'age', 'label': 'Age', 'field': 'age'}]\n    rows = [{'name': 'Alice', 'age': 42}, {'name': 'Bob', 'age': 23}]\n    ui.table(columns, rows, 'name').on('rowClick', ui.notify, [[], ['name'], None])",
        "mutated": [
            "@text_demo('Specifying event attributes', '\\n        **A list of strings** names the attributes of the JavaScript event object:\\n            ```py\\n            ui.button().on(\\'click\\', handle_click, [\\'clientX\\', \\'clientY\\'])\\n            ```\\n\\n        **An empty list** requests _no_ attributes:\\n            ```py\\n            ui.button().on(\\'click\\', handle_click, [])\\n            ```\\n\\n        **The value `None`** represents _all_ attributes (the default):\\n            ```py\\n            ui.button().on(\\'click\\', handle_click, None)\\n            ```\\n\\n        **If the event is called with multiple arguments** like QTable\\'s \"row-click\" `(evt, row, index) => void`,\\n            you can define a list of argument definitions:\\n            ```py\\n            ui.table(...).on(\\'rowClick\\', handle_click, [[], [\\'name\\'], None])\\n            ```\\n            In this example the \"row-click\" event will omit all arguments of the first `evt` argument,\\n            send only the \"name\" attribute of the `row` argument and send the full `index`.\\n\\n        If the retrieved list of event arguments has length 1, the argument is automatically unpacked.\\n        So you can write\\n        ```py\\n        ui.button().on(\\'click\\', lambda e: print(e.args[\\'clientX\\'], flush=True))\\n        ```\\n        instead of\\n        ```py\\n        ui.button().on(\\'click\\', lambda e: print(e.args[0][\\'clientX\\'], flush=True))\\n        ```\\n\\n        Note that by default all JSON-serializable attributes of all arguments are sent.\\n        This is to simplify registering for new events and discovering their attributes.\\n        If bandwidth is an issue, the arguments should be limited to what is actually needed on the server.\\n    ')\ndef event_attributes() -> None:\n    if False:\n        i = 10\n    columns = [{'name': 'name', 'label': 'Name', 'field': 'name'}, {'name': 'age', 'label': 'Age', 'field': 'age'}]\n    rows = [{'name': 'Alice', 'age': 42}, {'name': 'Bob', 'age': 23}]\n    ui.table(columns, rows, 'name').on('rowClick', ui.notify, [[], ['name'], None])",
            "@text_demo('Specifying event attributes', '\\n        **A list of strings** names the attributes of the JavaScript event object:\\n            ```py\\n            ui.button().on(\\'click\\', handle_click, [\\'clientX\\', \\'clientY\\'])\\n            ```\\n\\n        **An empty list** requests _no_ attributes:\\n            ```py\\n            ui.button().on(\\'click\\', handle_click, [])\\n            ```\\n\\n        **The value `None`** represents _all_ attributes (the default):\\n            ```py\\n            ui.button().on(\\'click\\', handle_click, None)\\n            ```\\n\\n        **If the event is called with multiple arguments** like QTable\\'s \"row-click\" `(evt, row, index) => void`,\\n            you can define a list of argument definitions:\\n            ```py\\n            ui.table(...).on(\\'rowClick\\', handle_click, [[], [\\'name\\'], None])\\n            ```\\n            In this example the \"row-click\" event will omit all arguments of the first `evt` argument,\\n            send only the \"name\" attribute of the `row` argument and send the full `index`.\\n\\n        If the retrieved list of event arguments has length 1, the argument is automatically unpacked.\\n        So you can write\\n        ```py\\n        ui.button().on(\\'click\\', lambda e: print(e.args[\\'clientX\\'], flush=True))\\n        ```\\n        instead of\\n        ```py\\n        ui.button().on(\\'click\\', lambda e: print(e.args[0][\\'clientX\\'], flush=True))\\n        ```\\n\\n        Note that by default all JSON-serializable attributes of all arguments are sent.\\n        This is to simplify registering for new events and discovering their attributes.\\n        If bandwidth is an issue, the arguments should be limited to what is actually needed on the server.\\n    ')\ndef event_attributes() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    columns = [{'name': 'name', 'label': 'Name', 'field': 'name'}, {'name': 'age', 'label': 'Age', 'field': 'age'}]\n    rows = [{'name': 'Alice', 'age': 42}, {'name': 'Bob', 'age': 23}]\n    ui.table(columns, rows, 'name').on('rowClick', ui.notify, [[], ['name'], None])",
            "@text_demo('Specifying event attributes', '\\n        **A list of strings** names the attributes of the JavaScript event object:\\n            ```py\\n            ui.button().on(\\'click\\', handle_click, [\\'clientX\\', \\'clientY\\'])\\n            ```\\n\\n        **An empty list** requests _no_ attributes:\\n            ```py\\n            ui.button().on(\\'click\\', handle_click, [])\\n            ```\\n\\n        **The value `None`** represents _all_ attributes (the default):\\n            ```py\\n            ui.button().on(\\'click\\', handle_click, None)\\n            ```\\n\\n        **If the event is called with multiple arguments** like QTable\\'s \"row-click\" `(evt, row, index) => void`,\\n            you can define a list of argument definitions:\\n            ```py\\n            ui.table(...).on(\\'rowClick\\', handle_click, [[], [\\'name\\'], None])\\n            ```\\n            In this example the \"row-click\" event will omit all arguments of the first `evt` argument,\\n            send only the \"name\" attribute of the `row` argument and send the full `index`.\\n\\n        If the retrieved list of event arguments has length 1, the argument is automatically unpacked.\\n        So you can write\\n        ```py\\n        ui.button().on(\\'click\\', lambda e: print(e.args[\\'clientX\\'], flush=True))\\n        ```\\n        instead of\\n        ```py\\n        ui.button().on(\\'click\\', lambda e: print(e.args[0][\\'clientX\\'], flush=True))\\n        ```\\n\\n        Note that by default all JSON-serializable attributes of all arguments are sent.\\n        This is to simplify registering for new events and discovering their attributes.\\n        If bandwidth is an issue, the arguments should be limited to what is actually needed on the server.\\n    ')\ndef event_attributes() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    columns = [{'name': 'name', 'label': 'Name', 'field': 'name'}, {'name': 'age', 'label': 'Age', 'field': 'age'}]\n    rows = [{'name': 'Alice', 'age': 42}, {'name': 'Bob', 'age': 23}]\n    ui.table(columns, rows, 'name').on('rowClick', ui.notify, [[], ['name'], None])",
            "@text_demo('Specifying event attributes', '\\n        **A list of strings** names the attributes of the JavaScript event object:\\n            ```py\\n            ui.button().on(\\'click\\', handle_click, [\\'clientX\\', \\'clientY\\'])\\n            ```\\n\\n        **An empty list** requests _no_ attributes:\\n            ```py\\n            ui.button().on(\\'click\\', handle_click, [])\\n            ```\\n\\n        **The value `None`** represents _all_ attributes (the default):\\n            ```py\\n            ui.button().on(\\'click\\', handle_click, None)\\n            ```\\n\\n        **If the event is called with multiple arguments** like QTable\\'s \"row-click\" `(evt, row, index) => void`,\\n            you can define a list of argument definitions:\\n            ```py\\n            ui.table(...).on(\\'rowClick\\', handle_click, [[], [\\'name\\'], None])\\n            ```\\n            In this example the \"row-click\" event will omit all arguments of the first `evt` argument,\\n            send only the \"name\" attribute of the `row` argument and send the full `index`.\\n\\n        If the retrieved list of event arguments has length 1, the argument is automatically unpacked.\\n        So you can write\\n        ```py\\n        ui.button().on(\\'click\\', lambda e: print(e.args[\\'clientX\\'], flush=True))\\n        ```\\n        instead of\\n        ```py\\n        ui.button().on(\\'click\\', lambda e: print(e.args[0][\\'clientX\\'], flush=True))\\n        ```\\n\\n        Note that by default all JSON-serializable attributes of all arguments are sent.\\n        This is to simplify registering for new events and discovering their attributes.\\n        If bandwidth is an issue, the arguments should be limited to what is actually needed on the server.\\n    ')\ndef event_attributes() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    columns = [{'name': 'name', 'label': 'Name', 'field': 'name'}, {'name': 'age', 'label': 'Age', 'field': 'age'}]\n    rows = [{'name': 'Alice', 'age': 42}, {'name': 'Bob', 'age': 23}]\n    ui.table(columns, rows, 'name').on('rowClick', ui.notify, [[], ['name'], None])",
            "@text_demo('Specifying event attributes', '\\n        **A list of strings** names the attributes of the JavaScript event object:\\n            ```py\\n            ui.button().on(\\'click\\', handle_click, [\\'clientX\\', \\'clientY\\'])\\n            ```\\n\\n        **An empty list** requests _no_ attributes:\\n            ```py\\n            ui.button().on(\\'click\\', handle_click, [])\\n            ```\\n\\n        **The value `None`** represents _all_ attributes (the default):\\n            ```py\\n            ui.button().on(\\'click\\', handle_click, None)\\n            ```\\n\\n        **If the event is called with multiple arguments** like QTable\\'s \"row-click\" `(evt, row, index) => void`,\\n            you can define a list of argument definitions:\\n            ```py\\n            ui.table(...).on(\\'rowClick\\', handle_click, [[], [\\'name\\'], None])\\n            ```\\n            In this example the \"row-click\" event will omit all arguments of the first `evt` argument,\\n            send only the \"name\" attribute of the `row` argument and send the full `index`.\\n\\n        If the retrieved list of event arguments has length 1, the argument is automatically unpacked.\\n        So you can write\\n        ```py\\n        ui.button().on(\\'click\\', lambda e: print(e.args[\\'clientX\\'], flush=True))\\n        ```\\n        instead of\\n        ```py\\n        ui.button().on(\\'click\\', lambda e: print(e.args[0][\\'clientX\\'], flush=True))\\n        ```\\n\\n        Note that by default all JSON-serializable attributes of all arguments are sent.\\n        This is to simplify registering for new events and discovering their attributes.\\n        If bandwidth is an issue, the arguments should be limited to what is actually needed on the server.\\n    ')\ndef event_attributes() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    columns = [{'name': 'name', 'label': 'Name', 'field': 'name'}, {'name': 'age', 'label': 'Age', 'field': 'age'}]\n    rows = [{'name': 'Alice', 'age': 42}, {'name': 'Bob', 'age': 23}]\n    ui.table(columns, rows, 'name').on('rowClick', ui.notify, [[], ['name'], None])"
        ]
    },
    {
        "func_name": "modifiers",
        "original": "@text_demo('Modifiers', '\\n        You can also include [key modifiers](https://vuejs.org/guide/essentials/event-handling.html#key-modifiers>) (shown in input \"A\"),\\n        modifier combinations (shown in input \"B\"),\\n        and [event modifiers](https://vuejs.org/guide/essentials/event-handling.html#mouse-button-modifiers>) (shown in input \"C\").\\n    ')\ndef modifiers() -> None:\n    with ui.row():\n        ui.input('A').classes('w-12').on('keydown.space', lambda : ui.notify('You pressed space.'))\n        ui.input('B').classes('w-12').on('keydown.y.shift', lambda : ui.notify('You pressed Shift+Y'))\n        ui.input('C').classes('w-12').on('keydown.once', lambda : ui.notify('You started typing.'))",
        "mutated": [
            "@text_demo('Modifiers', '\\n        You can also include [key modifiers](https://vuejs.org/guide/essentials/event-handling.html#key-modifiers>) (shown in input \"A\"),\\n        modifier combinations (shown in input \"B\"),\\n        and [event modifiers](https://vuejs.org/guide/essentials/event-handling.html#mouse-button-modifiers>) (shown in input \"C\").\\n    ')\ndef modifiers() -> None:\n    if False:\n        i = 10\n    with ui.row():\n        ui.input('A').classes('w-12').on('keydown.space', lambda : ui.notify('You pressed space.'))\n        ui.input('B').classes('w-12').on('keydown.y.shift', lambda : ui.notify('You pressed Shift+Y'))\n        ui.input('C').classes('w-12').on('keydown.once', lambda : ui.notify('You started typing.'))",
            "@text_demo('Modifiers', '\\n        You can also include [key modifiers](https://vuejs.org/guide/essentials/event-handling.html#key-modifiers>) (shown in input \"A\"),\\n        modifier combinations (shown in input \"B\"),\\n        and [event modifiers](https://vuejs.org/guide/essentials/event-handling.html#mouse-button-modifiers>) (shown in input \"C\").\\n    ')\ndef modifiers() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    with ui.row():\n        ui.input('A').classes('w-12').on('keydown.space', lambda : ui.notify('You pressed space.'))\n        ui.input('B').classes('w-12').on('keydown.y.shift', lambda : ui.notify('You pressed Shift+Y'))\n        ui.input('C').classes('w-12').on('keydown.once', lambda : ui.notify('You started typing.'))",
            "@text_demo('Modifiers', '\\n        You can also include [key modifiers](https://vuejs.org/guide/essentials/event-handling.html#key-modifiers>) (shown in input \"A\"),\\n        modifier combinations (shown in input \"B\"),\\n        and [event modifiers](https://vuejs.org/guide/essentials/event-handling.html#mouse-button-modifiers>) (shown in input \"C\").\\n    ')\ndef modifiers() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    with ui.row():\n        ui.input('A').classes('w-12').on('keydown.space', lambda : ui.notify('You pressed space.'))\n        ui.input('B').classes('w-12').on('keydown.y.shift', lambda : ui.notify('You pressed Shift+Y'))\n        ui.input('C').classes('w-12').on('keydown.once', lambda : ui.notify('You started typing.'))",
            "@text_demo('Modifiers', '\\n        You can also include [key modifiers](https://vuejs.org/guide/essentials/event-handling.html#key-modifiers>) (shown in input \"A\"),\\n        modifier combinations (shown in input \"B\"),\\n        and [event modifiers](https://vuejs.org/guide/essentials/event-handling.html#mouse-button-modifiers>) (shown in input \"C\").\\n    ')\ndef modifiers() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    with ui.row():\n        ui.input('A').classes('w-12').on('keydown.space', lambda : ui.notify('You pressed space.'))\n        ui.input('B').classes('w-12').on('keydown.y.shift', lambda : ui.notify('You pressed Shift+Y'))\n        ui.input('C').classes('w-12').on('keydown.once', lambda : ui.notify('You started typing.'))",
            "@text_demo('Modifiers', '\\n        You can also include [key modifiers](https://vuejs.org/guide/essentials/event-handling.html#key-modifiers>) (shown in input \"A\"),\\n        modifier combinations (shown in input \"B\"),\\n        and [event modifiers](https://vuejs.org/guide/essentials/event-handling.html#mouse-button-modifiers>) (shown in input \"C\").\\n    ')\ndef modifiers() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    with ui.row():\n        ui.input('A').classes('w-12').on('keydown.space', lambda : ui.notify('You pressed space.'))\n        ui.input('B').classes('w-12').on('keydown.y.shift', lambda : ui.notify('You pressed Shift+Y'))\n        ui.input('C').classes('w-12').on('keydown.once', lambda : ui.notify('You started typing.'))"
        ]
    },
    {
        "func_name": "more",
        "original": "def more() -> None:\n\n    @text_demo('Specifying event attributes', '\\n        **A list of strings** names the attributes of the JavaScript event object:\\n            ```py\\n            ui.button().on(\\'click\\', handle_click, [\\'clientX\\', \\'clientY\\'])\\n            ```\\n\\n        **An empty list** requests _no_ attributes:\\n            ```py\\n            ui.button().on(\\'click\\', handle_click, [])\\n            ```\\n\\n        **The value `None`** represents _all_ attributes (the default):\\n            ```py\\n            ui.button().on(\\'click\\', handle_click, None)\\n            ```\\n\\n        **If the event is called with multiple arguments** like QTable\\'s \"row-click\" `(evt, row, index) => void`,\\n            you can define a list of argument definitions:\\n            ```py\\n            ui.table(...).on(\\'rowClick\\', handle_click, [[], [\\'name\\'], None])\\n            ```\\n            In this example the \"row-click\" event will omit all arguments of the first `evt` argument,\\n            send only the \"name\" attribute of the `row` argument and send the full `index`.\\n\\n        If the retrieved list of event arguments has length 1, the argument is automatically unpacked.\\n        So you can write\\n        ```py\\n        ui.button().on(\\'click\\', lambda e: print(e.args[\\'clientX\\'], flush=True))\\n        ```\\n        instead of\\n        ```py\\n        ui.button().on(\\'click\\', lambda e: print(e.args[0][\\'clientX\\'], flush=True))\\n        ```\\n\\n        Note that by default all JSON-serializable attributes of all arguments are sent.\\n        This is to simplify registering for new events and discovering their attributes.\\n        If bandwidth is an issue, the arguments should be limited to what is actually needed on the server.\\n    ')\n    def event_attributes() -> None:\n        columns = [{'name': 'name', 'label': 'Name', 'field': 'name'}, {'name': 'age', 'label': 'Age', 'field': 'age'}]\n        rows = [{'name': 'Alice', 'age': 42}, {'name': 'Bob', 'age': 23}]\n        ui.table(columns, rows, 'name').on('rowClick', ui.notify, [[], ['name'], None])\n\n    @text_demo('Modifiers', '\\n        You can also include [key modifiers](https://vuejs.org/guide/essentials/event-handling.html#key-modifiers>) (shown in input \"A\"),\\n        modifier combinations (shown in input \"B\"),\\n        and [event modifiers](https://vuejs.org/guide/essentials/event-handling.html#mouse-button-modifiers>) (shown in input \"C\").\\n    ')\n    def modifiers() -> None:\n        with ui.row():\n            ui.input('A').classes('w-12').on('keydown.space', lambda : ui.notify('You pressed space.'))\n            ui.input('B').classes('w-12').on('keydown.y.shift', lambda : ui.notify('You pressed Shift+Y'))\n            ui.input('C').classes('w-12').on('keydown.once', lambda : ui.notify('You started typing.'))\n\n    @text_demo('Custom events', '\\n        It is fairly easy to emit custom events from JavaScript which can be listened to with `element.on(...)`.\\n        This can be useful if you want to call Python code when something happens in JavaScript.\\n        In this example we are listening to the `visibilitychange` event of the browser tab.\\n    ')\n    async def custom_events() -> None:\n        tabwatch = ui.checkbox('Watch browser tab re-entering').on('tabvisible', lambda : ui.notify('Welcome back!') if tabwatch.value else None, args=[])\n        ui.add_head_html(f\"\\n            <script>\\n            document.addEventListener('visibilitychange', () => {{\\n                if (document.visibilityState === 'visible')\\n                    getElement({tabwatch.id}).$emit('tabvisible');\\n            }});\\n            </script>\\n        \")\n        await context.get_client().connected()\n        ui.run_javascript(f\"\\n            document.addEventListener('visibilitychange', () => {{\\n                if (document.visibilityState === 'visible')\\n                    getElement({tabwatch.id}).$emit('tabvisible');\\n            }});\\n        \")",
        "mutated": [
            "def more() -> None:\n    if False:\n        i = 10\n\n    @text_demo('Specifying event attributes', '\\n        **A list of strings** names the attributes of the JavaScript event object:\\n            ```py\\n            ui.button().on(\\'click\\', handle_click, [\\'clientX\\', \\'clientY\\'])\\n            ```\\n\\n        **An empty list** requests _no_ attributes:\\n            ```py\\n            ui.button().on(\\'click\\', handle_click, [])\\n            ```\\n\\n        **The value `None`** represents _all_ attributes (the default):\\n            ```py\\n            ui.button().on(\\'click\\', handle_click, None)\\n            ```\\n\\n        **If the event is called with multiple arguments** like QTable\\'s \"row-click\" `(evt, row, index) => void`,\\n            you can define a list of argument definitions:\\n            ```py\\n            ui.table(...).on(\\'rowClick\\', handle_click, [[], [\\'name\\'], None])\\n            ```\\n            In this example the \"row-click\" event will omit all arguments of the first `evt` argument,\\n            send only the \"name\" attribute of the `row` argument and send the full `index`.\\n\\n        If the retrieved list of event arguments has length 1, the argument is automatically unpacked.\\n        So you can write\\n        ```py\\n        ui.button().on(\\'click\\', lambda e: print(e.args[\\'clientX\\'], flush=True))\\n        ```\\n        instead of\\n        ```py\\n        ui.button().on(\\'click\\', lambda e: print(e.args[0][\\'clientX\\'], flush=True))\\n        ```\\n\\n        Note that by default all JSON-serializable attributes of all arguments are sent.\\n        This is to simplify registering for new events and discovering their attributes.\\n        If bandwidth is an issue, the arguments should be limited to what is actually needed on the server.\\n    ')\n    def event_attributes() -> None:\n        columns = [{'name': 'name', 'label': 'Name', 'field': 'name'}, {'name': 'age', 'label': 'Age', 'field': 'age'}]\n        rows = [{'name': 'Alice', 'age': 42}, {'name': 'Bob', 'age': 23}]\n        ui.table(columns, rows, 'name').on('rowClick', ui.notify, [[], ['name'], None])\n\n    @text_demo('Modifiers', '\\n        You can also include [key modifiers](https://vuejs.org/guide/essentials/event-handling.html#key-modifiers>) (shown in input \"A\"),\\n        modifier combinations (shown in input \"B\"),\\n        and [event modifiers](https://vuejs.org/guide/essentials/event-handling.html#mouse-button-modifiers>) (shown in input \"C\").\\n    ')\n    def modifiers() -> None:\n        with ui.row():\n            ui.input('A').classes('w-12').on('keydown.space', lambda : ui.notify('You pressed space.'))\n            ui.input('B').classes('w-12').on('keydown.y.shift', lambda : ui.notify('You pressed Shift+Y'))\n            ui.input('C').classes('w-12').on('keydown.once', lambda : ui.notify('You started typing.'))\n\n    @text_demo('Custom events', '\\n        It is fairly easy to emit custom events from JavaScript which can be listened to with `element.on(...)`.\\n        This can be useful if you want to call Python code when something happens in JavaScript.\\n        In this example we are listening to the `visibilitychange` event of the browser tab.\\n    ')\n    async def custom_events() -> None:\n        tabwatch = ui.checkbox('Watch browser tab re-entering').on('tabvisible', lambda : ui.notify('Welcome back!') if tabwatch.value else None, args=[])\n        ui.add_head_html(f\"\\n            <script>\\n            document.addEventListener('visibilitychange', () => {{\\n                if (document.visibilityState === 'visible')\\n                    getElement({tabwatch.id}).$emit('tabvisible');\\n            }});\\n            </script>\\n        \")\n        await context.get_client().connected()\n        ui.run_javascript(f\"\\n            document.addEventListener('visibilitychange', () => {{\\n                if (document.visibilityState === 'visible')\\n                    getElement({tabwatch.id}).$emit('tabvisible');\\n            }});\\n        \")",
            "def more() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    @text_demo('Specifying event attributes', '\\n        **A list of strings** names the attributes of the JavaScript event object:\\n            ```py\\n            ui.button().on(\\'click\\', handle_click, [\\'clientX\\', \\'clientY\\'])\\n            ```\\n\\n        **An empty list** requests _no_ attributes:\\n            ```py\\n            ui.button().on(\\'click\\', handle_click, [])\\n            ```\\n\\n        **The value `None`** represents _all_ attributes (the default):\\n            ```py\\n            ui.button().on(\\'click\\', handle_click, None)\\n            ```\\n\\n        **If the event is called with multiple arguments** like QTable\\'s \"row-click\" `(evt, row, index) => void`,\\n            you can define a list of argument definitions:\\n            ```py\\n            ui.table(...).on(\\'rowClick\\', handle_click, [[], [\\'name\\'], None])\\n            ```\\n            In this example the \"row-click\" event will omit all arguments of the first `evt` argument,\\n            send only the \"name\" attribute of the `row` argument and send the full `index`.\\n\\n        If the retrieved list of event arguments has length 1, the argument is automatically unpacked.\\n        So you can write\\n        ```py\\n        ui.button().on(\\'click\\', lambda e: print(e.args[\\'clientX\\'], flush=True))\\n        ```\\n        instead of\\n        ```py\\n        ui.button().on(\\'click\\', lambda e: print(e.args[0][\\'clientX\\'], flush=True))\\n        ```\\n\\n        Note that by default all JSON-serializable attributes of all arguments are sent.\\n        This is to simplify registering for new events and discovering their attributes.\\n        If bandwidth is an issue, the arguments should be limited to what is actually needed on the server.\\n    ')\n    def event_attributes() -> None:\n        columns = [{'name': 'name', 'label': 'Name', 'field': 'name'}, {'name': 'age', 'label': 'Age', 'field': 'age'}]\n        rows = [{'name': 'Alice', 'age': 42}, {'name': 'Bob', 'age': 23}]\n        ui.table(columns, rows, 'name').on('rowClick', ui.notify, [[], ['name'], None])\n\n    @text_demo('Modifiers', '\\n        You can also include [key modifiers](https://vuejs.org/guide/essentials/event-handling.html#key-modifiers>) (shown in input \"A\"),\\n        modifier combinations (shown in input \"B\"),\\n        and [event modifiers](https://vuejs.org/guide/essentials/event-handling.html#mouse-button-modifiers>) (shown in input \"C\").\\n    ')\n    def modifiers() -> None:\n        with ui.row():\n            ui.input('A').classes('w-12').on('keydown.space', lambda : ui.notify('You pressed space.'))\n            ui.input('B').classes('w-12').on('keydown.y.shift', lambda : ui.notify('You pressed Shift+Y'))\n            ui.input('C').classes('w-12').on('keydown.once', lambda : ui.notify('You started typing.'))\n\n    @text_demo('Custom events', '\\n        It is fairly easy to emit custom events from JavaScript which can be listened to with `element.on(...)`.\\n        This can be useful if you want to call Python code when something happens in JavaScript.\\n        In this example we are listening to the `visibilitychange` event of the browser tab.\\n    ')\n    async def custom_events() -> None:\n        tabwatch = ui.checkbox('Watch browser tab re-entering').on('tabvisible', lambda : ui.notify('Welcome back!') if tabwatch.value else None, args=[])\n        ui.add_head_html(f\"\\n            <script>\\n            document.addEventListener('visibilitychange', () => {{\\n                if (document.visibilityState === 'visible')\\n                    getElement({tabwatch.id}).$emit('tabvisible');\\n            }});\\n            </script>\\n        \")\n        await context.get_client().connected()\n        ui.run_javascript(f\"\\n            document.addEventListener('visibilitychange', () => {{\\n                if (document.visibilityState === 'visible')\\n                    getElement({tabwatch.id}).$emit('tabvisible');\\n            }});\\n        \")",
            "def more() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    @text_demo('Specifying event attributes', '\\n        **A list of strings** names the attributes of the JavaScript event object:\\n            ```py\\n            ui.button().on(\\'click\\', handle_click, [\\'clientX\\', \\'clientY\\'])\\n            ```\\n\\n        **An empty list** requests _no_ attributes:\\n            ```py\\n            ui.button().on(\\'click\\', handle_click, [])\\n            ```\\n\\n        **The value `None`** represents _all_ attributes (the default):\\n            ```py\\n            ui.button().on(\\'click\\', handle_click, None)\\n            ```\\n\\n        **If the event is called with multiple arguments** like QTable\\'s \"row-click\" `(evt, row, index) => void`,\\n            you can define a list of argument definitions:\\n            ```py\\n            ui.table(...).on(\\'rowClick\\', handle_click, [[], [\\'name\\'], None])\\n            ```\\n            In this example the \"row-click\" event will omit all arguments of the first `evt` argument,\\n            send only the \"name\" attribute of the `row` argument and send the full `index`.\\n\\n        If the retrieved list of event arguments has length 1, the argument is automatically unpacked.\\n        So you can write\\n        ```py\\n        ui.button().on(\\'click\\', lambda e: print(e.args[\\'clientX\\'], flush=True))\\n        ```\\n        instead of\\n        ```py\\n        ui.button().on(\\'click\\', lambda e: print(e.args[0][\\'clientX\\'], flush=True))\\n        ```\\n\\n        Note that by default all JSON-serializable attributes of all arguments are sent.\\n        This is to simplify registering for new events and discovering their attributes.\\n        If bandwidth is an issue, the arguments should be limited to what is actually needed on the server.\\n    ')\n    def event_attributes() -> None:\n        columns = [{'name': 'name', 'label': 'Name', 'field': 'name'}, {'name': 'age', 'label': 'Age', 'field': 'age'}]\n        rows = [{'name': 'Alice', 'age': 42}, {'name': 'Bob', 'age': 23}]\n        ui.table(columns, rows, 'name').on('rowClick', ui.notify, [[], ['name'], None])\n\n    @text_demo('Modifiers', '\\n        You can also include [key modifiers](https://vuejs.org/guide/essentials/event-handling.html#key-modifiers>) (shown in input \"A\"),\\n        modifier combinations (shown in input \"B\"),\\n        and [event modifiers](https://vuejs.org/guide/essentials/event-handling.html#mouse-button-modifiers>) (shown in input \"C\").\\n    ')\n    def modifiers() -> None:\n        with ui.row():\n            ui.input('A').classes('w-12').on('keydown.space', lambda : ui.notify('You pressed space.'))\n            ui.input('B').classes('w-12').on('keydown.y.shift', lambda : ui.notify('You pressed Shift+Y'))\n            ui.input('C').classes('w-12').on('keydown.once', lambda : ui.notify('You started typing.'))\n\n    @text_demo('Custom events', '\\n        It is fairly easy to emit custom events from JavaScript which can be listened to with `element.on(...)`.\\n        This can be useful if you want to call Python code when something happens in JavaScript.\\n        In this example we are listening to the `visibilitychange` event of the browser tab.\\n    ')\n    async def custom_events() -> None:\n        tabwatch = ui.checkbox('Watch browser tab re-entering').on('tabvisible', lambda : ui.notify('Welcome back!') if tabwatch.value else None, args=[])\n        ui.add_head_html(f\"\\n            <script>\\n            document.addEventListener('visibilitychange', () => {{\\n                if (document.visibilityState === 'visible')\\n                    getElement({tabwatch.id}).$emit('tabvisible');\\n            }});\\n            </script>\\n        \")\n        await context.get_client().connected()\n        ui.run_javascript(f\"\\n            document.addEventListener('visibilitychange', () => {{\\n                if (document.visibilityState === 'visible')\\n                    getElement({tabwatch.id}).$emit('tabvisible');\\n            }});\\n        \")",
            "def more() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    @text_demo('Specifying event attributes', '\\n        **A list of strings** names the attributes of the JavaScript event object:\\n            ```py\\n            ui.button().on(\\'click\\', handle_click, [\\'clientX\\', \\'clientY\\'])\\n            ```\\n\\n        **An empty list** requests _no_ attributes:\\n            ```py\\n            ui.button().on(\\'click\\', handle_click, [])\\n            ```\\n\\n        **The value `None`** represents _all_ attributes (the default):\\n            ```py\\n            ui.button().on(\\'click\\', handle_click, None)\\n            ```\\n\\n        **If the event is called with multiple arguments** like QTable\\'s \"row-click\" `(evt, row, index) => void`,\\n            you can define a list of argument definitions:\\n            ```py\\n            ui.table(...).on(\\'rowClick\\', handle_click, [[], [\\'name\\'], None])\\n            ```\\n            In this example the \"row-click\" event will omit all arguments of the first `evt` argument,\\n            send only the \"name\" attribute of the `row` argument and send the full `index`.\\n\\n        If the retrieved list of event arguments has length 1, the argument is automatically unpacked.\\n        So you can write\\n        ```py\\n        ui.button().on(\\'click\\', lambda e: print(e.args[\\'clientX\\'], flush=True))\\n        ```\\n        instead of\\n        ```py\\n        ui.button().on(\\'click\\', lambda e: print(e.args[0][\\'clientX\\'], flush=True))\\n        ```\\n\\n        Note that by default all JSON-serializable attributes of all arguments are sent.\\n        This is to simplify registering for new events and discovering their attributes.\\n        If bandwidth is an issue, the arguments should be limited to what is actually needed on the server.\\n    ')\n    def event_attributes() -> None:\n        columns = [{'name': 'name', 'label': 'Name', 'field': 'name'}, {'name': 'age', 'label': 'Age', 'field': 'age'}]\n        rows = [{'name': 'Alice', 'age': 42}, {'name': 'Bob', 'age': 23}]\n        ui.table(columns, rows, 'name').on('rowClick', ui.notify, [[], ['name'], None])\n\n    @text_demo('Modifiers', '\\n        You can also include [key modifiers](https://vuejs.org/guide/essentials/event-handling.html#key-modifiers>) (shown in input \"A\"),\\n        modifier combinations (shown in input \"B\"),\\n        and [event modifiers](https://vuejs.org/guide/essentials/event-handling.html#mouse-button-modifiers>) (shown in input \"C\").\\n    ')\n    def modifiers() -> None:\n        with ui.row():\n            ui.input('A').classes('w-12').on('keydown.space', lambda : ui.notify('You pressed space.'))\n            ui.input('B').classes('w-12').on('keydown.y.shift', lambda : ui.notify('You pressed Shift+Y'))\n            ui.input('C').classes('w-12').on('keydown.once', lambda : ui.notify('You started typing.'))\n\n    @text_demo('Custom events', '\\n        It is fairly easy to emit custom events from JavaScript which can be listened to with `element.on(...)`.\\n        This can be useful if you want to call Python code when something happens in JavaScript.\\n        In this example we are listening to the `visibilitychange` event of the browser tab.\\n    ')\n    async def custom_events() -> None:\n        tabwatch = ui.checkbox('Watch browser tab re-entering').on('tabvisible', lambda : ui.notify('Welcome back!') if tabwatch.value else None, args=[])\n        ui.add_head_html(f\"\\n            <script>\\n            document.addEventListener('visibilitychange', () => {{\\n                if (document.visibilityState === 'visible')\\n                    getElement({tabwatch.id}).$emit('tabvisible');\\n            }});\\n            </script>\\n        \")\n        await context.get_client().connected()\n        ui.run_javascript(f\"\\n            document.addEventListener('visibilitychange', () => {{\\n                if (document.visibilityState === 'visible')\\n                    getElement({tabwatch.id}).$emit('tabvisible');\\n            }});\\n        \")",
            "def more() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    @text_demo('Specifying event attributes', '\\n        **A list of strings** names the attributes of the JavaScript event object:\\n            ```py\\n            ui.button().on(\\'click\\', handle_click, [\\'clientX\\', \\'clientY\\'])\\n            ```\\n\\n        **An empty list** requests _no_ attributes:\\n            ```py\\n            ui.button().on(\\'click\\', handle_click, [])\\n            ```\\n\\n        **The value `None`** represents _all_ attributes (the default):\\n            ```py\\n            ui.button().on(\\'click\\', handle_click, None)\\n            ```\\n\\n        **If the event is called with multiple arguments** like QTable\\'s \"row-click\" `(evt, row, index) => void`,\\n            you can define a list of argument definitions:\\n            ```py\\n            ui.table(...).on(\\'rowClick\\', handle_click, [[], [\\'name\\'], None])\\n            ```\\n            In this example the \"row-click\" event will omit all arguments of the first `evt` argument,\\n            send only the \"name\" attribute of the `row` argument and send the full `index`.\\n\\n        If the retrieved list of event arguments has length 1, the argument is automatically unpacked.\\n        So you can write\\n        ```py\\n        ui.button().on(\\'click\\', lambda e: print(e.args[\\'clientX\\'], flush=True))\\n        ```\\n        instead of\\n        ```py\\n        ui.button().on(\\'click\\', lambda e: print(e.args[0][\\'clientX\\'], flush=True))\\n        ```\\n\\n        Note that by default all JSON-serializable attributes of all arguments are sent.\\n        This is to simplify registering for new events and discovering their attributes.\\n        If bandwidth is an issue, the arguments should be limited to what is actually needed on the server.\\n    ')\n    def event_attributes() -> None:\n        columns = [{'name': 'name', 'label': 'Name', 'field': 'name'}, {'name': 'age', 'label': 'Age', 'field': 'age'}]\n        rows = [{'name': 'Alice', 'age': 42}, {'name': 'Bob', 'age': 23}]\n        ui.table(columns, rows, 'name').on('rowClick', ui.notify, [[], ['name'], None])\n\n    @text_demo('Modifiers', '\\n        You can also include [key modifiers](https://vuejs.org/guide/essentials/event-handling.html#key-modifiers>) (shown in input \"A\"),\\n        modifier combinations (shown in input \"B\"),\\n        and [event modifiers](https://vuejs.org/guide/essentials/event-handling.html#mouse-button-modifiers>) (shown in input \"C\").\\n    ')\n    def modifiers() -> None:\n        with ui.row():\n            ui.input('A').classes('w-12').on('keydown.space', lambda : ui.notify('You pressed space.'))\n            ui.input('B').classes('w-12').on('keydown.y.shift', lambda : ui.notify('You pressed Shift+Y'))\n            ui.input('C').classes('w-12').on('keydown.once', lambda : ui.notify('You started typing.'))\n\n    @text_demo('Custom events', '\\n        It is fairly easy to emit custom events from JavaScript which can be listened to with `element.on(...)`.\\n        This can be useful if you want to call Python code when something happens in JavaScript.\\n        In this example we are listening to the `visibilitychange` event of the browser tab.\\n    ')\n    async def custom_events() -> None:\n        tabwatch = ui.checkbox('Watch browser tab re-entering').on('tabvisible', lambda : ui.notify('Welcome back!') if tabwatch.value else None, args=[])\n        ui.add_head_html(f\"\\n            <script>\\n            document.addEventListener('visibilitychange', () => {{\\n                if (document.visibilityState === 'visible')\\n                    getElement({tabwatch.id}).$emit('tabvisible');\\n            }});\\n            </script>\\n        \")\n        await context.get_client().connected()\n        ui.run_javascript(f\"\\n            document.addEventListener('visibilitychange', () => {{\\n                if (document.visibilityState === 'visible')\\n                    getElement({tabwatch.id}).$emit('tabvisible');\\n            }});\\n        \")"
        ]
    }
]