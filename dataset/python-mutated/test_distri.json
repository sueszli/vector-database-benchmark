[
    {
        "func_name": "test_probtypes",
        "original": "@tf_util.in_session\ndef test_probtypes():\n    \"\"\"\n    test probability distribution types\n    \"\"\"\n    np.random.seed(0)\n    pdparam_diag_gauss = np.array([-0.2, 0.3, 0.4, -0.5, 0.1, -0.5, 0.1, 0.8])\n    diag_gauss = DiagGaussianProbabilityDistributionType(pdparam_diag_gauss.size // 2)\n    validate_probtype(diag_gauss, pdparam_diag_gauss)\n    pdparam_categorical = np.array([-0.2, 0.3, 0.5])\n    categorical = CategoricalProbabilityDistributionType(pdparam_categorical.size)\n    validate_probtype(categorical, pdparam_categorical)\n    nvec = np.array([1, 2, 3])\n    pdparam_multicategorical = np.array([-0.2, 0.3, 0.5, 0.1, 1, -0.1])\n    multicategorical = MultiCategoricalProbabilityDistributionType(nvec)\n    validate_probtype(multicategorical, pdparam_multicategorical)\n    pdparam_bernoulli = np.array([-0.2, 0.3, 0.5])\n    bernoulli = BernoulliProbabilityDistributionType(pdparam_bernoulli.size)\n    validate_probtype(bernoulli, pdparam_bernoulli)",
        "mutated": [
            "@tf_util.in_session\ndef test_probtypes():\n    if False:\n        i = 10\n    '\\n    test probability distribution types\\n    '\n    np.random.seed(0)\n    pdparam_diag_gauss = np.array([-0.2, 0.3, 0.4, -0.5, 0.1, -0.5, 0.1, 0.8])\n    diag_gauss = DiagGaussianProbabilityDistributionType(pdparam_diag_gauss.size // 2)\n    validate_probtype(diag_gauss, pdparam_diag_gauss)\n    pdparam_categorical = np.array([-0.2, 0.3, 0.5])\n    categorical = CategoricalProbabilityDistributionType(pdparam_categorical.size)\n    validate_probtype(categorical, pdparam_categorical)\n    nvec = np.array([1, 2, 3])\n    pdparam_multicategorical = np.array([-0.2, 0.3, 0.5, 0.1, 1, -0.1])\n    multicategorical = MultiCategoricalProbabilityDistributionType(nvec)\n    validate_probtype(multicategorical, pdparam_multicategorical)\n    pdparam_bernoulli = np.array([-0.2, 0.3, 0.5])\n    bernoulli = BernoulliProbabilityDistributionType(pdparam_bernoulli.size)\n    validate_probtype(bernoulli, pdparam_bernoulli)",
            "@tf_util.in_session\ndef test_probtypes():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    test probability distribution types\\n    '\n    np.random.seed(0)\n    pdparam_diag_gauss = np.array([-0.2, 0.3, 0.4, -0.5, 0.1, -0.5, 0.1, 0.8])\n    diag_gauss = DiagGaussianProbabilityDistributionType(pdparam_diag_gauss.size // 2)\n    validate_probtype(diag_gauss, pdparam_diag_gauss)\n    pdparam_categorical = np.array([-0.2, 0.3, 0.5])\n    categorical = CategoricalProbabilityDistributionType(pdparam_categorical.size)\n    validate_probtype(categorical, pdparam_categorical)\n    nvec = np.array([1, 2, 3])\n    pdparam_multicategorical = np.array([-0.2, 0.3, 0.5, 0.1, 1, -0.1])\n    multicategorical = MultiCategoricalProbabilityDistributionType(nvec)\n    validate_probtype(multicategorical, pdparam_multicategorical)\n    pdparam_bernoulli = np.array([-0.2, 0.3, 0.5])\n    bernoulli = BernoulliProbabilityDistributionType(pdparam_bernoulli.size)\n    validate_probtype(bernoulli, pdparam_bernoulli)",
            "@tf_util.in_session\ndef test_probtypes():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    test probability distribution types\\n    '\n    np.random.seed(0)\n    pdparam_diag_gauss = np.array([-0.2, 0.3, 0.4, -0.5, 0.1, -0.5, 0.1, 0.8])\n    diag_gauss = DiagGaussianProbabilityDistributionType(pdparam_diag_gauss.size // 2)\n    validate_probtype(diag_gauss, pdparam_diag_gauss)\n    pdparam_categorical = np.array([-0.2, 0.3, 0.5])\n    categorical = CategoricalProbabilityDistributionType(pdparam_categorical.size)\n    validate_probtype(categorical, pdparam_categorical)\n    nvec = np.array([1, 2, 3])\n    pdparam_multicategorical = np.array([-0.2, 0.3, 0.5, 0.1, 1, -0.1])\n    multicategorical = MultiCategoricalProbabilityDistributionType(nvec)\n    validate_probtype(multicategorical, pdparam_multicategorical)\n    pdparam_bernoulli = np.array([-0.2, 0.3, 0.5])\n    bernoulli = BernoulliProbabilityDistributionType(pdparam_bernoulli.size)\n    validate_probtype(bernoulli, pdparam_bernoulli)",
            "@tf_util.in_session\ndef test_probtypes():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    test probability distribution types\\n    '\n    np.random.seed(0)\n    pdparam_diag_gauss = np.array([-0.2, 0.3, 0.4, -0.5, 0.1, -0.5, 0.1, 0.8])\n    diag_gauss = DiagGaussianProbabilityDistributionType(pdparam_diag_gauss.size // 2)\n    validate_probtype(diag_gauss, pdparam_diag_gauss)\n    pdparam_categorical = np.array([-0.2, 0.3, 0.5])\n    categorical = CategoricalProbabilityDistributionType(pdparam_categorical.size)\n    validate_probtype(categorical, pdparam_categorical)\n    nvec = np.array([1, 2, 3])\n    pdparam_multicategorical = np.array([-0.2, 0.3, 0.5, 0.1, 1, -0.1])\n    multicategorical = MultiCategoricalProbabilityDistributionType(nvec)\n    validate_probtype(multicategorical, pdparam_multicategorical)\n    pdparam_bernoulli = np.array([-0.2, 0.3, 0.5])\n    bernoulli = BernoulliProbabilityDistributionType(pdparam_bernoulli.size)\n    validate_probtype(bernoulli, pdparam_bernoulli)",
            "@tf_util.in_session\ndef test_probtypes():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    test probability distribution types\\n    '\n    np.random.seed(0)\n    pdparam_diag_gauss = np.array([-0.2, 0.3, 0.4, -0.5, 0.1, -0.5, 0.1, 0.8])\n    diag_gauss = DiagGaussianProbabilityDistributionType(pdparam_diag_gauss.size // 2)\n    validate_probtype(diag_gauss, pdparam_diag_gauss)\n    pdparam_categorical = np.array([-0.2, 0.3, 0.5])\n    categorical = CategoricalProbabilityDistributionType(pdparam_categorical.size)\n    validate_probtype(categorical, pdparam_categorical)\n    nvec = np.array([1, 2, 3])\n    pdparam_multicategorical = np.array([-0.2, 0.3, 0.5, 0.1, 1, -0.1])\n    multicategorical = MultiCategoricalProbabilityDistributionType(nvec)\n    validate_probtype(multicategorical, pdparam_multicategorical)\n    pdparam_bernoulli = np.array([-0.2, 0.3, 0.5])\n    bernoulli = BernoulliProbabilityDistributionType(pdparam_bernoulli.size)\n    validate_probtype(bernoulli, pdparam_bernoulli)"
        ]
    },
    {
        "func_name": "validate_probtype",
        "original": "def validate_probtype(probtype, pdparam):\n    \"\"\"\n    validate probability distribution types\n\n    :param probtype: (ProbabilityDistributionType) the type to validate\n    :param pdparam: ([float]) the flat probabilities to test\n    \"\"\"\n    number_samples = 100000\n    mval = np.repeat(pdparam[None, :], number_samples, axis=0)\n    mval_ph = probtype.param_placeholder([number_samples])\n    xval_ph = probtype.sample_placeholder([number_samples])\n    proba_distribution = probtype.proba_distribution_from_flat(mval_ph)\n    calcloglik = tf_util.function([xval_ph, mval_ph], proba_distribution.logp(xval_ph))\n    calcent = tf_util.function([mval_ph], proba_distribution.entropy())\n    xval = tf.get_default_session().run(proba_distribution.sample(), feed_dict={mval_ph: mval})\n    logliks = calcloglik(xval, mval)\n    entval_ll = -logliks.mean()\n    entval_ll_stderr = logliks.std() / np.sqrt(number_samples)\n    entval = calcent(mval).mean()\n    assert np.abs(entval - entval_ll) < 3 * entval_ll_stderr\n    mval2_ph = probtype.param_placeholder([number_samples])\n    pd2 = probtype.proba_distribution_from_flat(mval2_ph)\n    tmp = pdparam + np.random.randn(pdparam.size) * 0.1\n    mval2 = np.repeat(tmp[None, :], number_samples, axis=0)\n    calckl = tf_util.function([mval_ph, mval2_ph], proba_distribution.kl(pd2))\n    klval = calckl(mval, mval2).mean()\n    logliks = calcloglik(xval, mval2)\n    klval_ll = -entval - logliks.mean()\n    klval_ll_stderr = logliks.std() / np.sqrt(number_samples)\n    assert np.abs(klval - klval_ll) < 3 * klval_ll_stderr\n    print('ok on', probtype, pdparam)",
        "mutated": [
            "def validate_probtype(probtype, pdparam):\n    if False:\n        i = 10\n    '\\n    validate probability distribution types\\n\\n    :param probtype: (ProbabilityDistributionType) the type to validate\\n    :param pdparam: ([float]) the flat probabilities to test\\n    '\n    number_samples = 100000\n    mval = np.repeat(pdparam[None, :], number_samples, axis=0)\n    mval_ph = probtype.param_placeholder([number_samples])\n    xval_ph = probtype.sample_placeholder([number_samples])\n    proba_distribution = probtype.proba_distribution_from_flat(mval_ph)\n    calcloglik = tf_util.function([xval_ph, mval_ph], proba_distribution.logp(xval_ph))\n    calcent = tf_util.function([mval_ph], proba_distribution.entropy())\n    xval = tf.get_default_session().run(proba_distribution.sample(), feed_dict={mval_ph: mval})\n    logliks = calcloglik(xval, mval)\n    entval_ll = -logliks.mean()\n    entval_ll_stderr = logliks.std() / np.sqrt(number_samples)\n    entval = calcent(mval).mean()\n    assert np.abs(entval - entval_ll) < 3 * entval_ll_stderr\n    mval2_ph = probtype.param_placeholder([number_samples])\n    pd2 = probtype.proba_distribution_from_flat(mval2_ph)\n    tmp = pdparam + np.random.randn(pdparam.size) * 0.1\n    mval2 = np.repeat(tmp[None, :], number_samples, axis=0)\n    calckl = tf_util.function([mval_ph, mval2_ph], proba_distribution.kl(pd2))\n    klval = calckl(mval, mval2).mean()\n    logliks = calcloglik(xval, mval2)\n    klval_ll = -entval - logliks.mean()\n    klval_ll_stderr = logliks.std() / np.sqrt(number_samples)\n    assert np.abs(klval - klval_ll) < 3 * klval_ll_stderr\n    print('ok on', probtype, pdparam)",
            "def validate_probtype(probtype, pdparam):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    validate probability distribution types\\n\\n    :param probtype: (ProbabilityDistributionType) the type to validate\\n    :param pdparam: ([float]) the flat probabilities to test\\n    '\n    number_samples = 100000\n    mval = np.repeat(pdparam[None, :], number_samples, axis=0)\n    mval_ph = probtype.param_placeholder([number_samples])\n    xval_ph = probtype.sample_placeholder([number_samples])\n    proba_distribution = probtype.proba_distribution_from_flat(mval_ph)\n    calcloglik = tf_util.function([xval_ph, mval_ph], proba_distribution.logp(xval_ph))\n    calcent = tf_util.function([mval_ph], proba_distribution.entropy())\n    xval = tf.get_default_session().run(proba_distribution.sample(), feed_dict={mval_ph: mval})\n    logliks = calcloglik(xval, mval)\n    entval_ll = -logliks.mean()\n    entval_ll_stderr = logliks.std() / np.sqrt(number_samples)\n    entval = calcent(mval).mean()\n    assert np.abs(entval - entval_ll) < 3 * entval_ll_stderr\n    mval2_ph = probtype.param_placeholder([number_samples])\n    pd2 = probtype.proba_distribution_from_flat(mval2_ph)\n    tmp = pdparam + np.random.randn(pdparam.size) * 0.1\n    mval2 = np.repeat(tmp[None, :], number_samples, axis=0)\n    calckl = tf_util.function([mval_ph, mval2_ph], proba_distribution.kl(pd2))\n    klval = calckl(mval, mval2).mean()\n    logliks = calcloglik(xval, mval2)\n    klval_ll = -entval - logliks.mean()\n    klval_ll_stderr = logliks.std() / np.sqrt(number_samples)\n    assert np.abs(klval - klval_ll) < 3 * klval_ll_stderr\n    print('ok on', probtype, pdparam)",
            "def validate_probtype(probtype, pdparam):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    validate probability distribution types\\n\\n    :param probtype: (ProbabilityDistributionType) the type to validate\\n    :param pdparam: ([float]) the flat probabilities to test\\n    '\n    number_samples = 100000\n    mval = np.repeat(pdparam[None, :], number_samples, axis=0)\n    mval_ph = probtype.param_placeholder([number_samples])\n    xval_ph = probtype.sample_placeholder([number_samples])\n    proba_distribution = probtype.proba_distribution_from_flat(mval_ph)\n    calcloglik = tf_util.function([xval_ph, mval_ph], proba_distribution.logp(xval_ph))\n    calcent = tf_util.function([mval_ph], proba_distribution.entropy())\n    xval = tf.get_default_session().run(proba_distribution.sample(), feed_dict={mval_ph: mval})\n    logliks = calcloglik(xval, mval)\n    entval_ll = -logliks.mean()\n    entval_ll_stderr = logliks.std() / np.sqrt(number_samples)\n    entval = calcent(mval).mean()\n    assert np.abs(entval - entval_ll) < 3 * entval_ll_stderr\n    mval2_ph = probtype.param_placeholder([number_samples])\n    pd2 = probtype.proba_distribution_from_flat(mval2_ph)\n    tmp = pdparam + np.random.randn(pdparam.size) * 0.1\n    mval2 = np.repeat(tmp[None, :], number_samples, axis=0)\n    calckl = tf_util.function([mval_ph, mval2_ph], proba_distribution.kl(pd2))\n    klval = calckl(mval, mval2).mean()\n    logliks = calcloglik(xval, mval2)\n    klval_ll = -entval - logliks.mean()\n    klval_ll_stderr = logliks.std() / np.sqrt(number_samples)\n    assert np.abs(klval - klval_ll) < 3 * klval_ll_stderr\n    print('ok on', probtype, pdparam)",
            "def validate_probtype(probtype, pdparam):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    validate probability distribution types\\n\\n    :param probtype: (ProbabilityDistributionType) the type to validate\\n    :param pdparam: ([float]) the flat probabilities to test\\n    '\n    number_samples = 100000\n    mval = np.repeat(pdparam[None, :], number_samples, axis=0)\n    mval_ph = probtype.param_placeholder([number_samples])\n    xval_ph = probtype.sample_placeholder([number_samples])\n    proba_distribution = probtype.proba_distribution_from_flat(mval_ph)\n    calcloglik = tf_util.function([xval_ph, mval_ph], proba_distribution.logp(xval_ph))\n    calcent = tf_util.function([mval_ph], proba_distribution.entropy())\n    xval = tf.get_default_session().run(proba_distribution.sample(), feed_dict={mval_ph: mval})\n    logliks = calcloglik(xval, mval)\n    entval_ll = -logliks.mean()\n    entval_ll_stderr = logliks.std() / np.sqrt(number_samples)\n    entval = calcent(mval).mean()\n    assert np.abs(entval - entval_ll) < 3 * entval_ll_stderr\n    mval2_ph = probtype.param_placeholder([number_samples])\n    pd2 = probtype.proba_distribution_from_flat(mval2_ph)\n    tmp = pdparam + np.random.randn(pdparam.size) * 0.1\n    mval2 = np.repeat(tmp[None, :], number_samples, axis=0)\n    calckl = tf_util.function([mval_ph, mval2_ph], proba_distribution.kl(pd2))\n    klval = calckl(mval, mval2).mean()\n    logliks = calcloglik(xval, mval2)\n    klval_ll = -entval - logliks.mean()\n    klval_ll_stderr = logliks.std() / np.sqrt(number_samples)\n    assert np.abs(klval - klval_ll) < 3 * klval_ll_stderr\n    print('ok on', probtype, pdparam)",
            "def validate_probtype(probtype, pdparam):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    validate probability distribution types\\n\\n    :param probtype: (ProbabilityDistributionType) the type to validate\\n    :param pdparam: ([float]) the flat probabilities to test\\n    '\n    number_samples = 100000\n    mval = np.repeat(pdparam[None, :], number_samples, axis=0)\n    mval_ph = probtype.param_placeholder([number_samples])\n    xval_ph = probtype.sample_placeholder([number_samples])\n    proba_distribution = probtype.proba_distribution_from_flat(mval_ph)\n    calcloglik = tf_util.function([xval_ph, mval_ph], proba_distribution.logp(xval_ph))\n    calcent = tf_util.function([mval_ph], proba_distribution.entropy())\n    xval = tf.get_default_session().run(proba_distribution.sample(), feed_dict={mval_ph: mval})\n    logliks = calcloglik(xval, mval)\n    entval_ll = -logliks.mean()\n    entval_ll_stderr = logliks.std() / np.sqrt(number_samples)\n    entval = calcent(mval).mean()\n    assert np.abs(entval - entval_ll) < 3 * entval_ll_stderr\n    mval2_ph = probtype.param_placeholder([number_samples])\n    pd2 = probtype.proba_distribution_from_flat(mval2_ph)\n    tmp = pdparam + np.random.randn(pdparam.size) * 0.1\n    mval2 = np.repeat(tmp[None, :], number_samples, axis=0)\n    calckl = tf_util.function([mval_ph, mval2_ph], proba_distribution.kl(pd2))\n    klval = calckl(mval, mval2).mean()\n    logliks = calcloglik(xval, mval2)\n    klval_ll = -entval - logliks.mean()\n    klval_ll_stderr = logliks.std() / np.sqrt(number_samples)\n    assert np.abs(klval - klval_ll) < 3 * klval_ll_stderr\n    print('ok on', probtype, pdparam)"
        ]
    }
]