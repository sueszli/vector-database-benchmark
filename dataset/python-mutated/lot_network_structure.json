[
    {
        "func_name": "plot_network_structure",
        "original": "def plot_network_structure(edge_model, embedding, names, labels, ax=[0.0, 0.0, 1.0, 1.0], figsize=None, corr_threshold=0.02, vmin=0, vmax=0.5, lw=1, alpha=None, cmap_scatter=plt.cm.nipy_spectral, cmap_lc=plt.cm.hot_r, edgecolor=plt.cm.nipy_spectral):\n    \"\"\"\n\n    Parameters\n    ----------\n    edge_model: sklearn.covariance.graph_lasso_.GraphicalLassoCV\n                The model specifications to build the graph\n\n    embedding: array-like of shape [n_components, n_instruments]\n               Transformed embedding vectors\n\n    names: array-like of shape [n_samples, 1]\n           Names of each financial instrument\n\n    labels: array-like of shape [n_instruments, 1]\n            numeric identifier of each cluster\n    ax: list of of 4 floats [left, bottom, width, height]\n        Add an axes to the current figure and make it the current axes (plt.axes\n        official docs)\n\n    figsize: (float, float), optional, default: None\n             Width and height in inches\n\n    corr_threshold: float\n                    Minimum correlation value for which to display points\n    vmin: float\n          Minimum value allowed in the normalised range\n\n    vmax: float\n          Maximum value allowed in the normalised range\n\n    lw: float or sequence of float\n\n    alpha: float between 0 and 1\n           Degree of transparency of the plot\n\n    cmap_scatter: plt.cm\n                  colour-mapping for scatter plots\n    cmap_lc: plt.cm\n             colour-mapping for LineCollection\n\n    edgecolor: plt.cm\n               colour of the borders of the box containing each financial instrument\n               name\n\n    Returns\n    A plot representing the correlation network of the financial instruments\n    -------\n\n    \"\"\"\n    if not isinstance(edge_model, covariance.graph_lasso_.GraphicalLassoCV):\n        raise TypeError('edge_model must be of class covariance.graph_lasso_.GraphicalLassoCV ')\n    if not isinstance(embedding, (np.ndarray, np.generic)):\n        raise TypeError('embedding must be of class ndarray.')\n    plt.figure(1, facecolor='w', figsize=figsize)\n    plt.clf()\n    ax = plt.axes(ax)\n    plt.axis('off')\n    partial_correlations = edge_model.precision_.copy()\n    d = 1 / np.sqrt(np.diag(partial_correlations))\n    partial_correlations *= d\n    partial_correlations *= d[:, np.newaxis]\n    non_zero = np.abs(np.triu(partial_correlations, k=1)) > corr_threshold\n    plt.scatter(embedding[0], embedding[1], s=100 * d ** 2, c=labels, cmap=cmap_scatter)\n    (start_idx, end_idx) = np.where(non_zero)\n    segments = [[embedding[:, start], embedding[:, stop]] for (start, stop) in zip(start_idx, end_idx)]\n    corr_values = np.abs(partial_correlations[non_zero])\n    lc = LineCollection(segments, zorder=0, cmap=cmap_lc, norm=plt.Normalize(vmin=vmin, vmax=vmax * corr_values.max()))\n    lc.set_array(corr_values)\n    lc.set_linewidth(lw=lw * corr_values)\n    ax.add_collection(lc)\n    n_labels = labels.max()\n    for (index, (name, label, (x, y))) in enumerate(zip(names, labels, embedding.T)):\n        dx = x - embedding[0]\n        dx[index] = 1\n        dy = y - embedding[1]\n        dy[index] = 1\n        this_dx = dx[np.argmin(np.abs(dy))]\n        this_dy = dy[np.argmin(np.abs(dx))]\n        if this_dx > 0:\n            horizontalalignment = 'left'\n            x = x + 0.002\n        else:\n            horizontalalignment = 'right'\n            x = x - 0.002\n        if this_dy > 0:\n            verticalalignment = 'bottom'\n            y = y + 0.002\n        else:\n            verticalalignment = 'top'\n            y = y - 0.002\n        plt.text(x, y, name, size=10, horizontalalignment=horizontalalignment, verticalalignment=verticalalignment, bbox=dict(facecolor='w', edgecolor=edgecolor(label / float(n_labels)), alpha=alpha))\n        plt.xlim(embedding[0].min() - 0.15 * embedding[0].ptp(), embedding[0].max() + 0.1 * embedding[0].ptp())\n        plt.ylim(embedding[1].min() - 0.03 * embedding[1].ptp(), embedding[1].min() + 0.03 * embedding[1].ptp())\n        plt.show()",
        "mutated": [
            "def plot_network_structure(edge_model, embedding, names, labels, ax=[0.0, 0.0, 1.0, 1.0], figsize=None, corr_threshold=0.02, vmin=0, vmax=0.5, lw=1, alpha=None, cmap_scatter=plt.cm.nipy_spectral, cmap_lc=plt.cm.hot_r, edgecolor=plt.cm.nipy_spectral):\n    if False:\n        i = 10\n    '\\n\\n    Parameters\\n    ----------\\n    edge_model: sklearn.covariance.graph_lasso_.GraphicalLassoCV\\n                The model specifications to build the graph\\n\\n    embedding: array-like of shape [n_components, n_instruments]\\n               Transformed embedding vectors\\n\\n    names: array-like of shape [n_samples, 1]\\n           Names of each financial instrument\\n\\n    labels: array-like of shape [n_instruments, 1]\\n            numeric identifier of each cluster\\n    ax: list of of 4 floats [left, bottom, width, height]\\n        Add an axes to the current figure and make it the current axes (plt.axes\\n        official docs)\\n\\n    figsize: (float, float), optional, default: None\\n             Width and height in inches\\n\\n    corr_threshold: float\\n                    Minimum correlation value for which to display points\\n    vmin: float\\n          Minimum value allowed in the normalised range\\n\\n    vmax: float\\n          Maximum value allowed in the normalised range\\n\\n    lw: float or sequence of float\\n\\n    alpha: float between 0 and 1\\n           Degree of transparency of the plot\\n\\n    cmap_scatter: plt.cm\\n                  colour-mapping for scatter plots\\n    cmap_lc: plt.cm\\n             colour-mapping for LineCollection\\n\\n    edgecolor: plt.cm\\n               colour of the borders of the box containing each financial instrument\\n               name\\n\\n    Returns\\n    A plot representing the correlation network of the financial instruments\\n    -------\\n\\n    '\n    if not isinstance(edge_model, covariance.graph_lasso_.GraphicalLassoCV):\n        raise TypeError('edge_model must be of class covariance.graph_lasso_.GraphicalLassoCV ')\n    if not isinstance(embedding, (np.ndarray, np.generic)):\n        raise TypeError('embedding must be of class ndarray.')\n    plt.figure(1, facecolor='w', figsize=figsize)\n    plt.clf()\n    ax = plt.axes(ax)\n    plt.axis('off')\n    partial_correlations = edge_model.precision_.copy()\n    d = 1 / np.sqrt(np.diag(partial_correlations))\n    partial_correlations *= d\n    partial_correlations *= d[:, np.newaxis]\n    non_zero = np.abs(np.triu(partial_correlations, k=1)) > corr_threshold\n    plt.scatter(embedding[0], embedding[1], s=100 * d ** 2, c=labels, cmap=cmap_scatter)\n    (start_idx, end_idx) = np.where(non_zero)\n    segments = [[embedding[:, start], embedding[:, stop]] for (start, stop) in zip(start_idx, end_idx)]\n    corr_values = np.abs(partial_correlations[non_zero])\n    lc = LineCollection(segments, zorder=0, cmap=cmap_lc, norm=plt.Normalize(vmin=vmin, vmax=vmax * corr_values.max()))\n    lc.set_array(corr_values)\n    lc.set_linewidth(lw=lw * corr_values)\n    ax.add_collection(lc)\n    n_labels = labels.max()\n    for (index, (name, label, (x, y))) in enumerate(zip(names, labels, embedding.T)):\n        dx = x - embedding[0]\n        dx[index] = 1\n        dy = y - embedding[1]\n        dy[index] = 1\n        this_dx = dx[np.argmin(np.abs(dy))]\n        this_dy = dy[np.argmin(np.abs(dx))]\n        if this_dx > 0:\n            horizontalalignment = 'left'\n            x = x + 0.002\n        else:\n            horizontalalignment = 'right'\n            x = x - 0.002\n        if this_dy > 0:\n            verticalalignment = 'bottom'\n            y = y + 0.002\n        else:\n            verticalalignment = 'top'\n            y = y - 0.002\n        plt.text(x, y, name, size=10, horizontalalignment=horizontalalignment, verticalalignment=verticalalignment, bbox=dict(facecolor='w', edgecolor=edgecolor(label / float(n_labels)), alpha=alpha))\n        plt.xlim(embedding[0].min() - 0.15 * embedding[0].ptp(), embedding[0].max() + 0.1 * embedding[0].ptp())\n        plt.ylim(embedding[1].min() - 0.03 * embedding[1].ptp(), embedding[1].min() + 0.03 * embedding[1].ptp())\n        plt.show()",
            "def plot_network_structure(edge_model, embedding, names, labels, ax=[0.0, 0.0, 1.0, 1.0], figsize=None, corr_threshold=0.02, vmin=0, vmax=0.5, lw=1, alpha=None, cmap_scatter=plt.cm.nipy_spectral, cmap_lc=plt.cm.hot_r, edgecolor=plt.cm.nipy_spectral):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n\\n    Parameters\\n    ----------\\n    edge_model: sklearn.covariance.graph_lasso_.GraphicalLassoCV\\n                The model specifications to build the graph\\n\\n    embedding: array-like of shape [n_components, n_instruments]\\n               Transformed embedding vectors\\n\\n    names: array-like of shape [n_samples, 1]\\n           Names of each financial instrument\\n\\n    labels: array-like of shape [n_instruments, 1]\\n            numeric identifier of each cluster\\n    ax: list of of 4 floats [left, bottom, width, height]\\n        Add an axes to the current figure and make it the current axes (plt.axes\\n        official docs)\\n\\n    figsize: (float, float), optional, default: None\\n             Width and height in inches\\n\\n    corr_threshold: float\\n                    Minimum correlation value for which to display points\\n    vmin: float\\n          Minimum value allowed in the normalised range\\n\\n    vmax: float\\n          Maximum value allowed in the normalised range\\n\\n    lw: float or sequence of float\\n\\n    alpha: float between 0 and 1\\n           Degree of transparency of the plot\\n\\n    cmap_scatter: plt.cm\\n                  colour-mapping for scatter plots\\n    cmap_lc: plt.cm\\n             colour-mapping for LineCollection\\n\\n    edgecolor: plt.cm\\n               colour of the borders of the box containing each financial instrument\\n               name\\n\\n    Returns\\n    A plot representing the correlation network of the financial instruments\\n    -------\\n\\n    '\n    if not isinstance(edge_model, covariance.graph_lasso_.GraphicalLassoCV):\n        raise TypeError('edge_model must be of class covariance.graph_lasso_.GraphicalLassoCV ')\n    if not isinstance(embedding, (np.ndarray, np.generic)):\n        raise TypeError('embedding must be of class ndarray.')\n    plt.figure(1, facecolor='w', figsize=figsize)\n    plt.clf()\n    ax = plt.axes(ax)\n    plt.axis('off')\n    partial_correlations = edge_model.precision_.copy()\n    d = 1 / np.sqrt(np.diag(partial_correlations))\n    partial_correlations *= d\n    partial_correlations *= d[:, np.newaxis]\n    non_zero = np.abs(np.triu(partial_correlations, k=1)) > corr_threshold\n    plt.scatter(embedding[0], embedding[1], s=100 * d ** 2, c=labels, cmap=cmap_scatter)\n    (start_idx, end_idx) = np.where(non_zero)\n    segments = [[embedding[:, start], embedding[:, stop]] for (start, stop) in zip(start_idx, end_idx)]\n    corr_values = np.abs(partial_correlations[non_zero])\n    lc = LineCollection(segments, zorder=0, cmap=cmap_lc, norm=plt.Normalize(vmin=vmin, vmax=vmax * corr_values.max()))\n    lc.set_array(corr_values)\n    lc.set_linewidth(lw=lw * corr_values)\n    ax.add_collection(lc)\n    n_labels = labels.max()\n    for (index, (name, label, (x, y))) in enumerate(zip(names, labels, embedding.T)):\n        dx = x - embedding[0]\n        dx[index] = 1\n        dy = y - embedding[1]\n        dy[index] = 1\n        this_dx = dx[np.argmin(np.abs(dy))]\n        this_dy = dy[np.argmin(np.abs(dx))]\n        if this_dx > 0:\n            horizontalalignment = 'left'\n            x = x + 0.002\n        else:\n            horizontalalignment = 'right'\n            x = x - 0.002\n        if this_dy > 0:\n            verticalalignment = 'bottom'\n            y = y + 0.002\n        else:\n            verticalalignment = 'top'\n            y = y - 0.002\n        plt.text(x, y, name, size=10, horizontalalignment=horizontalalignment, verticalalignment=verticalalignment, bbox=dict(facecolor='w', edgecolor=edgecolor(label / float(n_labels)), alpha=alpha))\n        plt.xlim(embedding[0].min() - 0.15 * embedding[0].ptp(), embedding[0].max() + 0.1 * embedding[0].ptp())\n        plt.ylim(embedding[1].min() - 0.03 * embedding[1].ptp(), embedding[1].min() + 0.03 * embedding[1].ptp())\n        plt.show()",
            "def plot_network_structure(edge_model, embedding, names, labels, ax=[0.0, 0.0, 1.0, 1.0], figsize=None, corr_threshold=0.02, vmin=0, vmax=0.5, lw=1, alpha=None, cmap_scatter=plt.cm.nipy_spectral, cmap_lc=plt.cm.hot_r, edgecolor=plt.cm.nipy_spectral):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n\\n    Parameters\\n    ----------\\n    edge_model: sklearn.covariance.graph_lasso_.GraphicalLassoCV\\n                The model specifications to build the graph\\n\\n    embedding: array-like of shape [n_components, n_instruments]\\n               Transformed embedding vectors\\n\\n    names: array-like of shape [n_samples, 1]\\n           Names of each financial instrument\\n\\n    labels: array-like of shape [n_instruments, 1]\\n            numeric identifier of each cluster\\n    ax: list of of 4 floats [left, bottom, width, height]\\n        Add an axes to the current figure and make it the current axes (plt.axes\\n        official docs)\\n\\n    figsize: (float, float), optional, default: None\\n             Width and height in inches\\n\\n    corr_threshold: float\\n                    Minimum correlation value for which to display points\\n    vmin: float\\n          Minimum value allowed in the normalised range\\n\\n    vmax: float\\n          Maximum value allowed in the normalised range\\n\\n    lw: float or sequence of float\\n\\n    alpha: float between 0 and 1\\n           Degree of transparency of the plot\\n\\n    cmap_scatter: plt.cm\\n                  colour-mapping for scatter plots\\n    cmap_lc: plt.cm\\n             colour-mapping for LineCollection\\n\\n    edgecolor: plt.cm\\n               colour of the borders of the box containing each financial instrument\\n               name\\n\\n    Returns\\n    A plot representing the correlation network of the financial instruments\\n    -------\\n\\n    '\n    if not isinstance(edge_model, covariance.graph_lasso_.GraphicalLassoCV):\n        raise TypeError('edge_model must be of class covariance.graph_lasso_.GraphicalLassoCV ')\n    if not isinstance(embedding, (np.ndarray, np.generic)):\n        raise TypeError('embedding must be of class ndarray.')\n    plt.figure(1, facecolor='w', figsize=figsize)\n    plt.clf()\n    ax = plt.axes(ax)\n    plt.axis('off')\n    partial_correlations = edge_model.precision_.copy()\n    d = 1 / np.sqrt(np.diag(partial_correlations))\n    partial_correlations *= d\n    partial_correlations *= d[:, np.newaxis]\n    non_zero = np.abs(np.triu(partial_correlations, k=1)) > corr_threshold\n    plt.scatter(embedding[0], embedding[1], s=100 * d ** 2, c=labels, cmap=cmap_scatter)\n    (start_idx, end_idx) = np.where(non_zero)\n    segments = [[embedding[:, start], embedding[:, stop]] for (start, stop) in zip(start_idx, end_idx)]\n    corr_values = np.abs(partial_correlations[non_zero])\n    lc = LineCollection(segments, zorder=0, cmap=cmap_lc, norm=plt.Normalize(vmin=vmin, vmax=vmax * corr_values.max()))\n    lc.set_array(corr_values)\n    lc.set_linewidth(lw=lw * corr_values)\n    ax.add_collection(lc)\n    n_labels = labels.max()\n    for (index, (name, label, (x, y))) in enumerate(zip(names, labels, embedding.T)):\n        dx = x - embedding[0]\n        dx[index] = 1\n        dy = y - embedding[1]\n        dy[index] = 1\n        this_dx = dx[np.argmin(np.abs(dy))]\n        this_dy = dy[np.argmin(np.abs(dx))]\n        if this_dx > 0:\n            horizontalalignment = 'left'\n            x = x + 0.002\n        else:\n            horizontalalignment = 'right'\n            x = x - 0.002\n        if this_dy > 0:\n            verticalalignment = 'bottom'\n            y = y + 0.002\n        else:\n            verticalalignment = 'top'\n            y = y - 0.002\n        plt.text(x, y, name, size=10, horizontalalignment=horizontalalignment, verticalalignment=verticalalignment, bbox=dict(facecolor='w', edgecolor=edgecolor(label / float(n_labels)), alpha=alpha))\n        plt.xlim(embedding[0].min() - 0.15 * embedding[0].ptp(), embedding[0].max() + 0.1 * embedding[0].ptp())\n        plt.ylim(embedding[1].min() - 0.03 * embedding[1].ptp(), embedding[1].min() + 0.03 * embedding[1].ptp())\n        plt.show()",
            "def plot_network_structure(edge_model, embedding, names, labels, ax=[0.0, 0.0, 1.0, 1.0], figsize=None, corr_threshold=0.02, vmin=0, vmax=0.5, lw=1, alpha=None, cmap_scatter=plt.cm.nipy_spectral, cmap_lc=plt.cm.hot_r, edgecolor=plt.cm.nipy_spectral):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n\\n    Parameters\\n    ----------\\n    edge_model: sklearn.covariance.graph_lasso_.GraphicalLassoCV\\n                The model specifications to build the graph\\n\\n    embedding: array-like of shape [n_components, n_instruments]\\n               Transformed embedding vectors\\n\\n    names: array-like of shape [n_samples, 1]\\n           Names of each financial instrument\\n\\n    labels: array-like of shape [n_instruments, 1]\\n            numeric identifier of each cluster\\n    ax: list of of 4 floats [left, bottom, width, height]\\n        Add an axes to the current figure and make it the current axes (plt.axes\\n        official docs)\\n\\n    figsize: (float, float), optional, default: None\\n             Width and height in inches\\n\\n    corr_threshold: float\\n                    Minimum correlation value for which to display points\\n    vmin: float\\n          Minimum value allowed in the normalised range\\n\\n    vmax: float\\n          Maximum value allowed in the normalised range\\n\\n    lw: float or sequence of float\\n\\n    alpha: float between 0 and 1\\n           Degree of transparency of the plot\\n\\n    cmap_scatter: plt.cm\\n                  colour-mapping for scatter plots\\n    cmap_lc: plt.cm\\n             colour-mapping for LineCollection\\n\\n    edgecolor: plt.cm\\n               colour of the borders of the box containing each financial instrument\\n               name\\n\\n    Returns\\n    A plot representing the correlation network of the financial instruments\\n    -------\\n\\n    '\n    if not isinstance(edge_model, covariance.graph_lasso_.GraphicalLassoCV):\n        raise TypeError('edge_model must be of class covariance.graph_lasso_.GraphicalLassoCV ')\n    if not isinstance(embedding, (np.ndarray, np.generic)):\n        raise TypeError('embedding must be of class ndarray.')\n    plt.figure(1, facecolor='w', figsize=figsize)\n    plt.clf()\n    ax = plt.axes(ax)\n    plt.axis('off')\n    partial_correlations = edge_model.precision_.copy()\n    d = 1 / np.sqrt(np.diag(partial_correlations))\n    partial_correlations *= d\n    partial_correlations *= d[:, np.newaxis]\n    non_zero = np.abs(np.triu(partial_correlations, k=1)) > corr_threshold\n    plt.scatter(embedding[0], embedding[1], s=100 * d ** 2, c=labels, cmap=cmap_scatter)\n    (start_idx, end_idx) = np.where(non_zero)\n    segments = [[embedding[:, start], embedding[:, stop]] for (start, stop) in zip(start_idx, end_idx)]\n    corr_values = np.abs(partial_correlations[non_zero])\n    lc = LineCollection(segments, zorder=0, cmap=cmap_lc, norm=plt.Normalize(vmin=vmin, vmax=vmax * corr_values.max()))\n    lc.set_array(corr_values)\n    lc.set_linewidth(lw=lw * corr_values)\n    ax.add_collection(lc)\n    n_labels = labels.max()\n    for (index, (name, label, (x, y))) in enumerate(zip(names, labels, embedding.T)):\n        dx = x - embedding[0]\n        dx[index] = 1\n        dy = y - embedding[1]\n        dy[index] = 1\n        this_dx = dx[np.argmin(np.abs(dy))]\n        this_dy = dy[np.argmin(np.abs(dx))]\n        if this_dx > 0:\n            horizontalalignment = 'left'\n            x = x + 0.002\n        else:\n            horizontalalignment = 'right'\n            x = x - 0.002\n        if this_dy > 0:\n            verticalalignment = 'bottom'\n            y = y + 0.002\n        else:\n            verticalalignment = 'top'\n            y = y - 0.002\n        plt.text(x, y, name, size=10, horizontalalignment=horizontalalignment, verticalalignment=verticalalignment, bbox=dict(facecolor='w', edgecolor=edgecolor(label / float(n_labels)), alpha=alpha))\n        plt.xlim(embedding[0].min() - 0.15 * embedding[0].ptp(), embedding[0].max() + 0.1 * embedding[0].ptp())\n        plt.ylim(embedding[1].min() - 0.03 * embedding[1].ptp(), embedding[1].min() + 0.03 * embedding[1].ptp())\n        plt.show()",
            "def plot_network_structure(edge_model, embedding, names, labels, ax=[0.0, 0.0, 1.0, 1.0], figsize=None, corr_threshold=0.02, vmin=0, vmax=0.5, lw=1, alpha=None, cmap_scatter=plt.cm.nipy_spectral, cmap_lc=plt.cm.hot_r, edgecolor=plt.cm.nipy_spectral):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n\\n    Parameters\\n    ----------\\n    edge_model: sklearn.covariance.graph_lasso_.GraphicalLassoCV\\n                The model specifications to build the graph\\n\\n    embedding: array-like of shape [n_components, n_instruments]\\n               Transformed embedding vectors\\n\\n    names: array-like of shape [n_samples, 1]\\n           Names of each financial instrument\\n\\n    labels: array-like of shape [n_instruments, 1]\\n            numeric identifier of each cluster\\n    ax: list of of 4 floats [left, bottom, width, height]\\n        Add an axes to the current figure and make it the current axes (plt.axes\\n        official docs)\\n\\n    figsize: (float, float), optional, default: None\\n             Width and height in inches\\n\\n    corr_threshold: float\\n                    Minimum correlation value for which to display points\\n    vmin: float\\n          Minimum value allowed in the normalised range\\n\\n    vmax: float\\n          Maximum value allowed in the normalised range\\n\\n    lw: float or sequence of float\\n\\n    alpha: float between 0 and 1\\n           Degree of transparency of the plot\\n\\n    cmap_scatter: plt.cm\\n                  colour-mapping for scatter plots\\n    cmap_lc: plt.cm\\n             colour-mapping for LineCollection\\n\\n    edgecolor: plt.cm\\n               colour of the borders of the box containing each financial instrument\\n               name\\n\\n    Returns\\n    A plot representing the correlation network of the financial instruments\\n    -------\\n\\n    '\n    if not isinstance(edge_model, covariance.graph_lasso_.GraphicalLassoCV):\n        raise TypeError('edge_model must be of class covariance.graph_lasso_.GraphicalLassoCV ')\n    if not isinstance(embedding, (np.ndarray, np.generic)):\n        raise TypeError('embedding must be of class ndarray.')\n    plt.figure(1, facecolor='w', figsize=figsize)\n    plt.clf()\n    ax = plt.axes(ax)\n    plt.axis('off')\n    partial_correlations = edge_model.precision_.copy()\n    d = 1 / np.sqrt(np.diag(partial_correlations))\n    partial_correlations *= d\n    partial_correlations *= d[:, np.newaxis]\n    non_zero = np.abs(np.triu(partial_correlations, k=1)) > corr_threshold\n    plt.scatter(embedding[0], embedding[1], s=100 * d ** 2, c=labels, cmap=cmap_scatter)\n    (start_idx, end_idx) = np.where(non_zero)\n    segments = [[embedding[:, start], embedding[:, stop]] for (start, stop) in zip(start_idx, end_idx)]\n    corr_values = np.abs(partial_correlations[non_zero])\n    lc = LineCollection(segments, zorder=0, cmap=cmap_lc, norm=plt.Normalize(vmin=vmin, vmax=vmax * corr_values.max()))\n    lc.set_array(corr_values)\n    lc.set_linewidth(lw=lw * corr_values)\n    ax.add_collection(lc)\n    n_labels = labels.max()\n    for (index, (name, label, (x, y))) in enumerate(zip(names, labels, embedding.T)):\n        dx = x - embedding[0]\n        dx[index] = 1\n        dy = y - embedding[1]\n        dy[index] = 1\n        this_dx = dx[np.argmin(np.abs(dy))]\n        this_dy = dy[np.argmin(np.abs(dx))]\n        if this_dx > 0:\n            horizontalalignment = 'left'\n            x = x + 0.002\n        else:\n            horizontalalignment = 'right'\n            x = x - 0.002\n        if this_dy > 0:\n            verticalalignment = 'bottom'\n            y = y + 0.002\n        else:\n            verticalalignment = 'top'\n            y = y - 0.002\n        plt.text(x, y, name, size=10, horizontalalignment=horizontalalignment, verticalalignment=verticalalignment, bbox=dict(facecolor='w', edgecolor=edgecolor(label / float(n_labels)), alpha=alpha))\n        plt.xlim(embedding[0].min() - 0.15 * embedding[0].ptp(), embedding[0].max() + 0.1 * embedding[0].ptp())\n        plt.ylim(embedding[1].min() - 0.03 * embedding[1].ptp(), embedding[1].min() + 0.03 * embedding[1].ptp())\n        plt.show()"
        ]
    }
]