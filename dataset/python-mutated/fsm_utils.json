[
    {
        "func_name": "dec2base",
        "original": "def dec2base(num, base, l):\n    \"\"\"\n    Decimal to any base conversion.\n    Convert 'num' to a list of 'l' numbers representing 'num'\n    to base 'base' (most significant symbol first).\n    \"\"\"\n    s = list(range(l))\n    n = num\n    for i in range(l):\n        s[l - i - 1] = n % base\n        n = int(n / base)\n    if n != 0:\n        print('Number ', num, ' requires more than ', l, 'digits.')\n    return s",
        "mutated": [
            "def dec2base(num, base, l):\n    if False:\n        i = 10\n    \"\\n    Decimal to any base conversion.\\n    Convert 'num' to a list of 'l' numbers representing 'num'\\n    to base 'base' (most significant symbol first).\\n    \"\n    s = list(range(l))\n    n = num\n    for i in range(l):\n        s[l - i - 1] = n % base\n        n = int(n / base)\n    if n != 0:\n        print('Number ', num, ' requires more than ', l, 'digits.')\n    return s",
            "def dec2base(num, base, l):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Decimal to any base conversion.\\n    Convert 'num' to a list of 'l' numbers representing 'num'\\n    to base 'base' (most significant symbol first).\\n    \"\n    s = list(range(l))\n    n = num\n    for i in range(l):\n        s[l - i - 1] = n % base\n        n = int(n / base)\n    if n != 0:\n        print('Number ', num, ' requires more than ', l, 'digits.')\n    return s",
            "def dec2base(num, base, l):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Decimal to any base conversion.\\n    Convert 'num' to a list of 'l' numbers representing 'num'\\n    to base 'base' (most significant symbol first).\\n    \"\n    s = list(range(l))\n    n = num\n    for i in range(l):\n        s[l - i - 1] = n % base\n        n = int(n / base)\n    if n != 0:\n        print('Number ', num, ' requires more than ', l, 'digits.')\n    return s",
            "def dec2base(num, base, l):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Decimal to any base conversion.\\n    Convert 'num' to a list of 'l' numbers representing 'num'\\n    to base 'base' (most significant symbol first).\\n    \"\n    s = list(range(l))\n    n = num\n    for i in range(l):\n        s[l - i - 1] = n % base\n        n = int(n / base)\n    if n != 0:\n        print('Number ', num, ' requires more than ', l, 'digits.')\n    return s",
            "def dec2base(num, base, l):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Decimal to any base conversion.\\n    Convert 'num' to a list of 'l' numbers representing 'num'\\n    to base 'base' (most significant symbol first).\\n    \"\n    s = list(range(l))\n    n = num\n    for i in range(l):\n        s[l - i - 1] = n % base\n        n = int(n / base)\n    if n != 0:\n        print('Number ', num, ' requires more than ', l, 'digits.')\n    return s"
        ]
    },
    {
        "func_name": "base2dec",
        "original": "def base2dec(s, base):\n    \"\"\"\n    Conversion from any base to decimal.\n    Convert a list 's' of symbols to a decimal number\n    (most significant symbol first)\n    \"\"\"\n    num = 0\n    for i in range(len(s)):\n        num = num * base + s[i]\n    return num",
        "mutated": [
            "def base2dec(s, base):\n    if False:\n        i = 10\n    \"\\n    Conversion from any base to decimal.\\n    Convert a list 's' of symbols to a decimal number\\n    (most significant symbol first)\\n    \"\n    num = 0\n    for i in range(len(s)):\n        num = num * base + s[i]\n    return num",
            "def base2dec(s, base):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Conversion from any base to decimal.\\n    Convert a list 's' of symbols to a decimal number\\n    (most significant symbol first)\\n    \"\n    num = 0\n    for i in range(len(s)):\n        num = num * base + s[i]\n    return num",
            "def base2dec(s, base):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Conversion from any base to decimal.\\n    Convert a list 's' of symbols to a decimal number\\n    (most significant symbol first)\\n    \"\n    num = 0\n    for i in range(len(s)):\n        num = num * base + s[i]\n    return num",
            "def base2dec(s, base):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Conversion from any base to decimal.\\n    Convert a list 's' of symbols to a decimal number\\n    (most significant symbol first)\\n    \"\n    num = 0\n    for i in range(len(s)):\n        num = num * base + s[i]\n    return num",
            "def base2dec(s, base):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Conversion from any base to decimal.\\n    Convert a list 's' of symbols to a decimal number\\n    (most significant symbol first)\\n    \"\n    num = 0\n    for i in range(len(s)):\n        num = num * base + s[i]\n    return num"
        ]
    },
    {
        "func_name": "make_isi_lookup",
        "original": "def make_isi_lookup(mod, channel, normalize):\n    \"\"\"\n    Automatically generate the lookup table that maps the FSM outputs\n    to channel inputs corresponding to a channel 'channel' and a modulation\n    'mod'. Optional normalization of channel to unit energy.\n    This table is used by the 'metrics' block to translate\n    channel outputs to metrics for use with the Viterbi algorithm.\n    Limitations: currently supports only one-dimensional modulations.\n    \"\"\"\n    dim = mod[0]\n    constellation = mod[1]\n    if normalize:\n        p = 0\n        for i in range(len(channel)):\n            p = p + channel[i] ** 2\n        for i in range(len(channel)):\n            channel[i] = channel[i] / math.sqrt(p)\n    lookup = list(range(len(constellation) ** len(channel)))\n    for o in range(len(constellation) ** len(channel)):\n        ss = dec2base(o, len(constellation), len(channel))\n        ll = 0\n        for i in range(len(channel)):\n            ll = ll + constellation[ss[i]] * channel[i]\n        lookup[o] = ll\n    return (1, lookup)",
        "mutated": [
            "def make_isi_lookup(mod, channel, normalize):\n    if False:\n        i = 10\n    \"\\n    Automatically generate the lookup table that maps the FSM outputs\\n    to channel inputs corresponding to a channel 'channel' and a modulation\\n    'mod'. Optional normalization of channel to unit energy.\\n    This table is used by the 'metrics' block to translate\\n    channel outputs to metrics for use with the Viterbi algorithm.\\n    Limitations: currently supports only one-dimensional modulations.\\n    \"\n    dim = mod[0]\n    constellation = mod[1]\n    if normalize:\n        p = 0\n        for i in range(len(channel)):\n            p = p + channel[i] ** 2\n        for i in range(len(channel)):\n            channel[i] = channel[i] / math.sqrt(p)\n    lookup = list(range(len(constellation) ** len(channel)))\n    for o in range(len(constellation) ** len(channel)):\n        ss = dec2base(o, len(constellation), len(channel))\n        ll = 0\n        for i in range(len(channel)):\n            ll = ll + constellation[ss[i]] * channel[i]\n        lookup[o] = ll\n    return (1, lookup)",
            "def make_isi_lookup(mod, channel, normalize):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Automatically generate the lookup table that maps the FSM outputs\\n    to channel inputs corresponding to a channel 'channel' and a modulation\\n    'mod'. Optional normalization of channel to unit energy.\\n    This table is used by the 'metrics' block to translate\\n    channel outputs to metrics for use with the Viterbi algorithm.\\n    Limitations: currently supports only one-dimensional modulations.\\n    \"\n    dim = mod[0]\n    constellation = mod[1]\n    if normalize:\n        p = 0\n        for i in range(len(channel)):\n            p = p + channel[i] ** 2\n        for i in range(len(channel)):\n            channel[i] = channel[i] / math.sqrt(p)\n    lookup = list(range(len(constellation) ** len(channel)))\n    for o in range(len(constellation) ** len(channel)):\n        ss = dec2base(o, len(constellation), len(channel))\n        ll = 0\n        for i in range(len(channel)):\n            ll = ll + constellation[ss[i]] * channel[i]\n        lookup[o] = ll\n    return (1, lookup)",
            "def make_isi_lookup(mod, channel, normalize):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Automatically generate the lookup table that maps the FSM outputs\\n    to channel inputs corresponding to a channel 'channel' and a modulation\\n    'mod'. Optional normalization of channel to unit energy.\\n    This table is used by the 'metrics' block to translate\\n    channel outputs to metrics for use with the Viterbi algorithm.\\n    Limitations: currently supports only one-dimensional modulations.\\n    \"\n    dim = mod[0]\n    constellation = mod[1]\n    if normalize:\n        p = 0\n        for i in range(len(channel)):\n            p = p + channel[i] ** 2\n        for i in range(len(channel)):\n            channel[i] = channel[i] / math.sqrt(p)\n    lookup = list(range(len(constellation) ** len(channel)))\n    for o in range(len(constellation) ** len(channel)):\n        ss = dec2base(o, len(constellation), len(channel))\n        ll = 0\n        for i in range(len(channel)):\n            ll = ll + constellation[ss[i]] * channel[i]\n        lookup[o] = ll\n    return (1, lookup)",
            "def make_isi_lookup(mod, channel, normalize):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Automatically generate the lookup table that maps the FSM outputs\\n    to channel inputs corresponding to a channel 'channel' and a modulation\\n    'mod'. Optional normalization of channel to unit energy.\\n    This table is used by the 'metrics' block to translate\\n    channel outputs to metrics for use with the Viterbi algorithm.\\n    Limitations: currently supports only one-dimensional modulations.\\n    \"\n    dim = mod[0]\n    constellation = mod[1]\n    if normalize:\n        p = 0\n        for i in range(len(channel)):\n            p = p + channel[i] ** 2\n        for i in range(len(channel)):\n            channel[i] = channel[i] / math.sqrt(p)\n    lookup = list(range(len(constellation) ** len(channel)))\n    for o in range(len(constellation) ** len(channel)):\n        ss = dec2base(o, len(constellation), len(channel))\n        ll = 0\n        for i in range(len(channel)):\n            ll = ll + constellation[ss[i]] * channel[i]\n        lookup[o] = ll\n    return (1, lookup)",
            "def make_isi_lookup(mod, channel, normalize):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Automatically generate the lookup table that maps the FSM outputs\\n    to channel inputs corresponding to a channel 'channel' and a modulation\\n    'mod'. Optional normalization of channel to unit energy.\\n    This table is used by the 'metrics' block to translate\\n    channel outputs to metrics for use with the Viterbi algorithm.\\n    Limitations: currently supports only one-dimensional modulations.\\n    \"\n    dim = mod[0]\n    constellation = mod[1]\n    if normalize:\n        p = 0\n        for i in range(len(channel)):\n            p = p + channel[i] ** 2\n        for i in range(len(channel)):\n            channel[i] = channel[i] / math.sqrt(p)\n    lookup = list(range(len(constellation) ** len(channel)))\n    for o in range(len(constellation) ** len(channel)):\n        ss = dec2base(o, len(constellation), len(channel))\n        ll = 0\n        for i in range(len(channel)):\n            ll = ll + constellation[ss[i]] * channel[i]\n        lookup[o] = ll\n    return (1, lookup)"
        ]
    },
    {
        "func_name": "make_cpm_signals",
        "original": "def make_cpm_signals(K, P, M, L, q, frac):\n    \"\"\"\n    Automatically generate the signals appropriate for CPM\n    decomposition.\n    This decomposition is based on the paper by B. Rimoldi\n    \"A decomposition approach to CPM\", IEEE Trans. Info Theory, March 1988\n    See also my own notes at http://www.eecs.umich.edu/~anastas/docs/cpm.pdf\n    \"\"\"\n    Q = numpy.size(q) / L\n    h = 1.0 * K / P\n    f0 = -h * (M - 1) / 2\n    dt = 0.0\n    t = (dt + numpy.arange(0, Q)) / Q\n    qq = numpy.zeros(Q)\n    for m in range(L):\n        qq = qq + q[m * Q:m * Q + Q]\n        w = math.pi * h * (M - 1) * t - 2 * math.pi * h * (M - 1) * qq + math.pi * h * (L - 1) * (M - 1)\n    X = M ** L * P\n    PSI = numpy.empty((X, Q))\n    for x in range(X):\n        xv = dec2base(x / P, M, L)\n        xv = numpy.append(xv, x % P)\n        qq1 = numpy.zeros(Q)\n        for m in range(L):\n            qq1 = qq1 + xv[m] * q[m * Q:m * Q + Q]\n        psi = 2 * math.pi * h * xv[-1] + 4 * math.pi * h * qq1 + w\n        PSI[x] = psi\n    PSI = numpy.transpose(PSI)\n    SS = numpy.exp(1j * PSI)\n    F = scipy.linalg.orth(SS)\n    S = numpy.dot(numpy.transpose(F.conjugate()), SS)\n    E = numpy.sum(numpy.absolute(S) ** 2, axis=1) / Q\n    E = E / numpy.sum(E)\n    Es = -numpy.sort(-E)\n    Esi = numpy.argsort(-E)\n    Ecum = numpy.cumsum(Es)\n    v0 = numpy.searchsorted(Ecum, frac)\n    N = v0 + 1\n    Ff = numpy.transpose(numpy.transpose(F)[Esi[0:v0 + 1]])\n    Sf = S[Esi[0:v0 + 1]]\n    return (f0, SS, S, F, Sf, Ff, N)",
        "mutated": [
            "def make_cpm_signals(K, P, M, L, q, frac):\n    if False:\n        i = 10\n    '\\n    Automatically generate the signals appropriate for CPM\\n    decomposition.\\n    This decomposition is based on the paper by B. Rimoldi\\n    \"A decomposition approach to CPM\", IEEE Trans. Info Theory, March 1988\\n    See also my own notes at http://www.eecs.umich.edu/~anastas/docs/cpm.pdf\\n    '\n    Q = numpy.size(q) / L\n    h = 1.0 * K / P\n    f0 = -h * (M - 1) / 2\n    dt = 0.0\n    t = (dt + numpy.arange(0, Q)) / Q\n    qq = numpy.zeros(Q)\n    for m in range(L):\n        qq = qq + q[m * Q:m * Q + Q]\n        w = math.pi * h * (M - 1) * t - 2 * math.pi * h * (M - 1) * qq + math.pi * h * (L - 1) * (M - 1)\n    X = M ** L * P\n    PSI = numpy.empty((X, Q))\n    for x in range(X):\n        xv = dec2base(x / P, M, L)\n        xv = numpy.append(xv, x % P)\n        qq1 = numpy.zeros(Q)\n        for m in range(L):\n            qq1 = qq1 + xv[m] * q[m * Q:m * Q + Q]\n        psi = 2 * math.pi * h * xv[-1] + 4 * math.pi * h * qq1 + w\n        PSI[x] = psi\n    PSI = numpy.transpose(PSI)\n    SS = numpy.exp(1j * PSI)\n    F = scipy.linalg.orth(SS)\n    S = numpy.dot(numpy.transpose(F.conjugate()), SS)\n    E = numpy.sum(numpy.absolute(S) ** 2, axis=1) / Q\n    E = E / numpy.sum(E)\n    Es = -numpy.sort(-E)\n    Esi = numpy.argsort(-E)\n    Ecum = numpy.cumsum(Es)\n    v0 = numpy.searchsorted(Ecum, frac)\n    N = v0 + 1\n    Ff = numpy.transpose(numpy.transpose(F)[Esi[0:v0 + 1]])\n    Sf = S[Esi[0:v0 + 1]]\n    return (f0, SS, S, F, Sf, Ff, N)",
            "def make_cpm_signals(K, P, M, L, q, frac):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Automatically generate the signals appropriate for CPM\\n    decomposition.\\n    This decomposition is based on the paper by B. Rimoldi\\n    \"A decomposition approach to CPM\", IEEE Trans. Info Theory, March 1988\\n    See also my own notes at http://www.eecs.umich.edu/~anastas/docs/cpm.pdf\\n    '\n    Q = numpy.size(q) / L\n    h = 1.0 * K / P\n    f0 = -h * (M - 1) / 2\n    dt = 0.0\n    t = (dt + numpy.arange(0, Q)) / Q\n    qq = numpy.zeros(Q)\n    for m in range(L):\n        qq = qq + q[m * Q:m * Q + Q]\n        w = math.pi * h * (M - 1) * t - 2 * math.pi * h * (M - 1) * qq + math.pi * h * (L - 1) * (M - 1)\n    X = M ** L * P\n    PSI = numpy.empty((X, Q))\n    for x in range(X):\n        xv = dec2base(x / P, M, L)\n        xv = numpy.append(xv, x % P)\n        qq1 = numpy.zeros(Q)\n        for m in range(L):\n            qq1 = qq1 + xv[m] * q[m * Q:m * Q + Q]\n        psi = 2 * math.pi * h * xv[-1] + 4 * math.pi * h * qq1 + w\n        PSI[x] = psi\n    PSI = numpy.transpose(PSI)\n    SS = numpy.exp(1j * PSI)\n    F = scipy.linalg.orth(SS)\n    S = numpy.dot(numpy.transpose(F.conjugate()), SS)\n    E = numpy.sum(numpy.absolute(S) ** 2, axis=1) / Q\n    E = E / numpy.sum(E)\n    Es = -numpy.sort(-E)\n    Esi = numpy.argsort(-E)\n    Ecum = numpy.cumsum(Es)\n    v0 = numpy.searchsorted(Ecum, frac)\n    N = v0 + 1\n    Ff = numpy.transpose(numpy.transpose(F)[Esi[0:v0 + 1]])\n    Sf = S[Esi[0:v0 + 1]]\n    return (f0, SS, S, F, Sf, Ff, N)",
            "def make_cpm_signals(K, P, M, L, q, frac):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Automatically generate the signals appropriate for CPM\\n    decomposition.\\n    This decomposition is based on the paper by B. Rimoldi\\n    \"A decomposition approach to CPM\", IEEE Trans. Info Theory, March 1988\\n    See also my own notes at http://www.eecs.umich.edu/~anastas/docs/cpm.pdf\\n    '\n    Q = numpy.size(q) / L\n    h = 1.0 * K / P\n    f0 = -h * (M - 1) / 2\n    dt = 0.0\n    t = (dt + numpy.arange(0, Q)) / Q\n    qq = numpy.zeros(Q)\n    for m in range(L):\n        qq = qq + q[m * Q:m * Q + Q]\n        w = math.pi * h * (M - 1) * t - 2 * math.pi * h * (M - 1) * qq + math.pi * h * (L - 1) * (M - 1)\n    X = M ** L * P\n    PSI = numpy.empty((X, Q))\n    for x in range(X):\n        xv = dec2base(x / P, M, L)\n        xv = numpy.append(xv, x % P)\n        qq1 = numpy.zeros(Q)\n        for m in range(L):\n            qq1 = qq1 + xv[m] * q[m * Q:m * Q + Q]\n        psi = 2 * math.pi * h * xv[-1] + 4 * math.pi * h * qq1 + w\n        PSI[x] = psi\n    PSI = numpy.transpose(PSI)\n    SS = numpy.exp(1j * PSI)\n    F = scipy.linalg.orth(SS)\n    S = numpy.dot(numpy.transpose(F.conjugate()), SS)\n    E = numpy.sum(numpy.absolute(S) ** 2, axis=1) / Q\n    E = E / numpy.sum(E)\n    Es = -numpy.sort(-E)\n    Esi = numpy.argsort(-E)\n    Ecum = numpy.cumsum(Es)\n    v0 = numpy.searchsorted(Ecum, frac)\n    N = v0 + 1\n    Ff = numpy.transpose(numpy.transpose(F)[Esi[0:v0 + 1]])\n    Sf = S[Esi[0:v0 + 1]]\n    return (f0, SS, S, F, Sf, Ff, N)",
            "def make_cpm_signals(K, P, M, L, q, frac):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Automatically generate the signals appropriate for CPM\\n    decomposition.\\n    This decomposition is based on the paper by B. Rimoldi\\n    \"A decomposition approach to CPM\", IEEE Trans. Info Theory, March 1988\\n    See also my own notes at http://www.eecs.umich.edu/~anastas/docs/cpm.pdf\\n    '\n    Q = numpy.size(q) / L\n    h = 1.0 * K / P\n    f0 = -h * (M - 1) / 2\n    dt = 0.0\n    t = (dt + numpy.arange(0, Q)) / Q\n    qq = numpy.zeros(Q)\n    for m in range(L):\n        qq = qq + q[m * Q:m * Q + Q]\n        w = math.pi * h * (M - 1) * t - 2 * math.pi * h * (M - 1) * qq + math.pi * h * (L - 1) * (M - 1)\n    X = M ** L * P\n    PSI = numpy.empty((X, Q))\n    for x in range(X):\n        xv = dec2base(x / P, M, L)\n        xv = numpy.append(xv, x % P)\n        qq1 = numpy.zeros(Q)\n        for m in range(L):\n            qq1 = qq1 + xv[m] * q[m * Q:m * Q + Q]\n        psi = 2 * math.pi * h * xv[-1] + 4 * math.pi * h * qq1 + w\n        PSI[x] = psi\n    PSI = numpy.transpose(PSI)\n    SS = numpy.exp(1j * PSI)\n    F = scipy.linalg.orth(SS)\n    S = numpy.dot(numpy.transpose(F.conjugate()), SS)\n    E = numpy.sum(numpy.absolute(S) ** 2, axis=1) / Q\n    E = E / numpy.sum(E)\n    Es = -numpy.sort(-E)\n    Esi = numpy.argsort(-E)\n    Ecum = numpy.cumsum(Es)\n    v0 = numpy.searchsorted(Ecum, frac)\n    N = v0 + 1\n    Ff = numpy.transpose(numpy.transpose(F)[Esi[0:v0 + 1]])\n    Sf = S[Esi[0:v0 + 1]]\n    return (f0, SS, S, F, Sf, Ff, N)",
            "def make_cpm_signals(K, P, M, L, q, frac):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Automatically generate the signals appropriate for CPM\\n    decomposition.\\n    This decomposition is based on the paper by B. Rimoldi\\n    \"A decomposition approach to CPM\", IEEE Trans. Info Theory, March 1988\\n    See also my own notes at http://www.eecs.umich.edu/~anastas/docs/cpm.pdf\\n    '\n    Q = numpy.size(q) / L\n    h = 1.0 * K / P\n    f0 = -h * (M - 1) / 2\n    dt = 0.0\n    t = (dt + numpy.arange(0, Q)) / Q\n    qq = numpy.zeros(Q)\n    for m in range(L):\n        qq = qq + q[m * Q:m * Q + Q]\n        w = math.pi * h * (M - 1) * t - 2 * math.pi * h * (M - 1) * qq + math.pi * h * (L - 1) * (M - 1)\n    X = M ** L * P\n    PSI = numpy.empty((X, Q))\n    for x in range(X):\n        xv = dec2base(x / P, M, L)\n        xv = numpy.append(xv, x % P)\n        qq1 = numpy.zeros(Q)\n        for m in range(L):\n            qq1 = qq1 + xv[m] * q[m * Q:m * Q + Q]\n        psi = 2 * math.pi * h * xv[-1] + 4 * math.pi * h * qq1 + w\n        PSI[x] = psi\n    PSI = numpy.transpose(PSI)\n    SS = numpy.exp(1j * PSI)\n    F = scipy.linalg.orth(SS)\n    S = numpy.dot(numpy.transpose(F.conjugate()), SS)\n    E = numpy.sum(numpy.absolute(S) ** 2, axis=1) / Q\n    E = E / numpy.sum(E)\n    Es = -numpy.sort(-E)\n    Esi = numpy.argsort(-E)\n    Ecum = numpy.cumsum(Es)\n    v0 = numpy.searchsorted(Ecum, frac)\n    N = v0 + 1\n    Ff = numpy.transpose(numpy.transpose(F)[Esi[0:v0 + 1]])\n    Sf = S[Esi[0:v0 + 1]]\n    return (f0, SS, S, F, Sf, Ff, N)"
        ]
    }
]