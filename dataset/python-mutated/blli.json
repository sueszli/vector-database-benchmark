[
    {
        "func_name": "_ensure_bllip_import_or_error",
        "original": "def _ensure_bllip_import_or_error():\n    pass",
        "mutated": [
            "def _ensure_bllip_import_or_error():\n    if False:\n        i = 10\n    pass",
            "def _ensure_bllip_import_or_error():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    pass",
            "def _ensure_bllip_import_or_error():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    pass",
            "def _ensure_bllip_import_or_error():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    pass",
            "def _ensure_bllip_import_or_error():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    pass"
        ]
    },
    {
        "func_name": "_ensure_bllip_import_or_error",
        "original": "def _ensure_bllip_import_or_error(ie=ie):\n    raise ImportError(\"Couldn't import bllipparser module: %s\" % ie)",
        "mutated": [
            "def _ensure_bllip_import_or_error(ie=ie):\n    if False:\n        i = 10\n    raise ImportError(\"Couldn't import bllipparser module: %s\" % ie)",
            "def _ensure_bllip_import_or_error(ie=ie):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    raise ImportError(\"Couldn't import bllipparser module: %s\" % ie)",
            "def _ensure_bllip_import_or_error(ie=ie):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    raise ImportError(\"Couldn't import bllipparser module: %s\" % ie)",
            "def _ensure_bllip_import_or_error(ie=ie):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    raise ImportError(\"Couldn't import bllipparser module: %s\" % ie)",
            "def _ensure_bllip_import_or_error(ie=ie):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    raise ImportError(\"Couldn't import bllipparser module: %s\" % ie)"
        ]
    },
    {
        "func_name": "_ensure_ascii",
        "original": "def _ensure_ascii(words):\n    try:\n        for (i, word) in enumerate(words):\n            word.encode('ascii')\n    except UnicodeEncodeError as e:\n        raise ValueError(f\"Token {i} ({word!r}) is non-ASCII. BLLIP Parser currently doesn't support non-ASCII inputs.\") from e",
        "mutated": [
            "def _ensure_ascii(words):\n    if False:\n        i = 10\n    try:\n        for (i, word) in enumerate(words):\n            word.encode('ascii')\n    except UnicodeEncodeError as e:\n        raise ValueError(f\"Token {i} ({word!r}) is non-ASCII. BLLIP Parser currently doesn't support non-ASCII inputs.\") from e",
            "def _ensure_ascii(words):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    try:\n        for (i, word) in enumerate(words):\n            word.encode('ascii')\n    except UnicodeEncodeError as e:\n        raise ValueError(f\"Token {i} ({word!r}) is non-ASCII. BLLIP Parser currently doesn't support non-ASCII inputs.\") from e",
            "def _ensure_ascii(words):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    try:\n        for (i, word) in enumerate(words):\n            word.encode('ascii')\n    except UnicodeEncodeError as e:\n        raise ValueError(f\"Token {i} ({word!r}) is non-ASCII. BLLIP Parser currently doesn't support non-ASCII inputs.\") from e",
            "def _ensure_ascii(words):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    try:\n        for (i, word) in enumerate(words):\n            word.encode('ascii')\n    except UnicodeEncodeError as e:\n        raise ValueError(f\"Token {i} ({word!r}) is non-ASCII. BLLIP Parser currently doesn't support non-ASCII inputs.\") from e",
            "def _ensure_ascii(words):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    try:\n        for (i, word) in enumerate(words):\n            word.encode('ascii')\n    except UnicodeEncodeError as e:\n        raise ValueError(f\"Token {i} ({word!r}) is non-ASCII. BLLIP Parser currently doesn't support non-ASCII inputs.\") from e"
        ]
    },
    {
        "func_name": "_scored_parse_to_nltk_tree",
        "original": "def _scored_parse_to_nltk_tree(scored_parse):\n    return Tree.fromstring(str(scored_parse.ptb_parse))",
        "mutated": [
            "def _scored_parse_to_nltk_tree(scored_parse):\n    if False:\n        i = 10\n    return Tree.fromstring(str(scored_parse.ptb_parse))",
            "def _scored_parse_to_nltk_tree(scored_parse):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return Tree.fromstring(str(scored_parse.ptb_parse))",
            "def _scored_parse_to_nltk_tree(scored_parse):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return Tree.fromstring(str(scored_parse.ptb_parse))",
            "def _scored_parse_to_nltk_tree(scored_parse):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return Tree.fromstring(str(scored_parse.ptb_parse))",
            "def _scored_parse_to_nltk_tree(scored_parse):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return Tree.fromstring(str(scored_parse.ptb_parse))"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, parser_model=None, reranker_features=None, reranker_weights=None, parser_options=None, reranker_options=None):\n    \"\"\"\n        Load a BLLIP Parser model from scratch. You'll typically want to\n        use the ``from_unified_model_dir()`` class method to construct\n        this object.\n\n        :param parser_model: Path to parser model directory\n        :type parser_model: str\n\n        :param reranker_features: Path the reranker model's features file\n        :type reranker_features: str\n\n        :param reranker_weights: Path the reranker model's weights file\n        :type reranker_weights: str\n\n        :param parser_options: optional dictionary of parser options, see\n            ``bllipparser.RerankingParser.RerankingParser.load_parser_options()``\n            for more information.\n        :type parser_options: dict(str)\n\n        :param reranker_options: optional\n            dictionary of reranker options, see\n            ``bllipparser.RerankingParser.RerankingParser.load_reranker_model()``\n            for more information.\n        :type reranker_options: dict(str)\n        \"\"\"\n    _ensure_bllip_import_or_error()\n    parser_options = parser_options or {}\n    reranker_options = reranker_options or {}\n    self.rrp = RerankingParser()\n    self.rrp.load_parser_model(parser_model, **parser_options)\n    if reranker_features and reranker_weights:\n        self.rrp.load_reranker_model(features_filename=reranker_features, weights_filename=reranker_weights, **reranker_options)",
        "mutated": [
            "def __init__(self, parser_model=None, reranker_features=None, reranker_weights=None, parser_options=None, reranker_options=None):\n    if False:\n        i = 10\n    \"\\n        Load a BLLIP Parser model from scratch. You'll typically want to\\n        use the ``from_unified_model_dir()`` class method to construct\\n        this object.\\n\\n        :param parser_model: Path to parser model directory\\n        :type parser_model: str\\n\\n        :param reranker_features: Path the reranker model's features file\\n        :type reranker_features: str\\n\\n        :param reranker_weights: Path the reranker model's weights file\\n        :type reranker_weights: str\\n\\n        :param parser_options: optional dictionary of parser options, see\\n            ``bllipparser.RerankingParser.RerankingParser.load_parser_options()``\\n            for more information.\\n        :type parser_options: dict(str)\\n\\n        :param reranker_options: optional\\n            dictionary of reranker options, see\\n            ``bllipparser.RerankingParser.RerankingParser.load_reranker_model()``\\n            for more information.\\n        :type reranker_options: dict(str)\\n        \"\n    _ensure_bllip_import_or_error()\n    parser_options = parser_options or {}\n    reranker_options = reranker_options or {}\n    self.rrp = RerankingParser()\n    self.rrp.load_parser_model(parser_model, **parser_options)\n    if reranker_features and reranker_weights:\n        self.rrp.load_reranker_model(features_filename=reranker_features, weights_filename=reranker_weights, **reranker_options)",
            "def __init__(self, parser_model=None, reranker_features=None, reranker_weights=None, parser_options=None, reranker_options=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n        Load a BLLIP Parser model from scratch. You'll typically want to\\n        use the ``from_unified_model_dir()`` class method to construct\\n        this object.\\n\\n        :param parser_model: Path to parser model directory\\n        :type parser_model: str\\n\\n        :param reranker_features: Path the reranker model's features file\\n        :type reranker_features: str\\n\\n        :param reranker_weights: Path the reranker model's weights file\\n        :type reranker_weights: str\\n\\n        :param parser_options: optional dictionary of parser options, see\\n            ``bllipparser.RerankingParser.RerankingParser.load_parser_options()``\\n            for more information.\\n        :type parser_options: dict(str)\\n\\n        :param reranker_options: optional\\n            dictionary of reranker options, see\\n            ``bllipparser.RerankingParser.RerankingParser.load_reranker_model()``\\n            for more information.\\n        :type reranker_options: dict(str)\\n        \"\n    _ensure_bllip_import_or_error()\n    parser_options = parser_options or {}\n    reranker_options = reranker_options or {}\n    self.rrp = RerankingParser()\n    self.rrp.load_parser_model(parser_model, **parser_options)\n    if reranker_features and reranker_weights:\n        self.rrp.load_reranker_model(features_filename=reranker_features, weights_filename=reranker_weights, **reranker_options)",
            "def __init__(self, parser_model=None, reranker_features=None, reranker_weights=None, parser_options=None, reranker_options=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n        Load a BLLIP Parser model from scratch. You'll typically want to\\n        use the ``from_unified_model_dir()`` class method to construct\\n        this object.\\n\\n        :param parser_model: Path to parser model directory\\n        :type parser_model: str\\n\\n        :param reranker_features: Path the reranker model's features file\\n        :type reranker_features: str\\n\\n        :param reranker_weights: Path the reranker model's weights file\\n        :type reranker_weights: str\\n\\n        :param parser_options: optional dictionary of parser options, see\\n            ``bllipparser.RerankingParser.RerankingParser.load_parser_options()``\\n            for more information.\\n        :type parser_options: dict(str)\\n\\n        :param reranker_options: optional\\n            dictionary of reranker options, see\\n            ``bllipparser.RerankingParser.RerankingParser.load_reranker_model()``\\n            for more information.\\n        :type reranker_options: dict(str)\\n        \"\n    _ensure_bllip_import_or_error()\n    parser_options = parser_options or {}\n    reranker_options = reranker_options or {}\n    self.rrp = RerankingParser()\n    self.rrp.load_parser_model(parser_model, **parser_options)\n    if reranker_features and reranker_weights:\n        self.rrp.load_reranker_model(features_filename=reranker_features, weights_filename=reranker_weights, **reranker_options)",
            "def __init__(self, parser_model=None, reranker_features=None, reranker_weights=None, parser_options=None, reranker_options=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n        Load a BLLIP Parser model from scratch. You'll typically want to\\n        use the ``from_unified_model_dir()`` class method to construct\\n        this object.\\n\\n        :param parser_model: Path to parser model directory\\n        :type parser_model: str\\n\\n        :param reranker_features: Path the reranker model's features file\\n        :type reranker_features: str\\n\\n        :param reranker_weights: Path the reranker model's weights file\\n        :type reranker_weights: str\\n\\n        :param parser_options: optional dictionary of parser options, see\\n            ``bllipparser.RerankingParser.RerankingParser.load_parser_options()``\\n            for more information.\\n        :type parser_options: dict(str)\\n\\n        :param reranker_options: optional\\n            dictionary of reranker options, see\\n            ``bllipparser.RerankingParser.RerankingParser.load_reranker_model()``\\n            for more information.\\n        :type reranker_options: dict(str)\\n        \"\n    _ensure_bllip_import_or_error()\n    parser_options = parser_options or {}\n    reranker_options = reranker_options or {}\n    self.rrp = RerankingParser()\n    self.rrp.load_parser_model(parser_model, **parser_options)\n    if reranker_features and reranker_weights:\n        self.rrp.load_reranker_model(features_filename=reranker_features, weights_filename=reranker_weights, **reranker_options)",
            "def __init__(self, parser_model=None, reranker_features=None, reranker_weights=None, parser_options=None, reranker_options=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n        Load a BLLIP Parser model from scratch. You'll typically want to\\n        use the ``from_unified_model_dir()`` class method to construct\\n        this object.\\n\\n        :param parser_model: Path to parser model directory\\n        :type parser_model: str\\n\\n        :param reranker_features: Path the reranker model's features file\\n        :type reranker_features: str\\n\\n        :param reranker_weights: Path the reranker model's weights file\\n        :type reranker_weights: str\\n\\n        :param parser_options: optional dictionary of parser options, see\\n            ``bllipparser.RerankingParser.RerankingParser.load_parser_options()``\\n            for more information.\\n        :type parser_options: dict(str)\\n\\n        :param reranker_options: optional\\n            dictionary of reranker options, see\\n            ``bllipparser.RerankingParser.RerankingParser.load_reranker_model()``\\n            for more information.\\n        :type reranker_options: dict(str)\\n        \"\n    _ensure_bllip_import_or_error()\n    parser_options = parser_options or {}\n    reranker_options = reranker_options or {}\n    self.rrp = RerankingParser()\n    self.rrp.load_parser_model(parser_model, **parser_options)\n    if reranker_features and reranker_weights:\n        self.rrp.load_reranker_model(features_filename=reranker_features, weights_filename=reranker_weights, **reranker_options)"
        ]
    },
    {
        "func_name": "parse",
        "original": "def parse(self, sentence):\n    \"\"\"\n        Use BLLIP Parser to parse a sentence. Takes a sentence as a list\n        of words; it will be automatically tagged with this BLLIP Parser\n        instance's tagger.\n\n        :return: An iterator that generates parse trees for the sentence\n            from most likely to least likely.\n\n        :param sentence: The sentence to be parsed\n        :type sentence: list(str)\n        :rtype: iter(Tree)\n        \"\"\"\n    _ensure_ascii(sentence)\n    nbest_list = self.rrp.parse(sentence)\n    for scored_parse in nbest_list:\n        yield _scored_parse_to_nltk_tree(scored_parse)",
        "mutated": [
            "def parse(self, sentence):\n    if False:\n        i = 10\n    \"\\n        Use BLLIP Parser to parse a sentence. Takes a sentence as a list\\n        of words; it will be automatically tagged with this BLLIP Parser\\n        instance's tagger.\\n\\n        :return: An iterator that generates parse trees for the sentence\\n            from most likely to least likely.\\n\\n        :param sentence: The sentence to be parsed\\n        :type sentence: list(str)\\n        :rtype: iter(Tree)\\n        \"\n    _ensure_ascii(sentence)\n    nbest_list = self.rrp.parse(sentence)\n    for scored_parse in nbest_list:\n        yield _scored_parse_to_nltk_tree(scored_parse)",
            "def parse(self, sentence):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n        Use BLLIP Parser to parse a sentence. Takes a sentence as a list\\n        of words; it will be automatically tagged with this BLLIP Parser\\n        instance's tagger.\\n\\n        :return: An iterator that generates parse trees for the sentence\\n            from most likely to least likely.\\n\\n        :param sentence: The sentence to be parsed\\n        :type sentence: list(str)\\n        :rtype: iter(Tree)\\n        \"\n    _ensure_ascii(sentence)\n    nbest_list = self.rrp.parse(sentence)\n    for scored_parse in nbest_list:\n        yield _scored_parse_to_nltk_tree(scored_parse)",
            "def parse(self, sentence):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n        Use BLLIP Parser to parse a sentence. Takes a sentence as a list\\n        of words; it will be automatically tagged with this BLLIP Parser\\n        instance's tagger.\\n\\n        :return: An iterator that generates parse trees for the sentence\\n            from most likely to least likely.\\n\\n        :param sentence: The sentence to be parsed\\n        :type sentence: list(str)\\n        :rtype: iter(Tree)\\n        \"\n    _ensure_ascii(sentence)\n    nbest_list = self.rrp.parse(sentence)\n    for scored_parse in nbest_list:\n        yield _scored_parse_to_nltk_tree(scored_parse)",
            "def parse(self, sentence):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n        Use BLLIP Parser to parse a sentence. Takes a sentence as a list\\n        of words; it will be automatically tagged with this BLLIP Parser\\n        instance's tagger.\\n\\n        :return: An iterator that generates parse trees for the sentence\\n            from most likely to least likely.\\n\\n        :param sentence: The sentence to be parsed\\n        :type sentence: list(str)\\n        :rtype: iter(Tree)\\n        \"\n    _ensure_ascii(sentence)\n    nbest_list = self.rrp.parse(sentence)\n    for scored_parse in nbest_list:\n        yield _scored_parse_to_nltk_tree(scored_parse)",
            "def parse(self, sentence):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n        Use BLLIP Parser to parse a sentence. Takes a sentence as a list\\n        of words; it will be automatically tagged with this BLLIP Parser\\n        instance's tagger.\\n\\n        :return: An iterator that generates parse trees for the sentence\\n            from most likely to least likely.\\n\\n        :param sentence: The sentence to be parsed\\n        :type sentence: list(str)\\n        :rtype: iter(Tree)\\n        \"\n    _ensure_ascii(sentence)\n    nbest_list = self.rrp.parse(sentence)\n    for scored_parse in nbest_list:\n        yield _scored_parse_to_nltk_tree(scored_parse)"
        ]
    },
    {
        "func_name": "tagged_parse",
        "original": "def tagged_parse(self, word_and_tag_pairs):\n    \"\"\"\n        Use BLLIP to parse a sentence. Takes a sentence as a list of\n        (word, tag) tuples; the sentence must have already been tokenized\n        and tagged. BLLIP will attempt to use the tags provided but may\n        use others if it can't come up with a complete parse subject\n        to those constraints. You may also specify a tag as ``None``\n        to leave a token's tag unconstrained.\n\n        :return: An iterator that generates parse trees for the sentence\n            from most likely to least likely.\n\n        :param sentence: Input sentence to parse as (word, tag) pairs\n        :type sentence: list(tuple(str, str))\n        :rtype: iter(Tree)\n        \"\"\"\n    words = []\n    tag_map = {}\n    for (i, (word, tag)) in enumerate(word_and_tag_pairs):\n        words.append(word)\n        if tag is not None:\n            tag_map[i] = tag\n    _ensure_ascii(words)\n    nbest_list = self.rrp.parse_tagged(words, tag_map)\n    for scored_parse in nbest_list:\n        yield _scored_parse_to_nltk_tree(scored_parse)",
        "mutated": [
            "def tagged_parse(self, word_and_tag_pairs):\n    if False:\n        i = 10\n    \"\\n        Use BLLIP to parse a sentence. Takes a sentence as a list of\\n        (word, tag) tuples; the sentence must have already been tokenized\\n        and tagged. BLLIP will attempt to use the tags provided but may\\n        use others if it can't come up with a complete parse subject\\n        to those constraints. You may also specify a tag as ``None``\\n        to leave a token's tag unconstrained.\\n\\n        :return: An iterator that generates parse trees for the sentence\\n            from most likely to least likely.\\n\\n        :param sentence: Input sentence to parse as (word, tag) pairs\\n        :type sentence: list(tuple(str, str))\\n        :rtype: iter(Tree)\\n        \"\n    words = []\n    tag_map = {}\n    for (i, (word, tag)) in enumerate(word_and_tag_pairs):\n        words.append(word)\n        if tag is not None:\n            tag_map[i] = tag\n    _ensure_ascii(words)\n    nbest_list = self.rrp.parse_tagged(words, tag_map)\n    for scored_parse in nbest_list:\n        yield _scored_parse_to_nltk_tree(scored_parse)",
            "def tagged_parse(self, word_and_tag_pairs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n        Use BLLIP to parse a sentence. Takes a sentence as a list of\\n        (word, tag) tuples; the sentence must have already been tokenized\\n        and tagged. BLLIP will attempt to use the tags provided but may\\n        use others if it can't come up with a complete parse subject\\n        to those constraints. You may also specify a tag as ``None``\\n        to leave a token's tag unconstrained.\\n\\n        :return: An iterator that generates parse trees for the sentence\\n            from most likely to least likely.\\n\\n        :param sentence: Input sentence to parse as (word, tag) pairs\\n        :type sentence: list(tuple(str, str))\\n        :rtype: iter(Tree)\\n        \"\n    words = []\n    tag_map = {}\n    for (i, (word, tag)) in enumerate(word_and_tag_pairs):\n        words.append(word)\n        if tag is not None:\n            tag_map[i] = tag\n    _ensure_ascii(words)\n    nbest_list = self.rrp.parse_tagged(words, tag_map)\n    for scored_parse in nbest_list:\n        yield _scored_parse_to_nltk_tree(scored_parse)",
            "def tagged_parse(self, word_and_tag_pairs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n        Use BLLIP to parse a sentence. Takes a sentence as a list of\\n        (word, tag) tuples; the sentence must have already been tokenized\\n        and tagged. BLLIP will attempt to use the tags provided but may\\n        use others if it can't come up with a complete parse subject\\n        to those constraints. You may also specify a tag as ``None``\\n        to leave a token's tag unconstrained.\\n\\n        :return: An iterator that generates parse trees for the sentence\\n            from most likely to least likely.\\n\\n        :param sentence: Input sentence to parse as (word, tag) pairs\\n        :type sentence: list(tuple(str, str))\\n        :rtype: iter(Tree)\\n        \"\n    words = []\n    tag_map = {}\n    for (i, (word, tag)) in enumerate(word_and_tag_pairs):\n        words.append(word)\n        if tag is not None:\n            tag_map[i] = tag\n    _ensure_ascii(words)\n    nbest_list = self.rrp.parse_tagged(words, tag_map)\n    for scored_parse in nbest_list:\n        yield _scored_parse_to_nltk_tree(scored_parse)",
            "def tagged_parse(self, word_and_tag_pairs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n        Use BLLIP to parse a sentence. Takes a sentence as a list of\\n        (word, tag) tuples; the sentence must have already been tokenized\\n        and tagged. BLLIP will attempt to use the tags provided but may\\n        use others if it can't come up with a complete parse subject\\n        to those constraints. You may also specify a tag as ``None``\\n        to leave a token's tag unconstrained.\\n\\n        :return: An iterator that generates parse trees for the sentence\\n            from most likely to least likely.\\n\\n        :param sentence: Input sentence to parse as (word, tag) pairs\\n        :type sentence: list(tuple(str, str))\\n        :rtype: iter(Tree)\\n        \"\n    words = []\n    tag_map = {}\n    for (i, (word, tag)) in enumerate(word_and_tag_pairs):\n        words.append(word)\n        if tag is not None:\n            tag_map[i] = tag\n    _ensure_ascii(words)\n    nbest_list = self.rrp.parse_tagged(words, tag_map)\n    for scored_parse in nbest_list:\n        yield _scored_parse_to_nltk_tree(scored_parse)",
            "def tagged_parse(self, word_and_tag_pairs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n        Use BLLIP to parse a sentence. Takes a sentence as a list of\\n        (word, tag) tuples; the sentence must have already been tokenized\\n        and tagged. BLLIP will attempt to use the tags provided but may\\n        use others if it can't come up with a complete parse subject\\n        to those constraints. You may also specify a tag as ``None``\\n        to leave a token's tag unconstrained.\\n\\n        :return: An iterator that generates parse trees for the sentence\\n            from most likely to least likely.\\n\\n        :param sentence: Input sentence to parse as (word, tag) pairs\\n        :type sentence: list(tuple(str, str))\\n        :rtype: iter(Tree)\\n        \"\n    words = []\n    tag_map = {}\n    for (i, (word, tag)) in enumerate(word_and_tag_pairs):\n        words.append(word)\n        if tag is not None:\n            tag_map[i] = tag\n    _ensure_ascii(words)\n    nbest_list = self.rrp.parse_tagged(words, tag_map)\n    for scored_parse in nbest_list:\n        yield _scored_parse_to_nltk_tree(scored_parse)"
        ]
    },
    {
        "func_name": "from_unified_model_dir",
        "original": "@classmethod\ndef from_unified_model_dir(cls, model_dir, parser_options=None, reranker_options=None):\n    \"\"\"\n        Create a ``BllipParser`` object from a unified parsing model\n        directory. Unified parsing model directories are a standardized\n        way of storing BLLIP parser and reranker models together on disk.\n        See ``bllipparser.RerankingParser.get_unified_model_parameters()``\n        for more information about unified model directories.\n\n        :return: A ``BllipParser`` object using the parser and reranker\n            models in the model directory.\n\n        :param model_dir: Path to the unified model directory.\n        :type model_dir: str\n        :param parser_options: optional dictionary of parser options, see\n            ``bllipparser.RerankingParser.RerankingParser.load_parser_options()``\n            for more information.\n        :type parser_options: dict(str)\n        :param reranker_options: optional dictionary of reranker options, see\n            ``bllipparser.RerankingParser.RerankingParser.load_reranker_model()``\n            for more information.\n        :type reranker_options: dict(str)\n        :rtype: BllipParser\n        \"\"\"\n    (parser_model_dir, reranker_features_filename, reranker_weights_filename) = get_unified_model_parameters(model_dir)\n    return cls(parser_model_dir, reranker_features_filename, reranker_weights_filename, parser_options, reranker_options)",
        "mutated": [
            "@classmethod\ndef from_unified_model_dir(cls, model_dir, parser_options=None, reranker_options=None):\n    if False:\n        i = 10\n    '\\n        Create a ``BllipParser`` object from a unified parsing model\\n        directory. Unified parsing model directories are a standardized\\n        way of storing BLLIP parser and reranker models together on disk.\\n        See ``bllipparser.RerankingParser.get_unified_model_parameters()``\\n        for more information about unified model directories.\\n\\n        :return: A ``BllipParser`` object using the parser and reranker\\n            models in the model directory.\\n\\n        :param model_dir: Path to the unified model directory.\\n        :type model_dir: str\\n        :param parser_options: optional dictionary of parser options, see\\n            ``bllipparser.RerankingParser.RerankingParser.load_parser_options()``\\n            for more information.\\n        :type parser_options: dict(str)\\n        :param reranker_options: optional dictionary of reranker options, see\\n            ``bllipparser.RerankingParser.RerankingParser.load_reranker_model()``\\n            for more information.\\n        :type reranker_options: dict(str)\\n        :rtype: BllipParser\\n        '\n    (parser_model_dir, reranker_features_filename, reranker_weights_filename) = get_unified_model_parameters(model_dir)\n    return cls(parser_model_dir, reranker_features_filename, reranker_weights_filename, parser_options, reranker_options)",
            "@classmethod\ndef from_unified_model_dir(cls, model_dir, parser_options=None, reranker_options=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Create a ``BllipParser`` object from a unified parsing model\\n        directory. Unified parsing model directories are a standardized\\n        way of storing BLLIP parser and reranker models together on disk.\\n        See ``bllipparser.RerankingParser.get_unified_model_parameters()``\\n        for more information about unified model directories.\\n\\n        :return: A ``BllipParser`` object using the parser and reranker\\n            models in the model directory.\\n\\n        :param model_dir: Path to the unified model directory.\\n        :type model_dir: str\\n        :param parser_options: optional dictionary of parser options, see\\n            ``bllipparser.RerankingParser.RerankingParser.load_parser_options()``\\n            for more information.\\n        :type parser_options: dict(str)\\n        :param reranker_options: optional dictionary of reranker options, see\\n            ``bllipparser.RerankingParser.RerankingParser.load_reranker_model()``\\n            for more information.\\n        :type reranker_options: dict(str)\\n        :rtype: BllipParser\\n        '\n    (parser_model_dir, reranker_features_filename, reranker_weights_filename) = get_unified_model_parameters(model_dir)\n    return cls(parser_model_dir, reranker_features_filename, reranker_weights_filename, parser_options, reranker_options)",
            "@classmethod\ndef from_unified_model_dir(cls, model_dir, parser_options=None, reranker_options=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Create a ``BllipParser`` object from a unified parsing model\\n        directory. Unified parsing model directories are a standardized\\n        way of storing BLLIP parser and reranker models together on disk.\\n        See ``bllipparser.RerankingParser.get_unified_model_parameters()``\\n        for more information about unified model directories.\\n\\n        :return: A ``BllipParser`` object using the parser and reranker\\n            models in the model directory.\\n\\n        :param model_dir: Path to the unified model directory.\\n        :type model_dir: str\\n        :param parser_options: optional dictionary of parser options, see\\n            ``bllipparser.RerankingParser.RerankingParser.load_parser_options()``\\n            for more information.\\n        :type parser_options: dict(str)\\n        :param reranker_options: optional dictionary of reranker options, see\\n            ``bllipparser.RerankingParser.RerankingParser.load_reranker_model()``\\n            for more information.\\n        :type reranker_options: dict(str)\\n        :rtype: BllipParser\\n        '\n    (parser_model_dir, reranker_features_filename, reranker_weights_filename) = get_unified_model_parameters(model_dir)\n    return cls(parser_model_dir, reranker_features_filename, reranker_weights_filename, parser_options, reranker_options)",
            "@classmethod\ndef from_unified_model_dir(cls, model_dir, parser_options=None, reranker_options=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Create a ``BllipParser`` object from a unified parsing model\\n        directory. Unified parsing model directories are a standardized\\n        way of storing BLLIP parser and reranker models together on disk.\\n        See ``bllipparser.RerankingParser.get_unified_model_parameters()``\\n        for more information about unified model directories.\\n\\n        :return: A ``BllipParser`` object using the parser and reranker\\n            models in the model directory.\\n\\n        :param model_dir: Path to the unified model directory.\\n        :type model_dir: str\\n        :param parser_options: optional dictionary of parser options, see\\n            ``bllipparser.RerankingParser.RerankingParser.load_parser_options()``\\n            for more information.\\n        :type parser_options: dict(str)\\n        :param reranker_options: optional dictionary of reranker options, see\\n            ``bllipparser.RerankingParser.RerankingParser.load_reranker_model()``\\n            for more information.\\n        :type reranker_options: dict(str)\\n        :rtype: BllipParser\\n        '\n    (parser_model_dir, reranker_features_filename, reranker_weights_filename) = get_unified_model_parameters(model_dir)\n    return cls(parser_model_dir, reranker_features_filename, reranker_weights_filename, parser_options, reranker_options)",
            "@classmethod\ndef from_unified_model_dir(cls, model_dir, parser_options=None, reranker_options=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Create a ``BllipParser`` object from a unified parsing model\\n        directory. Unified parsing model directories are a standardized\\n        way of storing BLLIP parser and reranker models together on disk.\\n        See ``bllipparser.RerankingParser.get_unified_model_parameters()``\\n        for more information about unified model directories.\\n\\n        :return: A ``BllipParser`` object using the parser and reranker\\n            models in the model directory.\\n\\n        :param model_dir: Path to the unified model directory.\\n        :type model_dir: str\\n        :param parser_options: optional dictionary of parser options, see\\n            ``bllipparser.RerankingParser.RerankingParser.load_parser_options()``\\n            for more information.\\n        :type parser_options: dict(str)\\n        :param reranker_options: optional dictionary of reranker options, see\\n            ``bllipparser.RerankingParser.RerankingParser.load_reranker_model()``\\n            for more information.\\n        :type reranker_options: dict(str)\\n        :rtype: BllipParser\\n        '\n    (parser_model_dir, reranker_features_filename, reranker_weights_filename) = get_unified_model_parameters(model_dir)\n    return cls(parser_model_dir, reranker_features_filename, reranker_weights_filename, parser_options, reranker_options)"
        ]
    },
    {
        "func_name": "demo",
        "original": "def demo():\n    \"\"\"This assumes the Python module bllipparser is installed.\"\"\"\n    from nltk.data import find\n    model_dir = find('models/bllip_wsj_no_aux').path\n    print('Loading BLLIP Parsing models...')\n    bllip = BllipParser.from_unified_model_dir(model_dir)\n    print('Done.')\n    sentence1 = 'British left waffles on Falklands .'.split()\n    sentence2 = 'I saw the man with the telescope .'.split()\n    fail1 = '# ! ? : -'.split()\n    for sentence in (sentence1, sentence2, fail1):\n        print('Sentence: %r' % ' '.join(sentence))\n        try:\n            tree = next(bllip.parse(sentence))\n            print(tree)\n        except StopIteration:\n            print('(parse failed)')\n    for (i, parse) in enumerate(bllip.parse(sentence1)):\n        print('parse %d:\\n%s' % (i, parse))\n    print(\"forcing 'tree' to be 'NN':\", next(bllip.tagged_parse([('A', None), ('tree', 'NN')])))\n    print(\"forcing 'A' to be 'DT' and 'tree' to be 'NNP':\", next(bllip.tagged_parse([('A', 'DT'), ('tree', 'NNP')])))\n    print(\"forcing 'A' to be 'NNP':\", next(bllip.tagged_parse([('A', 'NNP'), ('tree', None)])))",
        "mutated": [
            "def demo():\n    if False:\n        i = 10\n    'This assumes the Python module bllipparser is installed.'\n    from nltk.data import find\n    model_dir = find('models/bllip_wsj_no_aux').path\n    print('Loading BLLIP Parsing models...')\n    bllip = BllipParser.from_unified_model_dir(model_dir)\n    print('Done.')\n    sentence1 = 'British left waffles on Falklands .'.split()\n    sentence2 = 'I saw the man with the telescope .'.split()\n    fail1 = '# ! ? : -'.split()\n    for sentence in (sentence1, sentence2, fail1):\n        print('Sentence: %r' % ' '.join(sentence))\n        try:\n            tree = next(bllip.parse(sentence))\n            print(tree)\n        except StopIteration:\n            print('(parse failed)')\n    for (i, parse) in enumerate(bllip.parse(sentence1)):\n        print('parse %d:\\n%s' % (i, parse))\n    print(\"forcing 'tree' to be 'NN':\", next(bllip.tagged_parse([('A', None), ('tree', 'NN')])))\n    print(\"forcing 'A' to be 'DT' and 'tree' to be 'NNP':\", next(bllip.tagged_parse([('A', 'DT'), ('tree', 'NNP')])))\n    print(\"forcing 'A' to be 'NNP':\", next(bllip.tagged_parse([('A', 'NNP'), ('tree', None)])))",
            "def demo():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'This assumes the Python module bllipparser is installed.'\n    from nltk.data import find\n    model_dir = find('models/bllip_wsj_no_aux').path\n    print('Loading BLLIP Parsing models...')\n    bllip = BllipParser.from_unified_model_dir(model_dir)\n    print('Done.')\n    sentence1 = 'British left waffles on Falklands .'.split()\n    sentence2 = 'I saw the man with the telescope .'.split()\n    fail1 = '# ! ? : -'.split()\n    for sentence in (sentence1, sentence2, fail1):\n        print('Sentence: %r' % ' '.join(sentence))\n        try:\n            tree = next(bllip.parse(sentence))\n            print(tree)\n        except StopIteration:\n            print('(parse failed)')\n    for (i, parse) in enumerate(bllip.parse(sentence1)):\n        print('parse %d:\\n%s' % (i, parse))\n    print(\"forcing 'tree' to be 'NN':\", next(bllip.tagged_parse([('A', None), ('tree', 'NN')])))\n    print(\"forcing 'A' to be 'DT' and 'tree' to be 'NNP':\", next(bllip.tagged_parse([('A', 'DT'), ('tree', 'NNP')])))\n    print(\"forcing 'A' to be 'NNP':\", next(bllip.tagged_parse([('A', 'NNP'), ('tree', None)])))",
            "def demo():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'This assumes the Python module bllipparser is installed.'\n    from nltk.data import find\n    model_dir = find('models/bllip_wsj_no_aux').path\n    print('Loading BLLIP Parsing models...')\n    bllip = BllipParser.from_unified_model_dir(model_dir)\n    print('Done.')\n    sentence1 = 'British left waffles on Falklands .'.split()\n    sentence2 = 'I saw the man with the telescope .'.split()\n    fail1 = '# ! ? : -'.split()\n    for sentence in (sentence1, sentence2, fail1):\n        print('Sentence: %r' % ' '.join(sentence))\n        try:\n            tree = next(bllip.parse(sentence))\n            print(tree)\n        except StopIteration:\n            print('(parse failed)')\n    for (i, parse) in enumerate(bllip.parse(sentence1)):\n        print('parse %d:\\n%s' % (i, parse))\n    print(\"forcing 'tree' to be 'NN':\", next(bllip.tagged_parse([('A', None), ('tree', 'NN')])))\n    print(\"forcing 'A' to be 'DT' and 'tree' to be 'NNP':\", next(bllip.tagged_parse([('A', 'DT'), ('tree', 'NNP')])))\n    print(\"forcing 'A' to be 'NNP':\", next(bllip.tagged_parse([('A', 'NNP'), ('tree', None)])))",
            "def demo():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'This assumes the Python module bllipparser is installed.'\n    from nltk.data import find\n    model_dir = find('models/bllip_wsj_no_aux').path\n    print('Loading BLLIP Parsing models...')\n    bllip = BllipParser.from_unified_model_dir(model_dir)\n    print('Done.')\n    sentence1 = 'British left waffles on Falklands .'.split()\n    sentence2 = 'I saw the man with the telescope .'.split()\n    fail1 = '# ! ? : -'.split()\n    for sentence in (sentence1, sentence2, fail1):\n        print('Sentence: %r' % ' '.join(sentence))\n        try:\n            tree = next(bllip.parse(sentence))\n            print(tree)\n        except StopIteration:\n            print('(parse failed)')\n    for (i, parse) in enumerate(bllip.parse(sentence1)):\n        print('parse %d:\\n%s' % (i, parse))\n    print(\"forcing 'tree' to be 'NN':\", next(bllip.tagged_parse([('A', None), ('tree', 'NN')])))\n    print(\"forcing 'A' to be 'DT' and 'tree' to be 'NNP':\", next(bllip.tagged_parse([('A', 'DT'), ('tree', 'NNP')])))\n    print(\"forcing 'A' to be 'NNP':\", next(bllip.tagged_parse([('A', 'NNP'), ('tree', None)])))",
            "def demo():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'This assumes the Python module bllipparser is installed.'\n    from nltk.data import find\n    model_dir = find('models/bllip_wsj_no_aux').path\n    print('Loading BLLIP Parsing models...')\n    bllip = BllipParser.from_unified_model_dir(model_dir)\n    print('Done.')\n    sentence1 = 'British left waffles on Falklands .'.split()\n    sentence2 = 'I saw the man with the telescope .'.split()\n    fail1 = '# ! ? : -'.split()\n    for sentence in (sentence1, sentence2, fail1):\n        print('Sentence: %r' % ' '.join(sentence))\n        try:\n            tree = next(bllip.parse(sentence))\n            print(tree)\n        except StopIteration:\n            print('(parse failed)')\n    for (i, parse) in enumerate(bllip.parse(sentence1)):\n        print('parse %d:\\n%s' % (i, parse))\n    print(\"forcing 'tree' to be 'NN':\", next(bllip.tagged_parse([('A', None), ('tree', 'NN')])))\n    print(\"forcing 'A' to be 'DT' and 'tree' to be 'NNP':\", next(bllip.tagged_parse([('A', 'DT'), ('tree', 'NNP')])))\n    print(\"forcing 'A' to be 'NNP':\", next(bllip.tagged_parse([('A', 'NNP'), ('tree', None)])))"
        ]
    }
]