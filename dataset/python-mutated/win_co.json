[
    {
        "func_name": "_recurse",
        "original": "def _recurse(topdir, rel_offset, parent_dirs, rel_base=u'', checksum_check=False):\n    \"\"\"\n        This is a closure (function utilizing variables from it's parent\n        function's scope) so that we only need one copy of all the containers.\n        Note that this function uses side effects (See the Variables used from\n        outer scope).\n\n        :arg topdir: The directory we are walking for files\n        :arg rel_offset: Integer defining how many characters to strip off of\n            the beginning of a path\n        :arg parent_dirs: Directories that we're copying that this directory is in.\n        :kwarg rel_base: String to prepend to the path after ``rel_offset`` is\n            applied to form the relative path.\n\n        Variables used from the outer scope\n        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n        :r_files: Dictionary of files in the hierarchy.  See the return value\n            for :func:`walk` for the structure of this dictionary.\n        :local_follow: Read-only inside of :func:`_recurse`. Whether to follow symlinks\n        \"\"\"\n    for (base_path, sub_folders, files) in os.walk(topdir):\n        for filename in files:\n            filepath = os.path.join(base_path, filename)\n            dest_filepath = os.path.join(rel_base, filepath[rel_offset:])\n            if os.path.islink(filepath):\n                real_file = loader.get_real_file(os.path.realpath(filepath), decrypt=decrypt)\n                if local_follow and os.path.isfile(real_file):\n                    r_files['files'].append({'src': real_file, 'dest': dest_filepath, 'checksum': _get_local_checksum(checksum_check, real_file)})\n                else:\n                    r_files['symlinks'].append({'src': os.readlink(filepath), 'dest': dest_filepath})\n            else:\n                real_file = loader.get_real_file(filepath, decrypt=decrypt)\n                r_files['files'].append({'src': real_file, 'dest': dest_filepath, 'checksum': _get_local_checksum(checksum_check, real_file)})\n        for dirname in sub_folders:\n            dirpath = os.path.join(base_path, dirname)\n            dest_dirpath = os.path.join(rel_base, dirpath[rel_offset:])\n            real_dir = os.path.realpath(dirpath)\n            dir_stats = os.stat(real_dir)\n            if os.path.islink(dirpath):\n                if local_follow:\n                    if (dir_stats.st_dev, dir_stats.st_ino) in parent_dirs:\n                        r_files['symlinks'].append({'src': os.readlink(dirpath), 'dest': dest_dirpath})\n                    else:\n                        new_parents = set()\n                        parent_dir_list = os.path.dirname(dirpath).split(os.path.sep)\n                        for parent in range(len(parent_dir_list), 0, -1):\n                            parent_stat = os.stat(u'/'.join(parent_dir_list[:parent]))\n                            if (parent_stat.st_dev, parent_stat.st_ino) in parent_dirs:\n                                break\n                            new_parents.add((parent_stat.st_dev, parent_stat.st_ino))\n                        if (dir_stats.st_dev, dir_stats.st_ino) in new_parents:\n                            r_files['symlinks'].append({'src': os.readlink(dirpath), 'dest': dest_dirpath})\n                        else:\n                            r_files['directories'].append({'src': real_dir, 'dest': dest_dirpath})\n                            offset = len(real_dir) + 1\n                            _recurse(real_dir, offset, parent_dirs.union(new_parents), rel_base=dest_dirpath, checksum_check=checksum_check)\n                else:\n                    r_files['symlinks'].append({'src': os.readlink(dirpath), 'dest': dest_dirpath})\n            else:\n                r_files['directories'].append({'src': dirpath, 'dest': dest_dirpath})",
        "mutated": [
            "def _recurse(topdir, rel_offset, parent_dirs, rel_base=u'', checksum_check=False):\n    if False:\n        i = 10\n    \"\\n        This is a closure (function utilizing variables from it's parent\\n        function's scope) so that we only need one copy of all the containers.\\n        Note that this function uses side effects (See the Variables used from\\n        outer scope).\\n\\n        :arg topdir: The directory we are walking for files\\n        :arg rel_offset: Integer defining how many characters to strip off of\\n            the beginning of a path\\n        :arg parent_dirs: Directories that we're copying that this directory is in.\\n        :kwarg rel_base: String to prepend to the path after ``rel_offset`` is\\n            applied to form the relative path.\\n\\n        Variables used from the outer scope\\n        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n\\n        :r_files: Dictionary of files in the hierarchy.  See the return value\\n            for :func:`walk` for the structure of this dictionary.\\n        :local_follow: Read-only inside of :func:`_recurse`. Whether to follow symlinks\\n        \"\n    for (base_path, sub_folders, files) in os.walk(topdir):\n        for filename in files:\n            filepath = os.path.join(base_path, filename)\n            dest_filepath = os.path.join(rel_base, filepath[rel_offset:])\n            if os.path.islink(filepath):\n                real_file = loader.get_real_file(os.path.realpath(filepath), decrypt=decrypt)\n                if local_follow and os.path.isfile(real_file):\n                    r_files['files'].append({'src': real_file, 'dest': dest_filepath, 'checksum': _get_local_checksum(checksum_check, real_file)})\n                else:\n                    r_files['symlinks'].append({'src': os.readlink(filepath), 'dest': dest_filepath})\n            else:\n                real_file = loader.get_real_file(filepath, decrypt=decrypt)\n                r_files['files'].append({'src': real_file, 'dest': dest_filepath, 'checksum': _get_local_checksum(checksum_check, real_file)})\n        for dirname in sub_folders:\n            dirpath = os.path.join(base_path, dirname)\n            dest_dirpath = os.path.join(rel_base, dirpath[rel_offset:])\n            real_dir = os.path.realpath(dirpath)\n            dir_stats = os.stat(real_dir)\n            if os.path.islink(dirpath):\n                if local_follow:\n                    if (dir_stats.st_dev, dir_stats.st_ino) in parent_dirs:\n                        r_files['symlinks'].append({'src': os.readlink(dirpath), 'dest': dest_dirpath})\n                    else:\n                        new_parents = set()\n                        parent_dir_list = os.path.dirname(dirpath).split(os.path.sep)\n                        for parent in range(len(parent_dir_list), 0, -1):\n                            parent_stat = os.stat(u'/'.join(parent_dir_list[:parent]))\n                            if (parent_stat.st_dev, parent_stat.st_ino) in parent_dirs:\n                                break\n                            new_parents.add((parent_stat.st_dev, parent_stat.st_ino))\n                        if (dir_stats.st_dev, dir_stats.st_ino) in new_parents:\n                            r_files['symlinks'].append({'src': os.readlink(dirpath), 'dest': dest_dirpath})\n                        else:\n                            r_files['directories'].append({'src': real_dir, 'dest': dest_dirpath})\n                            offset = len(real_dir) + 1\n                            _recurse(real_dir, offset, parent_dirs.union(new_parents), rel_base=dest_dirpath, checksum_check=checksum_check)\n                else:\n                    r_files['symlinks'].append({'src': os.readlink(dirpath), 'dest': dest_dirpath})\n            else:\n                r_files['directories'].append({'src': dirpath, 'dest': dest_dirpath})",
            "def _recurse(topdir, rel_offset, parent_dirs, rel_base=u'', checksum_check=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n        This is a closure (function utilizing variables from it's parent\\n        function's scope) so that we only need one copy of all the containers.\\n        Note that this function uses side effects (See the Variables used from\\n        outer scope).\\n\\n        :arg topdir: The directory we are walking for files\\n        :arg rel_offset: Integer defining how many characters to strip off of\\n            the beginning of a path\\n        :arg parent_dirs: Directories that we're copying that this directory is in.\\n        :kwarg rel_base: String to prepend to the path after ``rel_offset`` is\\n            applied to form the relative path.\\n\\n        Variables used from the outer scope\\n        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n\\n        :r_files: Dictionary of files in the hierarchy.  See the return value\\n            for :func:`walk` for the structure of this dictionary.\\n        :local_follow: Read-only inside of :func:`_recurse`. Whether to follow symlinks\\n        \"\n    for (base_path, sub_folders, files) in os.walk(topdir):\n        for filename in files:\n            filepath = os.path.join(base_path, filename)\n            dest_filepath = os.path.join(rel_base, filepath[rel_offset:])\n            if os.path.islink(filepath):\n                real_file = loader.get_real_file(os.path.realpath(filepath), decrypt=decrypt)\n                if local_follow and os.path.isfile(real_file):\n                    r_files['files'].append({'src': real_file, 'dest': dest_filepath, 'checksum': _get_local_checksum(checksum_check, real_file)})\n                else:\n                    r_files['symlinks'].append({'src': os.readlink(filepath), 'dest': dest_filepath})\n            else:\n                real_file = loader.get_real_file(filepath, decrypt=decrypt)\n                r_files['files'].append({'src': real_file, 'dest': dest_filepath, 'checksum': _get_local_checksum(checksum_check, real_file)})\n        for dirname in sub_folders:\n            dirpath = os.path.join(base_path, dirname)\n            dest_dirpath = os.path.join(rel_base, dirpath[rel_offset:])\n            real_dir = os.path.realpath(dirpath)\n            dir_stats = os.stat(real_dir)\n            if os.path.islink(dirpath):\n                if local_follow:\n                    if (dir_stats.st_dev, dir_stats.st_ino) in parent_dirs:\n                        r_files['symlinks'].append({'src': os.readlink(dirpath), 'dest': dest_dirpath})\n                    else:\n                        new_parents = set()\n                        parent_dir_list = os.path.dirname(dirpath).split(os.path.sep)\n                        for parent in range(len(parent_dir_list), 0, -1):\n                            parent_stat = os.stat(u'/'.join(parent_dir_list[:parent]))\n                            if (parent_stat.st_dev, parent_stat.st_ino) in parent_dirs:\n                                break\n                            new_parents.add((parent_stat.st_dev, parent_stat.st_ino))\n                        if (dir_stats.st_dev, dir_stats.st_ino) in new_parents:\n                            r_files['symlinks'].append({'src': os.readlink(dirpath), 'dest': dest_dirpath})\n                        else:\n                            r_files['directories'].append({'src': real_dir, 'dest': dest_dirpath})\n                            offset = len(real_dir) + 1\n                            _recurse(real_dir, offset, parent_dirs.union(new_parents), rel_base=dest_dirpath, checksum_check=checksum_check)\n                else:\n                    r_files['symlinks'].append({'src': os.readlink(dirpath), 'dest': dest_dirpath})\n            else:\n                r_files['directories'].append({'src': dirpath, 'dest': dest_dirpath})",
            "def _recurse(topdir, rel_offset, parent_dirs, rel_base=u'', checksum_check=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n        This is a closure (function utilizing variables from it's parent\\n        function's scope) so that we only need one copy of all the containers.\\n        Note that this function uses side effects (See the Variables used from\\n        outer scope).\\n\\n        :arg topdir: The directory we are walking for files\\n        :arg rel_offset: Integer defining how many characters to strip off of\\n            the beginning of a path\\n        :arg parent_dirs: Directories that we're copying that this directory is in.\\n        :kwarg rel_base: String to prepend to the path after ``rel_offset`` is\\n            applied to form the relative path.\\n\\n        Variables used from the outer scope\\n        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n\\n        :r_files: Dictionary of files in the hierarchy.  See the return value\\n            for :func:`walk` for the structure of this dictionary.\\n        :local_follow: Read-only inside of :func:`_recurse`. Whether to follow symlinks\\n        \"\n    for (base_path, sub_folders, files) in os.walk(topdir):\n        for filename in files:\n            filepath = os.path.join(base_path, filename)\n            dest_filepath = os.path.join(rel_base, filepath[rel_offset:])\n            if os.path.islink(filepath):\n                real_file = loader.get_real_file(os.path.realpath(filepath), decrypt=decrypt)\n                if local_follow and os.path.isfile(real_file):\n                    r_files['files'].append({'src': real_file, 'dest': dest_filepath, 'checksum': _get_local_checksum(checksum_check, real_file)})\n                else:\n                    r_files['symlinks'].append({'src': os.readlink(filepath), 'dest': dest_filepath})\n            else:\n                real_file = loader.get_real_file(filepath, decrypt=decrypt)\n                r_files['files'].append({'src': real_file, 'dest': dest_filepath, 'checksum': _get_local_checksum(checksum_check, real_file)})\n        for dirname in sub_folders:\n            dirpath = os.path.join(base_path, dirname)\n            dest_dirpath = os.path.join(rel_base, dirpath[rel_offset:])\n            real_dir = os.path.realpath(dirpath)\n            dir_stats = os.stat(real_dir)\n            if os.path.islink(dirpath):\n                if local_follow:\n                    if (dir_stats.st_dev, dir_stats.st_ino) in parent_dirs:\n                        r_files['symlinks'].append({'src': os.readlink(dirpath), 'dest': dest_dirpath})\n                    else:\n                        new_parents = set()\n                        parent_dir_list = os.path.dirname(dirpath).split(os.path.sep)\n                        for parent in range(len(parent_dir_list), 0, -1):\n                            parent_stat = os.stat(u'/'.join(parent_dir_list[:parent]))\n                            if (parent_stat.st_dev, parent_stat.st_ino) in parent_dirs:\n                                break\n                            new_parents.add((parent_stat.st_dev, parent_stat.st_ino))\n                        if (dir_stats.st_dev, dir_stats.st_ino) in new_parents:\n                            r_files['symlinks'].append({'src': os.readlink(dirpath), 'dest': dest_dirpath})\n                        else:\n                            r_files['directories'].append({'src': real_dir, 'dest': dest_dirpath})\n                            offset = len(real_dir) + 1\n                            _recurse(real_dir, offset, parent_dirs.union(new_parents), rel_base=dest_dirpath, checksum_check=checksum_check)\n                else:\n                    r_files['symlinks'].append({'src': os.readlink(dirpath), 'dest': dest_dirpath})\n            else:\n                r_files['directories'].append({'src': dirpath, 'dest': dest_dirpath})",
            "def _recurse(topdir, rel_offset, parent_dirs, rel_base=u'', checksum_check=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n        This is a closure (function utilizing variables from it's parent\\n        function's scope) so that we only need one copy of all the containers.\\n        Note that this function uses side effects (See the Variables used from\\n        outer scope).\\n\\n        :arg topdir: The directory we are walking for files\\n        :arg rel_offset: Integer defining how many characters to strip off of\\n            the beginning of a path\\n        :arg parent_dirs: Directories that we're copying that this directory is in.\\n        :kwarg rel_base: String to prepend to the path after ``rel_offset`` is\\n            applied to form the relative path.\\n\\n        Variables used from the outer scope\\n        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n\\n        :r_files: Dictionary of files in the hierarchy.  See the return value\\n            for :func:`walk` for the structure of this dictionary.\\n        :local_follow: Read-only inside of :func:`_recurse`. Whether to follow symlinks\\n        \"\n    for (base_path, sub_folders, files) in os.walk(topdir):\n        for filename in files:\n            filepath = os.path.join(base_path, filename)\n            dest_filepath = os.path.join(rel_base, filepath[rel_offset:])\n            if os.path.islink(filepath):\n                real_file = loader.get_real_file(os.path.realpath(filepath), decrypt=decrypt)\n                if local_follow and os.path.isfile(real_file):\n                    r_files['files'].append({'src': real_file, 'dest': dest_filepath, 'checksum': _get_local_checksum(checksum_check, real_file)})\n                else:\n                    r_files['symlinks'].append({'src': os.readlink(filepath), 'dest': dest_filepath})\n            else:\n                real_file = loader.get_real_file(filepath, decrypt=decrypt)\n                r_files['files'].append({'src': real_file, 'dest': dest_filepath, 'checksum': _get_local_checksum(checksum_check, real_file)})\n        for dirname in sub_folders:\n            dirpath = os.path.join(base_path, dirname)\n            dest_dirpath = os.path.join(rel_base, dirpath[rel_offset:])\n            real_dir = os.path.realpath(dirpath)\n            dir_stats = os.stat(real_dir)\n            if os.path.islink(dirpath):\n                if local_follow:\n                    if (dir_stats.st_dev, dir_stats.st_ino) in parent_dirs:\n                        r_files['symlinks'].append({'src': os.readlink(dirpath), 'dest': dest_dirpath})\n                    else:\n                        new_parents = set()\n                        parent_dir_list = os.path.dirname(dirpath).split(os.path.sep)\n                        for parent in range(len(parent_dir_list), 0, -1):\n                            parent_stat = os.stat(u'/'.join(parent_dir_list[:parent]))\n                            if (parent_stat.st_dev, parent_stat.st_ino) in parent_dirs:\n                                break\n                            new_parents.add((parent_stat.st_dev, parent_stat.st_ino))\n                        if (dir_stats.st_dev, dir_stats.st_ino) in new_parents:\n                            r_files['symlinks'].append({'src': os.readlink(dirpath), 'dest': dest_dirpath})\n                        else:\n                            r_files['directories'].append({'src': real_dir, 'dest': dest_dirpath})\n                            offset = len(real_dir) + 1\n                            _recurse(real_dir, offset, parent_dirs.union(new_parents), rel_base=dest_dirpath, checksum_check=checksum_check)\n                else:\n                    r_files['symlinks'].append({'src': os.readlink(dirpath), 'dest': dest_dirpath})\n            else:\n                r_files['directories'].append({'src': dirpath, 'dest': dest_dirpath})",
            "def _recurse(topdir, rel_offset, parent_dirs, rel_base=u'', checksum_check=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n        This is a closure (function utilizing variables from it's parent\\n        function's scope) so that we only need one copy of all the containers.\\n        Note that this function uses side effects (See the Variables used from\\n        outer scope).\\n\\n        :arg topdir: The directory we are walking for files\\n        :arg rel_offset: Integer defining how many characters to strip off of\\n            the beginning of a path\\n        :arg parent_dirs: Directories that we're copying that this directory is in.\\n        :kwarg rel_base: String to prepend to the path after ``rel_offset`` is\\n            applied to form the relative path.\\n\\n        Variables used from the outer scope\\n        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n\\n        :r_files: Dictionary of files in the hierarchy.  See the return value\\n            for :func:`walk` for the structure of this dictionary.\\n        :local_follow: Read-only inside of :func:`_recurse`. Whether to follow symlinks\\n        \"\n    for (base_path, sub_folders, files) in os.walk(topdir):\n        for filename in files:\n            filepath = os.path.join(base_path, filename)\n            dest_filepath = os.path.join(rel_base, filepath[rel_offset:])\n            if os.path.islink(filepath):\n                real_file = loader.get_real_file(os.path.realpath(filepath), decrypt=decrypt)\n                if local_follow and os.path.isfile(real_file):\n                    r_files['files'].append({'src': real_file, 'dest': dest_filepath, 'checksum': _get_local_checksum(checksum_check, real_file)})\n                else:\n                    r_files['symlinks'].append({'src': os.readlink(filepath), 'dest': dest_filepath})\n            else:\n                real_file = loader.get_real_file(filepath, decrypt=decrypt)\n                r_files['files'].append({'src': real_file, 'dest': dest_filepath, 'checksum': _get_local_checksum(checksum_check, real_file)})\n        for dirname in sub_folders:\n            dirpath = os.path.join(base_path, dirname)\n            dest_dirpath = os.path.join(rel_base, dirpath[rel_offset:])\n            real_dir = os.path.realpath(dirpath)\n            dir_stats = os.stat(real_dir)\n            if os.path.islink(dirpath):\n                if local_follow:\n                    if (dir_stats.st_dev, dir_stats.st_ino) in parent_dirs:\n                        r_files['symlinks'].append({'src': os.readlink(dirpath), 'dest': dest_dirpath})\n                    else:\n                        new_parents = set()\n                        parent_dir_list = os.path.dirname(dirpath).split(os.path.sep)\n                        for parent in range(len(parent_dir_list), 0, -1):\n                            parent_stat = os.stat(u'/'.join(parent_dir_list[:parent]))\n                            if (parent_stat.st_dev, parent_stat.st_ino) in parent_dirs:\n                                break\n                            new_parents.add((parent_stat.st_dev, parent_stat.st_ino))\n                        if (dir_stats.st_dev, dir_stats.st_ino) in new_parents:\n                            r_files['symlinks'].append({'src': os.readlink(dirpath), 'dest': dest_dirpath})\n                        else:\n                            r_files['directories'].append({'src': real_dir, 'dest': dest_dirpath})\n                            offset = len(real_dir) + 1\n                            _recurse(real_dir, offset, parent_dirs.union(new_parents), rel_base=dest_dirpath, checksum_check=checksum_check)\n                else:\n                    r_files['symlinks'].append({'src': os.readlink(dirpath), 'dest': dest_dirpath})\n            else:\n                r_files['directories'].append({'src': dirpath, 'dest': dest_dirpath})"
        ]
    },
    {
        "func_name": "_walk_dirs",
        "original": "def _walk_dirs(topdir, loader, decrypt=True, base_path=None, local_follow=False, trailing_slash_detector=None, checksum_check=False):\n    \"\"\"\n    Walk a filesystem tree returning enough information to copy the files.\n    This is similar to the _walk_dirs function in ``copy.py`` but returns\n    a dict instead of a tuple for each entry and includes the checksum of\n    a local file if wanted.\n\n    :arg topdir: The directory that the filesystem tree is rooted at\n    :arg loader: The self._loader object from ActionBase\n    :kwarg decrypt: Whether to decrypt a file encrypted with ansible-vault\n    :kwarg base_path: The initial directory structure to strip off of the\n        files for the destination directory.  If this is None (the default),\n        the base_path is set to ``top_dir``.\n    :kwarg local_follow: Whether to follow symlinks on the source.  When set\n        to False, no symlinks are dereferenced.  When set to True (the\n        default), the code will dereference most symlinks.  However, symlinks\n        can still be present if needed to break a circular link.\n    :kwarg trailing_slash_detector: Function to determine if a path has\n        a trailing directory separator. Only needed when dealing with paths on\n        a remote machine (in which case, pass in a function that is aware of the\n        directory separator conventions on the remote machine).\n    :kawrg whether to get the checksum of the local file and add to the dict\n    :returns: dictionary of dictionaries. All of the path elements in the structure are text string.\n            This separates all the files, directories, and symlinks along with\n            import information about each::\n\n                {\n                    'files'; [{\n                        src: '/absolute/path/to/copy/from',\n                        dest: 'relative/path/to/copy/to',\n                        checksum: 'b54ba7f5621240d403f06815f7246006ef8c7d43'\n                    }, ...],\n                    'directories'; [{\n                        src: '/absolute/path/to/copy/from',\n                        dest: 'relative/path/to/copy/to'\n                    }, ...],\n                    'symlinks'; [{\n                        src: '/symlink/target/path',\n                        dest: 'relative/path/to/copy/to'\n                    }, ...],\n\n                }\n\n        The ``symlinks`` field is only populated if ``local_follow`` is set to False\n        *or* a circular symlink cannot be dereferenced. The ``checksum`` entry is set\n        to None if checksum_check=False.\n\n    \"\"\"\n    r_files = {'files': [], 'directories': [], 'symlinks': []}\n\n    def _recurse(topdir, rel_offset, parent_dirs, rel_base=u'', checksum_check=False):\n        \"\"\"\n        This is a closure (function utilizing variables from it's parent\n        function's scope) so that we only need one copy of all the containers.\n        Note that this function uses side effects (See the Variables used from\n        outer scope).\n\n        :arg topdir: The directory we are walking for files\n        :arg rel_offset: Integer defining how many characters to strip off of\n            the beginning of a path\n        :arg parent_dirs: Directories that we're copying that this directory is in.\n        :kwarg rel_base: String to prepend to the path after ``rel_offset`` is\n            applied to form the relative path.\n\n        Variables used from the outer scope\n        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n        :r_files: Dictionary of files in the hierarchy.  See the return value\n            for :func:`walk` for the structure of this dictionary.\n        :local_follow: Read-only inside of :func:`_recurse`. Whether to follow symlinks\n        \"\"\"\n        for (base_path, sub_folders, files) in os.walk(topdir):\n            for filename in files:\n                filepath = os.path.join(base_path, filename)\n                dest_filepath = os.path.join(rel_base, filepath[rel_offset:])\n                if os.path.islink(filepath):\n                    real_file = loader.get_real_file(os.path.realpath(filepath), decrypt=decrypt)\n                    if local_follow and os.path.isfile(real_file):\n                        r_files['files'].append({'src': real_file, 'dest': dest_filepath, 'checksum': _get_local_checksum(checksum_check, real_file)})\n                    else:\n                        r_files['symlinks'].append({'src': os.readlink(filepath), 'dest': dest_filepath})\n                else:\n                    real_file = loader.get_real_file(filepath, decrypt=decrypt)\n                    r_files['files'].append({'src': real_file, 'dest': dest_filepath, 'checksum': _get_local_checksum(checksum_check, real_file)})\n            for dirname in sub_folders:\n                dirpath = os.path.join(base_path, dirname)\n                dest_dirpath = os.path.join(rel_base, dirpath[rel_offset:])\n                real_dir = os.path.realpath(dirpath)\n                dir_stats = os.stat(real_dir)\n                if os.path.islink(dirpath):\n                    if local_follow:\n                        if (dir_stats.st_dev, dir_stats.st_ino) in parent_dirs:\n                            r_files['symlinks'].append({'src': os.readlink(dirpath), 'dest': dest_dirpath})\n                        else:\n                            new_parents = set()\n                            parent_dir_list = os.path.dirname(dirpath).split(os.path.sep)\n                            for parent in range(len(parent_dir_list), 0, -1):\n                                parent_stat = os.stat(u'/'.join(parent_dir_list[:parent]))\n                                if (parent_stat.st_dev, parent_stat.st_ino) in parent_dirs:\n                                    break\n                                new_parents.add((parent_stat.st_dev, parent_stat.st_ino))\n                            if (dir_stats.st_dev, dir_stats.st_ino) in new_parents:\n                                r_files['symlinks'].append({'src': os.readlink(dirpath), 'dest': dest_dirpath})\n                            else:\n                                r_files['directories'].append({'src': real_dir, 'dest': dest_dirpath})\n                                offset = len(real_dir) + 1\n                                _recurse(real_dir, offset, parent_dirs.union(new_parents), rel_base=dest_dirpath, checksum_check=checksum_check)\n                    else:\n                        r_files['symlinks'].append({'src': os.readlink(dirpath), 'dest': dest_dirpath})\n                else:\n                    r_files['directories'].append({'src': dirpath, 'dest': dest_dirpath})\n    source_trailing_slash = False\n    if trailing_slash_detector:\n        source_trailing_slash = trailing_slash_detector(topdir)\n    else:\n        source_trailing_slash = topdir.endswith(os.path.sep)\n    if base_path is None:\n        base_path = topdir\n    if not source_trailing_slash:\n        base_path = os.path.dirname(base_path)\n    if topdir.startswith(base_path):\n        offset = len(base_path)\n    if trailing_slash_detector and (not trailing_slash_detector(base_path)):\n        offset += 1\n    elif not base_path.endswith(os.path.sep):\n        offset += 1\n    if os.path.islink(topdir) and (not local_follow):\n        r_files['symlinks'] = {'src': os.readlink(topdir), 'dest': os.path.basename(topdir)}\n        return r_files\n    dir_stats = os.stat(topdir)\n    parents = frozenset(((dir_stats.st_dev, dir_stats.st_ino),))\n    _recurse(topdir, offset, parents, checksum_check=checksum_check)\n    return r_files",
        "mutated": [
            "def _walk_dirs(topdir, loader, decrypt=True, base_path=None, local_follow=False, trailing_slash_detector=None, checksum_check=False):\n    if False:\n        i = 10\n    \"\\n    Walk a filesystem tree returning enough information to copy the files.\\n    This is similar to the _walk_dirs function in ``copy.py`` but returns\\n    a dict instead of a tuple for each entry and includes the checksum of\\n    a local file if wanted.\\n\\n    :arg topdir: The directory that the filesystem tree is rooted at\\n    :arg loader: The self._loader object from ActionBase\\n    :kwarg decrypt: Whether to decrypt a file encrypted with ansible-vault\\n    :kwarg base_path: The initial directory structure to strip off of the\\n        files for the destination directory.  If this is None (the default),\\n        the base_path is set to ``top_dir``.\\n    :kwarg local_follow: Whether to follow symlinks on the source.  When set\\n        to False, no symlinks are dereferenced.  When set to True (the\\n        default), the code will dereference most symlinks.  However, symlinks\\n        can still be present if needed to break a circular link.\\n    :kwarg trailing_slash_detector: Function to determine if a path has\\n        a trailing directory separator. Only needed when dealing with paths on\\n        a remote machine (in which case, pass in a function that is aware of the\\n        directory separator conventions on the remote machine).\\n    :kawrg whether to get the checksum of the local file and add to the dict\\n    :returns: dictionary of dictionaries. All of the path elements in the structure are text string.\\n            This separates all the files, directories, and symlinks along with\\n            import information about each::\\n\\n                {\\n                    'files'; [{\\n                        src: '/absolute/path/to/copy/from',\\n                        dest: 'relative/path/to/copy/to',\\n                        checksum: 'b54ba7f5621240d403f06815f7246006ef8c7d43'\\n                    }, ...],\\n                    'directories'; [{\\n                        src: '/absolute/path/to/copy/from',\\n                        dest: 'relative/path/to/copy/to'\\n                    }, ...],\\n                    'symlinks'; [{\\n                        src: '/symlink/target/path',\\n                        dest: 'relative/path/to/copy/to'\\n                    }, ...],\\n\\n                }\\n\\n        The ``symlinks`` field is only populated if ``local_follow`` is set to False\\n        *or* a circular symlink cannot be dereferenced. The ``checksum`` entry is set\\n        to None if checksum_check=False.\\n\\n    \"\n    r_files = {'files': [], 'directories': [], 'symlinks': []}\n\n    def _recurse(topdir, rel_offset, parent_dirs, rel_base=u'', checksum_check=False):\n        \"\"\"\n        This is a closure (function utilizing variables from it's parent\n        function's scope) so that we only need one copy of all the containers.\n        Note that this function uses side effects (See the Variables used from\n        outer scope).\n\n        :arg topdir: The directory we are walking for files\n        :arg rel_offset: Integer defining how many characters to strip off of\n            the beginning of a path\n        :arg parent_dirs: Directories that we're copying that this directory is in.\n        :kwarg rel_base: String to prepend to the path after ``rel_offset`` is\n            applied to form the relative path.\n\n        Variables used from the outer scope\n        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n        :r_files: Dictionary of files in the hierarchy.  See the return value\n            for :func:`walk` for the structure of this dictionary.\n        :local_follow: Read-only inside of :func:`_recurse`. Whether to follow symlinks\n        \"\"\"\n        for (base_path, sub_folders, files) in os.walk(topdir):\n            for filename in files:\n                filepath = os.path.join(base_path, filename)\n                dest_filepath = os.path.join(rel_base, filepath[rel_offset:])\n                if os.path.islink(filepath):\n                    real_file = loader.get_real_file(os.path.realpath(filepath), decrypt=decrypt)\n                    if local_follow and os.path.isfile(real_file):\n                        r_files['files'].append({'src': real_file, 'dest': dest_filepath, 'checksum': _get_local_checksum(checksum_check, real_file)})\n                    else:\n                        r_files['symlinks'].append({'src': os.readlink(filepath), 'dest': dest_filepath})\n                else:\n                    real_file = loader.get_real_file(filepath, decrypt=decrypt)\n                    r_files['files'].append({'src': real_file, 'dest': dest_filepath, 'checksum': _get_local_checksum(checksum_check, real_file)})\n            for dirname in sub_folders:\n                dirpath = os.path.join(base_path, dirname)\n                dest_dirpath = os.path.join(rel_base, dirpath[rel_offset:])\n                real_dir = os.path.realpath(dirpath)\n                dir_stats = os.stat(real_dir)\n                if os.path.islink(dirpath):\n                    if local_follow:\n                        if (dir_stats.st_dev, dir_stats.st_ino) in parent_dirs:\n                            r_files['symlinks'].append({'src': os.readlink(dirpath), 'dest': dest_dirpath})\n                        else:\n                            new_parents = set()\n                            parent_dir_list = os.path.dirname(dirpath).split(os.path.sep)\n                            for parent in range(len(parent_dir_list), 0, -1):\n                                parent_stat = os.stat(u'/'.join(parent_dir_list[:parent]))\n                                if (parent_stat.st_dev, parent_stat.st_ino) in parent_dirs:\n                                    break\n                                new_parents.add((parent_stat.st_dev, parent_stat.st_ino))\n                            if (dir_stats.st_dev, dir_stats.st_ino) in new_parents:\n                                r_files['symlinks'].append({'src': os.readlink(dirpath), 'dest': dest_dirpath})\n                            else:\n                                r_files['directories'].append({'src': real_dir, 'dest': dest_dirpath})\n                                offset = len(real_dir) + 1\n                                _recurse(real_dir, offset, parent_dirs.union(new_parents), rel_base=dest_dirpath, checksum_check=checksum_check)\n                    else:\n                        r_files['symlinks'].append({'src': os.readlink(dirpath), 'dest': dest_dirpath})\n                else:\n                    r_files['directories'].append({'src': dirpath, 'dest': dest_dirpath})\n    source_trailing_slash = False\n    if trailing_slash_detector:\n        source_trailing_slash = trailing_slash_detector(topdir)\n    else:\n        source_trailing_slash = topdir.endswith(os.path.sep)\n    if base_path is None:\n        base_path = topdir\n    if not source_trailing_slash:\n        base_path = os.path.dirname(base_path)\n    if topdir.startswith(base_path):\n        offset = len(base_path)\n    if trailing_slash_detector and (not trailing_slash_detector(base_path)):\n        offset += 1\n    elif not base_path.endswith(os.path.sep):\n        offset += 1\n    if os.path.islink(topdir) and (not local_follow):\n        r_files['symlinks'] = {'src': os.readlink(topdir), 'dest': os.path.basename(topdir)}\n        return r_files\n    dir_stats = os.stat(topdir)\n    parents = frozenset(((dir_stats.st_dev, dir_stats.st_ino),))\n    _recurse(topdir, offset, parents, checksum_check=checksum_check)\n    return r_files",
            "def _walk_dirs(topdir, loader, decrypt=True, base_path=None, local_follow=False, trailing_slash_detector=None, checksum_check=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Walk a filesystem tree returning enough information to copy the files.\\n    This is similar to the _walk_dirs function in ``copy.py`` but returns\\n    a dict instead of a tuple for each entry and includes the checksum of\\n    a local file if wanted.\\n\\n    :arg topdir: The directory that the filesystem tree is rooted at\\n    :arg loader: The self._loader object from ActionBase\\n    :kwarg decrypt: Whether to decrypt a file encrypted with ansible-vault\\n    :kwarg base_path: The initial directory structure to strip off of the\\n        files for the destination directory.  If this is None (the default),\\n        the base_path is set to ``top_dir``.\\n    :kwarg local_follow: Whether to follow symlinks on the source.  When set\\n        to False, no symlinks are dereferenced.  When set to True (the\\n        default), the code will dereference most symlinks.  However, symlinks\\n        can still be present if needed to break a circular link.\\n    :kwarg trailing_slash_detector: Function to determine if a path has\\n        a trailing directory separator. Only needed when dealing with paths on\\n        a remote machine (in which case, pass in a function that is aware of the\\n        directory separator conventions on the remote machine).\\n    :kawrg whether to get the checksum of the local file and add to the dict\\n    :returns: dictionary of dictionaries. All of the path elements in the structure are text string.\\n            This separates all the files, directories, and symlinks along with\\n            import information about each::\\n\\n                {\\n                    'files'; [{\\n                        src: '/absolute/path/to/copy/from',\\n                        dest: 'relative/path/to/copy/to',\\n                        checksum: 'b54ba7f5621240d403f06815f7246006ef8c7d43'\\n                    }, ...],\\n                    'directories'; [{\\n                        src: '/absolute/path/to/copy/from',\\n                        dest: 'relative/path/to/copy/to'\\n                    }, ...],\\n                    'symlinks'; [{\\n                        src: '/symlink/target/path',\\n                        dest: 'relative/path/to/copy/to'\\n                    }, ...],\\n\\n                }\\n\\n        The ``symlinks`` field is only populated if ``local_follow`` is set to False\\n        *or* a circular symlink cannot be dereferenced. The ``checksum`` entry is set\\n        to None if checksum_check=False.\\n\\n    \"\n    r_files = {'files': [], 'directories': [], 'symlinks': []}\n\n    def _recurse(topdir, rel_offset, parent_dirs, rel_base=u'', checksum_check=False):\n        \"\"\"\n        This is a closure (function utilizing variables from it's parent\n        function's scope) so that we only need one copy of all the containers.\n        Note that this function uses side effects (See the Variables used from\n        outer scope).\n\n        :arg topdir: The directory we are walking for files\n        :arg rel_offset: Integer defining how many characters to strip off of\n            the beginning of a path\n        :arg parent_dirs: Directories that we're copying that this directory is in.\n        :kwarg rel_base: String to prepend to the path after ``rel_offset`` is\n            applied to form the relative path.\n\n        Variables used from the outer scope\n        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n        :r_files: Dictionary of files in the hierarchy.  See the return value\n            for :func:`walk` for the structure of this dictionary.\n        :local_follow: Read-only inside of :func:`_recurse`. Whether to follow symlinks\n        \"\"\"\n        for (base_path, sub_folders, files) in os.walk(topdir):\n            for filename in files:\n                filepath = os.path.join(base_path, filename)\n                dest_filepath = os.path.join(rel_base, filepath[rel_offset:])\n                if os.path.islink(filepath):\n                    real_file = loader.get_real_file(os.path.realpath(filepath), decrypt=decrypt)\n                    if local_follow and os.path.isfile(real_file):\n                        r_files['files'].append({'src': real_file, 'dest': dest_filepath, 'checksum': _get_local_checksum(checksum_check, real_file)})\n                    else:\n                        r_files['symlinks'].append({'src': os.readlink(filepath), 'dest': dest_filepath})\n                else:\n                    real_file = loader.get_real_file(filepath, decrypt=decrypt)\n                    r_files['files'].append({'src': real_file, 'dest': dest_filepath, 'checksum': _get_local_checksum(checksum_check, real_file)})\n            for dirname in sub_folders:\n                dirpath = os.path.join(base_path, dirname)\n                dest_dirpath = os.path.join(rel_base, dirpath[rel_offset:])\n                real_dir = os.path.realpath(dirpath)\n                dir_stats = os.stat(real_dir)\n                if os.path.islink(dirpath):\n                    if local_follow:\n                        if (dir_stats.st_dev, dir_stats.st_ino) in parent_dirs:\n                            r_files['symlinks'].append({'src': os.readlink(dirpath), 'dest': dest_dirpath})\n                        else:\n                            new_parents = set()\n                            parent_dir_list = os.path.dirname(dirpath).split(os.path.sep)\n                            for parent in range(len(parent_dir_list), 0, -1):\n                                parent_stat = os.stat(u'/'.join(parent_dir_list[:parent]))\n                                if (parent_stat.st_dev, parent_stat.st_ino) in parent_dirs:\n                                    break\n                                new_parents.add((parent_stat.st_dev, parent_stat.st_ino))\n                            if (dir_stats.st_dev, dir_stats.st_ino) in new_parents:\n                                r_files['symlinks'].append({'src': os.readlink(dirpath), 'dest': dest_dirpath})\n                            else:\n                                r_files['directories'].append({'src': real_dir, 'dest': dest_dirpath})\n                                offset = len(real_dir) + 1\n                                _recurse(real_dir, offset, parent_dirs.union(new_parents), rel_base=dest_dirpath, checksum_check=checksum_check)\n                    else:\n                        r_files['symlinks'].append({'src': os.readlink(dirpath), 'dest': dest_dirpath})\n                else:\n                    r_files['directories'].append({'src': dirpath, 'dest': dest_dirpath})\n    source_trailing_slash = False\n    if trailing_slash_detector:\n        source_trailing_slash = trailing_slash_detector(topdir)\n    else:\n        source_trailing_slash = topdir.endswith(os.path.sep)\n    if base_path is None:\n        base_path = topdir\n    if not source_trailing_slash:\n        base_path = os.path.dirname(base_path)\n    if topdir.startswith(base_path):\n        offset = len(base_path)\n    if trailing_slash_detector and (not trailing_slash_detector(base_path)):\n        offset += 1\n    elif not base_path.endswith(os.path.sep):\n        offset += 1\n    if os.path.islink(topdir) and (not local_follow):\n        r_files['symlinks'] = {'src': os.readlink(topdir), 'dest': os.path.basename(topdir)}\n        return r_files\n    dir_stats = os.stat(topdir)\n    parents = frozenset(((dir_stats.st_dev, dir_stats.st_ino),))\n    _recurse(topdir, offset, parents, checksum_check=checksum_check)\n    return r_files",
            "def _walk_dirs(topdir, loader, decrypt=True, base_path=None, local_follow=False, trailing_slash_detector=None, checksum_check=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Walk a filesystem tree returning enough information to copy the files.\\n    This is similar to the _walk_dirs function in ``copy.py`` but returns\\n    a dict instead of a tuple for each entry and includes the checksum of\\n    a local file if wanted.\\n\\n    :arg topdir: The directory that the filesystem tree is rooted at\\n    :arg loader: The self._loader object from ActionBase\\n    :kwarg decrypt: Whether to decrypt a file encrypted with ansible-vault\\n    :kwarg base_path: The initial directory structure to strip off of the\\n        files for the destination directory.  If this is None (the default),\\n        the base_path is set to ``top_dir``.\\n    :kwarg local_follow: Whether to follow symlinks on the source.  When set\\n        to False, no symlinks are dereferenced.  When set to True (the\\n        default), the code will dereference most symlinks.  However, symlinks\\n        can still be present if needed to break a circular link.\\n    :kwarg trailing_slash_detector: Function to determine if a path has\\n        a trailing directory separator. Only needed when dealing with paths on\\n        a remote machine (in which case, pass in a function that is aware of the\\n        directory separator conventions on the remote machine).\\n    :kawrg whether to get the checksum of the local file and add to the dict\\n    :returns: dictionary of dictionaries. All of the path elements in the structure are text string.\\n            This separates all the files, directories, and symlinks along with\\n            import information about each::\\n\\n                {\\n                    'files'; [{\\n                        src: '/absolute/path/to/copy/from',\\n                        dest: 'relative/path/to/copy/to',\\n                        checksum: 'b54ba7f5621240d403f06815f7246006ef8c7d43'\\n                    }, ...],\\n                    'directories'; [{\\n                        src: '/absolute/path/to/copy/from',\\n                        dest: 'relative/path/to/copy/to'\\n                    }, ...],\\n                    'symlinks'; [{\\n                        src: '/symlink/target/path',\\n                        dest: 'relative/path/to/copy/to'\\n                    }, ...],\\n\\n                }\\n\\n        The ``symlinks`` field is only populated if ``local_follow`` is set to False\\n        *or* a circular symlink cannot be dereferenced. The ``checksum`` entry is set\\n        to None if checksum_check=False.\\n\\n    \"\n    r_files = {'files': [], 'directories': [], 'symlinks': []}\n\n    def _recurse(topdir, rel_offset, parent_dirs, rel_base=u'', checksum_check=False):\n        \"\"\"\n        This is a closure (function utilizing variables from it's parent\n        function's scope) so that we only need one copy of all the containers.\n        Note that this function uses side effects (See the Variables used from\n        outer scope).\n\n        :arg topdir: The directory we are walking for files\n        :arg rel_offset: Integer defining how many characters to strip off of\n            the beginning of a path\n        :arg parent_dirs: Directories that we're copying that this directory is in.\n        :kwarg rel_base: String to prepend to the path after ``rel_offset`` is\n            applied to form the relative path.\n\n        Variables used from the outer scope\n        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n        :r_files: Dictionary of files in the hierarchy.  See the return value\n            for :func:`walk` for the structure of this dictionary.\n        :local_follow: Read-only inside of :func:`_recurse`. Whether to follow symlinks\n        \"\"\"\n        for (base_path, sub_folders, files) in os.walk(topdir):\n            for filename in files:\n                filepath = os.path.join(base_path, filename)\n                dest_filepath = os.path.join(rel_base, filepath[rel_offset:])\n                if os.path.islink(filepath):\n                    real_file = loader.get_real_file(os.path.realpath(filepath), decrypt=decrypt)\n                    if local_follow and os.path.isfile(real_file):\n                        r_files['files'].append({'src': real_file, 'dest': dest_filepath, 'checksum': _get_local_checksum(checksum_check, real_file)})\n                    else:\n                        r_files['symlinks'].append({'src': os.readlink(filepath), 'dest': dest_filepath})\n                else:\n                    real_file = loader.get_real_file(filepath, decrypt=decrypt)\n                    r_files['files'].append({'src': real_file, 'dest': dest_filepath, 'checksum': _get_local_checksum(checksum_check, real_file)})\n            for dirname in sub_folders:\n                dirpath = os.path.join(base_path, dirname)\n                dest_dirpath = os.path.join(rel_base, dirpath[rel_offset:])\n                real_dir = os.path.realpath(dirpath)\n                dir_stats = os.stat(real_dir)\n                if os.path.islink(dirpath):\n                    if local_follow:\n                        if (dir_stats.st_dev, dir_stats.st_ino) in parent_dirs:\n                            r_files['symlinks'].append({'src': os.readlink(dirpath), 'dest': dest_dirpath})\n                        else:\n                            new_parents = set()\n                            parent_dir_list = os.path.dirname(dirpath).split(os.path.sep)\n                            for parent in range(len(parent_dir_list), 0, -1):\n                                parent_stat = os.stat(u'/'.join(parent_dir_list[:parent]))\n                                if (parent_stat.st_dev, parent_stat.st_ino) in parent_dirs:\n                                    break\n                                new_parents.add((parent_stat.st_dev, parent_stat.st_ino))\n                            if (dir_stats.st_dev, dir_stats.st_ino) in new_parents:\n                                r_files['symlinks'].append({'src': os.readlink(dirpath), 'dest': dest_dirpath})\n                            else:\n                                r_files['directories'].append({'src': real_dir, 'dest': dest_dirpath})\n                                offset = len(real_dir) + 1\n                                _recurse(real_dir, offset, parent_dirs.union(new_parents), rel_base=dest_dirpath, checksum_check=checksum_check)\n                    else:\n                        r_files['symlinks'].append({'src': os.readlink(dirpath), 'dest': dest_dirpath})\n                else:\n                    r_files['directories'].append({'src': dirpath, 'dest': dest_dirpath})\n    source_trailing_slash = False\n    if trailing_slash_detector:\n        source_trailing_slash = trailing_slash_detector(topdir)\n    else:\n        source_trailing_slash = topdir.endswith(os.path.sep)\n    if base_path is None:\n        base_path = topdir\n    if not source_trailing_slash:\n        base_path = os.path.dirname(base_path)\n    if topdir.startswith(base_path):\n        offset = len(base_path)\n    if trailing_slash_detector and (not trailing_slash_detector(base_path)):\n        offset += 1\n    elif not base_path.endswith(os.path.sep):\n        offset += 1\n    if os.path.islink(topdir) and (not local_follow):\n        r_files['symlinks'] = {'src': os.readlink(topdir), 'dest': os.path.basename(topdir)}\n        return r_files\n    dir_stats = os.stat(topdir)\n    parents = frozenset(((dir_stats.st_dev, dir_stats.st_ino),))\n    _recurse(topdir, offset, parents, checksum_check=checksum_check)\n    return r_files",
            "def _walk_dirs(topdir, loader, decrypt=True, base_path=None, local_follow=False, trailing_slash_detector=None, checksum_check=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Walk a filesystem tree returning enough information to copy the files.\\n    This is similar to the _walk_dirs function in ``copy.py`` but returns\\n    a dict instead of a tuple for each entry and includes the checksum of\\n    a local file if wanted.\\n\\n    :arg topdir: The directory that the filesystem tree is rooted at\\n    :arg loader: The self._loader object from ActionBase\\n    :kwarg decrypt: Whether to decrypt a file encrypted with ansible-vault\\n    :kwarg base_path: The initial directory structure to strip off of the\\n        files for the destination directory.  If this is None (the default),\\n        the base_path is set to ``top_dir``.\\n    :kwarg local_follow: Whether to follow symlinks on the source.  When set\\n        to False, no symlinks are dereferenced.  When set to True (the\\n        default), the code will dereference most symlinks.  However, symlinks\\n        can still be present if needed to break a circular link.\\n    :kwarg trailing_slash_detector: Function to determine if a path has\\n        a trailing directory separator. Only needed when dealing with paths on\\n        a remote machine (in which case, pass in a function that is aware of the\\n        directory separator conventions on the remote machine).\\n    :kawrg whether to get the checksum of the local file and add to the dict\\n    :returns: dictionary of dictionaries. All of the path elements in the structure are text string.\\n            This separates all the files, directories, and symlinks along with\\n            import information about each::\\n\\n                {\\n                    'files'; [{\\n                        src: '/absolute/path/to/copy/from',\\n                        dest: 'relative/path/to/copy/to',\\n                        checksum: 'b54ba7f5621240d403f06815f7246006ef8c7d43'\\n                    }, ...],\\n                    'directories'; [{\\n                        src: '/absolute/path/to/copy/from',\\n                        dest: 'relative/path/to/copy/to'\\n                    }, ...],\\n                    'symlinks'; [{\\n                        src: '/symlink/target/path',\\n                        dest: 'relative/path/to/copy/to'\\n                    }, ...],\\n\\n                }\\n\\n        The ``symlinks`` field is only populated if ``local_follow`` is set to False\\n        *or* a circular symlink cannot be dereferenced. The ``checksum`` entry is set\\n        to None if checksum_check=False.\\n\\n    \"\n    r_files = {'files': [], 'directories': [], 'symlinks': []}\n\n    def _recurse(topdir, rel_offset, parent_dirs, rel_base=u'', checksum_check=False):\n        \"\"\"\n        This is a closure (function utilizing variables from it's parent\n        function's scope) so that we only need one copy of all the containers.\n        Note that this function uses side effects (See the Variables used from\n        outer scope).\n\n        :arg topdir: The directory we are walking for files\n        :arg rel_offset: Integer defining how many characters to strip off of\n            the beginning of a path\n        :arg parent_dirs: Directories that we're copying that this directory is in.\n        :kwarg rel_base: String to prepend to the path after ``rel_offset`` is\n            applied to form the relative path.\n\n        Variables used from the outer scope\n        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n        :r_files: Dictionary of files in the hierarchy.  See the return value\n            for :func:`walk` for the structure of this dictionary.\n        :local_follow: Read-only inside of :func:`_recurse`. Whether to follow symlinks\n        \"\"\"\n        for (base_path, sub_folders, files) in os.walk(topdir):\n            for filename in files:\n                filepath = os.path.join(base_path, filename)\n                dest_filepath = os.path.join(rel_base, filepath[rel_offset:])\n                if os.path.islink(filepath):\n                    real_file = loader.get_real_file(os.path.realpath(filepath), decrypt=decrypt)\n                    if local_follow and os.path.isfile(real_file):\n                        r_files['files'].append({'src': real_file, 'dest': dest_filepath, 'checksum': _get_local_checksum(checksum_check, real_file)})\n                    else:\n                        r_files['symlinks'].append({'src': os.readlink(filepath), 'dest': dest_filepath})\n                else:\n                    real_file = loader.get_real_file(filepath, decrypt=decrypt)\n                    r_files['files'].append({'src': real_file, 'dest': dest_filepath, 'checksum': _get_local_checksum(checksum_check, real_file)})\n            for dirname in sub_folders:\n                dirpath = os.path.join(base_path, dirname)\n                dest_dirpath = os.path.join(rel_base, dirpath[rel_offset:])\n                real_dir = os.path.realpath(dirpath)\n                dir_stats = os.stat(real_dir)\n                if os.path.islink(dirpath):\n                    if local_follow:\n                        if (dir_stats.st_dev, dir_stats.st_ino) in parent_dirs:\n                            r_files['symlinks'].append({'src': os.readlink(dirpath), 'dest': dest_dirpath})\n                        else:\n                            new_parents = set()\n                            parent_dir_list = os.path.dirname(dirpath).split(os.path.sep)\n                            for parent in range(len(parent_dir_list), 0, -1):\n                                parent_stat = os.stat(u'/'.join(parent_dir_list[:parent]))\n                                if (parent_stat.st_dev, parent_stat.st_ino) in parent_dirs:\n                                    break\n                                new_parents.add((parent_stat.st_dev, parent_stat.st_ino))\n                            if (dir_stats.st_dev, dir_stats.st_ino) in new_parents:\n                                r_files['symlinks'].append({'src': os.readlink(dirpath), 'dest': dest_dirpath})\n                            else:\n                                r_files['directories'].append({'src': real_dir, 'dest': dest_dirpath})\n                                offset = len(real_dir) + 1\n                                _recurse(real_dir, offset, parent_dirs.union(new_parents), rel_base=dest_dirpath, checksum_check=checksum_check)\n                    else:\n                        r_files['symlinks'].append({'src': os.readlink(dirpath), 'dest': dest_dirpath})\n                else:\n                    r_files['directories'].append({'src': dirpath, 'dest': dest_dirpath})\n    source_trailing_slash = False\n    if trailing_slash_detector:\n        source_trailing_slash = trailing_slash_detector(topdir)\n    else:\n        source_trailing_slash = topdir.endswith(os.path.sep)\n    if base_path is None:\n        base_path = topdir\n    if not source_trailing_slash:\n        base_path = os.path.dirname(base_path)\n    if topdir.startswith(base_path):\n        offset = len(base_path)\n    if trailing_slash_detector and (not trailing_slash_detector(base_path)):\n        offset += 1\n    elif not base_path.endswith(os.path.sep):\n        offset += 1\n    if os.path.islink(topdir) and (not local_follow):\n        r_files['symlinks'] = {'src': os.readlink(topdir), 'dest': os.path.basename(topdir)}\n        return r_files\n    dir_stats = os.stat(topdir)\n    parents = frozenset(((dir_stats.st_dev, dir_stats.st_ino),))\n    _recurse(topdir, offset, parents, checksum_check=checksum_check)\n    return r_files",
            "def _walk_dirs(topdir, loader, decrypt=True, base_path=None, local_follow=False, trailing_slash_detector=None, checksum_check=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Walk a filesystem tree returning enough information to copy the files.\\n    This is similar to the _walk_dirs function in ``copy.py`` but returns\\n    a dict instead of a tuple for each entry and includes the checksum of\\n    a local file if wanted.\\n\\n    :arg topdir: The directory that the filesystem tree is rooted at\\n    :arg loader: The self._loader object from ActionBase\\n    :kwarg decrypt: Whether to decrypt a file encrypted with ansible-vault\\n    :kwarg base_path: The initial directory structure to strip off of the\\n        files for the destination directory.  If this is None (the default),\\n        the base_path is set to ``top_dir``.\\n    :kwarg local_follow: Whether to follow symlinks on the source.  When set\\n        to False, no symlinks are dereferenced.  When set to True (the\\n        default), the code will dereference most symlinks.  However, symlinks\\n        can still be present if needed to break a circular link.\\n    :kwarg trailing_slash_detector: Function to determine if a path has\\n        a trailing directory separator. Only needed when dealing with paths on\\n        a remote machine (in which case, pass in a function that is aware of the\\n        directory separator conventions on the remote machine).\\n    :kawrg whether to get the checksum of the local file and add to the dict\\n    :returns: dictionary of dictionaries. All of the path elements in the structure are text string.\\n            This separates all the files, directories, and symlinks along with\\n            import information about each::\\n\\n                {\\n                    'files'; [{\\n                        src: '/absolute/path/to/copy/from',\\n                        dest: 'relative/path/to/copy/to',\\n                        checksum: 'b54ba7f5621240d403f06815f7246006ef8c7d43'\\n                    }, ...],\\n                    'directories'; [{\\n                        src: '/absolute/path/to/copy/from',\\n                        dest: 'relative/path/to/copy/to'\\n                    }, ...],\\n                    'symlinks'; [{\\n                        src: '/symlink/target/path',\\n                        dest: 'relative/path/to/copy/to'\\n                    }, ...],\\n\\n                }\\n\\n        The ``symlinks`` field is only populated if ``local_follow`` is set to False\\n        *or* a circular symlink cannot be dereferenced. The ``checksum`` entry is set\\n        to None if checksum_check=False.\\n\\n    \"\n    r_files = {'files': [], 'directories': [], 'symlinks': []}\n\n    def _recurse(topdir, rel_offset, parent_dirs, rel_base=u'', checksum_check=False):\n        \"\"\"\n        This is a closure (function utilizing variables from it's parent\n        function's scope) so that we only need one copy of all the containers.\n        Note that this function uses side effects (See the Variables used from\n        outer scope).\n\n        :arg topdir: The directory we are walking for files\n        :arg rel_offset: Integer defining how many characters to strip off of\n            the beginning of a path\n        :arg parent_dirs: Directories that we're copying that this directory is in.\n        :kwarg rel_base: String to prepend to the path after ``rel_offset`` is\n            applied to form the relative path.\n\n        Variables used from the outer scope\n        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n        :r_files: Dictionary of files in the hierarchy.  See the return value\n            for :func:`walk` for the structure of this dictionary.\n        :local_follow: Read-only inside of :func:`_recurse`. Whether to follow symlinks\n        \"\"\"\n        for (base_path, sub_folders, files) in os.walk(topdir):\n            for filename in files:\n                filepath = os.path.join(base_path, filename)\n                dest_filepath = os.path.join(rel_base, filepath[rel_offset:])\n                if os.path.islink(filepath):\n                    real_file = loader.get_real_file(os.path.realpath(filepath), decrypt=decrypt)\n                    if local_follow and os.path.isfile(real_file):\n                        r_files['files'].append({'src': real_file, 'dest': dest_filepath, 'checksum': _get_local_checksum(checksum_check, real_file)})\n                    else:\n                        r_files['symlinks'].append({'src': os.readlink(filepath), 'dest': dest_filepath})\n                else:\n                    real_file = loader.get_real_file(filepath, decrypt=decrypt)\n                    r_files['files'].append({'src': real_file, 'dest': dest_filepath, 'checksum': _get_local_checksum(checksum_check, real_file)})\n            for dirname in sub_folders:\n                dirpath = os.path.join(base_path, dirname)\n                dest_dirpath = os.path.join(rel_base, dirpath[rel_offset:])\n                real_dir = os.path.realpath(dirpath)\n                dir_stats = os.stat(real_dir)\n                if os.path.islink(dirpath):\n                    if local_follow:\n                        if (dir_stats.st_dev, dir_stats.st_ino) in parent_dirs:\n                            r_files['symlinks'].append({'src': os.readlink(dirpath), 'dest': dest_dirpath})\n                        else:\n                            new_parents = set()\n                            parent_dir_list = os.path.dirname(dirpath).split(os.path.sep)\n                            for parent in range(len(parent_dir_list), 0, -1):\n                                parent_stat = os.stat(u'/'.join(parent_dir_list[:parent]))\n                                if (parent_stat.st_dev, parent_stat.st_ino) in parent_dirs:\n                                    break\n                                new_parents.add((parent_stat.st_dev, parent_stat.st_ino))\n                            if (dir_stats.st_dev, dir_stats.st_ino) in new_parents:\n                                r_files['symlinks'].append({'src': os.readlink(dirpath), 'dest': dest_dirpath})\n                            else:\n                                r_files['directories'].append({'src': real_dir, 'dest': dest_dirpath})\n                                offset = len(real_dir) + 1\n                                _recurse(real_dir, offset, parent_dirs.union(new_parents), rel_base=dest_dirpath, checksum_check=checksum_check)\n                    else:\n                        r_files['symlinks'].append({'src': os.readlink(dirpath), 'dest': dest_dirpath})\n                else:\n                    r_files['directories'].append({'src': dirpath, 'dest': dest_dirpath})\n    source_trailing_slash = False\n    if trailing_slash_detector:\n        source_trailing_slash = trailing_slash_detector(topdir)\n    else:\n        source_trailing_slash = topdir.endswith(os.path.sep)\n    if base_path is None:\n        base_path = topdir\n    if not source_trailing_slash:\n        base_path = os.path.dirname(base_path)\n    if topdir.startswith(base_path):\n        offset = len(base_path)\n    if trailing_slash_detector and (not trailing_slash_detector(base_path)):\n        offset += 1\n    elif not base_path.endswith(os.path.sep):\n        offset += 1\n    if os.path.islink(topdir) and (not local_follow):\n        r_files['symlinks'] = {'src': os.readlink(topdir), 'dest': os.path.basename(topdir)}\n        return r_files\n    dir_stats = os.stat(topdir)\n    parents = frozenset(((dir_stats.st_dev, dir_stats.st_ino),))\n    _recurse(topdir, offset, parents, checksum_check=checksum_check)\n    return r_files"
        ]
    },
    {
        "func_name": "_get_local_checksum",
        "original": "def _get_local_checksum(get_checksum, local_path):\n    if get_checksum:\n        return checksum(local_path)\n    else:\n        return None",
        "mutated": [
            "def _get_local_checksum(get_checksum, local_path):\n    if False:\n        i = 10\n    if get_checksum:\n        return checksum(local_path)\n    else:\n        return None",
            "def _get_local_checksum(get_checksum, local_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if get_checksum:\n        return checksum(local_path)\n    else:\n        return None",
            "def _get_local_checksum(get_checksum, local_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if get_checksum:\n        return checksum(local_path)\n    else:\n        return None",
            "def _get_local_checksum(get_checksum, local_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if get_checksum:\n        return checksum(local_path)\n    else:\n        return None",
            "def _get_local_checksum(get_checksum, local_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if get_checksum:\n        return checksum(local_path)\n    else:\n        return None"
        ]
    },
    {
        "func_name": "_create_content_tempfile",
        "original": "def _create_content_tempfile(self, content):\n    \"\"\" Create a tempfile containing defined content \"\"\"\n    (fd, content_tempfile) = tempfile.mkstemp(dir=C.DEFAULT_LOCAL_TMP)\n    f = os.fdopen(fd, 'wb')\n    content = to_bytes(content)\n    try:\n        f.write(content)\n    except Exception as err:\n        os.remove(content_tempfile)\n        raise Exception(err)\n    finally:\n        f.close()\n    return content_tempfile",
        "mutated": [
            "def _create_content_tempfile(self, content):\n    if False:\n        i = 10\n    ' Create a tempfile containing defined content '\n    (fd, content_tempfile) = tempfile.mkstemp(dir=C.DEFAULT_LOCAL_TMP)\n    f = os.fdopen(fd, 'wb')\n    content = to_bytes(content)\n    try:\n        f.write(content)\n    except Exception as err:\n        os.remove(content_tempfile)\n        raise Exception(err)\n    finally:\n        f.close()\n    return content_tempfile",
            "def _create_content_tempfile(self, content):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ' Create a tempfile containing defined content '\n    (fd, content_tempfile) = tempfile.mkstemp(dir=C.DEFAULT_LOCAL_TMP)\n    f = os.fdopen(fd, 'wb')\n    content = to_bytes(content)\n    try:\n        f.write(content)\n    except Exception as err:\n        os.remove(content_tempfile)\n        raise Exception(err)\n    finally:\n        f.close()\n    return content_tempfile",
            "def _create_content_tempfile(self, content):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ' Create a tempfile containing defined content '\n    (fd, content_tempfile) = tempfile.mkstemp(dir=C.DEFAULT_LOCAL_TMP)\n    f = os.fdopen(fd, 'wb')\n    content = to_bytes(content)\n    try:\n        f.write(content)\n    except Exception as err:\n        os.remove(content_tempfile)\n        raise Exception(err)\n    finally:\n        f.close()\n    return content_tempfile",
            "def _create_content_tempfile(self, content):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ' Create a tempfile containing defined content '\n    (fd, content_tempfile) = tempfile.mkstemp(dir=C.DEFAULT_LOCAL_TMP)\n    f = os.fdopen(fd, 'wb')\n    content = to_bytes(content)\n    try:\n        f.write(content)\n    except Exception as err:\n        os.remove(content_tempfile)\n        raise Exception(err)\n    finally:\n        f.close()\n    return content_tempfile",
            "def _create_content_tempfile(self, content):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ' Create a tempfile containing defined content '\n    (fd, content_tempfile) = tempfile.mkstemp(dir=C.DEFAULT_LOCAL_TMP)\n    f = os.fdopen(fd, 'wb')\n    content = to_bytes(content)\n    try:\n        f.write(content)\n    except Exception as err:\n        os.remove(content_tempfile)\n        raise Exception(err)\n    finally:\n        f.close()\n    return content_tempfile"
        ]
    },
    {
        "func_name": "_create_zip_tempfile",
        "original": "def _create_zip_tempfile(self, files, directories):\n    tmpdir = tempfile.mkdtemp(dir=C.DEFAULT_LOCAL_TMP)\n    zip_file_path = os.path.join(tmpdir, 'win_copy.zip')\n    zip_file = zipfile.ZipFile(zip_file_path, 'w', zipfile.ZIP_STORED, True)\n    for directory in directories:\n        directory_path = to_bytes(directory['src'], errors='surrogate_or_strict')\n        archive_path = to_bytes(directory['dest'], errors='surrogate_or_strict')\n        encoded_path = to_text(base64.b64encode(archive_path), errors='surrogate_or_strict')\n        zip_file.write(directory_path, encoded_path, zipfile.ZIP_DEFLATED)\n    for file in files:\n        file_path = to_bytes(file['src'], errors='surrogate_or_strict')\n        archive_path = to_bytes(file['dest'], errors='surrogate_or_strict')\n        encoded_path = to_text(base64.b64encode(archive_path), errors='surrogate_or_strict')\n        zip_file.write(file_path, encoded_path, zipfile.ZIP_DEFLATED)\n    return zip_file_path",
        "mutated": [
            "def _create_zip_tempfile(self, files, directories):\n    if False:\n        i = 10\n    tmpdir = tempfile.mkdtemp(dir=C.DEFAULT_LOCAL_TMP)\n    zip_file_path = os.path.join(tmpdir, 'win_copy.zip')\n    zip_file = zipfile.ZipFile(zip_file_path, 'w', zipfile.ZIP_STORED, True)\n    for directory in directories:\n        directory_path = to_bytes(directory['src'], errors='surrogate_or_strict')\n        archive_path = to_bytes(directory['dest'], errors='surrogate_or_strict')\n        encoded_path = to_text(base64.b64encode(archive_path), errors='surrogate_or_strict')\n        zip_file.write(directory_path, encoded_path, zipfile.ZIP_DEFLATED)\n    for file in files:\n        file_path = to_bytes(file['src'], errors='surrogate_or_strict')\n        archive_path = to_bytes(file['dest'], errors='surrogate_or_strict')\n        encoded_path = to_text(base64.b64encode(archive_path), errors='surrogate_or_strict')\n        zip_file.write(file_path, encoded_path, zipfile.ZIP_DEFLATED)\n    return zip_file_path",
            "def _create_zip_tempfile(self, files, directories):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    tmpdir = tempfile.mkdtemp(dir=C.DEFAULT_LOCAL_TMP)\n    zip_file_path = os.path.join(tmpdir, 'win_copy.zip')\n    zip_file = zipfile.ZipFile(zip_file_path, 'w', zipfile.ZIP_STORED, True)\n    for directory in directories:\n        directory_path = to_bytes(directory['src'], errors='surrogate_or_strict')\n        archive_path = to_bytes(directory['dest'], errors='surrogate_or_strict')\n        encoded_path = to_text(base64.b64encode(archive_path), errors='surrogate_or_strict')\n        zip_file.write(directory_path, encoded_path, zipfile.ZIP_DEFLATED)\n    for file in files:\n        file_path = to_bytes(file['src'], errors='surrogate_or_strict')\n        archive_path = to_bytes(file['dest'], errors='surrogate_or_strict')\n        encoded_path = to_text(base64.b64encode(archive_path), errors='surrogate_or_strict')\n        zip_file.write(file_path, encoded_path, zipfile.ZIP_DEFLATED)\n    return zip_file_path",
            "def _create_zip_tempfile(self, files, directories):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    tmpdir = tempfile.mkdtemp(dir=C.DEFAULT_LOCAL_TMP)\n    zip_file_path = os.path.join(tmpdir, 'win_copy.zip')\n    zip_file = zipfile.ZipFile(zip_file_path, 'w', zipfile.ZIP_STORED, True)\n    for directory in directories:\n        directory_path = to_bytes(directory['src'], errors='surrogate_or_strict')\n        archive_path = to_bytes(directory['dest'], errors='surrogate_or_strict')\n        encoded_path = to_text(base64.b64encode(archive_path), errors='surrogate_or_strict')\n        zip_file.write(directory_path, encoded_path, zipfile.ZIP_DEFLATED)\n    for file in files:\n        file_path = to_bytes(file['src'], errors='surrogate_or_strict')\n        archive_path = to_bytes(file['dest'], errors='surrogate_or_strict')\n        encoded_path = to_text(base64.b64encode(archive_path), errors='surrogate_or_strict')\n        zip_file.write(file_path, encoded_path, zipfile.ZIP_DEFLATED)\n    return zip_file_path",
            "def _create_zip_tempfile(self, files, directories):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    tmpdir = tempfile.mkdtemp(dir=C.DEFAULT_LOCAL_TMP)\n    zip_file_path = os.path.join(tmpdir, 'win_copy.zip')\n    zip_file = zipfile.ZipFile(zip_file_path, 'w', zipfile.ZIP_STORED, True)\n    for directory in directories:\n        directory_path = to_bytes(directory['src'], errors='surrogate_or_strict')\n        archive_path = to_bytes(directory['dest'], errors='surrogate_or_strict')\n        encoded_path = to_text(base64.b64encode(archive_path), errors='surrogate_or_strict')\n        zip_file.write(directory_path, encoded_path, zipfile.ZIP_DEFLATED)\n    for file in files:\n        file_path = to_bytes(file['src'], errors='surrogate_or_strict')\n        archive_path = to_bytes(file['dest'], errors='surrogate_or_strict')\n        encoded_path = to_text(base64.b64encode(archive_path), errors='surrogate_or_strict')\n        zip_file.write(file_path, encoded_path, zipfile.ZIP_DEFLATED)\n    return zip_file_path",
            "def _create_zip_tempfile(self, files, directories):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    tmpdir = tempfile.mkdtemp(dir=C.DEFAULT_LOCAL_TMP)\n    zip_file_path = os.path.join(tmpdir, 'win_copy.zip')\n    zip_file = zipfile.ZipFile(zip_file_path, 'w', zipfile.ZIP_STORED, True)\n    for directory in directories:\n        directory_path = to_bytes(directory['src'], errors='surrogate_or_strict')\n        archive_path = to_bytes(directory['dest'], errors='surrogate_or_strict')\n        encoded_path = to_text(base64.b64encode(archive_path), errors='surrogate_or_strict')\n        zip_file.write(directory_path, encoded_path, zipfile.ZIP_DEFLATED)\n    for file in files:\n        file_path = to_bytes(file['src'], errors='surrogate_or_strict')\n        archive_path = to_bytes(file['dest'], errors='surrogate_or_strict')\n        encoded_path = to_text(base64.b64encode(archive_path), errors='surrogate_or_strict')\n        zip_file.write(file_path, encoded_path, zipfile.ZIP_DEFLATED)\n    return zip_file_path"
        ]
    },
    {
        "func_name": "_remove_tempfile_if_content_defined",
        "original": "def _remove_tempfile_if_content_defined(self, content, content_tempfile):\n    if content is not None:\n        os.remove(content_tempfile)",
        "mutated": [
            "def _remove_tempfile_if_content_defined(self, content, content_tempfile):\n    if False:\n        i = 10\n    if content is not None:\n        os.remove(content_tempfile)",
            "def _remove_tempfile_if_content_defined(self, content, content_tempfile):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if content is not None:\n        os.remove(content_tempfile)",
            "def _remove_tempfile_if_content_defined(self, content, content_tempfile):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if content is not None:\n        os.remove(content_tempfile)",
            "def _remove_tempfile_if_content_defined(self, content, content_tempfile):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if content is not None:\n        os.remove(content_tempfile)",
            "def _remove_tempfile_if_content_defined(self, content, content_tempfile):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if content is not None:\n        os.remove(content_tempfile)"
        ]
    },
    {
        "func_name": "_copy_single_file",
        "original": "def _copy_single_file(self, local_file, dest, source_rel, task_vars, tmp, backup):\n    if self._play_context.check_mode:\n        module_return = dict(changed=True)\n        return module_return\n    tmp_src = self._connection._shell.join_path(tmp, 'source')\n    self._transfer_file(local_file, tmp_src)\n    copy_args = self._task.args.copy()\n    copy_args.update(dict(dest=dest, src=tmp_src, _original_basename=source_rel, _copy_mode='single', backup=backup))\n    copy_args.pop('content', None)\n    copy_result = self._execute_module(module_name='copy', module_args=copy_args, task_vars=task_vars)\n    return copy_result",
        "mutated": [
            "def _copy_single_file(self, local_file, dest, source_rel, task_vars, tmp, backup):\n    if False:\n        i = 10\n    if self._play_context.check_mode:\n        module_return = dict(changed=True)\n        return module_return\n    tmp_src = self._connection._shell.join_path(tmp, 'source')\n    self._transfer_file(local_file, tmp_src)\n    copy_args = self._task.args.copy()\n    copy_args.update(dict(dest=dest, src=tmp_src, _original_basename=source_rel, _copy_mode='single', backup=backup))\n    copy_args.pop('content', None)\n    copy_result = self._execute_module(module_name='copy', module_args=copy_args, task_vars=task_vars)\n    return copy_result",
            "def _copy_single_file(self, local_file, dest, source_rel, task_vars, tmp, backup):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self._play_context.check_mode:\n        module_return = dict(changed=True)\n        return module_return\n    tmp_src = self._connection._shell.join_path(tmp, 'source')\n    self._transfer_file(local_file, tmp_src)\n    copy_args = self._task.args.copy()\n    copy_args.update(dict(dest=dest, src=tmp_src, _original_basename=source_rel, _copy_mode='single', backup=backup))\n    copy_args.pop('content', None)\n    copy_result = self._execute_module(module_name='copy', module_args=copy_args, task_vars=task_vars)\n    return copy_result",
            "def _copy_single_file(self, local_file, dest, source_rel, task_vars, tmp, backup):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self._play_context.check_mode:\n        module_return = dict(changed=True)\n        return module_return\n    tmp_src = self._connection._shell.join_path(tmp, 'source')\n    self._transfer_file(local_file, tmp_src)\n    copy_args = self._task.args.copy()\n    copy_args.update(dict(dest=dest, src=tmp_src, _original_basename=source_rel, _copy_mode='single', backup=backup))\n    copy_args.pop('content', None)\n    copy_result = self._execute_module(module_name='copy', module_args=copy_args, task_vars=task_vars)\n    return copy_result",
            "def _copy_single_file(self, local_file, dest, source_rel, task_vars, tmp, backup):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self._play_context.check_mode:\n        module_return = dict(changed=True)\n        return module_return\n    tmp_src = self._connection._shell.join_path(tmp, 'source')\n    self._transfer_file(local_file, tmp_src)\n    copy_args = self._task.args.copy()\n    copy_args.update(dict(dest=dest, src=tmp_src, _original_basename=source_rel, _copy_mode='single', backup=backup))\n    copy_args.pop('content', None)\n    copy_result = self._execute_module(module_name='copy', module_args=copy_args, task_vars=task_vars)\n    return copy_result",
            "def _copy_single_file(self, local_file, dest, source_rel, task_vars, tmp, backup):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self._play_context.check_mode:\n        module_return = dict(changed=True)\n        return module_return\n    tmp_src = self._connection._shell.join_path(tmp, 'source')\n    self._transfer_file(local_file, tmp_src)\n    copy_args = self._task.args.copy()\n    copy_args.update(dict(dest=dest, src=tmp_src, _original_basename=source_rel, _copy_mode='single', backup=backup))\n    copy_args.pop('content', None)\n    copy_result = self._execute_module(module_name='copy', module_args=copy_args, task_vars=task_vars)\n    return copy_result"
        ]
    },
    {
        "func_name": "_copy_zip_file",
        "original": "def _copy_zip_file(self, dest, files, directories, task_vars, tmp, backup):\n    if self._play_context.check_mode:\n        module_return = dict(changed=True)\n        return module_return\n    try:\n        zip_file = self._create_zip_tempfile(files, directories)\n    except Exception as e:\n        module_return = dict(changed=False, failed=True, msg='failed to create tmp zip file: %s' % to_text(e), exception=traceback.format_exc())\n        return module_return\n    zip_path = self._loader.get_real_file(zip_file)\n    tmp_src = self._connection._shell.join_path(tmp, 'source.zip')\n    self._transfer_file(zip_path, tmp_src)\n    copy_args = self._task.args.copy()\n    copy_args.update(dict(src=tmp_src, dest=dest, _copy_mode='explode', backup=backup))\n    copy_args.pop('content', None)\n    module_return = self._execute_module(module_name='copy', module_args=copy_args, task_vars=task_vars)\n    shutil.rmtree(os.path.dirname(zip_path))\n    return module_return",
        "mutated": [
            "def _copy_zip_file(self, dest, files, directories, task_vars, tmp, backup):\n    if False:\n        i = 10\n    if self._play_context.check_mode:\n        module_return = dict(changed=True)\n        return module_return\n    try:\n        zip_file = self._create_zip_tempfile(files, directories)\n    except Exception as e:\n        module_return = dict(changed=False, failed=True, msg='failed to create tmp zip file: %s' % to_text(e), exception=traceback.format_exc())\n        return module_return\n    zip_path = self._loader.get_real_file(zip_file)\n    tmp_src = self._connection._shell.join_path(tmp, 'source.zip')\n    self._transfer_file(zip_path, tmp_src)\n    copy_args = self._task.args.copy()\n    copy_args.update(dict(src=tmp_src, dest=dest, _copy_mode='explode', backup=backup))\n    copy_args.pop('content', None)\n    module_return = self._execute_module(module_name='copy', module_args=copy_args, task_vars=task_vars)\n    shutil.rmtree(os.path.dirname(zip_path))\n    return module_return",
            "def _copy_zip_file(self, dest, files, directories, task_vars, tmp, backup):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self._play_context.check_mode:\n        module_return = dict(changed=True)\n        return module_return\n    try:\n        zip_file = self._create_zip_tempfile(files, directories)\n    except Exception as e:\n        module_return = dict(changed=False, failed=True, msg='failed to create tmp zip file: %s' % to_text(e), exception=traceback.format_exc())\n        return module_return\n    zip_path = self._loader.get_real_file(zip_file)\n    tmp_src = self._connection._shell.join_path(tmp, 'source.zip')\n    self._transfer_file(zip_path, tmp_src)\n    copy_args = self._task.args.copy()\n    copy_args.update(dict(src=tmp_src, dest=dest, _copy_mode='explode', backup=backup))\n    copy_args.pop('content', None)\n    module_return = self._execute_module(module_name='copy', module_args=copy_args, task_vars=task_vars)\n    shutil.rmtree(os.path.dirname(zip_path))\n    return module_return",
            "def _copy_zip_file(self, dest, files, directories, task_vars, tmp, backup):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self._play_context.check_mode:\n        module_return = dict(changed=True)\n        return module_return\n    try:\n        zip_file = self._create_zip_tempfile(files, directories)\n    except Exception as e:\n        module_return = dict(changed=False, failed=True, msg='failed to create tmp zip file: %s' % to_text(e), exception=traceback.format_exc())\n        return module_return\n    zip_path = self._loader.get_real_file(zip_file)\n    tmp_src = self._connection._shell.join_path(tmp, 'source.zip')\n    self._transfer_file(zip_path, tmp_src)\n    copy_args = self._task.args.copy()\n    copy_args.update(dict(src=tmp_src, dest=dest, _copy_mode='explode', backup=backup))\n    copy_args.pop('content', None)\n    module_return = self._execute_module(module_name='copy', module_args=copy_args, task_vars=task_vars)\n    shutil.rmtree(os.path.dirname(zip_path))\n    return module_return",
            "def _copy_zip_file(self, dest, files, directories, task_vars, tmp, backup):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self._play_context.check_mode:\n        module_return = dict(changed=True)\n        return module_return\n    try:\n        zip_file = self._create_zip_tempfile(files, directories)\n    except Exception as e:\n        module_return = dict(changed=False, failed=True, msg='failed to create tmp zip file: %s' % to_text(e), exception=traceback.format_exc())\n        return module_return\n    zip_path = self._loader.get_real_file(zip_file)\n    tmp_src = self._connection._shell.join_path(tmp, 'source.zip')\n    self._transfer_file(zip_path, tmp_src)\n    copy_args = self._task.args.copy()\n    copy_args.update(dict(src=tmp_src, dest=dest, _copy_mode='explode', backup=backup))\n    copy_args.pop('content', None)\n    module_return = self._execute_module(module_name='copy', module_args=copy_args, task_vars=task_vars)\n    shutil.rmtree(os.path.dirname(zip_path))\n    return module_return",
            "def _copy_zip_file(self, dest, files, directories, task_vars, tmp, backup):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self._play_context.check_mode:\n        module_return = dict(changed=True)\n        return module_return\n    try:\n        zip_file = self._create_zip_tempfile(files, directories)\n    except Exception as e:\n        module_return = dict(changed=False, failed=True, msg='failed to create tmp zip file: %s' % to_text(e), exception=traceback.format_exc())\n        return module_return\n    zip_path = self._loader.get_real_file(zip_file)\n    tmp_src = self._connection._shell.join_path(tmp, 'source.zip')\n    self._transfer_file(zip_path, tmp_src)\n    copy_args = self._task.args.copy()\n    copy_args.update(dict(src=tmp_src, dest=dest, _copy_mode='explode', backup=backup))\n    copy_args.pop('content', None)\n    module_return = self._execute_module(module_name='copy', module_args=copy_args, task_vars=task_vars)\n    shutil.rmtree(os.path.dirname(zip_path))\n    return module_return"
        ]
    },
    {
        "func_name": "run",
        "original": "def run(self, tmp=None, task_vars=None):\n    \"\"\" handler for file transfer operations \"\"\"\n    if task_vars is None:\n        task_vars = dict()\n    result = super(ActionModule, self).run(tmp, task_vars)\n    del tmp\n    source = self._task.args.get('src', None)\n    content = self._task.args.get('content', None)\n    dest = self._task.args.get('dest', None)\n    remote_src = boolean(self._task.args.get('remote_src', False), strict=False)\n    local_follow = boolean(self._task.args.get('local_follow', False), strict=False)\n    force = boolean(self._task.args.get('force', True), strict=False)\n    decrypt = boolean(self._task.args.get('decrypt', True), strict=False)\n    backup = boolean(self._task.args.get('backup', False), strict=False)\n    result['src'] = source\n    result['dest'] = dest\n    result['failed'] = True\n    if source is None and content is None or dest is None:\n        result['msg'] = 'src (or content) and dest are required'\n    elif source is not None and content is not None:\n        result['msg'] = 'src and content are mutually exclusive'\n    elif content is not None and dest is not None and (dest.endswith(os.path.sep) or dest.endswith(self.WIN_PATH_SEPARATOR)):\n        result['msg'] = 'dest must be a file if content is defined'\n    else:\n        del result['failed']\n    if result.get('failed'):\n        return result\n    content_tempfile = None\n    if content is not None:\n        try:\n            if isinstance(content, dict) or isinstance(content, list):\n                content_tempfile = self._create_content_tempfile(json.dumps(content))\n            else:\n                content_tempfile = self._create_content_tempfile(content)\n            source = content_tempfile\n        except Exception as err:\n            result['failed'] = True\n            result['msg'] = 'could not write content tmp file: %s' % to_native(err)\n            return result\n    elif remote_src:\n        new_module_args = self._task.args.copy()\n        new_module_args.update(dict(_copy_mode='remote', dest=dest, src=source, force=force, backup=backup))\n        new_module_args.pop('content', None)\n        result.update(self._execute_module(module_args=new_module_args, task_vars=task_vars))\n        return result\n    else:\n        trailing_slash = source.endswith(os.path.sep)\n        try:\n            source = self._find_needle('files', source)\n        except AnsibleError as e:\n            result['failed'] = True\n            result['msg'] = to_text(e)\n            result['exception'] = traceback.format_exc()\n            return result\n        if trailing_slash != source.endswith(os.path.sep):\n            if source[-1] == os.path.sep:\n                source = source[:-1]\n            else:\n                source = source + os.path.sep\n    source_files = {'files': [], 'directories': [], 'symlinks': []}\n    if os.path.isdir(to_bytes(source, errors='surrogate_or_strict')):\n        result['operation'] = 'folder_copy'\n        source_files = _walk_dirs(source, self._loader, decrypt=decrypt, local_follow=local_follow, trailing_slash_detector=self._connection._shell.path_has_trailing_slash, checksum_check=force)\n        if not self._connection._shell.path_has_trailing_slash(dest):\n            dest = '%s%s' % (dest, self.WIN_PATH_SEPARATOR)\n        check_dest = dest\n    else:\n        result['operation'] = 'file_copy'\n        try:\n            source_full = self._loader.get_real_file(source, decrypt=decrypt)\n        except AnsibleFileNotFound as e:\n            result['failed'] = True\n            result['msg'] = 'could not find src=%s, %s' % (source, to_text(e))\n            return result\n        original_basename = os.path.basename(source)\n        result['original_basename'] = original_basename\n        if self._connection._shell.path_has_trailing_slash(dest):\n            check_dest = dest\n            filename = original_basename\n            result['dest'] = self._connection._shell.join_path(dest, filename)\n        else:\n            unix_path = dest.replace(self.WIN_PATH_SEPARATOR, os.path.sep)\n            filename = os.path.basename(unix_path)\n            check_dest = os.path.dirname(unix_path)\n        file_checksum = _get_local_checksum(force, source_full)\n        source_files['files'].append(dict(src=source_full, dest=filename, checksum=file_checksum))\n        result['checksum'] = file_checksum\n        result['size'] = os.path.getsize(to_bytes(source_full, errors='surrogate_or_strict'))\n    query_args = self._task.args.copy()\n    query_args.update(dict(_copy_mode='query', dest=check_dest, force=force, files=source_files['files'], directories=source_files['directories'], symlinks=source_files['symlinks']))\n    query_args.pop('src', None)\n    query_args.pop('content', None)\n    query_return = self._execute_module(module_args=query_args, task_vars=task_vars)\n    if query_return.get('failed') is True:\n        result.update(query_return)\n        return result\n    if len(query_return['files']) > 0 or (len(query_return['directories']) > 0 and self._connection._shell.tmpdir is None):\n        self._connection._shell.tmpdir = self._make_tmp_path()\n    if len(query_return['files']) == 1 and len(query_return['directories']) == 0:\n        file_src = query_return['files'][0]['src']\n        file_dest = query_return['files'][0]['dest']\n        result.update(self._copy_single_file(file_src, dest, file_dest, task_vars, self._connection._shell.tmpdir, backup))\n        if result.get('failed') is True:\n            result['msg'] = 'failed to copy file %s: %s' % (file_src, result['msg'])\n        result['changed'] = True\n    elif len(query_return['files']) > 0 or len(query_return['directories']) > 0:\n        result.update(self._copy_zip_file(dest, source_files['files'], source_files['directories'], task_vars, self._connection._shell.tmpdir, backup))\n        result['changed'] = True\n    else:\n        result['failed'] = False\n        result['changed'] = False\n    self._remove_tempfile_if_content_defined(content, content_tempfile)\n    self._remove_tmp_path(self._connection._shell.tmpdir)\n    return result",
        "mutated": [
            "def run(self, tmp=None, task_vars=None):\n    if False:\n        i = 10\n    ' handler for file transfer operations '\n    if task_vars is None:\n        task_vars = dict()\n    result = super(ActionModule, self).run(tmp, task_vars)\n    del tmp\n    source = self._task.args.get('src', None)\n    content = self._task.args.get('content', None)\n    dest = self._task.args.get('dest', None)\n    remote_src = boolean(self._task.args.get('remote_src', False), strict=False)\n    local_follow = boolean(self._task.args.get('local_follow', False), strict=False)\n    force = boolean(self._task.args.get('force', True), strict=False)\n    decrypt = boolean(self._task.args.get('decrypt', True), strict=False)\n    backup = boolean(self._task.args.get('backup', False), strict=False)\n    result['src'] = source\n    result['dest'] = dest\n    result['failed'] = True\n    if source is None and content is None or dest is None:\n        result['msg'] = 'src (or content) and dest are required'\n    elif source is not None and content is not None:\n        result['msg'] = 'src and content are mutually exclusive'\n    elif content is not None and dest is not None and (dest.endswith(os.path.sep) or dest.endswith(self.WIN_PATH_SEPARATOR)):\n        result['msg'] = 'dest must be a file if content is defined'\n    else:\n        del result['failed']\n    if result.get('failed'):\n        return result\n    content_tempfile = None\n    if content is not None:\n        try:\n            if isinstance(content, dict) or isinstance(content, list):\n                content_tempfile = self._create_content_tempfile(json.dumps(content))\n            else:\n                content_tempfile = self._create_content_tempfile(content)\n            source = content_tempfile\n        except Exception as err:\n            result['failed'] = True\n            result['msg'] = 'could not write content tmp file: %s' % to_native(err)\n            return result\n    elif remote_src:\n        new_module_args = self._task.args.copy()\n        new_module_args.update(dict(_copy_mode='remote', dest=dest, src=source, force=force, backup=backup))\n        new_module_args.pop('content', None)\n        result.update(self._execute_module(module_args=new_module_args, task_vars=task_vars))\n        return result\n    else:\n        trailing_slash = source.endswith(os.path.sep)\n        try:\n            source = self._find_needle('files', source)\n        except AnsibleError as e:\n            result['failed'] = True\n            result['msg'] = to_text(e)\n            result['exception'] = traceback.format_exc()\n            return result\n        if trailing_slash != source.endswith(os.path.sep):\n            if source[-1] == os.path.sep:\n                source = source[:-1]\n            else:\n                source = source + os.path.sep\n    source_files = {'files': [], 'directories': [], 'symlinks': []}\n    if os.path.isdir(to_bytes(source, errors='surrogate_or_strict')):\n        result['operation'] = 'folder_copy'\n        source_files = _walk_dirs(source, self._loader, decrypt=decrypt, local_follow=local_follow, trailing_slash_detector=self._connection._shell.path_has_trailing_slash, checksum_check=force)\n        if not self._connection._shell.path_has_trailing_slash(dest):\n            dest = '%s%s' % (dest, self.WIN_PATH_SEPARATOR)\n        check_dest = dest\n    else:\n        result['operation'] = 'file_copy'\n        try:\n            source_full = self._loader.get_real_file(source, decrypt=decrypt)\n        except AnsibleFileNotFound as e:\n            result['failed'] = True\n            result['msg'] = 'could not find src=%s, %s' % (source, to_text(e))\n            return result\n        original_basename = os.path.basename(source)\n        result['original_basename'] = original_basename\n        if self._connection._shell.path_has_trailing_slash(dest):\n            check_dest = dest\n            filename = original_basename\n            result['dest'] = self._connection._shell.join_path(dest, filename)\n        else:\n            unix_path = dest.replace(self.WIN_PATH_SEPARATOR, os.path.sep)\n            filename = os.path.basename(unix_path)\n            check_dest = os.path.dirname(unix_path)\n        file_checksum = _get_local_checksum(force, source_full)\n        source_files['files'].append(dict(src=source_full, dest=filename, checksum=file_checksum))\n        result['checksum'] = file_checksum\n        result['size'] = os.path.getsize(to_bytes(source_full, errors='surrogate_or_strict'))\n    query_args = self._task.args.copy()\n    query_args.update(dict(_copy_mode='query', dest=check_dest, force=force, files=source_files['files'], directories=source_files['directories'], symlinks=source_files['symlinks']))\n    query_args.pop('src', None)\n    query_args.pop('content', None)\n    query_return = self._execute_module(module_args=query_args, task_vars=task_vars)\n    if query_return.get('failed') is True:\n        result.update(query_return)\n        return result\n    if len(query_return['files']) > 0 or (len(query_return['directories']) > 0 and self._connection._shell.tmpdir is None):\n        self._connection._shell.tmpdir = self._make_tmp_path()\n    if len(query_return['files']) == 1 and len(query_return['directories']) == 0:\n        file_src = query_return['files'][0]['src']\n        file_dest = query_return['files'][0]['dest']\n        result.update(self._copy_single_file(file_src, dest, file_dest, task_vars, self._connection._shell.tmpdir, backup))\n        if result.get('failed') is True:\n            result['msg'] = 'failed to copy file %s: %s' % (file_src, result['msg'])\n        result['changed'] = True\n    elif len(query_return['files']) > 0 or len(query_return['directories']) > 0:\n        result.update(self._copy_zip_file(dest, source_files['files'], source_files['directories'], task_vars, self._connection._shell.tmpdir, backup))\n        result['changed'] = True\n    else:\n        result['failed'] = False\n        result['changed'] = False\n    self._remove_tempfile_if_content_defined(content, content_tempfile)\n    self._remove_tmp_path(self._connection._shell.tmpdir)\n    return result",
            "def run(self, tmp=None, task_vars=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ' handler for file transfer operations '\n    if task_vars is None:\n        task_vars = dict()\n    result = super(ActionModule, self).run(tmp, task_vars)\n    del tmp\n    source = self._task.args.get('src', None)\n    content = self._task.args.get('content', None)\n    dest = self._task.args.get('dest', None)\n    remote_src = boolean(self._task.args.get('remote_src', False), strict=False)\n    local_follow = boolean(self._task.args.get('local_follow', False), strict=False)\n    force = boolean(self._task.args.get('force', True), strict=False)\n    decrypt = boolean(self._task.args.get('decrypt', True), strict=False)\n    backup = boolean(self._task.args.get('backup', False), strict=False)\n    result['src'] = source\n    result['dest'] = dest\n    result['failed'] = True\n    if source is None and content is None or dest is None:\n        result['msg'] = 'src (or content) and dest are required'\n    elif source is not None and content is not None:\n        result['msg'] = 'src and content are mutually exclusive'\n    elif content is not None and dest is not None and (dest.endswith(os.path.sep) or dest.endswith(self.WIN_PATH_SEPARATOR)):\n        result['msg'] = 'dest must be a file if content is defined'\n    else:\n        del result['failed']\n    if result.get('failed'):\n        return result\n    content_tempfile = None\n    if content is not None:\n        try:\n            if isinstance(content, dict) or isinstance(content, list):\n                content_tempfile = self._create_content_tempfile(json.dumps(content))\n            else:\n                content_tempfile = self._create_content_tempfile(content)\n            source = content_tempfile\n        except Exception as err:\n            result['failed'] = True\n            result['msg'] = 'could not write content tmp file: %s' % to_native(err)\n            return result\n    elif remote_src:\n        new_module_args = self._task.args.copy()\n        new_module_args.update(dict(_copy_mode='remote', dest=dest, src=source, force=force, backup=backup))\n        new_module_args.pop('content', None)\n        result.update(self._execute_module(module_args=new_module_args, task_vars=task_vars))\n        return result\n    else:\n        trailing_slash = source.endswith(os.path.sep)\n        try:\n            source = self._find_needle('files', source)\n        except AnsibleError as e:\n            result['failed'] = True\n            result['msg'] = to_text(e)\n            result['exception'] = traceback.format_exc()\n            return result\n        if trailing_slash != source.endswith(os.path.sep):\n            if source[-1] == os.path.sep:\n                source = source[:-1]\n            else:\n                source = source + os.path.sep\n    source_files = {'files': [], 'directories': [], 'symlinks': []}\n    if os.path.isdir(to_bytes(source, errors='surrogate_or_strict')):\n        result['operation'] = 'folder_copy'\n        source_files = _walk_dirs(source, self._loader, decrypt=decrypt, local_follow=local_follow, trailing_slash_detector=self._connection._shell.path_has_trailing_slash, checksum_check=force)\n        if not self._connection._shell.path_has_trailing_slash(dest):\n            dest = '%s%s' % (dest, self.WIN_PATH_SEPARATOR)\n        check_dest = dest\n    else:\n        result['operation'] = 'file_copy'\n        try:\n            source_full = self._loader.get_real_file(source, decrypt=decrypt)\n        except AnsibleFileNotFound as e:\n            result['failed'] = True\n            result['msg'] = 'could not find src=%s, %s' % (source, to_text(e))\n            return result\n        original_basename = os.path.basename(source)\n        result['original_basename'] = original_basename\n        if self._connection._shell.path_has_trailing_slash(dest):\n            check_dest = dest\n            filename = original_basename\n            result['dest'] = self._connection._shell.join_path(dest, filename)\n        else:\n            unix_path = dest.replace(self.WIN_PATH_SEPARATOR, os.path.sep)\n            filename = os.path.basename(unix_path)\n            check_dest = os.path.dirname(unix_path)\n        file_checksum = _get_local_checksum(force, source_full)\n        source_files['files'].append(dict(src=source_full, dest=filename, checksum=file_checksum))\n        result['checksum'] = file_checksum\n        result['size'] = os.path.getsize(to_bytes(source_full, errors='surrogate_or_strict'))\n    query_args = self._task.args.copy()\n    query_args.update(dict(_copy_mode='query', dest=check_dest, force=force, files=source_files['files'], directories=source_files['directories'], symlinks=source_files['symlinks']))\n    query_args.pop('src', None)\n    query_args.pop('content', None)\n    query_return = self._execute_module(module_args=query_args, task_vars=task_vars)\n    if query_return.get('failed') is True:\n        result.update(query_return)\n        return result\n    if len(query_return['files']) > 0 or (len(query_return['directories']) > 0 and self._connection._shell.tmpdir is None):\n        self._connection._shell.tmpdir = self._make_tmp_path()\n    if len(query_return['files']) == 1 and len(query_return['directories']) == 0:\n        file_src = query_return['files'][0]['src']\n        file_dest = query_return['files'][0]['dest']\n        result.update(self._copy_single_file(file_src, dest, file_dest, task_vars, self._connection._shell.tmpdir, backup))\n        if result.get('failed') is True:\n            result['msg'] = 'failed to copy file %s: %s' % (file_src, result['msg'])\n        result['changed'] = True\n    elif len(query_return['files']) > 0 or len(query_return['directories']) > 0:\n        result.update(self._copy_zip_file(dest, source_files['files'], source_files['directories'], task_vars, self._connection._shell.tmpdir, backup))\n        result['changed'] = True\n    else:\n        result['failed'] = False\n        result['changed'] = False\n    self._remove_tempfile_if_content_defined(content, content_tempfile)\n    self._remove_tmp_path(self._connection._shell.tmpdir)\n    return result",
            "def run(self, tmp=None, task_vars=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ' handler for file transfer operations '\n    if task_vars is None:\n        task_vars = dict()\n    result = super(ActionModule, self).run(tmp, task_vars)\n    del tmp\n    source = self._task.args.get('src', None)\n    content = self._task.args.get('content', None)\n    dest = self._task.args.get('dest', None)\n    remote_src = boolean(self._task.args.get('remote_src', False), strict=False)\n    local_follow = boolean(self._task.args.get('local_follow', False), strict=False)\n    force = boolean(self._task.args.get('force', True), strict=False)\n    decrypt = boolean(self._task.args.get('decrypt', True), strict=False)\n    backup = boolean(self._task.args.get('backup', False), strict=False)\n    result['src'] = source\n    result['dest'] = dest\n    result['failed'] = True\n    if source is None and content is None or dest is None:\n        result['msg'] = 'src (or content) and dest are required'\n    elif source is not None and content is not None:\n        result['msg'] = 'src and content are mutually exclusive'\n    elif content is not None and dest is not None and (dest.endswith(os.path.sep) or dest.endswith(self.WIN_PATH_SEPARATOR)):\n        result['msg'] = 'dest must be a file if content is defined'\n    else:\n        del result['failed']\n    if result.get('failed'):\n        return result\n    content_tempfile = None\n    if content is not None:\n        try:\n            if isinstance(content, dict) or isinstance(content, list):\n                content_tempfile = self._create_content_tempfile(json.dumps(content))\n            else:\n                content_tempfile = self._create_content_tempfile(content)\n            source = content_tempfile\n        except Exception as err:\n            result['failed'] = True\n            result['msg'] = 'could not write content tmp file: %s' % to_native(err)\n            return result\n    elif remote_src:\n        new_module_args = self._task.args.copy()\n        new_module_args.update(dict(_copy_mode='remote', dest=dest, src=source, force=force, backup=backup))\n        new_module_args.pop('content', None)\n        result.update(self._execute_module(module_args=new_module_args, task_vars=task_vars))\n        return result\n    else:\n        trailing_slash = source.endswith(os.path.sep)\n        try:\n            source = self._find_needle('files', source)\n        except AnsibleError as e:\n            result['failed'] = True\n            result['msg'] = to_text(e)\n            result['exception'] = traceback.format_exc()\n            return result\n        if trailing_slash != source.endswith(os.path.sep):\n            if source[-1] == os.path.sep:\n                source = source[:-1]\n            else:\n                source = source + os.path.sep\n    source_files = {'files': [], 'directories': [], 'symlinks': []}\n    if os.path.isdir(to_bytes(source, errors='surrogate_or_strict')):\n        result['operation'] = 'folder_copy'\n        source_files = _walk_dirs(source, self._loader, decrypt=decrypt, local_follow=local_follow, trailing_slash_detector=self._connection._shell.path_has_trailing_slash, checksum_check=force)\n        if not self._connection._shell.path_has_trailing_slash(dest):\n            dest = '%s%s' % (dest, self.WIN_PATH_SEPARATOR)\n        check_dest = dest\n    else:\n        result['operation'] = 'file_copy'\n        try:\n            source_full = self._loader.get_real_file(source, decrypt=decrypt)\n        except AnsibleFileNotFound as e:\n            result['failed'] = True\n            result['msg'] = 'could not find src=%s, %s' % (source, to_text(e))\n            return result\n        original_basename = os.path.basename(source)\n        result['original_basename'] = original_basename\n        if self._connection._shell.path_has_trailing_slash(dest):\n            check_dest = dest\n            filename = original_basename\n            result['dest'] = self._connection._shell.join_path(dest, filename)\n        else:\n            unix_path = dest.replace(self.WIN_PATH_SEPARATOR, os.path.sep)\n            filename = os.path.basename(unix_path)\n            check_dest = os.path.dirname(unix_path)\n        file_checksum = _get_local_checksum(force, source_full)\n        source_files['files'].append(dict(src=source_full, dest=filename, checksum=file_checksum))\n        result['checksum'] = file_checksum\n        result['size'] = os.path.getsize(to_bytes(source_full, errors='surrogate_or_strict'))\n    query_args = self._task.args.copy()\n    query_args.update(dict(_copy_mode='query', dest=check_dest, force=force, files=source_files['files'], directories=source_files['directories'], symlinks=source_files['symlinks']))\n    query_args.pop('src', None)\n    query_args.pop('content', None)\n    query_return = self._execute_module(module_args=query_args, task_vars=task_vars)\n    if query_return.get('failed') is True:\n        result.update(query_return)\n        return result\n    if len(query_return['files']) > 0 or (len(query_return['directories']) > 0 and self._connection._shell.tmpdir is None):\n        self._connection._shell.tmpdir = self._make_tmp_path()\n    if len(query_return['files']) == 1 and len(query_return['directories']) == 0:\n        file_src = query_return['files'][0]['src']\n        file_dest = query_return['files'][0]['dest']\n        result.update(self._copy_single_file(file_src, dest, file_dest, task_vars, self._connection._shell.tmpdir, backup))\n        if result.get('failed') is True:\n            result['msg'] = 'failed to copy file %s: %s' % (file_src, result['msg'])\n        result['changed'] = True\n    elif len(query_return['files']) > 0 or len(query_return['directories']) > 0:\n        result.update(self._copy_zip_file(dest, source_files['files'], source_files['directories'], task_vars, self._connection._shell.tmpdir, backup))\n        result['changed'] = True\n    else:\n        result['failed'] = False\n        result['changed'] = False\n    self._remove_tempfile_if_content_defined(content, content_tempfile)\n    self._remove_tmp_path(self._connection._shell.tmpdir)\n    return result",
            "def run(self, tmp=None, task_vars=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ' handler for file transfer operations '\n    if task_vars is None:\n        task_vars = dict()\n    result = super(ActionModule, self).run(tmp, task_vars)\n    del tmp\n    source = self._task.args.get('src', None)\n    content = self._task.args.get('content', None)\n    dest = self._task.args.get('dest', None)\n    remote_src = boolean(self._task.args.get('remote_src', False), strict=False)\n    local_follow = boolean(self._task.args.get('local_follow', False), strict=False)\n    force = boolean(self._task.args.get('force', True), strict=False)\n    decrypt = boolean(self._task.args.get('decrypt', True), strict=False)\n    backup = boolean(self._task.args.get('backup', False), strict=False)\n    result['src'] = source\n    result['dest'] = dest\n    result['failed'] = True\n    if source is None and content is None or dest is None:\n        result['msg'] = 'src (or content) and dest are required'\n    elif source is not None and content is not None:\n        result['msg'] = 'src and content are mutually exclusive'\n    elif content is not None and dest is not None and (dest.endswith(os.path.sep) or dest.endswith(self.WIN_PATH_SEPARATOR)):\n        result['msg'] = 'dest must be a file if content is defined'\n    else:\n        del result['failed']\n    if result.get('failed'):\n        return result\n    content_tempfile = None\n    if content is not None:\n        try:\n            if isinstance(content, dict) or isinstance(content, list):\n                content_tempfile = self._create_content_tempfile(json.dumps(content))\n            else:\n                content_tempfile = self._create_content_tempfile(content)\n            source = content_tempfile\n        except Exception as err:\n            result['failed'] = True\n            result['msg'] = 'could not write content tmp file: %s' % to_native(err)\n            return result\n    elif remote_src:\n        new_module_args = self._task.args.copy()\n        new_module_args.update(dict(_copy_mode='remote', dest=dest, src=source, force=force, backup=backup))\n        new_module_args.pop('content', None)\n        result.update(self._execute_module(module_args=new_module_args, task_vars=task_vars))\n        return result\n    else:\n        trailing_slash = source.endswith(os.path.sep)\n        try:\n            source = self._find_needle('files', source)\n        except AnsibleError as e:\n            result['failed'] = True\n            result['msg'] = to_text(e)\n            result['exception'] = traceback.format_exc()\n            return result\n        if trailing_slash != source.endswith(os.path.sep):\n            if source[-1] == os.path.sep:\n                source = source[:-1]\n            else:\n                source = source + os.path.sep\n    source_files = {'files': [], 'directories': [], 'symlinks': []}\n    if os.path.isdir(to_bytes(source, errors='surrogate_or_strict')):\n        result['operation'] = 'folder_copy'\n        source_files = _walk_dirs(source, self._loader, decrypt=decrypt, local_follow=local_follow, trailing_slash_detector=self._connection._shell.path_has_trailing_slash, checksum_check=force)\n        if not self._connection._shell.path_has_trailing_slash(dest):\n            dest = '%s%s' % (dest, self.WIN_PATH_SEPARATOR)\n        check_dest = dest\n    else:\n        result['operation'] = 'file_copy'\n        try:\n            source_full = self._loader.get_real_file(source, decrypt=decrypt)\n        except AnsibleFileNotFound as e:\n            result['failed'] = True\n            result['msg'] = 'could not find src=%s, %s' % (source, to_text(e))\n            return result\n        original_basename = os.path.basename(source)\n        result['original_basename'] = original_basename\n        if self._connection._shell.path_has_trailing_slash(dest):\n            check_dest = dest\n            filename = original_basename\n            result['dest'] = self._connection._shell.join_path(dest, filename)\n        else:\n            unix_path = dest.replace(self.WIN_PATH_SEPARATOR, os.path.sep)\n            filename = os.path.basename(unix_path)\n            check_dest = os.path.dirname(unix_path)\n        file_checksum = _get_local_checksum(force, source_full)\n        source_files['files'].append(dict(src=source_full, dest=filename, checksum=file_checksum))\n        result['checksum'] = file_checksum\n        result['size'] = os.path.getsize(to_bytes(source_full, errors='surrogate_or_strict'))\n    query_args = self._task.args.copy()\n    query_args.update(dict(_copy_mode='query', dest=check_dest, force=force, files=source_files['files'], directories=source_files['directories'], symlinks=source_files['symlinks']))\n    query_args.pop('src', None)\n    query_args.pop('content', None)\n    query_return = self._execute_module(module_args=query_args, task_vars=task_vars)\n    if query_return.get('failed') is True:\n        result.update(query_return)\n        return result\n    if len(query_return['files']) > 0 or (len(query_return['directories']) > 0 and self._connection._shell.tmpdir is None):\n        self._connection._shell.tmpdir = self._make_tmp_path()\n    if len(query_return['files']) == 1 and len(query_return['directories']) == 0:\n        file_src = query_return['files'][0]['src']\n        file_dest = query_return['files'][0]['dest']\n        result.update(self._copy_single_file(file_src, dest, file_dest, task_vars, self._connection._shell.tmpdir, backup))\n        if result.get('failed') is True:\n            result['msg'] = 'failed to copy file %s: %s' % (file_src, result['msg'])\n        result['changed'] = True\n    elif len(query_return['files']) > 0 or len(query_return['directories']) > 0:\n        result.update(self._copy_zip_file(dest, source_files['files'], source_files['directories'], task_vars, self._connection._shell.tmpdir, backup))\n        result['changed'] = True\n    else:\n        result['failed'] = False\n        result['changed'] = False\n    self._remove_tempfile_if_content_defined(content, content_tempfile)\n    self._remove_tmp_path(self._connection._shell.tmpdir)\n    return result",
            "def run(self, tmp=None, task_vars=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ' handler for file transfer operations '\n    if task_vars is None:\n        task_vars = dict()\n    result = super(ActionModule, self).run(tmp, task_vars)\n    del tmp\n    source = self._task.args.get('src', None)\n    content = self._task.args.get('content', None)\n    dest = self._task.args.get('dest', None)\n    remote_src = boolean(self._task.args.get('remote_src', False), strict=False)\n    local_follow = boolean(self._task.args.get('local_follow', False), strict=False)\n    force = boolean(self._task.args.get('force', True), strict=False)\n    decrypt = boolean(self._task.args.get('decrypt', True), strict=False)\n    backup = boolean(self._task.args.get('backup', False), strict=False)\n    result['src'] = source\n    result['dest'] = dest\n    result['failed'] = True\n    if source is None and content is None or dest is None:\n        result['msg'] = 'src (or content) and dest are required'\n    elif source is not None and content is not None:\n        result['msg'] = 'src and content are mutually exclusive'\n    elif content is not None and dest is not None and (dest.endswith(os.path.sep) or dest.endswith(self.WIN_PATH_SEPARATOR)):\n        result['msg'] = 'dest must be a file if content is defined'\n    else:\n        del result['failed']\n    if result.get('failed'):\n        return result\n    content_tempfile = None\n    if content is not None:\n        try:\n            if isinstance(content, dict) or isinstance(content, list):\n                content_tempfile = self._create_content_tempfile(json.dumps(content))\n            else:\n                content_tempfile = self._create_content_tempfile(content)\n            source = content_tempfile\n        except Exception as err:\n            result['failed'] = True\n            result['msg'] = 'could not write content tmp file: %s' % to_native(err)\n            return result\n    elif remote_src:\n        new_module_args = self._task.args.copy()\n        new_module_args.update(dict(_copy_mode='remote', dest=dest, src=source, force=force, backup=backup))\n        new_module_args.pop('content', None)\n        result.update(self._execute_module(module_args=new_module_args, task_vars=task_vars))\n        return result\n    else:\n        trailing_slash = source.endswith(os.path.sep)\n        try:\n            source = self._find_needle('files', source)\n        except AnsibleError as e:\n            result['failed'] = True\n            result['msg'] = to_text(e)\n            result['exception'] = traceback.format_exc()\n            return result\n        if trailing_slash != source.endswith(os.path.sep):\n            if source[-1] == os.path.sep:\n                source = source[:-1]\n            else:\n                source = source + os.path.sep\n    source_files = {'files': [], 'directories': [], 'symlinks': []}\n    if os.path.isdir(to_bytes(source, errors='surrogate_or_strict')):\n        result['operation'] = 'folder_copy'\n        source_files = _walk_dirs(source, self._loader, decrypt=decrypt, local_follow=local_follow, trailing_slash_detector=self._connection._shell.path_has_trailing_slash, checksum_check=force)\n        if not self._connection._shell.path_has_trailing_slash(dest):\n            dest = '%s%s' % (dest, self.WIN_PATH_SEPARATOR)\n        check_dest = dest\n    else:\n        result['operation'] = 'file_copy'\n        try:\n            source_full = self._loader.get_real_file(source, decrypt=decrypt)\n        except AnsibleFileNotFound as e:\n            result['failed'] = True\n            result['msg'] = 'could not find src=%s, %s' % (source, to_text(e))\n            return result\n        original_basename = os.path.basename(source)\n        result['original_basename'] = original_basename\n        if self._connection._shell.path_has_trailing_slash(dest):\n            check_dest = dest\n            filename = original_basename\n            result['dest'] = self._connection._shell.join_path(dest, filename)\n        else:\n            unix_path = dest.replace(self.WIN_PATH_SEPARATOR, os.path.sep)\n            filename = os.path.basename(unix_path)\n            check_dest = os.path.dirname(unix_path)\n        file_checksum = _get_local_checksum(force, source_full)\n        source_files['files'].append(dict(src=source_full, dest=filename, checksum=file_checksum))\n        result['checksum'] = file_checksum\n        result['size'] = os.path.getsize(to_bytes(source_full, errors='surrogate_or_strict'))\n    query_args = self._task.args.copy()\n    query_args.update(dict(_copy_mode='query', dest=check_dest, force=force, files=source_files['files'], directories=source_files['directories'], symlinks=source_files['symlinks']))\n    query_args.pop('src', None)\n    query_args.pop('content', None)\n    query_return = self._execute_module(module_args=query_args, task_vars=task_vars)\n    if query_return.get('failed') is True:\n        result.update(query_return)\n        return result\n    if len(query_return['files']) > 0 or (len(query_return['directories']) > 0 and self._connection._shell.tmpdir is None):\n        self._connection._shell.tmpdir = self._make_tmp_path()\n    if len(query_return['files']) == 1 and len(query_return['directories']) == 0:\n        file_src = query_return['files'][0]['src']\n        file_dest = query_return['files'][0]['dest']\n        result.update(self._copy_single_file(file_src, dest, file_dest, task_vars, self._connection._shell.tmpdir, backup))\n        if result.get('failed') is True:\n            result['msg'] = 'failed to copy file %s: %s' % (file_src, result['msg'])\n        result['changed'] = True\n    elif len(query_return['files']) > 0 or len(query_return['directories']) > 0:\n        result.update(self._copy_zip_file(dest, source_files['files'], source_files['directories'], task_vars, self._connection._shell.tmpdir, backup))\n        result['changed'] = True\n    else:\n        result['failed'] = False\n        result['changed'] = False\n    self._remove_tempfile_if_content_defined(content, content_tempfile)\n    self._remove_tmp_path(self._connection._shell.tmpdir)\n    return result"
        ]
    }
]