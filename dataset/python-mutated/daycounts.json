[
    {
        "func_name": "actual_360",
        "original": "def actual_360(*, start_date, end_date, schedule_info=None, dtype=None, name=None):\n    \"\"\"Computes the year fraction between the specified dates.\n\n  The actual/360 convention specifies the year fraction between the start and\n  end date as the actual number of days between the two dates divided by 360.\n\n  Note that the schedule info is not needed for this convention and is ignored\n  if supplied.\n\n  For more details see:\n  https://en.wikipedia.org/wiki/Day_count_convention#Actual/360\n\n  Args:\n    start_date: A `DateTensor` object of any shape.\n    end_date: A `DateTensor` object of compatible shape with `start_date`.\n    schedule_info: The schedule info. Ignored for this convention.\n    dtype: The dtype of the result. Either `tf.float32` or `tf.float64`. If not\n      supplied, `tf.float32` is returned.\n    name: Python `str` name prefixed to ops created by this function. If not\n      supplied, `actual_360` is used.\n\n  Returns:\n    A real `Tensor` of supplied `dtype` and shape of `start_date`. The year\n    fraction between the start and end date as computed by Actual/360\n    convention.\n  \"\"\"\n    del schedule_info\n    with tf.name_scope(name or 'actual_360'):\n        end_date = dt.convert_to_date_tensor(end_date)\n        start_date = dt.convert_to_date_tensor(start_date)\n        dtype = dtype or tf.constant(0.0).dtype\n        actual_days = tf.cast(start_date.days_until(end_date), dtype=dtype)\n        return actual_days / 360",
        "mutated": [
            "def actual_360(*, start_date, end_date, schedule_info=None, dtype=None, name=None):\n    if False:\n        i = 10\n    'Computes the year fraction between the specified dates.\\n\\n  The actual/360 convention specifies the year fraction between the start and\\n  end date as the actual number of days between the two dates divided by 360.\\n\\n  Note that the schedule info is not needed for this convention and is ignored\\n  if supplied.\\n\\n  For more details see:\\n  https://en.wikipedia.org/wiki/Day_count_convention#Actual/360\\n\\n  Args:\\n    start_date: A `DateTensor` object of any shape.\\n    end_date: A `DateTensor` object of compatible shape with `start_date`.\\n    schedule_info: The schedule info. Ignored for this convention.\\n    dtype: The dtype of the result. Either `tf.float32` or `tf.float64`. If not\\n      supplied, `tf.float32` is returned.\\n    name: Python `str` name prefixed to ops created by this function. If not\\n      supplied, `actual_360` is used.\\n\\n  Returns:\\n    A real `Tensor` of supplied `dtype` and shape of `start_date`. The year\\n    fraction between the start and end date as computed by Actual/360\\n    convention.\\n  '\n    del schedule_info\n    with tf.name_scope(name or 'actual_360'):\n        end_date = dt.convert_to_date_tensor(end_date)\n        start_date = dt.convert_to_date_tensor(start_date)\n        dtype = dtype or tf.constant(0.0).dtype\n        actual_days = tf.cast(start_date.days_until(end_date), dtype=dtype)\n        return actual_days / 360",
            "def actual_360(*, start_date, end_date, schedule_info=None, dtype=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Computes the year fraction between the specified dates.\\n\\n  The actual/360 convention specifies the year fraction between the start and\\n  end date as the actual number of days between the two dates divided by 360.\\n\\n  Note that the schedule info is not needed for this convention and is ignored\\n  if supplied.\\n\\n  For more details see:\\n  https://en.wikipedia.org/wiki/Day_count_convention#Actual/360\\n\\n  Args:\\n    start_date: A `DateTensor` object of any shape.\\n    end_date: A `DateTensor` object of compatible shape with `start_date`.\\n    schedule_info: The schedule info. Ignored for this convention.\\n    dtype: The dtype of the result. Either `tf.float32` or `tf.float64`. If not\\n      supplied, `tf.float32` is returned.\\n    name: Python `str` name prefixed to ops created by this function. If not\\n      supplied, `actual_360` is used.\\n\\n  Returns:\\n    A real `Tensor` of supplied `dtype` and shape of `start_date`. The year\\n    fraction between the start and end date as computed by Actual/360\\n    convention.\\n  '\n    del schedule_info\n    with tf.name_scope(name or 'actual_360'):\n        end_date = dt.convert_to_date_tensor(end_date)\n        start_date = dt.convert_to_date_tensor(start_date)\n        dtype = dtype or tf.constant(0.0).dtype\n        actual_days = tf.cast(start_date.days_until(end_date), dtype=dtype)\n        return actual_days / 360",
            "def actual_360(*, start_date, end_date, schedule_info=None, dtype=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Computes the year fraction between the specified dates.\\n\\n  The actual/360 convention specifies the year fraction between the start and\\n  end date as the actual number of days between the two dates divided by 360.\\n\\n  Note that the schedule info is not needed for this convention and is ignored\\n  if supplied.\\n\\n  For more details see:\\n  https://en.wikipedia.org/wiki/Day_count_convention#Actual/360\\n\\n  Args:\\n    start_date: A `DateTensor` object of any shape.\\n    end_date: A `DateTensor` object of compatible shape with `start_date`.\\n    schedule_info: The schedule info. Ignored for this convention.\\n    dtype: The dtype of the result. Either `tf.float32` or `tf.float64`. If not\\n      supplied, `tf.float32` is returned.\\n    name: Python `str` name prefixed to ops created by this function. If not\\n      supplied, `actual_360` is used.\\n\\n  Returns:\\n    A real `Tensor` of supplied `dtype` and shape of `start_date`. The year\\n    fraction between the start and end date as computed by Actual/360\\n    convention.\\n  '\n    del schedule_info\n    with tf.name_scope(name or 'actual_360'):\n        end_date = dt.convert_to_date_tensor(end_date)\n        start_date = dt.convert_to_date_tensor(start_date)\n        dtype = dtype or tf.constant(0.0).dtype\n        actual_days = tf.cast(start_date.days_until(end_date), dtype=dtype)\n        return actual_days / 360",
            "def actual_360(*, start_date, end_date, schedule_info=None, dtype=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Computes the year fraction between the specified dates.\\n\\n  The actual/360 convention specifies the year fraction between the start and\\n  end date as the actual number of days between the two dates divided by 360.\\n\\n  Note that the schedule info is not needed for this convention and is ignored\\n  if supplied.\\n\\n  For more details see:\\n  https://en.wikipedia.org/wiki/Day_count_convention#Actual/360\\n\\n  Args:\\n    start_date: A `DateTensor` object of any shape.\\n    end_date: A `DateTensor` object of compatible shape with `start_date`.\\n    schedule_info: The schedule info. Ignored for this convention.\\n    dtype: The dtype of the result. Either `tf.float32` or `tf.float64`. If not\\n      supplied, `tf.float32` is returned.\\n    name: Python `str` name prefixed to ops created by this function. If not\\n      supplied, `actual_360` is used.\\n\\n  Returns:\\n    A real `Tensor` of supplied `dtype` and shape of `start_date`. The year\\n    fraction between the start and end date as computed by Actual/360\\n    convention.\\n  '\n    del schedule_info\n    with tf.name_scope(name or 'actual_360'):\n        end_date = dt.convert_to_date_tensor(end_date)\n        start_date = dt.convert_to_date_tensor(start_date)\n        dtype = dtype or tf.constant(0.0).dtype\n        actual_days = tf.cast(start_date.days_until(end_date), dtype=dtype)\n        return actual_days / 360",
            "def actual_360(*, start_date, end_date, schedule_info=None, dtype=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Computes the year fraction between the specified dates.\\n\\n  The actual/360 convention specifies the year fraction between the start and\\n  end date as the actual number of days between the two dates divided by 360.\\n\\n  Note that the schedule info is not needed for this convention and is ignored\\n  if supplied.\\n\\n  For more details see:\\n  https://en.wikipedia.org/wiki/Day_count_convention#Actual/360\\n\\n  Args:\\n    start_date: A `DateTensor` object of any shape.\\n    end_date: A `DateTensor` object of compatible shape with `start_date`.\\n    schedule_info: The schedule info. Ignored for this convention.\\n    dtype: The dtype of the result. Either `tf.float32` or `tf.float64`. If not\\n      supplied, `tf.float32` is returned.\\n    name: Python `str` name prefixed to ops created by this function. If not\\n      supplied, `actual_360` is used.\\n\\n  Returns:\\n    A real `Tensor` of supplied `dtype` and shape of `start_date`. The year\\n    fraction between the start and end date as computed by Actual/360\\n    convention.\\n  '\n    del schedule_info\n    with tf.name_scope(name or 'actual_360'):\n        end_date = dt.convert_to_date_tensor(end_date)\n        start_date = dt.convert_to_date_tensor(start_date)\n        dtype = dtype or tf.constant(0.0).dtype\n        actual_days = tf.cast(start_date.days_until(end_date), dtype=dtype)\n        return actual_days / 360"
        ]
    },
    {
        "func_name": "actual_365_fixed",
        "original": "def actual_365_fixed(*, start_date, end_date, schedule_info=None, dtype=None, name=None):\n    \"\"\"Computes the year fraction between the specified dates.\n\n  The actual/365 convention specifies the year fraction between the start and\n  end date as the actual number of days between the two dates divided by 365.\n\n  Note that the schedule info is not needed for this convention and is ignored\n  if supplied.\n\n  For more details see:\n  https://en.wikipedia.org/wiki/Day_count_convention#Actual/365_Fixed\n\n  Args:\n    start_date: A `DateTensor` object of any shape.\n    end_date: A `DateTensor` object of compatible shape with `start_date`.\n    schedule_info: The schedule info. Ignored for this convention.\n    dtype: The dtype of the result. Either `tf.float32` or `tf.float64`. If not\n      supplied, `tf.float32` is returned.\n    name: Python `str` name prefixed to ops created by this function. If not\n      supplied, `actual_365_fixed` is used.\n\n  Returns:\n    A real `Tensor` of supplied `dtype` and shape of `start_date`. The year\n    fraction between the start and end date as computed by Actual/365 fixed\n    convention.\n  \"\"\"\n    del schedule_info\n    with tf.name_scope(name or 'actual_365_fixed'):\n        end_date = dt.convert_to_date_tensor(end_date)\n        start_date = dt.convert_to_date_tensor(start_date)\n        dtype = dtype or tf.constant(0.0).dtype\n        actual_days = tf.cast(start_date.days_until(end_date), dtype=dtype)\n        return actual_days / 365",
        "mutated": [
            "def actual_365_fixed(*, start_date, end_date, schedule_info=None, dtype=None, name=None):\n    if False:\n        i = 10\n    'Computes the year fraction between the specified dates.\\n\\n  The actual/365 convention specifies the year fraction between the start and\\n  end date as the actual number of days between the two dates divided by 365.\\n\\n  Note that the schedule info is not needed for this convention and is ignored\\n  if supplied.\\n\\n  For more details see:\\n  https://en.wikipedia.org/wiki/Day_count_convention#Actual/365_Fixed\\n\\n  Args:\\n    start_date: A `DateTensor` object of any shape.\\n    end_date: A `DateTensor` object of compatible shape with `start_date`.\\n    schedule_info: The schedule info. Ignored for this convention.\\n    dtype: The dtype of the result. Either `tf.float32` or `tf.float64`. If not\\n      supplied, `tf.float32` is returned.\\n    name: Python `str` name prefixed to ops created by this function. If not\\n      supplied, `actual_365_fixed` is used.\\n\\n  Returns:\\n    A real `Tensor` of supplied `dtype` and shape of `start_date`. The year\\n    fraction between the start and end date as computed by Actual/365 fixed\\n    convention.\\n  '\n    del schedule_info\n    with tf.name_scope(name or 'actual_365_fixed'):\n        end_date = dt.convert_to_date_tensor(end_date)\n        start_date = dt.convert_to_date_tensor(start_date)\n        dtype = dtype or tf.constant(0.0).dtype\n        actual_days = tf.cast(start_date.days_until(end_date), dtype=dtype)\n        return actual_days / 365",
            "def actual_365_fixed(*, start_date, end_date, schedule_info=None, dtype=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Computes the year fraction between the specified dates.\\n\\n  The actual/365 convention specifies the year fraction between the start and\\n  end date as the actual number of days between the two dates divided by 365.\\n\\n  Note that the schedule info is not needed for this convention and is ignored\\n  if supplied.\\n\\n  For more details see:\\n  https://en.wikipedia.org/wiki/Day_count_convention#Actual/365_Fixed\\n\\n  Args:\\n    start_date: A `DateTensor` object of any shape.\\n    end_date: A `DateTensor` object of compatible shape with `start_date`.\\n    schedule_info: The schedule info. Ignored for this convention.\\n    dtype: The dtype of the result. Either `tf.float32` or `tf.float64`. If not\\n      supplied, `tf.float32` is returned.\\n    name: Python `str` name prefixed to ops created by this function. If not\\n      supplied, `actual_365_fixed` is used.\\n\\n  Returns:\\n    A real `Tensor` of supplied `dtype` and shape of `start_date`. The year\\n    fraction between the start and end date as computed by Actual/365 fixed\\n    convention.\\n  '\n    del schedule_info\n    with tf.name_scope(name or 'actual_365_fixed'):\n        end_date = dt.convert_to_date_tensor(end_date)\n        start_date = dt.convert_to_date_tensor(start_date)\n        dtype = dtype or tf.constant(0.0).dtype\n        actual_days = tf.cast(start_date.days_until(end_date), dtype=dtype)\n        return actual_days / 365",
            "def actual_365_fixed(*, start_date, end_date, schedule_info=None, dtype=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Computes the year fraction between the specified dates.\\n\\n  The actual/365 convention specifies the year fraction between the start and\\n  end date as the actual number of days between the two dates divided by 365.\\n\\n  Note that the schedule info is not needed for this convention and is ignored\\n  if supplied.\\n\\n  For more details see:\\n  https://en.wikipedia.org/wiki/Day_count_convention#Actual/365_Fixed\\n\\n  Args:\\n    start_date: A `DateTensor` object of any shape.\\n    end_date: A `DateTensor` object of compatible shape with `start_date`.\\n    schedule_info: The schedule info. Ignored for this convention.\\n    dtype: The dtype of the result. Either `tf.float32` or `tf.float64`. If not\\n      supplied, `tf.float32` is returned.\\n    name: Python `str` name prefixed to ops created by this function. If not\\n      supplied, `actual_365_fixed` is used.\\n\\n  Returns:\\n    A real `Tensor` of supplied `dtype` and shape of `start_date`. The year\\n    fraction between the start and end date as computed by Actual/365 fixed\\n    convention.\\n  '\n    del schedule_info\n    with tf.name_scope(name or 'actual_365_fixed'):\n        end_date = dt.convert_to_date_tensor(end_date)\n        start_date = dt.convert_to_date_tensor(start_date)\n        dtype = dtype or tf.constant(0.0).dtype\n        actual_days = tf.cast(start_date.days_until(end_date), dtype=dtype)\n        return actual_days / 365",
            "def actual_365_fixed(*, start_date, end_date, schedule_info=None, dtype=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Computes the year fraction between the specified dates.\\n\\n  The actual/365 convention specifies the year fraction between the start and\\n  end date as the actual number of days between the two dates divided by 365.\\n\\n  Note that the schedule info is not needed for this convention and is ignored\\n  if supplied.\\n\\n  For more details see:\\n  https://en.wikipedia.org/wiki/Day_count_convention#Actual/365_Fixed\\n\\n  Args:\\n    start_date: A `DateTensor` object of any shape.\\n    end_date: A `DateTensor` object of compatible shape with `start_date`.\\n    schedule_info: The schedule info. Ignored for this convention.\\n    dtype: The dtype of the result. Either `tf.float32` or `tf.float64`. If not\\n      supplied, `tf.float32` is returned.\\n    name: Python `str` name prefixed to ops created by this function. If not\\n      supplied, `actual_365_fixed` is used.\\n\\n  Returns:\\n    A real `Tensor` of supplied `dtype` and shape of `start_date`. The year\\n    fraction between the start and end date as computed by Actual/365 fixed\\n    convention.\\n  '\n    del schedule_info\n    with tf.name_scope(name or 'actual_365_fixed'):\n        end_date = dt.convert_to_date_tensor(end_date)\n        start_date = dt.convert_to_date_tensor(start_date)\n        dtype = dtype or tf.constant(0.0).dtype\n        actual_days = tf.cast(start_date.days_until(end_date), dtype=dtype)\n        return actual_days / 365",
            "def actual_365_fixed(*, start_date, end_date, schedule_info=None, dtype=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Computes the year fraction between the specified dates.\\n\\n  The actual/365 convention specifies the year fraction between the start and\\n  end date as the actual number of days between the two dates divided by 365.\\n\\n  Note that the schedule info is not needed for this convention and is ignored\\n  if supplied.\\n\\n  For more details see:\\n  https://en.wikipedia.org/wiki/Day_count_convention#Actual/365_Fixed\\n\\n  Args:\\n    start_date: A `DateTensor` object of any shape.\\n    end_date: A `DateTensor` object of compatible shape with `start_date`.\\n    schedule_info: The schedule info. Ignored for this convention.\\n    dtype: The dtype of the result. Either `tf.float32` or `tf.float64`. If not\\n      supplied, `tf.float32` is returned.\\n    name: Python `str` name prefixed to ops created by this function. If not\\n      supplied, `actual_365_fixed` is used.\\n\\n  Returns:\\n    A real `Tensor` of supplied `dtype` and shape of `start_date`. The year\\n    fraction between the start and end date as computed by Actual/365 fixed\\n    convention.\\n  '\n    del schedule_info\n    with tf.name_scope(name or 'actual_365_fixed'):\n        end_date = dt.convert_to_date_tensor(end_date)\n        start_date = dt.convert_to_date_tensor(start_date)\n        dtype = dtype or tf.constant(0.0).dtype\n        actual_days = tf.cast(start_date.days_until(end_date), dtype=dtype)\n        return actual_days / 365"
        ]
    },
    {
        "func_name": "actual_365_actual",
        "original": "def actual_365_actual(*, start_date, end_date, schedule_info=None, dtype=None, name=None):\n    \"\"\"Computes the year fraction between the specified dates.\n\n  The actual/365 actual convention specifies the year fraction between the\n  start and end date as the actual number of days between the two dates divided\n  365 if no leap day is contained in the date range and 366 otherwise.\n\n  When determining whether a leap day is contained in the date range,\n  `start_date` is excluded and `end_date` is included.\n\n  Note that the schedule info is not needed for this convention and is ignored\n  if supplied.\n\n  Args:\n    start_date: A `DateTensor` object of any shape.\n    end_date: A `DateTensor` object of compatible shape with `start_date`.\n    schedule_info: The schedule info. Ignored for this convention.\n    dtype: The dtype of the result. Either `tf.float32` or `tf.float64`. If not\n      supplied, `tf.float32` is returned.\n    name: Python `str` name prefixed to ops created by this function. If not\n      supplied, `actual_365_actual` is used.\n\n  Returns:\n    A real `Tensor` of supplied `dtype` and shape of `start_date`. The year\n    fraction between the start and end date as computed by Actual/365 Actual\n    convention.\n  \"\"\"\n    del schedule_info\n    with tf.name_scope(name or 'actual_365_actual'):\n        end_date = dt.convert_to_date_tensor(end_date)\n        start_date = dt.convert_to_date_tensor(start_date)\n        dtype = dtype or tf.constant(0.0).dtype\n        actual_days = tf.cast(start_date.days_until(end_date), dtype=dtype)\n        day = periods.day()\n        leap_days_between = du.leap_days_between(start_date=start_date + day, end_date=end_date + day)\n        denominator = tf.cast(tf.where(leap_days_between > 0, 366, 365), dtype=dtype)\n        return actual_days / denominator",
        "mutated": [
            "def actual_365_actual(*, start_date, end_date, schedule_info=None, dtype=None, name=None):\n    if False:\n        i = 10\n    'Computes the year fraction between the specified dates.\\n\\n  The actual/365 actual convention specifies the year fraction between the\\n  start and end date as the actual number of days between the two dates divided\\n  365 if no leap day is contained in the date range and 366 otherwise.\\n\\n  When determining whether a leap day is contained in the date range,\\n  `start_date` is excluded and `end_date` is included.\\n\\n  Note that the schedule info is not needed for this convention and is ignored\\n  if supplied.\\n\\n  Args:\\n    start_date: A `DateTensor` object of any shape.\\n    end_date: A `DateTensor` object of compatible shape with `start_date`.\\n    schedule_info: The schedule info. Ignored for this convention.\\n    dtype: The dtype of the result. Either `tf.float32` or `tf.float64`. If not\\n      supplied, `tf.float32` is returned.\\n    name: Python `str` name prefixed to ops created by this function. If not\\n      supplied, `actual_365_actual` is used.\\n\\n  Returns:\\n    A real `Tensor` of supplied `dtype` and shape of `start_date`. The year\\n    fraction between the start and end date as computed by Actual/365 Actual\\n    convention.\\n  '\n    del schedule_info\n    with tf.name_scope(name or 'actual_365_actual'):\n        end_date = dt.convert_to_date_tensor(end_date)\n        start_date = dt.convert_to_date_tensor(start_date)\n        dtype = dtype or tf.constant(0.0).dtype\n        actual_days = tf.cast(start_date.days_until(end_date), dtype=dtype)\n        day = periods.day()\n        leap_days_between = du.leap_days_between(start_date=start_date + day, end_date=end_date + day)\n        denominator = tf.cast(tf.where(leap_days_between > 0, 366, 365), dtype=dtype)\n        return actual_days / denominator",
            "def actual_365_actual(*, start_date, end_date, schedule_info=None, dtype=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Computes the year fraction between the specified dates.\\n\\n  The actual/365 actual convention specifies the year fraction between the\\n  start and end date as the actual number of days between the two dates divided\\n  365 if no leap day is contained in the date range and 366 otherwise.\\n\\n  When determining whether a leap day is contained in the date range,\\n  `start_date` is excluded and `end_date` is included.\\n\\n  Note that the schedule info is not needed for this convention and is ignored\\n  if supplied.\\n\\n  Args:\\n    start_date: A `DateTensor` object of any shape.\\n    end_date: A `DateTensor` object of compatible shape with `start_date`.\\n    schedule_info: The schedule info. Ignored for this convention.\\n    dtype: The dtype of the result. Either `tf.float32` or `tf.float64`. If not\\n      supplied, `tf.float32` is returned.\\n    name: Python `str` name prefixed to ops created by this function. If not\\n      supplied, `actual_365_actual` is used.\\n\\n  Returns:\\n    A real `Tensor` of supplied `dtype` and shape of `start_date`. The year\\n    fraction between the start and end date as computed by Actual/365 Actual\\n    convention.\\n  '\n    del schedule_info\n    with tf.name_scope(name or 'actual_365_actual'):\n        end_date = dt.convert_to_date_tensor(end_date)\n        start_date = dt.convert_to_date_tensor(start_date)\n        dtype = dtype or tf.constant(0.0).dtype\n        actual_days = tf.cast(start_date.days_until(end_date), dtype=dtype)\n        day = periods.day()\n        leap_days_between = du.leap_days_between(start_date=start_date + day, end_date=end_date + day)\n        denominator = tf.cast(tf.where(leap_days_between > 0, 366, 365), dtype=dtype)\n        return actual_days / denominator",
            "def actual_365_actual(*, start_date, end_date, schedule_info=None, dtype=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Computes the year fraction between the specified dates.\\n\\n  The actual/365 actual convention specifies the year fraction between the\\n  start and end date as the actual number of days between the two dates divided\\n  365 if no leap day is contained in the date range and 366 otherwise.\\n\\n  When determining whether a leap day is contained in the date range,\\n  `start_date` is excluded and `end_date` is included.\\n\\n  Note that the schedule info is not needed for this convention and is ignored\\n  if supplied.\\n\\n  Args:\\n    start_date: A `DateTensor` object of any shape.\\n    end_date: A `DateTensor` object of compatible shape with `start_date`.\\n    schedule_info: The schedule info. Ignored for this convention.\\n    dtype: The dtype of the result. Either `tf.float32` or `tf.float64`. If not\\n      supplied, `tf.float32` is returned.\\n    name: Python `str` name prefixed to ops created by this function. If not\\n      supplied, `actual_365_actual` is used.\\n\\n  Returns:\\n    A real `Tensor` of supplied `dtype` and shape of `start_date`. The year\\n    fraction between the start and end date as computed by Actual/365 Actual\\n    convention.\\n  '\n    del schedule_info\n    with tf.name_scope(name or 'actual_365_actual'):\n        end_date = dt.convert_to_date_tensor(end_date)\n        start_date = dt.convert_to_date_tensor(start_date)\n        dtype = dtype or tf.constant(0.0).dtype\n        actual_days = tf.cast(start_date.days_until(end_date), dtype=dtype)\n        day = periods.day()\n        leap_days_between = du.leap_days_between(start_date=start_date + day, end_date=end_date + day)\n        denominator = tf.cast(tf.where(leap_days_between > 0, 366, 365), dtype=dtype)\n        return actual_days / denominator",
            "def actual_365_actual(*, start_date, end_date, schedule_info=None, dtype=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Computes the year fraction between the specified dates.\\n\\n  The actual/365 actual convention specifies the year fraction between the\\n  start and end date as the actual number of days between the two dates divided\\n  365 if no leap day is contained in the date range and 366 otherwise.\\n\\n  When determining whether a leap day is contained in the date range,\\n  `start_date` is excluded and `end_date` is included.\\n\\n  Note that the schedule info is not needed for this convention and is ignored\\n  if supplied.\\n\\n  Args:\\n    start_date: A `DateTensor` object of any shape.\\n    end_date: A `DateTensor` object of compatible shape with `start_date`.\\n    schedule_info: The schedule info. Ignored for this convention.\\n    dtype: The dtype of the result. Either `tf.float32` or `tf.float64`. If not\\n      supplied, `tf.float32` is returned.\\n    name: Python `str` name prefixed to ops created by this function. If not\\n      supplied, `actual_365_actual` is used.\\n\\n  Returns:\\n    A real `Tensor` of supplied `dtype` and shape of `start_date`. The year\\n    fraction between the start and end date as computed by Actual/365 Actual\\n    convention.\\n  '\n    del schedule_info\n    with tf.name_scope(name or 'actual_365_actual'):\n        end_date = dt.convert_to_date_tensor(end_date)\n        start_date = dt.convert_to_date_tensor(start_date)\n        dtype = dtype or tf.constant(0.0).dtype\n        actual_days = tf.cast(start_date.days_until(end_date), dtype=dtype)\n        day = periods.day()\n        leap_days_between = du.leap_days_between(start_date=start_date + day, end_date=end_date + day)\n        denominator = tf.cast(tf.where(leap_days_between > 0, 366, 365), dtype=dtype)\n        return actual_days / denominator",
            "def actual_365_actual(*, start_date, end_date, schedule_info=None, dtype=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Computes the year fraction between the specified dates.\\n\\n  The actual/365 actual convention specifies the year fraction between the\\n  start and end date as the actual number of days between the two dates divided\\n  365 if no leap day is contained in the date range and 366 otherwise.\\n\\n  When determining whether a leap day is contained in the date range,\\n  `start_date` is excluded and `end_date` is included.\\n\\n  Note that the schedule info is not needed for this convention and is ignored\\n  if supplied.\\n\\n  Args:\\n    start_date: A `DateTensor` object of any shape.\\n    end_date: A `DateTensor` object of compatible shape with `start_date`.\\n    schedule_info: The schedule info. Ignored for this convention.\\n    dtype: The dtype of the result. Either `tf.float32` or `tf.float64`. If not\\n      supplied, `tf.float32` is returned.\\n    name: Python `str` name prefixed to ops created by this function. If not\\n      supplied, `actual_365_actual` is used.\\n\\n  Returns:\\n    A real `Tensor` of supplied `dtype` and shape of `start_date`. The year\\n    fraction between the start and end date as computed by Actual/365 Actual\\n    convention.\\n  '\n    del schedule_info\n    with tf.name_scope(name or 'actual_365_actual'):\n        end_date = dt.convert_to_date_tensor(end_date)\n        start_date = dt.convert_to_date_tensor(start_date)\n        dtype = dtype or tf.constant(0.0).dtype\n        actual_days = tf.cast(start_date.days_until(end_date), dtype=dtype)\n        day = periods.day()\n        leap_days_between = du.leap_days_between(start_date=start_date + day, end_date=end_date + day)\n        denominator = tf.cast(tf.where(leap_days_between > 0, 366, 365), dtype=dtype)\n        return actual_days / denominator"
        ]
    },
    {
        "func_name": "thirty_360_isda",
        "original": "def thirty_360_isda(*, start_date, end_date, schedule_info=None, dtype=None, name=None):\n    \"\"\"Computes the year fraction between the specified dates.\n\n  The 30/360 (ISDA / Bond Basis) convention specifies the year fraction\n  between the start and end date as the number of days by the following\n  formula between the two dates divided by 360.\n\n    day difference = (Y2 - Y1) * 360 + (M2 - M1) * 30 + (D2 - D1)\n\n  where\n\n    Y1 is the year, expressed as a number, of the start date;\n\n    Y2 is the year, expressed as a number, of the end date;\n\n    M1 is the calendar month, expressed as a number, of the start date;\n\n    M2 is the calendar month, expressed as a number of the last date;\n\n    D1 is the start date calendar day, unless such number would be 31, in\n    which case D1 will be 30;\n\n    D2 is the last date calendar day, unless such number would be 31 and D1\n    is either 30 or 31, in which case D2 will be 30\n\n  Note that the schedule info is not needed for this convention and is ignored\n  if supplied.\n\n  For more details see:\n  https://en.wikipedia.org/wiki/Day_count_convention#30/360_Bond_Basis\n  https://www.isda.org/2008/12/22/30-360-day-count-conventions\n\n  Args:\n    start_date: A `DateTensor` object of any shape.\n    end_date: A `DateTensor` object of compatible shape with `start_date`.\n    schedule_info: The schedule info. Ignored for this convention.\n    dtype: The dtype of the result. Either `tf.float32` or `tf.float64`. If not\n      supplied, `tf.float32` is returned.\n    name: Python `str` name prefixed to ops created by this function. If not\n      supplied, `thirty_360_isda` is used.\n\n  Returns:\n    A real `Tensor` of supplied `dtype` and shape of `start_date`. The year\n    fraction between the start and end date as computed by 30/360 convention.\n  \"\"\"\n    del schedule_info\n    with tf.name_scope(name or 'thirty_360_isda'):\n        d1_days = tf.minimum(start_date.day(), 30)\n        d2_days = tf.where(tf.equal(d1_days, 30) & tf.equal(end_date.day(), 31), 30, end_date.day())\n        day_difference = d2_days - d1_days\n        month_difference = (end_date.month() - start_date.month()) * 30\n        year_difference = (end_date.year() - start_date.year()) * 360\n        dtype = dtype or tf.constant(0.0).dtype\n        total_day_difference = tf.cast(day_difference + month_difference + year_difference, dtype=dtype)\n        return total_day_difference / 360",
        "mutated": [
            "def thirty_360_isda(*, start_date, end_date, schedule_info=None, dtype=None, name=None):\n    if False:\n        i = 10\n    'Computes the year fraction between the specified dates.\\n\\n  The 30/360 (ISDA / Bond Basis) convention specifies the year fraction\\n  between the start and end date as the number of days by the following\\n  formula between the two dates divided by 360.\\n\\n    day difference = (Y2 - Y1) * 360 + (M2 - M1) * 30 + (D2 - D1)\\n\\n  where\\n\\n    Y1 is the year, expressed as a number, of the start date;\\n\\n    Y2 is the year, expressed as a number, of the end date;\\n\\n    M1 is the calendar month, expressed as a number, of the start date;\\n\\n    M2 is the calendar month, expressed as a number of the last date;\\n\\n    D1 is the start date calendar day, unless such number would be 31, in\\n    which case D1 will be 30;\\n\\n    D2 is the last date calendar day, unless such number would be 31 and D1\\n    is either 30 or 31, in which case D2 will be 30\\n\\n  Note that the schedule info is not needed for this convention and is ignored\\n  if supplied.\\n\\n  For more details see:\\n  https://en.wikipedia.org/wiki/Day_count_convention#30/360_Bond_Basis\\n  https://www.isda.org/2008/12/22/30-360-day-count-conventions\\n\\n  Args:\\n    start_date: A `DateTensor` object of any shape.\\n    end_date: A `DateTensor` object of compatible shape with `start_date`.\\n    schedule_info: The schedule info. Ignored for this convention.\\n    dtype: The dtype of the result. Either `tf.float32` or `tf.float64`. If not\\n      supplied, `tf.float32` is returned.\\n    name: Python `str` name prefixed to ops created by this function. If not\\n      supplied, `thirty_360_isda` is used.\\n\\n  Returns:\\n    A real `Tensor` of supplied `dtype` and shape of `start_date`. The year\\n    fraction between the start and end date as computed by 30/360 convention.\\n  '\n    del schedule_info\n    with tf.name_scope(name or 'thirty_360_isda'):\n        d1_days = tf.minimum(start_date.day(), 30)\n        d2_days = tf.where(tf.equal(d1_days, 30) & tf.equal(end_date.day(), 31), 30, end_date.day())\n        day_difference = d2_days - d1_days\n        month_difference = (end_date.month() - start_date.month()) * 30\n        year_difference = (end_date.year() - start_date.year()) * 360\n        dtype = dtype or tf.constant(0.0).dtype\n        total_day_difference = tf.cast(day_difference + month_difference + year_difference, dtype=dtype)\n        return total_day_difference / 360",
            "def thirty_360_isda(*, start_date, end_date, schedule_info=None, dtype=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Computes the year fraction between the specified dates.\\n\\n  The 30/360 (ISDA / Bond Basis) convention specifies the year fraction\\n  between the start and end date as the number of days by the following\\n  formula between the two dates divided by 360.\\n\\n    day difference = (Y2 - Y1) * 360 + (M2 - M1) * 30 + (D2 - D1)\\n\\n  where\\n\\n    Y1 is the year, expressed as a number, of the start date;\\n\\n    Y2 is the year, expressed as a number, of the end date;\\n\\n    M1 is the calendar month, expressed as a number, of the start date;\\n\\n    M2 is the calendar month, expressed as a number of the last date;\\n\\n    D1 is the start date calendar day, unless such number would be 31, in\\n    which case D1 will be 30;\\n\\n    D2 is the last date calendar day, unless such number would be 31 and D1\\n    is either 30 or 31, in which case D2 will be 30\\n\\n  Note that the schedule info is not needed for this convention and is ignored\\n  if supplied.\\n\\n  For more details see:\\n  https://en.wikipedia.org/wiki/Day_count_convention#30/360_Bond_Basis\\n  https://www.isda.org/2008/12/22/30-360-day-count-conventions\\n\\n  Args:\\n    start_date: A `DateTensor` object of any shape.\\n    end_date: A `DateTensor` object of compatible shape with `start_date`.\\n    schedule_info: The schedule info. Ignored for this convention.\\n    dtype: The dtype of the result. Either `tf.float32` or `tf.float64`. If not\\n      supplied, `tf.float32` is returned.\\n    name: Python `str` name prefixed to ops created by this function. If not\\n      supplied, `thirty_360_isda` is used.\\n\\n  Returns:\\n    A real `Tensor` of supplied `dtype` and shape of `start_date`. The year\\n    fraction between the start and end date as computed by 30/360 convention.\\n  '\n    del schedule_info\n    with tf.name_scope(name or 'thirty_360_isda'):\n        d1_days = tf.minimum(start_date.day(), 30)\n        d2_days = tf.where(tf.equal(d1_days, 30) & tf.equal(end_date.day(), 31), 30, end_date.day())\n        day_difference = d2_days - d1_days\n        month_difference = (end_date.month() - start_date.month()) * 30\n        year_difference = (end_date.year() - start_date.year()) * 360\n        dtype = dtype or tf.constant(0.0).dtype\n        total_day_difference = tf.cast(day_difference + month_difference + year_difference, dtype=dtype)\n        return total_day_difference / 360",
            "def thirty_360_isda(*, start_date, end_date, schedule_info=None, dtype=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Computes the year fraction between the specified dates.\\n\\n  The 30/360 (ISDA / Bond Basis) convention specifies the year fraction\\n  between the start and end date as the number of days by the following\\n  formula between the two dates divided by 360.\\n\\n    day difference = (Y2 - Y1) * 360 + (M2 - M1) * 30 + (D2 - D1)\\n\\n  where\\n\\n    Y1 is the year, expressed as a number, of the start date;\\n\\n    Y2 is the year, expressed as a number, of the end date;\\n\\n    M1 is the calendar month, expressed as a number, of the start date;\\n\\n    M2 is the calendar month, expressed as a number of the last date;\\n\\n    D1 is the start date calendar day, unless such number would be 31, in\\n    which case D1 will be 30;\\n\\n    D2 is the last date calendar day, unless such number would be 31 and D1\\n    is either 30 or 31, in which case D2 will be 30\\n\\n  Note that the schedule info is not needed for this convention and is ignored\\n  if supplied.\\n\\n  For more details see:\\n  https://en.wikipedia.org/wiki/Day_count_convention#30/360_Bond_Basis\\n  https://www.isda.org/2008/12/22/30-360-day-count-conventions\\n\\n  Args:\\n    start_date: A `DateTensor` object of any shape.\\n    end_date: A `DateTensor` object of compatible shape with `start_date`.\\n    schedule_info: The schedule info. Ignored for this convention.\\n    dtype: The dtype of the result. Either `tf.float32` or `tf.float64`. If not\\n      supplied, `tf.float32` is returned.\\n    name: Python `str` name prefixed to ops created by this function. If not\\n      supplied, `thirty_360_isda` is used.\\n\\n  Returns:\\n    A real `Tensor` of supplied `dtype` and shape of `start_date`. The year\\n    fraction between the start and end date as computed by 30/360 convention.\\n  '\n    del schedule_info\n    with tf.name_scope(name or 'thirty_360_isda'):\n        d1_days = tf.minimum(start_date.day(), 30)\n        d2_days = tf.where(tf.equal(d1_days, 30) & tf.equal(end_date.day(), 31), 30, end_date.day())\n        day_difference = d2_days - d1_days\n        month_difference = (end_date.month() - start_date.month()) * 30\n        year_difference = (end_date.year() - start_date.year()) * 360\n        dtype = dtype or tf.constant(0.0).dtype\n        total_day_difference = tf.cast(day_difference + month_difference + year_difference, dtype=dtype)\n        return total_day_difference / 360",
            "def thirty_360_isda(*, start_date, end_date, schedule_info=None, dtype=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Computes the year fraction between the specified dates.\\n\\n  The 30/360 (ISDA / Bond Basis) convention specifies the year fraction\\n  between the start and end date as the number of days by the following\\n  formula between the two dates divided by 360.\\n\\n    day difference = (Y2 - Y1) * 360 + (M2 - M1) * 30 + (D2 - D1)\\n\\n  where\\n\\n    Y1 is the year, expressed as a number, of the start date;\\n\\n    Y2 is the year, expressed as a number, of the end date;\\n\\n    M1 is the calendar month, expressed as a number, of the start date;\\n\\n    M2 is the calendar month, expressed as a number of the last date;\\n\\n    D1 is the start date calendar day, unless such number would be 31, in\\n    which case D1 will be 30;\\n\\n    D2 is the last date calendar day, unless such number would be 31 and D1\\n    is either 30 or 31, in which case D2 will be 30\\n\\n  Note that the schedule info is not needed for this convention and is ignored\\n  if supplied.\\n\\n  For more details see:\\n  https://en.wikipedia.org/wiki/Day_count_convention#30/360_Bond_Basis\\n  https://www.isda.org/2008/12/22/30-360-day-count-conventions\\n\\n  Args:\\n    start_date: A `DateTensor` object of any shape.\\n    end_date: A `DateTensor` object of compatible shape with `start_date`.\\n    schedule_info: The schedule info. Ignored for this convention.\\n    dtype: The dtype of the result. Either `tf.float32` or `tf.float64`. If not\\n      supplied, `tf.float32` is returned.\\n    name: Python `str` name prefixed to ops created by this function. If not\\n      supplied, `thirty_360_isda` is used.\\n\\n  Returns:\\n    A real `Tensor` of supplied `dtype` and shape of `start_date`. The year\\n    fraction between the start and end date as computed by 30/360 convention.\\n  '\n    del schedule_info\n    with tf.name_scope(name or 'thirty_360_isda'):\n        d1_days = tf.minimum(start_date.day(), 30)\n        d2_days = tf.where(tf.equal(d1_days, 30) & tf.equal(end_date.day(), 31), 30, end_date.day())\n        day_difference = d2_days - d1_days\n        month_difference = (end_date.month() - start_date.month()) * 30\n        year_difference = (end_date.year() - start_date.year()) * 360\n        dtype = dtype or tf.constant(0.0).dtype\n        total_day_difference = tf.cast(day_difference + month_difference + year_difference, dtype=dtype)\n        return total_day_difference / 360",
            "def thirty_360_isda(*, start_date, end_date, schedule_info=None, dtype=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Computes the year fraction between the specified dates.\\n\\n  The 30/360 (ISDA / Bond Basis) convention specifies the year fraction\\n  between the start and end date as the number of days by the following\\n  formula between the two dates divided by 360.\\n\\n    day difference = (Y2 - Y1) * 360 + (M2 - M1) * 30 + (D2 - D1)\\n\\n  where\\n\\n    Y1 is the year, expressed as a number, of the start date;\\n\\n    Y2 is the year, expressed as a number, of the end date;\\n\\n    M1 is the calendar month, expressed as a number, of the start date;\\n\\n    M2 is the calendar month, expressed as a number of the last date;\\n\\n    D1 is the start date calendar day, unless such number would be 31, in\\n    which case D1 will be 30;\\n\\n    D2 is the last date calendar day, unless such number would be 31 and D1\\n    is either 30 or 31, in which case D2 will be 30\\n\\n  Note that the schedule info is not needed for this convention and is ignored\\n  if supplied.\\n\\n  For more details see:\\n  https://en.wikipedia.org/wiki/Day_count_convention#30/360_Bond_Basis\\n  https://www.isda.org/2008/12/22/30-360-day-count-conventions\\n\\n  Args:\\n    start_date: A `DateTensor` object of any shape.\\n    end_date: A `DateTensor` object of compatible shape with `start_date`.\\n    schedule_info: The schedule info. Ignored for this convention.\\n    dtype: The dtype of the result. Either `tf.float32` or `tf.float64`. If not\\n      supplied, `tf.float32` is returned.\\n    name: Python `str` name prefixed to ops created by this function. If not\\n      supplied, `thirty_360_isda` is used.\\n\\n  Returns:\\n    A real `Tensor` of supplied `dtype` and shape of `start_date`. The year\\n    fraction between the start and end date as computed by 30/360 convention.\\n  '\n    del schedule_info\n    with tf.name_scope(name or 'thirty_360_isda'):\n        d1_days = tf.minimum(start_date.day(), 30)\n        d2_days = tf.where(tf.equal(d1_days, 30) & tf.equal(end_date.day(), 31), 30, end_date.day())\n        day_difference = d2_days - d1_days\n        month_difference = (end_date.month() - start_date.month()) * 30\n        year_difference = (end_date.year() - start_date.year()) * 360\n        dtype = dtype or tf.constant(0.0).dtype\n        total_day_difference = tf.cast(day_difference + month_difference + year_difference, dtype=dtype)\n        return total_day_difference / 360"
        ]
    },
    {
        "func_name": "actual_actual_isda",
        "original": "def actual_actual_isda(*, start_date, end_date, schedule_info=None, dtype=None, name=None):\n    \"\"\"Computes the year fraction between the specified dates.\n\n  Computes the year fraction between the dates by dividing the actual number of\n  days in a leap year by 366 and the actual number of days in a standard year by\n  365.\n\n  When determining whether a leap day is contained in the date range,\n  'start_date' is excluded and 'end_date' is included.\n\n  Note that the schedule info is not needed for this convention and is ignored\n  if supplied.\n\n  https://en.wikipedia.org/wiki/Day_count_convention#Actual/Actual_ISDA\n\n  Args:\n    start_date: A `DateTensor` object of any shape.\n    end_date: A `DateTensor` object of compatible shape with `start_date`.\n    schedule_info: The schedule info. Ignored for this convention.\n    dtype: The dtype of the result. Either `tf.float32` or `tf.float64`. If not\n      supplied, `tf.float32` is returned.\n    name: Python `str` name prefixed to ops created by this function. If not\n      supplied, `actual_actual_isda` is used.\n\n  Returns:\n    A real `Tensor` of supplied `dtype` and shape of `start_date`. The year\n    fraction between the start and end date as computed by Actual/Actual ISDA\n    convention.\n  \"\"\"\n    del schedule_info\n    with tf.name_scope(name or 'actual_actual_isda'):\n        end_date = dt.convert_to_date_tensor(end_date)\n        start_date = dt.convert_to_date_tensor(start_date)\n        dtype = dtype or tf.float32\n        (days_in_leap_years, days_in_nonleap_years) = du.days_in_leap_and_nonleap_years_between(start_date, end_date)\n        days_in_leap_years = tf.cast(days_in_leap_years, dtype=dtype)\n        days_in_nonleap_years = tf.cast(days_in_nonleap_years, dtype=dtype)\n        return days_in_leap_years / 366 + days_in_nonleap_years / 365",
        "mutated": [
            "def actual_actual_isda(*, start_date, end_date, schedule_info=None, dtype=None, name=None):\n    if False:\n        i = 10\n    \"Computes the year fraction between the specified dates.\\n\\n  Computes the year fraction between the dates by dividing the actual number of\\n  days in a leap year by 366 and the actual number of days in a standard year by\\n  365.\\n\\n  When determining whether a leap day is contained in the date range,\\n  'start_date' is excluded and 'end_date' is included.\\n\\n  Note that the schedule info is not needed for this convention and is ignored\\n  if supplied.\\n\\n  https://en.wikipedia.org/wiki/Day_count_convention#Actual/Actual_ISDA\\n\\n  Args:\\n    start_date: A `DateTensor` object of any shape.\\n    end_date: A `DateTensor` object of compatible shape with `start_date`.\\n    schedule_info: The schedule info. Ignored for this convention.\\n    dtype: The dtype of the result. Either `tf.float32` or `tf.float64`. If not\\n      supplied, `tf.float32` is returned.\\n    name: Python `str` name prefixed to ops created by this function. If not\\n      supplied, `actual_actual_isda` is used.\\n\\n  Returns:\\n    A real `Tensor` of supplied `dtype` and shape of `start_date`. The year\\n    fraction between the start and end date as computed by Actual/Actual ISDA\\n    convention.\\n  \"\n    del schedule_info\n    with tf.name_scope(name or 'actual_actual_isda'):\n        end_date = dt.convert_to_date_tensor(end_date)\n        start_date = dt.convert_to_date_tensor(start_date)\n        dtype = dtype or tf.float32\n        (days_in_leap_years, days_in_nonleap_years) = du.days_in_leap_and_nonleap_years_between(start_date, end_date)\n        days_in_leap_years = tf.cast(days_in_leap_years, dtype=dtype)\n        days_in_nonleap_years = tf.cast(days_in_nonleap_years, dtype=dtype)\n        return days_in_leap_years / 366 + days_in_nonleap_years / 365",
            "def actual_actual_isda(*, start_date, end_date, schedule_info=None, dtype=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Computes the year fraction between the specified dates.\\n\\n  Computes the year fraction between the dates by dividing the actual number of\\n  days in a leap year by 366 and the actual number of days in a standard year by\\n  365.\\n\\n  When determining whether a leap day is contained in the date range,\\n  'start_date' is excluded and 'end_date' is included.\\n\\n  Note that the schedule info is not needed for this convention and is ignored\\n  if supplied.\\n\\n  https://en.wikipedia.org/wiki/Day_count_convention#Actual/Actual_ISDA\\n\\n  Args:\\n    start_date: A `DateTensor` object of any shape.\\n    end_date: A `DateTensor` object of compatible shape with `start_date`.\\n    schedule_info: The schedule info. Ignored for this convention.\\n    dtype: The dtype of the result. Either `tf.float32` or `tf.float64`. If not\\n      supplied, `tf.float32` is returned.\\n    name: Python `str` name prefixed to ops created by this function. If not\\n      supplied, `actual_actual_isda` is used.\\n\\n  Returns:\\n    A real `Tensor` of supplied `dtype` and shape of `start_date`. The year\\n    fraction between the start and end date as computed by Actual/Actual ISDA\\n    convention.\\n  \"\n    del schedule_info\n    with tf.name_scope(name or 'actual_actual_isda'):\n        end_date = dt.convert_to_date_tensor(end_date)\n        start_date = dt.convert_to_date_tensor(start_date)\n        dtype = dtype or tf.float32\n        (days_in_leap_years, days_in_nonleap_years) = du.days_in_leap_and_nonleap_years_between(start_date, end_date)\n        days_in_leap_years = tf.cast(days_in_leap_years, dtype=dtype)\n        days_in_nonleap_years = tf.cast(days_in_nonleap_years, dtype=dtype)\n        return days_in_leap_years / 366 + days_in_nonleap_years / 365",
            "def actual_actual_isda(*, start_date, end_date, schedule_info=None, dtype=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Computes the year fraction between the specified dates.\\n\\n  Computes the year fraction between the dates by dividing the actual number of\\n  days in a leap year by 366 and the actual number of days in a standard year by\\n  365.\\n\\n  When determining whether a leap day is contained in the date range,\\n  'start_date' is excluded and 'end_date' is included.\\n\\n  Note that the schedule info is not needed for this convention and is ignored\\n  if supplied.\\n\\n  https://en.wikipedia.org/wiki/Day_count_convention#Actual/Actual_ISDA\\n\\n  Args:\\n    start_date: A `DateTensor` object of any shape.\\n    end_date: A `DateTensor` object of compatible shape with `start_date`.\\n    schedule_info: The schedule info. Ignored for this convention.\\n    dtype: The dtype of the result. Either `tf.float32` or `tf.float64`. If not\\n      supplied, `tf.float32` is returned.\\n    name: Python `str` name prefixed to ops created by this function. If not\\n      supplied, `actual_actual_isda` is used.\\n\\n  Returns:\\n    A real `Tensor` of supplied `dtype` and shape of `start_date`. The year\\n    fraction between the start and end date as computed by Actual/Actual ISDA\\n    convention.\\n  \"\n    del schedule_info\n    with tf.name_scope(name or 'actual_actual_isda'):\n        end_date = dt.convert_to_date_tensor(end_date)\n        start_date = dt.convert_to_date_tensor(start_date)\n        dtype = dtype or tf.float32\n        (days_in_leap_years, days_in_nonleap_years) = du.days_in_leap_and_nonleap_years_between(start_date, end_date)\n        days_in_leap_years = tf.cast(days_in_leap_years, dtype=dtype)\n        days_in_nonleap_years = tf.cast(days_in_nonleap_years, dtype=dtype)\n        return days_in_leap_years / 366 + days_in_nonleap_years / 365",
            "def actual_actual_isda(*, start_date, end_date, schedule_info=None, dtype=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Computes the year fraction between the specified dates.\\n\\n  Computes the year fraction between the dates by dividing the actual number of\\n  days in a leap year by 366 and the actual number of days in a standard year by\\n  365.\\n\\n  When determining whether a leap day is contained in the date range,\\n  'start_date' is excluded and 'end_date' is included.\\n\\n  Note that the schedule info is not needed for this convention and is ignored\\n  if supplied.\\n\\n  https://en.wikipedia.org/wiki/Day_count_convention#Actual/Actual_ISDA\\n\\n  Args:\\n    start_date: A `DateTensor` object of any shape.\\n    end_date: A `DateTensor` object of compatible shape with `start_date`.\\n    schedule_info: The schedule info. Ignored for this convention.\\n    dtype: The dtype of the result. Either `tf.float32` or `tf.float64`. If not\\n      supplied, `tf.float32` is returned.\\n    name: Python `str` name prefixed to ops created by this function. If not\\n      supplied, `actual_actual_isda` is used.\\n\\n  Returns:\\n    A real `Tensor` of supplied `dtype` and shape of `start_date`. The year\\n    fraction between the start and end date as computed by Actual/Actual ISDA\\n    convention.\\n  \"\n    del schedule_info\n    with tf.name_scope(name or 'actual_actual_isda'):\n        end_date = dt.convert_to_date_tensor(end_date)\n        start_date = dt.convert_to_date_tensor(start_date)\n        dtype = dtype or tf.float32\n        (days_in_leap_years, days_in_nonleap_years) = du.days_in_leap_and_nonleap_years_between(start_date, end_date)\n        days_in_leap_years = tf.cast(days_in_leap_years, dtype=dtype)\n        days_in_nonleap_years = tf.cast(days_in_nonleap_years, dtype=dtype)\n        return days_in_leap_years / 366 + days_in_nonleap_years / 365",
            "def actual_actual_isda(*, start_date, end_date, schedule_info=None, dtype=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Computes the year fraction between the specified dates.\\n\\n  Computes the year fraction between the dates by dividing the actual number of\\n  days in a leap year by 366 and the actual number of days in a standard year by\\n  365.\\n\\n  When determining whether a leap day is contained in the date range,\\n  'start_date' is excluded and 'end_date' is included.\\n\\n  Note that the schedule info is not needed for this convention and is ignored\\n  if supplied.\\n\\n  https://en.wikipedia.org/wiki/Day_count_convention#Actual/Actual_ISDA\\n\\n  Args:\\n    start_date: A `DateTensor` object of any shape.\\n    end_date: A `DateTensor` object of compatible shape with `start_date`.\\n    schedule_info: The schedule info. Ignored for this convention.\\n    dtype: The dtype of the result. Either `tf.float32` or `tf.float64`. If not\\n      supplied, `tf.float32` is returned.\\n    name: Python `str` name prefixed to ops created by this function. If not\\n      supplied, `actual_actual_isda` is used.\\n\\n  Returns:\\n    A real `Tensor` of supplied `dtype` and shape of `start_date`. The year\\n    fraction between the start and end date as computed by Actual/Actual ISDA\\n    convention.\\n  \"\n    del schedule_info\n    with tf.name_scope(name or 'actual_actual_isda'):\n        end_date = dt.convert_to_date_tensor(end_date)\n        start_date = dt.convert_to_date_tensor(start_date)\n        dtype = dtype or tf.float32\n        (days_in_leap_years, days_in_nonleap_years) = du.days_in_leap_and_nonleap_years_between(start_date, end_date)\n        days_in_leap_years = tf.cast(days_in_leap_years, dtype=dtype)\n        days_in_nonleap_years = tf.cast(days_in_nonleap_years, dtype=dtype)\n        return days_in_leap_years / 366 + days_in_nonleap_years / 365"
        ]
    }
]