[
    {
        "func_name": "utilGetStrs",
        "original": "def utilGetStrs(line: Any, m: Any):\n    return (line[0:m.start('match')], line[m.start('match'):m.end('match')], line[m.end('match'):])",
        "mutated": [
            "def utilGetStrs(line: Any, m: Any):\n    if False:\n        i = 10\n    return (line[0:m.start('match')], line[m.start('match'):m.end('match')], line[m.end('match'):])",
            "def utilGetStrs(line: Any, m: Any):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return (line[0:m.start('match')], line[m.start('match'):m.end('match')], line[m.end('match'):])",
            "def utilGetStrs(line: Any, m: Any):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return (line[0:m.start('match')], line[m.start('match'):m.end('match')], line[m.end('match'):])",
            "def utilGetStrs(line: Any, m: Any):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return (line[0:m.start('match')], line[m.start('match'):m.end('match')], line[m.end('match'):])",
            "def utilGetStrs(line: Any, m: Any):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return (line[0:m.start('match')], line[m.start('match'):m.end('match')], line[m.end('match'):])"
        ]
    },
    {
        "func_name": "noDoubleBackslashFixer",
        "original": "def noDoubleBackslashFixer(line: str, m: Any) -> str:\n    (prestr, midstr, poststr) = utilGetStrs(line, m)\n    return f'{prestr}{midstr[1:]}{poststr}'",
        "mutated": [
            "def noDoubleBackslashFixer(line: str, m: Any) -> str:\n    if False:\n        i = 10\n    (prestr, midstr, poststr) = utilGetStrs(line, m)\n    return f'{prestr}{midstr[1:]}{poststr}'",
            "def noDoubleBackslashFixer(line: str, m: Any) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (prestr, midstr, poststr) = utilGetStrs(line, m)\n    return f'{prestr}{midstr[1:]}{poststr}'",
            "def noDoubleBackslashFixer(line: str, m: Any) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (prestr, midstr, poststr) = utilGetStrs(line, m)\n    return f'{prestr}{midstr[1:]}{poststr}'",
            "def noDoubleBackslashFixer(line: str, m: Any) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (prestr, midstr, poststr) = utilGetStrs(line, m)\n    return f'{prestr}{midstr[1:]}{poststr}'",
            "def noDoubleBackslashFixer(line: str, m: Any) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (prestr, midstr, poststr) = utilGetStrs(line, m)\n    return f'{prestr}{midstr[1:]}{poststr}'"
        ]
    },
    {
        "func_name": "noPwdCaptureFixer",
        "original": "def noPwdCaptureFixer(line: str, m: Any) -> str:\n    (prestr, _, poststr) = utilGetStrs(line, m)\n    return f'{prestr}$PWD{poststr}'",
        "mutated": [
            "def noPwdCaptureFixer(line: str, m: Any) -> str:\n    if False:\n        i = 10\n    (prestr, _, poststr) = utilGetStrs(line, m)\n    return f'{prestr}$PWD{poststr}'",
            "def noPwdCaptureFixer(line: str, m: Any) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (prestr, _, poststr) = utilGetStrs(line, m)\n    return f'{prestr}$PWD{poststr}'",
            "def noPwdCaptureFixer(line: str, m: Any) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (prestr, _, poststr) = utilGetStrs(line, m)\n    return f'{prestr}$PWD{poststr}'",
            "def noPwdCaptureFixer(line: str, m: Any) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (prestr, _, poststr) = utilGetStrs(line, m)\n    return f'{prestr}$PWD{poststr}'",
            "def noPwdCaptureFixer(line: str, m: Any) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (prestr, _, poststr) = utilGetStrs(line, m)\n    return f'{prestr}$PWD{poststr}'"
        ]
    },
    {
        "func_name": "noTestDoubleEqualsFixer",
        "original": "def noTestDoubleEqualsFixer(line: str, m: Any) -> str:\n    (prestr, _, poststr) = utilGetStrs(line, m)\n    return f'{prestr}={poststr}'",
        "mutated": [
            "def noTestDoubleEqualsFixer(line: str, m: Any) -> str:\n    if False:\n        i = 10\n    (prestr, _, poststr) = utilGetStrs(line, m)\n    return f'{prestr}={poststr}'",
            "def noTestDoubleEqualsFixer(line: str, m: Any) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (prestr, _, poststr) = utilGetStrs(line, m)\n    return f'{prestr}={poststr}'",
            "def noTestDoubleEqualsFixer(line: str, m: Any) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (prestr, _, poststr) = utilGetStrs(line, m)\n    return f'{prestr}={poststr}'",
            "def noTestDoubleEqualsFixer(line: str, m: Any) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (prestr, _, poststr) = utilGetStrs(line, m)\n    return f'{prestr}={poststr}'",
            "def noTestDoubleEqualsFixer(line: str, m: Any) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (prestr, _, poststr) = utilGetStrs(line, m)\n    return f'{prestr}={poststr}'"
        ]
    },
    {
        "func_name": "noFunctionKeywordFixer",
        "original": "def noFunctionKeywordFixer(line: str, m: Any) -> str:\n    (prestr, midstr, poststr) = utilGetStrs(line, m)\n    midstr = midstr.strip()\n    midstr = midstr[len('function'):]\n    midstr = midstr.strip()\n    parenIdx = midstr.find('(')\n    if parenIdx != -1:\n        midstr = midstr[:parenIdx]\n    return f'{prestr}{midstr}() {poststr}'",
        "mutated": [
            "def noFunctionKeywordFixer(line: str, m: Any) -> str:\n    if False:\n        i = 10\n    (prestr, midstr, poststr) = utilGetStrs(line, m)\n    midstr = midstr.strip()\n    midstr = midstr[len('function'):]\n    midstr = midstr.strip()\n    parenIdx = midstr.find('(')\n    if parenIdx != -1:\n        midstr = midstr[:parenIdx]\n    return f'{prestr}{midstr}() {poststr}'",
            "def noFunctionKeywordFixer(line: str, m: Any) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (prestr, midstr, poststr) = utilGetStrs(line, m)\n    midstr = midstr.strip()\n    midstr = midstr[len('function'):]\n    midstr = midstr.strip()\n    parenIdx = midstr.find('(')\n    if parenIdx != -1:\n        midstr = midstr[:parenIdx]\n    return f'{prestr}{midstr}() {poststr}'",
            "def noFunctionKeywordFixer(line: str, m: Any) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (prestr, midstr, poststr) = utilGetStrs(line, m)\n    midstr = midstr.strip()\n    midstr = midstr[len('function'):]\n    midstr = midstr.strip()\n    parenIdx = midstr.find('(')\n    if parenIdx != -1:\n        midstr = midstr[:parenIdx]\n    return f'{prestr}{midstr}() {poststr}'",
            "def noFunctionKeywordFixer(line: str, m: Any) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (prestr, midstr, poststr) = utilGetStrs(line, m)\n    midstr = midstr.strip()\n    midstr = midstr[len('function'):]\n    midstr = midstr.strip()\n    parenIdx = midstr.find('(')\n    if parenIdx != -1:\n        midstr = midstr[:parenIdx]\n    return f'{prestr}{midstr}() {poststr}'",
            "def noFunctionKeywordFixer(line: str, m: Any) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (prestr, midstr, poststr) = utilGetStrs(line, m)\n    midstr = midstr.strip()\n    midstr = midstr[len('function'):]\n    midstr = midstr.strip()\n    parenIdx = midstr.find('(')\n    if parenIdx != -1:\n        midstr = midstr[:parenIdx]\n    return f'{prestr}{midstr}() {poststr}'"
        ]
    },
    {
        "func_name": "noVerboseRedirectionFixer",
        "original": "def noVerboseRedirectionFixer(line: str, m: Any) -> str:\n    (prestr, _, poststr) = utilGetStrs(line, m)\n    return f'{prestr}&>/dev/null{poststr}'",
        "mutated": [
            "def noVerboseRedirectionFixer(line: str, m: Any) -> str:\n    if False:\n        i = 10\n    (prestr, _, poststr) = utilGetStrs(line, m)\n    return f'{prestr}&>/dev/null{poststr}'",
            "def noVerboseRedirectionFixer(line: str, m: Any) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (prestr, _, poststr) = utilGetStrs(line, m)\n    return f'{prestr}&>/dev/null{poststr}'",
            "def noVerboseRedirectionFixer(line: str, m: Any) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (prestr, _, poststr) = utilGetStrs(line, m)\n    return f'{prestr}&>/dev/null{poststr}'",
            "def noVerboseRedirectionFixer(line: str, m: Any) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (prestr, _, poststr) = utilGetStrs(line, m)\n    return f'{prestr}&>/dev/null{poststr}'",
            "def noVerboseRedirectionFixer(line: str, m: Any) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (prestr, _, poststr) = utilGetStrs(line, m)\n    return f'{prestr}&>/dev/null{poststr}'"
        ]
    },
    {
        "func_name": "lintfile",
        "original": "def lintfile(file: Path, rules: List[Rule], options: Dict[str, Any]):\n    content_arr = file.read_text().split('\\n')\n    for (line_i, line) in enumerate(content_arr):\n        if 'checkstyle-ignore' in line:\n            continue\n        for rule in rules:\n            should_run = False\n            if 'sh' in rule['fileTypes']:\n                if file.name.endswith('.sh') or str(file.absolute()).endswith('bin/asdf'):\n                    should_run = True\n            if 'bash' in rule['fileTypes']:\n                if file.name.endswith('.bash') or file.name.endswith('.bats'):\n                    should_run = True\n            if options['verbose']:\n                print(f'{str(file)}: {should_run}')\n            if not should_run:\n                continue\n            m = re.search(rule['regex'], line)\n            if m is not None and m.group('match') is not None:\n                dir = os.path.relpath(file.resolve(), Path.cwd())\n                prestr = line[0:m.start('match')]\n                midstr = line[m.start('match'):m.end('match')]\n                poststr = line[m.end('match'):]\n                print(f'{c.CYAN}{dir}{c.RESET}:{line_i + 1}')\n                print(f\"{c.MAGENTA}{rule['name']}{c.RESET}: {rule['reason']}\")\n                print(f'{prestr}{c.RED}{midstr}{c.RESET}{poststr}')\n                print()\n                if options['fix']:\n                    content_arr[line_i] = rule['fixerFn'](line, m)\n                rule['found'] += 1\n    if options['fix']:\n        file.write_text('\\n'.join(content_arr))",
        "mutated": [
            "def lintfile(file: Path, rules: List[Rule], options: Dict[str, Any]):\n    if False:\n        i = 10\n    content_arr = file.read_text().split('\\n')\n    for (line_i, line) in enumerate(content_arr):\n        if 'checkstyle-ignore' in line:\n            continue\n        for rule in rules:\n            should_run = False\n            if 'sh' in rule['fileTypes']:\n                if file.name.endswith('.sh') or str(file.absolute()).endswith('bin/asdf'):\n                    should_run = True\n            if 'bash' in rule['fileTypes']:\n                if file.name.endswith('.bash') or file.name.endswith('.bats'):\n                    should_run = True\n            if options['verbose']:\n                print(f'{str(file)}: {should_run}')\n            if not should_run:\n                continue\n            m = re.search(rule['regex'], line)\n            if m is not None and m.group('match') is not None:\n                dir = os.path.relpath(file.resolve(), Path.cwd())\n                prestr = line[0:m.start('match')]\n                midstr = line[m.start('match'):m.end('match')]\n                poststr = line[m.end('match'):]\n                print(f'{c.CYAN}{dir}{c.RESET}:{line_i + 1}')\n                print(f\"{c.MAGENTA}{rule['name']}{c.RESET}: {rule['reason']}\")\n                print(f'{prestr}{c.RED}{midstr}{c.RESET}{poststr}')\n                print()\n                if options['fix']:\n                    content_arr[line_i] = rule['fixerFn'](line, m)\n                rule['found'] += 1\n    if options['fix']:\n        file.write_text('\\n'.join(content_arr))",
            "def lintfile(file: Path, rules: List[Rule], options: Dict[str, Any]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    content_arr = file.read_text().split('\\n')\n    for (line_i, line) in enumerate(content_arr):\n        if 'checkstyle-ignore' in line:\n            continue\n        for rule in rules:\n            should_run = False\n            if 'sh' in rule['fileTypes']:\n                if file.name.endswith('.sh') or str(file.absolute()).endswith('bin/asdf'):\n                    should_run = True\n            if 'bash' in rule['fileTypes']:\n                if file.name.endswith('.bash') or file.name.endswith('.bats'):\n                    should_run = True\n            if options['verbose']:\n                print(f'{str(file)}: {should_run}')\n            if not should_run:\n                continue\n            m = re.search(rule['regex'], line)\n            if m is not None and m.group('match') is not None:\n                dir = os.path.relpath(file.resolve(), Path.cwd())\n                prestr = line[0:m.start('match')]\n                midstr = line[m.start('match'):m.end('match')]\n                poststr = line[m.end('match'):]\n                print(f'{c.CYAN}{dir}{c.RESET}:{line_i + 1}')\n                print(f\"{c.MAGENTA}{rule['name']}{c.RESET}: {rule['reason']}\")\n                print(f'{prestr}{c.RED}{midstr}{c.RESET}{poststr}')\n                print()\n                if options['fix']:\n                    content_arr[line_i] = rule['fixerFn'](line, m)\n                rule['found'] += 1\n    if options['fix']:\n        file.write_text('\\n'.join(content_arr))",
            "def lintfile(file: Path, rules: List[Rule], options: Dict[str, Any]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    content_arr = file.read_text().split('\\n')\n    for (line_i, line) in enumerate(content_arr):\n        if 'checkstyle-ignore' in line:\n            continue\n        for rule in rules:\n            should_run = False\n            if 'sh' in rule['fileTypes']:\n                if file.name.endswith('.sh') or str(file.absolute()).endswith('bin/asdf'):\n                    should_run = True\n            if 'bash' in rule['fileTypes']:\n                if file.name.endswith('.bash') or file.name.endswith('.bats'):\n                    should_run = True\n            if options['verbose']:\n                print(f'{str(file)}: {should_run}')\n            if not should_run:\n                continue\n            m = re.search(rule['regex'], line)\n            if m is not None and m.group('match') is not None:\n                dir = os.path.relpath(file.resolve(), Path.cwd())\n                prestr = line[0:m.start('match')]\n                midstr = line[m.start('match'):m.end('match')]\n                poststr = line[m.end('match'):]\n                print(f'{c.CYAN}{dir}{c.RESET}:{line_i + 1}')\n                print(f\"{c.MAGENTA}{rule['name']}{c.RESET}: {rule['reason']}\")\n                print(f'{prestr}{c.RED}{midstr}{c.RESET}{poststr}')\n                print()\n                if options['fix']:\n                    content_arr[line_i] = rule['fixerFn'](line, m)\n                rule['found'] += 1\n    if options['fix']:\n        file.write_text('\\n'.join(content_arr))",
            "def lintfile(file: Path, rules: List[Rule], options: Dict[str, Any]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    content_arr = file.read_text().split('\\n')\n    for (line_i, line) in enumerate(content_arr):\n        if 'checkstyle-ignore' in line:\n            continue\n        for rule in rules:\n            should_run = False\n            if 'sh' in rule['fileTypes']:\n                if file.name.endswith('.sh') or str(file.absolute()).endswith('bin/asdf'):\n                    should_run = True\n            if 'bash' in rule['fileTypes']:\n                if file.name.endswith('.bash') or file.name.endswith('.bats'):\n                    should_run = True\n            if options['verbose']:\n                print(f'{str(file)}: {should_run}')\n            if not should_run:\n                continue\n            m = re.search(rule['regex'], line)\n            if m is not None and m.group('match') is not None:\n                dir = os.path.relpath(file.resolve(), Path.cwd())\n                prestr = line[0:m.start('match')]\n                midstr = line[m.start('match'):m.end('match')]\n                poststr = line[m.end('match'):]\n                print(f'{c.CYAN}{dir}{c.RESET}:{line_i + 1}')\n                print(f\"{c.MAGENTA}{rule['name']}{c.RESET}: {rule['reason']}\")\n                print(f'{prestr}{c.RED}{midstr}{c.RESET}{poststr}')\n                print()\n                if options['fix']:\n                    content_arr[line_i] = rule['fixerFn'](line, m)\n                rule['found'] += 1\n    if options['fix']:\n        file.write_text('\\n'.join(content_arr))",
            "def lintfile(file: Path, rules: List[Rule], options: Dict[str, Any]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    content_arr = file.read_text().split('\\n')\n    for (line_i, line) in enumerate(content_arr):\n        if 'checkstyle-ignore' in line:\n            continue\n        for rule in rules:\n            should_run = False\n            if 'sh' in rule['fileTypes']:\n                if file.name.endswith('.sh') or str(file.absolute()).endswith('bin/asdf'):\n                    should_run = True\n            if 'bash' in rule['fileTypes']:\n                if file.name.endswith('.bash') or file.name.endswith('.bats'):\n                    should_run = True\n            if options['verbose']:\n                print(f'{str(file)}: {should_run}')\n            if not should_run:\n                continue\n            m = re.search(rule['regex'], line)\n            if m is not None and m.group('match') is not None:\n                dir = os.path.relpath(file.resolve(), Path.cwd())\n                prestr = line[0:m.start('match')]\n                midstr = line[m.start('match'):m.end('match')]\n                poststr = line[m.end('match'):]\n                print(f'{c.CYAN}{dir}{c.RESET}:{line_i + 1}')\n                print(f\"{c.MAGENTA}{rule['name']}{c.RESET}: {rule['reason']}\")\n                print(f'{prestr}{c.RED}{midstr}{c.RESET}{poststr}')\n                print()\n                if options['fix']:\n                    content_arr[line_i] = rule['fixerFn'](line, m)\n                rule['found'] += 1\n    if options['fix']:\n        file.write_text('\\n'.join(content_arr))"
        ]
    },
    {
        "func_name": "main",
        "original": "def main():\n    rules: List[Rule] = [{'name': 'no-double-backslash', 'regex': '\".*?(?P<match>\\\\\\\\\\\\\\\\[abeEfnrtv\\'\"?xuUc]).*?(?<!\\\\\\\\)\"', 'reason': 'Backslashes are only required if followed by a $, `, \", \\\\, or <newline>', 'fileTypes': ['bash', 'sh'], 'fixerFn': noDoubleBackslashFixer, 'testPositiveMatches': ['printf \"%s\\\\\\\\n\" \"Hai\"', 'echo -n \"Hello\\\\\\\\n\"'], 'testNegativeMatches': ['printf \"%s\\\\n\" \"Hai\"', 'echo -n \"Hello\\\\n\"']}, {'name': 'no-pwd-capture', 'regex': '(?P<match>\\\\$\\\\(pwd\\\\))', 'reason': '$PWD is essentially equivalent to $(pwd) without the overhead of a subshell', 'fileTypes': ['bash', 'sh'], 'fixerFn': noPwdCaptureFixer, 'testPositiveMatches': ['$(pwd)'], 'testNegativeMatches': ['$PWD']}, {'name': 'no-test-double-equals', 'regex': '(?<!\\\\[)\\\\[ (?:[^]]|](?=}))*?(?P<match>==).*?]', 'reason': 'Disallow double equals in places where they are not necessary for consistency', 'fileTypes': ['bash', 'sh'], 'fixerFn': noTestDoubleEqualsFixer, 'testPositiveMatches': ['[ a == b ]', '[ \"${lines[0]}\" == blah ]'], 'testNegativeMatches': ['[ a = b ]', '[[ a = b ]]', '[[ a == b ]]', '[ a = b ] || [[ a == b ]]', '[[ a = b ]] || [[ a == b ]]', '[[ \"${lines[0]}\" == \\'usage: \\'* ]]', '[ \"${lines[0]}\" = blah ]']}, {'name': 'no-function-keyword', 'regex': '^[ \\\\t]*(?P<match>function .*?(?:\\\\([ \\\\t]*\\\\))?[ \\\\t]*){', 'reason': 'Only allow functions declared like `fn_name() {{ :; }}` for consistency (see ' + c.LINK('https://www.shellcheck.net/wiki/SC2113', 'ShellCheck SC2113') + ')', 'fileTypes': ['bash', 'sh'], 'fixerFn': noFunctionKeywordFixer, 'testPositiveMatches': ['function fn() { :; }', 'function fn { :; }'], 'testNegativeMatches': ['fn() { :; }']}, {'name': 'no-verbose-redirection', 'regex': '(?P<match>(>/dev/null 2>&1|2>/dev/null 1>&2))', 'reason': 'Use `&>/dev/null` instead of `>/dev/null 2>&1` or `2>/dev/null 1>&2` for consistency', 'fileTypes': ['bash'], 'fixerFn': noVerboseRedirectionFixer, 'testPositiveMatches': ['echo woof >/dev/null 2>&1', 'echo woof 2>/dev/null 1>&2'], 'testNegativeMatches': ['echo woof &>/dev/null', 'echo woof >&/dev/null']}]\n    [rule.update({'found': 0}) for rule in rules]\n    parser = argparse.ArgumentParser()\n    parser.add_argument('files', metavar='FILES', nargs='*')\n    parser.add_argument('--fix', action='store_true')\n    parser.add_argument('--verbose', action='store_true')\n    parser.add_argument('--internal-test-regex', action='store_true')\n    args = parser.parse_args()\n    if args.internal_test_regex:\n        for rule in rules:\n            for positiveMatch in rule['testPositiveMatches']:\n                m: Any = re.search(rule['regex'], positiveMatch)\n                if m is None or m.group('match') is None:\n                    print(f\"{c.MAGENTA}{rule['name']}{c.RESET}: Failed {c.CYAN}positive{c.RESET} test:\")\n                    print(f'=> {positiveMatch}')\n                    print()\n            for negativeMatch in rule['testNegativeMatches']:\n                m: Any = re.search(rule['regex'], negativeMatch)\n                if m is not None and m.group('match') is not None:\n                    print(f\"{c.MAGENTA}{rule['name']}{c.RESET}: Failed {c.YELLOW}negative{c.RESET} test:\")\n                    print(f'=> {negativeMatch}')\n                    print()\n        print('Done.')\n        return\n    options = {'fix': args.fix, 'verbose': args.verbose}\n    if len(args.files) > 0:\n        for file in args.files:\n            p = Path(file)\n            if p.is_file():\n                lintfile(p, rules, options)\n    else:\n        for file in Path.cwd().glob('**/*'):\n            if '.git' in str(file.absolute()):\n                continue\n            if file.is_file():\n                lintfile(file, rules, options)\n    print(f'{c.UNDERLINE}TOTAL ISSUES{c.RESET}')\n    for rule in rules:\n        print(f\"{c.MAGENTA}{rule['name']}{c.RESET}: {rule['found']}\")\n    grand_total = sum([rule['found'] for rule in rules])\n    print(f'GRAND TOTAL: {grand_total}')\n    if grand_total == 0:\n        exit(0)\n    else:\n        exit(2)",
        "mutated": [
            "def main():\n    if False:\n        i = 10\n    rules: List[Rule] = [{'name': 'no-double-backslash', 'regex': '\".*?(?P<match>\\\\\\\\\\\\\\\\[abeEfnrtv\\'\"?xuUc]).*?(?<!\\\\\\\\)\"', 'reason': 'Backslashes are only required if followed by a $, `, \", \\\\, or <newline>', 'fileTypes': ['bash', 'sh'], 'fixerFn': noDoubleBackslashFixer, 'testPositiveMatches': ['printf \"%s\\\\\\\\n\" \"Hai\"', 'echo -n \"Hello\\\\\\\\n\"'], 'testNegativeMatches': ['printf \"%s\\\\n\" \"Hai\"', 'echo -n \"Hello\\\\n\"']}, {'name': 'no-pwd-capture', 'regex': '(?P<match>\\\\$\\\\(pwd\\\\))', 'reason': '$PWD is essentially equivalent to $(pwd) without the overhead of a subshell', 'fileTypes': ['bash', 'sh'], 'fixerFn': noPwdCaptureFixer, 'testPositiveMatches': ['$(pwd)'], 'testNegativeMatches': ['$PWD']}, {'name': 'no-test-double-equals', 'regex': '(?<!\\\\[)\\\\[ (?:[^]]|](?=}))*?(?P<match>==).*?]', 'reason': 'Disallow double equals in places where they are not necessary for consistency', 'fileTypes': ['bash', 'sh'], 'fixerFn': noTestDoubleEqualsFixer, 'testPositiveMatches': ['[ a == b ]', '[ \"${lines[0]}\" == blah ]'], 'testNegativeMatches': ['[ a = b ]', '[[ a = b ]]', '[[ a == b ]]', '[ a = b ] || [[ a == b ]]', '[[ a = b ]] || [[ a == b ]]', '[[ \"${lines[0]}\" == \\'usage: \\'* ]]', '[ \"${lines[0]}\" = blah ]']}, {'name': 'no-function-keyword', 'regex': '^[ \\\\t]*(?P<match>function .*?(?:\\\\([ \\\\t]*\\\\))?[ \\\\t]*){', 'reason': 'Only allow functions declared like `fn_name() {{ :; }}` for consistency (see ' + c.LINK('https://www.shellcheck.net/wiki/SC2113', 'ShellCheck SC2113') + ')', 'fileTypes': ['bash', 'sh'], 'fixerFn': noFunctionKeywordFixer, 'testPositiveMatches': ['function fn() { :; }', 'function fn { :; }'], 'testNegativeMatches': ['fn() { :; }']}, {'name': 'no-verbose-redirection', 'regex': '(?P<match>(>/dev/null 2>&1|2>/dev/null 1>&2))', 'reason': 'Use `&>/dev/null` instead of `>/dev/null 2>&1` or `2>/dev/null 1>&2` for consistency', 'fileTypes': ['bash'], 'fixerFn': noVerboseRedirectionFixer, 'testPositiveMatches': ['echo woof >/dev/null 2>&1', 'echo woof 2>/dev/null 1>&2'], 'testNegativeMatches': ['echo woof &>/dev/null', 'echo woof >&/dev/null']}]\n    [rule.update({'found': 0}) for rule in rules]\n    parser = argparse.ArgumentParser()\n    parser.add_argument('files', metavar='FILES', nargs='*')\n    parser.add_argument('--fix', action='store_true')\n    parser.add_argument('--verbose', action='store_true')\n    parser.add_argument('--internal-test-regex', action='store_true')\n    args = parser.parse_args()\n    if args.internal_test_regex:\n        for rule in rules:\n            for positiveMatch in rule['testPositiveMatches']:\n                m: Any = re.search(rule['regex'], positiveMatch)\n                if m is None or m.group('match') is None:\n                    print(f\"{c.MAGENTA}{rule['name']}{c.RESET}: Failed {c.CYAN}positive{c.RESET} test:\")\n                    print(f'=> {positiveMatch}')\n                    print()\n            for negativeMatch in rule['testNegativeMatches']:\n                m: Any = re.search(rule['regex'], negativeMatch)\n                if m is not None and m.group('match') is not None:\n                    print(f\"{c.MAGENTA}{rule['name']}{c.RESET}: Failed {c.YELLOW}negative{c.RESET} test:\")\n                    print(f'=> {negativeMatch}')\n                    print()\n        print('Done.')\n        return\n    options = {'fix': args.fix, 'verbose': args.verbose}\n    if len(args.files) > 0:\n        for file in args.files:\n            p = Path(file)\n            if p.is_file():\n                lintfile(p, rules, options)\n    else:\n        for file in Path.cwd().glob('**/*'):\n            if '.git' in str(file.absolute()):\n                continue\n            if file.is_file():\n                lintfile(file, rules, options)\n    print(f'{c.UNDERLINE}TOTAL ISSUES{c.RESET}')\n    for rule in rules:\n        print(f\"{c.MAGENTA}{rule['name']}{c.RESET}: {rule['found']}\")\n    grand_total = sum([rule['found'] for rule in rules])\n    print(f'GRAND TOTAL: {grand_total}')\n    if grand_total == 0:\n        exit(0)\n    else:\n        exit(2)",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    rules: List[Rule] = [{'name': 'no-double-backslash', 'regex': '\".*?(?P<match>\\\\\\\\\\\\\\\\[abeEfnrtv\\'\"?xuUc]).*?(?<!\\\\\\\\)\"', 'reason': 'Backslashes are only required if followed by a $, `, \", \\\\, or <newline>', 'fileTypes': ['bash', 'sh'], 'fixerFn': noDoubleBackslashFixer, 'testPositiveMatches': ['printf \"%s\\\\\\\\n\" \"Hai\"', 'echo -n \"Hello\\\\\\\\n\"'], 'testNegativeMatches': ['printf \"%s\\\\n\" \"Hai\"', 'echo -n \"Hello\\\\n\"']}, {'name': 'no-pwd-capture', 'regex': '(?P<match>\\\\$\\\\(pwd\\\\))', 'reason': '$PWD is essentially equivalent to $(pwd) without the overhead of a subshell', 'fileTypes': ['bash', 'sh'], 'fixerFn': noPwdCaptureFixer, 'testPositiveMatches': ['$(pwd)'], 'testNegativeMatches': ['$PWD']}, {'name': 'no-test-double-equals', 'regex': '(?<!\\\\[)\\\\[ (?:[^]]|](?=}))*?(?P<match>==).*?]', 'reason': 'Disallow double equals in places where they are not necessary for consistency', 'fileTypes': ['bash', 'sh'], 'fixerFn': noTestDoubleEqualsFixer, 'testPositiveMatches': ['[ a == b ]', '[ \"${lines[0]}\" == blah ]'], 'testNegativeMatches': ['[ a = b ]', '[[ a = b ]]', '[[ a == b ]]', '[ a = b ] || [[ a == b ]]', '[[ a = b ]] || [[ a == b ]]', '[[ \"${lines[0]}\" == \\'usage: \\'* ]]', '[ \"${lines[0]}\" = blah ]']}, {'name': 'no-function-keyword', 'regex': '^[ \\\\t]*(?P<match>function .*?(?:\\\\([ \\\\t]*\\\\))?[ \\\\t]*){', 'reason': 'Only allow functions declared like `fn_name() {{ :; }}` for consistency (see ' + c.LINK('https://www.shellcheck.net/wiki/SC2113', 'ShellCheck SC2113') + ')', 'fileTypes': ['bash', 'sh'], 'fixerFn': noFunctionKeywordFixer, 'testPositiveMatches': ['function fn() { :; }', 'function fn { :; }'], 'testNegativeMatches': ['fn() { :; }']}, {'name': 'no-verbose-redirection', 'regex': '(?P<match>(>/dev/null 2>&1|2>/dev/null 1>&2))', 'reason': 'Use `&>/dev/null` instead of `>/dev/null 2>&1` or `2>/dev/null 1>&2` for consistency', 'fileTypes': ['bash'], 'fixerFn': noVerboseRedirectionFixer, 'testPositiveMatches': ['echo woof >/dev/null 2>&1', 'echo woof 2>/dev/null 1>&2'], 'testNegativeMatches': ['echo woof &>/dev/null', 'echo woof >&/dev/null']}]\n    [rule.update({'found': 0}) for rule in rules]\n    parser = argparse.ArgumentParser()\n    parser.add_argument('files', metavar='FILES', nargs='*')\n    parser.add_argument('--fix', action='store_true')\n    parser.add_argument('--verbose', action='store_true')\n    parser.add_argument('--internal-test-regex', action='store_true')\n    args = parser.parse_args()\n    if args.internal_test_regex:\n        for rule in rules:\n            for positiveMatch in rule['testPositiveMatches']:\n                m: Any = re.search(rule['regex'], positiveMatch)\n                if m is None or m.group('match') is None:\n                    print(f\"{c.MAGENTA}{rule['name']}{c.RESET}: Failed {c.CYAN}positive{c.RESET} test:\")\n                    print(f'=> {positiveMatch}')\n                    print()\n            for negativeMatch in rule['testNegativeMatches']:\n                m: Any = re.search(rule['regex'], negativeMatch)\n                if m is not None and m.group('match') is not None:\n                    print(f\"{c.MAGENTA}{rule['name']}{c.RESET}: Failed {c.YELLOW}negative{c.RESET} test:\")\n                    print(f'=> {negativeMatch}')\n                    print()\n        print('Done.')\n        return\n    options = {'fix': args.fix, 'verbose': args.verbose}\n    if len(args.files) > 0:\n        for file in args.files:\n            p = Path(file)\n            if p.is_file():\n                lintfile(p, rules, options)\n    else:\n        for file in Path.cwd().glob('**/*'):\n            if '.git' in str(file.absolute()):\n                continue\n            if file.is_file():\n                lintfile(file, rules, options)\n    print(f'{c.UNDERLINE}TOTAL ISSUES{c.RESET}')\n    for rule in rules:\n        print(f\"{c.MAGENTA}{rule['name']}{c.RESET}: {rule['found']}\")\n    grand_total = sum([rule['found'] for rule in rules])\n    print(f'GRAND TOTAL: {grand_total}')\n    if grand_total == 0:\n        exit(0)\n    else:\n        exit(2)",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    rules: List[Rule] = [{'name': 'no-double-backslash', 'regex': '\".*?(?P<match>\\\\\\\\\\\\\\\\[abeEfnrtv\\'\"?xuUc]).*?(?<!\\\\\\\\)\"', 'reason': 'Backslashes are only required if followed by a $, `, \", \\\\, or <newline>', 'fileTypes': ['bash', 'sh'], 'fixerFn': noDoubleBackslashFixer, 'testPositiveMatches': ['printf \"%s\\\\\\\\n\" \"Hai\"', 'echo -n \"Hello\\\\\\\\n\"'], 'testNegativeMatches': ['printf \"%s\\\\n\" \"Hai\"', 'echo -n \"Hello\\\\n\"']}, {'name': 'no-pwd-capture', 'regex': '(?P<match>\\\\$\\\\(pwd\\\\))', 'reason': '$PWD is essentially equivalent to $(pwd) without the overhead of a subshell', 'fileTypes': ['bash', 'sh'], 'fixerFn': noPwdCaptureFixer, 'testPositiveMatches': ['$(pwd)'], 'testNegativeMatches': ['$PWD']}, {'name': 'no-test-double-equals', 'regex': '(?<!\\\\[)\\\\[ (?:[^]]|](?=}))*?(?P<match>==).*?]', 'reason': 'Disallow double equals in places where they are not necessary for consistency', 'fileTypes': ['bash', 'sh'], 'fixerFn': noTestDoubleEqualsFixer, 'testPositiveMatches': ['[ a == b ]', '[ \"${lines[0]}\" == blah ]'], 'testNegativeMatches': ['[ a = b ]', '[[ a = b ]]', '[[ a == b ]]', '[ a = b ] || [[ a == b ]]', '[[ a = b ]] || [[ a == b ]]', '[[ \"${lines[0]}\" == \\'usage: \\'* ]]', '[ \"${lines[0]}\" = blah ]']}, {'name': 'no-function-keyword', 'regex': '^[ \\\\t]*(?P<match>function .*?(?:\\\\([ \\\\t]*\\\\))?[ \\\\t]*){', 'reason': 'Only allow functions declared like `fn_name() {{ :; }}` for consistency (see ' + c.LINK('https://www.shellcheck.net/wiki/SC2113', 'ShellCheck SC2113') + ')', 'fileTypes': ['bash', 'sh'], 'fixerFn': noFunctionKeywordFixer, 'testPositiveMatches': ['function fn() { :; }', 'function fn { :; }'], 'testNegativeMatches': ['fn() { :; }']}, {'name': 'no-verbose-redirection', 'regex': '(?P<match>(>/dev/null 2>&1|2>/dev/null 1>&2))', 'reason': 'Use `&>/dev/null` instead of `>/dev/null 2>&1` or `2>/dev/null 1>&2` for consistency', 'fileTypes': ['bash'], 'fixerFn': noVerboseRedirectionFixer, 'testPositiveMatches': ['echo woof >/dev/null 2>&1', 'echo woof 2>/dev/null 1>&2'], 'testNegativeMatches': ['echo woof &>/dev/null', 'echo woof >&/dev/null']}]\n    [rule.update({'found': 0}) for rule in rules]\n    parser = argparse.ArgumentParser()\n    parser.add_argument('files', metavar='FILES', nargs='*')\n    parser.add_argument('--fix', action='store_true')\n    parser.add_argument('--verbose', action='store_true')\n    parser.add_argument('--internal-test-regex', action='store_true')\n    args = parser.parse_args()\n    if args.internal_test_regex:\n        for rule in rules:\n            for positiveMatch in rule['testPositiveMatches']:\n                m: Any = re.search(rule['regex'], positiveMatch)\n                if m is None or m.group('match') is None:\n                    print(f\"{c.MAGENTA}{rule['name']}{c.RESET}: Failed {c.CYAN}positive{c.RESET} test:\")\n                    print(f'=> {positiveMatch}')\n                    print()\n            for negativeMatch in rule['testNegativeMatches']:\n                m: Any = re.search(rule['regex'], negativeMatch)\n                if m is not None and m.group('match') is not None:\n                    print(f\"{c.MAGENTA}{rule['name']}{c.RESET}: Failed {c.YELLOW}negative{c.RESET} test:\")\n                    print(f'=> {negativeMatch}')\n                    print()\n        print('Done.')\n        return\n    options = {'fix': args.fix, 'verbose': args.verbose}\n    if len(args.files) > 0:\n        for file in args.files:\n            p = Path(file)\n            if p.is_file():\n                lintfile(p, rules, options)\n    else:\n        for file in Path.cwd().glob('**/*'):\n            if '.git' in str(file.absolute()):\n                continue\n            if file.is_file():\n                lintfile(file, rules, options)\n    print(f'{c.UNDERLINE}TOTAL ISSUES{c.RESET}')\n    for rule in rules:\n        print(f\"{c.MAGENTA}{rule['name']}{c.RESET}: {rule['found']}\")\n    grand_total = sum([rule['found'] for rule in rules])\n    print(f'GRAND TOTAL: {grand_total}')\n    if grand_total == 0:\n        exit(0)\n    else:\n        exit(2)",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    rules: List[Rule] = [{'name': 'no-double-backslash', 'regex': '\".*?(?P<match>\\\\\\\\\\\\\\\\[abeEfnrtv\\'\"?xuUc]).*?(?<!\\\\\\\\)\"', 'reason': 'Backslashes are only required if followed by a $, `, \", \\\\, or <newline>', 'fileTypes': ['bash', 'sh'], 'fixerFn': noDoubleBackslashFixer, 'testPositiveMatches': ['printf \"%s\\\\\\\\n\" \"Hai\"', 'echo -n \"Hello\\\\\\\\n\"'], 'testNegativeMatches': ['printf \"%s\\\\n\" \"Hai\"', 'echo -n \"Hello\\\\n\"']}, {'name': 'no-pwd-capture', 'regex': '(?P<match>\\\\$\\\\(pwd\\\\))', 'reason': '$PWD is essentially equivalent to $(pwd) without the overhead of a subshell', 'fileTypes': ['bash', 'sh'], 'fixerFn': noPwdCaptureFixer, 'testPositiveMatches': ['$(pwd)'], 'testNegativeMatches': ['$PWD']}, {'name': 'no-test-double-equals', 'regex': '(?<!\\\\[)\\\\[ (?:[^]]|](?=}))*?(?P<match>==).*?]', 'reason': 'Disallow double equals in places where they are not necessary for consistency', 'fileTypes': ['bash', 'sh'], 'fixerFn': noTestDoubleEqualsFixer, 'testPositiveMatches': ['[ a == b ]', '[ \"${lines[0]}\" == blah ]'], 'testNegativeMatches': ['[ a = b ]', '[[ a = b ]]', '[[ a == b ]]', '[ a = b ] || [[ a == b ]]', '[[ a = b ]] || [[ a == b ]]', '[[ \"${lines[0]}\" == \\'usage: \\'* ]]', '[ \"${lines[0]}\" = blah ]']}, {'name': 'no-function-keyword', 'regex': '^[ \\\\t]*(?P<match>function .*?(?:\\\\([ \\\\t]*\\\\))?[ \\\\t]*){', 'reason': 'Only allow functions declared like `fn_name() {{ :; }}` for consistency (see ' + c.LINK('https://www.shellcheck.net/wiki/SC2113', 'ShellCheck SC2113') + ')', 'fileTypes': ['bash', 'sh'], 'fixerFn': noFunctionKeywordFixer, 'testPositiveMatches': ['function fn() { :; }', 'function fn { :; }'], 'testNegativeMatches': ['fn() { :; }']}, {'name': 'no-verbose-redirection', 'regex': '(?P<match>(>/dev/null 2>&1|2>/dev/null 1>&2))', 'reason': 'Use `&>/dev/null` instead of `>/dev/null 2>&1` or `2>/dev/null 1>&2` for consistency', 'fileTypes': ['bash'], 'fixerFn': noVerboseRedirectionFixer, 'testPositiveMatches': ['echo woof >/dev/null 2>&1', 'echo woof 2>/dev/null 1>&2'], 'testNegativeMatches': ['echo woof &>/dev/null', 'echo woof >&/dev/null']}]\n    [rule.update({'found': 0}) for rule in rules]\n    parser = argparse.ArgumentParser()\n    parser.add_argument('files', metavar='FILES', nargs='*')\n    parser.add_argument('--fix', action='store_true')\n    parser.add_argument('--verbose', action='store_true')\n    parser.add_argument('--internal-test-regex', action='store_true')\n    args = parser.parse_args()\n    if args.internal_test_regex:\n        for rule in rules:\n            for positiveMatch in rule['testPositiveMatches']:\n                m: Any = re.search(rule['regex'], positiveMatch)\n                if m is None or m.group('match') is None:\n                    print(f\"{c.MAGENTA}{rule['name']}{c.RESET}: Failed {c.CYAN}positive{c.RESET} test:\")\n                    print(f'=> {positiveMatch}')\n                    print()\n            for negativeMatch in rule['testNegativeMatches']:\n                m: Any = re.search(rule['regex'], negativeMatch)\n                if m is not None and m.group('match') is not None:\n                    print(f\"{c.MAGENTA}{rule['name']}{c.RESET}: Failed {c.YELLOW}negative{c.RESET} test:\")\n                    print(f'=> {negativeMatch}')\n                    print()\n        print('Done.')\n        return\n    options = {'fix': args.fix, 'verbose': args.verbose}\n    if len(args.files) > 0:\n        for file in args.files:\n            p = Path(file)\n            if p.is_file():\n                lintfile(p, rules, options)\n    else:\n        for file in Path.cwd().glob('**/*'):\n            if '.git' in str(file.absolute()):\n                continue\n            if file.is_file():\n                lintfile(file, rules, options)\n    print(f'{c.UNDERLINE}TOTAL ISSUES{c.RESET}')\n    for rule in rules:\n        print(f\"{c.MAGENTA}{rule['name']}{c.RESET}: {rule['found']}\")\n    grand_total = sum([rule['found'] for rule in rules])\n    print(f'GRAND TOTAL: {grand_total}')\n    if grand_total == 0:\n        exit(0)\n    else:\n        exit(2)",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    rules: List[Rule] = [{'name': 'no-double-backslash', 'regex': '\".*?(?P<match>\\\\\\\\\\\\\\\\[abeEfnrtv\\'\"?xuUc]).*?(?<!\\\\\\\\)\"', 'reason': 'Backslashes are only required if followed by a $, `, \", \\\\, or <newline>', 'fileTypes': ['bash', 'sh'], 'fixerFn': noDoubleBackslashFixer, 'testPositiveMatches': ['printf \"%s\\\\\\\\n\" \"Hai\"', 'echo -n \"Hello\\\\\\\\n\"'], 'testNegativeMatches': ['printf \"%s\\\\n\" \"Hai\"', 'echo -n \"Hello\\\\n\"']}, {'name': 'no-pwd-capture', 'regex': '(?P<match>\\\\$\\\\(pwd\\\\))', 'reason': '$PWD is essentially equivalent to $(pwd) without the overhead of a subshell', 'fileTypes': ['bash', 'sh'], 'fixerFn': noPwdCaptureFixer, 'testPositiveMatches': ['$(pwd)'], 'testNegativeMatches': ['$PWD']}, {'name': 'no-test-double-equals', 'regex': '(?<!\\\\[)\\\\[ (?:[^]]|](?=}))*?(?P<match>==).*?]', 'reason': 'Disallow double equals in places where they are not necessary for consistency', 'fileTypes': ['bash', 'sh'], 'fixerFn': noTestDoubleEqualsFixer, 'testPositiveMatches': ['[ a == b ]', '[ \"${lines[0]}\" == blah ]'], 'testNegativeMatches': ['[ a = b ]', '[[ a = b ]]', '[[ a == b ]]', '[ a = b ] || [[ a == b ]]', '[[ a = b ]] || [[ a == b ]]', '[[ \"${lines[0]}\" == \\'usage: \\'* ]]', '[ \"${lines[0]}\" = blah ]']}, {'name': 'no-function-keyword', 'regex': '^[ \\\\t]*(?P<match>function .*?(?:\\\\([ \\\\t]*\\\\))?[ \\\\t]*){', 'reason': 'Only allow functions declared like `fn_name() {{ :; }}` for consistency (see ' + c.LINK('https://www.shellcheck.net/wiki/SC2113', 'ShellCheck SC2113') + ')', 'fileTypes': ['bash', 'sh'], 'fixerFn': noFunctionKeywordFixer, 'testPositiveMatches': ['function fn() { :; }', 'function fn { :; }'], 'testNegativeMatches': ['fn() { :; }']}, {'name': 'no-verbose-redirection', 'regex': '(?P<match>(>/dev/null 2>&1|2>/dev/null 1>&2))', 'reason': 'Use `&>/dev/null` instead of `>/dev/null 2>&1` or `2>/dev/null 1>&2` for consistency', 'fileTypes': ['bash'], 'fixerFn': noVerboseRedirectionFixer, 'testPositiveMatches': ['echo woof >/dev/null 2>&1', 'echo woof 2>/dev/null 1>&2'], 'testNegativeMatches': ['echo woof &>/dev/null', 'echo woof >&/dev/null']}]\n    [rule.update({'found': 0}) for rule in rules]\n    parser = argparse.ArgumentParser()\n    parser.add_argument('files', metavar='FILES', nargs='*')\n    parser.add_argument('--fix', action='store_true')\n    parser.add_argument('--verbose', action='store_true')\n    parser.add_argument('--internal-test-regex', action='store_true')\n    args = parser.parse_args()\n    if args.internal_test_regex:\n        for rule in rules:\n            for positiveMatch in rule['testPositiveMatches']:\n                m: Any = re.search(rule['regex'], positiveMatch)\n                if m is None or m.group('match') is None:\n                    print(f\"{c.MAGENTA}{rule['name']}{c.RESET}: Failed {c.CYAN}positive{c.RESET} test:\")\n                    print(f'=> {positiveMatch}')\n                    print()\n            for negativeMatch in rule['testNegativeMatches']:\n                m: Any = re.search(rule['regex'], negativeMatch)\n                if m is not None and m.group('match') is not None:\n                    print(f\"{c.MAGENTA}{rule['name']}{c.RESET}: Failed {c.YELLOW}negative{c.RESET} test:\")\n                    print(f'=> {negativeMatch}')\n                    print()\n        print('Done.')\n        return\n    options = {'fix': args.fix, 'verbose': args.verbose}\n    if len(args.files) > 0:\n        for file in args.files:\n            p = Path(file)\n            if p.is_file():\n                lintfile(p, rules, options)\n    else:\n        for file in Path.cwd().glob('**/*'):\n            if '.git' in str(file.absolute()):\n                continue\n            if file.is_file():\n                lintfile(file, rules, options)\n    print(f'{c.UNDERLINE}TOTAL ISSUES{c.RESET}')\n    for rule in rules:\n        print(f\"{c.MAGENTA}{rule['name']}{c.RESET}: {rule['found']}\")\n    grand_total = sum([rule['found'] for rule in rules])\n    print(f'GRAND TOTAL: {grand_total}')\n    if grand_total == 0:\n        exit(0)\n    else:\n        exit(2)"
        ]
    }
]