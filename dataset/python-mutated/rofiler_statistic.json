[
    {
        "func_name": "_nodename2opname",
        "original": "def _nodename2opname(name):\n    \"\"\"\n    convert static host node name to operator name\n    \"\"\"\n    op_name = name.replace(' compute', '')\n    op_name = op_name.replace(' dygraph', '')\n    op_name = op_name.replace(' pybind_imperative_func', '')\n    return op_name",
        "mutated": [
            "def _nodename2opname(name):\n    if False:\n        i = 10\n    '\\n    convert static host node name to operator name\\n    '\n    op_name = name.replace(' compute', '')\n    op_name = op_name.replace(' dygraph', '')\n    op_name = op_name.replace(' pybind_imperative_func', '')\n    return op_name",
            "def _nodename2opname(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    convert static host node name to operator name\\n    '\n    op_name = name.replace(' compute', '')\n    op_name = op_name.replace(' dygraph', '')\n    op_name = op_name.replace(' pybind_imperative_func', '')\n    return op_name",
            "def _nodename2opname(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    convert static host node name to operator name\\n    '\n    op_name = name.replace(' compute', '')\n    op_name = op_name.replace(' dygraph', '')\n    op_name = op_name.replace(' pybind_imperative_func', '')\n    return op_name",
            "def _nodename2opname(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    convert static host node name to operator name\\n    '\n    op_name = name.replace(' compute', '')\n    op_name = op_name.replace(' dygraph', '')\n    op_name = op_name.replace(' pybind_imperative_func', '')\n    return op_name",
            "def _nodename2opname(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    convert static host node name to operator name\\n    '\n    op_name = name.replace(' compute', '')\n    op_name = op_name.replace(' dygraph', '')\n    op_name = op_name.replace(' pybind_imperative_func', '')\n    return op_name"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, hostnode):\n    self.hostnode = hostnode\n    self.children_node = []\n    self.runtime_node = []\n    self.cpu_time = 0\n    self.self_cpu_time = 0\n    self.gpu_time = 0\n    self.self_gpu_time = 0\n    self.general_gpu_time = 0\n    self.self_general_gpu_time = 0\n    self.flops = 0",
        "mutated": [
            "def __init__(self, hostnode):\n    if False:\n        i = 10\n    self.hostnode = hostnode\n    self.children_node = []\n    self.runtime_node = []\n    self.cpu_time = 0\n    self.self_cpu_time = 0\n    self.gpu_time = 0\n    self.self_gpu_time = 0\n    self.general_gpu_time = 0\n    self.self_general_gpu_time = 0\n    self.flops = 0",
            "def __init__(self, hostnode):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.hostnode = hostnode\n    self.children_node = []\n    self.runtime_node = []\n    self.cpu_time = 0\n    self.self_cpu_time = 0\n    self.gpu_time = 0\n    self.self_gpu_time = 0\n    self.general_gpu_time = 0\n    self.self_general_gpu_time = 0\n    self.flops = 0",
            "def __init__(self, hostnode):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.hostnode = hostnode\n    self.children_node = []\n    self.runtime_node = []\n    self.cpu_time = 0\n    self.self_cpu_time = 0\n    self.gpu_time = 0\n    self.self_gpu_time = 0\n    self.general_gpu_time = 0\n    self.self_general_gpu_time = 0\n    self.flops = 0",
            "def __init__(self, hostnode):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.hostnode = hostnode\n    self.children_node = []\n    self.runtime_node = []\n    self.cpu_time = 0\n    self.self_cpu_time = 0\n    self.gpu_time = 0\n    self.self_gpu_time = 0\n    self.general_gpu_time = 0\n    self.self_general_gpu_time = 0\n    self.flops = 0",
            "def __init__(self, hostnode):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.hostnode = hostnode\n    self.children_node = []\n    self.runtime_node = []\n    self.cpu_time = 0\n    self.self_cpu_time = 0\n    self.gpu_time = 0\n    self.self_gpu_time = 0\n    self.general_gpu_time = 0\n    self.self_general_gpu_time = 0\n    self.flops = 0"
        ]
    },
    {
        "func_name": "cal_flops",
        "original": "def cal_flops(self):\n    if self.hostnode.type == TracerEventType.Operator:\n        if hasattr(self.hostnode, 'input_shapes'):\n            op_name = _nodename2opname(self.hostnode.name)\n            self.flops = flops(op_name, self.hostnode.input_shapes, self.hostnode.attributes)",
        "mutated": [
            "def cal_flops(self):\n    if False:\n        i = 10\n    if self.hostnode.type == TracerEventType.Operator:\n        if hasattr(self.hostnode, 'input_shapes'):\n            op_name = _nodename2opname(self.hostnode.name)\n            self.flops = flops(op_name, self.hostnode.input_shapes, self.hostnode.attributes)",
            "def cal_flops(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self.hostnode.type == TracerEventType.Operator:\n        if hasattr(self.hostnode, 'input_shapes'):\n            op_name = _nodename2opname(self.hostnode.name)\n            self.flops = flops(op_name, self.hostnode.input_shapes, self.hostnode.attributes)",
            "def cal_flops(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self.hostnode.type == TracerEventType.Operator:\n        if hasattr(self.hostnode, 'input_shapes'):\n            op_name = _nodename2opname(self.hostnode.name)\n            self.flops = flops(op_name, self.hostnode.input_shapes, self.hostnode.attributes)",
            "def cal_flops(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self.hostnode.type == TracerEventType.Operator:\n        if hasattr(self.hostnode, 'input_shapes'):\n            op_name = _nodename2opname(self.hostnode.name)\n            self.flops = flops(op_name, self.hostnode.input_shapes, self.hostnode.attributes)",
            "def cal_flops(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self.hostnode.type == TracerEventType.Operator:\n        if hasattr(self.hostnode, 'input_shapes'):\n            op_name = _nodename2opname(self.hostnode.name)\n            self.flops = flops(op_name, self.hostnode.input_shapes, self.hostnode.attributes)"
        ]
    },
    {
        "func_name": "cal_statistic",
        "original": "def cal_statistic(self):\n    self.cpu_time = self.hostnode.end_ns - self.hostnode.start_ns\n    self.self_cpu_time = self.cpu_time\n    self.cal_flops()\n    for child in self.children_node:\n        child.cal_flops()\n        child.cal_statistic()\n        self.gpu_time += child.gpu_time\n        self.general_gpu_time += child.general_gpu_time\n        self.self_cpu_time -= child.end_ns - child.start_ns\n        self.flops += child.flops\n    for rt in self.runtime_node:\n        rt.cal_statistic()\n        self.self_cpu_time -= rt.end_ns - rt.start_ns\n        self.gpu_time += rt.gpu_time\n        self.self_gpu_time += rt.gpu_time\n        self.general_gpu_time += rt.general_gpu_time\n        self.self_general_gpu_time += rt.general_gpu_time\n    for device in self.hostnode.device_node:\n        if device.type == TracerEventType.Kernel:\n            self.gpu_time += device.end_ns - device.start_ns\n            self.self_gpu_time += device.end_ns - device.start_ns\n        self.general_gpu_time += device.end_ns - device.start_ns\n        self.self_general_gpu_time += device.end_ns - device.start_ns",
        "mutated": [
            "def cal_statistic(self):\n    if False:\n        i = 10\n    self.cpu_time = self.hostnode.end_ns - self.hostnode.start_ns\n    self.self_cpu_time = self.cpu_time\n    self.cal_flops()\n    for child in self.children_node:\n        child.cal_flops()\n        child.cal_statistic()\n        self.gpu_time += child.gpu_time\n        self.general_gpu_time += child.general_gpu_time\n        self.self_cpu_time -= child.end_ns - child.start_ns\n        self.flops += child.flops\n    for rt in self.runtime_node:\n        rt.cal_statistic()\n        self.self_cpu_time -= rt.end_ns - rt.start_ns\n        self.gpu_time += rt.gpu_time\n        self.self_gpu_time += rt.gpu_time\n        self.general_gpu_time += rt.general_gpu_time\n        self.self_general_gpu_time += rt.general_gpu_time\n    for device in self.hostnode.device_node:\n        if device.type == TracerEventType.Kernel:\n            self.gpu_time += device.end_ns - device.start_ns\n            self.self_gpu_time += device.end_ns - device.start_ns\n        self.general_gpu_time += device.end_ns - device.start_ns\n        self.self_general_gpu_time += device.end_ns - device.start_ns",
            "def cal_statistic(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.cpu_time = self.hostnode.end_ns - self.hostnode.start_ns\n    self.self_cpu_time = self.cpu_time\n    self.cal_flops()\n    for child in self.children_node:\n        child.cal_flops()\n        child.cal_statistic()\n        self.gpu_time += child.gpu_time\n        self.general_gpu_time += child.general_gpu_time\n        self.self_cpu_time -= child.end_ns - child.start_ns\n        self.flops += child.flops\n    for rt in self.runtime_node:\n        rt.cal_statistic()\n        self.self_cpu_time -= rt.end_ns - rt.start_ns\n        self.gpu_time += rt.gpu_time\n        self.self_gpu_time += rt.gpu_time\n        self.general_gpu_time += rt.general_gpu_time\n        self.self_general_gpu_time += rt.general_gpu_time\n    for device in self.hostnode.device_node:\n        if device.type == TracerEventType.Kernel:\n            self.gpu_time += device.end_ns - device.start_ns\n            self.self_gpu_time += device.end_ns - device.start_ns\n        self.general_gpu_time += device.end_ns - device.start_ns\n        self.self_general_gpu_time += device.end_ns - device.start_ns",
            "def cal_statistic(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.cpu_time = self.hostnode.end_ns - self.hostnode.start_ns\n    self.self_cpu_time = self.cpu_time\n    self.cal_flops()\n    for child in self.children_node:\n        child.cal_flops()\n        child.cal_statistic()\n        self.gpu_time += child.gpu_time\n        self.general_gpu_time += child.general_gpu_time\n        self.self_cpu_time -= child.end_ns - child.start_ns\n        self.flops += child.flops\n    for rt in self.runtime_node:\n        rt.cal_statistic()\n        self.self_cpu_time -= rt.end_ns - rt.start_ns\n        self.gpu_time += rt.gpu_time\n        self.self_gpu_time += rt.gpu_time\n        self.general_gpu_time += rt.general_gpu_time\n        self.self_general_gpu_time += rt.general_gpu_time\n    for device in self.hostnode.device_node:\n        if device.type == TracerEventType.Kernel:\n            self.gpu_time += device.end_ns - device.start_ns\n            self.self_gpu_time += device.end_ns - device.start_ns\n        self.general_gpu_time += device.end_ns - device.start_ns\n        self.self_general_gpu_time += device.end_ns - device.start_ns",
            "def cal_statistic(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.cpu_time = self.hostnode.end_ns - self.hostnode.start_ns\n    self.self_cpu_time = self.cpu_time\n    self.cal_flops()\n    for child in self.children_node:\n        child.cal_flops()\n        child.cal_statistic()\n        self.gpu_time += child.gpu_time\n        self.general_gpu_time += child.general_gpu_time\n        self.self_cpu_time -= child.end_ns - child.start_ns\n        self.flops += child.flops\n    for rt in self.runtime_node:\n        rt.cal_statistic()\n        self.self_cpu_time -= rt.end_ns - rt.start_ns\n        self.gpu_time += rt.gpu_time\n        self.self_gpu_time += rt.gpu_time\n        self.general_gpu_time += rt.general_gpu_time\n        self.self_general_gpu_time += rt.general_gpu_time\n    for device in self.hostnode.device_node:\n        if device.type == TracerEventType.Kernel:\n            self.gpu_time += device.end_ns - device.start_ns\n            self.self_gpu_time += device.end_ns - device.start_ns\n        self.general_gpu_time += device.end_ns - device.start_ns\n        self.self_general_gpu_time += device.end_ns - device.start_ns",
            "def cal_statistic(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.cpu_time = self.hostnode.end_ns - self.hostnode.start_ns\n    self.self_cpu_time = self.cpu_time\n    self.cal_flops()\n    for child in self.children_node:\n        child.cal_flops()\n        child.cal_statistic()\n        self.gpu_time += child.gpu_time\n        self.general_gpu_time += child.general_gpu_time\n        self.self_cpu_time -= child.end_ns - child.start_ns\n        self.flops += child.flops\n    for rt in self.runtime_node:\n        rt.cal_statistic()\n        self.self_cpu_time -= rt.end_ns - rt.start_ns\n        self.gpu_time += rt.gpu_time\n        self.self_gpu_time += rt.gpu_time\n        self.general_gpu_time += rt.general_gpu_time\n        self.self_general_gpu_time += rt.general_gpu_time\n    for device in self.hostnode.device_node:\n        if device.type == TracerEventType.Kernel:\n            self.gpu_time += device.end_ns - device.start_ns\n            self.self_gpu_time += device.end_ns - device.start_ns\n        self.general_gpu_time += device.end_ns - device.start_ns\n        self.self_general_gpu_time += device.end_ns - device.start_ns"
        ]
    },
    {
        "func_name": "end_ns",
        "original": "@property\ndef end_ns(self):\n    return self.hostnode.end_ns",
        "mutated": [
            "@property\ndef end_ns(self):\n    if False:\n        i = 10\n    return self.hostnode.end_ns",
            "@property\ndef end_ns(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return self.hostnode.end_ns",
            "@property\ndef end_ns(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return self.hostnode.end_ns",
            "@property\ndef end_ns(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return self.hostnode.end_ns",
            "@property\ndef end_ns(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return self.hostnode.end_ns"
        ]
    },
    {
        "func_name": "start_ns",
        "original": "@property\ndef start_ns(self):\n    return self.hostnode.start_ns",
        "mutated": [
            "@property\ndef start_ns(self):\n    if False:\n        i = 10\n    return self.hostnode.start_ns",
            "@property\ndef start_ns(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return self.hostnode.start_ns",
            "@property\ndef start_ns(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return self.hostnode.start_ns",
            "@property\ndef start_ns(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return self.hostnode.start_ns",
            "@property\ndef start_ns(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return self.hostnode.start_ns"
        ]
    },
    {
        "func_name": "__getattr__",
        "original": "def __getattr__(self, name):\n    return getattr(self.hostnode, name)",
        "mutated": [
            "def __getattr__(self, name):\n    if False:\n        i = 10\n    return getattr(self.hostnode, name)",
            "def __getattr__(self, name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return getattr(self.hostnode, name)",
            "def __getattr__(self, name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return getattr(self.hostnode, name)",
            "def __getattr__(self, name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return getattr(self.hostnode, name)",
            "def __getattr__(self, name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return getattr(self.hostnode, name)"
        ]
    },
    {
        "func_name": "traverse_tree",
        "original": "def traverse_tree(nodetrees):\n    results = collections.defaultdict(list)\n    for (thread_id, rootnode) in nodetrees.items():\n        stack = []\n        stack.append(rootnode)\n        threadlist = results[thread_id]\n        while stack:\n            current_node = stack.pop()\n            threadlist.append(current_node)\n            for childnode in current_node.children_node:\n                stack.append(childnode)\n    return results",
        "mutated": [
            "def traverse_tree(nodetrees):\n    if False:\n        i = 10\n    results = collections.defaultdict(list)\n    for (thread_id, rootnode) in nodetrees.items():\n        stack = []\n        stack.append(rootnode)\n        threadlist = results[thread_id]\n        while stack:\n            current_node = stack.pop()\n            threadlist.append(current_node)\n            for childnode in current_node.children_node:\n                stack.append(childnode)\n    return results",
            "def traverse_tree(nodetrees):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    results = collections.defaultdict(list)\n    for (thread_id, rootnode) in nodetrees.items():\n        stack = []\n        stack.append(rootnode)\n        threadlist = results[thread_id]\n        while stack:\n            current_node = stack.pop()\n            threadlist.append(current_node)\n            for childnode in current_node.children_node:\n                stack.append(childnode)\n    return results",
            "def traverse_tree(nodetrees):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    results = collections.defaultdict(list)\n    for (thread_id, rootnode) in nodetrees.items():\n        stack = []\n        stack.append(rootnode)\n        threadlist = results[thread_id]\n        while stack:\n            current_node = stack.pop()\n            threadlist.append(current_node)\n            for childnode in current_node.children_node:\n                stack.append(childnode)\n    return results",
            "def traverse_tree(nodetrees):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    results = collections.defaultdict(list)\n    for (thread_id, rootnode) in nodetrees.items():\n        stack = []\n        stack.append(rootnode)\n        threadlist = results[thread_id]\n        while stack:\n            current_node = stack.pop()\n            threadlist.append(current_node)\n            for childnode in current_node.children_node:\n                stack.append(childnode)\n    return results",
            "def traverse_tree(nodetrees):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    results = collections.defaultdict(list)\n    for (thread_id, rootnode) in nodetrees.items():\n        stack = []\n        stack.append(rootnode)\n        threadlist = results[thread_id]\n        while stack:\n            current_node = stack.pop()\n            threadlist.append(current_node)\n            for childnode in current_node.children_node:\n                stack.append(childnode)\n    return results"
        ]
    },
    {
        "func_name": "get_device_nodes",
        "original": "def get_device_nodes(hostnode):\n    \"\"\"\n    Get all device nodes called in the time range of hostnode.\n    \"\"\"\n    stack = []\n    device_nodes = []\n    stack.append(hostnode)\n    while stack:\n        current_node = stack.pop()\n        for childnode in current_node.children_node:\n            stack.append(childnode)\n        for runtimenode in current_node.runtime_node:\n            for devicenode in runtimenode.device_node:\n                device_nodes.append(devicenode)\n    return device_nodes",
        "mutated": [
            "def get_device_nodes(hostnode):\n    if False:\n        i = 10\n    '\\n    Get all device nodes called in the time range of hostnode.\\n    '\n    stack = []\n    device_nodes = []\n    stack.append(hostnode)\n    while stack:\n        current_node = stack.pop()\n        for childnode in current_node.children_node:\n            stack.append(childnode)\n        for runtimenode in current_node.runtime_node:\n            for devicenode in runtimenode.device_node:\n                device_nodes.append(devicenode)\n    return device_nodes",
            "def get_device_nodes(hostnode):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Get all device nodes called in the time range of hostnode.\\n    '\n    stack = []\n    device_nodes = []\n    stack.append(hostnode)\n    while stack:\n        current_node = stack.pop()\n        for childnode in current_node.children_node:\n            stack.append(childnode)\n        for runtimenode in current_node.runtime_node:\n            for devicenode in runtimenode.device_node:\n                device_nodes.append(devicenode)\n    return device_nodes",
            "def get_device_nodes(hostnode):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Get all device nodes called in the time range of hostnode.\\n    '\n    stack = []\n    device_nodes = []\n    stack.append(hostnode)\n    while stack:\n        current_node = stack.pop()\n        for childnode in current_node.children_node:\n            stack.append(childnode)\n        for runtimenode in current_node.runtime_node:\n            for devicenode in runtimenode.device_node:\n                device_nodes.append(devicenode)\n    return device_nodes",
            "def get_device_nodes(hostnode):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Get all device nodes called in the time range of hostnode.\\n    '\n    stack = []\n    device_nodes = []\n    stack.append(hostnode)\n    while stack:\n        current_node = stack.pop()\n        for childnode in current_node.children_node:\n            stack.append(childnode)\n        for runtimenode in current_node.runtime_node:\n            for devicenode in runtimenode.device_node:\n                device_nodes.append(devicenode)\n    return device_nodes",
            "def get_device_nodes(hostnode):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Get all device nodes called in the time range of hostnode.\\n    '\n    stack = []\n    device_nodes = []\n    stack.append(hostnode)\n    while stack:\n        current_node = stack.pop()\n        for childnode in current_node.children_node:\n            stack.append(childnode)\n        for runtimenode in current_node.runtime_node:\n            for devicenode in runtimenode.device_node:\n                device_nodes.append(devicenode)\n    return device_nodes"
        ]
    },
    {
        "func_name": "build_layer",
        "original": "def build_layer(node, depth=0):\n    if 'GradNode' in node.name:\n        return ([], 0)\n    if node.type in [TracerEventType.Backward, TracerEventType.Optimization]:\n        return ([], 0)\n    if node.type == TracerEventType.Operator:\n        stat_node = HostStatisticNode(node)\n        stat_node.cal_statistic()\n        return (stat_node, stat_node.flops)\n    layer = []\n    nflops = 0\n    for c in node.children_node:\n        (l, f) = build_layer(c, depth + 1)\n        if l:\n            nflops += f\n            layer.append(l)\n    if node.type == TracerEventType.Forward:\n        stat_node = HostStatisticNode(node)\n        stat_node.cal_statistic()\n        stat_node.flops = nflops\n        return ([stat_node, layer], nflops)\n    return (layer, nflops)",
        "mutated": [
            "def build_layer(node, depth=0):\n    if False:\n        i = 10\n    if 'GradNode' in node.name:\n        return ([], 0)\n    if node.type in [TracerEventType.Backward, TracerEventType.Optimization]:\n        return ([], 0)\n    if node.type == TracerEventType.Operator:\n        stat_node = HostStatisticNode(node)\n        stat_node.cal_statistic()\n        return (stat_node, stat_node.flops)\n    layer = []\n    nflops = 0\n    for c in node.children_node:\n        (l, f) = build_layer(c, depth + 1)\n        if l:\n            nflops += f\n            layer.append(l)\n    if node.type == TracerEventType.Forward:\n        stat_node = HostStatisticNode(node)\n        stat_node.cal_statistic()\n        stat_node.flops = nflops\n        return ([stat_node, layer], nflops)\n    return (layer, nflops)",
            "def build_layer(node, depth=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if 'GradNode' in node.name:\n        return ([], 0)\n    if node.type in [TracerEventType.Backward, TracerEventType.Optimization]:\n        return ([], 0)\n    if node.type == TracerEventType.Operator:\n        stat_node = HostStatisticNode(node)\n        stat_node.cal_statistic()\n        return (stat_node, stat_node.flops)\n    layer = []\n    nflops = 0\n    for c in node.children_node:\n        (l, f) = build_layer(c, depth + 1)\n        if l:\n            nflops += f\n            layer.append(l)\n    if node.type == TracerEventType.Forward:\n        stat_node = HostStatisticNode(node)\n        stat_node.cal_statistic()\n        stat_node.flops = nflops\n        return ([stat_node, layer], nflops)\n    return (layer, nflops)",
            "def build_layer(node, depth=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if 'GradNode' in node.name:\n        return ([], 0)\n    if node.type in [TracerEventType.Backward, TracerEventType.Optimization]:\n        return ([], 0)\n    if node.type == TracerEventType.Operator:\n        stat_node = HostStatisticNode(node)\n        stat_node.cal_statistic()\n        return (stat_node, stat_node.flops)\n    layer = []\n    nflops = 0\n    for c in node.children_node:\n        (l, f) = build_layer(c, depth + 1)\n        if l:\n            nflops += f\n            layer.append(l)\n    if node.type == TracerEventType.Forward:\n        stat_node = HostStatisticNode(node)\n        stat_node.cal_statistic()\n        stat_node.flops = nflops\n        return ([stat_node, layer], nflops)\n    return (layer, nflops)",
            "def build_layer(node, depth=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if 'GradNode' in node.name:\n        return ([], 0)\n    if node.type in [TracerEventType.Backward, TracerEventType.Optimization]:\n        return ([], 0)\n    if node.type == TracerEventType.Operator:\n        stat_node = HostStatisticNode(node)\n        stat_node.cal_statistic()\n        return (stat_node, stat_node.flops)\n    layer = []\n    nflops = 0\n    for c in node.children_node:\n        (l, f) = build_layer(c, depth + 1)\n        if l:\n            nflops += f\n            layer.append(l)\n    if node.type == TracerEventType.Forward:\n        stat_node = HostStatisticNode(node)\n        stat_node.cal_statistic()\n        stat_node.flops = nflops\n        return ([stat_node, layer], nflops)\n    return (layer, nflops)",
            "def build_layer(node, depth=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if 'GradNode' in node.name:\n        return ([], 0)\n    if node.type in [TracerEventType.Backward, TracerEventType.Optimization]:\n        return ([], 0)\n    if node.type == TracerEventType.Operator:\n        stat_node = HostStatisticNode(node)\n        stat_node.cal_statistic()\n        return (stat_node, stat_node.flops)\n    layer = []\n    nflops = 0\n    for c in node.children_node:\n        (l, f) = build_layer(c, depth + 1)\n        if l:\n            nflops += f\n            layer.append(l)\n    if node.type == TracerEventType.Forward:\n        stat_node = HostStatisticNode(node)\n        stat_node.cal_statistic()\n        stat_node.flops = nflops\n        return ([stat_node, layer], nflops)\n    return (layer, nflops)"
        ]
    },
    {
        "func_name": "_build_layer_from_tree",
        "original": "def _build_layer_from_tree(nodetrees):\n\n    def build_layer(node, depth=0):\n        if 'GradNode' in node.name:\n            return ([], 0)\n        if node.type in [TracerEventType.Backward, TracerEventType.Optimization]:\n            return ([], 0)\n        if node.type == TracerEventType.Operator:\n            stat_node = HostStatisticNode(node)\n            stat_node.cal_statistic()\n            return (stat_node, stat_node.flops)\n        layer = []\n        nflops = 0\n        for c in node.children_node:\n            (l, f) = build_layer(c, depth + 1)\n            if l:\n                nflops += f\n                layer.append(l)\n        if node.type == TracerEventType.Forward:\n            stat_node = HostStatisticNode(node)\n            stat_node.cal_statistic()\n            stat_node.flops = nflops\n            return ([stat_node, layer], nflops)\n        return (layer, nflops)\n    ret = []\n    for (_, rootnode) in nodetrees.items():\n        (layer, _) = build_layer(rootnode)\n        ret.append(layer)\n    return ret",
        "mutated": [
            "def _build_layer_from_tree(nodetrees):\n    if False:\n        i = 10\n\n    def build_layer(node, depth=0):\n        if 'GradNode' in node.name:\n            return ([], 0)\n        if node.type in [TracerEventType.Backward, TracerEventType.Optimization]:\n            return ([], 0)\n        if node.type == TracerEventType.Operator:\n            stat_node = HostStatisticNode(node)\n            stat_node.cal_statistic()\n            return (stat_node, stat_node.flops)\n        layer = []\n        nflops = 0\n        for c in node.children_node:\n            (l, f) = build_layer(c, depth + 1)\n            if l:\n                nflops += f\n                layer.append(l)\n        if node.type == TracerEventType.Forward:\n            stat_node = HostStatisticNode(node)\n            stat_node.cal_statistic()\n            stat_node.flops = nflops\n            return ([stat_node, layer], nflops)\n        return (layer, nflops)\n    ret = []\n    for (_, rootnode) in nodetrees.items():\n        (layer, _) = build_layer(rootnode)\n        ret.append(layer)\n    return ret",
            "def _build_layer_from_tree(nodetrees):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    def build_layer(node, depth=0):\n        if 'GradNode' in node.name:\n            return ([], 0)\n        if node.type in [TracerEventType.Backward, TracerEventType.Optimization]:\n            return ([], 0)\n        if node.type == TracerEventType.Operator:\n            stat_node = HostStatisticNode(node)\n            stat_node.cal_statistic()\n            return (stat_node, stat_node.flops)\n        layer = []\n        nflops = 0\n        for c in node.children_node:\n            (l, f) = build_layer(c, depth + 1)\n            if l:\n                nflops += f\n                layer.append(l)\n        if node.type == TracerEventType.Forward:\n            stat_node = HostStatisticNode(node)\n            stat_node.cal_statistic()\n            stat_node.flops = nflops\n            return ([stat_node, layer], nflops)\n        return (layer, nflops)\n    ret = []\n    for (_, rootnode) in nodetrees.items():\n        (layer, _) = build_layer(rootnode)\n        ret.append(layer)\n    return ret",
            "def _build_layer_from_tree(nodetrees):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    def build_layer(node, depth=0):\n        if 'GradNode' in node.name:\n            return ([], 0)\n        if node.type in [TracerEventType.Backward, TracerEventType.Optimization]:\n            return ([], 0)\n        if node.type == TracerEventType.Operator:\n            stat_node = HostStatisticNode(node)\n            stat_node.cal_statistic()\n            return (stat_node, stat_node.flops)\n        layer = []\n        nflops = 0\n        for c in node.children_node:\n            (l, f) = build_layer(c, depth + 1)\n            if l:\n                nflops += f\n                layer.append(l)\n        if node.type == TracerEventType.Forward:\n            stat_node = HostStatisticNode(node)\n            stat_node.cal_statistic()\n            stat_node.flops = nflops\n            return ([stat_node, layer], nflops)\n        return (layer, nflops)\n    ret = []\n    for (_, rootnode) in nodetrees.items():\n        (layer, _) = build_layer(rootnode)\n        ret.append(layer)\n    return ret",
            "def _build_layer_from_tree(nodetrees):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    def build_layer(node, depth=0):\n        if 'GradNode' in node.name:\n            return ([], 0)\n        if node.type in [TracerEventType.Backward, TracerEventType.Optimization]:\n            return ([], 0)\n        if node.type == TracerEventType.Operator:\n            stat_node = HostStatisticNode(node)\n            stat_node.cal_statistic()\n            return (stat_node, stat_node.flops)\n        layer = []\n        nflops = 0\n        for c in node.children_node:\n            (l, f) = build_layer(c, depth + 1)\n            if l:\n                nflops += f\n                layer.append(l)\n        if node.type == TracerEventType.Forward:\n            stat_node = HostStatisticNode(node)\n            stat_node.cal_statistic()\n            stat_node.flops = nflops\n            return ([stat_node, layer], nflops)\n        return (layer, nflops)\n    ret = []\n    for (_, rootnode) in nodetrees.items():\n        (layer, _) = build_layer(rootnode)\n        ret.append(layer)\n    return ret",
            "def _build_layer_from_tree(nodetrees):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    def build_layer(node, depth=0):\n        if 'GradNode' in node.name:\n            return ([], 0)\n        if node.type in [TracerEventType.Backward, TracerEventType.Optimization]:\n            return ([], 0)\n        if node.type == TracerEventType.Operator:\n            stat_node = HostStatisticNode(node)\n            stat_node.cal_statistic()\n            return (stat_node, stat_node.flops)\n        layer = []\n        nflops = 0\n        for c in node.children_node:\n            (l, f) = build_layer(c, depth + 1)\n            if l:\n                nflops += f\n                layer.append(l)\n        if node.type == TracerEventType.Forward:\n            stat_node = HostStatisticNode(node)\n            stat_node.cal_statistic()\n            stat_node.flops = nflops\n            return ([stat_node, layer], nflops)\n        return (layer, nflops)\n    ret = []\n    for (_, rootnode) in nodetrees.items():\n        (layer, _) = build_layer(rootnode)\n        ret.append(layer)\n    return ret"
        ]
    },
    {
        "func_name": "_format_large_number",
        "original": "def _format_large_number(n, precision=2):\n    if n // 1000000000000.0 > 0:\n        return f'{round(n / 1000000000000.0, precision)} T'\n    if n // 1000000000.0 > 0:\n        return f'{round(n / 1000000000.0, precision)} G'\n    if n // 1000000.0 > 0:\n        return f'{round(n / 1000000.0, precision)} M'\n    if n // 1000.0 > 0:\n        return f'{round(n / 1000.0, precision)} K'\n    return f'{round(n, precision)}'",
        "mutated": [
            "def _format_large_number(n, precision=2):\n    if False:\n        i = 10\n    if n // 1000000000000.0 > 0:\n        return f'{round(n / 1000000000000.0, precision)} T'\n    if n // 1000000000.0 > 0:\n        return f'{round(n / 1000000000.0, precision)} G'\n    if n // 1000000.0 > 0:\n        return f'{round(n / 1000000.0, precision)} M'\n    if n // 1000.0 > 0:\n        return f'{round(n / 1000.0, precision)} K'\n    return f'{round(n, precision)}'",
            "def _format_large_number(n, precision=2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if n // 1000000000000.0 > 0:\n        return f'{round(n / 1000000000000.0, precision)} T'\n    if n // 1000000000.0 > 0:\n        return f'{round(n / 1000000000.0, precision)} G'\n    if n // 1000000.0 > 0:\n        return f'{round(n / 1000000.0, precision)} M'\n    if n // 1000.0 > 0:\n        return f'{round(n / 1000.0, precision)} K'\n    return f'{round(n, precision)}'",
            "def _format_large_number(n, precision=2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if n // 1000000000000.0 > 0:\n        return f'{round(n / 1000000000000.0, precision)} T'\n    if n // 1000000000.0 > 0:\n        return f'{round(n / 1000000000.0, precision)} G'\n    if n // 1000000.0 > 0:\n        return f'{round(n / 1000000.0, precision)} M'\n    if n // 1000.0 > 0:\n        return f'{round(n / 1000.0, precision)} K'\n    return f'{round(n, precision)}'",
            "def _format_large_number(n, precision=2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if n // 1000000000000.0 > 0:\n        return f'{round(n / 1000000000000.0, precision)} T'\n    if n // 1000000000.0 > 0:\n        return f'{round(n / 1000000000.0, precision)} G'\n    if n // 1000000.0 > 0:\n        return f'{round(n / 1000000.0, precision)} M'\n    if n // 1000.0 > 0:\n        return f'{round(n / 1000.0, precision)} K'\n    return f'{round(n, precision)}'",
            "def _format_large_number(n, precision=2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if n // 1000000000000.0 > 0:\n        return f'{round(n / 1000000000000.0, precision)} T'\n    if n // 1000000000.0 > 0:\n        return f'{round(n / 1000000000.0, precision)} G'\n    if n // 1000000.0 > 0:\n        return f'{round(n / 1000000.0, precision)} M'\n    if n // 1000.0 > 0:\n        return f'{round(n / 1000.0, precision)} K'\n    return f'{round(n, precision)}'"
        ]
    },
    {
        "func_name": "_format_time",
        "original": "def _format_time(n, precision=2):\n    if n // 1000000000.0 > 0:\n        return f'{round(n / 1000000000.0, precision)} s'\n    if n // 1000000.0 > 0:\n        return f'{round(n / 1000000.0, precision)} ms'\n    if n // 1000.0 > 0:\n        return f'{round(n / 1000.0, precision)} us'\n    return f'{round(n, precision)} ns'",
        "mutated": [
            "def _format_time(n, precision=2):\n    if False:\n        i = 10\n    if n // 1000000000.0 > 0:\n        return f'{round(n / 1000000000.0, precision)} s'\n    if n // 1000000.0 > 0:\n        return f'{round(n / 1000000.0, precision)} ms'\n    if n // 1000.0 > 0:\n        return f'{round(n / 1000.0, precision)} us'\n    return f'{round(n, precision)} ns'",
            "def _format_time(n, precision=2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if n // 1000000000.0 > 0:\n        return f'{round(n / 1000000000.0, precision)} s'\n    if n // 1000000.0 > 0:\n        return f'{round(n / 1000000.0, precision)} ms'\n    if n // 1000.0 > 0:\n        return f'{round(n / 1000.0, precision)} us'\n    return f'{round(n, precision)} ns'",
            "def _format_time(n, precision=2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if n // 1000000000.0 > 0:\n        return f'{round(n / 1000000000.0, precision)} s'\n    if n // 1000000.0 > 0:\n        return f'{round(n / 1000000.0, precision)} ms'\n    if n // 1000.0 > 0:\n        return f'{round(n / 1000.0, precision)} us'\n    return f'{round(n, precision)} ns'",
            "def _format_time(n, precision=2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if n // 1000000000.0 > 0:\n        return f'{round(n / 1000000000.0, precision)} s'\n    if n // 1000000.0 > 0:\n        return f'{round(n / 1000000.0, precision)} ms'\n    if n // 1000.0 > 0:\n        return f'{round(n / 1000.0, precision)} us'\n    return f'{round(n, precision)} ns'",
            "def _format_time(n, precision=2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if n // 1000000000.0 > 0:\n        return f'{round(n / 1000000000.0, precision)} s'\n    if n // 1000000.0 > 0:\n        return f'{round(n / 1000000.0, precision)} ms'\n    if n // 1000.0 > 0:\n        return f'{round(n / 1000.0, precision)} us'\n    return f'{round(n, precision)} ns'"
        ]
    },
    {
        "func_name": "print_layer_tree",
        "original": "def print_layer_tree(node, depth=0):\n    if isinstance(node, list):\n        for n in node:\n            print_layer_tree(n, depth + 1)\n    elif node.type in [TracerEventType.Forward, TracerEventType.Operator]:\n        if len(offset) == 0:\n            offset.append(depth)\n        name = _nodename2opname(node.name)\n        if depth == offset[-1] and len(ret) > 0 and ret[0].startswith(name):\n            loop.append(1)\n        if len(loop) >= repeat:\n            return ''.join(ret)\n        align = ' ' * (depth - offset[-1])\n        tm = _format_time(node.cpu_time)\n        flops_n = _format_large_number(node.flops)\n        flops_s = _format_large_number(node.flops * 1000000000.0 / node.cpu_time)\n        ret.append(f'{align}{name} latency: {tm}, FLOPs: {flops_n}, FLOPS: {flops_s}\\n')",
        "mutated": [
            "def print_layer_tree(node, depth=0):\n    if False:\n        i = 10\n    if isinstance(node, list):\n        for n in node:\n            print_layer_tree(n, depth + 1)\n    elif node.type in [TracerEventType.Forward, TracerEventType.Operator]:\n        if len(offset) == 0:\n            offset.append(depth)\n        name = _nodename2opname(node.name)\n        if depth == offset[-1] and len(ret) > 0 and ret[0].startswith(name):\n            loop.append(1)\n        if len(loop) >= repeat:\n            return ''.join(ret)\n        align = ' ' * (depth - offset[-1])\n        tm = _format_time(node.cpu_time)\n        flops_n = _format_large_number(node.flops)\n        flops_s = _format_large_number(node.flops * 1000000000.0 / node.cpu_time)\n        ret.append(f'{align}{name} latency: {tm}, FLOPs: {flops_n}, FLOPS: {flops_s}\\n')",
            "def print_layer_tree(node, depth=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if isinstance(node, list):\n        for n in node:\n            print_layer_tree(n, depth + 1)\n    elif node.type in [TracerEventType.Forward, TracerEventType.Operator]:\n        if len(offset) == 0:\n            offset.append(depth)\n        name = _nodename2opname(node.name)\n        if depth == offset[-1] and len(ret) > 0 and ret[0].startswith(name):\n            loop.append(1)\n        if len(loop) >= repeat:\n            return ''.join(ret)\n        align = ' ' * (depth - offset[-1])\n        tm = _format_time(node.cpu_time)\n        flops_n = _format_large_number(node.flops)\n        flops_s = _format_large_number(node.flops * 1000000000.0 / node.cpu_time)\n        ret.append(f'{align}{name} latency: {tm}, FLOPs: {flops_n}, FLOPS: {flops_s}\\n')",
            "def print_layer_tree(node, depth=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if isinstance(node, list):\n        for n in node:\n            print_layer_tree(n, depth + 1)\n    elif node.type in [TracerEventType.Forward, TracerEventType.Operator]:\n        if len(offset) == 0:\n            offset.append(depth)\n        name = _nodename2opname(node.name)\n        if depth == offset[-1] and len(ret) > 0 and ret[0].startswith(name):\n            loop.append(1)\n        if len(loop) >= repeat:\n            return ''.join(ret)\n        align = ' ' * (depth - offset[-1])\n        tm = _format_time(node.cpu_time)\n        flops_n = _format_large_number(node.flops)\n        flops_s = _format_large_number(node.flops * 1000000000.0 / node.cpu_time)\n        ret.append(f'{align}{name} latency: {tm}, FLOPs: {flops_n}, FLOPS: {flops_s}\\n')",
            "def print_layer_tree(node, depth=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if isinstance(node, list):\n        for n in node:\n            print_layer_tree(n, depth + 1)\n    elif node.type in [TracerEventType.Forward, TracerEventType.Operator]:\n        if len(offset) == 0:\n            offset.append(depth)\n        name = _nodename2opname(node.name)\n        if depth == offset[-1] and len(ret) > 0 and ret[0].startswith(name):\n            loop.append(1)\n        if len(loop) >= repeat:\n            return ''.join(ret)\n        align = ' ' * (depth - offset[-1])\n        tm = _format_time(node.cpu_time)\n        flops_n = _format_large_number(node.flops)\n        flops_s = _format_large_number(node.flops * 1000000000.0 / node.cpu_time)\n        ret.append(f'{align}{name} latency: {tm}, FLOPs: {flops_n}, FLOPS: {flops_s}\\n')",
            "def print_layer_tree(node, depth=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if isinstance(node, list):\n        for n in node:\n            print_layer_tree(n, depth + 1)\n    elif node.type in [TracerEventType.Forward, TracerEventType.Operator]:\n        if len(offset) == 0:\n            offset.append(depth)\n        name = _nodename2opname(node.name)\n        if depth == offset[-1] and len(ret) > 0 and ret[0].startswith(name):\n            loop.append(1)\n        if len(loop) >= repeat:\n            return ''.join(ret)\n        align = ' ' * (depth - offset[-1])\n        tm = _format_time(node.cpu_time)\n        flops_n = _format_large_number(node.flops)\n        flops_s = _format_large_number(node.flops * 1000000000.0 / node.cpu_time)\n        ret.append(f'{align}{name} latency: {tm}, FLOPs: {flops_n}, FLOPS: {flops_s}\\n')"
        ]
    },
    {
        "func_name": "_gen_layer_flops",
        "original": "def _gen_layer_flops(node, repeat=1):\n    ret = []\n    offset = []\n    loop = []\n\n    def print_layer_tree(node, depth=0):\n        if isinstance(node, list):\n            for n in node:\n                print_layer_tree(n, depth + 1)\n        elif node.type in [TracerEventType.Forward, TracerEventType.Operator]:\n            if len(offset) == 0:\n                offset.append(depth)\n            name = _nodename2opname(node.name)\n            if depth == offset[-1] and len(ret) > 0 and ret[0].startswith(name):\n                loop.append(1)\n            if len(loop) >= repeat:\n                return ''.join(ret)\n            align = ' ' * (depth - offset[-1])\n            tm = _format_time(node.cpu_time)\n            flops_n = _format_large_number(node.flops)\n            flops_s = _format_large_number(node.flops * 1000000000.0 / node.cpu_time)\n            ret.append(f'{align}{name} latency: {tm}, FLOPs: {flops_n}, FLOPS: {flops_s}\\n')\n    for n in node[1:]:\n        print_layer_tree(n)\n    return ''.join(ret)",
        "mutated": [
            "def _gen_layer_flops(node, repeat=1):\n    if False:\n        i = 10\n    ret = []\n    offset = []\n    loop = []\n\n    def print_layer_tree(node, depth=0):\n        if isinstance(node, list):\n            for n in node:\n                print_layer_tree(n, depth + 1)\n        elif node.type in [TracerEventType.Forward, TracerEventType.Operator]:\n            if len(offset) == 0:\n                offset.append(depth)\n            name = _nodename2opname(node.name)\n            if depth == offset[-1] and len(ret) > 0 and ret[0].startswith(name):\n                loop.append(1)\n            if len(loop) >= repeat:\n                return ''.join(ret)\n            align = ' ' * (depth - offset[-1])\n            tm = _format_time(node.cpu_time)\n            flops_n = _format_large_number(node.flops)\n            flops_s = _format_large_number(node.flops * 1000000000.0 / node.cpu_time)\n            ret.append(f'{align}{name} latency: {tm}, FLOPs: {flops_n}, FLOPS: {flops_s}\\n')\n    for n in node[1:]:\n        print_layer_tree(n)\n    return ''.join(ret)",
            "def _gen_layer_flops(node, repeat=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ret = []\n    offset = []\n    loop = []\n\n    def print_layer_tree(node, depth=0):\n        if isinstance(node, list):\n            for n in node:\n                print_layer_tree(n, depth + 1)\n        elif node.type in [TracerEventType.Forward, TracerEventType.Operator]:\n            if len(offset) == 0:\n                offset.append(depth)\n            name = _nodename2opname(node.name)\n            if depth == offset[-1] and len(ret) > 0 and ret[0].startswith(name):\n                loop.append(1)\n            if len(loop) >= repeat:\n                return ''.join(ret)\n            align = ' ' * (depth - offset[-1])\n            tm = _format_time(node.cpu_time)\n            flops_n = _format_large_number(node.flops)\n            flops_s = _format_large_number(node.flops * 1000000000.0 / node.cpu_time)\n            ret.append(f'{align}{name} latency: {tm}, FLOPs: {flops_n}, FLOPS: {flops_s}\\n')\n    for n in node[1:]:\n        print_layer_tree(n)\n    return ''.join(ret)",
            "def _gen_layer_flops(node, repeat=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ret = []\n    offset = []\n    loop = []\n\n    def print_layer_tree(node, depth=0):\n        if isinstance(node, list):\n            for n in node:\n                print_layer_tree(n, depth + 1)\n        elif node.type in [TracerEventType.Forward, TracerEventType.Operator]:\n            if len(offset) == 0:\n                offset.append(depth)\n            name = _nodename2opname(node.name)\n            if depth == offset[-1] and len(ret) > 0 and ret[0].startswith(name):\n                loop.append(1)\n            if len(loop) >= repeat:\n                return ''.join(ret)\n            align = ' ' * (depth - offset[-1])\n            tm = _format_time(node.cpu_time)\n            flops_n = _format_large_number(node.flops)\n            flops_s = _format_large_number(node.flops * 1000000000.0 / node.cpu_time)\n            ret.append(f'{align}{name} latency: {tm}, FLOPs: {flops_n}, FLOPS: {flops_s}\\n')\n    for n in node[1:]:\n        print_layer_tree(n)\n    return ''.join(ret)",
            "def _gen_layer_flops(node, repeat=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ret = []\n    offset = []\n    loop = []\n\n    def print_layer_tree(node, depth=0):\n        if isinstance(node, list):\n            for n in node:\n                print_layer_tree(n, depth + 1)\n        elif node.type in [TracerEventType.Forward, TracerEventType.Operator]:\n            if len(offset) == 0:\n                offset.append(depth)\n            name = _nodename2opname(node.name)\n            if depth == offset[-1] and len(ret) > 0 and ret[0].startswith(name):\n                loop.append(1)\n            if len(loop) >= repeat:\n                return ''.join(ret)\n            align = ' ' * (depth - offset[-1])\n            tm = _format_time(node.cpu_time)\n            flops_n = _format_large_number(node.flops)\n            flops_s = _format_large_number(node.flops * 1000000000.0 / node.cpu_time)\n            ret.append(f'{align}{name} latency: {tm}, FLOPs: {flops_n}, FLOPS: {flops_s}\\n')\n    for n in node[1:]:\n        print_layer_tree(n)\n    return ''.join(ret)",
            "def _gen_layer_flops(node, repeat=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ret = []\n    offset = []\n    loop = []\n\n    def print_layer_tree(node, depth=0):\n        if isinstance(node, list):\n            for n in node:\n                print_layer_tree(n, depth + 1)\n        elif node.type in [TracerEventType.Forward, TracerEventType.Operator]:\n            if len(offset) == 0:\n                offset.append(depth)\n            name = _nodename2opname(node.name)\n            if depth == offset[-1] and len(ret) > 0 and ret[0].startswith(name):\n                loop.append(1)\n            if len(loop) >= repeat:\n                return ''.join(ret)\n            align = ' ' * (depth - offset[-1])\n            tm = _format_time(node.cpu_time)\n            flops_n = _format_large_number(node.flops)\n            flops_s = _format_large_number(node.flops * 1000000000.0 / node.cpu_time)\n            ret.append(f'{align}{name} latency: {tm}, FLOPs: {flops_n}, FLOPS: {flops_s}\\n')\n    for n in node[1:]:\n        print_layer_tree(n)\n    return ''.join(ret)"
        ]
    },
    {
        "func_name": "gen_layer_flops",
        "original": "def gen_layer_flops(nodetrees, repeat=1):\n    \"\"\"\n    gen_layer_flops generate flops/runtime information depend on layer/operator.\n    \"\"\"\n    layer_tree = _build_layer_from_tree(nodetrees)\n    return _gen_layer_flops(layer_tree, repeat)",
        "mutated": [
            "def gen_layer_flops(nodetrees, repeat=1):\n    if False:\n        i = 10\n    '\\n    gen_layer_flops generate flops/runtime information depend on layer/operator.\\n    '\n    layer_tree = _build_layer_from_tree(nodetrees)\n    return _gen_layer_flops(layer_tree, repeat)",
            "def gen_layer_flops(nodetrees, repeat=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    gen_layer_flops generate flops/runtime information depend on layer/operator.\\n    '\n    layer_tree = _build_layer_from_tree(nodetrees)\n    return _gen_layer_flops(layer_tree, repeat)",
            "def gen_layer_flops(nodetrees, repeat=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    gen_layer_flops generate flops/runtime information depend on layer/operator.\\n    '\n    layer_tree = _build_layer_from_tree(nodetrees)\n    return _gen_layer_flops(layer_tree, repeat)",
            "def gen_layer_flops(nodetrees, repeat=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    gen_layer_flops generate flops/runtime information depend on layer/operator.\\n    '\n    layer_tree = _build_layer_from_tree(nodetrees)\n    return _gen_layer_flops(layer_tree, repeat)",
            "def gen_layer_flops(nodetrees, repeat=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    gen_layer_flops generate flops/runtime information depend on layer/operator.\\n    '\n    layer_tree = _build_layer_from_tree(nodetrees)\n    return _gen_layer_flops(layer_tree, repeat)"
        ]
    },
    {
        "func_name": "wrap_tree",
        "original": "def wrap_tree(nodetrees):\n    \"\"\"\n    Using HostStatisticNode to wrap original profiler result tree, and calculate node statistic metrics.\n    \"\"\"\n    node_statistic_tree = {}\n    results = collections.defaultdict(list)\n    newresults = collections.defaultdict(list)\n    for (thread_id, rootnode) in nodetrees.items():\n        stack = []\n        stack.append(rootnode)\n        root_statistic_node = HostStatisticNode(rootnode)\n        newstack = []\n        newstack.append(root_statistic_node)\n        node_statistic_tree[thread_id] = root_statistic_node\n        threadlist = results[thread_id]\n        newthreadlist = newresults[thread_id]\n        while stack:\n            current_node = stack.pop()\n            threadlist.append(current_node)\n            current_statistic_node = newstack.pop()\n            newthreadlist.append(current_statistic_node)\n            for childnode in current_node.children_node:\n                stack.append(childnode)\n                child_statistic_node = HostStatisticNode(childnode)\n                current_statistic_node.children_node.append(child_statistic_node)\n                newstack.append(child_statistic_node)\n            for runtimenode in current_node.runtime_node:\n                runtime_statistic_node = HostStatisticNode(runtimenode)\n                current_statistic_node.runtime_node.append(runtime_statistic_node)\n    for (thread_id, root_statistic_node) in node_statistic_tree.items():\n        root_statistic_node.cal_statistic()\n    return (node_statistic_tree, newresults)",
        "mutated": [
            "def wrap_tree(nodetrees):\n    if False:\n        i = 10\n    '\\n    Using HostStatisticNode to wrap original profiler result tree, and calculate node statistic metrics.\\n    '\n    node_statistic_tree = {}\n    results = collections.defaultdict(list)\n    newresults = collections.defaultdict(list)\n    for (thread_id, rootnode) in nodetrees.items():\n        stack = []\n        stack.append(rootnode)\n        root_statistic_node = HostStatisticNode(rootnode)\n        newstack = []\n        newstack.append(root_statistic_node)\n        node_statistic_tree[thread_id] = root_statistic_node\n        threadlist = results[thread_id]\n        newthreadlist = newresults[thread_id]\n        while stack:\n            current_node = stack.pop()\n            threadlist.append(current_node)\n            current_statistic_node = newstack.pop()\n            newthreadlist.append(current_statistic_node)\n            for childnode in current_node.children_node:\n                stack.append(childnode)\n                child_statistic_node = HostStatisticNode(childnode)\n                current_statistic_node.children_node.append(child_statistic_node)\n                newstack.append(child_statistic_node)\n            for runtimenode in current_node.runtime_node:\n                runtime_statistic_node = HostStatisticNode(runtimenode)\n                current_statistic_node.runtime_node.append(runtime_statistic_node)\n    for (thread_id, root_statistic_node) in node_statistic_tree.items():\n        root_statistic_node.cal_statistic()\n    return (node_statistic_tree, newresults)",
            "def wrap_tree(nodetrees):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Using HostStatisticNode to wrap original profiler result tree, and calculate node statistic metrics.\\n    '\n    node_statistic_tree = {}\n    results = collections.defaultdict(list)\n    newresults = collections.defaultdict(list)\n    for (thread_id, rootnode) in nodetrees.items():\n        stack = []\n        stack.append(rootnode)\n        root_statistic_node = HostStatisticNode(rootnode)\n        newstack = []\n        newstack.append(root_statistic_node)\n        node_statistic_tree[thread_id] = root_statistic_node\n        threadlist = results[thread_id]\n        newthreadlist = newresults[thread_id]\n        while stack:\n            current_node = stack.pop()\n            threadlist.append(current_node)\n            current_statistic_node = newstack.pop()\n            newthreadlist.append(current_statistic_node)\n            for childnode in current_node.children_node:\n                stack.append(childnode)\n                child_statistic_node = HostStatisticNode(childnode)\n                current_statistic_node.children_node.append(child_statistic_node)\n                newstack.append(child_statistic_node)\n            for runtimenode in current_node.runtime_node:\n                runtime_statistic_node = HostStatisticNode(runtimenode)\n                current_statistic_node.runtime_node.append(runtime_statistic_node)\n    for (thread_id, root_statistic_node) in node_statistic_tree.items():\n        root_statistic_node.cal_statistic()\n    return (node_statistic_tree, newresults)",
            "def wrap_tree(nodetrees):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Using HostStatisticNode to wrap original profiler result tree, and calculate node statistic metrics.\\n    '\n    node_statistic_tree = {}\n    results = collections.defaultdict(list)\n    newresults = collections.defaultdict(list)\n    for (thread_id, rootnode) in nodetrees.items():\n        stack = []\n        stack.append(rootnode)\n        root_statistic_node = HostStatisticNode(rootnode)\n        newstack = []\n        newstack.append(root_statistic_node)\n        node_statistic_tree[thread_id] = root_statistic_node\n        threadlist = results[thread_id]\n        newthreadlist = newresults[thread_id]\n        while stack:\n            current_node = stack.pop()\n            threadlist.append(current_node)\n            current_statistic_node = newstack.pop()\n            newthreadlist.append(current_statistic_node)\n            for childnode in current_node.children_node:\n                stack.append(childnode)\n                child_statistic_node = HostStatisticNode(childnode)\n                current_statistic_node.children_node.append(child_statistic_node)\n                newstack.append(child_statistic_node)\n            for runtimenode in current_node.runtime_node:\n                runtime_statistic_node = HostStatisticNode(runtimenode)\n                current_statistic_node.runtime_node.append(runtime_statistic_node)\n    for (thread_id, root_statistic_node) in node_statistic_tree.items():\n        root_statistic_node.cal_statistic()\n    return (node_statistic_tree, newresults)",
            "def wrap_tree(nodetrees):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Using HostStatisticNode to wrap original profiler result tree, and calculate node statistic metrics.\\n    '\n    node_statistic_tree = {}\n    results = collections.defaultdict(list)\n    newresults = collections.defaultdict(list)\n    for (thread_id, rootnode) in nodetrees.items():\n        stack = []\n        stack.append(rootnode)\n        root_statistic_node = HostStatisticNode(rootnode)\n        newstack = []\n        newstack.append(root_statistic_node)\n        node_statistic_tree[thread_id] = root_statistic_node\n        threadlist = results[thread_id]\n        newthreadlist = newresults[thread_id]\n        while stack:\n            current_node = stack.pop()\n            threadlist.append(current_node)\n            current_statistic_node = newstack.pop()\n            newthreadlist.append(current_statistic_node)\n            for childnode in current_node.children_node:\n                stack.append(childnode)\n                child_statistic_node = HostStatisticNode(childnode)\n                current_statistic_node.children_node.append(child_statistic_node)\n                newstack.append(child_statistic_node)\n            for runtimenode in current_node.runtime_node:\n                runtime_statistic_node = HostStatisticNode(runtimenode)\n                current_statistic_node.runtime_node.append(runtime_statistic_node)\n    for (thread_id, root_statistic_node) in node_statistic_tree.items():\n        root_statistic_node.cal_statistic()\n    return (node_statistic_tree, newresults)",
            "def wrap_tree(nodetrees):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Using HostStatisticNode to wrap original profiler result tree, and calculate node statistic metrics.\\n    '\n    node_statistic_tree = {}\n    results = collections.defaultdict(list)\n    newresults = collections.defaultdict(list)\n    for (thread_id, rootnode) in nodetrees.items():\n        stack = []\n        stack.append(rootnode)\n        root_statistic_node = HostStatisticNode(rootnode)\n        newstack = []\n        newstack.append(root_statistic_node)\n        node_statistic_tree[thread_id] = root_statistic_node\n        threadlist = results[thread_id]\n        newthreadlist = newresults[thread_id]\n        while stack:\n            current_node = stack.pop()\n            threadlist.append(current_node)\n            current_statistic_node = newstack.pop()\n            newthreadlist.append(current_statistic_node)\n            for childnode in current_node.children_node:\n                stack.append(childnode)\n                child_statistic_node = HostStatisticNode(childnode)\n                current_statistic_node.children_node.append(child_statistic_node)\n                newstack.append(child_statistic_node)\n            for runtimenode in current_node.runtime_node:\n                runtime_statistic_node = HostStatisticNode(runtimenode)\n                current_statistic_node.runtime_node.append(runtime_statistic_node)\n    for (thread_id, root_statistic_node) in node_statistic_tree.items():\n        root_statistic_node.cal_statistic()\n    return (node_statistic_tree, newresults)"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self):\n    self.CPUTimeRange = collections.defaultdict(list)\n    self.GPUTimeRange = collections.defaultdict(lambda : collections.defaultdict(list))\n    self.CPUTimeRangeSum = collections.defaultdict(int)\n    self.GPUTimeRangeSum = collections.defaultdict(lambda : collections.defaultdict(int))\n    self.call_times = collections.defaultdict(int)",
        "mutated": [
            "def __init__(self):\n    if False:\n        i = 10\n    self.CPUTimeRange = collections.defaultdict(list)\n    self.GPUTimeRange = collections.defaultdict(lambda : collections.defaultdict(list))\n    self.CPUTimeRangeSum = collections.defaultdict(int)\n    self.GPUTimeRangeSum = collections.defaultdict(lambda : collections.defaultdict(int))\n    self.call_times = collections.defaultdict(int)",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.CPUTimeRange = collections.defaultdict(list)\n    self.GPUTimeRange = collections.defaultdict(lambda : collections.defaultdict(list))\n    self.CPUTimeRangeSum = collections.defaultdict(int)\n    self.GPUTimeRangeSum = collections.defaultdict(lambda : collections.defaultdict(int))\n    self.call_times = collections.defaultdict(int)",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.CPUTimeRange = collections.defaultdict(list)\n    self.GPUTimeRange = collections.defaultdict(lambda : collections.defaultdict(list))\n    self.CPUTimeRangeSum = collections.defaultdict(int)\n    self.GPUTimeRangeSum = collections.defaultdict(lambda : collections.defaultdict(int))\n    self.call_times = collections.defaultdict(int)",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.CPUTimeRange = collections.defaultdict(list)\n    self.GPUTimeRange = collections.defaultdict(lambda : collections.defaultdict(list))\n    self.CPUTimeRangeSum = collections.defaultdict(int)\n    self.GPUTimeRangeSum = collections.defaultdict(lambda : collections.defaultdict(int))\n    self.call_times = collections.defaultdict(int)",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.CPUTimeRange = collections.defaultdict(list)\n    self.GPUTimeRange = collections.defaultdict(lambda : collections.defaultdict(list))\n    self.CPUTimeRangeSum = collections.defaultdict(int)\n    self.GPUTimeRangeSum = collections.defaultdict(lambda : collections.defaultdict(int))\n    self.call_times = collections.defaultdict(int)"
        ]
    },
    {
        "func_name": "parse",
        "original": "def parse(self, nodetrees):\n    \"\"\"\n        Analysis node trees in profiler result, and get time range for different tracer event type.\n        \"\"\"\n    thread2hostnodes = traverse_tree(nodetrees)\n    for (threadid, hostnodes) in thread2hostnodes.items():\n        CPUTimeRange = collections.defaultdict(list)\n        GPUTimeRange = collections.defaultdict(lambda : collections.defaultdict(lambda : collections.defaultdict(list)))\n        for hostnode in hostnodes[1:]:\n            CPUTimeRange[hostnode.type].append((hostnode.start_ns, hostnode.end_ns))\n            self.call_times[hostnode.type] += 1\n            for runtimenode in hostnode.runtime_node:\n                CPUTimeRange[runtimenode.type].append((runtimenode.start_ns, runtimenode.end_ns))\n                self.call_times[runtimenode.type] += 1\n                for devicenode in runtimenode.device_node:\n                    GPUTimeRange[devicenode.device_id][devicenode.type][devicenode.stream_id].append((devicenode.start_ns, devicenode.end_ns))\n                    self.call_times[devicenode.type] += 1\n        for (event_type, time_ranges) in CPUTimeRange.items():\n            time_ranges = merge_self_ranges(time_ranges, is_sorted=False)\n            self.CPUTimeRange[event_type] = merge_ranges(self.CPUTimeRange[event_type], time_ranges, is_sorted=True)\n        for (device_id, device_time_ranges) in GPUTimeRange.items():\n            for (event_type, event_time_ranges) in device_time_ranges.items():\n                for (stream_id, time_ranges) in event_time_ranges.items():\n                    time_ranges = merge_self_ranges(time_ranges, is_sorted=False)\n                    self.GPUTimeRange[device_id][event_type] = merge_ranges(self.GPUTimeRange[device_id][event_type], time_ranges, is_sorted=True)\n    for (event_type, time_ranges) in self.CPUTimeRange.items():\n        self.CPUTimeRangeSum[event_type] = sum_ranges(time_ranges)\n    for (device_id, device_time_ranges) in self.GPUTimeRange.items():\n        for (event_type, time_ranges) in device_time_ranges.items():\n            self.GPUTimeRangeSum[device_id][event_type] = sum_ranges(time_ranges)",
        "mutated": [
            "def parse(self, nodetrees):\n    if False:\n        i = 10\n    '\\n        Analysis node trees in profiler result, and get time range for different tracer event type.\\n        '\n    thread2hostnodes = traverse_tree(nodetrees)\n    for (threadid, hostnodes) in thread2hostnodes.items():\n        CPUTimeRange = collections.defaultdict(list)\n        GPUTimeRange = collections.defaultdict(lambda : collections.defaultdict(lambda : collections.defaultdict(list)))\n        for hostnode in hostnodes[1:]:\n            CPUTimeRange[hostnode.type].append((hostnode.start_ns, hostnode.end_ns))\n            self.call_times[hostnode.type] += 1\n            for runtimenode in hostnode.runtime_node:\n                CPUTimeRange[runtimenode.type].append((runtimenode.start_ns, runtimenode.end_ns))\n                self.call_times[runtimenode.type] += 1\n                for devicenode in runtimenode.device_node:\n                    GPUTimeRange[devicenode.device_id][devicenode.type][devicenode.stream_id].append((devicenode.start_ns, devicenode.end_ns))\n                    self.call_times[devicenode.type] += 1\n        for (event_type, time_ranges) in CPUTimeRange.items():\n            time_ranges = merge_self_ranges(time_ranges, is_sorted=False)\n            self.CPUTimeRange[event_type] = merge_ranges(self.CPUTimeRange[event_type], time_ranges, is_sorted=True)\n        for (device_id, device_time_ranges) in GPUTimeRange.items():\n            for (event_type, event_time_ranges) in device_time_ranges.items():\n                for (stream_id, time_ranges) in event_time_ranges.items():\n                    time_ranges = merge_self_ranges(time_ranges, is_sorted=False)\n                    self.GPUTimeRange[device_id][event_type] = merge_ranges(self.GPUTimeRange[device_id][event_type], time_ranges, is_sorted=True)\n    for (event_type, time_ranges) in self.CPUTimeRange.items():\n        self.CPUTimeRangeSum[event_type] = sum_ranges(time_ranges)\n    for (device_id, device_time_ranges) in self.GPUTimeRange.items():\n        for (event_type, time_ranges) in device_time_ranges.items():\n            self.GPUTimeRangeSum[device_id][event_type] = sum_ranges(time_ranges)",
            "def parse(self, nodetrees):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Analysis node trees in profiler result, and get time range for different tracer event type.\\n        '\n    thread2hostnodes = traverse_tree(nodetrees)\n    for (threadid, hostnodes) in thread2hostnodes.items():\n        CPUTimeRange = collections.defaultdict(list)\n        GPUTimeRange = collections.defaultdict(lambda : collections.defaultdict(lambda : collections.defaultdict(list)))\n        for hostnode in hostnodes[1:]:\n            CPUTimeRange[hostnode.type].append((hostnode.start_ns, hostnode.end_ns))\n            self.call_times[hostnode.type] += 1\n            for runtimenode in hostnode.runtime_node:\n                CPUTimeRange[runtimenode.type].append((runtimenode.start_ns, runtimenode.end_ns))\n                self.call_times[runtimenode.type] += 1\n                for devicenode in runtimenode.device_node:\n                    GPUTimeRange[devicenode.device_id][devicenode.type][devicenode.stream_id].append((devicenode.start_ns, devicenode.end_ns))\n                    self.call_times[devicenode.type] += 1\n        for (event_type, time_ranges) in CPUTimeRange.items():\n            time_ranges = merge_self_ranges(time_ranges, is_sorted=False)\n            self.CPUTimeRange[event_type] = merge_ranges(self.CPUTimeRange[event_type], time_ranges, is_sorted=True)\n        for (device_id, device_time_ranges) in GPUTimeRange.items():\n            for (event_type, event_time_ranges) in device_time_ranges.items():\n                for (stream_id, time_ranges) in event_time_ranges.items():\n                    time_ranges = merge_self_ranges(time_ranges, is_sorted=False)\n                    self.GPUTimeRange[device_id][event_type] = merge_ranges(self.GPUTimeRange[device_id][event_type], time_ranges, is_sorted=True)\n    for (event_type, time_ranges) in self.CPUTimeRange.items():\n        self.CPUTimeRangeSum[event_type] = sum_ranges(time_ranges)\n    for (device_id, device_time_ranges) in self.GPUTimeRange.items():\n        for (event_type, time_ranges) in device_time_ranges.items():\n            self.GPUTimeRangeSum[device_id][event_type] = sum_ranges(time_ranges)",
            "def parse(self, nodetrees):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Analysis node trees in profiler result, and get time range for different tracer event type.\\n        '\n    thread2hostnodes = traverse_tree(nodetrees)\n    for (threadid, hostnodes) in thread2hostnodes.items():\n        CPUTimeRange = collections.defaultdict(list)\n        GPUTimeRange = collections.defaultdict(lambda : collections.defaultdict(lambda : collections.defaultdict(list)))\n        for hostnode in hostnodes[1:]:\n            CPUTimeRange[hostnode.type].append((hostnode.start_ns, hostnode.end_ns))\n            self.call_times[hostnode.type] += 1\n            for runtimenode in hostnode.runtime_node:\n                CPUTimeRange[runtimenode.type].append((runtimenode.start_ns, runtimenode.end_ns))\n                self.call_times[runtimenode.type] += 1\n                for devicenode in runtimenode.device_node:\n                    GPUTimeRange[devicenode.device_id][devicenode.type][devicenode.stream_id].append((devicenode.start_ns, devicenode.end_ns))\n                    self.call_times[devicenode.type] += 1\n        for (event_type, time_ranges) in CPUTimeRange.items():\n            time_ranges = merge_self_ranges(time_ranges, is_sorted=False)\n            self.CPUTimeRange[event_type] = merge_ranges(self.CPUTimeRange[event_type], time_ranges, is_sorted=True)\n        for (device_id, device_time_ranges) in GPUTimeRange.items():\n            for (event_type, event_time_ranges) in device_time_ranges.items():\n                for (stream_id, time_ranges) in event_time_ranges.items():\n                    time_ranges = merge_self_ranges(time_ranges, is_sorted=False)\n                    self.GPUTimeRange[device_id][event_type] = merge_ranges(self.GPUTimeRange[device_id][event_type], time_ranges, is_sorted=True)\n    for (event_type, time_ranges) in self.CPUTimeRange.items():\n        self.CPUTimeRangeSum[event_type] = sum_ranges(time_ranges)\n    for (device_id, device_time_ranges) in self.GPUTimeRange.items():\n        for (event_type, time_ranges) in device_time_ranges.items():\n            self.GPUTimeRangeSum[device_id][event_type] = sum_ranges(time_ranges)",
            "def parse(self, nodetrees):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Analysis node trees in profiler result, and get time range for different tracer event type.\\n        '\n    thread2hostnodes = traverse_tree(nodetrees)\n    for (threadid, hostnodes) in thread2hostnodes.items():\n        CPUTimeRange = collections.defaultdict(list)\n        GPUTimeRange = collections.defaultdict(lambda : collections.defaultdict(lambda : collections.defaultdict(list)))\n        for hostnode in hostnodes[1:]:\n            CPUTimeRange[hostnode.type].append((hostnode.start_ns, hostnode.end_ns))\n            self.call_times[hostnode.type] += 1\n            for runtimenode in hostnode.runtime_node:\n                CPUTimeRange[runtimenode.type].append((runtimenode.start_ns, runtimenode.end_ns))\n                self.call_times[runtimenode.type] += 1\n                for devicenode in runtimenode.device_node:\n                    GPUTimeRange[devicenode.device_id][devicenode.type][devicenode.stream_id].append((devicenode.start_ns, devicenode.end_ns))\n                    self.call_times[devicenode.type] += 1\n        for (event_type, time_ranges) in CPUTimeRange.items():\n            time_ranges = merge_self_ranges(time_ranges, is_sorted=False)\n            self.CPUTimeRange[event_type] = merge_ranges(self.CPUTimeRange[event_type], time_ranges, is_sorted=True)\n        for (device_id, device_time_ranges) in GPUTimeRange.items():\n            for (event_type, event_time_ranges) in device_time_ranges.items():\n                for (stream_id, time_ranges) in event_time_ranges.items():\n                    time_ranges = merge_self_ranges(time_ranges, is_sorted=False)\n                    self.GPUTimeRange[device_id][event_type] = merge_ranges(self.GPUTimeRange[device_id][event_type], time_ranges, is_sorted=True)\n    for (event_type, time_ranges) in self.CPUTimeRange.items():\n        self.CPUTimeRangeSum[event_type] = sum_ranges(time_ranges)\n    for (device_id, device_time_ranges) in self.GPUTimeRange.items():\n        for (event_type, time_ranges) in device_time_ranges.items():\n            self.GPUTimeRangeSum[device_id][event_type] = sum_ranges(time_ranges)",
            "def parse(self, nodetrees):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Analysis node trees in profiler result, and get time range for different tracer event type.\\n        '\n    thread2hostnodes = traverse_tree(nodetrees)\n    for (threadid, hostnodes) in thread2hostnodes.items():\n        CPUTimeRange = collections.defaultdict(list)\n        GPUTimeRange = collections.defaultdict(lambda : collections.defaultdict(lambda : collections.defaultdict(list)))\n        for hostnode in hostnodes[1:]:\n            CPUTimeRange[hostnode.type].append((hostnode.start_ns, hostnode.end_ns))\n            self.call_times[hostnode.type] += 1\n            for runtimenode in hostnode.runtime_node:\n                CPUTimeRange[runtimenode.type].append((runtimenode.start_ns, runtimenode.end_ns))\n                self.call_times[runtimenode.type] += 1\n                for devicenode in runtimenode.device_node:\n                    GPUTimeRange[devicenode.device_id][devicenode.type][devicenode.stream_id].append((devicenode.start_ns, devicenode.end_ns))\n                    self.call_times[devicenode.type] += 1\n        for (event_type, time_ranges) in CPUTimeRange.items():\n            time_ranges = merge_self_ranges(time_ranges, is_sorted=False)\n            self.CPUTimeRange[event_type] = merge_ranges(self.CPUTimeRange[event_type], time_ranges, is_sorted=True)\n        for (device_id, device_time_ranges) in GPUTimeRange.items():\n            for (event_type, event_time_ranges) in device_time_ranges.items():\n                for (stream_id, time_ranges) in event_time_ranges.items():\n                    time_ranges = merge_self_ranges(time_ranges, is_sorted=False)\n                    self.GPUTimeRange[device_id][event_type] = merge_ranges(self.GPUTimeRange[device_id][event_type], time_ranges, is_sorted=True)\n    for (event_type, time_ranges) in self.CPUTimeRange.items():\n        self.CPUTimeRangeSum[event_type] = sum_ranges(time_ranges)\n    for (device_id, device_time_ranges) in self.GPUTimeRange.items():\n        for (event_type, time_ranges) in device_time_ranges.items():\n            self.GPUTimeRangeSum[device_id][event_type] = sum_ranges(time_ranges)"
        ]
    },
    {
        "func_name": "get_gpu_devices",
        "original": "def get_gpu_devices(self):\n    return self.GPUTimeRange.keys()",
        "mutated": [
            "def get_gpu_devices(self):\n    if False:\n        i = 10\n    return self.GPUTimeRange.keys()",
            "def get_gpu_devices(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return self.GPUTimeRange.keys()",
            "def get_gpu_devices(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return self.GPUTimeRange.keys()",
            "def get_gpu_devices(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return self.GPUTimeRange.keys()",
            "def get_gpu_devices(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return self.GPUTimeRange.keys()"
        ]
    },
    {
        "func_name": "get_gpu_range_sum",
        "original": "def get_gpu_range_sum(self, device_id, event_type):\n    return self.GPUTimeRangeSum[device_id][event_type]",
        "mutated": [
            "def get_gpu_range_sum(self, device_id, event_type):\n    if False:\n        i = 10\n    return self.GPUTimeRangeSum[device_id][event_type]",
            "def get_gpu_range_sum(self, device_id, event_type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return self.GPUTimeRangeSum[device_id][event_type]",
            "def get_gpu_range_sum(self, device_id, event_type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return self.GPUTimeRangeSum[device_id][event_type]",
            "def get_gpu_range_sum(self, device_id, event_type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return self.GPUTimeRangeSum[device_id][event_type]",
            "def get_gpu_range_sum(self, device_id, event_type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return self.GPUTimeRangeSum[device_id][event_type]"
        ]
    },
    {
        "func_name": "get_cpu_range_sum",
        "original": "def get_cpu_range_sum(self, event_type):\n    return self.CPUTimeRangeSum[event_type]",
        "mutated": [
            "def get_cpu_range_sum(self, event_type):\n    if False:\n        i = 10\n    return self.CPUTimeRangeSum[event_type]",
            "def get_cpu_range_sum(self, event_type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return self.CPUTimeRangeSum[event_type]",
            "def get_cpu_range_sum(self, event_type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return self.CPUTimeRangeSum[event_type]",
            "def get_cpu_range_sum(self, event_type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return self.CPUTimeRangeSum[event_type]",
            "def get_cpu_range_sum(self, event_type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return self.CPUTimeRangeSum[event_type]"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self):\n    self.cpu_communication_range = []\n    self.gpu_communication_range = []\n    self.communication_range = []\n    self.computation_range = []\n    self.overlap_range = []\n    self.cpu_calls = 0\n    self.gpu_calls = 0",
        "mutated": [
            "def __init__(self):\n    if False:\n        i = 10\n    self.cpu_communication_range = []\n    self.gpu_communication_range = []\n    self.communication_range = []\n    self.computation_range = []\n    self.overlap_range = []\n    self.cpu_calls = 0\n    self.gpu_calls = 0",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.cpu_communication_range = []\n    self.gpu_communication_range = []\n    self.communication_range = []\n    self.computation_range = []\n    self.overlap_range = []\n    self.cpu_calls = 0\n    self.gpu_calls = 0",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.cpu_communication_range = []\n    self.gpu_communication_range = []\n    self.communication_range = []\n    self.computation_range = []\n    self.overlap_range = []\n    self.cpu_calls = 0\n    self.gpu_calls = 0",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.cpu_communication_range = []\n    self.gpu_communication_range = []\n    self.communication_range = []\n    self.computation_range = []\n    self.overlap_range = []\n    self.cpu_calls = 0\n    self.gpu_calls = 0",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.cpu_communication_range = []\n    self.gpu_communication_range = []\n    self.communication_range = []\n    self.computation_range = []\n    self.overlap_range = []\n    self.cpu_calls = 0\n    self.gpu_calls = 0"
        ]
    },
    {
        "func_name": "parse",
        "original": "def parse(self, nodetrees):\n    \"\"\"\n        Collect all communication and computation time ranges.\n        \"\"\"\n    thread2hostnodes = traverse_tree(nodetrees)\n    for (threadid, hostnodes) in thread2hostnodes.items():\n        for hostnode in hostnodes[1:]:\n            if hostnode.type == TracerEventType.Communication:\n                self.cpu_communication_range.append((hostnode.start_ns, hostnode.end_ns))\n                device_nodes = get_device_nodes(hostnode)\n                for device_node in device_nodes:\n                    if device_node.type == TracerEventType.Kernel:\n                        self.gpu_communication_range.append((device_node.start_ns, device_node.end_ns))\n            elif hostnode.type == TracerEventType.Operator and any((name in hostnode.name.lower() for name in _CommunicationOpName)):\n                self.cpu_communication_range.append((hostnode.start_ns, hostnode.end_ns))\n                device_nodes = get_device_nodes(hostnode)\n                for device_node in device_nodes:\n                    if device_node.type == TracerEventType.Kernel:\n                        self.gpu_communication_range.append((device_node.start_ns, device_node.end_ns))\n            else:\n                for runtimenode in hostnode.runtime_node:\n                    for devicenode in runtimenode.device_node:\n                        if devicenode.type == TracerEventType.Kernel:\n                            kernel_name = devicenode.name.lower()\n                            if 'nccl' in kernel_name or 'xccl' in kernel_name:\n                                self.gpu_communication_range.append((devicenode.start_ns, devicenode.end_ns))\n                            else:\n                                self.computation_range.append((devicenode.start_ns, devicenode.end_ns))\n    self.cpu_calls = len(set(self.cpu_communication_range))\n    self.gpu_calls = len(set(self.gpu_communication_range))\n    self.cpu_communication_range = merge_self_ranges(self.cpu_communication_range, is_sorted=False)\n    self.gpu_communication_range = merge_self_ranges(self.gpu_communication_range, is_sorted=False)\n    self.communication_range = merge_ranges(self.cpu_communication_range, self.gpu_communication_range, is_sorted=True)\n    self.computation_range = merge_self_ranges(self.computation_range, is_sorted=False)\n    self.overlap_range = intersection_ranges(self.communication_range, self.computation_range, is_sorted=True)",
        "mutated": [
            "def parse(self, nodetrees):\n    if False:\n        i = 10\n    '\\n        Collect all communication and computation time ranges.\\n        '\n    thread2hostnodes = traverse_tree(nodetrees)\n    for (threadid, hostnodes) in thread2hostnodes.items():\n        for hostnode in hostnodes[1:]:\n            if hostnode.type == TracerEventType.Communication:\n                self.cpu_communication_range.append((hostnode.start_ns, hostnode.end_ns))\n                device_nodes = get_device_nodes(hostnode)\n                for device_node in device_nodes:\n                    if device_node.type == TracerEventType.Kernel:\n                        self.gpu_communication_range.append((device_node.start_ns, device_node.end_ns))\n            elif hostnode.type == TracerEventType.Operator and any((name in hostnode.name.lower() for name in _CommunicationOpName)):\n                self.cpu_communication_range.append((hostnode.start_ns, hostnode.end_ns))\n                device_nodes = get_device_nodes(hostnode)\n                for device_node in device_nodes:\n                    if device_node.type == TracerEventType.Kernel:\n                        self.gpu_communication_range.append((device_node.start_ns, device_node.end_ns))\n            else:\n                for runtimenode in hostnode.runtime_node:\n                    for devicenode in runtimenode.device_node:\n                        if devicenode.type == TracerEventType.Kernel:\n                            kernel_name = devicenode.name.lower()\n                            if 'nccl' in kernel_name or 'xccl' in kernel_name:\n                                self.gpu_communication_range.append((devicenode.start_ns, devicenode.end_ns))\n                            else:\n                                self.computation_range.append((devicenode.start_ns, devicenode.end_ns))\n    self.cpu_calls = len(set(self.cpu_communication_range))\n    self.gpu_calls = len(set(self.gpu_communication_range))\n    self.cpu_communication_range = merge_self_ranges(self.cpu_communication_range, is_sorted=False)\n    self.gpu_communication_range = merge_self_ranges(self.gpu_communication_range, is_sorted=False)\n    self.communication_range = merge_ranges(self.cpu_communication_range, self.gpu_communication_range, is_sorted=True)\n    self.computation_range = merge_self_ranges(self.computation_range, is_sorted=False)\n    self.overlap_range = intersection_ranges(self.communication_range, self.computation_range, is_sorted=True)",
            "def parse(self, nodetrees):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Collect all communication and computation time ranges.\\n        '\n    thread2hostnodes = traverse_tree(nodetrees)\n    for (threadid, hostnodes) in thread2hostnodes.items():\n        for hostnode in hostnodes[1:]:\n            if hostnode.type == TracerEventType.Communication:\n                self.cpu_communication_range.append((hostnode.start_ns, hostnode.end_ns))\n                device_nodes = get_device_nodes(hostnode)\n                for device_node in device_nodes:\n                    if device_node.type == TracerEventType.Kernel:\n                        self.gpu_communication_range.append((device_node.start_ns, device_node.end_ns))\n            elif hostnode.type == TracerEventType.Operator and any((name in hostnode.name.lower() for name in _CommunicationOpName)):\n                self.cpu_communication_range.append((hostnode.start_ns, hostnode.end_ns))\n                device_nodes = get_device_nodes(hostnode)\n                for device_node in device_nodes:\n                    if device_node.type == TracerEventType.Kernel:\n                        self.gpu_communication_range.append((device_node.start_ns, device_node.end_ns))\n            else:\n                for runtimenode in hostnode.runtime_node:\n                    for devicenode in runtimenode.device_node:\n                        if devicenode.type == TracerEventType.Kernel:\n                            kernel_name = devicenode.name.lower()\n                            if 'nccl' in kernel_name or 'xccl' in kernel_name:\n                                self.gpu_communication_range.append((devicenode.start_ns, devicenode.end_ns))\n                            else:\n                                self.computation_range.append((devicenode.start_ns, devicenode.end_ns))\n    self.cpu_calls = len(set(self.cpu_communication_range))\n    self.gpu_calls = len(set(self.gpu_communication_range))\n    self.cpu_communication_range = merge_self_ranges(self.cpu_communication_range, is_sorted=False)\n    self.gpu_communication_range = merge_self_ranges(self.gpu_communication_range, is_sorted=False)\n    self.communication_range = merge_ranges(self.cpu_communication_range, self.gpu_communication_range, is_sorted=True)\n    self.computation_range = merge_self_ranges(self.computation_range, is_sorted=False)\n    self.overlap_range = intersection_ranges(self.communication_range, self.computation_range, is_sorted=True)",
            "def parse(self, nodetrees):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Collect all communication and computation time ranges.\\n        '\n    thread2hostnodes = traverse_tree(nodetrees)\n    for (threadid, hostnodes) in thread2hostnodes.items():\n        for hostnode in hostnodes[1:]:\n            if hostnode.type == TracerEventType.Communication:\n                self.cpu_communication_range.append((hostnode.start_ns, hostnode.end_ns))\n                device_nodes = get_device_nodes(hostnode)\n                for device_node in device_nodes:\n                    if device_node.type == TracerEventType.Kernel:\n                        self.gpu_communication_range.append((device_node.start_ns, device_node.end_ns))\n            elif hostnode.type == TracerEventType.Operator and any((name in hostnode.name.lower() for name in _CommunicationOpName)):\n                self.cpu_communication_range.append((hostnode.start_ns, hostnode.end_ns))\n                device_nodes = get_device_nodes(hostnode)\n                for device_node in device_nodes:\n                    if device_node.type == TracerEventType.Kernel:\n                        self.gpu_communication_range.append((device_node.start_ns, device_node.end_ns))\n            else:\n                for runtimenode in hostnode.runtime_node:\n                    for devicenode in runtimenode.device_node:\n                        if devicenode.type == TracerEventType.Kernel:\n                            kernel_name = devicenode.name.lower()\n                            if 'nccl' in kernel_name or 'xccl' in kernel_name:\n                                self.gpu_communication_range.append((devicenode.start_ns, devicenode.end_ns))\n                            else:\n                                self.computation_range.append((devicenode.start_ns, devicenode.end_ns))\n    self.cpu_calls = len(set(self.cpu_communication_range))\n    self.gpu_calls = len(set(self.gpu_communication_range))\n    self.cpu_communication_range = merge_self_ranges(self.cpu_communication_range, is_sorted=False)\n    self.gpu_communication_range = merge_self_ranges(self.gpu_communication_range, is_sorted=False)\n    self.communication_range = merge_ranges(self.cpu_communication_range, self.gpu_communication_range, is_sorted=True)\n    self.computation_range = merge_self_ranges(self.computation_range, is_sorted=False)\n    self.overlap_range = intersection_ranges(self.communication_range, self.computation_range, is_sorted=True)",
            "def parse(self, nodetrees):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Collect all communication and computation time ranges.\\n        '\n    thread2hostnodes = traverse_tree(nodetrees)\n    for (threadid, hostnodes) in thread2hostnodes.items():\n        for hostnode in hostnodes[1:]:\n            if hostnode.type == TracerEventType.Communication:\n                self.cpu_communication_range.append((hostnode.start_ns, hostnode.end_ns))\n                device_nodes = get_device_nodes(hostnode)\n                for device_node in device_nodes:\n                    if device_node.type == TracerEventType.Kernel:\n                        self.gpu_communication_range.append((device_node.start_ns, device_node.end_ns))\n            elif hostnode.type == TracerEventType.Operator and any((name in hostnode.name.lower() for name in _CommunicationOpName)):\n                self.cpu_communication_range.append((hostnode.start_ns, hostnode.end_ns))\n                device_nodes = get_device_nodes(hostnode)\n                for device_node in device_nodes:\n                    if device_node.type == TracerEventType.Kernel:\n                        self.gpu_communication_range.append((device_node.start_ns, device_node.end_ns))\n            else:\n                for runtimenode in hostnode.runtime_node:\n                    for devicenode in runtimenode.device_node:\n                        if devicenode.type == TracerEventType.Kernel:\n                            kernel_name = devicenode.name.lower()\n                            if 'nccl' in kernel_name or 'xccl' in kernel_name:\n                                self.gpu_communication_range.append((devicenode.start_ns, devicenode.end_ns))\n                            else:\n                                self.computation_range.append((devicenode.start_ns, devicenode.end_ns))\n    self.cpu_calls = len(set(self.cpu_communication_range))\n    self.gpu_calls = len(set(self.gpu_communication_range))\n    self.cpu_communication_range = merge_self_ranges(self.cpu_communication_range, is_sorted=False)\n    self.gpu_communication_range = merge_self_ranges(self.gpu_communication_range, is_sorted=False)\n    self.communication_range = merge_ranges(self.cpu_communication_range, self.gpu_communication_range, is_sorted=True)\n    self.computation_range = merge_self_ranges(self.computation_range, is_sorted=False)\n    self.overlap_range = intersection_ranges(self.communication_range, self.computation_range, is_sorted=True)",
            "def parse(self, nodetrees):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Collect all communication and computation time ranges.\\n        '\n    thread2hostnodes = traverse_tree(nodetrees)\n    for (threadid, hostnodes) in thread2hostnodes.items():\n        for hostnode in hostnodes[1:]:\n            if hostnode.type == TracerEventType.Communication:\n                self.cpu_communication_range.append((hostnode.start_ns, hostnode.end_ns))\n                device_nodes = get_device_nodes(hostnode)\n                for device_node in device_nodes:\n                    if device_node.type == TracerEventType.Kernel:\n                        self.gpu_communication_range.append((device_node.start_ns, device_node.end_ns))\n            elif hostnode.type == TracerEventType.Operator and any((name in hostnode.name.lower() for name in _CommunicationOpName)):\n                self.cpu_communication_range.append((hostnode.start_ns, hostnode.end_ns))\n                device_nodes = get_device_nodes(hostnode)\n                for device_node in device_nodes:\n                    if device_node.type == TracerEventType.Kernel:\n                        self.gpu_communication_range.append((device_node.start_ns, device_node.end_ns))\n            else:\n                for runtimenode in hostnode.runtime_node:\n                    for devicenode in runtimenode.device_node:\n                        if devicenode.type == TracerEventType.Kernel:\n                            kernel_name = devicenode.name.lower()\n                            if 'nccl' in kernel_name or 'xccl' in kernel_name:\n                                self.gpu_communication_range.append((devicenode.start_ns, devicenode.end_ns))\n                            else:\n                                self.computation_range.append((devicenode.start_ns, devicenode.end_ns))\n    self.cpu_calls = len(set(self.cpu_communication_range))\n    self.gpu_calls = len(set(self.gpu_communication_range))\n    self.cpu_communication_range = merge_self_ranges(self.cpu_communication_range, is_sorted=False)\n    self.gpu_communication_range = merge_self_ranges(self.gpu_communication_range, is_sorted=False)\n    self.communication_range = merge_ranges(self.cpu_communication_range, self.gpu_communication_range, is_sorted=True)\n    self.computation_range = merge_self_ranges(self.computation_range, is_sorted=False)\n    self.overlap_range = intersection_ranges(self.communication_range, self.computation_range, is_sorted=True)"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, name):\n    self.name = name\n    self.call = 0\n    self.cpu_time = 0\n    self.gpu_time = 0\n    self.max_cpu_time = 0\n    self.min_cpu_time = float('inf')\n    self.max_gpu_time = 0\n    self.min_gpu_time = float('inf')\n    self.devices = {}\n    self.operator_inners = {}\n    self.general_gpu_time = 0\n    self.min_general_gpu_time = float('inf')\n    self.max_general_gpu_time = 0\n    self._flops = 0",
        "mutated": [
            "def __init__(self, name):\n    if False:\n        i = 10\n    self.name = name\n    self.call = 0\n    self.cpu_time = 0\n    self.gpu_time = 0\n    self.max_cpu_time = 0\n    self.min_cpu_time = float('inf')\n    self.max_gpu_time = 0\n    self.min_gpu_time = float('inf')\n    self.devices = {}\n    self.operator_inners = {}\n    self.general_gpu_time = 0\n    self.min_general_gpu_time = float('inf')\n    self.max_general_gpu_time = 0\n    self._flops = 0",
            "def __init__(self, name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.name = name\n    self.call = 0\n    self.cpu_time = 0\n    self.gpu_time = 0\n    self.max_cpu_time = 0\n    self.min_cpu_time = float('inf')\n    self.max_gpu_time = 0\n    self.min_gpu_time = float('inf')\n    self.devices = {}\n    self.operator_inners = {}\n    self.general_gpu_time = 0\n    self.min_general_gpu_time = float('inf')\n    self.max_general_gpu_time = 0\n    self._flops = 0",
            "def __init__(self, name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.name = name\n    self.call = 0\n    self.cpu_time = 0\n    self.gpu_time = 0\n    self.max_cpu_time = 0\n    self.min_cpu_time = float('inf')\n    self.max_gpu_time = 0\n    self.min_gpu_time = float('inf')\n    self.devices = {}\n    self.operator_inners = {}\n    self.general_gpu_time = 0\n    self.min_general_gpu_time = float('inf')\n    self.max_general_gpu_time = 0\n    self._flops = 0",
            "def __init__(self, name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.name = name\n    self.call = 0\n    self.cpu_time = 0\n    self.gpu_time = 0\n    self.max_cpu_time = 0\n    self.min_cpu_time = float('inf')\n    self.max_gpu_time = 0\n    self.min_gpu_time = float('inf')\n    self.devices = {}\n    self.operator_inners = {}\n    self.general_gpu_time = 0\n    self.min_general_gpu_time = float('inf')\n    self.max_general_gpu_time = 0\n    self._flops = 0",
            "def __init__(self, name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.name = name\n    self.call = 0\n    self.cpu_time = 0\n    self.gpu_time = 0\n    self.max_cpu_time = 0\n    self.min_cpu_time = float('inf')\n    self.max_gpu_time = 0\n    self.min_gpu_time = float('inf')\n    self.devices = {}\n    self.operator_inners = {}\n    self.general_gpu_time = 0\n    self.min_general_gpu_time = float('inf')\n    self.max_general_gpu_time = 0\n    self._flops = 0"
        ]
    },
    {
        "func_name": "flops",
        "original": "@property\ndef flops(self):\n    return self._flops",
        "mutated": [
            "@property\ndef flops(self):\n    if False:\n        i = 10\n    return self._flops",
            "@property\ndef flops(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return self._flops",
            "@property\ndef flops(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return self._flops",
            "@property\ndef flops(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return self._flops",
            "@property\ndef flops(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return self._flops"
        ]
    },
    {
        "func_name": "avg_cpu_time",
        "original": "@property\ndef avg_cpu_time(self):\n    return self.cpu_time / self.call",
        "mutated": [
            "@property\ndef avg_cpu_time(self):\n    if False:\n        i = 10\n    return self.cpu_time / self.call",
            "@property\ndef avg_cpu_time(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return self.cpu_time / self.call",
            "@property\ndef avg_cpu_time(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return self.cpu_time / self.call",
            "@property\ndef avg_cpu_time(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return self.cpu_time / self.call",
            "@property\ndef avg_cpu_time(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return self.cpu_time / self.call"
        ]
    },
    {
        "func_name": "avg_gpu_time",
        "original": "@property\ndef avg_gpu_time(self):\n    return self.gpu_time / self.call",
        "mutated": [
            "@property\ndef avg_gpu_time(self):\n    if False:\n        i = 10\n    return self.gpu_time / self.call",
            "@property\ndef avg_gpu_time(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return self.gpu_time / self.call",
            "@property\ndef avg_gpu_time(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return self.gpu_time / self.call",
            "@property\ndef avg_gpu_time(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return self.gpu_time / self.call",
            "@property\ndef avg_gpu_time(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return self.gpu_time / self.call"
        ]
    },
    {
        "func_name": "avg_general_gpu_time",
        "original": "@property\ndef avg_general_gpu_time(self):\n    return self.general_gpu_time / self.call",
        "mutated": [
            "@property\ndef avg_general_gpu_time(self):\n    if False:\n        i = 10\n    return self.general_gpu_time / self.call",
            "@property\ndef avg_general_gpu_time(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return self.general_gpu_time / self.call",
            "@property\ndef avg_general_gpu_time(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return self.general_gpu_time / self.call",
            "@property\ndef avg_general_gpu_time(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return self.general_gpu_time / self.call",
            "@property\ndef avg_general_gpu_time(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return self.general_gpu_time / self.call"
        ]
    },
    {
        "func_name": "add_cpu_time",
        "original": "def add_cpu_time(self, time):\n    if time > self.max_cpu_time:\n        self.max_cpu_time = time\n    if time < self.min_cpu_time:\n        self.min_cpu_time = time\n    self.cpu_time += time",
        "mutated": [
            "def add_cpu_time(self, time):\n    if False:\n        i = 10\n    if time > self.max_cpu_time:\n        self.max_cpu_time = time\n    if time < self.min_cpu_time:\n        self.min_cpu_time = time\n    self.cpu_time += time",
            "def add_cpu_time(self, time):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if time > self.max_cpu_time:\n        self.max_cpu_time = time\n    if time < self.min_cpu_time:\n        self.min_cpu_time = time\n    self.cpu_time += time",
            "def add_cpu_time(self, time):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if time > self.max_cpu_time:\n        self.max_cpu_time = time\n    if time < self.min_cpu_time:\n        self.min_cpu_time = time\n    self.cpu_time += time",
            "def add_cpu_time(self, time):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if time > self.max_cpu_time:\n        self.max_cpu_time = time\n    if time < self.min_cpu_time:\n        self.min_cpu_time = time\n    self.cpu_time += time",
            "def add_cpu_time(self, time):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if time > self.max_cpu_time:\n        self.max_cpu_time = time\n    if time < self.min_cpu_time:\n        self.min_cpu_time = time\n    self.cpu_time += time"
        ]
    },
    {
        "func_name": "add_gpu_time",
        "original": "def add_gpu_time(self, time):\n    if time > self.max_gpu_time:\n        self.max_gpu_time = time\n    if time < self.min_gpu_time:\n        self.min_gpu_time = time\n    self.gpu_time += time",
        "mutated": [
            "def add_gpu_time(self, time):\n    if False:\n        i = 10\n    if time > self.max_gpu_time:\n        self.max_gpu_time = time\n    if time < self.min_gpu_time:\n        self.min_gpu_time = time\n    self.gpu_time += time",
            "def add_gpu_time(self, time):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if time > self.max_gpu_time:\n        self.max_gpu_time = time\n    if time < self.min_gpu_time:\n        self.min_gpu_time = time\n    self.gpu_time += time",
            "def add_gpu_time(self, time):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if time > self.max_gpu_time:\n        self.max_gpu_time = time\n    if time < self.min_gpu_time:\n        self.min_gpu_time = time\n    self.gpu_time += time",
            "def add_gpu_time(self, time):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if time > self.max_gpu_time:\n        self.max_gpu_time = time\n    if time < self.min_gpu_time:\n        self.min_gpu_time = time\n    self.gpu_time += time",
            "def add_gpu_time(self, time):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if time > self.max_gpu_time:\n        self.max_gpu_time = time\n    if time < self.min_gpu_time:\n        self.min_gpu_time = time\n    self.gpu_time += time"
        ]
    },
    {
        "func_name": "add_general_gpu_time",
        "original": "def add_general_gpu_time(self, time):\n    if time > self.max_general_gpu_time:\n        self.max_general_gpu_time = time\n    if time < self.min_general_gpu_time:\n        self.min_general_gpu_time = time\n    self.general_gpu_time += time",
        "mutated": [
            "def add_general_gpu_time(self, time):\n    if False:\n        i = 10\n    if time > self.max_general_gpu_time:\n        self.max_general_gpu_time = time\n    if time < self.min_general_gpu_time:\n        self.min_general_gpu_time = time\n    self.general_gpu_time += time",
            "def add_general_gpu_time(self, time):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if time > self.max_general_gpu_time:\n        self.max_general_gpu_time = time\n    if time < self.min_general_gpu_time:\n        self.min_general_gpu_time = time\n    self.general_gpu_time += time",
            "def add_general_gpu_time(self, time):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if time > self.max_general_gpu_time:\n        self.max_general_gpu_time = time\n    if time < self.min_general_gpu_time:\n        self.min_general_gpu_time = time\n    self.general_gpu_time += time",
            "def add_general_gpu_time(self, time):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if time > self.max_general_gpu_time:\n        self.max_general_gpu_time = time\n    if time < self.min_general_gpu_time:\n        self.min_general_gpu_time = time\n    self.general_gpu_time += time",
            "def add_general_gpu_time(self, time):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if time > self.max_general_gpu_time:\n        self.max_general_gpu_time = time\n    if time < self.min_general_gpu_time:\n        self.min_general_gpu_time = time\n    self.general_gpu_time += time"
        ]
    },
    {
        "func_name": "add_call",
        "original": "def add_call(self):\n    self.call += 1",
        "mutated": [
            "def add_call(self):\n    if False:\n        i = 10\n    self.call += 1",
            "def add_call(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.call += 1",
            "def add_call(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.call += 1",
            "def add_call(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.call += 1",
            "def add_call(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.call += 1"
        ]
    },
    {
        "func_name": "add_flops",
        "original": "def add_flops(self, flops):\n    self._flops += flops",
        "mutated": [
            "def add_flops(self, flops):\n    if False:\n        i = 10\n    self._flops += flops",
            "def add_flops(self, flops):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self._flops += flops",
            "def add_flops(self, flops):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self._flops += flops",
            "def add_flops(self, flops):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self._flops += flops",
            "def add_flops(self, flops):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self._flops += flops"
        ]
    },
    {
        "func_name": "add_item",
        "original": "def add_item(self, node):\n    raise NotImplementedError",
        "mutated": [
            "def add_item(self, node):\n    if False:\n        i = 10\n    raise NotImplementedError",
            "def add_item(self, node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    raise NotImplementedError",
            "def add_item(self, node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    raise NotImplementedError",
            "def add_item(self, node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    raise NotImplementedError",
            "def add_item(self, node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    raise NotImplementedError"
        ]
    },
    {
        "func_name": "add_item",
        "original": "def add_item(self, node):\n    self.call += 1\n    self.add_gpu_time(node.end_ns - node.start_ns)",
        "mutated": [
            "def add_item(self, node):\n    if False:\n        i = 10\n    self.call += 1\n    self.add_gpu_time(node.end_ns - node.start_ns)",
            "def add_item(self, node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.call += 1\n    self.add_gpu_time(node.end_ns - node.start_ns)",
            "def add_item(self, node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.call += 1\n    self.add_gpu_time(node.end_ns - node.start_ns)",
            "def add_item(self, node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.call += 1\n    self.add_gpu_time(node.end_ns - node.start_ns)",
            "def add_item(self, node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.call += 1\n    self.add_gpu_time(node.end_ns - node.start_ns)"
        ]
    },
    {
        "func_name": "add_item",
        "original": "def add_item(self, node):\n    self.add_call()\n    self.add_cpu_time(node.cpu_time)\n    self.add_gpu_time(node.gpu_time)\n    self.add_general_gpu_time(node.general_gpu_time)\n    self.add_flops(node.flops)\n    for child in node.children_node:\n        if child.type != TracerEventType.Operator:\n            if child.name not in self.operator_inners:\n                self.operator_inners[child.name] = EventSummary.OperatorItem(child.name)\n            self.operator_inners[child.name].add_item(child)\n    for runtimenode in node.runtime_node:\n        for devicenode in runtimenode.device_node:\n            name = devicenode.name\n            if name not in self.devices:\n                self.devices[name] = EventSummary.DeviceItem(name)\n            self.devices[name].add_item(devicenode)",
        "mutated": [
            "def add_item(self, node):\n    if False:\n        i = 10\n    self.add_call()\n    self.add_cpu_time(node.cpu_time)\n    self.add_gpu_time(node.gpu_time)\n    self.add_general_gpu_time(node.general_gpu_time)\n    self.add_flops(node.flops)\n    for child in node.children_node:\n        if child.type != TracerEventType.Operator:\n            if child.name not in self.operator_inners:\n                self.operator_inners[child.name] = EventSummary.OperatorItem(child.name)\n            self.operator_inners[child.name].add_item(child)\n    for runtimenode in node.runtime_node:\n        for devicenode in runtimenode.device_node:\n            name = devicenode.name\n            if name not in self.devices:\n                self.devices[name] = EventSummary.DeviceItem(name)\n            self.devices[name].add_item(devicenode)",
            "def add_item(self, node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.add_call()\n    self.add_cpu_time(node.cpu_time)\n    self.add_gpu_time(node.gpu_time)\n    self.add_general_gpu_time(node.general_gpu_time)\n    self.add_flops(node.flops)\n    for child in node.children_node:\n        if child.type != TracerEventType.Operator:\n            if child.name not in self.operator_inners:\n                self.operator_inners[child.name] = EventSummary.OperatorItem(child.name)\n            self.operator_inners[child.name].add_item(child)\n    for runtimenode in node.runtime_node:\n        for devicenode in runtimenode.device_node:\n            name = devicenode.name\n            if name not in self.devices:\n                self.devices[name] = EventSummary.DeviceItem(name)\n            self.devices[name].add_item(devicenode)",
            "def add_item(self, node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.add_call()\n    self.add_cpu_time(node.cpu_time)\n    self.add_gpu_time(node.gpu_time)\n    self.add_general_gpu_time(node.general_gpu_time)\n    self.add_flops(node.flops)\n    for child in node.children_node:\n        if child.type != TracerEventType.Operator:\n            if child.name not in self.operator_inners:\n                self.operator_inners[child.name] = EventSummary.OperatorItem(child.name)\n            self.operator_inners[child.name].add_item(child)\n    for runtimenode in node.runtime_node:\n        for devicenode in runtimenode.device_node:\n            name = devicenode.name\n            if name not in self.devices:\n                self.devices[name] = EventSummary.DeviceItem(name)\n            self.devices[name].add_item(devicenode)",
            "def add_item(self, node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.add_call()\n    self.add_cpu_time(node.cpu_time)\n    self.add_gpu_time(node.gpu_time)\n    self.add_general_gpu_time(node.general_gpu_time)\n    self.add_flops(node.flops)\n    for child in node.children_node:\n        if child.type != TracerEventType.Operator:\n            if child.name not in self.operator_inners:\n                self.operator_inners[child.name] = EventSummary.OperatorItem(child.name)\n            self.operator_inners[child.name].add_item(child)\n    for runtimenode in node.runtime_node:\n        for devicenode in runtimenode.device_node:\n            name = devicenode.name\n            if name not in self.devices:\n                self.devices[name] = EventSummary.DeviceItem(name)\n            self.devices[name].add_item(devicenode)",
            "def add_item(self, node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.add_call()\n    self.add_cpu_time(node.cpu_time)\n    self.add_gpu_time(node.gpu_time)\n    self.add_general_gpu_time(node.general_gpu_time)\n    self.add_flops(node.flops)\n    for child in node.children_node:\n        if child.type != TracerEventType.Operator:\n            if child.name not in self.operator_inners:\n                self.operator_inners[child.name] = EventSummary.OperatorItem(child.name)\n            self.operator_inners[child.name].add_item(child)\n    for runtimenode in node.runtime_node:\n        for devicenode in runtimenode.device_node:\n            name = devicenode.name\n            if name not in self.devices:\n                self.devices[name] = EventSummary.DeviceItem(name)\n            self.devices[name].add_item(devicenode)"
        ]
    },
    {
        "func_name": "add_item",
        "original": "def add_item(self, node):\n    self.add_call()\n    self.add_cpu_time(node.cpu_time)\n    self.add_gpu_time(node.gpu_time)\n    self.add_general_gpu_time(node.general_gpu_time)\n    self.add_flops(node.flops)\n    for child in node.children_node:\n        if child.type != TracerEventType.Operator:\n            if child.name not in self.operator_inners:\n                self.operator_inners[child.name] = EventSummary.OperatorItem(child.name)\n            self.operator_inners[child.name].add_item(child)",
        "mutated": [
            "def add_item(self, node):\n    if False:\n        i = 10\n    self.add_call()\n    self.add_cpu_time(node.cpu_time)\n    self.add_gpu_time(node.gpu_time)\n    self.add_general_gpu_time(node.general_gpu_time)\n    self.add_flops(node.flops)\n    for child in node.children_node:\n        if child.type != TracerEventType.Operator:\n            if child.name not in self.operator_inners:\n                self.operator_inners[child.name] = EventSummary.OperatorItem(child.name)\n            self.operator_inners[child.name].add_item(child)",
            "def add_item(self, node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.add_call()\n    self.add_cpu_time(node.cpu_time)\n    self.add_gpu_time(node.gpu_time)\n    self.add_general_gpu_time(node.general_gpu_time)\n    self.add_flops(node.flops)\n    for child in node.children_node:\n        if child.type != TracerEventType.Operator:\n            if child.name not in self.operator_inners:\n                self.operator_inners[child.name] = EventSummary.OperatorItem(child.name)\n            self.operator_inners[child.name].add_item(child)",
            "def add_item(self, node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.add_call()\n    self.add_cpu_time(node.cpu_time)\n    self.add_gpu_time(node.gpu_time)\n    self.add_general_gpu_time(node.general_gpu_time)\n    self.add_flops(node.flops)\n    for child in node.children_node:\n        if child.type != TracerEventType.Operator:\n            if child.name not in self.operator_inners:\n                self.operator_inners[child.name] = EventSummary.OperatorItem(child.name)\n            self.operator_inners[child.name].add_item(child)",
            "def add_item(self, node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.add_call()\n    self.add_cpu_time(node.cpu_time)\n    self.add_gpu_time(node.gpu_time)\n    self.add_general_gpu_time(node.general_gpu_time)\n    self.add_flops(node.flops)\n    for child in node.children_node:\n        if child.type != TracerEventType.Operator:\n            if child.name not in self.operator_inners:\n                self.operator_inners[child.name] = EventSummary.OperatorItem(child.name)\n            self.operator_inners[child.name].add_item(child)",
            "def add_item(self, node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.add_call()\n    self.add_cpu_time(node.cpu_time)\n    self.add_gpu_time(node.gpu_time)\n    self.add_general_gpu_time(node.general_gpu_time)\n    self.add_flops(node.flops)\n    for child in node.children_node:\n        if child.type != TracerEventType.Operator:\n            if child.name not in self.operator_inners:\n                self.operator_inners[child.name] = EventSummary.OperatorItem(child.name)\n            self.operator_inners[child.name].add_item(child)"
        ]
    },
    {
        "func_name": "add_item",
        "original": "def add_item(self, node):\n    self.add_call()\n    self.add_cpu_time(node.cpu_time)\n    self.add_gpu_time(node.gpu_time)\n    self.add_general_gpu_time(node.general_gpu_time)",
        "mutated": [
            "def add_item(self, node):\n    if False:\n        i = 10\n    self.add_call()\n    self.add_cpu_time(node.cpu_time)\n    self.add_gpu_time(node.gpu_time)\n    self.add_general_gpu_time(node.general_gpu_time)",
            "def add_item(self, node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.add_call()\n    self.add_cpu_time(node.cpu_time)\n    self.add_gpu_time(node.gpu_time)\n    self.add_general_gpu_time(node.general_gpu_time)",
            "def add_item(self, node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.add_call()\n    self.add_cpu_time(node.cpu_time)\n    self.add_gpu_time(node.gpu_time)\n    self.add_general_gpu_time(node.general_gpu_time)",
            "def add_item(self, node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.add_call()\n    self.add_cpu_time(node.cpu_time)\n    self.add_gpu_time(node.gpu_time)\n    self.add_general_gpu_time(node.general_gpu_time)",
            "def add_item(self, node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.add_call()\n    self.add_cpu_time(node.cpu_time)\n    self.add_gpu_time(node.gpu_time)\n    self.add_general_gpu_time(node.general_gpu_time)"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self):\n    self.items = {}\n    self.thread_items = collections.defaultdict(dict)\n    self.userdefined_items = {}\n    self.userdefined_thread_items = collections.defaultdict(dict)\n    self.model_perspective_items = {}\n    self.memory_manipulation_items = {}\n    self.kernel_items = {}",
        "mutated": [
            "def __init__(self):\n    if False:\n        i = 10\n    self.items = {}\n    self.thread_items = collections.defaultdict(dict)\n    self.userdefined_items = {}\n    self.userdefined_thread_items = collections.defaultdict(dict)\n    self.model_perspective_items = {}\n    self.memory_manipulation_items = {}\n    self.kernel_items = {}",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.items = {}\n    self.thread_items = collections.defaultdict(dict)\n    self.userdefined_items = {}\n    self.userdefined_thread_items = collections.defaultdict(dict)\n    self.model_perspective_items = {}\n    self.memory_manipulation_items = {}\n    self.kernel_items = {}",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.items = {}\n    self.thread_items = collections.defaultdict(dict)\n    self.userdefined_items = {}\n    self.userdefined_thread_items = collections.defaultdict(dict)\n    self.model_perspective_items = {}\n    self.memory_manipulation_items = {}\n    self.kernel_items = {}",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.items = {}\n    self.thread_items = collections.defaultdict(dict)\n    self.userdefined_items = {}\n    self.userdefined_thread_items = collections.defaultdict(dict)\n    self.model_perspective_items = {}\n    self.memory_manipulation_items = {}\n    self.kernel_items = {}",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.items = {}\n    self.thread_items = collections.defaultdict(dict)\n    self.userdefined_items = {}\n    self.userdefined_thread_items = collections.defaultdict(dict)\n    self.model_perspective_items = {}\n    self.memory_manipulation_items = {}\n    self.kernel_items = {}"
        ]
    },
    {
        "func_name": "parse",
        "original": "def parse(self, nodetrees):\n    \"\"\"\n        Analysis operator event in the nodetress.\n        \"\"\"\n    (node_statistic_trees, thread2host_statistic_nodes) = wrap_tree(nodetrees)\n    for (threadid, host_statistic_nodes) in thread2host_statistic_nodes.items():\n        for host_statistic_node in host_statistic_nodes[1:]:\n            if host_statistic_node.type == TracerEventType.Operator:\n                self.add_operator_item(host_statistic_node)\n            if host_statistic_node.type == TracerEventType.UserDefined or host_statistic_node.type == TracerEventType.PythonUserDefined:\n                if 'memcpy' in host_statistic_node.name.lower() or 'memorycopy' in host_statistic_node.name.lower() or 'memset' in host_statistic_node.name.lower():\n                    self.add_memory_manipulation_item(host_statistic_node)\n                elif host_statistic_node.type == TracerEventType.PythonUserDefined:\n                    self.add_userdefined_item(host_statistic_node)\n        self.add_kernel_item(host_statistic_nodes[0])\n    for (threadid, root_statistic_node) in node_statistic_trees.items():\n        deque = collections.deque()\n        deque.append(root_statistic_node)\n        while deque:\n            current_node = deque.popleft()\n            for child in current_node.children_node:\n                if child.type == TracerEventType.Forward or child.type == TracerEventType.Dataloader or child.type == TracerEventType.Backward or (child.type == TracerEventType.Optimization):\n                    self.add_model_perspective_item(child)\n                else:\n                    if child.type == TracerEventType.ProfileStep:\n                        self.add_model_perspective_item(child)\n                    deque.append(child)",
        "mutated": [
            "def parse(self, nodetrees):\n    if False:\n        i = 10\n    '\\n        Analysis operator event in the nodetress.\\n        '\n    (node_statistic_trees, thread2host_statistic_nodes) = wrap_tree(nodetrees)\n    for (threadid, host_statistic_nodes) in thread2host_statistic_nodes.items():\n        for host_statistic_node in host_statistic_nodes[1:]:\n            if host_statistic_node.type == TracerEventType.Operator:\n                self.add_operator_item(host_statistic_node)\n            if host_statistic_node.type == TracerEventType.UserDefined or host_statistic_node.type == TracerEventType.PythonUserDefined:\n                if 'memcpy' in host_statistic_node.name.lower() or 'memorycopy' in host_statistic_node.name.lower() or 'memset' in host_statistic_node.name.lower():\n                    self.add_memory_manipulation_item(host_statistic_node)\n                elif host_statistic_node.type == TracerEventType.PythonUserDefined:\n                    self.add_userdefined_item(host_statistic_node)\n        self.add_kernel_item(host_statistic_nodes[0])\n    for (threadid, root_statistic_node) in node_statistic_trees.items():\n        deque = collections.deque()\n        deque.append(root_statistic_node)\n        while deque:\n            current_node = deque.popleft()\n            for child in current_node.children_node:\n                if child.type == TracerEventType.Forward or child.type == TracerEventType.Dataloader or child.type == TracerEventType.Backward or (child.type == TracerEventType.Optimization):\n                    self.add_model_perspective_item(child)\n                else:\n                    if child.type == TracerEventType.ProfileStep:\n                        self.add_model_perspective_item(child)\n                    deque.append(child)",
            "def parse(self, nodetrees):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Analysis operator event in the nodetress.\\n        '\n    (node_statistic_trees, thread2host_statistic_nodes) = wrap_tree(nodetrees)\n    for (threadid, host_statistic_nodes) in thread2host_statistic_nodes.items():\n        for host_statistic_node in host_statistic_nodes[1:]:\n            if host_statistic_node.type == TracerEventType.Operator:\n                self.add_operator_item(host_statistic_node)\n            if host_statistic_node.type == TracerEventType.UserDefined or host_statistic_node.type == TracerEventType.PythonUserDefined:\n                if 'memcpy' in host_statistic_node.name.lower() or 'memorycopy' in host_statistic_node.name.lower() or 'memset' in host_statistic_node.name.lower():\n                    self.add_memory_manipulation_item(host_statistic_node)\n                elif host_statistic_node.type == TracerEventType.PythonUserDefined:\n                    self.add_userdefined_item(host_statistic_node)\n        self.add_kernel_item(host_statistic_nodes[0])\n    for (threadid, root_statistic_node) in node_statistic_trees.items():\n        deque = collections.deque()\n        deque.append(root_statistic_node)\n        while deque:\n            current_node = deque.popleft()\n            for child in current_node.children_node:\n                if child.type == TracerEventType.Forward or child.type == TracerEventType.Dataloader or child.type == TracerEventType.Backward or (child.type == TracerEventType.Optimization):\n                    self.add_model_perspective_item(child)\n                else:\n                    if child.type == TracerEventType.ProfileStep:\n                        self.add_model_perspective_item(child)\n                    deque.append(child)",
            "def parse(self, nodetrees):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Analysis operator event in the nodetress.\\n        '\n    (node_statistic_trees, thread2host_statistic_nodes) = wrap_tree(nodetrees)\n    for (threadid, host_statistic_nodes) in thread2host_statistic_nodes.items():\n        for host_statistic_node in host_statistic_nodes[1:]:\n            if host_statistic_node.type == TracerEventType.Operator:\n                self.add_operator_item(host_statistic_node)\n            if host_statistic_node.type == TracerEventType.UserDefined or host_statistic_node.type == TracerEventType.PythonUserDefined:\n                if 'memcpy' in host_statistic_node.name.lower() or 'memorycopy' in host_statistic_node.name.lower() or 'memset' in host_statistic_node.name.lower():\n                    self.add_memory_manipulation_item(host_statistic_node)\n                elif host_statistic_node.type == TracerEventType.PythonUserDefined:\n                    self.add_userdefined_item(host_statistic_node)\n        self.add_kernel_item(host_statistic_nodes[0])\n    for (threadid, root_statistic_node) in node_statistic_trees.items():\n        deque = collections.deque()\n        deque.append(root_statistic_node)\n        while deque:\n            current_node = deque.popleft()\n            for child in current_node.children_node:\n                if child.type == TracerEventType.Forward or child.type == TracerEventType.Dataloader or child.type == TracerEventType.Backward or (child.type == TracerEventType.Optimization):\n                    self.add_model_perspective_item(child)\n                else:\n                    if child.type == TracerEventType.ProfileStep:\n                        self.add_model_perspective_item(child)\n                    deque.append(child)",
            "def parse(self, nodetrees):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Analysis operator event in the nodetress.\\n        '\n    (node_statistic_trees, thread2host_statistic_nodes) = wrap_tree(nodetrees)\n    for (threadid, host_statistic_nodes) in thread2host_statistic_nodes.items():\n        for host_statistic_node in host_statistic_nodes[1:]:\n            if host_statistic_node.type == TracerEventType.Operator:\n                self.add_operator_item(host_statistic_node)\n            if host_statistic_node.type == TracerEventType.UserDefined or host_statistic_node.type == TracerEventType.PythonUserDefined:\n                if 'memcpy' in host_statistic_node.name.lower() or 'memorycopy' in host_statistic_node.name.lower() or 'memset' in host_statistic_node.name.lower():\n                    self.add_memory_manipulation_item(host_statistic_node)\n                elif host_statistic_node.type == TracerEventType.PythonUserDefined:\n                    self.add_userdefined_item(host_statistic_node)\n        self.add_kernel_item(host_statistic_nodes[0])\n    for (threadid, root_statistic_node) in node_statistic_trees.items():\n        deque = collections.deque()\n        deque.append(root_statistic_node)\n        while deque:\n            current_node = deque.popleft()\n            for child in current_node.children_node:\n                if child.type == TracerEventType.Forward or child.type == TracerEventType.Dataloader or child.type == TracerEventType.Backward or (child.type == TracerEventType.Optimization):\n                    self.add_model_perspective_item(child)\n                else:\n                    if child.type == TracerEventType.ProfileStep:\n                        self.add_model_perspective_item(child)\n                    deque.append(child)",
            "def parse(self, nodetrees):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Analysis operator event in the nodetress.\\n        '\n    (node_statistic_trees, thread2host_statistic_nodes) = wrap_tree(nodetrees)\n    for (threadid, host_statistic_nodes) in thread2host_statistic_nodes.items():\n        for host_statistic_node in host_statistic_nodes[1:]:\n            if host_statistic_node.type == TracerEventType.Operator:\n                self.add_operator_item(host_statistic_node)\n            if host_statistic_node.type == TracerEventType.UserDefined or host_statistic_node.type == TracerEventType.PythonUserDefined:\n                if 'memcpy' in host_statistic_node.name.lower() or 'memorycopy' in host_statistic_node.name.lower() or 'memset' in host_statistic_node.name.lower():\n                    self.add_memory_manipulation_item(host_statistic_node)\n                elif host_statistic_node.type == TracerEventType.PythonUserDefined:\n                    self.add_userdefined_item(host_statistic_node)\n        self.add_kernel_item(host_statistic_nodes[0])\n    for (threadid, root_statistic_node) in node_statistic_trees.items():\n        deque = collections.deque()\n        deque.append(root_statistic_node)\n        while deque:\n            current_node = deque.popleft()\n            for child in current_node.children_node:\n                if child.type == TracerEventType.Forward or child.type == TracerEventType.Dataloader or child.type == TracerEventType.Backward or (child.type == TracerEventType.Optimization):\n                    self.add_model_perspective_item(child)\n                else:\n                    if child.type == TracerEventType.ProfileStep:\n                        self.add_model_perspective_item(child)\n                    deque.append(child)"
        ]
    },
    {
        "func_name": "add_forward_item",
        "original": "def add_forward_item(self, operator_node):\n    pass",
        "mutated": [
            "def add_forward_item(self, operator_node):\n    if False:\n        i = 10\n    pass",
            "def add_forward_item(self, operator_node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    pass",
            "def add_forward_item(self, operator_node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    pass",
            "def add_forward_item(self, operator_node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    pass",
            "def add_forward_item(self, operator_node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    pass"
        ]
    },
    {
        "func_name": "add_operator_item",
        "original": "def add_operator_item(self, operator_node):\n    if operator_node.name not in self.items:\n        self.items[operator_node.name] = EventSummary.OperatorItem(operator_node.name)\n    self.items[operator_node.name].add_item(operator_node)\n    if operator_node.name not in self.thread_items[operator_node.thread_id]:\n        self.thread_items[operator_node.thread_id][operator_node.name] = EventSummary.OperatorItem(operator_node.name)\n    self.thread_items[operator_node.thread_id][operator_node.name].add_item(operator_node)",
        "mutated": [
            "def add_operator_item(self, operator_node):\n    if False:\n        i = 10\n    if operator_node.name not in self.items:\n        self.items[operator_node.name] = EventSummary.OperatorItem(operator_node.name)\n    self.items[operator_node.name].add_item(operator_node)\n    if operator_node.name not in self.thread_items[operator_node.thread_id]:\n        self.thread_items[operator_node.thread_id][operator_node.name] = EventSummary.OperatorItem(operator_node.name)\n    self.thread_items[operator_node.thread_id][operator_node.name].add_item(operator_node)",
            "def add_operator_item(self, operator_node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if operator_node.name not in self.items:\n        self.items[operator_node.name] = EventSummary.OperatorItem(operator_node.name)\n    self.items[operator_node.name].add_item(operator_node)\n    if operator_node.name not in self.thread_items[operator_node.thread_id]:\n        self.thread_items[operator_node.thread_id][operator_node.name] = EventSummary.OperatorItem(operator_node.name)\n    self.thread_items[operator_node.thread_id][operator_node.name].add_item(operator_node)",
            "def add_operator_item(self, operator_node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if operator_node.name not in self.items:\n        self.items[operator_node.name] = EventSummary.OperatorItem(operator_node.name)\n    self.items[operator_node.name].add_item(operator_node)\n    if operator_node.name not in self.thread_items[operator_node.thread_id]:\n        self.thread_items[operator_node.thread_id][operator_node.name] = EventSummary.OperatorItem(operator_node.name)\n    self.thread_items[operator_node.thread_id][operator_node.name].add_item(operator_node)",
            "def add_operator_item(self, operator_node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if operator_node.name not in self.items:\n        self.items[operator_node.name] = EventSummary.OperatorItem(operator_node.name)\n    self.items[operator_node.name].add_item(operator_node)\n    if operator_node.name not in self.thread_items[operator_node.thread_id]:\n        self.thread_items[operator_node.thread_id][operator_node.name] = EventSummary.OperatorItem(operator_node.name)\n    self.thread_items[operator_node.thread_id][operator_node.name].add_item(operator_node)",
            "def add_operator_item(self, operator_node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if operator_node.name not in self.items:\n        self.items[operator_node.name] = EventSummary.OperatorItem(operator_node.name)\n    self.items[operator_node.name].add_item(operator_node)\n    if operator_node.name not in self.thread_items[operator_node.thread_id]:\n        self.thread_items[operator_node.thread_id][operator_node.name] = EventSummary.OperatorItem(operator_node.name)\n    self.thread_items[operator_node.thread_id][operator_node.name].add_item(operator_node)"
        ]
    },
    {
        "func_name": "add_userdefined_item",
        "original": "def add_userdefined_item(self, userdefined_node):\n    if userdefined_node.name not in self.userdefined_items:\n        self.userdefined_items[userdefined_node.name] = EventSummary.GeneralItem(userdefined_node.name)\n    self.userdefined_items[userdefined_node.name].add_item(userdefined_node)\n    if userdefined_node.name not in self.userdefined_thread_items[userdefined_node.thread_id]:\n        self.userdefined_thread_items[userdefined_node.thread_id][userdefined_node.name] = EventSummary.GeneralItem(userdefined_node.name)\n    self.userdefined_thread_items[userdefined_node.thread_id][userdefined_node.name].add_item(userdefined_node)",
        "mutated": [
            "def add_userdefined_item(self, userdefined_node):\n    if False:\n        i = 10\n    if userdefined_node.name not in self.userdefined_items:\n        self.userdefined_items[userdefined_node.name] = EventSummary.GeneralItem(userdefined_node.name)\n    self.userdefined_items[userdefined_node.name].add_item(userdefined_node)\n    if userdefined_node.name not in self.userdefined_thread_items[userdefined_node.thread_id]:\n        self.userdefined_thread_items[userdefined_node.thread_id][userdefined_node.name] = EventSummary.GeneralItem(userdefined_node.name)\n    self.userdefined_thread_items[userdefined_node.thread_id][userdefined_node.name].add_item(userdefined_node)",
            "def add_userdefined_item(self, userdefined_node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if userdefined_node.name not in self.userdefined_items:\n        self.userdefined_items[userdefined_node.name] = EventSummary.GeneralItem(userdefined_node.name)\n    self.userdefined_items[userdefined_node.name].add_item(userdefined_node)\n    if userdefined_node.name not in self.userdefined_thread_items[userdefined_node.thread_id]:\n        self.userdefined_thread_items[userdefined_node.thread_id][userdefined_node.name] = EventSummary.GeneralItem(userdefined_node.name)\n    self.userdefined_thread_items[userdefined_node.thread_id][userdefined_node.name].add_item(userdefined_node)",
            "def add_userdefined_item(self, userdefined_node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if userdefined_node.name not in self.userdefined_items:\n        self.userdefined_items[userdefined_node.name] = EventSummary.GeneralItem(userdefined_node.name)\n    self.userdefined_items[userdefined_node.name].add_item(userdefined_node)\n    if userdefined_node.name not in self.userdefined_thread_items[userdefined_node.thread_id]:\n        self.userdefined_thread_items[userdefined_node.thread_id][userdefined_node.name] = EventSummary.GeneralItem(userdefined_node.name)\n    self.userdefined_thread_items[userdefined_node.thread_id][userdefined_node.name].add_item(userdefined_node)",
            "def add_userdefined_item(self, userdefined_node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if userdefined_node.name not in self.userdefined_items:\n        self.userdefined_items[userdefined_node.name] = EventSummary.GeneralItem(userdefined_node.name)\n    self.userdefined_items[userdefined_node.name].add_item(userdefined_node)\n    if userdefined_node.name not in self.userdefined_thread_items[userdefined_node.thread_id]:\n        self.userdefined_thread_items[userdefined_node.thread_id][userdefined_node.name] = EventSummary.GeneralItem(userdefined_node.name)\n    self.userdefined_thread_items[userdefined_node.thread_id][userdefined_node.name].add_item(userdefined_node)",
            "def add_userdefined_item(self, userdefined_node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if userdefined_node.name not in self.userdefined_items:\n        self.userdefined_items[userdefined_node.name] = EventSummary.GeneralItem(userdefined_node.name)\n    self.userdefined_items[userdefined_node.name].add_item(userdefined_node)\n    if userdefined_node.name not in self.userdefined_thread_items[userdefined_node.thread_id]:\n        self.userdefined_thread_items[userdefined_node.thread_id][userdefined_node.name] = EventSummary.GeneralItem(userdefined_node.name)\n    self.userdefined_thread_items[userdefined_node.thread_id][userdefined_node.name].add_item(userdefined_node)"
        ]
    },
    {
        "func_name": "add_memory_manipulation_item",
        "original": "def add_memory_manipulation_item(self, memory_manipulation_node):\n    if memory_manipulation_node.name not in self.memory_manipulation_items:\n        self.memory_manipulation_items[memory_manipulation_node.name] = EventSummary.GeneralItem(memory_manipulation_node.name)\n    self.memory_manipulation_items[memory_manipulation_node.name].add_item(memory_manipulation_node)",
        "mutated": [
            "def add_memory_manipulation_item(self, memory_manipulation_node):\n    if False:\n        i = 10\n    if memory_manipulation_node.name not in self.memory_manipulation_items:\n        self.memory_manipulation_items[memory_manipulation_node.name] = EventSummary.GeneralItem(memory_manipulation_node.name)\n    self.memory_manipulation_items[memory_manipulation_node.name].add_item(memory_manipulation_node)",
            "def add_memory_manipulation_item(self, memory_manipulation_node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if memory_manipulation_node.name not in self.memory_manipulation_items:\n        self.memory_manipulation_items[memory_manipulation_node.name] = EventSummary.GeneralItem(memory_manipulation_node.name)\n    self.memory_manipulation_items[memory_manipulation_node.name].add_item(memory_manipulation_node)",
            "def add_memory_manipulation_item(self, memory_manipulation_node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if memory_manipulation_node.name not in self.memory_manipulation_items:\n        self.memory_manipulation_items[memory_manipulation_node.name] = EventSummary.GeneralItem(memory_manipulation_node.name)\n    self.memory_manipulation_items[memory_manipulation_node.name].add_item(memory_manipulation_node)",
            "def add_memory_manipulation_item(self, memory_manipulation_node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if memory_manipulation_node.name not in self.memory_manipulation_items:\n        self.memory_manipulation_items[memory_manipulation_node.name] = EventSummary.GeneralItem(memory_manipulation_node.name)\n    self.memory_manipulation_items[memory_manipulation_node.name].add_item(memory_manipulation_node)",
            "def add_memory_manipulation_item(self, memory_manipulation_node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if memory_manipulation_node.name not in self.memory_manipulation_items:\n        self.memory_manipulation_items[memory_manipulation_node.name] = EventSummary.GeneralItem(memory_manipulation_node.name)\n    self.memory_manipulation_items[memory_manipulation_node.name].add_item(memory_manipulation_node)"
        ]
    },
    {
        "func_name": "add_model_perspective_item",
        "original": "def add_model_perspective_item(self, model_perspective_node):\n    if model_perspective_node.type == TracerEventType.Forward:\n        name = 'Forward'\n    elif model_perspective_node.type == TracerEventType.Backward:\n        name = 'Backward'\n    elif model_perspective_node.type == TracerEventType.Optimization:\n        name = 'Optimization'\n    elif model_perspective_node.type == TracerEventType.Dataloader:\n        name = 'Dataloader'\n    elif model_perspective_node.type == TracerEventType.ProfileStep:\n        name = 'ProfileStep'\n    else:\n        return\n    if name not in self.model_perspective_items:\n        self.model_perspective_items[name] = EventSummary.GeneralItem(name)\n    self.model_perspective_items[name].add_item(model_perspective_node)",
        "mutated": [
            "def add_model_perspective_item(self, model_perspective_node):\n    if False:\n        i = 10\n    if model_perspective_node.type == TracerEventType.Forward:\n        name = 'Forward'\n    elif model_perspective_node.type == TracerEventType.Backward:\n        name = 'Backward'\n    elif model_perspective_node.type == TracerEventType.Optimization:\n        name = 'Optimization'\n    elif model_perspective_node.type == TracerEventType.Dataloader:\n        name = 'Dataloader'\n    elif model_perspective_node.type == TracerEventType.ProfileStep:\n        name = 'ProfileStep'\n    else:\n        return\n    if name not in self.model_perspective_items:\n        self.model_perspective_items[name] = EventSummary.GeneralItem(name)\n    self.model_perspective_items[name].add_item(model_perspective_node)",
            "def add_model_perspective_item(self, model_perspective_node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if model_perspective_node.type == TracerEventType.Forward:\n        name = 'Forward'\n    elif model_perspective_node.type == TracerEventType.Backward:\n        name = 'Backward'\n    elif model_perspective_node.type == TracerEventType.Optimization:\n        name = 'Optimization'\n    elif model_perspective_node.type == TracerEventType.Dataloader:\n        name = 'Dataloader'\n    elif model_perspective_node.type == TracerEventType.ProfileStep:\n        name = 'ProfileStep'\n    else:\n        return\n    if name not in self.model_perspective_items:\n        self.model_perspective_items[name] = EventSummary.GeneralItem(name)\n    self.model_perspective_items[name].add_item(model_perspective_node)",
            "def add_model_perspective_item(self, model_perspective_node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if model_perspective_node.type == TracerEventType.Forward:\n        name = 'Forward'\n    elif model_perspective_node.type == TracerEventType.Backward:\n        name = 'Backward'\n    elif model_perspective_node.type == TracerEventType.Optimization:\n        name = 'Optimization'\n    elif model_perspective_node.type == TracerEventType.Dataloader:\n        name = 'Dataloader'\n    elif model_perspective_node.type == TracerEventType.ProfileStep:\n        name = 'ProfileStep'\n    else:\n        return\n    if name not in self.model_perspective_items:\n        self.model_perspective_items[name] = EventSummary.GeneralItem(name)\n    self.model_perspective_items[name].add_item(model_perspective_node)",
            "def add_model_perspective_item(self, model_perspective_node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if model_perspective_node.type == TracerEventType.Forward:\n        name = 'Forward'\n    elif model_perspective_node.type == TracerEventType.Backward:\n        name = 'Backward'\n    elif model_perspective_node.type == TracerEventType.Optimization:\n        name = 'Optimization'\n    elif model_perspective_node.type == TracerEventType.Dataloader:\n        name = 'Dataloader'\n    elif model_perspective_node.type == TracerEventType.ProfileStep:\n        name = 'ProfileStep'\n    else:\n        return\n    if name not in self.model_perspective_items:\n        self.model_perspective_items[name] = EventSummary.GeneralItem(name)\n    self.model_perspective_items[name].add_item(model_perspective_node)",
            "def add_model_perspective_item(self, model_perspective_node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if model_perspective_node.type == TracerEventType.Forward:\n        name = 'Forward'\n    elif model_perspective_node.type == TracerEventType.Backward:\n        name = 'Backward'\n    elif model_perspective_node.type == TracerEventType.Optimization:\n        name = 'Optimization'\n    elif model_perspective_node.type == TracerEventType.Dataloader:\n        name = 'Dataloader'\n    elif model_perspective_node.type == TracerEventType.ProfileStep:\n        name = 'ProfileStep'\n    else:\n        return\n    if name not in self.model_perspective_items:\n        self.model_perspective_items[name] = EventSummary.GeneralItem(name)\n    self.model_perspective_items[name].add_item(model_perspective_node)"
        ]
    },
    {
        "func_name": "add_kernel_item",
        "original": "def add_kernel_item(self, root_node):\n    device_nodes = get_device_nodes(root_node)\n    for device_node in device_nodes:\n        if device_node.type == TracerEventType.Kernel:\n            name = device_node.name\n            if name not in self.kernel_items:\n                self.kernel_items[name] = EventSummary.DeviceItem(name)\n            self.kernel_items[name].add_item(device_node)",
        "mutated": [
            "def add_kernel_item(self, root_node):\n    if False:\n        i = 10\n    device_nodes = get_device_nodes(root_node)\n    for device_node in device_nodes:\n        if device_node.type == TracerEventType.Kernel:\n            name = device_node.name\n            if name not in self.kernel_items:\n                self.kernel_items[name] = EventSummary.DeviceItem(name)\n            self.kernel_items[name].add_item(device_node)",
            "def add_kernel_item(self, root_node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    device_nodes = get_device_nodes(root_node)\n    for device_node in device_nodes:\n        if device_node.type == TracerEventType.Kernel:\n            name = device_node.name\n            if name not in self.kernel_items:\n                self.kernel_items[name] = EventSummary.DeviceItem(name)\n            self.kernel_items[name].add_item(device_node)",
            "def add_kernel_item(self, root_node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    device_nodes = get_device_nodes(root_node)\n    for device_node in device_nodes:\n        if device_node.type == TracerEventType.Kernel:\n            name = device_node.name\n            if name not in self.kernel_items:\n                self.kernel_items[name] = EventSummary.DeviceItem(name)\n            self.kernel_items[name].add_item(device_node)",
            "def add_kernel_item(self, root_node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    device_nodes = get_device_nodes(root_node)\n    for device_node in device_nodes:\n        if device_node.type == TracerEventType.Kernel:\n            name = device_node.name\n            if name not in self.kernel_items:\n                self.kernel_items[name] = EventSummary.DeviceItem(name)\n            self.kernel_items[name].add_item(device_node)",
            "def add_kernel_item(self, root_node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    device_nodes = get_device_nodes(root_node)\n    for device_node in device_nodes:\n        if device_node.type == TracerEventType.Kernel:\n            name = device_node.name\n            if name not in self.kernel_items:\n                self.kernel_items[name] = EventSummary.DeviceItem(name)\n            self.kernel_items[name].add_item(device_node)"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, event_name, place, memory_type='Allocated'):\n    self.event_name = event_name\n    self.place = place\n    self.allocation_count = 0\n    self.free_count = 0\n    self.allocation_size = 0\n    self.free_size = 0\n    self.increase_size = 0\n    self.memory_type = memory_type",
        "mutated": [
            "def __init__(self, event_name, place, memory_type='Allocated'):\n    if False:\n        i = 10\n    self.event_name = event_name\n    self.place = place\n    self.allocation_count = 0\n    self.free_count = 0\n    self.allocation_size = 0\n    self.free_size = 0\n    self.increase_size = 0\n    self.memory_type = memory_type",
            "def __init__(self, event_name, place, memory_type='Allocated'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.event_name = event_name\n    self.place = place\n    self.allocation_count = 0\n    self.free_count = 0\n    self.allocation_size = 0\n    self.free_size = 0\n    self.increase_size = 0\n    self.memory_type = memory_type",
            "def __init__(self, event_name, place, memory_type='Allocated'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.event_name = event_name\n    self.place = place\n    self.allocation_count = 0\n    self.free_count = 0\n    self.allocation_size = 0\n    self.free_size = 0\n    self.increase_size = 0\n    self.memory_type = memory_type",
            "def __init__(self, event_name, place, memory_type='Allocated'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.event_name = event_name\n    self.place = place\n    self.allocation_count = 0\n    self.free_count = 0\n    self.allocation_size = 0\n    self.free_size = 0\n    self.increase_size = 0\n    self.memory_type = memory_type",
            "def __init__(self, event_name, place, memory_type='Allocated'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.event_name = event_name\n    self.place = place\n    self.allocation_count = 0\n    self.free_count = 0\n    self.allocation_size = 0\n    self.free_size = 0\n    self.increase_size = 0\n    self.memory_type = memory_type"
        ]
    },
    {
        "func_name": "add_memory_record",
        "original": "def add_memory_record(self, size, allocation_type):\n    if allocation_type == TracerMemEventType.Allocate or allocation_type == TracerMemEventType.ReservedAllocate:\n        self.allocation_count += 1\n        self.allocation_size += size\n    elif allocation_type == TracerMemEventType.Free or allocation_type == TracerMemEventType.ReservedFree:\n        self.free_count += 1\n        self.free_size -= size\n    else:\n        print('No corresponding type.')\n    self.increase_size = self.allocation_size - self.free_size",
        "mutated": [
            "def add_memory_record(self, size, allocation_type):\n    if False:\n        i = 10\n    if allocation_type == TracerMemEventType.Allocate or allocation_type == TracerMemEventType.ReservedAllocate:\n        self.allocation_count += 1\n        self.allocation_size += size\n    elif allocation_type == TracerMemEventType.Free or allocation_type == TracerMemEventType.ReservedFree:\n        self.free_count += 1\n        self.free_size -= size\n    else:\n        print('No corresponding type.')\n    self.increase_size = self.allocation_size - self.free_size",
            "def add_memory_record(self, size, allocation_type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if allocation_type == TracerMemEventType.Allocate or allocation_type == TracerMemEventType.ReservedAllocate:\n        self.allocation_count += 1\n        self.allocation_size += size\n    elif allocation_type == TracerMemEventType.Free or allocation_type == TracerMemEventType.ReservedFree:\n        self.free_count += 1\n        self.free_size -= size\n    else:\n        print('No corresponding type.')\n    self.increase_size = self.allocation_size - self.free_size",
            "def add_memory_record(self, size, allocation_type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if allocation_type == TracerMemEventType.Allocate or allocation_type == TracerMemEventType.ReservedAllocate:\n        self.allocation_count += 1\n        self.allocation_size += size\n    elif allocation_type == TracerMemEventType.Free or allocation_type == TracerMemEventType.ReservedFree:\n        self.free_count += 1\n        self.free_size -= size\n    else:\n        print('No corresponding type.')\n    self.increase_size = self.allocation_size - self.free_size",
            "def add_memory_record(self, size, allocation_type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if allocation_type == TracerMemEventType.Allocate or allocation_type == TracerMemEventType.ReservedAllocate:\n        self.allocation_count += 1\n        self.allocation_size += size\n    elif allocation_type == TracerMemEventType.Free or allocation_type == TracerMemEventType.ReservedFree:\n        self.free_count += 1\n        self.free_size -= size\n    else:\n        print('No corresponding type.')\n    self.increase_size = self.allocation_size - self.free_size",
            "def add_memory_record(self, size, allocation_type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if allocation_type == TracerMemEventType.Allocate or allocation_type == TracerMemEventType.ReservedAllocate:\n        self.allocation_count += 1\n        self.allocation_size += size\n    elif allocation_type == TracerMemEventType.Free or allocation_type == TracerMemEventType.ReservedFree:\n        self.free_count += 1\n        self.free_size -= size\n    else:\n        print('No corresponding type.')\n    self.increase_size = self.allocation_size - self.free_size"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self):\n    self.allocated_items = collections.defaultdict(dict)\n    self.reserved_items = collections.defaultdict(dict)\n    self.peak_allocation_values = collections.defaultdict(int)\n    self.peak_reserved_values = collections.defaultdict(int)",
        "mutated": [
            "def __init__(self):\n    if False:\n        i = 10\n    self.allocated_items = collections.defaultdict(dict)\n    self.reserved_items = collections.defaultdict(dict)\n    self.peak_allocation_values = collections.defaultdict(int)\n    self.peak_reserved_values = collections.defaultdict(int)",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.allocated_items = collections.defaultdict(dict)\n    self.reserved_items = collections.defaultdict(dict)\n    self.peak_allocation_values = collections.defaultdict(int)\n    self.peak_reserved_values = collections.defaultdict(int)",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.allocated_items = collections.defaultdict(dict)\n    self.reserved_items = collections.defaultdict(dict)\n    self.peak_allocation_values = collections.defaultdict(int)\n    self.peak_reserved_values = collections.defaultdict(int)",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.allocated_items = collections.defaultdict(dict)\n    self.reserved_items = collections.defaultdict(dict)\n    self.peak_allocation_values = collections.defaultdict(int)\n    self.peak_reserved_values = collections.defaultdict(int)",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.allocated_items = collections.defaultdict(dict)\n    self.reserved_items = collections.defaultdict(dict)\n    self.peak_allocation_values = collections.defaultdict(int)\n    self.peak_reserved_values = collections.defaultdict(int)"
        ]
    },
    {
        "func_name": "_analyse_node_memory",
        "original": "def _analyse_node_memory(self, event_name, node):\n    for memnode in node.mem_node:\n        if memnode.type == TracerMemEventType.Allocate or memnode.type == TracerMemEventType.Free:\n            if event_name not in self.allocated_items[memnode.place]:\n                self.allocated_items[memnode.place][event_name] = MemorySummary.MemoryItem(event_name, memnode.place, 'Allocated')\n            self.allocated_items[memnode.place][event_name].add_memory_record(memnode.increase_bytes, memnode.type)\n        elif memnode.type == TracerMemEventType.ReservedAllocate or memnode.type == TracerMemEventType.ReservedFree:\n            if event_name not in self.reserved_items[memnode.place]:\n                self.reserved_items[memnode.place][event_name] = MemorySummary.MemoryItem(event_name, memnode.place, 'Reserved')\n            self.reserved_items[memnode.place][event_name].add_memory_record(memnode.increase_bytes, memnode.type)\n        self.peak_allocation_values[memnode.place] = max(self.peak_allocation_values[memnode.place], memnode.peak_allocated)\n        self.peak_reserved_values[memnode.place] = max(self.peak_reserved_values[memnode.place], memnode.peak_reserved)",
        "mutated": [
            "def _analyse_node_memory(self, event_name, node):\n    if False:\n        i = 10\n    for memnode in node.mem_node:\n        if memnode.type == TracerMemEventType.Allocate or memnode.type == TracerMemEventType.Free:\n            if event_name not in self.allocated_items[memnode.place]:\n                self.allocated_items[memnode.place][event_name] = MemorySummary.MemoryItem(event_name, memnode.place, 'Allocated')\n            self.allocated_items[memnode.place][event_name].add_memory_record(memnode.increase_bytes, memnode.type)\n        elif memnode.type == TracerMemEventType.ReservedAllocate or memnode.type == TracerMemEventType.ReservedFree:\n            if event_name not in self.reserved_items[memnode.place]:\n                self.reserved_items[memnode.place][event_name] = MemorySummary.MemoryItem(event_name, memnode.place, 'Reserved')\n            self.reserved_items[memnode.place][event_name].add_memory_record(memnode.increase_bytes, memnode.type)\n        self.peak_allocation_values[memnode.place] = max(self.peak_allocation_values[memnode.place], memnode.peak_allocated)\n        self.peak_reserved_values[memnode.place] = max(self.peak_reserved_values[memnode.place], memnode.peak_reserved)",
            "def _analyse_node_memory(self, event_name, node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    for memnode in node.mem_node:\n        if memnode.type == TracerMemEventType.Allocate or memnode.type == TracerMemEventType.Free:\n            if event_name not in self.allocated_items[memnode.place]:\n                self.allocated_items[memnode.place][event_name] = MemorySummary.MemoryItem(event_name, memnode.place, 'Allocated')\n            self.allocated_items[memnode.place][event_name].add_memory_record(memnode.increase_bytes, memnode.type)\n        elif memnode.type == TracerMemEventType.ReservedAllocate or memnode.type == TracerMemEventType.ReservedFree:\n            if event_name not in self.reserved_items[memnode.place]:\n                self.reserved_items[memnode.place][event_name] = MemorySummary.MemoryItem(event_name, memnode.place, 'Reserved')\n            self.reserved_items[memnode.place][event_name].add_memory_record(memnode.increase_bytes, memnode.type)\n        self.peak_allocation_values[memnode.place] = max(self.peak_allocation_values[memnode.place], memnode.peak_allocated)\n        self.peak_reserved_values[memnode.place] = max(self.peak_reserved_values[memnode.place], memnode.peak_reserved)",
            "def _analyse_node_memory(self, event_name, node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    for memnode in node.mem_node:\n        if memnode.type == TracerMemEventType.Allocate or memnode.type == TracerMemEventType.Free:\n            if event_name not in self.allocated_items[memnode.place]:\n                self.allocated_items[memnode.place][event_name] = MemorySummary.MemoryItem(event_name, memnode.place, 'Allocated')\n            self.allocated_items[memnode.place][event_name].add_memory_record(memnode.increase_bytes, memnode.type)\n        elif memnode.type == TracerMemEventType.ReservedAllocate or memnode.type == TracerMemEventType.ReservedFree:\n            if event_name not in self.reserved_items[memnode.place]:\n                self.reserved_items[memnode.place][event_name] = MemorySummary.MemoryItem(event_name, memnode.place, 'Reserved')\n            self.reserved_items[memnode.place][event_name].add_memory_record(memnode.increase_bytes, memnode.type)\n        self.peak_allocation_values[memnode.place] = max(self.peak_allocation_values[memnode.place], memnode.peak_allocated)\n        self.peak_reserved_values[memnode.place] = max(self.peak_reserved_values[memnode.place], memnode.peak_reserved)",
            "def _analyse_node_memory(self, event_name, node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    for memnode in node.mem_node:\n        if memnode.type == TracerMemEventType.Allocate or memnode.type == TracerMemEventType.Free:\n            if event_name not in self.allocated_items[memnode.place]:\n                self.allocated_items[memnode.place][event_name] = MemorySummary.MemoryItem(event_name, memnode.place, 'Allocated')\n            self.allocated_items[memnode.place][event_name].add_memory_record(memnode.increase_bytes, memnode.type)\n        elif memnode.type == TracerMemEventType.ReservedAllocate or memnode.type == TracerMemEventType.ReservedFree:\n            if event_name not in self.reserved_items[memnode.place]:\n                self.reserved_items[memnode.place][event_name] = MemorySummary.MemoryItem(event_name, memnode.place, 'Reserved')\n            self.reserved_items[memnode.place][event_name].add_memory_record(memnode.increase_bytes, memnode.type)\n        self.peak_allocation_values[memnode.place] = max(self.peak_allocation_values[memnode.place], memnode.peak_allocated)\n        self.peak_reserved_values[memnode.place] = max(self.peak_reserved_values[memnode.place], memnode.peak_reserved)",
            "def _analyse_node_memory(self, event_name, node):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    for memnode in node.mem_node:\n        if memnode.type == TracerMemEventType.Allocate or memnode.type == TracerMemEventType.Free:\n            if event_name not in self.allocated_items[memnode.place]:\n                self.allocated_items[memnode.place][event_name] = MemorySummary.MemoryItem(event_name, memnode.place, 'Allocated')\n            self.allocated_items[memnode.place][event_name].add_memory_record(memnode.increase_bytes, memnode.type)\n        elif memnode.type == TracerMemEventType.ReservedAllocate or memnode.type == TracerMemEventType.ReservedFree:\n            if event_name not in self.reserved_items[memnode.place]:\n                self.reserved_items[memnode.place][event_name] = MemorySummary.MemoryItem(event_name, memnode.place, 'Reserved')\n            self.reserved_items[memnode.place][event_name].add_memory_record(memnode.increase_bytes, memnode.type)\n        self.peak_allocation_values[memnode.place] = max(self.peak_allocation_values[memnode.place], memnode.peak_allocated)\n        self.peak_reserved_values[memnode.place] = max(self.peak_reserved_values[memnode.place], memnode.peak_reserved)"
        ]
    },
    {
        "func_name": "parse",
        "original": "def parse(self, nodetrees):\n    \"\"\"\n        Analyse memory event in the nodetress.\n        \"\"\"\n    thread2hostnodes = traverse_tree(nodetrees)\n    for (threadid, host_nodes) in thread2hostnodes.items():\n        for host_node in host_nodes[1:]:\n            if host_node.type == TracerEventType.OperatorInner:\n                continue\n            if host_node.type == TracerEventType.Operator:\n                for child in host_node.children_node:\n                    self._analyse_node_memory(host_node.name, child)\n            self._analyse_node_memory(host_node.name, host_node)",
        "mutated": [
            "def parse(self, nodetrees):\n    if False:\n        i = 10\n    '\\n        Analyse memory event in the nodetress.\\n        '\n    thread2hostnodes = traverse_tree(nodetrees)\n    for (threadid, host_nodes) in thread2hostnodes.items():\n        for host_node in host_nodes[1:]:\n            if host_node.type == TracerEventType.OperatorInner:\n                continue\n            if host_node.type == TracerEventType.Operator:\n                for child in host_node.children_node:\n                    self._analyse_node_memory(host_node.name, child)\n            self._analyse_node_memory(host_node.name, host_node)",
            "def parse(self, nodetrees):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Analyse memory event in the nodetress.\\n        '\n    thread2hostnodes = traverse_tree(nodetrees)\n    for (threadid, host_nodes) in thread2hostnodes.items():\n        for host_node in host_nodes[1:]:\n            if host_node.type == TracerEventType.OperatorInner:\n                continue\n            if host_node.type == TracerEventType.Operator:\n                for child in host_node.children_node:\n                    self._analyse_node_memory(host_node.name, child)\n            self._analyse_node_memory(host_node.name, host_node)",
            "def parse(self, nodetrees):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Analyse memory event in the nodetress.\\n        '\n    thread2hostnodes = traverse_tree(nodetrees)\n    for (threadid, host_nodes) in thread2hostnodes.items():\n        for host_node in host_nodes[1:]:\n            if host_node.type == TracerEventType.OperatorInner:\n                continue\n            if host_node.type == TracerEventType.Operator:\n                for child in host_node.children_node:\n                    self._analyse_node_memory(host_node.name, child)\n            self._analyse_node_memory(host_node.name, host_node)",
            "def parse(self, nodetrees):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Analyse memory event in the nodetress.\\n        '\n    thread2hostnodes = traverse_tree(nodetrees)\n    for (threadid, host_nodes) in thread2hostnodes.items():\n        for host_node in host_nodes[1:]:\n            if host_node.type == TracerEventType.OperatorInner:\n                continue\n            if host_node.type == TracerEventType.Operator:\n                for child in host_node.children_node:\n                    self._analyse_node_memory(host_node.name, child)\n            self._analyse_node_memory(host_node.name, host_node)",
            "def parse(self, nodetrees):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Analyse memory event in the nodetress.\\n        '\n    thread2hostnodes = traverse_tree(nodetrees)\n    for (threadid, host_nodes) in thread2hostnodes.items():\n        for host_node in host_nodes[1:]:\n            if host_node.type == TracerEventType.OperatorInner:\n                continue\n            if host_node.type == TracerEventType.Operator:\n                for child in host_node.children_node:\n                    self._analyse_node_memory(host_node.name, child)\n            self._analyse_node_memory(host_node.name, host_node)"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, node_trees, extra_info):\n    self.node_trees = node_trees\n    self.extra_info = extra_info\n    self.time_range_summary = TimeRangeSummary()\n    self.event_summary = EventSummary()\n    self.distributed_summary = DistributedSummary()\n    self.memory_summary = MemorySummary()\n    self.time_range_summary.parse(node_trees)\n    self.event_summary.parse(node_trees)\n    self.distributed_summary.parse(node_trees)\n    self.memory_summary.parse(node_trees)",
        "mutated": [
            "def __init__(self, node_trees, extra_info):\n    if False:\n        i = 10\n    self.node_trees = node_trees\n    self.extra_info = extra_info\n    self.time_range_summary = TimeRangeSummary()\n    self.event_summary = EventSummary()\n    self.distributed_summary = DistributedSummary()\n    self.memory_summary = MemorySummary()\n    self.time_range_summary.parse(node_trees)\n    self.event_summary.parse(node_trees)\n    self.distributed_summary.parse(node_trees)\n    self.memory_summary.parse(node_trees)",
            "def __init__(self, node_trees, extra_info):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.node_trees = node_trees\n    self.extra_info = extra_info\n    self.time_range_summary = TimeRangeSummary()\n    self.event_summary = EventSummary()\n    self.distributed_summary = DistributedSummary()\n    self.memory_summary = MemorySummary()\n    self.time_range_summary.parse(node_trees)\n    self.event_summary.parse(node_trees)\n    self.distributed_summary.parse(node_trees)\n    self.memory_summary.parse(node_trees)",
            "def __init__(self, node_trees, extra_info):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.node_trees = node_trees\n    self.extra_info = extra_info\n    self.time_range_summary = TimeRangeSummary()\n    self.event_summary = EventSummary()\n    self.distributed_summary = DistributedSummary()\n    self.memory_summary = MemorySummary()\n    self.time_range_summary.parse(node_trees)\n    self.event_summary.parse(node_trees)\n    self.distributed_summary.parse(node_trees)\n    self.memory_summary.parse(node_trees)",
            "def __init__(self, node_trees, extra_info):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.node_trees = node_trees\n    self.extra_info = extra_info\n    self.time_range_summary = TimeRangeSummary()\n    self.event_summary = EventSummary()\n    self.distributed_summary = DistributedSummary()\n    self.memory_summary = MemorySummary()\n    self.time_range_summary.parse(node_trees)\n    self.event_summary.parse(node_trees)\n    self.distributed_summary.parse(node_trees)\n    self.memory_summary.parse(node_trees)",
            "def __init__(self, node_trees, extra_info):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.node_trees = node_trees\n    self.extra_info = extra_info\n    self.time_range_summary = TimeRangeSummary()\n    self.event_summary = EventSummary()\n    self.distributed_summary = DistributedSummary()\n    self.memory_summary = MemorySummary()\n    self.time_range_summary.parse(node_trees)\n    self.event_summary.parse(node_trees)\n    self.distributed_summary.parse(node_trees)\n    self.memory_summary.parse(node_trees)"
        ]
    },
    {
        "func_name": "add_column",
        "original": "def add_column(padding, text_dir='<'):\n    row_format_list[0] += '{: ' + text_dir + str(padding) + '}' + ' ' * SPACING_SIZE\n    header_sep_list[0] += '-' * padding + ' ' * SPACING_SIZE\n    line_length_list[0] += padding + SPACING_SIZE",
        "mutated": [
            "def add_column(padding, text_dir='<'):\n    if False:\n        i = 10\n    row_format_list[0] += '{: ' + text_dir + str(padding) + '}' + ' ' * SPACING_SIZE\n    header_sep_list[0] += '-' * padding + ' ' * SPACING_SIZE\n    line_length_list[0] += padding + SPACING_SIZE",
            "def add_column(padding, text_dir='<'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    row_format_list[0] += '{: ' + text_dir + str(padding) + '}' + ' ' * SPACING_SIZE\n    header_sep_list[0] += '-' * padding + ' ' * SPACING_SIZE\n    line_length_list[0] += padding + SPACING_SIZE",
            "def add_column(padding, text_dir='<'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    row_format_list[0] += '{: ' + text_dir + str(padding) + '}' + ' ' * SPACING_SIZE\n    header_sep_list[0] += '-' * padding + ' ' * SPACING_SIZE\n    line_length_list[0] += padding + SPACING_SIZE",
            "def add_column(padding, text_dir='<'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    row_format_list[0] += '{: ' + text_dir + str(padding) + '}' + ' ' * SPACING_SIZE\n    header_sep_list[0] += '-' * padding + ' ' * SPACING_SIZE\n    line_length_list[0] += padding + SPACING_SIZE",
            "def add_column(padding, text_dir='<'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    row_format_list[0] += '{: ' + text_dir + str(padding) + '}' + ' ' * SPACING_SIZE\n    header_sep_list[0] += '-' * padding + ' ' * SPACING_SIZE\n    line_length_list[0] += padding + SPACING_SIZE"
        ]
    },
    {
        "func_name": "add_title",
        "original": "def add_title(padding, text):\n    left_length = padding - len(text)\n    half = left_length // 2\n    return '-' * half + text + '-' * (left_length - half)",
        "mutated": [
            "def add_title(padding, text):\n    if False:\n        i = 10\n    left_length = padding - len(text)\n    half = left_length // 2\n    return '-' * half + text + '-' * (left_length - half)",
            "def add_title(padding, text):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    left_length = padding - len(text)\n    half = left_length // 2\n    return '-' * half + text + '-' * (left_length - half)",
            "def add_title(padding, text):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    left_length = padding - len(text)\n    half = left_length // 2\n    return '-' * half + text + '-' * (left_length - half)",
            "def add_title(padding, text):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    left_length = padding - len(text)\n    half = left_length // 2\n    return '-' * half + text + '-' * (left_length - half)",
            "def add_title(padding, text):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    left_length = padding - len(text)\n    half = left_length // 2\n    return '-' * half + text + '-' * (left_length - half)"
        ]
    },
    {
        "func_name": "append",
        "original": "def append(s):\n    result.append(s)\n    result.append('\\n')",
        "mutated": [
            "def append(s):\n    if False:\n        i = 10\n    result.append(s)\n    result.append('\\n')",
            "def append(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    result.append(s)\n    result.append('\\n')",
            "def append(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    result.append(s)\n    result.append('\\n')",
            "def append(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    result.append(s)\n    result.append('\\n')",
            "def append(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    result.append(s)\n    result.append('\\n')"
        ]
    },
    {
        "func_name": "format_time",
        "original": "def format_time(time, unit='ms', indent=0):\n    \"\"\"\n        Transform time in ns to time in unit.\n        \"\"\"\n    if time == float('inf'):\n        return '-'\n    else:\n        result = float(time)\n        if unit == 's':\n            result /= 1000000000.0\n        elif unit == 'ms':\n            result /= 1000000.0\n        elif unit == 'us':\n            result /= 1000.0\n        return '{}{:.2f}'.format(' ' * indent, result)",
        "mutated": [
            "def format_time(time, unit='ms', indent=0):\n    if False:\n        i = 10\n    '\\n        Transform time in ns to time in unit.\\n        '\n    if time == float('inf'):\n        return '-'\n    else:\n        result = float(time)\n        if unit == 's':\n            result /= 1000000000.0\n        elif unit == 'ms':\n            result /= 1000000.0\n        elif unit == 'us':\n            result /= 1000.0\n        return '{}{:.2f}'.format(' ' * indent, result)",
            "def format_time(time, unit='ms', indent=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Transform time in ns to time in unit.\\n        '\n    if time == float('inf'):\n        return '-'\n    else:\n        result = float(time)\n        if unit == 's':\n            result /= 1000000000.0\n        elif unit == 'ms':\n            result /= 1000000.0\n        elif unit == 'us':\n            result /= 1000.0\n        return '{}{:.2f}'.format(' ' * indent, result)",
            "def format_time(time, unit='ms', indent=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Transform time in ns to time in unit.\\n        '\n    if time == float('inf'):\n        return '-'\n    else:\n        result = float(time)\n        if unit == 's':\n            result /= 1000000000.0\n        elif unit == 'ms':\n            result /= 1000000.0\n        elif unit == 'us':\n            result /= 1000.0\n        return '{}{:.2f}'.format(' ' * indent, result)",
            "def format_time(time, unit='ms', indent=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Transform time in ns to time in unit.\\n        '\n    if time == float('inf'):\n        return '-'\n    else:\n        result = float(time)\n        if unit == 's':\n            result /= 1000000000.0\n        elif unit == 'ms':\n            result /= 1000000.0\n        elif unit == 'us':\n            result /= 1000.0\n        return '{}{:.2f}'.format(' ' * indent, result)",
            "def format_time(time, unit='ms', indent=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Transform time in ns to time in unit.\\n        '\n    if time == float('inf'):\n        return '-'\n    else:\n        result = float(time)\n        if unit == 's':\n            result /= 1000000000.0\n        elif unit == 'ms':\n            result /= 1000000.0\n        elif unit == 'us':\n            result /= 1000.0\n        return '{}{:.2f}'.format(' ' * indent, result)"
        ]
    },
    {
        "func_name": "format_ratio",
        "original": "def format_ratio(ratio, indent=0):\n    \"\"\"\n        Transform ratio within [0, 1] to percentage presentation.\n        \"\"\"\n    return '{}{:.2f}'.format(' ' * indent, ratio * 100)",
        "mutated": [
            "def format_ratio(ratio, indent=0):\n    if False:\n        i = 10\n    '\\n        Transform ratio within [0, 1] to percentage presentation.\\n        '\n    return '{}{:.2f}'.format(' ' * indent, ratio * 100)",
            "def format_ratio(ratio, indent=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Transform ratio within [0, 1] to percentage presentation.\\n        '\n    return '{}{:.2f}'.format(' ' * indent, ratio * 100)",
            "def format_ratio(ratio, indent=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Transform ratio within [0, 1] to percentage presentation.\\n        '\n    return '{}{:.2f}'.format(' ' * indent, ratio * 100)",
            "def format_ratio(ratio, indent=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Transform ratio within [0, 1] to percentage presentation.\\n        '\n    return '{}{:.2f}'.format(' ' * indent, ratio * 100)",
            "def format_ratio(ratio, indent=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Transform ratio within [0, 1] to percentage presentation.\\n        '\n    return '{}{:.2f}'.format(' ' * indent, ratio * 100)"
        ]
    },
    {
        "func_name": "_build_table",
        "original": "def _build_table(statistic_data, sorted_by=SortedKeys.CPUTotal, op_detail=True, thread_sep=False, time_unit='ms', row_limit=100, max_src_column_width=75, views=None):\n    from .profiler import SummaryView\n    'Prints a summary of events.'\n    SPACING_SIZE = 2\n    row_format_list = ['']\n    header_sep_list = ['']\n    line_length_list = [-SPACING_SIZE]\n\n    def add_column(padding, text_dir='<'):\n        row_format_list[0] += '{: ' + text_dir + str(padding) + '}' + ' ' * SPACING_SIZE\n        header_sep_list[0] += '-' * padding + ' ' * SPACING_SIZE\n        line_length_list[0] += padding + SPACING_SIZE\n\n    def add_title(padding, text):\n        left_length = padding - len(text)\n        half = left_length // 2\n        return '-' * half + text + '-' * (left_length - half)\n    result = []\n\n    def append(s):\n        result.append(s)\n        result.append('\\n')\n\n    def format_time(time, unit='ms', indent=0):\n        \"\"\"\n        Transform time in ns to time in unit.\n        \"\"\"\n        if time == float('inf'):\n            return '-'\n        else:\n            result = float(time)\n            if unit == 's':\n                result /= 1000000000.0\n            elif unit == 'ms':\n                result /= 1000000.0\n            elif unit == 'us':\n                result /= 1000.0\n            return '{}{:.2f}'.format(' ' * indent, result)\n\n    def format_ratio(ratio, indent=0):\n        \"\"\"\n        Transform ratio within [0, 1] to percentage presentation.\n        \"\"\"\n        return '{}{:.2f}'.format(' ' * indent, ratio * 100)\n    total_time = statistic_data.time_range_summary.get_cpu_range_sum(TracerEventType.ProfileStep)\n    if views is None or SummaryView.DeviceView in views:\n        headers = ['Device', 'Utilization (%)']\n        name_column_width = 30\n        DEFAULT_COLUMN_WIDTH = 20\n        add_column(name_column_width)\n        for _ in headers[1:]:\n            add_column(DEFAULT_COLUMN_WIDTH)\n        row_format = row_format_list[0]\n        header_sep = header_sep_list[0]\n        line_length = line_length_list[0]\n        append(add_title(line_length, 'Device Summary'))\n        append(header_sep)\n        append(row_format.format(*headers))\n        append(header_sep)\n        row_values = ['CPU(Process)', format_ratio(float(statistic_data.extra_info['Process Cpu Utilization']))]\n        append(row_format.format(*row_values))\n        row_values = ['CPU(System)', format_ratio(float(statistic_data.extra_info['System Cpu Utilization']))]\n        append(row_format.format(*row_values))\n        for gpu_name in statistic_data.time_range_summary.get_gpu_devices():\n            gpu_time = float(statistic_data.time_range_summary.get_gpu_range_sum(gpu_name, TracerEventType.Kernel))\n            utilization = gpu_time / total_time\n            row_values = [f'GPU{gpu_name}', format_ratio(utilization)]\n            append(row_format.format(*row_values))\n        append(header_sep)\n        append('Note:\\nCPU(Process) Utilization = Current process CPU time over all cpu cores / elapsed time, so max utilization can be reached 100% * number of cpu cores.\\nCPU(System) Utilization = All processes CPU time over all cpu cores(busy time) / (busy time + idle time).\\nGPU Utilization = Current process GPU time / elapsed time.')\n        append('-' * line_length)\n        append('')\n        append('')\n        if total_time == 0:\n            return ''.join(result)\n    if views is None or SummaryView.OverView in views:\n        headers = ['Event Type', 'Calls', 'CPU Time', 'Ratio (%)']\n        row_format_list = ['']\n        header_sep_list = ['']\n        line_length_list = [-SPACING_SIZE]\n        DEFAULT_COLUMN_WIDTH = 25\n        for _ in headers:\n            add_column(DEFAULT_COLUMN_WIDTH)\n        row_format = row_format_list[0]\n        header_sep = header_sep_list[0]\n        line_length = line_length_list[0]\n        append(add_title(line_length, 'Overview Summary'))\n        append(f'Time unit: {time_unit}')\n        append(header_sep)\n        append(row_format.format(*headers))\n        append(header_sep)\n        cpu_type_time = collections.defaultdict(int)\n        gpu_type_time = collections.defaultdict(int)\n        cpu_call_times = collections.defaultdict(int)\n        gpu_call_times = collections.defaultdict(int)\n        cpu_call_times.update(statistic_data.time_range_summary.call_times)\n        gpu_call_times.update(statistic_data.time_range_summary.call_times)\n        for (event_type, value) in statistic_data.time_range_summary.CPUTimeRangeSum.items():\n            if event_type != TracerEventType.Communication:\n                cpu_type_time[event_type] = value\n        if statistic_data.distributed_summary.cpu_communication_range:\n            cpu_type_time[TracerEventType.Communication] = sum_ranges(statistic_data.distributed_summary.cpu_communication_range)\n            cpu_call_times[TracerEventType.Communication] = statistic_data.distributed_summary.cpu_calls\n        for event_type in [TracerEventType.Dataloader, TracerEventType.Forward, TracerEventType.Backward, TracerEventType.Optimization]:\n            event_type_name = str(event_type).split('.')[1]\n            if event_type in cpu_call_times and event_type_name in statistic_data.event_summary.model_perspective_items:\n                cpu_call_times[event_type] = statistic_data.event_summary.model_perspective_items[event_type_name].call\n                cpu_type_time[event_type] = statistic_data.event_summary.model_perspective_items[event_type_name].cpu_time\n        gpu_time_range = collections.defaultdict(list)\n        for (device_id, device_time_ranges) in statistic_data.time_range_summary.GPUTimeRange.items():\n            for (event_type, time_range) in device_time_ranges.items():\n                gpu_time_range[event_type] = merge_ranges(gpu_time_range[event_type], time_range, is_sorted=True)\n        for (event_type, time_range) in gpu_time_range.items():\n            gpu_type_time[event_type] = sum_ranges(time_range)\n        if statistic_data.distributed_summary.gpu_communication_range:\n            gpu_type_time[TracerEventType.Communication] = sum_ranges(statistic_data.distributed_summary.gpu_communication_range)\n            gpu_call_times[TracerEventType.Communication] = statistic_data.distributed_summary.gpu_calls\n        sorted_items = sorted(cpu_type_time.items(), key=lambda x: x[1], reverse=True)\n        (event_type, time) = sorted_items[0]\n        row_values = ['{}'.format(str(event_type).split('.')[1]), cpu_call_times[event_type], format_time(time, unit=time_unit), format_ratio(float(time) / total_time)]\n        append(row_format.format(*row_values))\n        for (event_type, time) in sorted_items[1:]:\n            row_values = ['  {}'.format(str(event_type).split('.')[1]), cpu_call_times[event_type], format_time(time, unit=time_unit), format_ratio(float(time) / total_time)]\n            append(row_format.format(*row_values))\n        append(header_sep)\n        headers = ['', 'Calls', 'GPU Time', 'Ratio (%)']\n        append(row_format.format(*headers))\n        append(header_sep)\n        for (event_type, time) in gpu_type_time.items():\n            row_values = ['  {}'.format(str(event_type).split('.')[1]), gpu_call_times[event_type], format_time(time, unit=time_unit), format_ratio(float(time) / total_time)]\n            append(row_format.format(*row_values))\n        append(header_sep)\n        append('Note:\\nIn this table, We sum up all collected events in terms of event type.\\nThe time of events collected on host are presented as CPU Time, and as GPU Time if on device.\\nEvents with different types may overlap or inclusion, e.g. Operator includes OperatorInner, so the sum of ratios is not 100%.\\nThe time of events in the same type with overlap will not calculate twice, and all time is summed after merged.\\nExample:\\nThread 1:\\n  Operator: |___________|     |__________|\\nThread 2:\\n  Operator:   |____________|     |___|\\nAfter merged:\\n  Result:   |______________|  |__________|\\n')\n        append('-' * line_length)\n        append('')\n        append('')\n    if views is None or SummaryView.ModelView in views:\n        model_perspective_items = statistic_data.event_summary.model_perspective_items\n        if len(model_perspective_items) > 1:\n            all_row_values = []\n            accmulation_time = 0\n            gpu_accmulation_time = 0\n            gpu_total_time = statistic_data.event_summary.model_perspective_items['ProfileStep'].gpu_time\n            for name in ['ProfileStep', 'Dataloader', 'Forward', 'Backward', 'Optimization']:\n                if name in model_perspective_items:\n                    item = model_perspective_items[name]\n                    if gpu_total_time == 0:\n                        gpu_ratio = 0\n                    else:\n                        gpu_ratio = float(item.gpu_time) / gpu_total_time\n                    name = f'{name}' if 'ProfileStep' in name else f'  {name}'\n                    row_values = [f'{name}', item.call, '{} / {} / {} / {} / {}'.format(format_time(item.cpu_time, unit=time_unit), format_time(item.avg_cpu_time, unit=time_unit), format_time(item.max_cpu_time, unit=time_unit), format_time(item.min_cpu_time, unit=time_unit), format_ratio(float(item.cpu_time) / total_time)), '{} / {} / {} / {} / {}'.format(format_time(item.gpu_time, unit=time_unit), format_time(item.avg_gpu_time, unit=time_unit), format_time(item.max_gpu_time, unit=time_unit), format_time(item.min_gpu_time, unit=time_unit), format_ratio(gpu_ratio))]\n                    all_row_values.append(row_values)\n                    if 'ProfileStep' not in name:\n                        accmulation_time += item.cpu_time\n                        gpu_accmulation_time += item.gpu_time\n            other_time = total_time - accmulation_time\n            other_gpu_time = gpu_total_time - gpu_accmulation_time\n            if gpu_total_time == 0:\n                gpu_ratio = 0\n            else:\n                gpu_ratio = float(other_gpu_time) / gpu_total_time\n            row_values = ['  Others', '-', '{} / - / - / - / {}'.format(format_time(other_time, unit=time_unit), format_ratio(float(other_time) / total_time)), '{} / - / - / - / {}'.format(format_time(other_gpu_time, unit=time_unit), format_ratio(gpu_ratio))]\n            all_row_values.append(row_values)\n            calltime_width = 6\n            cpu_data_description_width = 40\n            gpu_data_description_width = 40\n            for row_values in all_row_values:\n                if isinstance(row_values[1], int) and len(str(row_values[1])) > calltime_width:\n                    calltime_width = len(str(row_values[1]))\n                if len(row_values[2]) > cpu_data_description_width:\n                    cpu_data_description_width = len(row_values[2])\n                if len(row_values[3]) > gpu_data_description_width:\n                    gpu_data_description_width = len(row_values[3])\n            headers = ['Name', 'Calls', 'CPU Total / Avg / Max / Min / Ratio(%)', 'GPU Total / Avg / Max / Min / Ratio(%)']\n            row_format_list = ['']\n            header_sep_list = ['']\n            line_length_list = [-SPACING_SIZE]\n            name_column_width = 15\n            add_column(name_column_width)\n            add_column(calltime_width)\n            add_column(cpu_data_description_width)\n            add_column(gpu_data_description_width)\n            row_format = row_format_list[0]\n            header_sep = header_sep_list[0]\n            line_length = line_length_list[0]\n            append(add_title(line_length, 'Model Summary'))\n            append(f'Time unit: {time_unit}')\n            append(header_sep)\n            append(row_format.format(*headers))\n            append(header_sep)\n            for row_values in all_row_values:\n                append(row_format.format(*row_values))\n            append(header_sep)\n            append('Note:\\nIn this table, GPU time is the sum of all device(GPU) events called in the phase.\\nUnlike overview summary, if two device(GPU) events execute on different streams with overlap time, we sum them directly here.\\n')\n            append('-' * line_length)\n            append('')\n            append('')\n    if views is None or SummaryView.DistributedView in views:\n        if statistic_data.distributed_summary.communication_range:\n            headers = ['Name', 'Total Time', 'Ratio (%)']\n            row_format_list = ['']\n            header_sep_list = ['']\n            line_length_list = [-SPACING_SIZE]\n            DEFAULT_COLUMN_WIDTH = 25\n            for _ in headers:\n                add_column(DEFAULT_COLUMN_WIDTH)\n            row_format = row_format_list[0]\n            header_sep = header_sep_list[0]\n            line_length = line_length_list[0]\n            append(add_title(line_length, 'Distribution Summary'))\n            append(f'Time unit: {time_unit}')\n            append(header_sep)\n            append(row_format.format(*headers))\n            append(header_sep)\n            communication_time = sum_ranges(statistic_data.distributed_summary.communication_range)\n            computation_time = sum_ranges(statistic_data.distributed_summary.computation_range)\n            overlap_time = sum_ranges(statistic_data.distributed_summary.overlap_range)\n            row_values = ['ProfileStep', format_time(total_time, unit=time_unit), format_ratio(float(total_time) / total_time)]\n            append(row_format.format(*row_values))\n            row_values = ['  Communication', format_time(communication_time, unit=time_unit), format_ratio(float(communication_time) / total_time)]\n            append(row_format.format(*row_values))\n            row_values = ['  Computation', format_time(computation_time, unit=time_unit), format_ratio(float(computation_time) / total_time)]\n            append(row_format.format(*row_values))\n            row_values = ['  Overlap', format_time(overlap_time, unit=time_unit), format_ratio(float(overlap_time) / total_time)]\n            append(row_format.format(*row_values))\n            append(header_sep)\n            append('Note:\\nCommunication time: Communication Event time, Communication Op time and its kernel time on gpu.\\nComputation time: Kernel time, except kernels belong to communication(nccl kernels).\\nOverlap time: Communication time intersects with computation time.\\nExample:\\nCommunication:\\n  CPU:              |_________________|\\n  GPU:                                  |______________|\\n  Total:            |_________________| |______________|\\nComputation time(Kernel):\\n  GPU:         |________________|\\nOverlap time:       |___________|\\n')\n            append('-' * line_length)\n            append('')\n            append('')\n    if views is None or SummaryView.OperatorView in views:\n        if statistic_data.event_summary.items:\n            all_row_values = []\n            name_column_width = 52\n            if thread_sep:\n                thread_items = statistic_data.event_summary.thread_items\n            else:\n                thread_items = {'All threads merged': statistic_data.event_summary.items}\n            for (thread_id, items) in thread_items.items():\n                all_row_values.append(f'Thread: {thread_id}')\n                if sorted_by == SortedKeys.CPUTotal:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].cpu_time, reverse=True)\n                elif sorted_by == SortedKeys.CPUAvg:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].avg_cpu_time, reverse=True)\n                elif sorted_by == SortedKeys.CPUMax:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].max_cpu_time, reverse=True)\n                elif sorted_by == SortedKeys.CPUMin:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].min_cpu_time)\n                elif sorted_by == SortedKeys.GPUTotal:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].general_gpu_time, reverse=True)\n                elif sorted_by == SortedKeys.GPUAvg:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].avg_general_gpu_time, reverse=True)\n                elif sorted_by == SortedKeys.GPUMax:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].max_general_gpu_time, reverse=True)\n                elif sorted_by == SortedKeys.GPUMin:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].min_general_gpu_time)\n                total_op_cpu_time = 0\n                total_op_gpu_time = 0\n                for (name, item) in sorted_items:\n                    total_op_cpu_time += item.cpu_time\n                    total_op_gpu_time += item.general_gpu_time\n                for (name, item) in sorted_items:\n                    if total_op_cpu_time == 0:\n                        cpu_ratio = 0\n                    else:\n                        cpu_ratio = float(item.cpu_time) / total_op_cpu_time\n                    if total_op_gpu_time == 0:\n                        gpu_ratio = 0\n                    else:\n                        gpu_ratio = float(item.general_gpu_time) / total_op_gpu_time\n                    row_values = [name, item.call, '{} / {} / {} / {} / {}'.format(format_time(item.cpu_time, unit=time_unit), format_time(item.avg_cpu_time, unit=time_unit), format_time(item.max_cpu_time, unit=time_unit), format_time(item.min_cpu_time, unit=time_unit), format_ratio(cpu_ratio)), '{} / {} / {} / {} / {}'.format(format_time(item.general_gpu_time, unit=time_unit), format_time(item.avg_general_gpu_time, unit=time_unit), format_time(item.max_general_gpu_time, unit=time_unit), format_time(item.min_general_gpu_time, unit=time_unit), format_ratio(gpu_ratio)), item.flops]\n                    all_row_values.append(row_values)\n                    if op_detail:\n                        for (innerop_name, innerop_node) in item.operator_inners.items():\n                            if item.cpu_time == 0:\n                                cpu_ratio = 0\n                            else:\n                                cpu_ratio = float(innerop_node.cpu_time) / item.cpu_time\n                            if item.general_gpu_time == 0:\n                                gpu_ratio = 0\n                            else:\n                                gpu_ratio = float(innerop_node.general_gpu_time) / item.general_gpu_time\n                            if len(innerop_name) + 2 > name_column_width:\n                                innerop_name = innerop_name[:name_column_width - 5]\n                                innerop_name += '...'\n                            row_values = [f'  {innerop_name}', innerop_node.call, '{} / {} / {} / {} / {}'.format(format_time(innerop_node.cpu_time, unit=time_unit), format_time(innerop_node.avg_cpu_time, unit=time_unit), format_time(innerop_node.max_cpu_time, unit=time_unit), format_time(innerop_node.min_cpu_time, unit=time_unit), format_ratio(cpu_ratio)), '{} / {} / {} / {} / {}'.format(format_time(innerop_node.general_gpu_time, unit=time_unit), format_time(innerop_node.avg_general_gpu_time, unit=time_unit), format_time(innerop_node.max_general_gpu_time, unit=time_unit), format_time(innerop_node.min_general_gpu_time, unit=time_unit), format_ratio(gpu_ratio)), '-']\n                            all_row_values.append(row_values)\n                            for (device_node_name, device_node) in innerop_node.devices.items():\n                                if innerop_node.general_gpu_time == 0:\n                                    gpu_ratio = 0\n                                else:\n                                    gpu_ratio = float(device_node.gpu_time) / innerop_node.general_gpu_time\n                                if len(device_node_name) + 4 > name_column_width:\n                                    device_node_name = device_node_name[:name_column_width - 7]\n                                    device_node_name += '...'\n                                row_values = [f'    {device_node_name}', device_node.call, '- / - / - / - / -', '{} / {} / {} / {} / {}'.format(format_time(device_node.gpu_time, unit=time_unit), format_time(device_node.avg_gpu_time, unit=time_unit), format_time(device_node.max_gpu_time, unit=time_unit), format_time(device_node.min_gpu_time, unit=time_unit), format_ratio(gpu_ratio)), '-']\n                                all_row_values.append(row_values)\n                        for (device_node_name, device_node) in item.devices.items():\n                            if item.general_gpu_time == 0:\n                                gpu_ratio = 0\n                            else:\n                                gpu_ratio = float(device_node.gpu_time) / item.general_gpu_time\n                            if len(device_node_name) + 2 > name_column_width:\n                                device_node_name = device_node_name[:name_column_width - 5]\n                                device_node_name += '...'\n                            row_values = [f'  {device_node_name}', device_node.call, '- / - / - / - / -', '{} / {} / {} / {} / {}'.format(format_time(device_node.gpu_time, unit=time_unit), format_time(device_node.avg_gpu_time, unit=time_unit), format_time(device_node.max_gpu_time, unit=time_unit), format_time(device_node.min_gpu_time, unit=time_unit), format_ratio(gpu_ratio)), '-']\n                            all_row_values.append(row_values)\n            calltime_width = 6\n            cpu_data_description_width = 40\n            gpu_data_description_width = 40\n            flops_width = 10\n            for row_values in all_row_values:\n                if isinstance(row_values, str):\n                    continue\n                if isinstance(row_values[1], int) and len(str(row_values[1])) > calltime_width:\n                    calltime_width = len(str(row_values[1]))\n                if len(row_values[2]) > cpu_data_description_width:\n                    cpu_data_description_width = len(row_values[2])\n                if len(row_values[3]) > gpu_data_description_width:\n                    gpu_data_description_width = len(row_values[3])\n            headers = ['Name', 'Calls', 'CPU Total / Avg / Max / Min / Ratio(%)', 'GPU Total / Avg / Max / Min / Ratio(%)', 'FLOPs']\n            row_format_list = ['']\n            header_sep_list = ['']\n            line_length_list = [-SPACING_SIZE]\n            add_column(name_column_width)\n            add_column(calltime_width)\n            add_column(cpu_data_description_width)\n            add_column(gpu_data_description_width)\n            add_column(flops_width)\n            row_format = row_format_list[0]\n            header_sep = header_sep_list[0]\n            line_length = line_length_list[0]\n            append(add_title(line_length, 'Operator Summary'))\n            append(f'Time unit: {time_unit}')\n            append(header_sep)\n            append(row_format.format(*headers))\n            append(header_sep)\n            for row_values in all_row_values:\n                if isinstance(row_values, str):\n                    append(add_title(line_length, row_values))\n                else:\n                    append(row_format.format(*row_values))\n            append(header_sep)\n            append('')\n            append('')\n    if views is None or SummaryView.KernelView in views:\n        if statistic_data.event_summary.kernel_items:\n            all_row_values = []\n            kernel_items = statistic_data.event_summary.kernel_items\n            if sorted_by == SortedKeys.GPUAvg:\n                sorted_items = sorted(kernel_items.items(), key=lambda x: x[1].avg_gpu_time, reverse=True)\n            elif sorted_by == SortedKeys.GPUMax:\n                sorted_items = sorted(kernel_items.items(), key=lambda x: x[1].max_gpu_time, reverse=True)\n            elif sorted_by == SortedKeys.GPUMin:\n                sorted_items = sorted(kernel_items.items(), key=lambda x: x[1].min_gpu_time)\n            else:\n                sorted_items = sorted(kernel_items.items(), key=lambda x: x[1].gpu_time, reverse=True)\n            total_kernel_gpu_time = 0\n            for (name, item) in sorted_items:\n                total_kernel_gpu_time += item.gpu_time\n            for (name, item) in sorted_items:\n                if total_kernel_gpu_time == 0:\n                    gpu_ratio = 0\n                else:\n                    gpu_ratio = float(item.gpu_time) / total_kernel_gpu_time\n                row_values = [name, item.call, '{} / {} / {} / {} / {}'.format(format_time(item.gpu_time, unit=time_unit), format_time(item.avg_gpu_time, unit=time_unit), format_time(item.max_gpu_time, unit=time_unit), format_time(item.min_gpu_time, unit=time_unit), format_ratio(gpu_ratio))]\n                all_row_values.append(row_values)\n            headers = ['Name', 'Calls', 'GPU Total / Avg / Max / Min / Ratio(%)']\n            name_column_width = 90\n            calltime_width = 6\n            gpu_data_description_width = 40\n            for row_values in all_row_values:\n                if isinstance(row_values[1], int) and len(str(row_values[1])) > calltime_width:\n                    calltime_width = len(str(row_values[1]))\n                if len(row_values[2]) > gpu_data_description_width:\n                    gpu_data_description_width = len(row_values[2])\n            row_format_list = ['']\n            header_sep_list = ['']\n            line_length_list = [-SPACING_SIZE]\n            add_column(name_column_width)\n            add_column(calltime_width)\n            add_column(gpu_data_description_width)\n            row_format = row_format_list[0]\n            header_sep = header_sep_list[0]\n            line_length = line_length_list[0]\n            append(add_title(line_length, 'Kernel Summary'))\n            append(f'Time unit: {time_unit}')\n            append(header_sep)\n            append(row_format.format(*headers))\n            append(header_sep)\n            kernel_name_pattern = re.compile('(.+?)(<.*>)(\\\\(.*\\\\))')\n            for row_values in all_row_values:\n                match = kernel_name_pattern.match(row_values[0])\n                if match:\n                    name = match.group(1) + match.group(2)\n                else:\n                    name = row_values[0]\n                if len(name) > name_column_width:\n                    row_values[0] = name[:name_column_width - 3] + '...'\n                else:\n                    row_values[0] = name\n                append(row_format.format(*row_values))\n            append(header_sep)\n            append('')\n            append('')\n    if views is None or SummaryView.MemoryManipulationView in views:\n        if statistic_data.event_summary.memory_manipulation_items:\n            all_row_values = []\n            memory_manipulation_items = statistic_data.event_summary.memory_manipulation_items\n            gpu_total_time = statistic_data.event_summary.model_perspective_items['ProfileStep'].general_gpu_time\n            for (name, item) in memory_manipulation_items.items():\n                if gpu_total_time == 0:\n                    gpu_ratio = 0\n                else:\n                    gpu_ratio = float(item.general_gpu_time) / gpu_total_time\n                row_values = [name, item.call, '{} / {} / {} / {} / {}'.format(format_time(item.cpu_time, unit=time_unit), format_time(item.avg_cpu_time, unit=time_unit), format_time(item.max_cpu_time, unit=time_unit), format_time(item.min_cpu_time, unit=time_unit), format_ratio(float(item.cpu_time) / total_time)), '{} / {} / {} / {} / {}'.format(format_time(item.general_gpu_time, unit=time_unit), format_time(item.avg_general_gpu_time, unit=time_unit), format_time(item.max_general_gpu_time, unit=time_unit), format_time(item.min_general_gpu_time, unit=time_unit), format_ratio(gpu_ratio))]\n                all_row_values.append(row_values)\n            headers = ['Name', 'Calls', 'CPU Total / Avg / Max / Min / Ratio(%)', 'GPU Total / Avg / Max / Min / Ratio(%)']\n            name_column_width = 0\n            calltime_width = 6\n            cpu_data_description_width = 40\n            gpu_data_description_width = 40\n            for row_values in all_row_values:\n                if len(row_values[0]) > name_column_width:\n                    name_column_width = len(row_values[0])\n                if isinstance(row_values[1], int) and len(str(row_values[1])) > calltime_width:\n                    calltime_width = len(str(row_values[1]))\n                if len(row_values[2]) > cpu_data_description_width:\n                    cpu_data_description_width = len(row_values[2])\n                if len(row_values[3]) > gpu_data_description_width:\n                    gpu_data_description_width = len(row_values[3])\n            row_format_list = ['']\n            header_sep_list = ['']\n            line_length_list = [-SPACING_SIZE]\n            add_column(name_column_width)\n            add_column(calltime_width)\n            add_column(cpu_data_description_width)\n            add_column(gpu_data_description_width)\n            row_format = row_format_list[0]\n            header_sep = header_sep_list[0]\n            line_length = line_length_list[0]\n            append(add_title(line_length, 'Memory Manipulation Summary'))\n            append(f'Time unit: {time_unit}')\n            append(header_sep)\n            append(row_format.format(*headers))\n            append(header_sep)\n            for row_values in all_row_values:\n                append(row_format.format(*row_values))\n            append(header_sep)\n            append('')\n            append('')\n    if views is None or SummaryView.UDFView in views:\n        if statistic_data.event_summary.userdefined_items:\n            all_row_values = []\n            gpu_total_time = statistic_data.event_summary.model_perspective_items['ProfileStep'].general_gpu_time\n            if thread_sep:\n                userdefined_thread_items = statistic_data.event_summary.userdefined_thread_items\n            else:\n                userdefined_thread_items = {'All threads merged': statistic_data.event_summary.userdefined_items}\n            for (thread_id, items) in userdefined_thread_items.items():\n                all_row_values.append(f'Thread: {thread_id}')\n                if sorted_by == SortedKeys.CPUTotal:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].cpu_time, reverse=True)\n                elif sorted_by == SortedKeys.CPUAvg:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].avg_cpu_time, reverse=True)\n                elif sorted_by == SortedKeys.CPUMax:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].max_cpu_time, reverse=True)\n                elif sorted_by == SortedKeys.CPUMin:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].min_cpu_time)\n                elif sorted_by == SortedKeys.GPUTotal:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].general_gpu_time, reverse=True)\n                elif sorted_by == SortedKeys.GPUAvg:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].avg_general_gpu_time, reverse=True)\n                elif sorted_by == SortedKeys.GPUMax:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].max_general_gpu_time, reverse=True)\n                elif sorted_by == SortedKeys.GPUMin:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].min_general_gpu_time)\n                for (name, item) in sorted_items:\n                    if gpu_total_time == 0:\n                        gpu_ratio = 0\n                    else:\n                        gpu_ratio = float(item.general_gpu_time) / gpu_total_time\n                    row_values = [name, item.call, '{} / {} / {} / {} / {}'.format(format_time(item.cpu_time, unit=time_unit), format_time(item.avg_cpu_time, unit=time_unit), format_time(item.max_cpu_time, unit=time_unit), format_time(item.min_cpu_time, unit=time_unit), format_ratio(float(item.cpu_time) / total_time)), '{} / {} / {} / {} / {}'.format(format_time(item.general_gpu_time, unit=time_unit), format_time(item.avg_general_gpu_time, unit=time_unit), format_time(item.max_general_gpu_time, unit=time_unit), format_time(item.min_general_gpu_time, unit=time_unit), format_ratio(gpu_ratio))]\n                    all_row_values.append(row_values)\n            name_column_width = 0\n            calltime_width = 6\n            cpu_data_description_width = 40\n            gpu_data_description_width = 40\n            for row_values in all_row_values:\n                if isinstance(row_values, str):\n                    continue\n                if len(row_values[0]) > name_column_width:\n                    name_column_width = len(row_values[0])\n                if isinstance(row_values[1], int) and len(str(row_values[1])) > calltime_width:\n                    calltime_width = len(str(row_values[1]))\n                if len(row_values[2]) > cpu_data_description_width:\n                    cpu_data_description_width = len(row_values[2])\n                if len(row_values[3]) > gpu_data_description_width:\n                    gpu_data_description_width = len(row_values[3])\n            headers = ['Name', 'Calls', 'CPU Total / Avg / Max / Min / Ratio(%)', 'GPU Total / Avg / Max / Min / Ratio(%)']\n            row_format_list = ['']\n            header_sep_list = ['']\n            line_length_list = [-SPACING_SIZE]\n            add_column(name_column_width)\n            add_column(calltime_width)\n            add_column(cpu_data_description_width)\n            add_column(gpu_data_description_width)\n            row_format = row_format_list[0]\n            header_sep = header_sep_list[0]\n            line_length = line_length_list[0]\n            append(add_title(line_length, 'UserDefined Summary'))\n            append(f'Time unit: {time_unit}')\n            append(header_sep)\n            append(row_format.format(*headers))\n            append(header_sep)\n            for row_values in all_row_values:\n                if isinstance(row_values, str):\n                    append(add_title(line_length, row_values))\n                else:\n                    append(row_format.format(*row_values))\n            append('')\n            append('')\n    if views is None or SummaryView.MemoryView in views:\n        if statistic_data.memory_summary.allocated_items or statistic_data.memory_summary.reserved_items:\n            for (device_type, memory_events) in statistic_data.memory_summary.allocated_items.items():\n                all_row_values = []\n                sorted_items = sorted(memory_events.items(), key=lambda x: x[1].increase_size, reverse=True)\n                for (event_name, item) in sorted_items:\n                    row_values = [event_name, item.memory_type, item.allocation_count, item.free_count, item.allocation_size, item.free_size, item.increase_size]\n                    all_row_values.append(row_values)\n                sorted_reserved_items = sorted(statistic_data.memory_summary.reserved_items[device_type].items(), key=lambda x: x[1].increase_size, reverse=True)\n                for (event_name, item) in sorted_reserved_items:\n                    row_values = [event_name, item.memory_type, item.allocation_count, item.free_count, item.allocation_size, item.free_size, item.increase_size]\n                    all_row_values.append(row_values)\n                headers = ['Name', 'Type', 'Allocation Count', 'Free Count', 'Allocation Size', 'Free Size', 'Increased Size']\n                row_format_list = ['']\n                header_sep_list = ['']\n                line_length_list = [-SPACING_SIZE]\n                name_column_width = 50\n                number_column_width = 15\n                add_column(name_column_width)\n                add_column(12)\n                add_column(number_column_width)\n                add_column(number_column_width)\n                add_column(number_column_width)\n                add_column(number_column_width)\n                add_column(number_column_width)\n                row_format = row_format_list[0]\n                header_sep = header_sep_list[0]\n                line_length = line_length_list[0]\n                append(add_title(line_length, f'Memory Summary - {device_type}'))\n                append('Peak Allocated Memory: {}'.format(statistic_data.memory_summary.peak_allocation_values[device_type]))\n                append('Peak Reserved Memory: {}'.format(statistic_data.memory_summary.peak_reserved_values[device_type]))\n                append(header_sep)\n                append(row_format.format(*headers))\n                append(header_sep)\n                for row_values in all_row_values:\n                    if isinstance(row_values, str):\n                        append(add_title(line_length, row_values))\n                    else:\n                        append(row_format.format(*row_values))\n                append('')\n                append('')\n    return ''.join(result)",
        "mutated": [
            "def _build_table(statistic_data, sorted_by=SortedKeys.CPUTotal, op_detail=True, thread_sep=False, time_unit='ms', row_limit=100, max_src_column_width=75, views=None):\n    if False:\n        i = 10\n    from .profiler import SummaryView\n    'Prints a summary of events.'\n    SPACING_SIZE = 2\n    row_format_list = ['']\n    header_sep_list = ['']\n    line_length_list = [-SPACING_SIZE]\n\n    def add_column(padding, text_dir='<'):\n        row_format_list[0] += '{: ' + text_dir + str(padding) + '}' + ' ' * SPACING_SIZE\n        header_sep_list[0] += '-' * padding + ' ' * SPACING_SIZE\n        line_length_list[0] += padding + SPACING_SIZE\n\n    def add_title(padding, text):\n        left_length = padding - len(text)\n        half = left_length // 2\n        return '-' * half + text + '-' * (left_length - half)\n    result = []\n\n    def append(s):\n        result.append(s)\n        result.append('\\n')\n\n    def format_time(time, unit='ms', indent=0):\n        \"\"\"\n        Transform time in ns to time in unit.\n        \"\"\"\n        if time == float('inf'):\n            return '-'\n        else:\n            result = float(time)\n            if unit == 's':\n                result /= 1000000000.0\n            elif unit == 'ms':\n                result /= 1000000.0\n            elif unit == 'us':\n                result /= 1000.0\n            return '{}{:.2f}'.format(' ' * indent, result)\n\n    def format_ratio(ratio, indent=0):\n        \"\"\"\n        Transform ratio within [0, 1] to percentage presentation.\n        \"\"\"\n        return '{}{:.2f}'.format(' ' * indent, ratio * 100)\n    total_time = statistic_data.time_range_summary.get_cpu_range_sum(TracerEventType.ProfileStep)\n    if views is None or SummaryView.DeviceView in views:\n        headers = ['Device', 'Utilization (%)']\n        name_column_width = 30\n        DEFAULT_COLUMN_WIDTH = 20\n        add_column(name_column_width)\n        for _ in headers[1:]:\n            add_column(DEFAULT_COLUMN_WIDTH)\n        row_format = row_format_list[0]\n        header_sep = header_sep_list[0]\n        line_length = line_length_list[0]\n        append(add_title(line_length, 'Device Summary'))\n        append(header_sep)\n        append(row_format.format(*headers))\n        append(header_sep)\n        row_values = ['CPU(Process)', format_ratio(float(statistic_data.extra_info['Process Cpu Utilization']))]\n        append(row_format.format(*row_values))\n        row_values = ['CPU(System)', format_ratio(float(statistic_data.extra_info['System Cpu Utilization']))]\n        append(row_format.format(*row_values))\n        for gpu_name in statistic_data.time_range_summary.get_gpu_devices():\n            gpu_time = float(statistic_data.time_range_summary.get_gpu_range_sum(gpu_name, TracerEventType.Kernel))\n            utilization = gpu_time / total_time\n            row_values = [f'GPU{gpu_name}', format_ratio(utilization)]\n            append(row_format.format(*row_values))\n        append(header_sep)\n        append('Note:\\nCPU(Process) Utilization = Current process CPU time over all cpu cores / elapsed time, so max utilization can be reached 100% * number of cpu cores.\\nCPU(System) Utilization = All processes CPU time over all cpu cores(busy time) / (busy time + idle time).\\nGPU Utilization = Current process GPU time / elapsed time.')\n        append('-' * line_length)\n        append('')\n        append('')\n        if total_time == 0:\n            return ''.join(result)\n    if views is None or SummaryView.OverView in views:\n        headers = ['Event Type', 'Calls', 'CPU Time', 'Ratio (%)']\n        row_format_list = ['']\n        header_sep_list = ['']\n        line_length_list = [-SPACING_SIZE]\n        DEFAULT_COLUMN_WIDTH = 25\n        for _ in headers:\n            add_column(DEFAULT_COLUMN_WIDTH)\n        row_format = row_format_list[0]\n        header_sep = header_sep_list[0]\n        line_length = line_length_list[0]\n        append(add_title(line_length, 'Overview Summary'))\n        append(f'Time unit: {time_unit}')\n        append(header_sep)\n        append(row_format.format(*headers))\n        append(header_sep)\n        cpu_type_time = collections.defaultdict(int)\n        gpu_type_time = collections.defaultdict(int)\n        cpu_call_times = collections.defaultdict(int)\n        gpu_call_times = collections.defaultdict(int)\n        cpu_call_times.update(statistic_data.time_range_summary.call_times)\n        gpu_call_times.update(statistic_data.time_range_summary.call_times)\n        for (event_type, value) in statistic_data.time_range_summary.CPUTimeRangeSum.items():\n            if event_type != TracerEventType.Communication:\n                cpu_type_time[event_type] = value\n        if statistic_data.distributed_summary.cpu_communication_range:\n            cpu_type_time[TracerEventType.Communication] = sum_ranges(statistic_data.distributed_summary.cpu_communication_range)\n            cpu_call_times[TracerEventType.Communication] = statistic_data.distributed_summary.cpu_calls\n        for event_type in [TracerEventType.Dataloader, TracerEventType.Forward, TracerEventType.Backward, TracerEventType.Optimization]:\n            event_type_name = str(event_type).split('.')[1]\n            if event_type in cpu_call_times and event_type_name in statistic_data.event_summary.model_perspective_items:\n                cpu_call_times[event_type] = statistic_data.event_summary.model_perspective_items[event_type_name].call\n                cpu_type_time[event_type] = statistic_data.event_summary.model_perspective_items[event_type_name].cpu_time\n        gpu_time_range = collections.defaultdict(list)\n        for (device_id, device_time_ranges) in statistic_data.time_range_summary.GPUTimeRange.items():\n            for (event_type, time_range) in device_time_ranges.items():\n                gpu_time_range[event_type] = merge_ranges(gpu_time_range[event_type], time_range, is_sorted=True)\n        for (event_type, time_range) in gpu_time_range.items():\n            gpu_type_time[event_type] = sum_ranges(time_range)\n        if statistic_data.distributed_summary.gpu_communication_range:\n            gpu_type_time[TracerEventType.Communication] = sum_ranges(statistic_data.distributed_summary.gpu_communication_range)\n            gpu_call_times[TracerEventType.Communication] = statistic_data.distributed_summary.gpu_calls\n        sorted_items = sorted(cpu_type_time.items(), key=lambda x: x[1], reverse=True)\n        (event_type, time) = sorted_items[0]\n        row_values = ['{}'.format(str(event_type).split('.')[1]), cpu_call_times[event_type], format_time(time, unit=time_unit), format_ratio(float(time) / total_time)]\n        append(row_format.format(*row_values))\n        for (event_type, time) in sorted_items[1:]:\n            row_values = ['  {}'.format(str(event_type).split('.')[1]), cpu_call_times[event_type], format_time(time, unit=time_unit), format_ratio(float(time) / total_time)]\n            append(row_format.format(*row_values))\n        append(header_sep)\n        headers = ['', 'Calls', 'GPU Time', 'Ratio (%)']\n        append(row_format.format(*headers))\n        append(header_sep)\n        for (event_type, time) in gpu_type_time.items():\n            row_values = ['  {}'.format(str(event_type).split('.')[1]), gpu_call_times[event_type], format_time(time, unit=time_unit), format_ratio(float(time) / total_time)]\n            append(row_format.format(*row_values))\n        append(header_sep)\n        append('Note:\\nIn this table, We sum up all collected events in terms of event type.\\nThe time of events collected on host are presented as CPU Time, and as GPU Time if on device.\\nEvents with different types may overlap or inclusion, e.g. Operator includes OperatorInner, so the sum of ratios is not 100%.\\nThe time of events in the same type with overlap will not calculate twice, and all time is summed after merged.\\nExample:\\nThread 1:\\n  Operator: |___________|     |__________|\\nThread 2:\\n  Operator:   |____________|     |___|\\nAfter merged:\\n  Result:   |______________|  |__________|\\n')\n        append('-' * line_length)\n        append('')\n        append('')\n    if views is None or SummaryView.ModelView in views:\n        model_perspective_items = statistic_data.event_summary.model_perspective_items\n        if len(model_perspective_items) > 1:\n            all_row_values = []\n            accmulation_time = 0\n            gpu_accmulation_time = 0\n            gpu_total_time = statistic_data.event_summary.model_perspective_items['ProfileStep'].gpu_time\n            for name in ['ProfileStep', 'Dataloader', 'Forward', 'Backward', 'Optimization']:\n                if name in model_perspective_items:\n                    item = model_perspective_items[name]\n                    if gpu_total_time == 0:\n                        gpu_ratio = 0\n                    else:\n                        gpu_ratio = float(item.gpu_time) / gpu_total_time\n                    name = f'{name}' if 'ProfileStep' in name else f'  {name}'\n                    row_values = [f'{name}', item.call, '{} / {} / {} / {} / {}'.format(format_time(item.cpu_time, unit=time_unit), format_time(item.avg_cpu_time, unit=time_unit), format_time(item.max_cpu_time, unit=time_unit), format_time(item.min_cpu_time, unit=time_unit), format_ratio(float(item.cpu_time) / total_time)), '{} / {} / {} / {} / {}'.format(format_time(item.gpu_time, unit=time_unit), format_time(item.avg_gpu_time, unit=time_unit), format_time(item.max_gpu_time, unit=time_unit), format_time(item.min_gpu_time, unit=time_unit), format_ratio(gpu_ratio))]\n                    all_row_values.append(row_values)\n                    if 'ProfileStep' not in name:\n                        accmulation_time += item.cpu_time\n                        gpu_accmulation_time += item.gpu_time\n            other_time = total_time - accmulation_time\n            other_gpu_time = gpu_total_time - gpu_accmulation_time\n            if gpu_total_time == 0:\n                gpu_ratio = 0\n            else:\n                gpu_ratio = float(other_gpu_time) / gpu_total_time\n            row_values = ['  Others', '-', '{} / - / - / - / {}'.format(format_time(other_time, unit=time_unit), format_ratio(float(other_time) / total_time)), '{} / - / - / - / {}'.format(format_time(other_gpu_time, unit=time_unit), format_ratio(gpu_ratio))]\n            all_row_values.append(row_values)\n            calltime_width = 6\n            cpu_data_description_width = 40\n            gpu_data_description_width = 40\n            for row_values in all_row_values:\n                if isinstance(row_values[1], int) and len(str(row_values[1])) > calltime_width:\n                    calltime_width = len(str(row_values[1]))\n                if len(row_values[2]) > cpu_data_description_width:\n                    cpu_data_description_width = len(row_values[2])\n                if len(row_values[3]) > gpu_data_description_width:\n                    gpu_data_description_width = len(row_values[3])\n            headers = ['Name', 'Calls', 'CPU Total / Avg / Max / Min / Ratio(%)', 'GPU Total / Avg / Max / Min / Ratio(%)']\n            row_format_list = ['']\n            header_sep_list = ['']\n            line_length_list = [-SPACING_SIZE]\n            name_column_width = 15\n            add_column(name_column_width)\n            add_column(calltime_width)\n            add_column(cpu_data_description_width)\n            add_column(gpu_data_description_width)\n            row_format = row_format_list[0]\n            header_sep = header_sep_list[0]\n            line_length = line_length_list[0]\n            append(add_title(line_length, 'Model Summary'))\n            append(f'Time unit: {time_unit}')\n            append(header_sep)\n            append(row_format.format(*headers))\n            append(header_sep)\n            for row_values in all_row_values:\n                append(row_format.format(*row_values))\n            append(header_sep)\n            append('Note:\\nIn this table, GPU time is the sum of all device(GPU) events called in the phase.\\nUnlike overview summary, if two device(GPU) events execute on different streams with overlap time, we sum them directly here.\\n')\n            append('-' * line_length)\n            append('')\n            append('')\n    if views is None or SummaryView.DistributedView in views:\n        if statistic_data.distributed_summary.communication_range:\n            headers = ['Name', 'Total Time', 'Ratio (%)']\n            row_format_list = ['']\n            header_sep_list = ['']\n            line_length_list = [-SPACING_SIZE]\n            DEFAULT_COLUMN_WIDTH = 25\n            for _ in headers:\n                add_column(DEFAULT_COLUMN_WIDTH)\n            row_format = row_format_list[0]\n            header_sep = header_sep_list[0]\n            line_length = line_length_list[0]\n            append(add_title(line_length, 'Distribution Summary'))\n            append(f'Time unit: {time_unit}')\n            append(header_sep)\n            append(row_format.format(*headers))\n            append(header_sep)\n            communication_time = sum_ranges(statistic_data.distributed_summary.communication_range)\n            computation_time = sum_ranges(statistic_data.distributed_summary.computation_range)\n            overlap_time = sum_ranges(statistic_data.distributed_summary.overlap_range)\n            row_values = ['ProfileStep', format_time(total_time, unit=time_unit), format_ratio(float(total_time) / total_time)]\n            append(row_format.format(*row_values))\n            row_values = ['  Communication', format_time(communication_time, unit=time_unit), format_ratio(float(communication_time) / total_time)]\n            append(row_format.format(*row_values))\n            row_values = ['  Computation', format_time(computation_time, unit=time_unit), format_ratio(float(computation_time) / total_time)]\n            append(row_format.format(*row_values))\n            row_values = ['  Overlap', format_time(overlap_time, unit=time_unit), format_ratio(float(overlap_time) / total_time)]\n            append(row_format.format(*row_values))\n            append(header_sep)\n            append('Note:\\nCommunication time: Communication Event time, Communication Op time and its kernel time on gpu.\\nComputation time: Kernel time, except kernels belong to communication(nccl kernels).\\nOverlap time: Communication time intersects with computation time.\\nExample:\\nCommunication:\\n  CPU:              |_________________|\\n  GPU:                                  |______________|\\n  Total:            |_________________| |______________|\\nComputation time(Kernel):\\n  GPU:         |________________|\\nOverlap time:       |___________|\\n')\n            append('-' * line_length)\n            append('')\n            append('')\n    if views is None or SummaryView.OperatorView in views:\n        if statistic_data.event_summary.items:\n            all_row_values = []\n            name_column_width = 52\n            if thread_sep:\n                thread_items = statistic_data.event_summary.thread_items\n            else:\n                thread_items = {'All threads merged': statistic_data.event_summary.items}\n            for (thread_id, items) in thread_items.items():\n                all_row_values.append(f'Thread: {thread_id}')\n                if sorted_by == SortedKeys.CPUTotal:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].cpu_time, reverse=True)\n                elif sorted_by == SortedKeys.CPUAvg:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].avg_cpu_time, reverse=True)\n                elif sorted_by == SortedKeys.CPUMax:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].max_cpu_time, reverse=True)\n                elif sorted_by == SortedKeys.CPUMin:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].min_cpu_time)\n                elif sorted_by == SortedKeys.GPUTotal:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].general_gpu_time, reverse=True)\n                elif sorted_by == SortedKeys.GPUAvg:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].avg_general_gpu_time, reverse=True)\n                elif sorted_by == SortedKeys.GPUMax:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].max_general_gpu_time, reverse=True)\n                elif sorted_by == SortedKeys.GPUMin:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].min_general_gpu_time)\n                total_op_cpu_time = 0\n                total_op_gpu_time = 0\n                for (name, item) in sorted_items:\n                    total_op_cpu_time += item.cpu_time\n                    total_op_gpu_time += item.general_gpu_time\n                for (name, item) in sorted_items:\n                    if total_op_cpu_time == 0:\n                        cpu_ratio = 0\n                    else:\n                        cpu_ratio = float(item.cpu_time) / total_op_cpu_time\n                    if total_op_gpu_time == 0:\n                        gpu_ratio = 0\n                    else:\n                        gpu_ratio = float(item.general_gpu_time) / total_op_gpu_time\n                    row_values = [name, item.call, '{} / {} / {} / {} / {}'.format(format_time(item.cpu_time, unit=time_unit), format_time(item.avg_cpu_time, unit=time_unit), format_time(item.max_cpu_time, unit=time_unit), format_time(item.min_cpu_time, unit=time_unit), format_ratio(cpu_ratio)), '{} / {} / {} / {} / {}'.format(format_time(item.general_gpu_time, unit=time_unit), format_time(item.avg_general_gpu_time, unit=time_unit), format_time(item.max_general_gpu_time, unit=time_unit), format_time(item.min_general_gpu_time, unit=time_unit), format_ratio(gpu_ratio)), item.flops]\n                    all_row_values.append(row_values)\n                    if op_detail:\n                        for (innerop_name, innerop_node) in item.operator_inners.items():\n                            if item.cpu_time == 0:\n                                cpu_ratio = 0\n                            else:\n                                cpu_ratio = float(innerop_node.cpu_time) / item.cpu_time\n                            if item.general_gpu_time == 0:\n                                gpu_ratio = 0\n                            else:\n                                gpu_ratio = float(innerop_node.general_gpu_time) / item.general_gpu_time\n                            if len(innerop_name) + 2 > name_column_width:\n                                innerop_name = innerop_name[:name_column_width - 5]\n                                innerop_name += '...'\n                            row_values = [f'  {innerop_name}', innerop_node.call, '{} / {} / {} / {} / {}'.format(format_time(innerop_node.cpu_time, unit=time_unit), format_time(innerop_node.avg_cpu_time, unit=time_unit), format_time(innerop_node.max_cpu_time, unit=time_unit), format_time(innerop_node.min_cpu_time, unit=time_unit), format_ratio(cpu_ratio)), '{} / {} / {} / {} / {}'.format(format_time(innerop_node.general_gpu_time, unit=time_unit), format_time(innerop_node.avg_general_gpu_time, unit=time_unit), format_time(innerop_node.max_general_gpu_time, unit=time_unit), format_time(innerop_node.min_general_gpu_time, unit=time_unit), format_ratio(gpu_ratio)), '-']\n                            all_row_values.append(row_values)\n                            for (device_node_name, device_node) in innerop_node.devices.items():\n                                if innerop_node.general_gpu_time == 0:\n                                    gpu_ratio = 0\n                                else:\n                                    gpu_ratio = float(device_node.gpu_time) / innerop_node.general_gpu_time\n                                if len(device_node_name) + 4 > name_column_width:\n                                    device_node_name = device_node_name[:name_column_width - 7]\n                                    device_node_name += '...'\n                                row_values = [f'    {device_node_name}', device_node.call, '- / - / - / - / -', '{} / {} / {} / {} / {}'.format(format_time(device_node.gpu_time, unit=time_unit), format_time(device_node.avg_gpu_time, unit=time_unit), format_time(device_node.max_gpu_time, unit=time_unit), format_time(device_node.min_gpu_time, unit=time_unit), format_ratio(gpu_ratio)), '-']\n                                all_row_values.append(row_values)\n                        for (device_node_name, device_node) in item.devices.items():\n                            if item.general_gpu_time == 0:\n                                gpu_ratio = 0\n                            else:\n                                gpu_ratio = float(device_node.gpu_time) / item.general_gpu_time\n                            if len(device_node_name) + 2 > name_column_width:\n                                device_node_name = device_node_name[:name_column_width - 5]\n                                device_node_name += '...'\n                            row_values = [f'  {device_node_name}', device_node.call, '- / - / - / - / -', '{} / {} / {} / {} / {}'.format(format_time(device_node.gpu_time, unit=time_unit), format_time(device_node.avg_gpu_time, unit=time_unit), format_time(device_node.max_gpu_time, unit=time_unit), format_time(device_node.min_gpu_time, unit=time_unit), format_ratio(gpu_ratio)), '-']\n                            all_row_values.append(row_values)\n            calltime_width = 6\n            cpu_data_description_width = 40\n            gpu_data_description_width = 40\n            flops_width = 10\n            for row_values in all_row_values:\n                if isinstance(row_values, str):\n                    continue\n                if isinstance(row_values[1], int) and len(str(row_values[1])) > calltime_width:\n                    calltime_width = len(str(row_values[1]))\n                if len(row_values[2]) > cpu_data_description_width:\n                    cpu_data_description_width = len(row_values[2])\n                if len(row_values[3]) > gpu_data_description_width:\n                    gpu_data_description_width = len(row_values[3])\n            headers = ['Name', 'Calls', 'CPU Total / Avg / Max / Min / Ratio(%)', 'GPU Total / Avg / Max / Min / Ratio(%)', 'FLOPs']\n            row_format_list = ['']\n            header_sep_list = ['']\n            line_length_list = [-SPACING_SIZE]\n            add_column(name_column_width)\n            add_column(calltime_width)\n            add_column(cpu_data_description_width)\n            add_column(gpu_data_description_width)\n            add_column(flops_width)\n            row_format = row_format_list[0]\n            header_sep = header_sep_list[0]\n            line_length = line_length_list[0]\n            append(add_title(line_length, 'Operator Summary'))\n            append(f'Time unit: {time_unit}')\n            append(header_sep)\n            append(row_format.format(*headers))\n            append(header_sep)\n            for row_values in all_row_values:\n                if isinstance(row_values, str):\n                    append(add_title(line_length, row_values))\n                else:\n                    append(row_format.format(*row_values))\n            append(header_sep)\n            append('')\n            append('')\n    if views is None or SummaryView.KernelView in views:\n        if statistic_data.event_summary.kernel_items:\n            all_row_values = []\n            kernel_items = statistic_data.event_summary.kernel_items\n            if sorted_by == SortedKeys.GPUAvg:\n                sorted_items = sorted(kernel_items.items(), key=lambda x: x[1].avg_gpu_time, reverse=True)\n            elif sorted_by == SortedKeys.GPUMax:\n                sorted_items = sorted(kernel_items.items(), key=lambda x: x[1].max_gpu_time, reverse=True)\n            elif sorted_by == SortedKeys.GPUMin:\n                sorted_items = sorted(kernel_items.items(), key=lambda x: x[1].min_gpu_time)\n            else:\n                sorted_items = sorted(kernel_items.items(), key=lambda x: x[1].gpu_time, reverse=True)\n            total_kernel_gpu_time = 0\n            for (name, item) in sorted_items:\n                total_kernel_gpu_time += item.gpu_time\n            for (name, item) in sorted_items:\n                if total_kernel_gpu_time == 0:\n                    gpu_ratio = 0\n                else:\n                    gpu_ratio = float(item.gpu_time) / total_kernel_gpu_time\n                row_values = [name, item.call, '{} / {} / {} / {} / {}'.format(format_time(item.gpu_time, unit=time_unit), format_time(item.avg_gpu_time, unit=time_unit), format_time(item.max_gpu_time, unit=time_unit), format_time(item.min_gpu_time, unit=time_unit), format_ratio(gpu_ratio))]\n                all_row_values.append(row_values)\n            headers = ['Name', 'Calls', 'GPU Total / Avg / Max / Min / Ratio(%)']\n            name_column_width = 90\n            calltime_width = 6\n            gpu_data_description_width = 40\n            for row_values in all_row_values:\n                if isinstance(row_values[1], int) and len(str(row_values[1])) > calltime_width:\n                    calltime_width = len(str(row_values[1]))\n                if len(row_values[2]) > gpu_data_description_width:\n                    gpu_data_description_width = len(row_values[2])\n            row_format_list = ['']\n            header_sep_list = ['']\n            line_length_list = [-SPACING_SIZE]\n            add_column(name_column_width)\n            add_column(calltime_width)\n            add_column(gpu_data_description_width)\n            row_format = row_format_list[0]\n            header_sep = header_sep_list[0]\n            line_length = line_length_list[0]\n            append(add_title(line_length, 'Kernel Summary'))\n            append(f'Time unit: {time_unit}')\n            append(header_sep)\n            append(row_format.format(*headers))\n            append(header_sep)\n            kernel_name_pattern = re.compile('(.+?)(<.*>)(\\\\(.*\\\\))')\n            for row_values in all_row_values:\n                match = kernel_name_pattern.match(row_values[0])\n                if match:\n                    name = match.group(1) + match.group(2)\n                else:\n                    name = row_values[0]\n                if len(name) > name_column_width:\n                    row_values[0] = name[:name_column_width - 3] + '...'\n                else:\n                    row_values[0] = name\n                append(row_format.format(*row_values))\n            append(header_sep)\n            append('')\n            append('')\n    if views is None or SummaryView.MemoryManipulationView in views:\n        if statistic_data.event_summary.memory_manipulation_items:\n            all_row_values = []\n            memory_manipulation_items = statistic_data.event_summary.memory_manipulation_items\n            gpu_total_time = statistic_data.event_summary.model_perspective_items['ProfileStep'].general_gpu_time\n            for (name, item) in memory_manipulation_items.items():\n                if gpu_total_time == 0:\n                    gpu_ratio = 0\n                else:\n                    gpu_ratio = float(item.general_gpu_time) / gpu_total_time\n                row_values = [name, item.call, '{} / {} / {} / {} / {}'.format(format_time(item.cpu_time, unit=time_unit), format_time(item.avg_cpu_time, unit=time_unit), format_time(item.max_cpu_time, unit=time_unit), format_time(item.min_cpu_time, unit=time_unit), format_ratio(float(item.cpu_time) / total_time)), '{} / {} / {} / {} / {}'.format(format_time(item.general_gpu_time, unit=time_unit), format_time(item.avg_general_gpu_time, unit=time_unit), format_time(item.max_general_gpu_time, unit=time_unit), format_time(item.min_general_gpu_time, unit=time_unit), format_ratio(gpu_ratio))]\n                all_row_values.append(row_values)\n            headers = ['Name', 'Calls', 'CPU Total / Avg / Max / Min / Ratio(%)', 'GPU Total / Avg / Max / Min / Ratio(%)']\n            name_column_width = 0\n            calltime_width = 6\n            cpu_data_description_width = 40\n            gpu_data_description_width = 40\n            for row_values in all_row_values:\n                if len(row_values[0]) > name_column_width:\n                    name_column_width = len(row_values[0])\n                if isinstance(row_values[1], int) and len(str(row_values[1])) > calltime_width:\n                    calltime_width = len(str(row_values[1]))\n                if len(row_values[2]) > cpu_data_description_width:\n                    cpu_data_description_width = len(row_values[2])\n                if len(row_values[3]) > gpu_data_description_width:\n                    gpu_data_description_width = len(row_values[3])\n            row_format_list = ['']\n            header_sep_list = ['']\n            line_length_list = [-SPACING_SIZE]\n            add_column(name_column_width)\n            add_column(calltime_width)\n            add_column(cpu_data_description_width)\n            add_column(gpu_data_description_width)\n            row_format = row_format_list[0]\n            header_sep = header_sep_list[0]\n            line_length = line_length_list[0]\n            append(add_title(line_length, 'Memory Manipulation Summary'))\n            append(f'Time unit: {time_unit}')\n            append(header_sep)\n            append(row_format.format(*headers))\n            append(header_sep)\n            for row_values in all_row_values:\n                append(row_format.format(*row_values))\n            append(header_sep)\n            append('')\n            append('')\n    if views is None or SummaryView.UDFView in views:\n        if statistic_data.event_summary.userdefined_items:\n            all_row_values = []\n            gpu_total_time = statistic_data.event_summary.model_perspective_items['ProfileStep'].general_gpu_time\n            if thread_sep:\n                userdefined_thread_items = statistic_data.event_summary.userdefined_thread_items\n            else:\n                userdefined_thread_items = {'All threads merged': statistic_data.event_summary.userdefined_items}\n            for (thread_id, items) in userdefined_thread_items.items():\n                all_row_values.append(f'Thread: {thread_id}')\n                if sorted_by == SortedKeys.CPUTotal:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].cpu_time, reverse=True)\n                elif sorted_by == SortedKeys.CPUAvg:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].avg_cpu_time, reverse=True)\n                elif sorted_by == SortedKeys.CPUMax:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].max_cpu_time, reverse=True)\n                elif sorted_by == SortedKeys.CPUMin:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].min_cpu_time)\n                elif sorted_by == SortedKeys.GPUTotal:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].general_gpu_time, reverse=True)\n                elif sorted_by == SortedKeys.GPUAvg:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].avg_general_gpu_time, reverse=True)\n                elif sorted_by == SortedKeys.GPUMax:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].max_general_gpu_time, reverse=True)\n                elif sorted_by == SortedKeys.GPUMin:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].min_general_gpu_time)\n                for (name, item) in sorted_items:\n                    if gpu_total_time == 0:\n                        gpu_ratio = 0\n                    else:\n                        gpu_ratio = float(item.general_gpu_time) / gpu_total_time\n                    row_values = [name, item.call, '{} / {} / {} / {} / {}'.format(format_time(item.cpu_time, unit=time_unit), format_time(item.avg_cpu_time, unit=time_unit), format_time(item.max_cpu_time, unit=time_unit), format_time(item.min_cpu_time, unit=time_unit), format_ratio(float(item.cpu_time) / total_time)), '{} / {} / {} / {} / {}'.format(format_time(item.general_gpu_time, unit=time_unit), format_time(item.avg_general_gpu_time, unit=time_unit), format_time(item.max_general_gpu_time, unit=time_unit), format_time(item.min_general_gpu_time, unit=time_unit), format_ratio(gpu_ratio))]\n                    all_row_values.append(row_values)\n            name_column_width = 0\n            calltime_width = 6\n            cpu_data_description_width = 40\n            gpu_data_description_width = 40\n            for row_values in all_row_values:\n                if isinstance(row_values, str):\n                    continue\n                if len(row_values[0]) > name_column_width:\n                    name_column_width = len(row_values[0])\n                if isinstance(row_values[1], int) and len(str(row_values[1])) > calltime_width:\n                    calltime_width = len(str(row_values[1]))\n                if len(row_values[2]) > cpu_data_description_width:\n                    cpu_data_description_width = len(row_values[2])\n                if len(row_values[3]) > gpu_data_description_width:\n                    gpu_data_description_width = len(row_values[3])\n            headers = ['Name', 'Calls', 'CPU Total / Avg / Max / Min / Ratio(%)', 'GPU Total / Avg / Max / Min / Ratio(%)']\n            row_format_list = ['']\n            header_sep_list = ['']\n            line_length_list = [-SPACING_SIZE]\n            add_column(name_column_width)\n            add_column(calltime_width)\n            add_column(cpu_data_description_width)\n            add_column(gpu_data_description_width)\n            row_format = row_format_list[0]\n            header_sep = header_sep_list[0]\n            line_length = line_length_list[0]\n            append(add_title(line_length, 'UserDefined Summary'))\n            append(f'Time unit: {time_unit}')\n            append(header_sep)\n            append(row_format.format(*headers))\n            append(header_sep)\n            for row_values in all_row_values:\n                if isinstance(row_values, str):\n                    append(add_title(line_length, row_values))\n                else:\n                    append(row_format.format(*row_values))\n            append('')\n            append('')\n    if views is None or SummaryView.MemoryView in views:\n        if statistic_data.memory_summary.allocated_items or statistic_data.memory_summary.reserved_items:\n            for (device_type, memory_events) in statistic_data.memory_summary.allocated_items.items():\n                all_row_values = []\n                sorted_items = sorted(memory_events.items(), key=lambda x: x[1].increase_size, reverse=True)\n                for (event_name, item) in sorted_items:\n                    row_values = [event_name, item.memory_type, item.allocation_count, item.free_count, item.allocation_size, item.free_size, item.increase_size]\n                    all_row_values.append(row_values)\n                sorted_reserved_items = sorted(statistic_data.memory_summary.reserved_items[device_type].items(), key=lambda x: x[1].increase_size, reverse=True)\n                for (event_name, item) in sorted_reserved_items:\n                    row_values = [event_name, item.memory_type, item.allocation_count, item.free_count, item.allocation_size, item.free_size, item.increase_size]\n                    all_row_values.append(row_values)\n                headers = ['Name', 'Type', 'Allocation Count', 'Free Count', 'Allocation Size', 'Free Size', 'Increased Size']\n                row_format_list = ['']\n                header_sep_list = ['']\n                line_length_list = [-SPACING_SIZE]\n                name_column_width = 50\n                number_column_width = 15\n                add_column(name_column_width)\n                add_column(12)\n                add_column(number_column_width)\n                add_column(number_column_width)\n                add_column(number_column_width)\n                add_column(number_column_width)\n                add_column(number_column_width)\n                row_format = row_format_list[0]\n                header_sep = header_sep_list[0]\n                line_length = line_length_list[0]\n                append(add_title(line_length, f'Memory Summary - {device_type}'))\n                append('Peak Allocated Memory: {}'.format(statistic_data.memory_summary.peak_allocation_values[device_type]))\n                append('Peak Reserved Memory: {}'.format(statistic_data.memory_summary.peak_reserved_values[device_type]))\n                append(header_sep)\n                append(row_format.format(*headers))\n                append(header_sep)\n                for row_values in all_row_values:\n                    if isinstance(row_values, str):\n                        append(add_title(line_length, row_values))\n                    else:\n                        append(row_format.format(*row_values))\n                append('')\n                append('')\n    return ''.join(result)",
            "def _build_table(statistic_data, sorted_by=SortedKeys.CPUTotal, op_detail=True, thread_sep=False, time_unit='ms', row_limit=100, max_src_column_width=75, views=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    from .profiler import SummaryView\n    'Prints a summary of events.'\n    SPACING_SIZE = 2\n    row_format_list = ['']\n    header_sep_list = ['']\n    line_length_list = [-SPACING_SIZE]\n\n    def add_column(padding, text_dir='<'):\n        row_format_list[0] += '{: ' + text_dir + str(padding) + '}' + ' ' * SPACING_SIZE\n        header_sep_list[0] += '-' * padding + ' ' * SPACING_SIZE\n        line_length_list[0] += padding + SPACING_SIZE\n\n    def add_title(padding, text):\n        left_length = padding - len(text)\n        half = left_length // 2\n        return '-' * half + text + '-' * (left_length - half)\n    result = []\n\n    def append(s):\n        result.append(s)\n        result.append('\\n')\n\n    def format_time(time, unit='ms', indent=0):\n        \"\"\"\n        Transform time in ns to time in unit.\n        \"\"\"\n        if time == float('inf'):\n            return '-'\n        else:\n            result = float(time)\n            if unit == 's':\n                result /= 1000000000.0\n            elif unit == 'ms':\n                result /= 1000000.0\n            elif unit == 'us':\n                result /= 1000.0\n            return '{}{:.2f}'.format(' ' * indent, result)\n\n    def format_ratio(ratio, indent=0):\n        \"\"\"\n        Transform ratio within [0, 1] to percentage presentation.\n        \"\"\"\n        return '{}{:.2f}'.format(' ' * indent, ratio * 100)\n    total_time = statistic_data.time_range_summary.get_cpu_range_sum(TracerEventType.ProfileStep)\n    if views is None or SummaryView.DeviceView in views:\n        headers = ['Device', 'Utilization (%)']\n        name_column_width = 30\n        DEFAULT_COLUMN_WIDTH = 20\n        add_column(name_column_width)\n        for _ in headers[1:]:\n            add_column(DEFAULT_COLUMN_WIDTH)\n        row_format = row_format_list[0]\n        header_sep = header_sep_list[0]\n        line_length = line_length_list[0]\n        append(add_title(line_length, 'Device Summary'))\n        append(header_sep)\n        append(row_format.format(*headers))\n        append(header_sep)\n        row_values = ['CPU(Process)', format_ratio(float(statistic_data.extra_info['Process Cpu Utilization']))]\n        append(row_format.format(*row_values))\n        row_values = ['CPU(System)', format_ratio(float(statistic_data.extra_info['System Cpu Utilization']))]\n        append(row_format.format(*row_values))\n        for gpu_name in statistic_data.time_range_summary.get_gpu_devices():\n            gpu_time = float(statistic_data.time_range_summary.get_gpu_range_sum(gpu_name, TracerEventType.Kernel))\n            utilization = gpu_time / total_time\n            row_values = [f'GPU{gpu_name}', format_ratio(utilization)]\n            append(row_format.format(*row_values))\n        append(header_sep)\n        append('Note:\\nCPU(Process) Utilization = Current process CPU time over all cpu cores / elapsed time, so max utilization can be reached 100% * number of cpu cores.\\nCPU(System) Utilization = All processes CPU time over all cpu cores(busy time) / (busy time + idle time).\\nGPU Utilization = Current process GPU time / elapsed time.')\n        append('-' * line_length)\n        append('')\n        append('')\n        if total_time == 0:\n            return ''.join(result)\n    if views is None or SummaryView.OverView in views:\n        headers = ['Event Type', 'Calls', 'CPU Time', 'Ratio (%)']\n        row_format_list = ['']\n        header_sep_list = ['']\n        line_length_list = [-SPACING_SIZE]\n        DEFAULT_COLUMN_WIDTH = 25\n        for _ in headers:\n            add_column(DEFAULT_COLUMN_WIDTH)\n        row_format = row_format_list[0]\n        header_sep = header_sep_list[0]\n        line_length = line_length_list[0]\n        append(add_title(line_length, 'Overview Summary'))\n        append(f'Time unit: {time_unit}')\n        append(header_sep)\n        append(row_format.format(*headers))\n        append(header_sep)\n        cpu_type_time = collections.defaultdict(int)\n        gpu_type_time = collections.defaultdict(int)\n        cpu_call_times = collections.defaultdict(int)\n        gpu_call_times = collections.defaultdict(int)\n        cpu_call_times.update(statistic_data.time_range_summary.call_times)\n        gpu_call_times.update(statistic_data.time_range_summary.call_times)\n        for (event_type, value) in statistic_data.time_range_summary.CPUTimeRangeSum.items():\n            if event_type != TracerEventType.Communication:\n                cpu_type_time[event_type] = value\n        if statistic_data.distributed_summary.cpu_communication_range:\n            cpu_type_time[TracerEventType.Communication] = sum_ranges(statistic_data.distributed_summary.cpu_communication_range)\n            cpu_call_times[TracerEventType.Communication] = statistic_data.distributed_summary.cpu_calls\n        for event_type in [TracerEventType.Dataloader, TracerEventType.Forward, TracerEventType.Backward, TracerEventType.Optimization]:\n            event_type_name = str(event_type).split('.')[1]\n            if event_type in cpu_call_times and event_type_name in statistic_data.event_summary.model_perspective_items:\n                cpu_call_times[event_type] = statistic_data.event_summary.model_perspective_items[event_type_name].call\n                cpu_type_time[event_type] = statistic_data.event_summary.model_perspective_items[event_type_name].cpu_time\n        gpu_time_range = collections.defaultdict(list)\n        for (device_id, device_time_ranges) in statistic_data.time_range_summary.GPUTimeRange.items():\n            for (event_type, time_range) in device_time_ranges.items():\n                gpu_time_range[event_type] = merge_ranges(gpu_time_range[event_type], time_range, is_sorted=True)\n        for (event_type, time_range) in gpu_time_range.items():\n            gpu_type_time[event_type] = sum_ranges(time_range)\n        if statistic_data.distributed_summary.gpu_communication_range:\n            gpu_type_time[TracerEventType.Communication] = sum_ranges(statistic_data.distributed_summary.gpu_communication_range)\n            gpu_call_times[TracerEventType.Communication] = statistic_data.distributed_summary.gpu_calls\n        sorted_items = sorted(cpu_type_time.items(), key=lambda x: x[1], reverse=True)\n        (event_type, time) = sorted_items[0]\n        row_values = ['{}'.format(str(event_type).split('.')[1]), cpu_call_times[event_type], format_time(time, unit=time_unit), format_ratio(float(time) / total_time)]\n        append(row_format.format(*row_values))\n        for (event_type, time) in sorted_items[1:]:\n            row_values = ['  {}'.format(str(event_type).split('.')[1]), cpu_call_times[event_type], format_time(time, unit=time_unit), format_ratio(float(time) / total_time)]\n            append(row_format.format(*row_values))\n        append(header_sep)\n        headers = ['', 'Calls', 'GPU Time', 'Ratio (%)']\n        append(row_format.format(*headers))\n        append(header_sep)\n        for (event_type, time) in gpu_type_time.items():\n            row_values = ['  {}'.format(str(event_type).split('.')[1]), gpu_call_times[event_type], format_time(time, unit=time_unit), format_ratio(float(time) / total_time)]\n            append(row_format.format(*row_values))\n        append(header_sep)\n        append('Note:\\nIn this table, We sum up all collected events in terms of event type.\\nThe time of events collected on host are presented as CPU Time, and as GPU Time if on device.\\nEvents with different types may overlap or inclusion, e.g. Operator includes OperatorInner, so the sum of ratios is not 100%.\\nThe time of events in the same type with overlap will not calculate twice, and all time is summed after merged.\\nExample:\\nThread 1:\\n  Operator: |___________|     |__________|\\nThread 2:\\n  Operator:   |____________|     |___|\\nAfter merged:\\n  Result:   |______________|  |__________|\\n')\n        append('-' * line_length)\n        append('')\n        append('')\n    if views is None or SummaryView.ModelView in views:\n        model_perspective_items = statistic_data.event_summary.model_perspective_items\n        if len(model_perspective_items) > 1:\n            all_row_values = []\n            accmulation_time = 0\n            gpu_accmulation_time = 0\n            gpu_total_time = statistic_data.event_summary.model_perspective_items['ProfileStep'].gpu_time\n            for name in ['ProfileStep', 'Dataloader', 'Forward', 'Backward', 'Optimization']:\n                if name in model_perspective_items:\n                    item = model_perspective_items[name]\n                    if gpu_total_time == 0:\n                        gpu_ratio = 0\n                    else:\n                        gpu_ratio = float(item.gpu_time) / gpu_total_time\n                    name = f'{name}' if 'ProfileStep' in name else f'  {name}'\n                    row_values = [f'{name}', item.call, '{} / {} / {} / {} / {}'.format(format_time(item.cpu_time, unit=time_unit), format_time(item.avg_cpu_time, unit=time_unit), format_time(item.max_cpu_time, unit=time_unit), format_time(item.min_cpu_time, unit=time_unit), format_ratio(float(item.cpu_time) / total_time)), '{} / {} / {} / {} / {}'.format(format_time(item.gpu_time, unit=time_unit), format_time(item.avg_gpu_time, unit=time_unit), format_time(item.max_gpu_time, unit=time_unit), format_time(item.min_gpu_time, unit=time_unit), format_ratio(gpu_ratio))]\n                    all_row_values.append(row_values)\n                    if 'ProfileStep' not in name:\n                        accmulation_time += item.cpu_time\n                        gpu_accmulation_time += item.gpu_time\n            other_time = total_time - accmulation_time\n            other_gpu_time = gpu_total_time - gpu_accmulation_time\n            if gpu_total_time == 0:\n                gpu_ratio = 0\n            else:\n                gpu_ratio = float(other_gpu_time) / gpu_total_time\n            row_values = ['  Others', '-', '{} / - / - / - / {}'.format(format_time(other_time, unit=time_unit), format_ratio(float(other_time) / total_time)), '{} / - / - / - / {}'.format(format_time(other_gpu_time, unit=time_unit), format_ratio(gpu_ratio))]\n            all_row_values.append(row_values)\n            calltime_width = 6\n            cpu_data_description_width = 40\n            gpu_data_description_width = 40\n            for row_values in all_row_values:\n                if isinstance(row_values[1], int) and len(str(row_values[1])) > calltime_width:\n                    calltime_width = len(str(row_values[1]))\n                if len(row_values[2]) > cpu_data_description_width:\n                    cpu_data_description_width = len(row_values[2])\n                if len(row_values[3]) > gpu_data_description_width:\n                    gpu_data_description_width = len(row_values[3])\n            headers = ['Name', 'Calls', 'CPU Total / Avg / Max / Min / Ratio(%)', 'GPU Total / Avg / Max / Min / Ratio(%)']\n            row_format_list = ['']\n            header_sep_list = ['']\n            line_length_list = [-SPACING_SIZE]\n            name_column_width = 15\n            add_column(name_column_width)\n            add_column(calltime_width)\n            add_column(cpu_data_description_width)\n            add_column(gpu_data_description_width)\n            row_format = row_format_list[0]\n            header_sep = header_sep_list[0]\n            line_length = line_length_list[0]\n            append(add_title(line_length, 'Model Summary'))\n            append(f'Time unit: {time_unit}')\n            append(header_sep)\n            append(row_format.format(*headers))\n            append(header_sep)\n            for row_values in all_row_values:\n                append(row_format.format(*row_values))\n            append(header_sep)\n            append('Note:\\nIn this table, GPU time is the sum of all device(GPU) events called in the phase.\\nUnlike overview summary, if two device(GPU) events execute on different streams with overlap time, we sum them directly here.\\n')\n            append('-' * line_length)\n            append('')\n            append('')\n    if views is None or SummaryView.DistributedView in views:\n        if statistic_data.distributed_summary.communication_range:\n            headers = ['Name', 'Total Time', 'Ratio (%)']\n            row_format_list = ['']\n            header_sep_list = ['']\n            line_length_list = [-SPACING_SIZE]\n            DEFAULT_COLUMN_WIDTH = 25\n            for _ in headers:\n                add_column(DEFAULT_COLUMN_WIDTH)\n            row_format = row_format_list[0]\n            header_sep = header_sep_list[0]\n            line_length = line_length_list[0]\n            append(add_title(line_length, 'Distribution Summary'))\n            append(f'Time unit: {time_unit}')\n            append(header_sep)\n            append(row_format.format(*headers))\n            append(header_sep)\n            communication_time = sum_ranges(statistic_data.distributed_summary.communication_range)\n            computation_time = sum_ranges(statistic_data.distributed_summary.computation_range)\n            overlap_time = sum_ranges(statistic_data.distributed_summary.overlap_range)\n            row_values = ['ProfileStep', format_time(total_time, unit=time_unit), format_ratio(float(total_time) / total_time)]\n            append(row_format.format(*row_values))\n            row_values = ['  Communication', format_time(communication_time, unit=time_unit), format_ratio(float(communication_time) / total_time)]\n            append(row_format.format(*row_values))\n            row_values = ['  Computation', format_time(computation_time, unit=time_unit), format_ratio(float(computation_time) / total_time)]\n            append(row_format.format(*row_values))\n            row_values = ['  Overlap', format_time(overlap_time, unit=time_unit), format_ratio(float(overlap_time) / total_time)]\n            append(row_format.format(*row_values))\n            append(header_sep)\n            append('Note:\\nCommunication time: Communication Event time, Communication Op time and its kernel time on gpu.\\nComputation time: Kernel time, except kernels belong to communication(nccl kernels).\\nOverlap time: Communication time intersects with computation time.\\nExample:\\nCommunication:\\n  CPU:              |_________________|\\n  GPU:                                  |______________|\\n  Total:            |_________________| |______________|\\nComputation time(Kernel):\\n  GPU:         |________________|\\nOverlap time:       |___________|\\n')\n            append('-' * line_length)\n            append('')\n            append('')\n    if views is None or SummaryView.OperatorView in views:\n        if statistic_data.event_summary.items:\n            all_row_values = []\n            name_column_width = 52\n            if thread_sep:\n                thread_items = statistic_data.event_summary.thread_items\n            else:\n                thread_items = {'All threads merged': statistic_data.event_summary.items}\n            for (thread_id, items) in thread_items.items():\n                all_row_values.append(f'Thread: {thread_id}')\n                if sorted_by == SortedKeys.CPUTotal:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].cpu_time, reverse=True)\n                elif sorted_by == SortedKeys.CPUAvg:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].avg_cpu_time, reverse=True)\n                elif sorted_by == SortedKeys.CPUMax:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].max_cpu_time, reverse=True)\n                elif sorted_by == SortedKeys.CPUMin:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].min_cpu_time)\n                elif sorted_by == SortedKeys.GPUTotal:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].general_gpu_time, reverse=True)\n                elif sorted_by == SortedKeys.GPUAvg:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].avg_general_gpu_time, reverse=True)\n                elif sorted_by == SortedKeys.GPUMax:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].max_general_gpu_time, reverse=True)\n                elif sorted_by == SortedKeys.GPUMin:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].min_general_gpu_time)\n                total_op_cpu_time = 0\n                total_op_gpu_time = 0\n                for (name, item) in sorted_items:\n                    total_op_cpu_time += item.cpu_time\n                    total_op_gpu_time += item.general_gpu_time\n                for (name, item) in sorted_items:\n                    if total_op_cpu_time == 0:\n                        cpu_ratio = 0\n                    else:\n                        cpu_ratio = float(item.cpu_time) / total_op_cpu_time\n                    if total_op_gpu_time == 0:\n                        gpu_ratio = 0\n                    else:\n                        gpu_ratio = float(item.general_gpu_time) / total_op_gpu_time\n                    row_values = [name, item.call, '{} / {} / {} / {} / {}'.format(format_time(item.cpu_time, unit=time_unit), format_time(item.avg_cpu_time, unit=time_unit), format_time(item.max_cpu_time, unit=time_unit), format_time(item.min_cpu_time, unit=time_unit), format_ratio(cpu_ratio)), '{} / {} / {} / {} / {}'.format(format_time(item.general_gpu_time, unit=time_unit), format_time(item.avg_general_gpu_time, unit=time_unit), format_time(item.max_general_gpu_time, unit=time_unit), format_time(item.min_general_gpu_time, unit=time_unit), format_ratio(gpu_ratio)), item.flops]\n                    all_row_values.append(row_values)\n                    if op_detail:\n                        for (innerop_name, innerop_node) in item.operator_inners.items():\n                            if item.cpu_time == 0:\n                                cpu_ratio = 0\n                            else:\n                                cpu_ratio = float(innerop_node.cpu_time) / item.cpu_time\n                            if item.general_gpu_time == 0:\n                                gpu_ratio = 0\n                            else:\n                                gpu_ratio = float(innerop_node.general_gpu_time) / item.general_gpu_time\n                            if len(innerop_name) + 2 > name_column_width:\n                                innerop_name = innerop_name[:name_column_width - 5]\n                                innerop_name += '...'\n                            row_values = [f'  {innerop_name}', innerop_node.call, '{} / {} / {} / {} / {}'.format(format_time(innerop_node.cpu_time, unit=time_unit), format_time(innerop_node.avg_cpu_time, unit=time_unit), format_time(innerop_node.max_cpu_time, unit=time_unit), format_time(innerop_node.min_cpu_time, unit=time_unit), format_ratio(cpu_ratio)), '{} / {} / {} / {} / {}'.format(format_time(innerop_node.general_gpu_time, unit=time_unit), format_time(innerop_node.avg_general_gpu_time, unit=time_unit), format_time(innerop_node.max_general_gpu_time, unit=time_unit), format_time(innerop_node.min_general_gpu_time, unit=time_unit), format_ratio(gpu_ratio)), '-']\n                            all_row_values.append(row_values)\n                            for (device_node_name, device_node) in innerop_node.devices.items():\n                                if innerop_node.general_gpu_time == 0:\n                                    gpu_ratio = 0\n                                else:\n                                    gpu_ratio = float(device_node.gpu_time) / innerop_node.general_gpu_time\n                                if len(device_node_name) + 4 > name_column_width:\n                                    device_node_name = device_node_name[:name_column_width - 7]\n                                    device_node_name += '...'\n                                row_values = [f'    {device_node_name}', device_node.call, '- / - / - / - / -', '{} / {} / {} / {} / {}'.format(format_time(device_node.gpu_time, unit=time_unit), format_time(device_node.avg_gpu_time, unit=time_unit), format_time(device_node.max_gpu_time, unit=time_unit), format_time(device_node.min_gpu_time, unit=time_unit), format_ratio(gpu_ratio)), '-']\n                                all_row_values.append(row_values)\n                        for (device_node_name, device_node) in item.devices.items():\n                            if item.general_gpu_time == 0:\n                                gpu_ratio = 0\n                            else:\n                                gpu_ratio = float(device_node.gpu_time) / item.general_gpu_time\n                            if len(device_node_name) + 2 > name_column_width:\n                                device_node_name = device_node_name[:name_column_width - 5]\n                                device_node_name += '...'\n                            row_values = [f'  {device_node_name}', device_node.call, '- / - / - / - / -', '{} / {} / {} / {} / {}'.format(format_time(device_node.gpu_time, unit=time_unit), format_time(device_node.avg_gpu_time, unit=time_unit), format_time(device_node.max_gpu_time, unit=time_unit), format_time(device_node.min_gpu_time, unit=time_unit), format_ratio(gpu_ratio)), '-']\n                            all_row_values.append(row_values)\n            calltime_width = 6\n            cpu_data_description_width = 40\n            gpu_data_description_width = 40\n            flops_width = 10\n            for row_values in all_row_values:\n                if isinstance(row_values, str):\n                    continue\n                if isinstance(row_values[1], int) and len(str(row_values[1])) > calltime_width:\n                    calltime_width = len(str(row_values[1]))\n                if len(row_values[2]) > cpu_data_description_width:\n                    cpu_data_description_width = len(row_values[2])\n                if len(row_values[3]) > gpu_data_description_width:\n                    gpu_data_description_width = len(row_values[3])\n            headers = ['Name', 'Calls', 'CPU Total / Avg / Max / Min / Ratio(%)', 'GPU Total / Avg / Max / Min / Ratio(%)', 'FLOPs']\n            row_format_list = ['']\n            header_sep_list = ['']\n            line_length_list = [-SPACING_SIZE]\n            add_column(name_column_width)\n            add_column(calltime_width)\n            add_column(cpu_data_description_width)\n            add_column(gpu_data_description_width)\n            add_column(flops_width)\n            row_format = row_format_list[0]\n            header_sep = header_sep_list[0]\n            line_length = line_length_list[0]\n            append(add_title(line_length, 'Operator Summary'))\n            append(f'Time unit: {time_unit}')\n            append(header_sep)\n            append(row_format.format(*headers))\n            append(header_sep)\n            for row_values in all_row_values:\n                if isinstance(row_values, str):\n                    append(add_title(line_length, row_values))\n                else:\n                    append(row_format.format(*row_values))\n            append(header_sep)\n            append('')\n            append('')\n    if views is None or SummaryView.KernelView in views:\n        if statistic_data.event_summary.kernel_items:\n            all_row_values = []\n            kernel_items = statistic_data.event_summary.kernel_items\n            if sorted_by == SortedKeys.GPUAvg:\n                sorted_items = sorted(kernel_items.items(), key=lambda x: x[1].avg_gpu_time, reverse=True)\n            elif sorted_by == SortedKeys.GPUMax:\n                sorted_items = sorted(kernel_items.items(), key=lambda x: x[1].max_gpu_time, reverse=True)\n            elif sorted_by == SortedKeys.GPUMin:\n                sorted_items = sorted(kernel_items.items(), key=lambda x: x[1].min_gpu_time)\n            else:\n                sorted_items = sorted(kernel_items.items(), key=lambda x: x[1].gpu_time, reverse=True)\n            total_kernel_gpu_time = 0\n            for (name, item) in sorted_items:\n                total_kernel_gpu_time += item.gpu_time\n            for (name, item) in sorted_items:\n                if total_kernel_gpu_time == 0:\n                    gpu_ratio = 0\n                else:\n                    gpu_ratio = float(item.gpu_time) / total_kernel_gpu_time\n                row_values = [name, item.call, '{} / {} / {} / {} / {}'.format(format_time(item.gpu_time, unit=time_unit), format_time(item.avg_gpu_time, unit=time_unit), format_time(item.max_gpu_time, unit=time_unit), format_time(item.min_gpu_time, unit=time_unit), format_ratio(gpu_ratio))]\n                all_row_values.append(row_values)\n            headers = ['Name', 'Calls', 'GPU Total / Avg / Max / Min / Ratio(%)']\n            name_column_width = 90\n            calltime_width = 6\n            gpu_data_description_width = 40\n            for row_values in all_row_values:\n                if isinstance(row_values[1], int) and len(str(row_values[1])) > calltime_width:\n                    calltime_width = len(str(row_values[1]))\n                if len(row_values[2]) > gpu_data_description_width:\n                    gpu_data_description_width = len(row_values[2])\n            row_format_list = ['']\n            header_sep_list = ['']\n            line_length_list = [-SPACING_SIZE]\n            add_column(name_column_width)\n            add_column(calltime_width)\n            add_column(gpu_data_description_width)\n            row_format = row_format_list[0]\n            header_sep = header_sep_list[0]\n            line_length = line_length_list[0]\n            append(add_title(line_length, 'Kernel Summary'))\n            append(f'Time unit: {time_unit}')\n            append(header_sep)\n            append(row_format.format(*headers))\n            append(header_sep)\n            kernel_name_pattern = re.compile('(.+?)(<.*>)(\\\\(.*\\\\))')\n            for row_values in all_row_values:\n                match = kernel_name_pattern.match(row_values[0])\n                if match:\n                    name = match.group(1) + match.group(2)\n                else:\n                    name = row_values[0]\n                if len(name) > name_column_width:\n                    row_values[0] = name[:name_column_width - 3] + '...'\n                else:\n                    row_values[0] = name\n                append(row_format.format(*row_values))\n            append(header_sep)\n            append('')\n            append('')\n    if views is None or SummaryView.MemoryManipulationView in views:\n        if statistic_data.event_summary.memory_manipulation_items:\n            all_row_values = []\n            memory_manipulation_items = statistic_data.event_summary.memory_manipulation_items\n            gpu_total_time = statistic_data.event_summary.model_perspective_items['ProfileStep'].general_gpu_time\n            for (name, item) in memory_manipulation_items.items():\n                if gpu_total_time == 0:\n                    gpu_ratio = 0\n                else:\n                    gpu_ratio = float(item.general_gpu_time) / gpu_total_time\n                row_values = [name, item.call, '{} / {} / {} / {} / {}'.format(format_time(item.cpu_time, unit=time_unit), format_time(item.avg_cpu_time, unit=time_unit), format_time(item.max_cpu_time, unit=time_unit), format_time(item.min_cpu_time, unit=time_unit), format_ratio(float(item.cpu_time) / total_time)), '{} / {} / {} / {} / {}'.format(format_time(item.general_gpu_time, unit=time_unit), format_time(item.avg_general_gpu_time, unit=time_unit), format_time(item.max_general_gpu_time, unit=time_unit), format_time(item.min_general_gpu_time, unit=time_unit), format_ratio(gpu_ratio))]\n                all_row_values.append(row_values)\n            headers = ['Name', 'Calls', 'CPU Total / Avg / Max / Min / Ratio(%)', 'GPU Total / Avg / Max / Min / Ratio(%)']\n            name_column_width = 0\n            calltime_width = 6\n            cpu_data_description_width = 40\n            gpu_data_description_width = 40\n            for row_values in all_row_values:\n                if len(row_values[0]) > name_column_width:\n                    name_column_width = len(row_values[0])\n                if isinstance(row_values[1], int) and len(str(row_values[1])) > calltime_width:\n                    calltime_width = len(str(row_values[1]))\n                if len(row_values[2]) > cpu_data_description_width:\n                    cpu_data_description_width = len(row_values[2])\n                if len(row_values[3]) > gpu_data_description_width:\n                    gpu_data_description_width = len(row_values[3])\n            row_format_list = ['']\n            header_sep_list = ['']\n            line_length_list = [-SPACING_SIZE]\n            add_column(name_column_width)\n            add_column(calltime_width)\n            add_column(cpu_data_description_width)\n            add_column(gpu_data_description_width)\n            row_format = row_format_list[0]\n            header_sep = header_sep_list[0]\n            line_length = line_length_list[0]\n            append(add_title(line_length, 'Memory Manipulation Summary'))\n            append(f'Time unit: {time_unit}')\n            append(header_sep)\n            append(row_format.format(*headers))\n            append(header_sep)\n            for row_values in all_row_values:\n                append(row_format.format(*row_values))\n            append(header_sep)\n            append('')\n            append('')\n    if views is None or SummaryView.UDFView in views:\n        if statistic_data.event_summary.userdefined_items:\n            all_row_values = []\n            gpu_total_time = statistic_data.event_summary.model_perspective_items['ProfileStep'].general_gpu_time\n            if thread_sep:\n                userdefined_thread_items = statistic_data.event_summary.userdefined_thread_items\n            else:\n                userdefined_thread_items = {'All threads merged': statistic_data.event_summary.userdefined_items}\n            for (thread_id, items) in userdefined_thread_items.items():\n                all_row_values.append(f'Thread: {thread_id}')\n                if sorted_by == SortedKeys.CPUTotal:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].cpu_time, reverse=True)\n                elif sorted_by == SortedKeys.CPUAvg:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].avg_cpu_time, reverse=True)\n                elif sorted_by == SortedKeys.CPUMax:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].max_cpu_time, reverse=True)\n                elif sorted_by == SortedKeys.CPUMin:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].min_cpu_time)\n                elif sorted_by == SortedKeys.GPUTotal:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].general_gpu_time, reverse=True)\n                elif sorted_by == SortedKeys.GPUAvg:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].avg_general_gpu_time, reverse=True)\n                elif sorted_by == SortedKeys.GPUMax:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].max_general_gpu_time, reverse=True)\n                elif sorted_by == SortedKeys.GPUMin:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].min_general_gpu_time)\n                for (name, item) in sorted_items:\n                    if gpu_total_time == 0:\n                        gpu_ratio = 0\n                    else:\n                        gpu_ratio = float(item.general_gpu_time) / gpu_total_time\n                    row_values = [name, item.call, '{} / {} / {} / {} / {}'.format(format_time(item.cpu_time, unit=time_unit), format_time(item.avg_cpu_time, unit=time_unit), format_time(item.max_cpu_time, unit=time_unit), format_time(item.min_cpu_time, unit=time_unit), format_ratio(float(item.cpu_time) / total_time)), '{} / {} / {} / {} / {}'.format(format_time(item.general_gpu_time, unit=time_unit), format_time(item.avg_general_gpu_time, unit=time_unit), format_time(item.max_general_gpu_time, unit=time_unit), format_time(item.min_general_gpu_time, unit=time_unit), format_ratio(gpu_ratio))]\n                    all_row_values.append(row_values)\n            name_column_width = 0\n            calltime_width = 6\n            cpu_data_description_width = 40\n            gpu_data_description_width = 40\n            for row_values in all_row_values:\n                if isinstance(row_values, str):\n                    continue\n                if len(row_values[0]) > name_column_width:\n                    name_column_width = len(row_values[0])\n                if isinstance(row_values[1], int) and len(str(row_values[1])) > calltime_width:\n                    calltime_width = len(str(row_values[1]))\n                if len(row_values[2]) > cpu_data_description_width:\n                    cpu_data_description_width = len(row_values[2])\n                if len(row_values[3]) > gpu_data_description_width:\n                    gpu_data_description_width = len(row_values[3])\n            headers = ['Name', 'Calls', 'CPU Total / Avg / Max / Min / Ratio(%)', 'GPU Total / Avg / Max / Min / Ratio(%)']\n            row_format_list = ['']\n            header_sep_list = ['']\n            line_length_list = [-SPACING_SIZE]\n            add_column(name_column_width)\n            add_column(calltime_width)\n            add_column(cpu_data_description_width)\n            add_column(gpu_data_description_width)\n            row_format = row_format_list[0]\n            header_sep = header_sep_list[0]\n            line_length = line_length_list[0]\n            append(add_title(line_length, 'UserDefined Summary'))\n            append(f'Time unit: {time_unit}')\n            append(header_sep)\n            append(row_format.format(*headers))\n            append(header_sep)\n            for row_values in all_row_values:\n                if isinstance(row_values, str):\n                    append(add_title(line_length, row_values))\n                else:\n                    append(row_format.format(*row_values))\n            append('')\n            append('')\n    if views is None or SummaryView.MemoryView in views:\n        if statistic_data.memory_summary.allocated_items or statistic_data.memory_summary.reserved_items:\n            for (device_type, memory_events) in statistic_data.memory_summary.allocated_items.items():\n                all_row_values = []\n                sorted_items = sorted(memory_events.items(), key=lambda x: x[1].increase_size, reverse=True)\n                for (event_name, item) in sorted_items:\n                    row_values = [event_name, item.memory_type, item.allocation_count, item.free_count, item.allocation_size, item.free_size, item.increase_size]\n                    all_row_values.append(row_values)\n                sorted_reserved_items = sorted(statistic_data.memory_summary.reserved_items[device_type].items(), key=lambda x: x[1].increase_size, reverse=True)\n                for (event_name, item) in sorted_reserved_items:\n                    row_values = [event_name, item.memory_type, item.allocation_count, item.free_count, item.allocation_size, item.free_size, item.increase_size]\n                    all_row_values.append(row_values)\n                headers = ['Name', 'Type', 'Allocation Count', 'Free Count', 'Allocation Size', 'Free Size', 'Increased Size']\n                row_format_list = ['']\n                header_sep_list = ['']\n                line_length_list = [-SPACING_SIZE]\n                name_column_width = 50\n                number_column_width = 15\n                add_column(name_column_width)\n                add_column(12)\n                add_column(number_column_width)\n                add_column(number_column_width)\n                add_column(number_column_width)\n                add_column(number_column_width)\n                add_column(number_column_width)\n                row_format = row_format_list[0]\n                header_sep = header_sep_list[0]\n                line_length = line_length_list[0]\n                append(add_title(line_length, f'Memory Summary - {device_type}'))\n                append('Peak Allocated Memory: {}'.format(statistic_data.memory_summary.peak_allocation_values[device_type]))\n                append('Peak Reserved Memory: {}'.format(statistic_data.memory_summary.peak_reserved_values[device_type]))\n                append(header_sep)\n                append(row_format.format(*headers))\n                append(header_sep)\n                for row_values in all_row_values:\n                    if isinstance(row_values, str):\n                        append(add_title(line_length, row_values))\n                    else:\n                        append(row_format.format(*row_values))\n                append('')\n                append('')\n    return ''.join(result)",
            "def _build_table(statistic_data, sorted_by=SortedKeys.CPUTotal, op_detail=True, thread_sep=False, time_unit='ms', row_limit=100, max_src_column_width=75, views=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    from .profiler import SummaryView\n    'Prints a summary of events.'\n    SPACING_SIZE = 2\n    row_format_list = ['']\n    header_sep_list = ['']\n    line_length_list = [-SPACING_SIZE]\n\n    def add_column(padding, text_dir='<'):\n        row_format_list[0] += '{: ' + text_dir + str(padding) + '}' + ' ' * SPACING_SIZE\n        header_sep_list[0] += '-' * padding + ' ' * SPACING_SIZE\n        line_length_list[0] += padding + SPACING_SIZE\n\n    def add_title(padding, text):\n        left_length = padding - len(text)\n        half = left_length // 2\n        return '-' * half + text + '-' * (left_length - half)\n    result = []\n\n    def append(s):\n        result.append(s)\n        result.append('\\n')\n\n    def format_time(time, unit='ms', indent=0):\n        \"\"\"\n        Transform time in ns to time in unit.\n        \"\"\"\n        if time == float('inf'):\n            return '-'\n        else:\n            result = float(time)\n            if unit == 's':\n                result /= 1000000000.0\n            elif unit == 'ms':\n                result /= 1000000.0\n            elif unit == 'us':\n                result /= 1000.0\n            return '{}{:.2f}'.format(' ' * indent, result)\n\n    def format_ratio(ratio, indent=0):\n        \"\"\"\n        Transform ratio within [0, 1] to percentage presentation.\n        \"\"\"\n        return '{}{:.2f}'.format(' ' * indent, ratio * 100)\n    total_time = statistic_data.time_range_summary.get_cpu_range_sum(TracerEventType.ProfileStep)\n    if views is None or SummaryView.DeviceView in views:\n        headers = ['Device', 'Utilization (%)']\n        name_column_width = 30\n        DEFAULT_COLUMN_WIDTH = 20\n        add_column(name_column_width)\n        for _ in headers[1:]:\n            add_column(DEFAULT_COLUMN_WIDTH)\n        row_format = row_format_list[0]\n        header_sep = header_sep_list[0]\n        line_length = line_length_list[0]\n        append(add_title(line_length, 'Device Summary'))\n        append(header_sep)\n        append(row_format.format(*headers))\n        append(header_sep)\n        row_values = ['CPU(Process)', format_ratio(float(statistic_data.extra_info['Process Cpu Utilization']))]\n        append(row_format.format(*row_values))\n        row_values = ['CPU(System)', format_ratio(float(statistic_data.extra_info['System Cpu Utilization']))]\n        append(row_format.format(*row_values))\n        for gpu_name in statistic_data.time_range_summary.get_gpu_devices():\n            gpu_time = float(statistic_data.time_range_summary.get_gpu_range_sum(gpu_name, TracerEventType.Kernel))\n            utilization = gpu_time / total_time\n            row_values = [f'GPU{gpu_name}', format_ratio(utilization)]\n            append(row_format.format(*row_values))\n        append(header_sep)\n        append('Note:\\nCPU(Process) Utilization = Current process CPU time over all cpu cores / elapsed time, so max utilization can be reached 100% * number of cpu cores.\\nCPU(System) Utilization = All processes CPU time over all cpu cores(busy time) / (busy time + idle time).\\nGPU Utilization = Current process GPU time / elapsed time.')\n        append('-' * line_length)\n        append('')\n        append('')\n        if total_time == 0:\n            return ''.join(result)\n    if views is None or SummaryView.OverView in views:\n        headers = ['Event Type', 'Calls', 'CPU Time', 'Ratio (%)']\n        row_format_list = ['']\n        header_sep_list = ['']\n        line_length_list = [-SPACING_SIZE]\n        DEFAULT_COLUMN_WIDTH = 25\n        for _ in headers:\n            add_column(DEFAULT_COLUMN_WIDTH)\n        row_format = row_format_list[0]\n        header_sep = header_sep_list[0]\n        line_length = line_length_list[0]\n        append(add_title(line_length, 'Overview Summary'))\n        append(f'Time unit: {time_unit}')\n        append(header_sep)\n        append(row_format.format(*headers))\n        append(header_sep)\n        cpu_type_time = collections.defaultdict(int)\n        gpu_type_time = collections.defaultdict(int)\n        cpu_call_times = collections.defaultdict(int)\n        gpu_call_times = collections.defaultdict(int)\n        cpu_call_times.update(statistic_data.time_range_summary.call_times)\n        gpu_call_times.update(statistic_data.time_range_summary.call_times)\n        for (event_type, value) in statistic_data.time_range_summary.CPUTimeRangeSum.items():\n            if event_type != TracerEventType.Communication:\n                cpu_type_time[event_type] = value\n        if statistic_data.distributed_summary.cpu_communication_range:\n            cpu_type_time[TracerEventType.Communication] = sum_ranges(statistic_data.distributed_summary.cpu_communication_range)\n            cpu_call_times[TracerEventType.Communication] = statistic_data.distributed_summary.cpu_calls\n        for event_type in [TracerEventType.Dataloader, TracerEventType.Forward, TracerEventType.Backward, TracerEventType.Optimization]:\n            event_type_name = str(event_type).split('.')[1]\n            if event_type in cpu_call_times and event_type_name in statistic_data.event_summary.model_perspective_items:\n                cpu_call_times[event_type] = statistic_data.event_summary.model_perspective_items[event_type_name].call\n                cpu_type_time[event_type] = statistic_data.event_summary.model_perspective_items[event_type_name].cpu_time\n        gpu_time_range = collections.defaultdict(list)\n        for (device_id, device_time_ranges) in statistic_data.time_range_summary.GPUTimeRange.items():\n            for (event_type, time_range) in device_time_ranges.items():\n                gpu_time_range[event_type] = merge_ranges(gpu_time_range[event_type], time_range, is_sorted=True)\n        for (event_type, time_range) in gpu_time_range.items():\n            gpu_type_time[event_type] = sum_ranges(time_range)\n        if statistic_data.distributed_summary.gpu_communication_range:\n            gpu_type_time[TracerEventType.Communication] = sum_ranges(statistic_data.distributed_summary.gpu_communication_range)\n            gpu_call_times[TracerEventType.Communication] = statistic_data.distributed_summary.gpu_calls\n        sorted_items = sorted(cpu_type_time.items(), key=lambda x: x[1], reverse=True)\n        (event_type, time) = sorted_items[0]\n        row_values = ['{}'.format(str(event_type).split('.')[1]), cpu_call_times[event_type], format_time(time, unit=time_unit), format_ratio(float(time) / total_time)]\n        append(row_format.format(*row_values))\n        for (event_type, time) in sorted_items[1:]:\n            row_values = ['  {}'.format(str(event_type).split('.')[1]), cpu_call_times[event_type], format_time(time, unit=time_unit), format_ratio(float(time) / total_time)]\n            append(row_format.format(*row_values))\n        append(header_sep)\n        headers = ['', 'Calls', 'GPU Time', 'Ratio (%)']\n        append(row_format.format(*headers))\n        append(header_sep)\n        for (event_type, time) in gpu_type_time.items():\n            row_values = ['  {}'.format(str(event_type).split('.')[1]), gpu_call_times[event_type], format_time(time, unit=time_unit), format_ratio(float(time) / total_time)]\n            append(row_format.format(*row_values))\n        append(header_sep)\n        append('Note:\\nIn this table, We sum up all collected events in terms of event type.\\nThe time of events collected on host are presented as CPU Time, and as GPU Time if on device.\\nEvents with different types may overlap or inclusion, e.g. Operator includes OperatorInner, so the sum of ratios is not 100%.\\nThe time of events in the same type with overlap will not calculate twice, and all time is summed after merged.\\nExample:\\nThread 1:\\n  Operator: |___________|     |__________|\\nThread 2:\\n  Operator:   |____________|     |___|\\nAfter merged:\\n  Result:   |______________|  |__________|\\n')\n        append('-' * line_length)\n        append('')\n        append('')\n    if views is None or SummaryView.ModelView in views:\n        model_perspective_items = statistic_data.event_summary.model_perspective_items\n        if len(model_perspective_items) > 1:\n            all_row_values = []\n            accmulation_time = 0\n            gpu_accmulation_time = 0\n            gpu_total_time = statistic_data.event_summary.model_perspective_items['ProfileStep'].gpu_time\n            for name in ['ProfileStep', 'Dataloader', 'Forward', 'Backward', 'Optimization']:\n                if name in model_perspective_items:\n                    item = model_perspective_items[name]\n                    if gpu_total_time == 0:\n                        gpu_ratio = 0\n                    else:\n                        gpu_ratio = float(item.gpu_time) / gpu_total_time\n                    name = f'{name}' if 'ProfileStep' in name else f'  {name}'\n                    row_values = [f'{name}', item.call, '{} / {} / {} / {} / {}'.format(format_time(item.cpu_time, unit=time_unit), format_time(item.avg_cpu_time, unit=time_unit), format_time(item.max_cpu_time, unit=time_unit), format_time(item.min_cpu_time, unit=time_unit), format_ratio(float(item.cpu_time) / total_time)), '{} / {} / {} / {} / {}'.format(format_time(item.gpu_time, unit=time_unit), format_time(item.avg_gpu_time, unit=time_unit), format_time(item.max_gpu_time, unit=time_unit), format_time(item.min_gpu_time, unit=time_unit), format_ratio(gpu_ratio))]\n                    all_row_values.append(row_values)\n                    if 'ProfileStep' not in name:\n                        accmulation_time += item.cpu_time\n                        gpu_accmulation_time += item.gpu_time\n            other_time = total_time - accmulation_time\n            other_gpu_time = gpu_total_time - gpu_accmulation_time\n            if gpu_total_time == 0:\n                gpu_ratio = 0\n            else:\n                gpu_ratio = float(other_gpu_time) / gpu_total_time\n            row_values = ['  Others', '-', '{} / - / - / - / {}'.format(format_time(other_time, unit=time_unit), format_ratio(float(other_time) / total_time)), '{} / - / - / - / {}'.format(format_time(other_gpu_time, unit=time_unit), format_ratio(gpu_ratio))]\n            all_row_values.append(row_values)\n            calltime_width = 6\n            cpu_data_description_width = 40\n            gpu_data_description_width = 40\n            for row_values in all_row_values:\n                if isinstance(row_values[1], int) and len(str(row_values[1])) > calltime_width:\n                    calltime_width = len(str(row_values[1]))\n                if len(row_values[2]) > cpu_data_description_width:\n                    cpu_data_description_width = len(row_values[2])\n                if len(row_values[3]) > gpu_data_description_width:\n                    gpu_data_description_width = len(row_values[3])\n            headers = ['Name', 'Calls', 'CPU Total / Avg / Max / Min / Ratio(%)', 'GPU Total / Avg / Max / Min / Ratio(%)']\n            row_format_list = ['']\n            header_sep_list = ['']\n            line_length_list = [-SPACING_SIZE]\n            name_column_width = 15\n            add_column(name_column_width)\n            add_column(calltime_width)\n            add_column(cpu_data_description_width)\n            add_column(gpu_data_description_width)\n            row_format = row_format_list[0]\n            header_sep = header_sep_list[0]\n            line_length = line_length_list[0]\n            append(add_title(line_length, 'Model Summary'))\n            append(f'Time unit: {time_unit}')\n            append(header_sep)\n            append(row_format.format(*headers))\n            append(header_sep)\n            for row_values in all_row_values:\n                append(row_format.format(*row_values))\n            append(header_sep)\n            append('Note:\\nIn this table, GPU time is the sum of all device(GPU) events called in the phase.\\nUnlike overview summary, if two device(GPU) events execute on different streams with overlap time, we sum them directly here.\\n')\n            append('-' * line_length)\n            append('')\n            append('')\n    if views is None or SummaryView.DistributedView in views:\n        if statistic_data.distributed_summary.communication_range:\n            headers = ['Name', 'Total Time', 'Ratio (%)']\n            row_format_list = ['']\n            header_sep_list = ['']\n            line_length_list = [-SPACING_SIZE]\n            DEFAULT_COLUMN_WIDTH = 25\n            for _ in headers:\n                add_column(DEFAULT_COLUMN_WIDTH)\n            row_format = row_format_list[0]\n            header_sep = header_sep_list[0]\n            line_length = line_length_list[0]\n            append(add_title(line_length, 'Distribution Summary'))\n            append(f'Time unit: {time_unit}')\n            append(header_sep)\n            append(row_format.format(*headers))\n            append(header_sep)\n            communication_time = sum_ranges(statistic_data.distributed_summary.communication_range)\n            computation_time = sum_ranges(statistic_data.distributed_summary.computation_range)\n            overlap_time = sum_ranges(statistic_data.distributed_summary.overlap_range)\n            row_values = ['ProfileStep', format_time(total_time, unit=time_unit), format_ratio(float(total_time) / total_time)]\n            append(row_format.format(*row_values))\n            row_values = ['  Communication', format_time(communication_time, unit=time_unit), format_ratio(float(communication_time) / total_time)]\n            append(row_format.format(*row_values))\n            row_values = ['  Computation', format_time(computation_time, unit=time_unit), format_ratio(float(computation_time) / total_time)]\n            append(row_format.format(*row_values))\n            row_values = ['  Overlap', format_time(overlap_time, unit=time_unit), format_ratio(float(overlap_time) / total_time)]\n            append(row_format.format(*row_values))\n            append(header_sep)\n            append('Note:\\nCommunication time: Communication Event time, Communication Op time and its kernel time on gpu.\\nComputation time: Kernel time, except kernels belong to communication(nccl kernels).\\nOverlap time: Communication time intersects with computation time.\\nExample:\\nCommunication:\\n  CPU:              |_________________|\\n  GPU:                                  |______________|\\n  Total:            |_________________| |______________|\\nComputation time(Kernel):\\n  GPU:         |________________|\\nOverlap time:       |___________|\\n')\n            append('-' * line_length)\n            append('')\n            append('')\n    if views is None or SummaryView.OperatorView in views:\n        if statistic_data.event_summary.items:\n            all_row_values = []\n            name_column_width = 52\n            if thread_sep:\n                thread_items = statistic_data.event_summary.thread_items\n            else:\n                thread_items = {'All threads merged': statistic_data.event_summary.items}\n            for (thread_id, items) in thread_items.items():\n                all_row_values.append(f'Thread: {thread_id}')\n                if sorted_by == SortedKeys.CPUTotal:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].cpu_time, reverse=True)\n                elif sorted_by == SortedKeys.CPUAvg:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].avg_cpu_time, reverse=True)\n                elif sorted_by == SortedKeys.CPUMax:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].max_cpu_time, reverse=True)\n                elif sorted_by == SortedKeys.CPUMin:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].min_cpu_time)\n                elif sorted_by == SortedKeys.GPUTotal:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].general_gpu_time, reverse=True)\n                elif sorted_by == SortedKeys.GPUAvg:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].avg_general_gpu_time, reverse=True)\n                elif sorted_by == SortedKeys.GPUMax:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].max_general_gpu_time, reverse=True)\n                elif sorted_by == SortedKeys.GPUMin:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].min_general_gpu_time)\n                total_op_cpu_time = 0\n                total_op_gpu_time = 0\n                for (name, item) in sorted_items:\n                    total_op_cpu_time += item.cpu_time\n                    total_op_gpu_time += item.general_gpu_time\n                for (name, item) in sorted_items:\n                    if total_op_cpu_time == 0:\n                        cpu_ratio = 0\n                    else:\n                        cpu_ratio = float(item.cpu_time) / total_op_cpu_time\n                    if total_op_gpu_time == 0:\n                        gpu_ratio = 0\n                    else:\n                        gpu_ratio = float(item.general_gpu_time) / total_op_gpu_time\n                    row_values = [name, item.call, '{} / {} / {} / {} / {}'.format(format_time(item.cpu_time, unit=time_unit), format_time(item.avg_cpu_time, unit=time_unit), format_time(item.max_cpu_time, unit=time_unit), format_time(item.min_cpu_time, unit=time_unit), format_ratio(cpu_ratio)), '{} / {} / {} / {} / {}'.format(format_time(item.general_gpu_time, unit=time_unit), format_time(item.avg_general_gpu_time, unit=time_unit), format_time(item.max_general_gpu_time, unit=time_unit), format_time(item.min_general_gpu_time, unit=time_unit), format_ratio(gpu_ratio)), item.flops]\n                    all_row_values.append(row_values)\n                    if op_detail:\n                        for (innerop_name, innerop_node) in item.operator_inners.items():\n                            if item.cpu_time == 0:\n                                cpu_ratio = 0\n                            else:\n                                cpu_ratio = float(innerop_node.cpu_time) / item.cpu_time\n                            if item.general_gpu_time == 0:\n                                gpu_ratio = 0\n                            else:\n                                gpu_ratio = float(innerop_node.general_gpu_time) / item.general_gpu_time\n                            if len(innerop_name) + 2 > name_column_width:\n                                innerop_name = innerop_name[:name_column_width - 5]\n                                innerop_name += '...'\n                            row_values = [f'  {innerop_name}', innerop_node.call, '{} / {} / {} / {} / {}'.format(format_time(innerop_node.cpu_time, unit=time_unit), format_time(innerop_node.avg_cpu_time, unit=time_unit), format_time(innerop_node.max_cpu_time, unit=time_unit), format_time(innerop_node.min_cpu_time, unit=time_unit), format_ratio(cpu_ratio)), '{} / {} / {} / {} / {}'.format(format_time(innerop_node.general_gpu_time, unit=time_unit), format_time(innerop_node.avg_general_gpu_time, unit=time_unit), format_time(innerop_node.max_general_gpu_time, unit=time_unit), format_time(innerop_node.min_general_gpu_time, unit=time_unit), format_ratio(gpu_ratio)), '-']\n                            all_row_values.append(row_values)\n                            for (device_node_name, device_node) in innerop_node.devices.items():\n                                if innerop_node.general_gpu_time == 0:\n                                    gpu_ratio = 0\n                                else:\n                                    gpu_ratio = float(device_node.gpu_time) / innerop_node.general_gpu_time\n                                if len(device_node_name) + 4 > name_column_width:\n                                    device_node_name = device_node_name[:name_column_width - 7]\n                                    device_node_name += '...'\n                                row_values = [f'    {device_node_name}', device_node.call, '- / - / - / - / -', '{} / {} / {} / {} / {}'.format(format_time(device_node.gpu_time, unit=time_unit), format_time(device_node.avg_gpu_time, unit=time_unit), format_time(device_node.max_gpu_time, unit=time_unit), format_time(device_node.min_gpu_time, unit=time_unit), format_ratio(gpu_ratio)), '-']\n                                all_row_values.append(row_values)\n                        for (device_node_name, device_node) in item.devices.items():\n                            if item.general_gpu_time == 0:\n                                gpu_ratio = 0\n                            else:\n                                gpu_ratio = float(device_node.gpu_time) / item.general_gpu_time\n                            if len(device_node_name) + 2 > name_column_width:\n                                device_node_name = device_node_name[:name_column_width - 5]\n                                device_node_name += '...'\n                            row_values = [f'  {device_node_name}', device_node.call, '- / - / - / - / -', '{} / {} / {} / {} / {}'.format(format_time(device_node.gpu_time, unit=time_unit), format_time(device_node.avg_gpu_time, unit=time_unit), format_time(device_node.max_gpu_time, unit=time_unit), format_time(device_node.min_gpu_time, unit=time_unit), format_ratio(gpu_ratio)), '-']\n                            all_row_values.append(row_values)\n            calltime_width = 6\n            cpu_data_description_width = 40\n            gpu_data_description_width = 40\n            flops_width = 10\n            for row_values in all_row_values:\n                if isinstance(row_values, str):\n                    continue\n                if isinstance(row_values[1], int) and len(str(row_values[1])) > calltime_width:\n                    calltime_width = len(str(row_values[1]))\n                if len(row_values[2]) > cpu_data_description_width:\n                    cpu_data_description_width = len(row_values[2])\n                if len(row_values[3]) > gpu_data_description_width:\n                    gpu_data_description_width = len(row_values[3])\n            headers = ['Name', 'Calls', 'CPU Total / Avg / Max / Min / Ratio(%)', 'GPU Total / Avg / Max / Min / Ratio(%)', 'FLOPs']\n            row_format_list = ['']\n            header_sep_list = ['']\n            line_length_list = [-SPACING_SIZE]\n            add_column(name_column_width)\n            add_column(calltime_width)\n            add_column(cpu_data_description_width)\n            add_column(gpu_data_description_width)\n            add_column(flops_width)\n            row_format = row_format_list[0]\n            header_sep = header_sep_list[0]\n            line_length = line_length_list[0]\n            append(add_title(line_length, 'Operator Summary'))\n            append(f'Time unit: {time_unit}')\n            append(header_sep)\n            append(row_format.format(*headers))\n            append(header_sep)\n            for row_values in all_row_values:\n                if isinstance(row_values, str):\n                    append(add_title(line_length, row_values))\n                else:\n                    append(row_format.format(*row_values))\n            append(header_sep)\n            append('')\n            append('')\n    if views is None or SummaryView.KernelView in views:\n        if statistic_data.event_summary.kernel_items:\n            all_row_values = []\n            kernel_items = statistic_data.event_summary.kernel_items\n            if sorted_by == SortedKeys.GPUAvg:\n                sorted_items = sorted(kernel_items.items(), key=lambda x: x[1].avg_gpu_time, reverse=True)\n            elif sorted_by == SortedKeys.GPUMax:\n                sorted_items = sorted(kernel_items.items(), key=lambda x: x[1].max_gpu_time, reverse=True)\n            elif sorted_by == SortedKeys.GPUMin:\n                sorted_items = sorted(kernel_items.items(), key=lambda x: x[1].min_gpu_time)\n            else:\n                sorted_items = sorted(kernel_items.items(), key=lambda x: x[1].gpu_time, reverse=True)\n            total_kernel_gpu_time = 0\n            for (name, item) in sorted_items:\n                total_kernel_gpu_time += item.gpu_time\n            for (name, item) in sorted_items:\n                if total_kernel_gpu_time == 0:\n                    gpu_ratio = 0\n                else:\n                    gpu_ratio = float(item.gpu_time) / total_kernel_gpu_time\n                row_values = [name, item.call, '{} / {} / {} / {} / {}'.format(format_time(item.gpu_time, unit=time_unit), format_time(item.avg_gpu_time, unit=time_unit), format_time(item.max_gpu_time, unit=time_unit), format_time(item.min_gpu_time, unit=time_unit), format_ratio(gpu_ratio))]\n                all_row_values.append(row_values)\n            headers = ['Name', 'Calls', 'GPU Total / Avg / Max / Min / Ratio(%)']\n            name_column_width = 90\n            calltime_width = 6\n            gpu_data_description_width = 40\n            for row_values in all_row_values:\n                if isinstance(row_values[1], int) and len(str(row_values[1])) > calltime_width:\n                    calltime_width = len(str(row_values[1]))\n                if len(row_values[2]) > gpu_data_description_width:\n                    gpu_data_description_width = len(row_values[2])\n            row_format_list = ['']\n            header_sep_list = ['']\n            line_length_list = [-SPACING_SIZE]\n            add_column(name_column_width)\n            add_column(calltime_width)\n            add_column(gpu_data_description_width)\n            row_format = row_format_list[0]\n            header_sep = header_sep_list[0]\n            line_length = line_length_list[0]\n            append(add_title(line_length, 'Kernel Summary'))\n            append(f'Time unit: {time_unit}')\n            append(header_sep)\n            append(row_format.format(*headers))\n            append(header_sep)\n            kernel_name_pattern = re.compile('(.+?)(<.*>)(\\\\(.*\\\\))')\n            for row_values in all_row_values:\n                match = kernel_name_pattern.match(row_values[0])\n                if match:\n                    name = match.group(1) + match.group(2)\n                else:\n                    name = row_values[0]\n                if len(name) > name_column_width:\n                    row_values[0] = name[:name_column_width - 3] + '...'\n                else:\n                    row_values[0] = name\n                append(row_format.format(*row_values))\n            append(header_sep)\n            append('')\n            append('')\n    if views is None or SummaryView.MemoryManipulationView in views:\n        if statistic_data.event_summary.memory_manipulation_items:\n            all_row_values = []\n            memory_manipulation_items = statistic_data.event_summary.memory_manipulation_items\n            gpu_total_time = statistic_data.event_summary.model_perspective_items['ProfileStep'].general_gpu_time\n            for (name, item) in memory_manipulation_items.items():\n                if gpu_total_time == 0:\n                    gpu_ratio = 0\n                else:\n                    gpu_ratio = float(item.general_gpu_time) / gpu_total_time\n                row_values = [name, item.call, '{} / {} / {} / {} / {}'.format(format_time(item.cpu_time, unit=time_unit), format_time(item.avg_cpu_time, unit=time_unit), format_time(item.max_cpu_time, unit=time_unit), format_time(item.min_cpu_time, unit=time_unit), format_ratio(float(item.cpu_time) / total_time)), '{} / {} / {} / {} / {}'.format(format_time(item.general_gpu_time, unit=time_unit), format_time(item.avg_general_gpu_time, unit=time_unit), format_time(item.max_general_gpu_time, unit=time_unit), format_time(item.min_general_gpu_time, unit=time_unit), format_ratio(gpu_ratio))]\n                all_row_values.append(row_values)\n            headers = ['Name', 'Calls', 'CPU Total / Avg / Max / Min / Ratio(%)', 'GPU Total / Avg / Max / Min / Ratio(%)']\n            name_column_width = 0\n            calltime_width = 6\n            cpu_data_description_width = 40\n            gpu_data_description_width = 40\n            for row_values in all_row_values:\n                if len(row_values[0]) > name_column_width:\n                    name_column_width = len(row_values[0])\n                if isinstance(row_values[1], int) and len(str(row_values[1])) > calltime_width:\n                    calltime_width = len(str(row_values[1]))\n                if len(row_values[2]) > cpu_data_description_width:\n                    cpu_data_description_width = len(row_values[2])\n                if len(row_values[3]) > gpu_data_description_width:\n                    gpu_data_description_width = len(row_values[3])\n            row_format_list = ['']\n            header_sep_list = ['']\n            line_length_list = [-SPACING_SIZE]\n            add_column(name_column_width)\n            add_column(calltime_width)\n            add_column(cpu_data_description_width)\n            add_column(gpu_data_description_width)\n            row_format = row_format_list[0]\n            header_sep = header_sep_list[0]\n            line_length = line_length_list[0]\n            append(add_title(line_length, 'Memory Manipulation Summary'))\n            append(f'Time unit: {time_unit}')\n            append(header_sep)\n            append(row_format.format(*headers))\n            append(header_sep)\n            for row_values in all_row_values:\n                append(row_format.format(*row_values))\n            append(header_sep)\n            append('')\n            append('')\n    if views is None or SummaryView.UDFView in views:\n        if statistic_data.event_summary.userdefined_items:\n            all_row_values = []\n            gpu_total_time = statistic_data.event_summary.model_perspective_items['ProfileStep'].general_gpu_time\n            if thread_sep:\n                userdefined_thread_items = statistic_data.event_summary.userdefined_thread_items\n            else:\n                userdefined_thread_items = {'All threads merged': statistic_data.event_summary.userdefined_items}\n            for (thread_id, items) in userdefined_thread_items.items():\n                all_row_values.append(f'Thread: {thread_id}')\n                if sorted_by == SortedKeys.CPUTotal:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].cpu_time, reverse=True)\n                elif sorted_by == SortedKeys.CPUAvg:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].avg_cpu_time, reverse=True)\n                elif sorted_by == SortedKeys.CPUMax:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].max_cpu_time, reverse=True)\n                elif sorted_by == SortedKeys.CPUMin:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].min_cpu_time)\n                elif sorted_by == SortedKeys.GPUTotal:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].general_gpu_time, reverse=True)\n                elif sorted_by == SortedKeys.GPUAvg:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].avg_general_gpu_time, reverse=True)\n                elif sorted_by == SortedKeys.GPUMax:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].max_general_gpu_time, reverse=True)\n                elif sorted_by == SortedKeys.GPUMin:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].min_general_gpu_time)\n                for (name, item) in sorted_items:\n                    if gpu_total_time == 0:\n                        gpu_ratio = 0\n                    else:\n                        gpu_ratio = float(item.general_gpu_time) / gpu_total_time\n                    row_values = [name, item.call, '{} / {} / {} / {} / {}'.format(format_time(item.cpu_time, unit=time_unit), format_time(item.avg_cpu_time, unit=time_unit), format_time(item.max_cpu_time, unit=time_unit), format_time(item.min_cpu_time, unit=time_unit), format_ratio(float(item.cpu_time) / total_time)), '{} / {} / {} / {} / {}'.format(format_time(item.general_gpu_time, unit=time_unit), format_time(item.avg_general_gpu_time, unit=time_unit), format_time(item.max_general_gpu_time, unit=time_unit), format_time(item.min_general_gpu_time, unit=time_unit), format_ratio(gpu_ratio))]\n                    all_row_values.append(row_values)\n            name_column_width = 0\n            calltime_width = 6\n            cpu_data_description_width = 40\n            gpu_data_description_width = 40\n            for row_values in all_row_values:\n                if isinstance(row_values, str):\n                    continue\n                if len(row_values[0]) > name_column_width:\n                    name_column_width = len(row_values[0])\n                if isinstance(row_values[1], int) and len(str(row_values[1])) > calltime_width:\n                    calltime_width = len(str(row_values[1]))\n                if len(row_values[2]) > cpu_data_description_width:\n                    cpu_data_description_width = len(row_values[2])\n                if len(row_values[3]) > gpu_data_description_width:\n                    gpu_data_description_width = len(row_values[3])\n            headers = ['Name', 'Calls', 'CPU Total / Avg / Max / Min / Ratio(%)', 'GPU Total / Avg / Max / Min / Ratio(%)']\n            row_format_list = ['']\n            header_sep_list = ['']\n            line_length_list = [-SPACING_SIZE]\n            add_column(name_column_width)\n            add_column(calltime_width)\n            add_column(cpu_data_description_width)\n            add_column(gpu_data_description_width)\n            row_format = row_format_list[0]\n            header_sep = header_sep_list[0]\n            line_length = line_length_list[0]\n            append(add_title(line_length, 'UserDefined Summary'))\n            append(f'Time unit: {time_unit}')\n            append(header_sep)\n            append(row_format.format(*headers))\n            append(header_sep)\n            for row_values in all_row_values:\n                if isinstance(row_values, str):\n                    append(add_title(line_length, row_values))\n                else:\n                    append(row_format.format(*row_values))\n            append('')\n            append('')\n    if views is None or SummaryView.MemoryView in views:\n        if statistic_data.memory_summary.allocated_items or statistic_data.memory_summary.reserved_items:\n            for (device_type, memory_events) in statistic_data.memory_summary.allocated_items.items():\n                all_row_values = []\n                sorted_items = sorted(memory_events.items(), key=lambda x: x[1].increase_size, reverse=True)\n                for (event_name, item) in sorted_items:\n                    row_values = [event_name, item.memory_type, item.allocation_count, item.free_count, item.allocation_size, item.free_size, item.increase_size]\n                    all_row_values.append(row_values)\n                sorted_reserved_items = sorted(statistic_data.memory_summary.reserved_items[device_type].items(), key=lambda x: x[1].increase_size, reverse=True)\n                for (event_name, item) in sorted_reserved_items:\n                    row_values = [event_name, item.memory_type, item.allocation_count, item.free_count, item.allocation_size, item.free_size, item.increase_size]\n                    all_row_values.append(row_values)\n                headers = ['Name', 'Type', 'Allocation Count', 'Free Count', 'Allocation Size', 'Free Size', 'Increased Size']\n                row_format_list = ['']\n                header_sep_list = ['']\n                line_length_list = [-SPACING_SIZE]\n                name_column_width = 50\n                number_column_width = 15\n                add_column(name_column_width)\n                add_column(12)\n                add_column(number_column_width)\n                add_column(number_column_width)\n                add_column(number_column_width)\n                add_column(number_column_width)\n                add_column(number_column_width)\n                row_format = row_format_list[0]\n                header_sep = header_sep_list[0]\n                line_length = line_length_list[0]\n                append(add_title(line_length, f'Memory Summary - {device_type}'))\n                append('Peak Allocated Memory: {}'.format(statistic_data.memory_summary.peak_allocation_values[device_type]))\n                append('Peak Reserved Memory: {}'.format(statistic_data.memory_summary.peak_reserved_values[device_type]))\n                append(header_sep)\n                append(row_format.format(*headers))\n                append(header_sep)\n                for row_values in all_row_values:\n                    if isinstance(row_values, str):\n                        append(add_title(line_length, row_values))\n                    else:\n                        append(row_format.format(*row_values))\n                append('')\n                append('')\n    return ''.join(result)",
            "def _build_table(statistic_data, sorted_by=SortedKeys.CPUTotal, op_detail=True, thread_sep=False, time_unit='ms', row_limit=100, max_src_column_width=75, views=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    from .profiler import SummaryView\n    'Prints a summary of events.'\n    SPACING_SIZE = 2\n    row_format_list = ['']\n    header_sep_list = ['']\n    line_length_list = [-SPACING_SIZE]\n\n    def add_column(padding, text_dir='<'):\n        row_format_list[0] += '{: ' + text_dir + str(padding) + '}' + ' ' * SPACING_SIZE\n        header_sep_list[0] += '-' * padding + ' ' * SPACING_SIZE\n        line_length_list[0] += padding + SPACING_SIZE\n\n    def add_title(padding, text):\n        left_length = padding - len(text)\n        half = left_length // 2\n        return '-' * half + text + '-' * (left_length - half)\n    result = []\n\n    def append(s):\n        result.append(s)\n        result.append('\\n')\n\n    def format_time(time, unit='ms', indent=0):\n        \"\"\"\n        Transform time in ns to time in unit.\n        \"\"\"\n        if time == float('inf'):\n            return '-'\n        else:\n            result = float(time)\n            if unit == 's':\n                result /= 1000000000.0\n            elif unit == 'ms':\n                result /= 1000000.0\n            elif unit == 'us':\n                result /= 1000.0\n            return '{}{:.2f}'.format(' ' * indent, result)\n\n    def format_ratio(ratio, indent=0):\n        \"\"\"\n        Transform ratio within [0, 1] to percentage presentation.\n        \"\"\"\n        return '{}{:.2f}'.format(' ' * indent, ratio * 100)\n    total_time = statistic_data.time_range_summary.get_cpu_range_sum(TracerEventType.ProfileStep)\n    if views is None or SummaryView.DeviceView in views:\n        headers = ['Device', 'Utilization (%)']\n        name_column_width = 30\n        DEFAULT_COLUMN_WIDTH = 20\n        add_column(name_column_width)\n        for _ in headers[1:]:\n            add_column(DEFAULT_COLUMN_WIDTH)\n        row_format = row_format_list[0]\n        header_sep = header_sep_list[0]\n        line_length = line_length_list[0]\n        append(add_title(line_length, 'Device Summary'))\n        append(header_sep)\n        append(row_format.format(*headers))\n        append(header_sep)\n        row_values = ['CPU(Process)', format_ratio(float(statistic_data.extra_info['Process Cpu Utilization']))]\n        append(row_format.format(*row_values))\n        row_values = ['CPU(System)', format_ratio(float(statistic_data.extra_info['System Cpu Utilization']))]\n        append(row_format.format(*row_values))\n        for gpu_name in statistic_data.time_range_summary.get_gpu_devices():\n            gpu_time = float(statistic_data.time_range_summary.get_gpu_range_sum(gpu_name, TracerEventType.Kernel))\n            utilization = gpu_time / total_time\n            row_values = [f'GPU{gpu_name}', format_ratio(utilization)]\n            append(row_format.format(*row_values))\n        append(header_sep)\n        append('Note:\\nCPU(Process) Utilization = Current process CPU time over all cpu cores / elapsed time, so max utilization can be reached 100% * number of cpu cores.\\nCPU(System) Utilization = All processes CPU time over all cpu cores(busy time) / (busy time + idle time).\\nGPU Utilization = Current process GPU time / elapsed time.')\n        append('-' * line_length)\n        append('')\n        append('')\n        if total_time == 0:\n            return ''.join(result)\n    if views is None or SummaryView.OverView in views:\n        headers = ['Event Type', 'Calls', 'CPU Time', 'Ratio (%)']\n        row_format_list = ['']\n        header_sep_list = ['']\n        line_length_list = [-SPACING_SIZE]\n        DEFAULT_COLUMN_WIDTH = 25\n        for _ in headers:\n            add_column(DEFAULT_COLUMN_WIDTH)\n        row_format = row_format_list[0]\n        header_sep = header_sep_list[0]\n        line_length = line_length_list[0]\n        append(add_title(line_length, 'Overview Summary'))\n        append(f'Time unit: {time_unit}')\n        append(header_sep)\n        append(row_format.format(*headers))\n        append(header_sep)\n        cpu_type_time = collections.defaultdict(int)\n        gpu_type_time = collections.defaultdict(int)\n        cpu_call_times = collections.defaultdict(int)\n        gpu_call_times = collections.defaultdict(int)\n        cpu_call_times.update(statistic_data.time_range_summary.call_times)\n        gpu_call_times.update(statistic_data.time_range_summary.call_times)\n        for (event_type, value) in statistic_data.time_range_summary.CPUTimeRangeSum.items():\n            if event_type != TracerEventType.Communication:\n                cpu_type_time[event_type] = value\n        if statistic_data.distributed_summary.cpu_communication_range:\n            cpu_type_time[TracerEventType.Communication] = sum_ranges(statistic_data.distributed_summary.cpu_communication_range)\n            cpu_call_times[TracerEventType.Communication] = statistic_data.distributed_summary.cpu_calls\n        for event_type in [TracerEventType.Dataloader, TracerEventType.Forward, TracerEventType.Backward, TracerEventType.Optimization]:\n            event_type_name = str(event_type).split('.')[1]\n            if event_type in cpu_call_times and event_type_name in statistic_data.event_summary.model_perspective_items:\n                cpu_call_times[event_type] = statistic_data.event_summary.model_perspective_items[event_type_name].call\n                cpu_type_time[event_type] = statistic_data.event_summary.model_perspective_items[event_type_name].cpu_time\n        gpu_time_range = collections.defaultdict(list)\n        for (device_id, device_time_ranges) in statistic_data.time_range_summary.GPUTimeRange.items():\n            for (event_type, time_range) in device_time_ranges.items():\n                gpu_time_range[event_type] = merge_ranges(gpu_time_range[event_type], time_range, is_sorted=True)\n        for (event_type, time_range) in gpu_time_range.items():\n            gpu_type_time[event_type] = sum_ranges(time_range)\n        if statistic_data.distributed_summary.gpu_communication_range:\n            gpu_type_time[TracerEventType.Communication] = sum_ranges(statistic_data.distributed_summary.gpu_communication_range)\n            gpu_call_times[TracerEventType.Communication] = statistic_data.distributed_summary.gpu_calls\n        sorted_items = sorted(cpu_type_time.items(), key=lambda x: x[1], reverse=True)\n        (event_type, time) = sorted_items[0]\n        row_values = ['{}'.format(str(event_type).split('.')[1]), cpu_call_times[event_type], format_time(time, unit=time_unit), format_ratio(float(time) / total_time)]\n        append(row_format.format(*row_values))\n        for (event_type, time) in sorted_items[1:]:\n            row_values = ['  {}'.format(str(event_type).split('.')[1]), cpu_call_times[event_type], format_time(time, unit=time_unit), format_ratio(float(time) / total_time)]\n            append(row_format.format(*row_values))\n        append(header_sep)\n        headers = ['', 'Calls', 'GPU Time', 'Ratio (%)']\n        append(row_format.format(*headers))\n        append(header_sep)\n        for (event_type, time) in gpu_type_time.items():\n            row_values = ['  {}'.format(str(event_type).split('.')[1]), gpu_call_times[event_type], format_time(time, unit=time_unit), format_ratio(float(time) / total_time)]\n            append(row_format.format(*row_values))\n        append(header_sep)\n        append('Note:\\nIn this table, We sum up all collected events in terms of event type.\\nThe time of events collected on host are presented as CPU Time, and as GPU Time if on device.\\nEvents with different types may overlap or inclusion, e.g. Operator includes OperatorInner, so the sum of ratios is not 100%.\\nThe time of events in the same type with overlap will not calculate twice, and all time is summed after merged.\\nExample:\\nThread 1:\\n  Operator: |___________|     |__________|\\nThread 2:\\n  Operator:   |____________|     |___|\\nAfter merged:\\n  Result:   |______________|  |__________|\\n')\n        append('-' * line_length)\n        append('')\n        append('')\n    if views is None or SummaryView.ModelView in views:\n        model_perspective_items = statistic_data.event_summary.model_perspective_items\n        if len(model_perspective_items) > 1:\n            all_row_values = []\n            accmulation_time = 0\n            gpu_accmulation_time = 0\n            gpu_total_time = statistic_data.event_summary.model_perspective_items['ProfileStep'].gpu_time\n            for name in ['ProfileStep', 'Dataloader', 'Forward', 'Backward', 'Optimization']:\n                if name in model_perspective_items:\n                    item = model_perspective_items[name]\n                    if gpu_total_time == 0:\n                        gpu_ratio = 0\n                    else:\n                        gpu_ratio = float(item.gpu_time) / gpu_total_time\n                    name = f'{name}' if 'ProfileStep' in name else f'  {name}'\n                    row_values = [f'{name}', item.call, '{} / {} / {} / {} / {}'.format(format_time(item.cpu_time, unit=time_unit), format_time(item.avg_cpu_time, unit=time_unit), format_time(item.max_cpu_time, unit=time_unit), format_time(item.min_cpu_time, unit=time_unit), format_ratio(float(item.cpu_time) / total_time)), '{} / {} / {} / {} / {}'.format(format_time(item.gpu_time, unit=time_unit), format_time(item.avg_gpu_time, unit=time_unit), format_time(item.max_gpu_time, unit=time_unit), format_time(item.min_gpu_time, unit=time_unit), format_ratio(gpu_ratio))]\n                    all_row_values.append(row_values)\n                    if 'ProfileStep' not in name:\n                        accmulation_time += item.cpu_time\n                        gpu_accmulation_time += item.gpu_time\n            other_time = total_time - accmulation_time\n            other_gpu_time = gpu_total_time - gpu_accmulation_time\n            if gpu_total_time == 0:\n                gpu_ratio = 0\n            else:\n                gpu_ratio = float(other_gpu_time) / gpu_total_time\n            row_values = ['  Others', '-', '{} / - / - / - / {}'.format(format_time(other_time, unit=time_unit), format_ratio(float(other_time) / total_time)), '{} / - / - / - / {}'.format(format_time(other_gpu_time, unit=time_unit), format_ratio(gpu_ratio))]\n            all_row_values.append(row_values)\n            calltime_width = 6\n            cpu_data_description_width = 40\n            gpu_data_description_width = 40\n            for row_values in all_row_values:\n                if isinstance(row_values[1], int) and len(str(row_values[1])) > calltime_width:\n                    calltime_width = len(str(row_values[1]))\n                if len(row_values[2]) > cpu_data_description_width:\n                    cpu_data_description_width = len(row_values[2])\n                if len(row_values[3]) > gpu_data_description_width:\n                    gpu_data_description_width = len(row_values[3])\n            headers = ['Name', 'Calls', 'CPU Total / Avg / Max / Min / Ratio(%)', 'GPU Total / Avg / Max / Min / Ratio(%)']\n            row_format_list = ['']\n            header_sep_list = ['']\n            line_length_list = [-SPACING_SIZE]\n            name_column_width = 15\n            add_column(name_column_width)\n            add_column(calltime_width)\n            add_column(cpu_data_description_width)\n            add_column(gpu_data_description_width)\n            row_format = row_format_list[0]\n            header_sep = header_sep_list[0]\n            line_length = line_length_list[0]\n            append(add_title(line_length, 'Model Summary'))\n            append(f'Time unit: {time_unit}')\n            append(header_sep)\n            append(row_format.format(*headers))\n            append(header_sep)\n            for row_values in all_row_values:\n                append(row_format.format(*row_values))\n            append(header_sep)\n            append('Note:\\nIn this table, GPU time is the sum of all device(GPU) events called in the phase.\\nUnlike overview summary, if two device(GPU) events execute on different streams with overlap time, we sum them directly here.\\n')\n            append('-' * line_length)\n            append('')\n            append('')\n    if views is None or SummaryView.DistributedView in views:\n        if statistic_data.distributed_summary.communication_range:\n            headers = ['Name', 'Total Time', 'Ratio (%)']\n            row_format_list = ['']\n            header_sep_list = ['']\n            line_length_list = [-SPACING_SIZE]\n            DEFAULT_COLUMN_WIDTH = 25\n            for _ in headers:\n                add_column(DEFAULT_COLUMN_WIDTH)\n            row_format = row_format_list[0]\n            header_sep = header_sep_list[0]\n            line_length = line_length_list[0]\n            append(add_title(line_length, 'Distribution Summary'))\n            append(f'Time unit: {time_unit}')\n            append(header_sep)\n            append(row_format.format(*headers))\n            append(header_sep)\n            communication_time = sum_ranges(statistic_data.distributed_summary.communication_range)\n            computation_time = sum_ranges(statistic_data.distributed_summary.computation_range)\n            overlap_time = sum_ranges(statistic_data.distributed_summary.overlap_range)\n            row_values = ['ProfileStep', format_time(total_time, unit=time_unit), format_ratio(float(total_time) / total_time)]\n            append(row_format.format(*row_values))\n            row_values = ['  Communication', format_time(communication_time, unit=time_unit), format_ratio(float(communication_time) / total_time)]\n            append(row_format.format(*row_values))\n            row_values = ['  Computation', format_time(computation_time, unit=time_unit), format_ratio(float(computation_time) / total_time)]\n            append(row_format.format(*row_values))\n            row_values = ['  Overlap', format_time(overlap_time, unit=time_unit), format_ratio(float(overlap_time) / total_time)]\n            append(row_format.format(*row_values))\n            append(header_sep)\n            append('Note:\\nCommunication time: Communication Event time, Communication Op time and its kernel time on gpu.\\nComputation time: Kernel time, except kernels belong to communication(nccl kernels).\\nOverlap time: Communication time intersects with computation time.\\nExample:\\nCommunication:\\n  CPU:              |_________________|\\n  GPU:                                  |______________|\\n  Total:            |_________________| |______________|\\nComputation time(Kernel):\\n  GPU:         |________________|\\nOverlap time:       |___________|\\n')\n            append('-' * line_length)\n            append('')\n            append('')\n    if views is None or SummaryView.OperatorView in views:\n        if statistic_data.event_summary.items:\n            all_row_values = []\n            name_column_width = 52\n            if thread_sep:\n                thread_items = statistic_data.event_summary.thread_items\n            else:\n                thread_items = {'All threads merged': statistic_data.event_summary.items}\n            for (thread_id, items) in thread_items.items():\n                all_row_values.append(f'Thread: {thread_id}')\n                if sorted_by == SortedKeys.CPUTotal:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].cpu_time, reverse=True)\n                elif sorted_by == SortedKeys.CPUAvg:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].avg_cpu_time, reverse=True)\n                elif sorted_by == SortedKeys.CPUMax:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].max_cpu_time, reverse=True)\n                elif sorted_by == SortedKeys.CPUMin:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].min_cpu_time)\n                elif sorted_by == SortedKeys.GPUTotal:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].general_gpu_time, reverse=True)\n                elif sorted_by == SortedKeys.GPUAvg:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].avg_general_gpu_time, reverse=True)\n                elif sorted_by == SortedKeys.GPUMax:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].max_general_gpu_time, reverse=True)\n                elif sorted_by == SortedKeys.GPUMin:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].min_general_gpu_time)\n                total_op_cpu_time = 0\n                total_op_gpu_time = 0\n                for (name, item) in sorted_items:\n                    total_op_cpu_time += item.cpu_time\n                    total_op_gpu_time += item.general_gpu_time\n                for (name, item) in sorted_items:\n                    if total_op_cpu_time == 0:\n                        cpu_ratio = 0\n                    else:\n                        cpu_ratio = float(item.cpu_time) / total_op_cpu_time\n                    if total_op_gpu_time == 0:\n                        gpu_ratio = 0\n                    else:\n                        gpu_ratio = float(item.general_gpu_time) / total_op_gpu_time\n                    row_values = [name, item.call, '{} / {} / {} / {} / {}'.format(format_time(item.cpu_time, unit=time_unit), format_time(item.avg_cpu_time, unit=time_unit), format_time(item.max_cpu_time, unit=time_unit), format_time(item.min_cpu_time, unit=time_unit), format_ratio(cpu_ratio)), '{} / {} / {} / {} / {}'.format(format_time(item.general_gpu_time, unit=time_unit), format_time(item.avg_general_gpu_time, unit=time_unit), format_time(item.max_general_gpu_time, unit=time_unit), format_time(item.min_general_gpu_time, unit=time_unit), format_ratio(gpu_ratio)), item.flops]\n                    all_row_values.append(row_values)\n                    if op_detail:\n                        for (innerop_name, innerop_node) in item.operator_inners.items():\n                            if item.cpu_time == 0:\n                                cpu_ratio = 0\n                            else:\n                                cpu_ratio = float(innerop_node.cpu_time) / item.cpu_time\n                            if item.general_gpu_time == 0:\n                                gpu_ratio = 0\n                            else:\n                                gpu_ratio = float(innerop_node.general_gpu_time) / item.general_gpu_time\n                            if len(innerop_name) + 2 > name_column_width:\n                                innerop_name = innerop_name[:name_column_width - 5]\n                                innerop_name += '...'\n                            row_values = [f'  {innerop_name}', innerop_node.call, '{} / {} / {} / {} / {}'.format(format_time(innerop_node.cpu_time, unit=time_unit), format_time(innerop_node.avg_cpu_time, unit=time_unit), format_time(innerop_node.max_cpu_time, unit=time_unit), format_time(innerop_node.min_cpu_time, unit=time_unit), format_ratio(cpu_ratio)), '{} / {} / {} / {} / {}'.format(format_time(innerop_node.general_gpu_time, unit=time_unit), format_time(innerop_node.avg_general_gpu_time, unit=time_unit), format_time(innerop_node.max_general_gpu_time, unit=time_unit), format_time(innerop_node.min_general_gpu_time, unit=time_unit), format_ratio(gpu_ratio)), '-']\n                            all_row_values.append(row_values)\n                            for (device_node_name, device_node) in innerop_node.devices.items():\n                                if innerop_node.general_gpu_time == 0:\n                                    gpu_ratio = 0\n                                else:\n                                    gpu_ratio = float(device_node.gpu_time) / innerop_node.general_gpu_time\n                                if len(device_node_name) + 4 > name_column_width:\n                                    device_node_name = device_node_name[:name_column_width - 7]\n                                    device_node_name += '...'\n                                row_values = [f'    {device_node_name}', device_node.call, '- / - / - / - / -', '{} / {} / {} / {} / {}'.format(format_time(device_node.gpu_time, unit=time_unit), format_time(device_node.avg_gpu_time, unit=time_unit), format_time(device_node.max_gpu_time, unit=time_unit), format_time(device_node.min_gpu_time, unit=time_unit), format_ratio(gpu_ratio)), '-']\n                                all_row_values.append(row_values)\n                        for (device_node_name, device_node) in item.devices.items():\n                            if item.general_gpu_time == 0:\n                                gpu_ratio = 0\n                            else:\n                                gpu_ratio = float(device_node.gpu_time) / item.general_gpu_time\n                            if len(device_node_name) + 2 > name_column_width:\n                                device_node_name = device_node_name[:name_column_width - 5]\n                                device_node_name += '...'\n                            row_values = [f'  {device_node_name}', device_node.call, '- / - / - / - / -', '{} / {} / {} / {} / {}'.format(format_time(device_node.gpu_time, unit=time_unit), format_time(device_node.avg_gpu_time, unit=time_unit), format_time(device_node.max_gpu_time, unit=time_unit), format_time(device_node.min_gpu_time, unit=time_unit), format_ratio(gpu_ratio)), '-']\n                            all_row_values.append(row_values)\n            calltime_width = 6\n            cpu_data_description_width = 40\n            gpu_data_description_width = 40\n            flops_width = 10\n            for row_values in all_row_values:\n                if isinstance(row_values, str):\n                    continue\n                if isinstance(row_values[1], int) and len(str(row_values[1])) > calltime_width:\n                    calltime_width = len(str(row_values[1]))\n                if len(row_values[2]) > cpu_data_description_width:\n                    cpu_data_description_width = len(row_values[2])\n                if len(row_values[3]) > gpu_data_description_width:\n                    gpu_data_description_width = len(row_values[3])\n            headers = ['Name', 'Calls', 'CPU Total / Avg / Max / Min / Ratio(%)', 'GPU Total / Avg / Max / Min / Ratio(%)', 'FLOPs']\n            row_format_list = ['']\n            header_sep_list = ['']\n            line_length_list = [-SPACING_SIZE]\n            add_column(name_column_width)\n            add_column(calltime_width)\n            add_column(cpu_data_description_width)\n            add_column(gpu_data_description_width)\n            add_column(flops_width)\n            row_format = row_format_list[0]\n            header_sep = header_sep_list[0]\n            line_length = line_length_list[0]\n            append(add_title(line_length, 'Operator Summary'))\n            append(f'Time unit: {time_unit}')\n            append(header_sep)\n            append(row_format.format(*headers))\n            append(header_sep)\n            for row_values in all_row_values:\n                if isinstance(row_values, str):\n                    append(add_title(line_length, row_values))\n                else:\n                    append(row_format.format(*row_values))\n            append(header_sep)\n            append('')\n            append('')\n    if views is None or SummaryView.KernelView in views:\n        if statistic_data.event_summary.kernel_items:\n            all_row_values = []\n            kernel_items = statistic_data.event_summary.kernel_items\n            if sorted_by == SortedKeys.GPUAvg:\n                sorted_items = sorted(kernel_items.items(), key=lambda x: x[1].avg_gpu_time, reverse=True)\n            elif sorted_by == SortedKeys.GPUMax:\n                sorted_items = sorted(kernel_items.items(), key=lambda x: x[1].max_gpu_time, reverse=True)\n            elif sorted_by == SortedKeys.GPUMin:\n                sorted_items = sorted(kernel_items.items(), key=lambda x: x[1].min_gpu_time)\n            else:\n                sorted_items = sorted(kernel_items.items(), key=lambda x: x[1].gpu_time, reverse=True)\n            total_kernel_gpu_time = 0\n            for (name, item) in sorted_items:\n                total_kernel_gpu_time += item.gpu_time\n            for (name, item) in sorted_items:\n                if total_kernel_gpu_time == 0:\n                    gpu_ratio = 0\n                else:\n                    gpu_ratio = float(item.gpu_time) / total_kernel_gpu_time\n                row_values = [name, item.call, '{} / {} / {} / {} / {}'.format(format_time(item.gpu_time, unit=time_unit), format_time(item.avg_gpu_time, unit=time_unit), format_time(item.max_gpu_time, unit=time_unit), format_time(item.min_gpu_time, unit=time_unit), format_ratio(gpu_ratio))]\n                all_row_values.append(row_values)\n            headers = ['Name', 'Calls', 'GPU Total / Avg / Max / Min / Ratio(%)']\n            name_column_width = 90\n            calltime_width = 6\n            gpu_data_description_width = 40\n            for row_values in all_row_values:\n                if isinstance(row_values[1], int) and len(str(row_values[1])) > calltime_width:\n                    calltime_width = len(str(row_values[1]))\n                if len(row_values[2]) > gpu_data_description_width:\n                    gpu_data_description_width = len(row_values[2])\n            row_format_list = ['']\n            header_sep_list = ['']\n            line_length_list = [-SPACING_SIZE]\n            add_column(name_column_width)\n            add_column(calltime_width)\n            add_column(gpu_data_description_width)\n            row_format = row_format_list[0]\n            header_sep = header_sep_list[0]\n            line_length = line_length_list[0]\n            append(add_title(line_length, 'Kernel Summary'))\n            append(f'Time unit: {time_unit}')\n            append(header_sep)\n            append(row_format.format(*headers))\n            append(header_sep)\n            kernel_name_pattern = re.compile('(.+?)(<.*>)(\\\\(.*\\\\))')\n            for row_values in all_row_values:\n                match = kernel_name_pattern.match(row_values[0])\n                if match:\n                    name = match.group(1) + match.group(2)\n                else:\n                    name = row_values[0]\n                if len(name) > name_column_width:\n                    row_values[0] = name[:name_column_width - 3] + '...'\n                else:\n                    row_values[0] = name\n                append(row_format.format(*row_values))\n            append(header_sep)\n            append('')\n            append('')\n    if views is None or SummaryView.MemoryManipulationView in views:\n        if statistic_data.event_summary.memory_manipulation_items:\n            all_row_values = []\n            memory_manipulation_items = statistic_data.event_summary.memory_manipulation_items\n            gpu_total_time = statistic_data.event_summary.model_perspective_items['ProfileStep'].general_gpu_time\n            for (name, item) in memory_manipulation_items.items():\n                if gpu_total_time == 0:\n                    gpu_ratio = 0\n                else:\n                    gpu_ratio = float(item.general_gpu_time) / gpu_total_time\n                row_values = [name, item.call, '{} / {} / {} / {} / {}'.format(format_time(item.cpu_time, unit=time_unit), format_time(item.avg_cpu_time, unit=time_unit), format_time(item.max_cpu_time, unit=time_unit), format_time(item.min_cpu_time, unit=time_unit), format_ratio(float(item.cpu_time) / total_time)), '{} / {} / {} / {} / {}'.format(format_time(item.general_gpu_time, unit=time_unit), format_time(item.avg_general_gpu_time, unit=time_unit), format_time(item.max_general_gpu_time, unit=time_unit), format_time(item.min_general_gpu_time, unit=time_unit), format_ratio(gpu_ratio))]\n                all_row_values.append(row_values)\n            headers = ['Name', 'Calls', 'CPU Total / Avg / Max / Min / Ratio(%)', 'GPU Total / Avg / Max / Min / Ratio(%)']\n            name_column_width = 0\n            calltime_width = 6\n            cpu_data_description_width = 40\n            gpu_data_description_width = 40\n            for row_values in all_row_values:\n                if len(row_values[0]) > name_column_width:\n                    name_column_width = len(row_values[0])\n                if isinstance(row_values[1], int) and len(str(row_values[1])) > calltime_width:\n                    calltime_width = len(str(row_values[1]))\n                if len(row_values[2]) > cpu_data_description_width:\n                    cpu_data_description_width = len(row_values[2])\n                if len(row_values[3]) > gpu_data_description_width:\n                    gpu_data_description_width = len(row_values[3])\n            row_format_list = ['']\n            header_sep_list = ['']\n            line_length_list = [-SPACING_SIZE]\n            add_column(name_column_width)\n            add_column(calltime_width)\n            add_column(cpu_data_description_width)\n            add_column(gpu_data_description_width)\n            row_format = row_format_list[0]\n            header_sep = header_sep_list[0]\n            line_length = line_length_list[0]\n            append(add_title(line_length, 'Memory Manipulation Summary'))\n            append(f'Time unit: {time_unit}')\n            append(header_sep)\n            append(row_format.format(*headers))\n            append(header_sep)\n            for row_values in all_row_values:\n                append(row_format.format(*row_values))\n            append(header_sep)\n            append('')\n            append('')\n    if views is None or SummaryView.UDFView in views:\n        if statistic_data.event_summary.userdefined_items:\n            all_row_values = []\n            gpu_total_time = statistic_data.event_summary.model_perspective_items['ProfileStep'].general_gpu_time\n            if thread_sep:\n                userdefined_thread_items = statistic_data.event_summary.userdefined_thread_items\n            else:\n                userdefined_thread_items = {'All threads merged': statistic_data.event_summary.userdefined_items}\n            for (thread_id, items) in userdefined_thread_items.items():\n                all_row_values.append(f'Thread: {thread_id}')\n                if sorted_by == SortedKeys.CPUTotal:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].cpu_time, reverse=True)\n                elif sorted_by == SortedKeys.CPUAvg:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].avg_cpu_time, reverse=True)\n                elif sorted_by == SortedKeys.CPUMax:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].max_cpu_time, reverse=True)\n                elif sorted_by == SortedKeys.CPUMin:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].min_cpu_time)\n                elif sorted_by == SortedKeys.GPUTotal:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].general_gpu_time, reverse=True)\n                elif sorted_by == SortedKeys.GPUAvg:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].avg_general_gpu_time, reverse=True)\n                elif sorted_by == SortedKeys.GPUMax:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].max_general_gpu_time, reverse=True)\n                elif sorted_by == SortedKeys.GPUMin:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].min_general_gpu_time)\n                for (name, item) in sorted_items:\n                    if gpu_total_time == 0:\n                        gpu_ratio = 0\n                    else:\n                        gpu_ratio = float(item.general_gpu_time) / gpu_total_time\n                    row_values = [name, item.call, '{} / {} / {} / {} / {}'.format(format_time(item.cpu_time, unit=time_unit), format_time(item.avg_cpu_time, unit=time_unit), format_time(item.max_cpu_time, unit=time_unit), format_time(item.min_cpu_time, unit=time_unit), format_ratio(float(item.cpu_time) / total_time)), '{} / {} / {} / {} / {}'.format(format_time(item.general_gpu_time, unit=time_unit), format_time(item.avg_general_gpu_time, unit=time_unit), format_time(item.max_general_gpu_time, unit=time_unit), format_time(item.min_general_gpu_time, unit=time_unit), format_ratio(gpu_ratio))]\n                    all_row_values.append(row_values)\n            name_column_width = 0\n            calltime_width = 6\n            cpu_data_description_width = 40\n            gpu_data_description_width = 40\n            for row_values in all_row_values:\n                if isinstance(row_values, str):\n                    continue\n                if len(row_values[0]) > name_column_width:\n                    name_column_width = len(row_values[0])\n                if isinstance(row_values[1], int) and len(str(row_values[1])) > calltime_width:\n                    calltime_width = len(str(row_values[1]))\n                if len(row_values[2]) > cpu_data_description_width:\n                    cpu_data_description_width = len(row_values[2])\n                if len(row_values[3]) > gpu_data_description_width:\n                    gpu_data_description_width = len(row_values[3])\n            headers = ['Name', 'Calls', 'CPU Total / Avg / Max / Min / Ratio(%)', 'GPU Total / Avg / Max / Min / Ratio(%)']\n            row_format_list = ['']\n            header_sep_list = ['']\n            line_length_list = [-SPACING_SIZE]\n            add_column(name_column_width)\n            add_column(calltime_width)\n            add_column(cpu_data_description_width)\n            add_column(gpu_data_description_width)\n            row_format = row_format_list[0]\n            header_sep = header_sep_list[0]\n            line_length = line_length_list[0]\n            append(add_title(line_length, 'UserDefined Summary'))\n            append(f'Time unit: {time_unit}')\n            append(header_sep)\n            append(row_format.format(*headers))\n            append(header_sep)\n            for row_values in all_row_values:\n                if isinstance(row_values, str):\n                    append(add_title(line_length, row_values))\n                else:\n                    append(row_format.format(*row_values))\n            append('')\n            append('')\n    if views is None or SummaryView.MemoryView in views:\n        if statistic_data.memory_summary.allocated_items or statistic_data.memory_summary.reserved_items:\n            for (device_type, memory_events) in statistic_data.memory_summary.allocated_items.items():\n                all_row_values = []\n                sorted_items = sorted(memory_events.items(), key=lambda x: x[1].increase_size, reverse=True)\n                for (event_name, item) in sorted_items:\n                    row_values = [event_name, item.memory_type, item.allocation_count, item.free_count, item.allocation_size, item.free_size, item.increase_size]\n                    all_row_values.append(row_values)\n                sorted_reserved_items = sorted(statistic_data.memory_summary.reserved_items[device_type].items(), key=lambda x: x[1].increase_size, reverse=True)\n                for (event_name, item) in sorted_reserved_items:\n                    row_values = [event_name, item.memory_type, item.allocation_count, item.free_count, item.allocation_size, item.free_size, item.increase_size]\n                    all_row_values.append(row_values)\n                headers = ['Name', 'Type', 'Allocation Count', 'Free Count', 'Allocation Size', 'Free Size', 'Increased Size']\n                row_format_list = ['']\n                header_sep_list = ['']\n                line_length_list = [-SPACING_SIZE]\n                name_column_width = 50\n                number_column_width = 15\n                add_column(name_column_width)\n                add_column(12)\n                add_column(number_column_width)\n                add_column(number_column_width)\n                add_column(number_column_width)\n                add_column(number_column_width)\n                add_column(number_column_width)\n                row_format = row_format_list[0]\n                header_sep = header_sep_list[0]\n                line_length = line_length_list[0]\n                append(add_title(line_length, f'Memory Summary - {device_type}'))\n                append('Peak Allocated Memory: {}'.format(statistic_data.memory_summary.peak_allocation_values[device_type]))\n                append('Peak Reserved Memory: {}'.format(statistic_data.memory_summary.peak_reserved_values[device_type]))\n                append(header_sep)\n                append(row_format.format(*headers))\n                append(header_sep)\n                for row_values in all_row_values:\n                    if isinstance(row_values, str):\n                        append(add_title(line_length, row_values))\n                    else:\n                        append(row_format.format(*row_values))\n                append('')\n                append('')\n    return ''.join(result)",
            "def _build_table(statistic_data, sorted_by=SortedKeys.CPUTotal, op_detail=True, thread_sep=False, time_unit='ms', row_limit=100, max_src_column_width=75, views=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    from .profiler import SummaryView\n    'Prints a summary of events.'\n    SPACING_SIZE = 2\n    row_format_list = ['']\n    header_sep_list = ['']\n    line_length_list = [-SPACING_SIZE]\n\n    def add_column(padding, text_dir='<'):\n        row_format_list[0] += '{: ' + text_dir + str(padding) + '}' + ' ' * SPACING_SIZE\n        header_sep_list[0] += '-' * padding + ' ' * SPACING_SIZE\n        line_length_list[0] += padding + SPACING_SIZE\n\n    def add_title(padding, text):\n        left_length = padding - len(text)\n        half = left_length // 2\n        return '-' * half + text + '-' * (left_length - half)\n    result = []\n\n    def append(s):\n        result.append(s)\n        result.append('\\n')\n\n    def format_time(time, unit='ms', indent=0):\n        \"\"\"\n        Transform time in ns to time in unit.\n        \"\"\"\n        if time == float('inf'):\n            return '-'\n        else:\n            result = float(time)\n            if unit == 's':\n                result /= 1000000000.0\n            elif unit == 'ms':\n                result /= 1000000.0\n            elif unit == 'us':\n                result /= 1000.0\n            return '{}{:.2f}'.format(' ' * indent, result)\n\n    def format_ratio(ratio, indent=0):\n        \"\"\"\n        Transform ratio within [0, 1] to percentage presentation.\n        \"\"\"\n        return '{}{:.2f}'.format(' ' * indent, ratio * 100)\n    total_time = statistic_data.time_range_summary.get_cpu_range_sum(TracerEventType.ProfileStep)\n    if views is None or SummaryView.DeviceView in views:\n        headers = ['Device', 'Utilization (%)']\n        name_column_width = 30\n        DEFAULT_COLUMN_WIDTH = 20\n        add_column(name_column_width)\n        for _ in headers[1:]:\n            add_column(DEFAULT_COLUMN_WIDTH)\n        row_format = row_format_list[0]\n        header_sep = header_sep_list[0]\n        line_length = line_length_list[0]\n        append(add_title(line_length, 'Device Summary'))\n        append(header_sep)\n        append(row_format.format(*headers))\n        append(header_sep)\n        row_values = ['CPU(Process)', format_ratio(float(statistic_data.extra_info['Process Cpu Utilization']))]\n        append(row_format.format(*row_values))\n        row_values = ['CPU(System)', format_ratio(float(statistic_data.extra_info['System Cpu Utilization']))]\n        append(row_format.format(*row_values))\n        for gpu_name in statistic_data.time_range_summary.get_gpu_devices():\n            gpu_time = float(statistic_data.time_range_summary.get_gpu_range_sum(gpu_name, TracerEventType.Kernel))\n            utilization = gpu_time / total_time\n            row_values = [f'GPU{gpu_name}', format_ratio(utilization)]\n            append(row_format.format(*row_values))\n        append(header_sep)\n        append('Note:\\nCPU(Process) Utilization = Current process CPU time over all cpu cores / elapsed time, so max utilization can be reached 100% * number of cpu cores.\\nCPU(System) Utilization = All processes CPU time over all cpu cores(busy time) / (busy time + idle time).\\nGPU Utilization = Current process GPU time / elapsed time.')\n        append('-' * line_length)\n        append('')\n        append('')\n        if total_time == 0:\n            return ''.join(result)\n    if views is None or SummaryView.OverView in views:\n        headers = ['Event Type', 'Calls', 'CPU Time', 'Ratio (%)']\n        row_format_list = ['']\n        header_sep_list = ['']\n        line_length_list = [-SPACING_SIZE]\n        DEFAULT_COLUMN_WIDTH = 25\n        for _ in headers:\n            add_column(DEFAULT_COLUMN_WIDTH)\n        row_format = row_format_list[0]\n        header_sep = header_sep_list[0]\n        line_length = line_length_list[0]\n        append(add_title(line_length, 'Overview Summary'))\n        append(f'Time unit: {time_unit}')\n        append(header_sep)\n        append(row_format.format(*headers))\n        append(header_sep)\n        cpu_type_time = collections.defaultdict(int)\n        gpu_type_time = collections.defaultdict(int)\n        cpu_call_times = collections.defaultdict(int)\n        gpu_call_times = collections.defaultdict(int)\n        cpu_call_times.update(statistic_data.time_range_summary.call_times)\n        gpu_call_times.update(statistic_data.time_range_summary.call_times)\n        for (event_type, value) in statistic_data.time_range_summary.CPUTimeRangeSum.items():\n            if event_type != TracerEventType.Communication:\n                cpu_type_time[event_type] = value\n        if statistic_data.distributed_summary.cpu_communication_range:\n            cpu_type_time[TracerEventType.Communication] = sum_ranges(statistic_data.distributed_summary.cpu_communication_range)\n            cpu_call_times[TracerEventType.Communication] = statistic_data.distributed_summary.cpu_calls\n        for event_type in [TracerEventType.Dataloader, TracerEventType.Forward, TracerEventType.Backward, TracerEventType.Optimization]:\n            event_type_name = str(event_type).split('.')[1]\n            if event_type in cpu_call_times and event_type_name in statistic_data.event_summary.model_perspective_items:\n                cpu_call_times[event_type] = statistic_data.event_summary.model_perspective_items[event_type_name].call\n                cpu_type_time[event_type] = statistic_data.event_summary.model_perspective_items[event_type_name].cpu_time\n        gpu_time_range = collections.defaultdict(list)\n        for (device_id, device_time_ranges) in statistic_data.time_range_summary.GPUTimeRange.items():\n            for (event_type, time_range) in device_time_ranges.items():\n                gpu_time_range[event_type] = merge_ranges(gpu_time_range[event_type], time_range, is_sorted=True)\n        for (event_type, time_range) in gpu_time_range.items():\n            gpu_type_time[event_type] = sum_ranges(time_range)\n        if statistic_data.distributed_summary.gpu_communication_range:\n            gpu_type_time[TracerEventType.Communication] = sum_ranges(statistic_data.distributed_summary.gpu_communication_range)\n            gpu_call_times[TracerEventType.Communication] = statistic_data.distributed_summary.gpu_calls\n        sorted_items = sorted(cpu_type_time.items(), key=lambda x: x[1], reverse=True)\n        (event_type, time) = sorted_items[0]\n        row_values = ['{}'.format(str(event_type).split('.')[1]), cpu_call_times[event_type], format_time(time, unit=time_unit), format_ratio(float(time) / total_time)]\n        append(row_format.format(*row_values))\n        for (event_type, time) in sorted_items[1:]:\n            row_values = ['  {}'.format(str(event_type).split('.')[1]), cpu_call_times[event_type], format_time(time, unit=time_unit), format_ratio(float(time) / total_time)]\n            append(row_format.format(*row_values))\n        append(header_sep)\n        headers = ['', 'Calls', 'GPU Time', 'Ratio (%)']\n        append(row_format.format(*headers))\n        append(header_sep)\n        for (event_type, time) in gpu_type_time.items():\n            row_values = ['  {}'.format(str(event_type).split('.')[1]), gpu_call_times[event_type], format_time(time, unit=time_unit), format_ratio(float(time) / total_time)]\n            append(row_format.format(*row_values))\n        append(header_sep)\n        append('Note:\\nIn this table, We sum up all collected events in terms of event type.\\nThe time of events collected on host are presented as CPU Time, and as GPU Time if on device.\\nEvents with different types may overlap or inclusion, e.g. Operator includes OperatorInner, so the sum of ratios is not 100%.\\nThe time of events in the same type with overlap will not calculate twice, and all time is summed after merged.\\nExample:\\nThread 1:\\n  Operator: |___________|     |__________|\\nThread 2:\\n  Operator:   |____________|     |___|\\nAfter merged:\\n  Result:   |______________|  |__________|\\n')\n        append('-' * line_length)\n        append('')\n        append('')\n    if views is None or SummaryView.ModelView in views:\n        model_perspective_items = statistic_data.event_summary.model_perspective_items\n        if len(model_perspective_items) > 1:\n            all_row_values = []\n            accmulation_time = 0\n            gpu_accmulation_time = 0\n            gpu_total_time = statistic_data.event_summary.model_perspective_items['ProfileStep'].gpu_time\n            for name in ['ProfileStep', 'Dataloader', 'Forward', 'Backward', 'Optimization']:\n                if name in model_perspective_items:\n                    item = model_perspective_items[name]\n                    if gpu_total_time == 0:\n                        gpu_ratio = 0\n                    else:\n                        gpu_ratio = float(item.gpu_time) / gpu_total_time\n                    name = f'{name}' if 'ProfileStep' in name else f'  {name}'\n                    row_values = [f'{name}', item.call, '{} / {} / {} / {} / {}'.format(format_time(item.cpu_time, unit=time_unit), format_time(item.avg_cpu_time, unit=time_unit), format_time(item.max_cpu_time, unit=time_unit), format_time(item.min_cpu_time, unit=time_unit), format_ratio(float(item.cpu_time) / total_time)), '{} / {} / {} / {} / {}'.format(format_time(item.gpu_time, unit=time_unit), format_time(item.avg_gpu_time, unit=time_unit), format_time(item.max_gpu_time, unit=time_unit), format_time(item.min_gpu_time, unit=time_unit), format_ratio(gpu_ratio))]\n                    all_row_values.append(row_values)\n                    if 'ProfileStep' not in name:\n                        accmulation_time += item.cpu_time\n                        gpu_accmulation_time += item.gpu_time\n            other_time = total_time - accmulation_time\n            other_gpu_time = gpu_total_time - gpu_accmulation_time\n            if gpu_total_time == 0:\n                gpu_ratio = 0\n            else:\n                gpu_ratio = float(other_gpu_time) / gpu_total_time\n            row_values = ['  Others', '-', '{} / - / - / - / {}'.format(format_time(other_time, unit=time_unit), format_ratio(float(other_time) / total_time)), '{} / - / - / - / {}'.format(format_time(other_gpu_time, unit=time_unit), format_ratio(gpu_ratio))]\n            all_row_values.append(row_values)\n            calltime_width = 6\n            cpu_data_description_width = 40\n            gpu_data_description_width = 40\n            for row_values in all_row_values:\n                if isinstance(row_values[1], int) and len(str(row_values[1])) > calltime_width:\n                    calltime_width = len(str(row_values[1]))\n                if len(row_values[2]) > cpu_data_description_width:\n                    cpu_data_description_width = len(row_values[2])\n                if len(row_values[3]) > gpu_data_description_width:\n                    gpu_data_description_width = len(row_values[3])\n            headers = ['Name', 'Calls', 'CPU Total / Avg / Max / Min / Ratio(%)', 'GPU Total / Avg / Max / Min / Ratio(%)']\n            row_format_list = ['']\n            header_sep_list = ['']\n            line_length_list = [-SPACING_SIZE]\n            name_column_width = 15\n            add_column(name_column_width)\n            add_column(calltime_width)\n            add_column(cpu_data_description_width)\n            add_column(gpu_data_description_width)\n            row_format = row_format_list[0]\n            header_sep = header_sep_list[0]\n            line_length = line_length_list[0]\n            append(add_title(line_length, 'Model Summary'))\n            append(f'Time unit: {time_unit}')\n            append(header_sep)\n            append(row_format.format(*headers))\n            append(header_sep)\n            for row_values in all_row_values:\n                append(row_format.format(*row_values))\n            append(header_sep)\n            append('Note:\\nIn this table, GPU time is the sum of all device(GPU) events called in the phase.\\nUnlike overview summary, if two device(GPU) events execute on different streams with overlap time, we sum them directly here.\\n')\n            append('-' * line_length)\n            append('')\n            append('')\n    if views is None or SummaryView.DistributedView in views:\n        if statistic_data.distributed_summary.communication_range:\n            headers = ['Name', 'Total Time', 'Ratio (%)']\n            row_format_list = ['']\n            header_sep_list = ['']\n            line_length_list = [-SPACING_SIZE]\n            DEFAULT_COLUMN_WIDTH = 25\n            for _ in headers:\n                add_column(DEFAULT_COLUMN_WIDTH)\n            row_format = row_format_list[0]\n            header_sep = header_sep_list[0]\n            line_length = line_length_list[0]\n            append(add_title(line_length, 'Distribution Summary'))\n            append(f'Time unit: {time_unit}')\n            append(header_sep)\n            append(row_format.format(*headers))\n            append(header_sep)\n            communication_time = sum_ranges(statistic_data.distributed_summary.communication_range)\n            computation_time = sum_ranges(statistic_data.distributed_summary.computation_range)\n            overlap_time = sum_ranges(statistic_data.distributed_summary.overlap_range)\n            row_values = ['ProfileStep', format_time(total_time, unit=time_unit), format_ratio(float(total_time) / total_time)]\n            append(row_format.format(*row_values))\n            row_values = ['  Communication', format_time(communication_time, unit=time_unit), format_ratio(float(communication_time) / total_time)]\n            append(row_format.format(*row_values))\n            row_values = ['  Computation', format_time(computation_time, unit=time_unit), format_ratio(float(computation_time) / total_time)]\n            append(row_format.format(*row_values))\n            row_values = ['  Overlap', format_time(overlap_time, unit=time_unit), format_ratio(float(overlap_time) / total_time)]\n            append(row_format.format(*row_values))\n            append(header_sep)\n            append('Note:\\nCommunication time: Communication Event time, Communication Op time and its kernel time on gpu.\\nComputation time: Kernel time, except kernels belong to communication(nccl kernels).\\nOverlap time: Communication time intersects with computation time.\\nExample:\\nCommunication:\\n  CPU:              |_________________|\\n  GPU:                                  |______________|\\n  Total:            |_________________| |______________|\\nComputation time(Kernel):\\n  GPU:         |________________|\\nOverlap time:       |___________|\\n')\n            append('-' * line_length)\n            append('')\n            append('')\n    if views is None or SummaryView.OperatorView in views:\n        if statistic_data.event_summary.items:\n            all_row_values = []\n            name_column_width = 52\n            if thread_sep:\n                thread_items = statistic_data.event_summary.thread_items\n            else:\n                thread_items = {'All threads merged': statistic_data.event_summary.items}\n            for (thread_id, items) in thread_items.items():\n                all_row_values.append(f'Thread: {thread_id}')\n                if sorted_by == SortedKeys.CPUTotal:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].cpu_time, reverse=True)\n                elif sorted_by == SortedKeys.CPUAvg:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].avg_cpu_time, reverse=True)\n                elif sorted_by == SortedKeys.CPUMax:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].max_cpu_time, reverse=True)\n                elif sorted_by == SortedKeys.CPUMin:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].min_cpu_time)\n                elif sorted_by == SortedKeys.GPUTotal:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].general_gpu_time, reverse=True)\n                elif sorted_by == SortedKeys.GPUAvg:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].avg_general_gpu_time, reverse=True)\n                elif sorted_by == SortedKeys.GPUMax:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].max_general_gpu_time, reverse=True)\n                elif sorted_by == SortedKeys.GPUMin:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].min_general_gpu_time)\n                total_op_cpu_time = 0\n                total_op_gpu_time = 0\n                for (name, item) in sorted_items:\n                    total_op_cpu_time += item.cpu_time\n                    total_op_gpu_time += item.general_gpu_time\n                for (name, item) in sorted_items:\n                    if total_op_cpu_time == 0:\n                        cpu_ratio = 0\n                    else:\n                        cpu_ratio = float(item.cpu_time) / total_op_cpu_time\n                    if total_op_gpu_time == 0:\n                        gpu_ratio = 0\n                    else:\n                        gpu_ratio = float(item.general_gpu_time) / total_op_gpu_time\n                    row_values = [name, item.call, '{} / {} / {} / {} / {}'.format(format_time(item.cpu_time, unit=time_unit), format_time(item.avg_cpu_time, unit=time_unit), format_time(item.max_cpu_time, unit=time_unit), format_time(item.min_cpu_time, unit=time_unit), format_ratio(cpu_ratio)), '{} / {} / {} / {} / {}'.format(format_time(item.general_gpu_time, unit=time_unit), format_time(item.avg_general_gpu_time, unit=time_unit), format_time(item.max_general_gpu_time, unit=time_unit), format_time(item.min_general_gpu_time, unit=time_unit), format_ratio(gpu_ratio)), item.flops]\n                    all_row_values.append(row_values)\n                    if op_detail:\n                        for (innerop_name, innerop_node) in item.operator_inners.items():\n                            if item.cpu_time == 0:\n                                cpu_ratio = 0\n                            else:\n                                cpu_ratio = float(innerop_node.cpu_time) / item.cpu_time\n                            if item.general_gpu_time == 0:\n                                gpu_ratio = 0\n                            else:\n                                gpu_ratio = float(innerop_node.general_gpu_time) / item.general_gpu_time\n                            if len(innerop_name) + 2 > name_column_width:\n                                innerop_name = innerop_name[:name_column_width - 5]\n                                innerop_name += '...'\n                            row_values = [f'  {innerop_name}', innerop_node.call, '{} / {} / {} / {} / {}'.format(format_time(innerop_node.cpu_time, unit=time_unit), format_time(innerop_node.avg_cpu_time, unit=time_unit), format_time(innerop_node.max_cpu_time, unit=time_unit), format_time(innerop_node.min_cpu_time, unit=time_unit), format_ratio(cpu_ratio)), '{} / {} / {} / {} / {}'.format(format_time(innerop_node.general_gpu_time, unit=time_unit), format_time(innerop_node.avg_general_gpu_time, unit=time_unit), format_time(innerop_node.max_general_gpu_time, unit=time_unit), format_time(innerop_node.min_general_gpu_time, unit=time_unit), format_ratio(gpu_ratio)), '-']\n                            all_row_values.append(row_values)\n                            for (device_node_name, device_node) in innerop_node.devices.items():\n                                if innerop_node.general_gpu_time == 0:\n                                    gpu_ratio = 0\n                                else:\n                                    gpu_ratio = float(device_node.gpu_time) / innerop_node.general_gpu_time\n                                if len(device_node_name) + 4 > name_column_width:\n                                    device_node_name = device_node_name[:name_column_width - 7]\n                                    device_node_name += '...'\n                                row_values = [f'    {device_node_name}', device_node.call, '- / - / - / - / -', '{} / {} / {} / {} / {}'.format(format_time(device_node.gpu_time, unit=time_unit), format_time(device_node.avg_gpu_time, unit=time_unit), format_time(device_node.max_gpu_time, unit=time_unit), format_time(device_node.min_gpu_time, unit=time_unit), format_ratio(gpu_ratio)), '-']\n                                all_row_values.append(row_values)\n                        for (device_node_name, device_node) in item.devices.items():\n                            if item.general_gpu_time == 0:\n                                gpu_ratio = 0\n                            else:\n                                gpu_ratio = float(device_node.gpu_time) / item.general_gpu_time\n                            if len(device_node_name) + 2 > name_column_width:\n                                device_node_name = device_node_name[:name_column_width - 5]\n                                device_node_name += '...'\n                            row_values = [f'  {device_node_name}', device_node.call, '- / - / - / - / -', '{} / {} / {} / {} / {}'.format(format_time(device_node.gpu_time, unit=time_unit), format_time(device_node.avg_gpu_time, unit=time_unit), format_time(device_node.max_gpu_time, unit=time_unit), format_time(device_node.min_gpu_time, unit=time_unit), format_ratio(gpu_ratio)), '-']\n                            all_row_values.append(row_values)\n            calltime_width = 6\n            cpu_data_description_width = 40\n            gpu_data_description_width = 40\n            flops_width = 10\n            for row_values in all_row_values:\n                if isinstance(row_values, str):\n                    continue\n                if isinstance(row_values[1], int) and len(str(row_values[1])) > calltime_width:\n                    calltime_width = len(str(row_values[1]))\n                if len(row_values[2]) > cpu_data_description_width:\n                    cpu_data_description_width = len(row_values[2])\n                if len(row_values[3]) > gpu_data_description_width:\n                    gpu_data_description_width = len(row_values[3])\n            headers = ['Name', 'Calls', 'CPU Total / Avg / Max / Min / Ratio(%)', 'GPU Total / Avg / Max / Min / Ratio(%)', 'FLOPs']\n            row_format_list = ['']\n            header_sep_list = ['']\n            line_length_list = [-SPACING_SIZE]\n            add_column(name_column_width)\n            add_column(calltime_width)\n            add_column(cpu_data_description_width)\n            add_column(gpu_data_description_width)\n            add_column(flops_width)\n            row_format = row_format_list[0]\n            header_sep = header_sep_list[0]\n            line_length = line_length_list[0]\n            append(add_title(line_length, 'Operator Summary'))\n            append(f'Time unit: {time_unit}')\n            append(header_sep)\n            append(row_format.format(*headers))\n            append(header_sep)\n            for row_values in all_row_values:\n                if isinstance(row_values, str):\n                    append(add_title(line_length, row_values))\n                else:\n                    append(row_format.format(*row_values))\n            append(header_sep)\n            append('')\n            append('')\n    if views is None or SummaryView.KernelView in views:\n        if statistic_data.event_summary.kernel_items:\n            all_row_values = []\n            kernel_items = statistic_data.event_summary.kernel_items\n            if sorted_by == SortedKeys.GPUAvg:\n                sorted_items = sorted(kernel_items.items(), key=lambda x: x[1].avg_gpu_time, reverse=True)\n            elif sorted_by == SortedKeys.GPUMax:\n                sorted_items = sorted(kernel_items.items(), key=lambda x: x[1].max_gpu_time, reverse=True)\n            elif sorted_by == SortedKeys.GPUMin:\n                sorted_items = sorted(kernel_items.items(), key=lambda x: x[1].min_gpu_time)\n            else:\n                sorted_items = sorted(kernel_items.items(), key=lambda x: x[1].gpu_time, reverse=True)\n            total_kernel_gpu_time = 0\n            for (name, item) in sorted_items:\n                total_kernel_gpu_time += item.gpu_time\n            for (name, item) in sorted_items:\n                if total_kernel_gpu_time == 0:\n                    gpu_ratio = 0\n                else:\n                    gpu_ratio = float(item.gpu_time) / total_kernel_gpu_time\n                row_values = [name, item.call, '{} / {} / {} / {} / {}'.format(format_time(item.gpu_time, unit=time_unit), format_time(item.avg_gpu_time, unit=time_unit), format_time(item.max_gpu_time, unit=time_unit), format_time(item.min_gpu_time, unit=time_unit), format_ratio(gpu_ratio))]\n                all_row_values.append(row_values)\n            headers = ['Name', 'Calls', 'GPU Total / Avg / Max / Min / Ratio(%)']\n            name_column_width = 90\n            calltime_width = 6\n            gpu_data_description_width = 40\n            for row_values in all_row_values:\n                if isinstance(row_values[1], int) and len(str(row_values[1])) > calltime_width:\n                    calltime_width = len(str(row_values[1]))\n                if len(row_values[2]) > gpu_data_description_width:\n                    gpu_data_description_width = len(row_values[2])\n            row_format_list = ['']\n            header_sep_list = ['']\n            line_length_list = [-SPACING_SIZE]\n            add_column(name_column_width)\n            add_column(calltime_width)\n            add_column(gpu_data_description_width)\n            row_format = row_format_list[0]\n            header_sep = header_sep_list[0]\n            line_length = line_length_list[0]\n            append(add_title(line_length, 'Kernel Summary'))\n            append(f'Time unit: {time_unit}')\n            append(header_sep)\n            append(row_format.format(*headers))\n            append(header_sep)\n            kernel_name_pattern = re.compile('(.+?)(<.*>)(\\\\(.*\\\\))')\n            for row_values in all_row_values:\n                match = kernel_name_pattern.match(row_values[0])\n                if match:\n                    name = match.group(1) + match.group(2)\n                else:\n                    name = row_values[0]\n                if len(name) > name_column_width:\n                    row_values[0] = name[:name_column_width - 3] + '...'\n                else:\n                    row_values[0] = name\n                append(row_format.format(*row_values))\n            append(header_sep)\n            append('')\n            append('')\n    if views is None or SummaryView.MemoryManipulationView in views:\n        if statistic_data.event_summary.memory_manipulation_items:\n            all_row_values = []\n            memory_manipulation_items = statistic_data.event_summary.memory_manipulation_items\n            gpu_total_time = statistic_data.event_summary.model_perspective_items['ProfileStep'].general_gpu_time\n            for (name, item) in memory_manipulation_items.items():\n                if gpu_total_time == 0:\n                    gpu_ratio = 0\n                else:\n                    gpu_ratio = float(item.general_gpu_time) / gpu_total_time\n                row_values = [name, item.call, '{} / {} / {} / {} / {}'.format(format_time(item.cpu_time, unit=time_unit), format_time(item.avg_cpu_time, unit=time_unit), format_time(item.max_cpu_time, unit=time_unit), format_time(item.min_cpu_time, unit=time_unit), format_ratio(float(item.cpu_time) / total_time)), '{} / {} / {} / {} / {}'.format(format_time(item.general_gpu_time, unit=time_unit), format_time(item.avg_general_gpu_time, unit=time_unit), format_time(item.max_general_gpu_time, unit=time_unit), format_time(item.min_general_gpu_time, unit=time_unit), format_ratio(gpu_ratio))]\n                all_row_values.append(row_values)\n            headers = ['Name', 'Calls', 'CPU Total / Avg / Max / Min / Ratio(%)', 'GPU Total / Avg / Max / Min / Ratio(%)']\n            name_column_width = 0\n            calltime_width = 6\n            cpu_data_description_width = 40\n            gpu_data_description_width = 40\n            for row_values in all_row_values:\n                if len(row_values[0]) > name_column_width:\n                    name_column_width = len(row_values[0])\n                if isinstance(row_values[1], int) and len(str(row_values[1])) > calltime_width:\n                    calltime_width = len(str(row_values[1]))\n                if len(row_values[2]) > cpu_data_description_width:\n                    cpu_data_description_width = len(row_values[2])\n                if len(row_values[3]) > gpu_data_description_width:\n                    gpu_data_description_width = len(row_values[3])\n            row_format_list = ['']\n            header_sep_list = ['']\n            line_length_list = [-SPACING_SIZE]\n            add_column(name_column_width)\n            add_column(calltime_width)\n            add_column(cpu_data_description_width)\n            add_column(gpu_data_description_width)\n            row_format = row_format_list[0]\n            header_sep = header_sep_list[0]\n            line_length = line_length_list[0]\n            append(add_title(line_length, 'Memory Manipulation Summary'))\n            append(f'Time unit: {time_unit}')\n            append(header_sep)\n            append(row_format.format(*headers))\n            append(header_sep)\n            for row_values in all_row_values:\n                append(row_format.format(*row_values))\n            append(header_sep)\n            append('')\n            append('')\n    if views is None or SummaryView.UDFView in views:\n        if statistic_data.event_summary.userdefined_items:\n            all_row_values = []\n            gpu_total_time = statistic_data.event_summary.model_perspective_items['ProfileStep'].general_gpu_time\n            if thread_sep:\n                userdefined_thread_items = statistic_data.event_summary.userdefined_thread_items\n            else:\n                userdefined_thread_items = {'All threads merged': statistic_data.event_summary.userdefined_items}\n            for (thread_id, items) in userdefined_thread_items.items():\n                all_row_values.append(f'Thread: {thread_id}')\n                if sorted_by == SortedKeys.CPUTotal:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].cpu_time, reverse=True)\n                elif sorted_by == SortedKeys.CPUAvg:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].avg_cpu_time, reverse=True)\n                elif sorted_by == SortedKeys.CPUMax:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].max_cpu_time, reverse=True)\n                elif sorted_by == SortedKeys.CPUMin:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].min_cpu_time)\n                elif sorted_by == SortedKeys.GPUTotal:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].general_gpu_time, reverse=True)\n                elif sorted_by == SortedKeys.GPUAvg:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].avg_general_gpu_time, reverse=True)\n                elif sorted_by == SortedKeys.GPUMax:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].max_general_gpu_time, reverse=True)\n                elif sorted_by == SortedKeys.GPUMin:\n                    sorted_items = sorted(items.items(), key=lambda x: x[1].min_general_gpu_time)\n                for (name, item) in sorted_items:\n                    if gpu_total_time == 0:\n                        gpu_ratio = 0\n                    else:\n                        gpu_ratio = float(item.general_gpu_time) / gpu_total_time\n                    row_values = [name, item.call, '{} / {} / {} / {} / {}'.format(format_time(item.cpu_time, unit=time_unit), format_time(item.avg_cpu_time, unit=time_unit), format_time(item.max_cpu_time, unit=time_unit), format_time(item.min_cpu_time, unit=time_unit), format_ratio(float(item.cpu_time) / total_time)), '{} / {} / {} / {} / {}'.format(format_time(item.general_gpu_time, unit=time_unit), format_time(item.avg_general_gpu_time, unit=time_unit), format_time(item.max_general_gpu_time, unit=time_unit), format_time(item.min_general_gpu_time, unit=time_unit), format_ratio(gpu_ratio))]\n                    all_row_values.append(row_values)\n            name_column_width = 0\n            calltime_width = 6\n            cpu_data_description_width = 40\n            gpu_data_description_width = 40\n            for row_values in all_row_values:\n                if isinstance(row_values, str):\n                    continue\n                if len(row_values[0]) > name_column_width:\n                    name_column_width = len(row_values[0])\n                if isinstance(row_values[1], int) and len(str(row_values[1])) > calltime_width:\n                    calltime_width = len(str(row_values[1]))\n                if len(row_values[2]) > cpu_data_description_width:\n                    cpu_data_description_width = len(row_values[2])\n                if len(row_values[3]) > gpu_data_description_width:\n                    gpu_data_description_width = len(row_values[3])\n            headers = ['Name', 'Calls', 'CPU Total / Avg / Max / Min / Ratio(%)', 'GPU Total / Avg / Max / Min / Ratio(%)']\n            row_format_list = ['']\n            header_sep_list = ['']\n            line_length_list = [-SPACING_SIZE]\n            add_column(name_column_width)\n            add_column(calltime_width)\n            add_column(cpu_data_description_width)\n            add_column(gpu_data_description_width)\n            row_format = row_format_list[0]\n            header_sep = header_sep_list[0]\n            line_length = line_length_list[0]\n            append(add_title(line_length, 'UserDefined Summary'))\n            append(f'Time unit: {time_unit}')\n            append(header_sep)\n            append(row_format.format(*headers))\n            append(header_sep)\n            for row_values in all_row_values:\n                if isinstance(row_values, str):\n                    append(add_title(line_length, row_values))\n                else:\n                    append(row_format.format(*row_values))\n            append('')\n            append('')\n    if views is None or SummaryView.MemoryView in views:\n        if statistic_data.memory_summary.allocated_items or statistic_data.memory_summary.reserved_items:\n            for (device_type, memory_events) in statistic_data.memory_summary.allocated_items.items():\n                all_row_values = []\n                sorted_items = sorted(memory_events.items(), key=lambda x: x[1].increase_size, reverse=True)\n                for (event_name, item) in sorted_items:\n                    row_values = [event_name, item.memory_type, item.allocation_count, item.free_count, item.allocation_size, item.free_size, item.increase_size]\n                    all_row_values.append(row_values)\n                sorted_reserved_items = sorted(statistic_data.memory_summary.reserved_items[device_type].items(), key=lambda x: x[1].increase_size, reverse=True)\n                for (event_name, item) in sorted_reserved_items:\n                    row_values = [event_name, item.memory_type, item.allocation_count, item.free_count, item.allocation_size, item.free_size, item.increase_size]\n                    all_row_values.append(row_values)\n                headers = ['Name', 'Type', 'Allocation Count', 'Free Count', 'Allocation Size', 'Free Size', 'Increased Size']\n                row_format_list = ['']\n                header_sep_list = ['']\n                line_length_list = [-SPACING_SIZE]\n                name_column_width = 50\n                number_column_width = 15\n                add_column(name_column_width)\n                add_column(12)\n                add_column(number_column_width)\n                add_column(number_column_width)\n                add_column(number_column_width)\n                add_column(number_column_width)\n                add_column(number_column_width)\n                row_format = row_format_list[0]\n                header_sep = header_sep_list[0]\n                line_length = line_length_list[0]\n                append(add_title(line_length, f'Memory Summary - {device_type}'))\n                append('Peak Allocated Memory: {}'.format(statistic_data.memory_summary.peak_allocation_values[device_type]))\n                append('Peak Reserved Memory: {}'.format(statistic_data.memory_summary.peak_reserved_values[device_type]))\n                append(header_sep)\n                append(row_format.format(*headers))\n                append(header_sep)\n                for row_values in all_row_values:\n                    if isinstance(row_values, str):\n                        append(add_title(line_length, row_values))\n                    else:\n                        append(row_format.format(*row_values))\n                append('')\n                append('')\n    return ''.join(result)"
        ]
    }
]