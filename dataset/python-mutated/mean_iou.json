[
    {
        "func_name": "mean_iou",
        "original": "def mean_iou(pred: torch.Tensor, target: torch.Tensor, num_classes: int, eps: float=1e-06) -> torch.Tensor:\n    \"\"\"Calculate mean Intersection-Over-Union (mIOU).\n\n    The function internally computes the confusion matrix.\n\n    Args:\n        pred : tensor with estimated targets returned by a\n          classifier. The shape can be :math:`(B, *)` and must contain integer\n          values between 0 and K-1.\n        target: tensor with ground truth (correct) target\n          values. The shape can be :math:`(B, *)` and must contain integer\n          values between 0 and K-1, where targets are assumed to be provided as\n          one-hot vectors.\n        num_classes: total possible number of classes in target.\n\n    Returns:\n        a tensor representing the mean intersection-over union\n        with shape :math:`(B, K)` where K is the number of classes.\n\n    Example:\n        >>> logits = torch.tensor([[0, 1, 0]])\n        >>> target = torch.tensor([[0, 1, 0]])\n        >>> mean_iou(logits, target, num_classes=3)\n        tensor([[1., 1., 1.]])\n    \"\"\"\n    if not torch.is_tensor(pred) and pred.dtype is not torch.int64:\n        raise TypeError(f'Input pred type is not a torch.Tensor with torch.int64 dtype. Got {type(pred)}')\n    if not torch.is_tensor(target) and target.dtype is not torch.int64:\n        raise TypeError(f'Input target type is not a torch.Tensor with torch.int64 dtype. Got {type(target)}')\n    if not pred.shape == target.shape:\n        raise ValueError(f'Inputs pred and target must have the same shape. Got: {pred.shape} and {target.shape}')\n    if not pred.device == target.device:\n        raise ValueError(f'Inputs must be in the same device. Got: {pred.device} - {target.device}')\n    if not isinstance(num_classes, int) or num_classes < 2:\n        raise ValueError(f'The number of classes must be an integer bigger than two. Got: {num_classes}')\n    conf_mat: torch.Tensor = confusion_matrix(pred, target, num_classes)\n    sum_over_row = torch.sum(conf_mat, dim=1)\n    sum_over_col = torch.sum(conf_mat, dim=2)\n    conf_mat_diag = torch.diagonal(conf_mat, dim1=-2, dim2=-1)\n    denominator = sum_over_row + sum_over_col - conf_mat_diag\n    ious = (conf_mat_diag + eps) / (denominator + eps)\n    return ious",
        "mutated": [
            "def mean_iou(pred: torch.Tensor, target: torch.Tensor, num_classes: int, eps: float=1e-06) -> torch.Tensor:\n    if False:\n        i = 10\n    'Calculate mean Intersection-Over-Union (mIOU).\\n\\n    The function internally computes the confusion matrix.\\n\\n    Args:\\n        pred : tensor with estimated targets returned by a\\n          classifier. The shape can be :math:`(B, *)` and must contain integer\\n          values between 0 and K-1.\\n        target: tensor with ground truth (correct) target\\n          values. The shape can be :math:`(B, *)` and must contain integer\\n          values between 0 and K-1, where targets are assumed to be provided as\\n          one-hot vectors.\\n        num_classes: total possible number of classes in target.\\n\\n    Returns:\\n        a tensor representing the mean intersection-over union\\n        with shape :math:`(B, K)` where K is the number of classes.\\n\\n    Example:\\n        >>> logits = torch.tensor([[0, 1, 0]])\\n        >>> target = torch.tensor([[0, 1, 0]])\\n        >>> mean_iou(logits, target, num_classes=3)\\n        tensor([[1., 1., 1.]])\\n    '\n    if not torch.is_tensor(pred) and pred.dtype is not torch.int64:\n        raise TypeError(f'Input pred type is not a torch.Tensor with torch.int64 dtype. Got {type(pred)}')\n    if not torch.is_tensor(target) and target.dtype is not torch.int64:\n        raise TypeError(f'Input target type is not a torch.Tensor with torch.int64 dtype. Got {type(target)}')\n    if not pred.shape == target.shape:\n        raise ValueError(f'Inputs pred and target must have the same shape. Got: {pred.shape} and {target.shape}')\n    if not pred.device == target.device:\n        raise ValueError(f'Inputs must be in the same device. Got: {pred.device} - {target.device}')\n    if not isinstance(num_classes, int) or num_classes < 2:\n        raise ValueError(f'The number of classes must be an integer bigger than two. Got: {num_classes}')\n    conf_mat: torch.Tensor = confusion_matrix(pred, target, num_classes)\n    sum_over_row = torch.sum(conf_mat, dim=1)\n    sum_over_col = torch.sum(conf_mat, dim=2)\n    conf_mat_diag = torch.diagonal(conf_mat, dim1=-2, dim2=-1)\n    denominator = sum_over_row + sum_over_col - conf_mat_diag\n    ious = (conf_mat_diag + eps) / (denominator + eps)\n    return ious",
            "def mean_iou(pred: torch.Tensor, target: torch.Tensor, num_classes: int, eps: float=1e-06) -> torch.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Calculate mean Intersection-Over-Union (mIOU).\\n\\n    The function internally computes the confusion matrix.\\n\\n    Args:\\n        pred : tensor with estimated targets returned by a\\n          classifier. The shape can be :math:`(B, *)` and must contain integer\\n          values between 0 and K-1.\\n        target: tensor with ground truth (correct) target\\n          values. The shape can be :math:`(B, *)` and must contain integer\\n          values between 0 and K-1, where targets are assumed to be provided as\\n          one-hot vectors.\\n        num_classes: total possible number of classes in target.\\n\\n    Returns:\\n        a tensor representing the mean intersection-over union\\n        with shape :math:`(B, K)` where K is the number of classes.\\n\\n    Example:\\n        >>> logits = torch.tensor([[0, 1, 0]])\\n        >>> target = torch.tensor([[0, 1, 0]])\\n        >>> mean_iou(logits, target, num_classes=3)\\n        tensor([[1., 1., 1.]])\\n    '\n    if not torch.is_tensor(pred) and pred.dtype is not torch.int64:\n        raise TypeError(f'Input pred type is not a torch.Tensor with torch.int64 dtype. Got {type(pred)}')\n    if not torch.is_tensor(target) and target.dtype is not torch.int64:\n        raise TypeError(f'Input target type is not a torch.Tensor with torch.int64 dtype. Got {type(target)}')\n    if not pred.shape == target.shape:\n        raise ValueError(f'Inputs pred and target must have the same shape. Got: {pred.shape} and {target.shape}')\n    if not pred.device == target.device:\n        raise ValueError(f'Inputs must be in the same device. Got: {pred.device} - {target.device}')\n    if not isinstance(num_classes, int) or num_classes < 2:\n        raise ValueError(f'The number of classes must be an integer bigger than two. Got: {num_classes}')\n    conf_mat: torch.Tensor = confusion_matrix(pred, target, num_classes)\n    sum_over_row = torch.sum(conf_mat, dim=1)\n    sum_over_col = torch.sum(conf_mat, dim=2)\n    conf_mat_diag = torch.diagonal(conf_mat, dim1=-2, dim2=-1)\n    denominator = sum_over_row + sum_over_col - conf_mat_diag\n    ious = (conf_mat_diag + eps) / (denominator + eps)\n    return ious",
            "def mean_iou(pred: torch.Tensor, target: torch.Tensor, num_classes: int, eps: float=1e-06) -> torch.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Calculate mean Intersection-Over-Union (mIOU).\\n\\n    The function internally computes the confusion matrix.\\n\\n    Args:\\n        pred : tensor with estimated targets returned by a\\n          classifier. The shape can be :math:`(B, *)` and must contain integer\\n          values between 0 and K-1.\\n        target: tensor with ground truth (correct) target\\n          values. The shape can be :math:`(B, *)` and must contain integer\\n          values between 0 and K-1, where targets are assumed to be provided as\\n          one-hot vectors.\\n        num_classes: total possible number of classes in target.\\n\\n    Returns:\\n        a tensor representing the mean intersection-over union\\n        with shape :math:`(B, K)` where K is the number of classes.\\n\\n    Example:\\n        >>> logits = torch.tensor([[0, 1, 0]])\\n        >>> target = torch.tensor([[0, 1, 0]])\\n        >>> mean_iou(logits, target, num_classes=3)\\n        tensor([[1., 1., 1.]])\\n    '\n    if not torch.is_tensor(pred) and pred.dtype is not torch.int64:\n        raise TypeError(f'Input pred type is not a torch.Tensor with torch.int64 dtype. Got {type(pred)}')\n    if not torch.is_tensor(target) and target.dtype is not torch.int64:\n        raise TypeError(f'Input target type is not a torch.Tensor with torch.int64 dtype. Got {type(target)}')\n    if not pred.shape == target.shape:\n        raise ValueError(f'Inputs pred and target must have the same shape. Got: {pred.shape} and {target.shape}')\n    if not pred.device == target.device:\n        raise ValueError(f'Inputs must be in the same device. Got: {pred.device} - {target.device}')\n    if not isinstance(num_classes, int) or num_classes < 2:\n        raise ValueError(f'The number of classes must be an integer bigger than two. Got: {num_classes}')\n    conf_mat: torch.Tensor = confusion_matrix(pred, target, num_classes)\n    sum_over_row = torch.sum(conf_mat, dim=1)\n    sum_over_col = torch.sum(conf_mat, dim=2)\n    conf_mat_diag = torch.diagonal(conf_mat, dim1=-2, dim2=-1)\n    denominator = sum_over_row + sum_over_col - conf_mat_diag\n    ious = (conf_mat_diag + eps) / (denominator + eps)\n    return ious",
            "def mean_iou(pred: torch.Tensor, target: torch.Tensor, num_classes: int, eps: float=1e-06) -> torch.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Calculate mean Intersection-Over-Union (mIOU).\\n\\n    The function internally computes the confusion matrix.\\n\\n    Args:\\n        pred : tensor with estimated targets returned by a\\n          classifier. The shape can be :math:`(B, *)` and must contain integer\\n          values between 0 and K-1.\\n        target: tensor with ground truth (correct) target\\n          values. The shape can be :math:`(B, *)` and must contain integer\\n          values between 0 and K-1, where targets are assumed to be provided as\\n          one-hot vectors.\\n        num_classes: total possible number of classes in target.\\n\\n    Returns:\\n        a tensor representing the mean intersection-over union\\n        with shape :math:`(B, K)` where K is the number of classes.\\n\\n    Example:\\n        >>> logits = torch.tensor([[0, 1, 0]])\\n        >>> target = torch.tensor([[0, 1, 0]])\\n        >>> mean_iou(logits, target, num_classes=3)\\n        tensor([[1., 1., 1.]])\\n    '\n    if not torch.is_tensor(pred) and pred.dtype is not torch.int64:\n        raise TypeError(f'Input pred type is not a torch.Tensor with torch.int64 dtype. Got {type(pred)}')\n    if not torch.is_tensor(target) and target.dtype is not torch.int64:\n        raise TypeError(f'Input target type is not a torch.Tensor with torch.int64 dtype. Got {type(target)}')\n    if not pred.shape == target.shape:\n        raise ValueError(f'Inputs pred and target must have the same shape. Got: {pred.shape} and {target.shape}')\n    if not pred.device == target.device:\n        raise ValueError(f'Inputs must be in the same device. Got: {pred.device} - {target.device}')\n    if not isinstance(num_classes, int) or num_classes < 2:\n        raise ValueError(f'The number of classes must be an integer bigger than two. Got: {num_classes}')\n    conf_mat: torch.Tensor = confusion_matrix(pred, target, num_classes)\n    sum_over_row = torch.sum(conf_mat, dim=1)\n    sum_over_col = torch.sum(conf_mat, dim=2)\n    conf_mat_diag = torch.diagonal(conf_mat, dim1=-2, dim2=-1)\n    denominator = sum_over_row + sum_over_col - conf_mat_diag\n    ious = (conf_mat_diag + eps) / (denominator + eps)\n    return ious",
            "def mean_iou(pred: torch.Tensor, target: torch.Tensor, num_classes: int, eps: float=1e-06) -> torch.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Calculate mean Intersection-Over-Union (mIOU).\\n\\n    The function internally computes the confusion matrix.\\n\\n    Args:\\n        pred : tensor with estimated targets returned by a\\n          classifier. The shape can be :math:`(B, *)` and must contain integer\\n          values between 0 and K-1.\\n        target: tensor with ground truth (correct) target\\n          values. The shape can be :math:`(B, *)` and must contain integer\\n          values between 0 and K-1, where targets are assumed to be provided as\\n          one-hot vectors.\\n        num_classes: total possible number of classes in target.\\n\\n    Returns:\\n        a tensor representing the mean intersection-over union\\n        with shape :math:`(B, K)` where K is the number of classes.\\n\\n    Example:\\n        >>> logits = torch.tensor([[0, 1, 0]])\\n        >>> target = torch.tensor([[0, 1, 0]])\\n        >>> mean_iou(logits, target, num_classes=3)\\n        tensor([[1., 1., 1.]])\\n    '\n    if not torch.is_tensor(pred) and pred.dtype is not torch.int64:\n        raise TypeError(f'Input pred type is not a torch.Tensor with torch.int64 dtype. Got {type(pred)}')\n    if not torch.is_tensor(target) and target.dtype is not torch.int64:\n        raise TypeError(f'Input target type is not a torch.Tensor with torch.int64 dtype. Got {type(target)}')\n    if not pred.shape == target.shape:\n        raise ValueError(f'Inputs pred and target must have the same shape. Got: {pred.shape} and {target.shape}')\n    if not pred.device == target.device:\n        raise ValueError(f'Inputs must be in the same device. Got: {pred.device} - {target.device}')\n    if not isinstance(num_classes, int) or num_classes < 2:\n        raise ValueError(f'The number of classes must be an integer bigger than two. Got: {num_classes}')\n    conf_mat: torch.Tensor = confusion_matrix(pred, target, num_classes)\n    sum_over_row = torch.sum(conf_mat, dim=1)\n    sum_over_col = torch.sum(conf_mat, dim=2)\n    conf_mat_diag = torch.diagonal(conf_mat, dim1=-2, dim2=-1)\n    denominator = sum_over_row + sum_over_col - conf_mat_diag\n    ious = (conf_mat_diag + eps) / (denominator + eps)\n    return ious"
        ]
    },
    {
        "func_name": "mean_iou_bbox",
        "original": "def mean_iou_bbox(boxes_1: torch.Tensor, boxes_2: torch.Tensor) -> torch.Tensor:\n    \"\"\"Compute the IoU of the cartesian product of two sets of boxes.\n\n    Each box in each set shall be (x1, y1, x2, y2).\n\n    Args:\n        boxes_1: a tensor of bounding boxes in :math:`(B1, 4)`.\n        boxes_2: a tensor of bounding boxes in :math:`(B2, 4)`.\n\n    Returns:\n        a tensor in dimensions :math:`(B1, B2)`, representing the\n        intersection of each of the boxes in set 1 with respect to each of the boxes in set 2.\n\n    Example:\n        >>> boxes_1 = torch.tensor([[40, 40, 60, 60], [30, 40, 50, 60]])\n        >>> boxes_2 = torch.tensor([[40, 50, 60, 70], [30, 40, 40, 50]])\n        >>> mean_iou_bbox(boxes_1, boxes_2)\n        tensor([[0.3333, 0.0000],\n                [0.1429, 0.2500]])\n    \"\"\"\n    if not ((boxes_1[:, 2] - boxes_1[:, 0] > 0).all() or (boxes_1[:, 3] - boxes_1[:, 1] > 0).all()):\n        raise AssertionError('Boxes_1 does not follow (x1, y1, x2, y2) format.')\n    if not ((boxes_2[:, 2] - boxes_2[:, 0] > 0).all() or (boxes_2[:, 3] - boxes_2[:, 1] > 0).all()):\n        raise AssertionError('Boxes_2 does not follow (x1, y1, x2, y2) format.')\n    lower_bounds = torch.max(boxes_1[:, :2].unsqueeze(1), boxes_2[:, :2].unsqueeze(0))\n    upper_bounds = torch.min(boxes_1[:, 2:].unsqueeze(1), boxes_2[:, 2:].unsqueeze(0))\n    intersection_dims = torch.clamp(upper_bounds - lower_bounds, min=0)\n    intersection = intersection_dims[:, :, 0] * intersection_dims[:, :, 1]\n    areas_set_1 = (boxes_1[:, 2] - boxes_1[:, 0]) * (boxes_1[:, 3] - boxes_1[:, 1])\n    areas_set_2 = (boxes_2[:, 2] - boxes_2[:, 0]) * (boxes_2[:, 3] - boxes_2[:, 1])\n    union = areas_set_1.unsqueeze(1) + areas_set_2.unsqueeze(0) - intersection\n    return intersection / union",
        "mutated": [
            "def mean_iou_bbox(boxes_1: torch.Tensor, boxes_2: torch.Tensor) -> torch.Tensor:\n    if False:\n        i = 10\n    'Compute the IoU of the cartesian product of two sets of boxes.\\n\\n    Each box in each set shall be (x1, y1, x2, y2).\\n\\n    Args:\\n        boxes_1: a tensor of bounding boxes in :math:`(B1, 4)`.\\n        boxes_2: a tensor of bounding boxes in :math:`(B2, 4)`.\\n\\n    Returns:\\n        a tensor in dimensions :math:`(B1, B2)`, representing the\\n        intersection of each of the boxes in set 1 with respect to each of the boxes in set 2.\\n\\n    Example:\\n        >>> boxes_1 = torch.tensor([[40, 40, 60, 60], [30, 40, 50, 60]])\\n        >>> boxes_2 = torch.tensor([[40, 50, 60, 70], [30, 40, 40, 50]])\\n        >>> mean_iou_bbox(boxes_1, boxes_2)\\n        tensor([[0.3333, 0.0000],\\n                [0.1429, 0.2500]])\\n    '\n    if not ((boxes_1[:, 2] - boxes_1[:, 0] > 0).all() or (boxes_1[:, 3] - boxes_1[:, 1] > 0).all()):\n        raise AssertionError('Boxes_1 does not follow (x1, y1, x2, y2) format.')\n    if not ((boxes_2[:, 2] - boxes_2[:, 0] > 0).all() or (boxes_2[:, 3] - boxes_2[:, 1] > 0).all()):\n        raise AssertionError('Boxes_2 does not follow (x1, y1, x2, y2) format.')\n    lower_bounds = torch.max(boxes_1[:, :2].unsqueeze(1), boxes_2[:, :2].unsqueeze(0))\n    upper_bounds = torch.min(boxes_1[:, 2:].unsqueeze(1), boxes_2[:, 2:].unsqueeze(0))\n    intersection_dims = torch.clamp(upper_bounds - lower_bounds, min=0)\n    intersection = intersection_dims[:, :, 0] * intersection_dims[:, :, 1]\n    areas_set_1 = (boxes_1[:, 2] - boxes_1[:, 0]) * (boxes_1[:, 3] - boxes_1[:, 1])\n    areas_set_2 = (boxes_2[:, 2] - boxes_2[:, 0]) * (boxes_2[:, 3] - boxes_2[:, 1])\n    union = areas_set_1.unsqueeze(1) + areas_set_2.unsqueeze(0) - intersection\n    return intersection / union",
            "def mean_iou_bbox(boxes_1: torch.Tensor, boxes_2: torch.Tensor) -> torch.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Compute the IoU of the cartesian product of two sets of boxes.\\n\\n    Each box in each set shall be (x1, y1, x2, y2).\\n\\n    Args:\\n        boxes_1: a tensor of bounding boxes in :math:`(B1, 4)`.\\n        boxes_2: a tensor of bounding boxes in :math:`(B2, 4)`.\\n\\n    Returns:\\n        a tensor in dimensions :math:`(B1, B2)`, representing the\\n        intersection of each of the boxes in set 1 with respect to each of the boxes in set 2.\\n\\n    Example:\\n        >>> boxes_1 = torch.tensor([[40, 40, 60, 60], [30, 40, 50, 60]])\\n        >>> boxes_2 = torch.tensor([[40, 50, 60, 70], [30, 40, 40, 50]])\\n        >>> mean_iou_bbox(boxes_1, boxes_2)\\n        tensor([[0.3333, 0.0000],\\n                [0.1429, 0.2500]])\\n    '\n    if not ((boxes_1[:, 2] - boxes_1[:, 0] > 0).all() or (boxes_1[:, 3] - boxes_1[:, 1] > 0).all()):\n        raise AssertionError('Boxes_1 does not follow (x1, y1, x2, y2) format.')\n    if not ((boxes_2[:, 2] - boxes_2[:, 0] > 0).all() or (boxes_2[:, 3] - boxes_2[:, 1] > 0).all()):\n        raise AssertionError('Boxes_2 does not follow (x1, y1, x2, y2) format.')\n    lower_bounds = torch.max(boxes_1[:, :2].unsqueeze(1), boxes_2[:, :2].unsqueeze(0))\n    upper_bounds = torch.min(boxes_1[:, 2:].unsqueeze(1), boxes_2[:, 2:].unsqueeze(0))\n    intersection_dims = torch.clamp(upper_bounds - lower_bounds, min=0)\n    intersection = intersection_dims[:, :, 0] * intersection_dims[:, :, 1]\n    areas_set_1 = (boxes_1[:, 2] - boxes_1[:, 0]) * (boxes_1[:, 3] - boxes_1[:, 1])\n    areas_set_2 = (boxes_2[:, 2] - boxes_2[:, 0]) * (boxes_2[:, 3] - boxes_2[:, 1])\n    union = areas_set_1.unsqueeze(1) + areas_set_2.unsqueeze(0) - intersection\n    return intersection / union",
            "def mean_iou_bbox(boxes_1: torch.Tensor, boxes_2: torch.Tensor) -> torch.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Compute the IoU of the cartesian product of two sets of boxes.\\n\\n    Each box in each set shall be (x1, y1, x2, y2).\\n\\n    Args:\\n        boxes_1: a tensor of bounding boxes in :math:`(B1, 4)`.\\n        boxes_2: a tensor of bounding boxes in :math:`(B2, 4)`.\\n\\n    Returns:\\n        a tensor in dimensions :math:`(B1, B2)`, representing the\\n        intersection of each of the boxes in set 1 with respect to each of the boxes in set 2.\\n\\n    Example:\\n        >>> boxes_1 = torch.tensor([[40, 40, 60, 60], [30, 40, 50, 60]])\\n        >>> boxes_2 = torch.tensor([[40, 50, 60, 70], [30, 40, 40, 50]])\\n        >>> mean_iou_bbox(boxes_1, boxes_2)\\n        tensor([[0.3333, 0.0000],\\n                [0.1429, 0.2500]])\\n    '\n    if not ((boxes_1[:, 2] - boxes_1[:, 0] > 0).all() or (boxes_1[:, 3] - boxes_1[:, 1] > 0).all()):\n        raise AssertionError('Boxes_1 does not follow (x1, y1, x2, y2) format.')\n    if not ((boxes_2[:, 2] - boxes_2[:, 0] > 0).all() or (boxes_2[:, 3] - boxes_2[:, 1] > 0).all()):\n        raise AssertionError('Boxes_2 does not follow (x1, y1, x2, y2) format.')\n    lower_bounds = torch.max(boxes_1[:, :2].unsqueeze(1), boxes_2[:, :2].unsqueeze(0))\n    upper_bounds = torch.min(boxes_1[:, 2:].unsqueeze(1), boxes_2[:, 2:].unsqueeze(0))\n    intersection_dims = torch.clamp(upper_bounds - lower_bounds, min=0)\n    intersection = intersection_dims[:, :, 0] * intersection_dims[:, :, 1]\n    areas_set_1 = (boxes_1[:, 2] - boxes_1[:, 0]) * (boxes_1[:, 3] - boxes_1[:, 1])\n    areas_set_2 = (boxes_2[:, 2] - boxes_2[:, 0]) * (boxes_2[:, 3] - boxes_2[:, 1])\n    union = areas_set_1.unsqueeze(1) + areas_set_2.unsqueeze(0) - intersection\n    return intersection / union",
            "def mean_iou_bbox(boxes_1: torch.Tensor, boxes_2: torch.Tensor) -> torch.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Compute the IoU of the cartesian product of two sets of boxes.\\n\\n    Each box in each set shall be (x1, y1, x2, y2).\\n\\n    Args:\\n        boxes_1: a tensor of bounding boxes in :math:`(B1, 4)`.\\n        boxes_2: a tensor of bounding boxes in :math:`(B2, 4)`.\\n\\n    Returns:\\n        a tensor in dimensions :math:`(B1, B2)`, representing the\\n        intersection of each of the boxes in set 1 with respect to each of the boxes in set 2.\\n\\n    Example:\\n        >>> boxes_1 = torch.tensor([[40, 40, 60, 60], [30, 40, 50, 60]])\\n        >>> boxes_2 = torch.tensor([[40, 50, 60, 70], [30, 40, 40, 50]])\\n        >>> mean_iou_bbox(boxes_1, boxes_2)\\n        tensor([[0.3333, 0.0000],\\n                [0.1429, 0.2500]])\\n    '\n    if not ((boxes_1[:, 2] - boxes_1[:, 0] > 0).all() or (boxes_1[:, 3] - boxes_1[:, 1] > 0).all()):\n        raise AssertionError('Boxes_1 does not follow (x1, y1, x2, y2) format.')\n    if not ((boxes_2[:, 2] - boxes_2[:, 0] > 0).all() or (boxes_2[:, 3] - boxes_2[:, 1] > 0).all()):\n        raise AssertionError('Boxes_2 does not follow (x1, y1, x2, y2) format.')\n    lower_bounds = torch.max(boxes_1[:, :2].unsqueeze(1), boxes_2[:, :2].unsqueeze(0))\n    upper_bounds = torch.min(boxes_1[:, 2:].unsqueeze(1), boxes_2[:, 2:].unsqueeze(0))\n    intersection_dims = torch.clamp(upper_bounds - lower_bounds, min=0)\n    intersection = intersection_dims[:, :, 0] * intersection_dims[:, :, 1]\n    areas_set_1 = (boxes_1[:, 2] - boxes_1[:, 0]) * (boxes_1[:, 3] - boxes_1[:, 1])\n    areas_set_2 = (boxes_2[:, 2] - boxes_2[:, 0]) * (boxes_2[:, 3] - boxes_2[:, 1])\n    union = areas_set_1.unsqueeze(1) + areas_set_2.unsqueeze(0) - intersection\n    return intersection / union",
            "def mean_iou_bbox(boxes_1: torch.Tensor, boxes_2: torch.Tensor) -> torch.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Compute the IoU of the cartesian product of two sets of boxes.\\n\\n    Each box in each set shall be (x1, y1, x2, y2).\\n\\n    Args:\\n        boxes_1: a tensor of bounding boxes in :math:`(B1, 4)`.\\n        boxes_2: a tensor of bounding boxes in :math:`(B2, 4)`.\\n\\n    Returns:\\n        a tensor in dimensions :math:`(B1, B2)`, representing the\\n        intersection of each of the boxes in set 1 with respect to each of the boxes in set 2.\\n\\n    Example:\\n        >>> boxes_1 = torch.tensor([[40, 40, 60, 60], [30, 40, 50, 60]])\\n        >>> boxes_2 = torch.tensor([[40, 50, 60, 70], [30, 40, 40, 50]])\\n        >>> mean_iou_bbox(boxes_1, boxes_2)\\n        tensor([[0.3333, 0.0000],\\n                [0.1429, 0.2500]])\\n    '\n    if not ((boxes_1[:, 2] - boxes_1[:, 0] > 0).all() or (boxes_1[:, 3] - boxes_1[:, 1] > 0).all()):\n        raise AssertionError('Boxes_1 does not follow (x1, y1, x2, y2) format.')\n    if not ((boxes_2[:, 2] - boxes_2[:, 0] > 0).all() or (boxes_2[:, 3] - boxes_2[:, 1] > 0).all()):\n        raise AssertionError('Boxes_2 does not follow (x1, y1, x2, y2) format.')\n    lower_bounds = torch.max(boxes_1[:, :2].unsqueeze(1), boxes_2[:, :2].unsqueeze(0))\n    upper_bounds = torch.min(boxes_1[:, 2:].unsqueeze(1), boxes_2[:, 2:].unsqueeze(0))\n    intersection_dims = torch.clamp(upper_bounds - lower_bounds, min=0)\n    intersection = intersection_dims[:, :, 0] * intersection_dims[:, :, 1]\n    areas_set_1 = (boxes_1[:, 2] - boxes_1[:, 0]) * (boxes_1[:, 3] - boxes_1[:, 1])\n    areas_set_2 = (boxes_2[:, 2] - boxes_2[:, 0]) * (boxes_2[:, 3] - boxes_2[:, 1])\n    union = areas_set_1.unsqueeze(1) + areas_set_2.unsqueeze(0) - intersection\n    return intersection / union"
        ]
    }
]