[
    {
        "func_name": "get_ufunc_info",
        "original": "def get_ufunc_info(ufunc_key):\n    return ufunc_db()[ufunc_key]",
        "mutated": [
            "def get_ufunc_info(ufunc_key):\n    if False:\n        i = 10\n    return ufunc_db()[ufunc_key]",
            "def get_ufunc_info(ufunc_key):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return ufunc_db()[ufunc_key]",
            "def get_ufunc_info(ufunc_key):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return ufunc_db()[ufunc_key]",
            "def get_ufunc_info(ufunc_key):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return ufunc_db()[ufunc_key]",
            "def get_ufunc_info(ufunc_key):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return ufunc_db()[ufunc_key]"
        ]
    },
    {
        "func_name": "np_unary_impl",
        "original": "def np_unary_impl(fn, context, builder, sig, args):\n    npyfuncs._check_arity_and_homogeneity(sig, args, 1)\n    impl = get_unary_impl_for_fn_and_ty(fn, sig.args[0])\n    return impl(context, builder, sig, args)",
        "mutated": [
            "def np_unary_impl(fn, context, builder, sig, args):\n    if False:\n        i = 10\n    npyfuncs._check_arity_and_homogeneity(sig, args, 1)\n    impl = get_unary_impl_for_fn_and_ty(fn, sig.args[0])\n    return impl(context, builder, sig, args)",
            "def np_unary_impl(fn, context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    npyfuncs._check_arity_and_homogeneity(sig, args, 1)\n    impl = get_unary_impl_for_fn_and_ty(fn, sig.args[0])\n    return impl(context, builder, sig, args)",
            "def np_unary_impl(fn, context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    npyfuncs._check_arity_and_homogeneity(sig, args, 1)\n    impl = get_unary_impl_for_fn_and_ty(fn, sig.args[0])\n    return impl(context, builder, sig, args)",
            "def np_unary_impl(fn, context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    npyfuncs._check_arity_and_homogeneity(sig, args, 1)\n    impl = get_unary_impl_for_fn_and_ty(fn, sig.args[0])\n    return impl(context, builder, sig, args)",
            "def np_unary_impl(fn, context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    npyfuncs._check_arity_and_homogeneity(sig, args, 1)\n    impl = get_unary_impl_for_fn_and_ty(fn, sig.args[0])\n    return impl(context, builder, sig, args)"
        ]
    },
    {
        "func_name": "np_binary_impl",
        "original": "def np_binary_impl(fn, context, builder, sig, args):\n    npyfuncs._check_arity_and_homogeneity(sig, args, 2)\n    impl = get_binary_impl_for_fn_and_ty(fn, sig.args[0])\n    return impl(context, builder, sig, args)",
        "mutated": [
            "def np_binary_impl(fn, context, builder, sig, args):\n    if False:\n        i = 10\n    npyfuncs._check_arity_and_homogeneity(sig, args, 2)\n    impl = get_binary_impl_for_fn_and_ty(fn, sig.args[0])\n    return impl(context, builder, sig, args)",
            "def np_binary_impl(fn, context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    npyfuncs._check_arity_and_homogeneity(sig, args, 2)\n    impl = get_binary_impl_for_fn_and_ty(fn, sig.args[0])\n    return impl(context, builder, sig, args)",
            "def np_binary_impl(fn, context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    npyfuncs._check_arity_and_homogeneity(sig, args, 2)\n    impl = get_binary_impl_for_fn_and_ty(fn, sig.args[0])\n    return impl(context, builder, sig, args)",
            "def np_binary_impl(fn, context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    npyfuncs._check_arity_and_homogeneity(sig, args, 2)\n    impl = get_binary_impl_for_fn_and_ty(fn, sig.args[0])\n    return impl(context, builder, sig, args)",
            "def np_binary_impl(fn, context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    npyfuncs._check_arity_and_homogeneity(sig, args, 2)\n    impl = get_binary_impl_for_fn_and_ty(fn, sig.args[0])\n    return impl(context, builder, sig, args)"
        ]
    },
    {
        "func_name": "np_real_sin_impl",
        "original": "def np_real_sin_impl(context, builder, sig, args):\n    return np_unary_impl(math.sin, context, builder, sig, args)",
        "mutated": [
            "def np_real_sin_impl(context, builder, sig, args):\n    if False:\n        i = 10\n    return np_unary_impl(math.sin, context, builder, sig, args)",
            "def np_real_sin_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return np_unary_impl(math.sin, context, builder, sig, args)",
            "def np_real_sin_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return np_unary_impl(math.sin, context, builder, sig, args)",
            "def np_real_sin_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return np_unary_impl(math.sin, context, builder, sig, args)",
            "def np_real_sin_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return np_unary_impl(math.sin, context, builder, sig, args)"
        ]
    },
    {
        "func_name": "np_real_cos_impl",
        "original": "def np_real_cos_impl(context, builder, sig, args):\n    return np_unary_impl(math.cos, context, builder, sig, args)",
        "mutated": [
            "def np_real_cos_impl(context, builder, sig, args):\n    if False:\n        i = 10\n    return np_unary_impl(math.cos, context, builder, sig, args)",
            "def np_real_cos_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return np_unary_impl(math.cos, context, builder, sig, args)",
            "def np_real_cos_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return np_unary_impl(math.cos, context, builder, sig, args)",
            "def np_real_cos_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return np_unary_impl(math.cos, context, builder, sig, args)",
            "def np_real_cos_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return np_unary_impl(math.cos, context, builder, sig, args)"
        ]
    },
    {
        "func_name": "np_real_tan_impl",
        "original": "def np_real_tan_impl(context, builder, sig, args):\n    return np_unary_impl(math.tan, context, builder, sig, args)",
        "mutated": [
            "def np_real_tan_impl(context, builder, sig, args):\n    if False:\n        i = 10\n    return np_unary_impl(math.tan, context, builder, sig, args)",
            "def np_real_tan_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return np_unary_impl(math.tan, context, builder, sig, args)",
            "def np_real_tan_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return np_unary_impl(math.tan, context, builder, sig, args)",
            "def np_real_tan_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return np_unary_impl(math.tan, context, builder, sig, args)",
            "def np_real_tan_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return np_unary_impl(math.tan, context, builder, sig, args)"
        ]
    },
    {
        "func_name": "np_real_asin_impl",
        "original": "def np_real_asin_impl(context, builder, sig, args):\n    return np_unary_impl(math.asin, context, builder, sig, args)",
        "mutated": [
            "def np_real_asin_impl(context, builder, sig, args):\n    if False:\n        i = 10\n    return np_unary_impl(math.asin, context, builder, sig, args)",
            "def np_real_asin_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return np_unary_impl(math.asin, context, builder, sig, args)",
            "def np_real_asin_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return np_unary_impl(math.asin, context, builder, sig, args)",
            "def np_real_asin_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return np_unary_impl(math.asin, context, builder, sig, args)",
            "def np_real_asin_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return np_unary_impl(math.asin, context, builder, sig, args)"
        ]
    },
    {
        "func_name": "np_real_acos_impl",
        "original": "def np_real_acos_impl(context, builder, sig, args):\n    return np_unary_impl(math.acos, context, builder, sig, args)",
        "mutated": [
            "def np_real_acos_impl(context, builder, sig, args):\n    if False:\n        i = 10\n    return np_unary_impl(math.acos, context, builder, sig, args)",
            "def np_real_acos_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return np_unary_impl(math.acos, context, builder, sig, args)",
            "def np_real_acos_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return np_unary_impl(math.acos, context, builder, sig, args)",
            "def np_real_acos_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return np_unary_impl(math.acos, context, builder, sig, args)",
            "def np_real_acos_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return np_unary_impl(math.acos, context, builder, sig, args)"
        ]
    },
    {
        "func_name": "np_real_atan_impl",
        "original": "def np_real_atan_impl(context, builder, sig, args):\n    return np_unary_impl(math.atan, context, builder, sig, args)",
        "mutated": [
            "def np_real_atan_impl(context, builder, sig, args):\n    if False:\n        i = 10\n    return np_unary_impl(math.atan, context, builder, sig, args)",
            "def np_real_atan_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return np_unary_impl(math.atan, context, builder, sig, args)",
            "def np_real_atan_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return np_unary_impl(math.atan, context, builder, sig, args)",
            "def np_real_atan_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return np_unary_impl(math.atan, context, builder, sig, args)",
            "def np_real_atan_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return np_unary_impl(math.atan, context, builder, sig, args)"
        ]
    },
    {
        "func_name": "np_real_atan2_impl",
        "original": "def np_real_atan2_impl(context, builder, sig, args):\n    return np_binary_impl(math.atan2, context, builder, sig, args)",
        "mutated": [
            "def np_real_atan2_impl(context, builder, sig, args):\n    if False:\n        i = 10\n    return np_binary_impl(math.atan2, context, builder, sig, args)",
            "def np_real_atan2_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return np_binary_impl(math.atan2, context, builder, sig, args)",
            "def np_real_atan2_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return np_binary_impl(math.atan2, context, builder, sig, args)",
            "def np_real_atan2_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return np_binary_impl(math.atan2, context, builder, sig, args)",
            "def np_real_atan2_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return np_binary_impl(math.atan2, context, builder, sig, args)"
        ]
    },
    {
        "func_name": "np_real_hypot_impl",
        "original": "def np_real_hypot_impl(context, builder, sig, args):\n    return np_binary_impl(math.hypot, context, builder, sig, args)",
        "mutated": [
            "def np_real_hypot_impl(context, builder, sig, args):\n    if False:\n        i = 10\n    return np_binary_impl(math.hypot, context, builder, sig, args)",
            "def np_real_hypot_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return np_binary_impl(math.hypot, context, builder, sig, args)",
            "def np_real_hypot_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return np_binary_impl(math.hypot, context, builder, sig, args)",
            "def np_real_hypot_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return np_binary_impl(math.hypot, context, builder, sig, args)",
            "def np_real_hypot_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return np_binary_impl(math.hypot, context, builder, sig, args)"
        ]
    },
    {
        "func_name": "np_real_sinh_impl",
        "original": "def np_real_sinh_impl(context, builder, sig, args):\n    return np_unary_impl(math.sinh, context, builder, sig, args)",
        "mutated": [
            "def np_real_sinh_impl(context, builder, sig, args):\n    if False:\n        i = 10\n    return np_unary_impl(math.sinh, context, builder, sig, args)",
            "def np_real_sinh_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return np_unary_impl(math.sinh, context, builder, sig, args)",
            "def np_real_sinh_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return np_unary_impl(math.sinh, context, builder, sig, args)",
            "def np_real_sinh_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return np_unary_impl(math.sinh, context, builder, sig, args)",
            "def np_real_sinh_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return np_unary_impl(math.sinh, context, builder, sig, args)"
        ]
    },
    {
        "func_name": "np_complex_sinh_impl",
        "original": "def np_complex_sinh_impl(context, builder, sig, args):\n    npyfuncs._check_arity_and_homogeneity(sig, args, 1)\n    ty = sig.args[0]\n    fty = ty.underlying_float\n    fsig1 = typing.signature(*[fty] * 2)\n    x = context.make_complex(builder, ty, args[0])\n    out = context.make_complex(builder, ty)\n    xr = x.real\n    xi = x.imag\n    sxi = np_real_sin_impl(context, builder, fsig1, [xi])\n    shxr = np_real_sinh_impl(context, builder, fsig1, [xr])\n    cxi = np_real_cos_impl(context, builder, fsig1, [xi])\n    chxr = np_real_cosh_impl(context, builder, fsig1, [xr])\n    out.real = builder.fmul(cxi, shxr)\n    out.imag = builder.fmul(sxi, chxr)\n    return out._getvalue()",
        "mutated": [
            "def np_complex_sinh_impl(context, builder, sig, args):\n    if False:\n        i = 10\n    npyfuncs._check_arity_and_homogeneity(sig, args, 1)\n    ty = sig.args[0]\n    fty = ty.underlying_float\n    fsig1 = typing.signature(*[fty] * 2)\n    x = context.make_complex(builder, ty, args[0])\n    out = context.make_complex(builder, ty)\n    xr = x.real\n    xi = x.imag\n    sxi = np_real_sin_impl(context, builder, fsig1, [xi])\n    shxr = np_real_sinh_impl(context, builder, fsig1, [xr])\n    cxi = np_real_cos_impl(context, builder, fsig1, [xi])\n    chxr = np_real_cosh_impl(context, builder, fsig1, [xr])\n    out.real = builder.fmul(cxi, shxr)\n    out.imag = builder.fmul(sxi, chxr)\n    return out._getvalue()",
            "def np_complex_sinh_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    npyfuncs._check_arity_and_homogeneity(sig, args, 1)\n    ty = sig.args[0]\n    fty = ty.underlying_float\n    fsig1 = typing.signature(*[fty] * 2)\n    x = context.make_complex(builder, ty, args[0])\n    out = context.make_complex(builder, ty)\n    xr = x.real\n    xi = x.imag\n    sxi = np_real_sin_impl(context, builder, fsig1, [xi])\n    shxr = np_real_sinh_impl(context, builder, fsig1, [xr])\n    cxi = np_real_cos_impl(context, builder, fsig1, [xi])\n    chxr = np_real_cosh_impl(context, builder, fsig1, [xr])\n    out.real = builder.fmul(cxi, shxr)\n    out.imag = builder.fmul(sxi, chxr)\n    return out._getvalue()",
            "def np_complex_sinh_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    npyfuncs._check_arity_and_homogeneity(sig, args, 1)\n    ty = sig.args[0]\n    fty = ty.underlying_float\n    fsig1 = typing.signature(*[fty] * 2)\n    x = context.make_complex(builder, ty, args[0])\n    out = context.make_complex(builder, ty)\n    xr = x.real\n    xi = x.imag\n    sxi = np_real_sin_impl(context, builder, fsig1, [xi])\n    shxr = np_real_sinh_impl(context, builder, fsig1, [xr])\n    cxi = np_real_cos_impl(context, builder, fsig1, [xi])\n    chxr = np_real_cosh_impl(context, builder, fsig1, [xr])\n    out.real = builder.fmul(cxi, shxr)\n    out.imag = builder.fmul(sxi, chxr)\n    return out._getvalue()",
            "def np_complex_sinh_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    npyfuncs._check_arity_and_homogeneity(sig, args, 1)\n    ty = sig.args[0]\n    fty = ty.underlying_float\n    fsig1 = typing.signature(*[fty] * 2)\n    x = context.make_complex(builder, ty, args[0])\n    out = context.make_complex(builder, ty)\n    xr = x.real\n    xi = x.imag\n    sxi = np_real_sin_impl(context, builder, fsig1, [xi])\n    shxr = np_real_sinh_impl(context, builder, fsig1, [xr])\n    cxi = np_real_cos_impl(context, builder, fsig1, [xi])\n    chxr = np_real_cosh_impl(context, builder, fsig1, [xr])\n    out.real = builder.fmul(cxi, shxr)\n    out.imag = builder.fmul(sxi, chxr)\n    return out._getvalue()",
            "def np_complex_sinh_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    npyfuncs._check_arity_and_homogeneity(sig, args, 1)\n    ty = sig.args[0]\n    fty = ty.underlying_float\n    fsig1 = typing.signature(*[fty] * 2)\n    x = context.make_complex(builder, ty, args[0])\n    out = context.make_complex(builder, ty)\n    xr = x.real\n    xi = x.imag\n    sxi = np_real_sin_impl(context, builder, fsig1, [xi])\n    shxr = np_real_sinh_impl(context, builder, fsig1, [xr])\n    cxi = np_real_cos_impl(context, builder, fsig1, [xi])\n    chxr = np_real_cosh_impl(context, builder, fsig1, [xr])\n    out.real = builder.fmul(cxi, shxr)\n    out.imag = builder.fmul(sxi, chxr)\n    return out._getvalue()"
        ]
    },
    {
        "func_name": "np_real_cosh_impl",
        "original": "def np_real_cosh_impl(context, builder, sig, args):\n    return np_unary_impl(math.cosh, context, builder, sig, args)",
        "mutated": [
            "def np_real_cosh_impl(context, builder, sig, args):\n    if False:\n        i = 10\n    return np_unary_impl(math.cosh, context, builder, sig, args)",
            "def np_real_cosh_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return np_unary_impl(math.cosh, context, builder, sig, args)",
            "def np_real_cosh_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return np_unary_impl(math.cosh, context, builder, sig, args)",
            "def np_real_cosh_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return np_unary_impl(math.cosh, context, builder, sig, args)",
            "def np_real_cosh_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return np_unary_impl(math.cosh, context, builder, sig, args)"
        ]
    },
    {
        "func_name": "np_complex_cosh_impl",
        "original": "def np_complex_cosh_impl(context, builder, sig, args):\n    npyfuncs._check_arity_and_homogeneity(sig, args, 1)\n    ty = sig.args[0]\n    fty = ty.underlying_float\n    fsig1 = typing.signature(*[fty] * 2)\n    x = context.make_complex(builder, ty, args[0])\n    out = context.make_complex(builder, ty)\n    xr = x.real\n    xi = x.imag\n    cxi = np_real_cos_impl(context, builder, fsig1, [xi])\n    chxr = np_real_cosh_impl(context, builder, fsig1, [xr])\n    sxi = np_real_sin_impl(context, builder, fsig1, [xi])\n    shxr = np_real_sinh_impl(context, builder, fsig1, [xr])\n    out.real = builder.fmul(cxi, chxr)\n    out.imag = builder.fmul(sxi, shxr)\n    return out._getvalue()",
        "mutated": [
            "def np_complex_cosh_impl(context, builder, sig, args):\n    if False:\n        i = 10\n    npyfuncs._check_arity_and_homogeneity(sig, args, 1)\n    ty = sig.args[0]\n    fty = ty.underlying_float\n    fsig1 = typing.signature(*[fty] * 2)\n    x = context.make_complex(builder, ty, args[0])\n    out = context.make_complex(builder, ty)\n    xr = x.real\n    xi = x.imag\n    cxi = np_real_cos_impl(context, builder, fsig1, [xi])\n    chxr = np_real_cosh_impl(context, builder, fsig1, [xr])\n    sxi = np_real_sin_impl(context, builder, fsig1, [xi])\n    shxr = np_real_sinh_impl(context, builder, fsig1, [xr])\n    out.real = builder.fmul(cxi, chxr)\n    out.imag = builder.fmul(sxi, shxr)\n    return out._getvalue()",
            "def np_complex_cosh_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    npyfuncs._check_arity_and_homogeneity(sig, args, 1)\n    ty = sig.args[0]\n    fty = ty.underlying_float\n    fsig1 = typing.signature(*[fty] * 2)\n    x = context.make_complex(builder, ty, args[0])\n    out = context.make_complex(builder, ty)\n    xr = x.real\n    xi = x.imag\n    cxi = np_real_cos_impl(context, builder, fsig1, [xi])\n    chxr = np_real_cosh_impl(context, builder, fsig1, [xr])\n    sxi = np_real_sin_impl(context, builder, fsig1, [xi])\n    shxr = np_real_sinh_impl(context, builder, fsig1, [xr])\n    out.real = builder.fmul(cxi, chxr)\n    out.imag = builder.fmul(sxi, shxr)\n    return out._getvalue()",
            "def np_complex_cosh_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    npyfuncs._check_arity_and_homogeneity(sig, args, 1)\n    ty = sig.args[0]\n    fty = ty.underlying_float\n    fsig1 = typing.signature(*[fty] * 2)\n    x = context.make_complex(builder, ty, args[0])\n    out = context.make_complex(builder, ty)\n    xr = x.real\n    xi = x.imag\n    cxi = np_real_cos_impl(context, builder, fsig1, [xi])\n    chxr = np_real_cosh_impl(context, builder, fsig1, [xr])\n    sxi = np_real_sin_impl(context, builder, fsig1, [xi])\n    shxr = np_real_sinh_impl(context, builder, fsig1, [xr])\n    out.real = builder.fmul(cxi, chxr)\n    out.imag = builder.fmul(sxi, shxr)\n    return out._getvalue()",
            "def np_complex_cosh_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    npyfuncs._check_arity_and_homogeneity(sig, args, 1)\n    ty = sig.args[0]\n    fty = ty.underlying_float\n    fsig1 = typing.signature(*[fty] * 2)\n    x = context.make_complex(builder, ty, args[0])\n    out = context.make_complex(builder, ty)\n    xr = x.real\n    xi = x.imag\n    cxi = np_real_cos_impl(context, builder, fsig1, [xi])\n    chxr = np_real_cosh_impl(context, builder, fsig1, [xr])\n    sxi = np_real_sin_impl(context, builder, fsig1, [xi])\n    shxr = np_real_sinh_impl(context, builder, fsig1, [xr])\n    out.real = builder.fmul(cxi, chxr)\n    out.imag = builder.fmul(sxi, shxr)\n    return out._getvalue()",
            "def np_complex_cosh_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    npyfuncs._check_arity_and_homogeneity(sig, args, 1)\n    ty = sig.args[0]\n    fty = ty.underlying_float\n    fsig1 = typing.signature(*[fty] * 2)\n    x = context.make_complex(builder, ty, args[0])\n    out = context.make_complex(builder, ty)\n    xr = x.real\n    xi = x.imag\n    cxi = np_real_cos_impl(context, builder, fsig1, [xi])\n    chxr = np_real_cosh_impl(context, builder, fsig1, [xr])\n    sxi = np_real_sin_impl(context, builder, fsig1, [xi])\n    shxr = np_real_sinh_impl(context, builder, fsig1, [xr])\n    out.real = builder.fmul(cxi, chxr)\n    out.imag = builder.fmul(sxi, shxr)\n    return out._getvalue()"
        ]
    },
    {
        "func_name": "np_real_tanh_impl",
        "original": "def np_real_tanh_impl(context, builder, sig, args):\n    return np_unary_impl(math.tanh, context, builder, sig, args)",
        "mutated": [
            "def np_real_tanh_impl(context, builder, sig, args):\n    if False:\n        i = 10\n    return np_unary_impl(math.tanh, context, builder, sig, args)",
            "def np_real_tanh_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return np_unary_impl(math.tanh, context, builder, sig, args)",
            "def np_real_tanh_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return np_unary_impl(math.tanh, context, builder, sig, args)",
            "def np_real_tanh_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return np_unary_impl(math.tanh, context, builder, sig, args)",
            "def np_real_tanh_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return np_unary_impl(math.tanh, context, builder, sig, args)"
        ]
    },
    {
        "func_name": "np_complex_tanh_impl",
        "original": "def np_complex_tanh_impl(context, builder, sig, args):\n    npyfuncs._check_arity_and_homogeneity(sig, args, 1)\n    ty = sig.args[0]\n    fty = ty.underlying_float\n    fsig1 = typing.signature(*[fty] * 2)\n    ONE = context.get_constant(fty, 1.0)\n    x = context.make_complex(builder, ty, args[0])\n    out = context.make_complex(builder, ty)\n    xr = x.real\n    xi = x.imag\n    si = np_real_sin_impl(context, builder, fsig1, [xi])\n    ci = np_real_cos_impl(context, builder, fsig1, [xi])\n    shr = np_real_sinh_impl(context, builder, fsig1, [xr])\n    chr_ = np_real_cosh_impl(context, builder, fsig1, [xr])\n    rs = builder.fmul(ci, shr)\n    is_ = builder.fmul(si, chr_)\n    rc = builder.fmul(ci, chr_)\n    ic = builder.fmul(si, shr)\n    sqr_rc = builder.fmul(rc, rc)\n    sqr_ic = builder.fmul(ic, ic)\n    d = builder.fadd(sqr_rc, sqr_ic)\n    inv_d = builder.fdiv(ONE, d)\n    rs_rc = builder.fmul(rs, rc)\n    is_ic = builder.fmul(is_, ic)\n    is_rc = builder.fmul(is_, rc)\n    rs_ic = builder.fmul(rs, ic)\n    numr = builder.fadd(rs_rc, is_ic)\n    numi = builder.fsub(is_rc, rs_ic)\n    out.real = builder.fmul(numr, inv_d)\n    out.imag = builder.fmul(numi, inv_d)\n    return out._getvalue()",
        "mutated": [
            "def np_complex_tanh_impl(context, builder, sig, args):\n    if False:\n        i = 10\n    npyfuncs._check_arity_and_homogeneity(sig, args, 1)\n    ty = sig.args[0]\n    fty = ty.underlying_float\n    fsig1 = typing.signature(*[fty] * 2)\n    ONE = context.get_constant(fty, 1.0)\n    x = context.make_complex(builder, ty, args[0])\n    out = context.make_complex(builder, ty)\n    xr = x.real\n    xi = x.imag\n    si = np_real_sin_impl(context, builder, fsig1, [xi])\n    ci = np_real_cos_impl(context, builder, fsig1, [xi])\n    shr = np_real_sinh_impl(context, builder, fsig1, [xr])\n    chr_ = np_real_cosh_impl(context, builder, fsig1, [xr])\n    rs = builder.fmul(ci, shr)\n    is_ = builder.fmul(si, chr_)\n    rc = builder.fmul(ci, chr_)\n    ic = builder.fmul(si, shr)\n    sqr_rc = builder.fmul(rc, rc)\n    sqr_ic = builder.fmul(ic, ic)\n    d = builder.fadd(sqr_rc, sqr_ic)\n    inv_d = builder.fdiv(ONE, d)\n    rs_rc = builder.fmul(rs, rc)\n    is_ic = builder.fmul(is_, ic)\n    is_rc = builder.fmul(is_, rc)\n    rs_ic = builder.fmul(rs, ic)\n    numr = builder.fadd(rs_rc, is_ic)\n    numi = builder.fsub(is_rc, rs_ic)\n    out.real = builder.fmul(numr, inv_d)\n    out.imag = builder.fmul(numi, inv_d)\n    return out._getvalue()",
            "def np_complex_tanh_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    npyfuncs._check_arity_and_homogeneity(sig, args, 1)\n    ty = sig.args[0]\n    fty = ty.underlying_float\n    fsig1 = typing.signature(*[fty] * 2)\n    ONE = context.get_constant(fty, 1.0)\n    x = context.make_complex(builder, ty, args[0])\n    out = context.make_complex(builder, ty)\n    xr = x.real\n    xi = x.imag\n    si = np_real_sin_impl(context, builder, fsig1, [xi])\n    ci = np_real_cos_impl(context, builder, fsig1, [xi])\n    shr = np_real_sinh_impl(context, builder, fsig1, [xr])\n    chr_ = np_real_cosh_impl(context, builder, fsig1, [xr])\n    rs = builder.fmul(ci, shr)\n    is_ = builder.fmul(si, chr_)\n    rc = builder.fmul(ci, chr_)\n    ic = builder.fmul(si, shr)\n    sqr_rc = builder.fmul(rc, rc)\n    sqr_ic = builder.fmul(ic, ic)\n    d = builder.fadd(sqr_rc, sqr_ic)\n    inv_d = builder.fdiv(ONE, d)\n    rs_rc = builder.fmul(rs, rc)\n    is_ic = builder.fmul(is_, ic)\n    is_rc = builder.fmul(is_, rc)\n    rs_ic = builder.fmul(rs, ic)\n    numr = builder.fadd(rs_rc, is_ic)\n    numi = builder.fsub(is_rc, rs_ic)\n    out.real = builder.fmul(numr, inv_d)\n    out.imag = builder.fmul(numi, inv_d)\n    return out._getvalue()",
            "def np_complex_tanh_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    npyfuncs._check_arity_and_homogeneity(sig, args, 1)\n    ty = sig.args[0]\n    fty = ty.underlying_float\n    fsig1 = typing.signature(*[fty] * 2)\n    ONE = context.get_constant(fty, 1.0)\n    x = context.make_complex(builder, ty, args[0])\n    out = context.make_complex(builder, ty)\n    xr = x.real\n    xi = x.imag\n    si = np_real_sin_impl(context, builder, fsig1, [xi])\n    ci = np_real_cos_impl(context, builder, fsig1, [xi])\n    shr = np_real_sinh_impl(context, builder, fsig1, [xr])\n    chr_ = np_real_cosh_impl(context, builder, fsig1, [xr])\n    rs = builder.fmul(ci, shr)\n    is_ = builder.fmul(si, chr_)\n    rc = builder.fmul(ci, chr_)\n    ic = builder.fmul(si, shr)\n    sqr_rc = builder.fmul(rc, rc)\n    sqr_ic = builder.fmul(ic, ic)\n    d = builder.fadd(sqr_rc, sqr_ic)\n    inv_d = builder.fdiv(ONE, d)\n    rs_rc = builder.fmul(rs, rc)\n    is_ic = builder.fmul(is_, ic)\n    is_rc = builder.fmul(is_, rc)\n    rs_ic = builder.fmul(rs, ic)\n    numr = builder.fadd(rs_rc, is_ic)\n    numi = builder.fsub(is_rc, rs_ic)\n    out.real = builder.fmul(numr, inv_d)\n    out.imag = builder.fmul(numi, inv_d)\n    return out._getvalue()",
            "def np_complex_tanh_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    npyfuncs._check_arity_and_homogeneity(sig, args, 1)\n    ty = sig.args[0]\n    fty = ty.underlying_float\n    fsig1 = typing.signature(*[fty] * 2)\n    ONE = context.get_constant(fty, 1.0)\n    x = context.make_complex(builder, ty, args[0])\n    out = context.make_complex(builder, ty)\n    xr = x.real\n    xi = x.imag\n    si = np_real_sin_impl(context, builder, fsig1, [xi])\n    ci = np_real_cos_impl(context, builder, fsig1, [xi])\n    shr = np_real_sinh_impl(context, builder, fsig1, [xr])\n    chr_ = np_real_cosh_impl(context, builder, fsig1, [xr])\n    rs = builder.fmul(ci, shr)\n    is_ = builder.fmul(si, chr_)\n    rc = builder.fmul(ci, chr_)\n    ic = builder.fmul(si, shr)\n    sqr_rc = builder.fmul(rc, rc)\n    sqr_ic = builder.fmul(ic, ic)\n    d = builder.fadd(sqr_rc, sqr_ic)\n    inv_d = builder.fdiv(ONE, d)\n    rs_rc = builder.fmul(rs, rc)\n    is_ic = builder.fmul(is_, ic)\n    is_rc = builder.fmul(is_, rc)\n    rs_ic = builder.fmul(rs, ic)\n    numr = builder.fadd(rs_rc, is_ic)\n    numi = builder.fsub(is_rc, rs_ic)\n    out.real = builder.fmul(numr, inv_d)\n    out.imag = builder.fmul(numi, inv_d)\n    return out._getvalue()",
            "def np_complex_tanh_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    npyfuncs._check_arity_and_homogeneity(sig, args, 1)\n    ty = sig.args[0]\n    fty = ty.underlying_float\n    fsig1 = typing.signature(*[fty] * 2)\n    ONE = context.get_constant(fty, 1.0)\n    x = context.make_complex(builder, ty, args[0])\n    out = context.make_complex(builder, ty)\n    xr = x.real\n    xi = x.imag\n    si = np_real_sin_impl(context, builder, fsig1, [xi])\n    ci = np_real_cos_impl(context, builder, fsig1, [xi])\n    shr = np_real_sinh_impl(context, builder, fsig1, [xr])\n    chr_ = np_real_cosh_impl(context, builder, fsig1, [xr])\n    rs = builder.fmul(ci, shr)\n    is_ = builder.fmul(si, chr_)\n    rc = builder.fmul(ci, chr_)\n    ic = builder.fmul(si, shr)\n    sqr_rc = builder.fmul(rc, rc)\n    sqr_ic = builder.fmul(ic, ic)\n    d = builder.fadd(sqr_rc, sqr_ic)\n    inv_d = builder.fdiv(ONE, d)\n    rs_rc = builder.fmul(rs, rc)\n    is_ic = builder.fmul(is_, ic)\n    is_rc = builder.fmul(is_, rc)\n    rs_ic = builder.fmul(rs, ic)\n    numr = builder.fadd(rs_rc, is_ic)\n    numi = builder.fsub(is_rc, rs_ic)\n    out.real = builder.fmul(numr, inv_d)\n    out.imag = builder.fmul(numi, inv_d)\n    return out._getvalue()"
        ]
    },
    {
        "func_name": "np_real_asinh_impl",
        "original": "def np_real_asinh_impl(context, builder, sig, args):\n    return np_unary_impl(math.asinh, context, builder, sig, args)",
        "mutated": [
            "def np_real_asinh_impl(context, builder, sig, args):\n    if False:\n        i = 10\n    return np_unary_impl(math.asinh, context, builder, sig, args)",
            "def np_real_asinh_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return np_unary_impl(math.asinh, context, builder, sig, args)",
            "def np_real_asinh_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return np_unary_impl(math.asinh, context, builder, sig, args)",
            "def np_real_asinh_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return np_unary_impl(math.asinh, context, builder, sig, args)",
            "def np_real_asinh_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return np_unary_impl(math.asinh, context, builder, sig, args)"
        ]
    },
    {
        "func_name": "np_real_acosh_impl",
        "original": "def np_real_acosh_impl(context, builder, sig, args):\n    return np_unary_impl(math.acosh, context, builder, sig, args)",
        "mutated": [
            "def np_real_acosh_impl(context, builder, sig, args):\n    if False:\n        i = 10\n    return np_unary_impl(math.acosh, context, builder, sig, args)",
            "def np_real_acosh_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return np_unary_impl(math.acosh, context, builder, sig, args)",
            "def np_real_acosh_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return np_unary_impl(math.acosh, context, builder, sig, args)",
            "def np_real_acosh_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return np_unary_impl(math.acosh, context, builder, sig, args)",
            "def np_real_acosh_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return np_unary_impl(math.acosh, context, builder, sig, args)"
        ]
    },
    {
        "func_name": "np_real_atanh_impl",
        "original": "def np_real_atanh_impl(context, builder, sig, args):\n    return np_unary_impl(math.atanh, context, builder, sig, args)",
        "mutated": [
            "def np_real_atanh_impl(context, builder, sig, args):\n    if False:\n        i = 10\n    return np_unary_impl(math.atanh, context, builder, sig, args)",
            "def np_real_atanh_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return np_unary_impl(math.atanh, context, builder, sig, args)",
            "def np_real_atanh_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return np_unary_impl(math.atanh, context, builder, sig, args)",
            "def np_real_atanh_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return np_unary_impl(math.atanh, context, builder, sig, args)",
            "def np_real_atanh_impl(context, builder, sig, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return np_unary_impl(math.atanh, context, builder, sig, args)"
        ]
    },
    {
        "func_name": "ufunc_db",
        "original": "@lru_cache\ndef ufunc_db():\n    from numba.cpython import cmathimpl, mathimpl, numbers\n    from numba.np import npyfuncs\n    from numba.np.numpy_support import numpy_version\n\n    def np_unary_impl(fn, context, builder, sig, args):\n        npyfuncs._check_arity_and_homogeneity(sig, args, 1)\n        impl = get_unary_impl_for_fn_and_ty(fn, sig.args[0])\n        return impl(context, builder, sig, args)\n\n    def np_binary_impl(fn, context, builder, sig, args):\n        npyfuncs._check_arity_and_homogeneity(sig, args, 2)\n        impl = get_binary_impl_for_fn_and_ty(fn, sig.args[0])\n        return impl(context, builder, sig, args)\n\n    def np_real_sin_impl(context, builder, sig, args):\n        return np_unary_impl(math.sin, context, builder, sig, args)\n\n    def np_real_cos_impl(context, builder, sig, args):\n        return np_unary_impl(math.cos, context, builder, sig, args)\n\n    def np_real_tan_impl(context, builder, sig, args):\n        return np_unary_impl(math.tan, context, builder, sig, args)\n\n    def np_real_asin_impl(context, builder, sig, args):\n        return np_unary_impl(math.asin, context, builder, sig, args)\n\n    def np_real_acos_impl(context, builder, sig, args):\n        return np_unary_impl(math.acos, context, builder, sig, args)\n\n    def np_real_atan_impl(context, builder, sig, args):\n        return np_unary_impl(math.atan, context, builder, sig, args)\n\n    def np_real_atan2_impl(context, builder, sig, args):\n        return np_binary_impl(math.atan2, context, builder, sig, args)\n\n    def np_real_hypot_impl(context, builder, sig, args):\n        return np_binary_impl(math.hypot, context, builder, sig, args)\n\n    def np_real_sinh_impl(context, builder, sig, args):\n        return np_unary_impl(math.sinh, context, builder, sig, args)\n\n    def np_complex_sinh_impl(context, builder, sig, args):\n        npyfuncs._check_arity_and_homogeneity(sig, args, 1)\n        ty = sig.args[0]\n        fty = ty.underlying_float\n        fsig1 = typing.signature(*[fty] * 2)\n        x = context.make_complex(builder, ty, args[0])\n        out = context.make_complex(builder, ty)\n        xr = x.real\n        xi = x.imag\n        sxi = np_real_sin_impl(context, builder, fsig1, [xi])\n        shxr = np_real_sinh_impl(context, builder, fsig1, [xr])\n        cxi = np_real_cos_impl(context, builder, fsig1, [xi])\n        chxr = np_real_cosh_impl(context, builder, fsig1, [xr])\n        out.real = builder.fmul(cxi, shxr)\n        out.imag = builder.fmul(sxi, chxr)\n        return out._getvalue()\n\n    def np_real_cosh_impl(context, builder, sig, args):\n        return np_unary_impl(math.cosh, context, builder, sig, args)\n\n    def np_complex_cosh_impl(context, builder, sig, args):\n        npyfuncs._check_arity_and_homogeneity(sig, args, 1)\n        ty = sig.args[0]\n        fty = ty.underlying_float\n        fsig1 = typing.signature(*[fty] * 2)\n        x = context.make_complex(builder, ty, args[0])\n        out = context.make_complex(builder, ty)\n        xr = x.real\n        xi = x.imag\n        cxi = np_real_cos_impl(context, builder, fsig1, [xi])\n        chxr = np_real_cosh_impl(context, builder, fsig1, [xr])\n        sxi = np_real_sin_impl(context, builder, fsig1, [xi])\n        shxr = np_real_sinh_impl(context, builder, fsig1, [xr])\n        out.real = builder.fmul(cxi, chxr)\n        out.imag = builder.fmul(sxi, shxr)\n        return out._getvalue()\n\n    def np_real_tanh_impl(context, builder, sig, args):\n        return np_unary_impl(math.tanh, context, builder, sig, args)\n\n    def np_complex_tanh_impl(context, builder, sig, args):\n        npyfuncs._check_arity_and_homogeneity(sig, args, 1)\n        ty = sig.args[0]\n        fty = ty.underlying_float\n        fsig1 = typing.signature(*[fty] * 2)\n        ONE = context.get_constant(fty, 1.0)\n        x = context.make_complex(builder, ty, args[0])\n        out = context.make_complex(builder, ty)\n        xr = x.real\n        xi = x.imag\n        si = np_real_sin_impl(context, builder, fsig1, [xi])\n        ci = np_real_cos_impl(context, builder, fsig1, [xi])\n        shr = np_real_sinh_impl(context, builder, fsig1, [xr])\n        chr_ = np_real_cosh_impl(context, builder, fsig1, [xr])\n        rs = builder.fmul(ci, shr)\n        is_ = builder.fmul(si, chr_)\n        rc = builder.fmul(ci, chr_)\n        ic = builder.fmul(si, shr)\n        sqr_rc = builder.fmul(rc, rc)\n        sqr_ic = builder.fmul(ic, ic)\n        d = builder.fadd(sqr_rc, sqr_ic)\n        inv_d = builder.fdiv(ONE, d)\n        rs_rc = builder.fmul(rs, rc)\n        is_ic = builder.fmul(is_, ic)\n        is_rc = builder.fmul(is_, rc)\n        rs_ic = builder.fmul(rs, ic)\n        numr = builder.fadd(rs_rc, is_ic)\n        numi = builder.fsub(is_rc, rs_ic)\n        out.real = builder.fmul(numr, inv_d)\n        out.imag = builder.fmul(numi, inv_d)\n        return out._getvalue()\n\n    def np_real_asinh_impl(context, builder, sig, args):\n        return np_unary_impl(math.asinh, context, builder, sig, args)\n\n    def np_real_acosh_impl(context, builder, sig, args):\n        return np_unary_impl(math.acosh, context, builder, sig, args)\n\n    def np_real_atanh_impl(context, builder, sig, args):\n        return np_unary_impl(math.atanh, context, builder, sig, args)\n    db = {}\n    db[np.sin] = {'f->f': np_real_sin_impl, 'd->d': np_real_sin_impl, 'F->F': npyfuncs.np_complex_sin_impl, 'D->D': npyfuncs.np_complex_sin_impl}\n    db[np.cos] = {'f->f': np_real_cos_impl, 'd->d': np_real_cos_impl, 'F->F': npyfuncs.np_complex_cos_impl, 'D->D': npyfuncs.np_complex_cos_impl}\n    db[np.tan] = {'f->f': np_real_tan_impl, 'd->d': np_real_tan_impl, 'F->F': cmathimpl.tan_impl, 'D->D': cmathimpl.tan_impl}\n    db[np.arcsin] = {'f->f': np_real_asin_impl, 'd->d': np_real_asin_impl, 'F->F': cmathimpl.asin_impl, 'D->D': cmathimpl.asin_impl}\n    db[np.arccos] = {'f->f': np_real_acos_impl, 'd->d': np_real_acos_impl, 'F->F': cmathimpl.acos_impl, 'D->D': cmathimpl.acos_impl}\n    db[np.arctan] = {'f->f': np_real_atan_impl, 'd->d': np_real_atan_impl, 'F->F': cmathimpl.atan_impl, 'D->D': cmathimpl.atan_impl}\n    db[np.arctan2] = {'ff->f': np_real_atan2_impl, 'dd->d': np_real_atan2_impl}\n    db[np.hypot] = {'ff->f': np_real_hypot_impl, 'dd->d': np_real_hypot_impl}\n    db[np.sinh] = {'f->f': np_real_sinh_impl, 'd->d': np_real_sinh_impl, 'F->F': np_complex_sinh_impl, 'D->D': np_complex_sinh_impl}\n    db[np.cosh] = {'f->f': np_real_cosh_impl, 'd->d': np_real_cosh_impl, 'F->F': np_complex_cosh_impl, 'D->D': np_complex_cosh_impl}\n    db[np.tanh] = {'f->f': np_real_tanh_impl, 'd->d': np_real_tanh_impl, 'F->F': np_complex_tanh_impl, 'D->D': np_complex_tanh_impl}\n    db[np.arcsinh] = {'f->f': np_real_asinh_impl, 'd->d': np_real_asinh_impl, 'F->F': cmathimpl.asinh_impl, 'D->D': cmathimpl.asinh_impl}\n    db[np.arccosh] = {'f->f': np_real_acosh_impl, 'd->d': np_real_acosh_impl, 'F->F': npyfuncs.np_complex_acosh_impl, 'D->D': npyfuncs.np_complex_acosh_impl}\n    db[np.arctanh] = {'f->f': np_real_atanh_impl, 'd->d': np_real_atanh_impl, 'F->F': cmathimpl.atanh_impl, 'D->D': cmathimpl.atanh_impl}\n    db[np.deg2rad] = {'f->f': mathimpl.radians_float_impl, 'd->d': mathimpl.radians_float_impl}\n    db[np.radians] = db[np.deg2rad]\n    db[np.rad2deg] = {'f->f': mathimpl.degrees_float_impl, 'd->d': mathimpl.degrees_float_impl}\n    db[np.degrees] = db[np.rad2deg]\n    db[np.greater] = {'??->?': numbers.int_ugt_impl, 'bb->?': numbers.int_sgt_impl, 'BB->?': numbers.int_ugt_impl, 'hh->?': numbers.int_sgt_impl, 'HH->?': numbers.int_ugt_impl, 'ii->?': numbers.int_sgt_impl, 'II->?': numbers.int_ugt_impl, 'll->?': numbers.int_sgt_impl, 'LL->?': numbers.int_ugt_impl, 'qq->?': numbers.int_sgt_impl, 'QQ->?': numbers.int_ugt_impl, 'ff->?': numbers.real_gt_impl, 'dd->?': numbers.real_gt_impl, 'FF->?': npyfuncs.np_complex_gt_impl, 'DD->?': npyfuncs.np_complex_gt_impl}\n    if numpy_version >= (1, 25):\n        db[np.greater].update({'qQ->?': numbers.int_signed_unsigned_cmp('>'), 'Qq->?': numbers.int_unsigned_signed_cmp('>')})\n    db[np.greater_equal] = {'??->?': numbers.int_uge_impl, 'bb->?': numbers.int_sge_impl, 'BB->?': numbers.int_uge_impl, 'hh->?': numbers.int_sge_impl, 'HH->?': numbers.int_uge_impl, 'ii->?': numbers.int_sge_impl, 'II->?': numbers.int_uge_impl, 'll->?': numbers.int_sge_impl, 'LL->?': numbers.int_uge_impl, 'qq->?': numbers.int_sge_impl, 'QQ->?': numbers.int_uge_impl, 'ff->?': numbers.real_ge_impl, 'dd->?': numbers.real_ge_impl, 'FF->?': npyfuncs.np_complex_ge_impl, 'DD->?': npyfuncs.np_complex_ge_impl}\n    if numpy_version >= (1, 25):\n        db[np.greater_equal].update({'qQ->?': numbers.int_signed_unsigned_cmp('>='), 'Qq->?': numbers.int_unsigned_signed_cmp('>=')})\n    db[np.less] = {'??->?': numbers.int_ult_impl, 'bb->?': numbers.int_slt_impl, 'BB->?': numbers.int_ult_impl, 'hh->?': numbers.int_slt_impl, 'HH->?': numbers.int_ult_impl, 'ii->?': numbers.int_slt_impl, 'II->?': numbers.int_ult_impl, 'll->?': numbers.int_slt_impl, 'LL->?': numbers.int_ult_impl, 'qq->?': numbers.int_slt_impl, 'QQ->?': numbers.int_ult_impl, 'ff->?': numbers.real_lt_impl, 'dd->?': numbers.real_lt_impl, 'FF->?': npyfuncs.np_complex_lt_impl, 'DD->?': npyfuncs.np_complex_lt_impl}\n    if numpy_version >= (1, 25):\n        db[np.less].update({'qQ->?': numbers.int_signed_unsigned_cmp('<'), 'Qq->?': numbers.int_unsigned_signed_cmp('<')})\n    db[np.less_equal] = {'??->?': numbers.int_ule_impl, 'bb->?': numbers.int_sle_impl, 'BB->?': numbers.int_ule_impl, 'hh->?': numbers.int_sle_impl, 'HH->?': numbers.int_ule_impl, 'ii->?': numbers.int_sle_impl, 'II->?': numbers.int_ule_impl, 'll->?': numbers.int_sle_impl, 'LL->?': numbers.int_ule_impl, 'qq->?': numbers.int_sle_impl, 'QQ->?': numbers.int_ule_impl, 'ff->?': numbers.real_le_impl, 'dd->?': numbers.real_le_impl, 'FF->?': npyfuncs.np_complex_le_impl, 'DD->?': npyfuncs.np_complex_le_impl}\n    if numpy_version >= (1, 25):\n        db[np.less_equal].update({'qQ->?': numbers.int_signed_unsigned_cmp('<='), 'Qq->?': numbers.int_unsigned_signed_cmp('<=')})\n    db[np.not_equal] = {'??->?': numbers.int_ne_impl, 'bb->?': numbers.int_ne_impl, 'BB->?': numbers.int_ne_impl, 'hh->?': numbers.int_ne_impl, 'HH->?': numbers.int_ne_impl, 'ii->?': numbers.int_ne_impl, 'II->?': numbers.int_ne_impl, 'll->?': numbers.int_ne_impl, 'LL->?': numbers.int_ne_impl, 'qq->?': numbers.int_ne_impl, 'QQ->?': numbers.int_ne_impl, 'ff->?': numbers.real_ne_impl, 'dd->?': numbers.real_ne_impl, 'FF->?': npyfuncs.np_complex_ne_impl, 'DD->?': npyfuncs.np_complex_ne_impl}\n    if numpy_version >= (1, 25):\n        db[np.not_equal].update({'qQ->?': numbers.int_signed_unsigned_cmp('!='), 'Qq->?': numbers.int_unsigned_signed_cmp('!=')})\n    db[np.equal] = {'??->?': numbers.int_eq_impl, 'bb->?': numbers.int_eq_impl, 'BB->?': numbers.int_eq_impl, 'hh->?': numbers.int_eq_impl, 'HH->?': numbers.int_eq_impl, 'ii->?': numbers.int_eq_impl, 'II->?': numbers.int_eq_impl, 'll->?': numbers.int_eq_impl, 'LL->?': numbers.int_eq_impl, 'qq->?': numbers.int_eq_impl, 'QQ->?': numbers.int_eq_impl, 'ff->?': numbers.real_eq_impl, 'dd->?': numbers.real_eq_impl, 'FF->?': npyfuncs.np_complex_eq_impl, 'DD->?': npyfuncs.np_complex_eq_impl}\n    if numpy_version >= (1, 25):\n        db[np.equal].update({'qQ->?': numbers.int_signed_unsigned_cmp('=='), 'Qq->?': numbers.int_unsigned_signed_cmp('==')})\n    db[np.logical_and] = {'??->?': npyfuncs.np_logical_and_impl, 'bb->?': npyfuncs.np_logical_and_impl, 'BB->?': npyfuncs.np_logical_and_impl, 'hh->?': npyfuncs.np_logical_and_impl, 'HH->?': npyfuncs.np_logical_and_impl, 'ii->?': npyfuncs.np_logical_and_impl, 'II->?': npyfuncs.np_logical_and_impl, 'll->?': npyfuncs.np_logical_and_impl, 'LL->?': npyfuncs.np_logical_and_impl, 'qq->?': npyfuncs.np_logical_and_impl, 'QQ->?': npyfuncs.np_logical_and_impl, 'ff->?': npyfuncs.np_logical_and_impl, 'dd->?': npyfuncs.np_logical_and_impl, 'FF->?': npyfuncs.np_complex_logical_and_impl, 'DD->?': npyfuncs.np_complex_logical_and_impl}\n    db[np.logical_or] = {'??->?': npyfuncs.np_logical_or_impl, 'bb->?': npyfuncs.np_logical_or_impl, 'BB->?': npyfuncs.np_logical_or_impl, 'hh->?': npyfuncs.np_logical_or_impl, 'HH->?': npyfuncs.np_logical_or_impl, 'ii->?': npyfuncs.np_logical_or_impl, 'II->?': npyfuncs.np_logical_or_impl, 'll->?': npyfuncs.np_logical_or_impl, 'LL->?': npyfuncs.np_logical_or_impl, 'qq->?': npyfuncs.np_logical_or_impl, 'QQ->?': npyfuncs.np_logical_or_impl, 'ff->?': npyfuncs.np_logical_or_impl, 'dd->?': npyfuncs.np_logical_or_impl, 'FF->?': npyfuncs.np_complex_logical_or_impl, 'DD->?': npyfuncs.np_complex_logical_or_impl}\n    db[np.logical_xor] = {'??->?': npyfuncs.np_logical_xor_impl, 'bb->?': npyfuncs.np_logical_xor_impl, 'BB->?': npyfuncs.np_logical_xor_impl, 'hh->?': npyfuncs.np_logical_xor_impl, 'HH->?': npyfuncs.np_logical_xor_impl, 'ii->?': npyfuncs.np_logical_xor_impl, 'II->?': npyfuncs.np_logical_xor_impl, 'll->?': npyfuncs.np_logical_xor_impl, 'LL->?': npyfuncs.np_logical_xor_impl, 'qq->?': npyfuncs.np_logical_xor_impl, 'QQ->?': npyfuncs.np_logical_xor_impl, 'ff->?': npyfuncs.np_logical_xor_impl, 'dd->?': npyfuncs.np_logical_xor_impl, 'FF->?': npyfuncs.np_complex_logical_xor_impl, 'DD->?': npyfuncs.np_complex_logical_xor_impl}\n    db[np.logical_not] = {'?->?': npyfuncs.np_logical_not_impl, 'b->?': npyfuncs.np_logical_not_impl, 'B->?': npyfuncs.np_logical_not_impl, 'h->?': npyfuncs.np_logical_not_impl, 'H->?': npyfuncs.np_logical_not_impl, 'i->?': npyfuncs.np_logical_not_impl, 'I->?': npyfuncs.np_logical_not_impl, 'l->?': npyfuncs.np_logical_not_impl, 'L->?': npyfuncs.np_logical_not_impl, 'q->?': npyfuncs.np_logical_not_impl, 'Q->?': npyfuncs.np_logical_not_impl, 'f->?': npyfuncs.np_logical_not_impl, 'd->?': npyfuncs.np_logical_not_impl, 'F->?': npyfuncs.np_complex_logical_not_impl, 'D->?': npyfuncs.np_complex_logical_not_impl}\n    db[np.maximum] = {'??->?': npyfuncs.np_logical_or_impl, 'bb->b': npyfuncs.np_int_smax_impl, 'BB->B': npyfuncs.np_int_umax_impl, 'hh->h': npyfuncs.np_int_smax_impl, 'HH->H': npyfuncs.np_int_umax_impl, 'ii->i': npyfuncs.np_int_smax_impl, 'II->I': npyfuncs.np_int_umax_impl, 'll->l': npyfuncs.np_int_smax_impl, 'LL->L': npyfuncs.np_int_umax_impl, 'qq->q': npyfuncs.np_int_smax_impl, 'QQ->Q': npyfuncs.np_int_umax_impl, 'ff->f': npyfuncs.np_real_maximum_impl, 'dd->d': npyfuncs.np_real_maximum_impl, 'FF->F': npyfuncs.np_complex_maximum_impl, 'DD->D': npyfuncs.np_complex_maximum_impl}\n    db[np.minimum] = {'??->?': npyfuncs.np_logical_and_impl, 'bb->b': npyfuncs.np_int_smin_impl, 'BB->B': npyfuncs.np_int_umin_impl, 'hh->h': npyfuncs.np_int_smin_impl, 'HH->H': npyfuncs.np_int_umin_impl, 'ii->i': npyfuncs.np_int_smin_impl, 'II->I': npyfuncs.np_int_umin_impl, 'll->l': npyfuncs.np_int_smin_impl, 'LL->L': npyfuncs.np_int_umin_impl, 'qq->q': npyfuncs.np_int_smin_impl, 'QQ->Q': npyfuncs.np_int_umin_impl, 'ff->f': npyfuncs.np_real_minimum_impl, 'dd->d': npyfuncs.np_real_minimum_impl, 'FF->F': npyfuncs.np_complex_minimum_impl, 'DD->D': npyfuncs.np_complex_minimum_impl}\n    db[np.fmax] = {'??->?': npyfuncs.np_logical_or_impl, 'bb->b': npyfuncs.np_int_smax_impl, 'BB->B': npyfuncs.np_int_umax_impl, 'hh->h': npyfuncs.np_int_smax_impl, 'HH->H': npyfuncs.np_int_umax_impl, 'ii->i': npyfuncs.np_int_smax_impl, 'II->I': npyfuncs.np_int_umax_impl, 'll->l': npyfuncs.np_int_smax_impl, 'LL->L': npyfuncs.np_int_umax_impl, 'qq->q': npyfuncs.np_int_smax_impl, 'QQ->Q': npyfuncs.np_int_umax_impl, 'ff->f': npyfuncs.np_real_fmax_impl, 'dd->d': npyfuncs.np_real_fmax_impl, 'FF->F': npyfuncs.np_complex_fmax_impl, 'DD->D': npyfuncs.np_complex_fmax_impl}\n    db[np.fmin] = {'??->?': npyfuncs.np_logical_and_impl, 'bb->b': npyfuncs.np_int_smin_impl, 'BB->B': npyfuncs.np_int_umin_impl, 'hh->h': npyfuncs.np_int_smin_impl, 'HH->H': npyfuncs.np_int_umin_impl, 'ii->i': npyfuncs.np_int_smin_impl, 'II->I': npyfuncs.np_int_umin_impl, 'll->l': npyfuncs.np_int_smin_impl, 'LL->L': npyfuncs.np_int_umin_impl, 'qq->q': npyfuncs.np_int_smin_impl, 'QQ->Q': npyfuncs.np_int_umin_impl, 'ff->f': npyfuncs.np_real_fmin_impl, 'dd->d': npyfuncs.np_real_fmin_impl, 'FF->F': npyfuncs.np_complex_fmin_impl, 'DD->D': npyfuncs.np_complex_fmin_impl}\n    db[np.bitwise_and] = {'??->?': numbers.int_and_impl, 'bb->b': numbers.int_and_impl, 'BB->B': numbers.int_and_impl, 'hh->h': numbers.int_and_impl, 'HH->H': numbers.int_and_impl, 'ii->i': numbers.int_and_impl, 'II->I': numbers.int_and_impl, 'll->l': numbers.int_and_impl, 'LL->L': numbers.int_and_impl, 'qq->q': numbers.int_and_impl, 'QQ->Q': numbers.int_and_impl}\n    db[np.bitwise_or] = {'??->?': numbers.int_or_impl, 'bb->b': numbers.int_or_impl, 'BB->B': numbers.int_or_impl, 'hh->h': numbers.int_or_impl, 'HH->H': numbers.int_or_impl, 'ii->i': numbers.int_or_impl, 'II->I': numbers.int_or_impl, 'll->l': numbers.int_or_impl, 'LL->L': numbers.int_or_impl, 'qq->q': numbers.int_or_impl, 'QQ->Q': numbers.int_or_impl}\n    db[np.bitwise_xor] = {'??->?': numbers.int_xor_impl, 'bb->b': numbers.int_xor_impl, 'BB->B': numbers.int_xor_impl, 'hh->h': numbers.int_xor_impl, 'HH->H': numbers.int_xor_impl, 'ii->i': numbers.int_xor_impl, 'II->I': numbers.int_xor_impl, 'll->l': numbers.int_xor_impl, 'LL->L': numbers.int_xor_impl, 'qq->q': numbers.int_xor_impl, 'QQ->Q': numbers.int_xor_impl}\n    db[np.invert] = {'?->?': numbers.int_invert_impl, 'b->b': numbers.int_invert_impl, 'B->B': numbers.int_invert_impl, 'h->h': numbers.int_invert_impl, 'H->H': numbers.int_invert_impl, 'i->i': numbers.int_invert_impl, 'I->I': numbers.int_invert_impl, 'l->l': numbers.int_invert_impl, 'L->L': numbers.int_invert_impl, 'q->q': numbers.int_invert_impl, 'Q->Q': numbers.int_invert_impl}\n    db[np.left_shift] = {'bb->b': numbers.int_shl_impl, 'BB->B': numbers.int_shl_impl, 'hh->h': numbers.int_shl_impl, 'HH->H': numbers.int_shl_impl, 'ii->i': numbers.int_shl_impl, 'II->I': numbers.int_shl_impl, 'll->l': numbers.int_shl_impl, 'LL->L': numbers.int_shl_impl, 'qq->q': numbers.int_shl_impl, 'QQ->Q': numbers.int_shl_impl}\n    db[np.right_shift] = {'bb->b': numbers.int_shr_impl, 'BB->B': numbers.int_shr_impl, 'hh->h': numbers.int_shr_impl, 'HH->H': numbers.int_shr_impl, 'ii->i': numbers.int_shr_impl, 'II->I': numbers.int_shr_impl, 'll->l': numbers.int_shr_impl, 'LL->L': numbers.int_shr_impl, 'qq->q': numbers.int_shr_impl, 'QQ->Q': numbers.int_shr_impl}\n    return db",
        "mutated": [
            "@lru_cache\ndef ufunc_db():\n    if False:\n        i = 10\n    from numba.cpython import cmathimpl, mathimpl, numbers\n    from numba.np import npyfuncs\n    from numba.np.numpy_support import numpy_version\n\n    def np_unary_impl(fn, context, builder, sig, args):\n        npyfuncs._check_arity_and_homogeneity(sig, args, 1)\n        impl = get_unary_impl_for_fn_and_ty(fn, sig.args[0])\n        return impl(context, builder, sig, args)\n\n    def np_binary_impl(fn, context, builder, sig, args):\n        npyfuncs._check_arity_and_homogeneity(sig, args, 2)\n        impl = get_binary_impl_for_fn_and_ty(fn, sig.args[0])\n        return impl(context, builder, sig, args)\n\n    def np_real_sin_impl(context, builder, sig, args):\n        return np_unary_impl(math.sin, context, builder, sig, args)\n\n    def np_real_cos_impl(context, builder, sig, args):\n        return np_unary_impl(math.cos, context, builder, sig, args)\n\n    def np_real_tan_impl(context, builder, sig, args):\n        return np_unary_impl(math.tan, context, builder, sig, args)\n\n    def np_real_asin_impl(context, builder, sig, args):\n        return np_unary_impl(math.asin, context, builder, sig, args)\n\n    def np_real_acos_impl(context, builder, sig, args):\n        return np_unary_impl(math.acos, context, builder, sig, args)\n\n    def np_real_atan_impl(context, builder, sig, args):\n        return np_unary_impl(math.atan, context, builder, sig, args)\n\n    def np_real_atan2_impl(context, builder, sig, args):\n        return np_binary_impl(math.atan2, context, builder, sig, args)\n\n    def np_real_hypot_impl(context, builder, sig, args):\n        return np_binary_impl(math.hypot, context, builder, sig, args)\n\n    def np_real_sinh_impl(context, builder, sig, args):\n        return np_unary_impl(math.sinh, context, builder, sig, args)\n\n    def np_complex_sinh_impl(context, builder, sig, args):\n        npyfuncs._check_arity_and_homogeneity(sig, args, 1)\n        ty = sig.args[0]\n        fty = ty.underlying_float\n        fsig1 = typing.signature(*[fty] * 2)\n        x = context.make_complex(builder, ty, args[0])\n        out = context.make_complex(builder, ty)\n        xr = x.real\n        xi = x.imag\n        sxi = np_real_sin_impl(context, builder, fsig1, [xi])\n        shxr = np_real_sinh_impl(context, builder, fsig1, [xr])\n        cxi = np_real_cos_impl(context, builder, fsig1, [xi])\n        chxr = np_real_cosh_impl(context, builder, fsig1, [xr])\n        out.real = builder.fmul(cxi, shxr)\n        out.imag = builder.fmul(sxi, chxr)\n        return out._getvalue()\n\n    def np_real_cosh_impl(context, builder, sig, args):\n        return np_unary_impl(math.cosh, context, builder, sig, args)\n\n    def np_complex_cosh_impl(context, builder, sig, args):\n        npyfuncs._check_arity_and_homogeneity(sig, args, 1)\n        ty = sig.args[0]\n        fty = ty.underlying_float\n        fsig1 = typing.signature(*[fty] * 2)\n        x = context.make_complex(builder, ty, args[0])\n        out = context.make_complex(builder, ty)\n        xr = x.real\n        xi = x.imag\n        cxi = np_real_cos_impl(context, builder, fsig1, [xi])\n        chxr = np_real_cosh_impl(context, builder, fsig1, [xr])\n        sxi = np_real_sin_impl(context, builder, fsig1, [xi])\n        shxr = np_real_sinh_impl(context, builder, fsig1, [xr])\n        out.real = builder.fmul(cxi, chxr)\n        out.imag = builder.fmul(sxi, shxr)\n        return out._getvalue()\n\n    def np_real_tanh_impl(context, builder, sig, args):\n        return np_unary_impl(math.tanh, context, builder, sig, args)\n\n    def np_complex_tanh_impl(context, builder, sig, args):\n        npyfuncs._check_arity_and_homogeneity(sig, args, 1)\n        ty = sig.args[0]\n        fty = ty.underlying_float\n        fsig1 = typing.signature(*[fty] * 2)\n        ONE = context.get_constant(fty, 1.0)\n        x = context.make_complex(builder, ty, args[0])\n        out = context.make_complex(builder, ty)\n        xr = x.real\n        xi = x.imag\n        si = np_real_sin_impl(context, builder, fsig1, [xi])\n        ci = np_real_cos_impl(context, builder, fsig1, [xi])\n        shr = np_real_sinh_impl(context, builder, fsig1, [xr])\n        chr_ = np_real_cosh_impl(context, builder, fsig1, [xr])\n        rs = builder.fmul(ci, shr)\n        is_ = builder.fmul(si, chr_)\n        rc = builder.fmul(ci, chr_)\n        ic = builder.fmul(si, shr)\n        sqr_rc = builder.fmul(rc, rc)\n        sqr_ic = builder.fmul(ic, ic)\n        d = builder.fadd(sqr_rc, sqr_ic)\n        inv_d = builder.fdiv(ONE, d)\n        rs_rc = builder.fmul(rs, rc)\n        is_ic = builder.fmul(is_, ic)\n        is_rc = builder.fmul(is_, rc)\n        rs_ic = builder.fmul(rs, ic)\n        numr = builder.fadd(rs_rc, is_ic)\n        numi = builder.fsub(is_rc, rs_ic)\n        out.real = builder.fmul(numr, inv_d)\n        out.imag = builder.fmul(numi, inv_d)\n        return out._getvalue()\n\n    def np_real_asinh_impl(context, builder, sig, args):\n        return np_unary_impl(math.asinh, context, builder, sig, args)\n\n    def np_real_acosh_impl(context, builder, sig, args):\n        return np_unary_impl(math.acosh, context, builder, sig, args)\n\n    def np_real_atanh_impl(context, builder, sig, args):\n        return np_unary_impl(math.atanh, context, builder, sig, args)\n    db = {}\n    db[np.sin] = {'f->f': np_real_sin_impl, 'd->d': np_real_sin_impl, 'F->F': npyfuncs.np_complex_sin_impl, 'D->D': npyfuncs.np_complex_sin_impl}\n    db[np.cos] = {'f->f': np_real_cos_impl, 'd->d': np_real_cos_impl, 'F->F': npyfuncs.np_complex_cos_impl, 'D->D': npyfuncs.np_complex_cos_impl}\n    db[np.tan] = {'f->f': np_real_tan_impl, 'd->d': np_real_tan_impl, 'F->F': cmathimpl.tan_impl, 'D->D': cmathimpl.tan_impl}\n    db[np.arcsin] = {'f->f': np_real_asin_impl, 'd->d': np_real_asin_impl, 'F->F': cmathimpl.asin_impl, 'D->D': cmathimpl.asin_impl}\n    db[np.arccos] = {'f->f': np_real_acos_impl, 'd->d': np_real_acos_impl, 'F->F': cmathimpl.acos_impl, 'D->D': cmathimpl.acos_impl}\n    db[np.arctan] = {'f->f': np_real_atan_impl, 'd->d': np_real_atan_impl, 'F->F': cmathimpl.atan_impl, 'D->D': cmathimpl.atan_impl}\n    db[np.arctan2] = {'ff->f': np_real_atan2_impl, 'dd->d': np_real_atan2_impl}\n    db[np.hypot] = {'ff->f': np_real_hypot_impl, 'dd->d': np_real_hypot_impl}\n    db[np.sinh] = {'f->f': np_real_sinh_impl, 'd->d': np_real_sinh_impl, 'F->F': np_complex_sinh_impl, 'D->D': np_complex_sinh_impl}\n    db[np.cosh] = {'f->f': np_real_cosh_impl, 'd->d': np_real_cosh_impl, 'F->F': np_complex_cosh_impl, 'D->D': np_complex_cosh_impl}\n    db[np.tanh] = {'f->f': np_real_tanh_impl, 'd->d': np_real_tanh_impl, 'F->F': np_complex_tanh_impl, 'D->D': np_complex_tanh_impl}\n    db[np.arcsinh] = {'f->f': np_real_asinh_impl, 'd->d': np_real_asinh_impl, 'F->F': cmathimpl.asinh_impl, 'D->D': cmathimpl.asinh_impl}\n    db[np.arccosh] = {'f->f': np_real_acosh_impl, 'd->d': np_real_acosh_impl, 'F->F': npyfuncs.np_complex_acosh_impl, 'D->D': npyfuncs.np_complex_acosh_impl}\n    db[np.arctanh] = {'f->f': np_real_atanh_impl, 'd->d': np_real_atanh_impl, 'F->F': cmathimpl.atanh_impl, 'D->D': cmathimpl.atanh_impl}\n    db[np.deg2rad] = {'f->f': mathimpl.radians_float_impl, 'd->d': mathimpl.radians_float_impl}\n    db[np.radians] = db[np.deg2rad]\n    db[np.rad2deg] = {'f->f': mathimpl.degrees_float_impl, 'd->d': mathimpl.degrees_float_impl}\n    db[np.degrees] = db[np.rad2deg]\n    db[np.greater] = {'??->?': numbers.int_ugt_impl, 'bb->?': numbers.int_sgt_impl, 'BB->?': numbers.int_ugt_impl, 'hh->?': numbers.int_sgt_impl, 'HH->?': numbers.int_ugt_impl, 'ii->?': numbers.int_sgt_impl, 'II->?': numbers.int_ugt_impl, 'll->?': numbers.int_sgt_impl, 'LL->?': numbers.int_ugt_impl, 'qq->?': numbers.int_sgt_impl, 'QQ->?': numbers.int_ugt_impl, 'ff->?': numbers.real_gt_impl, 'dd->?': numbers.real_gt_impl, 'FF->?': npyfuncs.np_complex_gt_impl, 'DD->?': npyfuncs.np_complex_gt_impl}\n    if numpy_version >= (1, 25):\n        db[np.greater].update({'qQ->?': numbers.int_signed_unsigned_cmp('>'), 'Qq->?': numbers.int_unsigned_signed_cmp('>')})\n    db[np.greater_equal] = {'??->?': numbers.int_uge_impl, 'bb->?': numbers.int_sge_impl, 'BB->?': numbers.int_uge_impl, 'hh->?': numbers.int_sge_impl, 'HH->?': numbers.int_uge_impl, 'ii->?': numbers.int_sge_impl, 'II->?': numbers.int_uge_impl, 'll->?': numbers.int_sge_impl, 'LL->?': numbers.int_uge_impl, 'qq->?': numbers.int_sge_impl, 'QQ->?': numbers.int_uge_impl, 'ff->?': numbers.real_ge_impl, 'dd->?': numbers.real_ge_impl, 'FF->?': npyfuncs.np_complex_ge_impl, 'DD->?': npyfuncs.np_complex_ge_impl}\n    if numpy_version >= (1, 25):\n        db[np.greater_equal].update({'qQ->?': numbers.int_signed_unsigned_cmp('>='), 'Qq->?': numbers.int_unsigned_signed_cmp('>=')})\n    db[np.less] = {'??->?': numbers.int_ult_impl, 'bb->?': numbers.int_slt_impl, 'BB->?': numbers.int_ult_impl, 'hh->?': numbers.int_slt_impl, 'HH->?': numbers.int_ult_impl, 'ii->?': numbers.int_slt_impl, 'II->?': numbers.int_ult_impl, 'll->?': numbers.int_slt_impl, 'LL->?': numbers.int_ult_impl, 'qq->?': numbers.int_slt_impl, 'QQ->?': numbers.int_ult_impl, 'ff->?': numbers.real_lt_impl, 'dd->?': numbers.real_lt_impl, 'FF->?': npyfuncs.np_complex_lt_impl, 'DD->?': npyfuncs.np_complex_lt_impl}\n    if numpy_version >= (1, 25):\n        db[np.less].update({'qQ->?': numbers.int_signed_unsigned_cmp('<'), 'Qq->?': numbers.int_unsigned_signed_cmp('<')})\n    db[np.less_equal] = {'??->?': numbers.int_ule_impl, 'bb->?': numbers.int_sle_impl, 'BB->?': numbers.int_ule_impl, 'hh->?': numbers.int_sle_impl, 'HH->?': numbers.int_ule_impl, 'ii->?': numbers.int_sle_impl, 'II->?': numbers.int_ule_impl, 'll->?': numbers.int_sle_impl, 'LL->?': numbers.int_ule_impl, 'qq->?': numbers.int_sle_impl, 'QQ->?': numbers.int_ule_impl, 'ff->?': numbers.real_le_impl, 'dd->?': numbers.real_le_impl, 'FF->?': npyfuncs.np_complex_le_impl, 'DD->?': npyfuncs.np_complex_le_impl}\n    if numpy_version >= (1, 25):\n        db[np.less_equal].update({'qQ->?': numbers.int_signed_unsigned_cmp('<='), 'Qq->?': numbers.int_unsigned_signed_cmp('<=')})\n    db[np.not_equal] = {'??->?': numbers.int_ne_impl, 'bb->?': numbers.int_ne_impl, 'BB->?': numbers.int_ne_impl, 'hh->?': numbers.int_ne_impl, 'HH->?': numbers.int_ne_impl, 'ii->?': numbers.int_ne_impl, 'II->?': numbers.int_ne_impl, 'll->?': numbers.int_ne_impl, 'LL->?': numbers.int_ne_impl, 'qq->?': numbers.int_ne_impl, 'QQ->?': numbers.int_ne_impl, 'ff->?': numbers.real_ne_impl, 'dd->?': numbers.real_ne_impl, 'FF->?': npyfuncs.np_complex_ne_impl, 'DD->?': npyfuncs.np_complex_ne_impl}\n    if numpy_version >= (1, 25):\n        db[np.not_equal].update({'qQ->?': numbers.int_signed_unsigned_cmp('!='), 'Qq->?': numbers.int_unsigned_signed_cmp('!=')})\n    db[np.equal] = {'??->?': numbers.int_eq_impl, 'bb->?': numbers.int_eq_impl, 'BB->?': numbers.int_eq_impl, 'hh->?': numbers.int_eq_impl, 'HH->?': numbers.int_eq_impl, 'ii->?': numbers.int_eq_impl, 'II->?': numbers.int_eq_impl, 'll->?': numbers.int_eq_impl, 'LL->?': numbers.int_eq_impl, 'qq->?': numbers.int_eq_impl, 'QQ->?': numbers.int_eq_impl, 'ff->?': numbers.real_eq_impl, 'dd->?': numbers.real_eq_impl, 'FF->?': npyfuncs.np_complex_eq_impl, 'DD->?': npyfuncs.np_complex_eq_impl}\n    if numpy_version >= (1, 25):\n        db[np.equal].update({'qQ->?': numbers.int_signed_unsigned_cmp('=='), 'Qq->?': numbers.int_unsigned_signed_cmp('==')})\n    db[np.logical_and] = {'??->?': npyfuncs.np_logical_and_impl, 'bb->?': npyfuncs.np_logical_and_impl, 'BB->?': npyfuncs.np_logical_and_impl, 'hh->?': npyfuncs.np_logical_and_impl, 'HH->?': npyfuncs.np_logical_and_impl, 'ii->?': npyfuncs.np_logical_and_impl, 'II->?': npyfuncs.np_logical_and_impl, 'll->?': npyfuncs.np_logical_and_impl, 'LL->?': npyfuncs.np_logical_and_impl, 'qq->?': npyfuncs.np_logical_and_impl, 'QQ->?': npyfuncs.np_logical_and_impl, 'ff->?': npyfuncs.np_logical_and_impl, 'dd->?': npyfuncs.np_logical_and_impl, 'FF->?': npyfuncs.np_complex_logical_and_impl, 'DD->?': npyfuncs.np_complex_logical_and_impl}\n    db[np.logical_or] = {'??->?': npyfuncs.np_logical_or_impl, 'bb->?': npyfuncs.np_logical_or_impl, 'BB->?': npyfuncs.np_logical_or_impl, 'hh->?': npyfuncs.np_logical_or_impl, 'HH->?': npyfuncs.np_logical_or_impl, 'ii->?': npyfuncs.np_logical_or_impl, 'II->?': npyfuncs.np_logical_or_impl, 'll->?': npyfuncs.np_logical_or_impl, 'LL->?': npyfuncs.np_logical_or_impl, 'qq->?': npyfuncs.np_logical_or_impl, 'QQ->?': npyfuncs.np_logical_or_impl, 'ff->?': npyfuncs.np_logical_or_impl, 'dd->?': npyfuncs.np_logical_or_impl, 'FF->?': npyfuncs.np_complex_logical_or_impl, 'DD->?': npyfuncs.np_complex_logical_or_impl}\n    db[np.logical_xor] = {'??->?': npyfuncs.np_logical_xor_impl, 'bb->?': npyfuncs.np_logical_xor_impl, 'BB->?': npyfuncs.np_logical_xor_impl, 'hh->?': npyfuncs.np_logical_xor_impl, 'HH->?': npyfuncs.np_logical_xor_impl, 'ii->?': npyfuncs.np_logical_xor_impl, 'II->?': npyfuncs.np_logical_xor_impl, 'll->?': npyfuncs.np_logical_xor_impl, 'LL->?': npyfuncs.np_logical_xor_impl, 'qq->?': npyfuncs.np_logical_xor_impl, 'QQ->?': npyfuncs.np_logical_xor_impl, 'ff->?': npyfuncs.np_logical_xor_impl, 'dd->?': npyfuncs.np_logical_xor_impl, 'FF->?': npyfuncs.np_complex_logical_xor_impl, 'DD->?': npyfuncs.np_complex_logical_xor_impl}\n    db[np.logical_not] = {'?->?': npyfuncs.np_logical_not_impl, 'b->?': npyfuncs.np_logical_not_impl, 'B->?': npyfuncs.np_logical_not_impl, 'h->?': npyfuncs.np_logical_not_impl, 'H->?': npyfuncs.np_logical_not_impl, 'i->?': npyfuncs.np_logical_not_impl, 'I->?': npyfuncs.np_logical_not_impl, 'l->?': npyfuncs.np_logical_not_impl, 'L->?': npyfuncs.np_logical_not_impl, 'q->?': npyfuncs.np_logical_not_impl, 'Q->?': npyfuncs.np_logical_not_impl, 'f->?': npyfuncs.np_logical_not_impl, 'd->?': npyfuncs.np_logical_not_impl, 'F->?': npyfuncs.np_complex_logical_not_impl, 'D->?': npyfuncs.np_complex_logical_not_impl}\n    db[np.maximum] = {'??->?': npyfuncs.np_logical_or_impl, 'bb->b': npyfuncs.np_int_smax_impl, 'BB->B': npyfuncs.np_int_umax_impl, 'hh->h': npyfuncs.np_int_smax_impl, 'HH->H': npyfuncs.np_int_umax_impl, 'ii->i': npyfuncs.np_int_smax_impl, 'II->I': npyfuncs.np_int_umax_impl, 'll->l': npyfuncs.np_int_smax_impl, 'LL->L': npyfuncs.np_int_umax_impl, 'qq->q': npyfuncs.np_int_smax_impl, 'QQ->Q': npyfuncs.np_int_umax_impl, 'ff->f': npyfuncs.np_real_maximum_impl, 'dd->d': npyfuncs.np_real_maximum_impl, 'FF->F': npyfuncs.np_complex_maximum_impl, 'DD->D': npyfuncs.np_complex_maximum_impl}\n    db[np.minimum] = {'??->?': npyfuncs.np_logical_and_impl, 'bb->b': npyfuncs.np_int_smin_impl, 'BB->B': npyfuncs.np_int_umin_impl, 'hh->h': npyfuncs.np_int_smin_impl, 'HH->H': npyfuncs.np_int_umin_impl, 'ii->i': npyfuncs.np_int_smin_impl, 'II->I': npyfuncs.np_int_umin_impl, 'll->l': npyfuncs.np_int_smin_impl, 'LL->L': npyfuncs.np_int_umin_impl, 'qq->q': npyfuncs.np_int_smin_impl, 'QQ->Q': npyfuncs.np_int_umin_impl, 'ff->f': npyfuncs.np_real_minimum_impl, 'dd->d': npyfuncs.np_real_minimum_impl, 'FF->F': npyfuncs.np_complex_minimum_impl, 'DD->D': npyfuncs.np_complex_minimum_impl}\n    db[np.fmax] = {'??->?': npyfuncs.np_logical_or_impl, 'bb->b': npyfuncs.np_int_smax_impl, 'BB->B': npyfuncs.np_int_umax_impl, 'hh->h': npyfuncs.np_int_smax_impl, 'HH->H': npyfuncs.np_int_umax_impl, 'ii->i': npyfuncs.np_int_smax_impl, 'II->I': npyfuncs.np_int_umax_impl, 'll->l': npyfuncs.np_int_smax_impl, 'LL->L': npyfuncs.np_int_umax_impl, 'qq->q': npyfuncs.np_int_smax_impl, 'QQ->Q': npyfuncs.np_int_umax_impl, 'ff->f': npyfuncs.np_real_fmax_impl, 'dd->d': npyfuncs.np_real_fmax_impl, 'FF->F': npyfuncs.np_complex_fmax_impl, 'DD->D': npyfuncs.np_complex_fmax_impl}\n    db[np.fmin] = {'??->?': npyfuncs.np_logical_and_impl, 'bb->b': npyfuncs.np_int_smin_impl, 'BB->B': npyfuncs.np_int_umin_impl, 'hh->h': npyfuncs.np_int_smin_impl, 'HH->H': npyfuncs.np_int_umin_impl, 'ii->i': npyfuncs.np_int_smin_impl, 'II->I': npyfuncs.np_int_umin_impl, 'll->l': npyfuncs.np_int_smin_impl, 'LL->L': npyfuncs.np_int_umin_impl, 'qq->q': npyfuncs.np_int_smin_impl, 'QQ->Q': npyfuncs.np_int_umin_impl, 'ff->f': npyfuncs.np_real_fmin_impl, 'dd->d': npyfuncs.np_real_fmin_impl, 'FF->F': npyfuncs.np_complex_fmin_impl, 'DD->D': npyfuncs.np_complex_fmin_impl}\n    db[np.bitwise_and] = {'??->?': numbers.int_and_impl, 'bb->b': numbers.int_and_impl, 'BB->B': numbers.int_and_impl, 'hh->h': numbers.int_and_impl, 'HH->H': numbers.int_and_impl, 'ii->i': numbers.int_and_impl, 'II->I': numbers.int_and_impl, 'll->l': numbers.int_and_impl, 'LL->L': numbers.int_and_impl, 'qq->q': numbers.int_and_impl, 'QQ->Q': numbers.int_and_impl}\n    db[np.bitwise_or] = {'??->?': numbers.int_or_impl, 'bb->b': numbers.int_or_impl, 'BB->B': numbers.int_or_impl, 'hh->h': numbers.int_or_impl, 'HH->H': numbers.int_or_impl, 'ii->i': numbers.int_or_impl, 'II->I': numbers.int_or_impl, 'll->l': numbers.int_or_impl, 'LL->L': numbers.int_or_impl, 'qq->q': numbers.int_or_impl, 'QQ->Q': numbers.int_or_impl}\n    db[np.bitwise_xor] = {'??->?': numbers.int_xor_impl, 'bb->b': numbers.int_xor_impl, 'BB->B': numbers.int_xor_impl, 'hh->h': numbers.int_xor_impl, 'HH->H': numbers.int_xor_impl, 'ii->i': numbers.int_xor_impl, 'II->I': numbers.int_xor_impl, 'll->l': numbers.int_xor_impl, 'LL->L': numbers.int_xor_impl, 'qq->q': numbers.int_xor_impl, 'QQ->Q': numbers.int_xor_impl}\n    db[np.invert] = {'?->?': numbers.int_invert_impl, 'b->b': numbers.int_invert_impl, 'B->B': numbers.int_invert_impl, 'h->h': numbers.int_invert_impl, 'H->H': numbers.int_invert_impl, 'i->i': numbers.int_invert_impl, 'I->I': numbers.int_invert_impl, 'l->l': numbers.int_invert_impl, 'L->L': numbers.int_invert_impl, 'q->q': numbers.int_invert_impl, 'Q->Q': numbers.int_invert_impl}\n    db[np.left_shift] = {'bb->b': numbers.int_shl_impl, 'BB->B': numbers.int_shl_impl, 'hh->h': numbers.int_shl_impl, 'HH->H': numbers.int_shl_impl, 'ii->i': numbers.int_shl_impl, 'II->I': numbers.int_shl_impl, 'll->l': numbers.int_shl_impl, 'LL->L': numbers.int_shl_impl, 'qq->q': numbers.int_shl_impl, 'QQ->Q': numbers.int_shl_impl}\n    db[np.right_shift] = {'bb->b': numbers.int_shr_impl, 'BB->B': numbers.int_shr_impl, 'hh->h': numbers.int_shr_impl, 'HH->H': numbers.int_shr_impl, 'ii->i': numbers.int_shr_impl, 'II->I': numbers.int_shr_impl, 'll->l': numbers.int_shr_impl, 'LL->L': numbers.int_shr_impl, 'qq->q': numbers.int_shr_impl, 'QQ->Q': numbers.int_shr_impl}\n    return db",
            "@lru_cache\ndef ufunc_db():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    from numba.cpython import cmathimpl, mathimpl, numbers\n    from numba.np import npyfuncs\n    from numba.np.numpy_support import numpy_version\n\n    def np_unary_impl(fn, context, builder, sig, args):\n        npyfuncs._check_arity_and_homogeneity(sig, args, 1)\n        impl = get_unary_impl_for_fn_and_ty(fn, sig.args[0])\n        return impl(context, builder, sig, args)\n\n    def np_binary_impl(fn, context, builder, sig, args):\n        npyfuncs._check_arity_and_homogeneity(sig, args, 2)\n        impl = get_binary_impl_for_fn_and_ty(fn, sig.args[0])\n        return impl(context, builder, sig, args)\n\n    def np_real_sin_impl(context, builder, sig, args):\n        return np_unary_impl(math.sin, context, builder, sig, args)\n\n    def np_real_cos_impl(context, builder, sig, args):\n        return np_unary_impl(math.cos, context, builder, sig, args)\n\n    def np_real_tan_impl(context, builder, sig, args):\n        return np_unary_impl(math.tan, context, builder, sig, args)\n\n    def np_real_asin_impl(context, builder, sig, args):\n        return np_unary_impl(math.asin, context, builder, sig, args)\n\n    def np_real_acos_impl(context, builder, sig, args):\n        return np_unary_impl(math.acos, context, builder, sig, args)\n\n    def np_real_atan_impl(context, builder, sig, args):\n        return np_unary_impl(math.atan, context, builder, sig, args)\n\n    def np_real_atan2_impl(context, builder, sig, args):\n        return np_binary_impl(math.atan2, context, builder, sig, args)\n\n    def np_real_hypot_impl(context, builder, sig, args):\n        return np_binary_impl(math.hypot, context, builder, sig, args)\n\n    def np_real_sinh_impl(context, builder, sig, args):\n        return np_unary_impl(math.sinh, context, builder, sig, args)\n\n    def np_complex_sinh_impl(context, builder, sig, args):\n        npyfuncs._check_arity_and_homogeneity(sig, args, 1)\n        ty = sig.args[0]\n        fty = ty.underlying_float\n        fsig1 = typing.signature(*[fty] * 2)\n        x = context.make_complex(builder, ty, args[0])\n        out = context.make_complex(builder, ty)\n        xr = x.real\n        xi = x.imag\n        sxi = np_real_sin_impl(context, builder, fsig1, [xi])\n        shxr = np_real_sinh_impl(context, builder, fsig1, [xr])\n        cxi = np_real_cos_impl(context, builder, fsig1, [xi])\n        chxr = np_real_cosh_impl(context, builder, fsig1, [xr])\n        out.real = builder.fmul(cxi, shxr)\n        out.imag = builder.fmul(sxi, chxr)\n        return out._getvalue()\n\n    def np_real_cosh_impl(context, builder, sig, args):\n        return np_unary_impl(math.cosh, context, builder, sig, args)\n\n    def np_complex_cosh_impl(context, builder, sig, args):\n        npyfuncs._check_arity_and_homogeneity(sig, args, 1)\n        ty = sig.args[0]\n        fty = ty.underlying_float\n        fsig1 = typing.signature(*[fty] * 2)\n        x = context.make_complex(builder, ty, args[0])\n        out = context.make_complex(builder, ty)\n        xr = x.real\n        xi = x.imag\n        cxi = np_real_cos_impl(context, builder, fsig1, [xi])\n        chxr = np_real_cosh_impl(context, builder, fsig1, [xr])\n        sxi = np_real_sin_impl(context, builder, fsig1, [xi])\n        shxr = np_real_sinh_impl(context, builder, fsig1, [xr])\n        out.real = builder.fmul(cxi, chxr)\n        out.imag = builder.fmul(sxi, shxr)\n        return out._getvalue()\n\n    def np_real_tanh_impl(context, builder, sig, args):\n        return np_unary_impl(math.tanh, context, builder, sig, args)\n\n    def np_complex_tanh_impl(context, builder, sig, args):\n        npyfuncs._check_arity_and_homogeneity(sig, args, 1)\n        ty = sig.args[0]\n        fty = ty.underlying_float\n        fsig1 = typing.signature(*[fty] * 2)\n        ONE = context.get_constant(fty, 1.0)\n        x = context.make_complex(builder, ty, args[0])\n        out = context.make_complex(builder, ty)\n        xr = x.real\n        xi = x.imag\n        si = np_real_sin_impl(context, builder, fsig1, [xi])\n        ci = np_real_cos_impl(context, builder, fsig1, [xi])\n        shr = np_real_sinh_impl(context, builder, fsig1, [xr])\n        chr_ = np_real_cosh_impl(context, builder, fsig1, [xr])\n        rs = builder.fmul(ci, shr)\n        is_ = builder.fmul(si, chr_)\n        rc = builder.fmul(ci, chr_)\n        ic = builder.fmul(si, shr)\n        sqr_rc = builder.fmul(rc, rc)\n        sqr_ic = builder.fmul(ic, ic)\n        d = builder.fadd(sqr_rc, sqr_ic)\n        inv_d = builder.fdiv(ONE, d)\n        rs_rc = builder.fmul(rs, rc)\n        is_ic = builder.fmul(is_, ic)\n        is_rc = builder.fmul(is_, rc)\n        rs_ic = builder.fmul(rs, ic)\n        numr = builder.fadd(rs_rc, is_ic)\n        numi = builder.fsub(is_rc, rs_ic)\n        out.real = builder.fmul(numr, inv_d)\n        out.imag = builder.fmul(numi, inv_d)\n        return out._getvalue()\n\n    def np_real_asinh_impl(context, builder, sig, args):\n        return np_unary_impl(math.asinh, context, builder, sig, args)\n\n    def np_real_acosh_impl(context, builder, sig, args):\n        return np_unary_impl(math.acosh, context, builder, sig, args)\n\n    def np_real_atanh_impl(context, builder, sig, args):\n        return np_unary_impl(math.atanh, context, builder, sig, args)\n    db = {}\n    db[np.sin] = {'f->f': np_real_sin_impl, 'd->d': np_real_sin_impl, 'F->F': npyfuncs.np_complex_sin_impl, 'D->D': npyfuncs.np_complex_sin_impl}\n    db[np.cos] = {'f->f': np_real_cos_impl, 'd->d': np_real_cos_impl, 'F->F': npyfuncs.np_complex_cos_impl, 'D->D': npyfuncs.np_complex_cos_impl}\n    db[np.tan] = {'f->f': np_real_tan_impl, 'd->d': np_real_tan_impl, 'F->F': cmathimpl.tan_impl, 'D->D': cmathimpl.tan_impl}\n    db[np.arcsin] = {'f->f': np_real_asin_impl, 'd->d': np_real_asin_impl, 'F->F': cmathimpl.asin_impl, 'D->D': cmathimpl.asin_impl}\n    db[np.arccos] = {'f->f': np_real_acos_impl, 'd->d': np_real_acos_impl, 'F->F': cmathimpl.acos_impl, 'D->D': cmathimpl.acos_impl}\n    db[np.arctan] = {'f->f': np_real_atan_impl, 'd->d': np_real_atan_impl, 'F->F': cmathimpl.atan_impl, 'D->D': cmathimpl.atan_impl}\n    db[np.arctan2] = {'ff->f': np_real_atan2_impl, 'dd->d': np_real_atan2_impl}\n    db[np.hypot] = {'ff->f': np_real_hypot_impl, 'dd->d': np_real_hypot_impl}\n    db[np.sinh] = {'f->f': np_real_sinh_impl, 'd->d': np_real_sinh_impl, 'F->F': np_complex_sinh_impl, 'D->D': np_complex_sinh_impl}\n    db[np.cosh] = {'f->f': np_real_cosh_impl, 'd->d': np_real_cosh_impl, 'F->F': np_complex_cosh_impl, 'D->D': np_complex_cosh_impl}\n    db[np.tanh] = {'f->f': np_real_tanh_impl, 'd->d': np_real_tanh_impl, 'F->F': np_complex_tanh_impl, 'D->D': np_complex_tanh_impl}\n    db[np.arcsinh] = {'f->f': np_real_asinh_impl, 'd->d': np_real_asinh_impl, 'F->F': cmathimpl.asinh_impl, 'D->D': cmathimpl.asinh_impl}\n    db[np.arccosh] = {'f->f': np_real_acosh_impl, 'd->d': np_real_acosh_impl, 'F->F': npyfuncs.np_complex_acosh_impl, 'D->D': npyfuncs.np_complex_acosh_impl}\n    db[np.arctanh] = {'f->f': np_real_atanh_impl, 'd->d': np_real_atanh_impl, 'F->F': cmathimpl.atanh_impl, 'D->D': cmathimpl.atanh_impl}\n    db[np.deg2rad] = {'f->f': mathimpl.radians_float_impl, 'd->d': mathimpl.radians_float_impl}\n    db[np.radians] = db[np.deg2rad]\n    db[np.rad2deg] = {'f->f': mathimpl.degrees_float_impl, 'd->d': mathimpl.degrees_float_impl}\n    db[np.degrees] = db[np.rad2deg]\n    db[np.greater] = {'??->?': numbers.int_ugt_impl, 'bb->?': numbers.int_sgt_impl, 'BB->?': numbers.int_ugt_impl, 'hh->?': numbers.int_sgt_impl, 'HH->?': numbers.int_ugt_impl, 'ii->?': numbers.int_sgt_impl, 'II->?': numbers.int_ugt_impl, 'll->?': numbers.int_sgt_impl, 'LL->?': numbers.int_ugt_impl, 'qq->?': numbers.int_sgt_impl, 'QQ->?': numbers.int_ugt_impl, 'ff->?': numbers.real_gt_impl, 'dd->?': numbers.real_gt_impl, 'FF->?': npyfuncs.np_complex_gt_impl, 'DD->?': npyfuncs.np_complex_gt_impl}\n    if numpy_version >= (1, 25):\n        db[np.greater].update({'qQ->?': numbers.int_signed_unsigned_cmp('>'), 'Qq->?': numbers.int_unsigned_signed_cmp('>')})\n    db[np.greater_equal] = {'??->?': numbers.int_uge_impl, 'bb->?': numbers.int_sge_impl, 'BB->?': numbers.int_uge_impl, 'hh->?': numbers.int_sge_impl, 'HH->?': numbers.int_uge_impl, 'ii->?': numbers.int_sge_impl, 'II->?': numbers.int_uge_impl, 'll->?': numbers.int_sge_impl, 'LL->?': numbers.int_uge_impl, 'qq->?': numbers.int_sge_impl, 'QQ->?': numbers.int_uge_impl, 'ff->?': numbers.real_ge_impl, 'dd->?': numbers.real_ge_impl, 'FF->?': npyfuncs.np_complex_ge_impl, 'DD->?': npyfuncs.np_complex_ge_impl}\n    if numpy_version >= (1, 25):\n        db[np.greater_equal].update({'qQ->?': numbers.int_signed_unsigned_cmp('>='), 'Qq->?': numbers.int_unsigned_signed_cmp('>=')})\n    db[np.less] = {'??->?': numbers.int_ult_impl, 'bb->?': numbers.int_slt_impl, 'BB->?': numbers.int_ult_impl, 'hh->?': numbers.int_slt_impl, 'HH->?': numbers.int_ult_impl, 'ii->?': numbers.int_slt_impl, 'II->?': numbers.int_ult_impl, 'll->?': numbers.int_slt_impl, 'LL->?': numbers.int_ult_impl, 'qq->?': numbers.int_slt_impl, 'QQ->?': numbers.int_ult_impl, 'ff->?': numbers.real_lt_impl, 'dd->?': numbers.real_lt_impl, 'FF->?': npyfuncs.np_complex_lt_impl, 'DD->?': npyfuncs.np_complex_lt_impl}\n    if numpy_version >= (1, 25):\n        db[np.less].update({'qQ->?': numbers.int_signed_unsigned_cmp('<'), 'Qq->?': numbers.int_unsigned_signed_cmp('<')})\n    db[np.less_equal] = {'??->?': numbers.int_ule_impl, 'bb->?': numbers.int_sle_impl, 'BB->?': numbers.int_ule_impl, 'hh->?': numbers.int_sle_impl, 'HH->?': numbers.int_ule_impl, 'ii->?': numbers.int_sle_impl, 'II->?': numbers.int_ule_impl, 'll->?': numbers.int_sle_impl, 'LL->?': numbers.int_ule_impl, 'qq->?': numbers.int_sle_impl, 'QQ->?': numbers.int_ule_impl, 'ff->?': numbers.real_le_impl, 'dd->?': numbers.real_le_impl, 'FF->?': npyfuncs.np_complex_le_impl, 'DD->?': npyfuncs.np_complex_le_impl}\n    if numpy_version >= (1, 25):\n        db[np.less_equal].update({'qQ->?': numbers.int_signed_unsigned_cmp('<='), 'Qq->?': numbers.int_unsigned_signed_cmp('<=')})\n    db[np.not_equal] = {'??->?': numbers.int_ne_impl, 'bb->?': numbers.int_ne_impl, 'BB->?': numbers.int_ne_impl, 'hh->?': numbers.int_ne_impl, 'HH->?': numbers.int_ne_impl, 'ii->?': numbers.int_ne_impl, 'II->?': numbers.int_ne_impl, 'll->?': numbers.int_ne_impl, 'LL->?': numbers.int_ne_impl, 'qq->?': numbers.int_ne_impl, 'QQ->?': numbers.int_ne_impl, 'ff->?': numbers.real_ne_impl, 'dd->?': numbers.real_ne_impl, 'FF->?': npyfuncs.np_complex_ne_impl, 'DD->?': npyfuncs.np_complex_ne_impl}\n    if numpy_version >= (1, 25):\n        db[np.not_equal].update({'qQ->?': numbers.int_signed_unsigned_cmp('!='), 'Qq->?': numbers.int_unsigned_signed_cmp('!=')})\n    db[np.equal] = {'??->?': numbers.int_eq_impl, 'bb->?': numbers.int_eq_impl, 'BB->?': numbers.int_eq_impl, 'hh->?': numbers.int_eq_impl, 'HH->?': numbers.int_eq_impl, 'ii->?': numbers.int_eq_impl, 'II->?': numbers.int_eq_impl, 'll->?': numbers.int_eq_impl, 'LL->?': numbers.int_eq_impl, 'qq->?': numbers.int_eq_impl, 'QQ->?': numbers.int_eq_impl, 'ff->?': numbers.real_eq_impl, 'dd->?': numbers.real_eq_impl, 'FF->?': npyfuncs.np_complex_eq_impl, 'DD->?': npyfuncs.np_complex_eq_impl}\n    if numpy_version >= (1, 25):\n        db[np.equal].update({'qQ->?': numbers.int_signed_unsigned_cmp('=='), 'Qq->?': numbers.int_unsigned_signed_cmp('==')})\n    db[np.logical_and] = {'??->?': npyfuncs.np_logical_and_impl, 'bb->?': npyfuncs.np_logical_and_impl, 'BB->?': npyfuncs.np_logical_and_impl, 'hh->?': npyfuncs.np_logical_and_impl, 'HH->?': npyfuncs.np_logical_and_impl, 'ii->?': npyfuncs.np_logical_and_impl, 'II->?': npyfuncs.np_logical_and_impl, 'll->?': npyfuncs.np_logical_and_impl, 'LL->?': npyfuncs.np_logical_and_impl, 'qq->?': npyfuncs.np_logical_and_impl, 'QQ->?': npyfuncs.np_logical_and_impl, 'ff->?': npyfuncs.np_logical_and_impl, 'dd->?': npyfuncs.np_logical_and_impl, 'FF->?': npyfuncs.np_complex_logical_and_impl, 'DD->?': npyfuncs.np_complex_logical_and_impl}\n    db[np.logical_or] = {'??->?': npyfuncs.np_logical_or_impl, 'bb->?': npyfuncs.np_logical_or_impl, 'BB->?': npyfuncs.np_logical_or_impl, 'hh->?': npyfuncs.np_logical_or_impl, 'HH->?': npyfuncs.np_logical_or_impl, 'ii->?': npyfuncs.np_logical_or_impl, 'II->?': npyfuncs.np_logical_or_impl, 'll->?': npyfuncs.np_logical_or_impl, 'LL->?': npyfuncs.np_logical_or_impl, 'qq->?': npyfuncs.np_logical_or_impl, 'QQ->?': npyfuncs.np_logical_or_impl, 'ff->?': npyfuncs.np_logical_or_impl, 'dd->?': npyfuncs.np_logical_or_impl, 'FF->?': npyfuncs.np_complex_logical_or_impl, 'DD->?': npyfuncs.np_complex_logical_or_impl}\n    db[np.logical_xor] = {'??->?': npyfuncs.np_logical_xor_impl, 'bb->?': npyfuncs.np_logical_xor_impl, 'BB->?': npyfuncs.np_logical_xor_impl, 'hh->?': npyfuncs.np_logical_xor_impl, 'HH->?': npyfuncs.np_logical_xor_impl, 'ii->?': npyfuncs.np_logical_xor_impl, 'II->?': npyfuncs.np_logical_xor_impl, 'll->?': npyfuncs.np_logical_xor_impl, 'LL->?': npyfuncs.np_logical_xor_impl, 'qq->?': npyfuncs.np_logical_xor_impl, 'QQ->?': npyfuncs.np_logical_xor_impl, 'ff->?': npyfuncs.np_logical_xor_impl, 'dd->?': npyfuncs.np_logical_xor_impl, 'FF->?': npyfuncs.np_complex_logical_xor_impl, 'DD->?': npyfuncs.np_complex_logical_xor_impl}\n    db[np.logical_not] = {'?->?': npyfuncs.np_logical_not_impl, 'b->?': npyfuncs.np_logical_not_impl, 'B->?': npyfuncs.np_logical_not_impl, 'h->?': npyfuncs.np_logical_not_impl, 'H->?': npyfuncs.np_logical_not_impl, 'i->?': npyfuncs.np_logical_not_impl, 'I->?': npyfuncs.np_logical_not_impl, 'l->?': npyfuncs.np_logical_not_impl, 'L->?': npyfuncs.np_logical_not_impl, 'q->?': npyfuncs.np_logical_not_impl, 'Q->?': npyfuncs.np_logical_not_impl, 'f->?': npyfuncs.np_logical_not_impl, 'd->?': npyfuncs.np_logical_not_impl, 'F->?': npyfuncs.np_complex_logical_not_impl, 'D->?': npyfuncs.np_complex_logical_not_impl}\n    db[np.maximum] = {'??->?': npyfuncs.np_logical_or_impl, 'bb->b': npyfuncs.np_int_smax_impl, 'BB->B': npyfuncs.np_int_umax_impl, 'hh->h': npyfuncs.np_int_smax_impl, 'HH->H': npyfuncs.np_int_umax_impl, 'ii->i': npyfuncs.np_int_smax_impl, 'II->I': npyfuncs.np_int_umax_impl, 'll->l': npyfuncs.np_int_smax_impl, 'LL->L': npyfuncs.np_int_umax_impl, 'qq->q': npyfuncs.np_int_smax_impl, 'QQ->Q': npyfuncs.np_int_umax_impl, 'ff->f': npyfuncs.np_real_maximum_impl, 'dd->d': npyfuncs.np_real_maximum_impl, 'FF->F': npyfuncs.np_complex_maximum_impl, 'DD->D': npyfuncs.np_complex_maximum_impl}\n    db[np.minimum] = {'??->?': npyfuncs.np_logical_and_impl, 'bb->b': npyfuncs.np_int_smin_impl, 'BB->B': npyfuncs.np_int_umin_impl, 'hh->h': npyfuncs.np_int_smin_impl, 'HH->H': npyfuncs.np_int_umin_impl, 'ii->i': npyfuncs.np_int_smin_impl, 'II->I': npyfuncs.np_int_umin_impl, 'll->l': npyfuncs.np_int_smin_impl, 'LL->L': npyfuncs.np_int_umin_impl, 'qq->q': npyfuncs.np_int_smin_impl, 'QQ->Q': npyfuncs.np_int_umin_impl, 'ff->f': npyfuncs.np_real_minimum_impl, 'dd->d': npyfuncs.np_real_minimum_impl, 'FF->F': npyfuncs.np_complex_minimum_impl, 'DD->D': npyfuncs.np_complex_minimum_impl}\n    db[np.fmax] = {'??->?': npyfuncs.np_logical_or_impl, 'bb->b': npyfuncs.np_int_smax_impl, 'BB->B': npyfuncs.np_int_umax_impl, 'hh->h': npyfuncs.np_int_smax_impl, 'HH->H': npyfuncs.np_int_umax_impl, 'ii->i': npyfuncs.np_int_smax_impl, 'II->I': npyfuncs.np_int_umax_impl, 'll->l': npyfuncs.np_int_smax_impl, 'LL->L': npyfuncs.np_int_umax_impl, 'qq->q': npyfuncs.np_int_smax_impl, 'QQ->Q': npyfuncs.np_int_umax_impl, 'ff->f': npyfuncs.np_real_fmax_impl, 'dd->d': npyfuncs.np_real_fmax_impl, 'FF->F': npyfuncs.np_complex_fmax_impl, 'DD->D': npyfuncs.np_complex_fmax_impl}\n    db[np.fmin] = {'??->?': npyfuncs.np_logical_and_impl, 'bb->b': npyfuncs.np_int_smin_impl, 'BB->B': npyfuncs.np_int_umin_impl, 'hh->h': npyfuncs.np_int_smin_impl, 'HH->H': npyfuncs.np_int_umin_impl, 'ii->i': npyfuncs.np_int_smin_impl, 'II->I': npyfuncs.np_int_umin_impl, 'll->l': npyfuncs.np_int_smin_impl, 'LL->L': npyfuncs.np_int_umin_impl, 'qq->q': npyfuncs.np_int_smin_impl, 'QQ->Q': npyfuncs.np_int_umin_impl, 'ff->f': npyfuncs.np_real_fmin_impl, 'dd->d': npyfuncs.np_real_fmin_impl, 'FF->F': npyfuncs.np_complex_fmin_impl, 'DD->D': npyfuncs.np_complex_fmin_impl}\n    db[np.bitwise_and] = {'??->?': numbers.int_and_impl, 'bb->b': numbers.int_and_impl, 'BB->B': numbers.int_and_impl, 'hh->h': numbers.int_and_impl, 'HH->H': numbers.int_and_impl, 'ii->i': numbers.int_and_impl, 'II->I': numbers.int_and_impl, 'll->l': numbers.int_and_impl, 'LL->L': numbers.int_and_impl, 'qq->q': numbers.int_and_impl, 'QQ->Q': numbers.int_and_impl}\n    db[np.bitwise_or] = {'??->?': numbers.int_or_impl, 'bb->b': numbers.int_or_impl, 'BB->B': numbers.int_or_impl, 'hh->h': numbers.int_or_impl, 'HH->H': numbers.int_or_impl, 'ii->i': numbers.int_or_impl, 'II->I': numbers.int_or_impl, 'll->l': numbers.int_or_impl, 'LL->L': numbers.int_or_impl, 'qq->q': numbers.int_or_impl, 'QQ->Q': numbers.int_or_impl}\n    db[np.bitwise_xor] = {'??->?': numbers.int_xor_impl, 'bb->b': numbers.int_xor_impl, 'BB->B': numbers.int_xor_impl, 'hh->h': numbers.int_xor_impl, 'HH->H': numbers.int_xor_impl, 'ii->i': numbers.int_xor_impl, 'II->I': numbers.int_xor_impl, 'll->l': numbers.int_xor_impl, 'LL->L': numbers.int_xor_impl, 'qq->q': numbers.int_xor_impl, 'QQ->Q': numbers.int_xor_impl}\n    db[np.invert] = {'?->?': numbers.int_invert_impl, 'b->b': numbers.int_invert_impl, 'B->B': numbers.int_invert_impl, 'h->h': numbers.int_invert_impl, 'H->H': numbers.int_invert_impl, 'i->i': numbers.int_invert_impl, 'I->I': numbers.int_invert_impl, 'l->l': numbers.int_invert_impl, 'L->L': numbers.int_invert_impl, 'q->q': numbers.int_invert_impl, 'Q->Q': numbers.int_invert_impl}\n    db[np.left_shift] = {'bb->b': numbers.int_shl_impl, 'BB->B': numbers.int_shl_impl, 'hh->h': numbers.int_shl_impl, 'HH->H': numbers.int_shl_impl, 'ii->i': numbers.int_shl_impl, 'II->I': numbers.int_shl_impl, 'll->l': numbers.int_shl_impl, 'LL->L': numbers.int_shl_impl, 'qq->q': numbers.int_shl_impl, 'QQ->Q': numbers.int_shl_impl}\n    db[np.right_shift] = {'bb->b': numbers.int_shr_impl, 'BB->B': numbers.int_shr_impl, 'hh->h': numbers.int_shr_impl, 'HH->H': numbers.int_shr_impl, 'ii->i': numbers.int_shr_impl, 'II->I': numbers.int_shr_impl, 'll->l': numbers.int_shr_impl, 'LL->L': numbers.int_shr_impl, 'qq->q': numbers.int_shr_impl, 'QQ->Q': numbers.int_shr_impl}\n    return db",
            "@lru_cache\ndef ufunc_db():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    from numba.cpython import cmathimpl, mathimpl, numbers\n    from numba.np import npyfuncs\n    from numba.np.numpy_support import numpy_version\n\n    def np_unary_impl(fn, context, builder, sig, args):\n        npyfuncs._check_arity_and_homogeneity(sig, args, 1)\n        impl = get_unary_impl_for_fn_and_ty(fn, sig.args[0])\n        return impl(context, builder, sig, args)\n\n    def np_binary_impl(fn, context, builder, sig, args):\n        npyfuncs._check_arity_and_homogeneity(sig, args, 2)\n        impl = get_binary_impl_for_fn_and_ty(fn, sig.args[0])\n        return impl(context, builder, sig, args)\n\n    def np_real_sin_impl(context, builder, sig, args):\n        return np_unary_impl(math.sin, context, builder, sig, args)\n\n    def np_real_cos_impl(context, builder, sig, args):\n        return np_unary_impl(math.cos, context, builder, sig, args)\n\n    def np_real_tan_impl(context, builder, sig, args):\n        return np_unary_impl(math.tan, context, builder, sig, args)\n\n    def np_real_asin_impl(context, builder, sig, args):\n        return np_unary_impl(math.asin, context, builder, sig, args)\n\n    def np_real_acos_impl(context, builder, sig, args):\n        return np_unary_impl(math.acos, context, builder, sig, args)\n\n    def np_real_atan_impl(context, builder, sig, args):\n        return np_unary_impl(math.atan, context, builder, sig, args)\n\n    def np_real_atan2_impl(context, builder, sig, args):\n        return np_binary_impl(math.atan2, context, builder, sig, args)\n\n    def np_real_hypot_impl(context, builder, sig, args):\n        return np_binary_impl(math.hypot, context, builder, sig, args)\n\n    def np_real_sinh_impl(context, builder, sig, args):\n        return np_unary_impl(math.sinh, context, builder, sig, args)\n\n    def np_complex_sinh_impl(context, builder, sig, args):\n        npyfuncs._check_arity_and_homogeneity(sig, args, 1)\n        ty = sig.args[0]\n        fty = ty.underlying_float\n        fsig1 = typing.signature(*[fty] * 2)\n        x = context.make_complex(builder, ty, args[0])\n        out = context.make_complex(builder, ty)\n        xr = x.real\n        xi = x.imag\n        sxi = np_real_sin_impl(context, builder, fsig1, [xi])\n        shxr = np_real_sinh_impl(context, builder, fsig1, [xr])\n        cxi = np_real_cos_impl(context, builder, fsig1, [xi])\n        chxr = np_real_cosh_impl(context, builder, fsig1, [xr])\n        out.real = builder.fmul(cxi, shxr)\n        out.imag = builder.fmul(sxi, chxr)\n        return out._getvalue()\n\n    def np_real_cosh_impl(context, builder, sig, args):\n        return np_unary_impl(math.cosh, context, builder, sig, args)\n\n    def np_complex_cosh_impl(context, builder, sig, args):\n        npyfuncs._check_arity_and_homogeneity(sig, args, 1)\n        ty = sig.args[0]\n        fty = ty.underlying_float\n        fsig1 = typing.signature(*[fty] * 2)\n        x = context.make_complex(builder, ty, args[0])\n        out = context.make_complex(builder, ty)\n        xr = x.real\n        xi = x.imag\n        cxi = np_real_cos_impl(context, builder, fsig1, [xi])\n        chxr = np_real_cosh_impl(context, builder, fsig1, [xr])\n        sxi = np_real_sin_impl(context, builder, fsig1, [xi])\n        shxr = np_real_sinh_impl(context, builder, fsig1, [xr])\n        out.real = builder.fmul(cxi, chxr)\n        out.imag = builder.fmul(sxi, shxr)\n        return out._getvalue()\n\n    def np_real_tanh_impl(context, builder, sig, args):\n        return np_unary_impl(math.tanh, context, builder, sig, args)\n\n    def np_complex_tanh_impl(context, builder, sig, args):\n        npyfuncs._check_arity_and_homogeneity(sig, args, 1)\n        ty = sig.args[0]\n        fty = ty.underlying_float\n        fsig1 = typing.signature(*[fty] * 2)\n        ONE = context.get_constant(fty, 1.0)\n        x = context.make_complex(builder, ty, args[0])\n        out = context.make_complex(builder, ty)\n        xr = x.real\n        xi = x.imag\n        si = np_real_sin_impl(context, builder, fsig1, [xi])\n        ci = np_real_cos_impl(context, builder, fsig1, [xi])\n        shr = np_real_sinh_impl(context, builder, fsig1, [xr])\n        chr_ = np_real_cosh_impl(context, builder, fsig1, [xr])\n        rs = builder.fmul(ci, shr)\n        is_ = builder.fmul(si, chr_)\n        rc = builder.fmul(ci, chr_)\n        ic = builder.fmul(si, shr)\n        sqr_rc = builder.fmul(rc, rc)\n        sqr_ic = builder.fmul(ic, ic)\n        d = builder.fadd(sqr_rc, sqr_ic)\n        inv_d = builder.fdiv(ONE, d)\n        rs_rc = builder.fmul(rs, rc)\n        is_ic = builder.fmul(is_, ic)\n        is_rc = builder.fmul(is_, rc)\n        rs_ic = builder.fmul(rs, ic)\n        numr = builder.fadd(rs_rc, is_ic)\n        numi = builder.fsub(is_rc, rs_ic)\n        out.real = builder.fmul(numr, inv_d)\n        out.imag = builder.fmul(numi, inv_d)\n        return out._getvalue()\n\n    def np_real_asinh_impl(context, builder, sig, args):\n        return np_unary_impl(math.asinh, context, builder, sig, args)\n\n    def np_real_acosh_impl(context, builder, sig, args):\n        return np_unary_impl(math.acosh, context, builder, sig, args)\n\n    def np_real_atanh_impl(context, builder, sig, args):\n        return np_unary_impl(math.atanh, context, builder, sig, args)\n    db = {}\n    db[np.sin] = {'f->f': np_real_sin_impl, 'd->d': np_real_sin_impl, 'F->F': npyfuncs.np_complex_sin_impl, 'D->D': npyfuncs.np_complex_sin_impl}\n    db[np.cos] = {'f->f': np_real_cos_impl, 'd->d': np_real_cos_impl, 'F->F': npyfuncs.np_complex_cos_impl, 'D->D': npyfuncs.np_complex_cos_impl}\n    db[np.tan] = {'f->f': np_real_tan_impl, 'd->d': np_real_tan_impl, 'F->F': cmathimpl.tan_impl, 'D->D': cmathimpl.tan_impl}\n    db[np.arcsin] = {'f->f': np_real_asin_impl, 'd->d': np_real_asin_impl, 'F->F': cmathimpl.asin_impl, 'D->D': cmathimpl.asin_impl}\n    db[np.arccos] = {'f->f': np_real_acos_impl, 'd->d': np_real_acos_impl, 'F->F': cmathimpl.acos_impl, 'D->D': cmathimpl.acos_impl}\n    db[np.arctan] = {'f->f': np_real_atan_impl, 'd->d': np_real_atan_impl, 'F->F': cmathimpl.atan_impl, 'D->D': cmathimpl.atan_impl}\n    db[np.arctan2] = {'ff->f': np_real_atan2_impl, 'dd->d': np_real_atan2_impl}\n    db[np.hypot] = {'ff->f': np_real_hypot_impl, 'dd->d': np_real_hypot_impl}\n    db[np.sinh] = {'f->f': np_real_sinh_impl, 'd->d': np_real_sinh_impl, 'F->F': np_complex_sinh_impl, 'D->D': np_complex_sinh_impl}\n    db[np.cosh] = {'f->f': np_real_cosh_impl, 'd->d': np_real_cosh_impl, 'F->F': np_complex_cosh_impl, 'D->D': np_complex_cosh_impl}\n    db[np.tanh] = {'f->f': np_real_tanh_impl, 'd->d': np_real_tanh_impl, 'F->F': np_complex_tanh_impl, 'D->D': np_complex_tanh_impl}\n    db[np.arcsinh] = {'f->f': np_real_asinh_impl, 'd->d': np_real_asinh_impl, 'F->F': cmathimpl.asinh_impl, 'D->D': cmathimpl.asinh_impl}\n    db[np.arccosh] = {'f->f': np_real_acosh_impl, 'd->d': np_real_acosh_impl, 'F->F': npyfuncs.np_complex_acosh_impl, 'D->D': npyfuncs.np_complex_acosh_impl}\n    db[np.arctanh] = {'f->f': np_real_atanh_impl, 'd->d': np_real_atanh_impl, 'F->F': cmathimpl.atanh_impl, 'D->D': cmathimpl.atanh_impl}\n    db[np.deg2rad] = {'f->f': mathimpl.radians_float_impl, 'd->d': mathimpl.radians_float_impl}\n    db[np.radians] = db[np.deg2rad]\n    db[np.rad2deg] = {'f->f': mathimpl.degrees_float_impl, 'd->d': mathimpl.degrees_float_impl}\n    db[np.degrees] = db[np.rad2deg]\n    db[np.greater] = {'??->?': numbers.int_ugt_impl, 'bb->?': numbers.int_sgt_impl, 'BB->?': numbers.int_ugt_impl, 'hh->?': numbers.int_sgt_impl, 'HH->?': numbers.int_ugt_impl, 'ii->?': numbers.int_sgt_impl, 'II->?': numbers.int_ugt_impl, 'll->?': numbers.int_sgt_impl, 'LL->?': numbers.int_ugt_impl, 'qq->?': numbers.int_sgt_impl, 'QQ->?': numbers.int_ugt_impl, 'ff->?': numbers.real_gt_impl, 'dd->?': numbers.real_gt_impl, 'FF->?': npyfuncs.np_complex_gt_impl, 'DD->?': npyfuncs.np_complex_gt_impl}\n    if numpy_version >= (1, 25):\n        db[np.greater].update({'qQ->?': numbers.int_signed_unsigned_cmp('>'), 'Qq->?': numbers.int_unsigned_signed_cmp('>')})\n    db[np.greater_equal] = {'??->?': numbers.int_uge_impl, 'bb->?': numbers.int_sge_impl, 'BB->?': numbers.int_uge_impl, 'hh->?': numbers.int_sge_impl, 'HH->?': numbers.int_uge_impl, 'ii->?': numbers.int_sge_impl, 'II->?': numbers.int_uge_impl, 'll->?': numbers.int_sge_impl, 'LL->?': numbers.int_uge_impl, 'qq->?': numbers.int_sge_impl, 'QQ->?': numbers.int_uge_impl, 'ff->?': numbers.real_ge_impl, 'dd->?': numbers.real_ge_impl, 'FF->?': npyfuncs.np_complex_ge_impl, 'DD->?': npyfuncs.np_complex_ge_impl}\n    if numpy_version >= (1, 25):\n        db[np.greater_equal].update({'qQ->?': numbers.int_signed_unsigned_cmp('>='), 'Qq->?': numbers.int_unsigned_signed_cmp('>=')})\n    db[np.less] = {'??->?': numbers.int_ult_impl, 'bb->?': numbers.int_slt_impl, 'BB->?': numbers.int_ult_impl, 'hh->?': numbers.int_slt_impl, 'HH->?': numbers.int_ult_impl, 'ii->?': numbers.int_slt_impl, 'II->?': numbers.int_ult_impl, 'll->?': numbers.int_slt_impl, 'LL->?': numbers.int_ult_impl, 'qq->?': numbers.int_slt_impl, 'QQ->?': numbers.int_ult_impl, 'ff->?': numbers.real_lt_impl, 'dd->?': numbers.real_lt_impl, 'FF->?': npyfuncs.np_complex_lt_impl, 'DD->?': npyfuncs.np_complex_lt_impl}\n    if numpy_version >= (1, 25):\n        db[np.less].update({'qQ->?': numbers.int_signed_unsigned_cmp('<'), 'Qq->?': numbers.int_unsigned_signed_cmp('<')})\n    db[np.less_equal] = {'??->?': numbers.int_ule_impl, 'bb->?': numbers.int_sle_impl, 'BB->?': numbers.int_ule_impl, 'hh->?': numbers.int_sle_impl, 'HH->?': numbers.int_ule_impl, 'ii->?': numbers.int_sle_impl, 'II->?': numbers.int_ule_impl, 'll->?': numbers.int_sle_impl, 'LL->?': numbers.int_ule_impl, 'qq->?': numbers.int_sle_impl, 'QQ->?': numbers.int_ule_impl, 'ff->?': numbers.real_le_impl, 'dd->?': numbers.real_le_impl, 'FF->?': npyfuncs.np_complex_le_impl, 'DD->?': npyfuncs.np_complex_le_impl}\n    if numpy_version >= (1, 25):\n        db[np.less_equal].update({'qQ->?': numbers.int_signed_unsigned_cmp('<='), 'Qq->?': numbers.int_unsigned_signed_cmp('<=')})\n    db[np.not_equal] = {'??->?': numbers.int_ne_impl, 'bb->?': numbers.int_ne_impl, 'BB->?': numbers.int_ne_impl, 'hh->?': numbers.int_ne_impl, 'HH->?': numbers.int_ne_impl, 'ii->?': numbers.int_ne_impl, 'II->?': numbers.int_ne_impl, 'll->?': numbers.int_ne_impl, 'LL->?': numbers.int_ne_impl, 'qq->?': numbers.int_ne_impl, 'QQ->?': numbers.int_ne_impl, 'ff->?': numbers.real_ne_impl, 'dd->?': numbers.real_ne_impl, 'FF->?': npyfuncs.np_complex_ne_impl, 'DD->?': npyfuncs.np_complex_ne_impl}\n    if numpy_version >= (1, 25):\n        db[np.not_equal].update({'qQ->?': numbers.int_signed_unsigned_cmp('!='), 'Qq->?': numbers.int_unsigned_signed_cmp('!=')})\n    db[np.equal] = {'??->?': numbers.int_eq_impl, 'bb->?': numbers.int_eq_impl, 'BB->?': numbers.int_eq_impl, 'hh->?': numbers.int_eq_impl, 'HH->?': numbers.int_eq_impl, 'ii->?': numbers.int_eq_impl, 'II->?': numbers.int_eq_impl, 'll->?': numbers.int_eq_impl, 'LL->?': numbers.int_eq_impl, 'qq->?': numbers.int_eq_impl, 'QQ->?': numbers.int_eq_impl, 'ff->?': numbers.real_eq_impl, 'dd->?': numbers.real_eq_impl, 'FF->?': npyfuncs.np_complex_eq_impl, 'DD->?': npyfuncs.np_complex_eq_impl}\n    if numpy_version >= (1, 25):\n        db[np.equal].update({'qQ->?': numbers.int_signed_unsigned_cmp('=='), 'Qq->?': numbers.int_unsigned_signed_cmp('==')})\n    db[np.logical_and] = {'??->?': npyfuncs.np_logical_and_impl, 'bb->?': npyfuncs.np_logical_and_impl, 'BB->?': npyfuncs.np_logical_and_impl, 'hh->?': npyfuncs.np_logical_and_impl, 'HH->?': npyfuncs.np_logical_and_impl, 'ii->?': npyfuncs.np_logical_and_impl, 'II->?': npyfuncs.np_logical_and_impl, 'll->?': npyfuncs.np_logical_and_impl, 'LL->?': npyfuncs.np_logical_and_impl, 'qq->?': npyfuncs.np_logical_and_impl, 'QQ->?': npyfuncs.np_logical_and_impl, 'ff->?': npyfuncs.np_logical_and_impl, 'dd->?': npyfuncs.np_logical_and_impl, 'FF->?': npyfuncs.np_complex_logical_and_impl, 'DD->?': npyfuncs.np_complex_logical_and_impl}\n    db[np.logical_or] = {'??->?': npyfuncs.np_logical_or_impl, 'bb->?': npyfuncs.np_logical_or_impl, 'BB->?': npyfuncs.np_logical_or_impl, 'hh->?': npyfuncs.np_logical_or_impl, 'HH->?': npyfuncs.np_logical_or_impl, 'ii->?': npyfuncs.np_logical_or_impl, 'II->?': npyfuncs.np_logical_or_impl, 'll->?': npyfuncs.np_logical_or_impl, 'LL->?': npyfuncs.np_logical_or_impl, 'qq->?': npyfuncs.np_logical_or_impl, 'QQ->?': npyfuncs.np_logical_or_impl, 'ff->?': npyfuncs.np_logical_or_impl, 'dd->?': npyfuncs.np_logical_or_impl, 'FF->?': npyfuncs.np_complex_logical_or_impl, 'DD->?': npyfuncs.np_complex_logical_or_impl}\n    db[np.logical_xor] = {'??->?': npyfuncs.np_logical_xor_impl, 'bb->?': npyfuncs.np_logical_xor_impl, 'BB->?': npyfuncs.np_logical_xor_impl, 'hh->?': npyfuncs.np_logical_xor_impl, 'HH->?': npyfuncs.np_logical_xor_impl, 'ii->?': npyfuncs.np_logical_xor_impl, 'II->?': npyfuncs.np_logical_xor_impl, 'll->?': npyfuncs.np_logical_xor_impl, 'LL->?': npyfuncs.np_logical_xor_impl, 'qq->?': npyfuncs.np_logical_xor_impl, 'QQ->?': npyfuncs.np_logical_xor_impl, 'ff->?': npyfuncs.np_logical_xor_impl, 'dd->?': npyfuncs.np_logical_xor_impl, 'FF->?': npyfuncs.np_complex_logical_xor_impl, 'DD->?': npyfuncs.np_complex_logical_xor_impl}\n    db[np.logical_not] = {'?->?': npyfuncs.np_logical_not_impl, 'b->?': npyfuncs.np_logical_not_impl, 'B->?': npyfuncs.np_logical_not_impl, 'h->?': npyfuncs.np_logical_not_impl, 'H->?': npyfuncs.np_logical_not_impl, 'i->?': npyfuncs.np_logical_not_impl, 'I->?': npyfuncs.np_logical_not_impl, 'l->?': npyfuncs.np_logical_not_impl, 'L->?': npyfuncs.np_logical_not_impl, 'q->?': npyfuncs.np_logical_not_impl, 'Q->?': npyfuncs.np_logical_not_impl, 'f->?': npyfuncs.np_logical_not_impl, 'd->?': npyfuncs.np_logical_not_impl, 'F->?': npyfuncs.np_complex_logical_not_impl, 'D->?': npyfuncs.np_complex_logical_not_impl}\n    db[np.maximum] = {'??->?': npyfuncs.np_logical_or_impl, 'bb->b': npyfuncs.np_int_smax_impl, 'BB->B': npyfuncs.np_int_umax_impl, 'hh->h': npyfuncs.np_int_smax_impl, 'HH->H': npyfuncs.np_int_umax_impl, 'ii->i': npyfuncs.np_int_smax_impl, 'II->I': npyfuncs.np_int_umax_impl, 'll->l': npyfuncs.np_int_smax_impl, 'LL->L': npyfuncs.np_int_umax_impl, 'qq->q': npyfuncs.np_int_smax_impl, 'QQ->Q': npyfuncs.np_int_umax_impl, 'ff->f': npyfuncs.np_real_maximum_impl, 'dd->d': npyfuncs.np_real_maximum_impl, 'FF->F': npyfuncs.np_complex_maximum_impl, 'DD->D': npyfuncs.np_complex_maximum_impl}\n    db[np.minimum] = {'??->?': npyfuncs.np_logical_and_impl, 'bb->b': npyfuncs.np_int_smin_impl, 'BB->B': npyfuncs.np_int_umin_impl, 'hh->h': npyfuncs.np_int_smin_impl, 'HH->H': npyfuncs.np_int_umin_impl, 'ii->i': npyfuncs.np_int_smin_impl, 'II->I': npyfuncs.np_int_umin_impl, 'll->l': npyfuncs.np_int_smin_impl, 'LL->L': npyfuncs.np_int_umin_impl, 'qq->q': npyfuncs.np_int_smin_impl, 'QQ->Q': npyfuncs.np_int_umin_impl, 'ff->f': npyfuncs.np_real_minimum_impl, 'dd->d': npyfuncs.np_real_minimum_impl, 'FF->F': npyfuncs.np_complex_minimum_impl, 'DD->D': npyfuncs.np_complex_minimum_impl}\n    db[np.fmax] = {'??->?': npyfuncs.np_logical_or_impl, 'bb->b': npyfuncs.np_int_smax_impl, 'BB->B': npyfuncs.np_int_umax_impl, 'hh->h': npyfuncs.np_int_smax_impl, 'HH->H': npyfuncs.np_int_umax_impl, 'ii->i': npyfuncs.np_int_smax_impl, 'II->I': npyfuncs.np_int_umax_impl, 'll->l': npyfuncs.np_int_smax_impl, 'LL->L': npyfuncs.np_int_umax_impl, 'qq->q': npyfuncs.np_int_smax_impl, 'QQ->Q': npyfuncs.np_int_umax_impl, 'ff->f': npyfuncs.np_real_fmax_impl, 'dd->d': npyfuncs.np_real_fmax_impl, 'FF->F': npyfuncs.np_complex_fmax_impl, 'DD->D': npyfuncs.np_complex_fmax_impl}\n    db[np.fmin] = {'??->?': npyfuncs.np_logical_and_impl, 'bb->b': npyfuncs.np_int_smin_impl, 'BB->B': npyfuncs.np_int_umin_impl, 'hh->h': npyfuncs.np_int_smin_impl, 'HH->H': npyfuncs.np_int_umin_impl, 'ii->i': npyfuncs.np_int_smin_impl, 'II->I': npyfuncs.np_int_umin_impl, 'll->l': npyfuncs.np_int_smin_impl, 'LL->L': npyfuncs.np_int_umin_impl, 'qq->q': npyfuncs.np_int_smin_impl, 'QQ->Q': npyfuncs.np_int_umin_impl, 'ff->f': npyfuncs.np_real_fmin_impl, 'dd->d': npyfuncs.np_real_fmin_impl, 'FF->F': npyfuncs.np_complex_fmin_impl, 'DD->D': npyfuncs.np_complex_fmin_impl}\n    db[np.bitwise_and] = {'??->?': numbers.int_and_impl, 'bb->b': numbers.int_and_impl, 'BB->B': numbers.int_and_impl, 'hh->h': numbers.int_and_impl, 'HH->H': numbers.int_and_impl, 'ii->i': numbers.int_and_impl, 'II->I': numbers.int_and_impl, 'll->l': numbers.int_and_impl, 'LL->L': numbers.int_and_impl, 'qq->q': numbers.int_and_impl, 'QQ->Q': numbers.int_and_impl}\n    db[np.bitwise_or] = {'??->?': numbers.int_or_impl, 'bb->b': numbers.int_or_impl, 'BB->B': numbers.int_or_impl, 'hh->h': numbers.int_or_impl, 'HH->H': numbers.int_or_impl, 'ii->i': numbers.int_or_impl, 'II->I': numbers.int_or_impl, 'll->l': numbers.int_or_impl, 'LL->L': numbers.int_or_impl, 'qq->q': numbers.int_or_impl, 'QQ->Q': numbers.int_or_impl}\n    db[np.bitwise_xor] = {'??->?': numbers.int_xor_impl, 'bb->b': numbers.int_xor_impl, 'BB->B': numbers.int_xor_impl, 'hh->h': numbers.int_xor_impl, 'HH->H': numbers.int_xor_impl, 'ii->i': numbers.int_xor_impl, 'II->I': numbers.int_xor_impl, 'll->l': numbers.int_xor_impl, 'LL->L': numbers.int_xor_impl, 'qq->q': numbers.int_xor_impl, 'QQ->Q': numbers.int_xor_impl}\n    db[np.invert] = {'?->?': numbers.int_invert_impl, 'b->b': numbers.int_invert_impl, 'B->B': numbers.int_invert_impl, 'h->h': numbers.int_invert_impl, 'H->H': numbers.int_invert_impl, 'i->i': numbers.int_invert_impl, 'I->I': numbers.int_invert_impl, 'l->l': numbers.int_invert_impl, 'L->L': numbers.int_invert_impl, 'q->q': numbers.int_invert_impl, 'Q->Q': numbers.int_invert_impl}\n    db[np.left_shift] = {'bb->b': numbers.int_shl_impl, 'BB->B': numbers.int_shl_impl, 'hh->h': numbers.int_shl_impl, 'HH->H': numbers.int_shl_impl, 'ii->i': numbers.int_shl_impl, 'II->I': numbers.int_shl_impl, 'll->l': numbers.int_shl_impl, 'LL->L': numbers.int_shl_impl, 'qq->q': numbers.int_shl_impl, 'QQ->Q': numbers.int_shl_impl}\n    db[np.right_shift] = {'bb->b': numbers.int_shr_impl, 'BB->B': numbers.int_shr_impl, 'hh->h': numbers.int_shr_impl, 'HH->H': numbers.int_shr_impl, 'ii->i': numbers.int_shr_impl, 'II->I': numbers.int_shr_impl, 'll->l': numbers.int_shr_impl, 'LL->L': numbers.int_shr_impl, 'qq->q': numbers.int_shr_impl, 'QQ->Q': numbers.int_shr_impl}\n    return db",
            "@lru_cache\ndef ufunc_db():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    from numba.cpython import cmathimpl, mathimpl, numbers\n    from numba.np import npyfuncs\n    from numba.np.numpy_support import numpy_version\n\n    def np_unary_impl(fn, context, builder, sig, args):\n        npyfuncs._check_arity_and_homogeneity(sig, args, 1)\n        impl = get_unary_impl_for_fn_and_ty(fn, sig.args[0])\n        return impl(context, builder, sig, args)\n\n    def np_binary_impl(fn, context, builder, sig, args):\n        npyfuncs._check_arity_and_homogeneity(sig, args, 2)\n        impl = get_binary_impl_for_fn_and_ty(fn, sig.args[0])\n        return impl(context, builder, sig, args)\n\n    def np_real_sin_impl(context, builder, sig, args):\n        return np_unary_impl(math.sin, context, builder, sig, args)\n\n    def np_real_cos_impl(context, builder, sig, args):\n        return np_unary_impl(math.cos, context, builder, sig, args)\n\n    def np_real_tan_impl(context, builder, sig, args):\n        return np_unary_impl(math.tan, context, builder, sig, args)\n\n    def np_real_asin_impl(context, builder, sig, args):\n        return np_unary_impl(math.asin, context, builder, sig, args)\n\n    def np_real_acos_impl(context, builder, sig, args):\n        return np_unary_impl(math.acos, context, builder, sig, args)\n\n    def np_real_atan_impl(context, builder, sig, args):\n        return np_unary_impl(math.atan, context, builder, sig, args)\n\n    def np_real_atan2_impl(context, builder, sig, args):\n        return np_binary_impl(math.atan2, context, builder, sig, args)\n\n    def np_real_hypot_impl(context, builder, sig, args):\n        return np_binary_impl(math.hypot, context, builder, sig, args)\n\n    def np_real_sinh_impl(context, builder, sig, args):\n        return np_unary_impl(math.sinh, context, builder, sig, args)\n\n    def np_complex_sinh_impl(context, builder, sig, args):\n        npyfuncs._check_arity_and_homogeneity(sig, args, 1)\n        ty = sig.args[0]\n        fty = ty.underlying_float\n        fsig1 = typing.signature(*[fty] * 2)\n        x = context.make_complex(builder, ty, args[0])\n        out = context.make_complex(builder, ty)\n        xr = x.real\n        xi = x.imag\n        sxi = np_real_sin_impl(context, builder, fsig1, [xi])\n        shxr = np_real_sinh_impl(context, builder, fsig1, [xr])\n        cxi = np_real_cos_impl(context, builder, fsig1, [xi])\n        chxr = np_real_cosh_impl(context, builder, fsig1, [xr])\n        out.real = builder.fmul(cxi, shxr)\n        out.imag = builder.fmul(sxi, chxr)\n        return out._getvalue()\n\n    def np_real_cosh_impl(context, builder, sig, args):\n        return np_unary_impl(math.cosh, context, builder, sig, args)\n\n    def np_complex_cosh_impl(context, builder, sig, args):\n        npyfuncs._check_arity_and_homogeneity(sig, args, 1)\n        ty = sig.args[0]\n        fty = ty.underlying_float\n        fsig1 = typing.signature(*[fty] * 2)\n        x = context.make_complex(builder, ty, args[0])\n        out = context.make_complex(builder, ty)\n        xr = x.real\n        xi = x.imag\n        cxi = np_real_cos_impl(context, builder, fsig1, [xi])\n        chxr = np_real_cosh_impl(context, builder, fsig1, [xr])\n        sxi = np_real_sin_impl(context, builder, fsig1, [xi])\n        shxr = np_real_sinh_impl(context, builder, fsig1, [xr])\n        out.real = builder.fmul(cxi, chxr)\n        out.imag = builder.fmul(sxi, shxr)\n        return out._getvalue()\n\n    def np_real_tanh_impl(context, builder, sig, args):\n        return np_unary_impl(math.tanh, context, builder, sig, args)\n\n    def np_complex_tanh_impl(context, builder, sig, args):\n        npyfuncs._check_arity_and_homogeneity(sig, args, 1)\n        ty = sig.args[0]\n        fty = ty.underlying_float\n        fsig1 = typing.signature(*[fty] * 2)\n        ONE = context.get_constant(fty, 1.0)\n        x = context.make_complex(builder, ty, args[0])\n        out = context.make_complex(builder, ty)\n        xr = x.real\n        xi = x.imag\n        si = np_real_sin_impl(context, builder, fsig1, [xi])\n        ci = np_real_cos_impl(context, builder, fsig1, [xi])\n        shr = np_real_sinh_impl(context, builder, fsig1, [xr])\n        chr_ = np_real_cosh_impl(context, builder, fsig1, [xr])\n        rs = builder.fmul(ci, shr)\n        is_ = builder.fmul(si, chr_)\n        rc = builder.fmul(ci, chr_)\n        ic = builder.fmul(si, shr)\n        sqr_rc = builder.fmul(rc, rc)\n        sqr_ic = builder.fmul(ic, ic)\n        d = builder.fadd(sqr_rc, sqr_ic)\n        inv_d = builder.fdiv(ONE, d)\n        rs_rc = builder.fmul(rs, rc)\n        is_ic = builder.fmul(is_, ic)\n        is_rc = builder.fmul(is_, rc)\n        rs_ic = builder.fmul(rs, ic)\n        numr = builder.fadd(rs_rc, is_ic)\n        numi = builder.fsub(is_rc, rs_ic)\n        out.real = builder.fmul(numr, inv_d)\n        out.imag = builder.fmul(numi, inv_d)\n        return out._getvalue()\n\n    def np_real_asinh_impl(context, builder, sig, args):\n        return np_unary_impl(math.asinh, context, builder, sig, args)\n\n    def np_real_acosh_impl(context, builder, sig, args):\n        return np_unary_impl(math.acosh, context, builder, sig, args)\n\n    def np_real_atanh_impl(context, builder, sig, args):\n        return np_unary_impl(math.atanh, context, builder, sig, args)\n    db = {}\n    db[np.sin] = {'f->f': np_real_sin_impl, 'd->d': np_real_sin_impl, 'F->F': npyfuncs.np_complex_sin_impl, 'D->D': npyfuncs.np_complex_sin_impl}\n    db[np.cos] = {'f->f': np_real_cos_impl, 'd->d': np_real_cos_impl, 'F->F': npyfuncs.np_complex_cos_impl, 'D->D': npyfuncs.np_complex_cos_impl}\n    db[np.tan] = {'f->f': np_real_tan_impl, 'd->d': np_real_tan_impl, 'F->F': cmathimpl.tan_impl, 'D->D': cmathimpl.tan_impl}\n    db[np.arcsin] = {'f->f': np_real_asin_impl, 'd->d': np_real_asin_impl, 'F->F': cmathimpl.asin_impl, 'D->D': cmathimpl.asin_impl}\n    db[np.arccos] = {'f->f': np_real_acos_impl, 'd->d': np_real_acos_impl, 'F->F': cmathimpl.acos_impl, 'D->D': cmathimpl.acos_impl}\n    db[np.arctan] = {'f->f': np_real_atan_impl, 'd->d': np_real_atan_impl, 'F->F': cmathimpl.atan_impl, 'D->D': cmathimpl.atan_impl}\n    db[np.arctan2] = {'ff->f': np_real_atan2_impl, 'dd->d': np_real_atan2_impl}\n    db[np.hypot] = {'ff->f': np_real_hypot_impl, 'dd->d': np_real_hypot_impl}\n    db[np.sinh] = {'f->f': np_real_sinh_impl, 'd->d': np_real_sinh_impl, 'F->F': np_complex_sinh_impl, 'D->D': np_complex_sinh_impl}\n    db[np.cosh] = {'f->f': np_real_cosh_impl, 'd->d': np_real_cosh_impl, 'F->F': np_complex_cosh_impl, 'D->D': np_complex_cosh_impl}\n    db[np.tanh] = {'f->f': np_real_tanh_impl, 'd->d': np_real_tanh_impl, 'F->F': np_complex_tanh_impl, 'D->D': np_complex_tanh_impl}\n    db[np.arcsinh] = {'f->f': np_real_asinh_impl, 'd->d': np_real_asinh_impl, 'F->F': cmathimpl.asinh_impl, 'D->D': cmathimpl.asinh_impl}\n    db[np.arccosh] = {'f->f': np_real_acosh_impl, 'd->d': np_real_acosh_impl, 'F->F': npyfuncs.np_complex_acosh_impl, 'D->D': npyfuncs.np_complex_acosh_impl}\n    db[np.arctanh] = {'f->f': np_real_atanh_impl, 'd->d': np_real_atanh_impl, 'F->F': cmathimpl.atanh_impl, 'D->D': cmathimpl.atanh_impl}\n    db[np.deg2rad] = {'f->f': mathimpl.radians_float_impl, 'd->d': mathimpl.radians_float_impl}\n    db[np.radians] = db[np.deg2rad]\n    db[np.rad2deg] = {'f->f': mathimpl.degrees_float_impl, 'd->d': mathimpl.degrees_float_impl}\n    db[np.degrees] = db[np.rad2deg]\n    db[np.greater] = {'??->?': numbers.int_ugt_impl, 'bb->?': numbers.int_sgt_impl, 'BB->?': numbers.int_ugt_impl, 'hh->?': numbers.int_sgt_impl, 'HH->?': numbers.int_ugt_impl, 'ii->?': numbers.int_sgt_impl, 'II->?': numbers.int_ugt_impl, 'll->?': numbers.int_sgt_impl, 'LL->?': numbers.int_ugt_impl, 'qq->?': numbers.int_sgt_impl, 'QQ->?': numbers.int_ugt_impl, 'ff->?': numbers.real_gt_impl, 'dd->?': numbers.real_gt_impl, 'FF->?': npyfuncs.np_complex_gt_impl, 'DD->?': npyfuncs.np_complex_gt_impl}\n    if numpy_version >= (1, 25):\n        db[np.greater].update({'qQ->?': numbers.int_signed_unsigned_cmp('>'), 'Qq->?': numbers.int_unsigned_signed_cmp('>')})\n    db[np.greater_equal] = {'??->?': numbers.int_uge_impl, 'bb->?': numbers.int_sge_impl, 'BB->?': numbers.int_uge_impl, 'hh->?': numbers.int_sge_impl, 'HH->?': numbers.int_uge_impl, 'ii->?': numbers.int_sge_impl, 'II->?': numbers.int_uge_impl, 'll->?': numbers.int_sge_impl, 'LL->?': numbers.int_uge_impl, 'qq->?': numbers.int_sge_impl, 'QQ->?': numbers.int_uge_impl, 'ff->?': numbers.real_ge_impl, 'dd->?': numbers.real_ge_impl, 'FF->?': npyfuncs.np_complex_ge_impl, 'DD->?': npyfuncs.np_complex_ge_impl}\n    if numpy_version >= (1, 25):\n        db[np.greater_equal].update({'qQ->?': numbers.int_signed_unsigned_cmp('>='), 'Qq->?': numbers.int_unsigned_signed_cmp('>=')})\n    db[np.less] = {'??->?': numbers.int_ult_impl, 'bb->?': numbers.int_slt_impl, 'BB->?': numbers.int_ult_impl, 'hh->?': numbers.int_slt_impl, 'HH->?': numbers.int_ult_impl, 'ii->?': numbers.int_slt_impl, 'II->?': numbers.int_ult_impl, 'll->?': numbers.int_slt_impl, 'LL->?': numbers.int_ult_impl, 'qq->?': numbers.int_slt_impl, 'QQ->?': numbers.int_ult_impl, 'ff->?': numbers.real_lt_impl, 'dd->?': numbers.real_lt_impl, 'FF->?': npyfuncs.np_complex_lt_impl, 'DD->?': npyfuncs.np_complex_lt_impl}\n    if numpy_version >= (1, 25):\n        db[np.less].update({'qQ->?': numbers.int_signed_unsigned_cmp('<'), 'Qq->?': numbers.int_unsigned_signed_cmp('<')})\n    db[np.less_equal] = {'??->?': numbers.int_ule_impl, 'bb->?': numbers.int_sle_impl, 'BB->?': numbers.int_ule_impl, 'hh->?': numbers.int_sle_impl, 'HH->?': numbers.int_ule_impl, 'ii->?': numbers.int_sle_impl, 'II->?': numbers.int_ule_impl, 'll->?': numbers.int_sle_impl, 'LL->?': numbers.int_ule_impl, 'qq->?': numbers.int_sle_impl, 'QQ->?': numbers.int_ule_impl, 'ff->?': numbers.real_le_impl, 'dd->?': numbers.real_le_impl, 'FF->?': npyfuncs.np_complex_le_impl, 'DD->?': npyfuncs.np_complex_le_impl}\n    if numpy_version >= (1, 25):\n        db[np.less_equal].update({'qQ->?': numbers.int_signed_unsigned_cmp('<='), 'Qq->?': numbers.int_unsigned_signed_cmp('<=')})\n    db[np.not_equal] = {'??->?': numbers.int_ne_impl, 'bb->?': numbers.int_ne_impl, 'BB->?': numbers.int_ne_impl, 'hh->?': numbers.int_ne_impl, 'HH->?': numbers.int_ne_impl, 'ii->?': numbers.int_ne_impl, 'II->?': numbers.int_ne_impl, 'll->?': numbers.int_ne_impl, 'LL->?': numbers.int_ne_impl, 'qq->?': numbers.int_ne_impl, 'QQ->?': numbers.int_ne_impl, 'ff->?': numbers.real_ne_impl, 'dd->?': numbers.real_ne_impl, 'FF->?': npyfuncs.np_complex_ne_impl, 'DD->?': npyfuncs.np_complex_ne_impl}\n    if numpy_version >= (1, 25):\n        db[np.not_equal].update({'qQ->?': numbers.int_signed_unsigned_cmp('!='), 'Qq->?': numbers.int_unsigned_signed_cmp('!=')})\n    db[np.equal] = {'??->?': numbers.int_eq_impl, 'bb->?': numbers.int_eq_impl, 'BB->?': numbers.int_eq_impl, 'hh->?': numbers.int_eq_impl, 'HH->?': numbers.int_eq_impl, 'ii->?': numbers.int_eq_impl, 'II->?': numbers.int_eq_impl, 'll->?': numbers.int_eq_impl, 'LL->?': numbers.int_eq_impl, 'qq->?': numbers.int_eq_impl, 'QQ->?': numbers.int_eq_impl, 'ff->?': numbers.real_eq_impl, 'dd->?': numbers.real_eq_impl, 'FF->?': npyfuncs.np_complex_eq_impl, 'DD->?': npyfuncs.np_complex_eq_impl}\n    if numpy_version >= (1, 25):\n        db[np.equal].update({'qQ->?': numbers.int_signed_unsigned_cmp('=='), 'Qq->?': numbers.int_unsigned_signed_cmp('==')})\n    db[np.logical_and] = {'??->?': npyfuncs.np_logical_and_impl, 'bb->?': npyfuncs.np_logical_and_impl, 'BB->?': npyfuncs.np_logical_and_impl, 'hh->?': npyfuncs.np_logical_and_impl, 'HH->?': npyfuncs.np_logical_and_impl, 'ii->?': npyfuncs.np_logical_and_impl, 'II->?': npyfuncs.np_logical_and_impl, 'll->?': npyfuncs.np_logical_and_impl, 'LL->?': npyfuncs.np_logical_and_impl, 'qq->?': npyfuncs.np_logical_and_impl, 'QQ->?': npyfuncs.np_logical_and_impl, 'ff->?': npyfuncs.np_logical_and_impl, 'dd->?': npyfuncs.np_logical_and_impl, 'FF->?': npyfuncs.np_complex_logical_and_impl, 'DD->?': npyfuncs.np_complex_logical_and_impl}\n    db[np.logical_or] = {'??->?': npyfuncs.np_logical_or_impl, 'bb->?': npyfuncs.np_logical_or_impl, 'BB->?': npyfuncs.np_logical_or_impl, 'hh->?': npyfuncs.np_logical_or_impl, 'HH->?': npyfuncs.np_logical_or_impl, 'ii->?': npyfuncs.np_logical_or_impl, 'II->?': npyfuncs.np_logical_or_impl, 'll->?': npyfuncs.np_logical_or_impl, 'LL->?': npyfuncs.np_logical_or_impl, 'qq->?': npyfuncs.np_logical_or_impl, 'QQ->?': npyfuncs.np_logical_or_impl, 'ff->?': npyfuncs.np_logical_or_impl, 'dd->?': npyfuncs.np_logical_or_impl, 'FF->?': npyfuncs.np_complex_logical_or_impl, 'DD->?': npyfuncs.np_complex_logical_or_impl}\n    db[np.logical_xor] = {'??->?': npyfuncs.np_logical_xor_impl, 'bb->?': npyfuncs.np_logical_xor_impl, 'BB->?': npyfuncs.np_logical_xor_impl, 'hh->?': npyfuncs.np_logical_xor_impl, 'HH->?': npyfuncs.np_logical_xor_impl, 'ii->?': npyfuncs.np_logical_xor_impl, 'II->?': npyfuncs.np_logical_xor_impl, 'll->?': npyfuncs.np_logical_xor_impl, 'LL->?': npyfuncs.np_logical_xor_impl, 'qq->?': npyfuncs.np_logical_xor_impl, 'QQ->?': npyfuncs.np_logical_xor_impl, 'ff->?': npyfuncs.np_logical_xor_impl, 'dd->?': npyfuncs.np_logical_xor_impl, 'FF->?': npyfuncs.np_complex_logical_xor_impl, 'DD->?': npyfuncs.np_complex_logical_xor_impl}\n    db[np.logical_not] = {'?->?': npyfuncs.np_logical_not_impl, 'b->?': npyfuncs.np_logical_not_impl, 'B->?': npyfuncs.np_logical_not_impl, 'h->?': npyfuncs.np_logical_not_impl, 'H->?': npyfuncs.np_logical_not_impl, 'i->?': npyfuncs.np_logical_not_impl, 'I->?': npyfuncs.np_logical_not_impl, 'l->?': npyfuncs.np_logical_not_impl, 'L->?': npyfuncs.np_logical_not_impl, 'q->?': npyfuncs.np_logical_not_impl, 'Q->?': npyfuncs.np_logical_not_impl, 'f->?': npyfuncs.np_logical_not_impl, 'd->?': npyfuncs.np_logical_not_impl, 'F->?': npyfuncs.np_complex_logical_not_impl, 'D->?': npyfuncs.np_complex_logical_not_impl}\n    db[np.maximum] = {'??->?': npyfuncs.np_logical_or_impl, 'bb->b': npyfuncs.np_int_smax_impl, 'BB->B': npyfuncs.np_int_umax_impl, 'hh->h': npyfuncs.np_int_smax_impl, 'HH->H': npyfuncs.np_int_umax_impl, 'ii->i': npyfuncs.np_int_smax_impl, 'II->I': npyfuncs.np_int_umax_impl, 'll->l': npyfuncs.np_int_smax_impl, 'LL->L': npyfuncs.np_int_umax_impl, 'qq->q': npyfuncs.np_int_smax_impl, 'QQ->Q': npyfuncs.np_int_umax_impl, 'ff->f': npyfuncs.np_real_maximum_impl, 'dd->d': npyfuncs.np_real_maximum_impl, 'FF->F': npyfuncs.np_complex_maximum_impl, 'DD->D': npyfuncs.np_complex_maximum_impl}\n    db[np.minimum] = {'??->?': npyfuncs.np_logical_and_impl, 'bb->b': npyfuncs.np_int_smin_impl, 'BB->B': npyfuncs.np_int_umin_impl, 'hh->h': npyfuncs.np_int_smin_impl, 'HH->H': npyfuncs.np_int_umin_impl, 'ii->i': npyfuncs.np_int_smin_impl, 'II->I': npyfuncs.np_int_umin_impl, 'll->l': npyfuncs.np_int_smin_impl, 'LL->L': npyfuncs.np_int_umin_impl, 'qq->q': npyfuncs.np_int_smin_impl, 'QQ->Q': npyfuncs.np_int_umin_impl, 'ff->f': npyfuncs.np_real_minimum_impl, 'dd->d': npyfuncs.np_real_minimum_impl, 'FF->F': npyfuncs.np_complex_minimum_impl, 'DD->D': npyfuncs.np_complex_minimum_impl}\n    db[np.fmax] = {'??->?': npyfuncs.np_logical_or_impl, 'bb->b': npyfuncs.np_int_smax_impl, 'BB->B': npyfuncs.np_int_umax_impl, 'hh->h': npyfuncs.np_int_smax_impl, 'HH->H': npyfuncs.np_int_umax_impl, 'ii->i': npyfuncs.np_int_smax_impl, 'II->I': npyfuncs.np_int_umax_impl, 'll->l': npyfuncs.np_int_smax_impl, 'LL->L': npyfuncs.np_int_umax_impl, 'qq->q': npyfuncs.np_int_smax_impl, 'QQ->Q': npyfuncs.np_int_umax_impl, 'ff->f': npyfuncs.np_real_fmax_impl, 'dd->d': npyfuncs.np_real_fmax_impl, 'FF->F': npyfuncs.np_complex_fmax_impl, 'DD->D': npyfuncs.np_complex_fmax_impl}\n    db[np.fmin] = {'??->?': npyfuncs.np_logical_and_impl, 'bb->b': npyfuncs.np_int_smin_impl, 'BB->B': npyfuncs.np_int_umin_impl, 'hh->h': npyfuncs.np_int_smin_impl, 'HH->H': npyfuncs.np_int_umin_impl, 'ii->i': npyfuncs.np_int_smin_impl, 'II->I': npyfuncs.np_int_umin_impl, 'll->l': npyfuncs.np_int_smin_impl, 'LL->L': npyfuncs.np_int_umin_impl, 'qq->q': npyfuncs.np_int_smin_impl, 'QQ->Q': npyfuncs.np_int_umin_impl, 'ff->f': npyfuncs.np_real_fmin_impl, 'dd->d': npyfuncs.np_real_fmin_impl, 'FF->F': npyfuncs.np_complex_fmin_impl, 'DD->D': npyfuncs.np_complex_fmin_impl}\n    db[np.bitwise_and] = {'??->?': numbers.int_and_impl, 'bb->b': numbers.int_and_impl, 'BB->B': numbers.int_and_impl, 'hh->h': numbers.int_and_impl, 'HH->H': numbers.int_and_impl, 'ii->i': numbers.int_and_impl, 'II->I': numbers.int_and_impl, 'll->l': numbers.int_and_impl, 'LL->L': numbers.int_and_impl, 'qq->q': numbers.int_and_impl, 'QQ->Q': numbers.int_and_impl}\n    db[np.bitwise_or] = {'??->?': numbers.int_or_impl, 'bb->b': numbers.int_or_impl, 'BB->B': numbers.int_or_impl, 'hh->h': numbers.int_or_impl, 'HH->H': numbers.int_or_impl, 'ii->i': numbers.int_or_impl, 'II->I': numbers.int_or_impl, 'll->l': numbers.int_or_impl, 'LL->L': numbers.int_or_impl, 'qq->q': numbers.int_or_impl, 'QQ->Q': numbers.int_or_impl}\n    db[np.bitwise_xor] = {'??->?': numbers.int_xor_impl, 'bb->b': numbers.int_xor_impl, 'BB->B': numbers.int_xor_impl, 'hh->h': numbers.int_xor_impl, 'HH->H': numbers.int_xor_impl, 'ii->i': numbers.int_xor_impl, 'II->I': numbers.int_xor_impl, 'll->l': numbers.int_xor_impl, 'LL->L': numbers.int_xor_impl, 'qq->q': numbers.int_xor_impl, 'QQ->Q': numbers.int_xor_impl}\n    db[np.invert] = {'?->?': numbers.int_invert_impl, 'b->b': numbers.int_invert_impl, 'B->B': numbers.int_invert_impl, 'h->h': numbers.int_invert_impl, 'H->H': numbers.int_invert_impl, 'i->i': numbers.int_invert_impl, 'I->I': numbers.int_invert_impl, 'l->l': numbers.int_invert_impl, 'L->L': numbers.int_invert_impl, 'q->q': numbers.int_invert_impl, 'Q->Q': numbers.int_invert_impl}\n    db[np.left_shift] = {'bb->b': numbers.int_shl_impl, 'BB->B': numbers.int_shl_impl, 'hh->h': numbers.int_shl_impl, 'HH->H': numbers.int_shl_impl, 'ii->i': numbers.int_shl_impl, 'II->I': numbers.int_shl_impl, 'll->l': numbers.int_shl_impl, 'LL->L': numbers.int_shl_impl, 'qq->q': numbers.int_shl_impl, 'QQ->Q': numbers.int_shl_impl}\n    db[np.right_shift] = {'bb->b': numbers.int_shr_impl, 'BB->B': numbers.int_shr_impl, 'hh->h': numbers.int_shr_impl, 'HH->H': numbers.int_shr_impl, 'ii->i': numbers.int_shr_impl, 'II->I': numbers.int_shr_impl, 'll->l': numbers.int_shr_impl, 'LL->L': numbers.int_shr_impl, 'qq->q': numbers.int_shr_impl, 'QQ->Q': numbers.int_shr_impl}\n    return db",
            "@lru_cache\ndef ufunc_db():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    from numba.cpython import cmathimpl, mathimpl, numbers\n    from numba.np import npyfuncs\n    from numba.np.numpy_support import numpy_version\n\n    def np_unary_impl(fn, context, builder, sig, args):\n        npyfuncs._check_arity_and_homogeneity(sig, args, 1)\n        impl = get_unary_impl_for_fn_and_ty(fn, sig.args[0])\n        return impl(context, builder, sig, args)\n\n    def np_binary_impl(fn, context, builder, sig, args):\n        npyfuncs._check_arity_and_homogeneity(sig, args, 2)\n        impl = get_binary_impl_for_fn_and_ty(fn, sig.args[0])\n        return impl(context, builder, sig, args)\n\n    def np_real_sin_impl(context, builder, sig, args):\n        return np_unary_impl(math.sin, context, builder, sig, args)\n\n    def np_real_cos_impl(context, builder, sig, args):\n        return np_unary_impl(math.cos, context, builder, sig, args)\n\n    def np_real_tan_impl(context, builder, sig, args):\n        return np_unary_impl(math.tan, context, builder, sig, args)\n\n    def np_real_asin_impl(context, builder, sig, args):\n        return np_unary_impl(math.asin, context, builder, sig, args)\n\n    def np_real_acos_impl(context, builder, sig, args):\n        return np_unary_impl(math.acos, context, builder, sig, args)\n\n    def np_real_atan_impl(context, builder, sig, args):\n        return np_unary_impl(math.atan, context, builder, sig, args)\n\n    def np_real_atan2_impl(context, builder, sig, args):\n        return np_binary_impl(math.atan2, context, builder, sig, args)\n\n    def np_real_hypot_impl(context, builder, sig, args):\n        return np_binary_impl(math.hypot, context, builder, sig, args)\n\n    def np_real_sinh_impl(context, builder, sig, args):\n        return np_unary_impl(math.sinh, context, builder, sig, args)\n\n    def np_complex_sinh_impl(context, builder, sig, args):\n        npyfuncs._check_arity_and_homogeneity(sig, args, 1)\n        ty = sig.args[0]\n        fty = ty.underlying_float\n        fsig1 = typing.signature(*[fty] * 2)\n        x = context.make_complex(builder, ty, args[0])\n        out = context.make_complex(builder, ty)\n        xr = x.real\n        xi = x.imag\n        sxi = np_real_sin_impl(context, builder, fsig1, [xi])\n        shxr = np_real_sinh_impl(context, builder, fsig1, [xr])\n        cxi = np_real_cos_impl(context, builder, fsig1, [xi])\n        chxr = np_real_cosh_impl(context, builder, fsig1, [xr])\n        out.real = builder.fmul(cxi, shxr)\n        out.imag = builder.fmul(sxi, chxr)\n        return out._getvalue()\n\n    def np_real_cosh_impl(context, builder, sig, args):\n        return np_unary_impl(math.cosh, context, builder, sig, args)\n\n    def np_complex_cosh_impl(context, builder, sig, args):\n        npyfuncs._check_arity_and_homogeneity(sig, args, 1)\n        ty = sig.args[0]\n        fty = ty.underlying_float\n        fsig1 = typing.signature(*[fty] * 2)\n        x = context.make_complex(builder, ty, args[0])\n        out = context.make_complex(builder, ty)\n        xr = x.real\n        xi = x.imag\n        cxi = np_real_cos_impl(context, builder, fsig1, [xi])\n        chxr = np_real_cosh_impl(context, builder, fsig1, [xr])\n        sxi = np_real_sin_impl(context, builder, fsig1, [xi])\n        shxr = np_real_sinh_impl(context, builder, fsig1, [xr])\n        out.real = builder.fmul(cxi, chxr)\n        out.imag = builder.fmul(sxi, shxr)\n        return out._getvalue()\n\n    def np_real_tanh_impl(context, builder, sig, args):\n        return np_unary_impl(math.tanh, context, builder, sig, args)\n\n    def np_complex_tanh_impl(context, builder, sig, args):\n        npyfuncs._check_arity_and_homogeneity(sig, args, 1)\n        ty = sig.args[0]\n        fty = ty.underlying_float\n        fsig1 = typing.signature(*[fty] * 2)\n        ONE = context.get_constant(fty, 1.0)\n        x = context.make_complex(builder, ty, args[0])\n        out = context.make_complex(builder, ty)\n        xr = x.real\n        xi = x.imag\n        si = np_real_sin_impl(context, builder, fsig1, [xi])\n        ci = np_real_cos_impl(context, builder, fsig1, [xi])\n        shr = np_real_sinh_impl(context, builder, fsig1, [xr])\n        chr_ = np_real_cosh_impl(context, builder, fsig1, [xr])\n        rs = builder.fmul(ci, shr)\n        is_ = builder.fmul(si, chr_)\n        rc = builder.fmul(ci, chr_)\n        ic = builder.fmul(si, shr)\n        sqr_rc = builder.fmul(rc, rc)\n        sqr_ic = builder.fmul(ic, ic)\n        d = builder.fadd(sqr_rc, sqr_ic)\n        inv_d = builder.fdiv(ONE, d)\n        rs_rc = builder.fmul(rs, rc)\n        is_ic = builder.fmul(is_, ic)\n        is_rc = builder.fmul(is_, rc)\n        rs_ic = builder.fmul(rs, ic)\n        numr = builder.fadd(rs_rc, is_ic)\n        numi = builder.fsub(is_rc, rs_ic)\n        out.real = builder.fmul(numr, inv_d)\n        out.imag = builder.fmul(numi, inv_d)\n        return out._getvalue()\n\n    def np_real_asinh_impl(context, builder, sig, args):\n        return np_unary_impl(math.asinh, context, builder, sig, args)\n\n    def np_real_acosh_impl(context, builder, sig, args):\n        return np_unary_impl(math.acosh, context, builder, sig, args)\n\n    def np_real_atanh_impl(context, builder, sig, args):\n        return np_unary_impl(math.atanh, context, builder, sig, args)\n    db = {}\n    db[np.sin] = {'f->f': np_real_sin_impl, 'd->d': np_real_sin_impl, 'F->F': npyfuncs.np_complex_sin_impl, 'D->D': npyfuncs.np_complex_sin_impl}\n    db[np.cos] = {'f->f': np_real_cos_impl, 'd->d': np_real_cos_impl, 'F->F': npyfuncs.np_complex_cos_impl, 'D->D': npyfuncs.np_complex_cos_impl}\n    db[np.tan] = {'f->f': np_real_tan_impl, 'd->d': np_real_tan_impl, 'F->F': cmathimpl.tan_impl, 'D->D': cmathimpl.tan_impl}\n    db[np.arcsin] = {'f->f': np_real_asin_impl, 'd->d': np_real_asin_impl, 'F->F': cmathimpl.asin_impl, 'D->D': cmathimpl.asin_impl}\n    db[np.arccos] = {'f->f': np_real_acos_impl, 'd->d': np_real_acos_impl, 'F->F': cmathimpl.acos_impl, 'D->D': cmathimpl.acos_impl}\n    db[np.arctan] = {'f->f': np_real_atan_impl, 'd->d': np_real_atan_impl, 'F->F': cmathimpl.atan_impl, 'D->D': cmathimpl.atan_impl}\n    db[np.arctan2] = {'ff->f': np_real_atan2_impl, 'dd->d': np_real_atan2_impl}\n    db[np.hypot] = {'ff->f': np_real_hypot_impl, 'dd->d': np_real_hypot_impl}\n    db[np.sinh] = {'f->f': np_real_sinh_impl, 'd->d': np_real_sinh_impl, 'F->F': np_complex_sinh_impl, 'D->D': np_complex_sinh_impl}\n    db[np.cosh] = {'f->f': np_real_cosh_impl, 'd->d': np_real_cosh_impl, 'F->F': np_complex_cosh_impl, 'D->D': np_complex_cosh_impl}\n    db[np.tanh] = {'f->f': np_real_tanh_impl, 'd->d': np_real_tanh_impl, 'F->F': np_complex_tanh_impl, 'D->D': np_complex_tanh_impl}\n    db[np.arcsinh] = {'f->f': np_real_asinh_impl, 'd->d': np_real_asinh_impl, 'F->F': cmathimpl.asinh_impl, 'D->D': cmathimpl.asinh_impl}\n    db[np.arccosh] = {'f->f': np_real_acosh_impl, 'd->d': np_real_acosh_impl, 'F->F': npyfuncs.np_complex_acosh_impl, 'D->D': npyfuncs.np_complex_acosh_impl}\n    db[np.arctanh] = {'f->f': np_real_atanh_impl, 'd->d': np_real_atanh_impl, 'F->F': cmathimpl.atanh_impl, 'D->D': cmathimpl.atanh_impl}\n    db[np.deg2rad] = {'f->f': mathimpl.radians_float_impl, 'd->d': mathimpl.radians_float_impl}\n    db[np.radians] = db[np.deg2rad]\n    db[np.rad2deg] = {'f->f': mathimpl.degrees_float_impl, 'd->d': mathimpl.degrees_float_impl}\n    db[np.degrees] = db[np.rad2deg]\n    db[np.greater] = {'??->?': numbers.int_ugt_impl, 'bb->?': numbers.int_sgt_impl, 'BB->?': numbers.int_ugt_impl, 'hh->?': numbers.int_sgt_impl, 'HH->?': numbers.int_ugt_impl, 'ii->?': numbers.int_sgt_impl, 'II->?': numbers.int_ugt_impl, 'll->?': numbers.int_sgt_impl, 'LL->?': numbers.int_ugt_impl, 'qq->?': numbers.int_sgt_impl, 'QQ->?': numbers.int_ugt_impl, 'ff->?': numbers.real_gt_impl, 'dd->?': numbers.real_gt_impl, 'FF->?': npyfuncs.np_complex_gt_impl, 'DD->?': npyfuncs.np_complex_gt_impl}\n    if numpy_version >= (1, 25):\n        db[np.greater].update({'qQ->?': numbers.int_signed_unsigned_cmp('>'), 'Qq->?': numbers.int_unsigned_signed_cmp('>')})\n    db[np.greater_equal] = {'??->?': numbers.int_uge_impl, 'bb->?': numbers.int_sge_impl, 'BB->?': numbers.int_uge_impl, 'hh->?': numbers.int_sge_impl, 'HH->?': numbers.int_uge_impl, 'ii->?': numbers.int_sge_impl, 'II->?': numbers.int_uge_impl, 'll->?': numbers.int_sge_impl, 'LL->?': numbers.int_uge_impl, 'qq->?': numbers.int_sge_impl, 'QQ->?': numbers.int_uge_impl, 'ff->?': numbers.real_ge_impl, 'dd->?': numbers.real_ge_impl, 'FF->?': npyfuncs.np_complex_ge_impl, 'DD->?': npyfuncs.np_complex_ge_impl}\n    if numpy_version >= (1, 25):\n        db[np.greater_equal].update({'qQ->?': numbers.int_signed_unsigned_cmp('>='), 'Qq->?': numbers.int_unsigned_signed_cmp('>=')})\n    db[np.less] = {'??->?': numbers.int_ult_impl, 'bb->?': numbers.int_slt_impl, 'BB->?': numbers.int_ult_impl, 'hh->?': numbers.int_slt_impl, 'HH->?': numbers.int_ult_impl, 'ii->?': numbers.int_slt_impl, 'II->?': numbers.int_ult_impl, 'll->?': numbers.int_slt_impl, 'LL->?': numbers.int_ult_impl, 'qq->?': numbers.int_slt_impl, 'QQ->?': numbers.int_ult_impl, 'ff->?': numbers.real_lt_impl, 'dd->?': numbers.real_lt_impl, 'FF->?': npyfuncs.np_complex_lt_impl, 'DD->?': npyfuncs.np_complex_lt_impl}\n    if numpy_version >= (1, 25):\n        db[np.less].update({'qQ->?': numbers.int_signed_unsigned_cmp('<'), 'Qq->?': numbers.int_unsigned_signed_cmp('<')})\n    db[np.less_equal] = {'??->?': numbers.int_ule_impl, 'bb->?': numbers.int_sle_impl, 'BB->?': numbers.int_ule_impl, 'hh->?': numbers.int_sle_impl, 'HH->?': numbers.int_ule_impl, 'ii->?': numbers.int_sle_impl, 'II->?': numbers.int_ule_impl, 'll->?': numbers.int_sle_impl, 'LL->?': numbers.int_ule_impl, 'qq->?': numbers.int_sle_impl, 'QQ->?': numbers.int_ule_impl, 'ff->?': numbers.real_le_impl, 'dd->?': numbers.real_le_impl, 'FF->?': npyfuncs.np_complex_le_impl, 'DD->?': npyfuncs.np_complex_le_impl}\n    if numpy_version >= (1, 25):\n        db[np.less_equal].update({'qQ->?': numbers.int_signed_unsigned_cmp('<='), 'Qq->?': numbers.int_unsigned_signed_cmp('<=')})\n    db[np.not_equal] = {'??->?': numbers.int_ne_impl, 'bb->?': numbers.int_ne_impl, 'BB->?': numbers.int_ne_impl, 'hh->?': numbers.int_ne_impl, 'HH->?': numbers.int_ne_impl, 'ii->?': numbers.int_ne_impl, 'II->?': numbers.int_ne_impl, 'll->?': numbers.int_ne_impl, 'LL->?': numbers.int_ne_impl, 'qq->?': numbers.int_ne_impl, 'QQ->?': numbers.int_ne_impl, 'ff->?': numbers.real_ne_impl, 'dd->?': numbers.real_ne_impl, 'FF->?': npyfuncs.np_complex_ne_impl, 'DD->?': npyfuncs.np_complex_ne_impl}\n    if numpy_version >= (1, 25):\n        db[np.not_equal].update({'qQ->?': numbers.int_signed_unsigned_cmp('!='), 'Qq->?': numbers.int_unsigned_signed_cmp('!=')})\n    db[np.equal] = {'??->?': numbers.int_eq_impl, 'bb->?': numbers.int_eq_impl, 'BB->?': numbers.int_eq_impl, 'hh->?': numbers.int_eq_impl, 'HH->?': numbers.int_eq_impl, 'ii->?': numbers.int_eq_impl, 'II->?': numbers.int_eq_impl, 'll->?': numbers.int_eq_impl, 'LL->?': numbers.int_eq_impl, 'qq->?': numbers.int_eq_impl, 'QQ->?': numbers.int_eq_impl, 'ff->?': numbers.real_eq_impl, 'dd->?': numbers.real_eq_impl, 'FF->?': npyfuncs.np_complex_eq_impl, 'DD->?': npyfuncs.np_complex_eq_impl}\n    if numpy_version >= (1, 25):\n        db[np.equal].update({'qQ->?': numbers.int_signed_unsigned_cmp('=='), 'Qq->?': numbers.int_unsigned_signed_cmp('==')})\n    db[np.logical_and] = {'??->?': npyfuncs.np_logical_and_impl, 'bb->?': npyfuncs.np_logical_and_impl, 'BB->?': npyfuncs.np_logical_and_impl, 'hh->?': npyfuncs.np_logical_and_impl, 'HH->?': npyfuncs.np_logical_and_impl, 'ii->?': npyfuncs.np_logical_and_impl, 'II->?': npyfuncs.np_logical_and_impl, 'll->?': npyfuncs.np_logical_and_impl, 'LL->?': npyfuncs.np_logical_and_impl, 'qq->?': npyfuncs.np_logical_and_impl, 'QQ->?': npyfuncs.np_logical_and_impl, 'ff->?': npyfuncs.np_logical_and_impl, 'dd->?': npyfuncs.np_logical_and_impl, 'FF->?': npyfuncs.np_complex_logical_and_impl, 'DD->?': npyfuncs.np_complex_logical_and_impl}\n    db[np.logical_or] = {'??->?': npyfuncs.np_logical_or_impl, 'bb->?': npyfuncs.np_logical_or_impl, 'BB->?': npyfuncs.np_logical_or_impl, 'hh->?': npyfuncs.np_logical_or_impl, 'HH->?': npyfuncs.np_logical_or_impl, 'ii->?': npyfuncs.np_logical_or_impl, 'II->?': npyfuncs.np_logical_or_impl, 'll->?': npyfuncs.np_logical_or_impl, 'LL->?': npyfuncs.np_logical_or_impl, 'qq->?': npyfuncs.np_logical_or_impl, 'QQ->?': npyfuncs.np_logical_or_impl, 'ff->?': npyfuncs.np_logical_or_impl, 'dd->?': npyfuncs.np_logical_or_impl, 'FF->?': npyfuncs.np_complex_logical_or_impl, 'DD->?': npyfuncs.np_complex_logical_or_impl}\n    db[np.logical_xor] = {'??->?': npyfuncs.np_logical_xor_impl, 'bb->?': npyfuncs.np_logical_xor_impl, 'BB->?': npyfuncs.np_logical_xor_impl, 'hh->?': npyfuncs.np_logical_xor_impl, 'HH->?': npyfuncs.np_logical_xor_impl, 'ii->?': npyfuncs.np_logical_xor_impl, 'II->?': npyfuncs.np_logical_xor_impl, 'll->?': npyfuncs.np_logical_xor_impl, 'LL->?': npyfuncs.np_logical_xor_impl, 'qq->?': npyfuncs.np_logical_xor_impl, 'QQ->?': npyfuncs.np_logical_xor_impl, 'ff->?': npyfuncs.np_logical_xor_impl, 'dd->?': npyfuncs.np_logical_xor_impl, 'FF->?': npyfuncs.np_complex_logical_xor_impl, 'DD->?': npyfuncs.np_complex_logical_xor_impl}\n    db[np.logical_not] = {'?->?': npyfuncs.np_logical_not_impl, 'b->?': npyfuncs.np_logical_not_impl, 'B->?': npyfuncs.np_logical_not_impl, 'h->?': npyfuncs.np_logical_not_impl, 'H->?': npyfuncs.np_logical_not_impl, 'i->?': npyfuncs.np_logical_not_impl, 'I->?': npyfuncs.np_logical_not_impl, 'l->?': npyfuncs.np_logical_not_impl, 'L->?': npyfuncs.np_logical_not_impl, 'q->?': npyfuncs.np_logical_not_impl, 'Q->?': npyfuncs.np_logical_not_impl, 'f->?': npyfuncs.np_logical_not_impl, 'd->?': npyfuncs.np_logical_not_impl, 'F->?': npyfuncs.np_complex_logical_not_impl, 'D->?': npyfuncs.np_complex_logical_not_impl}\n    db[np.maximum] = {'??->?': npyfuncs.np_logical_or_impl, 'bb->b': npyfuncs.np_int_smax_impl, 'BB->B': npyfuncs.np_int_umax_impl, 'hh->h': npyfuncs.np_int_smax_impl, 'HH->H': npyfuncs.np_int_umax_impl, 'ii->i': npyfuncs.np_int_smax_impl, 'II->I': npyfuncs.np_int_umax_impl, 'll->l': npyfuncs.np_int_smax_impl, 'LL->L': npyfuncs.np_int_umax_impl, 'qq->q': npyfuncs.np_int_smax_impl, 'QQ->Q': npyfuncs.np_int_umax_impl, 'ff->f': npyfuncs.np_real_maximum_impl, 'dd->d': npyfuncs.np_real_maximum_impl, 'FF->F': npyfuncs.np_complex_maximum_impl, 'DD->D': npyfuncs.np_complex_maximum_impl}\n    db[np.minimum] = {'??->?': npyfuncs.np_logical_and_impl, 'bb->b': npyfuncs.np_int_smin_impl, 'BB->B': npyfuncs.np_int_umin_impl, 'hh->h': npyfuncs.np_int_smin_impl, 'HH->H': npyfuncs.np_int_umin_impl, 'ii->i': npyfuncs.np_int_smin_impl, 'II->I': npyfuncs.np_int_umin_impl, 'll->l': npyfuncs.np_int_smin_impl, 'LL->L': npyfuncs.np_int_umin_impl, 'qq->q': npyfuncs.np_int_smin_impl, 'QQ->Q': npyfuncs.np_int_umin_impl, 'ff->f': npyfuncs.np_real_minimum_impl, 'dd->d': npyfuncs.np_real_minimum_impl, 'FF->F': npyfuncs.np_complex_minimum_impl, 'DD->D': npyfuncs.np_complex_minimum_impl}\n    db[np.fmax] = {'??->?': npyfuncs.np_logical_or_impl, 'bb->b': npyfuncs.np_int_smax_impl, 'BB->B': npyfuncs.np_int_umax_impl, 'hh->h': npyfuncs.np_int_smax_impl, 'HH->H': npyfuncs.np_int_umax_impl, 'ii->i': npyfuncs.np_int_smax_impl, 'II->I': npyfuncs.np_int_umax_impl, 'll->l': npyfuncs.np_int_smax_impl, 'LL->L': npyfuncs.np_int_umax_impl, 'qq->q': npyfuncs.np_int_smax_impl, 'QQ->Q': npyfuncs.np_int_umax_impl, 'ff->f': npyfuncs.np_real_fmax_impl, 'dd->d': npyfuncs.np_real_fmax_impl, 'FF->F': npyfuncs.np_complex_fmax_impl, 'DD->D': npyfuncs.np_complex_fmax_impl}\n    db[np.fmin] = {'??->?': npyfuncs.np_logical_and_impl, 'bb->b': npyfuncs.np_int_smin_impl, 'BB->B': npyfuncs.np_int_umin_impl, 'hh->h': npyfuncs.np_int_smin_impl, 'HH->H': npyfuncs.np_int_umin_impl, 'ii->i': npyfuncs.np_int_smin_impl, 'II->I': npyfuncs.np_int_umin_impl, 'll->l': npyfuncs.np_int_smin_impl, 'LL->L': npyfuncs.np_int_umin_impl, 'qq->q': npyfuncs.np_int_smin_impl, 'QQ->Q': npyfuncs.np_int_umin_impl, 'ff->f': npyfuncs.np_real_fmin_impl, 'dd->d': npyfuncs.np_real_fmin_impl, 'FF->F': npyfuncs.np_complex_fmin_impl, 'DD->D': npyfuncs.np_complex_fmin_impl}\n    db[np.bitwise_and] = {'??->?': numbers.int_and_impl, 'bb->b': numbers.int_and_impl, 'BB->B': numbers.int_and_impl, 'hh->h': numbers.int_and_impl, 'HH->H': numbers.int_and_impl, 'ii->i': numbers.int_and_impl, 'II->I': numbers.int_and_impl, 'll->l': numbers.int_and_impl, 'LL->L': numbers.int_and_impl, 'qq->q': numbers.int_and_impl, 'QQ->Q': numbers.int_and_impl}\n    db[np.bitwise_or] = {'??->?': numbers.int_or_impl, 'bb->b': numbers.int_or_impl, 'BB->B': numbers.int_or_impl, 'hh->h': numbers.int_or_impl, 'HH->H': numbers.int_or_impl, 'ii->i': numbers.int_or_impl, 'II->I': numbers.int_or_impl, 'll->l': numbers.int_or_impl, 'LL->L': numbers.int_or_impl, 'qq->q': numbers.int_or_impl, 'QQ->Q': numbers.int_or_impl}\n    db[np.bitwise_xor] = {'??->?': numbers.int_xor_impl, 'bb->b': numbers.int_xor_impl, 'BB->B': numbers.int_xor_impl, 'hh->h': numbers.int_xor_impl, 'HH->H': numbers.int_xor_impl, 'ii->i': numbers.int_xor_impl, 'II->I': numbers.int_xor_impl, 'll->l': numbers.int_xor_impl, 'LL->L': numbers.int_xor_impl, 'qq->q': numbers.int_xor_impl, 'QQ->Q': numbers.int_xor_impl}\n    db[np.invert] = {'?->?': numbers.int_invert_impl, 'b->b': numbers.int_invert_impl, 'B->B': numbers.int_invert_impl, 'h->h': numbers.int_invert_impl, 'H->H': numbers.int_invert_impl, 'i->i': numbers.int_invert_impl, 'I->I': numbers.int_invert_impl, 'l->l': numbers.int_invert_impl, 'L->L': numbers.int_invert_impl, 'q->q': numbers.int_invert_impl, 'Q->Q': numbers.int_invert_impl}\n    db[np.left_shift] = {'bb->b': numbers.int_shl_impl, 'BB->B': numbers.int_shl_impl, 'hh->h': numbers.int_shl_impl, 'HH->H': numbers.int_shl_impl, 'ii->i': numbers.int_shl_impl, 'II->I': numbers.int_shl_impl, 'll->l': numbers.int_shl_impl, 'LL->L': numbers.int_shl_impl, 'qq->q': numbers.int_shl_impl, 'QQ->Q': numbers.int_shl_impl}\n    db[np.right_shift] = {'bb->b': numbers.int_shr_impl, 'BB->B': numbers.int_shr_impl, 'hh->h': numbers.int_shr_impl, 'HH->H': numbers.int_shr_impl, 'ii->i': numbers.int_shr_impl, 'II->I': numbers.int_shr_impl, 'll->l': numbers.int_shr_impl, 'LL->L': numbers.int_shr_impl, 'qq->q': numbers.int_shr_impl, 'QQ->Q': numbers.int_shr_impl}\n    return db"
        ]
    }
]