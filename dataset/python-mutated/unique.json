[
    {
        "func_name": "unique_rows",
        "original": "def unique_rows(ar):\n    \"\"\"Remove repeated rows from a 2D array.\n\n    In particular, if given an array of coordinates of shape\n    (Npoints, Ndim), it will remove repeated points.\n\n    Parameters\n    ----------\n    ar : ndarray, shape (M, N)\n        The input array.\n\n    Returns\n    -------\n    ar_out : ndarray, shape (P, N)\n        A copy of the input array with repeated rows removed.\n\n    Raises\n    ------\n    ValueError : if `ar` is not two-dimensional.\n\n    Notes\n    -----\n    The function will generate a copy of `ar` if it is not\n    C-contiguous, which will negatively affect performance for large\n    input arrays.\n\n    Examples\n    --------\n    >>> ar = np.array([[1, 0, 1],\n    ...                [0, 1, 0],\n    ...                [1, 0, 1]], np.uint8)\n    >>> unique_rows(ar)\n    array([[0, 1, 0],\n           [1, 0, 1]], dtype=uint8)\n    \"\"\"\n    if ar.ndim != 2:\n        raise ValueError(f'unique_rows() only makes sense for 2D arrays, got {ar.ndim}')\n    ar = np.ascontiguousarray(ar)\n    ar_row_view = ar.view(f'|S{ar.itemsize * ar.shape[1]}')\n    (_, unique_row_indices) = np.unique(ar_row_view, return_index=True)\n    ar_out = ar[unique_row_indices]\n    return ar_out",
        "mutated": [
            "def unique_rows(ar):\n    if False:\n        i = 10\n    'Remove repeated rows from a 2D array.\\n\\n    In particular, if given an array of coordinates of shape\\n    (Npoints, Ndim), it will remove repeated points.\\n\\n    Parameters\\n    ----------\\n    ar : ndarray, shape (M, N)\\n        The input array.\\n\\n    Returns\\n    -------\\n    ar_out : ndarray, shape (P, N)\\n        A copy of the input array with repeated rows removed.\\n\\n    Raises\\n    ------\\n    ValueError : if `ar` is not two-dimensional.\\n\\n    Notes\\n    -----\\n    The function will generate a copy of `ar` if it is not\\n    C-contiguous, which will negatively affect performance for large\\n    input arrays.\\n\\n    Examples\\n    --------\\n    >>> ar = np.array([[1, 0, 1],\\n    ...                [0, 1, 0],\\n    ...                [1, 0, 1]], np.uint8)\\n    >>> unique_rows(ar)\\n    array([[0, 1, 0],\\n           [1, 0, 1]], dtype=uint8)\\n    '\n    if ar.ndim != 2:\n        raise ValueError(f'unique_rows() only makes sense for 2D arrays, got {ar.ndim}')\n    ar = np.ascontiguousarray(ar)\n    ar_row_view = ar.view(f'|S{ar.itemsize * ar.shape[1]}')\n    (_, unique_row_indices) = np.unique(ar_row_view, return_index=True)\n    ar_out = ar[unique_row_indices]\n    return ar_out",
            "def unique_rows(ar):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Remove repeated rows from a 2D array.\\n\\n    In particular, if given an array of coordinates of shape\\n    (Npoints, Ndim), it will remove repeated points.\\n\\n    Parameters\\n    ----------\\n    ar : ndarray, shape (M, N)\\n        The input array.\\n\\n    Returns\\n    -------\\n    ar_out : ndarray, shape (P, N)\\n        A copy of the input array with repeated rows removed.\\n\\n    Raises\\n    ------\\n    ValueError : if `ar` is not two-dimensional.\\n\\n    Notes\\n    -----\\n    The function will generate a copy of `ar` if it is not\\n    C-contiguous, which will negatively affect performance for large\\n    input arrays.\\n\\n    Examples\\n    --------\\n    >>> ar = np.array([[1, 0, 1],\\n    ...                [0, 1, 0],\\n    ...                [1, 0, 1]], np.uint8)\\n    >>> unique_rows(ar)\\n    array([[0, 1, 0],\\n           [1, 0, 1]], dtype=uint8)\\n    '\n    if ar.ndim != 2:\n        raise ValueError(f'unique_rows() only makes sense for 2D arrays, got {ar.ndim}')\n    ar = np.ascontiguousarray(ar)\n    ar_row_view = ar.view(f'|S{ar.itemsize * ar.shape[1]}')\n    (_, unique_row_indices) = np.unique(ar_row_view, return_index=True)\n    ar_out = ar[unique_row_indices]\n    return ar_out",
            "def unique_rows(ar):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Remove repeated rows from a 2D array.\\n\\n    In particular, if given an array of coordinates of shape\\n    (Npoints, Ndim), it will remove repeated points.\\n\\n    Parameters\\n    ----------\\n    ar : ndarray, shape (M, N)\\n        The input array.\\n\\n    Returns\\n    -------\\n    ar_out : ndarray, shape (P, N)\\n        A copy of the input array with repeated rows removed.\\n\\n    Raises\\n    ------\\n    ValueError : if `ar` is not two-dimensional.\\n\\n    Notes\\n    -----\\n    The function will generate a copy of `ar` if it is not\\n    C-contiguous, which will negatively affect performance for large\\n    input arrays.\\n\\n    Examples\\n    --------\\n    >>> ar = np.array([[1, 0, 1],\\n    ...                [0, 1, 0],\\n    ...                [1, 0, 1]], np.uint8)\\n    >>> unique_rows(ar)\\n    array([[0, 1, 0],\\n           [1, 0, 1]], dtype=uint8)\\n    '\n    if ar.ndim != 2:\n        raise ValueError(f'unique_rows() only makes sense for 2D arrays, got {ar.ndim}')\n    ar = np.ascontiguousarray(ar)\n    ar_row_view = ar.view(f'|S{ar.itemsize * ar.shape[1]}')\n    (_, unique_row_indices) = np.unique(ar_row_view, return_index=True)\n    ar_out = ar[unique_row_indices]\n    return ar_out",
            "def unique_rows(ar):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Remove repeated rows from a 2D array.\\n\\n    In particular, if given an array of coordinates of shape\\n    (Npoints, Ndim), it will remove repeated points.\\n\\n    Parameters\\n    ----------\\n    ar : ndarray, shape (M, N)\\n        The input array.\\n\\n    Returns\\n    -------\\n    ar_out : ndarray, shape (P, N)\\n        A copy of the input array with repeated rows removed.\\n\\n    Raises\\n    ------\\n    ValueError : if `ar` is not two-dimensional.\\n\\n    Notes\\n    -----\\n    The function will generate a copy of `ar` if it is not\\n    C-contiguous, which will negatively affect performance for large\\n    input arrays.\\n\\n    Examples\\n    --------\\n    >>> ar = np.array([[1, 0, 1],\\n    ...                [0, 1, 0],\\n    ...                [1, 0, 1]], np.uint8)\\n    >>> unique_rows(ar)\\n    array([[0, 1, 0],\\n           [1, 0, 1]], dtype=uint8)\\n    '\n    if ar.ndim != 2:\n        raise ValueError(f'unique_rows() only makes sense for 2D arrays, got {ar.ndim}')\n    ar = np.ascontiguousarray(ar)\n    ar_row_view = ar.view(f'|S{ar.itemsize * ar.shape[1]}')\n    (_, unique_row_indices) = np.unique(ar_row_view, return_index=True)\n    ar_out = ar[unique_row_indices]\n    return ar_out",
            "def unique_rows(ar):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Remove repeated rows from a 2D array.\\n\\n    In particular, if given an array of coordinates of shape\\n    (Npoints, Ndim), it will remove repeated points.\\n\\n    Parameters\\n    ----------\\n    ar : ndarray, shape (M, N)\\n        The input array.\\n\\n    Returns\\n    -------\\n    ar_out : ndarray, shape (P, N)\\n        A copy of the input array with repeated rows removed.\\n\\n    Raises\\n    ------\\n    ValueError : if `ar` is not two-dimensional.\\n\\n    Notes\\n    -----\\n    The function will generate a copy of `ar` if it is not\\n    C-contiguous, which will negatively affect performance for large\\n    input arrays.\\n\\n    Examples\\n    --------\\n    >>> ar = np.array([[1, 0, 1],\\n    ...                [0, 1, 0],\\n    ...                [1, 0, 1]], np.uint8)\\n    >>> unique_rows(ar)\\n    array([[0, 1, 0],\\n           [1, 0, 1]], dtype=uint8)\\n    '\n    if ar.ndim != 2:\n        raise ValueError(f'unique_rows() only makes sense for 2D arrays, got {ar.ndim}')\n    ar = np.ascontiguousarray(ar)\n    ar_row_view = ar.view(f'|S{ar.itemsize * ar.shape[1]}')\n    (_, unique_row_indices) = np.unique(ar_row_view, return_index=True)\n    ar_out = ar[unique_row_indices]\n    return ar_out"
        ]
    }
]