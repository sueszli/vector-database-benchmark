[
    {
        "func_name": "test_basic",
        "original": "def test_basic():\n    t = BoostBuild.Tester()\n    __write_appender(t, 'appender.jam')\n    t.write('a.cpp', '')\n    t.write('b.cxx', '')\n    t.write('c.tui', '')\n    t.write('d.wd', '')\n    t.write('e.cpp', '')\n    t.write('x.l', '')\n    t.write('y.x_pro', '')\n    t.write('z.cpp', '')\n    t.write('lib/c.cpp', 'int bar() { return 0; }\\n')\n    t.write('lib/jamfile.jam', 'my-lib auxilliary : c.cpp ;')\n    t.write('jamroot.jam', 'import appender ;\\n\\nimport \"class\" : new ;\\nimport generators ;\\nimport type ;\\n\\n\\n################################################################################\\n#\\n#   We use our own custom EXE, LIB & OBJ target generators as using the regular\\n# ones would force us to have to deal with different compiler/linker specific\\n# \\'features\\' that really have nothing to do with this test. For example, IBM XL\\n# C/C++ for AIX, V12.1 (Version: 12.01.0000.0000) compiler exits with a non-zero\\n# exit code and thus fails our build when run with a source file using an\\n# unknown suffix like \\'.marked_cpp\\'.\\n#\\n################################################################################\\n\\ntype.register MY_EXE : my_exe ;\\ntype.register MY_LIB : my_lib ;\\ntype.register MY_OBJ : my_obj ;\\n\\nappender.register compile-c : C : MY_OBJ ;\\nappender.register compile-cpp : CPP : MY_OBJ ;\\nappender.register link-lib composing : MY_OBJ : MY_LIB ;\\nappender.register link-exe composing : MY_OBJ MY_LIB : MY_EXE ;\\n\\n\\n################################################################################\\n#\\n# LEX --> C\\n#\\n################################################################################\\n\\ntype.register LEX : l ;\\n\\nappender.register lex-to-c : LEX : C ;\\n\\n\\n################################################################################\\n#\\n#        /--> tUI_H --\\\\\\n# tUI --<              >--> CPP\\n#        \\\\------------/\\n#\\n################################################################################\\n\\ntype.register tUI : tui ;\\ntype.register tUI_H : tui_h ;\\n\\nappender.register ui-to-cpp : tUI tUI_H : CPP ;\\nappender.register ui-to-h : tUI : tUI_H ;\\n\\n\\n################################################################################\\n#\\n#          /--> X1 --\\\\\\n# X_PRO --<           >--> CPP\\n#          \\\\--> X2 --/\\n#\\n################################################################################\\n\\ntype.register X1 : x1 ;\\ntype.register X2 : x2 ;\\ntype.register X_PRO : x_pro ;\\n\\nappender.register x1-x2-to-cpp : X1 X2 : CPP ;\\nappender.register x-pro-to-x1-x2 : X_PRO : X1 X2 ;\\n\\n\\n################################################################################\\n#\\n#   When the main target type is NM_EXE, build OBJ from CPP-MARKED and not from\\n# anything else, e.g. directly from CPP.\\n#\\n################################################################################\\n\\ntype.register CPP_MARKED : marked_cpp : CPP ;\\ntype.register POSITIONS : positions ;\\ntype.register NM.TARGET.CPP : target_cpp : CPP ;\\ntype.register NM_EXE : : MY_EXE ;\\n\\nappender.register marked-to-target-cpp : CPP_MARKED : NM.TARGET.CPP ;\\nappender.register cpp-to-marked-positions : CPP : CPP_MARKED POSITIONS ;\\n\\nclass \"nm::target::cpp-obj-generator\" : generator\\n{\\n    rule __init__ ( id )\\n    {\\n        generator.__init__ $(id) : NM.TARGET.CPP : MY_OBJ ;\\n        generator.set-rule-name appender.appender ;\\n    }\\n\\n    rule requirements ( )\\n    {\\n        return <main-target-type>NM_EXE ;\\n    }\\n\\n    rule run ( project name ? : properties * : source : multiple ? )\\n    {\\n        if [ $(source).type ] = CPP\\n        {\\n            local converted = [ generators.construct $(project) : NM.TARGET.CPP\\n                : $(properties) : $(source) ] ;\\n            if $(converted)\\n            {\\n                return [ generators.construct $(project) : MY_OBJ :\\n                    $(properties) : $(converted[2]) ] ;\\n            }\\n        }\\n    }\\n}\\ngenerators.register [ new \"nm::target::cpp-obj-generator\" target-obj ] ;\\ngenerators.override target-obj : all ;\\n\\n\\n################################################################################\\n#\\n# A more complex test case scenario with the following generators:\\n#  1. WHL --> CPP, WHL_LR0, H, H(%_symbols)\\n#  2. DLP --> CPP\\n#  3. WD --> WHL(%_parser) DLP(%_lexer)\\n#  4. A custom generator of higher priority than generators 1. & 2. that helps\\n#     disambiguate between them when generating CPP files from WHL and DLP\\n#     sources.\\n#\\n################################################################################\\n\\ntype.register WHL : whl ;\\ntype.register DLP : dlp ;\\ntype.register WHL_LR0 : lr0 ;\\ntype.register WD : wd ;\\n\\nlocal whale-generator-id = [ appender.register whale : WHL : CPP WHL_LR0 H\\n    H(%_symbols) ] ;\\nlocal dolphin-generator-id = [ appender.register dolphin : DLP : CPP ] ;\\nappender.register wd : WD : WHL(%_parser) DLP(%_lexer) ;\\n\\nclass wd-to-cpp : generator\\n{\\n    rule __init__ ( id : sources * : targets * )\\n    {\\n        generator.__init__ $(id) : $(sources) : $(targets) ;\\n    }\\n\\n    rule run ( project name ? : property-set : source )\\n    {\\n        local new-sources = $(source) ;\\n        if ! [ $(source).type ] in WHL DLP\\n        {\\n            local r1 = [ generators.construct $(project) $(name) : WHL :\\n                $(property-set) : $(source) ] ;\\n            local r2 = [ generators.construct $(project) $(name) : DLP :\\n                $(property-set) : $(source) ] ;\\n            new-sources = [ sequence.unique $(r1[2-]) $(r2[2-]) ] ;\\n        }\\n\\n        local result ;\\n        for local i in $(new-sources)\\n        {\\n            local t = [ generators.construct $(project) $(name) : CPP :\\n                $(property-set) : $(i) ] ;\\n            result += $(t[2-]) ;\\n        }\\n        return $(result) ;\\n    }\\n}\\ngenerators.override $(__name__).wd-to-cpp : $(whale-generator-id) ;\\ngenerators.override $(__name__).wd-to-cpp : $(dolphin-generator-id) ;\\ngenerators.register [ new wd-to-cpp $(__name__).wd-to-cpp : : CPP ] ;\\n\\n\\n################################################################################\\n#\\n# Declare build targets.\\n#\\n################################################################################\\n\\n# This should not cause two CPP --> MY_OBJ constructions for a.cpp or b.cpp.\\nmy-exe a : a.cpp b.cxx obj_1 obj_2 c.tui d.wd x.l y.x_pro lib//auxilliary ;\\nmy-exe f : a.cpp b.cxx obj_1 obj_2 lib//auxilliary ;\\n\\n# This should cause two CPP --> MY_OBJ constructions for z.cpp.\\nmy-obj obj_1 : z.cpp ;\\nmy-obj obj_2 : z.cpp ;\\n\\nnm-exe e : e.cpp ;\\n')\n    t.run_build_system()\n    t.expect_addition('bin/' * BoostBuild.List('a.my_exe a.my_obj b.my_obj c.tui_h c.cpp c.my_obj d_parser.whl d_lexer.dlp d_parser.cpp d_lexer.cpp d_lexer.my_obj d_parser.lr0 d_parser.h d_parser.my_obj d_parser_symbols.h x.c x.my_obj y.x1 y.x2 y.cpp y.my_obj e.marked_cpp e.positions e.target_cpp e.my_obj e.my_exe f.my_exe obj_1.my_obj obj_2.my_obj'))\n    t.expect_addition('lib/bin/' * BoostBuild.List('c.my_obj auxilliary.my_lib'))\n    t.expect_nothing_more()\n    folder = 'bin'\n    t.expect_content_lines('%s/obj_1.my_obj' % folder, \"     Sources: 'z.cpp'\")\n    t.expect_content_lines('%s/obj_2.my_obj' % folder, \"     Sources: 'z.cpp'\")\n    t.expect_content_lines('%s/a.my_obj' % folder, \"     Sources: 'a.cpp'\")\n    lines = t.stdout().splitlines()\n    source_lines = [x for x in lines if re.match(\"^     Sources: '\", x)]\n    if not __match_count_is(source_lines, \"'z.cpp'\", 2):\n        BoostBuild.annotation('failure', 'z.cpp must be compiled exactly twice.')\n        t.fail_test(1)\n    if not __match_count_is(source_lines, \"'a.cpp'\", 1):\n        BoostBuild.annotation('failure', 'a.cpp must be compiled exactly once.')\n        t.fail_test(1)\n    t.cleanup()",
        "mutated": [
            "def test_basic():\n    if False:\n        i = 10\n    t = BoostBuild.Tester()\n    __write_appender(t, 'appender.jam')\n    t.write('a.cpp', '')\n    t.write('b.cxx', '')\n    t.write('c.tui', '')\n    t.write('d.wd', '')\n    t.write('e.cpp', '')\n    t.write('x.l', '')\n    t.write('y.x_pro', '')\n    t.write('z.cpp', '')\n    t.write('lib/c.cpp', 'int bar() { return 0; }\\n')\n    t.write('lib/jamfile.jam', 'my-lib auxilliary : c.cpp ;')\n    t.write('jamroot.jam', 'import appender ;\\n\\nimport \"class\" : new ;\\nimport generators ;\\nimport type ;\\n\\n\\n################################################################################\\n#\\n#   We use our own custom EXE, LIB & OBJ target generators as using the regular\\n# ones would force us to have to deal with different compiler/linker specific\\n# \\'features\\' that really have nothing to do with this test. For example, IBM XL\\n# C/C++ for AIX, V12.1 (Version: 12.01.0000.0000) compiler exits with a non-zero\\n# exit code and thus fails our build when run with a source file using an\\n# unknown suffix like \\'.marked_cpp\\'.\\n#\\n################################################################################\\n\\ntype.register MY_EXE : my_exe ;\\ntype.register MY_LIB : my_lib ;\\ntype.register MY_OBJ : my_obj ;\\n\\nappender.register compile-c : C : MY_OBJ ;\\nappender.register compile-cpp : CPP : MY_OBJ ;\\nappender.register link-lib composing : MY_OBJ : MY_LIB ;\\nappender.register link-exe composing : MY_OBJ MY_LIB : MY_EXE ;\\n\\n\\n################################################################################\\n#\\n# LEX --> C\\n#\\n################################################################################\\n\\ntype.register LEX : l ;\\n\\nappender.register lex-to-c : LEX : C ;\\n\\n\\n################################################################################\\n#\\n#        /--> tUI_H --\\\\\\n# tUI --<              >--> CPP\\n#        \\\\------------/\\n#\\n################################################################################\\n\\ntype.register tUI : tui ;\\ntype.register tUI_H : tui_h ;\\n\\nappender.register ui-to-cpp : tUI tUI_H : CPP ;\\nappender.register ui-to-h : tUI : tUI_H ;\\n\\n\\n################################################################################\\n#\\n#          /--> X1 --\\\\\\n# X_PRO --<           >--> CPP\\n#          \\\\--> X2 --/\\n#\\n################################################################################\\n\\ntype.register X1 : x1 ;\\ntype.register X2 : x2 ;\\ntype.register X_PRO : x_pro ;\\n\\nappender.register x1-x2-to-cpp : X1 X2 : CPP ;\\nappender.register x-pro-to-x1-x2 : X_PRO : X1 X2 ;\\n\\n\\n################################################################################\\n#\\n#   When the main target type is NM_EXE, build OBJ from CPP-MARKED and not from\\n# anything else, e.g. directly from CPP.\\n#\\n################################################################################\\n\\ntype.register CPP_MARKED : marked_cpp : CPP ;\\ntype.register POSITIONS : positions ;\\ntype.register NM.TARGET.CPP : target_cpp : CPP ;\\ntype.register NM_EXE : : MY_EXE ;\\n\\nappender.register marked-to-target-cpp : CPP_MARKED : NM.TARGET.CPP ;\\nappender.register cpp-to-marked-positions : CPP : CPP_MARKED POSITIONS ;\\n\\nclass \"nm::target::cpp-obj-generator\" : generator\\n{\\n    rule __init__ ( id )\\n    {\\n        generator.__init__ $(id) : NM.TARGET.CPP : MY_OBJ ;\\n        generator.set-rule-name appender.appender ;\\n    }\\n\\n    rule requirements ( )\\n    {\\n        return <main-target-type>NM_EXE ;\\n    }\\n\\n    rule run ( project name ? : properties * : source : multiple ? )\\n    {\\n        if [ $(source).type ] = CPP\\n        {\\n            local converted = [ generators.construct $(project) : NM.TARGET.CPP\\n                : $(properties) : $(source) ] ;\\n            if $(converted)\\n            {\\n                return [ generators.construct $(project) : MY_OBJ :\\n                    $(properties) : $(converted[2]) ] ;\\n            }\\n        }\\n    }\\n}\\ngenerators.register [ new \"nm::target::cpp-obj-generator\" target-obj ] ;\\ngenerators.override target-obj : all ;\\n\\n\\n################################################################################\\n#\\n# A more complex test case scenario with the following generators:\\n#  1. WHL --> CPP, WHL_LR0, H, H(%_symbols)\\n#  2. DLP --> CPP\\n#  3. WD --> WHL(%_parser) DLP(%_lexer)\\n#  4. A custom generator of higher priority than generators 1. & 2. that helps\\n#     disambiguate between them when generating CPP files from WHL and DLP\\n#     sources.\\n#\\n################################################################################\\n\\ntype.register WHL : whl ;\\ntype.register DLP : dlp ;\\ntype.register WHL_LR0 : lr0 ;\\ntype.register WD : wd ;\\n\\nlocal whale-generator-id = [ appender.register whale : WHL : CPP WHL_LR0 H\\n    H(%_symbols) ] ;\\nlocal dolphin-generator-id = [ appender.register dolphin : DLP : CPP ] ;\\nappender.register wd : WD : WHL(%_parser) DLP(%_lexer) ;\\n\\nclass wd-to-cpp : generator\\n{\\n    rule __init__ ( id : sources * : targets * )\\n    {\\n        generator.__init__ $(id) : $(sources) : $(targets) ;\\n    }\\n\\n    rule run ( project name ? : property-set : source )\\n    {\\n        local new-sources = $(source) ;\\n        if ! [ $(source).type ] in WHL DLP\\n        {\\n            local r1 = [ generators.construct $(project) $(name) : WHL :\\n                $(property-set) : $(source) ] ;\\n            local r2 = [ generators.construct $(project) $(name) : DLP :\\n                $(property-set) : $(source) ] ;\\n            new-sources = [ sequence.unique $(r1[2-]) $(r2[2-]) ] ;\\n        }\\n\\n        local result ;\\n        for local i in $(new-sources)\\n        {\\n            local t = [ generators.construct $(project) $(name) : CPP :\\n                $(property-set) : $(i) ] ;\\n            result += $(t[2-]) ;\\n        }\\n        return $(result) ;\\n    }\\n}\\ngenerators.override $(__name__).wd-to-cpp : $(whale-generator-id) ;\\ngenerators.override $(__name__).wd-to-cpp : $(dolphin-generator-id) ;\\ngenerators.register [ new wd-to-cpp $(__name__).wd-to-cpp : : CPP ] ;\\n\\n\\n################################################################################\\n#\\n# Declare build targets.\\n#\\n################################################################################\\n\\n# This should not cause two CPP --> MY_OBJ constructions for a.cpp or b.cpp.\\nmy-exe a : a.cpp b.cxx obj_1 obj_2 c.tui d.wd x.l y.x_pro lib//auxilliary ;\\nmy-exe f : a.cpp b.cxx obj_1 obj_2 lib//auxilliary ;\\n\\n# This should cause two CPP --> MY_OBJ constructions for z.cpp.\\nmy-obj obj_1 : z.cpp ;\\nmy-obj obj_2 : z.cpp ;\\n\\nnm-exe e : e.cpp ;\\n')\n    t.run_build_system()\n    t.expect_addition('bin/' * BoostBuild.List('a.my_exe a.my_obj b.my_obj c.tui_h c.cpp c.my_obj d_parser.whl d_lexer.dlp d_parser.cpp d_lexer.cpp d_lexer.my_obj d_parser.lr0 d_parser.h d_parser.my_obj d_parser_symbols.h x.c x.my_obj y.x1 y.x2 y.cpp y.my_obj e.marked_cpp e.positions e.target_cpp e.my_obj e.my_exe f.my_exe obj_1.my_obj obj_2.my_obj'))\n    t.expect_addition('lib/bin/' * BoostBuild.List('c.my_obj auxilliary.my_lib'))\n    t.expect_nothing_more()\n    folder = 'bin'\n    t.expect_content_lines('%s/obj_1.my_obj' % folder, \"     Sources: 'z.cpp'\")\n    t.expect_content_lines('%s/obj_2.my_obj' % folder, \"     Sources: 'z.cpp'\")\n    t.expect_content_lines('%s/a.my_obj' % folder, \"     Sources: 'a.cpp'\")\n    lines = t.stdout().splitlines()\n    source_lines = [x for x in lines if re.match(\"^     Sources: '\", x)]\n    if not __match_count_is(source_lines, \"'z.cpp'\", 2):\n        BoostBuild.annotation('failure', 'z.cpp must be compiled exactly twice.')\n        t.fail_test(1)\n    if not __match_count_is(source_lines, \"'a.cpp'\", 1):\n        BoostBuild.annotation('failure', 'a.cpp must be compiled exactly once.')\n        t.fail_test(1)\n    t.cleanup()",
            "def test_basic():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    t = BoostBuild.Tester()\n    __write_appender(t, 'appender.jam')\n    t.write('a.cpp', '')\n    t.write('b.cxx', '')\n    t.write('c.tui', '')\n    t.write('d.wd', '')\n    t.write('e.cpp', '')\n    t.write('x.l', '')\n    t.write('y.x_pro', '')\n    t.write('z.cpp', '')\n    t.write('lib/c.cpp', 'int bar() { return 0; }\\n')\n    t.write('lib/jamfile.jam', 'my-lib auxilliary : c.cpp ;')\n    t.write('jamroot.jam', 'import appender ;\\n\\nimport \"class\" : new ;\\nimport generators ;\\nimport type ;\\n\\n\\n################################################################################\\n#\\n#   We use our own custom EXE, LIB & OBJ target generators as using the regular\\n# ones would force us to have to deal with different compiler/linker specific\\n# \\'features\\' that really have nothing to do with this test. For example, IBM XL\\n# C/C++ for AIX, V12.1 (Version: 12.01.0000.0000) compiler exits with a non-zero\\n# exit code and thus fails our build when run with a source file using an\\n# unknown suffix like \\'.marked_cpp\\'.\\n#\\n################################################################################\\n\\ntype.register MY_EXE : my_exe ;\\ntype.register MY_LIB : my_lib ;\\ntype.register MY_OBJ : my_obj ;\\n\\nappender.register compile-c : C : MY_OBJ ;\\nappender.register compile-cpp : CPP : MY_OBJ ;\\nappender.register link-lib composing : MY_OBJ : MY_LIB ;\\nappender.register link-exe composing : MY_OBJ MY_LIB : MY_EXE ;\\n\\n\\n################################################################################\\n#\\n# LEX --> C\\n#\\n################################################################################\\n\\ntype.register LEX : l ;\\n\\nappender.register lex-to-c : LEX : C ;\\n\\n\\n################################################################################\\n#\\n#        /--> tUI_H --\\\\\\n# tUI --<              >--> CPP\\n#        \\\\------------/\\n#\\n################################################################################\\n\\ntype.register tUI : tui ;\\ntype.register tUI_H : tui_h ;\\n\\nappender.register ui-to-cpp : tUI tUI_H : CPP ;\\nappender.register ui-to-h : tUI : tUI_H ;\\n\\n\\n################################################################################\\n#\\n#          /--> X1 --\\\\\\n# X_PRO --<           >--> CPP\\n#          \\\\--> X2 --/\\n#\\n################################################################################\\n\\ntype.register X1 : x1 ;\\ntype.register X2 : x2 ;\\ntype.register X_PRO : x_pro ;\\n\\nappender.register x1-x2-to-cpp : X1 X2 : CPP ;\\nappender.register x-pro-to-x1-x2 : X_PRO : X1 X2 ;\\n\\n\\n################################################################################\\n#\\n#   When the main target type is NM_EXE, build OBJ from CPP-MARKED and not from\\n# anything else, e.g. directly from CPP.\\n#\\n################################################################################\\n\\ntype.register CPP_MARKED : marked_cpp : CPP ;\\ntype.register POSITIONS : positions ;\\ntype.register NM.TARGET.CPP : target_cpp : CPP ;\\ntype.register NM_EXE : : MY_EXE ;\\n\\nappender.register marked-to-target-cpp : CPP_MARKED : NM.TARGET.CPP ;\\nappender.register cpp-to-marked-positions : CPP : CPP_MARKED POSITIONS ;\\n\\nclass \"nm::target::cpp-obj-generator\" : generator\\n{\\n    rule __init__ ( id )\\n    {\\n        generator.__init__ $(id) : NM.TARGET.CPP : MY_OBJ ;\\n        generator.set-rule-name appender.appender ;\\n    }\\n\\n    rule requirements ( )\\n    {\\n        return <main-target-type>NM_EXE ;\\n    }\\n\\n    rule run ( project name ? : properties * : source : multiple ? )\\n    {\\n        if [ $(source).type ] = CPP\\n        {\\n            local converted = [ generators.construct $(project) : NM.TARGET.CPP\\n                : $(properties) : $(source) ] ;\\n            if $(converted)\\n            {\\n                return [ generators.construct $(project) : MY_OBJ :\\n                    $(properties) : $(converted[2]) ] ;\\n            }\\n        }\\n    }\\n}\\ngenerators.register [ new \"nm::target::cpp-obj-generator\" target-obj ] ;\\ngenerators.override target-obj : all ;\\n\\n\\n################################################################################\\n#\\n# A more complex test case scenario with the following generators:\\n#  1. WHL --> CPP, WHL_LR0, H, H(%_symbols)\\n#  2. DLP --> CPP\\n#  3. WD --> WHL(%_parser) DLP(%_lexer)\\n#  4. A custom generator of higher priority than generators 1. & 2. that helps\\n#     disambiguate between them when generating CPP files from WHL and DLP\\n#     sources.\\n#\\n################################################################################\\n\\ntype.register WHL : whl ;\\ntype.register DLP : dlp ;\\ntype.register WHL_LR0 : lr0 ;\\ntype.register WD : wd ;\\n\\nlocal whale-generator-id = [ appender.register whale : WHL : CPP WHL_LR0 H\\n    H(%_symbols) ] ;\\nlocal dolphin-generator-id = [ appender.register dolphin : DLP : CPP ] ;\\nappender.register wd : WD : WHL(%_parser) DLP(%_lexer) ;\\n\\nclass wd-to-cpp : generator\\n{\\n    rule __init__ ( id : sources * : targets * )\\n    {\\n        generator.__init__ $(id) : $(sources) : $(targets) ;\\n    }\\n\\n    rule run ( project name ? : property-set : source )\\n    {\\n        local new-sources = $(source) ;\\n        if ! [ $(source).type ] in WHL DLP\\n        {\\n            local r1 = [ generators.construct $(project) $(name) : WHL :\\n                $(property-set) : $(source) ] ;\\n            local r2 = [ generators.construct $(project) $(name) : DLP :\\n                $(property-set) : $(source) ] ;\\n            new-sources = [ sequence.unique $(r1[2-]) $(r2[2-]) ] ;\\n        }\\n\\n        local result ;\\n        for local i in $(new-sources)\\n        {\\n            local t = [ generators.construct $(project) $(name) : CPP :\\n                $(property-set) : $(i) ] ;\\n            result += $(t[2-]) ;\\n        }\\n        return $(result) ;\\n    }\\n}\\ngenerators.override $(__name__).wd-to-cpp : $(whale-generator-id) ;\\ngenerators.override $(__name__).wd-to-cpp : $(dolphin-generator-id) ;\\ngenerators.register [ new wd-to-cpp $(__name__).wd-to-cpp : : CPP ] ;\\n\\n\\n################################################################################\\n#\\n# Declare build targets.\\n#\\n################################################################################\\n\\n# This should not cause two CPP --> MY_OBJ constructions for a.cpp or b.cpp.\\nmy-exe a : a.cpp b.cxx obj_1 obj_2 c.tui d.wd x.l y.x_pro lib//auxilliary ;\\nmy-exe f : a.cpp b.cxx obj_1 obj_2 lib//auxilliary ;\\n\\n# This should cause two CPP --> MY_OBJ constructions for z.cpp.\\nmy-obj obj_1 : z.cpp ;\\nmy-obj obj_2 : z.cpp ;\\n\\nnm-exe e : e.cpp ;\\n')\n    t.run_build_system()\n    t.expect_addition('bin/' * BoostBuild.List('a.my_exe a.my_obj b.my_obj c.tui_h c.cpp c.my_obj d_parser.whl d_lexer.dlp d_parser.cpp d_lexer.cpp d_lexer.my_obj d_parser.lr0 d_parser.h d_parser.my_obj d_parser_symbols.h x.c x.my_obj y.x1 y.x2 y.cpp y.my_obj e.marked_cpp e.positions e.target_cpp e.my_obj e.my_exe f.my_exe obj_1.my_obj obj_2.my_obj'))\n    t.expect_addition('lib/bin/' * BoostBuild.List('c.my_obj auxilliary.my_lib'))\n    t.expect_nothing_more()\n    folder = 'bin'\n    t.expect_content_lines('%s/obj_1.my_obj' % folder, \"     Sources: 'z.cpp'\")\n    t.expect_content_lines('%s/obj_2.my_obj' % folder, \"     Sources: 'z.cpp'\")\n    t.expect_content_lines('%s/a.my_obj' % folder, \"     Sources: 'a.cpp'\")\n    lines = t.stdout().splitlines()\n    source_lines = [x for x in lines if re.match(\"^     Sources: '\", x)]\n    if not __match_count_is(source_lines, \"'z.cpp'\", 2):\n        BoostBuild.annotation('failure', 'z.cpp must be compiled exactly twice.')\n        t.fail_test(1)\n    if not __match_count_is(source_lines, \"'a.cpp'\", 1):\n        BoostBuild.annotation('failure', 'a.cpp must be compiled exactly once.')\n        t.fail_test(1)\n    t.cleanup()",
            "def test_basic():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    t = BoostBuild.Tester()\n    __write_appender(t, 'appender.jam')\n    t.write('a.cpp', '')\n    t.write('b.cxx', '')\n    t.write('c.tui', '')\n    t.write('d.wd', '')\n    t.write('e.cpp', '')\n    t.write('x.l', '')\n    t.write('y.x_pro', '')\n    t.write('z.cpp', '')\n    t.write('lib/c.cpp', 'int bar() { return 0; }\\n')\n    t.write('lib/jamfile.jam', 'my-lib auxilliary : c.cpp ;')\n    t.write('jamroot.jam', 'import appender ;\\n\\nimport \"class\" : new ;\\nimport generators ;\\nimport type ;\\n\\n\\n################################################################################\\n#\\n#   We use our own custom EXE, LIB & OBJ target generators as using the regular\\n# ones would force us to have to deal with different compiler/linker specific\\n# \\'features\\' that really have nothing to do with this test. For example, IBM XL\\n# C/C++ for AIX, V12.1 (Version: 12.01.0000.0000) compiler exits with a non-zero\\n# exit code and thus fails our build when run with a source file using an\\n# unknown suffix like \\'.marked_cpp\\'.\\n#\\n################################################################################\\n\\ntype.register MY_EXE : my_exe ;\\ntype.register MY_LIB : my_lib ;\\ntype.register MY_OBJ : my_obj ;\\n\\nappender.register compile-c : C : MY_OBJ ;\\nappender.register compile-cpp : CPP : MY_OBJ ;\\nappender.register link-lib composing : MY_OBJ : MY_LIB ;\\nappender.register link-exe composing : MY_OBJ MY_LIB : MY_EXE ;\\n\\n\\n################################################################################\\n#\\n# LEX --> C\\n#\\n################################################################################\\n\\ntype.register LEX : l ;\\n\\nappender.register lex-to-c : LEX : C ;\\n\\n\\n################################################################################\\n#\\n#        /--> tUI_H --\\\\\\n# tUI --<              >--> CPP\\n#        \\\\------------/\\n#\\n################################################################################\\n\\ntype.register tUI : tui ;\\ntype.register tUI_H : tui_h ;\\n\\nappender.register ui-to-cpp : tUI tUI_H : CPP ;\\nappender.register ui-to-h : tUI : tUI_H ;\\n\\n\\n################################################################################\\n#\\n#          /--> X1 --\\\\\\n# X_PRO --<           >--> CPP\\n#          \\\\--> X2 --/\\n#\\n################################################################################\\n\\ntype.register X1 : x1 ;\\ntype.register X2 : x2 ;\\ntype.register X_PRO : x_pro ;\\n\\nappender.register x1-x2-to-cpp : X1 X2 : CPP ;\\nappender.register x-pro-to-x1-x2 : X_PRO : X1 X2 ;\\n\\n\\n################################################################################\\n#\\n#   When the main target type is NM_EXE, build OBJ from CPP-MARKED and not from\\n# anything else, e.g. directly from CPP.\\n#\\n################################################################################\\n\\ntype.register CPP_MARKED : marked_cpp : CPP ;\\ntype.register POSITIONS : positions ;\\ntype.register NM.TARGET.CPP : target_cpp : CPP ;\\ntype.register NM_EXE : : MY_EXE ;\\n\\nappender.register marked-to-target-cpp : CPP_MARKED : NM.TARGET.CPP ;\\nappender.register cpp-to-marked-positions : CPP : CPP_MARKED POSITIONS ;\\n\\nclass \"nm::target::cpp-obj-generator\" : generator\\n{\\n    rule __init__ ( id )\\n    {\\n        generator.__init__ $(id) : NM.TARGET.CPP : MY_OBJ ;\\n        generator.set-rule-name appender.appender ;\\n    }\\n\\n    rule requirements ( )\\n    {\\n        return <main-target-type>NM_EXE ;\\n    }\\n\\n    rule run ( project name ? : properties * : source : multiple ? )\\n    {\\n        if [ $(source).type ] = CPP\\n        {\\n            local converted = [ generators.construct $(project) : NM.TARGET.CPP\\n                : $(properties) : $(source) ] ;\\n            if $(converted)\\n            {\\n                return [ generators.construct $(project) : MY_OBJ :\\n                    $(properties) : $(converted[2]) ] ;\\n            }\\n        }\\n    }\\n}\\ngenerators.register [ new \"nm::target::cpp-obj-generator\" target-obj ] ;\\ngenerators.override target-obj : all ;\\n\\n\\n################################################################################\\n#\\n# A more complex test case scenario with the following generators:\\n#  1. WHL --> CPP, WHL_LR0, H, H(%_symbols)\\n#  2. DLP --> CPP\\n#  3. WD --> WHL(%_parser) DLP(%_lexer)\\n#  4. A custom generator of higher priority than generators 1. & 2. that helps\\n#     disambiguate between them when generating CPP files from WHL and DLP\\n#     sources.\\n#\\n################################################################################\\n\\ntype.register WHL : whl ;\\ntype.register DLP : dlp ;\\ntype.register WHL_LR0 : lr0 ;\\ntype.register WD : wd ;\\n\\nlocal whale-generator-id = [ appender.register whale : WHL : CPP WHL_LR0 H\\n    H(%_symbols) ] ;\\nlocal dolphin-generator-id = [ appender.register dolphin : DLP : CPP ] ;\\nappender.register wd : WD : WHL(%_parser) DLP(%_lexer) ;\\n\\nclass wd-to-cpp : generator\\n{\\n    rule __init__ ( id : sources * : targets * )\\n    {\\n        generator.__init__ $(id) : $(sources) : $(targets) ;\\n    }\\n\\n    rule run ( project name ? : property-set : source )\\n    {\\n        local new-sources = $(source) ;\\n        if ! [ $(source).type ] in WHL DLP\\n        {\\n            local r1 = [ generators.construct $(project) $(name) : WHL :\\n                $(property-set) : $(source) ] ;\\n            local r2 = [ generators.construct $(project) $(name) : DLP :\\n                $(property-set) : $(source) ] ;\\n            new-sources = [ sequence.unique $(r1[2-]) $(r2[2-]) ] ;\\n        }\\n\\n        local result ;\\n        for local i in $(new-sources)\\n        {\\n            local t = [ generators.construct $(project) $(name) : CPP :\\n                $(property-set) : $(i) ] ;\\n            result += $(t[2-]) ;\\n        }\\n        return $(result) ;\\n    }\\n}\\ngenerators.override $(__name__).wd-to-cpp : $(whale-generator-id) ;\\ngenerators.override $(__name__).wd-to-cpp : $(dolphin-generator-id) ;\\ngenerators.register [ new wd-to-cpp $(__name__).wd-to-cpp : : CPP ] ;\\n\\n\\n################################################################################\\n#\\n# Declare build targets.\\n#\\n################################################################################\\n\\n# This should not cause two CPP --> MY_OBJ constructions for a.cpp or b.cpp.\\nmy-exe a : a.cpp b.cxx obj_1 obj_2 c.tui d.wd x.l y.x_pro lib//auxilliary ;\\nmy-exe f : a.cpp b.cxx obj_1 obj_2 lib//auxilliary ;\\n\\n# This should cause two CPP --> MY_OBJ constructions for z.cpp.\\nmy-obj obj_1 : z.cpp ;\\nmy-obj obj_2 : z.cpp ;\\n\\nnm-exe e : e.cpp ;\\n')\n    t.run_build_system()\n    t.expect_addition('bin/' * BoostBuild.List('a.my_exe a.my_obj b.my_obj c.tui_h c.cpp c.my_obj d_parser.whl d_lexer.dlp d_parser.cpp d_lexer.cpp d_lexer.my_obj d_parser.lr0 d_parser.h d_parser.my_obj d_parser_symbols.h x.c x.my_obj y.x1 y.x2 y.cpp y.my_obj e.marked_cpp e.positions e.target_cpp e.my_obj e.my_exe f.my_exe obj_1.my_obj obj_2.my_obj'))\n    t.expect_addition('lib/bin/' * BoostBuild.List('c.my_obj auxilliary.my_lib'))\n    t.expect_nothing_more()\n    folder = 'bin'\n    t.expect_content_lines('%s/obj_1.my_obj' % folder, \"     Sources: 'z.cpp'\")\n    t.expect_content_lines('%s/obj_2.my_obj' % folder, \"     Sources: 'z.cpp'\")\n    t.expect_content_lines('%s/a.my_obj' % folder, \"     Sources: 'a.cpp'\")\n    lines = t.stdout().splitlines()\n    source_lines = [x for x in lines if re.match(\"^     Sources: '\", x)]\n    if not __match_count_is(source_lines, \"'z.cpp'\", 2):\n        BoostBuild.annotation('failure', 'z.cpp must be compiled exactly twice.')\n        t.fail_test(1)\n    if not __match_count_is(source_lines, \"'a.cpp'\", 1):\n        BoostBuild.annotation('failure', 'a.cpp must be compiled exactly once.')\n        t.fail_test(1)\n    t.cleanup()",
            "def test_basic():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    t = BoostBuild.Tester()\n    __write_appender(t, 'appender.jam')\n    t.write('a.cpp', '')\n    t.write('b.cxx', '')\n    t.write('c.tui', '')\n    t.write('d.wd', '')\n    t.write('e.cpp', '')\n    t.write('x.l', '')\n    t.write('y.x_pro', '')\n    t.write('z.cpp', '')\n    t.write('lib/c.cpp', 'int bar() { return 0; }\\n')\n    t.write('lib/jamfile.jam', 'my-lib auxilliary : c.cpp ;')\n    t.write('jamroot.jam', 'import appender ;\\n\\nimport \"class\" : new ;\\nimport generators ;\\nimport type ;\\n\\n\\n################################################################################\\n#\\n#   We use our own custom EXE, LIB & OBJ target generators as using the regular\\n# ones would force us to have to deal with different compiler/linker specific\\n# \\'features\\' that really have nothing to do with this test. For example, IBM XL\\n# C/C++ for AIX, V12.1 (Version: 12.01.0000.0000) compiler exits with a non-zero\\n# exit code and thus fails our build when run with a source file using an\\n# unknown suffix like \\'.marked_cpp\\'.\\n#\\n################################################################################\\n\\ntype.register MY_EXE : my_exe ;\\ntype.register MY_LIB : my_lib ;\\ntype.register MY_OBJ : my_obj ;\\n\\nappender.register compile-c : C : MY_OBJ ;\\nappender.register compile-cpp : CPP : MY_OBJ ;\\nappender.register link-lib composing : MY_OBJ : MY_LIB ;\\nappender.register link-exe composing : MY_OBJ MY_LIB : MY_EXE ;\\n\\n\\n################################################################################\\n#\\n# LEX --> C\\n#\\n################################################################################\\n\\ntype.register LEX : l ;\\n\\nappender.register lex-to-c : LEX : C ;\\n\\n\\n################################################################################\\n#\\n#        /--> tUI_H --\\\\\\n# tUI --<              >--> CPP\\n#        \\\\------------/\\n#\\n################################################################################\\n\\ntype.register tUI : tui ;\\ntype.register tUI_H : tui_h ;\\n\\nappender.register ui-to-cpp : tUI tUI_H : CPP ;\\nappender.register ui-to-h : tUI : tUI_H ;\\n\\n\\n################################################################################\\n#\\n#          /--> X1 --\\\\\\n# X_PRO --<           >--> CPP\\n#          \\\\--> X2 --/\\n#\\n################################################################################\\n\\ntype.register X1 : x1 ;\\ntype.register X2 : x2 ;\\ntype.register X_PRO : x_pro ;\\n\\nappender.register x1-x2-to-cpp : X1 X2 : CPP ;\\nappender.register x-pro-to-x1-x2 : X_PRO : X1 X2 ;\\n\\n\\n################################################################################\\n#\\n#   When the main target type is NM_EXE, build OBJ from CPP-MARKED and not from\\n# anything else, e.g. directly from CPP.\\n#\\n################################################################################\\n\\ntype.register CPP_MARKED : marked_cpp : CPP ;\\ntype.register POSITIONS : positions ;\\ntype.register NM.TARGET.CPP : target_cpp : CPP ;\\ntype.register NM_EXE : : MY_EXE ;\\n\\nappender.register marked-to-target-cpp : CPP_MARKED : NM.TARGET.CPP ;\\nappender.register cpp-to-marked-positions : CPP : CPP_MARKED POSITIONS ;\\n\\nclass \"nm::target::cpp-obj-generator\" : generator\\n{\\n    rule __init__ ( id )\\n    {\\n        generator.__init__ $(id) : NM.TARGET.CPP : MY_OBJ ;\\n        generator.set-rule-name appender.appender ;\\n    }\\n\\n    rule requirements ( )\\n    {\\n        return <main-target-type>NM_EXE ;\\n    }\\n\\n    rule run ( project name ? : properties * : source : multiple ? )\\n    {\\n        if [ $(source).type ] = CPP\\n        {\\n            local converted = [ generators.construct $(project) : NM.TARGET.CPP\\n                : $(properties) : $(source) ] ;\\n            if $(converted)\\n            {\\n                return [ generators.construct $(project) : MY_OBJ :\\n                    $(properties) : $(converted[2]) ] ;\\n            }\\n        }\\n    }\\n}\\ngenerators.register [ new \"nm::target::cpp-obj-generator\" target-obj ] ;\\ngenerators.override target-obj : all ;\\n\\n\\n################################################################################\\n#\\n# A more complex test case scenario with the following generators:\\n#  1. WHL --> CPP, WHL_LR0, H, H(%_symbols)\\n#  2. DLP --> CPP\\n#  3. WD --> WHL(%_parser) DLP(%_lexer)\\n#  4. A custom generator of higher priority than generators 1. & 2. that helps\\n#     disambiguate between them when generating CPP files from WHL and DLP\\n#     sources.\\n#\\n################################################################################\\n\\ntype.register WHL : whl ;\\ntype.register DLP : dlp ;\\ntype.register WHL_LR0 : lr0 ;\\ntype.register WD : wd ;\\n\\nlocal whale-generator-id = [ appender.register whale : WHL : CPP WHL_LR0 H\\n    H(%_symbols) ] ;\\nlocal dolphin-generator-id = [ appender.register dolphin : DLP : CPP ] ;\\nappender.register wd : WD : WHL(%_parser) DLP(%_lexer) ;\\n\\nclass wd-to-cpp : generator\\n{\\n    rule __init__ ( id : sources * : targets * )\\n    {\\n        generator.__init__ $(id) : $(sources) : $(targets) ;\\n    }\\n\\n    rule run ( project name ? : property-set : source )\\n    {\\n        local new-sources = $(source) ;\\n        if ! [ $(source).type ] in WHL DLP\\n        {\\n            local r1 = [ generators.construct $(project) $(name) : WHL :\\n                $(property-set) : $(source) ] ;\\n            local r2 = [ generators.construct $(project) $(name) : DLP :\\n                $(property-set) : $(source) ] ;\\n            new-sources = [ sequence.unique $(r1[2-]) $(r2[2-]) ] ;\\n        }\\n\\n        local result ;\\n        for local i in $(new-sources)\\n        {\\n            local t = [ generators.construct $(project) $(name) : CPP :\\n                $(property-set) : $(i) ] ;\\n            result += $(t[2-]) ;\\n        }\\n        return $(result) ;\\n    }\\n}\\ngenerators.override $(__name__).wd-to-cpp : $(whale-generator-id) ;\\ngenerators.override $(__name__).wd-to-cpp : $(dolphin-generator-id) ;\\ngenerators.register [ new wd-to-cpp $(__name__).wd-to-cpp : : CPP ] ;\\n\\n\\n################################################################################\\n#\\n# Declare build targets.\\n#\\n################################################################################\\n\\n# This should not cause two CPP --> MY_OBJ constructions for a.cpp or b.cpp.\\nmy-exe a : a.cpp b.cxx obj_1 obj_2 c.tui d.wd x.l y.x_pro lib//auxilliary ;\\nmy-exe f : a.cpp b.cxx obj_1 obj_2 lib//auxilliary ;\\n\\n# This should cause two CPP --> MY_OBJ constructions for z.cpp.\\nmy-obj obj_1 : z.cpp ;\\nmy-obj obj_2 : z.cpp ;\\n\\nnm-exe e : e.cpp ;\\n')\n    t.run_build_system()\n    t.expect_addition('bin/' * BoostBuild.List('a.my_exe a.my_obj b.my_obj c.tui_h c.cpp c.my_obj d_parser.whl d_lexer.dlp d_parser.cpp d_lexer.cpp d_lexer.my_obj d_parser.lr0 d_parser.h d_parser.my_obj d_parser_symbols.h x.c x.my_obj y.x1 y.x2 y.cpp y.my_obj e.marked_cpp e.positions e.target_cpp e.my_obj e.my_exe f.my_exe obj_1.my_obj obj_2.my_obj'))\n    t.expect_addition('lib/bin/' * BoostBuild.List('c.my_obj auxilliary.my_lib'))\n    t.expect_nothing_more()\n    folder = 'bin'\n    t.expect_content_lines('%s/obj_1.my_obj' % folder, \"     Sources: 'z.cpp'\")\n    t.expect_content_lines('%s/obj_2.my_obj' % folder, \"     Sources: 'z.cpp'\")\n    t.expect_content_lines('%s/a.my_obj' % folder, \"     Sources: 'a.cpp'\")\n    lines = t.stdout().splitlines()\n    source_lines = [x for x in lines if re.match(\"^     Sources: '\", x)]\n    if not __match_count_is(source_lines, \"'z.cpp'\", 2):\n        BoostBuild.annotation('failure', 'z.cpp must be compiled exactly twice.')\n        t.fail_test(1)\n    if not __match_count_is(source_lines, \"'a.cpp'\", 1):\n        BoostBuild.annotation('failure', 'a.cpp must be compiled exactly once.')\n        t.fail_test(1)\n    t.cleanup()",
            "def test_basic():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    t = BoostBuild.Tester()\n    __write_appender(t, 'appender.jam')\n    t.write('a.cpp', '')\n    t.write('b.cxx', '')\n    t.write('c.tui', '')\n    t.write('d.wd', '')\n    t.write('e.cpp', '')\n    t.write('x.l', '')\n    t.write('y.x_pro', '')\n    t.write('z.cpp', '')\n    t.write('lib/c.cpp', 'int bar() { return 0; }\\n')\n    t.write('lib/jamfile.jam', 'my-lib auxilliary : c.cpp ;')\n    t.write('jamroot.jam', 'import appender ;\\n\\nimport \"class\" : new ;\\nimport generators ;\\nimport type ;\\n\\n\\n################################################################################\\n#\\n#   We use our own custom EXE, LIB & OBJ target generators as using the regular\\n# ones would force us to have to deal with different compiler/linker specific\\n# \\'features\\' that really have nothing to do with this test. For example, IBM XL\\n# C/C++ for AIX, V12.1 (Version: 12.01.0000.0000) compiler exits with a non-zero\\n# exit code and thus fails our build when run with a source file using an\\n# unknown suffix like \\'.marked_cpp\\'.\\n#\\n################################################################################\\n\\ntype.register MY_EXE : my_exe ;\\ntype.register MY_LIB : my_lib ;\\ntype.register MY_OBJ : my_obj ;\\n\\nappender.register compile-c : C : MY_OBJ ;\\nappender.register compile-cpp : CPP : MY_OBJ ;\\nappender.register link-lib composing : MY_OBJ : MY_LIB ;\\nappender.register link-exe composing : MY_OBJ MY_LIB : MY_EXE ;\\n\\n\\n################################################################################\\n#\\n# LEX --> C\\n#\\n################################################################################\\n\\ntype.register LEX : l ;\\n\\nappender.register lex-to-c : LEX : C ;\\n\\n\\n################################################################################\\n#\\n#        /--> tUI_H --\\\\\\n# tUI --<              >--> CPP\\n#        \\\\------------/\\n#\\n################################################################################\\n\\ntype.register tUI : tui ;\\ntype.register tUI_H : tui_h ;\\n\\nappender.register ui-to-cpp : tUI tUI_H : CPP ;\\nappender.register ui-to-h : tUI : tUI_H ;\\n\\n\\n################################################################################\\n#\\n#          /--> X1 --\\\\\\n# X_PRO --<           >--> CPP\\n#          \\\\--> X2 --/\\n#\\n################################################################################\\n\\ntype.register X1 : x1 ;\\ntype.register X2 : x2 ;\\ntype.register X_PRO : x_pro ;\\n\\nappender.register x1-x2-to-cpp : X1 X2 : CPP ;\\nappender.register x-pro-to-x1-x2 : X_PRO : X1 X2 ;\\n\\n\\n################################################################################\\n#\\n#   When the main target type is NM_EXE, build OBJ from CPP-MARKED and not from\\n# anything else, e.g. directly from CPP.\\n#\\n################################################################################\\n\\ntype.register CPP_MARKED : marked_cpp : CPP ;\\ntype.register POSITIONS : positions ;\\ntype.register NM.TARGET.CPP : target_cpp : CPP ;\\ntype.register NM_EXE : : MY_EXE ;\\n\\nappender.register marked-to-target-cpp : CPP_MARKED : NM.TARGET.CPP ;\\nappender.register cpp-to-marked-positions : CPP : CPP_MARKED POSITIONS ;\\n\\nclass \"nm::target::cpp-obj-generator\" : generator\\n{\\n    rule __init__ ( id )\\n    {\\n        generator.__init__ $(id) : NM.TARGET.CPP : MY_OBJ ;\\n        generator.set-rule-name appender.appender ;\\n    }\\n\\n    rule requirements ( )\\n    {\\n        return <main-target-type>NM_EXE ;\\n    }\\n\\n    rule run ( project name ? : properties * : source : multiple ? )\\n    {\\n        if [ $(source).type ] = CPP\\n        {\\n            local converted = [ generators.construct $(project) : NM.TARGET.CPP\\n                : $(properties) : $(source) ] ;\\n            if $(converted)\\n            {\\n                return [ generators.construct $(project) : MY_OBJ :\\n                    $(properties) : $(converted[2]) ] ;\\n            }\\n        }\\n    }\\n}\\ngenerators.register [ new \"nm::target::cpp-obj-generator\" target-obj ] ;\\ngenerators.override target-obj : all ;\\n\\n\\n################################################################################\\n#\\n# A more complex test case scenario with the following generators:\\n#  1. WHL --> CPP, WHL_LR0, H, H(%_symbols)\\n#  2. DLP --> CPP\\n#  3. WD --> WHL(%_parser) DLP(%_lexer)\\n#  4. A custom generator of higher priority than generators 1. & 2. that helps\\n#     disambiguate between them when generating CPP files from WHL and DLP\\n#     sources.\\n#\\n################################################################################\\n\\ntype.register WHL : whl ;\\ntype.register DLP : dlp ;\\ntype.register WHL_LR0 : lr0 ;\\ntype.register WD : wd ;\\n\\nlocal whale-generator-id = [ appender.register whale : WHL : CPP WHL_LR0 H\\n    H(%_symbols) ] ;\\nlocal dolphin-generator-id = [ appender.register dolphin : DLP : CPP ] ;\\nappender.register wd : WD : WHL(%_parser) DLP(%_lexer) ;\\n\\nclass wd-to-cpp : generator\\n{\\n    rule __init__ ( id : sources * : targets * )\\n    {\\n        generator.__init__ $(id) : $(sources) : $(targets) ;\\n    }\\n\\n    rule run ( project name ? : property-set : source )\\n    {\\n        local new-sources = $(source) ;\\n        if ! [ $(source).type ] in WHL DLP\\n        {\\n            local r1 = [ generators.construct $(project) $(name) : WHL :\\n                $(property-set) : $(source) ] ;\\n            local r2 = [ generators.construct $(project) $(name) : DLP :\\n                $(property-set) : $(source) ] ;\\n            new-sources = [ sequence.unique $(r1[2-]) $(r2[2-]) ] ;\\n        }\\n\\n        local result ;\\n        for local i in $(new-sources)\\n        {\\n            local t = [ generators.construct $(project) $(name) : CPP :\\n                $(property-set) : $(i) ] ;\\n            result += $(t[2-]) ;\\n        }\\n        return $(result) ;\\n    }\\n}\\ngenerators.override $(__name__).wd-to-cpp : $(whale-generator-id) ;\\ngenerators.override $(__name__).wd-to-cpp : $(dolphin-generator-id) ;\\ngenerators.register [ new wd-to-cpp $(__name__).wd-to-cpp : : CPP ] ;\\n\\n\\n################################################################################\\n#\\n# Declare build targets.\\n#\\n################################################################################\\n\\n# This should not cause two CPP --> MY_OBJ constructions for a.cpp or b.cpp.\\nmy-exe a : a.cpp b.cxx obj_1 obj_2 c.tui d.wd x.l y.x_pro lib//auxilliary ;\\nmy-exe f : a.cpp b.cxx obj_1 obj_2 lib//auxilliary ;\\n\\n# This should cause two CPP --> MY_OBJ constructions for z.cpp.\\nmy-obj obj_1 : z.cpp ;\\nmy-obj obj_2 : z.cpp ;\\n\\nnm-exe e : e.cpp ;\\n')\n    t.run_build_system()\n    t.expect_addition('bin/' * BoostBuild.List('a.my_exe a.my_obj b.my_obj c.tui_h c.cpp c.my_obj d_parser.whl d_lexer.dlp d_parser.cpp d_lexer.cpp d_lexer.my_obj d_parser.lr0 d_parser.h d_parser.my_obj d_parser_symbols.h x.c x.my_obj y.x1 y.x2 y.cpp y.my_obj e.marked_cpp e.positions e.target_cpp e.my_obj e.my_exe f.my_exe obj_1.my_obj obj_2.my_obj'))\n    t.expect_addition('lib/bin/' * BoostBuild.List('c.my_obj auxilliary.my_lib'))\n    t.expect_nothing_more()\n    folder = 'bin'\n    t.expect_content_lines('%s/obj_1.my_obj' % folder, \"     Sources: 'z.cpp'\")\n    t.expect_content_lines('%s/obj_2.my_obj' % folder, \"     Sources: 'z.cpp'\")\n    t.expect_content_lines('%s/a.my_obj' % folder, \"     Sources: 'a.cpp'\")\n    lines = t.stdout().splitlines()\n    source_lines = [x for x in lines if re.match(\"^     Sources: '\", x)]\n    if not __match_count_is(source_lines, \"'z.cpp'\", 2):\n        BoostBuild.annotation('failure', 'z.cpp must be compiled exactly twice.')\n        t.fail_test(1)\n    if not __match_count_is(source_lines, \"'a.cpp'\", 1):\n        BoostBuild.annotation('failure', 'a.cpp must be compiled exactly once.')\n        t.fail_test(1)\n    t.cleanup()"
        ]
    },
    {
        "func_name": "f",
        "original": "def f(rename):\n    if rename:\n        return '(%_x)'\n    return ''",
        "mutated": [
            "def f(rename):\n    if False:\n        i = 10\n    if rename:\n        return '(%_x)'\n    return ''",
            "def f(rename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if rename:\n        return '(%_x)'\n    return ''",
            "def f(rename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if rename:\n        return '(%_x)'\n    return ''",
            "def f(rename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if rename:\n        return '(%_x)'\n    return ''",
            "def f(rename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if rename:\n        return '(%_x)'\n    return ''"
        ]
    },
    {
        "func_name": "suffix",
        "original": "def suffix(rename):\n    if rename:\n        return '_x'\n    return ''",
        "mutated": [
            "def suffix(rename):\n    if False:\n        i = 10\n    if rename:\n        return '_x'\n    return ''",
            "def suffix(rename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if rename:\n        return '_x'\n    return ''",
            "def suffix(rename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if rename:\n        return '_x'\n    return ''",
            "def suffix(rename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if rename:\n        return '_x'\n    return ''",
            "def suffix(rename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if rename:\n        return '_x'\n    return ''"
        ]
    },
    {
        "func_name": "test_one",
        "original": "def test_one(t, rename1, rename2, rename3, status):\n\n    def f(rename):\n        if rename:\n            return '(%_x)'\n        return ''\n    jamfile = jamfile_template % (f(rename1), f(rename2), f(rename3))\n    t.write('jamroot.jam', jamfile, wait=False)\n    t.rm('bin')\n    t.run_build_system(status=status)\n    if status:\n        t.expect_output_lines('*.bbX-to-ccc: source targets have different names: cannot determine target name')\n    else:\n\n        def suffix(rename):\n            if rename:\n                return '_x'\n            return ''\n        name = 'bin/_xxx'\n        e = t.expect_addition\n        e('%s%s._b1' % (name, suffix(rename1)))\n        e('%s%s._b2' % (name, suffix(rename2)))\n        e('%s%s._b3' % (name, suffix(rename3)))\n        e('%s%s._c' % (name, suffix(rename1 and rename2 and rename3)))\n        e('%s._d' % name)\n    t.expect_nothing_more()",
        "mutated": [
            "def test_one(t, rename1, rename2, rename3, status):\n    if False:\n        i = 10\n\n    def f(rename):\n        if rename:\n            return '(%_x)'\n        return ''\n    jamfile = jamfile_template % (f(rename1), f(rename2), f(rename3))\n    t.write('jamroot.jam', jamfile, wait=False)\n    t.rm('bin')\n    t.run_build_system(status=status)\n    if status:\n        t.expect_output_lines('*.bbX-to-ccc: source targets have different names: cannot determine target name')\n    else:\n\n        def suffix(rename):\n            if rename:\n                return '_x'\n            return ''\n        name = 'bin/_xxx'\n        e = t.expect_addition\n        e('%s%s._b1' % (name, suffix(rename1)))\n        e('%s%s._b2' % (name, suffix(rename2)))\n        e('%s%s._b3' % (name, suffix(rename3)))\n        e('%s%s._c' % (name, suffix(rename1 and rename2 and rename3)))\n        e('%s._d' % name)\n    t.expect_nothing_more()",
            "def test_one(t, rename1, rename2, rename3, status):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    def f(rename):\n        if rename:\n            return '(%_x)'\n        return ''\n    jamfile = jamfile_template % (f(rename1), f(rename2), f(rename3))\n    t.write('jamroot.jam', jamfile, wait=False)\n    t.rm('bin')\n    t.run_build_system(status=status)\n    if status:\n        t.expect_output_lines('*.bbX-to-ccc: source targets have different names: cannot determine target name')\n    else:\n\n        def suffix(rename):\n            if rename:\n                return '_x'\n            return ''\n        name = 'bin/_xxx'\n        e = t.expect_addition\n        e('%s%s._b1' % (name, suffix(rename1)))\n        e('%s%s._b2' % (name, suffix(rename2)))\n        e('%s%s._b3' % (name, suffix(rename3)))\n        e('%s%s._c' % (name, suffix(rename1 and rename2 and rename3)))\n        e('%s._d' % name)\n    t.expect_nothing_more()",
            "def test_one(t, rename1, rename2, rename3, status):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    def f(rename):\n        if rename:\n            return '(%_x)'\n        return ''\n    jamfile = jamfile_template % (f(rename1), f(rename2), f(rename3))\n    t.write('jamroot.jam', jamfile, wait=False)\n    t.rm('bin')\n    t.run_build_system(status=status)\n    if status:\n        t.expect_output_lines('*.bbX-to-ccc: source targets have different names: cannot determine target name')\n    else:\n\n        def suffix(rename):\n            if rename:\n                return '_x'\n            return ''\n        name = 'bin/_xxx'\n        e = t.expect_addition\n        e('%s%s._b1' % (name, suffix(rename1)))\n        e('%s%s._b2' % (name, suffix(rename2)))\n        e('%s%s._b3' % (name, suffix(rename3)))\n        e('%s%s._c' % (name, suffix(rename1 and rename2 and rename3)))\n        e('%s._d' % name)\n    t.expect_nothing_more()",
            "def test_one(t, rename1, rename2, rename3, status):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    def f(rename):\n        if rename:\n            return '(%_x)'\n        return ''\n    jamfile = jamfile_template % (f(rename1), f(rename2), f(rename3))\n    t.write('jamroot.jam', jamfile, wait=False)\n    t.rm('bin')\n    t.run_build_system(status=status)\n    if status:\n        t.expect_output_lines('*.bbX-to-ccc: source targets have different names: cannot determine target name')\n    else:\n\n        def suffix(rename):\n            if rename:\n                return '_x'\n            return ''\n        name = 'bin/_xxx'\n        e = t.expect_addition\n        e('%s%s._b1' % (name, suffix(rename1)))\n        e('%s%s._b2' % (name, suffix(rename2)))\n        e('%s%s._b3' % (name, suffix(rename3)))\n        e('%s%s._c' % (name, suffix(rename1 and rename2 and rename3)))\n        e('%s._d' % name)\n    t.expect_nothing_more()",
            "def test_one(t, rename1, rename2, rename3, status):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    def f(rename):\n        if rename:\n            return '(%_x)'\n        return ''\n    jamfile = jamfile_template % (f(rename1), f(rename2), f(rename3))\n    t.write('jamroot.jam', jamfile, wait=False)\n    t.rm('bin')\n    t.run_build_system(status=status)\n    if status:\n        t.expect_output_lines('*.bbX-to-ccc: source targets have different names: cannot determine target name')\n    else:\n\n        def suffix(rename):\n            if rename:\n                return '_x'\n            return ''\n        name = 'bin/_xxx'\n        e = t.expect_addition\n        e('%s%s._b1' % (name, suffix(rename1)))\n        e('%s%s._b2' % (name, suffix(rename2)))\n        e('%s%s._b3' % (name, suffix(rename3)))\n        e('%s%s._c' % (name, suffix(rename1 and rename2 and rename3)))\n        e('%s._d' % name)\n    t.expect_nothing_more()"
        ]
    },
    {
        "func_name": "test_generated_target_names",
        "original": "def test_generated_target_names():\n    \"\"\"\n      Test generator generated target names. Unless given explicitly, target\n    names should be determined based on their specified source names. All\n    sources for generating a target need to have matching names in order for\n    Boost Build to be able to implicitly determine the target's name.\n\n      We use the following target generation structure with differently named\n    BBX targets:\n                       /---> BB1 ---                AAA --<----> BB2 ---->--> CCC --(composing)--> DDD\n                       \\\\---> BB3 ---/\n\n      The extra generator at the end is needed because generating a top-level\n    CCC target directly would requires us to explicitly specify a name for it.\n    The extra generator needs to be composing in order not to explicitly\n    request a specific name for its CCC source target based on its own target\n    name.\n\n      We also check for a regression where only the first two sources were\n    checked to see if their names match. Note that we need to try out all file\n    renaming combinations as we do not know what ordering Boost Build is going\n    to use when passing in those files as generator sources.\n\n    \"\"\"\n    jamfile_template = 'import type ;\\ntype.register AAA : _a ;\\ntype.register BB1 : _b1 ;\\ntype.register BB2 : _b2 ;\\ntype.register BB3 : _b3 ;\\ntype.register CCC : _c ;\\ntype.register DDD : _d ;\\n\\nimport appender ;\\nappender.register aaa-to-bbX           : AAA         : BB1%s BB2%s BB3%s ;\\nappender.register bbX-to-ccc           : BB1 BB2 BB3 : CCC ;\\nappender.register ccc-to-ddd composing : CCC         : DDD ;\\n\\nddd _xxx : _xxx._a ;\\n'\n    t = BoostBuild.Tester()\n    __write_appender(t, 'appender.jam')\n    t.write('_xxx._a', '')\n\n    def test_one(t, rename1, rename2, rename3, status):\n\n        def f(rename):\n            if rename:\n                return '(%_x)'\n            return ''\n        jamfile = jamfile_template % (f(rename1), f(rename2), f(rename3))\n        t.write('jamroot.jam', jamfile, wait=False)\n        t.rm('bin')\n        t.run_build_system(status=status)\n        if status:\n            t.expect_output_lines('*.bbX-to-ccc: source targets have different names: cannot determine target name')\n        else:\n\n            def suffix(rename):\n                if rename:\n                    return '_x'\n                return ''\n            name = 'bin/_xxx'\n            e = t.expect_addition\n            e('%s%s._b1' % (name, suffix(rename1)))\n            e('%s%s._b2' % (name, suffix(rename2)))\n            e('%s%s._b3' % (name, suffix(rename3)))\n            e('%s%s._c' % (name, suffix(rename1 and rename2 and rename3)))\n            e('%s._d' % name)\n        t.expect_nothing_more()\n    test_one(t, False, False, False, status=0)\n    test_one(t, True, False, False, status=1)\n    test_one(t, False, True, False, status=1)\n    test_one(t, False, False, True, status=1)\n    test_one(t, True, True, False, status=1)\n    test_one(t, True, False, True, status=1)\n    test_one(t, False, True, True, status=1)\n    test_one(t, True, True, True, status=0)\n    t.cleanup()",
        "mutated": [
            "def test_generated_target_names():\n    if False:\n        i = 10\n    \"\\n      Test generator generated target names. Unless given explicitly, target\\n    names should be determined based on their specified source names. All\\n    sources for generating a target need to have matching names in order for\\n    Boost Build to be able to implicitly determine the target's name.\\n\\n      We use the following target generation structure with differently named\\n    BBX targets:\\n                       /---> BB1 ---                AAA --<----> BB2 ---->--> CCC --(composing)--> DDD\\n                       \\\\---> BB3 ---/\\n\\n      The extra generator at the end is needed because generating a top-level\\n    CCC target directly would requires us to explicitly specify a name for it.\\n    The extra generator needs to be composing in order not to explicitly\\n    request a specific name for its CCC source target based on its own target\\n    name.\\n\\n      We also check for a regression where only the first two sources were\\n    checked to see if their names match. Note that we need to try out all file\\n    renaming combinations as we do not know what ordering Boost Build is going\\n    to use when passing in those files as generator sources.\\n\\n    \"\n    jamfile_template = 'import type ;\\ntype.register AAA : _a ;\\ntype.register BB1 : _b1 ;\\ntype.register BB2 : _b2 ;\\ntype.register BB3 : _b3 ;\\ntype.register CCC : _c ;\\ntype.register DDD : _d ;\\n\\nimport appender ;\\nappender.register aaa-to-bbX           : AAA         : BB1%s BB2%s BB3%s ;\\nappender.register bbX-to-ccc           : BB1 BB2 BB3 : CCC ;\\nappender.register ccc-to-ddd composing : CCC         : DDD ;\\n\\nddd _xxx : _xxx._a ;\\n'\n    t = BoostBuild.Tester()\n    __write_appender(t, 'appender.jam')\n    t.write('_xxx._a', '')\n\n    def test_one(t, rename1, rename2, rename3, status):\n\n        def f(rename):\n            if rename:\n                return '(%_x)'\n            return ''\n        jamfile = jamfile_template % (f(rename1), f(rename2), f(rename3))\n        t.write('jamroot.jam', jamfile, wait=False)\n        t.rm('bin')\n        t.run_build_system(status=status)\n        if status:\n            t.expect_output_lines('*.bbX-to-ccc: source targets have different names: cannot determine target name')\n        else:\n\n            def suffix(rename):\n                if rename:\n                    return '_x'\n                return ''\n            name = 'bin/_xxx'\n            e = t.expect_addition\n            e('%s%s._b1' % (name, suffix(rename1)))\n            e('%s%s._b2' % (name, suffix(rename2)))\n            e('%s%s._b3' % (name, suffix(rename3)))\n            e('%s%s._c' % (name, suffix(rename1 and rename2 and rename3)))\n            e('%s._d' % name)\n        t.expect_nothing_more()\n    test_one(t, False, False, False, status=0)\n    test_one(t, True, False, False, status=1)\n    test_one(t, False, True, False, status=1)\n    test_one(t, False, False, True, status=1)\n    test_one(t, True, True, False, status=1)\n    test_one(t, True, False, True, status=1)\n    test_one(t, False, True, True, status=1)\n    test_one(t, True, True, True, status=0)\n    t.cleanup()",
            "def test_generated_target_names():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n      Test generator generated target names. Unless given explicitly, target\\n    names should be determined based on their specified source names. All\\n    sources for generating a target need to have matching names in order for\\n    Boost Build to be able to implicitly determine the target's name.\\n\\n      We use the following target generation structure with differently named\\n    BBX targets:\\n                       /---> BB1 ---                AAA --<----> BB2 ---->--> CCC --(composing)--> DDD\\n                       \\\\---> BB3 ---/\\n\\n      The extra generator at the end is needed because generating a top-level\\n    CCC target directly would requires us to explicitly specify a name for it.\\n    The extra generator needs to be composing in order not to explicitly\\n    request a specific name for its CCC source target based on its own target\\n    name.\\n\\n      We also check for a regression where only the first two sources were\\n    checked to see if their names match. Note that we need to try out all file\\n    renaming combinations as we do not know what ordering Boost Build is going\\n    to use when passing in those files as generator sources.\\n\\n    \"\n    jamfile_template = 'import type ;\\ntype.register AAA : _a ;\\ntype.register BB1 : _b1 ;\\ntype.register BB2 : _b2 ;\\ntype.register BB3 : _b3 ;\\ntype.register CCC : _c ;\\ntype.register DDD : _d ;\\n\\nimport appender ;\\nappender.register aaa-to-bbX           : AAA         : BB1%s BB2%s BB3%s ;\\nappender.register bbX-to-ccc           : BB1 BB2 BB3 : CCC ;\\nappender.register ccc-to-ddd composing : CCC         : DDD ;\\n\\nddd _xxx : _xxx._a ;\\n'\n    t = BoostBuild.Tester()\n    __write_appender(t, 'appender.jam')\n    t.write('_xxx._a', '')\n\n    def test_one(t, rename1, rename2, rename3, status):\n\n        def f(rename):\n            if rename:\n                return '(%_x)'\n            return ''\n        jamfile = jamfile_template % (f(rename1), f(rename2), f(rename3))\n        t.write('jamroot.jam', jamfile, wait=False)\n        t.rm('bin')\n        t.run_build_system(status=status)\n        if status:\n            t.expect_output_lines('*.bbX-to-ccc: source targets have different names: cannot determine target name')\n        else:\n\n            def suffix(rename):\n                if rename:\n                    return '_x'\n                return ''\n            name = 'bin/_xxx'\n            e = t.expect_addition\n            e('%s%s._b1' % (name, suffix(rename1)))\n            e('%s%s._b2' % (name, suffix(rename2)))\n            e('%s%s._b3' % (name, suffix(rename3)))\n            e('%s%s._c' % (name, suffix(rename1 and rename2 and rename3)))\n            e('%s._d' % name)\n        t.expect_nothing_more()\n    test_one(t, False, False, False, status=0)\n    test_one(t, True, False, False, status=1)\n    test_one(t, False, True, False, status=1)\n    test_one(t, False, False, True, status=1)\n    test_one(t, True, True, False, status=1)\n    test_one(t, True, False, True, status=1)\n    test_one(t, False, True, True, status=1)\n    test_one(t, True, True, True, status=0)\n    t.cleanup()",
            "def test_generated_target_names():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n      Test generator generated target names. Unless given explicitly, target\\n    names should be determined based on their specified source names. All\\n    sources for generating a target need to have matching names in order for\\n    Boost Build to be able to implicitly determine the target's name.\\n\\n      We use the following target generation structure with differently named\\n    BBX targets:\\n                       /---> BB1 ---                AAA --<----> BB2 ---->--> CCC --(composing)--> DDD\\n                       \\\\---> BB3 ---/\\n\\n      The extra generator at the end is needed because generating a top-level\\n    CCC target directly would requires us to explicitly specify a name for it.\\n    The extra generator needs to be composing in order not to explicitly\\n    request a specific name for its CCC source target based on its own target\\n    name.\\n\\n      We also check for a regression where only the first two sources were\\n    checked to see if their names match. Note that we need to try out all file\\n    renaming combinations as we do not know what ordering Boost Build is going\\n    to use when passing in those files as generator sources.\\n\\n    \"\n    jamfile_template = 'import type ;\\ntype.register AAA : _a ;\\ntype.register BB1 : _b1 ;\\ntype.register BB2 : _b2 ;\\ntype.register BB3 : _b3 ;\\ntype.register CCC : _c ;\\ntype.register DDD : _d ;\\n\\nimport appender ;\\nappender.register aaa-to-bbX           : AAA         : BB1%s BB2%s BB3%s ;\\nappender.register bbX-to-ccc           : BB1 BB2 BB3 : CCC ;\\nappender.register ccc-to-ddd composing : CCC         : DDD ;\\n\\nddd _xxx : _xxx._a ;\\n'\n    t = BoostBuild.Tester()\n    __write_appender(t, 'appender.jam')\n    t.write('_xxx._a', '')\n\n    def test_one(t, rename1, rename2, rename3, status):\n\n        def f(rename):\n            if rename:\n                return '(%_x)'\n            return ''\n        jamfile = jamfile_template % (f(rename1), f(rename2), f(rename3))\n        t.write('jamroot.jam', jamfile, wait=False)\n        t.rm('bin')\n        t.run_build_system(status=status)\n        if status:\n            t.expect_output_lines('*.bbX-to-ccc: source targets have different names: cannot determine target name')\n        else:\n\n            def suffix(rename):\n                if rename:\n                    return '_x'\n                return ''\n            name = 'bin/_xxx'\n            e = t.expect_addition\n            e('%s%s._b1' % (name, suffix(rename1)))\n            e('%s%s._b2' % (name, suffix(rename2)))\n            e('%s%s._b3' % (name, suffix(rename3)))\n            e('%s%s._c' % (name, suffix(rename1 and rename2 and rename3)))\n            e('%s._d' % name)\n        t.expect_nothing_more()\n    test_one(t, False, False, False, status=0)\n    test_one(t, True, False, False, status=1)\n    test_one(t, False, True, False, status=1)\n    test_one(t, False, False, True, status=1)\n    test_one(t, True, True, False, status=1)\n    test_one(t, True, False, True, status=1)\n    test_one(t, False, True, True, status=1)\n    test_one(t, True, True, True, status=0)\n    t.cleanup()",
            "def test_generated_target_names():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n      Test generator generated target names. Unless given explicitly, target\\n    names should be determined based on their specified source names. All\\n    sources for generating a target need to have matching names in order for\\n    Boost Build to be able to implicitly determine the target's name.\\n\\n      We use the following target generation structure with differently named\\n    BBX targets:\\n                       /---> BB1 ---                AAA --<----> BB2 ---->--> CCC --(composing)--> DDD\\n                       \\\\---> BB3 ---/\\n\\n      The extra generator at the end is needed because generating a top-level\\n    CCC target directly would requires us to explicitly specify a name for it.\\n    The extra generator needs to be composing in order not to explicitly\\n    request a specific name for its CCC source target based on its own target\\n    name.\\n\\n      We also check for a regression where only the first two sources were\\n    checked to see if their names match. Note that we need to try out all file\\n    renaming combinations as we do not know what ordering Boost Build is going\\n    to use when passing in those files as generator sources.\\n\\n    \"\n    jamfile_template = 'import type ;\\ntype.register AAA : _a ;\\ntype.register BB1 : _b1 ;\\ntype.register BB2 : _b2 ;\\ntype.register BB3 : _b3 ;\\ntype.register CCC : _c ;\\ntype.register DDD : _d ;\\n\\nimport appender ;\\nappender.register aaa-to-bbX           : AAA         : BB1%s BB2%s BB3%s ;\\nappender.register bbX-to-ccc           : BB1 BB2 BB3 : CCC ;\\nappender.register ccc-to-ddd composing : CCC         : DDD ;\\n\\nddd _xxx : _xxx._a ;\\n'\n    t = BoostBuild.Tester()\n    __write_appender(t, 'appender.jam')\n    t.write('_xxx._a', '')\n\n    def test_one(t, rename1, rename2, rename3, status):\n\n        def f(rename):\n            if rename:\n                return '(%_x)'\n            return ''\n        jamfile = jamfile_template % (f(rename1), f(rename2), f(rename3))\n        t.write('jamroot.jam', jamfile, wait=False)\n        t.rm('bin')\n        t.run_build_system(status=status)\n        if status:\n            t.expect_output_lines('*.bbX-to-ccc: source targets have different names: cannot determine target name')\n        else:\n\n            def suffix(rename):\n                if rename:\n                    return '_x'\n                return ''\n            name = 'bin/_xxx'\n            e = t.expect_addition\n            e('%s%s._b1' % (name, suffix(rename1)))\n            e('%s%s._b2' % (name, suffix(rename2)))\n            e('%s%s._b3' % (name, suffix(rename3)))\n            e('%s%s._c' % (name, suffix(rename1 and rename2 and rename3)))\n            e('%s._d' % name)\n        t.expect_nothing_more()\n    test_one(t, False, False, False, status=0)\n    test_one(t, True, False, False, status=1)\n    test_one(t, False, True, False, status=1)\n    test_one(t, False, False, True, status=1)\n    test_one(t, True, True, False, status=1)\n    test_one(t, True, False, True, status=1)\n    test_one(t, False, True, True, status=1)\n    test_one(t, True, True, True, status=0)\n    t.cleanup()",
            "def test_generated_target_names():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n      Test generator generated target names. Unless given explicitly, target\\n    names should be determined based on their specified source names. All\\n    sources for generating a target need to have matching names in order for\\n    Boost Build to be able to implicitly determine the target's name.\\n\\n      We use the following target generation structure with differently named\\n    BBX targets:\\n                       /---> BB1 ---                AAA --<----> BB2 ---->--> CCC --(composing)--> DDD\\n                       \\\\---> BB3 ---/\\n\\n      The extra generator at the end is needed because generating a top-level\\n    CCC target directly would requires us to explicitly specify a name for it.\\n    The extra generator needs to be composing in order not to explicitly\\n    request a specific name for its CCC source target based on its own target\\n    name.\\n\\n      We also check for a regression where only the first two sources were\\n    checked to see if their names match. Note that we need to try out all file\\n    renaming combinations as we do not know what ordering Boost Build is going\\n    to use when passing in those files as generator sources.\\n\\n    \"\n    jamfile_template = 'import type ;\\ntype.register AAA : _a ;\\ntype.register BB1 : _b1 ;\\ntype.register BB2 : _b2 ;\\ntype.register BB3 : _b3 ;\\ntype.register CCC : _c ;\\ntype.register DDD : _d ;\\n\\nimport appender ;\\nappender.register aaa-to-bbX           : AAA         : BB1%s BB2%s BB3%s ;\\nappender.register bbX-to-ccc           : BB1 BB2 BB3 : CCC ;\\nappender.register ccc-to-ddd composing : CCC         : DDD ;\\n\\nddd _xxx : _xxx._a ;\\n'\n    t = BoostBuild.Tester()\n    __write_appender(t, 'appender.jam')\n    t.write('_xxx._a', '')\n\n    def test_one(t, rename1, rename2, rename3, status):\n\n        def f(rename):\n            if rename:\n                return '(%_x)'\n            return ''\n        jamfile = jamfile_template % (f(rename1), f(rename2), f(rename3))\n        t.write('jamroot.jam', jamfile, wait=False)\n        t.rm('bin')\n        t.run_build_system(status=status)\n        if status:\n            t.expect_output_lines('*.bbX-to-ccc: source targets have different names: cannot determine target name')\n        else:\n\n            def suffix(rename):\n                if rename:\n                    return '_x'\n                return ''\n            name = 'bin/_xxx'\n            e = t.expect_addition\n            e('%s%s._b1' % (name, suffix(rename1)))\n            e('%s%s._b2' % (name, suffix(rename2)))\n            e('%s%s._b3' % (name, suffix(rename3)))\n            e('%s%s._c' % (name, suffix(rename1 and rename2 and rename3)))\n            e('%s._d' % name)\n        t.expect_nothing_more()\n    test_one(t, False, False, False, status=0)\n    test_one(t, True, False, False, status=1)\n    test_one(t, False, True, False, status=1)\n    test_one(t, False, False, True, status=1)\n    test_one(t, True, True, False, status=1)\n    test_one(t, True, False, True, status=1)\n    test_one(t, False, True, True, status=1)\n    test_one(t, True, True, True, status=0)\n    t.cleanup()"
        ]
    },
    {
        "func_name": "__match_count_is",
        "original": "def __match_count_is(lines, pattern, expected):\n    count = 0\n    for x in lines:\n        if re.search(pattern, x):\n            count += 1\n        if count > expected:\n            return False\n    return count == expected",
        "mutated": [
            "def __match_count_is(lines, pattern, expected):\n    if False:\n        i = 10\n    count = 0\n    for x in lines:\n        if re.search(pattern, x):\n            count += 1\n        if count > expected:\n            return False\n    return count == expected",
            "def __match_count_is(lines, pattern, expected):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    count = 0\n    for x in lines:\n        if re.search(pattern, x):\n            count += 1\n        if count > expected:\n            return False\n    return count == expected",
            "def __match_count_is(lines, pattern, expected):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    count = 0\n    for x in lines:\n        if re.search(pattern, x):\n            count += 1\n        if count > expected:\n            return False\n    return count == expected",
            "def __match_count_is(lines, pattern, expected):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    count = 0\n    for x in lines:\n        if re.search(pattern, x):\n            count += 1\n        if count > expected:\n            return False\n    return count == expected",
            "def __match_count_is(lines, pattern, expected):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    count = 0\n    for x in lines:\n        if re.search(pattern, x):\n            count += 1\n        if count > expected:\n            return False\n    return count == expected"
        ]
    },
    {
        "func_name": "__write_appender",
        "original": "def __write_appender(t, name):\n    t.write(name, '# Copyright 2012 Jurko Gospodnetic\\n# Distributed under the Boost Software License, Version 1.0.\\n# (See accompanying file LICENSE_1_0.txt or copy at\\n# http://www.boost.org/LICENSE_1_0.txt)\\n\\n#   Support for registering test generators that construct their targets by\\n# simply appending their given input data, e.g. list of sources & targets.\\n\\nimport \"class\" : new ;\\nimport generators ;\\nimport modules ;\\nimport sequence ;\\n\\nrule register ( id composing ? : source-types + : target-types + )\\n{\\n    local caller-module = [ CALLER_MODULE ] ;\\n    id = $(caller-module).$(id) ;\\n    local g = [ new generator $(id) $(composing) : $(source-types) :\\n        $(target-types) ] ;\\n    $(g).set-rule-name $(__name__).appender ;\\n    generators.register $(g) ;\\n    return $(id) ;\\n}\\n\\nif [ modules.peek : NT ]\\n{\\n    X = \")\" ;\\n    ECHO_CMD = (echo. ;\\n}\\nelse\\n{\\n    X = \\\\\" ;\\n    ECHO_CMD = \"echo $(X)\" ;\\n}\\n\\nlocal appender-runs ;\\n\\n# We set up separate actions for building each target in order to avoid having\\n# to iterate over them in action (i.e. shell) code. We have to be extra careful\\n# though to achieve the exact same effect as if doing all the work in just one\\n# action. Otherwise Boost Jam might, under some circumstances, run only some of\\n# our actions. To achieve this we register a series of actions for all the\\n# targets (since they all have the same target list - either all or none of them\\n# get run independent of which target actually needs to get built), each\\n# building only a single target. Since all our actions use the same targets, we\\n# can not use \\'on-target\\' parameters to pass data to a specific action so we\\n# pass them using the second \\'sources\\' parameter which our actions then know how\\n# to interpret correctly. This works well since Boost Jam does not automatically\\n# add dependency relations between specified action targets & sources and so the\\n# second argument, even though most often used to pass in a list of sources, can\\n# actually be used for passing in any type of information.\\nrule appender ( targets + : sources + : properties * )\\n{\\n    appender-runs = [ CALC $(appender-runs:E=0) + 1 ] ;\\n    local target-index = 0 ;\\n    local target-count = [ sequence.length $(targets) ] ;\\n    local original-targets ;\\n    for t in $(targets)\\n    {\\n        target-index = [ CALC $(target-index) + 1 ] ;\\n        local appender-run = $(appender-runs) ;\\n        if $(targets[2])-defined\\n        {\\n            appender-run += \"[$(target-index)/$(target-count)]\" ;\\n        }\\n        append $(targets) : $(appender-run:J=\" \") $(t) $(sources) ;\\n    }\\n}\\n\\nactions append\\n{\\n    $(ECHO_CMD)-------------------------------------------------$(X)\\n    $(ECHO_CMD)Appender run: $(>[1])$(X)\\n    $(ECHO_CMD)Appender run: $(>[1])$(X)>> \"$(>[2])\"\\n    $(ECHO_CMD)Target group: $(<:J=\\' \\')$(X)\\n    $(ECHO_CMD)Target group: $(<:J=\\' \\')$(X)>> \"$(>[2])\"\\n    $(ECHO_CMD)      Target: \\'$(>[2])\\'$(X)\\n    $(ECHO_CMD)      Target: \\'$(>[2])\\'$(X)>> \"$(>[2])\"\\n    $(ECHO_CMD)     Sources: \\'$(>[3-]:J=\\' \\')\\'$(X)\\n    $(ECHO_CMD)     Sources: \\'$(>[3-]:J=\\' \\')\\'$(X)>> \"$(>[2])\"\\n    $(ECHO_CMD)=================================================$(X)\\n    $(ECHO_CMD)-------------------------------------------------$(X)>> \"$(>[2])\"\\n}\\n')",
        "mutated": [
            "def __write_appender(t, name):\n    if False:\n        i = 10\n    t.write(name, '# Copyright 2012 Jurko Gospodnetic\\n# Distributed under the Boost Software License, Version 1.0.\\n# (See accompanying file LICENSE_1_0.txt or copy at\\n# http://www.boost.org/LICENSE_1_0.txt)\\n\\n#   Support for registering test generators that construct their targets by\\n# simply appending their given input data, e.g. list of sources & targets.\\n\\nimport \"class\" : new ;\\nimport generators ;\\nimport modules ;\\nimport sequence ;\\n\\nrule register ( id composing ? : source-types + : target-types + )\\n{\\n    local caller-module = [ CALLER_MODULE ] ;\\n    id = $(caller-module).$(id) ;\\n    local g = [ new generator $(id) $(composing) : $(source-types) :\\n        $(target-types) ] ;\\n    $(g).set-rule-name $(__name__).appender ;\\n    generators.register $(g) ;\\n    return $(id) ;\\n}\\n\\nif [ modules.peek : NT ]\\n{\\n    X = \")\" ;\\n    ECHO_CMD = (echo. ;\\n}\\nelse\\n{\\n    X = \\\\\" ;\\n    ECHO_CMD = \"echo $(X)\" ;\\n}\\n\\nlocal appender-runs ;\\n\\n# We set up separate actions for building each target in order to avoid having\\n# to iterate over them in action (i.e. shell) code. We have to be extra careful\\n# though to achieve the exact same effect as if doing all the work in just one\\n# action. Otherwise Boost Jam might, under some circumstances, run only some of\\n# our actions. To achieve this we register a series of actions for all the\\n# targets (since they all have the same target list - either all or none of them\\n# get run independent of which target actually needs to get built), each\\n# building only a single target. Since all our actions use the same targets, we\\n# can not use \\'on-target\\' parameters to pass data to a specific action so we\\n# pass them using the second \\'sources\\' parameter which our actions then know how\\n# to interpret correctly. This works well since Boost Jam does not automatically\\n# add dependency relations between specified action targets & sources and so the\\n# second argument, even though most often used to pass in a list of sources, can\\n# actually be used for passing in any type of information.\\nrule appender ( targets + : sources + : properties * )\\n{\\n    appender-runs = [ CALC $(appender-runs:E=0) + 1 ] ;\\n    local target-index = 0 ;\\n    local target-count = [ sequence.length $(targets) ] ;\\n    local original-targets ;\\n    for t in $(targets)\\n    {\\n        target-index = [ CALC $(target-index) + 1 ] ;\\n        local appender-run = $(appender-runs) ;\\n        if $(targets[2])-defined\\n        {\\n            appender-run += \"[$(target-index)/$(target-count)]\" ;\\n        }\\n        append $(targets) : $(appender-run:J=\" \") $(t) $(sources) ;\\n    }\\n}\\n\\nactions append\\n{\\n    $(ECHO_CMD)-------------------------------------------------$(X)\\n    $(ECHO_CMD)Appender run: $(>[1])$(X)\\n    $(ECHO_CMD)Appender run: $(>[1])$(X)>> \"$(>[2])\"\\n    $(ECHO_CMD)Target group: $(<:J=\\' \\')$(X)\\n    $(ECHO_CMD)Target group: $(<:J=\\' \\')$(X)>> \"$(>[2])\"\\n    $(ECHO_CMD)      Target: \\'$(>[2])\\'$(X)\\n    $(ECHO_CMD)      Target: \\'$(>[2])\\'$(X)>> \"$(>[2])\"\\n    $(ECHO_CMD)     Sources: \\'$(>[3-]:J=\\' \\')\\'$(X)\\n    $(ECHO_CMD)     Sources: \\'$(>[3-]:J=\\' \\')\\'$(X)>> \"$(>[2])\"\\n    $(ECHO_CMD)=================================================$(X)\\n    $(ECHO_CMD)-------------------------------------------------$(X)>> \"$(>[2])\"\\n}\\n')",
            "def __write_appender(t, name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    t.write(name, '# Copyright 2012 Jurko Gospodnetic\\n# Distributed under the Boost Software License, Version 1.0.\\n# (See accompanying file LICENSE_1_0.txt or copy at\\n# http://www.boost.org/LICENSE_1_0.txt)\\n\\n#   Support for registering test generators that construct their targets by\\n# simply appending their given input data, e.g. list of sources & targets.\\n\\nimport \"class\" : new ;\\nimport generators ;\\nimport modules ;\\nimport sequence ;\\n\\nrule register ( id composing ? : source-types + : target-types + )\\n{\\n    local caller-module = [ CALLER_MODULE ] ;\\n    id = $(caller-module).$(id) ;\\n    local g = [ new generator $(id) $(composing) : $(source-types) :\\n        $(target-types) ] ;\\n    $(g).set-rule-name $(__name__).appender ;\\n    generators.register $(g) ;\\n    return $(id) ;\\n}\\n\\nif [ modules.peek : NT ]\\n{\\n    X = \")\" ;\\n    ECHO_CMD = (echo. ;\\n}\\nelse\\n{\\n    X = \\\\\" ;\\n    ECHO_CMD = \"echo $(X)\" ;\\n}\\n\\nlocal appender-runs ;\\n\\n# We set up separate actions for building each target in order to avoid having\\n# to iterate over them in action (i.e. shell) code. We have to be extra careful\\n# though to achieve the exact same effect as if doing all the work in just one\\n# action. Otherwise Boost Jam might, under some circumstances, run only some of\\n# our actions. To achieve this we register a series of actions for all the\\n# targets (since they all have the same target list - either all or none of them\\n# get run independent of which target actually needs to get built), each\\n# building only a single target. Since all our actions use the same targets, we\\n# can not use \\'on-target\\' parameters to pass data to a specific action so we\\n# pass them using the second \\'sources\\' parameter which our actions then know how\\n# to interpret correctly. This works well since Boost Jam does not automatically\\n# add dependency relations between specified action targets & sources and so the\\n# second argument, even though most often used to pass in a list of sources, can\\n# actually be used for passing in any type of information.\\nrule appender ( targets + : sources + : properties * )\\n{\\n    appender-runs = [ CALC $(appender-runs:E=0) + 1 ] ;\\n    local target-index = 0 ;\\n    local target-count = [ sequence.length $(targets) ] ;\\n    local original-targets ;\\n    for t in $(targets)\\n    {\\n        target-index = [ CALC $(target-index) + 1 ] ;\\n        local appender-run = $(appender-runs) ;\\n        if $(targets[2])-defined\\n        {\\n            appender-run += \"[$(target-index)/$(target-count)]\" ;\\n        }\\n        append $(targets) : $(appender-run:J=\" \") $(t) $(sources) ;\\n    }\\n}\\n\\nactions append\\n{\\n    $(ECHO_CMD)-------------------------------------------------$(X)\\n    $(ECHO_CMD)Appender run: $(>[1])$(X)\\n    $(ECHO_CMD)Appender run: $(>[1])$(X)>> \"$(>[2])\"\\n    $(ECHO_CMD)Target group: $(<:J=\\' \\')$(X)\\n    $(ECHO_CMD)Target group: $(<:J=\\' \\')$(X)>> \"$(>[2])\"\\n    $(ECHO_CMD)      Target: \\'$(>[2])\\'$(X)\\n    $(ECHO_CMD)      Target: \\'$(>[2])\\'$(X)>> \"$(>[2])\"\\n    $(ECHO_CMD)     Sources: \\'$(>[3-]:J=\\' \\')\\'$(X)\\n    $(ECHO_CMD)     Sources: \\'$(>[3-]:J=\\' \\')\\'$(X)>> \"$(>[2])\"\\n    $(ECHO_CMD)=================================================$(X)\\n    $(ECHO_CMD)-------------------------------------------------$(X)>> \"$(>[2])\"\\n}\\n')",
            "def __write_appender(t, name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    t.write(name, '# Copyright 2012 Jurko Gospodnetic\\n# Distributed under the Boost Software License, Version 1.0.\\n# (See accompanying file LICENSE_1_0.txt or copy at\\n# http://www.boost.org/LICENSE_1_0.txt)\\n\\n#   Support for registering test generators that construct their targets by\\n# simply appending their given input data, e.g. list of sources & targets.\\n\\nimport \"class\" : new ;\\nimport generators ;\\nimport modules ;\\nimport sequence ;\\n\\nrule register ( id composing ? : source-types + : target-types + )\\n{\\n    local caller-module = [ CALLER_MODULE ] ;\\n    id = $(caller-module).$(id) ;\\n    local g = [ new generator $(id) $(composing) : $(source-types) :\\n        $(target-types) ] ;\\n    $(g).set-rule-name $(__name__).appender ;\\n    generators.register $(g) ;\\n    return $(id) ;\\n}\\n\\nif [ modules.peek : NT ]\\n{\\n    X = \")\" ;\\n    ECHO_CMD = (echo. ;\\n}\\nelse\\n{\\n    X = \\\\\" ;\\n    ECHO_CMD = \"echo $(X)\" ;\\n}\\n\\nlocal appender-runs ;\\n\\n# We set up separate actions for building each target in order to avoid having\\n# to iterate over them in action (i.e. shell) code. We have to be extra careful\\n# though to achieve the exact same effect as if doing all the work in just one\\n# action. Otherwise Boost Jam might, under some circumstances, run only some of\\n# our actions. To achieve this we register a series of actions for all the\\n# targets (since they all have the same target list - either all or none of them\\n# get run independent of which target actually needs to get built), each\\n# building only a single target. Since all our actions use the same targets, we\\n# can not use \\'on-target\\' parameters to pass data to a specific action so we\\n# pass them using the second \\'sources\\' parameter which our actions then know how\\n# to interpret correctly. This works well since Boost Jam does not automatically\\n# add dependency relations between specified action targets & sources and so the\\n# second argument, even though most often used to pass in a list of sources, can\\n# actually be used for passing in any type of information.\\nrule appender ( targets + : sources + : properties * )\\n{\\n    appender-runs = [ CALC $(appender-runs:E=0) + 1 ] ;\\n    local target-index = 0 ;\\n    local target-count = [ sequence.length $(targets) ] ;\\n    local original-targets ;\\n    for t in $(targets)\\n    {\\n        target-index = [ CALC $(target-index) + 1 ] ;\\n        local appender-run = $(appender-runs) ;\\n        if $(targets[2])-defined\\n        {\\n            appender-run += \"[$(target-index)/$(target-count)]\" ;\\n        }\\n        append $(targets) : $(appender-run:J=\" \") $(t) $(sources) ;\\n    }\\n}\\n\\nactions append\\n{\\n    $(ECHO_CMD)-------------------------------------------------$(X)\\n    $(ECHO_CMD)Appender run: $(>[1])$(X)\\n    $(ECHO_CMD)Appender run: $(>[1])$(X)>> \"$(>[2])\"\\n    $(ECHO_CMD)Target group: $(<:J=\\' \\')$(X)\\n    $(ECHO_CMD)Target group: $(<:J=\\' \\')$(X)>> \"$(>[2])\"\\n    $(ECHO_CMD)      Target: \\'$(>[2])\\'$(X)\\n    $(ECHO_CMD)      Target: \\'$(>[2])\\'$(X)>> \"$(>[2])\"\\n    $(ECHO_CMD)     Sources: \\'$(>[3-]:J=\\' \\')\\'$(X)\\n    $(ECHO_CMD)     Sources: \\'$(>[3-]:J=\\' \\')\\'$(X)>> \"$(>[2])\"\\n    $(ECHO_CMD)=================================================$(X)\\n    $(ECHO_CMD)-------------------------------------------------$(X)>> \"$(>[2])\"\\n}\\n')",
            "def __write_appender(t, name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    t.write(name, '# Copyright 2012 Jurko Gospodnetic\\n# Distributed under the Boost Software License, Version 1.0.\\n# (See accompanying file LICENSE_1_0.txt or copy at\\n# http://www.boost.org/LICENSE_1_0.txt)\\n\\n#   Support for registering test generators that construct their targets by\\n# simply appending their given input data, e.g. list of sources & targets.\\n\\nimport \"class\" : new ;\\nimport generators ;\\nimport modules ;\\nimport sequence ;\\n\\nrule register ( id composing ? : source-types + : target-types + )\\n{\\n    local caller-module = [ CALLER_MODULE ] ;\\n    id = $(caller-module).$(id) ;\\n    local g = [ new generator $(id) $(composing) : $(source-types) :\\n        $(target-types) ] ;\\n    $(g).set-rule-name $(__name__).appender ;\\n    generators.register $(g) ;\\n    return $(id) ;\\n}\\n\\nif [ modules.peek : NT ]\\n{\\n    X = \")\" ;\\n    ECHO_CMD = (echo. ;\\n}\\nelse\\n{\\n    X = \\\\\" ;\\n    ECHO_CMD = \"echo $(X)\" ;\\n}\\n\\nlocal appender-runs ;\\n\\n# We set up separate actions for building each target in order to avoid having\\n# to iterate over them in action (i.e. shell) code. We have to be extra careful\\n# though to achieve the exact same effect as if doing all the work in just one\\n# action. Otherwise Boost Jam might, under some circumstances, run only some of\\n# our actions. To achieve this we register a series of actions for all the\\n# targets (since they all have the same target list - either all or none of them\\n# get run independent of which target actually needs to get built), each\\n# building only a single target. Since all our actions use the same targets, we\\n# can not use \\'on-target\\' parameters to pass data to a specific action so we\\n# pass them using the second \\'sources\\' parameter which our actions then know how\\n# to interpret correctly. This works well since Boost Jam does not automatically\\n# add dependency relations between specified action targets & sources and so the\\n# second argument, even though most often used to pass in a list of sources, can\\n# actually be used for passing in any type of information.\\nrule appender ( targets + : sources + : properties * )\\n{\\n    appender-runs = [ CALC $(appender-runs:E=0) + 1 ] ;\\n    local target-index = 0 ;\\n    local target-count = [ sequence.length $(targets) ] ;\\n    local original-targets ;\\n    for t in $(targets)\\n    {\\n        target-index = [ CALC $(target-index) + 1 ] ;\\n        local appender-run = $(appender-runs) ;\\n        if $(targets[2])-defined\\n        {\\n            appender-run += \"[$(target-index)/$(target-count)]\" ;\\n        }\\n        append $(targets) : $(appender-run:J=\" \") $(t) $(sources) ;\\n    }\\n}\\n\\nactions append\\n{\\n    $(ECHO_CMD)-------------------------------------------------$(X)\\n    $(ECHO_CMD)Appender run: $(>[1])$(X)\\n    $(ECHO_CMD)Appender run: $(>[1])$(X)>> \"$(>[2])\"\\n    $(ECHO_CMD)Target group: $(<:J=\\' \\')$(X)\\n    $(ECHO_CMD)Target group: $(<:J=\\' \\')$(X)>> \"$(>[2])\"\\n    $(ECHO_CMD)      Target: \\'$(>[2])\\'$(X)\\n    $(ECHO_CMD)      Target: \\'$(>[2])\\'$(X)>> \"$(>[2])\"\\n    $(ECHO_CMD)     Sources: \\'$(>[3-]:J=\\' \\')\\'$(X)\\n    $(ECHO_CMD)     Sources: \\'$(>[3-]:J=\\' \\')\\'$(X)>> \"$(>[2])\"\\n    $(ECHO_CMD)=================================================$(X)\\n    $(ECHO_CMD)-------------------------------------------------$(X)>> \"$(>[2])\"\\n}\\n')",
            "def __write_appender(t, name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    t.write(name, '# Copyright 2012 Jurko Gospodnetic\\n# Distributed under the Boost Software License, Version 1.0.\\n# (See accompanying file LICENSE_1_0.txt or copy at\\n# http://www.boost.org/LICENSE_1_0.txt)\\n\\n#   Support for registering test generators that construct their targets by\\n# simply appending their given input data, e.g. list of sources & targets.\\n\\nimport \"class\" : new ;\\nimport generators ;\\nimport modules ;\\nimport sequence ;\\n\\nrule register ( id composing ? : source-types + : target-types + )\\n{\\n    local caller-module = [ CALLER_MODULE ] ;\\n    id = $(caller-module).$(id) ;\\n    local g = [ new generator $(id) $(composing) : $(source-types) :\\n        $(target-types) ] ;\\n    $(g).set-rule-name $(__name__).appender ;\\n    generators.register $(g) ;\\n    return $(id) ;\\n}\\n\\nif [ modules.peek : NT ]\\n{\\n    X = \")\" ;\\n    ECHO_CMD = (echo. ;\\n}\\nelse\\n{\\n    X = \\\\\" ;\\n    ECHO_CMD = \"echo $(X)\" ;\\n}\\n\\nlocal appender-runs ;\\n\\n# We set up separate actions for building each target in order to avoid having\\n# to iterate over them in action (i.e. shell) code. We have to be extra careful\\n# though to achieve the exact same effect as if doing all the work in just one\\n# action. Otherwise Boost Jam might, under some circumstances, run only some of\\n# our actions. To achieve this we register a series of actions for all the\\n# targets (since they all have the same target list - either all or none of them\\n# get run independent of which target actually needs to get built), each\\n# building only a single target. Since all our actions use the same targets, we\\n# can not use \\'on-target\\' parameters to pass data to a specific action so we\\n# pass them using the second \\'sources\\' parameter which our actions then know how\\n# to interpret correctly. This works well since Boost Jam does not automatically\\n# add dependency relations between specified action targets & sources and so the\\n# second argument, even though most often used to pass in a list of sources, can\\n# actually be used for passing in any type of information.\\nrule appender ( targets + : sources + : properties * )\\n{\\n    appender-runs = [ CALC $(appender-runs:E=0) + 1 ] ;\\n    local target-index = 0 ;\\n    local target-count = [ sequence.length $(targets) ] ;\\n    local original-targets ;\\n    for t in $(targets)\\n    {\\n        target-index = [ CALC $(target-index) + 1 ] ;\\n        local appender-run = $(appender-runs) ;\\n        if $(targets[2])-defined\\n        {\\n            appender-run += \"[$(target-index)/$(target-count)]\" ;\\n        }\\n        append $(targets) : $(appender-run:J=\" \") $(t) $(sources) ;\\n    }\\n}\\n\\nactions append\\n{\\n    $(ECHO_CMD)-------------------------------------------------$(X)\\n    $(ECHO_CMD)Appender run: $(>[1])$(X)\\n    $(ECHO_CMD)Appender run: $(>[1])$(X)>> \"$(>[2])\"\\n    $(ECHO_CMD)Target group: $(<:J=\\' \\')$(X)\\n    $(ECHO_CMD)Target group: $(<:J=\\' \\')$(X)>> \"$(>[2])\"\\n    $(ECHO_CMD)      Target: \\'$(>[2])\\'$(X)\\n    $(ECHO_CMD)      Target: \\'$(>[2])\\'$(X)>> \"$(>[2])\"\\n    $(ECHO_CMD)     Sources: \\'$(>[3-]:J=\\' \\')\\'$(X)\\n    $(ECHO_CMD)     Sources: \\'$(>[3-]:J=\\' \\')\\'$(X)>> \"$(>[2])\"\\n    $(ECHO_CMD)=================================================$(X)\\n    $(ECHO_CMD)-------------------------------------------------$(X)>> \"$(>[2])\"\\n}\\n')"
        ]
    }
]