[
    {
        "func_name": "who",
        "original": "def who(vardict=None):\n    \"\"\"Print the CuPy arrays in the given dictionary.\n\n    Prints out the name, shape, bytes and type of all of the ndarrays\n    present in `vardict`.\n\n    If there is no dictionary passed in or `vardict` is None then returns\n    CuPy arrays in the globals() dictionary (all CuPy arrays in the\n    namespace).\n\n    Args:\n        vardict : (None or dict)  A dictionary possibly containing ndarrays.\n                  Default is globals() if `None` specified\n\n\n    .. admonition:: Example\n\n        >>> a = cupy.arange(10)\n        >>> b = cupy.ones(20)\n        >>> cupy.who()\n        Name            Shape            Bytes            Type\n        ===========================================================\n        <BLANKLINE>\n        a               10               80               int64\n        b               20               160              float64\n        <BLANKLINE>\n        Upper bound on total bytes  =       240\n        >>> d = {'x': cupy.arange(2.0),\n        ... 'y': cupy.arange(3.0), 'txt': 'Some str',\n        ... 'idx':5}\n        >>> cupy.who(d)\n        Name            Shape            Bytes            Type\n        ===========================================================\n        <BLANKLINE>\n        x               2                16               float64\n        y               3                24               float64\n        <BLANKLINE>\n        Upper bound on total bytes  =       40\n\n    \"\"\"\n    if vardict is None:\n        frame = sys._getframe().f_back\n        vardict = frame.f_globals\n    sta = []\n    cache = {}\n    for name in sorted(vardict.keys()):\n        if isinstance(vardict[name], cupy.ndarray):\n            var = vardict[name]\n            idv = id(var)\n            if idv in cache.keys():\n                namestr = '{} ({})'.format(name, cache[idv])\n                original = 0\n            else:\n                cache[idv] = name\n                namestr = name\n                original = 1\n            shapestr = ' x '.join(map(str, var.shape))\n            bytestr = str(var.nbytes)\n            sta.append([namestr, shapestr, bytestr, var.dtype.name, original])\n    maxname = 0\n    maxshape = 0\n    maxbyte = 0\n    totalbytes = 0\n    for k in range(len(sta)):\n        val = sta[k]\n        if maxname < len(val[0]):\n            maxname = len(val[0])\n        if maxshape < len(val[1]):\n            maxshape = len(val[1])\n        if maxbyte < len(val[2]):\n            maxbyte = len(val[2])\n        if val[4]:\n            totalbytes += int(val[2])\n    if len(sta) > 0:\n        sp1 = max(10, maxname)\n        sp2 = max(10, maxshape)\n        sp3 = max(10, maxbyte)\n        prval = 'Name {} Shape {} Bytes {} Type'.format(sp1 * ' ', sp2 * ' ', sp3 * ' ')\n        print('{}\\n{}\\n'.format(prval, '=' * (len(prval) + 5)))\n    for k in range(len(sta)):\n        val = sta[k]\n        print('{} {} {} {} {} {} {}'.format(val[0], ' ' * (sp1 - len(val[0]) + 4), val[1], ' ' * (sp2 - len(val[1]) + 5), val[2], ' ' * (sp3 - len(val[2]) + 5), val[3]))\n    print('\\nUpper bound on total bytes  =       {}'.format(totalbytes))",
        "mutated": [
            "def who(vardict=None):\n    if False:\n        i = 10\n    \"Print the CuPy arrays in the given dictionary.\\n\\n    Prints out the name, shape, bytes and type of all of the ndarrays\\n    present in `vardict`.\\n\\n    If there is no dictionary passed in or `vardict` is None then returns\\n    CuPy arrays in the globals() dictionary (all CuPy arrays in the\\n    namespace).\\n\\n    Args:\\n        vardict : (None or dict)  A dictionary possibly containing ndarrays.\\n                  Default is globals() if `None` specified\\n\\n\\n    .. admonition:: Example\\n\\n        >>> a = cupy.arange(10)\\n        >>> b = cupy.ones(20)\\n        >>> cupy.who()\\n        Name            Shape            Bytes            Type\\n        ===========================================================\\n        <BLANKLINE>\\n        a               10               80               int64\\n        b               20               160              float64\\n        <BLANKLINE>\\n        Upper bound on total bytes  =       240\\n        >>> d = {'x': cupy.arange(2.0),\\n        ... 'y': cupy.arange(3.0), 'txt': 'Some str',\\n        ... 'idx':5}\\n        >>> cupy.who(d)\\n        Name            Shape            Bytes            Type\\n        ===========================================================\\n        <BLANKLINE>\\n        x               2                16               float64\\n        y               3                24               float64\\n        <BLANKLINE>\\n        Upper bound on total bytes  =       40\\n\\n    \"\n    if vardict is None:\n        frame = sys._getframe().f_back\n        vardict = frame.f_globals\n    sta = []\n    cache = {}\n    for name in sorted(vardict.keys()):\n        if isinstance(vardict[name], cupy.ndarray):\n            var = vardict[name]\n            idv = id(var)\n            if idv in cache.keys():\n                namestr = '{} ({})'.format(name, cache[idv])\n                original = 0\n            else:\n                cache[idv] = name\n                namestr = name\n                original = 1\n            shapestr = ' x '.join(map(str, var.shape))\n            bytestr = str(var.nbytes)\n            sta.append([namestr, shapestr, bytestr, var.dtype.name, original])\n    maxname = 0\n    maxshape = 0\n    maxbyte = 0\n    totalbytes = 0\n    for k in range(len(sta)):\n        val = sta[k]\n        if maxname < len(val[0]):\n            maxname = len(val[0])\n        if maxshape < len(val[1]):\n            maxshape = len(val[1])\n        if maxbyte < len(val[2]):\n            maxbyte = len(val[2])\n        if val[4]:\n            totalbytes += int(val[2])\n    if len(sta) > 0:\n        sp1 = max(10, maxname)\n        sp2 = max(10, maxshape)\n        sp3 = max(10, maxbyte)\n        prval = 'Name {} Shape {} Bytes {} Type'.format(sp1 * ' ', sp2 * ' ', sp3 * ' ')\n        print('{}\\n{}\\n'.format(prval, '=' * (len(prval) + 5)))\n    for k in range(len(sta)):\n        val = sta[k]\n        print('{} {} {} {} {} {} {}'.format(val[0], ' ' * (sp1 - len(val[0]) + 4), val[1], ' ' * (sp2 - len(val[1]) + 5), val[2], ' ' * (sp3 - len(val[2]) + 5), val[3]))\n    print('\\nUpper bound on total bytes  =       {}'.format(totalbytes))",
            "def who(vardict=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Print the CuPy arrays in the given dictionary.\\n\\n    Prints out the name, shape, bytes and type of all of the ndarrays\\n    present in `vardict`.\\n\\n    If there is no dictionary passed in or `vardict` is None then returns\\n    CuPy arrays in the globals() dictionary (all CuPy arrays in the\\n    namespace).\\n\\n    Args:\\n        vardict : (None or dict)  A dictionary possibly containing ndarrays.\\n                  Default is globals() if `None` specified\\n\\n\\n    .. admonition:: Example\\n\\n        >>> a = cupy.arange(10)\\n        >>> b = cupy.ones(20)\\n        >>> cupy.who()\\n        Name            Shape            Bytes            Type\\n        ===========================================================\\n        <BLANKLINE>\\n        a               10               80               int64\\n        b               20               160              float64\\n        <BLANKLINE>\\n        Upper bound on total bytes  =       240\\n        >>> d = {'x': cupy.arange(2.0),\\n        ... 'y': cupy.arange(3.0), 'txt': 'Some str',\\n        ... 'idx':5}\\n        >>> cupy.who(d)\\n        Name            Shape            Bytes            Type\\n        ===========================================================\\n        <BLANKLINE>\\n        x               2                16               float64\\n        y               3                24               float64\\n        <BLANKLINE>\\n        Upper bound on total bytes  =       40\\n\\n    \"\n    if vardict is None:\n        frame = sys._getframe().f_back\n        vardict = frame.f_globals\n    sta = []\n    cache = {}\n    for name in sorted(vardict.keys()):\n        if isinstance(vardict[name], cupy.ndarray):\n            var = vardict[name]\n            idv = id(var)\n            if idv in cache.keys():\n                namestr = '{} ({})'.format(name, cache[idv])\n                original = 0\n            else:\n                cache[idv] = name\n                namestr = name\n                original = 1\n            shapestr = ' x '.join(map(str, var.shape))\n            bytestr = str(var.nbytes)\n            sta.append([namestr, shapestr, bytestr, var.dtype.name, original])\n    maxname = 0\n    maxshape = 0\n    maxbyte = 0\n    totalbytes = 0\n    for k in range(len(sta)):\n        val = sta[k]\n        if maxname < len(val[0]):\n            maxname = len(val[0])\n        if maxshape < len(val[1]):\n            maxshape = len(val[1])\n        if maxbyte < len(val[2]):\n            maxbyte = len(val[2])\n        if val[4]:\n            totalbytes += int(val[2])\n    if len(sta) > 0:\n        sp1 = max(10, maxname)\n        sp2 = max(10, maxshape)\n        sp3 = max(10, maxbyte)\n        prval = 'Name {} Shape {} Bytes {} Type'.format(sp1 * ' ', sp2 * ' ', sp3 * ' ')\n        print('{}\\n{}\\n'.format(prval, '=' * (len(prval) + 5)))\n    for k in range(len(sta)):\n        val = sta[k]\n        print('{} {} {} {} {} {} {}'.format(val[0], ' ' * (sp1 - len(val[0]) + 4), val[1], ' ' * (sp2 - len(val[1]) + 5), val[2], ' ' * (sp3 - len(val[2]) + 5), val[3]))\n    print('\\nUpper bound on total bytes  =       {}'.format(totalbytes))",
            "def who(vardict=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Print the CuPy arrays in the given dictionary.\\n\\n    Prints out the name, shape, bytes and type of all of the ndarrays\\n    present in `vardict`.\\n\\n    If there is no dictionary passed in or `vardict` is None then returns\\n    CuPy arrays in the globals() dictionary (all CuPy arrays in the\\n    namespace).\\n\\n    Args:\\n        vardict : (None or dict)  A dictionary possibly containing ndarrays.\\n                  Default is globals() if `None` specified\\n\\n\\n    .. admonition:: Example\\n\\n        >>> a = cupy.arange(10)\\n        >>> b = cupy.ones(20)\\n        >>> cupy.who()\\n        Name            Shape            Bytes            Type\\n        ===========================================================\\n        <BLANKLINE>\\n        a               10               80               int64\\n        b               20               160              float64\\n        <BLANKLINE>\\n        Upper bound on total bytes  =       240\\n        >>> d = {'x': cupy.arange(2.0),\\n        ... 'y': cupy.arange(3.0), 'txt': 'Some str',\\n        ... 'idx':5}\\n        >>> cupy.who(d)\\n        Name            Shape            Bytes            Type\\n        ===========================================================\\n        <BLANKLINE>\\n        x               2                16               float64\\n        y               3                24               float64\\n        <BLANKLINE>\\n        Upper bound on total bytes  =       40\\n\\n    \"\n    if vardict is None:\n        frame = sys._getframe().f_back\n        vardict = frame.f_globals\n    sta = []\n    cache = {}\n    for name in sorted(vardict.keys()):\n        if isinstance(vardict[name], cupy.ndarray):\n            var = vardict[name]\n            idv = id(var)\n            if idv in cache.keys():\n                namestr = '{} ({})'.format(name, cache[idv])\n                original = 0\n            else:\n                cache[idv] = name\n                namestr = name\n                original = 1\n            shapestr = ' x '.join(map(str, var.shape))\n            bytestr = str(var.nbytes)\n            sta.append([namestr, shapestr, bytestr, var.dtype.name, original])\n    maxname = 0\n    maxshape = 0\n    maxbyte = 0\n    totalbytes = 0\n    for k in range(len(sta)):\n        val = sta[k]\n        if maxname < len(val[0]):\n            maxname = len(val[0])\n        if maxshape < len(val[1]):\n            maxshape = len(val[1])\n        if maxbyte < len(val[2]):\n            maxbyte = len(val[2])\n        if val[4]:\n            totalbytes += int(val[2])\n    if len(sta) > 0:\n        sp1 = max(10, maxname)\n        sp2 = max(10, maxshape)\n        sp3 = max(10, maxbyte)\n        prval = 'Name {} Shape {} Bytes {} Type'.format(sp1 * ' ', sp2 * ' ', sp3 * ' ')\n        print('{}\\n{}\\n'.format(prval, '=' * (len(prval) + 5)))\n    for k in range(len(sta)):\n        val = sta[k]\n        print('{} {} {} {} {} {} {}'.format(val[0], ' ' * (sp1 - len(val[0]) + 4), val[1], ' ' * (sp2 - len(val[1]) + 5), val[2], ' ' * (sp3 - len(val[2]) + 5), val[3]))\n    print('\\nUpper bound on total bytes  =       {}'.format(totalbytes))",
            "def who(vardict=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Print the CuPy arrays in the given dictionary.\\n\\n    Prints out the name, shape, bytes and type of all of the ndarrays\\n    present in `vardict`.\\n\\n    If there is no dictionary passed in or `vardict` is None then returns\\n    CuPy arrays in the globals() dictionary (all CuPy arrays in the\\n    namespace).\\n\\n    Args:\\n        vardict : (None or dict)  A dictionary possibly containing ndarrays.\\n                  Default is globals() if `None` specified\\n\\n\\n    .. admonition:: Example\\n\\n        >>> a = cupy.arange(10)\\n        >>> b = cupy.ones(20)\\n        >>> cupy.who()\\n        Name            Shape            Bytes            Type\\n        ===========================================================\\n        <BLANKLINE>\\n        a               10               80               int64\\n        b               20               160              float64\\n        <BLANKLINE>\\n        Upper bound on total bytes  =       240\\n        >>> d = {'x': cupy.arange(2.0),\\n        ... 'y': cupy.arange(3.0), 'txt': 'Some str',\\n        ... 'idx':5}\\n        >>> cupy.who(d)\\n        Name            Shape            Bytes            Type\\n        ===========================================================\\n        <BLANKLINE>\\n        x               2                16               float64\\n        y               3                24               float64\\n        <BLANKLINE>\\n        Upper bound on total bytes  =       40\\n\\n    \"\n    if vardict is None:\n        frame = sys._getframe().f_back\n        vardict = frame.f_globals\n    sta = []\n    cache = {}\n    for name in sorted(vardict.keys()):\n        if isinstance(vardict[name], cupy.ndarray):\n            var = vardict[name]\n            idv = id(var)\n            if idv in cache.keys():\n                namestr = '{} ({})'.format(name, cache[idv])\n                original = 0\n            else:\n                cache[idv] = name\n                namestr = name\n                original = 1\n            shapestr = ' x '.join(map(str, var.shape))\n            bytestr = str(var.nbytes)\n            sta.append([namestr, shapestr, bytestr, var.dtype.name, original])\n    maxname = 0\n    maxshape = 0\n    maxbyte = 0\n    totalbytes = 0\n    for k in range(len(sta)):\n        val = sta[k]\n        if maxname < len(val[0]):\n            maxname = len(val[0])\n        if maxshape < len(val[1]):\n            maxshape = len(val[1])\n        if maxbyte < len(val[2]):\n            maxbyte = len(val[2])\n        if val[4]:\n            totalbytes += int(val[2])\n    if len(sta) > 0:\n        sp1 = max(10, maxname)\n        sp2 = max(10, maxshape)\n        sp3 = max(10, maxbyte)\n        prval = 'Name {} Shape {} Bytes {} Type'.format(sp1 * ' ', sp2 * ' ', sp3 * ' ')\n        print('{}\\n{}\\n'.format(prval, '=' * (len(prval) + 5)))\n    for k in range(len(sta)):\n        val = sta[k]\n        print('{} {} {} {} {} {} {}'.format(val[0], ' ' * (sp1 - len(val[0]) + 4), val[1], ' ' * (sp2 - len(val[1]) + 5), val[2], ' ' * (sp3 - len(val[2]) + 5), val[3]))\n    print('\\nUpper bound on total bytes  =       {}'.format(totalbytes))",
            "def who(vardict=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Print the CuPy arrays in the given dictionary.\\n\\n    Prints out the name, shape, bytes and type of all of the ndarrays\\n    present in `vardict`.\\n\\n    If there is no dictionary passed in or `vardict` is None then returns\\n    CuPy arrays in the globals() dictionary (all CuPy arrays in the\\n    namespace).\\n\\n    Args:\\n        vardict : (None or dict)  A dictionary possibly containing ndarrays.\\n                  Default is globals() if `None` specified\\n\\n\\n    .. admonition:: Example\\n\\n        >>> a = cupy.arange(10)\\n        >>> b = cupy.ones(20)\\n        >>> cupy.who()\\n        Name            Shape            Bytes            Type\\n        ===========================================================\\n        <BLANKLINE>\\n        a               10               80               int64\\n        b               20               160              float64\\n        <BLANKLINE>\\n        Upper bound on total bytes  =       240\\n        >>> d = {'x': cupy.arange(2.0),\\n        ... 'y': cupy.arange(3.0), 'txt': 'Some str',\\n        ... 'idx':5}\\n        >>> cupy.who(d)\\n        Name            Shape            Bytes            Type\\n        ===========================================================\\n        <BLANKLINE>\\n        x               2                16               float64\\n        y               3                24               float64\\n        <BLANKLINE>\\n        Upper bound on total bytes  =       40\\n\\n    \"\n    if vardict is None:\n        frame = sys._getframe().f_back\n        vardict = frame.f_globals\n    sta = []\n    cache = {}\n    for name in sorted(vardict.keys()):\n        if isinstance(vardict[name], cupy.ndarray):\n            var = vardict[name]\n            idv = id(var)\n            if idv in cache.keys():\n                namestr = '{} ({})'.format(name, cache[idv])\n                original = 0\n            else:\n                cache[idv] = name\n                namestr = name\n                original = 1\n            shapestr = ' x '.join(map(str, var.shape))\n            bytestr = str(var.nbytes)\n            sta.append([namestr, shapestr, bytestr, var.dtype.name, original])\n    maxname = 0\n    maxshape = 0\n    maxbyte = 0\n    totalbytes = 0\n    for k in range(len(sta)):\n        val = sta[k]\n        if maxname < len(val[0]):\n            maxname = len(val[0])\n        if maxshape < len(val[1]):\n            maxshape = len(val[1])\n        if maxbyte < len(val[2]):\n            maxbyte = len(val[2])\n        if val[4]:\n            totalbytes += int(val[2])\n    if len(sta) > 0:\n        sp1 = max(10, maxname)\n        sp2 = max(10, maxshape)\n        sp3 = max(10, maxbyte)\n        prval = 'Name {} Shape {} Bytes {} Type'.format(sp1 * ' ', sp2 * ' ', sp3 * ' ')\n        print('{}\\n{}\\n'.format(prval, '=' * (len(prval) + 5)))\n    for k in range(len(sta)):\n        val = sta[k]\n        print('{} {} {} {} {} {} {}'.format(val[0], ' ' * (sp1 - len(val[0]) + 4), val[1], ' ' * (sp2 - len(val[1]) + 5), val[2], ' ' * (sp3 - len(val[2]) + 5), val[3]))\n    print('\\nUpper bound on total bytes  =       {}'.format(totalbytes))"
        ]
    }
]