"""
Comparison of the predicted vs. actual values for regression problems
"""
from yellowbrick.style.palettes import LINE_COLOR
from yellowbrick.exceptions import YellowbrickValueError
from yellowbrick.bestfit import draw_best_fit, draw_identity_line
from yellowbrick.regressor.base import RegressionScoreVisualizer
__all__ = ['PredictionError', 'prediction_error']

class PredictionError(RegressionScoreVisualizer):
    """
    The prediction error visualizer plots the actual targets from the dataset
    against the predicted values generated by our model(s). This visualizer is
    used to detect noise or heteroscedasticity along a range of the target
    domain.

    Parameters
    ----------

    estimator : a Scikit-Learn regressor
        Should be an instance of a regressor, otherwise will raise a
        YellowbrickTypeError exception on instantiation.
        If the estimator is not fitted, it is fit when the visualizer is fitted,
        unless otherwise specified by ``is_fitted``.

    ax : matplotlib Axes, default: None
        The axes to plot the figure on. If None is passed in the current axes
        will be used (or generated if required).

    shared_limits : bool, default: True
        If shared_limits is True, the range of the X and Y axis limits will
        be identical, creating a square graphic with a true 45 degree line.
        In this form, it is easier to diagnose under- or over- prediction,
        though the figure will become more sparse. To localize points, set
        shared_limits to False, but note that this will distort the figure
        and should be accounted for during analysis.

    bestfit : bool, default: True
        Draw a linear best fit line to estimate the correlation between the
        predicted and measured value of the target variable. The color of
        the bestfit line is determined by the ``line_color`` argument.

    identity : bool, default: True
        Draw the 45 degree identity line, y=x in order to better show the
        relationship or pattern of the residuals. E.g. to estimate if the
        model is over- or under- estimating the given values. The color of the
        identity line is a muted version of the ``line_color`` argument.

    alpha : float, default: 0.75
        Specify a transparency where 1 is completely opaque and 0 is completely
        transparent. This property makes densely clustered points more visible.

    is_fitted : bool or str, default='auto'
        Specify if the wrapped estimator is already fitted. If False, the estimator
        will be fit when the visualizer is fit, otherwise, the estimator will not be
        modified. If 'auto' (default), a helper method will check if the estimator
        is fitted before fitting it again.

    kwargs : dict
        Keyword arguments that are passed to the base class and may influence
        the visualization as defined in other Visualizers.

    Attributes
    ----------

    score_ : float
        The R^2 score that specifies the goodness of fit of the underlying
        regression model to the test data.

    Examples
    --------

    >>> from yellowbrick.regressor import PredictionError
    >>> from sklearn.linear_model import Lasso
    >>> model = PredictionError(Lasso())
    >>> model.fit(X_train, y_train)
    >>> model.score(X_test, y_test)
    >>> model.show()

    Notes
    -----

    PredictionError is a ScoreVisualizer, meaning that it wraps a model and
    its primary entry point is the `score()` method.
    """

    def __init__(self, estimator, ax=None, shared_limits=True, bestfit=True, identity=True, alpha=0.75, is_fitted='auto', **kwargs):
        if False:
            print('Hello World!')
        super(PredictionError, self).__init__(estimator, is_fitted=is_fitted, ax=ax, **kwargs)
        self.colors = {'point': kwargs.pop('point_color', None), 'line': kwargs.pop('line_color', LINE_COLOR)}
        self.shared_limits = shared_limits
        self.bestfit = bestfit
        self.identity = identity
        self.alpha = alpha

    def score(self, X, y, **kwargs):
        if False:
            i = 10
            return i + 15
        '\n        The score function is the hook for visual interaction. Pass in test\n        data and the visualizer will create predictions on the data and\n        evaluate them with respect to the test values. The evaluation will\n        then be passed to draw() and the result of the estimator score will\n        be returned.\n\n        Parameters\n        ----------\n        X : array-like\n            X (also X_test) are the dependent variables of test set to predict\n\n        y : array-like\n            y (also y_test) is the independent actual variables to score against\n\n        Returns\n        -------\n        score : float\n        '
        super(PredictionError, self).score(X, y, **kwargs)
        y_pred = self.predict(X)
        self.draw(y, y_pred)
        return self.score_

    def draw(self, y, y_pred):
        if False:
            i = 10
            return i + 15
        '\n        Parameters\n        ----------\n        y : ndarray or Series of length n\n            An array or series of target or class values\n\n        y_pred : ndarray or Series of length n\n            An array or series of predicted target values\n\n        Returns\n        -------\n        ax : matplotlib Axes\n            The axis with the plotted figure\n        '
        try:
            score_label = self.estimator.scoring
            score_label = ' '.join(score_label.split('_')).capitalize()
        except AttributeError:
            score_label = 'R2'
        if score_label == 'R2':
            score_label = '$R^2$'
        label = '{} $ = {:0.3f}$'.format(score_label, self.score_)
        self.ax.scatter(y, y_pred, c=self.colors['point'], alpha=self.alpha, label=label)
        if self.bestfit:
            draw_best_fit(y, y_pred, self.ax, 'linear', ls='--', lw=2, c=self.colors['line'], label='best fit')
        if self.shared_limits is True:
            self.ax.set_xlim(min(min(y), min(y_pred)), max(max(y), max(y_pred)))
            self.ax.set_ylim(self.ax.get_xlim())
        return self.ax

    def finalize(self, **kwargs):
        if False:
            while True:
                i = 10
        '\n        Finalizes the figure by ensuring the aspect ratio is correct and adding\n        the identity line for comparison. Also adds a title, axis labels, and\n        the legend.\n\n        Parameters\n        ----------\n        kwargs: generic keyword arguments.\n\n        Notes\n        -----\n        Generally this method is called from show and not directly by the user.\n        '
        self.set_title('Prediction Error for {}'.format(self.name))
        if self.shared_limits:
            ylim = self.ax.get_ylim()
            xlim = self.ax.get_xlim()
            bounds = (min(ylim[0], xlim[0]), max(ylim[1], xlim[1]))
            self.ax.set_xlim(bounds)
            self.ax.set_ylim(bounds)
            self.ax.set_aspect('equal', adjustable='box')
        if self.identity:
            draw_identity_line(ax=self.ax, ls='--', lw=2, c=self.colors['line'], alpha=0.5, label='identity')
        self.ax.set_ylabel('$\\hat{y}$')
        self.ax.set_xlabel('$y$')
        self.ax.legend(loc='best', frameon=True)

def prediction_error(estimator, X_train, y_train, X_test=None, y_test=None, ax=None, shared_limits=True, bestfit=True, identity=True, alpha=0.75, is_fitted='auto', show=True, **kwargs):
    if False:
        while True:
            i = 10
    "Quickly plot a prediction error visualizer\n\n    Plot the actual targets from the dataset against the\n    predicted values generated by our model(s).\n\n    This helper function is a quick wrapper to utilize the PredictionError\n    ScoreVisualizer for one-off analysis.\n\n    Parameters\n    ----------\n    estimator : the Scikit-Learn estimator (should be a regressor)\n        Should be an instance of a regressor, otherwise will raise a\n        YellowbrickTypeError exception on instantiation.\n        If the estimator is not fitted, it is fit when the visualizer is fitted,\n        unless otherwise specified by ``is_fitted``.\n\n    X_train : ndarray or DataFrame of shape n x m\n        A feature array of n instances with m features the model is trained on.\n        Used to fit the visualizer and also to score the visualizer if test splits are\n        not directly specified.\n\n    y_train : ndarray or Series of length n\n        An array or series of target or class values. Used to fit the visualizer and\n        also to score the visualizer if test splits are not specified.\n\n    X_test : ndarray or DataFrame of shape n x m, default: None\n        An optional feature array of n instances with m features that the model\n        is scored on if specified, using X_train as the training data.\n\n    y_test : ndarray or Series of length n, default: None\n        An optional array or series of target or class values that serve as actual\n        labels for X_test for scoring purposes.\n\n    ax : matplotlib Axes\n        The axes to plot the figure on.\n\n    shared_limits : bool, default: True\n        If shared_limits is True, the range of the X and Y axis limits will\n        be identical, creating a square graphic with a true 45 degree line.\n        In this form, it is easier to diagnose under- or over- prediction,\n        though the figure will become more sparse. To localize points, set\n        shared_limits to False, but note that this will distort the figure\n        and should be accounted for during analysis.\n\n    bestfit : bool, default: True\n        Draw a linear best fit line to estimate the correlation between the\n        predicted and measured value of the target variable. The color of\n        the bestfit line is determined by the ``line_color`` argument.\n\n    identity: bool, default: True\n        Draw the 45 degree identity line, y=x in order to better show the\n        relationship or pattern of the residuals. E.g. to estimate if the\n        model is over- or under- estimating the given values. The color of the\n        identity line is a muted version of the ``line_color`` argument.\n\n    alpha : float, default: 0.75\n        Specify a transparency where 1 is completely opaque and 0 is completely\n        transparent. This property makes densely clustered points more visible.\n\n    is_fitted : bool or str, default='auto'\n        Specify if the wrapped estimator is already fitted. If False, the estimator\n        will be fit when the visualizer is fit, otherwise, the estimator will not be\n        modified. If 'auto' (default), a helper method will check if the estimator\n        is fitted before fitting it again.\n\n    show: bool, default: True\n        If True, calls ``show()``, which in turn calls ``plt.show()`` however you cannot\n        call ``plt.savefig`` from this signature, nor ``clear_figure``. If False, simply\n        calls ``finalize()``\n\n    kwargs : dict\n        Keyword arguments that are passed to the base class and may influence\n        the visualization as defined in other Visualizers.\n\n    Returns\n    -------\n    ax : matplotlib Axes\n        Returns the axes that the prediction error plot was drawn on.\n    "
    visualizer = PredictionError(estimator, ax, shared_limits=shared_limits, bestfit=bestfit, identity=identity, alpha=alpha, is_fitted=is_fitted, **kwargs)
    visualizer.fit(X_train, y_train)
    if X_test is not None and y_test is not None:
        visualizer.score(X_test, y_test)
    elif X_test is not None or y_test is not None:
        raise YellowbrickValueError('both X_test and y_test are required if one is specified')
    else:
        visualizer.score(X_train, y_train)
    if show:
        visualizer.show()
    else:
        visualizer.finalize()
    return visualizer