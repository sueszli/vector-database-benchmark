[
    {
        "func_name": "n_order",
        "original": "def n_order(a, n):\n    \"\"\" Returns the order of ``a`` modulo ``n``.\n\n    Explanation\n    ===========\n\n    The order of ``a`` modulo ``n`` is the smallest integer\n    ``k`` such that `a^k` leaves a remainder of 1 with ``n``.\n\n    Parameters\n    ==========\n\n    a : integer\n    n : integer, n > 1. a and n should be relatively prime\n\n    Returns\n    =======\n\n    int : the order of ``a`` modulo ``n``\n\n    Raises\n    ======\n\n    ValueError\n        If `n \\\\le 1` or `\\\\gcd(a, n) \\\\neq 1`.\n        If ``a`` or ``n`` is not an integer.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory import n_order\n    >>> n_order(3, 7)\n    6\n    >>> n_order(4, 7)\n    3\n\n    See Also\n    ========\n\n    is_primitive_root\n        We say that ``a`` is a primitive root of ``n``\n        when the order of ``a`` modulo ``n`` equals ``totient(n)``\n\n    \"\"\"\n    (a, n) = (as_int(a), as_int(n))\n    if n <= 1:\n        raise ValueError('n should be an integer greater than 1')\n    a = a % n\n    if a == 1:\n        return 1\n    if gcd(a, n) != 1:\n        raise ValueError('The two numbers should be relatively prime')\n    a_order = 1\n    for (p, e) in factorint(n).items():\n        pe = p ** e\n        pe_order = (p - 1) * p ** (e - 1)\n        factors = factorint(p - 1)\n        if e > 1:\n            factors[p] = e - 1\n        order = 1\n        for (px, ex) in factors.items():\n            x = pow(a, pe_order // px ** ex, pe)\n            while x != 1:\n                x = pow(x, px, pe)\n                order *= px\n        a_order = lcm(a_order, order)\n    return int(a_order)",
        "mutated": [
            "def n_order(a, n):\n    if False:\n        i = 10\n    ' Returns the order of ``a`` modulo ``n``.\\n\\n    Explanation\\n    ===========\\n\\n    The order of ``a`` modulo ``n`` is the smallest integer\\n    ``k`` such that `a^k` leaves a remainder of 1 with ``n``.\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    n : integer, n > 1. a and n should be relatively prime\\n\\n    Returns\\n    =======\\n\\n    int : the order of ``a`` modulo ``n``\\n\\n    Raises\\n    ======\\n\\n    ValueError\\n        If `n \\\\le 1` or `\\\\gcd(a, n) \\\\neq 1`.\\n        If ``a`` or ``n`` is not an integer.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import n_order\\n    >>> n_order(3, 7)\\n    6\\n    >>> n_order(4, 7)\\n    3\\n\\n    See Also\\n    ========\\n\\n    is_primitive_root\\n        We say that ``a`` is a primitive root of ``n``\\n        when the order of ``a`` modulo ``n`` equals ``totient(n)``\\n\\n    '\n    (a, n) = (as_int(a), as_int(n))\n    if n <= 1:\n        raise ValueError('n should be an integer greater than 1')\n    a = a % n\n    if a == 1:\n        return 1\n    if gcd(a, n) != 1:\n        raise ValueError('The two numbers should be relatively prime')\n    a_order = 1\n    for (p, e) in factorint(n).items():\n        pe = p ** e\n        pe_order = (p - 1) * p ** (e - 1)\n        factors = factorint(p - 1)\n        if e > 1:\n            factors[p] = e - 1\n        order = 1\n        for (px, ex) in factors.items():\n            x = pow(a, pe_order // px ** ex, pe)\n            while x != 1:\n                x = pow(x, px, pe)\n                order *= px\n        a_order = lcm(a_order, order)\n    return int(a_order)",
            "def n_order(a, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ' Returns the order of ``a`` modulo ``n``.\\n\\n    Explanation\\n    ===========\\n\\n    The order of ``a`` modulo ``n`` is the smallest integer\\n    ``k`` such that `a^k` leaves a remainder of 1 with ``n``.\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    n : integer, n > 1. a and n should be relatively prime\\n\\n    Returns\\n    =======\\n\\n    int : the order of ``a`` modulo ``n``\\n\\n    Raises\\n    ======\\n\\n    ValueError\\n        If `n \\\\le 1` or `\\\\gcd(a, n) \\\\neq 1`.\\n        If ``a`` or ``n`` is not an integer.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import n_order\\n    >>> n_order(3, 7)\\n    6\\n    >>> n_order(4, 7)\\n    3\\n\\n    See Also\\n    ========\\n\\n    is_primitive_root\\n        We say that ``a`` is a primitive root of ``n``\\n        when the order of ``a`` modulo ``n`` equals ``totient(n)``\\n\\n    '\n    (a, n) = (as_int(a), as_int(n))\n    if n <= 1:\n        raise ValueError('n should be an integer greater than 1')\n    a = a % n\n    if a == 1:\n        return 1\n    if gcd(a, n) != 1:\n        raise ValueError('The two numbers should be relatively prime')\n    a_order = 1\n    for (p, e) in factorint(n).items():\n        pe = p ** e\n        pe_order = (p - 1) * p ** (e - 1)\n        factors = factorint(p - 1)\n        if e > 1:\n            factors[p] = e - 1\n        order = 1\n        for (px, ex) in factors.items():\n            x = pow(a, pe_order // px ** ex, pe)\n            while x != 1:\n                x = pow(x, px, pe)\n                order *= px\n        a_order = lcm(a_order, order)\n    return int(a_order)",
            "def n_order(a, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ' Returns the order of ``a`` modulo ``n``.\\n\\n    Explanation\\n    ===========\\n\\n    The order of ``a`` modulo ``n`` is the smallest integer\\n    ``k`` such that `a^k` leaves a remainder of 1 with ``n``.\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    n : integer, n > 1. a and n should be relatively prime\\n\\n    Returns\\n    =======\\n\\n    int : the order of ``a`` modulo ``n``\\n\\n    Raises\\n    ======\\n\\n    ValueError\\n        If `n \\\\le 1` or `\\\\gcd(a, n) \\\\neq 1`.\\n        If ``a`` or ``n`` is not an integer.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import n_order\\n    >>> n_order(3, 7)\\n    6\\n    >>> n_order(4, 7)\\n    3\\n\\n    See Also\\n    ========\\n\\n    is_primitive_root\\n        We say that ``a`` is a primitive root of ``n``\\n        when the order of ``a`` modulo ``n`` equals ``totient(n)``\\n\\n    '\n    (a, n) = (as_int(a), as_int(n))\n    if n <= 1:\n        raise ValueError('n should be an integer greater than 1')\n    a = a % n\n    if a == 1:\n        return 1\n    if gcd(a, n) != 1:\n        raise ValueError('The two numbers should be relatively prime')\n    a_order = 1\n    for (p, e) in factorint(n).items():\n        pe = p ** e\n        pe_order = (p - 1) * p ** (e - 1)\n        factors = factorint(p - 1)\n        if e > 1:\n            factors[p] = e - 1\n        order = 1\n        for (px, ex) in factors.items():\n            x = pow(a, pe_order // px ** ex, pe)\n            while x != 1:\n                x = pow(x, px, pe)\n                order *= px\n        a_order = lcm(a_order, order)\n    return int(a_order)",
            "def n_order(a, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ' Returns the order of ``a`` modulo ``n``.\\n\\n    Explanation\\n    ===========\\n\\n    The order of ``a`` modulo ``n`` is the smallest integer\\n    ``k`` such that `a^k` leaves a remainder of 1 with ``n``.\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    n : integer, n > 1. a and n should be relatively prime\\n\\n    Returns\\n    =======\\n\\n    int : the order of ``a`` modulo ``n``\\n\\n    Raises\\n    ======\\n\\n    ValueError\\n        If `n \\\\le 1` or `\\\\gcd(a, n) \\\\neq 1`.\\n        If ``a`` or ``n`` is not an integer.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import n_order\\n    >>> n_order(3, 7)\\n    6\\n    >>> n_order(4, 7)\\n    3\\n\\n    See Also\\n    ========\\n\\n    is_primitive_root\\n        We say that ``a`` is a primitive root of ``n``\\n        when the order of ``a`` modulo ``n`` equals ``totient(n)``\\n\\n    '\n    (a, n) = (as_int(a), as_int(n))\n    if n <= 1:\n        raise ValueError('n should be an integer greater than 1')\n    a = a % n\n    if a == 1:\n        return 1\n    if gcd(a, n) != 1:\n        raise ValueError('The two numbers should be relatively prime')\n    a_order = 1\n    for (p, e) in factorint(n).items():\n        pe = p ** e\n        pe_order = (p - 1) * p ** (e - 1)\n        factors = factorint(p - 1)\n        if e > 1:\n            factors[p] = e - 1\n        order = 1\n        for (px, ex) in factors.items():\n            x = pow(a, pe_order // px ** ex, pe)\n            while x != 1:\n                x = pow(x, px, pe)\n                order *= px\n        a_order = lcm(a_order, order)\n    return int(a_order)",
            "def n_order(a, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ' Returns the order of ``a`` modulo ``n``.\\n\\n    Explanation\\n    ===========\\n\\n    The order of ``a`` modulo ``n`` is the smallest integer\\n    ``k`` such that `a^k` leaves a remainder of 1 with ``n``.\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    n : integer, n > 1. a and n should be relatively prime\\n\\n    Returns\\n    =======\\n\\n    int : the order of ``a`` modulo ``n``\\n\\n    Raises\\n    ======\\n\\n    ValueError\\n        If `n \\\\le 1` or `\\\\gcd(a, n) \\\\neq 1`.\\n        If ``a`` or ``n`` is not an integer.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import n_order\\n    >>> n_order(3, 7)\\n    6\\n    >>> n_order(4, 7)\\n    3\\n\\n    See Also\\n    ========\\n\\n    is_primitive_root\\n        We say that ``a`` is a primitive root of ``n``\\n        when the order of ``a`` modulo ``n`` equals ``totient(n)``\\n\\n    '\n    (a, n) = (as_int(a), as_int(n))\n    if n <= 1:\n        raise ValueError('n should be an integer greater than 1')\n    a = a % n\n    if a == 1:\n        return 1\n    if gcd(a, n) != 1:\n        raise ValueError('The two numbers should be relatively prime')\n    a_order = 1\n    for (p, e) in factorint(n).items():\n        pe = p ** e\n        pe_order = (p - 1) * p ** (e - 1)\n        factors = factorint(p - 1)\n        if e > 1:\n            factors[p] = e - 1\n        order = 1\n        for (px, ex) in factors.items():\n            x = pow(a, pe_order // px ** ex, pe)\n            while x != 1:\n                x = pow(x, px, pe)\n                order *= px\n        a_order = lcm(a_order, order)\n    return int(a_order)"
        ]
    },
    {
        "func_name": "_primitive_root_prime_iter",
        "original": "def _primitive_root_prime_iter(p):\n    \"\"\" Generates the primitive roots for a prime ``p``.\n\n    Explanation\n    ===========\n\n    The primitive roots generated are not necessarily sorted.\n    However, the first one is the smallest primitive root.\n\n    Find the element whose order is ``p-1`` from the smaller one.\n    If we can find the first primitive root ``g``, we can use the following theorem.\n\n    .. math ::\n        \\\\operatorname{ord}(g^k) = \\\\frac{\\\\operatorname{ord}(g)}{\\\\gcd(\\\\operatorname{ord}(g), k)}\n\n    From the assumption that `\\\\operatorname{ord}(g)=p-1`,\n    it is a necessary and sufficient condition for\n    `\\\\operatorname{ord}(g^k)=p-1` that `\\\\gcd(p-1, k)=1`.\n\n    Parameters\n    ==========\n\n    p : odd prime\n\n    Yields\n    ======\n\n    int\n        the primitive roots of ``p``\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.residue_ntheory import _primitive_root_prime_iter\n    >>> sorted(_primitive_root_prime_iter(19))\n    [2, 3, 10, 13, 14, 15]\n\n    References\n    ==========\n\n    .. [1] W. Stein \"Elementary Number Theory\" (2011), page 44\n\n    \"\"\"\n    if p == 3:\n        yield 2\n        return\n    g_min = 3 if p % 8 in [1, 7] else 2\n    if p < 41:\n        g = 5 if p == 23 else g_min\n    else:\n        v = [(p - 1) // i for i in factorint(p - 1).keys()]\n        for g in range(g_min, p):\n            if all((pow(g, pw, p) != 1 for pw in v)):\n                break\n    yield g\n    for k in range(3, p, 2):\n        if gcd(p - 1, k) == 1:\n            yield pow(g, k, p)",
        "mutated": [
            "def _primitive_root_prime_iter(p):\n    if False:\n        i = 10\n    ' Generates the primitive roots for a prime ``p``.\\n\\n    Explanation\\n    ===========\\n\\n    The primitive roots generated are not necessarily sorted.\\n    However, the first one is the smallest primitive root.\\n\\n    Find the element whose order is ``p-1`` from the smaller one.\\n    If we can find the first primitive root ``g``, we can use the following theorem.\\n\\n    .. math ::\\n        \\\\operatorname{ord}(g^k) = \\\\frac{\\\\operatorname{ord}(g)}{\\\\gcd(\\\\operatorname{ord}(g), k)}\\n\\n    From the assumption that `\\\\operatorname{ord}(g)=p-1`,\\n    it is a necessary and sufficient condition for\\n    `\\\\operatorname{ord}(g^k)=p-1` that `\\\\gcd(p-1, k)=1`.\\n\\n    Parameters\\n    ==========\\n\\n    p : odd prime\\n\\n    Yields\\n    ======\\n\\n    int\\n        the primitive roots of ``p``\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _primitive_root_prime_iter\\n    >>> sorted(_primitive_root_prime_iter(19))\\n    [2, 3, 10, 13, 14, 15]\\n\\n    References\\n    ==========\\n\\n    .. [1] W. Stein \"Elementary Number Theory\" (2011), page 44\\n\\n    '\n    if p == 3:\n        yield 2\n        return\n    g_min = 3 if p % 8 in [1, 7] else 2\n    if p < 41:\n        g = 5 if p == 23 else g_min\n    else:\n        v = [(p - 1) // i for i in factorint(p - 1).keys()]\n        for g in range(g_min, p):\n            if all((pow(g, pw, p) != 1 for pw in v)):\n                break\n    yield g\n    for k in range(3, p, 2):\n        if gcd(p - 1, k) == 1:\n            yield pow(g, k, p)",
            "def _primitive_root_prime_iter(p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ' Generates the primitive roots for a prime ``p``.\\n\\n    Explanation\\n    ===========\\n\\n    The primitive roots generated are not necessarily sorted.\\n    However, the first one is the smallest primitive root.\\n\\n    Find the element whose order is ``p-1`` from the smaller one.\\n    If we can find the first primitive root ``g``, we can use the following theorem.\\n\\n    .. math ::\\n        \\\\operatorname{ord}(g^k) = \\\\frac{\\\\operatorname{ord}(g)}{\\\\gcd(\\\\operatorname{ord}(g), k)}\\n\\n    From the assumption that `\\\\operatorname{ord}(g)=p-1`,\\n    it is a necessary and sufficient condition for\\n    `\\\\operatorname{ord}(g^k)=p-1` that `\\\\gcd(p-1, k)=1`.\\n\\n    Parameters\\n    ==========\\n\\n    p : odd prime\\n\\n    Yields\\n    ======\\n\\n    int\\n        the primitive roots of ``p``\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _primitive_root_prime_iter\\n    >>> sorted(_primitive_root_prime_iter(19))\\n    [2, 3, 10, 13, 14, 15]\\n\\n    References\\n    ==========\\n\\n    .. [1] W. Stein \"Elementary Number Theory\" (2011), page 44\\n\\n    '\n    if p == 3:\n        yield 2\n        return\n    g_min = 3 if p % 8 in [1, 7] else 2\n    if p < 41:\n        g = 5 if p == 23 else g_min\n    else:\n        v = [(p - 1) // i for i in factorint(p - 1).keys()]\n        for g in range(g_min, p):\n            if all((pow(g, pw, p) != 1 for pw in v)):\n                break\n    yield g\n    for k in range(3, p, 2):\n        if gcd(p - 1, k) == 1:\n            yield pow(g, k, p)",
            "def _primitive_root_prime_iter(p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ' Generates the primitive roots for a prime ``p``.\\n\\n    Explanation\\n    ===========\\n\\n    The primitive roots generated are not necessarily sorted.\\n    However, the first one is the smallest primitive root.\\n\\n    Find the element whose order is ``p-1`` from the smaller one.\\n    If we can find the first primitive root ``g``, we can use the following theorem.\\n\\n    .. math ::\\n        \\\\operatorname{ord}(g^k) = \\\\frac{\\\\operatorname{ord}(g)}{\\\\gcd(\\\\operatorname{ord}(g), k)}\\n\\n    From the assumption that `\\\\operatorname{ord}(g)=p-1`,\\n    it is a necessary and sufficient condition for\\n    `\\\\operatorname{ord}(g^k)=p-1` that `\\\\gcd(p-1, k)=1`.\\n\\n    Parameters\\n    ==========\\n\\n    p : odd prime\\n\\n    Yields\\n    ======\\n\\n    int\\n        the primitive roots of ``p``\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _primitive_root_prime_iter\\n    >>> sorted(_primitive_root_prime_iter(19))\\n    [2, 3, 10, 13, 14, 15]\\n\\n    References\\n    ==========\\n\\n    .. [1] W. Stein \"Elementary Number Theory\" (2011), page 44\\n\\n    '\n    if p == 3:\n        yield 2\n        return\n    g_min = 3 if p % 8 in [1, 7] else 2\n    if p < 41:\n        g = 5 if p == 23 else g_min\n    else:\n        v = [(p - 1) // i for i in factorint(p - 1).keys()]\n        for g in range(g_min, p):\n            if all((pow(g, pw, p) != 1 for pw in v)):\n                break\n    yield g\n    for k in range(3, p, 2):\n        if gcd(p - 1, k) == 1:\n            yield pow(g, k, p)",
            "def _primitive_root_prime_iter(p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ' Generates the primitive roots for a prime ``p``.\\n\\n    Explanation\\n    ===========\\n\\n    The primitive roots generated are not necessarily sorted.\\n    However, the first one is the smallest primitive root.\\n\\n    Find the element whose order is ``p-1`` from the smaller one.\\n    If we can find the first primitive root ``g``, we can use the following theorem.\\n\\n    .. math ::\\n        \\\\operatorname{ord}(g^k) = \\\\frac{\\\\operatorname{ord}(g)}{\\\\gcd(\\\\operatorname{ord}(g), k)}\\n\\n    From the assumption that `\\\\operatorname{ord}(g)=p-1`,\\n    it is a necessary and sufficient condition for\\n    `\\\\operatorname{ord}(g^k)=p-1` that `\\\\gcd(p-1, k)=1`.\\n\\n    Parameters\\n    ==========\\n\\n    p : odd prime\\n\\n    Yields\\n    ======\\n\\n    int\\n        the primitive roots of ``p``\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _primitive_root_prime_iter\\n    >>> sorted(_primitive_root_prime_iter(19))\\n    [2, 3, 10, 13, 14, 15]\\n\\n    References\\n    ==========\\n\\n    .. [1] W. Stein \"Elementary Number Theory\" (2011), page 44\\n\\n    '\n    if p == 3:\n        yield 2\n        return\n    g_min = 3 if p % 8 in [1, 7] else 2\n    if p < 41:\n        g = 5 if p == 23 else g_min\n    else:\n        v = [(p - 1) // i for i in factorint(p - 1).keys()]\n        for g in range(g_min, p):\n            if all((pow(g, pw, p) != 1 for pw in v)):\n                break\n    yield g\n    for k in range(3, p, 2):\n        if gcd(p - 1, k) == 1:\n            yield pow(g, k, p)",
            "def _primitive_root_prime_iter(p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ' Generates the primitive roots for a prime ``p``.\\n\\n    Explanation\\n    ===========\\n\\n    The primitive roots generated are not necessarily sorted.\\n    However, the first one is the smallest primitive root.\\n\\n    Find the element whose order is ``p-1`` from the smaller one.\\n    If we can find the first primitive root ``g``, we can use the following theorem.\\n\\n    .. math ::\\n        \\\\operatorname{ord}(g^k) = \\\\frac{\\\\operatorname{ord}(g)}{\\\\gcd(\\\\operatorname{ord}(g), k)}\\n\\n    From the assumption that `\\\\operatorname{ord}(g)=p-1`,\\n    it is a necessary and sufficient condition for\\n    `\\\\operatorname{ord}(g^k)=p-1` that `\\\\gcd(p-1, k)=1`.\\n\\n    Parameters\\n    ==========\\n\\n    p : odd prime\\n\\n    Yields\\n    ======\\n\\n    int\\n        the primitive roots of ``p``\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _primitive_root_prime_iter\\n    >>> sorted(_primitive_root_prime_iter(19))\\n    [2, 3, 10, 13, 14, 15]\\n\\n    References\\n    ==========\\n\\n    .. [1] W. Stein \"Elementary Number Theory\" (2011), page 44\\n\\n    '\n    if p == 3:\n        yield 2\n        return\n    g_min = 3 if p % 8 in [1, 7] else 2\n    if p < 41:\n        g = 5 if p == 23 else g_min\n    else:\n        v = [(p - 1) // i for i in factorint(p - 1).keys()]\n        for g in range(g_min, p):\n            if all((pow(g, pw, p) != 1 for pw in v)):\n                break\n    yield g\n    for k in range(3, p, 2):\n        if gcd(p - 1, k) == 1:\n            yield pow(g, k, p)"
        ]
    },
    {
        "func_name": "_primitive_root_prime_power_iter",
        "original": "def _primitive_root_prime_power_iter(p, e):\n    \"\"\" Generates the primitive roots of `p^e`.\n\n    Explanation\n    ===========\n\n    Let ``g`` be the primitive root of ``p``.\n    If `g^{p-1} \\\\not\\\\equiv 1 \\\\pmod{p^2}`, then ``g`` is primitive root of `p^e`.\n    Thus, if we find a primitive root ``g`` of ``p``,\n    then `g, g+p, g+2p, \\\\ldots, g+(p-1)p` are primitive roots of `p^2` except one.\n    That one satisfies `\\\\hat{g}^{p-1} \\\\equiv 1 \\\\pmod{p^2}`.\n    If ``h`` is the primitive root of `p^2`,\n    then `h, h+p^2, h+2p^2, \\\\ldots, h+(p^{e-2}-1)p^e` are primitive roots of `p^e`.\n\n    Parameters\n    ==========\n\n    p : odd prime\n    e : positive integer\n\n    Yields\n    ======\n\n    int\n        the primitive roots of `p^e`\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.residue_ntheory import _primitive_root_prime_power_iter\n    >>> sorted(_primitive_root_prime_power_iter(5, 2))\n    [2, 3, 8, 12, 13, 17, 22, 23]\n\n    \"\"\"\n    if e == 1:\n        yield from _primitive_root_prime_iter(p)\n    else:\n        p2 = p ** 2\n        for g in _primitive_root_prime_iter(p):\n            t = (g - pow(g, 2 - p, p2)) % p2\n            for k in range(0, p2, p):\n                if k != t:\n                    yield from (g + k + m for m in range(0, p ** e, p2))",
        "mutated": [
            "def _primitive_root_prime_power_iter(p, e):\n    if False:\n        i = 10\n    ' Generates the primitive roots of `p^e`.\\n\\n    Explanation\\n    ===========\\n\\n    Let ``g`` be the primitive root of ``p``.\\n    If `g^{p-1} \\\\not\\\\equiv 1 \\\\pmod{p^2}`, then ``g`` is primitive root of `p^e`.\\n    Thus, if we find a primitive root ``g`` of ``p``,\\n    then `g, g+p, g+2p, \\\\ldots, g+(p-1)p` are primitive roots of `p^2` except one.\\n    That one satisfies `\\\\hat{g}^{p-1} \\\\equiv 1 \\\\pmod{p^2}`.\\n    If ``h`` is the primitive root of `p^2`,\\n    then `h, h+p^2, h+2p^2, \\\\ldots, h+(p^{e-2}-1)p^e` are primitive roots of `p^e`.\\n\\n    Parameters\\n    ==========\\n\\n    p : odd prime\\n    e : positive integer\\n\\n    Yields\\n    ======\\n\\n    int\\n        the primitive roots of `p^e`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _primitive_root_prime_power_iter\\n    >>> sorted(_primitive_root_prime_power_iter(5, 2))\\n    [2, 3, 8, 12, 13, 17, 22, 23]\\n\\n    '\n    if e == 1:\n        yield from _primitive_root_prime_iter(p)\n    else:\n        p2 = p ** 2\n        for g in _primitive_root_prime_iter(p):\n            t = (g - pow(g, 2 - p, p2)) % p2\n            for k in range(0, p2, p):\n                if k != t:\n                    yield from (g + k + m for m in range(0, p ** e, p2))",
            "def _primitive_root_prime_power_iter(p, e):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ' Generates the primitive roots of `p^e`.\\n\\n    Explanation\\n    ===========\\n\\n    Let ``g`` be the primitive root of ``p``.\\n    If `g^{p-1} \\\\not\\\\equiv 1 \\\\pmod{p^2}`, then ``g`` is primitive root of `p^e`.\\n    Thus, if we find a primitive root ``g`` of ``p``,\\n    then `g, g+p, g+2p, \\\\ldots, g+(p-1)p` are primitive roots of `p^2` except one.\\n    That one satisfies `\\\\hat{g}^{p-1} \\\\equiv 1 \\\\pmod{p^2}`.\\n    If ``h`` is the primitive root of `p^2`,\\n    then `h, h+p^2, h+2p^2, \\\\ldots, h+(p^{e-2}-1)p^e` are primitive roots of `p^e`.\\n\\n    Parameters\\n    ==========\\n\\n    p : odd prime\\n    e : positive integer\\n\\n    Yields\\n    ======\\n\\n    int\\n        the primitive roots of `p^e`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _primitive_root_prime_power_iter\\n    >>> sorted(_primitive_root_prime_power_iter(5, 2))\\n    [2, 3, 8, 12, 13, 17, 22, 23]\\n\\n    '\n    if e == 1:\n        yield from _primitive_root_prime_iter(p)\n    else:\n        p2 = p ** 2\n        for g in _primitive_root_prime_iter(p):\n            t = (g - pow(g, 2 - p, p2)) % p2\n            for k in range(0, p2, p):\n                if k != t:\n                    yield from (g + k + m for m in range(0, p ** e, p2))",
            "def _primitive_root_prime_power_iter(p, e):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ' Generates the primitive roots of `p^e`.\\n\\n    Explanation\\n    ===========\\n\\n    Let ``g`` be the primitive root of ``p``.\\n    If `g^{p-1} \\\\not\\\\equiv 1 \\\\pmod{p^2}`, then ``g`` is primitive root of `p^e`.\\n    Thus, if we find a primitive root ``g`` of ``p``,\\n    then `g, g+p, g+2p, \\\\ldots, g+(p-1)p` are primitive roots of `p^2` except one.\\n    That one satisfies `\\\\hat{g}^{p-1} \\\\equiv 1 \\\\pmod{p^2}`.\\n    If ``h`` is the primitive root of `p^2`,\\n    then `h, h+p^2, h+2p^2, \\\\ldots, h+(p^{e-2}-1)p^e` are primitive roots of `p^e`.\\n\\n    Parameters\\n    ==========\\n\\n    p : odd prime\\n    e : positive integer\\n\\n    Yields\\n    ======\\n\\n    int\\n        the primitive roots of `p^e`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _primitive_root_prime_power_iter\\n    >>> sorted(_primitive_root_prime_power_iter(5, 2))\\n    [2, 3, 8, 12, 13, 17, 22, 23]\\n\\n    '\n    if e == 1:\n        yield from _primitive_root_prime_iter(p)\n    else:\n        p2 = p ** 2\n        for g in _primitive_root_prime_iter(p):\n            t = (g - pow(g, 2 - p, p2)) % p2\n            for k in range(0, p2, p):\n                if k != t:\n                    yield from (g + k + m for m in range(0, p ** e, p2))",
            "def _primitive_root_prime_power_iter(p, e):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ' Generates the primitive roots of `p^e`.\\n\\n    Explanation\\n    ===========\\n\\n    Let ``g`` be the primitive root of ``p``.\\n    If `g^{p-1} \\\\not\\\\equiv 1 \\\\pmod{p^2}`, then ``g`` is primitive root of `p^e`.\\n    Thus, if we find a primitive root ``g`` of ``p``,\\n    then `g, g+p, g+2p, \\\\ldots, g+(p-1)p` are primitive roots of `p^2` except one.\\n    That one satisfies `\\\\hat{g}^{p-1} \\\\equiv 1 \\\\pmod{p^2}`.\\n    If ``h`` is the primitive root of `p^2`,\\n    then `h, h+p^2, h+2p^2, \\\\ldots, h+(p^{e-2}-1)p^e` are primitive roots of `p^e`.\\n\\n    Parameters\\n    ==========\\n\\n    p : odd prime\\n    e : positive integer\\n\\n    Yields\\n    ======\\n\\n    int\\n        the primitive roots of `p^e`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _primitive_root_prime_power_iter\\n    >>> sorted(_primitive_root_prime_power_iter(5, 2))\\n    [2, 3, 8, 12, 13, 17, 22, 23]\\n\\n    '\n    if e == 1:\n        yield from _primitive_root_prime_iter(p)\n    else:\n        p2 = p ** 2\n        for g in _primitive_root_prime_iter(p):\n            t = (g - pow(g, 2 - p, p2)) % p2\n            for k in range(0, p2, p):\n                if k != t:\n                    yield from (g + k + m for m in range(0, p ** e, p2))",
            "def _primitive_root_prime_power_iter(p, e):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ' Generates the primitive roots of `p^e`.\\n\\n    Explanation\\n    ===========\\n\\n    Let ``g`` be the primitive root of ``p``.\\n    If `g^{p-1} \\\\not\\\\equiv 1 \\\\pmod{p^2}`, then ``g`` is primitive root of `p^e`.\\n    Thus, if we find a primitive root ``g`` of ``p``,\\n    then `g, g+p, g+2p, \\\\ldots, g+(p-1)p` are primitive roots of `p^2` except one.\\n    That one satisfies `\\\\hat{g}^{p-1} \\\\equiv 1 \\\\pmod{p^2}`.\\n    If ``h`` is the primitive root of `p^2`,\\n    then `h, h+p^2, h+2p^2, \\\\ldots, h+(p^{e-2}-1)p^e` are primitive roots of `p^e`.\\n\\n    Parameters\\n    ==========\\n\\n    p : odd prime\\n    e : positive integer\\n\\n    Yields\\n    ======\\n\\n    int\\n        the primitive roots of `p^e`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _primitive_root_prime_power_iter\\n    >>> sorted(_primitive_root_prime_power_iter(5, 2))\\n    [2, 3, 8, 12, 13, 17, 22, 23]\\n\\n    '\n    if e == 1:\n        yield from _primitive_root_prime_iter(p)\n    else:\n        p2 = p ** 2\n        for g in _primitive_root_prime_iter(p):\n            t = (g - pow(g, 2 - p, p2)) % p2\n            for k in range(0, p2, p):\n                if k != t:\n                    yield from (g + k + m for m in range(0, p ** e, p2))"
        ]
    },
    {
        "func_name": "_primitive_root_prime_power2_iter",
        "original": "def _primitive_root_prime_power2_iter(p, e):\n    \"\"\" Generates the primitive roots of `2p^e`.\n\n    Explanation\n    ===========\n\n    If ``g`` is the primitive root of ``p**e``,\n    then the odd one of ``g`` and ``g+p**e`` is the primitive root of ``2*p**e``.\n\n    Parameters\n    ==========\n\n    p : odd prime\n    e : positive integer\n\n    Yields\n    ======\n\n    int\n        the primitive roots of `2p^e`\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.residue_ntheory import _primitive_root_prime_power2_iter\n    >>> sorted(_primitive_root_prime_power2_iter(5, 2))\n    [3, 13, 17, 23, 27, 33, 37, 47]\n\n    \"\"\"\n    for g in _primitive_root_prime_power_iter(p, e):\n        if g % 2 == 1:\n            yield g\n        else:\n            yield (g + p ** e)",
        "mutated": [
            "def _primitive_root_prime_power2_iter(p, e):\n    if False:\n        i = 10\n    ' Generates the primitive roots of `2p^e`.\\n\\n    Explanation\\n    ===========\\n\\n    If ``g`` is the primitive root of ``p**e``,\\n    then the odd one of ``g`` and ``g+p**e`` is the primitive root of ``2*p**e``.\\n\\n    Parameters\\n    ==========\\n\\n    p : odd prime\\n    e : positive integer\\n\\n    Yields\\n    ======\\n\\n    int\\n        the primitive roots of `2p^e`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _primitive_root_prime_power2_iter\\n    >>> sorted(_primitive_root_prime_power2_iter(5, 2))\\n    [3, 13, 17, 23, 27, 33, 37, 47]\\n\\n    '\n    for g in _primitive_root_prime_power_iter(p, e):\n        if g % 2 == 1:\n            yield g\n        else:\n            yield (g + p ** e)",
            "def _primitive_root_prime_power2_iter(p, e):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ' Generates the primitive roots of `2p^e`.\\n\\n    Explanation\\n    ===========\\n\\n    If ``g`` is the primitive root of ``p**e``,\\n    then the odd one of ``g`` and ``g+p**e`` is the primitive root of ``2*p**e``.\\n\\n    Parameters\\n    ==========\\n\\n    p : odd prime\\n    e : positive integer\\n\\n    Yields\\n    ======\\n\\n    int\\n        the primitive roots of `2p^e`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _primitive_root_prime_power2_iter\\n    >>> sorted(_primitive_root_prime_power2_iter(5, 2))\\n    [3, 13, 17, 23, 27, 33, 37, 47]\\n\\n    '\n    for g in _primitive_root_prime_power_iter(p, e):\n        if g % 2 == 1:\n            yield g\n        else:\n            yield (g + p ** e)",
            "def _primitive_root_prime_power2_iter(p, e):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ' Generates the primitive roots of `2p^e`.\\n\\n    Explanation\\n    ===========\\n\\n    If ``g`` is the primitive root of ``p**e``,\\n    then the odd one of ``g`` and ``g+p**e`` is the primitive root of ``2*p**e``.\\n\\n    Parameters\\n    ==========\\n\\n    p : odd prime\\n    e : positive integer\\n\\n    Yields\\n    ======\\n\\n    int\\n        the primitive roots of `2p^e`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _primitive_root_prime_power2_iter\\n    >>> sorted(_primitive_root_prime_power2_iter(5, 2))\\n    [3, 13, 17, 23, 27, 33, 37, 47]\\n\\n    '\n    for g in _primitive_root_prime_power_iter(p, e):\n        if g % 2 == 1:\n            yield g\n        else:\n            yield (g + p ** e)",
            "def _primitive_root_prime_power2_iter(p, e):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ' Generates the primitive roots of `2p^e`.\\n\\n    Explanation\\n    ===========\\n\\n    If ``g`` is the primitive root of ``p**e``,\\n    then the odd one of ``g`` and ``g+p**e`` is the primitive root of ``2*p**e``.\\n\\n    Parameters\\n    ==========\\n\\n    p : odd prime\\n    e : positive integer\\n\\n    Yields\\n    ======\\n\\n    int\\n        the primitive roots of `2p^e`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _primitive_root_prime_power2_iter\\n    >>> sorted(_primitive_root_prime_power2_iter(5, 2))\\n    [3, 13, 17, 23, 27, 33, 37, 47]\\n\\n    '\n    for g in _primitive_root_prime_power_iter(p, e):\n        if g % 2 == 1:\n            yield g\n        else:\n            yield (g + p ** e)",
            "def _primitive_root_prime_power2_iter(p, e):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ' Generates the primitive roots of `2p^e`.\\n\\n    Explanation\\n    ===========\\n\\n    If ``g`` is the primitive root of ``p**e``,\\n    then the odd one of ``g`` and ``g+p**e`` is the primitive root of ``2*p**e``.\\n\\n    Parameters\\n    ==========\\n\\n    p : odd prime\\n    e : positive integer\\n\\n    Yields\\n    ======\\n\\n    int\\n        the primitive roots of `2p^e`\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _primitive_root_prime_power2_iter\\n    >>> sorted(_primitive_root_prime_power2_iter(5, 2))\\n    [3, 13, 17, 23, 27, 33, 37, 47]\\n\\n    '\n    for g in _primitive_root_prime_power_iter(p, e):\n        if g % 2 == 1:\n            yield g\n        else:\n            yield (g + p ** e)"
        ]
    },
    {
        "func_name": "primitive_root",
        "original": "def primitive_root(p, smallest=True):\n    \"\"\" Returns a primitive root of ``p`` or None.\n\n    Explanation\n    ===========\n\n    For the definition of primitive root,\n    see the explanation of ``is_primitive_root``.\n\n    The primitive root of ``p`` exist only for\n    `p = 2, 4, q^e, 2q^e` (``q`` is an odd prime).\n    Now, if we know the primitive root of ``q``,\n    we can calculate the primitive root of `q^e`,\n    and if we know the primitive root of `q^e`,\n    we can calculate the primitive root of `2q^e`.\n    When there is no need to find the smallest primitive root,\n    this property can be used to obtain a fast primitive root.\n    On the other hand, when we want the smallest primitive root,\n    we naively determine whether it is a primitive root or not.\n\n    Parameters\n    ==========\n\n    p : integer, p > 1\n    smallest : if True the smallest primitive root is returned or None\n\n    Returns\n    =======\n\n    int | None :\n        If the primitive root exists, return the primitive root of ``p``.\n        If not, return None.\n\n    Raises\n    ======\n\n    ValueError\n        If `p \\\\le 1` or ``p`` is not an integer.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.residue_ntheory import primitive_root\n    >>> primitive_root(19)\n    2\n    >>> primitive_root(21) is None\n    True\n    >>> primitive_root(50, smallest=False)\n    27\n\n    See Also\n    ========\n\n    is_primitive_root\n\n    References\n    ==========\n\n    .. [1] W. Stein \"Elementary Number Theory\" (2011), page 44\n    .. [2] P. Hackman \"Elementary Number Theory\" (2009), Chapter C\n\n    \"\"\"\n    p = as_int(p)\n    if p <= 1:\n        raise ValueError('p should be an integer greater than 1')\n    if p <= 4:\n        return p - 1\n    p_even = p % 2 == 0\n    if not p_even:\n        q = p\n    elif p % 4:\n        q = p // 2\n    else:\n        return None\n    if isprime(q):\n        e = 1\n    else:\n        m = _perfect_power(q, 3)\n        if not m:\n            return None\n        (q, e) = m\n        if not isprime(q):\n            return None\n    if not smallest:\n        if p_even:\n            return next(_primitive_root_prime_power2_iter(q, e))\n        return next(_primitive_root_prime_power_iter(q, e))\n    if p_even:\n        for i in range(3, p, 2):\n            if i % q and is_primitive_root(i, p):\n                return i\n    g = next(_primitive_root_prime_iter(q))\n    if e == 1 or pow(g, q - 1, q ** 2) != 1:\n        return g\n    for i in range(g + 1, p):\n        if i % q and is_primitive_root(i, p):\n            return i",
        "mutated": [
            "def primitive_root(p, smallest=True):\n    if False:\n        i = 10\n    ' Returns a primitive root of ``p`` or None.\\n\\n    Explanation\\n    ===========\\n\\n    For the definition of primitive root,\\n    see the explanation of ``is_primitive_root``.\\n\\n    The primitive root of ``p`` exist only for\\n    `p = 2, 4, q^e, 2q^e` (``q`` is an odd prime).\\n    Now, if we know the primitive root of ``q``,\\n    we can calculate the primitive root of `q^e`,\\n    and if we know the primitive root of `q^e`,\\n    we can calculate the primitive root of `2q^e`.\\n    When there is no need to find the smallest primitive root,\\n    this property can be used to obtain a fast primitive root.\\n    On the other hand, when we want the smallest primitive root,\\n    we naively determine whether it is a primitive root or not.\\n\\n    Parameters\\n    ==========\\n\\n    p : integer, p > 1\\n    smallest : if True the smallest primitive root is returned or None\\n\\n    Returns\\n    =======\\n\\n    int | None :\\n        If the primitive root exists, return the primitive root of ``p``.\\n        If not, return None.\\n\\n    Raises\\n    ======\\n\\n    ValueError\\n        If `p \\\\le 1` or ``p`` is not an integer.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import primitive_root\\n    >>> primitive_root(19)\\n    2\\n    >>> primitive_root(21) is None\\n    True\\n    >>> primitive_root(50, smallest=False)\\n    27\\n\\n    See Also\\n    ========\\n\\n    is_primitive_root\\n\\n    References\\n    ==========\\n\\n    .. [1] W. Stein \"Elementary Number Theory\" (2011), page 44\\n    .. [2] P. Hackman \"Elementary Number Theory\" (2009), Chapter C\\n\\n    '\n    p = as_int(p)\n    if p <= 1:\n        raise ValueError('p should be an integer greater than 1')\n    if p <= 4:\n        return p - 1\n    p_even = p % 2 == 0\n    if not p_even:\n        q = p\n    elif p % 4:\n        q = p // 2\n    else:\n        return None\n    if isprime(q):\n        e = 1\n    else:\n        m = _perfect_power(q, 3)\n        if not m:\n            return None\n        (q, e) = m\n        if not isprime(q):\n            return None\n    if not smallest:\n        if p_even:\n            return next(_primitive_root_prime_power2_iter(q, e))\n        return next(_primitive_root_prime_power_iter(q, e))\n    if p_even:\n        for i in range(3, p, 2):\n            if i % q and is_primitive_root(i, p):\n                return i\n    g = next(_primitive_root_prime_iter(q))\n    if e == 1 or pow(g, q - 1, q ** 2) != 1:\n        return g\n    for i in range(g + 1, p):\n        if i % q and is_primitive_root(i, p):\n            return i",
            "def primitive_root(p, smallest=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ' Returns a primitive root of ``p`` or None.\\n\\n    Explanation\\n    ===========\\n\\n    For the definition of primitive root,\\n    see the explanation of ``is_primitive_root``.\\n\\n    The primitive root of ``p`` exist only for\\n    `p = 2, 4, q^e, 2q^e` (``q`` is an odd prime).\\n    Now, if we know the primitive root of ``q``,\\n    we can calculate the primitive root of `q^e`,\\n    and if we know the primitive root of `q^e`,\\n    we can calculate the primitive root of `2q^e`.\\n    When there is no need to find the smallest primitive root,\\n    this property can be used to obtain a fast primitive root.\\n    On the other hand, when we want the smallest primitive root,\\n    we naively determine whether it is a primitive root or not.\\n\\n    Parameters\\n    ==========\\n\\n    p : integer, p > 1\\n    smallest : if True the smallest primitive root is returned or None\\n\\n    Returns\\n    =======\\n\\n    int | None :\\n        If the primitive root exists, return the primitive root of ``p``.\\n        If not, return None.\\n\\n    Raises\\n    ======\\n\\n    ValueError\\n        If `p \\\\le 1` or ``p`` is not an integer.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import primitive_root\\n    >>> primitive_root(19)\\n    2\\n    >>> primitive_root(21) is None\\n    True\\n    >>> primitive_root(50, smallest=False)\\n    27\\n\\n    See Also\\n    ========\\n\\n    is_primitive_root\\n\\n    References\\n    ==========\\n\\n    .. [1] W. Stein \"Elementary Number Theory\" (2011), page 44\\n    .. [2] P. Hackman \"Elementary Number Theory\" (2009), Chapter C\\n\\n    '\n    p = as_int(p)\n    if p <= 1:\n        raise ValueError('p should be an integer greater than 1')\n    if p <= 4:\n        return p - 1\n    p_even = p % 2 == 0\n    if not p_even:\n        q = p\n    elif p % 4:\n        q = p // 2\n    else:\n        return None\n    if isprime(q):\n        e = 1\n    else:\n        m = _perfect_power(q, 3)\n        if not m:\n            return None\n        (q, e) = m\n        if not isprime(q):\n            return None\n    if not smallest:\n        if p_even:\n            return next(_primitive_root_prime_power2_iter(q, e))\n        return next(_primitive_root_prime_power_iter(q, e))\n    if p_even:\n        for i in range(3, p, 2):\n            if i % q and is_primitive_root(i, p):\n                return i\n    g = next(_primitive_root_prime_iter(q))\n    if e == 1 or pow(g, q - 1, q ** 2) != 1:\n        return g\n    for i in range(g + 1, p):\n        if i % q and is_primitive_root(i, p):\n            return i",
            "def primitive_root(p, smallest=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ' Returns a primitive root of ``p`` or None.\\n\\n    Explanation\\n    ===========\\n\\n    For the definition of primitive root,\\n    see the explanation of ``is_primitive_root``.\\n\\n    The primitive root of ``p`` exist only for\\n    `p = 2, 4, q^e, 2q^e` (``q`` is an odd prime).\\n    Now, if we know the primitive root of ``q``,\\n    we can calculate the primitive root of `q^e`,\\n    and if we know the primitive root of `q^e`,\\n    we can calculate the primitive root of `2q^e`.\\n    When there is no need to find the smallest primitive root,\\n    this property can be used to obtain a fast primitive root.\\n    On the other hand, when we want the smallest primitive root,\\n    we naively determine whether it is a primitive root or not.\\n\\n    Parameters\\n    ==========\\n\\n    p : integer, p > 1\\n    smallest : if True the smallest primitive root is returned or None\\n\\n    Returns\\n    =======\\n\\n    int | None :\\n        If the primitive root exists, return the primitive root of ``p``.\\n        If not, return None.\\n\\n    Raises\\n    ======\\n\\n    ValueError\\n        If `p \\\\le 1` or ``p`` is not an integer.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import primitive_root\\n    >>> primitive_root(19)\\n    2\\n    >>> primitive_root(21) is None\\n    True\\n    >>> primitive_root(50, smallest=False)\\n    27\\n\\n    See Also\\n    ========\\n\\n    is_primitive_root\\n\\n    References\\n    ==========\\n\\n    .. [1] W. Stein \"Elementary Number Theory\" (2011), page 44\\n    .. [2] P. Hackman \"Elementary Number Theory\" (2009), Chapter C\\n\\n    '\n    p = as_int(p)\n    if p <= 1:\n        raise ValueError('p should be an integer greater than 1')\n    if p <= 4:\n        return p - 1\n    p_even = p % 2 == 0\n    if not p_even:\n        q = p\n    elif p % 4:\n        q = p // 2\n    else:\n        return None\n    if isprime(q):\n        e = 1\n    else:\n        m = _perfect_power(q, 3)\n        if not m:\n            return None\n        (q, e) = m\n        if not isprime(q):\n            return None\n    if not smallest:\n        if p_even:\n            return next(_primitive_root_prime_power2_iter(q, e))\n        return next(_primitive_root_prime_power_iter(q, e))\n    if p_even:\n        for i in range(3, p, 2):\n            if i % q and is_primitive_root(i, p):\n                return i\n    g = next(_primitive_root_prime_iter(q))\n    if e == 1 or pow(g, q - 1, q ** 2) != 1:\n        return g\n    for i in range(g + 1, p):\n        if i % q and is_primitive_root(i, p):\n            return i",
            "def primitive_root(p, smallest=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ' Returns a primitive root of ``p`` or None.\\n\\n    Explanation\\n    ===========\\n\\n    For the definition of primitive root,\\n    see the explanation of ``is_primitive_root``.\\n\\n    The primitive root of ``p`` exist only for\\n    `p = 2, 4, q^e, 2q^e` (``q`` is an odd prime).\\n    Now, if we know the primitive root of ``q``,\\n    we can calculate the primitive root of `q^e`,\\n    and if we know the primitive root of `q^e`,\\n    we can calculate the primitive root of `2q^e`.\\n    When there is no need to find the smallest primitive root,\\n    this property can be used to obtain a fast primitive root.\\n    On the other hand, when we want the smallest primitive root,\\n    we naively determine whether it is a primitive root or not.\\n\\n    Parameters\\n    ==========\\n\\n    p : integer, p > 1\\n    smallest : if True the smallest primitive root is returned or None\\n\\n    Returns\\n    =======\\n\\n    int | None :\\n        If the primitive root exists, return the primitive root of ``p``.\\n        If not, return None.\\n\\n    Raises\\n    ======\\n\\n    ValueError\\n        If `p \\\\le 1` or ``p`` is not an integer.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import primitive_root\\n    >>> primitive_root(19)\\n    2\\n    >>> primitive_root(21) is None\\n    True\\n    >>> primitive_root(50, smallest=False)\\n    27\\n\\n    See Also\\n    ========\\n\\n    is_primitive_root\\n\\n    References\\n    ==========\\n\\n    .. [1] W. Stein \"Elementary Number Theory\" (2011), page 44\\n    .. [2] P. Hackman \"Elementary Number Theory\" (2009), Chapter C\\n\\n    '\n    p = as_int(p)\n    if p <= 1:\n        raise ValueError('p should be an integer greater than 1')\n    if p <= 4:\n        return p - 1\n    p_even = p % 2 == 0\n    if not p_even:\n        q = p\n    elif p % 4:\n        q = p // 2\n    else:\n        return None\n    if isprime(q):\n        e = 1\n    else:\n        m = _perfect_power(q, 3)\n        if not m:\n            return None\n        (q, e) = m\n        if not isprime(q):\n            return None\n    if not smallest:\n        if p_even:\n            return next(_primitive_root_prime_power2_iter(q, e))\n        return next(_primitive_root_prime_power_iter(q, e))\n    if p_even:\n        for i in range(3, p, 2):\n            if i % q and is_primitive_root(i, p):\n                return i\n    g = next(_primitive_root_prime_iter(q))\n    if e == 1 or pow(g, q - 1, q ** 2) != 1:\n        return g\n    for i in range(g + 1, p):\n        if i % q and is_primitive_root(i, p):\n            return i",
            "def primitive_root(p, smallest=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ' Returns a primitive root of ``p`` or None.\\n\\n    Explanation\\n    ===========\\n\\n    For the definition of primitive root,\\n    see the explanation of ``is_primitive_root``.\\n\\n    The primitive root of ``p`` exist only for\\n    `p = 2, 4, q^e, 2q^e` (``q`` is an odd prime).\\n    Now, if we know the primitive root of ``q``,\\n    we can calculate the primitive root of `q^e`,\\n    and if we know the primitive root of `q^e`,\\n    we can calculate the primitive root of `2q^e`.\\n    When there is no need to find the smallest primitive root,\\n    this property can be used to obtain a fast primitive root.\\n    On the other hand, when we want the smallest primitive root,\\n    we naively determine whether it is a primitive root or not.\\n\\n    Parameters\\n    ==========\\n\\n    p : integer, p > 1\\n    smallest : if True the smallest primitive root is returned or None\\n\\n    Returns\\n    =======\\n\\n    int | None :\\n        If the primitive root exists, return the primitive root of ``p``.\\n        If not, return None.\\n\\n    Raises\\n    ======\\n\\n    ValueError\\n        If `p \\\\le 1` or ``p`` is not an integer.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import primitive_root\\n    >>> primitive_root(19)\\n    2\\n    >>> primitive_root(21) is None\\n    True\\n    >>> primitive_root(50, smallest=False)\\n    27\\n\\n    See Also\\n    ========\\n\\n    is_primitive_root\\n\\n    References\\n    ==========\\n\\n    .. [1] W. Stein \"Elementary Number Theory\" (2011), page 44\\n    .. [2] P. Hackman \"Elementary Number Theory\" (2009), Chapter C\\n\\n    '\n    p = as_int(p)\n    if p <= 1:\n        raise ValueError('p should be an integer greater than 1')\n    if p <= 4:\n        return p - 1\n    p_even = p % 2 == 0\n    if not p_even:\n        q = p\n    elif p % 4:\n        q = p // 2\n    else:\n        return None\n    if isprime(q):\n        e = 1\n    else:\n        m = _perfect_power(q, 3)\n        if not m:\n            return None\n        (q, e) = m\n        if not isprime(q):\n            return None\n    if not smallest:\n        if p_even:\n            return next(_primitive_root_prime_power2_iter(q, e))\n        return next(_primitive_root_prime_power_iter(q, e))\n    if p_even:\n        for i in range(3, p, 2):\n            if i % q and is_primitive_root(i, p):\n                return i\n    g = next(_primitive_root_prime_iter(q))\n    if e == 1 or pow(g, q - 1, q ** 2) != 1:\n        return g\n    for i in range(g + 1, p):\n        if i % q and is_primitive_root(i, p):\n            return i"
        ]
    },
    {
        "func_name": "is_primitive_root",
        "original": "def is_primitive_root(a, p):\n    \"\"\" Returns True if ``a`` is a primitive root of ``p``.\n\n    Explanation\n    ===========\n\n    ``a`` is said to be the primitive root of ``p`` if `\\\\gcd(a, p) = 1` and\n    `\\\\phi(p)` is the smallest positive number s.t.\n\n        `a^{\\\\phi(p)} \\\\equiv 1 \\\\pmod{p}`.\n\n    where `\\\\phi(p)` is Euler's totient function.\n\n    The primitive root of ``p`` exist only for\n    `p = 2, 4, q^e, 2q^e` (``q`` is an odd prime).\n    Hence, if it is not such a ``p``, it returns False.\n    To determine the primitive root, we need to know\n    the prime factorization of ``q-1``.\n    The hardness of the determination depends on this complexity.\n\n    Parameters\n    ==========\n\n    a : integer\n    p : integer, ``p`` > 1. ``a`` and ``p`` should be relatively prime\n\n    Returns\n    =======\n\n    bool : If True, ``a`` is the primitive root of ``p``.\n\n    Raises\n    ======\n\n    ValueError\n        If `p \\\\le 1` or `\\\\gcd(a, p) \\\\neq 1`.\n        If ``a`` or ``p`` is not an integer.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory import is_primitive_root, n_order, totient\n    >>> is_primitive_root(3, 10)\n    True\n    >>> is_primitive_root(9, 10)\n    False\n    >>> n_order(3, 10) == totient(10)\n    True\n    >>> n_order(9, 10) == totient(10)\n    False\n\n    See Also\n    ========\n\n    primitive_root\n\n    \"\"\"\n    (a, p) = (as_int(a), as_int(p))\n    if p <= 1:\n        raise ValueError('p should be an integer greater than 1')\n    a = a % p\n    if gcd(a, p) != 1:\n        raise ValueError('The two numbers should be relatively prime')\n    if p <= 4:\n        return a == p - 1\n    if p % 2:\n        q = p\n    elif p % 4:\n        q = p // 2\n    else:\n        return False\n    if isprime(q):\n        group_order = q - 1\n        factors = factorint(q - 1).keys()\n    else:\n        m = _perfect_power(q, 3)\n        if not m:\n            return False\n        (q, e) = m\n        if not isprime(q):\n            return False\n        group_order = q ** (e - 1) * (q - 1)\n        factors = set(factorint(q - 1).keys())\n        factors.add(q)\n    return all((pow(a, group_order // prime, p) != 1 for prime in factors))",
        "mutated": [
            "def is_primitive_root(a, p):\n    if False:\n        i = 10\n    \" Returns True if ``a`` is a primitive root of ``p``.\\n\\n    Explanation\\n    ===========\\n\\n    ``a`` is said to be the primitive root of ``p`` if `\\\\gcd(a, p) = 1` and\\n    `\\\\phi(p)` is the smallest positive number s.t.\\n\\n        `a^{\\\\phi(p)} \\\\equiv 1 \\\\pmod{p}`.\\n\\n    where `\\\\phi(p)` is Euler's totient function.\\n\\n    The primitive root of ``p`` exist only for\\n    `p = 2, 4, q^e, 2q^e` (``q`` is an odd prime).\\n    Hence, if it is not such a ``p``, it returns False.\\n    To determine the primitive root, we need to know\\n    the prime factorization of ``q-1``.\\n    The hardness of the determination depends on this complexity.\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    p : integer, ``p`` > 1. ``a`` and ``p`` should be relatively prime\\n\\n    Returns\\n    =======\\n\\n    bool : If True, ``a`` is the primitive root of ``p``.\\n\\n    Raises\\n    ======\\n\\n    ValueError\\n        If `p \\\\le 1` or `\\\\gcd(a, p) \\\\neq 1`.\\n        If ``a`` or ``p`` is not an integer.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import is_primitive_root, n_order, totient\\n    >>> is_primitive_root(3, 10)\\n    True\\n    >>> is_primitive_root(9, 10)\\n    False\\n    >>> n_order(3, 10) == totient(10)\\n    True\\n    >>> n_order(9, 10) == totient(10)\\n    False\\n\\n    See Also\\n    ========\\n\\n    primitive_root\\n\\n    \"\n    (a, p) = (as_int(a), as_int(p))\n    if p <= 1:\n        raise ValueError('p should be an integer greater than 1')\n    a = a % p\n    if gcd(a, p) != 1:\n        raise ValueError('The two numbers should be relatively prime')\n    if p <= 4:\n        return a == p - 1\n    if p % 2:\n        q = p\n    elif p % 4:\n        q = p // 2\n    else:\n        return False\n    if isprime(q):\n        group_order = q - 1\n        factors = factorint(q - 1).keys()\n    else:\n        m = _perfect_power(q, 3)\n        if not m:\n            return False\n        (q, e) = m\n        if not isprime(q):\n            return False\n        group_order = q ** (e - 1) * (q - 1)\n        factors = set(factorint(q - 1).keys())\n        factors.add(q)\n    return all((pow(a, group_order // prime, p) != 1 for prime in factors))",
            "def is_primitive_root(a, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \" Returns True if ``a`` is a primitive root of ``p``.\\n\\n    Explanation\\n    ===========\\n\\n    ``a`` is said to be the primitive root of ``p`` if `\\\\gcd(a, p) = 1` and\\n    `\\\\phi(p)` is the smallest positive number s.t.\\n\\n        `a^{\\\\phi(p)} \\\\equiv 1 \\\\pmod{p}`.\\n\\n    where `\\\\phi(p)` is Euler's totient function.\\n\\n    The primitive root of ``p`` exist only for\\n    `p = 2, 4, q^e, 2q^e` (``q`` is an odd prime).\\n    Hence, if it is not such a ``p``, it returns False.\\n    To determine the primitive root, we need to know\\n    the prime factorization of ``q-1``.\\n    The hardness of the determination depends on this complexity.\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    p : integer, ``p`` > 1. ``a`` and ``p`` should be relatively prime\\n\\n    Returns\\n    =======\\n\\n    bool : If True, ``a`` is the primitive root of ``p``.\\n\\n    Raises\\n    ======\\n\\n    ValueError\\n        If `p \\\\le 1` or `\\\\gcd(a, p) \\\\neq 1`.\\n        If ``a`` or ``p`` is not an integer.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import is_primitive_root, n_order, totient\\n    >>> is_primitive_root(3, 10)\\n    True\\n    >>> is_primitive_root(9, 10)\\n    False\\n    >>> n_order(3, 10) == totient(10)\\n    True\\n    >>> n_order(9, 10) == totient(10)\\n    False\\n\\n    See Also\\n    ========\\n\\n    primitive_root\\n\\n    \"\n    (a, p) = (as_int(a), as_int(p))\n    if p <= 1:\n        raise ValueError('p should be an integer greater than 1')\n    a = a % p\n    if gcd(a, p) != 1:\n        raise ValueError('The two numbers should be relatively prime')\n    if p <= 4:\n        return a == p - 1\n    if p % 2:\n        q = p\n    elif p % 4:\n        q = p // 2\n    else:\n        return False\n    if isprime(q):\n        group_order = q - 1\n        factors = factorint(q - 1).keys()\n    else:\n        m = _perfect_power(q, 3)\n        if not m:\n            return False\n        (q, e) = m\n        if not isprime(q):\n            return False\n        group_order = q ** (e - 1) * (q - 1)\n        factors = set(factorint(q - 1).keys())\n        factors.add(q)\n    return all((pow(a, group_order // prime, p) != 1 for prime in factors))",
            "def is_primitive_root(a, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \" Returns True if ``a`` is a primitive root of ``p``.\\n\\n    Explanation\\n    ===========\\n\\n    ``a`` is said to be the primitive root of ``p`` if `\\\\gcd(a, p) = 1` and\\n    `\\\\phi(p)` is the smallest positive number s.t.\\n\\n        `a^{\\\\phi(p)} \\\\equiv 1 \\\\pmod{p}`.\\n\\n    where `\\\\phi(p)` is Euler's totient function.\\n\\n    The primitive root of ``p`` exist only for\\n    `p = 2, 4, q^e, 2q^e` (``q`` is an odd prime).\\n    Hence, if it is not such a ``p``, it returns False.\\n    To determine the primitive root, we need to know\\n    the prime factorization of ``q-1``.\\n    The hardness of the determination depends on this complexity.\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    p : integer, ``p`` > 1. ``a`` and ``p`` should be relatively prime\\n\\n    Returns\\n    =======\\n\\n    bool : If True, ``a`` is the primitive root of ``p``.\\n\\n    Raises\\n    ======\\n\\n    ValueError\\n        If `p \\\\le 1` or `\\\\gcd(a, p) \\\\neq 1`.\\n        If ``a`` or ``p`` is not an integer.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import is_primitive_root, n_order, totient\\n    >>> is_primitive_root(3, 10)\\n    True\\n    >>> is_primitive_root(9, 10)\\n    False\\n    >>> n_order(3, 10) == totient(10)\\n    True\\n    >>> n_order(9, 10) == totient(10)\\n    False\\n\\n    See Also\\n    ========\\n\\n    primitive_root\\n\\n    \"\n    (a, p) = (as_int(a), as_int(p))\n    if p <= 1:\n        raise ValueError('p should be an integer greater than 1')\n    a = a % p\n    if gcd(a, p) != 1:\n        raise ValueError('The two numbers should be relatively prime')\n    if p <= 4:\n        return a == p - 1\n    if p % 2:\n        q = p\n    elif p % 4:\n        q = p // 2\n    else:\n        return False\n    if isprime(q):\n        group_order = q - 1\n        factors = factorint(q - 1).keys()\n    else:\n        m = _perfect_power(q, 3)\n        if not m:\n            return False\n        (q, e) = m\n        if not isprime(q):\n            return False\n        group_order = q ** (e - 1) * (q - 1)\n        factors = set(factorint(q - 1).keys())\n        factors.add(q)\n    return all((pow(a, group_order // prime, p) != 1 for prime in factors))",
            "def is_primitive_root(a, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \" Returns True if ``a`` is a primitive root of ``p``.\\n\\n    Explanation\\n    ===========\\n\\n    ``a`` is said to be the primitive root of ``p`` if `\\\\gcd(a, p) = 1` and\\n    `\\\\phi(p)` is the smallest positive number s.t.\\n\\n        `a^{\\\\phi(p)} \\\\equiv 1 \\\\pmod{p}`.\\n\\n    where `\\\\phi(p)` is Euler's totient function.\\n\\n    The primitive root of ``p`` exist only for\\n    `p = 2, 4, q^e, 2q^e` (``q`` is an odd prime).\\n    Hence, if it is not such a ``p``, it returns False.\\n    To determine the primitive root, we need to know\\n    the prime factorization of ``q-1``.\\n    The hardness of the determination depends on this complexity.\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    p : integer, ``p`` > 1. ``a`` and ``p`` should be relatively prime\\n\\n    Returns\\n    =======\\n\\n    bool : If True, ``a`` is the primitive root of ``p``.\\n\\n    Raises\\n    ======\\n\\n    ValueError\\n        If `p \\\\le 1` or `\\\\gcd(a, p) \\\\neq 1`.\\n        If ``a`` or ``p`` is not an integer.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import is_primitive_root, n_order, totient\\n    >>> is_primitive_root(3, 10)\\n    True\\n    >>> is_primitive_root(9, 10)\\n    False\\n    >>> n_order(3, 10) == totient(10)\\n    True\\n    >>> n_order(9, 10) == totient(10)\\n    False\\n\\n    See Also\\n    ========\\n\\n    primitive_root\\n\\n    \"\n    (a, p) = (as_int(a), as_int(p))\n    if p <= 1:\n        raise ValueError('p should be an integer greater than 1')\n    a = a % p\n    if gcd(a, p) != 1:\n        raise ValueError('The two numbers should be relatively prime')\n    if p <= 4:\n        return a == p - 1\n    if p % 2:\n        q = p\n    elif p % 4:\n        q = p // 2\n    else:\n        return False\n    if isprime(q):\n        group_order = q - 1\n        factors = factorint(q - 1).keys()\n    else:\n        m = _perfect_power(q, 3)\n        if not m:\n            return False\n        (q, e) = m\n        if not isprime(q):\n            return False\n        group_order = q ** (e - 1) * (q - 1)\n        factors = set(factorint(q - 1).keys())\n        factors.add(q)\n    return all((pow(a, group_order // prime, p) != 1 for prime in factors))",
            "def is_primitive_root(a, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \" Returns True if ``a`` is a primitive root of ``p``.\\n\\n    Explanation\\n    ===========\\n\\n    ``a`` is said to be the primitive root of ``p`` if `\\\\gcd(a, p) = 1` and\\n    `\\\\phi(p)` is the smallest positive number s.t.\\n\\n        `a^{\\\\phi(p)} \\\\equiv 1 \\\\pmod{p}`.\\n\\n    where `\\\\phi(p)` is Euler's totient function.\\n\\n    The primitive root of ``p`` exist only for\\n    `p = 2, 4, q^e, 2q^e` (``q`` is an odd prime).\\n    Hence, if it is not such a ``p``, it returns False.\\n    To determine the primitive root, we need to know\\n    the prime factorization of ``q-1``.\\n    The hardness of the determination depends on this complexity.\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    p : integer, ``p`` > 1. ``a`` and ``p`` should be relatively prime\\n\\n    Returns\\n    =======\\n\\n    bool : If True, ``a`` is the primitive root of ``p``.\\n\\n    Raises\\n    ======\\n\\n    ValueError\\n        If `p \\\\le 1` or `\\\\gcd(a, p) \\\\neq 1`.\\n        If ``a`` or ``p`` is not an integer.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import is_primitive_root, n_order, totient\\n    >>> is_primitive_root(3, 10)\\n    True\\n    >>> is_primitive_root(9, 10)\\n    False\\n    >>> n_order(3, 10) == totient(10)\\n    True\\n    >>> n_order(9, 10) == totient(10)\\n    False\\n\\n    See Also\\n    ========\\n\\n    primitive_root\\n\\n    \"\n    (a, p) = (as_int(a), as_int(p))\n    if p <= 1:\n        raise ValueError('p should be an integer greater than 1')\n    a = a % p\n    if gcd(a, p) != 1:\n        raise ValueError('The two numbers should be relatively prime')\n    if p <= 4:\n        return a == p - 1\n    if p % 2:\n        q = p\n    elif p % 4:\n        q = p // 2\n    else:\n        return False\n    if isprime(q):\n        group_order = q - 1\n        factors = factorint(q - 1).keys()\n    else:\n        m = _perfect_power(q, 3)\n        if not m:\n            return False\n        (q, e) = m\n        if not isprime(q):\n            return False\n        group_order = q ** (e - 1) * (q - 1)\n        factors = set(factorint(q - 1).keys())\n        factors.add(q)\n    return all((pow(a, group_order // prime, p) != 1 for prime in factors))"
        ]
    },
    {
        "func_name": "_sqrt_mod_tonelli_shanks",
        "original": "def _sqrt_mod_tonelli_shanks(a, p):\n    \"\"\"\n    Returns the square root in the case of ``p`` prime with ``p == 1 (mod 8)``\n\n    Assume that the root exists.\n\n    Parameters\n    ==========\n\n    a : int\n    p : int\n        prime number. should be ``p % 8 == 1``\n\n    Returns\n    =======\n\n    int : Generally, there are two roots, but only one is returned.\n          Which one is returned is random.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.residue_ntheory import _sqrt_mod_tonelli_shanks\n    >>> _sqrt_mod_tonelli_shanks(2, 17) in [6, 11]\n    True\n\n    References\n    ==========\n\n    .. [1] Carl Pomerance, Richard Crandall, Prime Numbers: A Computational Perspective,\n           2nd Edition (2005), page 101, ISBN:978-0387252827\n\n    \"\"\"\n    s = bit_scan1(p - 1)\n    t = p >> s\n    if p % 12 == 5:\n        d = 3\n    elif p % 5 in [2, 3]:\n        d = 5\n    else:\n        while 1:\n            d = randint(6, p - 1)\n            if jacobi(d, p) == -1:\n                break\n    A = pow(a, t, p)\n    D = pow(d, t, p)\n    m = 0\n    for i in range(s):\n        adm = A * pow(D, m, p) % p\n        adm = pow(adm, 2 ** (s - 1 - i), p)\n        if adm % p == p - 1:\n            m += 2 ** i\n    x = pow(a, (t + 1) // 2, p) * pow(D, m // 2, p) % p\n    return x",
        "mutated": [
            "def _sqrt_mod_tonelli_shanks(a, p):\n    if False:\n        i = 10\n    '\\n    Returns the square root in the case of ``p`` prime with ``p == 1 (mod 8)``\\n\\n    Assume that the root exists.\\n\\n    Parameters\\n    ==========\\n\\n    a : int\\n    p : int\\n        prime number. should be ``p % 8 == 1``\\n\\n    Returns\\n    =======\\n\\n    int : Generally, there are two roots, but only one is returned.\\n          Which one is returned is random.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _sqrt_mod_tonelli_shanks\\n    >>> _sqrt_mod_tonelli_shanks(2, 17) in [6, 11]\\n    True\\n\\n    References\\n    ==========\\n\\n    .. [1] Carl Pomerance, Richard Crandall, Prime Numbers: A Computational Perspective,\\n           2nd Edition (2005), page 101, ISBN:978-0387252827\\n\\n    '\n    s = bit_scan1(p - 1)\n    t = p >> s\n    if p % 12 == 5:\n        d = 3\n    elif p % 5 in [2, 3]:\n        d = 5\n    else:\n        while 1:\n            d = randint(6, p - 1)\n            if jacobi(d, p) == -1:\n                break\n    A = pow(a, t, p)\n    D = pow(d, t, p)\n    m = 0\n    for i in range(s):\n        adm = A * pow(D, m, p) % p\n        adm = pow(adm, 2 ** (s - 1 - i), p)\n        if adm % p == p - 1:\n            m += 2 ** i\n    x = pow(a, (t + 1) // 2, p) * pow(D, m // 2, p) % p\n    return x",
            "def _sqrt_mod_tonelli_shanks(a, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Returns the square root in the case of ``p`` prime with ``p == 1 (mod 8)``\\n\\n    Assume that the root exists.\\n\\n    Parameters\\n    ==========\\n\\n    a : int\\n    p : int\\n        prime number. should be ``p % 8 == 1``\\n\\n    Returns\\n    =======\\n\\n    int : Generally, there are two roots, but only one is returned.\\n          Which one is returned is random.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _sqrt_mod_tonelli_shanks\\n    >>> _sqrt_mod_tonelli_shanks(2, 17) in [6, 11]\\n    True\\n\\n    References\\n    ==========\\n\\n    .. [1] Carl Pomerance, Richard Crandall, Prime Numbers: A Computational Perspective,\\n           2nd Edition (2005), page 101, ISBN:978-0387252827\\n\\n    '\n    s = bit_scan1(p - 1)\n    t = p >> s\n    if p % 12 == 5:\n        d = 3\n    elif p % 5 in [2, 3]:\n        d = 5\n    else:\n        while 1:\n            d = randint(6, p - 1)\n            if jacobi(d, p) == -1:\n                break\n    A = pow(a, t, p)\n    D = pow(d, t, p)\n    m = 0\n    for i in range(s):\n        adm = A * pow(D, m, p) % p\n        adm = pow(adm, 2 ** (s - 1 - i), p)\n        if adm % p == p - 1:\n            m += 2 ** i\n    x = pow(a, (t + 1) // 2, p) * pow(D, m // 2, p) % p\n    return x",
            "def _sqrt_mod_tonelli_shanks(a, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Returns the square root in the case of ``p`` prime with ``p == 1 (mod 8)``\\n\\n    Assume that the root exists.\\n\\n    Parameters\\n    ==========\\n\\n    a : int\\n    p : int\\n        prime number. should be ``p % 8 == 1``\\n\\n    Returns\\n    =======\\n\\n    int : Generally, there are two roots, but only one is returned.\\n          Which one is returned is random.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _sqrt_mod_tonelli_shanks\\n    >>> _sqrt_mod_tonelli_shanks(2, 17) in [6, 11]\\n    True\\n\\n    References\\n    ==========\\n\\n    .. [1] Carl Pomerance, Richard Crandall, Prime Numbers: A Computational Perspective,\\n           2nd Edition (2005), page 101, ISBN:978-0387252827\\n\\n    '\n    s = bit_scan1(p - 1)\n    t = p >> s\n    if p % 12 == 5:\n        d = 3\n    elif p % 5 in [2, 3]:\n        d = 5\n    else:\n        while 1:\n            d = randint(6, p - 1)\n            if jacobi(d, p) == -1:\n                break\n    A = pow(a, t, p)\n    D = pow(d, t, p)\n    m = 0\n    for i in range(s):\n        adm = A * pow(D, m, p) % p\n        adm = pow(adm, 2 ** (s - 1 - i), p)\n        if adm % p == p - 1:\n            m += 2 ** i\n    x = pow(a, (t + 1) // 2, p) * pow(D, m // 2, p) % p\n    return x",
            "def _sqrt_mod_tonelli_shanks(a, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Returns the square root in the case of ``p`` prime with ``p == 1 (mod 8)``\\n\\n    Assume that the root exists.\\n\\n    Parameters\\n    ==========\\n\\n    a : int\\n    p : int\\n        prime number. should be ``p % 8 == 1``\\n\\n    Returns\\n    =======\\n\\n    int : Generally, there are two roots, but only one is returned.\\n          Which one is returned is random.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _sqrt_mod_tonelli_shanks\\n    >>> _sqrt_mod_tonelli_shanks(2, 17) in [6, 11]\\n    True\\n\\n    References\\n    ==========\\n\\n    .. [1] Carl Pomerance, Richard Crandall, Prime Numbers: A Computational Perspective,\\n           2nd Edition (2005), page 101, ISBN:978-0387252827\\n\\n    '\n    s = bit_scan1(p - 1)\n    t = p >> s\n    if p % 12 == 5:\n        d = 3\n    elif p % 5 in [2, 3]:\n        d = 5\n    else:\n        while 1:\n            d = randint(6, p - 1)\n            if jacobi(d, p) == -1:\n                break\n    A = pow(a, t, p)\n    D = pow(d, t, p)\n    m = 0\n    for i in range(s):\n        adm = A * pow(D, m, p) % p\n        adm = pow(adm, 2 ** (s - 1 - i), p)\n        if adm % p == p - 1:\n            m += 2 ** i\n    x = pow(a, (t + 1) // 2, p) * pow(D, m // 2, p) % p\n    return x",
            "def _sqrt_mod_tonelli_shanks(a, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Returns the square root in the case of ``p`` prime with ``p == 1 (mod 8)``\\n\\n    Assume that the root exists.\\n\\n    Parameters\\n    ==========\\n\\n    a : int\\n    p : int\\n        prime number. should be ``p % 8 == 1``\\n\\n    Returns\\n    =======\\n\\n    int : Generally, there are two roots, but only one is returned.\\n          Which one is returned is random.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _sqrt_mod_tonelli_shanks\\n    >>> _sqrt_mod_tonelli_shanks(2, 17) in [6, 11]\\n    True\\n\\n    References\\n    ==========\\n\\n    .. [1] Carl Pomerance, Richard Crandall, Prime Numbers: A Computational Perspective,\\n           2nd Edition (2005), page 101, ISBN:978-0387252827\\n\\n    '\n    s = bit_scan1(p - 1)\n    t = p >> s\n    if p % 12 == 5:\n        d = 3\n    elif p % 5 in [2, 3]:\n        d = 5\n    else:\n        while 1:\n            d = randint(6, p - 1)\n            if jacobi(d, p) == -1:\n                break\n    A = pow(a, t, p)\n    D = pow(d, t, p)\n    m = 0\n    for i in range(s):\n        adm = A * pow(D, m, p) % p\n        adm = pow(adm, 2 ** (s - 1 - i), p)\n        if adm % p == p - 1:\n            m += 2 ** i\n    x = pow(a, (t + 1) // 2, p) * pow(D, m // 2, p) % p\n    return x"
        ]
    },
    {
        "func_name": "sqrt_mod",
        "original": "def sqrt_mod(a, p, all_roots=False):\n    \"\"\"\n    Find a root of ``x**2 = a mod p``.\n\n    Parameters\n    ==========\n\n    a : integer\n    p : positive integer\n    all_roots : if True the list of roots is returned or None\n\n    Notes\n    =====\n\n    If there is no root it is returned None; else the returned root\n    is less or equal to ``p // 2``; in general is not the smallest one.\n    It is returned ``p // 2`` only if it is the only root.\n\n    Use ``all_roots`` only when it is expected that all the roots fit\n    in memory; otherwise use ``sqrt_mod_iter``.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory import sqrt_mod\n    >>> sqrt_mod(11, 43)\n    21\n    >>> sqrt_mod(17, 32, True)\n    [7, 9, 23, 25]\n    \"\"\"\n    if all_roots:\n        return sorted(sqrt_mod_iter(a, p))\n    p = abs(as_int(p))\n    halfp = p // 2\n    x = None\n    for r in sqrt_mod_iter(a, p):\n        if r < halfp:\n            return r\n        elif r > halfp:\n            return p - r\n        else:\n            x = r\n    return x",
        "mutated": [
            "def sqrt_mod(a, p, all_roots=False):\n    if False:\n        i = 10\n    '\\n    Find a root of ``x**2 = a mod p``.\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    p : positive integer\\n    all_roots : if True the list of roots is returned or None\\n\\n    Notes\\n    =====\\n\\n    If there is no root it is returned None; else the returned root\\n    is less or equal to ``p // 2``; in general is not the smallest one.\\n    It is returned ``p // 2`` only if it is the only root.\\n\\n    Use ``all_roots`` only when it is expected that all the roots fit\\n    in memory; otherwise use ``sqrt_mod_iter``.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import sqrt_mod\\n    >>> sqrt_mod(11, 43)\\n    21\\n    >>> sqrt_mod(17, 32, True)\\n    [7, 9, 23, 25]\\n    '\n    if all_roots:\n        return sorted(sqrt_mod_iter(a, p))\n    p = abs(as_int(p))\n    halfp = p // 2\n    x = None\n    for r in sqrt_mod_iter(a, p):\n        if r < halfp:\n            return r\n        elif r > halfp:\n            return p - r\n        else:\n            x = r\n    return x",
            "def sqrt_mod(a, p, all_roots=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Find a root of ``x**2 = a mod p``.\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    p : positive integer\\n    all_roots : if True the list of roots is returned or None\\n\\n    Notes\\n    =====\\n\\n    If there is no root it is returned None; else the returned root\\n    is less or equal to ``p // 2``; in general is not the smallest one.\\n    It is returned ``p // 2`` only if it is the only root.\\n\\n    Use ``all_roots`` only when it is expected that all the roots fit\\n    in memory; otherwise use ``sqrt_mod_iter``.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import sqrt_mod\\n    >>> sqrt_mod(11, 43)\\n    21\\n    >>> sqrt_mod(17, 32, True)\\n    [7, 9, 23, 25]\\n    '\n    if all_roots:\n        return sorted(sqrt_mod_iter(a, p))\n    p = abs(as_int(p))\n    halfp = p // 2\n    x = None\n    for r in sqrt_mod_iter(a, p):\n        if r < halfp:\n            return r\n        elif r > halfp:\n            return p - r\n        else:\n            x = r\n    return x",
            "def sqrt_mod(a, p, all_roots=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Find a root of ``x**2 = a mod p``.\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    p : positive integer\\n    all_roots : if True the list of roots is returned or None\\n\\n    Notes\\n    =====\\n\\n    If there is no root it is returned None; else the returned root\\n    is less or equal to ``p // 2``; in general is not the smallest one.\\n    It is returned ``p // 2`` only if it is the only root.\\n\\n    Use ``all_roots`` only when it is expected that all the roots fit\\n    in memory; otherwise use ``sqrt_mod_iter``.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import sqrt_mod\\n    >>> sqrt_mod(11, 43)\\n    21\\n    >>> sqrt_mod(17, 32, True)\\n    [7, 9, 23, 25]\\n    '\n    if all_roots:\n        return sorted(sqrt_mod_iter(a, p))\n    p = abs(as_int(p))\n    halfp = p // 2\n    x = None\n    for r in sqrt_mod_iter(a, p):\n        if r < halfp:\n            return r\n        elif r > halfp:\n            return p - r\n        else:\n            x = r\n    return x",
            "def sqrt_mod(a, p, all_roots=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Find a root of ``x**2 = a mod p``.\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    p : positive integer\\n    all_roots : if True the list of roots is returned or None\\n\\n    Notes\\n    =====\\n\\n    If there is no root it is returned None; else the returned root\\n    is less or equal to ``p // 2``; in general is not the smallest one.\\n    It is returned ``p // 2`` only if it is the only root.\\n\\n    Use ``all_roots`` only when it is expected that all the roots fit\\n    in memory; otherwise use ``sqrt_mod_iter``.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import sqrt_mod\\n    >>> sqrt_mod(11, 43)\\n    21\\n    >>> sqrt_mod(17, 32, True)\\n    [7, 9, 23, 25]\\n    '\n    if all_roots:\n        return sorted(sqrt_mod_iter(a, p))\n    p = abs(as_int(p))\n    halfp = p // 2\n    x = None\n    for r in sqrt_mod_iter(a, p):\n        if r < halfp:\n            return r\n        elif r > halfp:\n            return p - r\n        else:\n            x = r\n    return x",
            "def sqrt_mod(a, p, all_roots=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Find a root of ``x**2 = a mod p``.\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    p : positive integer\\n    all_roots : if True the list of roots is returned or None\\n\\n    Notes\\n    =====\\n\\n    If there is no root it is returned None; else the returned root\\n    is less or equal to ``p // 2``; in general is not the smallest one.\\n    It is returned ``p // 2`` only if it is the only root.\\n\\n    Use ``all_roots`` only when it is expected that all the roots fit\\n    in memory; otherwise use ``sqrt_mod_iter``.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import sqrt_mod\\n    >>> sqrt_mod(11, 43)\\n    21\\n    >>> sqrt_mod(17, 32, True)\\n    [7, 9, 23, 25]\\n    '\n    if all_roots:\n        return sorted(sqrt_mod_iter(a, p))\n    p = abs(as_int(p))\n    halfp = p // 2\n    x = None\n    for r in sqrt_mod_iter(a, p):\n        if r < halfp:\n            return r\n        elif r > halfp:\n            return p - r\n        else:\n            x = r\n    return x"
        ]
    },
    {
        "func_name": "sqrt_mod_iter",
        "original": "def sqrt_mod_iter(a, p, domain=int):\n    \"\"\"\n    Iterate over solutions to ``x**2 = a mod p``.\n\n    Parameters\n    ==========\n\n    a : integer\n    p : positive integer\n    domain : integer domain, ``int``, ``ZZ`` or ``Integer``\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.residue_ntheory import sqrt_mod_iter\n    >>> list(sqrt_mod_iter(11, 43))\n    [21, 22]\n\n    See Also\n    ========\n\n    sqrt_mod : Same functionality, but you want a sorted list or only one solution.\n\n    \"\"\"\n    (a, p) = (as_int(a), abs(as_int(p)))\n    v = []\n    pv = []\n    _product = product\n    for (px, ex) in factorint(p).items():\n        if a % px:\n            rx = _sqrt_mod_prime_power(a, px, ex)\n        else:\n            rx = _sqrt_mod1(a, px, ex)\n            _product = iproduct\n        if not rx:\n            return\n        v.append(rx)\n        pv.append(px ** ex)\n    if len(v) == 1:\n        yield from map(domain, v[0])\n    else:\n        (mm, e, s) = gf_crt1(pv, ZZ)\n        for vx in _product(*v):\n            yield domain(gf_crt2(vx, pv, mm, e, s, ZZ))",
        "mutated": [
            "def sqrt_mod_iter(a, p, domain=int):\n    if False:\n        i = 10\n    '\\n    Iterate over solutions to ``x**2 = a mod p``.\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    p : positive integer\\n    domain : integer domain, ``int``, ``ZZ`` or ``Integer``\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import sqrt_mod_iter\\n    >>> list(sqrt_mod_iter(11, 43))\\n    [21, 22]\\n\\n    See Also\\n    ========\\n\\n    sqrt_mod : Same functionality, but you want a sorted list or only one solution.\\n\\n    '\n    (a, p) = (as_int(a), abs(as_int(p)))\n    v = []\n    pv = []\n    _product = product\n    for (px, ex) in factorint(p).items():\n        if a % px:\n            rx = _sqrt_mod_prime_power(a, px, ex)\n        else:\n            rx = _sqrt_mod1(a, px, ex)\n            _product = iproduct\n        if not rx:\n            return\n        v.append(rx)\n        pv.append(px ** ex)\n    if len(v) == 1:\n        yield from map(domain, v[0])\n    else:\n        (mm, e, s) = gf_crt1(pv, ZZ)\n        for vx in _product(*v):\n            yield domain(gf_crt2(vx, pv, mm, e, s, ZZ))",
            "def sqrt_mod_iter(a, p, domain=int):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Iterate over solutions to ``x**2 = a mod p``.\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    p : positive integer\\n    domain : integer domain, ``int``, ``ZZ`` or ``Integer``\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import sqrt_mod_iter\\n    >>> list(sqrt_mod_iter(11, 43))\\n    [21, 22]\\n\\n    See Also\\n    ========\\n\\n    sqrt_mod : Same functionality, but you want a sorted list or only one solution.\\n\\n    '\n    (a, p) = (as_int(a), abs(as_int(p)))\n    v = []\n    pv = []\n    _product = product\n    for (px, ex) in factorint(p).items():\n        if a % px:\n            rx = _sqrt_mod_prime_power(a, px, ex)\n        else:\n            rx = _sqrt_mod1(a, px, ex)\n            _product = iproduct\n        if not rx:\n            return\n        v.append(rx)\n        pv.append(px ** ex)\n    if len(v) == 1:\n        yield from map(domain, v[0])\n    else:\n        (mm, e, s) = gf_crt1(pv, ZZ)\n        for vx in _product(*v):\n            yield domain(gf_crt2(vx, pv, mm, e, s, ZZ))",
            "def sqrt_mod_iter(a, p, domain=int):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Iterate over solutions to ``x**2 = a mod p``.\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    p : positive integer\\n    domain : integer domain, ``int``, ``ZZ`` or ``Integer``\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import sqrt_mod_iter\\n    >>> list(sqrt_mod_iter(11, 43))\\n    [21, 22]\\n\\n    See Also\\n    ========\\n\\n    sqrt_mod : Same functionality, but you want a sorted list or only one solution.\\n\\n    '\n    (a, p) = (as_int(a), abs(as_int(p)))\n    v = []\n    pv = []\n    _product = product\n    for (px, ex) in factorint(p).items():\n        if a % px:\n            rx = _sqrt_mod_prime_power(a, px, ex)\n        else:\n            rx = _sqrt_mod1(a, px, ex)\n            _product = iproduct\n        if not rx:\n            return\n        v.append(rx)\n        pv.append(px ** ex)\n    if len(v) == 1:\n        yield from map(domain, v[0])\n    else:\n        (mm, e, s) = gf_crt1(pv, ZZ)\n        for vx in _product(*v):\n            yield domain(gf_crt2(vx, pv, mm, e, s, ZZ))",
            "def sqrt_mod_iter(a, p, domain=int):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Iterate over solutions to ``x**2 = a mod p``.\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    p : positive integer\\n    domain : integer domain, ``int``, ``ZZ`` or ``Integer``\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import sqrt_mod_iter\\n    >>> list(sqrt_mod_iter(11, 43))\\n    [21, 22]\\n\\n    See Also\\n    ========\\n\\n    sqrt_mod : Same functionality, but you want a sorted list or only one solution.\\n\\n    '\n    (a, p) = (as_int(a), abs(as_int(p)))\n    v = []\n    pv = []\n    _product = product\n    for (px, ex) in factorint(p).items():\n        if a % px:\n            rx = _sqrt_mod_prime_power(a, px, ex)\n        else:\n            rx = _sqrt_mod1(a, px, ex)\n            _product = iproduct\n        if not rx:\n            return\n        v.append(rx)\n        pv.append(px ** ex)\n    if len(v) == 1:\n        yield from map(domain, v[0])\n    else:\n        (mm, e, s) = gf_crt1(pv, ZZ)\n        for vx in _product(*v):\n            yield domain(gf_crt2(vx, pv, mm, e, s, ZZ))",
            "def sqrt_mod_iter(a, p, domain=int):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Iterate over solutions to ``x**2 = a mod p``.\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    p : positive integer\\n    domain : integer domain, ``int``, ``ZZ`` or ``Integer``\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import sqrt_mod_iter\\n    >>> list(sqrt_mod_iter(11, 43))\\n    [21, 22]\\n\\n    See Also\\n    ========\\n\\n    sqrt_mod : Same functionality, but you want a sorted list or only one solution.\\n\\n    '\n    (a, p) = (as_int(a), abs(as_int(p)))\n    v = []\n    pv = []\n    _product = product\n    for (px, ex) in factorint(p).items():\n        if a % px:\n            rx = _sqrt_mod_prime_power(a, px, ex)\n        else:\n            rx = _sqrt_mod1(a, px, ex)\n            _product = iproduct\n        if not rx:\n            return\n        v.append(rx)\n        pv.append(px ** ex)\n    if len(v) == 1:\n        yield from map(domain, v[0])\n    else:\n        (mm, e, s) = gf_crt1(pv, ZZ)\n        for vx in _product(*v):\n            yield domain(gf_crt2(vx, pv, mm, e, s, ZZ))"
        ]
    },
    {
        "func_name": "_sqrt_mod_prime_power",
        "original": "def _sqrt_mod_prime_power(a, p, k):\n    \"\"\"\n    Find the solutions to ``x**2 = a mod p**k`` when ``a % p != 0``.\n    If no solution exists, return ``None``.\n    Solutions are returned in an ascending list.\n\n    Parameters\n    ==========\n\n    a : integer\n    p : prime number\n    k : positive integer\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.residue_ntheory import _sqrt_mod_prime_power\n    >>> _sqrt_mod_prime_power(11, 43, 1)\n    [21, 22]\n\n    References\n    ==========\n\n    .. [1] P. Hackman \"Elementary Number Theory\" (2009), page 160\n    .. [2] http://www.numbertheory.org/php/squareroot.html\n    .. [3] [Gathen99]_\n    \"\"\"\n    pk = p ** k\n    a = a % pk\n    if p == 2:\n        if a % 8 != 1:\n            return None\n        if k <= 3:\n            return list(range(1, pk, 2))\n        r = 1\n        for nx in range(3, k):\n            if (r ** 2 - a >> nx) % 2:\n                r += 1 << nx - 1\n        h = 1 << k - 1\n        return sorted([r, pk - r, (r + h) % pk, -(r + h) % pk])\n    if jacobi(a, p) != 1:\n        return None\n    if p % 4 == 3:\n        res = pow(a, (p + 1) // 4, p)\n    elif p % 8 == 5:\n        res = pow(a, (p + 3) // 8, p)\n        if pow(res, 2, p) != a % p:\n            res = res * pow(2, (p - 1) // 4, p) % p\n    else:\n        res = _sqrt_mod_tonelli_shanks(a, p)\n    if k > 1:\n        px = p\n        for _ in range(k.bit_length() - 1):\n            px = px ** 2\n            frinv = invert(2 * res, px)\n            res = (res - (res ** 2 - a) * frinv) % px\n        if k & k - 1:\n            frinv = invert(2 * res, pk)\n            res = (res - (res ** 2 - a) * frinv) % pk\n    return sorted([res, pk - res])",
        "mutated": [
            "def _sqrt_mod_prime_power(a, p, k):\n    if False:\n        i = 10\n    '\\n    Find the solutions to ``x**2 = a mod p**k`` when ``a % p != 0``.\\n    If no solution exists, return ``None``.\\n    Solutions are returned in an ascending list.\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    p : prime number\\n    k : positive integer\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _sqrt_mod_prime_power\\n    >>> _sqrt_mod_prime_power(11, 43, 1)\\n    [21, 22]\\n\\n    References\\n    ==========\\n\\n    .. [1] P. Hackman \"Elementary Number Theory\" (2009), page 160\\n    .. [2] http://www.numbertheory.org/php/squareroot.html\\n    .. [3] [Gathen99]_\\n    '\n    pk = p ** k\n    a = a % pk\n    if p == 2:\n        if a % 8 != 1:\n            return None\n        if k <= 3:\n            return list(range(1, pk, 2))\n        r = 1\n        for nx in range(3, k):\n            if (r ** 2 - a >> nx) % 2:\n                r += 1 << nx - 1\n        h = 1 << k - 1\n        return sorted([r, pk - r, (r + h) % pk, -(r + h) % pk])\n    if jacobi(a, p) != 1:\n        return None\n    if p % 4 == 3:\n        res = pow(a, (p + 1) // 4, p)\n    elif p % 8 == 5:\n        res = pow(a, (p + 3) // 8, p)\n        if pow(res, 2, p) != a % p:\n            res = res * pow(2, (p - 1) // 4, p) % p\n    else:\n        res = _sqrt_mod_tonelli_shanks(a, p)\n    if k > 1:\n        px = p\n        for _ in range(k.bit_length() - 1):\n            px = px ** 2\n            frinv = invert(2 * res, px)\n            res = (res - (res ** 2 - a) * frinv) % px\n        if k & k - 1:\n            frinv = invert(2 * res, pk)\n            res = (res - (res ** 2 - a) * frinv) % pk\n    return sorted([res, pk - res])",
            "def _sqrt_mod_prime_power(a, p, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Find the solutions to ``x**2 = a mod p**k`` when ``a % p != 0``.\\n    If no solution exists, return ``None``.\\n    Solutions are returned in an ascending list.\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    p : prime number\\n    k : positive integer\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _sqrt_mod_prime_power\\n    >>> _sqrt_mod_prime_power(11, 43, 1)\\n    [21, 22]\\n\\n    References\\n    ==========\\n\\n    .. [1] P. Hackman \"Elementary Number Theory\" (2009), page 160\\n    .. [2] http://www.numbertheory.org/php/squareroot.html\\n    .. [3] [Gathen99]_\\n    '\n    pk = p ** k\n    a = a % pk\n    if p == 2:\n        if a % 8 != 1:\n            return None\n        if k <= 3:\n            return list(range(1, pk, 2))\n        r = 1\n        for nx in range(3, k):\n            if (r ** 2 - a >> nx) % 2:\n                r += 1 << nx - 1\n        h = 1 << k - 1\n        return sorted([r, pk - r, (r + h) % pk, -(r + h) % pk])\n    if jacobi(a, p) != 1:\n        return None\n    if p % 4 == 3:\n        res = pow(a, (p + 1) // 4, p)\n    elif p % 8 == 5:\n        res = pow(a, (p + 3) // 8, p)\n        if pow(res, 2, p) != a % p:\n            res = res * pow(2, (p - 1) // 4, p) % p\n    else:\n        res = _sqrt_mod_tonelli_shanks(a, p)\n    if k > 1:\n        px = p\n        for _ in range(k.bit_length() - 1):\n            px = px ** 2\n            frinv = invert(2 * res, px)\n            res = (res - (res ** 2 - a) * frinv) % px\n        if k & k - 1:\n            frinv = invert(2 * res, pk)\n            res = (res - (res ** 2 - a) * frinv) % pk\n    return sorted([res, pk - res])",
            "def _sqrt_mod_prime_power(a, p, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Find the solutions to ``x**2 = a mod p**k`` when ``a % p != 0``.\\n    If no solution exists, return ``None``.\\n    Solutions are returned in an ascending list.\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    p : prime number\\n    k : positive integer\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _sqrt_mod_prime_power\\n    >>> _sqrt_mod_prime_power(11, 43, 1)\\n    [21, 22]\\n\\n    References\\n    ==========\\n\\n    .. [1] P. Hackman \"Elementary Number Theory\" (2009), page 160\\n    .. [2] http://www.numbertheory.org/php/squareroot.html\\n    .. [3] [Gathen99]_\\n    '\n    pk = p ** k\n    a = a % pk\n    if p == 2:\n        if a % 8 != 1:\n            return None\n        if k <= 3:\n            return list(range(1, pk, 2))\n        r = 1\n        for nx in range(3, k):\n            if (r ** 2 - a >> nx) % 2:\n                r += 1 << nx - 1\n        h = 1 << k - 1\n        return sorted([r, pk - r, (r + h) % pk, -(r + h) % pk])\n    if jacobi(a, p) != 1:\n        return None\n    if p % 4 == 3:\n        res = pow(a, (p + 1) // 4, p)\n    elif p % 8 == 5:\n        res = pow(a, (p + 3) // 8, p)\n        if pow(res, 2, p) != a % p:\n            res = res * pow(2, (p - 1) // 4, p) % p\n    else:\n        res = _sqrt_mod_tonelli_shanks(a, p)\n    if k > 1:\n        px = p\n        for _ in range(k.bit_length() - 1):\n            px = px ** 2\n            frinv = invert(2 * res, px)\n            res = (res - (res ** 2 - a) * frinv) % px\n        if k & k - 1:\n            frinv = invert(2 * res, pk)\n            res = (res - (res ** 2 - a) * frinv) % pk\n    return sorted([res, pk - res])",
            "def _sqrt_mod_prime_power(a, p, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Find the solutions to ``x**2 = a mod p**k`` when ``a % p != 0``.\\n    If no solution exists, return ``None``.\\n    Solutions are returned in an ascending list.\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    p : prime number\\n    k : positive integer\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _sqrt_mod_prime_power\\n    >>> _sqrt_mod_prime_power(11, 43, 1)\\n    [21, 22]\\n\\n    References\\n    ==========\\n\\n    .. [1] P. Hackman \"Elementary Number Theory\" (2009), page 160\\n    .. [2] http://www.numbertheory.org/php/squareroot.html\\n    .. [3] [Gathen99]_\\n    '\n    pk = p ** k\n    a = a % pk\n    if p == 2:\n        if a % 8 != 1:\n            return None\n        if k <= 3:\n            return list(range(1, pk, 2))\n        r = 1\n        for nx in range(3, k):\n            if (r ** 2 - a >> nx) % 2:\n                r += 1 << nx - 1\n        h = 1 << k - 1\n        return sorted([r, pk - r, (r + h) % pk, -(r + h) % pk])\n    if jacobi(a, p) != 1:\n        return None\n    if p % 4 == 3:\n        res = pow(a, (p + 1) // 4, p)\n    elif p % 8 == 5:\n        res = pow(a, (p + 3) // 8, p)\n        if pow(res, 2, p) != a % p:\n            res = res * pow(2, (p - 1) // 4, p) % p\n    else:\n        res = _sqrt_mod_tonelli_shanks(a, p)\n    if k > 1:\n        px = p\n        for _ in range(k.bit_length() - 1):\n            px = px ** 2\n            frinv = invert(2 * res, px)\n            res = (res - (res ** 2 - a) * frinv) % px\n        if k & k - 1:\n            frinv = invert(2 * res, pk)\n            res = (res - (res ** 2 - a) * frinv) % pk\n    return sorted([res, pk - res])",
            "def _sqrt_mod_prime_power(a, p, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Find the solutions to ``x**2 = a mod p**k`` when ``a % p != 0``.\\n    If no solution exists, return ``None``.\\n    Solutions are returned in an ascending list.\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    p : prime number\\n    k : positive integer\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _sqrt_mod_prime_power\\n    >>> _sqrt_mod_prime_power(11, 43, 1)\\n    [21, 22]\\n\\n    References\\n    ==========\\n\\n    .. [1] P. Hackman \"Elementary Number Theory\" (2009), page 160\\n    .. [2] http://www.numbertheory.org/php/squareroot.html\\n    .. [3] [Gathen99]_\\n    '\n    pk = p ** k\n    a = a % pk\n    if p == 2:\n        if a % 8 != 1:\n            return None\n        if k <= 3:\n            return list(range(1, pk, 2))\n        r = 1\n        for nx in range(3, k):\n            if (r ** 2 - a >> nx) % 2:\n                r += 1 << nx - 1\n        h = 1 << k - 1\n        return sorted([r, pk - r, (r + h) % pk, -(r + h) % pk])\n    if jacobi(a, p) != 1:\n        return None\n    if p % 4 == 3:\n        res = pow(a, (p + 1) // 4, p)\n    elif p % 8 == 5:\n        res = pow(a, (p + 3) // 8, p)\n        if pow(res, 2, p) != a % p:\n            res = res * pow(2, (p - 1) // 4, p) % p\n    else:\n        res = _sqrt_mod_tonelli_shanks(a, p)\n    if k > 1:\n        px = p\n        for _ in range(k.bit_length() - 1):\n            px = px ** 2\n            frinv = invert(2 * res, px)\n            res = (res - (res ** 2 - a) * frinv) % px\n        if k & k - 1:\n            frinv = invert(2 * res, pk)\n            res = (res - (res ** 2 - a) * frinv) % pk\n    return sorted([res, pk - res])"
        ]
    },
    {
        "func_name": "_sqrt_mod1",
        "original": "def _sqrt_mod1(a, p, n):\n    \"\"\"\n    Find solution to ``x**2 == a mod p**n`` when ``a % p == 0``.\n    If no solution exists, return ``None``.\n\n    Parameters\n    ==========\n\n    a : integer\n    p : prime number, p must divide a\n    n : positive integer\n\n    References\n    ==========\n\n    .. [1] http://www.numbertheory.org/php/squareroot.html\n    \"\"\"\n    pn = p ** n\n    a = a % pn\n    if a == 0:\n        return range(0, pn, p ** ((n + 1) // 2))\n    (a, r) = remove(a, p)\n    if r % 2 == 1:\n        return None\n    res = _sqrt_mod_prime_power(a, p, n - r)\n    if res is None:\n        return None\n    m = r // 2\n    return (x for rx in res for x in range(rx * p ** m, pn, p ** (n - m)))",
        "mutated": [
            "def _sqrt_mod1(a, p, n):\n    if False:\n        i = 10\n    '\\n    Find solution to ``x**2 == a mod p**n`` when ``a % p == 0``.\\n    If no solution exists, return ``None``.\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    p : prime number, p must divide a\\n    n : positive integer\\n\\n    References\\n    ==========\\n\\n    .. [1] http://www.numbertheory.org/php/squareroot.html\\n    '\n    pn = p ** n\n    a = a % pn\n    if a == 0:\n        return range(0, pn, p ** ((n + 1) // 2))\n    (a, r) = remove(a, p)\n    if r % 2 == 1:\n        return None\n    res = _sqrt_mod_prime_power(a, p, n - r)\n    if res is None:\n        return None\n    m = r // 2\n    return (x for rx in res for x in range(rx * p ** m, pn, p ** (n - m)))",
            "def _sqrt_mod1(a, p, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Find solution to ``x**2 == a mod p**n`` when ``a % p == 0``.\\n    If no solution exists, return ``None``.\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    p : prime number, p must divide a\\n    n : positive integer\\n\\n    References\\n    ==========\\n\\n    .. [1] http://www.numbertheory.org/php/squareroot.html\\n    '\n    pn = p ** n\n    a = a % pn\n    if a == 0:\n        return range(0, pn, p ** ((n + 1) // 2))\n    (a, r) = remove(a, p)\n    if r % 2 == 1:\n        return None\n    res = _sqrt_mod_prime_power(a, p, n - r)\n    if res is None:\n        return None\n    m = r // 2\n    return (x for rx in res for x in range(rx * p ** m, pn, p ** (n - m)))",
            "def _sqrt_mod1(a, p, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Find solution to ``x**2 == a mod p**n`` when ``a % p == 0``.\\n    If no solution exists, return ``None``.\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    p : prime number, p must divide a\\n    n : positive integer\\n\\n    References\\n    ==========\\n\\n    .. [1] http://www.numbertheory.org/php/squareroot.html\\n    '\n    pn = p ** n\n    a = a % pn\n    if a == 0:\n        return range(0, pn, p ** ((n + 1) // 2))\n    (a, r) = remove(a, p)\n    if r % 2 == 1:\n        return None\n    res = _sqrt_mod_prime_power(a, p, n - r)\n    if res is None:\n        return None\n    m = r // 2\n    return (x for rx in res for x in range(rx * p ** m, pn, p ** (n - m)))",
            "def _sqrt_mod1(a, p, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Find solution to ``x**2 == a mod p**n`` when ``a % p == 0``.\\n    If no solution exists, return ``None``.\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    p : prime number, p must divide a\\n    n : positive integer\\n\\n    References\\n    ==========\\n\\n    .. [1] http://www.numbertheory.org/php/squareroot.html\\n    '\n    pn = p ** n\n    a = a % pn\n    if a == 0:\n        return range(0, pn, p ** ((n + 1) // 2))\n    (a, r) = remove(a, p)\n    if r % 2 == 1:\n        return None\n    res = _sqrt_mod_prime_power(a, p, n - r)\n    if res is None:\n        return None\n    m = r // 2\n    return (x for rx in res for x in range(rx * p ** m, pn, p ** (n - m)))",
            "def _sqrt_mod1(a, p, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Find solution to ``x**2 == a mod p**n`` when ``a % p == 0``.\\n    If no solution exists, return ``None``.\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    p : prime number, p must divide a\\n    n : positive integer\\n\\n    References\\n    ==========\\n\\n    .. [1] http://www.numbertheory.org/php/squareroot.html\\n    '\n    pn = p ** n\n    a = a % pn\n    if a == 0:\n        return range(0, pn, p ** ((n + 1) // 2))\n    (a, r) = remove(a, p)\n    if r % 2 == 1:\n        return None\n    res = _sqrt_mod_prime_power(a, p, n - r)\n    if res is None:\n        return None\n    m = r // 2\n    return (x for rx in res for x in range(rx * p ** m, pn, p ** (n - m)))"
        ]
    },
    {
        "func_name": "is_quad_residue",
        "original": "def is_quad_residue(a, p):\n    \"\"\"\n    Returns True if ``a`` (mod ``p``) is in the set of squares mod ``p``,\n    i.e a % p in set([i**2 % p for i in range(p)]).\n\n    Parameters\n    ==========\n\n    a : integer\n    p : positive integer\n\n    Returns\n    =======\n\n    bool : If True, ``x**2 == a (mod p)`` has solution.\n\n    Raises\n    ======\n\n    ValueError\n        If ``a``, ``p`` is not integer.\n        If ``p`` is not positive.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory import is_quad_residue\n    >>> is_quad_residue(21, 100)\n    True\n\n    Indeed, ``pow(39, 2, 100)`` would be 21.\n\n    >>> is_quad_residue(21, 120)\n    False\n\n    That is, for any integer ``x``, ``pow(x, 2, 120)`` is not 21.\n\n    If ``p`` is an odd\n    prime, an iterative method is used to make the determination:\n\n    >>> from sympy.ntheory import is_quad_residue\n    >>> sorted(set([i**2 % 7 for i in range(7)]))\n    [0, 1, 2, 4]\n    >>> [j for j in range(7) if is_quad_residue(j, 7)]\n    [0, 1, 2, 4]\n\n    See Also\n    ========\n\n    legendre_symbol, jacobi_symbol, sqrt_mod\n    \"\"\"\n    (a, p) = (as_int(a), as_int(p))\n    if p < 1:\n        raise ValueError('p must be > 0')\n    a %= p\n    if a < 2 or p < 3:\n        return True\n    t = bit_scan1(p)\n    if t:\n        a_ = a % (1 << t)\n        if a_:\n            r = bit_scan1(a_)\n            if r % 2 or a_ >> r & 6:\n                return False\n        p >>= t\n        a %= p\n        if a < 2 or p < 3:\n            return True\n    j = jacobi(a, p)\n    if j == -1 or isprime(p):\n        return j == 1\n    for (px, ex) in factorint(p).items():\n        if a % px:\n            if jacobi(a, px) != 1:\n                return False\n        else:\n            a_ = a % px ** ex\n            if a_ == 0:\n                continue\n            (a_, r) = remove(a_, px)\n            if r % 2 or jacobi(a_, px) != 1:\n                return False\n    return True",
        "mutated": [
            "def is_quad_residue(a, p):\n    if False:\n        i = 10\n    '\\n    Returns True if ``a`` (mod ``p``) is in the set of squares mod ``p``,\\n    i.e a % p in set([i**2 % p for i in range(p)]).\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    p : positive integer\\n\\n    Returns\\n    =======\\n\\n    bool : If True, ``x**2 == a (mod p)`` has solution.\\n\\n    Raises\\n    ======\\n\\n    ValueError\\n        If ``a``, ``p`` is not integer.\\n        If ``p`` is not positive.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import is_quad_residue\\n    >>> is_quad_residue(21, 100)\\n    True\\n\\n    Indeed, ``pow(39, 2, 100)`` would be 21.\\n\\n    >>> is_quad_residue(21, 120)\\n    False\\n\\n    That is, for any integer ``x``, ``pow(x, 2, 120)`` is not 21.\\n\\n    If ``p`` is an odd\\n    prime, an iterative method is used to make the determination:\\n\\n    >>> from sympy.ntheory import is_quad_residue\\n    >>> sorted(set([i**2 % 7 for i in range(7)]))\\n    [0, 1, 2, 4]\\n    >>> [j for j in range(7) if is_quad_residue(j, 7)]\\n    [0, 1, 2, 4]\\n\\n    See Also\\n    ========\\n\\n    legendre_symbol, jacobi_symbol, sqrt_mod\\n    '\n    (a, p) = (as_int(a), as_int(p))\n    if p < 1:\n        raise ValueError('p must be > 0')\n    a %= p\n    if a < 2 or p < 3:\n        return True\n    t = bit_scan1(p)\n    if t:\n        a_ = a % (1 << t)\n        if a_:\n            r = bit_scan1(a_)\n            if r % 2 or a_ >> r & 6:\n                return False\n        p >>= t\n        a %= p\n        if a < 2 or p < 3:\n            return True\n    j = jacobi(a, p)\n    if j == -1 or isprime(p):\n        return j == 1\n    for (px, ex) in factorint(p).items():\n        if a % px:\n            if jacobi(a, px) != 1:\n                return False\n        else:\n            a_ = a % px ** ex\n            if a_ == 0:\n                continue\n            (a_, r) = remove(a_, px)\n            if r % 2 or jacobi(a_, px) != 1:\n                return False\n    return True",
            "def is_quad_residue(a, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Returns True if ``a`` (mod ``p``) is in the set of squares mod ``p``,\\n    i.e a % p in set([i**2 % p for i in range(p)]).\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    p : positive integer\\n\\n    Returns\\n    =======\\n\\n    bool : If True, ``x**2 == a (mod p)`` has solution.\\n\\n    Raises\\n    ======\\n\\n    ValueError\\n        If ``a``, ``p`` is not integer.\\n        If ``p`` is not positive.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import is_quad_residue\\n    >>> is_quad_residue(21, 100)\\n    True\\n\\n    Indeed, ``pow(39, 2, 100)`` would be 21.\\n\\n    >>> is_quad_residue(21, 120)\\n    False\\n\\n    That is, for any integer ``x``, ``pow(x, 2, 120)`` is not 21.\\n\\n    If ``p`` is an odd\\n    prime, an iterative method is used to make the determination:\\n\\n    >>> from sympy.ntheory import is_quad_residue\\n    >>> sorted(set([i**2 % 7 for i in range(7)]))\\n    [0, 1, 2, 4]\\n    >>> [j for j in range(7) if is_quad_residue(j, 7)]\\n    [0, 1, 2, 4]\\n\\n    See Also\\n    ========\\n\\n    legendre_symbol, jacobi_symbol, sqrt_mod\\n    '\n    (a, p) = (as_int(a), as_int(p))\n    if p < 1:\n        raise ValueError('p must be > 0')\n    a %= p\n    if a < 2 or p < 3:\n        return True\n    t = bit_scan1(p)\n    if t:\n        a_ = a % (1 << t)\n        if a_:\n            r = bit_scan1(a_)\n            if r % 2 or a_ >> r & 6:\n                return False\n        p >>= t\n        a %= p\n        if a < 2 or p < 3:\n            return True\n    j = jacobi(a, p)\n    if j == -1 or isprime(p):\n        return j == 1\n    for (px, ex) in factorint(p).items():\n        if a % px:\n            if jacobi(a, px) != 1:\n                return False\n        else:\n            a_ = a % px ** ex\n            if a_ == 0:\n                continue\n            (a_, r) = remove(a_, px)\n            if r % 2 or jacobi(a_, px) != 1:\n                return False\n    return True",
            "def is_quad_residue(a, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Returns True if ``a`` (mod ``p``) is in the set of squares mod ``p``,\\n    i.e a % p in set([i**2 % p for i in range(p)]).\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    p : positive integer\\n\\n    Returns\\n    =======\\n\\n    bool : If True, ``x**2 == a (mod p)`` has solution.\\n\\n    Raises\\n    ======\\n\\n    ValueError\\n        If ``a``, ``p`` is not integer.\\n        If ``p`` is not positive.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import is_quad_residue\\n    >>> is_quad_residue(21, 100)\\n    True\\n\\n    Indeed, ``pow(39, 2, 100)`` would be 21.\\n\\n    >>> is_quad_residue(21, 120)\\n    False\\n\\n    That is, for any integer ``x``, ``pow(x, 2, 120)`` is not 21.\\n\\n    If ``p`` is an odd\\n    prime, an iterative method is used to make the determination:\\n\\n    >>> from sympy.ntheory import is_quad_residue\\n    >>> sorted(set([i**2 % 7 for i in range(7)]))\\n    [0, 1, 2, 4]\\n    >>> [j for j in range(7) if is_quad_residue(j, 7)]\\n    [0, 1, 2, 4]\\n\\n    See Also\\n    ========\\n\\n    legendre_symbol, jacobi_symbol, sqrt_mod\\n    '\n    (a, p) = (as_int(a), as_int(p))\n    if p < 1:\n        raise ValueError('p must be > 0')\n    a %= p\n    if a < 2 or p < 3:\n        return True\n    t = bit_scan1(p)\n    if t:\n        a_ = a % (1 << t)\n        if a_:\n            r = bit_scan1(a_)\n            if r % 2 or a_ >> r & 6:\n                return False\n        p >>= t\n        a %= p\n        if a < 2 or p < 3:\n            return True\n    j = jacobi(a, p)\n    if j == -1 or isprime(p):\n        return j == 1\n    for (px, ex) in factorint(p).items():\n        if a % px:\n            if jacobi(a, px) != 1:\n                return False\n        else:\n            a_ = a % px ** ex\n            if a_ == 0:\n                continue\n            (a_, r) = remove(a_, px)\n            if r % 2 or jacobi(a_, px) != 1:\n                return False\n    return True",
            "def is_quad_residue(a, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Returns True if ``a`` (mod ``p``) is in the set of squares mod ``p``,\\n    i.e a % p in set([i**2 % p for i in range(p)]).\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    p : positive integer\\n\\n    Returns\\n    =======\\n\\n    bool : If True, ``x**2 == a (mod p)`` has solution.\\n\\n    Raises\\n    ======\\n\\n    ValueError\\n        If ``a``, ``p`` is not integer.\\n        If ``p`` is not positive.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import is_quad_residue\\n    >>> is_quad_residue(21, 100)\\n    True\\n\\n    Indeed, ``pow(39, 2, 100)`` would be 21.\\n\\n    >>> is_quad_residue(21, 120)\\n    False\\n\\n    That is, for any integer ``x``, ``pow(x, 2, 120)`` is not 21.\\n\\n    If ``p`` is an odd\\n    prime, an iterative method is used to make the determination:\\n\\n    >>> from sympy.ntheory import is_quad_residue\\n    >>> sorted(set([i**2 % 7 for i in range(7)]))\\n    [0, 1, 2, 4]\\n    >>> [j for j in range(7) if is_quad_residue(j, 7)]\\n    [0, 1, 2, 4]\\n\\n    See Also\\n    ========\\n\\n    legendre_symbol, jacobi_symbol, sqrt_mod\\n    '\n    (a, p) = (as_int(a), as_int(p))\n    if p < 1:\n        raise ValueError('p must be > 0')\n    a %= p\n    if a < 2 or p < 3:\n        return True\n    t = bit_scan1(p)\n    if t:\n        a_ = a % (1 << t)\n        if a_:\n            r = bit_scan1(a_)\n            if r % 2 or a_ >> r & 6:\n                return False\n        p >>= t\n        a %= p\n        if a < 2 or p < 3:\n            return True\n    j = jacobi(a, p)\n    if j == -1 or isprime(p):\n        return j == 1\n    for (px, ex) in factorint(p).items():\n        if a % px:\n            if jacobi(a, px) != 1:\n                return False\n        else:\n            a_ = a % px ** ex\n            if a_ == 0:\n                continue\n            (a_, r) = remove(a_, px)\n            if r % 2 or jacobi(a_, px) != 1:\n                return False\n    return True",
            "def is_quad_residue(a, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Returns True if ``a`` (mod ``p``) is in the set of squares mod ``p``,\\n    i.e a % p in set([i**2 % p for i in range(p)]).\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    p : positive integer\\n\\n    Returns\\n    =======\\n\\n    bool : If True, ``x**2 == a (mod p)`` has solution.\\n\\n    Raises\\n    ======\\n\\n    ValueError\\n        If ``a``, ``p`` is not integer.\\n        If ``p`` is not positive.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import is_quad_residue\\n    >>> is_quad_residue(21, 100)\\n    True\\n\\n    Indeed, ``pow(39, 2, 100)`` would be 21.\\n\\n    >>> is_quad_residue(21, 120)\\n    False\\n\\n    That is, for any integer ``x``, ``pow(x, 2, 120)`` is not 21.\\n\\n    If ``p`` is an odd\\n    prime, an iterative method is used to make the determination:\\n\\n    >>> from sympy.ntheory import is_quad_residue\\n    >>> sorted(set([i**2 % 7 for i in range(7)]))\\n    [0, 1, 2, 4]\\n    >>> [j for j in range(7) if is_quad_residue(j, 7)]\\n    [0, 1, 2, 4]\\n\\n    See Also\\n    ========\\n\\n    legendre_symbol, jacobi_symbol, sqrt_mod\\n    '\n    (a, p) = (as_int(a), as_int(p))\n    if p < 1:\n        raise ValueError('p must be > 0')\n    a %= p\n    if a < 2 or p < 3:\n        return True\n    t = bit_scan1(p)\n    if t:\n        a_ = a % (1 << t)\n        if a_:\n            r = bit_scan1(a_)\n            if r % 2 or a_ >> r & 6:\n                return False\n        p >>= t\n        a %= p\n        if a < 2 or p < 3:\n            return True\n    j = jacobi(a, p)\n    if j == -1 or isprime(p):\n        return j == 1\n    for (px, ex) in factorint(p).items():\n        if a % px:\n            if jacobi(a, px) != 1:\n                return False\n        else:\n            a_ = a % px ** ex\n            if a_ == 0:\n                continue\n            (a_, r) = remove(a_, px)\n            if r % 2 or jacobi(a_, px) != 1:\n                return False\n    return True"
        ]
    },
    {
        "func_name": "is_nthpow_residue",
        "original": "def is_nthpow_residue(a, n, m):\n    \"\"\"\n    Returns True if ``x**n == a (mod m)`` has solutions.\n\n    References\n    ==========\n\n    .. [1] P. Hackman \"Elementary Number Theory\" (2009), page 76\n\n    \"\"\"\n    a = a % m\n    (a, n, m) = (as_int(a), as_int(n), as_int(m))\n    if m <= 0:\n        raise ValueError('m must be > 0')\n    if n < 0:\n        raise ValueError('n must be >= 0')\n    if n == 0:\n        if m == 1:\n            return False\n        return a == 1\n    if a == 0:\n        return True\n    if n == 1:\n        return True\n    if n == 2:\n        return is_quad_residue(a, m)\n    return all((_is_nthpow_residue_bign_prime_power(a, n, p, e) for (p, e) in factorint(m).items()))",
        "mutated": [
            "def is_nthpow_residue(a, n, m):\n    if False:\n        i = 10\n    '\\n    Returns True if ``x**n == a (mod m)`` has solutions.\\n\\n    References\\n    ==========\\n\\n    .. [1] P. Hackman \"Elementary Number Theory\" (2009), page 76\\n\\n    '\n    a = a % m\n    (a, n, m) = (as_int(a), as_int(n), as_int(m))\n    if m <= 0:\n        raise ValueError('m must be > 0')\n    if n < 0:\n        raise ValueError('n must be >= 0')\n    if n == 0:\n        if m == 1:\n            return False\n        return a == 1\n    if a == 0:\n        return True\n    if n == 1:\n        return True\n    if n == 2:\n        return is_quad_residue(a, m)\n    return all((_is_nthpow_residue_bign_prime_power(a, n, p, e) for (p, e) in factorint(m).items()))",
            "def is_nthpow_residue(a, n, m):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Returns True if ``x**n == a (mod m)`` has solutions.\\n\\n    References\\n    ==========\\n\\n    .. [1] P. Hackman \"Elementary Number Theory\" (2009), page 76\\n\\n    '\n    a = a % m\n    (a, n, m) = (as_int(a), as_int(n), as_int(m))\n    if m <= 0:\n        raise ValueError('m must be > 0')\n    if n < 0:\n        raise ValueError('n must be >= 0')\n    if n == 0:\n        if m == 1:\n            return False\n        return a == 1\n    if a == 0:\n        return True\n    if n == 1:\n        return True\n    if n == 2:\n        return is_quad_residue(a, m)\n    return all((_is_nthpow_residue_bign_prime_power(a, n, p, e) for (p, e) in factorint(m).items()))",
            "def is_nthpow_residue(a, n, m):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Returns True if ``x**n == a (mod m)`` has solutions.\\n\\n    References\\n    ==========\\n\\n    .. [1] P. Hackman \"Elementary Number Theory\" (2009), page 76\\n\\n    '\n    a = a % m\n    (a, n, m) = (as_int(a), as_int(n), as_int(m))\n    if m <= 0:\n        raise ValueError('m must be > 0')\n    if n < 0:\n        raise ValueError('n must be >= 0')\n    if n == 0:\n        if m == 1:\n            return False\n        return a == 1\n    if a == 0:\n        return True\n    if n == 1:\n        return True\n    if n == 2:\n        return is_quad_residue(a, m)\n    return all((_is_nthpow_residue_bign_prime_power(a, n, p, e) for (p, e) in factorint(m).items()))",
            "def is_nthpow_residue(a, n, m):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Returns True if ``x**n == a (mod m)`` has solutions.\\n\\n    References\\n    ==========\\n\\n    .. [1] P. Hackman \"Elementary Number Theory\" (2009), page 76\\n\\n    '\n    a = a % m\n    (a, n, m) = (as_int(a), as_int(n), as_int(m))\n    if m <= 0:\n        raise ValueError('m must be > 0')\n    if n < 0:\n        raise ValueError('n must be >= 0')\n    if n == 0:\n        if m == 1:\n            return False\n        return a == 1\n    if a == 0:\n        return True\n    if n == 1:\n        return True\n    if n == 2:\n        return is_quad_residue(a, m)\n    return all((_is_nthpow_residue_bign_prime_power(a, n, p, e) for (p, e) in factorint(m).items()))",
            "def is_nthpow_residue(a, n, m):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Returns True if ``x**n == a (mod m)`` has solutions.\\n\\n    References\\n    ==========\\n\\n    .. [1] P. Hackman \"Elementary Number Theory\" (2009), page 76\\n\\n    '\n    a = a % m\n    (a, n, m) = (as_int(a), as_int(n), as_int(m))\n    if m <= 0:\n        raise ValueError('m must be > 0')\n    if n < 0:\n        raise ValueError('n must be >= 0')\n    if n == 0:\n        if m == 1:\n            return False\n        return a == 1\n    if a == 0:\n        return True\n    if n == 1:\n        return True\n    if n == 2:\n        return is_quad_residue(a, m)\n    return all((_is_nthpow_residue_bign_prime_power(a, n, p, e) for (p, e) in factorint(m).items()))"
        ]
    },
    {
        "func_name": "_is_nthpow_residue_bign_prime_power",
        "original": "def _is_nthpow_residue_bign_prime_power(a, n, p, k):\n    \"\"\"\n    Returns True if `x^n = a \\\\pmod{p^k}` has solutions for `n > 2`.\n\n    Parameters\n    ==========\n\n    a : positive integer\n    n : integer, n > 2\n    p : prime number\n    k : positive integer\n\n    \"\"\"\n    while a % p == 0:\n        a %= pow(p, k)\n        if not a:\n            return True\n        (a, mu) = remove(a, p)\n        if mu % n:\n            return False\n        k -= mu\n    if p != 2:\n        f = p ** (k - 1) * (p - 1)\n        return pow(a, f // gcd(f, n), pow(p, k)) == 1\n    if n & 1:\n        return True\n    c = min(bit_scan1(n) + 2, k)\n    return a % pow(2, c) == 1",
        "mutated": [
            "def _is_nthpow_residue_bign_prime_power(a, n, p, k):\n    if False:\n        i = 10\n    '\\n    Returns True if `x^n = a \\\\pmod{p^k}` has solutions for `n > 2`.\\n\\n    Parameters\\n    ==========\\n\\n    a : positive integer\\n    n : integer, n > 2\\n    p : prime number\\n    k : positive integer\\n\\n    '\n    while a % p == 0:\n        a %= pow(p, k)\n        if not a:\n            return True\n        (a, mu) = remove(a, p)\n        if mu % n:\n            return False\n        k -= mu\n    if p != 2:\n        f = p ** (k - 1) * (p - 1)\n        return pow(a, f // gcd(f, n), pow(p, k)) == 1\n    if n & 1:\n        return True\n    c = min(bit_scan1(n) + 2, k)\n    return a % pow(2, c) == 1",
            "def _is_nthpow_residue_bign_prime_power(a, n, p, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Returns True if `x^n = a \\\\pmod{p^k}` has solutions for `n > 2`.\\n\\n    Parameters\\n    ==========\\n\\n    a : positive integer\\n    n : integer, n > 2\\n    p : prime number\\n    k : positive integer\\n\\n    '\n    while a % p == 0:\n        a %= pow(p, k)\n        if not a:\n            return True\n        (a, mu) = remove(a, p)\n        if mu % n:\n            return False\n        k -= mu\n    if p != 2:\n        f = p ** (k - 1) * (p - 1)\n        return pow(a, f // gcd(f, n), pow(p, k)) == 1\n    if n & 1:\n        return True\n    c = min(bit_scan1(n) + 2, k)\n    return a % pow(2, c) == 1",
            "def _is_nthpow_residue_bign_prime_power(a, n, p, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Returns True if `x^n = a \\\\pmod{p^k}` has solutions for `n > 2`.\\n\\n    Parameters\\n    ==========\\n\\n    a : positive integer\\n    n : integer, n > 2\\n    p : prime number\\n    k : positive integer\\n\\n    '\n    while a % p == 0:\n        a %= pow(p, k)\n        if not a:\n            return True\n        (a, mu) = remove(a, p)\n        if mu % n:\n            return False\n        k -= mu\n    if p != 2:\n        f = p ** (k - 1) * (p - 1)\n        return pow(a, f // gcd(f, n), pow(p, k)) == 1\n    if n & 1:\n        return True\n    c = min(bit_scan1(n) + 2, k)\n    return a % pow(2, c) == 1",
            "def _is_nthpow_residue_bign_prime_power(a, n, p, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Returns True if `x^n = a \\\\pmod{p^k}` has solutions for `n > 2`.\\n\\n    Parameters\\n    ==========\\n\\n    a : positive integer\\n    n : integer, n > 2\\n    p : prime number\\n    k : positive integer\\n\\n    '\n    while a % p == 0:\n        a %= pow(p, k)\n        if not a:\n            return True\n        (a, mu) = remove(a, p)\n        if mu % n:\n            return False\n        k -= mu\n    if p != 2:\n        f = p ** (k - 1) * (p - 1)\n        return pow(a, f // gcd(f, n), pow(p, k)) == 1\n    if n & 1:\n        return True\n    c = min(bit_scan1(n) + 2, k)\n    return a % pow(2, c) == 1",
            "def _is_nthpow_residue_bign_prime_power(a, n, p, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Returns True if `x^n = a \\\\pmod{p^k}` has solutions for `n > 2`.\\n\\n    Parameters\\n    ==========\\n\\n    a : positive integer\\n    n : integer, n > 2\\n    p : prime number\\n    k : positive integer\\n\\n    '\n    while a % p == 0:\n        a %= pow(p, k)\n        if not a:\n            return True\n        (a, mu) = remove(a, p)\n        if mu % n:\n            return False\n        k -= mu\n    if p != 2:\n        f = p ** (k - 1) * (p - 1)\n        return pow(a, f // gcd(f, n), pow(p, k)) == 1\n    if n & 1:\n        return True\n    c = min(bit_scan1(n) + 2, k)\n    return a % pow(2, c) == 1"
        ]
    },
    {
        "func_name": "_nthroot_mod1",
        "original": "def _nthroot_mod1(s, q, p, all_roots):\n    \"\"\"\n    Root of ``x**q = s mod p``, ``p`` prime and ``q`` divides ``p - 1``.\n    Assume that the root exists.\n\n    Parameters\n    ==========\n\n    s : integer\n    q : integer, n > 2. ``q`` divides ``p - 1``.\n    p : prime number\n    all_roots : if False returns the smallest root, else the list of roots\n\n    Returns\n    =======\n\n    list[int] | int :\n        Root of ``x**q = s mod p``. If ``all_roots == True``,\n        returned ascending list. otherwise, returned an int.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.residue_ntheory import _nthroot_mod1\n    >>> _nthroot_mod1(5, 3, 13, False)\n    7\n    >>> _nthroot_mod1(13, 4, 17, True)\n    [3, 5, 12, 14]\n\n    References\n    ==========\n\n    .. [1] A. M. Johnston, A Generalized qth Root Algorithm,\n           ACM-SIAM Symposium on Discrete Algorithms (1999), pp. 929-930\n\n    \"\"\"\n    g = next(_primitive_root_prime_iter(p))\n    r = s\n    for (qx, ex) in factorint(q).items():\n        f = (p - 1) // qx ** ex\n        while f % qx == 0:\n            f //= qx\n        z = f * invert(-f, qx)\n        x = (1 + z) // qx\n        t = discrete_log(p, pow(r, f, p), pow(g, f * qx, p))\n        for _ in range(ex):\n            r = pow(r, x, p) * pow(g, -z * t % (p - 1), p) % p\n            t //= qx\n    res = [r]\n    h = pow(g, (p - 1) // q, p)\n    hx = r\n    for _ in range(q - 1):\n        hx = hx * h % p\n        res.append(hx)\n    if all_roots:\n        res.sort()\n        return res\n    return min(res)",
        "mutated": [
            "def _nthroot_mod1(s, q, p, all_roots):\n    if False:\n        i = 10\n    '\\n    Root of ``x**q = s mod p``, ``p`` prime and ``q`` divides ``p - 1``.\\n    Assume that the root exists.\\n\\n    Parameters\\n    ==========\\n\\n    s : integer\\n    q : integer, n > 2. ``q`` divides ``p - 1``.\\n    p : prime number\\n    all_roots : if False returns the smallest root, else the list of roots\\n\\n    Returns\\n    =======\\n\\n    list[int] | int :\\n        Root of ``x**q = s mod p``. If ``all_roots == True``,\\n        returned ascending list. otherwise, returned an int.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _nthroot_mod1\\n    >>> _nthroot_mod1(5, 3, 13, False)\\n    7\\n    >>> _nthroot_mod1(13, 4, 17, True)\\n    [3, 5, 12, 14]\\n\\n    References\\n    ==========\\n\\n    .. [1] A. M. Johnston, A Generalized qth Root Algorithm,\\n           ACM-SIAM Symposium on Discrete Algorithms (1999), pp. 929-930\\n\\n    '\n    g = next(_primitive_root_prime_iter(p))\n    r = s\n    for (qx, ex) in factorint(q).items():\n        f = (p - 1) // qx ** ex\n        while f % qx == 0:\n            f //= qx\n        z = f * invert(-f, qx)\n        x = (1 + z) // qx\n        t = discrete_log(p, pow(r, f, p), pow(g, f * qx, p))\n        for _ in range(ex):\n            r = pow(r, x, p) * pow(g, -z * t % (p - 1), p) % p\n            t //= qx\n    res = [r]\n    h = pow(g, (p - 1) // q, p)\n    hx = r\n    for _ in range(q - 1):\n        hx = hx * h % p\n        res.append(hx)\n    if all_roots:\n        res.sort()\n        return res\n    return min(res)",
            "def _nthroot_mod1(s, q, p, all_roots):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Root of ``x**q = s mod p``, ``p`` prime and ``q`` divides ``p - 1``.\\n    Assume that the root exists.\\n\\n    Parameters\\n    ==========\\n\\n    s : integer\\n    q : integer, n > 2. ``q`` divides ``p - 1``.\\n    p : prime number\\n    all_roots : if False returns the smallest root, else the list of roots\\n\\n    Returns\\n    =======\\n\\n    list[int] | int :\\n        Root of ``x**q = s mod p``. If ``all_roots == True``,\\n        returned ascending list. otherwise, returned an int.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _nthroot_mod1\\n    >>> _nthroot_mod1(5, 3, 13, False)\\n    7\\n    >>> _nthroot_mod1(13, 4, 17, True)\\n    [3, 5, 12, 14]\\n\\n    References\\n    ==========\\n\\n    .. [1] A. M. Johnston, A Generalized qth Root Algorithm,\\n           ACM-SIAM Symposium on Discrete Algorithms (1999), pp. 929-930\\n\\n    '\n    g = next(_primitive_root_prime_iter(p))\n    r = s\n    for (qx, ex) in factorint(q).items():\n        f = (p - 1) // qx ** ex\n        while f % qx == 0:\n            f //= qx\n        z = f * invert(-f, qx)\n        x = (1 + z) // qx\n        t = discrete_log(p, pow(r, f, p), pow(g, f * qx, p))\n        for _ in range(ex):\n            r = pow(r, x, p) * pow(g, -z * t % (p - 1), p) % p\n            t //= qx\n    res = [r]\n    h = pow(g, (p - 1) // q, p)\n    hx = r\n    for _ in range(q - 1):\n        hx = hx * h % p\n        res.append(hx)\n    if all_roots:\n        res.sort()\n        return res\n    return min(res)",
            "def _nthroot_mod1(s, q, p, all_roots):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Root of ``x**q = s mod p``, ``p`` prime and ``q`` divides ``p - 1``.\\n    Assume that the root exists.\\n\\n    Parameters\\n    ==========\\n\\n    s : integer\\n    q : integer, n > 2. ``q`` divides ``p - 1``.\\n    p : prime number\\n    all_roots : if False returns the smallest root, else the list of roots\\n\\n    Returns\\n    =======\\n\\n    list[int] | int :\\n        Root of ``x**q = s mod p``. If ``all_roots == True``,\\n        returned ascending list. otherwise, returned an int.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _nthroot_mod1\\n    >>> _nthroot_mod1(5, 3, 13, False)\\n    7\\n    >>> _nthroot_mod1(13, 4, 17, True)\\n    [3, 5, 12, 14]\\n\\n    References\\n    ==========\\n\\n    .. [1] A. M. Johnston, A Generalized qth Root Algorithm,\\n           ACM-SIAM Symposium on Discrete Algorithms (1999), pp. 929-930\\n\\n    '\n    g = next(_primitive_root_prime_iter(p))\n    r = s\n    for (qx, ex) in factorint(q).items():\n        f = (p - 1) // qx ** ex\n        while f % qx == 0:\n            f //= qx\n        z = f * invert(-f, qx)\n        x = (1 + z) // qx\n        t = discrete_log(p, pow(r, f, p), pow(g, f * qx, p))\n        for _ in range(ex):\n            r = pow(r, x, p) * pow(g, -z * t % (p - 1), p) % p\n            t //= qx\n    res = [r]\n    h = pow(g, (p - 1) // q, p)\n    hx = r\n    for _ in range(q - 1):\n        hx = hx * h % p\n        res.append(hx)\n    if all_roots:\n        res.sort()\n        return res\n    return min(res)",
            "def _nthroot_mod1(s, q, p, all_roots):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Root of ``x**q = s mod p``, ``p`` prime and ``q`` divides ``p - 1``.\\n    Assume that the root exists.\\n\\n    Parameters\\n    ==========\\n\\n    s : integer\\n    q : integer, n > 2. ``q`` divides ``p - 1``.\\n    p : prime number\\n    all_roots : if False returns the smallest root, else the list of roots\\n\\n    Returns\\n    =======\\n\\n    list[int] | int :\\n        Root of ``x**q = s mod p``. If ``all_roots == True``,\\n        returned ascending list. otherwise, returned an int.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _nthroot_mod1\\n    >>> _nthroot_mod1(5, 3, 13, False)\\n    7\\n    >>> _nthroot_mod1(13, 4, 17, True)\\n    [3, 5, 12, 14]\\n\\n    References\\n    ==========\\n\\n    .. [1] A. M. Johnston, A Generalized qth Root Algorithm,\\n           ACM-SIAM Symposium on Discrete Algorithms (1999), pp. 929-930\\n\\n    '\n    g = next(_primitive_root_prime_iter(p))\n    r = s\n    for (qx, ex) in factorint(q).items():\n        f = (p - 1) // qx ** ex\n        while f % qx == 0:\n            f //= qx\n        z = f * invert(-f, qx)\n        x = (1 + z) // qx\n        t = discrete_log(p, pow(r, f, p), pow(g, f * qx, p))\n        for _ in range(ex):\n            r = pow(r, x, p) * pow(g, -z * t % (p - 1), p) % p\n            t //= qx\n    res = [r]\n    h = pow(g, (p - 1) // q, p)\n    hx = r\n    for _ in range(q - 1):\n        hx = hx * h % p\n        res.append(hx)\n    if all_roots:\n        res.sort()\n        return res\n    return min(res)",
            "def _nthroot_mod1(s, q, p, all_roots):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Root of ``x**q = s mod p``, ``p`` prime and ``q`` divides ``p - 1``.\\n    Assume that the root exists.\\n\\n    Parameters\\n    ==========\\n\\n    s : integer\\n    q : integer, n > 2. ``q`` divides ``p - 1``.\\n    p : prime number\\n    all_roots : if False returns the smallest root, else the list of roots\\n\\n    Returns\\n    =======\\n\\n    list[int] | int :\\n        Root of ``x**q = s mod p``. If ``all_roots == True``,\\n        returned ascending list. otherwise, returned an int.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _nthroot_mod1\\n    >>> _nthroot_mod1(5, 3, 13, False)\\n    7\\n    >>> _nthroot_mod1(13, 4, 17, True)\\n    [3, 5, 12, 14]\\n\\n    References\\n    ==========\\n\\n    .. [1] A. M. Johnston, A Generalized qth Root Algorithm,\\n           ACM-SIAM Symposium on Discrete Algorithms (1999), pp. 929-930\\n\\n    '\n    g = next(_primitive_root_prime_iter(p))\n    r = s\n    for (qx, ex) in factorint(q).items():\n        f = (p - 1) // qx ** ex\n        while f % qx == 0:\n            f //= qx\n        z = f * invert(-f, qx)\n        x = (1 + z) // qx\n        t = discrete_log(p, pow(r, f, p), pow(g, f * qx, p))\n        for _ in range(ex):\n            r = pow(r, x, p) * pow(g, -z * t % (p - 1), p) % p\n            t //= qx\n    res = [r]\n    h = pow(g, (p - 1) // q, p)\n    hx = r\n    for _ in range(q - 1):\n        hx = hx * h % p\n        res.append(hx)\n    if all_roots:\n        res.sort()\n        return res\n    return min(res)"
        ]
    },
    {
        "func_name": "_nthroot_mod_prime_power",
        "original": "def _nthroot_mod_prime_power(a, n, p, k):\n    \"\"\" Root of ``x**n = a mod p**k``.\n\n    Parameters\n    ==========\n\n    a : integer\n    n : integer, n > 2\n    p : prime number\n    k : positive integer\n\n    Returns\n    =======\n\n    list[int] :\n        Ascending list of roots of ``x**n = a mod p**k``.\n        If no solution exists, return ``[]``.\n\n    \"\"\"\n    if not _is_nthpow_residue_bign_prime_power(a, n, p, k):\n        return []\n    a_mod_p = a % p\n    if a_mod_p == 0:\n        base_roots = [0]\n    elif (p - 1) % n == 0:\n        base_roots = _nthroot_mod1(a_mod_p, n, p, all_roots=True)\n    else:\n        pa = n\n        pb = p - 1\n        b = 1\n        if pa < pb:\n            (a_mod_p, pa, b, pb) = (b, pb, a_mod_p, pa)\n        while pb:\n            (q, pc) = divmod(pa, pb)\n            c = pow(b, -q, p) * a_mod_p % p\n            (pa, pb) = (pb, pc)\n            (a_mod_p, b) = (b, c)\n        if pa == 1:\n            base_roots = [a_mod_p]\n        elif pa == 2:\n            base_roots = sqrt_mod(a_mod_p, p, all_roots=True)\n        else:\n            base_roots = _nthroot_mod1(a_mod_p, pa, p, all_roots=True)\n    if k == 1:\n        return base_roots\n    a %= p ** k\n    tot_roots = set()\n    for root in base_roots:\n        diff = pow(root, n - 1, p) * n % p\n        new_base = p\n        if diff != 0:\n            m_inv = invert(diff, p)\n            for _ in range(k - 1):\n                new_base *= p\n                tmp = pow(root, n, new_base) - a\n                tmp *= m_inv\n                root = (root - tmp) % new_base\n            tot_roots.add(root)\n        else:\n            roots_in_base = {root}\n            for _ in range(k - 1):\n                new_base *= p\n                new_roots = set()\n                for k_ in roots_in_base:\n                    if pow(k_, n, new_base) != a % new_base:\n                        continue\n                    while k_ not in new_roots:\n                        new_roots.add(k_)\n                        k_ = (k_ + new_base // p) % new_base\n                roots_in_base = new_roots\n            tot_roots = tot_roots | roots_in_base\n    return sorted(tot_roots)",
        "mutated": [
            "def _nthroot_mod_prime_power(a, n, p, k):\n    if False:\n        i = 10\n    ' Root of ``x**n = a mod p**k``.\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    n : integer, n > 2\\n    p : prime number\\n    k : positive integer\\n\\n    Returns\\n    =======\\n\\n    list[int] :\\n        Ascending list of roots of ``x**n = a mod p**k``.\\n        If no solution exists, return ``[]``.\\n\\n    '\n    if not _is_nthpow_residue_bign_prime_power(a, n, p, k):\n        return []\n    a_mod_p = a % p\n    if a_mod_p == 0:\n        base_roots = [0]\n    elif (p - 1) % n == 0:\n        base_roots = _nthroot_mod1(a_mod_p, n, p, all_roots=True)\n    else:\n        pa = n\n        pb = p - 1\n        b = 1\n        if pa < pb:\n            (a_mod_p, pa, b, pb) = (b, pb, a_mod_p, pa)\n        while pb:\n            (q, pc) = divmod(pa, pb)\n            c = pow(b, -q, p) * a_mod_p % p\n            (pa, pb) = (pb, pc)\n            (a_mod_p, b) = (b, c)\n        if pa == 1:\n            base_roots = [a_mod_p]\n        elif pa == 2:\n            base_roots = sqrt_mod(a_mod_p, p, all_roots=True)\n        else:\n            base_roots = _nthroot_mod1(a_mod_p, pa, p, all_roots=True)\n    if k == 1:\n        return base_roots\n    a %= p ** k\n    tot_roots = set()\n    for root in base_roots:\n        diff = pow(root, n - 1, p) * n % p\n        new_base = p\n        if diff != 0:\n            m_inv = invert(diff, p)\n            for _ in range(k - 1):\n                new_base *= p\n                tmp = pow(root, n, new_base) - a\n                tmp *= m_inv\n                root = (root - tmp) % new_base\n            tot_roots.add(root)\n        else:\n            roots_in_base = {root}\n            for _ in range(k - 1):\n                new_base *= p\n                new_roots = set()\n                for k_ in roots_in_base:\n                    if pow(k_, n, new_base) != a % new_base:\n                        continue\n                    while k_ not in new_roots:\n                        new_roots.add(k_)\n                        k_ = (k_ + new_base // p) % new_base\n                roots_in_base = new_roots\n            tot_roots = tot_roots | roots_in_base\n    return sorted(tot_roots)",
            "def _nthroot_mod_prime_power(a, n, p, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ' Root of ``x**n = a mod p**k``.\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    n : integer, n > 2\\n    p : prime number\\n    k : positive integer\\n\\n    Returns\\n    =======\\n\\n    list[int] :\\n        Ascending list of roots of ``x**n = a mod p**k``.\\n        If no solution exists, return ``[]``.\\n\\n    '\n    if not _is_nthpow_residue_bign_prime_power(a, n, p, k):\n        return []\n    a_mod_p = a % p\n    if a_mod_p == 0:\n        base_roots = [0]\n    elif (p - 1) % n == 0:\n        base_roots = _nthroot_mod1(a_mod_p, n, p, all_roots=True)\n    else:\n        pa = n\n        pb = p - 1\n        b = 1\n        if pa < pb:\n            (a_mod_p, pa, b, pb) = (b, pb, a_mod_p, pa)\n        while pb:\n            (q, pc) = divmod(pa, pb)\n            c = pow(b, -q, p) * a_mod_p % p\n            (pa, pb) = (pb, pc)\n            (a_mod_p, b) = (b, c)\n        if pa == 1:\n            base_roots = [a_mod_p]\n        elif pa == 2:\n            base_roots = sqrt_mod(a_mod_p, p, all_roots=True)\n        else:\n            base_roots = _nthroot_mod1(a_mod_p, pa, p, all_roots=True)\n    if k == 1:\n        return base_roots\n    a %= p ** k\n    tot_roots = set()\n    for root in base_roots:\n        diff = pow(root, n - 1, p) * n % p\n        new_base = p\n        if diff != 0:\n            m_inv = invert(diff, p)\n            for _ in range(k - 1):\n                new_base *= p\n                tmp = pow(root, n, new_base) - a\n                tmp *= m_inv\n                root = (root - tmp) % new_base\n            tot_roots.add(root)\n        else:\n            roots_in_base = {root}\n            for _ in range(k - 1):\n                new_base *= p\n                new_roots = set()\n                for k_ in roots_in_base:\n                    if pow(k_, n, new_base) != a % new_base:\n                        continue\n                    while k_ not in new_roots:\n                        new_roots.add(k_)\n                        k_ = (k_ + new_base // p) % new_base\n                roots_in_base = new_roots\n            tot_roots = tot_roots | roots_in_base\n    return sorted(tot_roots)",
            "def _nthroot_mod_prime_power(a, n, p, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ' Root of ``x**n = a mod p**k``.\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    n : integer, n > 2\\n    p : prime number\\n    k : positive integer\\n\\n    Returns\\n    =======\\n\\n    list[int] :\\n        Ascending list of roots of ``x**n = a mod p**k``.\\n        If no solution exists, return ``[]``.\\n\\n    '\n    if not _is_nthpow_residue_bign_prime_power(a, n, p, k):\n        return []\n    a_mod_p = a % p\n    if a_mod_p == 0:\n        base_roots = [0]\n    elif (p - 1) % n == 0:\n        base_roots = _nthroot_mod1(a_mod_p, n, p, all_roots=True)\n    else:\n        pa = n\n        pb = p - 1\n        b = 1\n        if pa < pb:\n            (a_mod_p, pa, b, pb) = (b, pb, a_mod_p, pa)\n        while pb:\n            (q, pc) = divmod(pa, pb)\n            c = pow(b, -q, p) * a_mod_p % p\n            (pa, pb) = (pb, pc)\n            (a_mod_p, b) = (b, c)\n        if pa == 1:\n            base_roots = [a_mod_p]\n        elif pa == 2:\n            base_roots = sqrt_mod(a_mod_p, p, all_roots=True)\n        else:\n            base_roots = _nthroot_mod1(a_mod_p, pa, p, all_roots=True)\n    if k == 1:\n        return base_roots\n    a %= p ** k\n    tot_roots = set()\n    for root in base_roots:\n        diff = pow(root, n - 1, p) * n % p\n        new_base = p\n        if diff != 0:\n            m_inv = invert(diff, p)\n            for _ in range(k - 1):\n                new_base *= p\n                tmp = pow(root, n, new_base) - a\n                tmp *= m_inv\n                root = (root - tmp) % new_base\n            tot_roots.add(root)\n        else:\n            roots_in_base = {root}\n            for _ in range(k - 1):\n                new_base *= p\n                new_roots = set()\n                for k_ in roots_in_base:\n                    if pow(k_, n, new_base) != a % new_base:\n                        continue\n                    while k_ not in new_roots:\n                        new_roots.add(k_)\n                        k_ = (k_ + new_base // p) % new_base\n                roots_in_base = new_roots\n            tot_roots = tot_roots | roots_in_base\n    return sorted(tot_roots)",
            "def _nthroot_mod_prime_power(a, n, p, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ' Root of ``x**n = a mod p**k``.\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    n : integer, n > 2\\n    p : prime number\\n    k : positive integer\\n\\n    Returns\\n    =======\\n\\n    list[int] :\\n        Ascending list of roots of ``x**n = a mod p**k``.\\n        If no solution exists, return ``[]``.\\n\\n    '\n    if not _is_nthpow_residue_bign_prime_power(a, n, p, k):\n        return []\n    a_mod_p = a % p\n    if a_mod_p == 0:\n        base_roots = [0]\n    elif (p - 1) % n == 0:\n        base_roots = _nthroot_mod1(a_mod_p, n, p, all_roots=True)\n    else:\n        pa = n\n        pb = p - 1\n        b = 1\n        if pa < pb:\n            (a_mod_p, pa, b, pb) = (b, pb, a_mod_p, pa)\n        while pb:\n            (q, pc) = divmod(pa, pb)\n            c = pow(b, -q, p) * a_mod_p % p\n            (pa, pb) = (pb, pc)\n            (a_mod_p, b) = (b, c)\n        if pa == 1:\n            base_roots = [a_mod_p]\n        elif pa == 2:\n            base_roots = sqrt_mod(a_mod_p, p, all_roots=True)\n        else:\n            base_roots = _nthroot_mod1(a_mod_p, pa, p, all_roots=True)\n    if k == 1:\n        return base_roots\n    a %= p ** k\n    tot_roots = set()\n    for root in base_roots:\n        diff = pow(root, n - 1, p) * n % p\n        new_base = p\n        if diff != 0:\n            m_inv = invert(diff, p)\n            for _ in range(k - 1):\n                new_base *= p\n                tmp = pow(root, n, new_base) - a\n                tmp *= m_inv\n                root = (root - tmp) % new_base\n            tot_roots.add(root)\n        else:\n            roots_in_base = {root}\n            for _ in range(k - 1):\n                new_base *= p\n                new_roots = set()\n                for k_ in roots_in_base:\n                    if pow(k_, n, new_base) != a % new_base:\n                        continue\n                    while k_ not in new_roots:\n                        new_roots.add(k_)\n                        k_ = (k_ + new_base // p) % new_base\n                roots_in_base = new_roots\n            tot_roots = tot_roots | roots_in_base\n    return sorted(tot_roots)",
            "def _nthroot_mod_prime_power(a, n, p, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ' Root of ``x**n = a mod p**k``.\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    n : integer, n > 2\\n    p : prime number\\n    k : positive integer\\n\\n    Returns\\n    =======\\n\\n    list[int] :\\n        Ascending list of roots of ``x**n = a mod p**k``.\\n        If no solution exists, return ``[]``.\\n\\n    '\n    if not _is_nthpow_residue_bign_prime_power(a, n, p, k):\n        return []\n    a_mod_p = a % p\n    if a_mod_p == 0:\n        base_roots = [0]\n    elif (p - 1) % n == 0:\n        base_roots = _nthroot_mod1(a_mod_p, n, p, all_roots=True)\n    else:\n        pa = n\n        pb = p - 1\n        b = 1\n        if pa < pb:\n            (a_mod_p, pa, b, pb) = (b, pb, a_mod_p, pa)\n        while pb:\n            (q, pc) = divmod(pa, pb)\n            c = pow(b, -q, p) * a_mod_p % p\n            (pa, pb) = (pb, pc)\n            (a_mod_p, b) = (b, c)\n        if pa == 1:\n            base_roots = [a_mod_p]\n        elif pa == 2:\n            base_roots = sqrt_mod(a_mod_p, p, all_roots=True)\n        else:\n            base_roots = _nthroot_mod1(a_mod_p, pa, p, all_roots=True)\n    if k == 1:\n        return base_roots\n    a %= p ** k\n    tot_roots = set()\n    for root in base_roots:\n        diff = pow(root, n - 1, p) * n % p\n        new_base = p\n        if diff != 0:\n            m_inv = invert(diff, p)\n            for _ in range(k - 1):\n                new_base *= p\n                tmp = pow(root, n, new_base) - a\n                tmp *= m_inv\n                root = (root - tmp) % new_base\n            tot_roots.add(root)\n        else:\n            roots_in_base = {root}\n            for _ in range(k - 1):\n                new_base *= p\n                new_roots = set()\n                for k_ in roots_in_base:\n                    if pow(k_, n, new_base) != a % new_base:\n                        continue\n                    while k_ not in new_roots:\n                        new_roots.add(k_)\n                        k_ = (k_ + new_base // p) % new_base\n                roots_in_base = new_roots\n            tot_roots = tot_roots | roots_in_base\n    return sorted(tot_roots)"
        ]
    },
    {
        "func_name": "nthroot_mod",
        "original": "def nthroot_mod(a, n, p, all_roots=False):\n    \"\"\"\n    Find the solutions to ``x**n = a mod p``.\n\n    Parameters\n    ==========\n\n    a : integer\n    n : positive integer\n    p : positive integer\n    all_roots : if False returns the smallest root, else the list of roots\n\n    Returns\n    =======\n\n        list[int] | int | None :\n            solutions to ``x**n = a mod p``.\n            The table of the output type is:\n\n            ========== ========== ==========\n            all_roots  has roots  Returns\n            ========== ========== ==========\n            True       Yes        list[int]\n            True       No         []\n            False      Yes        int\n            False      No         None\n            ========== ========== ==========\n\n    Raises\n    ======\n\n        ValueError\n            If ``a``, ``n`` or ``p`` is not integer.\n            If ``n`` or ``p`` is not positive.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.residue_ntheory import nthroot_mod\n    >>> nthroot_mod(11, 4, 19)\n    8\n    >>> nthroot_mod(11, 4, 19, True)\n    [8, 11]\n    >>> nthroot_mod(68, 3, 109)\n    23\n\n    References\n    ==========\n\n    .. [1] P. Hackman \"Elementary Number Theory\" (2009), page 76\n\n    \"\"\"\n    a = a % p\n    (a, n, p) = (as_int(a), as_int(n), as_int(p))\n    if n < 1:\n        raise ValueError('n should be positive')\n    if p < 1:\n        raise ValueError('p should be positive')\n    if n == 1:\n        return [a] if all_roots else a\n    if n == 2:\n        return sqrt_mod(a, p, all_roots)\n    base = []\n    prime_power = []\n    for (q, e) in factorint(p).items():\n        tot_roots = _nthroot_mod_prime_power(a, n, q, e)\n        if not tot_roots:\n            return [] if all_roots else None\n        prime_power.append(q ** e)\n        base.append(sorted(tot_roots))\n    (P, E, S) = gf_crt1(prime_power, ZZ)\n    ret = sorted(map(int, {gf_crt2(c, prime_power, P, E, S, ZZ) for c in product(*base)}))\n    if all_roots:\n        return ret\n    if ret:\n        return ret[0]",
        "mutated": [
            "def nthroot_mod(a, n, p, all_roots=False):\n    if False:\n        i = 10\n    '\\n    Find the solutions to ``x**n = a mod p``.\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    n : positive integer\\n    p : positive integer\\n    all_roots : if False returns the smallest root, else the list of roots\\n\\n    Returns\\n    =======\\n\\n        list[int] | int | None :\\n            solutions to ``x**n = a mod p``.\\n            The table of the output type is:\\n\\n            ========== ========== ==========\\n            all_roots  has roots  Returns\\n            ========== ========== ==========\\n            True       Yes        list[int]\\n            True       No         []\\n            False      Yes        int\\n            False      No         None\\n            ========== ========== ==========\\n\\n    Raises\\n    ======\\n\\n        ValueError\\n            If ``a``, ``n`` or ``p`` is not integer.\\n            If ``n`` or ``p`` is not positive.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import nthroot_mod\\n    >>> nthroot_mod(11, 4, 19)\\n    8\\n    >>> nthroot_mod(11, 4, 19, True)\\n    [8, 11]\\n    >>> nthroot_mod(68, 3, 109)\\n    23\\n\\n    References\\n    ==========\\n\\n    .. [1] P. Hackman \"Elementary Number Theory\" (2009), page 76\\n\\n    '\n    a = a % p\n    (a, n, p) = (as_int(a), as_int(n), as_int(p))\n    if n < 1:\n        raise ValueError('n should be positive')\n    if p < 1:\n        raise ValueError('p should be positive')\n    if n == 1:\n        return [a] if all_roots else a\n    if n == 2:\n        return sqrt_mod(a, p, all_roots)\n    base = []\n    prime_power = []\n    for (q, e) in factorint(p).items():\n        tot_roots = _nthroot_mod_prime_power(a, n, q, e)\n        if not tot_roots:\n            return [] if all_roots else None\n        prime_power.append(q ** e)\n        base.append(sorted(tot_roots))\n    (P, E, S) = gf_crt1(prime_power, ZZ)\n    ret = sorted(map(int, {gf_crt2(c, prime_power, P, E, S, ZZ) for c in product(*base)}))\n    if all_roots:\n        return ret\n    if ret:\n        return ret[0]",
            "def nthroot_mod(a, n, p, all_roots=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Find the solutions to ``x**n = a mod p``.\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    n : positive integer\\n    p : positive integer\\n    all_roots : if False returns the smallest root, else the list of roots\\n\\n    Returns\\n    =======\\n\\n        list[int] | int | None :\\n            solutions to ``x**n = a mod p``.\\n            The table of the output type is:\\n\\n            ========== ========== ==========\\n            all_roots  has roots  Returns\\n            ========== ========== ==========\\n            True       Yes        list[int]\\n            True       No         []\\n            False      Yes        int\\n            False      No         None\\n            ========== ========== ==========\\n\\n    Raises\\n    ======\\n\\n        ValueError\\n            If ``a``, ``n`` or ``p`` is not integer.\\n            If ``n`` or ``p`` is not positive.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import nthroot_mod\\n    >>> nthroot_mod(11, 4, 19)\\n    8\\n    >>> nthroot_mod(11, 4, 19, True)\\n    [8, 11]\\n    >>> nthroot_mod(68, 3, 109)\\n    23\\n\\n    References\\n    ==========\\n\\n    .. [1] P. Hackman \"Elementary Number Theory\" (2009), page 76\\n\\n    '\n    a = a % p\n    (a, n, p) = (as_int(a), as_int(n), as_int(p))\n    if n < 1:\n        raise ValueError('n should be positive')\n    if p < 1:\n        raise ValueError('p should be positive')\n    if n == 1:\n        return [a] if all_roots else a\n    if n == 2:\n        return sqrt_mod(a, p, all_roots)\n    base = []\n    prime_power = []\n    for (q, e) in factorint(p).items():\n        tot_roots = _nthroot_mod_prime_power(a, n, q, e)\n        if not tot_roots:\n            return [] if all_roots else None\n        prime_power.append(q ** e)\n        base.append(sorted(tot_roots))\n    (P, E, S) = gf_crt1(prime_power, ZZ)\n    ret = sorted(map(int, {gf_crt2(c, prime_power, P, E, S, ZZ) for c in product(*base)}))\n    if all_roots:\n        return ret\n    if ret:\n        return ret[0]",
            "def nthroot_mod(a, n, p, all_roots=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Find the solutions to ``x**n = a mod p``.\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    n : positive integer\\n    p : positive integer\\n    all_roots : if False returns the smallest root, else the list of roots\\n\\n    Returns\\n    =======\\n\\n        list[int] | int | None :\\n            solutions to ``x**n = a mod p``.\\n            The table of the output type is:\\n\\n            ========== ========== ==========\\n            all_roots  has roots  Returns\\n            ========== ========== ==========\\n            True       Yes        list[int]\\n            True       No         []\\n            False      Yes        int\\n            False      No         None\\n            ========== ========== ==========\\n\\n    Raises\\n    ======\\n\\n        ValueError\\n            If ``a``, ``n`` or ``p`` is not integer.\\n            If ``n`` or ``p`` is not positive.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import nthroot_mod\\n    >>> nthroot_mod(11, 4, 19)\\n    8\\n    >>> nthroot_mod(11, 4, 19, True)\\n    [8, 11]\\n    >>> nthroot_mod(68, 3, 109)\\n    23\\n\\n    References\\n    ==========\\n\\n    .. [1] P. Hackman \"Elementary Number Theory\" (2009), page 76\\n\\n    '\n    a = a % p\n    (a, n, p) = (as_int(a), as_int(n), as_int(p))\n    if n < 1:\n        raise ValueError('n should be positive')\n    if p < 1:\n        raise ValueError('p should be positive')\n    if n == 1:\n        return [a] if all_roots else a\n    if n == 2:\n        return sqrt_mod(a, p, all_roots)\n    base = []\n    prime_power = []\n    for (q, e) in factorint(p).items():\n        tot_roots = _nthroot_mod_prime_power(a, n, q, e)\n        if not tot_roots:\n            return [] if all_roots else None\n        prime_power.append(q ** e)\n        base.append(sorted(tot_roots))\n    (P, E, S) = gf_crt1(prime_power, ZZ)\n    ret = sorted(map(int, {gf_crt2(c, prime_power, P, E, S, ZZ) for c in product(*base)}))\n    if all_roots:\n        return ret\n    if ret:\n        return ret[0]",
            "def nthroot_mod(a, n, p, all_roots=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Find the solutions to ``x**n = a mod p``.\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    n : positive integer\\n    p : positive integer\\n    all_roots : if False returns the smallest root, else the list of roots\\n\\n    Returns\\n    =======\\n\\n        list[int] | int | None :\\n            solutions to ``x**n = a mod p``.\\n            The table of the output type is:\\n\\n            ========== ========== ==========\\n            all_roots  has roots  Returns\\n            ========== ========== ==========\\n            True       Yes        list[int]\\n            True       No         []\\n            False      Yes        int\\n            False      No         None\\n            ========== ========== ==========\\n\\n    Raises\\n    ======\\n\\n        ValueError\\n            If ``a``, ``n`` or ``p`` is not integer.\\n            If ``n`` or ``p`` is not positive.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import nthroot_mod\\n    >>> nthroot_mod(11, 4, 19)\\n    8\\n    >>> nthroot_mod(11, 4, 19, True)\\n    [8, 11]\\n    >>> nthroot_mod(68, 3, 109)\\n    23\\n\\n    References\\n    ==========\\n\\n    .. [1] P. Hackman \"Elementary Number Theory\" (2009), page 76\\n\\n    '\n    a = a % p\n    (a, n, p) = (as_int(a), as_int(n), as_int(p))\n    if n < 1:\n        raise ValueError('n should be positive')\n    if p < 1:\n        raise ValueError('p should be positive')\n    if n == 1:\n        return [a] if all_roots else a\n    if n == 2:\n        return sqrt_mod(a, p, all_roots)\n    base = []\n    prime_power = []\n    for (q, e) in factorint(p).items():\n        tot_roots = _nthroot_mod_prime_power(a, n, q, e)\n        if not tot_roots:\n            return [] if all_roots else None\n        prime_power.append(q ** e)\n        base.append(sorted(tot_roots))\n    (P, E, S) = gf_crt1(prime_power, ZZ)\n    ret = sorted(map(int, {gf_crt2(c, prime_power, P, E, S, ZZ) for c in product(*base)}))\n    if all_roots:\n        return ret\n    if ret:\n        return ret[0]",
            "def nthroot_mod(a, n, p, all_roots=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Find the solutions to ``x**n = a mod p``.\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    n : positive integer\\n    p : positive integer\\n    all_roots : if False returns the smallest root, else the list of roots\\n\\n    Returns\\n    =======\\n\\n        list[int] | int | None :\\n            solutions to ``x**n = a mod p``.\\n            The table of the output type is:\\n\\n            ========== ========== ==========\\n            all_roots  has roots  Returns\\n            ========== ========== ==========\\n            True       Yes        list[int]\\n            True       No         []\\n            False      Yes        int\\n            False      No         None\\n            ========== ========== ==========\\n\\n    Raises\\n    ======\\n\\n        ValueError\\n            If ``a``, ``n`` or ``p`` is not integer.\\n            If ``n`` or ``p`` is not positive.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import nthroot_mod\\n    >>> nthroot_mod(11, 4, 19)\\n    8\\n    >>> nthroot_mod(11, 4, 19, True)\\n    [8, 11]\\n    >>> nthroot_mod(68, 3, 109)\\n    23\\n\\n    References\\n    ==========\\n\\n    .. [1] P. Hackman \"Elementary Number Theory\" (2009), page 76\\n\\n    '\n    a = a % p\n    (a, n, p) = (as_int(a), as_int(n), as_int(p))\n    if n < 1:\n        raise ValueError('n should be positive')\n    if p < 1:\n        raise ValueError('p should be positive')\n    if n == 1:\n        return [a] if all_roots else a\n    if n == 2:\n        return sqrt_mod(a, p, all_roots)\n    base = []\n    prime_power = []\n    for (q, e) in factorint(p).items():\n        tot_roots = _nthroot_mod_prime_power(a, n, q, e)\n        if not tot_roots:\n            return [] if all_roots else None\n        prime_power.append(q ** e)\n        base.append(sorted(tot_roots))\n    (P, E, S) = gf_crt1(prime_power, ZZ)\n    ret = sorted(map(int, {gf_crt2(c, prime_power, P, E, S, ZZ) for c in product(*base)}))\n    if all_roots:\n        return ret\n    if ret:\n        return ret[0]"
        ]
    },
    {
        "func_name": "quadratic_residues",
        "original": "def quadratic_residues(p) -> list[int]:\n    \"\"\"\n    Returns the list of quadratic residues.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.residue_ntheory import quadratic_residues\n    >>> quadratic_residues(7)\n    [0, 1, 2, 4]\n    \"\"\"\n    p = as_int(p)\n    r = {pow(i, 2, p) for i in range(p // 2 + 1)}\n    return sorted(r)",
        "mutated": [
            "def quadratic_residues(p) -> list[int]:\n    if False:\n        i = 10\n    '\\n    Returns the list of quadratic residues.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import quadratic_residues\\n    >>> quadratic_residues(7)\\n    [0, 1, 2, 4]\\n    '\n    p = as_int(p)\n    r = {pow(i, 2, p) for i in range(p // 2 + 1)}\n    return sorted(r)",
            "def quadratic_residues(p) -> list[int]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Returns the list of quadratic residues.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import quadratic_residues\\n    >>> quadratic_residues(7)\\n    [0, 1, 2, 4]\\n    '\n    p = as_int(p)\n    r = {pow(i, 2, p) for i in range(p // 2 + 1)}\n    return sorted(r)",
            "def quadratic_residues(p) -> list[int]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Returns the list of quadratic residues.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import quadratic_residues\\n    >>> quadratic_residues(7)\\n    [0, 1, 2, 4]\\n    '\n    p = as_int(p)\n    r = {pow(i, 2, p) for i in range(p // 2 + 1)}\n    return sorted(r)",
            "def quadratic_residues(p) -> list[int]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Returns the list of quadratic residues.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import quadratic_residues\\n    >>> quadratic_residues(7)\\n    [0, 1, 2, 4]\\n    '\n    p = as_int(p)\n    r = {pow(i, 2, p) for i in range(p // 2 + 1)}\n    return sorted(r)",
            "def quadratic_residues(p) -> list[int]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Returns the list of quadratic residues.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import quadratic_residues\\n    >>> quadratic_residues(7)\\n    [0, 1, 2, 4]\\n    '\n    p = as_int(p)\n    r = {pow(i, 2, p) for i in range(p // 2 + 1)}\n    return sorted(r)"
        ]
    },
    {
        "func_name": "legendre_symbol",
        "original": "def legendre_symbol(a, p):\n    \"\"\"\n    Returns the Legendre symbol `(a / p)`.\n\n    For an integer ``a`` and an odd prime ``p``, the Legendre symbol is\n    defined as\n\n    .. math ::\n        \\\\genfrac(){}{}{a}{p} = \\\\begin{cases}\n             0 & \\\\text{if } p \\\\text{ divides } a\\\\\\\\\n             1 & \\\\text{if } a \\\\text{ is a quadratic residue modulo } p\\\\\\\\\n            -1 & \\\\text{if } a \\\\text{ is a quadratic nonresidue modulo } p\n        \\\\end{cases}\n\n    Parameters\n    ==========\n\n    a : integer\n    p : odd prime\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory import legendre_symbol\n    >>> [legendre_symbol(i, 7) for i in range(7)]\n    [0, 1, 1, -1, 1, -1, -1]\n    >>> sorted(set([i**2 % 7 for i in range(7)]))\n    [0, 1, 2, 4]\n\n    See Also\n    ========\n\n    is_quad_residue, jacobi_symbol\n\n    \"\"\"\n    (a, p) = (as_int(a), as_int(p))\n    if p == 2 or not isprime(p):\n        raise ValueError('p should be an odd prime')\n    return int(legendre(a, p))",
        "mutated": [
            "def legendre_symbol(a, p):\n    if False:\n        i = 10\n    '\\n    Returns the Legendre symbol `(a / p)`.\\n\\n    For an integer ``a`` and an odd prime ``p``, the Legendre symbol is\\n    defined as\\n\\n    .. math ::\\n        \\\\genfrac(){}{}{a}{p} = \\\\begin{cases}\\n             0 & \\\\text{if } p \\\\text{ divides } a\\\\\\\\\\n             1 & \\\\text{if } a \\\\text{ is a quadratic residue modulo } p\\\\\\\\\\n            -1 & \\\\text{if } a \\\\text{ is a quadratic nonresidue modulo } p\\n        \\\\end{cases}\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    p : odd prime\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import legendre_symbol\\n    >>> [legendre_symbol(i, 7) for i in range(7)]\\n    [0, 1, 1, -1, 1, -1, -1]\\n    >>> sorted(set([i**2 % 7 for i in range(7)]))\\n    [0, 1, 2, 4]\\n\\n    See Also\\n    ========\\n\\n    is_quad_residue, jacobi_symbol\\n\\n    '\n    (a, p) = (as_int(a), as_int(p))\n    if p == 2 or not isprime(p):\n        raise ValueError('p should be an odd prime')\n    return int(legendre(a, p))",
            "def legendre_symbol(a, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Returns the Legendre symbol `(a / p)`.\\n\\n    For an integer ``a`` and an odd prime ``p``, the Legendre symbol is\\n    defined as\\n\\n    .. math ::\\n        \\\\genfrac(){}{}{a}{p} = \\\\begin{cases}\\n             0 & \\\\text{if } p \\\\text{ divides } a\\\\\\\\\\n             1 & \\\\text{if } a \\\\text{ is a quadratic residue modulo } p\\\\\\\\\\n            -1 & \\\\text{if } a \\\\text{ is a quadratic nonresidue modulo } p\\n        \\\\end{cases}\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    p : odd prime\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import legendre_symbol\\n    >>> [legendre_symbol(i, 7) for i in range(7)]\\n    [0, 1, 1, -1, 1, -1, -1]\\n    >>> sorted(set([i**2 % 7 for i in range(7)]))\\n    [0, 1, 2, 4]\\n\\n    See Also\\n    ========\\n\\n    is_quad_residue, jacobi_symbol\\n\\n    '\n    (a, p) = (as_int(a), as_int(p))\n    if p == 2 or not isprime(p):\n        raise ValueError('p should be an odd prime')\n    return int(legendre(a, p))",
            "def legendre_symbol(a, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Returns the Legendre symbol `(a / p)`.\\n\\n    For an integer ``a`` and an odd prime ``p``, the Legendre symbol is\\n    defined as\\n\\n    .. math ::\\n        \\\\genfrac(){}{}{a}{p} = \\\\begin{cases}\\n             0 & \\\\text{if } p \\\\text{ divides } a\\\\\\\\\\n             1 & \\\\text{if } a \\\\text{ is a quadratic residue modulo } p\\\\\\\\\\n            -1 & \\\\text{if } a \\\\text{ is a quadratic nonresidue modulo } p\\n        \\\\end{cases}\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    p : odd prime\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import legendre_symbol\\n    >>> [legendre_symbol(i, 7) for i in range(7)]\\n    [0, 1, 1, -1, 1, -1, -1]\\n    >>> sorted(set([i**2 % 7 for i in range(7)]))\\n    [0, 1, 2, 4]\\n\\n    See Also\\n    ========\\n\\n    is_quad_residue, jacobi_symbol\\n\\n    '\n    (a, p) = (as_int(a), as_int(p))\n    if p == 2 or not isprime(p):\n        raise ValueError('p should be an odd prime')\n    return int(legendre(a, p))",
            "def legendre_symbol(a, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Returns the Legendre symbol `(a / p)`.\\n\\n    For an integer ``a`` and an odd prime ``p``, the Legendre symbol is\\n    defined as\\n\\n    .. math ::\\n        \\\\genfrac(){}{}{a}{p} = \\\\begin{cases}\\n             0 & \\\\text{if } p \\\\text{ divides } a\\\\\\\\\\n             1 & \\\\text{if } a \\\\text{ is a quadratic residue modulo } p\\\\\\\\\\n            -1 & \\\\text{if } a \\\\text{ is a quadratic nonresidue modulo } p\\n        \\\\end{cases}\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    p : odd prime\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import legendre_symbol\\n    >>> [legendre_symbol(i, 7) for i in range(7)]\\n    [0, 1, 1, -1, 1, -1, -1]\\n    >>> sorted(set([i**2 % 7 for i in range(7)]))\\n    [0, 1, 2, 4]\\n\\n    See Also\\n    ========\\n\\n    is_quad_residue, jacobi_symbol\\n\\n    '\n    (a, p) = (as_int(a), as_int(p))\n    if p == 2 or not isprime(p):\n        raise ValueError('p should be an odd prime')\n    return int(legendre(a, p))",
            "def legendre_symbol(a, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Returns the Legendre symbol `(a / p)`.\\n\\n    For an integer ``a`` and an odd prime ``p``, the Legendre symbol is\\n    defined as\\n\\n    .. math ::\\n        \\\\genfrac(){}{}{a}{p} = \\\\begin{cases}\\n             0 & \\\\text{if } p \\\\text{ divides } a\\\\\\\\\\n             1 & \\\\text{if } a \\\\text{ is a quadratic residue modulo } p\\\\\\\\\\n            -1 & \\\\text{if } a \\\\text{ is a quadratic nonresidue modulo } p\\n        \\\\end{cases}\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    p : odd prime\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import legendre_symbol\\n    >>> [legendre_symbol(i, 7) for i in range(7)]\\n    [0, 1, 1, -1, 1, -1, -1]\\n    >>> sorted(set([i**2 % 7 for i in range(7)]))\\n    [0, 1, 2, 4]\\n\\n    See Also\\n    ========\\n\\n    is_quad_residue, jacobi_symbol\\n\\n    '\n    (a, p) = (as_int(a), as_int(p))\n    if p == 2 or not isprime(p):\n        raise ValueError('p should be an odd prime')\n    return int(legendre(a, p))"
        ]
    },
    {
        "func_name": "jacobi_symbol",
        "original": "def jacobi_symbol(m, n):\n    \"\"\"\n    Returns the Jacobi symbol `(m / n)`.\n\n    For any integer ``m`` and any positive odd integer ``n`` the Jacobi symbol\n    is defined as the product of the Legendre symbols corresponding to the\n    prime factors of ``n``:\n\n    .. math ::\n        \\\\genfrac(){}{}{m}{n} =\n            \\\\genfrac(){}{}{m}{p^{1}}^{\\\\alpha_1}\n            \\\\genfrac(){}{}{m}{p^{2}}^{\\\\alpha_2}\n            ...\n            \\\\genfrac(){}{}{m}{p^{k}}^{\\\\alpha_k}\n            \\\\text{ where } n =\n                p_1^{\\\\alpha_1}\n                p_2^{\\\\alpha_2}\n                ...\n                p_k^{\\\\alpha_k}\n\n    Like the Legendre symbol, if the Jacobi symbol `\\\\genfrac(){}{}{m}{n} = -1`\n    then ``m`` is a quadratic nonresidue modulo ``n``.\n\n    But, unlike the Legendre symbol, if the Jacobi symbol\n    `\\\\genfrac(){}{}{m}{n} = 1` then ``m`` may or may not be a quadratic residue\n    modulo ``n``.\n\n    Parameters\n    ==========\n\n    m : integer\n    n : odd positive integer\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory import jacobi_symbol, legendre_symbol\n    >>> from sympy import S\n    >>> jacobi_symbol(45, 77)\n    -1\n    >>> jacobi_symbol(60, 121)\n    1\n\n    The relationship between the ``jacobi_symbol`` and ``legendre_symbol`` can\n    be demonstrated as follows:\n\n    >>> L = legendre_symbol\n    >>> S(45).factors()\n    {3: 2, 5: 1}\n    >>> jacobi_symbol(7, 45) == L(7, 3)**2 * L(7, 5)**1\n    True\n\n    See Also\n    ========\n\n    is_quad_residue, legendre_symbol\n    \"\"\"\n    (m, n) = (as_int(m), as_int(n))\n    return int(jacobi(m, n))",
        "mutated": [
            "def jacobi_symbol(m, n):\n    if False:\n        i = 10\n    '\\n    Returns the Jacobi symbol `(m / n)`.\\n\\n    For any integer ``m`` and any positive odd integer ``n`` the Jacobi symbol\\n    is defined as the product of the Legendre symbols corresponding to the\\n    prime factors of ``n``:\\n\\n    .. math ::\\n        \\\\genfrac(){}{}{m}{n} =\\n            \\\\genfrac(){}{}{m}{p^{1}}^{\\\\alpha_1}\\n            \\\\genfrac(){}{}{m}{p^{2}}^{\\\\alpha_2}\\n            ...\\n            \\\\genfrac(){}{}{m}{p^{k}}^{\\\\alpha_k}\\n            \\\\text{ where } n =\\n                p_1^{\\\\alpha_1}\\n                p_2^{\\\\alpha_2}\\n                ...\\n                p_k^{\\\\alpha_k}\\n\\n    Like the Legendre symbol, if the Jacobi symbol `\\\\genfrac(){}{}{m}{n} = -1`\\n    then ``m`` is a quadratic nonresidue modulo ``n``.\\n\\n    But, unlike the Legendre symbol, if the Jacobi symbol\\n    `\\\\genfrac(){}{}{m}{n} = 1` then ``m`` may or may not be a quadratic residue\\n    modulo ``n``.\\n\\n    Parameters\\n    ==========\\n\\n    m : integer\\n    n : odd positive integer\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import jacobi_symbol, legendre_symbol\\n    >>> from sympy import S\\n    >>> jacobi_symbol(45, 77)\\n    -1\\n    >>> jacobi_symbol(60, 121)\\n    1\\n\\n    The relationship between the ``jacobi_symbol`` and ``legendre_symbol`` can\\n    be demonstrated as follows:\\n\\n    >>> L = legendre_symbol\\n    >>> S(45).factors()\\n    {3: 2, 5: 1}\\n    >>> jacobi_symbol(7, 45) == L(7, 3)**2 * L(7, 5)**1\\n    True\\n\\n    See Also\\n    ========\\n\\n    is_quad_residue, legendre_symbol\\n    '\n    (m, n) = (as_int(m), as_int(n))\n    return int(jacobi(m, n))",
            "def jacobi_symbol(m, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Returns the Jacobi symbol `(m / n)`.\\n\\n    For any integer ``m`` and any positive odd integer ``n`` the Jacobi symbol\\n    is defined as the product of the Legendre symbols corresponding to the\\n    prime factors of ``n``:\\n\\n    .. math ::\\n        \\\\genfrac(){}{}{m}{n} =\\n            \\\\genfrac(){}{}{m}{p^{1}}^{\\\\alpha_1}\\n            \\\\genfrac(){}{}{m}{p^{2}}^{\\\\alpha_2}\\n            ...\\n            \\\\genfrac(){}{}{m}{p^{k}}^{\\\\alpha_k}\\n            \\\\text{ where } n =\\n                p_1^{\\\\alpha_1}\\n                p_2^{\\\\alpha_2}\\n                ...\\n                p_k^{\\\\alpha_k}\\n\\n    Like the Legendre symbol, if the Jacobi symbol `\\\\genfrac(){}{}{m}{n} = -1`\\n    then ``m`` is a quadratic nonresidue modulo ``n``.\\n\\n    But, unlike the Legendre symbol, if the Jacobi symbol\\n    `\\\\genfrac(){}{}{m}{n} = 1` then ``m`` may or may not be a quadratic residue\\n    modulo ``n``.\\n\\n    Parameters\\n    ==========\\n\\n    m : integer\\n    n : odd positive integer\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import jacobi_symbol, legendre_symbol\\n    >>> from sympy import S\\n    >>> jacobi_symbol(45, 77)\\n    -1\\n    >>> jacobi_symbol(60, 121)\\n    1\\n\\n    The relationship between the ``jacobi_symbol`` and ``legendre_symbol`` can\\n    be demonstrated as follows:\\n\\n    >>> L = legendre_symbol\\n    >>> S(45).factors()\\n    {3: 2, 5: 1}\\n    >>> jacobi_symbol(7, 45) == L(7, 3)**2 * L(7, 5)**1\\n    True\\n\\n    See Also\\n    ========\\n\\n    is_quad_residue, legendre_symbol\\n    '\n    (m, n) = (as_int(m), as_int(n))\n    return int(jacobi(m, n))",
            "def jacobi_symbol(m, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Returns the Jacobi symbol `(m / n)`.\\n\\n    For any integer ``m`` and any positive odd integer ``n`` the Jacobi symbol\\n    is defined as the product of the Legendre symbols corresponding to the\\n    prime factors of ``n``:\\n\\n    .. math ::\\n        \\\\genfrac(){}{}{m}{n} =\\n            \\\\genfrac(){}{}{m}{p^{1}}^{\\\\alpha_1}\\n            \\\\genfrac(){}{}{m}{p^{2}}^{\\\\alpha_2}\\n            ...\\n            \\\\genfrac(){}{}{m}{p^{k}}^{\\\\alpha_k}\\n            \\\\text{ where } n =\\n                p_1^{\\\\alpha_1}\\n                p_2^{\\\\alpha_2}\\n                ...\\n                p_k^{\\\\alpha_k}\\n\\n    Like the Legendre symbol, if the Jacobi symbol `\\\\genfrac(){}{}{m}{n} = -1`\\n    then ``m`` is a quadratic nonresidue modulo ``n``.\\n\\n    But, unlike the Legendre symbol, if the Jacobi symbol\\n    `\\\\genfrac(){}{}{m}{n} = 1` then ``m`` may or may not be a quadratic residue\\n    modulo ``n``.\\n\\n    Parameters\\n    ==========\\n\\n    m : integer\\n    n : odd positive integer\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import jacobi_symbol, legendre_symbol\\n    >>> from sympy import S\\n    >>> jacobi_symbol(45, 77)\\n    -1\\n    >>> jacobi_symbol(60, 121)\\n    1\\n\\n    The relationship between the ``jacobi_symbol`` and ``legendre_symbol`` can\\n    be demonstrated as follows:\\n\\n    >>> L = legendre_symbol\\n    >>> S(45).factors()\\n    {3: 2, 5: 1}\\n    >>> jacobi_symbol(7, 45) == L(7, 3)**2 * L(7, 5)**1\\n    True\\n\\n    See Also\\n    ========\\n\\n    is_quad_residue, legendre_symbol\\n    '\n    (m, n) = (as_int(m), as_int(n))\n    return int(jacobi(m, n))",
            "def jacobi_symbol(m, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Returns the Jacobi symbol `(m / n)`.\\n\\n    For any integer ``m`` and any positive odd integer ``n`` the Jacobi symbol\\n    is defined as the product of the Legendre symbols corresponding to the\\n    prime factors of ``n``:\\n\\n    .. math ::\\n        \\\\genfrac(){}{}{m}{n} =\\n            \\\\genfrac(){}{}{m}{p^{1}}^{\\\\alpha_1}\\n            \\\\genfrac(){}{}{m}{p^{2}}^{\\\\alpha_2}\\n            ...\\n            \\\\genfrac(){}{}{m}{p^{k}}^{\\\\alpha_k}\\n            \\\\text{ where } n =\\n                p_1^{\\\\alpha_1}\\n                p_2^{\\\\alpha_2}\\n                ...\\n                p_k^{\\\\alpha_k}\\n\\n    Like the Legendre symbol, if the Jacobi symbol `\\\\genfrac(){}{}{m}{n} = -1`\\n    then ``m`` is a quadratic nonresidue modulo ``n``.\\n\\n    But, unlike the Legendre symbol, if the Jacobi symbol\\n    `\\\\genfrac(){}{}{m}{n} = 1` then ``m`` may or may not be a quadratic residue\\n    modulo ``n``.\\n\\n    Parameters\\n    ==========\\n\\n    m : integer\\n    n : odd positive integer\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import jacobi_symbol, legendre_symbol\\n    >>> from sympy import S\\n    >>> jacobi_symbol(45, 77)\\n    -1\\n    >>> jacobi_symbol(60, 121)\\n    1\\n\\n    The relationship between the ``jacobi_symbol`` and ``legendre_symbol`` can\\n    be demonstrated as follows:\\n\\n    >>> L = legendre_symbol\\n    >>> S(45).factors()\\n    {3: 2, 5: 1}\\n    >>> jacobi_symbol(7, 45) == L(7, 3)**2 * L(7, 5)**1\\n    True\\n\\n    See Also\\n    ========\\n\\n    is_quad_residue, legendre_symbol\\n    '\n    (m, n) = (as_int(m), as_int(n))\n    return int(jacobi(m, n))",
            "def jacobi_symbol(m, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Returns the Jacobi symbol `(m / n)`.\\n\\n    For any integer ``m`` and any positive odd integer ``n`` the Jacobi symbol\\n    is defined as the product of the Legendre symbols corresponding to the\\n    prime factors of ``n``:\\n\\n    .. math ::\\n        \\\\genfrac(){}{}{m}{n} =\\n            \\\\genfrac(){}{}{m}{p^{1}}^{\\\\alpha_1}\\n            \\\\genfrac(){}{}{m}{p^{2}}^{\\\\alpha_2}\\n            ...\\n            \\\\genfrac(){}{}{m}{p^{k}}^{\\\\alpha_k}\\n            \\\\text{ where } n =\\n                p_1^{\\\\alpha_1}\\n                p_2^{\\\\alpha_2}\\n                ...\\n                p_k^{\\\\alpha_k}\\n\\n    Like the Legendre symbol, if the Jacobi symbol `\\\\genfrac(){}{}{m}{n} = -1`\\n    then ``m`` is a quadratic nonresidue modulo ``n``.\\n\\n    But, unlike the Legendre symbol, if the Jacobi symbol\\n    `\\\\genfrac(){}{}{m}{n} = 1` then ``m`` may or may not be a quadratic residue\\n    modulo ``n``.\\n\\n    Parameters\\n    ==========\\n\\n    m : integer\\n    n : odd positive integer\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import jacobi_symbol, legendre_symbol\\n    >>> from sympy import S\\n    >>> jacobi_symbol(45, 77)\\n    -1\\n    >>> jacobi_symbol(60, 121)\\n    1\\n\\n    The relationship between the ``jacobi_symbol`` and ``legendre_symbol`` can\\n    be demonstrated as follows:\\n\\n    >>> L = legendre_symbol\\n    >>> S(45).factors()\\n    {3: 2, 5: 1}\\n    >>> jacobi_symbol(7, 45) == L(7, 3)**2 * L(7, 5)**1\\n    True\\n\\n    See Also\\n    ========\\n\\n    is_quad_residue, legendre_symbol\\n    '\n    (m, n) = (as_int(m), as_int(n))\n    return int(jacobi(m, n))"
        ]
    },
    {
        "func_name": "kronecker_symbol",
        "original": "def kronecker_symbol(a, n):\n    \"\"\"\n    Returns the Kronecker symbol `(a / n)`.\n\n    Parameters\n    ==========\n\n    a : integer\n    n : integer\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.residue_ntheory import kronecker_symbol\n    >>> kronecker_symbol(45, 77)\n    -1\n    >>> kronecker_symbol(13, -120)\n    1\n\n    See Also\n    ========\n\n    jacobi_symbol, legendre_symbol\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Kronecker_symbol\n\n    \"\"\"\n    return int(kronecker(as_int(a), as_int(n)))",
        "mutated": [
            "def kronecker_symbol(a, n):\n    if False:\n        i = 10\n    '\\n    Returns the Kronecker symbol `(a / n)`.\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    n : integer\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import kronecker_symbol\\n    >>> kronecker_symbol(45, 77)\\n    -1\\n    >>> kronecker_symbol(13, -120)\\n    1\\n\\n    See Also\\n    ========\\n\\n    jacobi_symbol, legendre_symbol\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Kronecker_symbol\\n\\n    '\n    return int(kronecker(as_int(a), as_int(n)))",
            "def kronecker_symbol(a, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Returns the Kronecker symbol `(a / n)`.\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    n : integer\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import kronecker_symbol\\n    >>> kronecker_symbol(45, 77)\\n    -1\\n    >>> kronecker_symbol(13, -120)\\n    1\\n\\n    See Also\\n    ========\\n\\n    jacobi_symbol, legendre_symbol\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Kronecker_symbol\\n\\n    '\n    return int(kronecker(as_int(a), as_int(n)))",
            "def kronecker_symbol(a, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Returns the Kronecker symbol `(a / n)`.\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    n : integer\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import kronecker_symbol\\n    >>> kronecker_symbol(45, 77)\\n    -1\\n    >>> kronecker_symbol(13, -120)\\n    1\\n\\n    See Also\\n    ========\\n\\n    jacobi_symbol, legendre_symbol\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Kronecker_symbol\\n\\n    '\n    return int(kronecker(as_int(a), as_int(n)))",
            "def kronecker_symbol(a, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Returns the Kronecker symbol `(a / n)`.\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    n : integer\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import kronecker_symbol\\n    >>> kronecker_symbol(45, 77)\\n    -1\\n    >>> kronecker_symbol(13, -120)\\n    1\\n\\n    See Also\\n    ========\\n\\n    jacobi_symbol, legendre_symbol\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Kronecker_symbol\\n\\n    '\n    return int(kronecker(as_int(a), as_int(n)))",
            "def kronecker_symbol(a, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Returns the Kronecker symbol `(a / n)`.\\n\\n    Parameters\\n    ==========\\n\\n    a : integer\\n    n : integer\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import kronecker_symbol\\n    >>> kronecker_symbol(45, 77)\\n    -1\\n    >>> kronecker_symbol(13, -120)\\n    1\\n\\n    See Also\\n    ========\\n\\n    jacobi_symbol, legendre_symbol\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Kronecker_symbol\\n\\n    '\n    return int(kronecker(as_int(a), as_int(n)))"
        ]
    },
    {
        "func_name": "eval",
        "original": "@classmethod\ndef eval(cls, n):\n    if n.is_integer:\n        if n.is_positive is not True:\n            raise ValueError('n should be a positive integer')\n    else:\n        raise TypeError('n should be an integer')\n    if n.is_prime:\n        return S.NegativeOne\n    elif n is S.One:\n        return S.One\n    elif n.is_Integer:\n        a = factorint(n)\n        if any((i > 1 for i in a.values())):\n            return S.Zero\n        return S.NegativeOne ** len(a)",
        "mutated": [
            "@classmethod\ndef eval(cls, n):\n    if False:\n        i = 10\n    if n.is_integer:\n        if n.is_positive is not True:\n            raise ValueError('n should be a positive integer')\n    else:\n        raise TypeError('n should be an integer')\n    if n.is_prime:\n        return S.NegativeOne\n    elif n is S.One:\n        return S.One\n    elif n.is_Integer:\n        a = factorint(n)\n        if any((i > 1 for i in a.values())):\n            return S.Zero\n        return S.NegativeOne ** len(a)",
            "@classmethod\ndef eval(cls, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if n.is_integer:\n        if n.is_positive is not True:\n            raise ValueError('n should be a positive integer')\n    else:\n        raise TypeError('n should be an integer')\n    if n.is_prime:\n        return S.NegativeOne\n    elif n is S.One:\n        return S.One\n    elif n.is_Integer:\n        a = factorint(n)\n        if any((i > 1 for i in a.values())):\n            return S.Zero\n        return S.NegativeOne ** len(a)",
            "@classmethod\ndef eval(cls, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if n.is_integer:\n        if n.is_positive is not True:\n            raise ValueError('n should be a positive integer')\n    else:\n        raise TypeError('n should be an integer')\n    if n.is_prime:\n        return S.NegativeOne\n    elif n is S.One:\n        return S.One\n    elif n.is_Integer:\n        a = factorint(n)\n        if any((i > 1 for i in a.values())):\n            return S.Zero\n        return S.NegativeOne ** len(a)",
            "@classmethod\ndef eval(cls, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if n.is_integer:\n        if n.is_positive is not True:\n            raise ValueError('n should be a positive integer')\n    else:\n        raise TypeError('n should be an integer')\n    if n.is_prime:\n        return S.NegativeOne\n    elif n is S.One:\n        return S.One\n    elif n.is_Integer:\n        a = factorint(n)\n        if any((i > 1 for i in a.values())):\n            return S.Zero\n        return S.NegativeOne ** len(a)",
            "@classmethod\ndef eval(cls, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if n.is_integer:\n        if n.is_positive is not True:\n            raise ValueError('n should be a positive integer')\n    else:\n        raise TypeError('n should be an integer')\n    if n.is_prime:\n        return S.NegativeOne\n    elif n is S.One:\n        return S.One\n    elif n.is_Integer:\n        a = factorint(n)\n        if any((i > 1 for i in a.values())):\n            return S.Zero\n        return S.NegativeOne ** len(a)"
        ]
    },
    {
        "func_name": "_discrete_log_trial_mul",
        "original": "def _discrete_log_trial_mul(n, a, b, order=None):\n    \"\"\"\n    Trial multiplication algorithm for computing the discrete logarithm of\n    ``a`` to the base ``b`` modulo ``n``.\n\n    The algorithm finds the discrete logarithm using exhaustive search. This\n    naive method is used as fallback algorithm of ``discrete_log`` when the\n    group order is very small.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.residue_ntheory import _discrete_log_trial_mul\n    >>> _discrete_log_trial_mul(41, 15, 7)\n    3\n\n    See Also\n    ========\n\n    discrete_log\n\n    References\n    ==========\n\n    .. [1] \"Handbook of applied cryptography\", Menezes, A. J., Van, O. P. C., &\n        Vanstone, S. A. (1997).\n    \"\"\"\n    a %= n\n    b %= n\n    if order is None:\n        order = n\n    x = 1\n    for i in range(order):\n        if x == a:\n            return i\n        x = x * b % n\n    raise ValueError('Log does not exist')",
        "mutated": [
            "def _discrete_log_trial_mul(n, a, b, order=None):\n    if False:\n        i = 10\n    '\\n    Trial multiplication algorithm for computing the discrete logarithm of\\n    ``a`` to the base ``b`` modulo ``n``.\\n\\n    The algorithm finds the discrete logarithm using exhaustive search. This\\n    naive method is used as fallback algorithm of ``discrete_log`` when the\\n    group order is very small.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _discrete_log_trial_mul\\n    >>> _discrete_log_trial_mul(41, 15, 7)\\n    3\\n\\n    See Also\\n    ========\\n\\n    discrete_log\\n\\n    References\\n    ==========\\n\\n    .. [1] \"Handbook of applied cryptography\", Menezes, A. J., Van, O. P. C., &\\n        Vanstone, S. A. (1997).\\n    '\n    a %= n\n    b %= n\n    if order is None:\n        order = n\n    x = 1\n    for i in range(order):\n        if x == a:\n            return i\n        x = x * b % n\n    raise ValueError('Log does not exist')",
            "def _discrete_log_trial_mul(n, a, b, order=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Trial multiplication algorithm for computing the discrete logarithm of\\n    ``a`` to the base ``b`` modulo ``n``.\\n\\n    The algorithm finds the discrete logarithm using exhaustive search. This\\n    naive method is used as fallback algorithm of ``discrete_log`` when the\\n    group order is very small.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _discrete_log_trial_mul\\n    >>> _discrete_log_trial_mul(41, 15, 7)\\n    3\\n\\n    See Also\\n    ========\\n\\n    discrete_log\\n\\n    References\\n    ==========\\n\\n    .. [1] \"Handbook of applied cryptography\", Menezes, A. J., Van, O. P. C., &\\n        Vanstone, S. A. (1997).\\n    '\n    a %= n\n    b %= n\n    if order is None:\n        order = n\n    x = 1\n    for i in range(order):\n        if x == a:\n            return i\n        x = x * b % n\n    raise ValueError('Log does not exist')",
            "def _discrete_log_trial_mul(n, a, b, order=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Trial multiplication algorithm for computing the discrete logarithm of\\n    ``a`` to the base ``b`` modulo ``n``.\\n\\n    The algorithm finds the discrete logarithm using exhaustive search. This\\n    naive method is used as fallback algorithm of ``discrete_log`` when the\\n    group order is very small.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _discrete_log_trial_mul\\n    >>> _discrete_log_trial_mul(41, 15, 7)\\n    3\\n\\n    See Also\\n    ========\\n\\n    discrete_log\\n\\n    References\\n    ==========\\n\\n    .. [1] \"Handbook of applied cryptography\", Menezes, A. J., Van, O. P. C., &\\n        Vanstone, S. A. (1997).\\n    '\n    a %= n\n    b %= n\n    if order is None:\n        order = n\n    x = 1\n    for i in range(order):\n        if x == a:\n            return i\n        x = x * b % n\n    raise ValueError('Log does not exist')",
            "def _discrete_log_trial_mul(n, a, b, order=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Trial multiplication algorithm for computing the discrete logarithm of\\n    ``a`` to the base ``b`` modulo ``n``.\\n\\n    The algorithm finds the discrete logarithm using exhaustive search. This\\n    naive method is used as fallback algorithm of ``discrete_log`` when the\\n    group order is very small.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _discrete_log_trial_mul\\n    >>> _discrete_log_trial_mul(41, 15, 7)\\n    3\\n\\n    See Also\\n    ========\\n\\n    discrete_log\\n\\n    References\\n    ==========\\n\\n    .. [1] \"Handbook of applied cryptography\", Menezes, A. J., Van, O. P. C., &\\n        Vanstone, S. A. (1997).\\n    '\n    a %= n\n    b %= n\n    if order is None:\n        order = n\n    x = 1\n    for i in range(order):\n        if x == a:\n            return i\n        x = x * b % n\n    raise ValueError('Log does not exist')",
            "def _discrete_log_trial_mul(n, a, b, order=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Trial multiplication algorithm for computing the discrete logarithm of\\n    ``a`` to the base ``b`` modulo ``n``.\\n\\n    The algorithm finds the discrete logarithm using exhaustive search. This\\n    naive method is used as fallback algorithm of ``discrete_log`` when the\\n    group order is very small.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _discrete_log_trial_mul\\n    >>> _discrete_log_trial_mul(41, 15, 7)\\n    3\\n\\n    See Also\\n    ========\\n\\n    discrete_log\\n\\n    References\\n    ==========\\n\\n    .. [1] \"Handbook of applied cryptography\", Menezes, A. J., Van, O. P. C., &\\n        Vanstone, S. A. (1997).\\n    '\n    a %= n\n    b %= n\n    if order is None:\n        order = n\n    x = 1\n    for i in range(order):\n        if x == a:\n            return i\n        x = x * b % n\n    raise ValueError('Log does not exist')"
        ]
    },
    {
        "func_name": "_discrete_log_shanks_steps",
        "original": "def _discrete_log_shanks_steps(n, a, b, order=None):\n    \"\"\"\n    Baby-step giant-step algorithm for computing the discrete logarithm of\n    ``a`` to the base ``b`` modulo ``n``.\n\n    The algorithm is a time-memory trade-off of the method of exhaustive\n    search. It uses `O(sqrt(m))` memory, where `m` is the group order.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.residue_ntheory import _discrete_log_shanks_steps\n    >>> _discrete_log_shanks_steps(41, 15, 7)\n    3\n\n    See Also\n    ========\n\n    discrete_log\n\n    References\n    ==========\n\n    .. [1] \"Handbook of applied cryptography\", Menezes, A. J., Van, O. P. C., &\n        Vanstone, S. A. (1997).\n    \"\"\"\n    a %= n\n    b %= n\n    if order is None:\n        order = n_order(b, n)\n    m = sqrt(order) + 1\n    T = {}\n    x = 1\n    for i in range(m):\n        T[x] = i\n        x = x * b % n\n    z = pow(b, -m, n)\n    x = a\n    for i in range(m):\n        if x in T:\n            return i * m + T[x]\n        x = x * z % n\n    raise ValueError('Log does not exist')",
        "mutated": [
            "def _discrete_log_shanks_steps(n, a, b, order=None):\n    if False:\n        i = 10\n    '\\n    Baby-step giant-step algorithm for computing the discrete logarithm of\\n    ``a`` to the base ``b`` modulo ``n``.\\n\\n    The algorithm is a time-memory trade-off of the method of exhaustive\\n    search. It uses `O(sqrt(m))` memory, where `m` is the group order.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _discrete_log_shanks_steps\\n    >>> _discrete_log_shanks_steps(41, 15, 7)\\n    3\\n\\n    See Also\\n    ========\\n\\n    discrete_log\\n\\n    References\\n    ==========\\n\\n    .. [1] \"Handbook of applied cryptography\", Menezes, A. J., Van, O. P. C., &\\n        Vanstone, S. A. (1997).\\n    '\n    a %= n\n    b %= n\n    if order is None:\n        order = n_order(b, n)\n    m = sqrt(order) + 1\n    T = {}\n    x = 1\n    for i in range(m):\n        T[x] = i\n        x = x * b % n\n    z = pow(b, -m, n)\n    x = a\n    for i in range(m):\n        if x in T:\n            return i * m + T[x]\n        x = x * z % n\n    raise ValueError('Log does not exist')",
            "def _discrete_log_shanks_steps(n, a, b, order=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Baby-step giant-step algorithm for computing the discrete logarithm of\\n    ``a`` to the base ``b`` modulo ``n``.\\n\\n    The algorithm is a time-memory trade-off of the method of exhaustive\\n    search. It uses `O(sqrt(m))` memory, where `m` is the group order.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _discrete_log_shanks_steps\\n    >>> _discrete_log_shanks_steps(41, 15, 7)\\n    3\\n\\n    See Also\\n    ========\\n\\n    discrete_log\\n\\n    References\\n    ==========\\n\\n    .. [1] \"Handbook of applied cryptography\", Menezes, A. J., Van, O. P. C., &\\n        Vanstone, S. A. (1997).\\n    '\n    a %= n\n    b %= n\n    if order is None:\n        order = n_order(b, n)\n    m = sqrt(order) + 1\n    T = {}\n    x = 1\n    for i in range(m):\n        T[x] = i\n        x = x * b % n\n    z = pow(b, -m, n)\n    x = a\n    for i in range(m):\n        if x in T:\n            return i * m + T[x]\n        x = x * z % n\n    raise ValueError('Log does not exist')",
            "def _discrete_log_shanks_steps(n, a, b, order=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Baby-step giant-step algorithm for computing the discrete logarithm of\\n    ``a`` to the base ``b`` modulo ``n``.\\n\\n    The algorithm is a time-memory trade-off of the method of exhaustive\\n    search. It uses `O(sqrt(m))` memory, where `m` is the group order.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _discrete_log_shanks_steps\\n    >>> _discrete_log_shanks_steps(41, 15, 7)\\n    3\\n\\n    See Also\\n    ========\\n\\n    discrete_log\\n\\n    References\\n    ==========\\n\\n    .. [1] \"Handbook of applied cryptography\", Menezes, A. J., Van, O. P. C., &\\n        Vanstone, S. A. (1997).\\n    '\n    a %= n\n    b %= n\n    if order is None:\n        order = n_order(b, n)\n    m = sqrt(order) + 1\n    T = {}\n    x = 1\n    for i in range(m):\n        T[x] = i\n        x = x * b % n\n    z = pow(b, -m, n)\n    x = a\n    for i in range(m):\n        if x in T:\n            return i * m + T[x]\n        x = x * z % n\n    raise ValueError('Log does not exist')",
            "def _discrete_log_shanks_steps(n, a, b, order=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Baby-step giant-step algorithm for computing the discrete logarithm of\\n    ``a`` to the base ``b`` modulo ``n``.\\n\\n    The algorithm is a time-memory trade-off of the method of exhaustive\\n    search. It uses `O(sqrt(m))` memory, where `m` is the group order.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _discrete_log_shanks_steps\\n    >>> _discrete_log_shanks_steps(41, 15, 7)\\n    3\\n\\n    See Also\\n    ========\\n\\n    discrete_log\\n\\n    References\\n    ==========\\n\\n    .. [1] \"Handbook of applied cryptography\", Menezes, A. J., Van, O. P. C., &\\n        Vanstone, S. A. (1997).\\n    '\n    a %= n\n    b %= n\n    if order is None:\n        order = n_order(b, n)\n    m = sqrt(order) + 1\n    T = {}\n    x = 1\n    for i in range(m):\n        T[x] = i\n        x = x * b % n\n    z = pow(b, -m, n)\n    x = a\n    for i in range(m):\n        if x in T:\n            return i * m + T[x]\n        x = x * z % n\n    raise ValueError('Log does not exist')",
            "def _discrete_log_shanks_steps(n, a, b, order=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Baby-step giant-step algorithm for computing the discrete logarithm of\\n    ``a`` to the base ``b`` modulo ``n``.\\n\\n    The algorithm is a time-memory trade-off of the method of exhaustive\\n    search. It uses `O(sqrt(m))` memory, where `m` is the group order.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _discrete_log_shanks_steps\\n    >>> _discrete_log_shanks_steps(41, 15, 7)\\n    3\\n\\n    See Also\\n    ========\\n\\n    discrete_log\\n\\n    References\\n    ==========\\n\\n    .. [1] \"Handbook of applied cryptography\", Menezes, A. J., Van, O. P. C., &\\n        Vanstone, S. A. (1997).\\n    '\n    a %= n\n    b %= n\n    if order is None:\n        order = n_order(b, n)\n    m = sqrt(order) + 1\n    T = {}\n    x = 1\n    for i in range(m):\n        T[x] = i\n        x = x * b % n\n    z = pow(b, -m, n)\n    x = a\n    for i in range(m):\n        if x in T:\n            return i * m + T[x]\n        x = x * z % n\n    raise ValueError('Log does not exist')"
        ]
    },
    {
        "func_name": "_discrete_log_pollard_rho",
        "original": "def _discrete_log_pollard_rho(n, a, b, order=None, retries=10, rseed=None):\n    \"\"\"\n    Pollard's Rho algorithm for computing the discrete logarithm of ``a`` to\n    the base ``b`` modulo ``n``.\n\n    It is a randomized algorithm with the same expected running time as\n    ``_discrete_log_shanks_steps``, but requires a negligible amount of memory.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.residue_ntheory import _discrete_log_pollard_rho\n    >>> _discrete_log_pollard_rho(227, 3**7, 3)\n    7\n\n    See Also\n    ========\n\n    discrete_log\n\n    References\n    ==========\n\n    .. [1] \"Handbook of applied cryptography\", Menezes, A. J., Van, O. P. C., &\n        Vanstone, S. A. (1997).\n    \"\"\"\n    a %= n\n    b %= n\n    if order is None:\n        order = n_order(b, n)\n    randint = _randint(rseed)\n    for i in range(retries):\n        aa = randint(1, order - 1)\n        ba = randint(1, order - 1)\n        xa = pow(b, aa, n) * pow(a, ba, n) % n\n        c = xa % 3\n        if c == 0:\n            xb = a * xa % n\n            ab = aa\n            bb = (ba + 1) % order\n        elif c == 1:\n            xb = xa * xa % n\n            ab = (aa + aa) % order\n            bb = (ba + ba) % order\n        else:\n            xb = b * xa % n\n            ab = (aa + 1) % order\n            bb = ba\n        for j in range(order):\n            c = xa % 3\n            if c == 0:\n                xa = a * xa % n\n                ba = (ba + 1) % order\n            elif c == 1:\n                xa = xa * xa % n\n                aa = (aa + aa) % order\n                ba = (ba + ba) % order\n            else:\n                xa = b * xa % n\n                aa = (aa + 1) % order\n            c = xb % 3\n            if c == 0:\n                xb = a * xb % n\n                bb = (bb + 1) % order\n            elif c == 1:\n                xb = xb * xb % n\n                ab = (ab + ab) % order\n                bb = (bb + bb) % order\n            else:\n                xb = b * xb % n\n                ab = (ab + 1) % order\n            c = xb % 3\n            if c == 0:\n                xb = a * xb % n\n                bb = (bb + 1) % order\n            elif c == 1:\n                xb = xb * xb % n\n                ab = (ab + ab) % order\n                bb = (bb + bb) % order\n            else:\n                xb = b * xb % n\n                ab = (ab + 1) % order\n            if xa == xb:\n                r = (ba - bb) % order\n                try:\n                    e = invert(r, order) * (ab - aa) % order\n                    if (pow(b, e, n) - a) % n == 0:\n                        return e\n                except ZeroDivisionError:\n                    pass\n                break\n    raise ValueError(\"Pollard's Rho failed to find logarithm\")",
        "mutated": [
            "def _discrete_log_pollard_rho(n, a, b, order=None, retries=10, rseed=None):\n    if False:\n        i = 10\n    '\\n    Pollard\\'s Rho algorithm for computing the discrete logarithm of ``a`` to\\n    the base ``b`` modulo ``n``.\\n\\n    It is a randomized algorithm with the same expected running time as\\n    ``_discrete_log_shanks_steps``, but requires a negligible amount of memory.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _discrete_log_pollard_rho\\n    >>> _discrete_log_pollard_rho(227, 3**7, 3)\\n    7\\n\\n    See Also\\n    ========\\n\\n    discrete_log\\n\\n    References\\n    ==========\\n\\n    .. [1] \"Handbook of applied cryptography\", Menezes, A. J., Van, O. P. C., &\\n        Vanstone, S. A. (1997).\\n    '\n    a %= n\n    b %= n\n    if order is None:\n        order = n_order(b, n)\n    randint = _randint(rseed)\n    for i in range(retries):\n        aa = randint(1, order - 1)\n        ba = randint(1, order - 1)\n        xa = pow(b, aa, n) * pow(a, ba, n) % n\n        c = xa % 3\n        if c == 0:\n            xb = a * xa % n\n            ab = aa\n            bb = (ba + 1) % order\n        elif c == 1:\n            xb = xa * xa % n\n            ab = (aa + aa) % order\n            bb = (ba + ba) % order\n        else:\n            xb = b * xa % n\n            ab = (aa + 1) % order\n            bb = ba\n        for j in range(order):\n            c = xa % 3\n            if c == 0:\n                xa = a * xa % n\n                ba = (ba + 1) % order\n            elif c == 1:\n                xa = xa * xa % n\n                aa = (aa + aa) % order\n                ba = (ba + ba) % order\n            else:\n                xa = b * xa % n\n                aa = (aa + 1) % order\n            c = xb % 3\n            if c == 0:\n                xb = a * xb % n\n                bb = (bb + 1) % order\n            elif c == 1:\n                xb = xb * xb % n\n                ab = (ab + ab) % order\n                bb = (bb + bb) % order\n            else:\n                xb = b * xb % n\n                ab = (ab + 1) % order\n            c = xb % 3\n            if c == 0:\n                xb = a * xb % n\n                bb = (bb + 1) % order\n            elif c == 1:\n                xb = xb * xb % n\n                ab = (ab + ab) % order\n                bb = (bb + bb) % order\n            else:\n                xb = b * xb % n\n                ab = (ab + 1) % order\n            if xa == xb:\n                r = (ba - bb) % order\n                try:\n                    e = invert(r, order) * (ab - aa) % order\n                    if (pow(b, e, n) - a) % n == 0:\n                        return e\n                except ZeroDivisionError:\n                    pass\n                break\n    raise ValueError(\"Pollard's Rho failed to find logarithm\")",
            "def _discrete_log_pollard_rho(n, a, b, order=None, retries=10, rseed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Pollard\\'s Rho algorithm for computing the discrete logarithm of ``a`` to\\n    the base ``b`` modulo ``n``.\\n\\n    It is a randomized algorithm with the same expected running time as\\n    ``_discrete_log_shanks_steps``, but requires a negligible amount of memory.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _discrete_log_pollard_rho\\n    >>> _discrete_log_pollard_rho(227, 3**7, 3)\\n    7\\n\\n    See Also\\n    ========\\n\\n    discrete_log\\n\\n    References\\n    ==========\\n\\n    .. [1] \"Handbook of applied cryptography\", Menezes, A. J., Van, O. P. C., &\\n        Vanstone, S. A. (1997).\\n    '\n    a %= n\n    b %= n\n    if order is None:\n        order = n_order(b, n)\n    randint = _randint(rseed)\n    for i in range(retries):\n        aa = randint(1, order - 1)\n        ba = randint(1, order - 1)\n        xa = pow(b, aa, n) * pow(a, ba, n) % n\n        c = xa % 3\n        if c == 0:\n            xb = a * xa % n\n            ab = aa\n            bb = (ba + 1) % order\n        elif c == 1:\n            xb = xa * xa % n\n            ab = (aa + aa) % order\n            bb = (ba + ba) % order\n        else:\n            xb = b * xa % n\n            ab = (aa + 1) % order\n            bb = ba\n        for j in range(order):\n            c = xa % 3\n            if c == 0:\n                xa = a * xa % n\n                ba = (ba + 1) % order\n            elif c == 1:\n                xa = xa * xa % n\n                aa = (aa + aa) % order\n                ba = (ba + ba) % order\n            else:\n                xa = b * xa % n\n                aa = (aa + 1) % order\n            c = xb % 3\n            if c == 0:\n                xb = a * xb % n\n                bb = (bb + 1) % order\n            elif c == 1:\n                xb = xb * xb % n\n                ab = (ab + ab) % order\n                bb = (bb + bb) % order\n            else:\n                xb = b * xb % n\n                ab = (ab + 1) % order\n            c = xb % 3\n            if c == 0:\n                xb = a * xb % n\n                bb = (bb + 1) % order\n            elif c == 1:\n                xb = xb * xb % n\n                ab = (ab + ab) % order\n                bb = (bb + bb) % order\n            else:\n                xb = b * xb % n\n                ab = (ab + 1) % order\n            if xa == xb:\n                r = (ba - bb) % order\n                try:\n                    e = invert(r, order) * (ab - aa) % order\n                    if (pow(b, e, n) - a) % n == 0:\n                        return e\n                except ZeroDivisionError:\n                    pass\n                break\n    raise ValueError(\"Pollard's Rho failed to find logarithm\")",
            "def _discrete_log_pollard_rho(n, a, b, order=None, retries=10, rseed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Pollard\\'s Rho algorithm for computing the discrete logarithm of ``a`` to\\n    the base ``b`` modulo ``n``.\\n\\n    It is a randomized algorithm with the same expected running time as\\n    ``_discrete_log_shanks_steps``, but requires a negligible amount of memory.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _discrete_log_pollard_rho\\n    >>> _discrete_log_pollard_rho(227, 3**7, 3)\\n    7\\n\\n    See Also\\n    ========\\n\\n    discrete_log\\n\\n    References\\n    ==========\\n\\n    .. [1] \"Handbook of applied cryptography\", Menezes, A. J., Van, O. P. C., &\\n        Vanstone, S. A. (1997).\\n    '\n    a %= n\n    b %= n\n    if order is None:\n        order = n_order(b, n)\n    randint = _randint(rseed)\n    for i in range(retries):\n        aa = randint(1, order - 1)\n        ba = randint(1, order - 1)\n        xa = pow(b, aa, n) * pow(a, ba, n) % n\n        c = xa % 3\n        if c == 0:\n            xb = a * xa % n\n            ab = aa\n            bb = (ba + 1) % order\n        elif c == 1:\n            xb = xa * xa % n\n            ab = (aa + aa) % order\n            bb = (ba + ba) % order\n        else:\n            xb = b * xa % n\n            ab = (aa + 1) % order\n            bb = ba\n        for j in range(order):\n            c = xa % 3\n            if c == 0:\n                xa = a * xa % n\n                ba = (ba + 1) % order\n            elif c == 1:\n                xa = xa * xa % n\n                aa = (aa + aa) % order\n                ba = (ba + ba) % order\n            else:\n                xa = b * xa % n\n                aa = (aa + 1) % order\n            c = xb % 3\n            if c == 0:\n                xb = a * xb % n\n                bb = (bb + 1) % order\n            elif c == 1:\n                xb = xb * xb % n\n                ab = (ab + ab) % order\n                bb = (bb + bb) % order\n            else:\n                xb = b * xb % n\n                ab = (ab + 1) % order\n            c = xb % 3\n            if c == 0:\n                xb = a * xb % n\n                bb = (bb + 1) % order\n            elif c == 1:\n                xb = xb * xb % n\n                ab = (ab + ab) % order\n                bb = (bb + bb) % order\n            else:\n                xb = b * xb % n\n                ab = (ab + 1) % order\n            if xa == xb:\n                r = (ba - bb) % order\n                try:\n                    e = invert(r, order) * (ab - aa) % order\n                    if (pow(b, e, n) - a) % n == 0:\n                        return e\n                except ZeroDivisionError:\n                    pass\n                break\n    raise ValueError(\"Pollard's Rho failed to find logarithm\")",
            "def _discrete_log_pollard_rho(n, a, b, order=None, retries=10, rseed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Pollard\\'s Rho algorithm for computing the discrete logarithm of ``a`` to\\n    the base ``b`` modulo ``n``.\\n\\n    It is a randomized algorithm with the same expected running time as\\n    ``_discrete_log_shanks_steps``, but requires a negligible amount of memory.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _discrete_log_pollard_rho\\n    >>> _discrete_log_pollard_rho(227, 3**7, 3)\\n    7\\n\\n    See Also\\n    ========\\n\\n    discrete_log\\n\\n    References\\n    ==========\\n\\n    .. [1] \"Handbook of applied cryptography\", Menezes, A. J., Van, O. P. C., &\\n        Vanstone, S. A. (1997).\\n    '\n    a %= n\n    b %= n\n    if order is None:\n        order = n_order(b, n)\n    randint = _randint(rseed)\n    for i in range(retries):\n        aa = randint(1, order - 1)\n        ba = randint(1, order - 1)\n        xa = pow(b, aa, n) * pow(a, ba, n) % n\n        c = xa % 3\n        if c == 0:\n            xb = a * xa % n\n            ab = aa\n            bb = (ba + 1) % order\n        elif c == 1:\n            xb = xa * xa % n\n            ab = (aa + aa) % order\n            bb = (ba + ba) % order\n        else:\n            xb = b * xa % n\n            ab = (aa + 1) % order\n            bb = ba\n        for j in range(order):\n            c = xa % 3\n            if c == 0:\n                xa = a * xa % n\n                ba = (ba + 1) % order\n            elif c == 1:\n                xa = xa * xa % n\n                aa = (aa + aa) % order\n                ba = (ba + ba) % order\n            else:\n                xa = b * xa % n\n                aa = (aa + 1) % order\n            c = xb % 3\n            if c == 0:\n                xb = a * xb % n\n                bb = (bb + 1) % order\n            elif c == 1:\n                xb = xb * xb % n\n                ab = (ab + ab) % order\n                bb = (bb + bb) % order\n            else:\n                xb = b * xb % n\n                ab = (ab + 1) % order\n            c = xb % 3\n            if c == 0:\n                xb = a * xb % n\n                bb = (bb + 1) % order\n            elif c == 1:\n                xb = xb * xb % n\n                ab = (ab + ab) % order\n                bb = (bb + bb) % order\n            else:\n                xb = b * xb % n\n                ab = (ab + 1) % order\n            if xa == xb:\n                r = (ba - bb) % order\n                try:\n                    e = invert(r, order) * (ab - aa) % order\n                    if (pow(b, e, n) - a) % n == 0:\n                        return e\n                except ZeroDivisionError:\n                    pass\n                break\n    raise ValueError(\"Pollard's Rho failed to find logarithm\")",
            "def _discrete_log_pollard_rho(n, a, b, order=None, retries=10, rseed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Pollard\\'s Rho algorithm for computing the discrete logarithm of ``a`` to\\n    the base ``b`` modulo ``n``.\\n\\n    It is a randomized algorithm with the same expected running time as\\n    ``_discrete_log_shanks_steps``, but requires a negligible amount of memory.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _discrete_log_pollard_rho\\n    >>> _discrete_log_pollard_rho(227, 3**7, 3)\\n    7\\n\\n    See Also\\n    ========\\n\\n    discrete_log\\n\\n    References\\n    ==========\\n\\n    .. [1] \"Handbook of applied cryptography\", Menezes, A. J., Van, O. P. C., &\\n        Vanstone, S. A. (1997).\\n    '\n    a %= n\n    b %= n\n    if order is None:\n        order = n_order(b, n)\n    randint = _randint(rseed)\n    for i in range(retries):\n        aa = randint(1, order - 1)\n        ba = randint(1, order - 1)\n        xa = pow(b, aa, n) * pow(a, ba, n) % n\n        c = xa % 3\n        if c == 0:\n            xb = a * xa % n\n            ab = aa\n            bb = (ba + 1) % order\n        elif c == 1:\n            xb = xa * xa % n\n            ab = (aa + aa) % order\n            bb = (ba + ba) % order\n        else:\n            xb = b * xa % n\n            ab = (aa + 1) % order\n            bb = ba\n        for j in range(order):\n            c = xa % 3\n            if c == 0:\n                xa = a * xa % n\n                ba = (ba + 1) % order\n            elif c == 1:\n                xa = xa * xa % n\n                aa = (aa + aa) % order\n                ba = (ba + ba) % order\n            else:\n                xa = b * xa % n\n                aa = (aa + 1) % order\n            c = xb % 3\n            if c == 0:\n                xb = a * xb % n\n                bb = (bb + 1) % order\n            elif c == 1:\n                xb = xb * xb % n\n                ab = (ab + ab) % order\n                bb = (bb + bb) % order\n            else:\n                xb = b * xb % n\n                ab = (ab + 1) % order\n            c = xb % 3\n            if c == 0:\n                xb = a * xb % n\n                bb = (bb + 1) % order\n            elif c == 1:\n                xb = xb * xb % n\n                ab = (ab + ab) % order\n                bb = (bb + bb) % order\n            else:\n                xb = b * xb % n\n                ab = (ab + 1) % order\n            if xa == xb:\n                r = (ba - bb) % order\n                try:\n                    e = invert(r, order) * (ab - aa) % order\n                    if (pow(b, e, n) - a) % n == 0:\n                        return e\n                except ZeroDivisionError:\n                    pass\n                break\n    raise ValueError(\"Pollard's Rho failed to find logarithm\")"
        ]
    },
    {
        "func_name": "_discrete_log_pohlig_hellman",
        "original": "def _discrete_log_pohlig_hellman(n, a, b, order=None):\n    \"\"\"\n    Pohlig-Hellman algorithm for computing the discrete logarithm of ``a`` to\n    the base ``b`` modulo ``n``.\n\n    In order to compute the discrete logarithm, the algorithm takes advantage\n    of the factorization of the group order. It is more efficient when the\n    group order factors into many small primes.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.residue_ntheory import _discrete_log_pohlig_hellman\n    >>> _discrete_log_pohlig_hellman(251, 210, 71)\n    197\n\n    See Also\n    ========\n\n    discrete_log\n\n    References\n    ==========\n\n    .. [1] \"Handbook of applied cryptography\", Menezes, A. J., Van, O. P. C., &\n        Vanstone, S. A. (1997).\n    \"\"\"\n    from .modular import crt\n    a %= n\n    b %= n\n    if order is None:\n        order = n_order(b, n)\n    f = factorint(order)\n    l = [0] * len(f)\n    for (i, (pi, ri)) in enumerate(f.items()):\n        for j in range(ri):\n            aj = pow(a * pow(b, -l[i], n), order // pi ** (j + 1), n)\n            bj = pow(b, order // pi, n)\n            cj = discrete_log(n, aj, bj, pi, True)\n            l[i] += cj * pi ** j\n    (d, _) = crt([pi ** ri for (pi, ri) in f.items()], l)\n    return d",
        "mutated": [
            "def _discrete_log_pohlig_hellman(n, a, b, order=None):\n    if False:\n        i = 10\n    '\\n    Pohlig-Hellman algorithm for computing the discrete logarithm of ``a`` to\\n    the base ``b`` modulo ``n``.\\n\\n    In order to compute the discrete logarithm, the algorithm takes advantage\\n    of the factorization of the group order. It is more efficient when the\\n    group order factors into many small primes.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _discrete_log_pohlig_hellman\\n    >>> _discrete_log_pohlig_hellman(251, 210, 71)\\n    197\\n\\n    See Also\\n    ========\\n\\n    discrete_log\\n\\n    References\\n    ==========\\n\\n    .. [1] \"Handbook of applied cryptography\", Menezes, A. J., Van, O. P. C., &\\n        Vanstone, S. A. (1997).\\n    '\n    from .modular import crt\n    a %= n\n    b %= n\n    if order is None:\n        order = n_order(b, n)\n    f = factorint(order)\n    l = [0] * len(f)\n    for (i, (pi, ri)) in enumerate(f.items()):\n        for j in range(ri):\n            aj = pow(a * pow(b, -l[i], n), order // pi ** (j + 1), n)\n            bj = pow(b, order // pi, n)\n            cj = discrete_log(n, aj, bj, pi, True)\n            l[i] += cj * pi ** j\n    (d, _) = crt([pi ** ri for (pi, ri) in f.items()], l)\n    return d",
            "def _discrete_log_pohlig_hellman(n, a, b, order=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Pohlig-Hellman algorithm for computing the discrete logarithm of ``a`` to\\n    the base ``b`` modulo ``n``.\\n\\n    In order to compute the discrete logarithm, the algorithm takes advantage\\n    of the factorization of the group order. It is more efficient when the\\n    group order factors into many small primes.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _discrete_log_pohlig_hellman\\n    >>> _discrete_log_pohlig_hellman(251, 210, 71)\\n    197\\n\\n    See Also\\n    ========\\n\\n    discrete_log\\n\\n    References\\n    ==========\\n\\n    .. [1] \"Handbook of applied cryptography\", Menezes, A. J., Van, O. P. C., &\\n        Vanstone, S. A. (1997).\\n    '\n    from .modular import crt\n    a %= n\n    b %= n\n    if order is None:\n        order = n_order(b, n)\n    f = factorint(order)\n    l = [0] * len(f)\n    for (i, (pi, ri)) in enumerate(f.items()):\n        for j in range(ri):\n            aj = pow(a * pow(b, -l[i], n), order // pi ** (j + 1), n)\n            bj = pow(b, order // pi, n)\n            cj = discrete_log(n, aj, bj, pi, True)\n            l[i] += cj * pi ** j\n    (d, _) = crt([pi ** ri for (pi, ri) in f.items()], l)\n    return d",
            "def _discrete_log_pohlig_hellman(n, a, b, order=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Pohlig-Hellman algorithm for computing the discrete logarithm of ``a`` to\\n    the base ``b`` modulo ``n``.\\n\\n    In order to compute the discrete logarithm, the algorithm takes advantage\\n    of the factorization of the group order. It is more efficient when the\\n    group order factors into many small primes.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _discrete_log_pohlig_hellman\\n    >>> _discrete_log_pohlig_hellman(251, 210, 71)\\n    197\\n\\n    See Also\\n    ========\\n\\n    discrete_log\\n\\n    References\\n    ==========\\n\\n    .. [1] \"Handbook of applied cryptography\", Menezes, A. J., Van, O. P. C., &\\n        Vanstone, S. A. (1997).\\n    '\n    from .modular import crt\n    a %= n\n    b %= n\n    if order is None:\n        order = n_order(b, n)\n    f = factorint(order)\n    l = [0] * len(f)\n    for (i, (pi, ri)) in enumerate(f.items()):\n        for j in range(ri):\n            aj = pow(a * pow(b, -l[i], n), order // pi ** (j + 1), n)\n            bj = pow(b, order // pi, n)\n            cj = discrete_log(n, aj, bj, pi, True)\n            l[i] += cj * pi ** j\n    (d, _) = crt([pi ** ri for (pi, ri) in f.items()], l)\n    return d",
            "def _discrete_log_pohlig_hellman(n, a, b, order=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Pohlig-Hellman algorithm for computing the discrete logarithm of ``a`` to\\n    the base ``b`` modulo ``n``.\\n\\n    In order to compute the discrete logarithm, the algorithm takes advantage\\n    of the factorization of the group order. It is more efficient when the\\n    group order factors into many small primes.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _discrete_log_pohlig_hellman\\n    >>> _discrete_log_pohlig_hellman(251, 210, 71)\\n    197\\n\\n    See Also\\n    ========\\n\\n    discrete_log\\n\\n    References\\n    ==========\\n\\n    .. [1] \"Handbook of applied cryptography\", Menezes, A. J., Van, O. P. C., &\\n        Vanstone, S. A. (1997).\\n    '\n    from .modular import crt\n    a %= n\n    b %= n\n    if order is None:\n        order = n_order(b, n)\n    f = factorint(order)\n    l = [0] * len(f)\n    for (i, (pi, ri)) in enumerate(f.items()):\n        for j in range(ri):\n            aj = pow(a * pow(b, -l[i], n), order // pi ** (j + 1), n)\n            bj = pow(b, order // pi, n)\n            cj = discrete_log(n, aj, bj, pi, True)\n            l[i] += cj * pi ** j\n    (d, _) = crt([pi ** ri for (pi, ri) in f.items()], l)\n    return d",
            "def _discrete_log_pohlig_hellman(n, a, b, order=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Pohlig-Hellman algorithm for computing the discrete logarithm of ``a`` to\\n    the base ``b`` modulo ``n``.\\n\\n    In order to compute the discrete logarithm, the algorithm takes advantage\\n    of the factorization of the group order. It is more efficient when the\\n    group order factors into many small primes.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _discrete_log_pohlig_hellman\\n    >>> _discrete_log_pohlig_hellman(251, 210, 71)\\n    197\\n\\n    See Also\\n    ========\\n\\n    discrete_log\\n\\n    References\\n    ==========\\n\\n    .. [1] \"Handbook of applied cryptography\", Menezes, A. J., Van, O. P. C., &\\n        Vanstone, S. A. (1997).\\n    '\n    from .modular import crt\n    a %= n\n    b %= n\n    if order is None:\n        order = n_order(b, n)\n    f = factorint(order)\n    l = [0] * len(f)\n    for (i, (pi, ri)) in enumerate(f.items()):\n        for j in range(ri):\n            aj = pow(a * pow(b, -l[i], n), order // pi ** (j + 1), n)\n            bj = pow(b, order // pi, n)\n            cj = discrete_log(n, aj, bj, pi, True)\n            l[i] += cj * pi ** j\n    (d, _) = crt([pi ** ri for (pi, ri) in f.items()], l)\n    return d"
        ]
    },
    {
        "func_name": "discrete_log",
        "original": "def discrete_log(n, a, b, order=None, prime_order=None):\n    \"\"\"\n    Compute the discrete logarithm of ``a`` to the base ``b`` modulo ``n``.\n\n    This is a recursive function to reduce the discrete logarithm problem in\n    cyclic groups of composite order to the problem in cyclic groups of prime\n    order.\n\n    It employs different algorithms depending on the problem (subgroup order\n    size, prime order or not):\n\n        * Trial multiplication\n        * Baby-step giant-step\n        * Pollard's Rho\n        * Pohlig-Hellman\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory import discrete_log\n    >>> discrete_log(41, 15, 7)\n    3\n\n    References\n    ==========\n\n    .. [1] https://mathworld.wolfram.com/DiscreteLogarithm.html\n    .. [2] \"Handbook of applied cryptography\", Menezes, A. J., Van, O. P. C., &\n        Vanstone, S. A. (1997).\n\n    \"\"\"\n    (n, a, b) = (as_int(n), as_int(a), as_int(b))\n    if order is None:\n        order = n_order(b, n)\n    if prime_order is None:\n        prime_order = isprime(order)\n    if order < 1000:\n        return _discrete_log_trial_mul(n, a, b, order)\n    elif prime_order:\n        if order < 1000000000000:\n            return _discrete_log_shanks_steps(n, a, b, order)\n        return _discrete_log_pollard_rho(n, a, b, order)\n    return _discrete_log_pohlig_hellman(n, a, b, order)",
        "mutated": [
            "def discrete_log(n, a, b, order=None, prime_order=None):\n    if False:\n        i = 10\n    '\\n    Compute the discrete logarithm of ``a`` to the base ``b`` modulo ``n``.\\n\\n    This is a recursive function to reduce the discrete logarithm problem in\\n    cyclic groups of composite order to the problem in cyclic groups of prime\\n    order.\\n\\n    It employs different algorithms depending on the problem (subgroup order\\n    size, prime order or not):\\n\\n        * Trial multiplication\\n        * Baby-step giant-step\\n        * Pollard\\'s Rho\\n        * Pohlig-Hellman\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import discrete_log\\n    >>> discrete_log(41, 15, 7)\\n    3\\n\\n    References\\n    ==========\\n\\n    .. [1] https://mathworld.wolfram.com/DiscreteLogarithm.html\\n    .. [2] \"Handbook of applied cryptography\", Menezes, A. J., Van, O. P. C., &\\n        Vanstone, S. A. (1997).\\n\\n    '\n    (n, a, b) = (as_int(n), as_int(a), as_int(b))\n    if order is None:\n        order = n_order(b, n)\n    if prime_order is None:\n        prime_order = isprime(order)\n    if order < 1000:\n        return _discrete_log_trial_mul(n, a, b, order)\n    elif prime_order:\n        if order < 1000000000000:\n            return _discrete_log_shanks_steps(n, a, b, order)\n        return _discrete_log_pollard_rho(n, a, b, order)\n    return _discrete_log_pohlig_hellman(n, a, b, order)",
            "def discrete_log(n, a, b, order=None, prime_order=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Compute the discrete logarithm of ``a`` to the base ``b`` modulo ``n``.\\n\\n    This is a recursive function to reduce the discrete logarithm problem in\\n    cyclic groups of composite order to the problem in cyclic groups of prime\\n    order.\\n\\n    It employs different algorithms depending on the problem (subgroup order\\n    size, prime order or not):\\n\\n        * Trial multiplication\\n        * Baby-step giant-step\\n        * Pollard\\'s Rho\\n        * Pohlig-Hellman\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import discrete_log\\n    >>> discrete_log(41, 15, 7)\\n    3\\n\\n    References\\n    ==========\\n\\n    .. [1] https://mathworld.wolfram.com/DiscreteLogarithm.html\\n    .. [2] \"Handbook of applied cryptography\", Menezes, A. J., Van, O. P. C., &\\n        Vanstone, S. A. (1997).\\n\\n    '\n    (n, a, b) = (as_int(n), as_int(a), as_int(b))\n    if order is None:\n        order = n_order(b, n)\n    if prime_order is None:\n        prime_order = isprime(order)\n    if order < 1000:\n        return _discrete_log_trial_mul(n, a, b, order)\n    elif prime_order:\n        if order < 1000000000000:\n            return _discrete_log_shanks_steps(n, a, b, order)\n        return _discrete_log_pollard_rho(n, a, b, order)\n    return _discrete_log_pohlig_hellman(n, a, b, order)",
            "def discrete_log(n, a, b, order=None, prime_order=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Compute the discrete logarithm of ``a`` to the base ``b`` modulo ``n``.\\n\\n    This is a recursive function to reduce the discrete logarithm problem in\\n    cyclic groups of composite order to the problem in cyclic groups of prime\\n    order.\\n\\n    It employs different algorithms depending on the problem (subgroup order\\n    size, prime order or not):\\n\\n        * Trial multiplication\\n        * Baby-step giant-step\\n        * Pollard\\'s Rho\\n        * Pohlig-Hellman\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import discrete_log\\n    >>> discrete_log(41, 15, 7)\\n    3\\n\\n    References\\n    ==========\\n\\n    .. [1] https://mathworld.wolfram.com/DiscreteLogarithm.html\\n    .. [2] \"Handbook of applied cryptography\", Menezes, A. J., Van, O. P. C., &\\n        Vanstone, S. A. (1997).\\n\\n    '\n    (n, a, b) = (as_int(n), as_int(a), as_int(b))\n    if order is None:\n        order = n_order(b, n)\n    if prime_order is None:\n        prime_order = isprime(order)\n    if order < 1000:\n        return _discrete_log_trial_mul(n, a, b, order)\n    elif prime_order:\n        if order < 1000000000000:\n            return _discrete_log_shanks_steps(n, a, b, order)\n        return _discrete_log_pollard_rho(n, a, b, order)\n    return _discrete_log_pohlig_hellman(n, a, b, order)",
            "def discrete_log(n, a, b, order=None, prime_order=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Compute the discrete logarithm of ``a`` to the base ``b`` modulo ``n``.\\n\\n    This is a recursive function to reduce the discrete logarithm problem in\\n    cyclic groups of composite order to the problem in cyclic groups of prime\\n    order.\\n\\n    It employs different algorithms depending on the problem (subgroup order\\n    size, prime order or not):\\n\\n        * Trial multiplication\\n        * Baby-step giant-step\\n        * Pollard\\'s Rho\\n        * Pohlig-Hellman\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import discrete_log\\n    >>> discrete_log(41, 15, 7)\\n    3\\n\\n    References\\n    ==========\\n\\n    .. [1] https://mathworld.wolfram.com/DiscreteLogarithm.html\\n    .. [2] \"Handbook of applied cryptography\", Menezes, A. J., Van, O. P. C., &\\n        Vanstone, S. A. (1997).\\n\\n    '\n    (n, a, b) = (as_int(n), as_int(a), as_int(b))\n    if order is None:\n        order = n_order(b, n)\n    if prime_order is None:\n        prime_order = isprime(order)\n    if order < 1000:\n        return _discrete_log_trial_mul(n, a, b, order)\n    elif prime_order:\n        if order < 1000000000000:\n            return _discrete_log_shanks_steps(n, a, b, order)\n        return _discrete_log_pollard_rho(n, a, b, order)\n    return _discrete_log_pohlig_hellman(n, a, b, order)",
            "def discrete_log(n, a, b, order=None, prime_order=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Compute the discrete logarithm of ``a`` to the base ``b`` modulo ``n``.\\n\\n    This is a recursive function to reduce the discrete logarithm problem in\\n    cyclic groups of composite order to the problem in cyclic groups of prime\\n    order.\\n\\n    It employs different algorithms depending on the problem (subgroup order\\n    size, prime order or not):\\n\\n        * Trial multiplication\\n        * Baby-step giant-step\\n        * Pollard\\'s Rho\\n        * Pohlig-Hellman\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import discrete_log\\n    >>> discrete_log(41, 15, 7)\\n    3\\n\\n    References\\n    ==========\\n\\n    .. [1] https://mathworld.wolfram.com/DiscreteLogarithm.html\\n    .. [2] \"Handbook of applied cryptography\", Menezes, A. J., Van, O. P. C., &\\n        Vanstone, S. A. (1997).\\n\\n    '\n    (n, a, b) = (as_int(n), as_int(a), as_int(b))\n    if order is None:\n        order = n_order(b, n)\n    if prime_order is None:\n        prime_order = isprime(order)\n    if order < 1000:\n        return _discrete_log_trial_mul(n, a, b, order)\n    elif prime_order:\n        if order < 1000000000000:\n            return _discrete_log_shanks_steps(n, a, b, order)\n        return _discrete_log_pollard_rho(n, a, b, order)\n    return _discrete_log_pohlig_hellman(n, a, b, order)"
        ]
    },
    {
        "func_name": "quadratic_congruence",
        "original": "def quadratic_congruence(a, b, c, n):\n    \"\"\"\n    Find the solutions to `a x^2 + b x + c \\\\equiv 0 \\\\pmod{n}`.\n\n    Parameters\n    ==========\n\n    a : int\n    b : int\n    c : int\n    n : int\n        A positive integer.\n\n    Returns\n    =======\n\n    list[int] :\n        A sorted list of solutions. If no solution exists, ``[]``.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.residue_ntheory import quadratic_congruence\n    >>> quadratic_congruence(2, 5, 3, 7) # 2x^2 + 5x + 3 = 0 (mod 7)\n    [2, 6]\n    >>> quadratic_congruence(8, 6, 4, 15) # No solution\n    []\n\n    See Also\n    ========\n\n    polynomial_congruence : Solve the polynomial congruence\n\n    \"\"\"\n    a = as_int(a)\n    b = as_int(b)\n    c = as_int(c)\n    n = as_int(n)\n    if n <= 1:\n        raise ValueError('n should be an integer greater than 1')\n    a %= n\n    b %= n\n    c %= n\n    if a == 0:\n        return linear_congruence(b, -c, n)\n    if n == 2:\n        roots = []\n        if c == 0:\n            roots.append(0)\n        if (b + c) % 2:\n            roots.append(1)\n        return roots\n    if gcd(2 * a, n) == 1:\n        inv_a = invert(a, n)\n        b *= inv_a\n        c *= inv_a\n        if b % 2:\n            b += n\n        b >>= 1\n        return sorted(((i - b) % n for i in sqrt_mod_iter(b ** 2 - c, n)))\n    res = set()\n    for i in sqrt_mod_iter(b ** 2 - 4 * a * c, 4 * a * n):\n        res.update((j % n for j in linear_congruence(2 * a, i - b, 4 * a * n)))\n    return sorted(res)",
        "mutated": [
            "def quadratic_congruence(a, b, c, n):\n    if False:\n        i = 10\n    '\\n    Find the solutions to `a x^2 + b x + c \\\\equiv 0 \\\\pmod{n}`.\\n\\n    Parameters\\n    ==========\\n\\n    a : int\\n    b : int\\n    c : int\\n    n : int\\n        A positive integer.\\n\\n    Returns\\n    =======\\n\\n    list[int] :\\n        A sorted list of solutions. If no solution exists, ``[]``.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import quadratic_congruence\\n    >>> quadratic_congruence(2, 5, 3, 7) # 2x^2 + 5x + 3 = 0 (mod 7)\\n    [2, 6]\\n    >>> quadratic_congruence(8, 6, 4, 15) # No solution\\n    []\\n\\n    See Also\\n    ========\\n\\n    polynomial_congruence : Solve the polynomial congruence\\n\\n    '\n    a = as_int(a)\n    b = as_int(b)\n    c = as_int(c)\n    n = as_int(n)\n    if n <= 1:\n        raise ValueError('n should be an integer greater than 1')\n    a %= n\n    b %= n\n    c %= n\n    if a == 0:\n        return linear_congruence(b, -c, n)\n    if n == 2:\n        roots = []\n        if c == 0:\n            roots.append(0)\n        if (b + c) % 2:\n            roots.append(1)\n        return roots\n    if gcd(2 * a, n) == 1:\n        inv_a = invert(a, n)\n        b *= inv_a\n        c *= inv_a\n        if b % 2:\n            b += n\n        b >>= 1\n        return sorted(((i - b) % n for i in sqrt_mod_iter(b ** 2 - c, n)))\n    res = set()\n    for i in sqrt_mod_iter(b ** 2 - 4 * a * c, 4 * a * n):\n        res.update((j % n for j in linear_congruence(2 * a, i - b, 4 * a * n)))\n    return sorted(res)",
            "def quadratic_congruence(a, b, c, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Find the solutions to `a x^2 + b x + c \\\\equiv 0 \\\\pmod{n}`.\\n\\n    Parameters\\n    ==========\\n\\n    a : int\\n    b : int\\n    c : int\\n    n : int\\n        A positive integer.\\n\\n    Returns\\n    =======\\n\\n    list[int] :\\n        A sorted list of solutions. If no solution exists, ``[]``.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import quadratic_congruence\\n    >>> quadratic_congruence(2, 5, 3, 7) # 2x^2 + 5x + 3 = 0 (mod 7)\\n    [2, 6]\\n    >>> quadratic_congruence(8, 6, 4, 15) # No solution\\n    []\\n\\n    See Also\\n    ========\\n\\n    polynomial_congruence : Solve the polynomial congruence\\n\\n    '\n    a = as_int(a)\n    b = as_int(b)\n    c = as_int(c)\n    n = as_int(n)\n    if n <= 1:\n        raise ValueError('n should be an integer greater than 1')\n    a %= n\n    b %= n\n    c %= n\n    if a == 0:\n        return linear_congruence(b, -c, n)\n    if n == 2:\n        roots = []\n        if c == 0:\n            roots.append(0)\n        if (b + c) % 2:\n            roots.append(1)\n        return roots\n    if gcd(2 * a, n) == 1:\n        inv_a = invert(a, n)\n        b *= inv_a\n        c *= inv_a\n        if b % 2:\n            b += n\n        b >>= 1\n        return sorted(((i - b) % n for i in sqrt_mod_iter(b ** 2 - c, n)))\n    res = set()\n    for i in sqrt_mod_iter(b ** 2 - 4 * a * c, 4 * a * n):\n        res.update((j % n for j in linear_congruence(2 * a, i - b, 4 * a * n)))\n    return sorted(res)",
            "def quadratic_congruence(a, b, c, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Find the solutions to `a x^2 + b x + c \\\\equiv 0 \\\\pmod{n}`.\\n\\n    Parameters\\n    ==========\\n\\n    a : int\\n    b : int\\n    c : int\\n    n : int\\n        A positive integer.\\n\\n    Returns\\n    =======\\n\\n    list[int] :\\n        A sorted list of solutions. If no solution exists, ``[]``.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import quadratic_congruence\\n    >>> quadratic_congruence(2, 5, 3, 7) # 2x^2 + 5x + 3 = 0 (mod 7)\\n    [2, 6]\\n    >>> quadratic_congruence(8, 6, 4, 15) # No solution\\n    []\\n\\n    See Also\\n    ========\\n\\n    polynomial_congruence : Solve the polynomial congruence\\n\\n    '\n    a = as_int(a)\n    b = as_int(b)\n    c = as_int(c)\n    n = as_int(n)\n    if n <= 1:\n        raise ValueError('n should be an integer greater than 1')\n    a %= n\n    b %= n\n    c %= n\n    if a == 0:\n        return linear_congruence(b, -c, n)\n    if n == 2:\n        roots = []\n        if c == 0:\n            roots.append(0)\n        if (b + c) % 2:\n            roots.append(1)\n        return roots\n    if gcd(2 * a, n) == 1:\n        inv_a = invert(a, n)\n        b *= inv_a\n        c *= inv_a\n        if b % 2:\n            b += n\n        b >>= 1\n        return sorted(((i - b) % n for i in sqrt_mod_iter(b ** 2 - c, n)))\n    res = set()\n    for i in sqrt_mod_iter(b ** 2 - 4 * a * c, 4 * a * n):\n        res.update((j % n for j in linear_congruence(2 * a, i - b, 4 * a * n)))\n    return sorted(res)",
            "def quadratic_congruence(a, b, c, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Find the solutions to `a x^2 + b x + c \\\\equiv 0 \\\\pmod{n}`.\\n\\n    Parameters\\n    ==========\\n\\n    a : int\\n    b : int\\n    c : int\\n    n : int\\n        A positive integer.\\n\\n    Returns\\n    =======\\n\\n    list[int] :\\n        A sorted list of solutions. If no solution exists, ``[]``.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import quadratic_congruence\\n    >>> quadratic_congruence(2, 5, 3, 7) # 2x^2 + 5x + 3 = 0 (mod 7)\\n    [2, 6]\\n    >>> quadratic_congruence(8, 6, 4, 15) # No solution\\n    []\\n\\n    See Also\\n    ========\\n\\n    polynomial_congruence : Solve the polynomial congruence\\n\\n    '\n    a = as_int(a)\n    b = as_int(b)\n    c = as_int(c)\n    n = as_int(n)\n    if n <= 1:\n        raise ValueError('n should be an integer greater than 1')\n    a %= n\n    b %= n\n    c %= n\n    if a == 0:\n        return linear_congruence(b, -c, n)\n    if n == 2:\n        roots = []\n        if c == 0:\n            roots.append(0)\n        if (b + c) % 2:\n            roots.append(1)\n        return roots\n    if gcd(2 * a, n) == 1:\n        inv_a = invert(a, n)\n        b *= inv_a\n        c *= inv_a\n        if b % 2:\n            b += n\n        b >>= 1\n        return sorted(((i - b) % n for i in sqrt_mod_iter(b ** 2 - c, n)))\n    res = set()\n    for i in sqrt_mod_iter(b ** 2 - 4 * a * c, 4 * a * n):\n        res.update((j % n for j in linear_congruence(2 * a, i - b, 4 * a * n)))\n    return sorted(res)",
            "def quadratic_congruence(a, b, c, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Find the solutions to `a x^2 + b x + c \\\\equiv 0 \\\\pmod{n}`.\\n\\n    Parameters\\n    ==========\\n\\n    a : int\\n    b : int\\n    c : int\\n    n : int\\n        A positive integer.\\n\\n    Returns\\n    =======\\n\\n    list[int] :\\n        A sorted list of solutions. If no solution exists, ``[]``.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import quadratic_congruence\\n    >>> quadratic_congruence(2, 5, 3, 7) # 2x^2 + 5x + 3 = 0 (mod 7)\\n    [2, 6]\\n    >>> quadratic_congruence(8, 6, 4, 15) # No solution\\n    []\\n\\n    See Also\\n    ========\\n\\n    polynomial_congruence : Solve the polynomial congruence\\n\\n    '\n    a = as_int(a)\n    b = as_int(b)\n    c = as_int(c)\n    n = as_int(n)\n    if n <= 1:\n        raise ValueError('n should be an integer greater than 1')\n    a %= n\n    b %= n\n    c %= n\n    if a == 0:\n        return linear_congruence(b, -c, n)\n    if n == 2:\n        roots = []\n        if c == 0:\n            roots.append(0)\n        if (b + c) % 2:\n            roots.append(1)\n        return roots\n    if gcd(2 * a, n) == 1:\n        inv_a = invert(a, n)\n        b *= inv_a\n        c *= inv_a\n        if b % 2:\n            b += n\n        b >>= 1\n        return sorted(((i - b) % n for i in sqrt_mod_iter(b ** 2 - c, n)))\n    res = set()\n    for i in sqrt_mod_iter(b ** 2 - 4 * a * c, 4 * a * n):\n        res.update((j % n for j in linear_congruence(2 * a, i - b, 4 * a * n)))\n    return sorted(res)"
        ]
    },
    {
        "func_name": "_valid_expr",
        "original": "def _valid_expr(expr):\n    \"\"\"\n    return coefficients of expr if it is a univariate polynomial\n    with integer coefficients else raise a ValueError.\n    \"\"\"\n    if not expr.is_polynomial():\n        raise ValueError('The expression should be a polynomial')\n    polynomial = Poly(expr)\n    if not polynomial.is_univariate:\n        raise ValueError('The expression should be univariate')\n    if not polynomial.domain == ZZ:\n        raise ValueError('The expression should should have integer coefficients')\n    return polynomial.all_coeffs()",
        "mutated": [
            "def _valid_expr(expr):\n    if False:\n        i = 10\n    '\\n    return coefficients of expr if it is a univariate polynomial\\n    with integer coefficients else raise a ValueError.\\n    '\n    if not expr.is_polynomial():\n        raise ValueError('The expression should be a polynomial')\n    polynomial = Poly(expr)\n    if not polynomial.is_univariate:\n        raise ValueError('The expression should be univariate')\n    if not polynomial.domain == ZZ:\n        raise ValueError('The expression should should have integer coefficients')\n    return polynomial.all_coeffs()",
            "def _valid_expr(expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    return coefficients of expr if it is a univariate polynomial\\n    with integer coefficients else raise a ValueError.\\n    '\n    if not expr.is_polynomial():\n        raise ValueError('The expression should be a polynomial')\n    polynomial = Poly(expr)\n    if not polynomial.is_univariate:\n        raise ValueError('The expression should be univariate')\n    if not polynomial.domain == ZZ:\n        raise ValueError('The expression should should have integer coefficients')\n    return polynomial.all_coeffs()",
            "def _valid_expr(expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    return coefficients of expr if it is a univariate polynomial\\n    with integer coefficients else raise a ValueError.\\n    '\n    if not expr.is_polynomial():\n        raise ValueError('The expression should be a polynomial')\n    polynomial = Poly(expr)\n    if not polynomial.is_univariate:\n        raise ValueError('The expression should be univariate')\n    if not polynomial.domain == ZZ:\n        raise ValueError('The expression should should have integer coefficients')\n    return polynomial.all_coeffs()",
            "def _valid_expr(expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    return coefficients of expr if it is a univariate polynomial\\n    with integer coefficients else raise a ValueError.\\n    '\n    if not expr.is_polynomial():\n        raise ValueError('The expression should be a polynomial')\n    polynomial = Poly(expr)\n    if not polynomial.is_univariate:\n        raise ValueError('The expression should be univariate')\n    if not polynomial.domain == ZZ:\n        raise ValueError('The expression should should have integer coefficients')\n    return polynomial.all_coeffs()",
            "def _valid_expr(expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    return coefficients of expr if it is a univariate polynomial\\n    with integer coefficients else raise a ValueError.\\n    '\n    if not expr.is_polynomial():\n        raise ValueError('The expression should be a polynomial')\n    polynomial = Poly(expr)\n    if not polynomial.is_univariate:\n        raise ValueError('The expression should be univariate')\n    if not polynomial.domain == ZZ:\n        raise ValueError('The expression should should have integer coefficients')\n    return polynomial.all_coeffs()"
        ]
    },
    {
        "func_name": "polynomial_congruence",
        "original": "def polynomial_congruence(expr, m):\n    \"\"\"\n    Find the solutions to a polynomial congruence equation modulo m.\n\n    Parameters\n    ==========\n\n    expr : integer coefficient polynomial\n    m : positive integer\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory import polynomial_congruence\n    >>> from sympy.abc import x\n    >>> expr = x**6 - 2*x**5 -35\n    >>> polynomial_congruence(expr, 6125)\n    [3257]\n\n    See Also\n    ========\n\n    sympy.polys.galoistools.gf_csolve : low level solving routine used by this routine\n\n    \"\"\"\n    coefficients = _valid_expr(expr)\n    coefficients = [num % m for num in coefficients]\n    rank = len(coefficients)\n    if rank == 3:\n        return quadratic_congruence(*coefficients, m)\n    if rank == 2:\n        return quadratic_congruence(0, *coefficients, m)\n    if coefficients[0] == 1 and 1 + coefficients[-1] == sum(coefficients):\n        return nthroot_mod(-coefficients[-1], rank - 1, m, True)\n    return gf_csolve(coefficients, m)",
        "mutated": [
            "def polynomial_congruence(expr, m):\n    if False:\n        i = 10\n    '\\n    Find the solutions to a polynomial congruence equation modulo m.\\n\\n    Parameters\\n    ==========\\n\\n    expr : integer coefficient polynomial\\n    m : positive integer\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import polynomial_congruence\\n    >>> from sympy.abc import x\\n    >>> expr = x**6 - 2*x**5 -35\\n    >>> polynomial_congruence(expr, 6125)\\n    [3257]\\n\\n    See Also\\n    ========\\n\\n    sympy.polys.galoistools.gf_csolve : low level solving routine used by this routine\\n\\n    '\n    coefficients = _valid_expr(expr)\n    coefficients = [num % m for num in coefficients]\n    rank = len(coefficients)\n    if rank == 3:\n        return quadratic_congruence(*coefficients, m)\n    if rank == 2:\n        return quadratic_congruence(0, *coefficients, m)\n    if coefficients[0] == 1 and 1 + coefficients[-1] == sum(coefficients):\n        return nthroot_mod(-coefficients[-1], rank - 1, m, True)\n    return gf_csolve(coefficients, m)",
            "def polynomial_congruence(expr, m):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Find the solutions to a polynomial congruence equation modulo m.\\n\\n    Parameters\\n    ==========\\n\\n    expr : integer coefficient polynomial\\n    m : positive integer\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import polynomial_congruence\\n    >>> from sympy.abc import x\\n    >>> expr = x**6 - 2*x**5 -35\\n    >>> polynomial_congruence(expr, 6125)\\n    [3257]\\n\\n    See Also\\n    ========\\n\\n    sympy.polys.galoistools.gf_csolve : low level solving routine used by this routine\\n\\n    '\n    coefficients = _valid_expr(expr)\n    coefficients = [num % m for num in coefficients]\n    rank = len(coefficients)\n    if rank == 3:\n        return quadratic_congruence(*coefficients, m)\n    if rank == 2:\n        return quadratic_congruence(0, *coefficients, m)\n    if coefficients[0] == 1 and 1 + coefficients[-1] == sum(coefficients):\n        return nthroot_mod(-coefficients[-1], rank - 1, m, True)\n    return gf_csolve(coefficients, m)",
            "def polynomial_congruence(expr, m):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Find the solutions to a polynomial congruence equation modulo m.\\n\\n    Parameters\\n    ==========\\n\\n    expr : integer coefficient polynomial\\n    m : positive integer\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import polynomial_congruence\\n    >>> from sympy.abc import x\\n    >>> expr = x**6 - 2*x**5 -35\\n    >>> polynomial_congruence(expr, 6125)\\n    [3257]\\n\\n    See Also\\n    ========\\n\\n    sympy.polys.galoistools.gf_csolve : low level solving routine used by this routine\\n\\n    '\n    coefficients = _valid_expr(expr)\n    coefficients = [num % m for num in coefficients]\n    rank = len(coefficients)\n    if rank == 3:\n        return quadratic_congruence(*coefficients, m)\n    if rank == 2:\n        return quadratic_congruence(0, *coefficients, m)\n    if coefficients[0] == 1 and 1 + coefficients[-1] == sum(coefficients):\n        return nthroot_mod(-coefficients[-1], rank - 1, m, True)\n    return gf_csolve(coefficients, m)",
            "def polynomial_congruence(expr, m):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Find the solutions to a polynomial congruence equation modulo m.\\n\\n    Parameters\\n    ==========\\n\\n    expr : integer coefficient polynomial\\n    m : positive integer\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import polynomial_congruence\\n    >>> from sympy.abc import x\\n    >>> expr = x**6 - 2*x**5 -35\\n    >>> polynomial_congruence(expr, 6125)\\n    [3257]\\n\\n    See Also\\n    ========\\n\\n    sympy.polys.galoistools.gf_csolve : low level solving routine used by this routine\\n\\n    '\n    coefficients = _valid_expr(expr)\n    coefficients = [num % m for num in coefficients]\n    rank = len(coefficients)\n    if rank == 3:\n        return quadratic_congruence(*coefficients, m)\n    if rank == 2:\n        return quadratic_congruence(0, *coefficients, m)\n    if coefficients[0] == 1 and 1 + coefficients[-1] == sum(coefficients):\n        return nthroot_mod(-coefficients[-1], rank - 1, m, True)\n    return gf_csolve(coefficients, m)",
            "def polynomial_congruence(expr, m):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Find the solutions to a polynomial congruence equation modulo m.\\n\\n    Parameters\\n    ==========\\n\\n    expr : integer coefficient polynomial\\n    m : positive integer\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory import polynomial_congruence\\n    >>> from sympy.abc import x\\n    >>> expr = x**6 - 2*x**5 -35\\n    >>> polynomial_congruence(expr, 6125)\\n    [3257]\\n\\n    See Also\\n    ========\\n\\n    sympy.polys.galoistools.gf_csolve : low level solving routine used by this routine\\n\\n    '\n    coefficients = _valid_expr(expr)\n    coefficients = [num % m for num in coefficients]\n    rank = len(coefficients)\n    if rank == 3:\n        return quadratic_congruence(*coefficients, m)\n    if rank == 2:\n        return quadratic_congruence(0, *coefficients, m)\n    if coefficients[0] == 1 and 1 + coefficients[-1] == sum(coefficients):\n        return nthroot_mod(-coefficients[-1], rank - 1, m, True)\n    return gf_csolve(coefficients, m)"
        ]
    },
    {
        "func_name": "binomial_mod",
        "original": "def binomial_mod(n, m, k):\n    \"\"\"Compute ``binomial(n, m) % k``.\n\n    Explanation\n    ===========\n\n    Returns ``binomial(n, m) % k`` using a generalization of Lucas'\n    Theorem for prime powers given by Granville [1]_, in conjunction with\n    the Chinese Remainder Theorem.  The residue for each prime power\n    is calculated in time O(log^2(n) + q^4*log(n)log(p) + q^4*p*log^3(p)).\n\n    Parameters\n    ==========\n\n    n : an integer\n    m : an integer\n    k : a positive integer\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.residue_ntheory import binomial_mod\n    >>> binomial_mod(10, 2, 6)  # binomial(10, 2) = 45\n    3\n    >>> binomial_mod(17, 9, 10)  # binomial(17, 9) = 24310\n    0\n\n    References\n    ==========\n\n    .. [1] Binomial coefficients modulo prime powers, Andrew Granville,\n        Available: https://web.archive.org/web/20170202003812/http://www.dms.umontreal.ca/~andrew/PDF/BinCoeff.pdf\n    \"\"\"\n    if k < 1:\n        raise ValueError('k is required to be positive')\n    if n < 0 or m < 0 or m > n:\n        return 0\n    factorisation = factorint(k)\n    residues = [_binomial_mod_prime_power(n, m, p, e) for (p, e) in factorisation.items()]\n    return crt([p ** pw for (p, pw) in factorisation.items()], residues, check=False)[0]",
        "mutated": [
            "def binomial_mod(n, m, k):\n    if False:\n        i = 10\n    \"Compute ``binomial(n, m) % k``.\\n\\n    Explanation\\n    ===========\\n\\n    Returns ``binomial(n, m) % k`` using a generalization of Lucas'\\n    Theorem for prime powers given by Granville [1]_, in conjunction with\\n    the Chinese Remainder Theorem.  The residue for each prime power\\n    is calculated in time O(log^2(n) + q^4*log(n)log(p) + q^4*p*log^3(p)).\\n\\n    Parameters\\n    ==========\\n\\n    n : an integer\\n    m : an integer\\n    k : a positive integer\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import binomial_mod\\n    >>> binomial_mod(10, 2, 6)  # binomial(10, 2) = 45\\n    3\\n    >>> binomial_mod(17, 9, 10)  # binomial(17, 9) = 24310\\n    0\\n\\n    References\\n    ==========\\n\\n    .. [1] Binomial coefficients modulo prime powers, Andrew Granville,\\n        Available: https://web.archive.org/web/20170202003812/http://www.dms.umontreal.ca/~andrew/PDF/BinCoeff.pdf\\n    \"\n    if k < 1:\n        raise ValueError('k is required to be positive')\n    if n < 0 or m < 0 or m > n:\n        return 0\n    factorisation = factorint(k)\n    residues = [_binomial_mod_prime_power(n, m, p, e) for (p, e) in factorisation.items()]\n    return crt([p ** pw for (p, pw) in factorisation.items()], residues, check=False)[0]",
            "def binomial_mod(n, m, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Compute ``binomial(n, m) % k``.\\n\\n    Explanation\\n    ===========\\n\\n    Returns ``binomial(n, m) % k`` using a generalization of Lucas'\\n    Theorem for prime powers given by Granville [1]_, in conjunction with\\n    the Chinese Remainder Theorem.  The residue for each prime power\\n    is calculated in time O(log^2(n) + q^4*log(n)log(p) + q^4*p*log^3(p)).\\n\\n    Parameters\\n    ==========\\n\\n    n : an integer\\n    m : an integer\\n    k : a positive integer\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import binomial_mod\\n    >>> binomial_mod(10, 2, 6)  # binomial(10, 2) = 45\\n    3\\n    >>> binomial_mod(17, 9, 10)  # binomial(17, 9) = 24310\\n    0\\n\\n    References\\n    ==========\\n\\n    .. [1] Binomial coefficients modulo prime powers, Andrew Granville,\\n        Available: https://web.archive.org/web/20170202003812/http://www.dms.umontreal.ca/~andrew/PDF/BinCoeff.pdf\\n    \"\n    if k < 1:\n        raise ValueError('k is required to be positive')\n    if n < 0 or m < 0 or m > n:\n        return 0\n    factorisation = factorint(k)\n    residues = [_binomial_mod_prime_power(n, m, p, e) for (p, e) in factorisation.items()]\n    return crt([p ** pw for (p, pw) in factorisation.items()], residues, check=False)[0]",
            "def binomial_mod(n, m, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Compute ``binomial(n, m) % k``.\\n\\n    Explanation\\n    ===========\\n\\n    Returns ``binomial(n, m) % k`` using a generalization of Lucas'\\n    Theorem for prime powers given by Granville [1]_, in conjunction with\\n    the Chinese Remainder Theorem.  The residue for each prime power\\n    is calculated in time O(log^2(n) + q^4*log(n)log(p) + q^4*p*log^3(p)).\\n\\n    Parameters\\n    ==========\\n\\n    n : an integer\\n    m : an integer\\n    k : a positive integer\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import binomial_mod\\n    >>> binomial_mod(10, 2, 6)  # binomial(10, 2) = 45\\n    3\\n    >>> binomial_mod(17, 9, 10)  # binomial(17, 9) = 24310\\n    0\\n\\n    References\\n    ==========\\n\\n    .. [1] Binomial coefficients modulo prime powers, Andrew Granville,\\n        Available: https://web.archive.org/web/20170202003812/http://www.dms.umontreal.ca/~andrew/PDF/BinCoeff.pdf\\n    \"\n    if k < 1:\n        raise ValueError('k is required to be positive')\n    if n < 0 or m < 0 or m > n:\n        return 0\n    factorisation = factorint(k)\n    residues = [_binomial_mod_prime_power(n, m, p, e) for (p, e) in factorisation.items()]\n    return crt([p ** pw for (p, pw) in factorisation.items()], residues, check=False)[0]",
            "def binomial_mod(n, m, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Compute ``binomial(n, m) % k``.\\n\\n    Explanation\\n    ===========\\n\\n    Returns ``binomial(n, m) % k`` using a generalization of Lucas'\\n    Theorem for prime powers given by Granville [1]_, in conjunction with\\n    the Chinese Remainder Theorem.  The residue for each prime power\\n    is calculated in time O(log^2(n) + q^4*log(n)log(p) + q^4*p*log^3(p)).\\n\\n    Parameters\\n    ==========\\n\\n    n : an integer\\n    m : an integer\\n    k : a positive integer\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import binomial_mod\\n    >>> binomial_mod(10, 2, 6)  # binomial(10, 2) = 45\\n    3\\n    >>> binomial_mod(17, 9, 10)  # binomial(17, 9) = 24310\\n    0\\n\\n    References\\n    ==========\\n\\n    .. [1] Binomial coefficients modulo prime powers, Andrew Granville,\\n        Available: https://web.archive.org/web/20170202003812/http://www.dms.umontreal.ca/~andrew/PDF/BinCoeff.pdf\\n    \"\n    if k < 1:\n        raise ValueError('k is required to be positive')\n    if n < 0 or m < 0 or m > n:\n        return 0\n    factorisation = factorint(k)\n    residues = [_binomial_mod_prime_power(n, m, p, e) for (p, e) in factorisation.items()]\n    return crt([p ** pw for (p, pw) in factorisation.items()], residues, check=False)[0]",
            "def binomial_mod(n, m, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Compute ``binomial(n, m) % k``.\\n\\n    Explanation\\n    ===========\\n\\n    Returns ``binomial(n, m) % k`` using a generalization of Lucas'\\n    Theorem for prime powers given by Granville [1]_, in conjunction with\\n    the Chinese Remainder Theorem.  The residue for each prime power\\n    is calculated in time O(log^2(n) + q^4*log(n)log(p) + q^4*p*log^3(p)).\\n\\n    Parameters\\n    ==========\\n\\n    n : an integer\\n    m : an integer\\n    k : a positive integer\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import binomial_mod\\n    >>> binomial_mod(10, 2, 6)  # binomial(10, 2) = 45\\n    3\\n    >>> binomial_mod(17, 9, 10)  # binomial(17, 9) = 24310\\n    0\\n\\n    References\\n    ==========\\n\\n    .. [1] Binomial coefficients modulo prime powers, Andrew Granville,\\n        Available: https://web.archive.org/web/20170202003812/http://www.dms.umontreal.ca/~andrew/PDF/BinCoeff.pdf\\n    \"\n    if k < 1:\n        raise ValueError('k is required to be positive')\n    if n < 0 or m < 0 or m > n:\n        return 0\n    factorisation = factorint(k)\n    residues = [_binomial_mod_prime_power(n, m, p, e) for (p, e) in factorisation.items()]\n    return crt([p ** pw for (p, pw) in factorisation.items()], residues, check=False)[0]"
        ]
    },
    {
        "func_name": "up_factorial",
        "original": "def up_factorial(u):\n    \"\"\"Compute (u*p)!_p modulo p^q.\"\"\"\n    r = q // 2\n    fac = prod = 1\n    if r == 1 and p == 2 or 2 * r + 1 in (p, p * p):\n        if q % 2 == 1:\n            r += 1\n        (modulo, div) = (pow(p, 2 * r), pow(p, 2 * r - q))\n    else:\n        (modulo, div) = (pow(p, 2 * r + 1), pow(p, 2 * r + 1 - q))\n    for j in range(1, r + 1):\n        for mul in range((j - 1) * p + 1, j * p):\n            fac *= mul\n            fac %= modulo\n        bj_ = bj(u, j, r)\n        prod *= pow(fac, bj_, modulo)\n        prod %= modulo\n    if p == 2:\n        sm = u // 2\n        for j in range(1, r + 1):\n            sm += j // 2 * bj(u, j, r)\n        if sm % 2 == 1:\n            prod *= -1\n    prod %= modulo // div\n    return prod % modulo",
        "mutated": [
            "def up_factorial(u):\n    if False:\n        i = 10\n    'Compute (u*p)!_p modulo p^q.'\n    r = q // 2\n    fac = prod = 1\n    if r == 1 and p == 2 or 2 * r + 1 in (p, p * p):\n        if q % 2 == 1:\n            r += 1\n        (modulo, div) = (pow(p, 2 * r), pow(p, 2 * r - q))\n    else:\n        (modulo, div) = (pow(p, 2 * r + 1), pow(p, 2 * r + 1 - q))\n    for j in range(1, r + 1):\n        for mul in range((j - 1) * p + 1, j * p):\n            fac *= mul\n            fac %= modulo\n        bj_ = bj(u, j, r)\n        prod *= pow(fac, bj_, modulo)\n        prod %= modulo\n    if p == 2:\n        sm = u // 2\n        for j in range(1, r + 1):\n            sm += j // 2 * bj(u, j, r)\n        if sm % 2 == 1:\n            prod *= -1\n    prod %= modulo // div\n    return prod % modulo",
            "def up_factorial(u):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Compute (u*p)!_p modulo p^q.'\n    r = q // 2\n    fac = prod = 1\n    if r == 1 and p == 2 or 2 * r + 1 in (p, p * p):\n        if q % 2 == 1:\n            r += 1\n        (modulo, div) = (pow(p, 2 * r), pow(p, 2 * r - q))\n    else:\n        (modulo, div) = (pow(p, 2 * r + 1), pow(p, 2 * r + 1 - q))\n    for j in range(1, r + 1):\n        for mul in range((j - 1) * p + 1, j * p):\n            fac *= mul\n            fac %= modulo\n        bj_ = bj(u, j, r)\n        prod *= pow(fac, bj_, modulo)\n        prod %= modulo\n    if p == 2:\n        sm = u // 2\n        for j in range(1, r + 1):\n            sm += j // 2 * bj(u, j, r)\n        if sm % 2 == 1:\n            prod *= -1\n    prod %= modulo // div\n    return prod % modulo",
            "def up_factorial(u):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Compute (u*p)!_p modulo p^q.'\n    r = q // 2\n    fac = prod = 1\n    if r == 1 and p == 2 or 2 * r + 1 in (p, p * p):\n        if q % 2 == 1:\n            r += 1\n        (modulo, div) = (pow(p, 2 * r), pow(p, 2 * r - q))\n    else:\n        (modulo, div) = (pow(p, 2 * r + 1), pow(p, 2 * r + 1 - q))\n    for j in range(1, r + 1):\n        for mul in range((j - 1) * p + 1, j * p):\n            fac *= mul\n            fac %= modulo\n        bj_ = bj(u, j, r)\n        prod *= pow(fac, bj_, modulo)\n        prod %= modulo\n    if p == 2:\n        sm = u // 2\n        for j in range(1, r + 1):\n            sm += j // 2 * bj(u, j, r)\n        if sm % 2 == 1:\n            prod *= -1\n    prod %= modulo // div\n    return prod % modulo",
            "def up_factorial(u):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Compute (u*p)!_p modulo p^q.'\n    r = q // 2\n    fac = prod = 1\n    if r == 1 and p == 2 or 2 * r + 1 in (p, p * p):\n        if q % 2 == 1:\n            r += 1\n        (modulo, div) = (pow(p, 2 * r), pow(p, 2 * r - q))\n    else:\n        (modulo, div) = (pow(p, 2 * r + 1), pow(p, 2 * r + 1 - q))\n    for j in range(1, r + 1):\n        for mul in range((j - 1) * p + 1, j * p):\n            fac *= mul\n            fac %= modulo\n        bj_ = bj(u, j, r)\n        prod *= pow(fac, bj_, modulo)\n        prod %= modulo\n    if p == 2:\n        sm = u // 2\n        for j in range(1, r + 1):\n            sm += j // 2 * bj(u, j, r)\n        if sm % 2 == 1:\n            prod *= -1\n    prod %= modulo // div\n    return prod % modulo",
            "def up_factorial(u):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Compute (u*p)!_p modulo p^q.'\n    r = q // 2\n    fac = prod = 1\n    if r == 1 and p == 2 or 2 * r + 1 in (p, p * p):\n        if q % 2 == 1:\n            r += 1\n        (modulo, div) = (pow(p, 2 * r), pow(p, 2 * r - q))\n    else:\n        (modulo, div) = (pow(p, 2 * r + 1), pow(p, 2 * r + 1 - q))\n    for j in range(1, r + 1):\n        for mul in range((j - 1) * p + 1, j * p):\n            fac *= mul\n            fac %= modulo\n        bj_ = bj(u, j, r)\n        prod *= pow(fac, bj_, modulo)\n        prod %= modulo\n    if p == 2:\n        sm = u // 2\n        for j in range(1, r + 1):\n            sm += j // 2 * bj(u, j, r)\n        if sm % 2 == 1:\n            prod *= -1\n    prod %= modulo // div\n    return prod % modulo"
        ]
    },
    {
        "func_name": "bj",
        "original": "def bj(u, j, r):\n    \"\"\"Compute the exponent of (j*p)!_p in the calculation of (u*p)!_p.\"\"\"\n    prod = u\n    for i in range(1, r + 1):\n        if i != j:\n            prod *= u * u - i * i\n    for i in range(1, r + 1):\n        if i != j:\n            prod //= j * j - i * i\n    return prod // j",
        "mutated": [
            "def bj(u, j, r):\n    if False:\n        i = 10\n    'Compute the exponent of (j*p)!_p in the calculation of (u*p)!_p.'\n    prod = u\n    for i in range(1, r + 1):\n        if i != j:\n            prod *= u * u - i * i\n    for i in range(1, r + 1):\n        if i != j:\n            prod //= j * j - i * i\n    return prod // j",
            "def bj(u, j, r):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Compute the exponent of (j*p)!_p in the calculation of (u*p)!_p.'\n    prod = u\n    for i in range(1, r + 1):\n        if i != j:\n            prod *= u * u - i * i\n    for i in range(1, r + 1):\n        if i != j:\n            prod //= j * j - i * i\n    return prod // j",
            "def bj(u, j, r):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Compute the exponent of (j*p)!_p in the calculation of (u*p)!_p.'\n    prod = u\n    for i in range(1, r + 1):\n        if i != j:\n            prod *= u * u - i * i\n    for i in range(1, r + 1):\n        if i != j:\n            prod //= j * j - i * i\n    return prod // j",
            "def bj(u, j, r):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Compute the exponent of (j*p)!_p in the calculation of (u*p)!_p.'\n    prod = u\n    for i in range(1, r + 1):\n        if i != j:\n            prod *= u * u - i * i\n    for i in range(1, r + 1):\n        if i != j:\n            prod //= j * j - i * i\n    return prod // j",
            "def bj(u, j, r):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Compute the exponent of (j*p)!_p in the calculation of (u*p)!_p.'\n    prod = u\n    for i in range(1, r + 1):\n        if i != j:\n            prod *= u * u - i * i\n    for i in range(1, r + 1):\n        if i != j:\n            prod //= j * j - i * i\n    return prod // j"
        ]
    },
    {
        "func_name": "up_plus_v_binom",
        "original": "def up_plus_v_binom(u, v):\n    \"\"\"Compute binomial(u*p + v, v)_p modulo p^q.\"\"\"\n    prod = div = 1\n    for i in range(1, v + 1):\n        div *= i\n        div %= modulo\n    div = invert(div, modulo)\n    for j in range(1, q):\n        b = div\n        for v_ in range(j * p + 1, j * p + v + 1):\n            b *= v_\n            b %= modulo\n        aj = u\n        for i in range(1, q):\n            if i != j:\n                aj *= u - i\n        for i in range(1, q):\n            if i != j:\n                aj //= j - i\n        aj //= j\n        prod *= pow(b, aj, modulo)\n        prod %= modulo\n    return prod",
        "mutated": [
            "def up_plus_v_binom(u, v):\n    if False:\n        i = 10\n    'Compute binomial(u*p + v, v)_p modulo p^q.'\n    prod = div = 1\n    for i in range(1, v + 1):\n        div *= i\n        div %= modulo\n    div = invert(div, modulo)\n    for j in range(1, q):\n        b = div\n        for v_ in range(j * p + 1, j * p + v + 1):\n            b *= v_\n            b %= modulo\n        aj = u\n        for i in range(1, q):\n            if i != j:\n                aj *= u - i\n        for i in range(1, q):\n            if i != j:\n                aj //= j - i\n        aj //= j\n        prod *= pow(b, aj, modulo)\n        prod %= modulo\n    return prod",
            "def up_plus_v_binom(u, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Compute binomial(u*p + v, v)_p modulo p^q.'\n    prod = div = 1\n    for i in range(1, v + 1):\n        div *= i\n        div %= modulo\n    div = invert(div, modulo)\n    for j in range(1, q):\n        b = div\n        for v_ in range(j * p + 1, j * p + v + 1):\n            b *= v_\n            b %= modulo\n        aj = u\n        for i in range(1, q):\n            if i != j:\n                aj *= u - i\n        for i in range(1, q):\n            if i != j:\n                aj //= j - i\n        aj //= j\n        prod *= pow(b, aj, modulo)\n        prod %= modulo\n    return prod",
            "def up_plus_v_binom(u, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Compute binomial(u*p + v, v)_p modulo p^q.'\n    prod = div = 1\n    for i in range(1, v + 1):\n        div *= i\n        div %= modulo\n    div = invert(div, modulo)\n    for j in range(1, q):\n        b = div\n        for v_ in range(j * p + 1, j * p + v + 1):\n            b *= v_\n            b %= modulo\n        aj = u\n        for i in range(1, q):\n            if i != j:\n                aj *= u - i\n        for i in range(1, q):\n            if i != j:\n                aj //= j - i\n        aj //= j\n        prod *= pow(b, aj, modulo)\n        prod %= modulo\n    return prod",
            "def up_plus_v_binom(u, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Compute binomial(u*p + v, v)_p modulo p^q.'\n    prod = div = 1\n    for i in range(1, v + 1):\n        div *= i\n        div %= modulo\n    div = invert(div, modulo)\n    for j in range(1, q):\n        b = div\n        for v_ in range(j * p + 1, j * p + v + 1):\n            b *= v_\n            b %= modulo\n        aj = u\n        for i in range(1, q):\n            if i != j:\n                aj *= u - i\n        for i in range(1, q):\n            if i != j:\n                aj //= j - i\n        aj //= j\n        prod *= pow(b, aj, modulo)\n        prod %= modulo\n    return prod",
            "def up_plus_v_binom(u, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Compute binomial(u*p + v, v)_p modulo p^q.'\n    prod = div = 1\n    for i in range(1, v + 1):\n        div *= i\n        div %= modulo\n    div = invert(div, modulo)\n    for j in range(1, q):\n        b = div\n        for v_ in range(j * p + 1, j * p + v + 1):\n            b *= v_\n            b %= modulo\n        aj = u\n        for i in range(1, q):\n            if i != j:\n                aj *= u - i\n        for i in range(1, q):\n            if i != j:\n                aj //= j - i\n        aj //= j\n        prod *= pow(b, aj, modulo)\n        prod %= modulo\n    return prod"
        ]
    },
    {
        "func_name": "factorial",
        "original": "def factorial(v):\n    \"\"\"Compute v! modulo p^q.\"\"\"\n    if len(factorials) <= v:\n        for i in range(len(factorials), v + 1):\n            factorials.append(factorials[-1] * i % modulo)\n    return factorials[v]",
        "mutated": [
            "def factorial(v):\n    if False:\n        i = 10\n    'Compute v! modulo p^q.'\n    if len(factorials) <= v:\n        for i in range(len(factorials), v + 1):\n            factorials.append(factorials[-1] * i % modulo)\n    return factorials[v]",
            "def factorial(v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Compute v! modulo p^q.'\n    if len(factorials) <= v:\n        for i in range(len(factorials), v + 1):\n            factorials.append(factorials[-1] * i % modulo)\n    return factorials[v]",
            "def factorial(v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Compute v! modulo p^q.'\n    if len(factorials) <= v:\n        for i in range(len(factorials), v + 1):\n            factorials.append(factorials[-1] * i % modulo)\n    return factorials[v]",
            "def factorial(v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Compute v! modulo p^q.'\n    if len(factorials) <= v:\n        for i in range(len(factorials), v + 1):\n            factorials.append(factorials[-1] * i % modulo)\n    return factorials[v]",
            "def factorial(v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Compute v! modulo p^q.'\n    if len(factorials) <= v:\n        for i in range(len(factorials), v + 1):\n            factorials.append(factorials[-1] * i % modulo)\n    return factorials[v]"
        ]
    },
    {
        "func_name": "factorial_p",
        "original": "def factorial_p(n):\n    \"\"\"Compute n!_p modulo p^q.\"\"\"\n    (u, v) = divmod(n, p)\n    return factorial(v) * up_factorial(u) * up_plus_v_binom(u, v) % modulo",
        "mutated": [
            "def factorial_p(n):\n    if False:\n        i = 10\n    'Compute n!_p modulo p^q.'\n    (u, v) = divmod(n, p)\n    return factorial(v) * up_factorial(u) * up_plus_v_binom(u, v) % modulo",
            "def factorial_p(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Compute n!_p modulo p^q.'\n    (u, v) = divmod(n, p)\n    return factorial(v) * up_factorial(u) * up_plus_v_binom(u, v) % modulo",
            "def factorial_p(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Compute n!_p modulo p^q.'\n    (u, v) = divmod(n, p)\n    return factorial(v) * up_factorial(u) * up_plus_v_binom(u, v) % modulo",
            "def factorial_p(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Compute n!_p modulo p^q.'\n    (u, v) = divmod(n, p)\n    return factorial(v) * up_factorial(u) * up_plus_v_binom(u, v) % modulo",
            "def factorial_p(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Compute n!_p modulo p^q.'\n    (u, v) = divmod(n, p)\n    return factorial(v) * up_factorial(u) * up_plus_v_binom(u, v) % modulo"
        ]
    },
    {
        "func_name": "_binomial_mod_prime_power",
        "original": "def _binomial_mod_prime_power(n, m, p, q):\n    \"\"\"Compute ``binomial(n, m) % p**q`` for a prime ``p``.\n\n    Parameters\n    ==========\n\n    n : positive integer\n    m : a nonnegative integer\n    p : a prime\n    q : a positive integer (the prime exponent)\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.residue_ntheory import _binomial_mod_prime_power\n    >>> _binomial_mod_prime_power(10, 2, 3, 2)  # binomial(10, 2) = 45\n    0\n    >>> _binomial_mod_prime_power(17, 9, 2, 4)  # binomial(17, 9) = 24310\n    6\n\n    References\n    ==========\n\n    .. [1] Binomial coefficients modulo prime powers, Andrew Granville,\n        Available: https://web.archive.org/web/20170202003812/http://www.dms.umontreal.ca/~andrew/PDF/BinCoeff.pdf\n    \"\"\"\n    modulo = pow(p, q)\n\n    def up_factorial(u):\n        \"\"\"Compute (u*p)!_p modulo p^q.\"\"\"\n        r = q // 2\n        fac = prod = 1\n        if r == 1 and p == 2 or 2 * r + 1 in (p, p * p):\n            if q % 2 == 1:\n                r += 1\n            (modulo, div) = (pow(p, 2 * r), pow(p, 2 * r - q))\n        else:\n            (modulo, div) = (pow(p, 2 * r + 1), pow(p, 2 * r + 1 - q))\n        for j in range(1, r + 1):\n            for mul in range((j - 1) * p + 1, j * p):\n                fac *= mul\n                fac %= modulo\n            bj_ = bj(u, j, r)\n            prod *= pow(fac, bj_, modulo)\n            prod %= modulo\n        if p == 2:\n            sm = u // 2\n            for j in range(1, r + 1):\n                sm += j // 2 * bj(u, j, r)\n            if sm % 2 == 1:\n                prod *= -1\n        prod %= modulo // div\n        return prod % modulo\n\n    def bj(u, j, r):\n        \"\"\"Compute the exponent of (j*p)!_p in the calculation of (u*p)!_p.\"\"\"\n        prod = u\n        for i in range(1, r + 1):\n            if i != j:\n                prod *= u * u - i * i\n        for i in range(1, r + 1):\n            if i != j:\n                prod //= j * j - i * i\n        return prod // j\n\n    def up_plus_v_binom(u, v):\n        \"\"\"Compute binomial(u*p + v, v)_p modulo p^q.\"\"\"\n        prod = div = 1\n        for i in range(1, v + 1):\n            div *= i\n            div %= modulo\n        div = invert(div, modulo)\n        for j in range(1, q):\n            b = div\n            for v_ in range(j * p + 1, j * p + v + 1):\n                b *= v_\n                b %= modulo\n            aj = u\n            for i in range(1, q):\n                if i != j:\n                    aj *= u - i\n            for i in range(1, q):\n                if i != j:\n                    aj //= j - i\n            aj //= j\n            prod *= pow(b, aj, modulo)\n            prod %= modulo\n        return prod\n    factorials = [1]\n\n    def factorial(v):\n        \"\"\"Compute v! modulo p^q.\"\"\"\n        if len(factorials) <= v:\n            for i in range(len(factorials), v + 1):\n                factorials.append(factorials[-1] * i % modulo)\n        return factorials[v]\n\n    def factorial_p(n):\n        \"\"\"Compute n!_p modulo p^q.\"\"\"\n        (u, v) = divmod(n, p)\n        return factorial(v) * up_factorial(u) * up_plus_v_binom(u, v) % modulo\n    prod = 1\n    (Nj, Mj, Rj) = (n, m, n - m)\n    e0 = carry = eq_1 = j = 0\n    while Nj:\n        numerator = factorial_p(Nj % modulo)\n        denominator = factorial_p(Mj % modulo) * factorial_p(Rj % modulo) % modulo\n        (Nj, (Mj, mj), (Rj, rj)) = (Nj // p, divmod(Mj, p), divmod(Rj, p))\n        carry = (mj + rj + carry) // p\n        e0 += carry\n        if j >= q - 1:\n            eq_1 += carry\n        prod *= numerator * invert(denominator, modulo)\n        prod %= modulo\n        j += 1\n    mul = pow(1 if p == 2 and q >= 3 else -1, eq_1, modulo)\n    return pow(p, e0, modulo) * mul * prod % modulo",
        "mutated": [
            "def _binomial_mod_prime_power(n, m, p, q):\n    if False:\n        i = 10\n    'Compute ``binomial(n, m) % p**q`` for a prime ``p``.\\n\\n    Parameters\\n    ==========\\n\\n    n : positive integer\\n    m : a nonnegative integer\\n    p : a prime\\n    q : a positive integer (the prime exponent)\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _binomial_mod_prime_power\\n    >>> _binomial_mod_prime_power(10, 2, 3, 2)  # binomial(10, 2) = 45\\n    0\\n    >>> _binomial_mod_prime_power(17, 9, 2, 4)  # binomial(17, 9) = 24310\\n    6\\n\\n    References\\n    ==========\\n\\n    .. [1] Binomial coefficients modulo prime powers, Andrew Granville,\\n        Available: https://web.archive.org/web/20170202003812/http://www.dms.umontreal.ca/~andrew/PDF/BinCoeff.pdf\\n    '\n    modulo = pow(p, q)\n\n    def up_factorial(u):\n        \"\"\"Compute (u*p)!_p modulo p^q.\"\"\"\n        r = q // 2\n        fac = prod = 1\n        if r == 1 and p == 2 or 2 * r + 1 in (p, p * p):\n            if q % 2 == 1:\n                r += 1\n            (modulo, div) = (pow(p, 2 * r), pow(p, 2 * r - q))\n        else:\n            (modulo, div) = (pow(p, 2 * r + 1), pow(p, 2 * r + 1 - q))\n        for j in range(1, r + 1):\n            for mul in range((j - 1) * p + 1, j * p):\n                fac *= mul\n                fac %= modulo\n            bj_ = bj(u, j, r)\n            prod *= pow(fac, bj_, modulo)\n            prod %= modulo\n        if p == 2:\n            sm = u // 2\n            for j in range(1, r + 1):\n                sm += j // 2 * bj(u, j, r)\n            if sm % 2 == 1:\n                prod *= -1\n        prod %= modulo // div\n        return prod % modulo\n\n    def bj(u, j, r):\n        \"\"\"Compute the exponent of (j*p)!_p in the calculation of (u*p)!_p.\"\"\"\n        prod = u\n        for i in range(1, r + 1):\n            if i != j:\n                prod *= u * u - i * i\n        for i in range(1, r + 1):\n            if i != j:\n                prod //= j * j - i * i\n        return prod // j\n\n    def up_plus_v_binom(u, v):\n        \"\"\"Compute binomial(u*p + v, v)_p modulo p^q.\"\"\"\n        prod = div = 1\n        for i in range(1, v + 1):\n            div *= i\n            div %= modulo\n        div = invert(div, modulo)\n        for j in range(1, q):\n            b = div\n            for v_ in range(j * p + 1, j * p + v + 1):\n                b *= v_\n                b %= modulo\n            aj = u\n            for i in range(1, q):\n                if i != j:\n                    aj *= u - i\n            for i in range(1, q):\n                if i != j:\n                    aj //= j - i\n            aj //= j\n            prod *= pow(b, aj, modulo)\n            prod %= modulo\n        return prod\n    factorials = [1]\n\n    def factorial(v):\n        \"\"\"Compute v! modulo p^q.\"\"\"\n        if len(factorials) <= v:\n            for i in range(len(factorials), v + 1):\n                factorials.append(factorials[-1] * i % modulo)\n        return factorials[v]\n\n    def factorial_p(n):\n        \"\"\"Compute n!_p modulo p^q.\"\"\"\n        (u, v) = divmod(n, p)\n        return factorial(v) * up_factorial(u) * up_plus_v_binom(u, v) % modulo\n    prod = 1\n    (Nj, Mj, Rj) = (n, m, n - m)\n    e0 = carry = eq_1 = j = 0\n    while Nj:\n        numerator = factorial_p(Nj % modulo)\n        denominator = factorial_p(Mj % modulo) * factorial_p(Rj % modulo) % modulo\n        (Nj, (Mj, mj), (Rj, rj)) = (Nj // p, divmod(Mj, p), divmod(Rj, p))\n        carry = (mj + rj + carry) // p\n        e0 += carry\n        if j >= q - 1:\n            eq_1 += carry\n        prod *= numerator * invert(denominator, modulo)\n        prod %= modulo\n        j += 1\n    mul = pow(1 if p == 2 and q >= 3 else -1, eq_1, modulo)\n    return pow(p, e0, modulo) * mul * prod % modulo",
            "def _binomial_mod_prime_power(n, m, p, q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Compute ``binomial(n, m) % p**q`` for a prime ``p``.\\n\\n    Parameters\\n    ==========\\n\\n    n : positive integer\\n    m : a nonnegative integer\\n    p : a prime\\n    q : a positive integer (the prime exponent)\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _binomial_mod_prime_power\\n    >>> _binomial_mod_prime_power(10, 2, 3, 2)  # binomial(10, 2) = 45\\n    0\\n    >>> _binomial_mod_prime_power(17, 9, 2, 4)  # binomial(17, 9) = 24310\\n    6\\n\\n    References\\n    ==========\\n\\n    .. [1] Binomial coefficients modulo prime powers, Andrew Granville,\\n        Available: https://web.archive.org/web/20170202003812/http://www.dms.umontreal.ca/~andrew/PDF/BinCoeff.pdf\\n    '\n    modulo = pow(p, q)\n\n    def up_factorial(u):\n        \"\"\"Compute (u*p)!_p modulo p^q.\"\"\"\n        r = q // 2\n        fac = prod = 1\n        if r == 1 and p == 2 or 2 * r + 1 in (p, p * p):\n            if q % 2 == 1:\n                r += 1\n            (modulo, div) = (pow(p, 2 * r), pow(p, 2 * r - q))\n        else:\n            (modulo, div) = (pow(p, 2 * r + 1), pow(p, 2 * r + 1 - q))\n        for j in range(1, r + 1):\n            for mul in range((j - 1) * p + 1, j * p):\n                fac *= mul\n                fac %= modulo\n            bj_ = bj(u, j, r)\n            prod *= pow(fac, bj_, modulo)\n            prod %= modulo\n        if p == 2:\n            sm = u // 2\n            for j in range(1, r + 1):\n                sm += j // 2 * bj(u, j, r)\n            if sm % 2 == 1:\n                prod *= -1\n        prod %= modulo // div\n        return prod % modulo\n\n    def bj(u, j, r):\n        \"\"\"Compute the exponent of (j*p)!_p in the calculation of (u*p)!_p.\"\"\"\n        prod = u\n        for i in range(1, r + 1):\n            if i != j:\n                prod *= u * u - i * i\n        for i in range(1, r + 1):\n            if i != j:\n                prod //= j * j - i * i\n        return prod // j\n\n    def up_plus_v_binom(u, v):\n        \"\"\"Compute binomial(u*p + v, v)_p modulo p^q.\"\"\"\n        prod = div = 1\n        for i in range(1, v + 1):\n            div *= i\n            div %= modulo\n        div = invert(div, modulo)\n        for j in range(1, q):\n            b = div\n            for v_ in range(j * p + 1, j * p + v + 1):\n                b *= v_\n                b %= modulo\n            aj = u\n            for i in range(1, q):\n                if i != j:\n                    aj *= u - i\n            for i in range(1, q):\n                if i != j:\n                    aj //= j - i\n            aj //= j\n            prod *= pow(b, aj, modulo)\n            prod %= modulo\n        return prod\n    factorials = [1]\n\n    def factorial(v):\n        \"\"\"Compute v! modulo p^q.\"\"\"\n        if len(factorials) <= v:\n            for i in range(len(factorials), v + 1):\n                factorials.append(factorials[-1] * i % modulo)\n        return factorials[v]\n\n    def factorial_p(n):\n        \"\"\"Compute n!_p modulo p^q.\"\"\"\n        (u, v) = divmod(n, p)\n        return factorial(v) * up_factorial(u) * up_plus_v_binom(u, v) % modulo\n    prod = 1\n    (Nj, Mj, Rj) = (n, m, n - m)\n    e0 = carry = eq_1 = j = 0\n    while Nj:\n        numerator = factorial_p(Nj % modulo)\n        denominator = factorial_p(Mj % modulo) * factorial_p(Rj % modulo) % modulo\n        (Nj, (Mj, mj), (Rj, rj)) = (Nj // p, divmod(Mj, p), divmod(Rj, p))\n        carry = (mj + rj + carry) // p\n        e0 += carry\n        if j >= q - 1:\n            eq_1 += carry\n        prod *= numerator * invert(denominator, modulo)\n        prod %= modulo\n        j += 1\n    mul = pow(1 if p == 2 and q >= 3 else -1, eq_1, modulo)\n    return pow(p, e0, modulo) * mul * prod % modulo",
            "def _binomial_mod_prime_power(n, m, p, q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Compute ``binomial(n, m) % p**q`` for a prime ``p``.\\n\\n    Parameters\\n    ==========\\n\\n    n : positive integer\\n    m : a nonnegative integer\\n    p : a prime\\n    q : a positive integer (the prime exponent)\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _binomial_mod_prime_power\\n    >>> _binomial_mod_prime_power(10, 2, 3, 2)  # binomial(10, 2) = 45\\n    0\\n    >>> _binomial_mod_prime_power(17, 9, 2, 4)  # binomial(17, 9) = 24310\\n    6\\n\\n    References\\n    ==========\\n\\n    .. [1] Binomial coefficients modulo prime powers, Andrew Granville,\\n        Available: https://web.archive.org/web/20170202003812/http://www.dms.umontreal.ca/~andrew/PDF/BinCoeff.pdf\\n    '\n    modulo = pow(p, q)\n\n    def up_factorial(u):\n        \"\"\"Compute (u*p)!_p modulo p^q.\"\"\"\n        r = q // 2\n        fac = prod = 1\n        if r == 1 and p == 2 or 2 * r + 1 in (p, p * p):\n            if q % 2 == 1:\n                r += 1\n            (modulo, div) = (pow(p, 2 * r), pow(p, 2 * r - q))\n        else:\n            (modulo, div) = (pow(p, 2 * r + 1), pow(p, 2 * r + 1 - q))\n        for j in range(1, r + 1):\n            for mul in range((j - 1) * p + 1, j * p):\n                fac *= mul\n                fac %= modulo\n            bj_ = bj(u, j, r)\n            prod *= pow(fac, bj_, modulo)\n            prod %= modulo\n        if p == 2:\n            sm = u // 2\n            for j in range(1, r + 1):\n                sm += j // 2 * bj(u, j, r)\n            if sm % 2 == 1:\n                prod *= -1\n        prod %= modulo // div\n        return prod % modulo\n\n    def bj(u, j, r):\n        \"\"\"Compute the exponent of (j*p)!_p in the calculation of (u*p)!_p.\"\"\"\n        prod = u\n        for i in range(1, r + 1):\n            if i != j:\n                prod *= u * u - i * i\n        for i in range(1, r + 1):\n            if i != j:\n                prod //= j * j - i * i\n        return prod // j\n\n    def up_plus_v_binom(u, v):\n        \"\"\"Compute binomial(u*p + v, v)_p modulo p^q.\"\"\"\n        prod = div = 1\n        for i in range(1, v + 1):\n            div *= i\n            div %= modulo\n        div = invert(div, modulo)\n        for j in range(1, q):\n            b = div\n            for v_ in range(j * p + 1, j * p + v + 1):\n                b *= v_\n                b %= modulo\n            aj = u\n            for i in range(1, q):\n                if i != j:\n                    aj *= u - i\n            for i in range(1, q):\n                if i != j:\n                    aj //= j - i\n            aj //= j\n            prod *= pow(b, aj, modulo)\n            prod %= modulo\n        return prod\n    factorials = [1]\n\n    def factorial(v):\n        \"\"\"Compute v! modulo p^q.\"\"\"\n        if len(factorials) <= v:\n            for i in range(len(factorials), v + 1):\n                factorials.append(factorials[-1] * i % modulo)\n        return factorials[v]\n\n    def factorial_p(n):\n        \"\"\"Compute n!_p modulo p^q.\"\"\"\n        (u, v) = divmod(n, p)\n        return factorial(v) * up_factorial(u) * up_plus_v_binom(u, v) % modulo\n    prod = 1\n    (Nj, Mj, Rj) = (n, m, n - m)\n    e0 = carry = eq_1 = j = 0\n    while Nj:\n        numerator = factorial_p(Nj % modulo)\n        denominator = factorial_p(Mj % modulo) * factorial_p(Rj % modulo) % modulo\n        (Nj, (Mj, mj), (Rj, rj)) = (Nj // p, divmod(Mj, p), divmod(Rj, p))\n        carry = (mj + rj + carry) // p\n        e0 += carry\n        if j >= q - 1:\n            eq_1 += carry\n        prod *= numerator * invert(denominator, modulo)\n        prod %= modulo\n        j += 1\n    mul = pow(1 if p == 2 and q >= 3 else -1, eq_1, modulo)\n    return pow(p, e0, modulo) * mul * prod % modulo",
            "def _binomial_mod_prime_power(n, m, p, q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Compute ``binomial(n, m) % p**q`` for a prime ``p``.\\n\\n    Parameters\\n    ==========\\n\\n    n : positive integer\\n    m : a nonnegative integer\\n    p : a prime\\n    q : a positive integer (the prime exponent)\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _binomial_mod_prime_power\\n    >>> _binomial_mod_prime_power(10, 2, 3, 2)  # binomial(10, 2) = 45\\n    0\\n    >>> _binomial_mod_prime_power(17, 9, 2, 4)  # binomial(17, 9) = 24310\\n    6\\n\\n    References\\n    ==========\\n\\n    .. [1] Binomial coefficients modulo prime powers, Andrew Granville,\\n        Available: https://web.archive.org/web/20170202003812/http://www.dms.umontreal.ca/~andrew/PDF/BinCoeff.pdf\\n    '\n    modulo = pow(p, q)\n\n    def up_factorial(u):\n        \"\"\"Compute (u*p)!_p modulo p^q.\"\"\"\n        r = q // 2\n        fac = prod = 1\n        if r == 1 and p == 2 or 2 * r + 1 in (p, p * p):\n            if q % 2 == 1:\n                r += 1\n            (modulo, div) = (pow(p, 2 * r), pow(p, 2 * r - q))\n        else:\n            (modulo, div) = (pow(p, 2 * r + 1), pow(p, 2 * r + 1 - q))\n        for j in range(1, r + 1):\n            for mul in range((j - 1) * p + 1, j * p):\n                fac *= mul\n                fac %= modulo\n            bj_ = bj(u, j, r)\n            prod *= pow(fac, bj_, modulo)\n            prod %= modulo\n        if p == 2:\n            sm = u // 2\n            for j in range(1, r + 1):\n                sm += j // 2 * bj(u, j, r)\n            if sm % 2 == 1:\n                prod *= -1\n        prod %= modulo // div\n        return prod % modulo\n\n    def bj(u, j, r):\n        \"\"\"Compute the exponent of (j*p)!_p in the calculation of (u*p)!_p.\"\"\"\n        prod = u\n        for i in range(1, r + 1):\n            if i != j:\n                prod *= u * u - i * i\n        for i in range(1, r + 1):\n            if i != j:\n                prod //= j * j - i * i\n        return prod // j\n\n    def up_plus_v_binom(u, v):\n        \"\"\"Compute binomial(u*p + v, v)_p modulo p^q.\"\"\"\n        prod = div = 1\n        for i in range(1, v + 1):\n            div *= i\n            div %= modulo\n        div = invert(div, modulo)\n        for j in range(1, q):\n            b = div\n            for v_ in range(j * p + 1, j * p + v + 1):\n                b *= v_\n                b %= modulo\n            aj = u\n            for i in range(1, q):\n                if i != j:\n                    aj *= u - i\n            for i in range(1, q):\n                if i != j:\n                    aj //= j - i\n            aj //= j\n            prod *= pow(b, aj, modulo)\n            prod %= modulo\n        return prod\n    factorials = [1]\n\n    def factorial(v):\n        \"\"\"Compute v! modulo p^q.\"\"\"\n        if len(factorials) <= v:\n            for i in range(len(factorials), v + 1):\n                factorials.append(factorials[-1] * i % modulo)\n        return factorials[v]\n\n    def factorial_p(n):\n        \"\"\"Compute n!_p modulo p^q.\"\"\"\n        (u, v) = divmod(n, p)\n        return factorial(v) * up_factorial(u) * up_plus_v_binom(u, v) % modulo\n    prod = 1\n    (Nj, Mj, Rj) = (n, m, n - m)\n    e0 = carry = eq_1 = j = 0\n    while Nj:\n        numerator = factorial_p(Nj % modulo)\n        denominator = factorial_p(Mj % modulo) * factorial_p(Rj % modulo) % modulo\n        (Nj, (Mj, mj), (Rj, rj)) = (Nj // p, divmod(Mj, p), divmod(Rj, p))\n        carry = (mj + rj + carry) // p\n        e0 += carry\n        if j >= q - 1:\n            eq_1 += carry\n        prod *= numerator * invert(denominator, modulo)\n        prod %= modulo\n        j += 1\n    mul = pow(1 if p == 2 and q >= 3 else -1, eq_1, modulo)\n    return pow(p, e0, modulo) * mul * prod % modulo",
            "def _binomial_mod_prime_power(n, m, p, q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Compute ``binomial(n, m) % p**q`` for a prime ``p``.\\n\\n    Parameters\\n    ==========\\n\\n    n : positive integer\\n    m : a nonnegative integer\\n    p : a prime\\n    q : a positive integer (the prime exponent)\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.ntheory.residue_ntheory import _binomial_mod_prime_power\\n    >>> _binomial_mod_prime_power(10, 2, 3, 2)  # binomial(10, 2) = 45\\n    0\\n    >>> _binomial_mod_prime_power(17, 9, 2, 4)  # binomial(17, 9) = 24310\\n    6\\n\\n    References\\n    ==========\\n\\n    .. [1] Binomial coefficients modulo prime powers, Andrew Granville,\\n        Available: https://web.archive.org/web/20170202003812/http://www.dms.umontreal.ca/~andrew/PDF/BinCoeff.pdf\\n    '\n    modulo = pow(p, q)\n\n    def up_factorial(u):\n        \"\"\"Compute (u*p)!_p modulo p^q.\"\"\"\n        r = q // 2\n        fac = prod = 1\n        if r == 1 and p == 2 or 2 * r + 1 in (p, p * p):\n            if q % 2 == 1:\n                r += 1\n            (modulo, div) = (pow(p, 2 * r), pow(p, 2 * r - q))\n        else:\n            (modulo, div) = (pow(p, 2 * r + 1), pow(p, 2 * r + 1 - q))\n        for j in range(1, r + 1):\n            for mul in range((j - 1) * p + 1, j * p):\n                fac *= mul\n                fac %= modulo\n            bj_ = bj(u, j, r)\n            prod *= pow(fac, bj_, modulo)\n            prod %= modulo\n        if p == 2:\n            sm = u // 2\n            for j in range(1, r + 1):\n                sm += j // 2 * bj(u, j, r)\n            if sm % 2 == 1:\n                prod *= -1\n        prod %= modulo // div\n        return prod % modulo\n\n    def bj(u, j, r):\n        \"\"\"Compute the exponent of (j*p)!_p in the calculation of (u*p)!_p.\"\"\"\n        prod = u\n        for i in range(1, r + 1):\n            if i != j:\n                prod *= u * u - i * i\n        for i in range(1, r + 1):\n            if i != j:\n                prod //= j * j - i * i\n        return prod // j\n\n    def up_plus_v_binom(u, v):\n        \"\"\"Compute binomial(u*p + v, v)_p modulo p^q.\"\"\"\n        prod = div = 1\n        for i in range(1, v + 1):\n            div *= i\n            div %= modulo\n        div = invert(div, modulo)\n        for j in range(1, q):\n            b = div\n            for v_ in range(j * p + 1, j * p + v + 1):\n                b *= v_\n                b %= modulo\n            aj = u\n            for i in range(1, q):\n                if i != j:\n                    aj *= u - i\n            for i in range(1, q):\n                if i != j:\n                    aj //= j - i\n            aj //= j\n            prod *= pow(b, aj, modulo)\n            prod %= modulo\n        return prod\n    factorials = [1]\n\n    def factorial(v):\n        \"\"\"Compute v! modulo p^q.\"\"\"\n        if len(factorials) <= v:\n            for i in range(len(factorials), v + 1):\n                factorials.append(factorials[-1] * i % modulo)\n        return factorials[v]\n\n    def factorial_p(n):\n        \"\"\"Compute n!_p modulo p^q.\"\"\"\n        (u, v) = divmod(n, p)\n        return factorial(v) * up_factorial(u) * up_plus_v_binom(u, v) % modulo\n    prod = 1\n    (Nj, Mj, Rj) = (n, m, n - m)\n    e0 = carry = eq_1 = j = 0\n    while Nj:\n        numerator = factorial_p(Nj % modulo)\n        denominator = factorial_p(Mj % modulo) * factorial_p(Rj % modulo) % modulo\n        (Nj, (Mj, mj), (Rj, rj)) = (Nj // p, divmod(Mj, p), divmod(Rj, p))\n        carry = (mj + rj + carry) // p\n        e0 += carry\n        if j >= q - 1:\n            eq_1 += carry\n        prod *= numerator * invert(denominator, modulo)\n        prod %= modulo\n        j += 1\n    mul = pow(1 if p == 2 and q >= 3 else -1, eq_1, modulo)\n    return pow(p, e0, modulo) * mul * prod % modulo"
        ]
    }
]