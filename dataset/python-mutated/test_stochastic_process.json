[
    {
        "func_name": "test_DiscreteMarkovChain",
        "original": "def test_DiscreteMarkovChain():\n    X = DiscreteMarkovChain('X')\n    assert isinstance(X.state_space, Range)\n    assert X.index_set == S.Naturals0\n    assert isinstance(X.transition_probabilities, MatrixSymbol)\n    t = symbols('t', positive=True, integer=True)\n    assert isinstance(X[t], RandomIndexedSymbol)\n    assert E(X[0]) == Expectation(X[0])\n    raises(TypeError, lambda : DiscreteMarkovChain(1))\n    raises(NotImplementedError, lambda : X(t))\n    raises(NotImplementedError, lambda : X.communication_classes())\n    raises(NotImplementedError, lambda : X.canonical_form())\n    raises(NotImplementedError, lambda : X.decompose())\n    nz = Symbol('n', integer=True)\n    TZ = MatrixSymbol('M', nz, nz)\n    SZ = Range(nz)\n    YZ = DiscreteMarkovChain('Y', SZ, TZ)\n    assert P(Eq(YZ[2], 1), Eq(YZ[1], 0)) == TZ[0, 1]\n    raises(ValueError, lambda : sample_stochastic_process(t))\n    raises(ValueError, lambda : next(sample_stochastic_process(X)))\n    (sym, rainy, cloudy, sunny) = symbols('a Rainy Cloudy Sunny', real=True)\n    state_spaces = [(1, 2, 3), [Str('Hello'), sym, DiscreteMarkovChain('Y', (1, 2, 3))], Tuple(S(1), exp(sym), Str('World'), sympify=False), Range(-1, 5, 2), [rainy, cloudy, sunny]]\n    chains = [DiscreteMarkovChain('Y', state_space) for state_space in state_spaces]\n    for (i, Y) in enumerate(chains):\n        assert isinstance(Y.transition_probabilities, MatrixSymbol)\n        assert Y.state_space == state_spaces[i] or Y.state_space == FiniteSet(*state_spaces[i])\n        assert Y.number_of_states == 3\n        with ignore_warnings(UserWarning):\n            assert P(Eq(Y[2], 1), Eq(Y[0], 2), evaluate=False) == Probability(Eq(Y[2], 1), Eq(Y[0], 2))\n        assert E(Y[0]) == Expectation(Y[0])\n        raises(ValueError, lambda : next(sample_stochastic_process(Y)))\n    raises(TypeError, lambda : DiscreteMarkovChain('Y', {1: 1}))\n    Y = DiscreteMarkovChain('Y', Range(1, t, 2))\n    assert Y.number_of_states == ceiling((t - 1) / 2)\n    chains = [DiscreteMarkovChain('Y', trans_probs=Matrix([[]])), DiscreteMarkovChain('Y', trans_probs=Matrix([[0, 1], [1, 0]])), DiscreteMarkovChain('Y', trans_probs=Matrix([[pi, 1 - pi], [sym, 1 - sym]]))]\n    for Z in chains:\n        assert Z.number_of_states == Z.transition_probabilities.shape[0]\n        assert isinstance(Z.transition_probabilities, ImmutableMatrix)\n    T = Matrix([[0.5, 0.2, 0.3], [0.2, 0.5, 0.3], [0.2, 0.3, 0.5]])\n    TS = MatrixSymbol('T', 3, 3)\n    Y = DiscreteMarkovChain('Y', [0, 1, 2], T)\n    YS = DiscreteMarkovChain('Y', ['One', 'Two', 3], TS)\n    assert Y.joint_distribution(1, Y[2], 3) == JointDistribution(Y[1], Y[2], Y[3])\n    raises(ValueError, lambda : Y.joint_distribution(Y[1].symbol, Y[2].symbol))\n    assert P(Eq(Y[3], 2), Eq(Y[1], 1)).round(2) == Float(0.36, 2)\n    assert (P(Eq(YS[3], 2), Eq(YS[1], 1)) - (TS[0, 2] * TS[1, 0] + TS[1, 1] * TS[1, 2] + TS[1, 2] * TS[2, 2])).simplify() == 0\n    assert P(Eq(YS[1], 1), Eq(YS[2], 2)) == Probability(Eq(YS[1], 1))\n    assert P(Eq(YS[3], 3), Eq(YS[1], 1)) == TS[0, 2] * TS[1, 0] + TS[1, 1] * TS[1, 2] + TS[1, 2] * TS[2, 2]\n    TO = Matrix([[0.25, 0.75, 0], [0, 0.25, 0.75], [0.75, 0, 0.25]])\n    assert P(Eq(Y[3], 2), Eq(Y[1], 1) & TransitionMatrixOf(Y, TO)).round(3) == Float(0.375, 3)\n    with ignore_warnings(UserWarning):\n        assert E(Y[3], evaluate=False) == Expectation(Y[3])\n        assert E(Y[3], Eq(Y[2], 1)).round(2) == Float(1.1, 3)\n    TSO = MatrixSymbol('T', 4, 4)\n    raises(ValueError, lambda : str(P(Eq(YS[3], 2), Eq(YS[1], 1) & TransitionMatrixOf(YS, TSO))))\n    raises(TypeError, lambda : DiscreteMarkovChain('Z', [0, 1, 2], symbols('M')))\n    raises(ValueError, lambda : DiscreteMarkovChain('Z', [0, 1, 2], MatrixSymbol('T', 3, 4)))\n    raises(ValueError, lambda : E(Y[3], Eq(Y[2], 6)))\n    raises(ValueError, lambda : E(Y[2], Eq(Y[3], 1)))\n    TO1 = Matrix([[Rational(1, 4), Rational(3, 4), 0], [Rational(1, 3), Rational(1, 3), Rational(1, 3)], [0, Rational(1, 4), Rational(3, 4)]])\n    assert P(And(Eq(Y[2], 1), Eq(Y[1], 1), Eq(Y[0], 0)), Eq(Probability(Eq(Y[0], 0)), Rational(1, 4)) & TransitionMatrixOf(Y, TO1)) == Rational(1, 16)\n    assert P(And(Eq(Y[2], 1), Eq(Y[1], 1), Eq(Y[0], 0)), TransitionMatrixOf(Y, TO1)) == Probability(Eq(Y[0], 0)) / 4\n    assert P(Lt(X[1], 2) & Gt(X[1], 0), Eq(X[0], 2) & StochasticStateSpaceOf(X, [0, 1, 2]) & TransitionMatrixOf(X, TO1)) == Rational(1, 4)\n    assert P(Lt(X[1], 2) & Gt(X[1], 0), Eq(X[0], 2) & StochasticStateSpaceOf(X, [S(0), '0', 1]) & TransitionMatrixOf(X, TO1)) == Rational(1, 4)\n    assert P(Ne(X[1], 2) & Ne(X[1], 1), Eq(X[0], 2) & StochasticStateSpaceOf(X, [0, 1, 2]) & TransitionMatrixOf(X, TO1)) is S.Zero\n    assert P(Ne(X[1], 2) & Ne(X[1], 1), Eq(X[0], 2) & StochasticStateSpaceOf(X, [S(0), '0', 1]) & TransitionMatrixOf(X, TO1)) is S.Zero\n    assert P(And(Eq(Y[2], 1), Eq(Y[1], 1), Eq(Y[0], 0)), Eq(Y[1], 1)) == 0.1 * Probability(Eq(Y[0], 0))\n    TO2 = Matrix([[S.One, 0, 0], [Rational(1, 3), Rational(1, 3), Rational(1, 3)], [0, Rational(1, 4), Rational(3, 4)]])\n    TO3 = Matrix([[Rational(1, 4), Rational(3, 4), 0], [Rational(1, 3), Rational(1, 3), Rational(1, 3)], [0, Rational(1, 4), Rational(3, 4)]])\n    Y2 = DiscreteMarkovChain('Y', trans_probs=TO2)\n    Y3 = DiscreteMarkovChain('Y', trans_probs=TO3)\n    assert Y3.fundamental_matrix() == ImmutableMatrix([[176, 81, -132], [36, 141, -52], [-44, -39, 208]]) / 125\n    assert Y2.is_absorbing_chain() == True\n    assert Y3.is_absorbing_chain() == False\n    assert Y2.canonical_form() == ([0, 1, 2], TO2)\n    assert Y3.canonical_form() == ([0, 1, 2], TO3)\n    assert Y2.decompose() == ([0, 1, 2], TO2[0:1, 0:1], TO2[1:3, 0:1], TO2[1:3, 1:3])\n    assert Y3.decompose() == ([0, 1, 2], TO3, Matrix(0, 3, []), Matrix(0, 0, []))\n    TO4 = Matrix([[Rational(1, 5), Rational(2, 5), Rational(2, 5)], [Rational(1, 10), S.Half, Rational(2, 5)], [Rational(3, 5), Rational(3, 10), Rational(1, 10)]])\n    Y4 = DiscreteMarkovChain('Y', trans_probs=TO4)\n    w = ImmutableMatrix([[Rational(11, 39), Rational(16, 39), Rational(4, 13)]])\n    assert Y4.limiting_distribution == w\n    assert Y4.is_regular() == True\n    assert Y4.is_ergodic() == True\n    TS1 = MatrixSymbol('T', 3, 3)\n    Y5 = DiscreteMarkovChain('Y', trans_probs=TS1)\n    assert Y5.limiting_distribution(w, TO4).doit() == True\n    assert Y5.stationary_distribution(condition_set=True).subs(TS1, TO4).contains(w).doit() == S.true\n    TO6 = Matrix([[S.One, 0, 0, 0, 0], [S.Half, 0, S.Half, 0, 0], [0, S.Half, 0, S.Half, 0], [0, 0, S.Half, 0, S.Half], [0, 0, 0, 0, 1]])\n    Y6 = DiscreteMarkovChain('Y', trans_probs=TO6)\n    assert Y6.fundamental_matrix() == ImmutableMatrix([[Rational(3, 2), S.One, S.Half], [S.One, S(2), S.One], [S.Half, S.One, Rational(3, 2)]])\n    assert Y6.absorbing_probabilities() == ImmutableMatrix([[Rational(3, 4), Rational(1, 4)], [S.Half, S.Half], [Rational(1, 4), Rational(3, 4)]])\n    with warns_deprecated_sympy():\n        Y6.absorbing_probabilites()\n    TO7 = Matrix([[Rational(1, 2), Rational(1, 4), Rational(1, 4)], [Rational(1, 2), 0, Rational(1, 2)], [Rational(1, 4), Rational(1, 4), Rational(1, 2)]])\n    Y7 = DiscreteMarkovChain('Y', trans_probs=TO7)\n    assert Y7.is_absorbing_chain() == False\n    assert Y7.fundamental_matrix() == ImmutableMatrix([[Rational(86, 75), Rational(1, 25), Rational(-14, 75)], [Rational(2, 25), Rational(21, 25), Rational(2, 25)], [Rational(-14, 75), Rational(1, 25), Rational(86, 75)]])\n    X = DiscreteMarkovChain('X', trans_probs=Matrix([[]]))\n    assert X.number_of_states == 0\n    assert X.stationary_distribution() == Matrix([[]])\n    assert X.communication_classes() == []\n    assert X.canonical_form() == ([], Matrix([[]]))\n    assert X.decompose() == ([], Matrix([[]]), Matrix([[]]), Matrix([[]]))\n    assert X.is_regular() == False\n    assert X.is_ergodic() == False\n    TO7 = Matrix([[0, 5, 5, 0, 0], [0, 0, 0, 10, 0], [5, 0, 5, 0, 0], [0, 10, 0, 0, 0], [0, 3, 0, 3, 4]]) / 10\n    Y7 = DiscreteMarkovChain('Y', trans_probs=TO7)\n    tuples = Y7.communication_classes()\n    (classes, recurrence, periods) = list(zip(*tuples))\n    assert classes == ([1, 3], [0, 2], [4])\n    assert recurrence == (True, False, False)\n    assert periods == (2, 1, 1)\n    TO8 = Matrix([[0, 0, 0, 10, 0, 0], [5, 0, 5, 0, 0, 0], [0, 4, 0, 0, 0, 6], [10, 0, 0, 0, 0, 0], [0, 10, 0, 0, 0, 0], [0, 0, 0, 5, 5, 0]]) / 10\n    Y8 = DiscreteMarkovChain('Y', trans_probs=TO8)\n    tuples = Y8.communication_classes()\n    (classes, recurrence, periods) = list(zip(*tuples))\n    assert classes == ([0, 3], [1, 2, 5, 4])\n    assert recurrence == (True, False)\n    assert periods == (2, 2)\n    TO9 = Matrix([[2, 0, 0, 3, 0, 0, 3, 2, 0, 0], [0, 10, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 0, 0, 0, 0, 0, 3, 3], [0, 0, 0, 3, 0, 0, 6, 1, 0, 0], [0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 10, 0, 0, 0, 0], [4, 0, 0, 5, 0, 0, 1, 0, 0, 0], [2, 0, 0, 4, 0, 0, 2, 2, 0, 0], [3, 0, 1, 0, 0, 0, 0, 0, 4, 2], [0, 0, 4, 0, 0, 0, 0, 0, 3, 3]]) / 10\n    Y9 = DiscreteMarkovChain('Y', trans_probs=TO9)\n    tuples = Y9.communication_classes()\n    (classes, recurrence, periods) = list(zip(*tuples))\n    assert classes == ([0, 3, 6, 7], [1], [2, 8, 9], [5], [4])\n    assert recurrence == (True, True, False, True, False)\n    assert periods == (1, 1, 1, 1, 1)\n    T = Matrix([[1, 0, 0, 0, 0], [S(1) / 2, 0, S(1) / 2, 0, 0], [0, S(1) / 2, 0, S(1) / 2, 0], [0, 0, S(1) / 2, 0, S(1) / 2], [0, 0, 0, 0, S(1)]])\n    DW = DiscreteMarkovChain('DW', [0, 1, 2, 3, 4], T)\n    (states, A, B, C) = DW.decompose()\n    assert states == [0, 4, 1, 2, 3]\n    assert A == Matrix([[1, 0], [0, 1]])\n    assert B == Matrix([[S(1) / 2, 0], [0, 0], [0, S(1) / 2]])\n    assert C == Matrix([[0, S(1) / 2, 0], [S(1) / 2, 0, S(1) / 2], [0, S(1) / 2, 0]])\n    (states, new_matrix) = DW.canonical_form()\n    assert states == [0, 4, 1, 2, 3]\n    assert new_matrix == Matrix([[1, 0, 0, 0, 0], [0, 1, 0, 0, 0], [S(1) / 2, 0, 0, S(1) / 2, 0], [0, 0, S(1) / 2, 0, S(1) / 2], [0, S(1) / 2, 0, S(1) / 2, 0]])\n    T = Matrix([[0, 4, 0, 0, 0], [1, 0, 3, 0, 0], [0, 2, 0, 2, 0], [0, 0, 3, 0, 1], [0, 0, 0, 4, 0]]) / 4\n    X = DiscreteMarkovChain('X', trans_probs=T)\n    assert not X.is_regular()\n    assert X.is_ergodic()\n    T = Matrix([[0, 1], [1, 0]])\n    X = DiscreteMarkovChain('X', trans_probs=T)\n    assert not X.is_regular()\n    assert X.is_ergodic()\n    T = Matrix([[2, 1, 1], [2, 0, 2], [1, 1, 2]]) / 4\n    X = DiscreteMarkovChain('X', trans_probs=T)\n    assert X.is_regular()\n    assert X.is_ergodic()\n    T = Matrix([[1, 1], [1, 1]]) / 2\n    X = DiscreteMarkovChain('X', trans_probs=T)\n    assert X.is_regular()\n    assert X.is_ergodic()\n    T = Matrix([[0, 1, 0], [1, 0, 0], [0, 0, 1]])\n    X = DiscreteMarkovChain('X', trans_probs=T)\n    assert not X.is_absorbing_chain()\n    T = Matrix([[1, 1, 0, 0], [0, 1, 1, 0], [1, 0, 0, 1], [0, 0, 0, 2]]) / 2\n    X = DiscreteMarkovChain('X', trans_probs=T)\n    assert X.is_absorbing_chain()\n    T = Matrix([[2, 0, 0, 0, 0], [1, 0, 1, 0, 0], [0, 1, 0, 1, 0], [0, 0, 1, 0, 1], [0, 0, 0, 0, 2]]) / 2\n    X = DiscreteMarkovChain('X', trans_probs=T)\n    assert X.is_absorbing_chain()\n    Y10 = DiscreteMarkovChain('Y', [1, 2, 3], TO2)\n    tuples = Y10.communication_classes()\n    (classes, recurrence, periods) = list(zip(*tuples))\n    assert classes == ([1], [2, 3])\n    assert recurrence == (True, False)\n    assert periods == (1, 1)\n    assert Y10.canonical_form() == ([1, 2, 3], TO2)\n    assert Y10.decompose() == ([1, 2, 3], TO2[0:1, 0:1], TO2[1:3, 0:1], TO2[1:3, 1:3])\n    T = Matrix([[S.Half, Rational(1, 4), Rational(1, 4)], [Rational(1, 3), 0, Rational(2, 3)], [S.Half, S.Half, 0]])\n    X = DiscreteMarkovChain('X', [0, 1, 2], T)\n    assert P(Eq(X[1], 2) & Eq(X[2], 1) & Eq(X[3], 0), Eq(P(Eq(X[1], 0)), Rational(1, 4)) & Eq(P(Eq(X[1], 1)), Rational(1, 4))) == Rational(1, 12)\n    assert P(Eq(X[2], 1) | Eq(X[2], 2), Eq(X[1], 1)) == Rational(2, 3)\n    assert P(Eq(X[2], 1) & Eq(X[2], 2), Eq(X[1], 1)) is S.Zero\n    assert P(Ne(X[2], 2), Eq(X[1], 1)) == Rational(1, 3)\n    assert E(X[1] ** 2, Eq(X[0], 1)) == Rational(8, 3)\n    assert variance(X[1], Eq(X[0], 1)) == Rational(8, 9)\n    raises(ValueError, lambda : E(X[1], Eq(X[2], 1)))\n    raises(ValueError, lambda : DiscreteMarkovChain('X', [0, 1], T))\n    X = DiscreteMarkovChain('X', ['A', 'B', 'C'], T)\n    assert P(Eq(X[1], 2) & Eq(X[2], 1) & Eq(X[3], 0), Eq(P(Eq(X[1], 0)), Rational(1, 4)) & Eq(P(Eq(X[1], 1)), Rational(1, 4))) == Rational(1, 12)\n    assert P(Eq(X[2], 1) | Eq(X[2], 2), Eq(X[1], 1)) == Rational(2, 3)\n    assert P(Eq(X[2], 1) & Eq(X[2], 2), Eq(X[1], 1)) is S.Zero\n    assert P(Ne(X[2], 2), Eq(X[1], 1)) == Rational(1, 3)\n    a = X.state_space.args[0]\n    c = X.state_space.args[2]\n    assert (E(X[1] ** 2, Eq(X[0], 1)) - (a ** 2 / 3 + 2 * c ** 2 / 3)).simplify() == 0\n    assert (variance(X[1], Eq(X[0], 1)) - (2 * (-a / 3 + c / 3) ** 2 / 3 + (2 * a / 3 - 2 * c / 3) ** 2 / 3)).simplify() == 0\n    raises(ValueError, lambda : E(X[1], Eq(X[2], 1)))\n    T = Matrix([[Rational(5, 10), Rational(3, 10), Rational(2, 10)], [Rational(2, 10), Rational(7, 10), Rational(1, 10)], [Rational(3, 10), Rational(3, 10), Rational(4, 10)]])\n    Y = DiscreteMarkovChain('Y', [0, 1, 2], T)\n    assert P(Eq(Y[7], Y[5]), Eq(Y[2], 0)).round(5) == Float(0.44428, 5)\n    assert P(Gt(Y[3], Y[1]), Eq(Y[0], 0)).round(2) == Float(0.36, 2)\n    assert P(Le(Y[5], Y[10]), Eq(Y[4], 2)).round(6) == Float(0.58312, 6)\n    assert Float(P(Eq(Y[10], Y[5]), Eq(Y[4], 1)), 14) == Float(1 - P(Ne(Y[10], Y[5]), Eq(Y[4], 1)), 14)\n    assert Float(P(Gt(Y[8], Y[9]), Eq(Y[3], 2)), 14) == Float(1 - P(Le(Y[8], Y[9]), Eq(Y[3], 2)), 14)\n    assert Float(P(Lt(Y[1], Y[4]), Eq(Y[0], 0)), 14) == Float(1 - P(Ge(Y[1], Y[4]), Eq(Y[0], 0)), 14)\n    assert P(Eq(Y[5], Y[10]), Eq(Y[2], 1)) == P(Eq(Y[10], Y[5]), Eq(Y[2], 1))\n    assert P(Gt(Y[1], Y[2]), Eq(Y[0], 1)) == P(Lt(Y[2], Y[1]), Eq(Y[0], 1))\n    assert P(Ge(Y[7], Y[6]), Eq(Y[4], 1)) == P(Le(Y[6], Y[7]), Eq(Y[4], 1))\n    (a, b, c, d) = symbols('a b c d')\n    T = Matrix([[Rational(1, 10), Rational(4, 10), Rational(5, 10)], [Rational(3, 10), Rational(4, 10), Rational(3, 10)], [Rational(7, 10), Rational(2, 10), Rational(1, 10)]])\n    Y = DiscreteMarkovChain('Y', [0, 1, 2], T)\n    query = P(Eq(Y[a], b), Eq(Y[c], d))\n    assert query.subs({a: 10, b: 2, c: 5, d: 1}).evalf().round(4) == P(Eq(Y[10], 2), Eq(Y[5], 1)).round(4)\n    assert query.subs({a: 15, b: 0, c: 10, d: 1}).evalf().round(4) == P(Eq(Y[15], 0), Eq(Y[10], 1)).round(4)\n    query_gt = P(Gt(Y[a], b), Eq(Y[c], d))\n    query_le = P(Le(Y[a], b), Eq(Y[c], d))\n    assert query_gt.subs({a: 5, b: 2, c: 1, d: 0}).evalf() + query_le.subs({a: 5, b: 2, c: 1, d: 0}).evalf() == 1.0\n    query_ge = P(Ge(Y[a], b), Eq(Y[c], d))\n    query_lt = P(Lt(Y[a], b), Eq(Y[c], d))\n    assert query_ge.subs({a: 4, b: 1, c: 0, d: 2}).evalf() + query_lt.subs({a: 4, b: 1, c: 0, d: 2}).evalf() == 1.0\n    assert (2 * Y[1] + 3 * Y[1]).simplify() == 5 * Y[1]\n    assert (2 * Y[1] - 3 * Y[1]).simplify() == -Y[1]\n    assert (2 * (0.25 * Y[1])).simplify() == 0.5 * Y[1]\n    assert (2 * Y[1] * (0.25 * Y[1])).simplify() == 0.5 * Y[1] ** 2\n    assert (Y[1] ** 2 + Y[1] ** 3).simplify() == (Y[1] + 1) * Y[1] ** 2",
        "mutated": [
            "def test_DiscreteMarkovChain():\n    if False:\n        i = 10\n    X = DiscreteMarkovChain('X')\n    assert isinstance(X.state_space, Range)\n    assert X.index_set == S.Naturals0\n    assert isinstance(X.transition_probabilities, MatrixSymbol)\n    t = symbols('t', positive=True, integer=True)\n    assert isinstance(X[t], RandomIndexedSymbol)\n    assert E(X[0]) == Expectation(X[0])\n    raises(TypeError, lambda : DiscreteMarkovChain(1))\n    raises(NotImplementedError, lambda : X(t))\n    raises(NotImplementedError, lambda : X.communication_classes())\n    raises(NotImplementedError, lambda : X.canonical_form())\n    raises(NotImplementedError, lambda : X.decompose())\n    nz = Symbol('n', integer=True)\n    TZ = MatrixSymbol('M', nz, nz)\n    SZ = Range(nz)\n    YZ = DiscreteMarkovChain('Y', SZ, TZ)\n    assert P(Eq(YZ[2], 1), Eq(YZ[1], 0)) == TZ[0, 1]\n    raises(ValueError, lambda : sample_stochastic_process(t))\n    raises(ValueError, lambda : next(sample_stochastic_process(X)))\n    (sym, rainy, cloudy, sunny) = symbols('a Rainy Cloudy Sunny', real=True)\n    state_spaces = [(1, 2, 3), [Str('Hello'), sym, DiscreteMarkovChain('Y', (1, 2, 3))], Tuple(S(1), exp(sym), Str('World'), sympify=False), Range(-1, 5, 2), [rainy, cloudy, sunny]]\n    chains = [DiscreteMarkovChain('Y', state_space) for state_space in state_spaces]\n    for (i, Y) in enumerate(chains):\n        assert isinstance(Y.transition_probabilities, MatrixSymbol)\n        assert Y.state_space == state_spaces[i] or Y.state_space == FiniteSet(*state_spaces[i])\n        assert Y.number_of_states == 3\n        with ignore_warnings(UserWarning):\n            assert P(Eq(Y[2], 1), Eq(Y[0], 2), evaluate=False) == Probability(Eq(Y[2], 1), Eq(Y[0], 2))\n        assert E(Y[0]) == Expectation(Y[0])\n        raises(ValueError, lambda : next(sample_stochastic_process(Y)))\n    raises(TypeError, lambda : DiscreteMarkovChain('Y', {1: 1}))\n    Y = DiscreteMarkovChain('Y', Range(1, t, 2))\n    assert Y.number_of_states == ceiling((t - 1) / 2)\n    chains = [DiscreteMarkovChain('Y', trans_probs=Matrix([[]])), DiscreteMarkovChain('Y', trans_probs=Matrix([[0, 1], [1, 0]])), DiscreteMarkovChain('Y', trans_probs=Matrix([[pi, 1 - pi], [sym, 1 - sym]]))]\n    for Z in chains:\n        assert Z.number_of_states == Z.transition_probabilities.shape[0]\n        assert isinstance(Z.transition_probabilities, ImmutableMatrix)\n    T = Matrix([[0.5, 0.2, 0.3], [0.2, 0.5, 0.3], [0.2, 0.3, 0.5]])\n    TS = MatrixSymbol('T', 3, 3)\n    Y = DiscreteMarkovChain('Y', [0, 1, 2], T)\n    YS = DiscreteMarkovChain('Y', ['One', 'Two', 3], TS)\n    assert Y.joint_distribution(1, Y[2], 3) == JointDistribution(Y[1], Y[2], Y[3])\n    raises(ValueError, lambda : Y.joint_distribution(Y[1].symbol, Y[2].symbol))\n    assert P(Eq(Y[3], 2), Eq(Y[1], 1)).round(2) == Float(0.36, 2)\n    assert (P(Eq(YS[3], 2), Eq(YS[1], 1)) - (TS[0, 2] * TS[1, 0] + TS[1, 1] * TS[1, 2] + TS[1, 2] * TS[2, 2])).simplify() == 0\n    assert P(Eq(YS[1], 1), Eq(YS[2], 2)) == Probability(Eq(YS[1], 1))\n    assert P(Eq(YS[3], 3), Eq(YS[1], 1)) == TS[0, 2] * TS[1, 0] + TS[1, 1] * TS[1, 2] + TS[1, 2] * TS[2, 2]\n    TO = Matrix([[0.25, 0.75, 0], [0, 0.25, 0.75], [0.75, 0, 0.25]])\n    assert P(Eq(Y[3], 2), Eq(Y[1], 1) & TransitionMatrixOf(Y, TO)).round(3) == Float(0.375, 3)\n    with ignore_warnings(UserWarning):\n        assert E(Y[3], evaluate=False) == Expectation(Y[3])\n        assert E(Y[3], Eq(Y[2], 1)).round(2) == Float(1.1, 3)\n    TSO = MatrixSymbol('T', 4, 4)\n    raises(ValueError, lambda : str(P(Eq(YS[3], 2), Eq(YS[1], 1) & TransitionMatrixOf(YS, TSO))))\n    raises(TypeError, lambda : DiscreteMarkovChain('Z', [0, 1, 2], symbols('M')))\n    raises(ValueError, lambda : DiscreteMarkovChain('Z', [0, 1, 2], MatrixSymbol('T', 3, 4)))\n    raises(ValueError, lambda : E(Y[3], Eq(Y[2], 6)))\n    raises(ValueError, lambda : E(Y[2], Eq(Y[3], 1)))\n    TO1 = Matrix([[Rational(1, 4), Rational(3, 4), 0], [Rational(1, 3), Rational(1, 3), Rational(1, 3)], [0, Rational(1, 4), Rational(3, 4)]])\n    assert P(And(Eq(Y[2], 1), Eq(Y[1], 1), Eq(Y[0], 0)), Eq(Probability(Eq(Y[0], 0)), Rational(1, 4)) & TransitionMatrixOf(Y, TO1)) == Rational(1, 16)\n    assert P(And(Eq(Y[2], 1), Eq(Y[1], 1), Eq(Y[0], 0)), TransitionMatrixOf(Y, TO1)) == Probability(Eq(Y[0], 0)) / 4\n    assert P(Lt(X[1], 2) & Gt(X[1], 0), Eq(X[0], 2) & StochasticStateSpaceOf(X, [0, 1, 2]) & TransitionMatrixOf(X, TO1)) == Rational(1, 4)\n    assert P(Lt(X[1], 2) & Gt(X[1], 0), Eq(X[0], 2) & StochasticStateSpaceOf(X, [S(0), '0', 1]) & TransitionMatrixOf(X, TO1)) == Rational(1, 4)\n    assert P(Ne(X[1], 2) & Ne(X[1], 1), Eq(X[0], 2) & StochasticStateSpaceOf(X, [0, 1, 2]) & TransitionMatrixOf(X, TO1)) is S.Zero\n    assert P(Ne(X[1], 2) & Ne(X[1], 1), Eq(X[0], 2) & StochasticStateSpaceOf(X, [S(0), '0', 1]) & TransitionMatrixOf(X, TO1)) is S.Zero\n    assert P(And(Eq(Y[2], 1), Eq(Y[1], 1), Eq(Y[0], 0)), Eq(Y[1], 1)) == 0.1 * Probability(Eq(Y[0], 0))\n    TO2 = Matrix([[S.One, 0, 0], [Rational(1, 3), Rational(1, 3), Rational(1, 3)], [0, Rational(1, 4), Rational(3, 4)]])\n    TO3 = Matrix([[Rational(1, 4), Rational(3, 4), 0], [Rational(1, 3), Rational(1, 3), Rational(1, 3)], [0, Rational(1, 4), Rational(3, 4)]])\n    Y2 = DiscreteMarkovChain('Y', trans_probs=TO2)\n    Y3 = DiscreteMarkovChain('Y', trans_probs=TO3)\n    assert Y3.fundamental_matrix() == ImmutableMatrix([[176, 81, -132], [36, 141, -52], [-44, -39, 208]]) / 125\n    assert Y2.is_absorbing_chain() == True\n    assert Y3.is_absorbing_chain() == False\n    assert Y2.canonical_form() == ([0, 1, 2], TO2)\n    assert Y3.canonical_form() == ([0, 1, 2], TO3)\n    assert Y2.decompose() == ([0, 1, 2], TO2[0:1, 0:1], TO2[1:3, 0:1], TO2[1:3, 1:3])\n    assert Y3.decompose() == ([0, 1, 2], TO3, Matrix(0, 3, []), Matrix(0, 0, []))\n    TO4 = Matrix([[Rational(1, 5), Rational(2, 5), Rational(2, 5)], [Rational(1, 10), S.Half, Rational(2, 5)], [Rational(3, 5), Rational(3, 10), Rational(1, 10)]])\n    Y4 = DiscreteMarkovChain('Y', trans_probs=TO4)\n    w = ImmutableMatrix([[Rational(11, 39), Rational(16, 39), Rational(4, 13)]])\n    assert Y4.limiting_distribution == w\n    assert Y4.is_regular() == True\n    assert Y4.is_ergodic() == True\n    TS1 = MatrixSymbol('T', 3, 3)\n    Y5 = DiscreteMarkovChain('Y', trans_probs=TS1)\n    assert Y5.limiting_distribution(w, TO4).doit() == True\n    assert Y5.stationary_distribution(condition_set=True).subs(TS1, TO4).contains(w).doit() == S.true\n    TO6 = Matrix([[S.One, 0, 0, 0, 0], [S.Half, 0, S.Half, 0, 0], [0, S.Half, 0, S.Half, 0], [0, 0, S.Half, 0, S.Half], [0, 0, 0, 0, 1]])\n    Y6 = DiscreteMarkovChain('Y', trans_probs=TO6)\n    assert Y6.fundamental_matrix() == ImmutableMatrix([[Rational(3, 2), S.One, S.Half], [S.One, S(2), S.One], [S.Half, S.One, Rational(3, 2)]])\n    assert Y6.absorbing_probabilities() == ImmutableMatrix([[Rational(3, 4), Rational(1, 4)], [S.Half, S.Half], [Rational(1, 4), Rational(3, 4)]])\n    with warns_deprecated_sympy():\n        Y6.absorbing_probabilites()\n    TO7 = Matrix([[Rational(1, 2), Rational(1, 4), Rational(1, 4)], [Rational(1, 2), 0, Rational(1, 2)], [Rational(1, 4), Rational(1, 4), Rational(1, 2)]])\n    Y7 = DiscreteMarkovChain('Y', trans_probs=TO7)\n    assert Y7.is_absorbing_chain() == False\n    assert Y7.fundamental_matrix() == ImmutableMatrix([[Rational(86, 75), Rational(1, 25), Rational(-14, 75)], [Rational(2, 25), Rational(21, 25), Rational(2, 25)], [Rational(-14, 75), Rational(1, 25), Rational(86, 75)]])\n    X = DiscreteMarkovChain('X', trans_probs=Matrix([[]]))\n    assert X.number_of_states == 0\n    assert X.stationary_distribution() == Matrix([[]])\n    assert X.communication_classes() == []\n    assert X.canonical_form() == ([], Matrix([[]]))\n    assert X.decompose() == ([], Matrix([[]]), Matrix([[]]), Matrix([[]]))\n    assert X.is_regular() == False\n    assert X.is_ergodic() == False\n    TO7 = Matrix([[0, 5, 5, 0, 0], [0, 0, 0, 10, 0], [5, 0, 5, 0, 0], [0, 10, 0, 0, 0], [0, 3, 0, 3, 4]]) / 10\n    Y7 = DiscreteMarkovChain('Y', trans_probs=TO7)\n    tuples = Y7.communication_classes()\n    (classes, recurrence, periods) = list(zip(*tuples))\n    assert classes == ([1, 3], [0, 2], [4])\n    assert recurrence == (True, False, False)\n    assert periods == (2, 1, 1)\n    TO8 = Matrix([[0, 0, 0, 10, 0, 0], [5, 0, 5, 0, 0, 0], [0, 4, 0, 0, 0, 6], [10, 0, 0, 0, 0, 0], [0, 10, 0, 0, 0, 0], [0, 0, 0, 5, 5, 0]]) / 10\n    Y8 = DiscreteMarkovChain('Y', trans_probs=TO8)\n    tuples = Y8.communication_classes()\n    (classes, recurrence, periods) = list(zip(*tuples))\n    assert classes == ([0, 3], [1, 2, 5, 4])\n    assert recurrence == (True, False)\n    assert periods == (2, 2)\n    TO9 = Matrix([[2, 0, 0, 3, 0, 0, 3, 2, 0, 0], [0, 10, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 0, 0, 0, 0, 0, 3, 3], [0, 0, 0, 3, 0, 0, 6, 1, 0, 0], [0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 10, 0, 0, 0, 0], [4, 0, 0, 5, 0, 0, 1, 0, 0, 0], [2, 0, 0, 4, 0, 0, 2, 2, 0, 0], [3, 0, 1, 0, 0, 0, 0, 0, 4, 2], [0, 0, 4, 0, 0, 0, 0, 0, 3, 3]]) / 10\n    Y9 = DiscreteMarkovChain('Y', trans_probs=TO9)\n    tuples = Y9.communication_classes()\n    (classes, recurrence, periods) = list(zip(*tuples))\n    assert classes == ([0, 3, 6, 7], [1], [2, 8, 9], [5], [4])\n    assert recurrence == (True, True, False, True, False)\n    assert periods == (1, 1, 1, 1, 1)\n    T = Matrix([[1, 0, 0, 0, 0], [S(1) / 2, 0, S(1) / 2, 0, 0], [0, S(1) / 2, 0, S(1) / 2, 0], [0, 0, S(1) / 2, 0, S(1) / 2], [0, 0, 0, 0, S(1)]])\n    DW = DiscreteMarkovChain('DW', [0, 1, 2, 3, 4], T)\n    (states, A, B, C) = DW.decompose()\n    assert states == [0, 4, 1, 2, 3]\n    assert A == Matrix([[1, 0], [0, 1]])\n    assert B == Matrix([[S(1) / 2, 0], [0, 0], [0, S(1) / 2]])\n    assert C == Matrix([[0, S(1) / 2, 0], [S(1) / 2, 0, S(1) / 2], [0, S(1) / 2, 0]])\n    (states, new_matrix) = DW.canonical_form()\n    assert states == [0, 4, 1, 2, 3]\n    assert new_matrix == Matrix([[1, 0, 0, 0, 0], [0, 1, 0, 0, 0], [S(1) / 2, 0, 0, S(1) / 2, 0], [0, 0, S(1) / 2, 0, S(1) / 2], [0, S(1) / 2, 0, S(1) / 2, 0]])\n    T = Matrix([[0, 4, 0, 0, 0], [1, 0, 3, 0, 0], [0, 2, 0, 2, 0], [0, 0, 3, 0, 1], [0, 0, 0, 4, 0]]) / 4\n    X = DiscreteMarkovChain('X', trans_probs=T)\n    assert not X.is_regular()\n    assert X.is_ergodic()\n    T = Matrix([[0, 1], [1, 0]])\n    X = DiscreteMarkovChain('X', trans_probs=T)\n    assert not X.is_regular()\n    assert X.is_ergodic()\n    T = Matrix([[2, 1, 1], [2, 0, 2], [1, 1, 2]]) / 4\n    X = DiscreteMarkovChain('X', trans_probs=T)\n    assert X.is_regular()\n    assert X.is_ergodic()\n    T = Matrix([[1, 1], [1, 1]]) / 2\n    X = DiscreteMarkovChain('X', trans_probs=T)\n    assert X.is_regular()\n    assert X.is_ergodic()\n    T = Matrix([[0, 1, 0], [1, 0, 0], [0, 0, 1]])\n    X = DiscreteMarkovChain('X', trans_probs=T)\n    assert not X.is_absorbing_chain()\n    T = Matrix([[1, 1, 0, 0], [0, 1, 1, 0], [1, 0, 0, 1], [0, 0, 0, 2]]) / 2\n    X = DiscreteMarkovChain('X', trans_probs=T)\n    assert X.is_absorbing_chain()\n    T = Matrix([[2, 0, 0, 0, 0], [1, 0, 1, 0, 0], [0, 1, 0, 1, 0], [0, 0, 1, 0, 1], [0, 0, 0, 0, 2]]) / 2\n    X = DiscreteMarkovChain('X', trans_probs=T)\n    assert X.is_absorbing_chain()\n    Y10 = DiscreteMarkovChain('Y', [1, 2, 3], TO2)\n    tuples = Y10.communication_classes()\n    (classes, recurrence, periods) = list(zip(*tuples))\n    assert classes == ([1], [2, 3])\n    assert recurrence == (True, False)\n    assert periods == (1, 1)\n    assert Y10.canonical_form() == ([1, 2, 3], TO2)\n    assert Y10.decompose() == ([1, 2, 3], TO2[0:1, 0:1], TO2[1:3, 0:1], TO2[1:3, 1:3])\n    T = Matrix([[S.Half, Rational(1, 4), Rational(1, 4)], [Rational(1, 3), 0, Rational(2, 3)], [S.Half, S.Half, 0]])\n    X = DiscreteMarkovChain('X', [0, 1, 2], T)\n    assert P(Eq(X[1], 2) & Eq(X[2], 1) & Eq(X[3], 0), Eq(P(Eq(X[1], 0)), Rational(1, 4)) & Eq(P(Eq(X[1], 1)), Rational(1, 4))) == Rational(1, 12)\n    assert P(Eq(X[2], 1) | Eq(X[2], 2), Eq(X[1], 1)) == Rational(2, 3)\n    assert P(Eq(X[2], 1) & Eq(X[2], 2), Eq(X[1], 1)) is S.Zero\n    assert P(Ne(X[2], 2), Eq(X[1], 1)) == Rational(1, 3)\n    assert E(X[1] ** 2, Eq(X[0], 1)) == Rational(8, 3)\n    assert variance(X[1], Eq(X[0], 1)) == Rational(8, 9)\n    raises(ValueError, lambda : E(X[1], Eq(X[2], 1)))\n    raises(ValueError, lambda : DiscreteMarkovChain('X', [0, 1], T))\n    X = DiscreteMarkovChain('X', ['A', 'B', 'C'], T)\n    assert P(Eq(X[1], 2) & Eq(X[2], 1) & Eq(X[3], 0), Eq(P(Eq(X[1], 0)), Rational(1, 4)) & Eq(P(Eq(X[1], 1)), Rational(1, 4))) == Rational(1, 12)\n    assert P(Eq(X[2], 1) | Eq(X[2], 2), Eq(X[1], 1)) == Rational(2, 3)\n    assert P(Eq(X[2], 1) & Eq(X[2], 2), Eq(X[1], 1)) is S.Zero\n    assert P(Ne(X[2], 2), Eq(X[1], 1)) == Rational(1, 3)\n    a = X.state_space.args[0]\n    c = X.state_space.args[2]\n    assert (E(X[1] ** 2, Eq(X[0], 1)) - (a ** 2 / 3 + 2 * c ** 2 / 3)).simplify() == 0\n    assert (variance(X[1], Eq(X[0], 1)) - (2 * (-a / 3 + c / 3) ** 2 / 3 + (2 * a / 3 - 2 * c / 3) ** 2 / 3)).simplify() == 0\n    raises(ValueError, lambda : E(X[1], Eq(X[2], 1)))\n    T = Matrix([[Rational(5, 10), Rational(3, 10), Rational(2, 10)], [Rational(2, 10), Rational(7, 10), Rational(1, 10)], [Rational(3, 10), Rational(3, 10), Rational(4, 10)]])\n    Y = DiscreteMarkovChain('Y', [0, 1, 2], T)\n    assert P(Eq(Y[7], Y[5]), Eq(Y[2], 0)).round(5) == Float(0.44428, 5)\n    assert P(Gt(Y[3], Y[1]), Eq(Y[0], 0)).round(2) == Float(0.36, 2)\n    assert P(Le(Y[5], Y[10]), Eq(Y[4], 2)).round(6) == Float(0.58312, 6)\n    assert Float(P(Eq(Y[10], Y[5]), Eq(Y[4], 1)), 14) == Float(1 - P(Ne(Y[10], Y[5]), Eq(Y[4], 1)), 14)\n    assert Float(P(Gt(Y[8], Y[9]), Eq(Y[3], 2)), 14) == Float(1 - P(Le(Y[8], Y[9]), Eq(Y[3], 2)), 14)\n    assert Float(P(Lt(Y[1], Y[4]), Eq(Y[0], 0)), 14) == Float(1 - P(Ge(Y[1], Y[4]), Eq(Y[0], 0)), 14)\n    assert P(Eq(Y[5], Y[10]), Eq(Y[2], 1)) == P(Eq(Y[10], Y[5]), Eq(Y[2], 1))\n    assert P(Gt(Y[1], Y[2]), Eq(Y[0], 1)) == P(Lt(Y[2], Y[1]), Eq(Y[0], 1))\n    assert P(Ge(Y[7], Y[6]), Eq(Y[4], 1)) == P(Le(Y[6], Y[7]), Eq(Y[4], 1))\n    (a, b, c, d) = symbols('a b c d')\n    T = Matrix([[Rational(1, 10), Rational(4, 10), Rational(5, 10)], [Rational(3, 10), Rational(4, 10), Rational(3, 10)], [Rational(7, 10), Rational(2, 10), Rational(1, 10)]])\n    Y = DiscreteMarkovChain('Y', [0, 1, 2], T)\n    query = P(Eq(Y[a], b), Eq(Y[c], d))\n    assert query.subs({a: 10, b: 2, c: 5, d: 1}).evalf().round(4) == P(Eq(Y[10], 2), Eq(Y[5], 1)).round(4)\n    assert query.subs({a: 15, b: 0, c: 10, d: 1}).evalf().round(4) == P(Eq(Y[15], 0), Eq(Y[10], 1)).round(4)\n    query_gt = P(Gt(Y[a], b), Eq(Y[c], d))\n    query_le = P(Le(Y[a], b), Eq(Y[c], d))\n    assert query_gt.subs({a: 5, b: 2, c: 1, d: 0}).evalf() + query_le.subs({a: 5, b: 2, c: 1, d: 0}).evalf() == 1.0\n    query_ge = P(Ge(Y[a], b), Eq(Y[c], d))\n    query_lt = P(Lt(Y[a], b), Eq(Y[c], d))\n    assert query_ge.subs({a: 4, b: 1, c: 0, d: 2}).evalf() + query_lt.subs({a: 4, b: 1, c: 0, d: 2}).evalf() == 1.0\n    assert (2 * Y[1] + 3 * Y[1]).simplify() == 5 * Y[1]\n    assert (2 * Y[1] - 3 * Y[1]).simplify() == -Y[1]\n    assert (2 * (0.25 * Y[1])).simplify() == 0.5 * Y[1]\n    assert (2 * Y[1] * (0.25 * Y[1])).simplify() == 0.5 * Y[1] ** 2\n    assert (Y[1] ** 2 + Y[1] ** 3).simplify() == (Y[1] + 1) * Y[1] ** 2",
            "def test_DiscreteMarkovChain():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    X = DiscreteMarkovChain('X')\n    assert isinstance(X.state_space, Range)\n    assert X.index_set == S.Naturals0\n    assert isinstance(X.transition_probabilities, MatrixSymbol)\n    t = symbols('t', positive=True, integer=True)\n    assert isinstance(X[t], RandomIndexedSymbol)\n    assert E(X[0]) == Expectation(X[0])\n    raises(TypeError, lambda : DiscreteMarkovChain(1))\n    raises(NotImplementedError, lambda : X(t))\n    raises(NotImplementedError, lambda : X.communication_classes())\n    raises(NotImplementedError, lambda : X.canonical_form())\n    raises(NotImplementedError, lambda : X.decompose())\n    nz = Symbol('n', integer=True)\n    TZ = MatrixSymbol('M', nz, nz)\n    SZ = Range(nz)\n    YZ = DiscreteMarkovChain('Y', SZ, TZ)\n    assert P(Eq(YZ[2], 1), Eq(YZ[1], 0)) == TZ[0, 1]\n    raises(ValueError, lambda : sample_stochastic_process(t))\n    raises(ValueError, lambda : next(sample_stochastic_process(X)))\n    (sym, rainy, cloudy, sunny) = symbols('a Rainy Cloudy Sunny', real=True)\n    state_spaces = [(1, 2, 3), [Str('Hello'), sym, DiscreteMarkovChain('Y', (1, 2, 3))], Tuple(S(1), exp(sym), Str('World'), sympify=False), Range(-1, 5, 2), [rainy, cloudy, sunny]]\n    chains = [DiscreteMarkovChain('Y', state_space) for state_space in state_spaces]\n    for (i, Y) in enumerate(chains):\n        assert isinstance(Y.transition_probabilities, MatrixSymbol)\n        assert Y.state_space == state_spaces[i] or Y.state_space == FiniteSet(*state_spaces[i])\n        assert Y.number_of_states == 3\n        with ignore_warnings(UserWarning):\n            assert P(Eq(Y[2], 1), Eq(Y[0], 2), evaluate=False) == Probability(Eq(Y[2], 1), Eq(Y[0], 2))\n        assert E(Y[0]) == Expectation(Y[0])\n        raises(ValueError, lambda : next(sample_stochastic_process(Y)))\n    raises(TypeError, lambda : DiscreteMarkovChain('Y', {1: 1}))\n    Y = DiscreteMarkovChain('Y', Range(1, t, 2))\n    assert Y.number_of_states == ceiling((t - 1) / 2)\n    chains = [DiscreteMarkovChain('Y', trans_probs=Matrix([[]])), DiscreteMarkovChain('Y', trans_probs=Matrix([[0, 1], [1, 0]])), DiscreteMarkovChain('Y', trans_probs=Matrix([[pi, 1 - pi], [sym, 1 - sym]]))]\n    for Z in chains:\n        assert Z.number_of_states == Z.transition_probabilities.shape[0]\n        assert isinstance(Z.transition_probabilities, ImmutableMatrix)\n    T = Matrix([[0.5, 0.2, 0.3], [0.2, 0.5, 0.3], [0.2, 0.3, 0.5]])\n    TS = MatrixSymbol('T', 3, 3)\n    Y = DiscreteMarkovChain('Y', [0, 1, 2], T)\n    YS = DiscreteMarkovChain('Y', ['One', 'Two', 3], TS)\n    assert Y.joint_distribution(1, Y[2], 3) == JointDistribution(Y[1], Y[2], Y[3])\n    raises(ValueError, lambda : Y.joint_distribution(Y[1].symbol, Y[2].symbol))\n    assert P(Eq(Y[3], 2), Eq(Y[1], 1)).round(2) == Float(0.36, 2)\n    assert (P(Eq(YS[3], 2), Eq(YS[1], 1)) - (TS[0, 2] * TS[1, 0] + TS[1, 1] * TS[1, 2] + TS[1, 2] * TS[2, 2])).simplify() == 0\n    assert P(Eq(YS[1], 1), Eq(YS[2], 2)) == Probability(Eq(YS[1], 1))\n    assert P(Eq(YS[3], 3), Eq(YS[1], 1)) == TS[0, 2] * TS[1, 0] + TS[1, 1] * TS[1, 2] + TS[1, 2] * TS[2, 2]\n    TO = Matrix([[0.25, 0.75, 0], [0, 0.25, 0.75], [0.75, 0, 0.25]])\n    assert P(Eq(Y[3], 2), Eq(Y[1], 1) & TransitionMatrixOf(Y, TO)).round(3) == Float(0.375, 3)\n    with ignore_warnings(UserWarning):\n        assert E(Y[3], evaluate=False) == Expectation(Y[3])\n        assert E(Y[3], Eq(Y[2], 1)).round(2) == Float(1.1, 3)\n    TSO = MatrixSymbol('T', 4, 4)\n    raises(ValueError, lambda : str(P(Eq(YS[3], 2), Eq(YS[1], 1) & TransitionMatrixOf(YS, TSO))))\n    raises(TypeError, lambda : DiscreteMarkovChain('Z', [0, 1, 2], symbols('M')))\n    raises(ValueError, lambda : DiscreteMarkovChain('Z', [0, 1, 2], MatrixSymbol('T', 3, 4)))\n    raises(ValueError, lambda : E(Y[3], Eq(Y[2], 6)))\n    raises(ValueError, lambda : E(Y[2], Eq(Y[3], 1)))\n    TO1 = Matrix([[Rational(1, 4), Rational(3, 4), 0], [Rational(1, 3), Rational(1, 3), Rational(1, 3)], [0, Rational(1, 4), Rational(3, 4)]])\n    assert P(And(Eq(Y[2], 1), Eq(Y[1], 1), Eq(Y[0], 0)), Eq(Probability(Eq(Y[0], 0)), Rational(1, 4)) & TransitionMatrixOf(Y, TO1)) == Rational(1, 16)\n    assert P(And(Eq(Y[2], 1), Eq(Y[1], 1), Eq(Y[0], 0)), TransitionMatrixOf(Y, TO1)) == Probability(Eq(Y[0], 0)) / 4\n    assert P(Lt(X[1], 2) & Gt(X[1], 0), Eq(X[0], 2) & StochasticStateSpaceOf(X, [0, 1, 2]) & TransitionMatrixOf(X, TO1)) == Rational(1, 4)\n    assert P(Lt(X[1], 2) & Gt(X[1], 0), Eq(X[0], 2) & StochasticStateSpaceOf(X, [S(0), '0', 1]) & TransitionMatrixOf(X, TO1)) == Rational(1, 4)\n    assert P(Ne(X[1], 2) & Ne(X[1], 1), Eq(X[0], 2) & StochasticStateSpaceOf(X, [0, 1, 2]) & TransitionMatrixOf(X, TO1)) is S.Zero\n    assert P(Ne(X[1], 2) & Ne(X[1], 1), Eq(X[0], 2) & StochasticStateSpaceOf(X, [S(0), '0', 1]) & TransitionMatrixOf(X, TO1)) is S.Zero\n    assert P(And(Eq(Y[2], 1), Eq(Y[1], 1), Eq(Y[0], 0)), Eq(Y[1], 1)) == 0.1 * Probability(Eq(Y[0], 0))\n    TO2 = Matrix([[S.One, 0, 0], [Rational(1, 3), Rational(1, 3), Rational(1, 3)], [0, Rational(1, 4), Rational(3, 4)]])\n    TO3 = Matrix([[Rational(1, 4), Rational(3, 4), 0], [Rational(1, 3), Rational(1, 3), Rational(1, 3)], [0, Rational(1, 4), Rational(3, 4)]])\n    Y2 = DiscreteMarkovChain('Y', trans_probs=TO2)\n    Y3 = DiscreteMarkovChain('Y', trans_probs=TO3)\n    assert Y3.fundamental_matrix() == ImmutableMatrix([[176, 81, -132], [36, 141, -52], [-44, -39, 208]]) / 125\n    assert Y2.is_absorbing_chain() == True\n    assert Y3.is_absorbing_chain() == False\n    assert Y2.canonical_form() == ([0, 1, 2], TO2)\n    assert Y3.canonical_form() == ([0, 1, 2], TO3)\n    assert Y2.decompose() == ([0, 1, 2], TO2[0:1, 0:1], TO2[1:3, 0:1], TO2[1:3, 1:3])\n    assert Y3.decompose() == ([0, 1, 2], TO3, Matrix(0, 3, []), Matrix(0, 0, []))\n    TO4 = Matrix([[Rational(1, 5), Rational(2, 5), Rational(2, 5)], [Rational(1, 10), S.Half, Rational(2, 5)], [Rational(3, 5), Rational(3, 10), Rational(1, 10)]])\n    Y4 = DiscreteMarkovChain('Y', trans_probs=TO4)\n    w = ImmutableMatrix([[Rational(11, 39), Rational(16, 39), Rational(4, 13)]])\n    assert Y4.limiting_distribution == w\n    assert Y4.is_regular() == True\n    assert Y4.is_ergodic() == True\n    TS1 = MatrixSymbol('T', 3, 3)\n    Y5 = DiscreteMarkovChain('Y', trans_probs=TS1)\n    assert Y5.limiting_distribution(w, TO4).doit() == True\n    assert Y5.stationary_distribution(condition_set=True).subs(TS1, TO4).contains(w).doit() == S.true\n    TO6 = Matrix([[S.One, 0, 0, 0, 0], [S.Half, 0, S.Half, 0, 0], [0, S.Half, 0, S.Half, 0], [0, 0, S.Half, 0, S.Half], [0, 0, 0, 0, 1]])\n    Y6 = DiscreteMarkovChain('Y', trans_probs=TO6)\n    assert Y6.fundamental_matrix() == ImmutableMatrix([[Rational(3, 2), S.One, S.Half], [S.One, S(2), S.One], [S.Half, S.One, Rational(3, 2)]])\n    assert Y6.absorbing_probabilities() == ImmutableMatrix([[Rational(3, 4), Rational(1, 4)], [S.Half, S.Half], [Rational(1, 4), Rational(3, 4)]])\n    with warns_deprecated_sympy():\n        Y6.absorbing_probabilites()\n    TO7 = Matrix([[Rational(1, 2), Rational(1, 4), Rational(1, 4)], [Rational(1, 2), 0, Rational(1, 2)], [Rational(1, 4), Rational(1, 4), Rational(1, 2)]])\n    Y7 = DiscreteMarkovChain('Y', trans_probs=TO7)\n    assert Y7.is_absorbing_chain() == False\n    assert Y7.fundamental_matrix() == ImmutableMatrix([[Rational(86, 75), Rational(1, 25), Rational(-14, 75)], [Rational(2, 25), Rational(21, 25), Rational(2, 25)], [Rational(-14, 75), Rational(1, 25), Rational(86, 75)]])\n    X = DiscreteMarkovChain('X', trans_probs=Matrix([[]]))\n    assert X.number_of_states == 0\n    assert X.stationary_distribution() == Matrix([[]])\n    assert X.communication_classes() == []\n    assert X.canonical_form() == ([], Matrix([[]]))\n    assert X.decompose() == ([], Matrix([[]]), Matrix([[]]), Matrix([[]]))\n    assert X.is_regular() == False\n    assert X.is_ergodic() == False\n    TO7 = Matrix([[0, 5, 5, 0, 0], [0, 0, 0, 10, 0], [5, 0, 5, 0, 0], [0, 10, 0, 0, 0], [0, 3, 0, 3, 4]]) / 10\n    Y7 = DiscreteMarkovChain('Y', trans_probs=TO7)\n    tuples = Y7.communication_classes()\n    (classes, recurrence, periods) = list(zip(*tuples))\n    assert classes == ([1, 3], [0, 2], [4])\n    assert recurrence == (True, False, False)\n    assert periods == (2, 1, 1)\n    TO8 = Matrix([[0, 0, 0, 10, 0, 0], [5, 0, 5, 0, 0, 0], [0, 4, 0, 0, 0, 6], [10, 0, 0, 0, 0, 0], [0, 10, 0, 0, 0, 0], [0, 0, 0, 5, 5, 0]]) / 10\n    Y8 = DiscreteMarkovChain('Y', trans_probs=TO8)\n    tuples = Y8.communication_classes()\n    (classes, recurrence, periods) = list(zip(*tuples))\n    assert classes == ([0, 3], [1, 2, 5, 4])\n    assert recurrence == (True, False)\n    assert periods == (2, 2)\n    TO9 = Matrix([[2, 0, 0, 3, 0, 0, 3, 2, 0, 0], [0, 10, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 0, 0, 0, 0, 0, 3, 3], [0, 0, 0, 3, 0, 0, 6, 1, 0, 0], [0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 10, 0, 0, 0, 0], [4, 0, 0, 5, 0, 0, 1, 0, 0, 0], [2, 0, 0, 4, 0, 0, 2, 2, 0, 0], [3, 0, 1, 0, 0, 0, 0, 0, 4, 2], [0, 0, 4, 0, 0, 0, 0, 0, 3, 3]]) / 10\n    Y9 = DiscreteMarkovChain('Y', trans_probs=TO9)\n    tuples = Y9.communication_classes()\n    (classes, recurrence, periods) = list(zip(*tuples))\n    assert classes == ([0, 3, 6, 7], [1], [2, 8, 9], [5], [4])\n    assert recurrence == (True, True, False, True, False)\n    assert periods == (1, 1, 1, 1, 1)\n    T = Matrix([[1, 0, 0, 0, 0], [S(1) / 2, 0, S(1) / 2, 0, 0], [0, S(1) / 2, 0, S(1) / 2, 0], [0, 0, S(1) / 2, 0, S(1) / 2], [0, 0, 0, 0, S(1)]])\n    DW = DiscreteMarkovChain('DW', [0, 1, 2, 3, 4], T)\n    (states, A, B, C) = DW.decompose()\n    assert states == [0, 4, 1, 2, 3]\n    assert A == Matrix([[1, 0], [0, 1]])\n    assert B == Matrix([[S(1) / 2, 0], [0, 0], [0, S(1) / 2]])\n    assert C == Matrix([[0, S(1) / 2, 0], [S(1) / 2, 0, S(1) / 2], [0, S(1) / 2, 0]])\n    (states, new_matrix) = DW.canonical_form()\n    assert states == [0, 4, 1, 2, 3]\n    assert new_matrix == Matrix([[1, 0, 0, 0, 0], [0, 1, 0, 0, 0], [S(1) / 2, 0, 0, S(1) / 2, 0], [0, 0, S(1) / 2, 0, S(1) / 2], [0, S(1) / 2, 0, S(1) / 2, 0]])\n    T = Matrix([[0, 4, 0, 0, 0], [1, 0, 3, 0, 0], [0, 2, 0, 2, 0], [0, 0, 3, 0, 1], [0, 0, 0, 4, 0]]) / 4\n    X = DiscreteMarkovChain('X', trans_probs=T)\n    assert not X.is_regular()\n    assert X.is_ergodic()\n    T = Matrix([[0, 1], [1, 0]])\n    X = DiscreteMarkovChain('X', trans_probs=T)\n    assert not X.is_regular()\n    assert X.is_ergodic()\n    T = Matrix([[2, 1, 1], [2, 0, 2], [1, 1, 2]]) / 4\n    X = DiscreteMarkovChain('X', trans_probs=T)\n    assert X.is_regular()\n    assert X.is_ergodic()\n    T = Matrix([[1, 1], [1, 1]]) / 2\n    X = DiscreteMarkovChain('X', trans_probs=T)\n    assert X.is_regular()\n    assert X.is_ergodic()\n    T = Matrix([[0, 1, 0], [1, 0, 0], [0, 0, 1]])\n    X = DiscreteMarkovChain('X', trans_probs=T)\n    assert not X.is_absorbing_chain()\n    T = Matrix([[1, 1, 0, 0], [0, 1, 1, 0], [1, 0, 0, 1], [0, 0, 0, 2]]) / 2\n    X = DiscreteMarkovChain('X', trans_probs=T)\n    assert X.is_absorbing_chain()\n    T = Matrix([[2, 0, 0, 0, 0], [1, 0, 1, 0, 0], [0, 1, 0, 1, 0], [0, 0, 1, 0, 1], [0, 0, 0, 0, 2]]) / 2\n    X = DiscreteMarkovChain('X', trans_probs=T)\n    assert X.is_absorbing_chain()\n    Y10 = DiscreteMarkovChain('Y', [1, 2, 3], TO2)\n    tuples = Y10.communication_classes()\n    (classes, recurrence, periods) = list(zip(*tuples))\n    assert classes == ([1], [2, 3])\n    assert recurrence == (True, False)\n    assert periods == (1, 1)\n    assert Y10.canonical_form() == ([1, 2, 3], TO2)\n    assert Y10.decompose() == ([1, 2, 3], TO2[0:1, 0:1], TO2[1:3, 0:1], TO2[1:3, 1:3])\n    T = Matrix([[S.Half, Rational(1, 4), Rational(1, 4)], [Rational(1, 3), 0, Rational(2, 3)], [S.Half, S.Half, 0]])\n    X = DiscreteMarkovChain('X', [0, 1, 2], T)\n    assert P(Eq(X[1], 2) & Eq(X[2], 1) & Eq(X[3], 0), Eq(P(Eq(X[1], 0)), Rational(1, 4)) & Eq(P(Eq(X[1], 1)), Rational(1, 4))) == Rational(1, 12)\n    assert P(Eq(X[2], 1) | Eq(X[2], 2), Eq(X[1], 1)) == Rational(2, 3)\n    assert P(Eq(X[2], 1) & Eq(X[2], 2), Eq(X[1], 1)) is S.Zero\n    assert P(Ne(X[2], 2), Eq(X[1], 1)) == Rational(1, 3)\n    assert E(X[1] ** 2, Eq(X[0], 1)) == Rational(8, 3)\n    assert variance(X[1], Eq(X[0], 1)) == Rational(8, 9)\n    raises(ValueError, lambda : E(X[1], Eq(X[2], 1)))\n    raises(ValueError, lambda : DiscreteMarkovChain('X', [0, 1], T))\n    X = DiscreteMarkovChain('X', ['A', 'B', 'C'], T)\n    assert P(Eq(X[1], 2) & Eq(X[2], 1) & Eq(X[3], 0), Eq(P(Eq(X[1], 0)), Rational(1, 4)) & Eq(P(Eq(X[1], 1)), Rational(1, 4))) == Rational(1, 12)\n    assert P(Eq(X[2], 1) | Eq(X[2], 2), Eq(X[1], 1)) == Rational(2, 3)\n    assert P(Eq(X[2], 1) & Eq(X[2], 2), Eq(X[1], 1)) is S.Zero\n    assert P(Ne(X[2], 2), Eq(X[1], 1)) == Rational(1, 3)\n    a = X.state_space.args[0]\n    c = X.state_space.args[2]\n    assert (E(X[1] ** 2, Eq(X[0], 1)) - (a ** 2 / 3 + 2 * c ** 2 / 3)).simplify() == 0\n    assert (variance(X[1], Eq(X[0], 1)) - (2 * (-a / 3 + c / 3) ** 2 / 3 + (2 * a / 3 - 2 * c / 3) ** 2 / 3)).simplify() == 0\n    raises(ValueError, lambda : E(X[1], Eq(X[2], 1)))\n    T = Matrix([[Rational(5, 10), Rational(3, 10), Rational(2, 10)], [Rational(2, 10), Rational(7, 10), Rational(1, 10)], [Rational(3, 10), Rational(3, 10), Rational(4, 10)]])\n    Y = DiscreteMarkovChain('Y', [0, 1, 2], T)\n    assert P(Eq(Y[7], Y[5]), Eq(Y[2], 0)).round(5) == Float(0.44428, 5)\n    assert P(Gt(Y[3], Y[1]), Eq(Y[0], 0)).round(2) == Float(0.36, 2)\n    assert P(Le(Y[5], Y[10]), Eq(Y[4], 2)).round(6) == Float(0.58312, 6)\n    assert Float(P(Eq(Y[10], Y[5]), Eq(Y[4], 1)), 14) == Float(1 - P(Ne(Y[10], Y[5]), Eq(Y[4], 1)), 14)\n    assert Float(P(Gt(Y[8], Y[9]), Eq(Y[3], 2)), 14) == Float(1 - P(Le(Y[8], Y[9]), Eq(Y[3], 2)), 14)\n    assert Float(P(Lt(Y[1], Y[4]), Eq(Y[0], 0)), 14) == Float(1 - P(Ge(Y[1], Y[4]), Eq(Y[0], 0)), 14)\n    assert P(Eq(Y[5], Y[10]), Eq(Y[2], 1)) == P(Eq(Y[10], Y[5]), Eq(Y[2], 1))\n    assert P(Gt(Y[1], Y[2]), Eq(Y[0], 1)) == P(Lt(Y[2], Y[1]), Eq(Y[0], 1))\n    assert P(Ge(Y[7], Y[6]), Eq(Y[4], 1)) == P(Le(Y[6], Y[7]), Eq(Y[4], 1))\n    (a, b, c, d) = symbols('a b c d')\n    T = Matrix([[Rational(1, 10), Rational(4, 10), Rational(5, 10)], [Rational(3, 10), Rational(4, 10), Rational(3, 10)], [Rational(7, 10), Rational(2, 10), Rational(1, 10)]])\n    Y = DiscreteMarkovChain('Y', [0, 1, 2], T)\n    query = P(Eq(Y[a], b), Eq(Y[c], d))\n    assert query.subs({a: 10, b: 2, c: 5, d: 1}).evalf().round(4) == P(Eq(Y[10], 2), Eq(Y[5], 1)).round(4)\n    assert query.subs({a: 15, b: 0, c: 10, d: 1}).evalf().round(4) == P(Eq(Y[15], 0), Eq(Y[10], 1)).round(4)\n    query_gt = P(Gt(Y[a], b), Eq(Y[c], d))\n    query_le = P(Le(Y[a], b), Eq(Y[c], d))\n    assert query_gt.subs({a: 5, b: 2, c: 1, d: 0}).evalf() + query_le.subs({a: 5, b: 2, c: 1, d: 0}).evalf() == 1.0\n    query_ge = P(Ge(Y[a], b), Eq(Y[c], d))\n    query_lt = P(Lt(Y[a], b), Eq(Y[c], d))\n    assert query_ge.subs({a: 4, b: 1, c: 0, d: 2}).evalf() + query_lt.subs({a: 4, b: 1, c: 0, d: 2}).evalf() == 1.0\n    assert (2 * Y[1] + 3 * Y[1]).simplify() == 5 * Y[1]\n    assert (2 * Y[1] - 3 * Y[1]).simplify() == -Y[1]\n    assert (2 * (0.25 * Y[1])).simplify() == 0.5 * Y[1]\n    assert (2 * Y[1] * (0.25 * Y[1])).simplify() == 0.5 * Y[1] ** 2\n    assert (Y[1] ** 2 + Y[1] ** 3).simplify() == (Y[1] + 1) * Y[1] ** 2",
            "def test_DiscreteMarkovChain():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    X = DiscreteMarkovChain('X')\n    assert isinstance(X.state_space, Range)\n    assert X.index_set == S.Naturals0\n    assert isinstance(X.transition_probabilities, MatrixSymbol)\n    t = symbols('t', positive=True, integer=True)\n    assert isinstance(X[t], RandomIndexedSymbol)\n    assert E(X[0]) == Expectation(X[0])\n    raises(TypeError, lambda : DiscreteMarkovChain(1))\n    raises(NotImplementedError, lambda : X(t))\n    raises(NotImplementedError, lambda : X.communication_classes())\n    raises(NotImplementedError, lambda : X.canonical_form())\n    raises(NotImplementedError, lambda : X.decompose())\n    nz = Symbol('n', integer=True)\n    TZ = MatrixSymbol('M', nz, nz)\n    SZ = Range(nz)\n    YZ = DiscreteMarkovChain('Y', SZ, TZ)\n    assert P(Eq(YZ[2], 1), Eq(YZ[1], 0)) == TZ[0, 1]\n    raises(ValueError, lambda : sample_stochastic_process(t))\n    raises(ValueError, lambda : next(sample_stochastic_process(X)))\n    (sym, rainy, cloudy, sunny) = symbols('a Rainy Cloudy Sunny', real=True)\n    state_spaces = [(1, 2, 3), [Str('Hello'), sym, DiscreteMarkovChain('Y', (1, 2, 3))], Tuple(S(1), exp(sym), Str('World'), sympify=False), Range(-1, 5, 2), [rainy, cloudy, sunny]]\n    chains = [DiscreteMarkovChain('Y', state_space) for state_space in state_spaces]\n    for (i, Y) in enumerate(chains):\n        assert isinstance(Y.transition_probabilities, MatrixSymbol)\n        assert Y.state_space == state_spaces[i] or Y.state_space == FiniteSet(*state_spaces[i])\n        assert Y.number_of_states == 3\n        with ignore_warnings(UserWarning):\n            assert P(Eq(Y[2], 1), Eq(Y[0], 2), evaluate=False) == Probability(Eq(Y[2], 1), Eq(Y[0], 2))\n        assert E(Y[0]) == Expectation(Y[0])\n        raises(ValueError, lambda : next(sample_stochastic_process(Y)))\n    raises(TypeError, lambda : DiscreteMarkovChain('Y', {1: 1}))\n    Y = DiscreteMarkovChain('Y', Range(1, t, 2))\n    assert Y.number_of_states == ceiling((t - 1) / 2)\n    chains = [DiscreteMarkovChain('Y', trans_probs=Matrix([[]])), DiscreteMarkovChain('Y', trans_probs=Matrix([[0, 1], [1, 0]])), DiscreteMarkovChain('Y', trans_probs=Matrix([[pi, 1 - pi], [sym, 1 - sym]]))]\n    for Z in chains:\n        assert Z.number_of_states == Z.transition_probabilities.shape[0]\n        assert isinstance(Z.transition_probabilities, ImmutableMatrix)\n    T = Matrix([[0.5, 0.2, 0.3], [0.2, 0.5, 0.3], [0.2, 0.3, 0.5]])\n    TS = MatrixSymbol('T', 3, 3)\n    Y = DiscreteMarkovChain('Y', [0, 1, 2], T)\n    YS = DiscreteMarkovChain('Y', ['One', 'Two', 3], TS)\n    assert Y.joint_distribution(1, Y[2], 3) == JointDistribution(Y[1], Y[2], Y[3])\n    raises(ValueError, lambda : Y.joint_distribution(Y[1].symbol, Y[2].symbol))\n    assert P(Eq(Y[3], 2), Eq(Y[1], 1)).round(2) == Float(0.36, 2)\n    assert (P(Eq(YS[3], 2), Eq(YS[1], 1)) - (TS[0, 2] * TS[1, 0] + TS[1, 1] * TS[1, 2] + TS[1, 2] * TS[2, 2])).simplify() == 0\n    assert P(Eq(YS[1], 1), Eq(YS[2], 2)) == Probability(Eq(YS[1], 1))\n    assert P(Eq(YS[3], 3), Eq(YS[1], 1)) == TS[0, 2] * TS[1, 0] + TS[1, 1] * TS[1, 2] + TS[1, 2] * TS[2, 2]\n    TO = Matrix([[0.25, 0.75, 0], [0, 0.25, 0.75], [0.75, 0, 0.25]])\n    assert P(Eq(Y[3], 2), Eq(Y[1], 1) & TransitionMatrixOf(Y, TO)).round(3) == Float(0.375, 3)\n    with ignore_warnings(UserWarning):\n        assert E(Y[3], evaluate=False) == Expectation(Y[3])\n        assert E(Y[3], Eq(Y[2], 1)).round(2) == Float(1.1, 3)\n    TSO = MatrixSymbol('T', 4, 4)\n    raises(ValueError, lambda : str(P(Eq(YS[3], 2), Eq(YS[1], 1) & TransitionMatrixOf(YS, TSO))))\n    raises(TypeError, lambda : DiscreteMarkovChain('Z', [0, 1, 2], symbols('M')))\n    raises(ValueError, lambda : DiscreteMarkovChain('Z', [0, 1, 2], MatrixSymbol('T', 3, 4)))\n    raises(ValueError, lambda : E(Y[3], Eq(Y[2], 6)))\n    raises(ValueError, lambda : E(Y[2], Eq(Y[3], 1)))\n    TO1 = Matrix([[Rational(1, 4), Rational(3, 4), 0], [Rational(1, 3), Rational(1, 3), Rational(1, 3)], [0, Rational(1, 4), Rational(3, 4)]])\n    assert P(And(Eq(Y[2], 1), Eq(Y[1], 1), Eq(Y[0], 0)), Eq(Probability(Eq(Y[0], 0)), Rational(1, 4)) & TransitionMatrixOf(Y, TO1)) == Rational(1, 16)\n    assert P(And(Eq(Y[2], 1), Eq(Y[1], 1), Eq(Y[0], 0)), TransitionMatrixOf(Y, TO1)) == Probability(Eq(Y[0], 0)) / 4\n    assert P(Lt(X[1], 2) & Gt(X[1], 0), Eq(X[0], 2) & StochasticStateSpaceOf(X, [0, 1, 2]) & TransitionMatrixOf(X, TO1)) == Rational(1, 4)\n    assert P(Lt(X[1], 2) & Gt(X[1], 0), Eq(X[0], 2) & StochasticStateSpaceOf(X, [S(0), '0', 1]) & TransitionMatrixOf(X, TO1)) == Rational(1, 4)\n    assert P(Ne(X[1], 2) & Ne(X[1], 1), Eq(X[0], 2) & StochasticStateSpaceOf(X, [0, 1, 2]) & TransitionMatrixOf(X, TO1)) is S.Zero\n    assert P(Ne(X[1], 2) & Ne(X[1], 1), Eq(X[0], 2) & StochasticStateSpaceOf(X, [S(0), '0', 1]) & TransitionMatrixOf(X, TO1)) is S.Zero\n    assert P(And(Eq(Y[2], 1), Eq(Y[1], 1), Eq(Y[0], 0)), Eq(Y[1], 1)) == 0.1 * Probability(Eq(Y[0], 0))\n    TO2 = Matrix([[S.One, 0, 0], [Rational(1, 3), Rational(1, 3), Rational(1, 3)], [0, Rational(1, 4), Rational(3, 4)]])\n    TO3 = Matrix([[Rational(1, 4), Rational(3, 4), 0], [Rational(1, 3), Rational(1, 3), Rational(1, 3)], [0, Rational(1, 4), Rational(3, 4)]])\n    Y2 = DiscreteMarkovChain('Y', trans_probs=TO2)\n    Y3 = DiscreteMarkovChain('Y', trans_probs=TO3)\n    assert Y3.fundamental_matrix() == ImmutableMatrix([[176, 81, -132], [36, 141, -52], [-44, -39, 208]]) / 125\n    assert Y2.is_absorbing_chain() == True\n    assert Y3.is_absorbing_chain() == False\n    assert Y2.canonical_form() == ([0, 1, 2], TO2)\n    assert Y3.canonical_form() == ([0, 1, 2], TO3)\n    assert Y2.decompose() == ([0, 1, 2], TO2[0:1, 0:1], TO2[1:3, 0:1], TO2[1:3, 1:3])\n    assert Y3.decompose() == ([0, 1, 2], TO3, Matrix(0, 3, []), Matrix(0, 0, []))\n    TO4 = Matrix([[Rational(1, 5), Rational(2, 5), Rational(2, 5)], [Rational(1, 10), S.Half, Rational(2, 5)], [Rational(3, 5), Rational(3, 10), Rational(1, 10)]])\n    Y4 = DiscreteMarkovChain('Y', trans_probs=TO4)\n    w = ImmutableMatrix([[Rational(11, 39), Rational(16, 39), Rational(4, 13)]])\n    assert Y4.limiting_distribution == w\n    assert Y4.is_regular() == True\n    assert Y4.is_ergodic() == True\n    TS1 = MatrixSymbol('T', 3, 3)\n    Y5 = DiscreteMarkovChain('Y', trans_probs=TS1)\n    assert Y5.limiting_distribution(w, TO4).doit() == True\n    assert Y5.stationary_distribution(condition_set=True).subs(TS1, TO4).contains(w).doit() == S.true\n    TO6 = Matrix([[S.One, 0, 0, 0, 0], [S.Half, 0, S.Half, 0, 0], [0, S.Half, 0, S.Half, 0], [0, 0, S.Half, 0, S.Half], [0, 0, 0, 0, 1]])\n    Y6 = DiscreteMarkovChain('Y', trans_probs=TO6)\n    assert Y6.fundamental_matrix() == ImmutableMatrix([[Rational(3, 2), S.One, S.Half], [S.One, S(2), S.One], [S.Half, S.One, Rational(3, 2)]])\n    assert Y6.absorbing_probabilities() == ImmutableMatrix([[Rational(3, 4), Rational(1, 4)], [S.Half, S.Half], [Rational(1, 4), Rational(3, 4)]])\n    with warns_deprecated_sympy():\n        Y6.absorbing_probabilites()\n    TO7 = Matrix([[Rational(1, 2), Rational(1, 4), Rational(1, 4)], [Rational(1, 2), 0, Rational(1, 2)], [Rational(1, 4), Rational(1, 4), Rational(1, 2)]])\n    Y7 = DiscreteMarkovChain('Y', trans_probs=TO7)\n    assert Y7.is_absorbing_chain() == False\n    assert Y7.fundamental_matrix() == ImmutableMatrix([[Rational(86, 75), Rational(1, 25), Rational(-14, 75)], [Rational(2, 25), Rational(21, 25), Rational(2, 25)], [Rational(-14, 75), Rational(1, 25), Rational(86, 75)]])\n    X = DiscreteMarkovChain('X', trans_probs=Matrix([[]]))\n    assert X.number_of_states == 0\n    assert X.stationary_distribution() == Matrix([[]])\n    assert X.communication_classes() == []\n    assert X.canonical_form() == ([], Matrix([[]]))\n    assert X.decompose() == ([], Matrix([[]]), Matrix([[]]), Matrix([[]]))\n    assert X.is_regular() == False\n    assert X.is_ergodic() == False\n    TO7 = Matrix([[0, 5, 5, 0, 0], [0, 0, 0, 10, 0], [5, 0, 5, 0, 0], [0, 10, 0, 0, 0], [0, 3, 0, 3, 4]]) / 10\n    Y7 = DiscreteMarkovChain('Y', trans_probs=TO7)\n    tuples = Y7.communication_classes()\n    (classes, recurrence, periods) = list(zip(*tuples))\n    assert classes == ([1, 3], [0, 2], [4])\n    assert recurrence == (True, False, False)\n    assert periods == (2, 1, 1)\n    TO8 = Matrix([[0, 0, 0, 10, 0, 0], [5, 0, 5, 0, 0, 0], [0, 4, 0, 0, 0, 6], [10, 0, 0, 0, 0, 0], [0, 10, 0, 0, 0, 0], [0, 0, 0, 5, 5, 0]]) / 10\n    Y8 = DiscreteMarkovChain('Y', trans_probs=TO8)\n    tuples = Y8.communication_classes()\n    (classes, recurrence, periods) = list(zip(*tuples))\n    assert classes == ([0, 3], [1, 2, 5, 4])\n    assert recurrence == (True, False)\n    assert periods == (2, 2)\n    TO9 = Matrix([[2, 0, 0, 3, 0, 0, 3, 2, 0, 0], [0, 10, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 0, 0, 0, 0, 0, 3, 3], [0, 0, 0, 3, 0, 0, 6, 1, 0, 0], [0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 10, 0, 0, 0, 0], [4, 0, 0, 5, 0, 0, 1, 0, 0, 0], [2, 0, 0, 4, 0, 0, 2, 2, 0, 0], [3, 0, 1, 0, 0, 0, 0, 0, 4, 2], [0, 0, 4, 0, 0, 0, 0, 0, 3, 3]]) / 10\n    Y9 = DiscreteMarkovChain('Y', trans_probs=TO9)\n    tuples = Y9.communication_classes()\n    (classes, recurrence, periods) = list(zip(*tuples))\n    assert classes == ([0, 3, 6, 7], [1], [2, 8, 9], [5], [4])\n    assert recurrence == (True, True, False, True, False)\n    assert periods == (1, 1, 1, 1, 1)\n    T = Matrix([[1, 0, 0, 0, 0], [S(1) / 2, 0, S(1) / 2, 0, 0], [0, S(1) / 2, 0, S(1) / 2, 0], [0, 0, S(1) / 2, 0, S(1) / 2], [0, 0, 0, 0, S(1)]])\n    DW = DiscreteMarkovChain('DW', [0, 1, 2, 3, 4], T)\n    (states, A, B, C) = DW.decompose()\n    assert states == [0, 4, 1, 2, 3]\n    assert A == Matrix([[1, 0], [0, 1]])\n    assert B == Matrix([[S(1) / 2, 0], [0, 0], [0, S(1) / 2]])\n    assert C == Matrix([[0, S(1) / 2, 0], [S(1) / 2, 0, S(1) / 2], [0, S(1) / 2, 0]])\n    (states, new_matrix) = DW.canonical_form()\n    assert states == [0, 4, 1, 2, 3]\n    assert new_matrix == Matrix([[1, 0, 0, 0, 0], [0, 1, 0, 0, 0], [S(1) / 2, 0, 0, S(1) / 2, 0], [0, 0, S(1) / 2, 0, S(1) / 2], [0, S(1) / 2, 0, S(1) / 2, 0]])\n    T = Matrix([[0, 4, 0, 0, 0], [1, 0, 3, 0, 0], [0, 2, 0, 2, 0], [0, 0, 3, 0, 1], [0, 0, 0, 4, 0]]) / 4\n    X = DiscreteMarkovChain('X', trans_probs=T)\n    assert not X.is_regular()\n    assert X.is_ergodic()\n    T = Matrix([[0, 1], [1, 0]])\n    X = DiscreteMarkovChain('X', trans_probs=T)\n    assert not X.is_regular()\n    assert X.is_ergodic()\n    T = Matrix([[2, 1, 1], [2, 0, 2], [1, 1, 2]]) / 4\n    X = DiscreteMarkovChain('X', trans_probs=T)\n    assert X.is_regular()\n    assert X.is_ergodic()\n    T = Matrix([[1, 1], [1, 1]]) / 2\n    X = DiscreteMarkovChain('X', trans_probs=T)\n    assert X.is_regular()\n    assert X.is_ergodic()\n    T = Matrix([[0, 1, 0], [1, 0, 0], [0, 0, 1]])\n    X = DiscreteMarkovChain('X', trans_probs=T)\n    assert not X.is_absorbing_chain()\n    T = Matrix([[1, 1, 0, 0], [0, 1, 1, 0], [1, 0, 0, 1], [0, 0, 0, 2]]) / 2\n    X = DiscreteMarkovChain('X', trans_probs=T)\n    assert X.is_absorbing_chain()\n    T = Matrix([[2, 0, 0, 0, 0], [1, 0, 1, 0, 0], [0, 1, 0, 1, 0], [0, 0, 1, 0, 1], [0, 0, 0, 0, 2]]) / 2\n    X = DiscreteMarkovChain('X', trans_probs=T)\n    assert X.is_absorbing_chain()\n    Y10 = DiscreteMarkovChain('Y', [1, 2, 3], TO2)\n    tuples = Y10.communication_classes()\n    (classes, recurrence, periods) = list(zip(*tuples))\n    assert classes == ([1], [2, 3])\n    assert recurrence == (True, False)\n    assert periods == (1, 1)\n    assert Y10.canonical_form() == ([1, 2, 3], TO2)\n    assert Y10.decompose() == ([1, 2, 3], TO2[0:1, 0:1], TO2[1:3, 0:1], TO2[1:3, 1:3])\n    T = Matrix([[S.Half, Rational(1, 4), Rational(1, 4)], [Rational(1, 3), 0, Rational(2, 3)], [S.Half, S.Half, 0]])\n    X = DiscreteMarkovChain('X', [0, 1, 2], T)\n    assert P(Eq(X[1], 2) & Eq(X[2], 1) & Eq(X[3], 0), Eq(P(Eq(X[1], 0)), Rational(1, 4)) & Eq(P(Eq(X[1], 1)), Rational(1, 4))) == Rational(1, 12)\n    assert P(Eq(X[2], 1) | Eq(X[2], 2), Eq(X[1], 1)) == Rational(2, 3)\n    assert P(Eq(X[2], 1) & Eq(X[2], 2), Eq(X[1], 1)) is S.Zero\n    assert P(Ne(X[2], 2), Eq(X[1], 1)) == Rational(1, 3)\n    assert E(X[1] ** 2, Eq(X[0], 1)) == Rational(8, 3)\n    assert variance(X[1], Eq(X[0], 1)) == Rational(8, 9)\n    raises(ValueError, lambda : E(X[1], Eq(X[2], 1)))\n    raises(ValueError, lambda : DiscreteMarkovChain('X', [0, 1], T))\n    X = DiscreteMarkovChain('X', ['A', 'B', 'C'], T)\n    assert P(Eq(X[1], 2) & Eq(X[2], 1) & Eq(X[3], 0), Eq(P(Eq(X[1], 0)), Rational(1, 4)) & Eq(P(Eq(X[1], 1)), Rational(1, 4))) == Rational(1, 12)\n    assert P(Eq(X[2], 1) | Eq(X[2], 2), Eq(X[1], 1)) == Rational(2, 3)\n    assert P(Eq(X[2], 1) & Eq(X[2], 2), Eq(X[1], 1)) is S.Zero\n    assert P(Ne(X[2], 2), Eq(X[1], 1)) == Rational(1, 3)\n    a = X.state_space.args[0]\n    c = X.state_space.args[2]\n    assert (E(X[1] ** 2, Eq(X[0], 1)) - (a ** 2 / 3 + 2 * c ** 2 / 3)).simplify() == 0\n    assert (variance(X[1], Eq(X[0], 1)) - (2 * (-a / 3 + c / 3) ** 2 / 3 + (2 * a / 3 - 2 * c / 3) ** 2 / 3)).simplify() == 0\n    raises(ValueError, lambda : E(X[1], Eq(X[2], 1)))\n    T = Matrix([[Rational(5, 10), Rational(3, 10), Rational(2, 10)], [Rational(2, 10), Rational(7, 10), Rational(1, 10)], [Rational(3, 10), Rational(3, 10), Rational(4, 10)]])\n    Y = DiscreteMarkovChain('Y', [0, 1, 2], T)\n    assert P(Eq(Y[7], Y[5]), Eq(Y[2], 0)).round(5) == Float(0.44428, 5)\n    assert P(Gt(Y[3], Y[1]), Eq(Y[0], 0)).round(2) == Float(0.36, 2)\n    assert P(Le(Y[5], Y[10]), Eq(Y[4], 2)).round(6) == Float(0.58312, 6)\n    assert Float(P(Eq(Y[10], Y[5]), Eq(Y[4], 1)), 14) == Float(1 - P(Ne(Y[10], Y[5]), Eq(Y[4], 1)), 14)\n    assert Float(P(Gt(Y[8], Y[9]), Eq(Y[3], 2)), 14) == Float(1 - P(Le(Y[8], Y[9]), Eq(Y[3], 2)), 14)\n    assert Float(P(Lt(Y[1], Y[4]), Eq(Y[0], 0)), 14) == Float(1 - P(Ge(Y[1], Y[4]), Eq(Y[0], 0)), 14)\n    assert P(Eq(Y[5], Y[10]), Eq(Y[2], 1)) == P(Eq(Y[10], Y[5]), Eq(Y[2], 1))\n    assert P(Gt(Y[1], Y[2]), Eq(Y[0], 1)) == P(Lt(Y[2], Y[1]), Eq(Y[0], 1))\n    assert P(Ge(Y[7], Y[6]), Eq(Y[4], 1)) == P(Le(Y[6], Y[7]), Eq(Y[4], 1))\n    (a, b, c, d) = symbols('a b c d')\n    T = Matrix([[Rational(1, 10), Rational(4, 10), Rational(5, 10)], [Rational(3, 10), Rational(4, 10), Rational(3, 10)], [Rational(7, 10), Rational(2, 10), Rational(1, 10)]])\n    Y = DiscreteMarkovChain('Y', [0, 1, 2], T)\n    query = P(Eq(Y[a], b), Eq(Y[c], d))\n    assert query.subs({a: 10, b: 2, c: 5, d: 1}).evalf().round(4) == P(Eq(Y[10], 2), Eq(Y[5], 1)).round(4)\n    assert query.subs({a: 15, b: 0, c: 10, d: 1}).evalf().round(4) == P(Eq(Y[15], 0), Eq(Y[10], 1)).round(4)\n    query_gt = P(Gt(Y[a], b), Eq(Y[c], d))\n    query_le = P(Le(Y[a], b), Eq(Y[c], d))\n    assert query_gt.subs({a: 5, b: 2, c: 1, d: 0}).evalf() + query_le.subs({a: 5, b: 2, c: 1, d: 0}).evalf() == 1.0\n    query_ge = P(Ge(Y[a], b), Eq(Y[c], d))\n    query_lt = P(Lt(Y[a], b), Eq(Y[c], d))\n    assert query_ge.subs({a: 4, b: 1, c: 0, d: 2}).evalf() + query_lt.subs({a: 4, b: 1, c: 0, d: 2}).evalf() == 1.0\n    assert (2 * Y[1] + 3 * Y[1]).simplify() == 5 * Y[1]\n    assert (2 * Y[1] - 3 * Y[1]).simplify() == -Y[1]\n    assert (2 * (0.25 * Y[1])).simplify() == 0.5 * Y[1]\n    assert (2 * Y[1] * (0.25 * Y[1])).simplify() == 0.5 * Y[1] ** 2\n    assert (Y[1] ** 2 + Y[1] ** 3).simplify() == (Y[1] + 1) * Y[1] ** 2",
            "def test_DiscreteMarkovChain():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    X = DiscreteMarkovChain('X')\n    assert isinstance(X.state_space, Range)\n    assert X.index_set == S.Naturals0\n    assert isinstance(X.transition_probabilities, MatrixSymbol)\n    t = symbols('t', positive=True, integer=True)\n    assert isinstance(X[t], RandomIndexedSymbol)\n    assert E(X[0]) == Expectation(X[0])\n    raises(TypeError, lambda : DiscreteMarkovChain(1))\n    raises(NotImplementedError, lambda : X(t))\n    raises(NotImplementedError, lambda : X.communication_classes())\n    raises(NotImplementedError, lambda : X.canonical_form())\n    raises(NotImplementedError, lambda : X.decompose())\n    nz = Symbol('n', integer=True)\n    TZ = MatrixSymbol('M', nz, nz)\n    SZ = Range(nz)\n    YZ = DiscreteMarkovChain('Y', SZ, TZ)\n    assert P(Eq(YZ[2], 1), Eq(YZ[1], 0)) == TZ[0, 1]\n    raises(ValueError, lambda : sample_stochastic_process(t))\n    raises(ValueError, lambda : next(sample_stochastic_process(X)))\n    (sym, rainy, cloudy, sunny) = symbols('a Rainy Cloudy Sunny', real=True)\n    state_spaces = [(1, 2, 3), [Str('Hello'), sym, DiscreteMarkovChain('Y', (1, 2, 3))], Tuple(S(1), exp(sym), Str('World'), sympify=False), Range(-1, 5, 2), [rainy, cloudy, sunny]]\n    chains = [DiscreteMarkovChain('Y', state_space) for state_space in state_spaces]\n    for (i, Y) in enumerate(chains):\n        assert isinstance(Y.transition_probabilities, MatrixSymbol)\n        assert Y.state_space == state_spaces[i] or Y.state_space == FiniteSet(*state_spaces[i])\n        assert Y.number_of_states == 3\n        with ignore_warnings(UserWarning):\n            assert P(Eq(Y[2], 1), Eq(Y[0], 2), evaluate=False) == Probability(Eq(Y[2], 1), Eq(Y[0], 2))\n        assert E(Y[0]) == Expectation(Y[0])\n        raises(ValueError, lambda : next(sample_stochastic_process(Y)))\n    raises(TypeError, lambda : DiscreteMarkovChain('Y', {1: 1}))\n    Y = DiscreteMarkovChain('Y', Range(1, t, 2))\n    assert Y.number_of_states == ceiling((t - 1) / 2)\n    chains = [DiscreteMarkovChain('Y', trans_probs=Matrix([[]])), DiscreteMarkovChain('Y', trans_probs=Matrix([[0, 1], [1, 0]])), DiscreteMarkovChain('Y', trans_probs=Matrix([[pi, 1 - pi], [sym, 1 - sym]]))]\n    for Z in chains:\n        assert Z.number_of_states == Z.transition_probabilities.shape[0]\n        assert isinstance(Z.transition_probabilities, ImmutableMatrix)\n    T = Matrix([[0.5, 0.2, 0.3], [0.2, 0.5, 0.3], [0.2, 0.3, 0.5]])\n    TS = MatrixSymbol('T', 3, 3)\n    Y = DiscreteMarkovChain('Y', [0, 1, 2], T)\n    YS = DiscreteMarkovChain('Y', ['One', 'Two', 3], TS)\n    assert Y.joint_distribution(1, Y[2], 3) == JointDistribution(Y[1], Y[2], Y[3])\n    raises(ValueError, lambda : Y.joint_distribution(Y[1].symbol, Y[2].symbol))\n    assert P(Eq(Y[3], 2), Eq(Y[1], 1)).round(2) == Float(0.36, 2)\n    assert (P(Eq(YS[3], 2), Eq(YS[1], 1)) - (TS[0, 2] * TS[1, 0] + TS[1, 1] * TS[1, 2] + TS[1, 2] * TS[2, 2])).simplify() == 0\n    assert P(Eq(YS[1], 1), Eq(YS[2], 2)) == Probability(Eq(YS[1], 1))\n    assert P(Eq(YS[3], 3), Eq(YS[1], 1)) == TS[0, 2] * TS[1, 0] + TS[1, 1] * TS[1, 2] + TS[1, 2] * TS[2, 2]\n    TO = Matrix([[0.25, 0.75, 0], [0, 0.25, 0.75], [0.75, 0, 0.25]])\n    assert P(Eq(Y[3], 2), Eq(Y[1], 1) & TransitionMatrixOf(Y, TO)).round(3) == Float(0.375, 3)\n    with ignore_warnings(UserWarning):\n        assert E(Y[3], evaluate=False) == Expectation(Y[3])\n        assert E(Y[3], Eq(Y[2], 1)).round(2) == Float(1.1, 3)\n    TSO = MatrixSymbol('T', 4, 4)\n    raises(ValueError, lambda : str(P(Eq(YS[3], 2), Eq(YS[1], 1) & TransitionMatrixOf(YS, TSO))))\n    raises(TypeError, lambda : DiscreteMarkovChain('Z', [0, 1, 2], symbols('M')))\n    raises(ValueError, lambda : DiscreteMarkovChain('Z', [0, 1, 2], MatrixSymbol('T', 3, 4)))\n    raises(ValueError, lambda : E(Y[3], Eq(Y[2], 6)))\n    raises(ValueError, lambda : E(Y[2], Eq(Y[3], 1)))\n    TO1 = Matrix([[Rational(1, 4), Rational(3, 4), 0], [Rational(1, 3), Rational(1, 3), Rational(1, 3)], [0, Rational(1, 4), Rational(3, 4)]])\n    assert P(And(Eq(Y[2], 1), Eq(Y[1], 1), Eq(Y[0], 0)), Eq(Probability(Eq(Y[0], 0)), Rational(1, 4)) & TransitionMatrixOf(Y, TO1)) == Rational(1, 16)\n    assert P(And(Eq(Y[2], 1), Eq(Y[1], 1), Eq(Y[0], 0)), TransitionMatrixOf(Y, TO1)) == Probability(Eq(Y[0], 0)) / 4\n    assert P(Lt(X[1], 2) & Gt(X[1], 0), Eq(X[0], 2) & StochasticStateSpaceOf(X, [0, 1, 2]) & TransitionMatrixOf(X, TO1)) == Rational(1, 4)\n    assert P(Lt(X[1], 2) & Gt(X[1], 0), Eq(X[0], 2) & StochasticStateSpaceOf(X, [S(0), '0', 1]) & TransitionMatrixOf(X, TO1)) == Rational(1, 4)\n    assert P(Ne(X[1], 2) & Ne(X[1], 1), Eq(X[0], 2) & StochasticStateSpaceOf(X, [0, 1, 2]) & TransitionMatrixOf(X, TO1)) is S.Zero\n    assert P(Ne(X[1], 2) & Ne(X[1], 1), Eq(X[0], 2) & StochasticStateSpaceOf(X, [S(0), '0', 1]) & TransitionMatrixOf(X, TO1)) is S.Zero\n    assert P(And(Eq(Y[2], 1), Eq(Y[1], 1), Eq(Y[0], 0)), Eq(Y[1], 1)) == 0.1 * Probability(Eq(Y[0], 0))\n    TO2 = Matrix([[S.One, 0, 0], [Rational(1, 3), Rational(1, 3), Rational(1, 3)], [0, Rational(1, 4), Rational(3, 4)]])\n    TO3 = Matrix([[Rational(1, 4), Rational(3, 4), 0], [Rational(1, 3), Rational(1, 3), Rational(1, 3)], [0, Rational(1, 4), Rational(3, 4)]])\n    Y2 = DiscreteMarkovChain('Y', trans_probs=TO2)\n    Y3 = DiscreteMarkovChain('Y', trans_probs=TO3)\n    assert Y3.fundamental_matrix() == ImmutableMatrix([[176, 81, -132], [36, 141, -52], [-44, -39, 208]]) / 125\n    assert Y2.is_absorbing_chain() == True\n    assert Y3.is_absorbing_chain() == False\n    assert Y2.canonical_form() == ([0, 1, 2], TO2)\n    assert Y3.canonical_form() == ([0, 1, 2], TO3)\n    assert Y2.decompose() == ([0, 1, 2], TO2[0:1, 0:1], TO2[1:3, 0:1], TO2[1:3, 1:3])\n    assert Y3.decompose() == ([0, 1, 2], TO3, Matrix(0, 3, []), Matrix(0, 0, []))\n    TO4 = Matrix([[Rational(1, 5), Rational(2, 5), Rational(2, 5)], [Rational(1, 10), S.Half, Rational(2, 5)], [Rational(3, 5), Rational(3, 10), Rational(1, 10)]])\n    Y4 = DiscreteMarkovChain('Y', trans_probs=TO4)\n    w = ImmutableMatrix([[Rational(11, 39), Rational(16, 39), Rational(4, 13)]])\n    assert Y4.limiting_distribution == w\n    assert Y4.is_regular() == True\n    assert Y4.is_ergodic() == True\n    TS1 = MatrixSymbol('T', 3, 3)\n    Y5 = DiscreteMarkovChain('Y', trans_probs=TS1)\n    assert Y5.limiting_distribution(w, TO4).doit() == True\n    assert Y5.stationary_distribution(condition_set=True).subs(TS1, TO4).contains(w).doit() == S.true\n    TO6 = Matrix([[S.One, 0, 0, 0, 0], [S.Half, 0, S.Half, 0, 0], [0, S.Half, 0, S.Half, 0], [0, 0, S.Half, 0, S.Half], [0, 0, 0, 0, 1]])\n    Y6 = DiscreteMarkovChain('Y', trans_probs=TO6)\n    assert Y6.fundamental_matrix() == ImmutableMatrix([[Rational(3, 2), S.One, S.Half], [S.One, S(2), S.One], [S.Half, S.One, Rational(3, 2)]])\n    assert Y6.absorbing_probabilities() == ImmutableMatrix([[Rational(3, 4), Rational(1, 4)], [S.Half, S.Half], [Rational(1, 4), Rational(3, 4)]])\n    with warns_deprecated_sympy():\n        Y6.absorbing_probabilites()\n    TO7 = Matrix([[Rational(1, 2), Rational(1, 4), Rational(1, 4)], [Rational(1, 2), 0, Rational(1, 2)], [Rational(1, 4), Rational(1, 4), Rational(1, 2)]])\n    Y7 = DiscreteMarkovChain('Y', trans_probs=TO7)\n    assert Y7.is_absorbing_chain() == False\n    assert Y7.fundamental_matrix() == ImmutableMatrix([[Rational(86, 75), Rational(1, 25), Rational(-14, 75)], [Rational(2, 25), Rational(21, 25), Rational(2, 25)], [Rational(-14, 75), Rational(1, 25), Rational(86, 75)]])\n    X = DiscreteMarkovChain('X', trans_probs=Matrix([[]]))\n    assert X.number_of_states == 0\n    assert X.stationary_distribution() == Matrix([[]])\n    assert X.communication_classes() == []\n    assert X.canonical_form() == ([], Matrix([[]]))\n    assert X.decompose() == ([], Matrix([[]]), Matrix([[]]), Matrix([[]]))\n    assert X.is_regular() == False\n    assert X.is_ergodic() == False\n    TO7 = Matrix([[0, 5, 5, 0, 0], [0, 0, 0, 10, 0], [5, 0, 5, 0, 0], [0, 10, 0, 0, 0], [0, 3, 0, 3, 4]]) / 10\n    Y7 = DiscreteMarkovChain('Y', trans_probs=TO7)\n    tuples = Y7.communication_classes()\n    (classes, recurrence, periods) = list(zip(*tuples))\n    assert classes == ([1, 3], [0, 2], [4])\n    assert recurrence == (True, False, False)\n    assert periods == (2, 1, 1)\n    TO8 = Matrix([[0, 0, 0, 10, 0, 0], [5, 0, 5, 0, 0, 0], [0, 4, 0, 0, 0, 6], [10, 0, 0, 0, 0, 0], [0, 10, 0, 0, 0, 0], [0, 0, 0, 5, 5, 0]]) / 10\n    Y8 = DiscreteMarkovChain('Y', trans_probs=TO8)\n    tuples = Y8.communication_classes()\n    (classes, recurrence, periods) = list(zip(*tuples))\n    assert classes == ([0, 3], [1, 2, 5, 4])\n    assert recurrence == (True, False)\n    assert periods == (2, 2)\n    TO9 = Matrix([[2, 0, 0, 3, 0, 0, 3, 2, 0, 0], [0, 10, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 0, 0, 0, 0, 0, 3, 3], [0, 0, 0, 3, 0, 0, 6, 1, 0, 0], [0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 10, 0, 0, 0, 0], [4, 0, 0, 5, 0, 0, 1, 0, 0, 0], [2, 0, 0, 4, 0, 0, 2, 2, 0, 0], [3, 0, 1, 0, 0, 0, 0, 0, 4, 2], [0, 0, 4, 0, 0, 0, 0, 0, 3, 3]]) / 10\n    Y9 = DiscreteMarkovChain('Y', trans_probs=TO9)\n    tuples = Y9.communication_classes()\n    (classes, recurrence, periods) = list(zip(*tuples))\n    assert classes == ([0, 3, 6, 7], [1], [2, 8, 9], [5], [4])\n    assert recurrence == (True, True, False, True, False)\n    assert periods == (1, 1, 1, 1, 1)\n    T = Matrix([[1, 0, 0, 0, 0], [S(1) / 2, 0, S(1) / 2, 0, 0], [0, S(1) / 2, 0, S(1) / 2, 0], [0, 0, S(1) / 2, 0, S(1) / 2], [0, 0, 0, 0, S(1)]])\n    DW = DiscreteMarkovChain('DW', [0, 1, 2, 3, 4], T)\n    (states, A, B, C) = DW.decompose()\n    assert states == [0, 4, 1, 2, 3]\n    assert A == Matrix([[1, 0], [0, 1]])\n    assert B == Matrix([[S(1) / 2, 0], [0, 0], [0, S(1) / 2]])\n    assert C == Matrix([[0, S(1) / 2, 0], [S(1) / 2, 0, S(1) / 2], [0, S(1) / 2, 0]])\n    (states, new_matrix) = DW.canonical_form()\n    assert states == [0, 4, 1, 2, 3]\n    assert new_matrix == Matrix([[1, 0, 0, 0, 0], [0, 1, 0, 0, 0], [S(1) / 2, 0, 0, S(1) / 2, 0], [0, 0, S(1) / 2, 0, S(1) / 2], [0, S(1) / 2, 0, S(1) / 2, 0]])\n    T = Matrix([[0, 4, 0, 0, 0], [1, 0, 3, 0, 0], [0, 2, 0, 2, 0], [0, 0, 3, 0, 1], [0, 0, 0, 4, 0]]) / 4\n    X = DiscreteMarkovChain('X', trans_probs=T)\n    assert not X.is_regular()\n    assert X.is_ergodic()\n    T = Matrix([[0, 1], [1, 0]])\n    X = DiscreteMarkovChain('X', trans_probs=T)\n    assert not X.is_regular()\n    assert X.is_ergodic()\n    T = Matrix([[2, 1, 1], [2, 0, 2], [1, 1, 2]]) / 4\n    X = DiscreteMarkovChain('X', trans_probs=T)\n    assert X.is_regular()\n    assert X.is_ergodic()\n    T = Matrix([[1, 1], [1, 1]]) / 2\n    X = DiscreteMarkovChain('X', trans_probs=T)\n    assert X.is_regular()\n    assert X.is_ergodic()\n    T = Matrix([[0, 1, 0], [1, 0, 0], [0, 0, 1]])\n    X = DiscreteMarkovChain('X', trans_probs=T)\n    assert not X.is_absorbing_chain()\n    T = Matrix([[1, 1, 0, 0], [0, 1, 1, 0], [1, 0, 0, 1], [0, 0, 0, 2]]) / 2\n    X = DiscreteMarkovChain('X', trans_probs=T)\n    assert X.is_absorbing_chain()\n    T = Matrix([[2, 0, 0, 0, 0], [1, 0, 1, 0, 0], [0, 1, 0, 1, 0], [0, 0, 1, 0, 1], [0, 0, 0, 0, 2]]) / 2\n    X = DiscreteMarkovChain('X', trans_probs=T)\n    assert X.is_absorbing_chain()\n    Y10 = DiscreteMarkovChain('Y', [1, 2, 3], TO2)\n    tuples = Y10.communication_classes()\n    (classes, recurrence, periods) = list(zip(*tuples))\n    assert classes == ([1], [2, 3])\n    assert recurrence == (True, False)\n    assert periods == (1, 1)\n    assert Y10.canonical_form() == ([1, 2, 3], TO2)\n    assert Y10.decompose() == ([1, 2, 3], TO2[0:1, 0:1], TO2[1:3, 0:1], TO2[1:3, 1:3])\n    T = Matrix([[S.Half, Rational(1, 4), Rational(1, 4)], [Rational(1, 3), 0, Rational(2, 3)], [S.Half, S.Half, 0]])\n    X = DiscreteMarkovChain('X', [0, 1, 2], T)\n    assert P(Eq(X[1], 2) & Eq(X[2], 1) & Eq(X[3], 0), Eq(P(Eq(X[1], 0)), Rational(1, 4)) & Eq(P(Eq(X[1], 1)), Rational(1, 4))) == Rational(1, 12)\n    assert P(Eq(X[2], 1) | Eq(X[2], 2), Eq(X[1], 1)) == Rational(2, 3)\n    assert P(Eq(X[2], 1) & Eq(X[2], 2), Eq(X[1], 1)) is S.Zero\n    assert P(Ne(X[2], 2), Eq(X[1], 1)) == Rational(1, 3)\n    assert E(X[1] ** 2, Eq(X[0], 1)) == Rational(8, 3)\n    assert variance(X[1], Eq(X[0], 1)) == Rational(8, 9)\n    raises(ValueError, lambda : E(X[1], Eq(X[2], 1)))\n    raises(ValueError, lambda : DiscreteMarkovChain('X', [0, 1], T))\n    X = DiscreteMarkovChain('X', ['A', 'B', 'C'], T)\n    assert P(Eq(X[1], 2) & Eq(X[2], 1) & Eq(X[3], 0), Eq(P(Eq(X[1], 0)), Rational(1, 4)) & Eq(P(Eq(X[1], 1)), Rational(1, 4))) == Rational(1, 12)\n    assert P(Eq(X[2], 1) | Eq(X[2], 2), Eq(X[1], 1)) == Rational(2, 3)\n    assert P(Eq(X[2], 1) & Eq(X[2], 2), Eq(X[1], 1)) is S.Zero\n    assert P(Ne(X[2], 2), Eq(X[1], 1)) == Rational(1, 3)\n    a = X.state_space.args[0]\n    c = X.state_space.args[2]\n    assert (E(X[1] ** 2, Eq(X[0], 1)) - (a ** 2 / 3 + 2 * c ** 2 / 3)).simplify() == 0\n    assert (variance(X[1], Eq(X[0], 1)) - (2 * (-a / 3 + c / 3) ** 2 / 3 + (2 * a / 3 - 2 * c / 3) ** 2 / 3)).simplify() == 0\n    raises(ValueError, lambda : E(X[1], Eq(X[2], 1)))\n    T = Matrix([[Rational(5, 10), Rational(3, 10), Rational(2, 10)], [Rational(2, 10), Rational(7, 10), Rational(1, 10)], [Rational(3, 10), Rational(3, 10), Rational(4, 10)]])\n    Y = DiscreteMarkovChain('Y', [0, 1, 2], T)\n    assert P(Eq(Y[7], Y[5]), Eq(Y[2], 0)).round(5) == Float(0.44428, 5)\n    assert P(Gt(Y[3], Y[1]), Eq(Y[0], 0)).round(2) == Float(0.36, 2)\n    assert P(Le(Y[5], Y[10]), Eq(Y[4], 2)).round(6) == Float(0.58312, 6)\n    assert Float(P(Eq(Y[10], Y[5]), Eq(Y[4], 1)), 14) == Float(1 - P(Ne(Y[10], Y[5]), Eq(Y[4], 1)), 14)\n    assert Float(P(Gt(Y[8], Y[9]), Eq(Y[3], 2)), 14) == Float(1 - P(Le(Y[8], Y[9]), Eq(Y[3], 2)), 14)\n    assert Float(P(Lt(Y[1], Y[4]), Eq(Y[0], 0)), 14) == Float(1 - P(Ge(Y[1], Y[4]), Eq(Y[0], 0)), 14)\n    assert P(Eq(Y[5], Y[10]), Eq(Y[2], 1)) == P(Eq(Y[10], Y[5]), Eq(Y[2], 1))\n    assert P(Gt(Y[1], Y[2]), Eq(Y[0], 1)) == P(Lt(Y[2], Y[1]), Eq(Y[0], 1))\n    assert P(Ge(Y[7], Y[6]), Eq(Y[4], 1)) == P(Le(Y[6], Y[7]), Eq(Y[4], 1))\n    (a, b, c, d) = symbols('a b c d')\n    T = Matrix([[Rational(1, 10), Rational(4, 10), Rational(5, 10)], [Rational(3, 10), Rational(4, 10), Rational(3, 10)], [Rational(7, 10), Rational(2, 10), Rational(1, 10)]])\n    Y = DiscreteMarkovChain('Y', [0, 1, 2], T)\n    query = P(Eq(Y[a], b), Eq(Y[c], d))\n    assert query.subs({a: 10, b: 2, c: 5, d: 1}).evalf().round(4) == P(Eq(Y[10], 2), Eq(Y[5], 1)).round(4)\n    assert query.subs({a: 15, b: 0, c: 10, d: 1}).evalf().round(4) == P(Eq(Y[15], 0), Eq(Y[10], 1)).round(4)\n    query_gt = P(Gt(Y[a], b), Eq(Y[c], d))\n    query_le = P(Le(Y[a], b), Eq(Y[c], d))\n    assert query_gt.subs({a: 5, b: 2, c: 1, d: 0}).evalf() + query_le.subs({a: 5, b: 2, c: 1, d: 0}).evalf() == 1.0\n    query_ge = P(Ge(Y[a], b), Eq(Y[c], d))\n    query_lt = P(Lt(Y[a], b), Eq(Y[c], d))\n    assert query_ge.subs({a: 4, b: 1, c: 0, d: 2}).evalf() + query_lt.subs({a: 4, b: 1, c: 0, d: 2}).evalf() == 1.0\n    assert (2 * Y[1] + 3 * Y[1]).simplify() == 5 * Y[1]\n    assert (2 * Y[1] - 3 * Y[1]).simplify() == -Y[1]\n    assert (2 * (0.25 * Y[1])).simplify() == 0.5 * Y[1]\n    assert (2 * Y[1] * (0.25 * Y[1])).simplify() == 0.5 * Y[1] ** 2\n    assert (Y[1] ** 2 + Y[1] ** 3).simplify() == (Y[1] + 1) * Y[1] ** 2",
            "def test_DiscreteMarkovChain():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    X = DiscreteMarkovChain('X')\n    assert isinstance(X.state_space, Range)\n    assert X.index_set == S.Naturals0\n    assert isinstance(X.transition_probabilities, MatrixSymbol)\n    t = symbols('t', positive=True, integer=True)\n    assert isinstance(X[t], RandomIndexedSymbol)\n    assert E(X[0]) == Expectation(X[0])\n    raises(TypeError, lambda : DiscreteMarkovChain(1))\n    raises(NotImplementedError, lambda : X(t))\n    raises(NotImplementedError, lambda : X.communication_classes())\n    raises(NotImplementedError, lambda : X.canonical_form())\n    raises(NotImplementedError, lambda : X.decompose())\n    nz = Symbol('n', integer=True)\n    TZ = MatrixSymbol('M', nz, nz)\n    SZ = Range(nz)\n    YZ = DiscreteMarkovChain('Y', SZ, TZ)\n    assert P(Eq(YZ[2], 1), Eq(YZ[1], 0)) == TZ[0, 1]\n    raises(ValueError, lambda : sample_stochastic_process(t))\n    raises(ValueError, lambda : next(sample_stochastic_process(X)))\n    (sym, rainy, cloudy, sunny) = symbols('a Rainy Cloudy Sunny', real=True)\n    state_spaces = [(1, 2, 3), [Str('Hello'), sym, DiscreteMarkovChain('Y', (1, 2, 3))], Tuple(S(1), exp(sym), Str('World'), sympify=False), Range(-1, 5, 2), [rainy, cloudy, sunny]]\n    chains = [DiscreteMarkovChain('Y', state_space) for state_space in state_spaces]\n    for (i, Y) in enumerate(chains):\n        assert isinstance(Y.transition_probabilities, MatrixSymbol)\n        assert Y.state_space == state_spaces[i] or Y.state_space == FiniteSet(*state_spaces[i])\n        assert Y.number_of_states == 3\n        with ignore_warnings(UserWarning):\n            assert P(Eq(Y[2], 1), Eq(Y[0], 2), evaluate=False) == Probability(Eq(Y[2], 1), Eq(Y[0], 2))\n        assert E(Y[0]) == Expectation(Y[0])\n        raises(ValueError, lambda : next(sample_stochastic_process(Y)))\n    raises(TypeError, lambda : DiscreteMarkovChain('Y', {1: 1}))\n    Y = DiscreteMarkovChain('Y', Range(1, t, 2))\n    assert Y.number_of_states == ceiling((t - 1) / 2)\n    chains = [DiscreteMarkovChain('Y', trans_probs=Matrix([[]])), DiscreteMarkovChain('Y', trans_probs=Matrix([[0, 1], [1, 0]])), DiscreteMarkovChain('Y', trans_probs=Matrix([[pi, 1 - pi], [sym, 1 - sym]]))]\n    for Z in chains:\n        assert Z.number_of_states == Z.transition_probabilities.shape[0]\n        assert isinstance(Z.transition_probabilities, ImmutableMatrix)\n    T = Matrix([[0.5, 0.2, 0.3], [0.2, 0.5, 0.3], [0.2, 0.3, 0.5]])\n    TS = MatrixSymbol('T', 3, 3)\n    Y = DiscreteMarkovChain('Y', [0, 1, 2], T)\n    YS = DiscreteMarkovChain('Y', ['One', 'Two', 3], TS)\n    assert Y.joint_distribution(1, Y[2], 3) == JointDistribution(Y[1], Y[2], Y[3])\n    raises(ValueError, lambda : Y.joint_distribution(Y[1].symbol, Y[2].symbol))\n    assert P(Eq(Y[3], 2), Eq(Y[1], 1)).round(2) == Float(0.36, 2)\n    assert (P(Eq(YS[3], 2), Eq(YS[1], 1)) - (TS[0, 2] * TS[1, 0] + TS[1, 1] * TS[1, 2] + TS[1, 2] * TS[2, 2])).simplify() == 0\n    assert P(Eq(YS[1], 1), Eq(YS[2], 2)) == Probability(Eq(YS[1], 1))\n    assert P(Eq(YS[3], 3), Eq(YS[1], 1)) == TS[0, 2] * TS[1, 0] + TS[1, 1] * TS[1, 2] + TS[1, 2] * TS[2, 2]\n    TO = Matrix([[0.25, 0.75, 0], [0, 0.25, 0.75], [0.75, 0, 0.25]])\n    assert P(Eq(Y[3], 2), Eq(Y[1], 1) & TransitionMatrixOf(Y, TO)).round(3) == Float(0.375, 3)\n    with ignore_warnings(UserWarning):\n        assert E(Y[3], evaluate=False) == Expectation(Y[3])\n        assert E(Y[3], Eq(Y[2], 1)).round(2) == Float(1.1, 3)\n    TSO = MatrixSymbol('T', 4, 4)\n    raises(ValueError, lambda : str(P(Eq(YS[3], 2), Eq(YS[1], 1) & TransitionMatrixOf(YS, TSO))))\n    raises(TypeError, lambda : DiscreteMarkovChain('Z', [0, 1, 2], symbols('M')))\n    raises(ValueError, lambda : DiscreteMarkovChain('Z', [0, 1, 2], MatrixSymbol('T', 3, 4)))\n    raises(ValueError, lambda : E(Y[3], Eq(Y[2], 6)))\n    raises(ValueError, lambda : E(Y[2], Eq(Y[3], 1)))\n    TO1 = Matrix([[Rational(1, 4), Rational(3, 4), 0], [Rational(1, 3), Rational(1, 3), Rational(1, 3)], [0, Rational(1, 4), Rational(3, 4)]])\n    assert P(And(Eq(Y[2], 1), Eq(Y[1], 1), Eq(Y[0], 0)), Eq(Probability(Eq(Y[0], 0)), Rational(1, 4)) & TransitionMatrixOf(Y, TO1)) == Rational(1, 16)\n    assert P(And(Eq(Y[2], 1), Eq(Y[1], 1), Eq(Y[0], 0)), TransitionMatrixOf(Y, TO1)) == Probability(Eq(Y[0], 0)) / 4\n    assert P(Lt(X[1], 2) & Gt(X[1], 0), Eq(X[0], 2) & StochasticStateSpaceOf(X, [0, 1, 2]) & TransitionMatrixOf(X, TO1)) == Rational(1, 4)\n    assert P(Lt(X[1], 2) & Gt(X[1], 0), Eq(X[0], 2) & StochasticStateSpaceOf(X, [S(0), '0', 1]) & TransitionMatrixOf(X, TO1)) == Rational(1, 4)\n    assert P(Ne(X[1], 2) & Ne(X[1], 1), Eq(X[0], 2) & StochasticStateSpaceOf(X, [0, 1, 2]) & TransitionMatrixOf(X, TO1)) is S.Zero\n    assert P(Ne(X[1], 2) & Ne(X[1], 1), Eq(X[0], 2) & StochasticStateSpaceOf(X, [S(0), '0', 1]) & TransitionMatrixOf(X, TO1)) is S.Zero\n    assert P(And(Eq(Y[2], 1), Eq(Y[1], 1), Eq(Y[0], 0)), Eq(Y[1], 1)) == 0.1 * Probability(Eq(Y[0], 0))\n    TO2 = Matrix([[S.One, 0, 0], [Rational(1, 3), Rational(1, 3), Rational(1, 3)], [0, Rational(1, 4), Rational(3, 4)]])\n    TO3 = Matrix([[Rational(1, 4), Rational(3, 4), 0], [Rational(1, 3), Rational(1, 3), Rational(1, 3)], [0, Rational(1, 4), Rational(3, 4)]])\n    Y2 = DiscreteMarkovChain('Y', trans_probs=TO2)\n    Y3 = DiscreteMarkovChain('Y', trans_probs=TO3)\n    assert Y3.fundamental_matrix() == ImmutableMatrix([[176, 81, -132], [36, 141, -52], [-44, -39, 208]]) / 125\n    assert Y2.is_absorbing_chain() == True\n    assert Y3.is_absorbing_chain() == False\n    assert Y2.canonical_form() == ([0, 1, 2], TO2)\n    assert Y3.canonical_form() == ([0, 1, 2], TO3)\n    assert Y2.decompose() == ([0, 1, 2], TO2[0:1, 0:1], TO2[1:3, 0:1], TO2[1:3, 1:3])\n    assert Y3.decompose() == ([0, 1, 2], TO3, Matrix(0, 3, []), Matrix(0, 0, []))\n    TO4 = Matrix([[Rational(1, 5), Rational(2, 5), Rational(2, 5)], [Rational(1, 10), S.Half, Rational(2, 5)], [Rational(3, 5), Rational(3, 10), Rational(1, 10)]])\n    Y4 = DiscreteMarkovChain('Y', trans_probs=TO4)\n    w = ImmutableMatrix([[Rational(11, 39), Rational(16, 39), Rational(4, 13)]])\n    assert Y4.limiting_distribution == w\n    assert Y4.is_regular() == True\n    assert Y4.is_ergodic() == True\n    TS1 = MatrixSymbol('T', 3, 3)\n    Y5 = DiscreteMarkovChain('Y', trans_probs=TS1)\n    assert Y5.limiting_distribution(w, TO4).doit() == True\n    assert Y5.stationary_distribution(condition_set=True).subs(TS1, TO4).contains(w).doit() == S.true\n    TO6 = Matrix([[S.One, 0, 0, 0, 0], [S.Half, 0, S.Half, 0, 0], [0, S.Half, 0, S.Half, 0], [0, 0, S.Half, 0, S.Half], [0, 0, 0, 0, 1]])\n    Y6 = DiscreteMarkovChain('Y', trans_probs=TO6)\n    assert Y6.fundamental_matrix() == ImmutableMatrix([[Rational(3, 2), S.One, S.Half], [S.One, S(2), S.One], [S.Half, S.One, Rational(3, 2)]])\n    assert Y6.absorbing_probabilities() == ImmutableMatrix([[Rational(3, 4), Rational(1, 4)], [S.Half, S.Half], [Rational(1, 4), Rational(3, 4)]])\n    with warns_deprecated_sympy():\n        Y6.absorbing_probabilites()\n    TO7 = Matrix([[Rational(1, 2), Rational(1, 4), Rational(1, 4)], [Rational(1, 2), 0, Rational(1, 2)], [Rational(1, 4), Rational(1, 4), Rational(1, 2)]])\n    Y7 = DiscreteMarkovChain('Y', trans_probs=TO7)\n    assert Y7.is_absorbing_chain() == False\n    assert Y7.fundamental_matrix() == ImmutableMatrix([[Rational(86, 75), Rational(1, 25), Rational(-14, 75)], [Rational(2, 25), Rational(21, 25), Rational(2, 25)], [Rational(-14, 75), Rational(1, 25), Rational(86, 75)]])\n    X = DiscreteMarkovChain('X', trans_probs=Matrix([[]]))\n    assert X.number_of_states == 0\n    assert X.stationary_distribution() == Matrix([[]])\n    assert X.communication_classes() == []\n    assert X.canonical_form() == ([], Matrix([[]]))\n    assert X.decompose() == ([], Matrix([[]]), Matrix([[]]), Matrix([[]]))\n    assert X.is_regular() == False\n    assert X.is_ergodic() == False\n    TO7 = Matrix([[0, 5, 5, 0, 0], [0, 0, 0, 10, 0], [5, 0, 5, 0, 0], [0, 10, 0, 0, 0], [0, 3, 0, 3, 4]]) / 10\n    Y7 = DiscreteMarkovChain('Y', trans_probs=TO7)\n    tuples = Y7.communication_classes()\n    (classes, recurrence, periods) = list(zip(*tuples))\n    assert classes == ([1, 3], [0, 2], [4])\n    assert recurrence == (True, False, False)\n    assert periods == (2, 1, 1)\n    TO8 = Matrix([[0, 0, 0, 10, 0, 0], [5, 0, 5, 0, 0, 0], [0, 4, 0, 0, 0, 6], [10, 0, 0, 0, 0, 0], [0, 10, 0, 0, 0, 0], [0, 0, 0, 5, 5, 0]]) / 10\n    Y8 = DiscreteMarkovChain('Y', trans_probs=TO8)\n    tuples = Y8.communication_classes()\n    (classes, recurrence, periods) = list(zip(*tuples))\n    assert classes == ([0, 3], [1, 2, 5, 4])\n    assert recurrence == (True, False)\n    assert periods == (2, 2)\n    TO9 = Matrix([[2, 0, 0, 3, 0, 0, 3, 2, 0, 0], [0, 10, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 0, 0, 0, 0, 0, 3, 3], [0, 0, 0, 3, 0, 0, 6, 1, 0, 0], [0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 10, 0, 0, 0, 0], [4, 0, 0, 5, 0, 0, 1, 0, 0, 0], [2, 0, 0, 4, 0, 0, 2, 2, 0, 0], [3, 0, 1, 0, 0, 0, 0, 0, 4, 2], [0, 0, 4, 0, 0, 0, 0, 0, 3, 3]]) / 10\n    Y9 = DiscreteMarkovChain('Y', trans_probs=TO9)\n    tuples = Y9.communication_classes()\n    (classes, recurrence, periods) = list(zip(*tuples))\n    assert classes == ([0, 3, 6, 7], [1], [2, 8, 9], [5], [4])\n    assert recurrence == (True, True, False, True, False)\n    assert periods == (1, 1, 1, 1, 1)\n    T = Matrix([[1, 0, 0, 0, 0], [S(1) / 2, 0, S(1) / 2, 0, 0], [0, S(1) / 2, 0, S(1) / 2, 0], [0, 0, S(1) / 2, 0, S(1) / 2], [0, 0, 0, 0, S(1)]])\n    DW = DiscreteMarkovChain('DW', [0, 1, 2, 3, 4], T)\n    (states, A, B, C) = DW.decompose()\n    assert states == [0, 4, 1, 2, 3]\n    assert A == Matrix([[1, 0], [0, 1]])\n    assert B == Matrix([[S(1) / 2, 0], [0, 0], [0, S(1) / 2]])\n    assert C == Matrix([[0, S(1) / 2, 0], [S(1) / 2, 0, S(1) / 2], [0, S(1) / 2, 0]])\n    (states, new_matrix) = DW.canonical_form()\n    assert states == [0, 4, 1, 2, 3]\n    assert new_matrix == Matrix([[1, 0, 0, 0, 0], [0, 1, 0, 0, 0], [S(1) / 2, 0, 0, S(1) / 2, 0], [0, 0, S(1) / 2, 0, S(1) / 2], [0, S(1) / 2, 0, S(1) / 2, 0]])\n    T = Matrix([[0, 4, 0, 0, 0], [1, 0, 3, 0, 0], [0, 2, 0, 2, 0], [0, 0, 3, 0, 1], [0, 0, 0, 4, 0]]) / 4\n    X = DiscreteMarkovChain('X', trans_probs=T)\n    assert not X.is_regular()\n    assert X.is_ergodic()\n    T = Matrix([[0, 1], [1, 0]])\n    X = DiscreteMarkovChain('X', trans_probs=T)\n    assert not X.is_regular()\n    assert X.is_ergodic()\n    T = Matrix([[2, 1, 1], [2, 0, 2], [1, 1, 2]]) / 4\n    X = DiscreteMarkovChain('X', trans_probs=T)\n    assert X.is_regular()\n    assert X.is_ergodic()\n    T = Matrix([[1, 1], [1, 1]]) / 2\n    X = DiscreteMarkovChain('X', trans_probs=T)\n    assert X.is_regular()\n    assert X.is_ergodic()\n    T = Matrix([[0, 1, 0], [1, 0, 0], [0, 0, 1]])\n    X = DiscreteMarkovChain('X', trans_probs=T)\n    assert not X.is_absorbing_chain()\n    T = Matrix([[1, 1, 0, 0], [0, 1, 1, 0], [1, 0, 0, 1], [0, 0, 0, 2]]) / 2\n    X = DiscreteMarkovChain('X', trans_probs=T)\n    assert X.is_absorbing_chain()\n    T = Matrix([[2, 0, 0, 0, 0], [1, 0, 1, 0, 0], [0, 1, 0, 1, 0], [0, 0, 1, 0, 1], [0, 0, 0, 0, 2]]) / 2\n    X = DiscreteMarkovChain('X', trans_probs=T)\n    assert X.is_absorbing_chain()\n    Y10 = DiscreteMarkovChain('Y', [1, 2, 3], TO2)\n    tuples = Y10.communication_classes()\n    (classes, recurrence, periods) = list(zip(*tuples))\n    assert classes == ([1], [2, 3])\n    assert recurrence == (True, False)\n    assert periods == (1, 1)\n    assert Y10.canonical_form() == ([1, 2, 3], TO2)\n    assert Y10.decompose() == ([1, 2, 3], TO2[0:1, 0:1], TO2[1:3, 0:1], TO2[1:3, 1:3])\n    T = Matrix([[S.Half, Rational(1, 4), Rational(1, 4)], [Rational(1, 3), 0, Rational(2, 3)], [S.Half, S.Half, 0]])\n    X = DiscreteMarkovChain('X', [0, 1, 2], T)\n    assert P(Eq(X[1], 2) & Eq(X[2], 1) & Eq(X[3], 0), Eq(P(Eq(X[1], 0)), Rational(1, 4)) & Eq(P(Eq(X[1], 1)), Rational(1, 4))) == Rational(1, 12)\n    assert P(Eq(X[2], 1) | Eq(X[2], 2), Eq(X[1], 1)) == Rational(2, 3)\n    assert P(Eq(X[2], 1) & Eq(X[2], 2), Eq(X[1], 1)) is S.Zero\n    assert P(Ne(X[2], 2), Eq(X[1], 1)) == Rational(1, 3)\n    assert E(X[1] ** 2, Eq(X[0], 1)) == Rational(8, 3)\n    assert variance(X[1], Eq(X[0], 1)) == Rational(8, 9)\n    raises(ValueError, lambda : E(X[1], Eq(X[2], 1)))\n    raises(ValueError, lambda : DiscreteMarkovChain('X', [0, 1], T))\n    X = DiscreteMarkovChain('X', ['A', 'B', 'C'], T)\n    assert P(Eq(X[1], 2) & Eq(X[2], 1) & Eq(X[3], 0), Eq(P(Eq(X[1], 0)), Rational(1, 4)) & Eq(P(Eq(X[1], 1)), Rational(1, 4))) == Rational(1, 12)\n    assert P(Eq(X[2], 1) | Eq(X[2], 2), Eq(X[1], 1)) == Rational(2, 3)\n    assert P(Eq(X[2], 1) & Eq(X[2], 2), Eq(X[1], 1)) is S.Zero\n    assert P(Ne(X[2], 2), Eq(X[1], 1)) == Rational(1, 3)\n    a = X.state_space.args[0]\n    c = X.state_space.args[2]\n    assert (E(X[1] ** 2, Eq(X[0], 1)) - (a ** 2 / 3 + 2 * c ** 2 / 3)).simplify() == 0\n    assert (variance(X[1], Eq(X[0], 1)) - (2 * (-a / 3 + c / 3) ** 2 / 3 + (2 * a / 3 - 2 * c / 3) ** 2 / 3)).simplify() == 0\n    raises(ValueError, lambda : E(X[1], Eq(X[2], 1)))\n    T = Matrix([[Rational(5, 10), Rational(3, 10), Rational(2, 10)], [Rational(2, 10), Rational(7, 10), Rational(1, 10)], [Rational(3, 10), Rational(3, 10), Rational(4, 10)]])\n    Y = DiscreteMarkovChain('Y', [0, 1, 2], T)\n    assert P(Eq(Y[7], Y[5]), Eq(Y[2], 0)).round(5) == Float(0.44428, 5)\n    assert P(Gt(Y[3], Y[1]), Eq(Y[0], 0)).round(2) == Float(0.36, 2)\n    assert P(Le(Y[5], Y[10]), Eq(Y[4], 2)).round(6) == Float(0.58312, 6)\n    assert Float(P(Eq(Y[10], Y[5]), Eq(Y[4], 1)), 14) == Float(1 - P(Ne(Y[10], Y[5]), Eq(Y[4], 1)), 14)\n    assert Float(P(Gt(Y[8], Y[9]), Eq(Y[3], 2)), 14) == Float(1 - P(Le(Y[8], Y[9]), Eq(Y[3], 2)), 14)\n    assert Float(P(Lt(Y[1], Y[4]), Eq(Y[0], 0)), 14) == Float(1 - P(Ge(Y[1], Y[4]), Eq(Y[0], 0)), 14)\n    assert P(Eq(Y[5], Y[10]), Eq(Y[2], 1)) == P(Eq(Y[10], Y[5]), Eq(Y[2], 1))\n    assert P(Gt(Y[1], Y[2]), Eq(Y[0], 1)) == P(Lt(Y[2], Y[1]), Eq(Y[0], 1))\n    assert P(Ge(Y[7], Y[6]), Eq(Y[4], 1)) == P(Le(Y[6], Y[7]), Eq(Y[4], 1))\n    (a, b, c, d) = symbols('a b c d')\n    T = Matrix([[Rational(1, 10), Rational(4, 10), Rational(5, 10)], [Rational(3, 10), Rational(4, 10), Rational(3, 10)], [Rational(7, 10), Rational(2, 10), Rational(1, 10)]])\n    Y = DiscreteMarkovChain('Y', [0, 1, 2], T)\n    query = P(Eq(Y[a], b), Eq(Y[c], d))\n    assert query.subs({a: 10, b: 2, c: 5, d: 1}).evalf().round(4) == P(Eq(Y[10], 2), Eq(Y[5], 1)).round(4)\n    assert query.subs({a: 15, b: 0, c: 10, d: 1}).evalf().round(4) == P(Eq(Y[15], 0), Eq(Y[10], 1)).round(4)\n    query_gt = P(Gt(Y[a], b), Eq(Y[c], d))\n    query_le = P(Le(Y[a], b), Eq(Y[c], d))\n    assert query_gt.subs({a: 5, b: 2, c: 1, d: 0}).evalf() + query_le.subs({a: 5, b: 2, c: 1, d: 0}).evalf() == 1.0\n    query_ge = P(Ge(Y[a], b), Eq(Y[c], d))\n    query_lt = P(Lt(Y[a], b), Eq(Y[c], d))\n    assert query_ge.subs({a: 4, b: 1, c: 0, d: 2}).evalf() + query_lt.subs({a: 4, b: 1, c: 0, d: 2}).evalf() == 1.0\n    assert (2 * Y[1] + 3 * Y[1]).simplify() == 5 * Y[1]\n    assert (2 * Y[1] - 3 * Y[1]).simplify() == -Y[1]\n    assert (2 * (0.25 * Y[1])).simplify() == 0.5 * Y[1]\n    assert (2 * Y[1] * (0.25 * Y[1])).simplify() == 0.5 * Y[1] ** 2\n    assert (Y[1] ** 2 + Y[1] ** 3).simplify() == (Y[1] + 1) * Y[1] ** 2"
        ]
    },
    {
        "func_name": "test_sample_stochastic_process",
        "original": "def test_sample_stochastic_process():\n    if not import_module('scipy'):\n        skip('SciPy Not installed. Skip sampling tests')\n    import random\n    random.seed(0)\n    numpy = import_module('numpy')\n    if numpy:\n        numpy.random.seed(0)\n    T = Matrix([[0.5, 0.2, 0.3], [0.2, 0.5, 0.3], [0.2, 0.3, 0.5]])\n    Y = DiscreteMarkovChain('Y', [0, 1, 2], T)\n    for samps in range(10):\n        assert next(sample_stochastic_process(Y)) in Y.state_space\n    Z = DiscreteMarkovChain('Z', ['1', 1, 0], T)\n    for samps in range(10):\n        assert next(sample_stochastic_process(Z)) in Z.state_space\n    T = Matrix([[S.Half, Rational(1, 4), Rational(1, 4)], [Rational(1, 3), 0, Rational(2, 3)], [S.Half, S.Half, 0]])\n    X = DiscreteMarkovChain('X', [0, 1, 2], T)\n    for samps in range(10):\n        assert next(sample_stochastic_process(X)) in X.state_space\n    W = DiscreteMarkovChain('W', [1, pi, oo], T)\n    for samps in range(10):\n        assert next(sample_stochastic_process(W)) in W.state_space",
        "mutated": [
            "def test_sample_stochastic_process():\n    if False:\n        i = 10\n    if not import_module('scipy'):\n        skip('SciPy Not installed. Skip sampling tests')\n    import random\n    random.seed(0)\n    numpy = import_module('numpy')\n    if numpy:\n        numpy.random.seed(0)\n    T = Matrix([[0.5, 0.2, 0.3], [0.2, 0.5, 0.3], [0.2, 0.3, 0.5]])\n    Y = DiscreteMarkovChain('Y', [0, 1, 2], T)\n    for samps in range(10):\n        assert next(sample_stochastic_process(Y)) in Y.state_space\n    Z = DiscreteMarkovChain('Z', ['1', 1, 0], T)\n    for samps in range(10):\n        assert next(sample_stochastic_process(Z)) in Z.state_space\n    T = Matrix([[S.Half, Rational(1, 4), Rational(1, 4)], [Rational(1, 3), 0, Rational(2, 3)], [S.Half, S.Half, 0]])\n    X = DiscreteMarkovChain('X', [0, 1, 2], T)\n    for samps in range(10):\n        assert next(sample_stochastic_process(X)) in X.state_space\n    W = DiscreteMarkovChain('W', [1, pi, oo], T)\n    for samps in range(10):\n        assert next(sample_stochastic_process(W)) in W.state_space",
            "def test_sample_stochastic_process():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not import_module('scipy'):\n        skip('SciPy Not installed. Skip sampling tests')\n    import random\n    random.seed(0)\n    numpy = import_module('numpy')\n    if numpy:\n        numpy.random.seed(0)\n    T = Matrix([[0.5, 0.2, 0.3], [0.2, 0.5, 0.3], [0.2, 0.3, 0.5]])\n    Y = DiscreteMarkovChain('Y', [0, 1, 2], T)\n    for samps in range(10):\n        assert next(sample_stochastic_process(Y)) in Y.state_space\n    Z = DiscreteMarkovChain('Z', ['1', 1, 0], T)\n    for samps in range(10):\n        assert next(sample_stochastic_process(Z)) in Z.state_space\n    T = Matrix([[S.Half, Rational(1, 4), Rational(1, 4)], [Rational(1, 3), 0, Rational(2, 3)], [S.Half, S.Half, 0]])\n    X = DiscreteMarkovChain('X', [0, 1, 2], T)\n    for samps in range(10):\n        assert next(sample_stochastic_process(X)) in X.state_space\n    W = DiscreteMarkovChain('W', [1, pi, oo], T)\n    for samps in range(10):\n        assert next(sample_stochastic_process(W)) in W.state_space",
            "def test_sample_stochastic_process():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not import_module('scipy'):\n        skip('SciPy Not installed. Skip sampling tests')\n    import random\n    random.seed(0)\n    numpy = import_module('numpy')\n    if numpy:\n        numpy.random.seed(0)\n    T = Matrix([[0.5, 0.2, 0.3], [0.2, 0.5, 0.3], [0.2, 0.3, 0.5]])\n    Y = DiscreteMarkovChain('Y', [0, 1, 2], T)\n    for samps in range(10):\n        assert next(sample_stochastic_process(Y)) in Y.state_space\n    Z = DiscreteMarkovChain('Z', ['1', 1, 0], T)\n    for samps in range(10):\n        assert next(sample_stochastic_process(Z)) in Z.state_space\n    T = Matrix([[S.Half, Rational(1, 4), Rational(1, 4)], [Rational(1, 3), 0, Rational(2, 3)], [S.Half, S.Half, 0]])\n    X = DiscreteMarkovChain('X', [0, 1, 2], T)\n    for samps in range(10):\n        assert next(sample_stochastic_process(X)) in X.state_space\n    W = DiscreteMarkovChain('W', [1, pi, oo], T)\n    for samps in range(10):\n        assert next(sample_stochastic_process(W)) in W.state_space",
            "def test_sample_stochastic_process():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not import_module('scipy'):\n        skip('SciPy Not installed. Skip sampling tests')\n    import random\n    random.seed(0)\n    numpy = import_module('numpy')\n    if numpy:\n        numpy.random.seed(0)\n    T = Matrix([[0.5, 0.2, 0.3], [0.2, 0.5, 0.3], [0.2, 0.3, 0.5]])\n    Y = DiscreteMarkovChain('Y', [0, 1, 2], T)\n    for samps in range(10):\n        assert next(sample_stochastic_process(Y)) in Y.state_space\n    Z = DiscreteMarkovChain('Z', ['1', 1, 0], T)\n    for samps in range(10):\n        assert next(sample_stochastic_process(Z)) in Z.state_space\n    T = Matrix([[S.Half, Rational(1, 4), Rational(1, 4)], [Rational(1, 3), 0, Rational(2, 3)], [S.Half, S.Half, 0]])\n    X = DiscreteMarkovChain('X', [0, 1, 2], T)\n    for samps in range(10):\n        assert next(sample_stochastic_process(X)) in X.state_space\n    W = DiscreteMarkovChain('W', [1, pi, oo], T)\n    for samps in range(10):\n        assert next(sample_stochastic_process(W)) in W.state_space",
            "def test_sample_stochastic_process():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not import_module('scipy'):\n        skip('SciPy Not installed. Skip sampling tests')\n    import random\n    random.seed(0)\n    numpy = import_module('numpy')\n    if numpy:\n        numpy.random.seed(0)\n    T = Matrix([[0.5, 0.2, 0.3], [0.2, 0.5, 0.3], [0.2, 0.3, 0.5]])\n    Y = DiscreteMarkovChain('Y', [0, 1, 2], T)\n    for samps in range(10):\n        assert next(sample_stochastic_process(Y)) in Y.state_space\n    Z = DiscreteMarkovChain('Z', ['1', 1, 0], T)\n    for samps in range(10):\n        assert next(sample_stochastic_process(Z)) in Z.state_space\n    T = Matrix([[S.Half, Rational(1, 4), Rational(1, 4)], [Rational(1, 3), 0, Rational(2, 3)], [S.Half, S.Half, 0]])\n    X = DiscreteMarkovChain('X', [0, 1, 2], T)\n    for samps in range(10):\n        assert next(sample_stochastic_process(X)) in X.state_space\n    W = DiscreteMarkovChain('W', [1, pi, oo], T)\n    for samps in range(10):\n        assert next(sample_stochastic_process(W)) in W.state_space"
        ]
    },
    {
        "func_name": "test_ContinuousMarkovChain",
        "original": "def test_ContinuousMarkovChain():\n    T1 = Matrix([[S(-2), S(2), S.Zero], [S.Zero, S.NegativeOne, S.One], [Rational(3, 2), Rational(3, 2), S(-3)]])\n    C1 = ContinuousMarkovChain('C', [0, 1, 2], T1)\n    assert C1.limiting_distribution() == ImmutableMatrix([[Rational(3, 19), Rational(12, 19), Rational(4, 19)]])\n    T2 = Matrix([[-S.One, S.One, S.Zero], [S.One, -S.One, S.Zero], [S.Zero, S.One, -S.One]])\n    C2 = ContinuousMarkovChain('C', [0, 1, 2], T2)\n    (A, t) = (C2.generator_matrix, symbols('t', positive=True))\n    assert C2.transition_probabilities(A)(t) == Matrix([[S.Half + exp(-2 * t) / 2, S.Half - exp(-2 * t) / 2, 0], [S.Half - exp(-2 * t) / 2, S.Half + exp(-2 * t) / 2, 0], [S.Half - exp(-t) + exp(-2 * t) / 2, S.Half - exp(-2 * t) / 2, exp(-t)]])\n    with ignore_warnings(UserWarning):\n        assert P(Eq(C2(1), 1), Eq(C2(0), 1), evaluate=False) == Probability(Eq(C2(1), 1), Eq(C2(0), 1))\n    assert P(Eq(C2(1), 1), Eq(C2(0), 1)) == exp(-2) / 2 + S.Half\n    assert P(Eq(C2(1), 0) & Eq(C2(2), 1) & Eq(C2(3), 1), Eq(P(Eq(C2(1), 0)), S.Half)) == (Rational(1, 4) - exp(-2) / 4) * (exp(-2) / 2 + S.Half)\n    assert P(Not(Eq(C2(1), 0) & Eq(C2(2), 1) & Eq(C2(3), 2)) | Eq(C2(1), 0) & Eq(C2(2), 1) & Eq(C2(3), 2), Eq(P(Eq(C2(1), 0)), Rational(1, 4)) & Eq(P(Eq(C2(1), 1)), Rational(1, 4))) is S.One\n    assert E(C2(Rational(3, 2)), Eq(C2(0), 2)) == -exp(-3) / 2 + 2 * exp(Rational(-3, 2)) + S.Half\n    assert variance(C2(Rational(3, 2)), Eq(C2(0), 1)) == (S.Half - exp(-3) / 2) ** 2 * (exp(-3) / 2 + S.Half) + (Rational(-1, 2) - exp(-3) / 2) ** 2 * (S.Half - exp(-3) / 2)\n    raises(KeyError, lambda : P(Eq(C2(1), 0), Eq(P(Eq(C2(1), 1)), S.Half)))\n    assert P(Eq(C2(1), 0), Eq(P(Eq(C2(5), 1)), S.Half)) == Probability(Eq(C2(1), 0))\n    TS1 = MatrixSymbol('G', 3, 3)\n    CS1 = ContinuousMarkovChain('C', [0, 1, 2], TS1)\n    A = CS1.generator_matrix\n    assert CS1.transition_probabilities(A)(t) == exp(t * A)\n    C3 = ContinuousMarkovChain('C', [Symbol('0'), Symbol('1'), Symbol('2')], T2)\n    assert P(Eq(C3(1), 1), Eq(C3(0), 1)) == exp(-2) / 2 + S.Half\n    assert P(Eq(C3(1), Symbol('1')), Eq(C3(0), Symbol('1'))) == exp(-2) / 2 + S.Half\n    G = Matrix([[-S(1), Rational(1, 10), Rational(9, 10)], [Rational(2, 5), -S(1), Rational(3, 5)], [Rational(1, 2), Rational(1, 2), -S(1)]])\n    C = ContinuousMarkovChain('C', state_space=[0, 1, 2], gen_mat=G)\n    assert P(Eq(C(7.385), C(3.19)), Eq(C(0.862), 0)).round(5) == Float(0.35469, 5)\n    assert P(Gt(C(98.715), C(19.807)), Eq(C(11.314), 2)).round(5) == Float(0.32452, 5)\n    assert P(Le(C(5.9), C(10.112)), Eq(C(4), 1)).round(6) == Float(0.675214, 6)\n    assert Float(P(Eq(C(7.32), C(2.91)), Eq(C(2.63), 1)), 14) == Float(1 - P(Ne(C(7.32), C(2.91)), Eq(C(2.63), 1)), 14)\n    assert Float(P(Gt(C(3.36), C(1.101)), Eq(C(0.8), 2)), 14) == Float(1 - P(Le(C(3.36), C(1.101)), Eq(C(0.8), 2)), 14)\n    assert Float(P(Lt(C(4.9), C(2.79)), Eq(C(1.61), 0)), 14) == Float(1 - P(Ge(C(4.9), C(2.79)), Eq(C(1.61), 0)), 14)\n    assert P(Eq(C(5.243), C(10.912)), Eq(C(2.174), 1)) == P(Eq(C(10.912), C(5.243)), Eq(C(2.174), 1))\n    assert P(Gt(C(2.344), C(9.9)), Eq(C(1.102), 1)) == P(Lt(C(9.9), C(2.344)), Eq(C(1.102), 1))\n    assert P(Ge(C(7.87), C(1.008)), Eq(C(0.153), 1)) == P(Le(C(1.008), C(7.87)), Eq(C(0.153), 1))\n    (a, b, c, d) = symbols('a b c d')\n    query = P(Eq(C(a), b), Eq(C(c), d))\n    assert query.subs({a: 3.65, b: 2, c: 1.78, d: 1}).evalf().round(10) == P(Eq(C(3.65), 2), Eq(C(1.78), 1)).round(10)\n    query_gt = P(Gt(C(a), b), Eq(C(c), d))\n    query_le = P(Le(C(a), b), Eq(C(c), d))\n    assert query_gt.subs({a: 13.2, b: 0, c: 3.29, d: 2}).evalf() + query_le.subs({a: 13.2, b: 0, c: 3.29, d: 2}).evalf() == 1.0\n    query_ge = P(Ge(C(a), b), Eq(C(c), d))\n    query_lt = P(Lt(C(a), b), Eq(C(c), d))\n    assert query_ge.subs({a: 7.43, b: 1, c: 1.45, d: 0}).evalf() + query_lt.subs({a: 7.43, b: 1, c: 1.45, d: 0}).evalf() == 1.0\n    assert (2 * C(1) + 3 * C(1)).simplify() == 5 * C(1)\n    assert (2 * C(1) - 3 * C(1)).simplify() == -C(1)\n    assert (2 * (0.25 * C(1))).simplify() == 0.5 * C(1)\n    assert (2 * C(1) * 0.25 * C(1)).simplify() == 0.5 * C(1) ** 2\n    assert (C(1) ** 2 + C(1) ** 3).simplify() == (C(1) + 1) * C(1) ** 2",
        "mutated": [
            "def test_ContinuousMarkovChain():\n    if False:\n        i = 10\n    T1 = Matrix([[S(-2), S(2), S.Zero], [S.Zero, S.NegativeOne, S.One], [Rational(3, 2), Rational(3, 2), S(-3)]])\n    C1 = ContinuousMarkovChain('C', [0, 1, 2], T1)\n    assert C1.limiting_distribution() == ImmutableMatrix([[Rational(3, 19), Rational(12, 19), Rational(4, 19)]])\n    T2 = Matrix([[-S.One, S.One, S.Zero], [S.One, -S.One, S.Zero], [S.Zero, S.One, -S.One]])\n    C2 = ContinuousMarkovChain('C', [0, 1, 2], T2)\n    (A, t) = (C2.generator_matrix, symbols('t', positive=True))\n    assert C2.transition_probabilities(A)(t) == Matrix([[S.Half + exp(-2 * t) / 2, S.Half - exp(-2 * t) / 2, 0], [S.Half - exp(-2 * t) / 2, S.Half + exp(-2 * t) / 2, 0], [S.Half - exp(-t) + exp(-2 * t) / 2, S.Half - exp(-2 * t) / 2, exp(-t)]])\n    with ignore_warnings(UserWarning):\n        assert P(Eq(C2(1), 1), Eq(C2(0), 1), evaluate=False) == Probability(Eq(C2(1), 1), Eq(C2(0), 1))\n    assert P(Eq(C2(1), 1), Eq(C2(0), 1)) == exp(-2) / 2 + S.Half\n    assert P(Eq(C2(1), 0) & Eq(C2(2), 1) & Eq(C2(3), 1), Eq(P(Eq(C2(1), 0)), S.Half)) == (Rational(1, 4) - exp(-2) / 4) * (exp(-2) / 2 + S.Half)\n    assert P(Not(Eq(C2(1), 0) & Eq(C2(2), 1) & Eq(C2(3), 2)) | Eq(C2(1), 0) & Eq(C2(2), 1) & Eq(C2(3), 2), Eq(P(Eq(C2(1), 0)), Rational(1, 4)) & Eq(P(Eq(C2(1), 1)), Rational(1, 4))) is S.One\n    assert E(C2(Rational(3, 2)), Eq(C2(0), 2)) == -exp(-3) / 2 + 2 * exp(Rational(-3, 2)) + S.Half\n    assert variance(C2(Rational(3, 2)), Eq(C2(0), 1)) == (S.Half - exp(-3) / 2) ** 2 * (exp(-3) / 2 + S.Half) + (Rational(-1, 2) - exp(-3) / 2) ** 2 * (S.Half - exp(-3) / 2)\n    raises(KeyError, lambda : P(Eq(C2(1), 0), Eq(P(Eq(C2(1), 1)), S.Half)))\n    assert P(Eq(C2(1), 0), Eq(P(Eq(C2(5), 1)), S.Half)) == Probability(Eq(C2(1), 0))\n    TS1 = MatrixSymbol('G', 3, 3)\n    CS1 = ContinuousMarkovChain('C', [0, 1, 2], TS1)\n    A = CS1.generator_matrix\n    assert CS1.transition_probabilities(A)(t) == exp(t * A)\n    C3 = ContinuousMarkovChain('C', [Symbol('0'), Symbol('1'), Symbol('2')], T2)\n    assert P(Eq(C3(1), 1), Eq(C3(0), 1)) == exp(-2) / 2 + S.Half\n    assert P(Eq(C3(1), Symbol('1')), Eq(C3(0), Symbol('1'))) == exp(-2) / 2 + S.Half\n    G = Matrix([[-S(1), Rational(1, 10), Rational(9, 10)], [Rational(2, 5), -S(1), Rational(3, 5)], [Rational(1, 2), Rational(1, 2), -S(1)]])\n    C = ContinuousMarkovChain('C', state_space=[0, 1, 2], gen_mat=G)\n    assert P(Eq(C(7.385), C(3.19)), Eq(C(0.862), 0)).round(5) == Float(0.35469, 5)\n    assert P(Gt(C(98.715), C(19.807)), Eq(C(11.314), 2)).round(5) == Float(0.32452, 5)\n    assert P(Le(C(5.9), C(10.112)), Eq(C(4), 1)).round(6) == Float(0.675214, 6)\n    assert Float(P(Eq(C(7.32), C(2.91)), Eq(C(2.63), 1)), 14) == Float(1 - P(Ne(C(7.32), C(2.91)), Eq(C(2.63), 1)), 14)\n    assert Float(P(Gt(C(3.36), C(1.101)), Eq(C(0.8), 2)), 14) == Float(1 - P(Le(C(3.36), C(1.101)), Eq(C(0.8), 2)), 14)\n    assert Float(P(Lt(C(4.9), C(2.79)), Eq(C(1.61), 0)), 14) == Float(1 - P(Ge(C(4.9), C(2.79)), Eq(C(1.61), 0)), 14)\n    assert P(Eq(C(5.243), C(10.912)), Eq(C(2.174), 1)) == P(Eq(C(10.912), C(5.243)), Eq(C(2.174), 1))\n    assert P(Gt(C(2.344), C(9.9)), Eq(C(1.102), 1)) == P(Lt(C(9.9), C(2.344)), Eq(C(1.102), 1))\n    assert P(Ge(C(7.87), C(1.008)), Eq(C(0.153), 1)) == P(Le(C(1.008), C(7.87)), Eq(C(0.153), 1))\n    (a, b, c, d) = symbols('a b c d')\n    query = P(Eq(C(a), b), Eq(C(c), d))\n    assert query.subs({a: 3.65, b: 2, c: 1.78, d: 1}).evalf().round(10) == P(Eq(C(3.65), 2), Eq(C(1.78), 1)).round(10)\n    query_gt = P(Gt(C(a), b), Eq(C(c), d))\n    query_le = P(Le(C(a), b), Eq(C(c), d))\n    assert query_gt.subs({a: 13.2, b: 0, c: 3.29, d: 2}).evalf() + query_le.subs({a: 13.2, b: 0, c: 3.29, d: 2}).evalf() == 1.0\n    query_ge = P(Ge(C(a), b), Eq(C(c), d))\n    query_lt = P(Lt(C(a), b), Eq(C(c), d))\n    assert query_ge.subs({a: 7.43, b: 1, c: 1.45, d: 0}).evalf() + query_lt.subs({a: 7.43, b: 1, c: 1.45, d: 0}).evalf() == 1.0\n    assert (2 * C(1) + 3 * C(1)).simplify() == 5 * C(1)\n    assert (2 * C(1) - 3 * C(1)).simplify() == -C(1)\n    assert (2 * (0.25 * C(1))).simplify() == 0.5 * C(1)\n    assert (2 * C(1) * 0.25 * C(1)).simplify() == 0.5 * C(1) ** 2\n    assert (C(1) ** 2 + C(1) ** 3).simplify() == (C(1) + 1) * C(1) ** 2",
            "def test_ContinuousMarkovChain():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    T1 = Matrix([[S(-2), S(2), S.Zero], [S.Zero, S.NegativeOne, S.One], [Rational(3, 2), Rational(3, 2), S(-3)]])\n    C1 = ContinuousMarkovChain('C', [0, 1, 2], T1)\n    assert C1.limiting_distribution() == ImmutableMatrix([[Rational(3, 19), Rational(12, 19), Rational(4, 19)]])\n    T2 = Matrix([[-S.One, S.One, S.Zero], [S.One, -S.One, S.Zero], [S.Zero, S.One, -S.One]])\n    C2 = ContinuousMarkovChain('C', [0, 1, 2], T2)\n    (A, t) = (C2.generator_matrix, symbols('t', positive=True))\n    assert C2.transition_probabilities(A)(t) == Matrix([[S.Half + exp(-2 * t) / 2, S.Half - exp(-2 * t) / 2, 0], [S.Half - exp(-2 * t) / 2, S.Half + exp(-2 * t) / 2, 0], [S.Half - exp(-t) + exp(-2 * t) / 2, S.Half - exp(-2 * t) / 2, exp(-t)]])\n    with ignore_warnings(UserWarning):\n        assert P(Eq(C2(1), 1), Eq(C2(0), 1), evaluate=False) == Probability(Eq(C2(1), 1), Eq(C2(0), 1))\n    assert P(Eq(C2(1), 1), Eq(C2(0), 1)) == exp(-2) / 2 + S.Half\n    assert P(Eq(C2(1), 0) & Eq(C2(2), 1) & Eq(C2(3), 1), Eq(P(Eq(C2(1), 0)), S.Half)) == (Rational(1, 4) - exp(-2) / 4) * (exp(-2) / 2 + S.Half)\n    assert P(Not(Eq(C2(1), 0) & Eq(C2(2), 1) & Eq(C2(3), 2)) | Eq(C2(1), 0) & Eq(C2(2), 1) & Eq(C2(3), 2), Eq(P(Eq(C2(1), 0)), Rational(1, 4)) & Eq(P(Eq(C2(1), 1)), Rational(1, 4))) is S.One\n    assert E(C2(Rational(3, 2)), Eq(C2(0), 2)) == -exp(-3) / 2 + 2 * exp(Rational(-3, 2)) + S.Half\n    assert variance(C2(Rational(3, 2)), Eq(C2(0), 1)) == (S.Half - exp(-3) / 2) ** 2 * (exp(-3) / 2 + S.Half) + (Rational(-1, 2) - exp(-3) / 2) ** 2 * (S.Half - exp(-3) / 2)\n    raises(KeyError, lambda : P(Eq(C2(1), 0), Eq(P(Eq(C2(1), 1)), S.Half)))\n    assert P(Eq(C2(1), 0), Eq(P(Eq(C2(5), 1)), S.Half)) == Probability(Eq(C2(1), 0))\n    TS1 = MatrixSymbol('G', 3, 3)\n    CS1 = ContinuousMarkovChain('C', [0, 1, 2], TS1)\n    A = CS1.generator_matrix\n    assert CS1.transition_probabilities(A)(t) == exp(t * A)\n    C3 = ContinuousMarkovChain('C', [Symbol('0'), Symbol('1'), Symbol('2')], T2)\n    assert P(Eq(C3(1), 1), Eq(C3(0), 1)) == exp(-2) / 2 + S.Half\n    assert P(Eq(C3(1), Symbol('1')), Eq(C3(0), Symbol('1'))) == exp(-2) / 2 + S.Half\n    G = Matrix([[-S(1), Rational(1, 10), Rational(9, 10)], [Rational(2, 5), -S(1), Rational(3, 5)], [Rational(1, 2), Rational(1, 2), -S(1)]])\n    C = ContinuousMarkovChain('C', state_space=[0, 1, 2], gen_mat=G)\n    assert P(Eq(C(7.385), C(3.19)), Eq(C(0.862), 0)).round(5) == Float(0.35469, 5)\n    assert P(Gt(C(98.715), C(19.807)), Eq(C(11.314), 2)).round(5) == Float(0.32452, 5)\n    assert P(Le(C(5.9), C(10.112)), Eq(C(4), 1)).round(6) == Float(0.675214, 6)\n    assert Float(P(Eq(C(7.32), C(2.91)), Eq(C(2.63), 1)), 14) == Float(1 - P(Ne(C(7.32), C(2.91)), Eq(C(2.63), 1)), 14)\n    assert Float(P(Gt(C(3.36), C(1.101)), Eq(C(0.8), 2)), 14) == Float(1 - P(Le(C(3.36), C(1.101)), Eq(C(0.8), 2)), 14)\n    assert Float(P(Lt(C(4.9), C(2.79)), Eq(C(1.61), 0)), 14) == Float(1 - P(Ge(C(4.9), C(2.79)), Eq(C(1.61), 0)), 14)\n    assert P(Eq(C(5.243), C(10.912)), Eq(C(2.174), 1)) == P(Eq(C(10.912), C(5.243)), Eq(C(2.174), 1))\n    assert P(Gt(C(2.344), C(9.9)), Eq(C(1.102), 1)) == P(Lt(C(9.9), C(2.344)), Eq(C(1.102), 1))\n    assert P(Ge(C(7.87), C(1.008)), Eq(C(0.153), 1)) == P(Le(C(1.008), C(7.87)), Eq(C(0.153), 1))\n    (a, b, c, d) = symbols('a b c d')\n    query = P(Eq(C(a), b), Eq(C(c), d))\n    assert query.subs({a: 3.65, b: 2, c: 1.78, d: 1}).evalf().round(10) == P(Eq(C(3.65), 2), Eq(C(1.78), 1)).round(10)\n    query_gt = P(Gt(C(a), b), Eq(C(c), d))\n    query_le = P(Le(C(a), b), Eq(C(c), d))\n    assert query_gt.subs({a: 13.2, b: 0, c: 3.29, d: 2}).evalf() + query_le.subs({a: 13.2, b: 0, c: 3.29, d: 2}).evalf() == 1.0\n    query_ge = P(Ge(C(a), b), Eq(C(c), d))\n    query_lt = P(Lt(C(a), b), Eq(C(c), d))\n    assert query_ge.subs({a: 7.43, b: 1, c: 1.45, d: 0}).evalf() + query_lt.subs({a: 7.43, b: 1, c: 1.45, d: 0}).evalf() == 1.0\n    assert (2 * C(1) + 3 * C(1)).simplify() == 5 * C(1)\n    assert (2 * C(1) - 3 * C(1)).simplify() == -C(1)\n    assert (2 * (0.25 * C(1))).simplify() == 0.5 * C(1)\n    assert (2 * C(1) * 0.25 * C(1)).simplify() == 0.5 * C(1) ** 2\n    assert (C(1) ** 2 + C(1) ** 3).simplify() == (C(1) + 1) * C(1) ** 2",
            "def test_ContinuousMarkovChain():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    T1 = Matrix([[S(-2), S(2), S.Zero], [S.Zero, S.NegativeOne, S.One], [Rational(3, 2), Rational(3, 2), S(-3)]])\n    C1 = ContinuousMarkovChain('C', [0, 1, 2], T1)\n    assert C1.limiting_distribution() == ImmutableMatrix([[Rational(3, 19), Rational(12, 19), Rational(4, 19)]])\n    T2 = Matrix([[-S.One, S.One, S.Zero], [S.One, -S.One, S.Zero], [S.Zero, S.One, -S.One]])\n    C2 = ContinuousMarkovChain('C', [0, 1, 2], T2)\n    (A, t) = (C2.generator_matrix, symbols('t', positive=True))\n    assert C2.transition_probabilities(A)(t) == Matrix([[S.Half + exp(-2 * t) / 2, S.Half - exp(-2 * t) / 2, 0], [S.Half - exp(-2 * t) / 2, S.Half + exp(-2 * t) / 2, 0], [S.Half - exp(-t) + exp(-2 * t) / 2, S.Half - exp(-2 * t) / 2, exp(-t)]])\n    with ignore_warnings(UserWarning):\n        assert P(Eq(C2(1), 1), Eq(C2(0), 1), evaluate=False) == Probability(Eq(C2(1), 1), Eq(C2(0), 1))\n    assert P(Eq(C2(1), 1), Eq(C2(0), 1)) == exp(-2) / 2 + S.Half\n    assert P(Eq(C2(1), 0) & Eq(C2(2), 1) & Eq(C2(3), 1), Eq(P(Eq(C2(1), 0)), S.Half)) == (Rational(1, 4) - exp(-2) / 4) * (exp(-2) / 2 + S.Half)\n    assert P(Not(Eq(C2(1), 0) & Eq(C2(2), 1) & Eq(C2(3), 2)) | Eq(C2(1), 0) & Eq(C2(2), 1) & Eq(C2(3), 2), Eq(P(Eq(C2(1), 0)), Rational(1, 4)) & Eq(P(Eq(C2(1), 1)), Rational(1, 4))) is S.One\n    assert E(C2(Rational(3, 2)), Eq(C2(0), 2)) == -exp(-3) / 2 + 2 * exp(Rational(-3, 2)) + S.Half\n    assert variance(C2(Rational(3, 2)), Eq(C2(0), 1)) == (S.Half - exp(-3) / 2) ** 2 * (exp(-3) / 2 + S.Half) + (Rational(-1, 2) - exp(-3) / 2) ** 2 * (S.Half - exp(-3) / 2)\n    raises(KeyError, lambda : P(Eq(C2(1), 0), Eq(P(Eq(C2(1), 1)), S.Half)))\n    assert P(Eq(C2(1), 0), Eq(P(Eq(C2(5), 1)), S.Half)) == Probability(Eq(C2(1), 0))\n    TS1 = MatrixSymbol('G', 3, 3)\n    CS1 = ContinuousMarkovChain('C', [0, 1, 2], TS1)\n    A = CS1.generator_matrix\n    assert CS1.transition_probabilities(A)(t) == exp(t * A)\n    C3 = ContinuousMarkovChain('C', [Symbol('0'), Symbol('1'), Symbol('2')], T2)\n    assert P(Eq(C3(1), 1), Eq(C3(0), 1)) == exp(-2) / 2 + S.Half\n    assert P(Eq(C3(1), Symbol('1')), Eq(C3(0), Symbol('1'))) == exp(-2) / 2 + S.Half\n    G = Matrix([[-S(1), Rational(1, 10), Rational(9, 10)], [Rational(2, 5), -S(1), Rational(3, 5)], [Rational(1, 2), Rational(1, 2), -S(1)]])\n    C = ContinuousMarkovChain('C', state_space=[0, 1, 2], gen_mat=G)\n    assert P(Eq(C(7.385), C(3.19)), Eq(C(0.862), 0)).round(5) == Float(0.35469, 5)\n    assert P(Gt(C(98.715), C(19.807)), Eq(C(11.314), 2)).round(5) == Float(0.32452, 5)\n    assert P(Le(C(5.9), C(10.112)), Eq(C(4), 1)).round(6) == Float(0.675214, 6)\n    assert Float(P(Eq(C(7.32), C(2.91)), Eq(C(2.63), 1)), 14) == Float(1 - P(Ne(C(7.32), C(2.91)), Eq(C(2.63), 1)), 14)\n    assert Float(P(Gt(C(3.36), C(1.101)), Eq(C(0.8), 2)), 14) == Float(1 - P(Le(C(3.36), C(1.101)), Eq(C(0.8), 2)), 14)\n    assert Float(P(Lt(C(4.9), C(2.79)), Eq(C(1.61), 0)), 14) == Float(1 - P(Ge(C(4.9), C(2.79)), Eq(C(1.61), 0)), 14)\n    assert P(Eq(C(5.243), C(10.912)), Eq(C(2.174), 1)) == P(Eq(C(10.912), C(5.243)), Eq(C(2.174), 1))\n    assert P(Gt(C(2.344), C(9.9)), Eq(C(1.102), 1)) == P(Lt(C(9.9), C(2.344)), Eq(C(1.102), 1))\n    assert P(Ge(C(7.87), C(1.008)), Eq(C(0.153), 1)) == P(Le(C(1.008), C(7.87)), Eq(C(0.153), 1))\n    (a, b, c, d) = symbols('a b c d')\n    query = P(Eq(C(a), b), Eq(C(c), d))\n    assert query.subs({a: 3.65, b: 2, c: 1.78, d: 1}).evalf().round(10) == P(Eq(C(3.65), 2), Eq(C(1.78), 1)).round(10)\n    query_gt = P(Gt(C(a), b), Eq(C(c), d))\n    query_le = P(Le(C(a), b), Eq(C(c), d))\n    assert query_gt.subs({a: 13.2, b: 0, c: 3.29, d: 2}).evalf() + query_le.subs({a: 13.2, b: 0, c: 3.29, d: 2}).evalf() == 1.0\n    query_ge = P(Ge(C(a), b), Eq(C(c), d))\n    query_lt = P(Lt(C(a), b), Eq(C(c), d))\n    assert query_ge.subs({a: 7.43, b: 1, c: 1.45, d: 0}).evalf() + query_lt.subs({a: 7.43, b: 1, c: 1.45, d: 0}).evalf() == 1.0\n    assert (2 * C(1) + 3 * C(1)).simplify() == 5 * C(1)\n    assert (2 * C(1) - 3 * C(1)).simplify() == -C(1)\n    assert (2 * (0.25 * C(1))).simplify() == 0.5 * C(1)\n    assert (2 * C(1) * 0.25 * C(1)).simplify() == 0.5 * C(1) ** 2\n    assert (C(1) ** 2 + C(1) ** 3).simplify() == (C(1) + 1) * C(1) ** 2",
            "def test_ContinuousMarkovChain():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    T1 = Matrix([[S(-2), S(2), S.Zero], [S.Zero, S.NegativeOne, S.One], [Rational(3, 2), Rational(3, 2), S(-3)]])\n    C1 = ContinuousMarkovChain('C', [0, 1, 2], T1)\n    assert C1.limiting_distribution() == ImmutableMatrix([[Rational(3, 19), Rational(12, 19), Rational(4, 19)]])\n    T2 = Matrix([[-S.One, S.One, S.Zero], [S.One, -S.One, S.Zero], [S.Zero, S.One, -S.One]])\n    C2 = ContinuousMarkovChain('C', [0, 1, 2], T2)\n    (A, t) = (C2.generator_matrix, symbols('t', positive=True))\n    assert C2.transition_probabilities(A)(t) == Matrix([[S.Half + exp(-2 * t) / 2, S.Half - exp(-2 * t) / 2, 0], [S.Half - exp(-2 * t) / 2, S.Half + exp(-2 * t) / 2, 0], [S.Half - exp(-t) + exp(-2 * t) / 2, S.Half - exp(-2 * t) / 2, exp(-t)]])\n    with ignore_warnings(UserWarning):\n        assert P(Eq(C2(1), 1), Eq(C2(0), 1), evaluate=False) == Probability(Eq(C2(1), 1), Eq(C2(0), 1))\n    assert P(Eq(C2(1), 1), Eq(C2(0), 1)) == exp(-2) / 2 + S.Half\n    assert P(Eq(C2(1), 0) & Eq(C2(2), 1) & Eq(C2(3), 1), Eq(P(Eq(C2(1), 0)), S.Half)) == (Rational(1, 4) - exp(-2) / 4) * (exp(-2) / 2 + S.Half)\n    assert P(Not(Eq(C2(1), 0) & Eq(C2(2), 1) & Eq(C2(3), 2)) | Eq(C2(1), 0) & Eq(C2(2), 1) & Eq(C2(3), 2), Eq(P(Eq(C2(1), 0)), Rational(1, 4)) & Eq(P(Eq(C2(1), 1)), Rational(1, 4))) is S.One\n    assert E(C2(Rational(3, 2)), Eq(C2(0), 2)) == -exp(-3) / 2 + 2 * exp(Rational(-3, 2)) + S.Half\n    assert variance(C2(Rational(3, 2)), Eq(C2(0), 1)) == (S.Half - exp(-3) / 2) ** 2 * (exp(-3) / 2 + S.Half) + (Rational(-1, 2) - exp(-3) / 2) ** 2 * (S.Half - exp(-3) / 2)\n    raises(KeyError, lambda : P(Eq(C2(1), 0), Eq(P(Eq(C2(1), 1)), S.Half)))\n    assert P(Eq(C2(1), 0), Eq(P(Eq(C2(5), 1)), S.Half)) == Probability(Eq(C2(1), 0))\n    TS1 = MatrixSymbol('G', 3, 3)\n    CS1 = ContinuousMarkovChain('C', [0, 1, 2], TS1)\n    A = CS1.generator_matrix\n    assert CS1.transition_probabilities(A)(t) == exp(t * A)\n    C3 = ContinuousMarkovChain('C', [Symbol('0'), Symbol('1'), Symbol('2')], T2)\n    assert P(Eq(C3(1), 1), Eq(C3(0), 1)) == exp(-2) / 2 + S.Half\n    assert P(Eq(C3(1), Symbol('1')), Eq(C3(0), Symbol('1'))) == exp(-2) / 2 + S.Half\n    G = Matrix([[-S(1), Rational(1, 10), Rational(9, 10)], [Rational(2, 5), -S(1), Rational(3, 5)], [Rational(1, 2), Rational(1, 2), -S(1)]])\n    C = ContinuousMarkovChain('C', state_space=[0, 1, 2], gen_mat=G)\n    assert P(Eq(C(7.385), C(3.19)), Eq(C(0.862), 0)).round(5) == Float(0.35469, 5)\n    assert P(Gt(C(98.715), C(19.807)), Eq(C(11.314), 2)).round(5) == Float(0.32452, 5)\n    assert P(Le(C(5.9), C(10.112)), Eq(C(4), 1)).round(6) == Float(0.675214, 6)\n    assert Float(P(Eq(C(7.32), C(2.91)), Eq(C(2.63), 1)), 14) == Float(1 - P(Ne(C(7.32), C(2.91)), Eq(C(2.63), 1)), 14)\n    assert Float(P(Gt(C(3.36), C(1.101)), Eq(C(0.8), 2)), 14) == Float(1 - P(Le(C(3.36), C(1.101)), Eq(C(0.8), 2)), 14)\n    assert Float(P(Lt(C(4.9), C(2.79)), Eq(C(1.61), 0)), 14) == Float(1 - P(Ge(C(4.9), C(2.79)), Eq(C(1.61), 0)), 14)\n    assert P(Eq(C(5.243), C(10.912)), Eq(C(2.174), 1)) == P(Eq(C(10.912), C(5.243)), Eq(C(2.174), 1))\n    assert P(Gt(C(2.344), C(9.9)), Eq(C(1.102), 1)) == P(Lt(C(9.9), C(2.344)), Eq(C(1.102), 1))\n    assert P(Ge(C(7.87), C(1.008)), Eq(C(0.153), 1)) == P(Le(C(1.008), C(7.87)), Eq(C(0.153), 1))\n    (a, b, c, d) = symbols('a b c d')\n    query = P(Eq(C(a), b), Eq(C(c), d))\n    assert query.subs({a: 3.65, b: 2, c: 1.78, d: 1}).evalf().round(10) == P(Eq(C(3.65), 2), Eq(C(1.78), 1)).round(10)\n    query_gt = P(Gt(C(a), b), Eq(C(c), d))\n    query_le = P(Le(C(a), b), Eq(C(c), d))\n    assert query_gt.subs({a: 13.2, b: 0, c: 3.29, d: 2}).evalf() + query_le.subs({a: 13.2, b: 0, c: 3.29, d: 2}).evalf() == 1.0\n    query_ge = P(Ge(C(a), b), Eq(C(c), d))\n    query_lt = P(Lt(C(a), b), Eq(C(c), d))\n    assert query_ge.subs({a: 7.43, b: 1, c: 1.45, d: 0}).evalf() + query_lt.subs({a: 7.43, b: 1, c: 1.45, d: 0}).evalf() == 1.0\n    assert (2 * C(1) + 3 * C(1)).simplify() == 5 * C(1)\n    assert (2 * C(1) - 3 * C(1)).simplify() == -C(1)\n    assert (2 * (0.25 * C(1))).simplify() == 0.5 * C(1)\n    assert (2 * C(1) * 0.25 * C(1)).simplify() == 0.5 * C(1) ** 2\n    assert (C(1) ** 2 + C(1) ** 3).simplify() == (C(1) + 1) * C(1) ** 2",
            "def test_ContinuousMarkovChain():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    T1 = Matrix([[S(-2), S(2), S.Zero], [S.Zero, S.NegativeOne, S.One], [Rational(3, 2), Rational(3, 2), S(-3)]])\n    C1 = ContinuousMarkovChain('C', [0, 1, 2], T1)\n    assert C1.limiting_distribution() == ImmutableMatrix([[Rational(3, 19), Rational(12, 19), Rational(4, 19)]])\n    T2 = Matrix([[-S.One, S.One, S.Zero], [S.One, -S.One, S.Zero], [S.Zero, S.One, -S.One]])\n    C2 = ContinuousMarkovChain('C', [0, 1, 2], T2)\n    (A, t) = (C2.generator_matrix, symbols('t', positive=True))\n    assert C2.transition_probabilities(A)(t) == Matrix([[S.Half + exp(-2 * t) / 2, S.Half - exp(-2 * t) / 2, 0], [S.Half - exp(-2 * t) / 2, S.Half + exp(-2 * t) / 2, 0], [S.Half - exp(-t) + exp(-2 * t) / 2, S.Half - exp(-2 * t) / 2, exp(-t)]])\n    with ignore_warnings(UserWarning):\n        assert P(Eq(C2(1), 1), Eq(C2(0), 1), evaluate=False) == Probability(Eq(C2(1), 1), Eq(C2(0), 1))\n    assert P(Eq(C2(1), 1), Eq(C2(0), 1)) == exp(-2) / 2 + S.Half\n    assert P(Eq(C2(1), 0) & Eq(C2(2), 1) & Eq(C2(3), 1), Eq(P(Eq(C2(1), 0)), S.Half)) == (Rational(1, 4) - exp(-2) / 4) * (exp(-2) / 2 + S.Half)\n    assert P(Not(Eq(C2(1), 0) & Eq(C2(2), 1) & Eq(C2(3), 2)) | Eq(C2(1), 0) & Eq(C2(2), 1) & Eq(C2(3), 2), Eq(P(Eq(C2(1), 0)), Rational(1, 4)) & Eq(P(Eq(C2(1), 1)), Rational(1, 4))) is S.One\n    assert E(C2(Rational(3, 2)), Eq(C2(0), 2)) == -exp(-3) / 2 + 2 * exp(Rational(-3, 2)) + S.Half\n    assert variance(C2(Rational(3, 2)), Eq(C2(0), 1)) == (S.Half - exp(-3) / 2) ** 2 * (exp(-3) / 2 + S.Half) + (Rational(-1, 2) - exp(-3) / 2) ** 2 * (S.Half - exp(-3) / 2)\n    raises(KeyError, lambda : P(Eq(C2(1), 0), Eq(P(Eq(C2(1), 1)), S.Half)))\n    assert P(Eq(C2(1), 0), Eq(P(Eq(C2(5), 1)), S.Half)) == Probability(Eq(C2(1), 0))\n    TS1 = MatrixSymbol('G', 3, 3)\n    CS1 = ContinuousMarkovChain('C', [0, 1, 2], TS1)\n    A = CS1.generator_matrix\n    assert CS1.transition_probabilities(A)(t) == exp(t * A)\n    C3 = ContinuousMarkovChain('C', [Symbol('0'), Symbol('1'), Symbol('2')], T2)\n    assert P(Eq(C3(1), 1), Eq(C3(0), 1)) == exp(-2) / 2 + S.Half\n    assert P(Eq(C3(1), Symbol('1')), Eq(C3(0), Symbol('1'))) == exp(-2) / 2 + S.Half\n    G = Matrix([[-S(1), Rational(1, 10), Rational(9, 10)], [Rational(2, 5), -S(1), Rational(3, 5)], [Rational(1, 2), Rational(1, 2), -S(1)]])\n    C = ContinuousMarkovChain('C', state_space=[0, 1, 2], gen_mat=G)\n    assert P(Eq(C(7.385), C(3.19)), Eq(C(0.862), 0)).round(5) == Float(0.35469, 5)\n    assert P(Gt(C(98.715), C(19.807)), Eq(C(11.314), 2)).round(5) == Float(0.32452, 5)\n    assert P(Le(C(5.9), C(10.112)), Eq(C(4), 1)).round(6) == Float(0.675214, 6)\n    assert Float(P(Eq(C(7.32), C(2.91)), Eq(C(2.63), 1)), 14) == Float(1 - P(Ne(C(7.32), C(2.91)), Eq(C(2.63), 1)), 14)\n    assert Float(P(Gt(C(3.36), C(1.101)), Eq(C(0.8), 2)), 14) == Float(1 - P(Le(C(3.36), C(1.101)), Eq(C(0.8), 2)), 14)\n    assert Float(P(Lt(C(4.9), C(2.79)), Eq(C(1.61), 0)), 14) == Float(1 - P(Ge(C(4.9), C(2.79)), Eq(C(1.61), 0)), 14)\n    assert P(Eq(C(5.243), C(10.912)), Eq(C(2.174), 1)) == P(Eq(C(10.912), C(5.243)), Eq(C(2.174), 1))\n    assert P(Gt(C(2.344), C(9.9)), Eq(C(1.102), 1)) == P(Lt(C(9.9), C(2.344)), Eq(C(1.102), 1))\n    assert P(Ge(C(7.87), C(1.008)), Eq(C(0.153), 1)) == P(Le(C(1.008), C(7.87)), Eq(C(0.153), 1))\n    (a, b, c, d) = symbols('a b c d')\n    query = P(Eq(C(a), b), Eq(C(c), d))\n    assert query.subs({a: 3.65, b: 2, c: 1.78, d: 1}).evalf().round(10) == P(Eq(C(3.65), 2), Eq(C(1.78), 1)).round(10)\n    query_gt = P(Gt(C(a), b), Eq(C(c), d))\n    query_le = P(Le(C(a), b), Eq(C(c), d))\n    assert query_gt.subs({a: 13.2, b: 0, c: 3.29, d: 2}).evalf() + query_le.subs({a: 13.2, b: 0, c: 3.29, d: 2}).evalf() == 1.0\n    query_ge = P(Ge(C(a), b), Eq(C(c), d))\n    query_lt = P(Lt(C(a), b), Eq(C(c), d))\n    assert query_ge.subs({a: 7.43, b: 1, c: 1.45, d: 0}).evalf() + query_lt.subs({a: 7.43, b: 1, c: 1.45, d: 0}).evalf() == 1.0\n    assert (2 * C(1) + 3 * C(1)).simplify() == 5 * C(1)\n    assert (2 * C(1) - 3 * C(1)).simplify() == -C(1)\n    assert (2 * (0.25 * C(1))).simplify() == 0.5 * C(1)\n    assert (2 * C(1) * 0.25 * C(1)).simplify() == 0.5 * C(1) ** 2\n    assert (C(1) ** 2 + C(1) ** 3).simplify() == (C(1) + 1) * C(1) ** 2"
        ]
    },
    {
        "func_name": "test_BernoulliProcess",
        "original": "def test_BernoulliProcess():\n    B = BernoulliProcess('B', p=0.6, success=1, failure=0)\n    assert B.state_space == FiniteSet(0, 1)\n    assert B.index_set == S.Naturals0\n    assert B.success == 1\n    assert B.failure == 0\n    X = BernoulliProcess('X', p=Rational(1, 3), success='H', failure='T')\n    assert X.state_space == FiniteSet('H', 'T')\n    (H, T) = symbols('H,T')\n    assert E(X[1] + X[2] * X[3]) == H ** 2 / 9 + 4 * H * T / 9 + H / 3 + 4 * T ** 2 / 9 + 2 * T / 3\n    (t, x) = symbols('t, x', positive=True, integer=True)\n    assert isinstance(B[t], RandomIndexedSymbol)\n    raises(ValueError, lambda : BernoulliProcess('X', p=1.1, success=1, failure=0))\n    raises(NotImplementedError, lambda : B(t))\n    raises(IndexError, lambda : B[-3])\n    assert B.joint_distribution(B[3], B[9]) == JointDistributionHandmade(Lambda((B[3], B[9]), Piecewise((0.6, Eq(B[3], 1)), (0.4, Eq(B[3], 0)), (0, True)) * Piecewise((0.6, Eq(B[9], 1)), (0.4, Eq(B[9], 0)), (0, True))))\n    assert B.joint_distribution(2, B[4]) == JointDistributionHandmade(Lambda((B[2], B[4]), Piecewise((0.6, Eq(B[2], 1)), (0.4, Eq(B[2], 0)), (0, True)) * Piecewise((0.6, Eq(B[4], 1)), (0.4, Eq(B[4], 0)), (0, True))))\n    Y = B[1] + B[2] + B[3]\n    assert P(Eq(Y, 0)).round(2) == Float(0.06, 1)\n    assert P(Eq(Y, 2)).round(2) == Float(0.43, 2)\n    assert P(Eq(Y, 4)).round(2) == 0\n    assert P(Gt(Y, 1)).round(2) == Float(0.65, 2)\n    assert P(Eq(B[1], 0) & Eq(B[2], 1) & Eq(B[3], 0) & Eq(B[4], 1)).round(2) == Float(0.06, 1)\n    assert E(2 * B[1] + B[2]).round(2) == Float(1.8, 3)\n    assert E(2 * B[1] + B[2] + 5).round(2) == Float(6.8, 3)\n    assert E(B[2] * B[4] + B[10]).round(2) == Float(0.96, 2)\n    assert E(B[2] > 0, Eq(B[1], 1) & Eq(B[2], 1)).round(2) == Float(0.6, 2)\n    assert E(B[1]) == 0.6\n    assert P(B[1] > 0).round(2) == Float(0.6, 2)\n    assert P(B[1] < 1).round(2) == Float(0.4, 2)\n    assert P(B[1] > 0, B[2] <= 1).round(2) == Float(0.6, 2)\n    assert P(B[12] * B[5] > 0).round(2) == Float(0.36, 2)\n    assert P(B[12] * B[5] > 0, B[4] < 1).round(2) == Float(0.36, 2)\n    assert P(Eq(B[2], 1), B[2] > 0) == 1.0\n    assert P(Eq(B[5], 3)) == 0\n    assert P(Eq(B[1], 1), B[1] < 0) == 0\n    assert P(B[2] > 0, Eq(B[2], 1)) == 1\n    assert P(B[2] < 0, Eq(B[2], 1)) == 0\n    assert P(B[2] > 0, B[2] == 7) == 0\n    assert P(B[5] > 0, B[5]) == BernoulliDistribution(0.6, 0, 1)\n    raises(ValueError, lambda : P(3))\n    raises(ValueError, lambda : P(B[3] > 0, 3))\n    expr = Sum(B[t], (t, 0, 4))\n    expr2 = Sum(B[t], (t, 1, 3))\n    expr3 = Sum(B[t] ** 2, (t, 1, 3))\n    assert expr.doit() == B[0] + B[1] + B[2] + B[3] + B[4]\n    assert expr2.doit() == Y\n    assert expr3.doit() == B[1] ** 2 + B[2] ** 2 + B[3] ** 2\n    assert B[2 * t].free_symbols == {B[2 * t], t}\n    assert B[4].free_symbols == {B[4]}\n    assert B[x * t].free_symbols == {B[x * t], x, t}\n    assert (2 * B[t] + 3 * B[t]).simplify() == 5 * B[t]\n    assert (2 * B[t] - 3 * B[t]).simplify() == -B[t]\n    assert (2 * (0.25 * B[t])).simplify() == 0.5 * B[t]\n    assert (2 * B[t] * 0.25 * B[t]).simplify() == 0.5 * B[t] ** 2\n    assert (B[t] ** 2 + B[t] ** 3).simplify() == (B[t] + 1) * B[t] ** 2",
        "mutated": [
            "def test_BernoulliProcess():\n    if False:\n        i = 10\n    B = BernoulliProcess('B', p=0.6, success=1, failure=0)\n    assert B.state_space == FiniteSet(0, 1)\n    assert B.index_set == S.Naturals0\n    assert B.success == 1\n    assert B.failure == 0\n    X = BernoulliProcess('X', p=Rational(1, 3), success='H', failure='T')\n    assert X.state_space == FiniteSet('H', 'T')\n    (H, T) = symbols('H,T')\n    assert E(X[1] + X[2] * X[3]) == H ** 2 / 9 + 4 * H * T / 9 + H / 3 + 4 * T ** 2 / 9 + 2 * T / 3\n    (t, x) = symbols('t, x', positive=True, integer=True)\n    assert isinstance(B[t], RandomIndexedSymbol)\n    raises(ValueError, lambda : BernoulliProcess('X', p=1.1, success=1, failure=0))\n    raises(NotImplementedError, lambda : B(t))\n    raises(IndexError, lambda : B[-3])\n    assert B.joint_distribution(B[3], B[9]) == JointDistributionHandmade(Lambda((B[3], B[9]), Piecewise((0.6, Eq(B[3], 1)), (0.4, Eq(B[3], 0)), (0, True)) * Piecewise((0.6, Eq(B[9], 1)), (0.4, Eq(B[9], 0)), (0, True))))\n    assert B.joint_distribution(2, B[4]) == JointDistributionHandmade(Lambda((B[2], B[4]), Piecewise((0.6, Eq(B[2], 1)), (0.4, Eq(B[2], 0)), (0, True)) * Piecewise((0.6, Eq(B[4], 1)), (0.4, Eq(B[4], 0)), (0, True))))\n    Y = B[1] + B[2] + B[3]\n    assert P(Eq(Y, 0)).round(2) == Float(0.06, 1)\n    assert P(Eq(Y, 2)).round(2) == Float(0.43, 2)\n    assert P(Eq(Y, 4)).round(2) == 0\n    assert P(Gt(Y, 1)).round(2) == Float(0.65, 2)\n    assert P(Eq(B[1], 0) & Eq(B[2], 1) & Eq(B[3], 0) & Eq(B[4], 1)).round(2) == Float(0.06, 1)\n    assert E(2 * B[1] + B[2]).round(2) == Float(1.8, 3)\n    assert E(2 * B[1] + B[2] + 5).round(2) == Float(6.8, 3)\n    assert E(B[2] * B[4] + B[10]).round(2) == Float(0.96, 2)\n    assert E(B[2] > 0, Eq(B[1], 1) & Eq(B[2], 1)).round(2) == Float(0.6, 2)\n    assert E(B[1]) == 0.6\n    assert P(B[1] > 0).round(2) == Float(0.6, 2)\n    assert P(B[1] < 1).round(2) == Float(0.4, 2)\n    assert P(B[1] > 0, B[2] <= 1).round(2) == Float(0.6, 2)\n    assert P(B[12] * B[5] > 0).round(2) == Float(0.36, 2)\n    assert P(B[12] * B[5] > 0, B[4] < 1).round(2) == Float(0.36, 2)\n    assert P(Eq(B[2], 1), B[2] > 0) == 1.0\n    assert P(Eq(B[5], 3)) == 0\n    assert P(Eq(B[1], 1), B[1] < 0) == 0\n    assert P(B[2] > 0, Eq(B[2], 1)) == 1\n    assert P(B[2] < 0, Eq(B[2], 1)) == 0\n    assert P(B[2] > 0, B[2] == 7) == 0\n    assert P(B[5] > 0, B[5]) == BernoulliDistribution(0.6, 0, 1)\n    raises(ValueError, lambda : P(3))\n    raises(ValueError, lambda : P(B[3] > 0, 3))\n    expr = Sum(B[t], (t, 0, 4))\n    expr2 = Sum(B[t], (t, 1, 3))\n    expr3 = Sum(B[t] ** 2, (t, 1, 3))\n    assert expr.doit() == B[0] + B[1] + B[2] + B[3] + B[4]\n    assert expr2.doit() == Y\n    assert expr3.doit() == B[1] ** 2 + B[2] ** 2 + B[3] ** 2\n    assert B[2 * t].free_symbols == {B[2 * t], t}\n    assert B[4].free_symbols == {B[4]}\n    assert B[x * t].free_symbols == {B[x * t], x, t}\n    assert (2 * B[t] + 3 * B[t]).simplify() == 5 * B[t]\n    assert (2 * B[t] - 3 * B[t]).simplify() == -B[t]\n    assert (2 * (0.25 * B[t])).simplify() == 0.5 * B[t]\n    assert (2 * B[t] * 0.25 * B[t]).simplify() == 0.5 * B[t] ** 2\n    assert (B[t] ** 2 + B[t] ** 3).simplify() == (B[t] + 1) * B[t] ** 2",
            "def test_BernoulliProcess():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    B = BernoulliProcess('B', p=0.6, success=1, failure=0)\n    assert B.state_space == FiniteSet(0, 1)\n    assert B.index_set == S.Naturals0\n    assert B.success == 1\n    assert B.failure == 0\n    X = BernoulliProcess('X', p=Rational(1, 3), success='H', failure='T')\n    assert X.state_space == FiniteSet('H', 'T')\n    (H, T) = symbols('H,T')\n    assert E(X[1] + X[2] * X[3]) == H ** 2 / 9 + 4 * H * T / 9 + H / 3 + 4 * T ** 2 / 9 + 2 * T / 3\n    (t, x) = symbols('t, x', positive=True, integer=True)\n    assert isinstance(B[t], RandomIndexedSymbol)\n    raises(ValueError, lambda : BernoulliProcess('X', p=1.1, success=1, failure=0))\n    raises(NotImplementedError, lambda : B(t))\n    raises(IndexError, lambda : B[-3])\n    assert B.joint_distribution(B[3], B[9]) == JointDistributionHandmade(Lambda((B[3], B[9]), Piecewise((0.6, Eq(B[3], 1)), (0.4, Eq(B[3], 0)), (0, True)) * Piecewise((0.6, Eq(B[9], 1)), (0.4, Eq(B[9], 0)), (0, True))))\n    assert B.joint_distribution(2, B[4]) == JointDistributionHandmade(Lambda((B[2], B[4]), Piecewise((0.6, Eq(B[2], 1)), (0.4, Eq(B[2], 0)), (0, True)) * Piecewise((0.6, Eq(B[4], 1)), (0.4, Eq(B[4], 0)), (0, True))))\n    Y = B[1] + B[2] + B[3]\n    assert P(Eq(Y, 0)).round(2) == Float(0.06, 1)\n    assert P(Eq(Y, 2)).round(2) == Float(0.43, 2)\n    assert P(Eq(Y, 4)).round(2) == 0\n    assert P(Gt(Y, 1)).round(2) == Float(0.65, 2)\n    assert P(Eq(B[1], 0) & Eq(B[2], 1) & Eq(B[3], 0) & Eq(B[4], 1)).round(2) == Float(0.06, 1)\n    assert E(2 * B[1] + B[2]).round(2) == Float(1.8, 3)\n    assert E(2 * B[1] + B[2] + 5).round(2) == Float(6.8, 3)\n    assert E(B[2] * B[4] + B[10]).round(2) == Float(0.96, 2)\n    assert E(B[2] > 0, Eq(B[1], 1) & Eq(B[2], 1)).round(2) == Float(0.6, 2)\n    assert E(B[1]) == 0.6\n    assert P(B[1] > 0).round(2) == Float(0.6, 2)\n    assert P(B[1] < 1).round(2) == Float(0.4, 2)\n    assert P(B[1] > 0, B[2] <= 1).round(2) == Float(0.6, 2)\n    assert P(B[12] * B[5] > 0).round(2) == Float(0.36, 2)\n    assert P(B[12] * B[5] > 0, B[4] < 1).round(2) == Float(0.36, 2)\n    assert P(Eq(B[2], 1), B[2] > 0) == 1.0\n    assert P(Eq(B[5], 3)) == 0\n    assert P(Eq(B[1], 1), B[1] < 0) == 0\n    assert P(B[2] > 0, Eq(B[2], 1)) == 1\n    assert P(B[2] < 0, Eq(B[2], 1)) == 0\n    assert P(B[2] > 0, B[2] == 7) == 0\n    assert P(B[5] > 0, B[5]) == BernoulliDistribution(0.6, 0, 1)\n    raises(ValueError, lambda : P(3))\n    raises(ValueError, lambda : P(B[3] > 0, 3))\n    expr = Sum(B[t], (t, 0, 4))\n    expr2 = Sum(B[t], (t, 1, 3))\n    expr3 = Sum(B[t] ** 2, (t, 1, 3))\n    assert expr.doit() == B[0] + B[1] + B[2] + B[3] + B[4]\n    assert expr2.doit() == Y\n    assert expr3.doit() == B[1] ** 2 + B[2] ** 2 + B[3] ** 2\n    assert B[2 * t].free_symbols == {B[2 * t], t}\n    assert B[4].free_symbols == {B[4]}\n    assert B[x * t].free_symbols == {B[x * t], x, t}\n    assert (2 * B[t] + 3 * B[t]).simplify() == 5 * B[t]\n    assert (2 * B[t] - 3 * B[t]).simplify() == -B[t]\n    assert (2 * (0.25 * B[t])).simplify() == 0.5 * B[t]\n    assert (2 * B[t] * 0.25 * B[t]).simplify() == 0.5 * B[t] ** 2\n    assert (B[t] ** 2 + B[t] ** 3).simplify() == (B[t] + 1) * B[t] ** 2",
            "def test_BernoulliProcess():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    B = BernoulliProcess('B', p=0.6, success=1, failure=0)\n    assert B.state_space == FiniteSet(0, 1)\n    assert B.index_set == S.Naturals0\n    assert B.success == 1\n    assert B.failure == 0\n    X = BernoulliProcess('X', p=Rational(1, 3), success='H', failure='T')\n    assert X.state_space == FiniteSet('H', 'T')\n    (H, T) = symbols('H,T')\n    assert E(X[1] + X[2] * X[3]) == H ** 2 / 9 + 4 * H * T / 9 + H / 3 + 4 * T ** 2 / 9 + 2 * T / 3\n    (t, x) = symbols('t, x', positive=True, integer=True)\n    assert isinstance(B[t], RandomIndexedSymbol)\n    raises(ValueError, lambda : BernoulliProcess('X', p=1.1, success=1, failure=0))\n    raises(NotImplementedError, lambda : B(t))\n    raises(IndexError, lambda : B[-3])\n    assert B.joint_distribution(B[3], B[9]) == JointDistributionHandmade(Lambda((B[3], B[9]), Piecewise((0.6, Eq(B[3], 1)), (0.4, Eq(B[3], 0)), (0, True)) * Piecewise((0.6, Eq(B[9], 1)), (0.4, Eq(B[9], 0)), (0, True))))\n    assert B.joint_distribution(2, B[4]) == JointDistributionHandmade(Lambda((B[2], B[4]), Piecewise((0.6, Eq(B[2], 1)), (0.4, Eq(B[2], 0)), (0, True)) * Piecewise((0.6, Eq(B[4], 1)), (0.4, Eq(B[4], 0)), (0, True))))\n    Y = B[1] + B[2] + B[3]\n    assert P(Eq(Y, 0)).round(2) == Float(0.06, 1)\n    assert P(Eq(Y, 2)).round(2) == Float(0.43, 2)\n    assert P(Eq(Y, 4)).round(2) == 0\n    assert P(Gt(Y, 1)).round(2) == Float(0.65, 2)\n    assert P(Eq(B[1], 0) & Eq(B[2], 1) & Eq(B[3], 0) & Eq(B[4], 1)).round(2) == Float(0.06, 1)\n    assert E(2 * B[1] + B[2]).round(2) == Float(1.8, 3)\n    assert E(2 * B[1] + B[2] + 5).round(2) == Float(6.8, 3)\n    assert E(B[2] * B[4] + B[10]).round(2) == Float(0.96, 2)\n    assert E(B[2] > 0, Eq(B[1], 1) & Eq(B[2], 1)).round(2) == Float(0.6, 2)\n    assert E(B[1]) == 0.6\n    assert P(B[1] > 0).round(2) == Float(0.6, 2)\n    assert P(B[1] < 1).round(2) == Float(0.4, 2)\n    assert P(B[1] > 0, B[2] <= 1).round(2) == Float(0.6, 2)\n    assert P(B[12] * B[5] > 0).round(2) == Float(0.36, 2)\n    assert P(B[12] * B[5] > 0, B[4] < 1).round(2) == Float(0.36, 2)\n    assert P(Eq(B[2], 1), B[2] > 0) == 1.0\n    assert P(Eq(B[5], 3)) == 0\n    assert P(Eq(B[1], 1), B[1] < 0) == 0\n    assert P(B[2] > 0, Eq(B[2], 1)) == 1\n    assert P(B[2] < 0, Eq(B[2], 1)) == 0\n    assert P(B[2] > 0, B[2] == 7) == 0\n    assert P(B[5] > 0, B[5]) == BernoulliDistribution(0.6, 0, 1)\n    raises(ValueError, lambda : P(3))\n    raises(ValueError, lambda : P(B[3] > 0, 3))\n    expr = Sum(B[t], (t, 0, 4))\n    expr2 = Sum(B[t], (t, 1, 3))\n    expr3 = Sum(B[t] ** 2, (t, 1, 3))\n    assert expr.doit() == B[0] + B[1] + B[2] + B[3] + B[4]\n    assert expr2.doit() == Y\n    assert expr3.doit() == B[1] ** 2 + B[2] ** 2 + B[3] ** 2\n    assert B[2 * t].free_symbols == {B[2 * t], t}\n    assert B[4].free_symbols == {B[4]}\n    assert B[x * t].free_symbols == {B[x * t], x, t}\n    assert (2 * B[t] + 3 * B[t]).simplify() == 5 * B[t]\n    assert (2 * B[t] - 3 * B[t]).simplify() == -B[t]\n    assert (2 * (0.25 * B[t])).simplify() == 0.5 * B[t]\n    assert (2 * B[t] * 0.25 * B[t]).simplify() == 0.5 * B[t] ** 2\n    assert (B[t] ** 2 + B[t] ** 3).simplify() == (B[t] + 1) * B[t] ** 2",
            "def test_BernoulliProcess():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    B = BernoulliProcess('B', p=0.6, success=1, failure=0)\n    assert B.state_space == FiniteSet(0, 1)\n    assert B.index_set == S.Naturals0\n    assert B.success == 1\n    assert B.failure == 0\n    X = BernoulliProcess('X', p=Rational(1, 3), success='H', failure='T')\n    assert X.state_space == FiniteSet('H', 'T')\n    (H, T) = symbols('H,T')\n    assert E(X[1] + X[2] * X[3]) == H ** 2 / 9 + 4 * H * T / 9 + H / 3 + 4 * T ** 2 / 9 + 2 * T / 3\n    (t, x) = symbols('t, x', positive=True, integer=True)\n    assert isinstance(B[t], RandomIndexedSymbol)\n    raises(ValueError, lambda : BernoulliProcess('X', p=1.1, success=1, failure=0))\n    raises(NotImplementedError, lambda : B(t))\n    raises(IndexError, lambda : B[-3])\n    assert B.joint_distribution(B[3], B[9]) == JointDistributionHandmade(Lambda((B[3], B[9]), Piecewise((0.6, Eq(B[3], 1)), (0.4, Eq(B[3], 0)), (0, True)) * Piecewise((0.6, Eq(B[9], 1)), (0.4, Eq(B[9], 0)), (0, True))))\n    assert B.joint_distribution(2, B[4]) == JointDistributionHandmade(Lambda((B[2], B[4]), Piecewise((0.6, Eq(B[2], 1)), (0.4, Eq(B[2], 0)), (0, True)) * Piecewise((0.6, Eq(B[4], 1)), (0.4, Eq(B[4], 0)), (0, True))))\n    Y = B[1] + B[2] + B[3]\n    assert P(Eq(Y, 0)).round(2) == Float(0.06, 1)\n    assert P(Eq(Y, 2)).round(2) == Float(0.43, 2)\n    assert P(Eq(Y, 4)).round(2) == 0\n    assert P(Gt(Y, 1)).round(2) == Float(0.65, 2)\n    assert P(Eq(B[1], 0) & Eq(B[2], 1) & Eq(B[3], 0) & Eq(B[4], 1)).round(2) == Float(0.06, 1)\n    assert E(2 * B[1] + B[2]).round(2) == Float(1.8, 3)\n    assert E(2 * B[1] + B[2] + 5).round(2) == Float(6.8, 3)\n    assert E(B[2] * B[4] + B[10]).round(2) == Float(0.96, 2)\n    assert E(B[2] > 0, Eq(B[1], 1) & Eq(B[2], 1)).round(2) == Float(0.6, 2)\n    assert E(B[1]) == 0.6\n    assert P(B[1] > 0).round(2) == Float(0.6, 2)\n    assert P(B[1] < 1).round(2) == Float(0.4, 2)\n    assert P(B[1] > 0, B[2] <= 1).round(2) == Float(0.6, 2)\n    assert P(B[12] * B[5] > 0).round(2) == Float(0.36, 2)\n    assert P(B[12] * B[5] > 0, B[4] < 1).round(2) == Float(0.36, 2)\n    assert P(Eq(B[2], 1), B[2] > 0) == 1.0\n    assert P(Eq(B[5], 3)) == 0\n    assert P(Eq(B[1], 1), B[1] < 0) == 0\n    assert P(B[2] > 0, Eq(B[2], 1)) == 1\n    assert P(B[2] < 0, Eq(B[2], 1)) == 0\n    assert P(B[2] > 0, B[2] == 7) == 0\n    assert P(B[5] > 0, B[5]) == BernoulliDistribution(0.6, 0, 1)\n    raises(ValueError, lambda : P(3))\n    raises(ValueError, lambda : P(B[3] > 0, 3))\n    expr = Sum(B[t], (t, 0, 4))\n    expr2 = Sum(B[t], (t, 1, 3))\n    expr3 = Sum(B[t] ** 2, (t, 1, 3))\n    assert expr.doit() == B[0] + B[1] + B[2] + B[3] + B[4]\n    assert expr2.doit() == Y\n    assert expr3.doit() == B[1] ** 2 + B[2] ** 2 + B[3] ** 2\n    assert B[2 * t].free_symbols == {B[2 * t], t}\n    assert B[4].free_symbols == {B[4]}\n    assert B[x * t].free_symbols == {B[x * t], x, t}\n    assert (2 * B[t] + 3 * B[t]).simplify() == 5 * B[t]\n    assert (2 * B[t] - 3 * B[t]).simplify() == -B[t]\n    assert (2 * (0.25 * B[t])).simplify() == 0.5 * B[t]\n    assert (2 * B[t] * 0.25 * B[t]).simplify() == 0.5 * B[t] ** 2\n    assert (B[t] ** 2 + B[t] ** 3).simplify() == (B[t] + 1) * B[t] ** 2",
            "def test_BernoulliProcess():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    B = BernoulliProcess('B', p=0.6, success=1, failure=0)\n    assert B.state_space == FiniteSet(0, 1)\n    assert B.index_set == S.Naturals0\n    assert B.success == 1\n    assert B.failure == 0\n    X = BernoulliProcess('X', p=Rational(1, 3), success='H', failure='T')\n    assert X.state_space == FiniteSet('H', 'T')\n    (H, T) = symbols('H,T')\n    assert E(X[1] + X[2] * X[3]) == H ** 2 / 9 + 4 * H * T / 9 + H / 3 + 4 * T ** 2 / 9 + 2 * T / 3\n    (t, x) = symbols('t, x', positive=True, integer=True)\n    assert isinstance(B[t], RandomIndexedSymbol)\n    raises(ValueError, lambda : BernoulliProcess('X', p=1.1, success=1, failure=0))\n    raises(NotImplementedError, lambda : B(t))\n    raises(IndexError, lambda : B[-3])\n    assert B.joint_distribution(B[3], B[9]) == JointDistributionHandmade(Lambda((B[3], B[9]), Piecewise((0.6, Eq(B[3], 1)), (0.4, Eq(B[3], 0)), (0, True)) * Piecewise((0.6, Eq(B[9], 1)), (0.4, Eq(B[9], 0)), (0, True))))\n    assert B.joint_distribution(2, B[4]) == JointDistributionHandmade(Lambda((B[2], B[4]), Piecewise((0.6, Eq(B[2], 1)), (0.4, Eq(B[2], 0)), (0, True)) * Piecewise((0.6, Eq(B[4], 1)), (0.4, Eq(B[4], 0)), (0, True))))\n    Y = B[1] + B[2] + B[3]\n    assert P(Eq(Y, 0)).round(2) == Float(0.06, 1)\n    assert P(Eq(Y, 2)).round(2) == Float(0.43, 2)\n    assert P(Eq(Y, 4)).round(2) == 0\n    assert P(Gt(Y, 1)).round(2) == Float(0.65, 2)\n    assert P(Eq(B[1], 0) & Eq(B[2], 1) & Eq(B[3], 0) & Eq(B[4], 1)).round(2) == Float(0.06, 1)\n    assert E(2 * B[1] + B[2]).round(2) == Float(1.8, 3)\n    assert E(2 * B[1] + B[2] + 5).round(2) == Float(6.8, 3)\n    assert E(B[2] * B[4] + B[10]).round(2) == Float(0.96, 2)\n    assert E(B[2] > 0, Eq(B[1], 1) & Eq(B[2], 1)).round(2) == Float(0.6, 2)\n    assert E(B[1]) == 0.6\n    assert P(B[1] > 0).round(2) == Float(0.6, 2)\n    assert P(B[1] < 1).round(2) == Float(0.4, 2)\n    assert P(B[1] > 0, B[2] <= 1).round(2) == Float(0.6, 2)\n    assert P(B[12] * B[5] > 0).round(2) == Float(0.36, 2)\n    assert P(B[12] * B[5] > 0, B[4] < 1).round(2) == Float(0.36, 2)\n    assert P(Eq(B[2], 1), B[2] > 0) == 1.0\n    assert P(Eq(B[5], 3)) == 0\n    assert P(Eq(B[1], 1), B[1] < 0) == 0\n    assert P(B[2] > 0, Eq(B[2], 1)) == 1\n    assert P(B[2] < 0, Eq(B[2], 1)) == 0\n    assert P(B[2] > 0, B[2] == 7) == 0\n    assert P(B[5] > 0, B[5]) == BernoulliDistribution(0.6, 0, 1)\n    raises(ValueError, lambda : P(3))\n    raises(ValueError, lambda : P(B[3] > 0, 3))\n    expr = Sum(B[t], (t, 0, 4))\n    expr2 = Sum(B[t], (t, 1, 3))\n    expr3 = Sum(B[t] ** 2, (t, 1, 3))\n    assert expr.doit() == B[0] + B[1] + B[2] + B[3] + B[4]\n    assert expr2.doit() == Y\n    assert expr3.doit() == B[1] ** 2 + B[2] ** 2 + B[3] ** 2\n    assert B[2 * t].free_symbols == {B[2 * t], t}\n    assert B[4].free_symbols == {B[4]}\n    assert B[x * t].free_symbols == {B[x * t], x, t}\n    assert (2 * B[t] + 3 * B[t]).simplify() == 5 * B[t]\n    assert (2 * B[t] - 3 * B[t]).simplify() == -B[t]\n    assert (2 * (0.25 * B[t])).simplify() == 0.5 * B[t]\n    assert (2 * B[t] * 0.25 * B[t]).simplify() == 0.5 * B[t] ** 2\n    assert (B[t] ** 2 + B[t] ** 3).simplify() == (B[t] + 1) * B[t] ** 2"
        ]
    },
    {
        "func_name": "test_PoissonProcess",
        "original": "def test_PoissonProcess():\n    X = PoissonProcess('X', 3)\n    assert X.state_space == S.Naturals0\n    assert X.index_set == Interval(0, oo)\n    assert X.lamda == 3\n    (t, d, x, y) = symbols('t d x y', positive=True)\n    assert isinstance(X(t), RandomIndexedSymbol)\n    assert X.distribution(t) == PoissonDistribution(3 * t)\n    with warns_deprecated_sympy():\n        X.distribution(X(t))\n    raises(ValueError, lambda : PoissonProcess('X', -1))\n    raises(NotImplementedError, lambda : X[t])\n    raises(IndexError, lambda : X(-5))\n    assert X.joint_distribution(X(2), X(3)) == JointDistributionHandmade(Lambda((X(2), X(3)), 6 ** X(2) * 9 ** X(3) * exp(-15) / (factorial(X(2)) * factorial(X(3)))))\n    assert X.joint_distribution(4, 6) == JointDistributionHandmade(Lambda((X(4), X(6)), 12 ** X(4) * 18 ** X(6) * exp(-30) / (factorial(X(4)) * factorial(X(6)))))\n    assert P(X(t) < 1) == exp(-3 * t)\n    assert P(Eq(X(t), 0), Contains(t, Interval.Lopen(3, 5))) == exp(-6)\n    res = P(Eq(X(t), 1), Contains(t, Interval.Lopen(3, 4)))\n    assert res == 3 * exp(-3)\n    assert P(Eq(X(t), 1) & Eq(X(d), 1) & Eq(X(x), 1) & Eq(X(y), 1), Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Lopen(1, 2)) & Contains(x, Interval.Lopen(2, 3)) & Contains(y, Interval.Lopen(3, 4))) == res ** 4\n    assert P(Eq(X(t), 2) & Eq(X(d), 3), Contains(t, Interval.Lopen(0, 2)) & Contains(d, Interval.Ropen(2, 4))) == Probability(Eq(X(d), 3) & Eq(X(t), 2), Contains(t, Interval.Lopen(0, 2)) & Contains(d, Interval.Ropen(2, 4)))\n    raises(ValueError, lambda : P(Eq(X(t), 2) & Eq(X(d), 3), Contains(t, Interval.Lopen(0, 4)) & Contains(d, Interval.Lopen(3, oo))))\n    assert P(Eq(X(3), 2)) == 81 * exp(-9) / 2\n    assert P(Eq(X(t), 2), Contains(t, Interval.Lopen(0, 5))) == 225 * exp(-15) / 2\n    res1 = P(X(t) <= 3, Contains(t, Interval.Lopen(0, 5)))\n    res2 = P(X(t) > 3, Contains(t, Interval.Lopen(0, 5)))\n    assert res1 == 691 * exp(-15)\n    assert (res1 + res2).simplify() == 1\n    assert P(Not(Eq(X(t), 2) & (X(d) > 3)), Contains(t, Interval.Ropen(2, 4)) & Contains(d, Interval.Lopen(7, 8))).simplify() == -18 * exp(-6) + 234 * exp(-9) + 1\n    assert P(Eq(X(t), 2) | Ne(X(t), 4), Contains(t, Interval.Ropen(2, 4))) == 1 - 36 * exp(-6)\n    raises(ValueError, lambda : P(X(t) > 2, X(t) + X(d)))\n    assert E(X(t)) == 3 * t\n    assert E(X(t) ** 2 + X(d) * 2 + X(y) ** 3, Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Lopen(1, 2)) & Contains(y, Interval.Ropen(3, 4))) == 75\n    assert E(X(t) ** 2, Contains(t, Interval.Lopen(0, 1))) == 12\n    assert E(x * (X(t) + X(d)) * (X(t) ** 2 + X(d) ** 2), Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Ropen(1, 2))) == Expectation(x * (X(d) + X(t)) * (X(d) ** 2 + X(t) ** 2), Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Ropen(1, 2)))\n    raises(ValueError, lambda : E(X(t) ** 3, Contains(t, Interval.Lopen(1, oo))))\n    assert E((X(t) + X(d)) * (X(t) - X(d)), Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Lopen(1, 2))) == 0\n    assert E(X(2) + x * E(X(5))) == 15 * x + 6\n    assert E(x * X(1) + y) == 3 * x + y\n    assert P(Eq(X(1), 2) & Eq(X(t), 3), Contains(t, Interval.Lopen(1, 2))) == 81 * exp(-6) / 4\n    Y = PoissonProcess('Y', 6)\n    Z = X + Y\n    assert Z.lamda == X.lamda + Y.lamda == 9\n    raises(ValueError, lambda : X + 5)\n    (N, M) = Z.split(4, 5)\n    assert N.lamda == 4\n    assert M.lamda == 5\n    raises(ValueError, lambda : Z.split(3, 2))\n    raises(ValueError, lambda : P(Eq(X(t), 0), Contains(t, Interval.Lopen(1, 3)) & Eq(X(1), 0)))\n    res1 = P(Eq(N(3), N(5)))\n    assert res1 == P(Eq(N(t), 0), Contains(t, Interval(3, 5)))\n    res2 = P(N(3) > N(1))\n    assert res2 == P(N(t) > 0, Contains(t, Interval(1, 3)))\n    assert P(N(3) < N(1)) == 0\n    res3 = P(N(3) <= N(1))\n    assert res3 == P(Eq(N(t), 0), Contains(t, Interval(1, 3)))\n    X = PoissonProcess('X', 10)\n    assert P(Eq(X(S(1) / 3), 3) & Eq(X(1), 10)) == exp(-10) * Rational(8000000000, 11160261)\n    assert P(Eq(X(1), 1), Eq(X(S(1) / 3), 3)) == 0\n    assert P(Eq(X(1), 10), Eq(X(S(1) / 3), 3)) == P(Eq(X(S(2) / 3), 7))\n    X = PoissonProcess('X', 2)\n    assert P(X(S(1) / 2) < 1) == exp(-1)\n    assert P(X(3) < 1, Eq(X(1), 0)) == exp(-4)\n    assert P(Eq(X(4), 3), Eq(X(2), 3)) == exp(-4)\n    X = PoissonProcess('X', 3)\n    assert P(Eq(X(2), 5) & Eq(X(1), 2)) == Rational(81, 4) * exp(-6)\n    assert P(X(2) <= 3, X(1) >= 1) == 3 * P(Eq(X(1), 0)) + 2 * P(Eq(X(1), 1)) + P(Eq(X(1), 2))\n    assert P(X(2) <= 3, X(1) > 1) == 2 * P(Eq(X(1), 0)) + 1 * P(Eq(X(1), 1))\n    assert P(Eq(X(2), 5) & Eq(X(1), 2)) == P(Eq(X(1), 3)) * P(Eq(X(1), 2))\n    assert P(Eq(X(3), 4), Eq(X(1), 3)) == P(Eq(X(2), 1))\n    assert (2 * X(t) + 3 * X(t)).simplify() == 5 * X(t)\n    assert (2 * X(t) - 3 * X(t)).simplify() == -X(t)\n    assert (2 * (0.25 * X(t))).simplify() == 0.5 * X(t)\n    assert (2 * X(t) * 0.25 * X(t)).simplify() == 0.5 * X(t) ** 2\n    assert (X(t) ** 2 + X(t) ** 3).simplify() == (X(t) + 1) * X(t) ** 2",
        "mutated": [
            "def test_PoissonProcess():\n    if False:\n        i = 10\n    X = PoissonProcess('X', 3)\n    assert X.state_space == S.Naturals0\n    assert X.index_set == Interval(0, oo)\n    assert X.lamda == 3\n    (t, d, x, y) = symbols('t d x y', positive=True)\n    assert isinstance(X(t), RandomIndexedSymbol)\n    assert X.distribution(t) == PoissonDistribution(3 * t)\n    with warns_deprecated_sympy():\n        X.distribution(X(t))\n    raises(ValueError, lambda : PoissonProcess('X', -1))\n    raises(NotImplementedError, lambda : X[t])\n    raises(IndexError, lambda : X(-5))\n    assert X.joint_distribution(X(2), X(3)) == JointDistributionHandmade(Lambda((X(2), X(3)), 6 ** X(2) * 9 ** X(3) * exp(-15) / (factorial(X(2)) * factorial(X(3)))))\n    assert X.joint_distribution(4, 6) == JointDistributionHandmade(Lambda((X(4), X(6)), 12 ** X(4) * 18 ** X(6) * exp(-30) / (factorial(X(4)) * factorial(X(6)))))\n    assert P(X(t) < 1) == exp(-3 * t)\n    assert P(Eq(X(t), 0), Contains(t, Interval.Lopen(3, 5))) == exp(-6)\n    res = P(Eq(X(t), 1), Contains(t, Interval.Lopen(3, 4)))\n    assert res == 3 * exp(-3)\n    assert P(Eq(X(t), 1) & Eq(X(d), 1) & Eq(X(x), 1) & Eq(X(y), 1), Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Lopen(1, 2)) & Contains(x, Interval.Lopen(2, 3)) & Contains(y, Interval.Lopen(3, 4))) == res ** 4\n    assert P(Eq(X(t), 2) & Eq(X(d), 3), Contains(t, Interval.Lopen(0, 2)) & Contains(d, Interval.Ropen(2, 4))) == Probability(Eq(X(d), 3) & Eq(X(t), 2), Contains(t, Interval.Lopen(0, 2)) & Contains(d, Interval.Ropen(2, 4)))\n    raises(ValueError, lambda : P(Eq(X(t), 2) & Eq(X(d), 3), Contains(t, Interval.Lopen(0, 4)) & Contains(d, Interval.Lopen(3, oo))))\n    assert P(Eq(X(3), 2)) == 81 * exp(-9) / 2\n    assert P(Eq(X(t), 2), Contains(t, Interval.Lopen(0, 5))) == 225 * exp(-15) / 2\n    res1 = P(X(t) <= 3, Contains(t, Interval.Lopen(0, 5)))\n    res2 = P(X(t) > 3, Contains(t, Interval.Lopen(0, 5)))\n    assert res1 == 691 * exp(-15)\n    assert (res1 + res2).simplify() == 1\n    assert P(Not(Eq(X(t), 2) & (X(d) > 3)), Contains(t, Interval.Ropen(2, 4)) & Contains(d, Interval.Lopen(7, 8))).simplify() == -18 * exp(-6) + 234 * exp(-9) + 1\n    assert P(Eq(X(t), 2) | Ne(X(t), 4), Contains(t, Interval.Ropen(2, 4))) == 1 - 36 * exp(-6)\n    raises(ValueError, lambda : P(X(t) > 2, X(t) + X(d)))\n    assert E(X(t)) == 3 * t\n    assert E(X(t) ** 2 + X(d) * 2 + X(y) ** 3, Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Lopen(1, 2)) & Contains(y, Interval.Ropen(3, 4))) == 75\n    assert E(X(t) ** 2, Contains(t, Interval.Lopen(0, 1))) == 12\n    assert E(x * (X(t) + X(d)) * (X(t) ** 2 + X(d) ** 2), Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Ropen(1, 2))) == Expectation(x * (X(d) + X(t)) * (X(d) ** 2 + X(t) ** 2), Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Ropen(1, 2)))\n    raises(ValueError, lambda : E(X(t) ** 3, Contains(t, Interval.Lopen(1, oo))))\n    assert E((X(t) + X(d)) * (X(t) - X(d)), Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Lopen(1, 2))) == 0\n    assert E(X(2) + x * E(X(5))) == 15 * x + 6\n    assert E(x * X(1) + y) == 3 * x + y\n    assert P(Eq(X(1), 2) & Eq(X(t), 3), Contains(t, Interval.Lopen(1, 2))) == 81 * exp(-6) / 4\n    Y = PoissonProcess('Y', 6)\n    Z = X + Y\n    assert Z.lamda == X.lamda + Y.lamda == 9\n    raises(ValueError, lambda : X + 5)\n    (N, M) = Z.split(4, 5)\n    assert N.lamda == 4\n    assert M.lamda == 5\n    raises(ValueError, lambda : Z.split(3, 2))\n    raises(ValueError, lambda : P(Eq(X(t), 0), Contains(t, Interval.Lopen(1, 3)) & Eq(X(1), 0)))\n    res1 = P(Eq(N(3), N(5)))\n    assert res1 == P(Eq(N(t), 0), Contains(t, Interval(3, 5)))\n    res2 = P(N(3) > N(1))\n    assert res2 == P(N(t) > 0, Contains(t, Interval(1, 3)))\n    assert P(N(3) < N(1)) == 0\n    res3 = P(N(3) <= N(1))\n    assert res3 == P(Eq(N(t), 0), Contains(t, Interval(1, 3)))\n    X = PoissonProcess('X', 10)\n    assert P(Eq(X(S(1) / 3), 3) & Eq(X(1), 10)) == exp(-10) * Rational(8000000000, 11160261)\n    assert P(Eq(X(1), 1), Eq(X(S(1) / 3), 3)) == 0\n    assert P(Eq(X(1), 10), Eq(X(S(1) / 3), 3)) == P(Eq(X(S(2) / 3), 7))\n    X = PoissonProcess('X', 2)\n    assert P(X(S(1) / 2) < 1) == exp(-1)\n    assert P(X(3) < 1, Eq(X(1), 0)) == exp(-4)\n    assert P(Eq(X(4), 3), Eq(X(2), 3)) == exp(-4)\n    X = PoissonProcess('X', 3)\n    assert P(Eq(X(2), 5) & Eq(X(1), 2)) == Rational(81, 4) * exp(-6)\n    assert P(X(2) <= 3, X(1) >= 1) == 3 * P(Eq(X(1), 0)) + 2 * P(Eq(X(1), 1)) + P(Eq(X(1), 2))\n    assert P(X(2) <= 3, X(1) > 1) == 2 * P(Eq(X(1), 0)) + 1 * P(Eq(X(1), 1))\n    assert P(Eq(X(2), 5) & Eq(X(1), 2)) == P(Eq(X(1), 3)) * P(Eq(X(1), 2))\n    assert P(Eq(X(3), 4), Eq(X(1), 3)) == P(Eq(X(2), 1))\n    assert (2 * X(t) + 3 * X(t)).simplify() == 5 * X(t)\n    assert (2 * X(t) - 3 * X(t)).simplify() == -X(t)\n    assert (2 * (0.25 * X(t))).simplify() == 0.5 * X(t)\n    assert (2 * X(t) * 0.25 * X(t)).simplify() == 0.5 * X(t) ** 2\n    assert (X(t) ** 2 + X(t) ** 3).simplify() == (X(t) + 1) * X(t) ** 2",
            "def test_PoissonProcess():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    X = PoissonProcess('X', 3)\n    assert X.state_space == S.Naturals0\n    assert X.index_set == Interval(0, oo)\n    assert X.lamda == 3\n    (t, d, x, y) = symbols('t d x y', positive=True)\n    assert isinstance(X(t), RandomIndexedSymbol)\n    assert X.distribution(t) == PoissonDistribution(3 * t)\n    with warns_deprecated_sympy():\n        X.distribution(X(t))\n    raises(ValueError, lambda : PoissonProcess('X', -1))\n    raises(NotImplementedError, lambda : X[t])\n    raises(IndexError, lambda : X(-5))\n    assert X.joint_distribution(X(2), X(3)) == JointDistributionHandmade(Lambda((X(2), X(3)), 6 ** X(2) * 9 ** X(3) * exp(-15) / (factorial(X(2)) * factorial(X(3)))))\n    assert X.joint_distribution(4, 6) == JointDistributionHandmade(Lambda((X(4), X(6)), 12 ** X(4) * 18 ** X(6) * exp(-30) / (factorial(X(4)) * factorial(X(6)))))\n    assert P(X(t) < 1) == exp(-3 * t)\n    assert P(Eq(X(t), 0), Contains(t, Interval.Lopen(3, 5))) == exp(-6)\n    res = P(Eq(X(t), 1), Contains(t, Interval.Lopen(3, 4)))\n    assert res == 3 * exp(-3)\n    assert P(Eq(X(t), 1) & Eq(X(d), 1) & Eq(X(x), 1) & Eq(X(y), 1), Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Lopen(1, 2)) & Contains(x, Interval.Lopen(2, 3)) & Contains(y, Interval.Lopen(3, 4))) == res ** 4\n    assert P(Eq(X(t), 2) & Eq(X(d), 3), Contains(t, Interval.Lopen(0, 2)) & Contains(d, Interval.Ropen(2, 4))) == Probability(Eq(X(d), 3) & Eq(X(t), 2), Contains(t, Interval.Lopen(0, 2)) & Contains(d, Interval.Ropen(2, 4)))\n    raises(ValueError, lambda : P(Eq(X(t), 2) & Eq(X(d), 3), Contains(t, Interval.Lopen(0, 4)) & Contains(d, Interval.Lopen(3, oo))))\n    assert P(Eq(X(3), 2)) == 81 * exp(-9) / 2\n    assert P(Eq(X(t), 2), Contains(t, Interval.Lopen(0, 5))) == 225 * exp(-15) / 2\n    res1 = P(X(t) <= 3, Contains(t, Interval.Lopen(0, 5)))\n    res2 = P(X(t) > 3, Contains(t, Interval.Lopen(0, 5)))\n    assert res1 == 691 * exp(-15)\n    assert (res1 + res2).simplify() == 1\n    assert P(Not(Eq(X(t), 2) & (X(d) > 3)), Contains(t, Interval.Ropen(2, 4)) & Contains(d, Interval.Lopen(7, 8))).simplify() == -18 * exp(-6) + 234 * exp(-9) + 1\n    assert P(Eq(X(t), 2) | Ne(X(t), 4), Contains(t, Interval.Ropen(2, 4))) == 1 - 36 * exp(-6)\n    raises(ValueError, lambda : P(X(t) > 2, X(t) + X(d)))\n    assert E(X(t)) == 3 * t\n    assert E(X(t) ** 2 + X(d) * 2 + X(y) ** 3, Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Lopen(1, 2)) & Contains(y, Interval.Ropen(3, 4))) == 75\n    assert E(X(t) ** 2, Contains(t, Interval.Lopen(0, 1))) == 12\n    assert E(x * (X(t) + X(d)) * (X(t) ** 2 + X(d) ** 2), Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Ropen(1, 2))) == Expectation(x * (X(d) + X(t)) * (X(d) ** 2 + X(t) ** 2), Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Ropen(1, 2)))\n    raises(ValueError, lambda : E(X(t) ** 3, Contains(t, Interval.Lopen(1, oo))))\n    assert E((X(t) + X(d)) * (X(t) - X(d)), Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Lopen(1, 2))) == 0\n    assert E(X(2) + x * E(X(5))) == 15 * x + 6\n    assert E(x * X(1) + y) == 3 * x + y\n    assert P(Eq(X(1), 2) & Eq(X(t), 3), Contains(t, Interval.Lopen(1, 2))) == 81 * exp(-6) / 4\n    Y = PoissonProcess('Y', 6)\n    Z = X + Y\n    assert Z.lamda == X.lamda + Y.lamda == 9\n    raises(ValueError, lambda : X + 5)\n    (N, M) = Z.split(4, 5)\n    assert N.lamda == 4\n    assert M.lamda == 5\n    raises(ValueError, lambda : Z.split(3, 2))\n    raises(ValueError, lambda : P(Eq(X(t), 0), Contains(t, Interval.Lopen(1, 3)) & Eq(X(1), 0)))\n    res1 = P(Eq(N(3), N(5)))\n    assert res1 == P(Eq(N(t), 0), Contains(t, Interval(3, 5)))\n    res2 = P(N(3) > N(1))\n    assert res2 == P(N(t) > 0, Contains(t, Interval(1, 3)))\n    assert P(N(3) < N(1)) == 0\n    res3 = P(N(3) <= N(1))\n    assert res3 == P(Eq(N(t), 0), Contains(t, Interval(1, 3)))\n    X = PoissonProcess('X', 10)\n    assert P(Eq(X(S(1) / 3), 3) & Eq(X(1), 10)) == exp(-10) * Rational(8000000000, 11160261)\n    assert P(Eq(X(1), 1), Eq(X(S(1) / 3), 3)) == 0\n    assert P(Eq(X(1), 10), Eq(X(S(1) / 3), 3)) == P(Eq(X(S(2) / 3), 7))\n    X = PoissonProcess('X', 2)\n    assert P(X(S(1) / 2) < 1) == exp(-1)\n    assert P(X(3) < 1, Eq(X(1), 0)) == exp(-4)\n    assert P(Eq(X(4), 3), Eq(X(2), 3)) == exp(-4)\n    X = PoissonProcess('X', 3)\n    assert P(Eq(X(2), 5) & Eq(X(1), 2)) == Rational(81, 4) * exp(-6)\n    assert P(X(2) <= 3, X(1) >= 1) == 3 * P(Eq(X(1), 0)) + 2 * P(Eq(X(1), 1)) + P(Eq(X(1), 2))\n    assert P(X(2) <= 3, X(1) > 1) == 2 * P(Eq(X(1), 0)) + 1 * P(Eq(X(1), 1))\n    assert P(Eq(X(2), 5) & Eq(X(1), 2)) == P(Eq(X(1), 3)) * P(Eq(X(1), 2))\n    assert P(Eq(X(3), 4), Eq(X(1), 3)) == P(Eq(X(2), 1))\n    assert (2 * X(t) + 3 * X(t)).simplify() == 5 * X(t)\n    assert (2 * X(t) - 3 * X(t)).simplify() == -X(t)\n    assert (2 * (0.25 * X(t))).simplify() == 0.5 * X(t)\n    assert (2 * X(t) * 0.25 * X(t)).simplify() == 0.5 * X(t) ** 2\n    assert (X(t) ** 2 + X(t) ** 3).simplify() == (X(t) + 1) * X(t) ** 2",
            "def test_PoissonProcess():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    X = PoissonProcess('X', 3)\n    assert X.state_space == S.Naturals0\n    assert X.index_set == Interval(0, oo)\n    assert X.lamda == 3\n    (t, d, x, y) = symbols('t d x y', positive=True)\n    assert isinstance(X(t), RandomIndexedSymbol)\n    assert X.distribution(t) == PoissonDistribution(3 * t)\n    with warns_deprecated_sympy():\n        X.distribution(X(t))\n    raises(ValueError, lambda : PoissonProcess('X', -1))\n    raises(NotImplementedError, lambda : X[t])\n    raises(IndexError, lambda : X(-5))\n    assert X.joint_distribution(X(2), X(3)) == JointDistributionHandmade(Lambda((X(2), X(3)), 6 ** X(2) * 9 ** X(3) * exp(-15) / (factorial(X(2)) * factorial(X(3)))))\n    assert X.joint_distribution(4, 6) == JointDistributionHandmade(Lambda((X(4), X(6)), 12 ** X(4) * 18 ** X(6) * exp(-30) / (factorial(X(4)) * factorial(X(6)))))\n    assert P(X(t) < 1) == exp(-3 * t)\n    assert P(Eq(X(t), 0), Contains(t, Interval.Lopen(3, 5))) == exp(-6)\n    res = P(Eq(X(t), 1), Contains(t, Interval.Lopen(3, 4)))\n    assert res == 3 * exp(-3)\n    assert P(Eq(X(t), 1) & Eq(X(d), 1) & Eq(X(x), 1) & Eq(X(y), 1), Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Lopen(1, 2)) & Contains(x, Interval.Lopen(2, 3)) & Contains(y, Interval.Lopen(3, 4))) == res ** 4\n    assert P(Eq(X(t), 2) & Eq(X(d), 3), Contains(t, Interval.Lopen(0, 2)) & Contains(d, Interval.Ropen(2, 4))) == Probability(Eq(X(d), 3) & Eq(X(t), 2), Contains(t, Interval.Lopen(0, 2)) & Contains(d, Interval.Ropen(2, 4)))\n    raises(ValueError, lambda : P(Eq(X(t), 2) & Eq(X(d), 3), Contains(t, Interval.Lopen(0, 4)) & Contains(d, Interval.Lopen(3, oo))))\n    assert P(Eq(X(3), 2)) == 81 * exp(-9) / 2\n    assert P(Eq(X(t), 2), Contains(t, Interval.Lopen(0, 5))) == 225 * exp(-15) / 2\n    res1 = P(X(t) <= 3, Contains(t, Interval.Lopen(0, 5)))\n    res2 = P(X(t) > 3, Contains(t, Interval.Lopen(0, 5)))\n    assert res1 == 691 * exp(-15)\n    assert (res1 + res2).simplify() == 1\n    assert P(Not(Eq(X(t), 2) & (X(d) > 3)), Contains(t, Interval.Ropen(2, 4)) & Contains(d, Interval.Lopen(7, 8))).simplify() == -18 * exp(-6) + 234 * exp(-9) + 1\n    assert P(Eq(X(t), 2) | Ne(X(t), 4), Contains(t, Interval.Ropen(2, 4))) == 1 - 36 * exp(-6)\n    raises(ValueError, lambda : P(X(t) > 2, X(t) + X(d)))\n    assert E(X(t)) == 3 * t\n    assert E(X(t) ** 2 + X(d) * 2 + X(y) ** 3, Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Lopen(1, 2)) & Contains(y, Interval.Ropen(3, 4))) == 75\n    assert E(X(t) ** 2, Contains(t, Interval.Lopen(0, 1))) == 12\n    assert E(x * (X(t) + X(d)) * (X(t) ** 2 + X(d) ** 2), Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Ropen(1, 2))) == Expectation(x * (X(d) + X(t)) * (X(d) ** 2 + X(t) ** 2), Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Ropen(1, 2)))\n    raises(ValueError, lambda : E(X(t) ** 3, Contains(t, Interval.Lopen(1, oo))))\n    assert E((X(t) + X(d)) * (X(t) - X(d)), Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Lopen(1, 2))) == 0\n    assert E(X(2) + x * E(X(5))) == 15 * x + 6\n    assert E(x * X(1) + y) == 3 * x + y\n    assert P(Eq(X(1), 2) & Eq(X(t), 3), Contains(t, Interval.Lopen(1, 2))) == 81 * exp(-6) / 4\n    Y = PoissonProcess('Y', 6)\n    Z = X + Y\n    assert Z.lamda == X.lamda + Y.lamda == 9\n    raises(ValueError, lambda : X + 5)\n    (N, M) = Z.split(4, 5)\n    assert N.lamda == 4\n    assert M.lamda == 5\n    raises(ValueError, lambda : Z.split(3, 2))\n    raises(ValueError, lambda : P(Eq(X(t), 0), Contains(t, Interval.Lopen(1, 3)) & Eq(X(1), 0)))\n    res1 = P(Eq(N(3), N(5)))\n    assert res1 == P(Eq(N(t), 0), Contains(t, Interval(3, 5)))\n    res2 = P(N(3) > N(1))\n    assert res2 == P(N(t) > 0, Contains(t, Interval(1, 3)))\n    assert P(N(3) < N(1)) == 0\n    res3 = P(N(3) <= N(1))\n    assert res3 == P(Eq(N(t), 0), Contains(t, Interval(1, 3)))\n    X = PoissonProcess('X', 10)\n    assert P(Eq(X(S(1) / 3), 3) & Eq(X(1), 10)) == exp(-10) * Rational(8000000000, 11160261)\n    assert P(Eq(X(1), 1), Eq(X(S(1) / 3), 3)) == 0\n    assert P(Eq(X(1), 10), Eq(X(S(1) / 3), 3)) == P(Eq(X(S(2) / 3), 7))\n    X = PoissonProcess('X', 2)\n    assert P(X(S(1) / 2) < 1) == exp(-1)\n    assert P(X(3) < 1, Eq(X(1), 0)) == exp(-4)\n    assert P(Eq(X(4), 3), Eq(X(2), 3)) == exp(-4)\n    X = PoissonProcess('X', 3)\n    assert P(Eq(X(2), 5) & Eq(X(1), 2)) == Rational(81, 4) * exp(-6)\n    assert P(X(2) <= 3, X(1) >= 1) == 3 * P(Eq(X(1), 0)) + 2 * P(Eq(X(1), 1)) + P(Eq(X(1), 2))\n    assert P(X(2) <= 3, X(1) > 1) == 2 * P(Eq(X(1), 0)) + 1 * P(Eq(X(1), 1))\n    assert P(Eq(X(2), 5) & Eq(X(1), 2)) == P(Eq(X(1), 3)) * P(Eq(X(1), 2))\n    assert P(Eq(X(3), 4), Eq(X(1), 3)) == P(Eq(X(2), 1))\n    assert (2 * X(t) + 3 * X(t)).simplify() == 5 * X(t)\n    assert (2 * X(t) - 3 * X(t)).simplify() == -X(t)\n    assert (2 * (0.25 * X(t))).simplify() == 0.5 * X(t)\n    assert (2 * X(t) * 0.25 * X(t)).simplify() == 0.5 * X(t) ** 2\n    assert (X(t) ** 2 + X(t) ** 3).simplify() == (X(t) + 1) * X(t) ** 2",
            "def test_PoissonProcess():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    X = PoissonProcess('X', 3)\n    assert X.state_space == S.Naturals0\n    assert X.index_set == Interval(0, oo)\n    assert X.lamda == 3\n    (t, d, x, y) = symbols('t d x y', positive=True)\n    assert isinstance(X(t), RandomIndexedSymbol)\n    assert X.distribution(t) == PoissonDistribution(3 * t)\n    with warns_deprecated_sympy():\n        X.distribution(X(t))\n    raises(ValueError, lambda : PoissonProcess('X', -1))\n    raises(NotImplementedError, lambda : X[t])\n    raises(IndexError, lambda : X(-5))\n    assert X.joint_distribution(X(2), X(3)) == JointDistributionHandmade(Lambda((X(2), X(3)), 6 ** X(2) * 9 ** X(3) * exp(-15) / (factorial(X(2)) * factorial(X(3)))))\n    assert X.joint_distribution(4, 6) == JointDistributionHandmade(Lambda((X(4), X(6)), 12 ** X(4) * 18 ** X(6) * exp(-30) / (factorial(X(4)) * factorial(X(6)))))\n    assert P(X(t) < 1) == exp(-3 * t)\n    assert P(Eq(X(t), 0), Contains(t, Interval.Lopen(3, 5))) == exp(-6)\n    res = P(Eq(X(t), 1), Contains(t, Interval.Lopen(3, 4)))\n    assert res == 3 * exp(-3)\n    assert P(Eq(X(t), 1) & Eq(X(d), 1) & Eq(X(x), 1) & Eq(X(y), 1), Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Lopen(1, 2)) & Contains(x, Interval.Lopen(2, 3)) & Contains(y, Interval.Lopen(3, 4))) == res ** 4\n    assert P(Eq(X(t), 2) & Eq(X(d), 3), Contains(t, Interval.Lopen(0, 2)) & Contains(d, Interval.Ropen(2, 4))) == Probability(Eq(X(d), 3) & Eq(X(t), 2), Contains(t, Interval.Lopen(0, 2)) & Contains(d, Interval.Ropen(2, 4)))\n    raises(ValueError, lambda : P(Eq(X(t), 2) & Eq(X(d), 3), Contains(t, Interval.Lopen(0, 4)) & Contains(d, Interval.Lopen(3, oo))))\n    assert P(Eq(X(3), 2)) == 81 * exp(-9) / 2\n    assert P(Eq(X(t), 2), Contains(t, Interval.Lopen(0, 5))) == 225 * exp(-15) / 2\n    res1 = P(X(t) <= 3, Contains(t, Interval.Lopen(0, 5)))\n    res2 = P(X(t) > 3, Contains(t, Interval.Lopen(0, 5)))\n    assert res1 == 691 * exp(-15)\n    assert (res1 + res2).simplify() == 1\n    assert P(Not(Eq(X(t), 2) & (X(d) > 3)), Contains(t, Interval.Ropen(2, 4)) & Contains(d, Interval.Lopen(7, 8))).simplify() == -18 * exp(-6) + 234 * exp(-9) + 1\n    assert P(Eq(X(t), 2) | Ne(X(t), 4), Contains(t, Interval.Ropen(2, 4))) == 1 - 36 * exp(-6)\n    raises(ValueError, lambda : P(X(t) > 2, X(t) + X(d)))\n    assert E(X(t)) == 3 * t\n    assert E(X(t) ** 2 + X(d) * 2 + X(y) ** 3, Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Lopen(1, 2)) & Contains(y, Interval.Ropen(3, 4))) == 75\n    assert E(X(t) ** 2, Contains(t, Interval.Lopen(0, 1))) == 12\n    assert E(x * (X(t) + X(d)) * (X(t) ** 2 + X(d) ** 2), Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Ropen(1, 2))) == Expectation(x * (X(d) + X(t)) * (X(d) ** 2 + X(t) ** 2), Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Ropen(1, 2)))\n    raises(ValueError, lambda : E(X(t) ** 3, Contains(t, Interval.Lopen(1, oo))))\n    assert E((X(t) + X(d)) * (X(t) - X(d)), Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Lopen(1, 2))) == 0\n    assert E(X(2) + x * E(X(5))) == 15 * x + 6\n    assert E(x * X(1) + y) == 3 * x + y\n    assert P(Eq(X(1), 2) & Eq(X(t), 3), Contains(t, Interval.Lopen(1, 2))) == 81 * exp(-6) / 4\n    Y = PoissonProcess('Y', 6)\n    Z = X + Y\n    assert Z.lamda == X.lamda + Y.lamda == 9\n    raises(ValueError, lambda : X + 5)\n    (N, M) = Z.split(4, 5)\n    assert N.lamda == 4\n    assert M.lamda == 5\n    raises(ValueError, lambda : Z.split(3, 2))\n    raises(ValueError, lambda : P(Eq(X(t), 0), Contains(t, Interval.Lopen(1, 3)) & Eq(X(1), 0)))\n    res1 = P(Eq(N(3), N(5)))\n    assert res1 == P(Eq(N(t), 0), Contains(t, Interval(3, 5)))\n    res2 = P(N(3) > N(1))\n    assert res2 == P(N(t) > 0, Contains(t, Interval(1, 3)))\n    assert P(N(3) < N(1)) == 0\n    res3 = P(N(3) <= N(1))\n    assert res3 == P(Eq(N(t), 0), Contains(t, Interval(1, 3)))\n    X = PoissonProcess('X', 10)\n    assert P(Eq(X(S(1) / 3), 3) & Eq(X(1), 10)) == exp(-10) * Rational(8000000000, 11160261)\n    assert P(Eq(X(1), 1), Eq(X(S(1) / 3), 3)) == 0\n    assert P(Eq(X(1), 10), Eq(X(S(1) / 3), 3)) == P(Eq(X(S(2) / 3), 7))\n    X = PoissonProcess('X', 2)\n    assert P(X(S(1) / 2) < 1) == exp(-1)\n    assert P(X(3) < 1, Eq(X(1), 0)) == exp(-4)\n    assert P(Eq(X(4), 3), Eq(X(2), 3)) == exp(-4)\n    X = PoissonProcess('X', 3)\n    assert P(Eq(X(2), 5) & Eq(X(1), 2)) == Rational(81, 4) * exp(-6)\n    assert P(X(2) <= 3, X(1) >= 1) == 3 * P(Eq(X(1), 0)) + 2 * P(Eq(X(1), 1)) + P(Eq(X(1), 2))\n    assert P(X(2) <= 3, X(1) > 1) == 2 * P(Eq(X(1), 0)) + 1 * P(Eq(X(1), 1))\n    assert P(Eq(X(2), 5) & Eq(X(1), 2)) == P(Eq(X(1), 3)) * P(Eq(X(1), 2))\n    assert P(Eq(X(3), 4), Eq(X(1), 3)) == P(Eq(X(2), 1))\n    assert (2 * X(t) + 3 * X(t)).simplify() == 5 * X(t)\n    assert (2 * X(t) - 3 * X(t)).simplify() == -X(t)\n    assert (2 * (0.25 * X(t))).simplify() == 0.5 * X(t)\n    assert (2 * X(t) * 0.25 * X(t)).simplify() == 0.5 * X(t) ** 2\n    assert (X(t) ** 2 + X(t) ** 3).simplify() == (X(t) + 1) * X(t) ** 2",
            "def test_PoissonProcess():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    X = PoissonProcess('X', 3)\n    assert X.state_space == S.Naturals0\n    assert X.index_set == Interval(0, oo)\n    assert X.lamda == 3\n    (t, d, x, y) = symbols('t d x y', positive=True)\n    assert isinstance(X(t), RandomIndexedSymbol)\n    assert X.distribution(t) == PoissonDistribution(3 * t)\n    with warns_deprecated_sympy():\n        X.distribution(X(t))\n    raises(ValueError, lambda : PoissonProcess('X', -1))\n    raises(NotImplementedError, lambda : X[t])\n    raises(IndexError, lambda : X(-5))\n    assert X.joint_distribution(X(2), X(3)) == JointDistributionHandmade(Lambda((X(2), X(3)), 6 ** X(2) * 9 ** X(3) * exp(-15) / (factorial(X(2)) * factorial(X(3)))))\n    assert X.joint_distribution(4, 6) == JointDistributionHandmade(Lambda((X(4), X(6)), 12 ** X(4) * 18 ** X(6) * exp(-30) / (factorial(X(4)) * factorial(X(6)))))\n    assert P(X(t) < 1) == exp(-3 * t)\n    assert P(Eq(X(t), 0), Contains(t, Interval.Lopen(3, 5))) == exp(-6)\n    res = P(Eq(X(t), 1), Contains(t, Interval.Lopen(3, 4)))\n    assert res == 3 * exp(-3)\n    assert P(Eq(X(t), 1) & Eq(X(d), 1) & Eq(X(x), 1) & Eq(X(y), 1), Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Lopen(1, 2)) & Contains(x, Interval.Lopen(2, 3)) & Contains(y, Interval.Lopen(3, 4))) == res ** 4\n    assert P(Eq(X(t), 2) & Eq(X(d), 3), Contains(t, Interval.Lopen(0, 2)) & Contains(d, Interval.Ropen(2, 4))) == Probability(Eq(X(d), 3) & Eq(X(t), 2), Contains(t, Interval.Lopen(0, 2)) & Contains(d, Interval.Ropen(2, 4)))\n    raises(ValueError, lambda : P(Eq(X(t), 2) & Eq(X(d), 3), Contains(t, Interval.Lopen(0, 4)) & Contains(d, Interval.Lopen(3, oo))))\n    assert P(Eq(X(3), 2)) == 81 * exp(-9) / 2\n    assert P(Eq(X(t), 2), Contains(t, Interval.Lopen(0, 5))) == 225 * exp(-15) / 2\n    res1 = P(X(t) <= 3, Contains(t, Interval.Lopen(0, 5)))\n    res2 = P(X(t) > 3, Contains(t, Interval.Lopen(0, 5)))\n    assert res1 == 691 * exp(-15)\n    assert (res1 + res2).simplify() == 1\n    assert P(Not(Eq(X(t), 2) & (X(d) > 3)), Contains(t, Interval.Ropen(2, 4)) & Contains(d, Interval.Lopen(7, 8))).simplify() == -18 * exp(-6) + 234 * exp(-9) + 1\n    assert P(Eq(X(t), 2) | Ne(X(t), 4), Contains(t, Interval.Ropen(2, 4))) == 1 - 36 * exp(-6)\n    raises(ValueError, lambda : P(X(t) > 2, X(t) + X(d)))\n    assert E(X(t)) == 3 * t\n    assert E(X(t) ** 2 + X(d) * 2 + X(y) ** 3, Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Lopen(1, 2)) & Contains(y, Interval.Ropen(3, 4))) == 75\n    assert E(X(t) ** 2, Contains(t, Interval.Lopen(0, 1))) == 12\n    assert E(x * (X(t) + X(d)) * (X(t) ** 2 + X(d) ** 2), Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Ropen(1, 2))) == Expectation(x * (X(d) + X(t)) * (X(d) ** 2 + X(t) ** 2), Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Ropen(1, 2)))\n    raises(ValueError, lambda : E(X(t) ** 3, Contains(t, Interval.Lopen(1, oo))))\n    assert E((X(t) + X(d)) * (X(t) - X(d)), Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Lopen(1, 2))) == 0\n    assert E(X(2) + x * E(X(5))) == 15 * x + 6\n    assert E(x * X(1) + y) == 3 * x + y\n    assert P(Eq(X(1), 2) & Eq(X(t), 3), Contains(t, Interval.Lopen(1, 2))) == 81 * exp(-6) / 4\n    Y = PoissonProcess('Y', 6)\n    Z = X + Y\n    assert Z.lamda == X.lamda + Y.lamda == 9\n    raises(ValueError, lambda : X + 5)\n    (N, M) = Z.split(4, 5)\n    assert N.lamda == 4\n    assert M.lamda == 5\n    raises(ValueError, lambda : Z.split(3, 2))\n    raises(ValueError, lambda : P(Eq(X(t), 0), Contains(t, Interval.Lopen(1, 3)) & Eq(X(1), 0)))\n    res1 = P(Eq(N(3), N(5)))\n    assert res1 == P(Eq(N(t), 0), Contains(t, Interval(3, 5)))\n    res2 = P(N(3) > N(1))\n    assert res2 == P(N(t) > 0, Contains(t, Interval(1, 3)))\n    assert P(N(3) < N(1)) == 0\n    res3 = P(N(3) <= N(1))\n    assert res3 == P(Eq(N(t), 0), Contains(t, Interval(1, 3)))\n    X = PoissonProcess('X', 10)\n    assert P(Eq(X(S(1) / 3), 3) & Eq(X(1), 10)) == exp(-10) * Rational(8000000000, 11160261)\n    assert P(Eq(X(1), 1), Eq(X(S(1) / 3), 3)) == 0\n    assert P(Eq(X(1), 10), Eq(X(S(1) / 3), 3)) == P(Eq(X(S(2) / 3), 7))\n    X = PoissonProcess('X', 2)\n    assert P(X(S(1) / 2) < 1) == exp(-1)\n    assert P(X(3) < 1, Eq(X(1), 0)) == exp(-4)\n    assert P(Eq(X(4), 3), Eq(X(2), 3)) == exp(-4)\n    X = PoissonProcess('X', 3)\n    assert P(Eq(X(2), 5) & Eq(X(1), 2)) == Rational(81, 4) * exp(-6)\n    assert P(X(2) <= 3, X(1) >= 1) == 3 * P(Eq(X(1), 0)) + 2 * P(Eq(X(1), 1)) + P(Eq(X(1), 2))\n    assert P(X(2) <= 3, X(1) > 1) == 2 * P(Eq(X(1), 0)) + 1 * P(Eq(X(1), 1))\n    assert P(Eq(X(2), 5) & Eq(X(1), 2)) == P(Eq(X(1), 3)) * P(Eq(X(1), 2))\n    assert P(Eq(X(3), 4), Eq(X(1), 3)) == P(Eq(X(2), 1))\n    assert (2 * X(t) + 3 * X(t)).simplify() == 5 * X(t)\n    assert (2 * X(t) - 3 * X(t)).simplify() == -X(t)\n    assert (2 * (0.25 * X(t))).simplify() == 0.5 * X(t)\n    assert (2 * X(t) * 0.25 * X(t)).simplify() == 0.5 * X(t) ** 2\n    assert (X(t) ** 2 + X(t) ** 3).simplify() == (X(t) + 1) * X(t) ** 2"
        ]
    },
    {
        "func_name": "test_WienerProcess",
        "original": "def test_WienerProcess():\n    X = WienerProcess('X')\n    assert X.state_space == S.Reals\n    assert X.index_set == Interval(0, oo)\n    (t, d, x, y) = symbols('t d x y', positive=True)\n    assert isinstance(X(t), RandomIndexedSymbol)\n    assert X.distribution(t) == NormalDistribution(0, sqrt(t))\n    with warns_deprecated_sympy():\n        X.distribution(X(t))\n    raises(ValueError, lambda : PoissonProcess('X', -1))\n    raises(NotImplementedError, lambda : X[t])\n    raises(IndexError, lambda : X(-2))\n    assert X.joint_distribution(X(2), X(3)) == JointDistributionHandmade(Lambda((X(2), X(3)), sqrt(6) * exp(-X(2) ** 2 / 4) * exp(-X(3) ** 2 / 6) / (12 * pi)))\n    assert X.joint_distribution(4, 6) == JointDistributionHandmade(Lambda((X(4), X(6)), sqrt(6) * exp(-X(4) ** 2 / 8) * exp(-X(6) ** 2 / 12) / (24 * pi)))\n    assert P(X(t) < 3).simplify() == erf(3 * sqrt(2) / (2 * sqrt(t))) / 2 + S(1) / 2\n    assert P(X(t) > 2, Contains(t, Interval.Lopen(3, 7))).simplify() == S(1) / 2 - erf(sqrt(2) / 2) / 2\n    assert P((X(t) > 4) & (X(d) > 3) & (X(x) > 2) & (X(y) > 1), Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Lopen(1, 2)) & Contains(x, Interval.Lopen(2, 3)) & Contains(y, Interval.Lopen(3, 4))).simplify() == (1 - erf(sqrt(2) / 2)) * (1 - erf(sqrt(2))) * (1 - erf(3 * sqrt(2) / 2)) * (1 - erf(2 * sqrt(2))) / 16\n    assert P((X(t) < 2) & (X(d) > 3), Contains(t, Interval.Lopen(0, 2)) & Contains(d, Interval.Ropen(2, 4))) == Probability((X(d) > 3) & (X(t) < 2), Contains(d, Interval.Ropen(2, 4)) & Contains(t, Interval.Lopen(0, 2)))\n    assert str(P(Not((X(t) < 5) & (X(d) > 3)), Contains(t, Interval.Ropen(2, 4)) & Contains(d, Interval.Lopen(7, 8))).simplify()) == '-(1 - erf(3*sqrt(2)/2))*(2 - erfc(5/2))/4 + 1'\n    assert E(X(t)) == 0\n    assert E(x * (X(t) + X(d)) * (X(t) ** 2 + X(d) ** 2), Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Ropen(1, 2))) == Expectation(x * (X(d) + X(t)) * (X(d) ** 2 + X(t) ** 2), Contains(d, Interval.Ropen(1, 2)) & Contains(t, Interval.Lopen(0, 1)))\n    assert E(X(t) + x * E(X(3))) == 0\n    assert (2 * X(t) + 3 * X(t)).simplify() == 5 * X(t)\n    assert (2 * X(t) - 3 * X(t)).simplify() == -X(t)\n    assert (2 * (0.25 * X(t))).simplify() == 0.5 * X(t)\n    assert (2 * X(t) * 0.25 * X(t)).simplify() == 0.5 * X(t) ** 2\n    assert (X(t) ** 2 + X(t) ** 3).simplify() == (X(t) + 1) * X(t) ** 2",
        "mutated": [
            "def test_WienerProcess():\n    if False:\n        i = 10\n    X = WienerProcess('X')\n    assert X.state_space == S.Reals\n    assert X.index_set == Interval(0, oo)\n    (t, d, x, y) = symbols('t d x y', positive=True)\n    assert isinstance(X(t), RandomIndexedSymbol)\n    assert X.distribution(t) == NormalDistribution(0, sqrt(t))\n    with warns_deprecated_sympy():\n        X.distribution(X(t))\n    raises(ValueError, lambda : PoissonProcess('X', -1))\n    raises(NotImplementedError, lambda : X[t])\n    raises(IndexError, lambda : X(-2))\n    assert X.joint_distribution(X(2), X(3)) == JointDistributionHandmade(Lambda((X(2), X(3)), sqrt(6) * exp(-X(2) ** 2 / 4) * exp(-X(3) ** 2 / 6) / (12 * pi)))\n    assert X.joint_distribution(4, 6) == JointDistributionHandmade(Lambda((X(4), X(6)), sqrt(6) * exp(-X(4) ** 2 / 8) * exp(-X(6) ** 2 / 12) / (24 * pi)))\n    assert P(X(t) < 3).simplify() == erf(3 * sqrt(2) / (2 * sqrt(t))) / 2 + S(1) / 2\n    assert P(X(t) > 2, Contains(t, Interval.Lopen(3, 7))).simplify() == S(1) / 2 - erf(sqrt(2) / 2) / 2\n    assert P((X(t) > 4) & (X(d) > 3) & (X(x) > 2) & (X(y) > 1), Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Lopen(1, 2)) & Contains(x, Interval.Lopen(2, 3)) & Contains(y, Interval.Lopen(3, 4))).simplify() == (1 - erf(sqrt(2) / 2)) * (1 - erf(sqrt(2))) * (1 - erf(3 * sqrt(2) / 2)) * (1 - erf(2 * sqrt(2))) / 16\n    assert P((X(t) < 2) & (X(d) > 3), Contains(t, Interval.Lopen(0, 2)) & Contains(d, Interval.Ropen(2, 4))) == Probability((X(d) > 3) & (X(t) < 2), Contains(d, Interval.Ropen(2, 4)) & Contains(t, Interval.Lopen(0, 2)))\n    assert str(P(Not((X(t) < 5) & (X(d) > 3)), Contains(t, Interval.Ropen(2, 4)) & Contains(d, Interval.Lopen(7, 8))).simplify()) == '-(1 - erf(3*sqrt(2)/2))*(2 - erfc(5/2))/4 + 1'\n    assert E(X(t)) == 0\n    assert E(x * (X(t) + X(d)) * (X(t) ** 2 + X(d) ** 2), Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Ropen(1, 2))) == Expectation(x * (X(d) + X(t)) * (X(d) ** 2 + X(t) ** 2), Contains(d, Interval.Ropen(1, 2)) & Contains(t, Interval.Lopen(0, 1)))\n    assert E(X(t) + x * E(X(3))) == 0\n    assert (2 * X(t) + 3 * X(t)).simplify() == 5 * X(t)\n    assert (2 * X(t) - 3 * X(t)).simplify() == -X(t)\n    assert (2 * (0.25 * X(t))).simplify() == 0.5 * X(t)\n    assert (2 * X(t) * 0.25 * X(t)).simplify() == 0.5 * X(t) ** 2\n    assert (X(t) ** 2 + X(t) ** 3).simplify() == (X(t) + 1) * X(t) ** 2",
            "def test_WienerProcess():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    X = WienerProcess('X')\n    assert X.state_space == S.Reals\n    assert X.index_set == Interval(0, oo)\n    (t, d, x, y) = symbols('t d x y', positive=True)\n    assert isinstance(X(t), RandomIndexedSymbol)\n    assert X.distribution(t) == NormalDistribution(0, sqrt(t))\n    with warns_deprecated_sympy():\n        X.distribution(X(t))\n    raises(ValueError, lambda : PoissonProcess('X', -1))\n    raises(NotImplementedError, lambda : X[t])\n    raises(IndexError, lambda : X(-2))\n    assert X.joint_distribution(X(2), X(3)) == JointDistributionHandmade(Lambda((X(2), X(3)), sqrt(6) * exp(-X(2) ** 2 / 4) * exp(-X(3) ** 2 / 6) / (12 * pi)))\n    assert X.joint_distribution(4, 6) == JointDistributionHandmade(Lambda((X(4), X(6)), sqrt(6) * exp(-X(4) ** 2 / 8) * exp(-X(6) ** 2 / 12) / (24 * pi)))\n    assert P(X(t) < 3).simplify() == erf(3 * sqrt(2) / (2 * sqrt(t))) / 2 + S(1) / 2\n    assert P(X(t) > 2, Contains(t, Interval.Lopen(3, 7))).simplify() == S(1) / 2 - erf(sqrt(2) / 2) / 2\n    assert P((X(t) > 4) & (X(d) > 3) & (X(x) > 2) & (X(y) > 1), Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Lopen(1, 2)) & Contains(x, Interval.Lopen(2, 3)) & Contains(y, Interval.Lopen(3, 4))).simplify() == (1 - erf(sqrt(2) / 2)) * (1 - erf(sqrt(2))) * (1 - erf(3 * sqrt(2) / 2)) * (1 - erf(2 * sqrt(2))) / 16\n    assert P((X(t) < 2) & (X(d) > 3), Contains(t, Interval.Lopen(0, 2)) & Contains(d, Interval.Ropen(2, 4))) == Probability((X(d) > 3) & (X(t) < 2), Contains(d, Interval.Ropen(2, 4)) & Contains(t, Interval.Lopen(0, 2)))\n    assert str(P(Not((X(t) < 5) & (X(d) > 3)), Contains(t, Interval.Ropen(2, 4)) & Contains(d, Interval.Lopen(7, 8))).simplify()) == '-(1 - erf(3*sqrt(2)/2))*(2 - erfc(5/2))/4 + 1'\n    assert E(X(t)) == 0\n    assert E(x * (X(t) + X(d)) * (X(t) ** 2 + X(d) ** 2), Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Ropen(1, 2))) == Expectation(x * (X(d) + X(t)) * (X(d) ** 2 + X(t) ** 2), Contains(d, Interval.Ropen(1, 2)) & Contains(t, Interval.Lopen(0, 1)))\n    assert E(X(t) + x * E(X(3))) == 0\n    assert (2 * X(t) + 3 * X(t)).simplify() == 5 * X(t)\n    assert (2 * X(t) - 3 * X(t)).simplify() == -X(t)\n    assert (2 * (0.25 * X(t))).simplify() == 0.5 * X(t)\n    assert (2 * X(t) * 0.25 * X(t)).simplify() == 0.5 * X(t) ** 2\n    assert (X(t) ** 2 + X(t) ** 3).simplify() == (X(t) + 1) * X(t) ** 2",
            "def test_WienerProcess():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    X = WienerProcess('X')\n    assert X.state_space == S.Reals\n    assert X.index_set == Interval(0, oo)\n    (t, d, x, y) = symbols('t d x y', positive=True)\n    assert isinstance(X(t), RandomIndexedSymbol)\n    assert X.distribution(t) == NormalDistribution(0, sqrt(t))\n    with warns_deprecated_sympy():\n        X.distribution(X(t))\n    raises(ValueError, lambda : PoissonProcess('X', -1))\n    raises(NotImplementedError, lambda : X[t])\n    raises(IndexError, lambda : X(-2))\n    assert X.joint_distribution(X(2), X(3)) == JointDistributionHandmade(Lambda((X(2), X(3)), sqrt(6) * exp(-X(2) ** 2 / 4) * exp(-X(3) ** 2 / 6) / (12 * pi)))\n    assert X.joint_distribution(4, 6) == JointDistributionHandmade(Lambda((X(4), X(6)), sqrt(6) * exp(-X(4) ** 2 / 8) * exp(-X(6) ** 2 / 12) / (24 * pi)))\n    assert P(X(t) < 3).simplify() == erf(3 * sqrt(2) / (2 * sqrt(t))) / 2 + S(1) / 2\n    assert P(X(t) > 2, Contains(t, Interval.Lopen(3, 7))).simplify() == S(1) / 2 - erf(sqrt(2) / 2) / 2\n    assert P((X(t) > 4) & (X(d) > 3) & (X(x) > 2) & (X(y) > 1), Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Lopen(1, 2)) & Contains(x, Interval.Lopen(2, 3)) & Contains(y, Interval.Lopen(3, 4))).simplify() == (1 - erf(sqrt(2) / 2)) * (1 - erf(sqrt(2))) * (1 - erf(3 * sqrt(2) / 2)) * (1 - erf(2 * sqrt(2))) / 16\n    assert P((X(t) < 2) & (X(d) > 3), Contains(t, Interval.Lopen(0, 2)) & Contains(d, Interval.Ropen(2, 4))) == Probability((X(d) > 3) & (X(t) < 2), Contains(d, Interval.Ropen(2, 4)) & Contains(t, Interval.Lopen(0, 2)))\n    assert str(P(Not((X(t) < 5) & (X(d) > 3)), Contains(t, Interval.Ropen(2, 4)) & Contains(d, Interval.Lopen(7, 8))).simplify()) == '-(1 - erf(3*sqrt(2)/2))*(2 - erfc(5/2))/4 + 1'\n    assert E(X(t)) == 0\n    assert E(x * (X(t) + X(d)) * (X(t) ** 2 + X(d) ** 2), Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Ropen(1, 2))) == Expectation(x * (X(d) + X(t)) * (X(d) ** 2 + X(t) ** 2), Contains(d, Interval.Ropen(1, 2)) & Contains(t, Interval.Lopen(0, 1)))\n    assert E(X(t) + x * E(X(3))) == 0\n    assert (2 * X(t) + 3 * X(t)).simplify() == 5 * X(t)\n    assert (2 * X(t) - 3 * X(t)).simplify() == -X(t)\n    assert (2 * (0.25 * X(t))).simplify() == 0.5 * X(t)\n    assert (2 * X(t) * 0.25 * X(t)).simplify() == 0.5 * X(t) ** 2\n    assert (X(t) ** 2 + X(t) ** 3).simplify() == (X(t) + 1) * X(t) ** 2",
            "def test_WienerProcess():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    X = WienerProcess('X')\n    assert X.state_space == S.Reals\n    assert X.index_set == Interval(0, oo)\n    (t, d, x, y) = symbols('t d x y', positive=True)\n    assert isinstance(X(t), RandomIndexedSymbol)\n    assert X.distribution(t) == NormalDistribution(0, sqrt(t))\n    with warns_deprecated_sympy():\n        X.distribution(X(t))\n    raises(ValueError, lambda : PoissonProcess('X', -1))\n    raises(NotImplementedError, lambda : X[t])\n    raises(IndexError, lambda : X(-2))\n    assert X.joint_distribution(X(2), X(3)) == JointDistributionHandmade(Lambda((X(2), X(3)), sqrt(6) * exp(-X(2) ** 2 / 4) * exp(-X(3) ** 2 / 6) / (12 * pi)))\n    assert X.joint_distribution(4, 6) == JointDistributionHandmade(Lambda((X(4), X(6)), sqrt(6) * exp(-X(4) ** 2 / 8) * exp(-X(6) ** 2 / 12) / (24 * pi)))\n    assert P(X(t) < 3).simplify() == erf(3 * sqrt(2) / (2 * sqrt(t))) / 2 + S(1) / 2\n    assert P(X(t) > 2, Contains(t, Interval.Lopen(3, 7))).simplify() == S(1) / 2 - erf(sqrt(2) / 2) / 2\n    assert P((X(t) > 4) & (X(d) > 3) & (X(x) > 2) & (X(y) > 1), Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Lopen(1, 2)) & Contains(x, Interval.Lopen(2, 3)) & Contains(y, Interval.Lopen(3, 4))).simplify() == (1 - erf(sqrt(2) / 2)) * (1 - erf(sqrt(2))) * (1 - erf(3 * sqrt(2) / 2)) * (1 - erf(2 * sqrt(2))) / 16\n    assert P((X(t) < 2) & (X(d) > 3), Contains(t, Interval.Lopen(0, 2)) & Contains(d, Interval.Ropen(2, 4))) == Probability((X(d) > 3) & (X(t) < 2), Contains(d, Interval.Ropen(2, 4)) & Contains(t, Interval.Lopen(0, 2)))\n    assert str(P(Not((X(t) < 5) & (X(d) > 3)), Contains(t, Interval.Ropen(2, 4)) & Contains(d, Interval.Lopen(7, 8))).simplify()) == '-(1 - erf(3*sqrt(2)/2))*(2 - erfc(5/2))/4 + 1'\n    assert E(X(t)) == 0\n    assert E(x * (X(t) + X(d)) * (X(t) ** 2 + X(d) ** 2), Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Ropen(1, 2))) == Expectation(x * (X(d) + X(t)) * (X(d) ** 2 + X(t) ** 2), Contains(d, Interval.Ropen(1, 2)) & Contains(t, Interval.Lopen(0, 1)))\n    assert E(X(t) + x * E(X(3))) == 0\n    assert (2 * X(t) + 3 * X(t)).simplify() == 5 * X(t)\n    assert (2 * X(t) - 3 * X(t)).simplify() == -X(t)\n    assert (2 * (0.25 * X(t))).simplify() == 0.5 * X(t)\n    assert (2 * X(t) * 0.25 * X(t)).simplify() == 0.5 * X(t) ** 2\n    assert (X(t) ** 2 + X(t) ** 3).simplify() == (X(t) + 1) * X(t) ** 2",
            "def test_WienerProcess():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    X = WienerProcess('X')\n    assert X.state_space == S.Reals\n    assert X.index_set == Interval(0, oo)\n    (t, d, x, y) = symbols('t d x y', positive=True)\n    assert isinstance(X(t), RandomIndexedSymbol)\n    assert X.distribution(t) == NormalDistribution(0, sqrt(t))\n    with warns_deprecated_sympy():\n        X.distribution(X(t))\n    raises(ValueError, lambda : PoissonProcess('X', -1))\n    raises(NotImplementedError, lambda : X[t])\n    raises(IndexError, lambda : X(-2))\n    assert X.joint_distribution(X(2), X(3)) == JointDistributionHandmade(Lambda((X(2), X(3)), sqrt(6) * exp(-X(2) ** 2 / 4) * exp(-X(3) ** 2 / 6) / (12 * pi)))\n    assert X.joint_distribution(4, 6) == JointDistributionHandmade(Lambda((X(4), X(6)), sqrt(6) * exp(-X(4) ** 2 / 8) * exp(-X(6) ** 2 / 12) / (24 * pi)))\n    assert P(X(t) < 3).simplify() == erf(3 * sqrt(2) / (2 * sqrt(t))) / 2 + S(1) / 2\n    assert P(X(t) > 2, Contains(t, Interval.Lopen(3, 7))).simplify() == S(1) / 2 - erf(sqrt(2) / 2) / 2\n    assert P((X(t) > 4) & (X(d) > 3) & (X(x) > 2) & (X(y) > 1), Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Lopen(1, 2)) & Contains(x, Interval.Lopen(2, 3)) & Contains(y, Interval.Lopen(3, 4))).simplify() == (1 - erf(sqrt(2) / 2)) * (1 - erf(sqrt(2))) * (1 - erf(3 * sqrt(2) / 2)) * (1 - erf(2 * sqrt(2))) / 16\n    assert P((X(t) < 2) & (X(d) > 3), Contains(t, Interval.Lopen(0, 2)) & Contains(d, Interval.Ropen(2, 4))) == Probability((X(d) > 3) & (X(t) < 2), Contains(d, Interval.Ropen(2, 4)) & Contains(t, Interval.Lopen(0, 2)))\n    assert str(P(Not((X(t) < 5) & (X(d) > 3)), Contains(t, Interval.Ropen(2, 4)) & Contains(d, Interval.Lopen(7, 8))).simplify()) == '-(1 - erf(3*sqrt(2)/2))*(2 - erfc(5/2))/4 + 1'\n    assert E(X(t)) == 0\n    assert E(x * (X(t) + X(d)) * (X(t) ** 2 + X(d) ** 2), Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Ropen(1, 2))) == Expectation(x * (X(d) + X(t)) * (X(d) ** 2 + X(t) ** 2), Contains(d, Interval.Ropen(1, 2)) & Contains(t, Interval.Lopen(0, 1)))\n    assert E(X(t) + x * E(X(3))) == 0\n    assert (2 * X(t) + 3 * X(t)).simplify() == 5 * X(t)\n    assert (2 * X(t) - 3 * X(t)).simplify() == -X(t)\n    assert (2 * (0.25 * X(t))).simplify() == 0.5 * X(t)\n    assert (2 * X(t) * 0.25 * X(t)).simplify() == 0.5 * X(t) ** 2\n    assert (X(t) ** 2 + X(t) ** 3).simplify() == (X(t) + 1) * X(t) ** 2"
        ]
    },
    {
        "func_name": "test_GammaProcess_symbolic",
        "original": "def test_GammaProcess_symbolic():\n    (t, d, x, y, g, l) = symbols('t d x y g l', positive=True)\n    X = GammaProcess('X', l, g)\n    raises(NotImplementedError, lambda : X[t])\n    raises(IndexError, lambda : X(-1))\n    assert isinstance(X(t), RandomIndexedSymbol)\n    assert X.state_space == Interval(0, oo)\n    assert X.distribution(t) == GammaDistribution(g * t, 1 / l)\n    with warns_deprecated_sympy():\n        X.distribution(X(t))\n    assert X.joint_distribution(5, X(3)) == JointDistributionHandmade(Lambda((X(5), X(3)), l ** (8 * g) * exp(-l * X(3)) * exp(-l * X(5)) * X(3) ** (3 * g - 1) * X(5) ** (5 * g - 1) / (gamma(3 * g) * gamma(5 * g))))\n    assert E(X(t)) == g * t / l\n    assert variance(X(t)).simplify() == g * t / l ** 2\n    assert E(X(t) ** 2 + X(d) * 2 + X(y) ** 3, Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Lopen(1, 2)) & Contains(y, Interval.Ropen(3, 4))) == 2 * g / l + (g ** 2 + g) / l ** 2 + (g ** 3 + 3 * g ** 2 + 2 * g) / l ** 3\n    assert P(X(t) > 3, Contains(t, Interval.Lopen(3, 4))).simplify() == 1 - lowergamma(g, 3 * l) / gamma(g)\n    assert (2 * X(t) + 3 * X(t)).simplify() == 5 * X(t)\n    assert (2 * X(t) - 3 * X(t)).simplify() == -X(t)\n    assert (2 * (0.25 * X(t))).simplify() == 0.5 * X(t)\n    assert (2 * X(t) * 0.25 * X(t)).simplify() == 0.5 * X(t) ** 2\n    assert (X(t) ** 2 + X(t) ** 3).simplify() == (X(t) + 1) * X(t) ** 2",
        "mutated": [
            "def test_GammaProcess_symbolic():\n    if False:\n        i = 10\n    (t, d, x, y, g, l) = symbols('t d x y g l', positive=True)\n    X = GammaProcess('X', l, g)\n    raises(NotImplementedError, lambda : X[t])\n    raises(IndexError, lambda : X(-1))\n    assert isinstance(X(t), RandomIndexedSymbol)\n    assert X.state_space == Interval(0, oo)\n    assert X.distribution(t) == GammaDistribution(g * t, 1 / l)\n    with warns_deprecated_sympy():\n        X.distribution(X(t))\n    assert X.joint_distribution(5, X(3)) == JointDistributionHandmade(Lambda((X(5), X(3)), l ** (8 * g) * exp(-l * X(3)) * exp(-l * X(5)) * X(3) ** (3 * g - 1) * X(5) ** (5 * g - 1) / (gamma(3 * g) * gamma(5 * g))))\n    assert E(X(t)) == g * t / l\n    assert variance(X(t)).simplify() == g * t / l ** 2\n    assert E(X(t) ** 2 + X(d) * 2 + X(y) ** 3, Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Lopen(1, 2)) & Contains(y, Interval.Ropen(3, 4))) == 2 * g / l + (g ** 2 + g) / l ** 2 + (g ** 3 + 3 * g ** 2 + 2 * g) / l ** 3\n    assert P(X(t) > 3, Contains(t, Interval.Lopen(3, 4))).simplify() == 1 - lowergamma(g, 3 * l) / gamma(g)\n    assert (2 * X(t) + 3 * X(t)).simplify() == 5 * X(t)\n    assert (2 * X(t) - 3 * X(t)).simplify() == -X(t)\n    assert (2 * (0.25 * X(t))).simplify() == 0.5 * X(t)\n    assert (2 * X(t) * 0.25 * X(t)).simplify() == 0.5 * X(t) ** 2\n    assert (X(t) ** 2 + X(t) ** 3).simplify() == (X(t) + 1) * X(t) ** 2",
            "def test_GammaProcess_symbolic():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (t, d, x, y, g, l) = symbols('t d x y g l', positive=True)\n    X = GammaProcess('X', l, g)\n    raises(NotImplementedError, lambda : X[t])\n    raises(IndexError, lambda : X(-1))\n    assert isinstance(X(t), RandomIndexedSymbol)\n    assert X.state_space == Interval(0, oo)\n    assert X.distribution(t) == GammaDistribution(g * t, 1 / l)\n    with warns_deprecated_sympy():\n        X.distribution(X(t))\n    assert X.joint_distribution(5, X(3)) == JointDistributionHandmade(Lambda((X(5), X(3)), l ** (8 * g) * exp(-l * X(3)) * exp(-l * X(5)) * X(3) ** (3 * g - 1) * X(5) ** (5 * g - 1) / (gamma(3 * g) * gamma(5 * g))))\n    assert E(X(t)) == g * t / l\n    assert variance(X(t)).simplify() == g * t / l ** 2\n    assert E(X(t) ** 2 + X(d) * 2 + X(y) ** 3, Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Lopen(1, 2)) & Contains(y, Interval.Ropen(3, 4))) == 2 * g / l + (g ** 2 + g) / l ** 2 + (g ** 3 + 3 * g ** 2 + 2 * g) / l ** 3\n    assert P(X(t) > 3, Contains(t, Interval.Lopen(3, 4))).simplify() == 1 - lowergamma(g, 3 * l) / gamma(g)\n    assert (2 * X(t) + 3 * X(t)).simplify() == 5 * X(t)\n    assert (2 * X(t) - 3 * X(t)).simplify() == -X(t)\n    assert (2 * (0.25 * X(t))).simplify() == 0.5 * X(t)\n    assert (2 * X(t) * 0.25 * X(t)).simplify() == 0.5 * X(t) ** 2\n    assert (X(t) ** 2 + X(t) ** 3).simplify() == (X(t) + 1) * X(t) ** 2",
            "def test_GammaProcess_symbolic():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (t, d, x, y, g, l) = symbols('t d x y g l', positive=True)\n    X = GammaProcess('X', l, g)\n    raises(NotImplementedError, lambda : X[t])\n    raises(IndexError, lambda : X(-1))\n    assert isinstance(X(t), RandomIndexedSymbol)\n    assert X.state_space == Interval(0, oo)\n    assert X.distribution(t) == GammaDistribution(g * t, 1 / l)\n    with warns_deprecated_sympy():\n        X.distribution(X(t))\n    assert X.joint_distribution(5, X(3)) == JointDistributionHandmade(Lambda((X(5), X(3)), l ** (8 * g) * exp(-l * X(3)) * exp(-l * X(5)) * X(3) ** (3 * g - 1) * X(5) ** (5 * g - 1) / (gamma(3 * g) * gamma(5 * g))))\n    assert E(X(t)) == g * t / l\n    assert variance(X(t)).simplify() == g * t / l ** 2\n    assert E(X(t) ** 2 + X(d) * 2 + X(y) ** 3, Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Lopen(1, 2)) & Contains(y, Interval.Ropen(3, 4))) == 2 * g / l + (g ** 2 + g) / l ** 2 + (g ** 3 + 3 * g ** 2 + 2 * g) / l ** 3\n    assert P(X(t) > 3, Contains(t, Interval.Lopen(3, 4))).simplify() == 1 - lowergamma(g, 3 * l) / gamma(g)\n    assert (2 * X(t) + 3 * X(t)).simplify() == 5 * X(t)\n    assert (2 * X(t) - 3 * X(t)).simplify() == -X(t)\n    assert (2 * (0.25 * X(t))).simplify() == 0.5 * X(t)\n    assert (2 * X(t) * 0.25 * X(t)).simplify() == 0.5 * X(t) ** 2\n    assert (X(t) ** 2 + X(t) ** 3).simplify() == (X(t) + 1) * X(t) ** 2",
            "def test_GammaProcess_symbolic():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (t, d, x, y, g, l) = symbols('t d x y g l', positive=True)\n    X = GammaProcess('X', l, g)\n    raises(NotImplementedError, lambda : X[t])\n    raises(IndexError, lambda : X(-1))\n    assert isinstance(X(t), RandomIndexedSymbol)\n    assert X.state_space == Interval(0, oo)\n    assert X.distribution(t) == GammaDistribution(g * t, 1 / l)\n    with warns_deprecated_sympy():\n        X.distribution(X(t))\n    assert X.joint_distribution(5, X(3)) == JointDistributionHandmade(Lambda((X(5), X(3)), l ** (8 * g) * exp(-l * X(3)) * exp(-l * X(5)) * X(3) ** (3 * g - 1) * X(5) ** (5 * g - 1) / (gamma(3 * g) * gamma(5 * g))))\n    assert E(X(t)) == g * t / l\n    assert variance(X(t)).simplify() == g * t / l ** 2\n    assert E(X(t) ** 2 + X(d) * 2 + X(y) ** 3, Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Lopen(1, 2)) & Contains(y, Interval.Ropen(3, 4))) == 2 * g / l + (g ** 2 + g) / l ** 2 + (g ** 3 + 3 * g ** 2 + 2 * g) / l ** 3\n    assert P(X(t) > 3, Contains(t, Interval.Lopen(3, 4))).simplify() == 1 - lowergamma(g, 3 * l) / gamma(g)\n    assert (2 * X(t) + 3 * X(t)).simplify() == 5 * X(t)\n    assert (2 * X(t) - 3 * X(t)).simplify() == -X(t)\n    assert (2 * (0.25 * X(t))).simplify() == 0.5 * X(t)\n    assert (2 * X(t) * 0.25 * X(t)).simplify() == 0.5 * X(t) ** 2\n    assert (X(t) ** 2 + X(t) ** 3).simplify() == (X(t) + 1) * X(t) ** 2",
            "def test_GammaProcess_symbolic():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (t, d, x, y, g, l) = symbols('t d x y g l', positive=True)\n    X = GammaProcess('X', l, g)\n    raises(NotImplementedError, lambda : X[t])\n    raises(IndexError, lambda : X(-1))\n    assert isinstance(X(t), RandomIndexedSymbol)\n    assert X.state_space == Interval(0, oo)\n    assert X.distribution(t) == GammaDistribution(g * t, 1 / l)\n    with warns_deprecated_sympy():\n        X.distribution(X(t))\n    assert X.joint_distribution(5, X(3)) == JointDistributionHandmade(Lambda((X(5), X(3)), l ** (8 * g) * exp(-l * X(3)) * exp(-l * X(5)) * X(3) ** (3 * g - 1) * X(5) ** (5 * g - 1) / (gamma(3 * g) * gamma(5 * g))))\n    assert E(X(t)) == g * t / l\n    assert variance(X(t)).simplify() == g * t / l ** 2\n    assert E(X(t) ** 2 + X(d) * 2 + X(y) ** 3, Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Lopen(1, 2)) & Contains(y, Interval.Ropen(3, 4))) == 2 * g / l + (g ** 2 + g) / l ** 2 + (g ** 3 + 3 * g ** 2 + 2 * g) / l ** 3\n    assert P(X(t) > 3, Contains(t, Interval.Lopen(3, 4))).simplify() == 1 - lowergamma(g, 3 * l) / gamma(g)\n    assert (2 * X(t) + 3 * X(t)).simplify() == 5 * X(t)\n    assert (2 * X(t) - 3 * X(t)).simplify() == -X(t)\n    assert (2 * (0.25 * X(t))).simplify() == 0.5 * X(t)\n    assert (2 * X(t) * 0.25 * X(t)).simplify() == 0.5 * X(t) ** 2\n    assert (X(t) ** 2 + X(t) ** 3).simplify() == (X(t) + 1) * X(t) ** 2"
        ]
    },
    {
        "func_name": "test_GammaProcess_numeric",
        "original": "def test_GammaProcess_numeric():\n    (t, d, x, y) = symbols('t d x y', positive=True)\n    X = GammaProcess('X', 1, 2)\n    assert X.state_space == Interval(0, oo)\n    assert X.index_set == Interval(0, oo)\n    assert X.lamda == 1\n    assert X.gamma == 2\n    raises(ValueError, lambda : GammaProcess('X', -1, 2))\n    raises(ValueError, lambda : GammaProcess('X', 0, -2))\n    raises(ValueError, lambda : GammaProcess('X', -1, -2))\n    assert P((X(t) > 4) & (X(d) > 3) & (X(x) > 2) & (X(y) > 1), Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Lopen(1, 2)) & Contains(x, Interval.Lopen(2, 3)) & Contains(y, Interval.Lopen(3, 4))).simplify() == 120 * exp(-10)\n    assert P(Not((X(t) < 5) & (X(d) > 3)), Contains(t, Interval.Ropen(2, 4)) & Contains(d, Interval.Lopen(7, 8))).simplify() == -4 * exp(-3) + 472 * exp(-8) / 3 + 1\n    assert P((X(t) > 2) | (X(t) < 4), Contains(t, Interval.Ropen(1, 4))).simplify() == -643 * exp(-4) / 15 + 109 * exp(-2) / 15 + 1\n    assert E(X(t)) == 2 * t\n    assert E(X(2) + x * E(X(5))) == 10 * x + 4",
        "mutated": [
            "def test_GammaProcess_numeric():\n    if False:\n        i = 10\n    (t, d, x, y) = symbols('t d x y', positive=True)\n    X = GammaProcess('X', 1, 2)\n    assert X.state_space == Interval(0, oo)\n    assert X.index_set == Interval(0, oo)\n    assert X.lamda == 1\n    assert X.gamma == 2\n    raises(ValueError, lambda : GammaProcess('X', -1, 2))\n    raises(ValueError, lambda : GammaProcess('X', 0, -2))\n    raises(ValueError, lambda : GammaProcess('X', -1, -2))\n    assert P((X(t) > 4) & (X(d) > 3) & (X(x) > 2) & (X(y) > 1), Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Lopen(1, 2)) & Contains(x, Interval.Lopen(2, 3)) & Contains(y, Interval.Lopen(3, 4))).simplify() == 120 * exp(-10)\n    assert P(Not((X(t) < 5) & (X(d) > 3)), Contains(t, Interval.Ropen(2, 4)) & Contains(d, Interval.Lopen(7, 8))).simplify() == -4 * exp(-3) + 472 * exp(-8) / 3 + 1\n    assert P((X(t) > 2) | (X(t) < 4), Contains(t, Interval.Ropen(1, 4))).simplify() == -643 * exp(-4) / 15 + 109 * exp(-2) / 15 + 1\n    assert E(X(t)) == 2 * t\n    assert E(X(2) + x * E(X(5))) == 10 * x + 4",
            "def test_GammaProcess_numeric():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (t, d, x, y) = symbols('t d x y', positive=True)\n    X = GammaProcess('X', 1, 2)\n    assert X.state_space == Interval(0, oo)\n    assert X.index_set == Interval(0, oo)\n    assert X.lamda == 1\n    assert X.gamma == 2\n    raises(ValueError, lambda : GammaProcess('X', -1, 2))\n    raises(ValueError, lambda : GammaProcess('X', 0, -2))\n    raises(ValueError, lambda : GammaProcess('X', -1, -2))\n    assert P((X(t) > 4) & (X(d) > 3) & (X(x) > 2) & (X(y) > 1), Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Lopen(1, 2)) & Contains(x, Interval.Lopen(2, 3)) & Contains(y, Interval.Lopen(3, 4))).simplify() == 120 * exp(-10)\n    assert P(Not((X(t) < 5) & (X(d) > 3)), Contains(t, Interval.Ropen(2, 4)) & Contains(d, Interval.Lopen(7, 8))).simplify() == -4 * exp(-3) + 472 * exp(-8) / 3 + 1\n    assert P((X(t) > 2) | (X(t) < 4), Contains(t, Interval.Ropen(1, 4))).simplify() == -643 * exp(-4) / 15 + 109 * exp(-2) / 15 + 1\n    assert E(X(t)) == 2 * t\n    assert E(X(2) + x * E(X(5))) == 10 * x + 4",
            "def test_GammaProcess_numeric():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (t, d, x, y) = symbols('t d x y', positive=True)\n    X = GammaProcess('X', 1, 2)\n    assert X.state_space == Interval(0, oo)\n    assert X.index_set == Interval(0, oo)\n    assert X.lamda == 1\n    assert X.gamma == 2\n    raises(ValueError, lambda : GammaProcess('X', -1, 2))\n    raises(ValueError, lambda : GammaProcess('X', 0, -2))\n    raises(ValueError, lambda : GammaProcess('X', -1, -2))\n    assert P((X(t) > 4) & (X(d) > 3) & (X(x) > 2) & (X(y) > 1), Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Lopen(1, 2)) & Contains(x, Interval.Lopen(2, 3)) & Contains(y, Interval.Lopen(3, 4))).simplify() == 120 * exp(-10)\n    assert P(Not((X(t) < 5) & (X(d) > 3)), Contains(t, Interval.Ropen(2, 4)) & Contains(d, Interval.Lopen(7, 8))).simplify() == -4 * exp(-3) + 472 * exp(-8) / 3 + 1\n    assert P((X(t) > 2) | (X(t) < 4), Contains(t, Interval.Ropen(1, 4))).simplify() == -643 * exp(-4) / 15 + 109 * exp(-2) / 15 + 1\n    assert E(X(t)) == 2 * t\n    assert E(X(2) + x * E(X(5))) == 10 * x + 4",
            "def test_GammaProcess_numeric():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (t, d, x, y) = symbols('t d x y', positive=True)\n    X = GammaProcess('X', 1, 2)\n    assert X.state_space == Interval(0, oo)\n    assert X.index_set == Interval(0, oo)\n    assert X.lamda == 1\n    assert X.gamma == 2\n    raises(ValueError, lambda : GammaProcess('X', -1, 2))\n    raises(ValueError, lambda : GammaProcess('X', 0, -2))\n    raises(ValueError, lambda : GammaProcess('X', -1, -2))\n    assert P((X(t) > 4) & (X(d) > 3) & (X(x) > 2) & (X(y) > 1), Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Lopen(1, 2)) & Contains(x, Interval.Lopen(2, 3)) & Contains(y, Interval.Lopen(3, 4))).simplify() == 120 * exp(-10)\n    assert P(Not((X(t) < 5) & (X(d) > 3)), Contains(t, Interval.Ropen(2, 4)) & Contains(d, Interval.Lopen(7, 8))).simplify() == -4 * exp(-3) + 472 * exp(-8) / 3 + 1\n    assert P((X(t) > 2) | (X(t) < 4), Contains(t, Interval.Ropen(1, 4))).simplify() == -643 * exp(-4) / 15 + 109 * exp(-2) / 15 + 1\n    assert E(X(t)) == 2 * t\n    assert E(X(2) + x * E(X(5))) == 10 * x + 4",
            "def test_GammaProcess_numeric():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (t, d, x, y) = symbols('t d x y', positive=True)\n    X = GammaProcess('X', 1, 2)\n    assert X.state_space == Interval(0, oo)\n    assert X.index_set == Interval(0, oo)\n    assert X.lamda == 1\n    assert X.gamma == 2\n    raises(ValueError, lambda : GammaProcess('X', -1, 2))\n    raises(ValueError, lambda : GammaProcess('X', 0, -2))\n    raises(ValueError, lambda : GammaProcess('X', -1, -2))\n    assert P((X(t) > 4) & (X(d) > 3) & (X(x) > 2) & (X(y) > 1), Contains(t, Interval.Lopen(0, 1)) & Contains(d, Interval.Lopen(1, 2)) & Contains(x, Interval.Lopen(2, 3)) & Contains(y, Interval.Lopen(3, 4))).simplify() == 120 * exp(-10)\n    assert P(Not((X(t) < 5) & (X(d) > 3)), Contains(t, Interval.Ropen(2, 4)) & Contains(d, Interval.Lopen(7, 8))).simplify() == -4 * exp(-3) + 472 * exp(-8) / 3 + 1\n    assert P((X(t) > 2) | (X(t) < 4), Contains(t, Interval.Ropen(1, 4))).simplify() == -643 * exp(-4) / 15 + 109 * exp(-2) / 15 + 1\n    assert E(X(t)) == 2 * t\n    assert E(X(2) + x * E(X(5))) == 10 * x + 4"
        ]
    }
]