[
    {
        "func_name": "ref",
        "original": "def ref(X):\n    output_height = np.int32(height * height_scale)\n    output_width = np.int32(width * width_scale)\n    (output_h_idxs, output_w_idxs) = np.meshgrid(np.arange(output_height), np.arange(output_width), indexing='ij')\n    input_h_idxs = np.minimum(output_h_idxs / height_scale, height - 1).astype(np.int32)\n    input_w_idxs = np.minimum(output_w_idxs / width_scale, width - 1).astype(np.int32)\n    if order == 'NCHW':\n        Y = X[:, :, input_h_idxs, input_w_idxs]\n    else:\n        Y = X[:, input_h_idxs, input_w_idxs, :]\n    return (Y,)",
        "mutated": [
            "def ref(X):\n    if False:\n        i = 10\n    output_height = np.int32(height * height_scale)\n    output_width = np.int32(width * width_scale)\n    (output_h_idxs, output_w_idxs) = np.meshgrid(np.arange(output_height), np.arange(output_width), indexing='ij')\n    input_h_idxs = np.minimum(output_h_idxs / height_scale, height - 1).astype(np.int32)\n    input_w_idxs = np.minimum(output_w_idxs / width_scale, width - 1).astype(np.int32)\n    if order == 'NCHW':\n        Y = X[:, :, input_h_idxs, input_w_idxs]\n    else:\n        Y = X[:, input_h_idxs, input_w_idxs, :]\n    return (Y,)",
            "def ref(X):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    output_height = np.int32(height * height_scale)\n    output_width = np.int32(width * width_scale)\n    (output_h_idxs, output_w_idxs) = np.meshgrid(np.arange(output_height), np.arange(output_width), indexing='ij')\n    input_h_idxs = np.minimum(output_h_idxs / height_scale, height - 1).astype(np.int32)\n    input_w_idxs = np.minimum(output_w_idxs / width_scale, width - 1).astype(np.int32)\n    if order == 'NCHW':\n        Y = X[:, :, input_h_idxs, input_w_idxs]\n    else:\n        Y = X[:, input_h_idxs, input_w_idxs, :]\n    return (Y,)",
            "def ref(X):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    output_height = np.int32(height * height_scale)\n    output_width = np.int32(width * width_scale)\n    (output_h_idxs, output_w_idxs) = np.meshgrid(np.arange(output_height), np.arange(output_width), indexing='ij')\n    input_h_idxs = np.minimum(output_h_idxs / height_scale, height - 1).astype(np.int32)\n    input_w_idxs = np.minimum(output_w_idxs / width_scale, width - 1).astype(np.int32)\n    if order == 'NCHW':\n        Y = X[:, :, input_h_idxs, input_w_idxs]\n    else:\n        Y = X[:, input_h_idxs, input_w_idxs, :]\n    return (Y,)",
            "def ref(X):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    output_height = np.int32(height * height_scale)\n    output_width = np.int32(width * width_scale)\n    (output_h_idxs, output_w_idxs) = np.meshgrid(np.arange(output_height), np.arange(output_width), indexing='ij')\n    input_h_idxs = np.minimum(output_h_idxs / height_scale, height - 1).astype(np.int32)\n    input_w_idxs = np.minimum(output_w_idxs / width_scale, width - 1).astype(np.int32)\n    if order == 'NCHW':\n        Y = X[:, :, input_h_idxs, input_w_idxs]\n    else:\n        Y = X[:, input_h_idxs, input_w_idxs, :]\n    return (Y,)",
            "def ref(X):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    output_height = np.int32(height * height_scale)\n    output_width = np.int32(width * width_scale)\n    (output_h_idxs, output_w_idxs) = np.meshgrid(np.arange(output_height), np.arange(output_width), indexing='ij')\n    input_h_idxs = np.minimum(output_h_idxs / height_scale, height - 1).astype(np.int32)\n    input_w_idxs = np.minimum(output_w_idxs / width_scale, width - 1).astype(np.int32)\n    if order == 'NCHW':\n        Y = X[:, :, input_h_idxs, input_w_idxs]\n    else:\n        Y = X[:, input_h_idxs, input_w_idxs, :]\n    return (Y,)"
        ]
    },
    {
        "func_name": "test_nearest",
        "original": "@given(height_scale=st.floats(0.25, 4.0) | st.just(2.0), width_scale=st.floats(0.25, 4.0) | st.just(2.0), height=st.integers(4, 32), width=st.integers(4, 32), num_channels=st.integers(1, 4), batch_size=st.integers(1, 4), seed=st.integers(0, 65535), order=st.sampled_from(['NCHW', 'NHWC']), **hu.gcs)\n@settings(max_examples=10, deadline=None)\ndef test_nearest(self, height_scale, width_scale, height, width, num_channels, batch_size, seed, order, gc, dc):\n    assume(order == 'NCHW' or gc.device_type == caffe2_pb2.CPU)\n    if order == 'NHWC':\n        dc = [d for d in dc if d.device_type == caffe2_pb2.CPU]\n    np.random.seed(seed)\n    op = core.CreateOperator('ResizeNearest', ['X'], ['Y'], width_scale=width_scale, height_scale=height_scale, order=order)\n    X = np.random.rand(batch_size, num_channels, height, width).astype(np.float32)\n    if order == 'NHWC':\n        X = X.transpose([0, 2, 3, 1])\n\n    def ref(X):\n        output_height = np.int32(height * height_scale)\n        output_width = np.int32(width * width_scale)\n        (output_h_idxs, output_w_idxs) = np.meshgrid(np.arange(output_height), np.arange(output_width), indexing='ij')\n        input_h_idxs = np.minimum(output_h_idxs / height_scale, height - 1).astype(np.int32)\n        input_w_idxs = np.minimum(output_w_idxs / width_scale, width - 1).astype(np.int32)\n        if order == 'NCHW':\n            Y = X[:, :, input_h_idxs, input_w_idxs]\n        else:\n            Y = X[:, input_h_idxs, input_w_idxs, :]\n        return (Y,)\n    self.assertReferenceChecks(gc, op, [X], ref)\n    self.assertDeviceChecks(dc, op, [X], [0])\n    self.assertGradientChecks(gc, op, [X], 0, [0], stepsize=0.1, threshold=0.01)",
        "mutated": [
            "@given(height_scale=st.floats(0.25, 4.0) | st.just(2.0), width_scale=st.floats(0.25, 4.0) | st.just(2.0), height=st.integers(4, 32), width=st.integers(4, 32), num_channels=st.integers(1, 4), batch_size=st.integers(1, 4), seed=st.integers(0, 65535), order=st.sampled_from(['NCHW', 'NHWC']), **hu.gcs)\n@settings(max_examples=10, deadline=None)\ndef test_nearest(self, height_scale, width_scale, height, width, num_channels, batch_size, seed, order, gc, dc):\n    if False:\n        i = 10\n    assume(order == 'NCHW' or gc.device_type == caffe2_pb2.CPU)\n    if order == 'NHWC':\n        dc = [d for d in dc if d.device_type == caffe2_pb2.CPU]\n    np.random.seed(seed)\n    op = core.CreateOperator('ResizeNearest', ['X'], ['Y'], width_scale=width_scale, height_scale=height_scale, order=order)\n    X = np.random.rand(batch_size, num_channels, height, width).astype(np.float32)\n    if order == 'NHWC':\n        X = X.transpose([0, 2, 3, 1])\n\n    def ref(X):\n        output_height = np.int32(height * height_scale)\n        output_width = np.int32(width * width_scale)\n        (output_h_idxs, output_w_idxs) = np.meshgrid(np.arange(output_height), np.arange(output_width), indexing='ij')\n        input_h_idxs = np.minimum(output_h_idxs / height_scale, height - 1).astype(np.int32)\n        input_w_idxs = np.minimum(output_w_idxs / width_scale, width - 1).astype(np.int32)\n        if order == 'NCHW':\n            Y = X[:, :, input_h_idxs, input_w_idxs]\n        else:\n            Y = X[:, input_h_idxs, input_w_idxs, :]\n        return (Y,)\n    self.assertReferenceChecks(gc, op, [X], ref)\n    self.assertDeviceChecks(dc, op, [X], [0])\n    self.assertGradientChecks(gc, op, [X], 0, [0], stepsize=0.1, threshold=0.01)",
            "@given(height_scale=st.floats(0.25, 4.0) | st.just(2.0), width_scale=st.floats(0.25, 4.0) | st.just(2.0), height=st.integers(4, 32), width=st.integers(4, 32), num_channels=st.integers(1, 4), batch_size=st.integers(1, 4), seed=st.integers(0, 65535), order=st.sampled_from(['NCHW', 'NHWC']), **hu.gcs)\n@settings(max_examples=10, deadline=None)\ndef test_nearest(self, height_scale, width_scale, height, width, num_channels, batch_size, seed, order, gc, dc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    assume(order == 'NCHW' or gc.device_type == caffe2_pb2.CPU)\n    if order == 'NHWC':\n        dc = [d for d in dc if d.device_type == caffe2_pb2.CPU]\n    np.random.seed(seed)\n    op = core.CreateOperator('ResizeNearest', ['X'], ['Y'], width_scale=width_scale, height_scale=height_scale, order=order)\n    X = np.random.rand(batch_size, num_channels, height, width).astype(np.float32)\n    if order == 'NHWC':\n        X = X.transpose([0, 2, 3, 1])\n\n    def ref(X):\n        output_height = np.int32(height * height_scale)\n        output_width = np.int32(width * width_scale)\n        (output_h_idxs, output_w_idxs) = np.meshgrid(np.arange(output_height), np.arange(output_width), indexing='ij')\n        input_h_idxs = np.minimum(output_h_idxs / height_scale, height - 1).astype(np.int32)\n        input_w_idxs = np.minimum(output_w_idxs / width_scale, width - 1).astype(np.int32)\n        if order == 'NCHW':\n            Y = X[:, :, input_h_idxs, input_w_idxs]\n        else:\n            Y = X[:, input_h_idxs, input_w_idxs, :]\n        return (Y,)\n    self.assertReferenceChecks(gc, op, [X], ref)\n    self.assertDeviceChecks(dc, op, [X], [0])\n    self.assertGradientChecks(gc, op, [X], 0, [0], stepsize=0.1, threshold=0.01)",
            "@given(height_scale=st.floats(0.25, 4.0) | st.just(2.0), width_scale=st.floats(0.25, 4.0) | st.just(2.0), height=st.integers(4, 32), width=st.integers(4, 32), num_channels=st.integers(1, 4), batch_size=st.integers(1, 4), seed=st.integers(0, 65535), order=st.sampled_from(['NCHW', 'NHWC']), **hu.gcs)\n@settings(max_examples=10, deadline=None)\ndef test_nearest(self, height_scale, width_scale, height, width, num_channels, batch_size, seed, order, gc, dc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    assume(order == 'NCHW' or gc.device_type == caffe2_pb2.CPU)\n    if order == 'NHWC':\n        dc = [d for d in dc if d.device_type == caffe2_pb2.CPU]\n    np.random.seed(seed)\n    op = core.CreateOperator('ResizeNearest', ['X'], ['Y'], width_scale=width_scale, height_scale=height_scale, order=order)\n    X = np.random.rand(batch_size, num_channels, height, width).astype(np.float32)\n    if order == 'NHWC':\n        X = X.transpose([0, 2, 3, 1])\n\n    def ref(X):\n        output_height = np.int32(height * height_scale)\n        output_width = np.int32(width * width_scale)\n        (output_h_idxs, output_w_idxs) = np.meshgrid(np.arange(output_height), np.arange(output_width), indexing='ij')\n        input_h_idxs = np.minimum(output_h_idxs / height_scale, height - 1).astype(np.int32)\n        input_w_idxs = np.minimum(output_w_idxs / width_scale, width - 1).astype(np.int32)\n        if order == 'NCHW':\n            Y = X[:, :, input_h_idxs, input_w_idxs]\n        else:\n            Y = X[:, input_h_idxs, input_w_idxs, :]\n        return (Y,)\n    self.assertReferenceChecks(gc, op, [X], ref)\n    self.assertDeviceChecks(dc, op, [X], [0])\n    self.assertGradientChecks(gc, op, [X], 0, [0], stepsize=0.1, threshold=0.01)",
            "@given(height_scale=st.floats(0.25, 4.0) | st.just(2.0), width_scale=st.floats(0.25, 4.0) | st.just(2.0), height=st.integers(4, 32), width=st.integers(4, 32), num_channels=st.integers(1, 4), batch_size=st.integers(1, 4), seed=st.integers(0, 65535), order=st.sampled_from(['NCHW', 'NHWC']), **hu.gcs)\n@settings(max_examples=10, deadline=None)\ndef test_nearest(self, height_scale, width_scale, height, width, num_channels, batch_size, seed, order, gc, dc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    assume(order == 'NCHW' or gc.device_type == caffe2_pb2.CPU)\n    if order == 'NHWC':\n        dc = [d for d in dc if d.device_type == caffe2_pb2.CPU]\n    np.random.seed(seed)\n    op = core.CreateOperator('ResizeNearest', ['X'], ['Y'], width_scale=width_scale, height_scale=height_scale, order=order)\n    X = np.random.rand(batch_size, num_channels, height, width).astype(np.float32)\n    if order == 'NHWC':\n        X = X.transpose([0, 2, 3, 1])\n\n    def ref(X):\n        output_height = np.int32(height * height_scale)\n        output_width = np.int32(width * width_scale)\n        (output_h_idxs, output_w_idxs) = np.meshgrid(np.arange(output_height), np.arange(output_width), indexing='ij')\n        input_h_idxs = np.minimum(output_h_idxs / height_scale, height - 1).astype(np.int32)\n        input_w_idxs = np.minimum(output_w_idxs / width_scale, width - 1).astype(np.int32)\n        if order == 'NCHW':\n            Y = X[:, :, input_h_idxs, input_w_idxs]\n        else:\n            Y = X[:, input_h_idxs, input_w_idxs, :]\n        return (Y,)\n    self.assertReferenceChecks(gc, op, [X], ref)\n    self.assertDeviceChecks(dc, op, [X], [0])\n    self.assertGradientChecks(gc, op, [X], 0, [0], stepsize=0.1, threshold=0.01)",
            "@given(height_scale=st.floats(0.25, 4.0) | st.just(2.0), width_scale=st.floats(0.25, 4.0) | st.just(2.0), height=st.integers(4, 32), width=st.integers(4, 32), num_channels=st.integers(1, 4), batch_size=st.integers(1, 4), seed=st.integers(0, 65535), order=st.sampled_from(['NCHW', 'NHWC']), **hu.gcs)\n@settings(max_examples=10, deadline=None)\ndef test_nearest(self, height_scale, width_scale, height, width, num_channels, batch_size, seed, order, gc, dc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    assume(order == 'NCHW' or gc.device_type == caffe2_pb2.CPU)\n    if order == 'NHWC':\n        dc = [d for d in dc if d.device_type == caffe2_pb2.CPU]\n    np.random.seed(seed)\n    op = core.CreateOperator('ResizeNearest', ['X'], ['Y'], width_scale=width_scale, height_scale=height_scale, order=order)\n    X = np.random.rand(batch_size, num_channels, height, width).astype(np.float32)\n    if order == 'NHWC':\n        X = X.transpose([0, 2, 3, 1])\n\n    def ref(X):\n        output_height = np.int32(height * height_scale)\n        output_width = np.int32(width * width_scale)\n        (output_h_idxs, output_w_idxs) = np.meshgrid(np.arange(output_height), np.arange(output_width), indexing='ij')\n        input_h_idxs = np.minimum(output_h_idxs / height_scale, height - 1).astype(np.int32)\n        input_w_idxs = np.minimum(output_w_idxs / width_scale, width - 1).astype(np.int32)\n        if order == 'NCHW':\n            Y = X[:, :, input_h_idxs, input_w_idxs]\n        else:\n            Y = X[:, input_h_idxs, input_w_idxs, :]\n        return (Y,)\n    self.assertReferenceChecks(gc, op, [X], ref)\n    self.assertDeviceChecks(dc, op, [X], [0])\n    self.assertGradientChecks(gc, op, [X], 0, [0], stepsize=0.1, threshold=0.01)"
        ]
    },
    {
        "func_name": "ref",
        "original": "def ref(dY, X):\n    dX = np.zeros_like(X)\n    for i in range(output_height):\n        for j in range(output_width):\n            input_i = np.minimum(i / height_scale, height - 1).astype(np.int32)\n            input_j = np.minimum(j / width_scale, width - 1).astype(np.int32)\n            if order == 'NCHW':\n                dX[:, :, input_i, input_j] += dY[:, :, i, j]\n            else:\n                dX[:, input_i, input_j, :] += dY[:, i, j, :]\n    return (dX,)",
        "mutated": [
            "def ref(dY, X):\n    if False:\n        i = 10\n    dX = np.zeros_like(X)\n    for i in range(output_height):\n        for j in range(output_width):\n            input_i = np.minimum(i / height_scale, height - 1).astype(np.int32)\n            input_j = np.minimum(j / width_scale, width - 1).astype(np.int32)\n            if order == 'NCHW':\n                dX[:, :, input_i, input_j] += dY[:, :, i, j]\n            else:\n                dX[:, input_i, input_j, :] += dY[:, i, j, :]\n    return (dX,)",
            "def ref(dY, X):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    dX = np.zeros_like(X)\n    for i in range(output_height):\n        for j in range(output_width):\n            input_i = np.minimum(i / height_scale, height - 1).astype(np.int32)\n            input_j = np.minimum(j / width_scale, width - 1).astype(np.int32)\n            if order == 'NCHW':\n                dX[:, :, input_i, input_j] += dY[:, :, i, j]\n            else:\n                dX[:, input_i, input_j, :] += dY[:, i, j, :]\n    return (dX,)",
            "def ref(dY, X):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    dX = np.zeros_like(X)\n    for i in range(output_height):\n        for j in range(output_width):\n            input_i = np.minimum(i / height_scale, height - 1).astype(np.int32)\n            input_j = np.minimum(j / width_scale, width - 1).astype(np.int32)\n            if order == 'NCHW':\n                dX[:, :, input_i, input_j] += dY[:, :, i, j]\n            else:\n                dX[:, input_i, input_j, :] += dY[:, i, j, :]\n    return (dX,)",
            "def ref(dY, X):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    dX = np.zeros_like(X)\n    for i in range(output_height):\n        for j in range(output_width):\n            input_i = np.minimum(i / height_scale, height - 1).astype(np.int32)\n            input_j = np.minimum(j / width_scale, width - 1).astype(np.int32)\n            if order == 'NCHW':\n                dX[:, :, input_i, input_j] += dY[:, :, i, j]\n            else:\n                dX[:, input_i, input_j, :] += dY[:, i, j, :]\n    return (dX,)",
            "def ref(dY, X):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    dX = np.zeros_like(X)\n    for i in range(output_height):\n        for j in range(output_width):\n            input_i = np.minimum(i / height_scale, height - 1).astype(np.int32)\n            input_j = np.minimum(j / width_scale, width - 1).astype(np.int32)\n            if order == 'NCHW':\n                dX[:, :, input_i, input_j] += dY[:, :, i, j]\n            else:\n                dX[:, input_i, input_j, :] += dY[:, i, j, :]\n    return (dX,)"
        ]
    },
    {
        "func_name": "test_nearest_grad",
        "original": "@given(height_scale=st.floats(0.25, 4.0) | st.just(2.0), width_scale=st.floats(0.25, 4.0) | st.just(2.0), height=st.integers(4, 32), width=st.integers(4, 32), num_channels=st.integers(1, 4), batch_size=st.integers(1, 4), seed=st.integers(0, 65535), order=st.sampled_from(['NCHW', 'NHWC']), **hu.gcs)\ndef test_nearest_grad(self, height_scale, width_scale, height, width, num_channels, batch_size, seed, order, gc, dc):\n    assume(order == 'NCHW' or gc.device_type == caffe2_pb2.CPU)\n    if order == 'NHWC':\n        dc = [d for d in dc if d.device_type == caffe2_pb2.CPU]\n    np.random.seed(seed)\n    output_height = np.int32(height * height_scale)\n    output_width = np.int32(width * width_scale)\n    X = np.random.rand(batch_size, num_channels, height, width).astype(np.float32)\n    dY = np.random.rand(batch_size, num_channels, output_height, output_width).astype(np.float32)\n    if order == 'NHWC':\n        X = X.transpose([0, 2, 3, 1])\n        dY = dY.transpose([0, 2, 3, 1])\n    op = core.CreateOperator('ResizeNearestGradient', ['dY', 'X'], ['dX'], width_scale=width_scale, height_scale=height_scale, order=order)\n\n    def ref(dY, X):\n        dX = np.zeros_like(X)\n        for i in range(output_height):\n            for j in range(output_width):\n                input_i = np.minimum(i / height_scale, height - 1).astype(np.int32)\n                input_j = np.minimum(j / width_scale, width - 1).astype(np.int32)\n                if order == 'NCHW':\n                    dX[:, :, input_i, input_j] += dY[:, :, i, j]\n                else:\n                    dX[:, input_i, input_j, :] += dY[:, i, j, :]\n        return (dX,)\n    self.assertDeviceChecks(dc, op, [dY, X], [0])\n    self.assertReferenceChecks(gc, op, [dY, X], ref)",
        "mutated": [
            "@given(height_scale=st.floats(0.25, 4.0) | st.just(2.0), width_scale=st.floats(0.25, 4.0) | st.just(2.0), height=st.integers(4, 32), width=st.integers(4, 32), num_channels=st.integers(1, 4), batch_size=st.integers(1, 4), seed=st.integers(0, 65535), order=st.sampled_from(['NCHW', 'NHWC']), **hu.gcs)\ndef test_nearest_grad(self, height_scale, width_scale, height, width, num_channels, batch_size, seed, order, gc, dc):\n    if False:\n        i = 10\n    assume(order == 'NCHW' or gc.device_type == caffe2_pb2.CPU)\n    if order == 'NHWC':\n        dc = [d for d in dc if d.device_type == caffe2_pb2.CPU]\n    np.random.seed(seed)\n    output_height = np.int32(height * height_scale)\n    output_width = np.int32(width * width_scale)\n    X = np.random.rand(batch_size, num_channels, height, width).astype(np.float32)\n    dY = np.random.rand(batch_size, num_channels, output_height, output_width).astype(np.float32)\n    if order == 'NHWC':\n        X = X.transpose([0, 2, 3, 1])\n        dY = dY.transpose([0, 2, 3, 1])\n    op = core.CreateOperator('ResizeNearestGradient', ['dY', 'X'], ['dX'], width_scale=width_scale, height_scale=height_scale, order=order)\n\n    def ref(dY, X):\n        dX = np.zeros_like(X)\n        for i in range(output_height):\n            for j in range(output_width):\n                input_i = np.minimum(i / height_scale, height - 1).astype(np.int32)\n                input_j = np.minimum(j / width_scale, width - 1).astype(np.int32)\n                if order == 'NCHW':\n                    dX[:, :, input_i, input_j] += dY[:, :, i, j]\n                else:\n                    dX[:, input_i, input_j, :] += dY[:, i, j, :]\n        return (dX,)\n    self.assertDeviceChecks(dc, op, [dY, X], [0])\n    self.assertReferenceChecks(gc, op, [dY, X], ref)",
            "@given(height_scale=st.floats(0.25, 4.0) | st.just(2.0), width_scale=st.floats(0.25, 4.0) | st.just(2.0), height=st.integers(4, 32), width=st.integers(4, 32), num_channels=st.integers(1, 4), batch_size=st.integers(1, 4), seed=st.integers(0, 65535), order=st.sampled_from(['NCHW', 'NHWC']), **hu.gcs)\ndef test_nearest_grad(self, height_scale, width_scale, height, width, num_channels, batch_size, seed, order, gc, dc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    assume(order == 'NCHW' or gc.device_type == caffe2_pb2.CPU)\n    if order == 'NHWC':\n        dc = [d for d in dc if d.device_type == caffe2_pb2.CPU]\n    np.random.seed(seed)\n    output_height = np.int32(height * height_scale)\n    output_width = np.int32(width * width_scale)\n    X = np.random.rand(batch_size, num_channels, height, width).astype(np.float32)\n    dY = np.random.rand(batch_size, num_channels, output_height, output_width).astype(np.float32)\n    if order == 'NHWC':\n        X = X.transpose([0, 2, 3, 1])\n        dY = dY.transpose([0, 2, 3, 1])\n    op = core.CreateOperator('ResizeNearestGradient', ['dY', 'X'], ['dX'], width_scale=width_scale, height_scale=height_scale, order=order)\n\n    def ref(dY, X):\n        dX = np.zeros_like(X)\n        for i in range(output_height):\n            for j in range(output_width):\n                input_i = np.minimum(i / height_scale, height - 1).astype(np.int32)\n                input_j = np.minimum(j / width_scale, width - 1).astype(np.int32)\n                if order == 'NCHW':\n                    dX[:, :, input_i, input_j] += dY[:, :, i, j]\n                else:\n                    dX[:, input_i, input_j, :] += dY[:, i, j, :]\n        return (dX,)\n    self.assertDeviceChecks(dc, op, [dY, X], [0])\n    self.assertReferenceChecks(gc, op, [dY, X], ref)",
            "@given(height_scale=st.floats(0.25, 4.0) | st.just(2.0), width_scale=st.floats(0.25, 4.0) | st.just(2.0), height=st.integers(4, 32), width=st.integers(4, 32), num_channels=st.integers(1, 4), batch_size=st.integers(1, 4), seed=st.integers(0, 65535), order=st.sampled_from(['NCHW', 'NHWC']), **hu.gcs)\ndef test_nearest_grad(self, height_scale, width_scale, height, width, num_channels, batch_size, seed, order, gc, dc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    assume(order == 'NCHW' or gc.device_type == caffe2_pb2.CPU)\n    if order == 'NHWC':\n        dc = [d for d in dc if d.device_type == caffe2_pb2.CPU]\n    np.random.seed(seed)\n    output_height = np.int32(height * height_scale)\n    output_width = np.int32(width * width_scale)\n    X = np.random.rand(batch_size, num_channels, height, width).astype(np.float32)\n    dY = np.random.rand(batch_size, num_channels, output_height, output_width).astype(np.float32)\n    if order == 'NHWC':\n        X = X.transpose([0, 2, 3, 1])\n        dY = dY.transpose([0, 2, 3, 1])\n    op = core.CreateOperator('ResizeNearestGradient', ['dY', 'X'], ['dX'], width_scale=width_scale, height_scale=height_scale, order=order)\n\n    def ref(dY, X):\n        dX = np.zeros_like(X)\n        for i in range(output_height):\n            for j in range(output_width):\n                input_i = np.minimum(i / height_scale, height - 1).astype(np.int32)\n                input_j = np.minimum(j / width_scale, width - 1).astype(np.int32)\n                if order == 'NCHW':\n                    dX[:, :, input_i, input_j] += dY[:, :, i, j]\n                else:\n                    dX[:, input_i, input_j, :] += dY[:, i, j, :]\n        return (dX,)\n    self.assertDeviceChecks(dc, op, [dY, X], [0])\n    self.assertReferenceChecks(gc, op, [dY, X], ref)",
            "@given(height_scale=st.floats(0.25, 4.0) | st.just(2.0), width_scale=st.floats(0.25, 4.0) | st.just(2.0), height=st.integers(4, 32), width=st.integers(4, 32), num_channels=st.integers(1, 4), batch_size=st.integers(1, 4), seed=st.integers(0, 65535), order=st.sampled_from(['NCHW', 'NHWC']), **hu.gcs)\ndef test_nearest_grad(self, height_scale, width_scale, height, width, num_channels, batch_size, seed, order, gc, dc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    assume(order == 'NCHW' or gc.device_type == caffe2_pb2.CPU)\n    if order == 'NHWC':\n        dc = [d for d in dc if d.device_type == caffe2_pb2.CPU]\n    np.random.seed(seed)\n    output_height = np.int32(height * height_scale)\n    output_width = np.int32(width * width_scale)\n    X = np.random.rand(batch_size, num_channels, height, width).astype(np.float32)\n    dY = np.random.rand(batch_size, num_channels, output_height, output_width).astype(np.float32)\n    if order == 'NHWC':\n        X = X.transpose([0, 2, 3, 1])\n        dY = dY.transpose([0, 2, 3, 1])\n    op = core.CreateOperator('ResizeNearestGradient', ['dY', 'X'], ['dX'], width_scale=width_scale, height_scale=height_scale, order=order)\n\n    def ref(dY, X):\n        dX = np.zeros_like(X)\n        for i in range(output_height):\n            for j in range(output_width):\n                input_i = np.minimum(i / height_scale, height - 1).astype(np.int32)\n                input_j = np.minimum(j / width_scale, width - 1).astype(np.int32)\n                if order == 'NCHW':\n                    dX[:, :, input_i, input_j] += dY[:, :, i, j]\n                else:\n                    dX[:, input_i, input_j, :] += dY[:, i, j, :]\n        return (dX,)\n    self.assertDeviceChecks(dc, op, [dY, X], [0])\n    self.assertReferenceChecks(gc, op, [dY, X], ref)",
            "@given(height_scale=st.floats(0.25, 4.0) | st.just(2.0), width_scale=st.floats(0.25, 4.0) | st.just(2.0), height=st.integers(4, 32), width=st.integers(4, 32), num_channels=st.integers(1, 4), batch_size=st.integers(1, 4), seed=st.integers(0, 65535), order=st.sampled_from(['NCHW', 'NHWC']), **hu.gcs)\ndef test_nearest_grad(self, height_scale, width_scale, height, width, num_channels, batch_size, seed, order, gc, dc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    assume(order == 'NCHW' or gc.device_type == caffe2_pb2.CPU)\n    if order == 'NHWC':\n        dc = [d for d in dc if d.device_type == caffe2_pb2.CPU]\n    np.random.seed(seed)\n    output_height = np.int32(height * height_scale)\n    output_width = np.int32(width * width_scale)\n    X = np.random.rand(batch_size, num_channels, height, width).astype(np.float32)\n    dY = np.random.rand(batch_size, num_channels, output_height, output_width).astype(np.float32)\n    if order == 'NHWC':\n        X = X.transpose([0, 2, 3, 1])\n        dY = dY.transpose([0, 2, 3, 1])\n    op = core.CreateOperator('ResizeNearestGradient', ['dY', 'X'], ['dX'], width_scale=width_scale, height_scale=height_scale, order=order)\n\n    def ref(dY, X):\n        dX = np.zeros_like(X)\n        for i in range(output_height):\n            for j in range(output_width):\n                input_i = np.minimum(i / height_scale, height - 1).astype(np.int32)\n                input_j = np.minimum(j / width_scale, width - 1).astype(np.int32)\n                if order == 'NCHW':\n                    dX[:, :, input_i, input_j] += dY[:, :, i, j]\n                else:\n                    dX[:, input_i, input_j, :] += dY[:, i, j, :]\n        return (dX,)\n    self.assertDeviceChecks(dc, op, [dY, X], [0])\n    self.assertReferenceChecks(gc, op, [dY, X], ref)"
        ]
    },
    {
        "func_name": "ref",
        "original": "def ref(X, scales):\n    output_height = np.int32(height * scales[0])\n    output_width = np.int32(width * scales[1])\n    (output_h_idxs, output_w_idxs) = np.meshgrid(np.arange(output_height), np.arange(output_width), indexing='ij')\n    input_h_idxs = np.minimum(output_h_idxs / scales[0], height - 1).astype(np.int32)\n    input_w_idxs = np.minimum(output_w_idxs / scales[1], width - 1).astype(np.int32)\n    if order == 'NCHW':\n        Y = X[:, :, input_h_idxs, input_w_idxs]\n    else:\n        Y = X[:, input_h_idxs, input_w_idxs, :]\n    return (Y,)",
        "mutated": [
            "def ref(X, scales):\n    if False:\n        i = 10\n    output_height = np.int32(height * scales[0])\n    output_width = np.int32(width * scales[1])\n    (output_h_idxs, output_w_idxs) = np.meshgrid(np.arange(output_height), np.arange(output_width), indexing='ij')\n    input_h_idxs = np.minimum(output_h_idxs / scales[0], height - 1).astype(np.int32)\n    input_w_idxs = np.minimum(output_w_idxs / scales[1], width - 1).astype(np.int32)\n    if order == 'NCHW':\n        Y = X[:, :, input_h_idxs, input_w_idxs]\n    else:\n        Y = X[:, input_h_idxs, input_w_idxs, :]\n    return (Y,)",
            "def ref(X, scales):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    output_height = np.int32(height * scales[0])\n    output_width = np.int32(width * scales[1])\n    (output_h_idxs, output_w_idxs) = np.meshgrid(np.arange(output_height), np.arange(output_width), indexing='ij')\n    input_h_idxs = np.minimum(output_h_idxs / scales[0], height - 1).astype(np.int32)\n    input_w_idxs = np.minimum(output_w_idxs / scales[1], width - 1).astype(np.int32)\n    if order == 'NCHW':\n        Y = X[:, :, input_h_idxs, input_w_idxs]\n    else:\n        Y = X[:, input_h_idxs, input_w_idxs, :]\n    return (Y,)",
            "def ref(X, scales):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    output_height = np.int32(height * scales[0])\n    output_width = np.int32(width * scales[1])\n    (output_h_idxs, output_w_idxs) = np.meshgrid(np.arange(output_height), np.arange(output_width), indexing='ij')\n    input_h_idxs = np.minimum(output_h_idxs / scales[0], height - 1).astype(np.int32)\n    input_w_idxs = np.minimum(output_w_idxs / scales[1], width - 1).astype(np.int32)\n    if order == 'NCHW':\n        Y = X[:, :, input_h_idxs, input_w_idxs]\n    else:\n        Y = X[:, input_h_idxs, input_w_idxs, :]\n    return (Y,)",
            "def ref(X, scales):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    output_height = np.int32(height * scales[0])\n    output_width = np.int32(width * scales[1])\n    (output_h_idxs, output_w_idxs) = np.meshgrid(np.arange(output_height), np.arange(output_width), indexing='ij')\n    input_h_idxs = np.minimum(output_h_idxs / scales[0], height - 1).astype(np.int32)\n    input_w_idxs = np.minimum(output_w_idxs / scales[1], width - 1).astype(np.int32)\n    if order == 'NCHW':\n        Y = X[:, :, input_h_idxs, input_w_idxs]\n    else:\n        Y = X[:, input_h_idxs, input_w_idxs, :]\n    return (Y,)",
            "def ref(X, scales):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    output_height = np.int32(height * scales[0])\n    output_width = np.int32(width * scales[1])\n    (output_h_idxs, output_w_idxs) = np.meshgrid(np.arange(output_height), np.arange(output_width), indexing='ij')\n    input_h_idxs = np.minimum(output_h_idxs / scales[0], height - 1).astype(np.int32)\n    input_w_idxs = np.minimum(output_w_idxs / scales[1], width - 1).astype(np.int32)\n    if order == 'NCHW':\n        Y = X[:, :, input_h_idxs, input_w_idxs]\n    else:\n        Y = X[:, input_h_idxs, input_w_idxs, :]\n    return (Y,)"
        ]
    },
    {
        "func_name": "test_nearest_onnx",
        "original": "@given(height_scale=st.floats(0.25, 4.0) | st.just(2.0), width_scale=st.floats(0.25, 4.0) | st.just(2.0), height=st.integers(4, 8), width=st.integers(4, 8), num_channels=st.integers(1, 4), batch_size=st.integers(1, 4), seed=st.integers(0, 65535), order=st.sampled_from(['NCHW', 'NHWC']), **hu.gcs)\n@settings(deadline=10000)\ndef test_nearest_onnx(self, height_scale, width_scale, height, width, num_channels, batch_size, seed, order, gc, dc):\n    assume(order == 'NCHW' or gc.device_type == caffe2_pb2.CPU)\n    if order == 'NHWC':\n        dc = [d for d in dc if d.device_type == caffe2_pb2.CPU]\n    np.random.seed(seed)\n    op = core.CreateOperator('ResizeNearest', ['X', 'scales'], ['Y'], order=order)\n    X = np.random.rand(batch_size, num_channels, height, width).astype(np.float32)\n    if order == 'NHWC':\n        X = X.transpose([0, 2, 3, 1])\n    scales = np.array([height_scale, width_scale]).astype(np.float32)\n\n    def ref(X, scales):\n        output_height = np.int32(height * scales[0])\n        output_width = np.int32(width * scales[1])\n        (output_h_idxs, output_w_idxs) = np.meshgrid(np.arange(output_height), np.arange(output_width), indexing='ij')\n        input_h_idxs = np.minimum(output_h_idxs / scales[0], height - 1).astype(np.int32)\n        input_w_idxs = np.minimum(output_w_idxs / scales[1], width - 1).astype(np.int32)\n        if order == 'NCHW':\n            Y = X[:, :, input_h_idxs, input_w_idxs]\n        else:\n            Y = X[:, input_h_idxs, input_w_idxs, :]\n        return (Y,)\n    self.assertReferenceChecks(gc, op, [X, scales], ref)\n    self.assertDeviceChecks(dc, op, [X, scales], [0])\n    self.assertGradientChecks(gc, op, [X, scales], 0, [0], stepsize=0.1, threshold=0.01)",
        "mutated": [
            "@given(height_scale=st.floats(0.25, 4.0) | st.just(2.0), width_scale=st.floats(0.25, 4.0) | st.just(2.0), height=st.integers(4, 8), width=st.integers(4, 8), num_channels=st.integers(1, 4), batch_size=st.integers(1, 4), seed=st.integers(0, 65535), order=st.sampled_from(['NCHW', 'NHWC']), **hu.gcs)\n@settings(deadline=10000)\ndef test_nearest_onnx(self, height_scale, width_scale, height, width, num_channels, batch_size, seed, order, gc, dc):\n    if False:\n        i = 10\n    assume(order == 'NCHW' or gc.device_type == caffe2_pb2.CPU)\n    if order == 'NHWC':\n        dc = [d for d in dc if d.device_type == caffe2_pb2.CPU]\n    np.random.seed(seed)\n    op = core.CreateOperator('ResizeNearest', ['X', 'scales'], ['Y'], order=order)\n    X = np.random.rand(batch_size, num_channels, height, width).astype(np.float32)\n    if order == 'NHWC':\n        X = X.transpose([0, 2, 3, 1])\n    scales = np.array([height_scale, width_scale]).astype(np.float32)\n\n    def ref(X, scales):\n        output_height = np.int32(height * scales[0])\n        output_width = np.int32(width * scales[1])\n        (output_h_idxs, output_w_idxs) = np.meshgrid(np.arange(output_height), np.arange(output_width), indexing='ij')\n        input_h_idxs = np.minimum(output_h_idxs / scales[0], height - 1).astype(np.int32)\n        input_w_idxs = np.minimum(output_w_idxs / scales[1], width - 1).astype(np.int32)\n        if order == 'NCHW':\n            Y = X[:, :, input_h_idxs, input_w_idxs]\n        else:\n            Y = X[:, input_h_idxs, input_w_idxs, :]\n        return (Y,)\n    self.assertReferenceChecks(gc, op, [X, scales], ref)\n    self.assertDeviceChecks(dc, op, [X, scales], [0])\n    self.assertGradientChecks(gc, op, [X, scales], 0, [0], stepsize=0.1, threshold=0.01)",
            "@given(height_scale=st.floats(0.25, 4.0) | st.just(2.0), width_scale=st.floats(0.25, 4.0) | st.just(2.0), height=st.integers(4, 8), width=st.integers(4, 8), num_channels=st.integers(1, 4), batch_size=st.integers(1, 4), seed=st.integers(0, 65535), order=st.sampled_from(['NCHW', 'NHWC']), **hu.gcs)\n@settings(deadline=10000)\ndef test_nearest_onnx(self, height_scale, width_scale, height, width, num_channels, batch_size, seed, order, gc, dc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    assume(order == 'NCHW' or gc.device_type == caffe2_pb2.CPU)\n    if order == 'NHWC':\n        dc = [d for d in dc if d.device_type == caffe2_pb2.CPU]\n    np.random.seed(seed)\n    op = core.CreateOperator('ResizeNearest', ['X', 'scales'], ['Y'], order=order)\n    X = np.random.rand(batch_size, num_channels, height, width).astype(np.float32)\n    if order == 'NHWC':\n        X = X.transpose([0, 2, 3, 1])\n    scales = np.array([height_scale, width_scale]).astype(np.float32)\n\n    def ref(X, scales):\n        output_height = np.int32(height * scales[0])\n        output_width = np.int32(width * scales[1])\n        (output_h_idxs, output_w_idxs) = np.meshgrid(np.arange(output_height), np.arange(output_width), indexing='ij')\n        input_h_idxs = np.minimum(output_h_idxs / scales[0], height - 1).astype(np.int32)\n        input_w_idxs = np.minimum(output_w_idxs / scales[1], width - 1).astype(np.int32)\n        if order == 'NCHW':\n            Y = X[:, :, input_h_idxs, input_w_idxs]\n        else:\n            Y = X[:, input_h_idxs, input_w_idxs, :]\n        return (Y,)\n    self.assertReferenceChecks(gc, op, [X, scales], ref)\n    self.assertDeviceChecks(dc, op, [X, scales], [0])\n    self.assertGradientChecks(gc, op, [X, scales], 0, [0], stepsize=0.1, threshold=0.01)",
            "@given(height_scale=st.floats(0.25, 4.0) | st.just(2.0), width_scale=st.floats(0.25, 4.0) | st.just(2.0), height=st.integers(4, 8), width=st.integers(4, 8), num_channels=st.integers(1, 4), batch_size=st.integers(1, 4), seed=st.integers(0, 65535), order=st.sampled_from(['NCHW', 'NHWC']), **hu.gcs)\n@settings(deadline=10000)\ndef test_nearest_onnx(self, height_scale, width_scale, height, width, num_channels, batch_size, seed, order, gc, dc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    assume(order == 'NCHW' or gc.device_type == caffe2_pb2.CPU)\n    if order == 'NHWC':\n        dc = [d for d in dc if d.device_type == caffe2_pb2.CPU]\n    np.random.seed(seed)\n    op = core.CreateOperator('ResizeNearest', ['X', 'scales'], ['Y'], order=order)\n    X = np.random.rand(batch_size, num_channels, height, width).astype(np.float32)\n    if order == 'NHWC':\n        X = X.transpose([0, 2, 3, 1])\n    scales = np.array([height_scale, width_scale]).astype(np.float32)\n\n    def ref(X, scales):\n        output_height = np.int32(height * scales[0])\n        output_width = np.int32(width * scales[1])\n        (output_h_idxs, output_w_idxs) = np.meshgrid(np.arange(output_height), np.arange(output_width), indexing='ij')\n        input_h_idxs = np.minimum(output_h_idxs / scales[0], height - 1).astype(np.int32)\n        input_w_idxs = np.minimum(output_w_idxs / scales[1], width - 1).astype(np.int32)\n        if order == 'NCHW':\n            Y = X[:, :, input_h_idxs, input_w_idxs]\n        else:\n            Y = X[:, input_h_idxs, input_w_idxs, :]\n        return (Y,)\n    self.assertReferenceChecks(gc, op, [X, scales], ref)\n    self.assertDeviceChecks(dc, op, [X, scales], [0])\n    self.assertGradientChecks(gc, op, [X, scales], 0, [0], stepsize=0.1, threshold=0.01)",
            "@given(height_scale=st.floats(0.25, 4.0) | st.just(2.0), width_scale=st.floats(0.25, 4.0) | st.just(2.0), height=st.integers(4, 8), width=st.integers(4, 8), num_channels=st.integers(1, 4), batch_size=st.integers(1, 4), seed=st.integers(0, 65535), order=st.sampled_from(['NCHW', 'NHWC']), **hu.gcs)\n@settings(deadline=10000)\ndef test_nearest_onnx(self, height_scale, width_scale, height, width, num_channels, batch_size, seed, order, gc, dc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    assume(order == 'NCHW' or gc.device_type == caffe2_pb2.CPU)\n    if order == 'NHWC':\n        dc = [d for d in dc if d.device_type == caffe2_pb2.CPU]\n    np.random.seed(seed)\n    op = core.CreateOperator('ResizeNearest', ['X', 'scales'], ['Y'], order=order)\n    X = np.random.rand(batch_size, num_channels, height, width).astype(np.float32)\n    if order == 'NHWC':\n        X = X.transpose([0, 2, 3, 1])\n    scales = np.array([height_scale, width_scale]).astype(np.float32)\n\n    def ref(X, scales):\n        output_height = np.int32(height * scales[0])\n        output_width = np.int32(width * scales[1])\n        (output_h_idxs, output_w_idxs) = np.meshgrid(np.arange(output_height), np.arange(output_width), indexing='ij')\n        input_h_idxs = np.minimum(output_h_idxs / scales[0], height - 1).astype(np.int32)\n        input_w_idxs = np.minimum(output_w_idxs / scales[1], width - 1).astype(np.int32)\n        if order == 'NCHW':\n            Y = X[:, :, input_h_idxs, input_w_idxs]\n        else:\n            Y = X[:, input_h_idxs, input_w_idxs, :]\n        return (Y,)\n    self.assertReferenceChecks(gc, op, [X, scales], ref)\n    self.assertDeviceChecks(dc, op, [X, scales], [0])\n    self.assertGradientChecks(gc, op, [X, scales], 0, [0], stepsize=0.1, threshold=0.01)",
            "@given(height_scale=st.floats(0.25, 4.0) | st.just(2.0), width_scale=st.floats(0.25, 4.0) | st.just(2.0), height=st.integers(4, 8), width=st.integers(4, 8), num_channels=st.integers(1, 4), batch_size=st.integers(1, 4), seed=st.integers(0, 65535), order=st.sampled_from(['NCHW', 'NHWC']), **hu.gcs)\n@settings(deadline=10000)\ndef test_nearest_onnx(self, height_scale, width_scale, height, width, num_channels, batch_size, seed, order, gc, dc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    assume(order == 'NCHW' or gc.device_type == caffe2_pb2.CPU)\n    if order == 'NHWC':\n        dc = [d for d in dc if d.device_type == caffe2_pb2.CPU]\n    np.random.seed(seed)\n    op = core.CreateOperator('ResizeNearest', ['X', 'scales'], ['Y'], order=order)\n    X = np.random.rand(batch_size, num_channels, height, width).astype(np.float32)\n    if order == 'NHWC':\n        X = X.transpose([0, 2, 3, 1])\n    scales = np.array([height_scale, width_scale]).astype(np.float32)\n\n    def ref(X, scales):\n        output_height = np.int32(height * scales[0])\n        output_width = np.int32(width * scales[1])\n        (output_h_idxs, output_w_idxs) = np.meshgrid(np.arange(output_height), np.arange(output_width), indexing='ij')\n        input_h_idxs = np.minimum(output_h_idxs / scales[0], height - 1).astype(np.int32)\n        input_w_idxs = np.minimum(output_w_idxs / scales[1], width - 1).astype(np.int32)\n        if order == 'NCHW':\n            Y = X[:, :, input_h_idxs, input_w_idxs]\n        else:\n            Y = X[:, input_h_idxs, input_w_idxs, :]\n        return (Y,)\n    self.assertReferenceChecks(gc, op, [X, scales], ref)\n    self.assertDeviceChecks(dc, op, [X, scales], [0])\n    self.assertGradientChecks(gc, op, [X, scales], 0, [0], stepsize=0.1, threshold=0.01)"
        ]
    },
    {
        "func_name": "ref",
        "original": "def ref(dY, X, scales):\n    dX = np.zeros_like(X)\n    for i in range(output_height):\n        for j in range(output_width):\n            input_i = np.minimum(i / scales[0], height - 1).astype(np.int32)\n            input_j = np.minimum(j / scales[1], width - 1).astype(np.int32)\n            if order == 'NCHW':\n                dX[:, :, input_i, input_j] += dY[:, :, i, j]\n            else:\n                dX[:, input_i, input_j, :] += dY[:, i, j, :]\n    return (dX,)",
        "mutated": [
            "def ref(dY, X, scales):\n    if False:\n        i = 10\n    dX = np.zeros_like(X)\n    for i in range(output_height):\n        for j in range(output_width):\n            input_i = np.minimum(i / scales[0], height - 1).astype(np.int32)\n            input_j = np.minimum(j / scales[1], width - 1).astype(np.int32)\n            if order == 'NCHW':\n                dX[:, :, input_i, input_j] += dY[:, :, i, j]\n            else:\n                dX[:, input_i, input_j, :] += dY[:, i, j, :]\n    return (dX,)",
            "def ref(dY, X, scales):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    dX = np.zeros_like(X)\n    for i in range(output_height):\n        for j in range(output_width):\n            input_i = np.minimum(i / scales[0], height - 1).astype(np.int32)\n            input_j = np.minimum(j / scales[1], width - 1).astype(np.int32)\n            if order == 'NCHW':\n                dX[:, :, input_i, input_j] += dY[:, :, i, j]\n            else:\n                dX[:, input_i, input_j, :] += dY[:, i, j, :]\n    return (dX,)",
            "def ref(dY, X, scales):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    dX = np.zeros_like(X)\n    for i in range(output_height):\n        for j in range(output_width):\n            input_i = np.minimum(i / scales[0], height - 1).astype(np.int32)\n            input_j = np.minimum(j / scales[1], width - 1).astype(np.int32)\n            if order == 'NCHW':\n                dX[:, :, input_i, input_j] += dY[:, :, i, j]\n            else:\n                dX[:, input_i, input_j, :] += dY[:, i, j, :]\n    return (dX,)",
            "def ref(dY, X, scales):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    dX = np.zeros_like(X)\n    for i in range(output_height):\n        for j in range(output_width):\n            input_i = np.minimum(i / scales[0], height - 1).astype(np.int32)\n            input_j = np.minimum(j / scales[1], width - 1).astype(np.int32)\n            if order == 'NCHW':\n                dX[:, :, input_i, input_j] += dY[:, :, i, j]\n            else:\n                dX[:, input_i, input_j, :] += dY[:, i, j, :]\n    return (dX,)",
            "def ref(dY, X, scales):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    dX = np.zeros_like(X)\n    for i in range(output_height):\n        for j in range(output_width):\n            input_i = np.minimum(i / scales[0], height - 1).astype(np.int32)\n            input_j = np.minimum(j / scales[1], width - 1).astype(np.int32)\n            if order == 'NCHW':\n                dX[:, :, input_i, input_j] += dY[:, :, i, j]\n            else:\n                dX[:, input_i, input_j, :] += dY[:, i, j, :]\n    return (dX,)"
        ]
    },
    {
        "func_name": "test_nearest_onnx_grad",
        "original": "@given(height_scale=st.floats(0.25, 4.0) | st.just(2.0), width_scale=st.floats(0.25, 4.0) | st.just(2.0), height=st.integers(4, 8), width=st.integers(4, 8), num_channels=st.integers(1, 4), batch_size=st.integers(1, 4), seed=st.integers(0, 65535), order=st.sampled_from(['NCHW', 'NHWC']), **hu.gcs)\ndef test_nearest_onnx_grad(self, height_scale, width_scale, height, width, num_channels, batch_size, seed, order, gc, dc):\n    assume(order == 'NCHW' or gc.device_type == caffe2_pb2.CPU)\n    if order == 'NHWC':\n        dc = [d for d in dc if d.device_type == caffe2_pb2.CPU]\n    np.random.seed(seed)\n    output_height = np.int32(height * height_scale)\n    output_width = np.int32(width * width_scale)\n    X = np.random.rand(batch_size, num_channels, height, width).astype(np.float32)\n    dY = np.random.rand(batch_size, num_channels, output_height, output_width).astype(np.float32)\n    if order == 'NHWC':\n        X = X.transpose([0, 2, 3, 1])\n        dY = dY.transpose([0, 2, 3, 1])\n    scales = np.array([height_scale, width_scale]).astype(np.float32)\n    op = core.CreateOperator('ResizeNearestGradient', ['dY', 'X', 'scales'], ['dX'], order=order)\n\n    def ref(dY, X, scales):\n        dX = np.zeros_like(X)\n        for i in range(output_height):\n            for j in range(output_width):\n                input_i = np.minimum(i / scales[0], height - 1).astype(np.int32)\n                input_j = np.minimum(j / scales[1], width - 1).astype(np.int32)\n                if order == 'NCHW':\n                    dX[:, :, input_i, input_j] += dY[:, :, i, j]\n                else:\n                    dX[:, input_i, input_j, :] += dY[:, i, j, :]\n        return (dX,)\n    self.assertDeviceChecks(dc, op, [dY, X, scales], [0])\n    self.assertReferenceChecks(gc, op, [dY, X, scales], ref)",
        "mutated": [
            "@given(height_scale=st.floats(0.25, 4.0) | st.just(2.0), width_scale=st.floats(0.25, 4.0) | st.just(2.0), height=st.integers(4, 8), width=st.integers(4, 8), num_channels=st.integers(1, 4), batch_size=st.integers(1, 4), seed=st.integers(0, 65535), order=st.sampled_from(['NCHW', 'NHWC']), **hu.gcs)\ndef test_nearest_onnx_grad(self, height_scale, width_scale, height, width, num_channels, batch_size, seed, order, gc, dc):\n    if False:\n        i = 10\n    assume(order == 'NCHW' or gc.device_type == caffe2_pb2.CPU)\n    if order == 'NHWC':\n        dc = [d for d in dc if d.device_type == caffe2_pb2.CPU]\n    np.random.seed(seed)\n    output_height = np.int32(height * height_scale)\n    output_width = np.int32(width * width_scale)\n    X = np.random.rand(batch_size, num_channels, height, width).astype(np.float32)\n    dY = np.random.rand(batch_size, num_channels, output_height, output_width).astype(np.float32)\n    if order == 'NHWC':\n        X = X.transpose([0, 2, 3, 1])\n        dY = dY.transpose([0, 2, 3, 1])\n    scales = np.array([height_scale, width_scale]).astype(np.float32)\n    op = core.CreateOperator('ResizeNearestGradient', ['dY', 'X', 'scales'], ['dX'], order=order)\n\n    def ref(dY, X, scales):\n        dX = np.zeros_like(X)\n        for i in range(output_height):\n            for j in range(output_width):\n                input_i = np.minimum(i / scales[0], height - 1).astype(np.int32)\n                input_j = np.minimum(j / scales[1], width - 1).astype(np.int32)\n                if order == 'NCHW':\n                    dX[:, :, input_i, input_j] += dY[:, :, i, j]\n                else:\n                    dX[:, input_i, input_j, :] += dY[:, i, j, :]\n        return (dX,)\n    self.assertDeviceChecks(dc, op, [dY, X, scales], [0])\n    self.assertReferenceChecks(gc, op, [dY, X, scales], ref)",
            "@given(height_scale=st.floats(0.25, 4.0) | st.just(2.0), width_scale=st.floats(0.25, 4.0) | st.just(2.0), height=st.integers(4, 8), width=st.integers(4, 8), num_channels=st.integers(1, 4), batch_size=st.integers(1, 4), seed=st.integers(0, 65535), order=st.sampled_from(['NCHW', 'NHWC']), **hu.gcs)\ndef test_nearest_onnx_grad(self, height_scale, width_scale, height, width, num_channels, batch_size, seed, order, gc, dc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    assume(order == 'NCHW' or gc.device_type == caffe2_pb2.CPU)\n    if order == 'NHWC':\n        dc = [d for d in dc if d.device_type == caffe2_pb2.CPU]\n    np.random.seed(seed)\n    output_height = np.int32(height * height_scale)\n    output_width = np.int32(width * width_scale)\n    X = np.random.rand(batch_size, num_channels, height, width).astype(np.float32)\n    dY = np.random.rand(batch_size, num_channels, output_height, output_width).astype(np.float32)\n    if order == 'NHWC':\n        X = X.transpose([0, 2, 3, 1])\n        dY = dY.transpose([0, 2, 3, 1])\n    scales = np.array([height_scale, width_scale]).astype(np.float32)\n    op = core.CreateOperator('ResizeNearestGradient', ['dY', 'X', 'scales'], ['dX'], order=order)\n\n    def ref(dY, X, scales):\n        dX = np.zeros_like(X)\n        for i in range(output_height):\n            for j in range(output_width):\n                input_i = np.minimum(i / scales[0], height - 1).astype(np.int32)\n                input_j = np.minimum(j / scales[1], width - 1).astype(np.int32)\n                if order == 'NCHW':\n                    dX[:, :, input_i, input_j] += dY[:, :, i, j]\n                else:\n                    dX[:, input_i, input_j, :] += dY[:, i, j, :]\n        return (dX,)\n    self.assertDeviceChecks(dc, op, [dY, X, scales], [0])\n    self.assertReferenceChecks(gc, op, [dY, X, scales], ref)",
            "@given(height_scale=st.floats(0.25, 4.0) | st.just(2.0), width_scale=st.floats(0.25, 4.0) | st.just(2.0), height=st.integers(4, 8), width=st.integers(4, 8), num_channels=st.integers(1, 4), batch_size=st.integers(1, 4), seed=st.integers(0, 65535), order=st.sampled_from(['NCHW', 'NHWC']), **hu.gcs)\ndef test_nearest_onnx_grad(self, height_scale, width_scale, height, width, num_channels, batch_size, seed, order, gc, dc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    assume(order == 'NCHW' or gc.device_type == caffe2_pb2.CPU)\n    if order == 'NHWC':\n        dc = [d for d in dc if d.device_type == caffe2_pb2.CPU]\n    np.random.seed(seed)\n    output_height = np.int32(height * height_scale)\n    output_width = np.int32(width * width_scale)\n    X = np.random.rand(batch_size, num_channels, height, width).astype(np.float32)\n    dY = np.random.rand(batch_size, num_channels, output_height, output_width).astype(np.float32)\n    if order == 'NHWC':\n        X = X.transpose([0, 2, 3, 1])\n        dY = dY.transpose([0, 2, 3, 1])\n    scales = np.array([height_scale, width_scale]).astype(np.float32)\n    op = core.CreateOperator('ResizeNearestGradient', ['dY', 'X', 'scales'], ['dX'], order=order)\n\n    def ref(dY, X, scales):\n        dX = np.zeros_like(X)\n        for i in range(output_height):\n            for j in range(output_width):\n                input_i = np.minimum(i / scales[0], height - 1).astype(np.int32)\n                input_j = np.minimum(j / scales[1], width - 1).astype(np.int32)\n                if order == 'NCHW':\n                    dX[:, :, input_i, input_j] += dY[:, :, i, j]\n                else:\n                    dX[:, input_i, input_j, :] += dY[:, i, j, :]\n        return (dX,)\n    self.assertDeviceChecks(dc, op, [dY, X, scales], [0])\n    self.assertReferenceChecks(gc, op, [dY, X, scales], ref)",
            "@given(height_scale=st.floats(0.25, 4.0) | st.just(2.0), width_scale=st.floats(0.25, 4.0) | st.just(2.0), height=st.integers(4, 8), width=st.integers(4, 8), num_channels=st.integers(1, 4), batch_size=st.integers(1, 4), seed=st.integers(0, 65535), order=st.sampled_from(['NCHW', 'NHWC']), **hu.gcs)\ndef test_nearest_onnx_grad(self, height_scale, width_scale, height, width, num_channels, batch_size, seed, order, gc, dc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    assume(order == 'NCHW' or gc.device_type == caffe2_pb2.CPU)\n    if order == 'NHWC':\n        dc = [d for d in dc if d.device_type == caffe2_pb2.CPU]\n    np.random.seed(seed)\n    output_height = np.int32(height * height_scale)\n    output_width = np.int32(width * width_scale)\n    X = np.random.rand(batch_size, num_channels, height, width).astype(np.float32)\n    dY = np.random.rand(batch_size, num_channels, output_height, output_width).astype(np.float32)\n    if order == 'NHWC':\n        X = X.transpose([0, 2, 3, 1])\n        dY = dY.transpose([0, 2, 3, 1])\n    scales = np.array([height_scale, width_scale]).astype(np.float32)\n    op = core.CreateOperator('ResizeNearestGradient', ['dY', 'X', 'scales'], ['dX'], order=order)\n\n    def ref(dY, X, scales):\n        dX = np.zeros_like(X)\n        for i in range(output_height):\n            for j in range(output_width):\n                input_i = np.minimum(i / scales[0], height - 1).astype(np.int32)\n                input_j = np.minimum(j / scales[1], width - 1).astype(np.int32)\n                if order == 'NCHW':\n                    dX[:, :, input_i, input_j] += dY[:, :, i, j]\n                else:\n                    dX[:, input_i, input_j, :] += dY[:, i, j, :]\n        return (dX,)\n    self.assertDeviceChecks(dc, op, [dY, X, scales], [0])\n    self.assertReferenceChecks(gc, op, [dY, X, scales], ref)",
            "@given(height_scale=st.floats(0.25, 4.0) | st.just(2.0), width_scale=st.floats(0.25, 4.0) | st.just(2.0), height=st.integers(4, 8), width=st.integers(4, 8), num_channels=st.integers(1, 4), batch_size=st.integers(1, 4), seed=st.integers(0, 65535), order=st.sampled_from(['NCHW', 'NHWC']), **hu.gcs)\ndef test_nearest_onnx_grad(self, height_scale, width_scale, height, width, num_channels, batch_size, seed, order, gc, dc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    assume(order == 'NCHW' or gc.device_type == caffe2_pb2.CPU)\n    if order == 'NHWC':\n        dc = [d for d in dc if d.device_type == caffe2_pb2.CPU]\n    np.random.seed(seed)\n    output_height = np.int32(height * height_scale)\n    output_width = np.int32(width * width_scale)\n    X = np.random.rand(batch_size, num_channels, height, width).astype(np.float32)\n    dY = np.random.rand(batch_size, num_channels, output_height, output_width).astype(np.float32)\n    if order == 'NHWC':\n        X = X.transpose([0, 2, 3, 1])\n        dY = dY.transpose([0, 2, 3, 1])\n    scales = np.array([height_scale, width_scale]).astype(np.float32)\n    op = core.CreateOperator('ResizeNearestGradient', ['dY', 'X', 'scales'], ['dX'], order=order)\n\n    def ref(dY, X, scales):\n        dX = np.zeros_like(X)\n        for i in range(output_height):\n            for j in range(output_width):\n                input_i = np.minimum(i / scales[0], height - 1).astype(np.int32)\n                input_j = np.minimum(j / scales[1], width - 1).astype(np.int32)\n                if order == 'NCHW':\n                    dX[:, :, input_i, input_j] += dY[:, :, i, j]\n                else:\n                    dX[:, input_i, input_j, :] += dY[:, i, j, :]\n        return (dX,)\n    self.assertDeviceChecks(dc, op, [dY, X, scales], [0])\n    self.assertReferenceChecks(gc, op, [dY, X, scales], ref)"
        ]
    }
]