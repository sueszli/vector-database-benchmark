[
    {
        "func_name": "head_to_head_votes",
        "original": "def head_to_head_votes(ranks: List[List[int]]):\n    tallies = np.zeros((len(ranks[0]), len(ranks[0])))\n    names = sorted(ranks[0])\n    ranks = np.array(ranks)\n    ranks = np.argsort(ranks, axis=1)\n    for i in range(ranks.shape[1]):\n        for j in range(i + 1, ranks.shape[1]):\n            over_j = np.sum(ranks[:, i] < ranks[:, j])\n            over_i = np.sum(ranks[:, j] < ranks[:, i])\n            tallies[i, j] = over_j\n            tallies[j, i] = over_i\n    return (tallies, names)",
        "mutated": [
            "def head_to_head_votes(ranks: List[List[int]]):\n    if False:\n        i = 10\n    tallies = np.zeros((len(ranks[0]), len(ranks[0])))\n    names = sorted(ranks[0])\n    ranks = np.array(ranks)\n    ranks = np.argsort(ranks, axis=1)\n    for i in range(ranks.shape[1]):\n        for j in range(i + 1, ranks.shape[1]):\n            over_j = np.sum(ranks[:, i] < ranks[:, j])\n            over_i = np.sum(ranks[:, j] < ranks[:, i])\n            tallies[i, j] = over_j\n            tallies[j, i] = over_i\n    return (tallies, names)",
            "def head_to_head_votes(ranks: List[List[int]]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    tallies = np.zeros((len(ranks[0]), len(ranks[0])))\n    names = sorted(ranks[0])\n    ranks = np.array(ranks)\n    ranks = np.argsort(ranks, axis=1)\n    for i in range(ranks.shape[1]):\n        for j in range(i + 1, ranks.shape[1]):\n            over_j = np.sum(ranks[:, i] < ranks[:, j])\n            over_i = np.sum(ranks[:, j] < ranks[:, i])\n            tallies[i, j] = over_j\n            tallies[j, i] = over_i\n    return (tallies, names)",
            "def head_to_head_votes(ranks: List[List[int]]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    tallies = np.zeros((len(ranks[0]), len(ranks[0])))\n    names = sorted(ranks[0])\n    ranks = np.array(ranks)\n    ranks = np.argsort(ranks, axis=1)\n    for i in range(ranks.shape[1]):\n        for j in range(i + 1, ranks.shape[1]):\n            over_j = np.sum(ranks[:, i] < ranks[:, j])\n            over_i = np.sum(ranks[:, j] < ranks[:, i])\n            tallies[i, j] = over_j\n            tallies[j, i] = over_i\n    return (tallies, names)",
            "def head_to_head_votes(ranks: List[List[int]]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    tallies = np.zeros((len(ranks[0]), len(ranks[0])))\n    names = sorted(ranks[0])\n    ranks = np.array(ranks)\n    ranks = np.argsort(ranks, axis=1)\n    for i in range(ranks.shape[1]):\n        for j in range(i + 1, ranks.shape[1]):\n            over_j = np.sum(ranks[:, i] < ranks[:, j])\n            over_i = np.sum(ranks[:, j] < ranks[:, i])\n            tallies[i, j] = over_j\n            tallies[j, i] = over_i\n    return (tallies, names)",
            "def head_to_head_votes(ranks: List[List[int]]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    tallies = np.zeros((len(ranks[0]), len(ranks[0])))\n    names = sorted(ranks[0])\n    ranks = np.array(ranks)\n    ranks = np.argsort(ranks, axis=1)\n    for i in range(ranks.shape[1]):\n        for j in range(i + 1, ranks.shape[1]):\n            over_j = np.sum(ranks[:, i] < ranks[:, j])\n            over_i = np.sum(ranks[:, j] < ranks[:, i])\n            tallies[i, j] = over_j\n            tallies[j, i] = over_i\n    return (tallies, names)"
        ]
    },
    {
        "func_name": "cycle_detect",
        "original": "def cycle_detect(pairs):\n    \"\"\"Recursively detect cycles by removing condorcet losers until either only one pair is left or condorcet losers no longer exist\n    This method upholds the invariant that in a ranking for all a,b either a>b or b>a for all a,b.\n\n\n    Returns\n    -------\n    out : False if the pairs do not contain a cycle, True if the pairs contain a cycle\n\n\n    \"\"\"\n    if len(pairs) <= 1:\n        return False\n    losers = [c_lose for c_lose in np.unique(pairs[:, 1]) if c_lose not in pairs[:, 0]]\n    if len(losers) == 0:\n        return True\n    new = []\n    for p in pairs:\n        if p[1] not in losers:\n            new.append(p)\n    return cycle_detect(np.array(new))",
        "mutated": [
            "def cycle_detect(pairs):\n    if False:\n        i = 10\n    'Recursively detect cycles by removing condorcet losers until either only one pair is left or condorcet losers no longer exist\\n    This method upholds the invariant that in a ranking for all a,b either a>b or b>a for all a,b.\\n\\n\\n    Returns\\n    -------\\n    out : False if the pairs do not contain a cycle, True if the pairs contain a cycle\\n\\n\\n    '\n    if len(pairs) <= 1:\n        return False\n    losers = [c_lose for c_lose in np.unique(pairs[:, 1]) if c_lose not in pairs[:, 0]]\n    if len(losers) == 0:\n        return True\n    new = []\n    for p in pairs:\n        if p[1] not in losers:\n            new.append(p)\n    return cycle_detect(np.array(new))",
            "def cycle_detect(pairs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Recursively detect cycles by removing condorcet losers until either only one pair is left or condorcet losers no longer exist\\n    This method upholds the invariant that in a ranking for all a,b either a>b or b>a for all a,b.\\n\\n\\n    Returns\\n    -------\\n    out : False if the pairs do not contain a cycle, True if the pairs contain a cycle\\n\\n\\n    '\n    if len(pairs) <= 1:\n        return False\n    losers = [c_lose for c_lose in np.unique(pairs[:, 1]) if c_lose not in pairs[:, 0]]\n    if len(losers) == 0:\n        return True\n    new = []\n    for p in pairs:\n        if p[1] not in losers:\n            new.append(p)\n    return cycle_detect(np.array(new))",
            "def cycle_detect(pairs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Recursively detect cycles by removing condorcet losers until either only one pair is left or condorcet losers no longer exist\\n    This method upholds the invariant that in a ranking for all a,b either a>b or b>a for all a,b.\\n\\n\\n    Returns\\n    -------\\n    out : False if the pairs do not contain a cycle, True if the pairs contain a cycle\\n\\n\\n    '\n    if len(pairs) <= 1:\n        return False\n    losers = [c_lose for c_lose in np.unique(pairs[:, 1]) if c_lose not in pairs[:, 0]]\n    if len(losers) == 0:\n        return True\n    new = []\n    for p in pairs:\n        if p[1] not in losers:\n            new.append(p)\n    return cycle_detect(np.array(new))",
            "def cycle_detect(pairs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Recursively detect cycles by removing condorcet losers until either only one pair is left or condorcet losers no longer exist\\n    This method upholds the invariant that in a ranking for all a,b either a>b or b>a for all a,b.\\n\\n\\n    Returns\\n    -------\\n    out : False if the pairs do not contain a cycle, True if the pairs contain a cycle\\n\\n\\n    '\n    if len(pairs) <= 1:\n        return False\n    losers = [c_lose for c_lose in np.unique(pairs[:, 1]) if c_lose not in pairs[:, 0]]\n    if len(losers) == 0:\n        return True\n    new = []\n    for p in pairs:\n        if p[1] not in losers:\n            new.append(p)\n    return cycle_detect(np.array(new))",
            "def cycle_detect(pairs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Recursively detect cycles by removing condorcet losers until either only one pair is left or condorcet losers no longer exist\\n    This method upholds the invariant that in a ranking for all a,b either a>b or b>a for all a,b.\\n\\n\\n    Returns\\n    -------\\n    out : False if the pairs do not contain a cycle, True if the pairs contain a cycle\\n\\n\\n    '\n    if len(pairs) <= 1:\n        return False\n    losers = [c_lose for c_lose in np.unique(pairs[:, 1]) if c_lose not in pairs[:, 0]]\n    if len(losers) == 0:\n        return True\n    new = []\n    for p in pairs:\n        if p[1] not in losers:\n            new.append(p)\n    return cycle_detect(np.array(new))"
        ]
    },
    {
        "func_name": "get_winner",
        "original": "def get_winner(pairs):\n    \"\"\"\n    This returns _one_ concordant winner.\n    It could be that there are multiple concordant winners, but in our case\n    since we are interested in a ranking, we have to choose one at random.\n    \"\"\"\n    losers = np.unique(pairs[:, 1]).astype(int)\n    winners = np.unique(pairs[:, 0]).astype(int)\n    for w in winners:\n        if w not in losers:\n            return w",
        "mutated": [
            "def get_winner(pairs):\n    if False:\n        i = 10\n    '\\n    This returns _one_ concordant winner.\\n    It could be that there are multiple concordant winners, but in our case\\n    since we are interested in a ranking, we have to choose one at random.\\n    '\n    losers = np.unique(pairs[:, 1]).astype(int)\n    winners = np.unique(pairs[:, 0]).astype(int)\n    for w in winners:\n        if w not in losers:\n            return w",
            "def get_winner(pairs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    This returns _one_ concordant winner.\\n    It could be that there are multiple concordant winners, but in our case\\n    since we are interested in a ranking, we have to choose one at random.\\n    '\n    losers = np.unique(pairs[:, 1]).astype(int)\n    winners = np.unique(pairs[:, 0]).astype(int)\n    for w in winners:\n        if w not in losers:\n            return w",
            "def get_winner(pairs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    This returns _one_ concordant winner.\\n    It could be that there are multiple concordant winners, but in our case\\n    since we are interested in a ranking, we have to choose one at random.\\n    '\n    losers = np.unique(pairs[:, 1]).astype(int)\n    winners = np.unique(pairs[:, 0]).astype(int)\n    for w in winners:\n        if w not in losers:\n            return w",
            "def get_winner(pairs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    This returns _one_ concordant winner.\\n    It could be that there are multiple concordant winners, but in our case\\n    since we are interested in a ranking, we have to choose one at random.\\n    '\n    losers = np.unique(pairs[:, 1]).astype(int)\n    winners = np.unique(pairs[:, 0]).astype(int)\n    for w in winners:\n        if w not in losers:\n            return w",
            "def get_winner(pairs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    This returns _one_ concordant winner.\\n    It could be that there are multiple concordant winners, but in our case\\n    since we are interested in a ranking, we have to choose one at random.\\n    '\n    losers = np.unique(pairs[:, 1]).astype(int)\n    winners = np.unique(pairs[:, 0]).astype(int)\n    for w in winners:\n        if w not in losers:\n            return w"
        ]
    },
    {
        "func_name": "get_ranking",
        "original": "def get_ranking(pairs):\n    \"\"\"\n    Abuses concordance property to get a (not necessarily unique) ranking.\n    The lack of uniqueness is due to the potential existence of multiple\n    equally ranked winners. We have to pick one, which is where\n    the non-uniqueness comes from\n    \"\"\"\n    if len(pairs) == 1:\n        return list(pairs[0])\n    w = get_winner(pairs)\n    p_new = np.array([(a, b) for (a, b) in pairs if a != w])\n    return [w] + get_ranking(p_new)",
        "mutated": [
            "def get_ranking(pairs):\n    if False:\n        i = 10\n    '\\n    Abuses concordance property to get a (not necessarily unique) ranking.\\n    The lack of uniqueness is due to the potential existence of multiple\\n    equally ranked winners. We have to pick one, which is where\\n    the non-uniqueness comes from\\n    '\n    if len(pairs) == 1:\n        return list(pairs[0])\n    w = get_winner(pairs)\n    p_new = np.array([(a, b) for (a, b) in pairs if a != w])\n    return [w] + get_ranking(p_new)",
            "def get_ranking(pairs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Abuses concordance property to get a (not necessarily unique) ranking.\\n    The lack of uniqueness is due to the potential existence of multiple\\n    equally ranked winners. We have to pick one, which is where\\n    the non-uniqueness comes from\\n    '\n    if len(pairs) == 1:\n        return list(pairs[0])\n    w = get_winner(pairs)\n    p_new = np.array([(a, b) for (a, b) in pairs if a != w])\n    return [w] + get_ranking(p_new)",
            "def get_ranking(pairs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Abuses concordance property to get a (not necessarily unique) ranking.\\n    The lack of uniqueness is due to the potential existence of multiple\\n    equally ranked winners. We have to pick one, which is where\\n    the non-uniqueness comes from\\n    '\n    if len(pairs) == 1:\n        return list(pairs[0])\n    w = get_winner(pairs)\n    p_new = np.array([(a, b) for (a, b) in pairs if a != w])\n    return [w] + get_ranking(p_new)",
            "def get_ranking(pairs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Abuses concordance property to get a (not necessarily unique) ranking.\\n    The lack of uniqueness is due to the potential existence of multiple\\n    equally ranked winners. We have to pick one, which is where\\n    the non-uniqueness comes from\\n    '\n    if len(pairs) == 1:\n        return list(pairs[0])\n    w = get_winner(pairs)\n    p_new = np.array([(a, b) for (a, b) in pairs if a != w])\n    return [w] + get_ranking(p_new)",
            "def get_ranking(pairs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Abuses concordance property to get a (not necessarily unique) ranking.\\n    The lack of uniqueness is due to the potential existence of multiple\\n    equally ranked winners. We have to pick one, which is where\\n    the non-uniqueness comes from\\n    '\n    if len(pairs) == 1:\n        return list(pairs[0])\n    w = get_winner(pairs)\n    p_new = np.array([(a, b) for (a, b) in pairs if a != w])\n    return [w] + get_ranking(p_new)"
        ]
    },
    {
        "func_name": "ranked_pairs",
        "original": "def ranked_pairs(ranks: List[List[int]]):\n    \"\"\"\n    Expects a list of rankings for an item like:\n        [(\"w\",\"x\",\"z\",\"y\") for _ in range(3)]\n        + [(\"w\",\"y\",\"x\",\"z\") for _ in range(2)]\n        + [(\"x\",\"y\",\"z\",\"w\") for _ in range(4)]\n        + [(\"x\",\"z\",\"w\",\"y\") for _ in range(5)]\n        + [(\"y\",\"w\",\"x\",\"z\") for _ in range(1)]\n    This code is quite brain melting, but the idea is the following:\n    1. create a head-to-head matrix that tallies up all win-lose combinations of preferences\n    2. take all combinations that win more than they loose and sort those by how often they win\n    3. use that to create an (implicit) directed graph\n    4. recursively extract nodes from the graph that do not have incoming edges\n    5. said recursive list is the ranking\n    \"\"\"\n    (tallies, names) = head_to_head_votes(ranks)\n    tallies = tallies - tallies.T\n    sorted_majorities = []\n    for i in range(len(ranks[0])):\n        for j in range(len(ranks[0])):\n            if tallies[i, j] >= 0 and i != j:\n                sorted_majorities.append((i, j, tallies[i, j]))\n    sorted_majorities = np.array(sorted(sorted_majorities, key=lambda x: x[2], reverse=True))\n    lock_ins = []\n    for (x, y, _) in sorted_majorities:\n        lock_ins.append((x, y))\n        if cycle_detect(np.array(lock_ins)):\n            lock_ins = lock_ins[:-1]\n    numerical_ranks = np.array(get_ranking(np.array(lock_ins))).astype(int)\n    conversion = [names[n] for n in numerical_ranks]\n    return conversion",
        "mutated": [
            "def ranked_pairs(ranks: List[List[int]]):\n    if False:\n        i = 10\n    '\\n    Expects a list of rankings for an item like:\\n        [(\"w\",\"x\",\"z\",\"y\") for _ in range(3)]\\n        + [(\"w\",\"y\",\"x\",\"z\") for _ in range(2)]\\n        + [(\"x\",\"y\",\"z\",\"w\") for _ in range(4)]\\n        + [(\"x\",\"z\",\"w\",\"y\") for _ in range(5)]\\n        + [(\"y\",\"w\",\"x\",\"z\") for _ in range(1)]\\n    This code is quite brain melting, but the idea is the following:\\n    1. create a head-to-head matrix that tallies up all win-lose combinations of preferences\\n    2. take all combinations that win more than they loose and sort those by how often they win\\n    3. use that to create an (implicit) directed graph\\n    4. recursively extract nodes from the graph that do not have incoming edges\\n    5. said recursive list is the ranking\\n    '\n    (tallies, names) = head_to_head_votes(ranks)\n    tallies = tallies - tallies.T\n    sorted_majorities = []\n    for i in range(len(ranks[0])):\n        for j in range(len(ranks[0])):\n            if tallies[i, j] >= 0 and i != j:\n                sorted_majorities.append((i, j, tallies[i, j]))\n    sorted_majorities = np.array(sorted(sorted_majorities, key=lambda x: x[2], reverse=True))\n    lock_ins = []\n    for (x, y, _) in sorted_majorities:\n        lock_ins.append((x, y))\n        if cycle_detect(np.array(lock_ins)):\n            lock_ins = lock_ins[:-1]\n    numerical_ranks = np.array(get_ranking(np.array(lock_ins))).astype(int)\n    conversion = [names[n] for n in numerical_ranks]\n    return conversion",
            "def ranked_pairs(ranks: List[List[int]]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Expects a list of rankings for an item like:\\n        [(\"w\",\"x\",\"z\",\"y\") for _ in range(3)]\\n        + [(\"w\",\"y\",\"x\",\"z\") for _ in range(2)]\\n        + [(\"x\",\"y\",\"z\",\"w\") for _ in range(4)]\\n        + [(\"x\",\"z\",\"w\",\"y\") for _ in range(5)]\\n        + [(\"y\",\"w\",\"x\",\"z\") for _ in range(1)]\\n    This code is quite brain melting, but the idea is the following:\\n    1. create a head-to-head matrix that tallies up all win-lose combinations of preferences\\n    2. take all combinations that win more than they loose and sort those by how often they win\\n    3. use that to create an (implicit) directed graph\\n    4. recursively extract nodes from the graph that do not have incoming edges\\n    5. said recursive list is the ranking\\n    '\n    (tallies, names) = head_to_head_votes(ranks)\n    tallies = tallies - tallies.T\n    sorted_majorities = []\n    for i in range(len(ranks[0])):\n        for j in range(len(ranks[0])):\n            if tallies[i, j] >= 0 and i != j:\n                sorted_majorities.append((i, j, tallies[i, j]))\n    sorted_majorities = np.array(sorted(sorted_majorities, key=lambda x: x[2], reverse=True))\n    lock_ins = []\n    for (x, y, _) in sorted_majorities:\n        lock_ins.append((x, y))\n        if cycle_detect(np.array(lock_ins)):\n            lock_ins = lock_ins[:-1]\n    numerical_ranks = np.array(get_ranking(np.array(lock_ins))).astype(int)\n    conversion = [names[n] for n in numerical_ranks]\n    return conversion",
            "def ranked_pairs(ranks: List[List[int]]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Expects a list of rankings for an item like:\\n        [(\"w\",\"x\",\"z\",\"y\") for _ in range(3)]\\n        + [(\"w\",\"y\",\"x\",\"z\") for _ in range(2)]\\n        + [(\"x\",\"y\",\"z\",\"w\") for _ in range(4)]\\n        + [(\"x\",\"z\",\"w\",\"y\") for _ in range(5)]\\n        + [(\"y\",\"w\",\"x\",\"z\") for _ in range(1)]\\n    This code is quite brain melting, but the idea is the following:\\n    1. create a head-to-head matrix that tallies up all win-lose combinations of preferences\\n    2. take all combinations that win more than they loose and sort those by how often they win\\n    3. use that to create an (implicit) directed graph\\n    4. recursively extract nodes from the graph that do not have incoming edges\\n    5. said recursive list is the ranking\\n    '\n    (tallies, names) = head_to_head_votes(ranks)\n    tallies = tallies - tallies.T\n    sorted_majorities = []\n    for i in range(len(ranks[0])):\n        for j in range(len(ranks[0])):\n            if tallies[i, j] >= 0 and i != j:\n                sorted_majorities.append((i, j, tallies[i, j]))\n    sorted_majorities = np.array(sorted(sorted_majorities, key=lambda x: x[2], reverse=True))\n    lock_ins = []\n    for (x, y, _) in sorted_majorities:\n        lock_ins.append((x, y))\n        if cycle_detect(np.array(lock_ins)):\n            lock_ins = lock_ins[:-1]\n    numerical_ranks = np.array(get_ranking(np.array(lock_ins))).astype(int)\n    conversion = [names[n] for n in numerical_ranks]\n    return conversion",
            "def ranked_pairs(ranks: List[List[int]]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Expects a list of rankings for an item like:\\n        [(\"w\",\"x\",\"z\",\"y\") for _ in range(3)]\\n        + [(\"w\",\"y\",\"x\",\"z\") for _ in range(2)]\\n        + [(\"x\",\"y\",\"z\",\"w\") for _ in range(4)]\\n        + [(\"x\",\"z\",\"w\",\"y\") for _ in range(5)]\\n        + [(\"y\",\"w\",\"x\",\"z\") for _ in range(1)]\\n    This code is quite brain melting, but the idea is the following:\\n    1. create a head-to-head matrix that tallies up all win-lose combinations of preferences\\n    2. take all combinations that win more than they loose and sort those by how often they win\\n    3. use that to create an (implicit) directed graph\\n    4. recursively extract nodes from the graph that do not have incoming edges\\n    5. said recursive list is the ranking\\n    '\n    (tallies, names) = head_to_head_votes(ranks)\n    tallies = tallies - tallies.T\n    sorted_majorities = []\n    for i in range(len(ranks[0])):\n        for j in range(len(ranks[0])):\n            if tallies[i, j] >= 0 and i != j:\n                sorted_majorities.append((i, j, tallies[i, j]))\n    sorted_majorities = np.array(sorted(sorted_majorities, key=lambda x: x[2], reverse=True))\n    lock_ins = []\n    for (x, y, _) in sorted_majorities:\n        lock_ins.append((x, y))\n        if cycle_detect(np.array(lock_ins)):\n            lock_ins = lock_ins[:-1]\n    numerical_ranks = np.array(get_ranking(np.array(lock_ins))).astype(int)\n    conversion = [names[n] for n in numerical_ranks]\n    return conversion",
            "def ranked_pairs(ranks: List[List[int]]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Expects a list of rankings for an item like:\\n        [(\"w\",\"x\",\"z\",\"y\") for _ in range(3)]\\n        + [(\"w\",\"y\",\"x\",\"z\") for _ in range(2)]\\n        + [(\"x\",\"y\",\"z\",\"w\") for _ in range(4)]\\n        + [(\"x\",\"z\",\"w\",\"y\") for _ in range(5)]\\n        + [(\"y\",\"w\",\"x\",\"z\") for _ in range(1)]\\n    This code is quite brain melting, but the idea is the following:\\n    1. create a head-to-head matrix that tallies up all win-lose combinations of preferences\\n    2. take all combinations that win more than they loose and sort those by how often they win\\n    3. use that to create an (implicit) directed graph\\n    4. recursively extract nodes from the graph that do not have incoming edges\\n    5. said recursive list is the ranking\\n    '\n    (tallies, names) = head_to_head_votes(ranks)\n    tallies = tallies - tallies.T\n    sorted_majorities = []\n    for i in range(len(ranks[0])):\n        for j in range(len(ranks[0])):\n            if tallies[i, j] >= 0 and i != j:\n                sorted_majorities.append((i, j, tallies[i, j]))\n    sorted_majorities = np.array(sorted(sorted_majorities, key=lambda x: x[2], reverse=True))\n    lock_ins = []\n    for (x, y, _) in sorted_majorities:\n        lock_ins.append((x, y))\n        if cycle_detect(np.array(lock_ins)):\n            lock_ins = lock_ins[:-1]\n    numerical_ranks = np.array(get_ranking(np.array(lock_ins))).astype(int)\n    conversion = [names[n] for n in numerical_ranks]\n    return conversion"
        ]
    }
]