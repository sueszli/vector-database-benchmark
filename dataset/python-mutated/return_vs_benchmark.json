[
    {
        "func_name": "return_over_benchmark",
        "original": "def return_over_benchmark(prices, benchmark=0, binary=False, resample_by=None, lag=True):\n    \"\"\"\n    Return over benchmark labeling method. Sourced from Chapter 5.5.1 of Machine Learning for Factor Investing,\n    by Coqueret, G. and Guida, T. (2020).\n\n    Returns a Series or DataFrame of numerical or categorical returns over a given benchmark. The time index of the\n    benchmark must match those of the price observations.\n\n    :param prices: (pd.Series or pd.DataFrame) Time indexed prices to compare returns against a benchmark.\n    :param benchmark: (pd.Series or float) Benchmark of returns to compare the returns from prices against for labeling.\n                    Can be a constant value, or a Series matching the index of prices. If no benchmark is given, then it\n                    is assumed to have a constant value of 0.\n    :param binary: (bool) If False, labels are given by their numerical value of return over benchmark. If True,\n                labels are given according to the sign of their excess return.\n    :param resample_by: (str) If not None, the resampling period for price data prior to calculating returns. 'B' = per\n                        business day, 'W' = week, 'M' = month, etc. Will take the last observation for each period.\n                        For full details see `here.\n                        <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#dateoffset-objects>`_\n    :param lag: (bool) If True, returns will be lagged to make them forward-looking.\n    :return: (pd.Series or pd.DataFrame) Excess returns over benchmark. If binary, the labels are -1 if the\n            return is below the benchmark, 1 if above, and 0 if it exactly matches the benchmark.\n    \"\"\"\n    pass",
        "mutated": [
            "def return_over_benchmark(prices, benchmark=0, binary=False, resample_by=None, lag=True):\n    if False:\n        i = 10\n    \"\\n    Return over benchmark labeling method. Sourced from Chapter 5.5.1 of Machine Learning for Factor Investing,\\n    by Coqueret, G. and Guida, T. (2020).\\n\\n    Returns a Series or DataFrame of numerical or categorical returns over a given benchmark. The time index of the\\n    benchmark must match those of the price observations.\\n\\n    :param prices: (pd.Series or pd.DataFrame) Time indexed prices to compare returns against a benchmark.\\n    :param benchmark: (pd.Series or float) Benchmark of returns to compare the returns from prices against for labeling.\\n                    Can be a constant value, or a Series matching the index of prices. If no benchmark is given, then it\\n                    is assumed to have a constant value of 0.\\n    :param binary: (bool) If False, labels are given by their numerical value of return over benchmark. If True,\\n                labels are given according to the sign of their excess return.\\n    :param resample_by: (str) If not None, the resampling period for price data prior to calculating returns. 'B' = per\\n                        business day, 'W' = week, 'M' = month, etc. Will take the last observation for each period.\\n                        For full details see `here.\\n                        <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#dateoffset-objects>`_\\n    :param lag: (bool) If True, returns will be lagged to make them forward-looking.\\n    :return: (pd.Series or pd.DataFrame) Excess returns over benchmark. If binary, the labels are -1 if the\\n            return is below the benchmark, 1 if above, and 0 if it exactly matches the benchmark.\\n    \"\n    pass",
            "def return_over_benchmark(prices, benchmark=0, binary=False, resample_by=None, lag=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Return over benchmark labeling method. Sourced from Chapter 5.5.1 of Machine Learning for Factor Investing,\\n    by Coqueret, G. and Guida, T. (2020).\\n\\n    Returns a Series or DataFrame of numerical or categorical returns over a given benchmark. The time index of the\\n    benchmark must match those of the price observations.\\n\\n    :param prices: (pd.Series or pd.DataFrame) Time indexed prices to compare returns against a benchmark.\\n    :param benchmark: (pd.Series or float) Benchmark of returns to compare the returns from prices against for labeling.\\n                    Can be a constant value, or a Series matching the index of prices. If no benchmark is given, then it\\n                    is assumed to have a constant value of 0.\\n    :param binary: (bool) If False, labels are given by their numerical value of return over benchmark. If True,\\n                labels are given according to the sign of their excess return.\\n    :param resample_by: (str) If not None, the resampling period for price data prior to calculating returns. 'B' = per\\n                        business day, 'W' = week, 'M' = month, etc. Will take the last observation for each period.\\n                        For full details see `here.\\n                        <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#dateoffset-objects>`_\\n    :param lag: (bool) If True, returns will be lagged to make them forward-looking.\\n    :return: (pd.Series or pd.DataFrame) Excess returns over benchmark. If binary, the labels are -1 if the\\n            return is below the benchmark, 1 if above, and 0 if it exactly matches the benchmark.\\n    \"\n    pass",
            "def return_over_benchmark(prices, benchmark=0, binary=False, resample_by=None, lag=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Return over benchmark labeling method. Sourced from Chapter 5.5.1 of Machine Learning for Factor Investing,\\n    by Coqueret, G. and Guida, T. (2020).\\n\\n    Returns a Series or DataFrame of numerical or categorical returns over a given benchmark. The time index of the\\n    benchmark must match those of the price observations.\\n\\n    :param prices: (pd.Series or pd.DataFrame) Time indexed prices to compare returns against a benchmark.\\n    :param benchmark: (pd.Series or float) Benchmark of returns to compare the returns from prices against for labeling.\\n                    Can be a constant value, or a Series matching the index of prices. If no benchmark is given, then it\\n                    is assumed to have a constant value of 0.\\n    :param binary: (bool) If False, labels are given by their numerical value of return over benchmark. If True,\\n                labels are given according to the sign of their excess return.\\n    :param resample_by: (str) If not None, the resampling period for price data prior to calculating returns. 'B' = per\\n                        business day, 'W' = week, 'M' = month, etc. Will take the last observation for each period.\\n                        For full details see `here.\\n                        <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#dateoffset-objects>`_\\n    :param lag: (bool) If True, returns will be lagged to make them forward-looking.\\n    :return: (pd.Series or pd.DataFrame) Excess returns over benchmark. If binary, the labels are -1 if the\\n            return is below the benchmark, 1 if above, and 0 if it exactly matches the benchmark.\\n    \"\n    pass",
            "def return_over_benchmark(prices, benchmark=0, binary=False, resample_by=None, lag=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Return over benchmark labeling method. Sourced from Chapter 5.5.1 of Machine Learning for Factor Investing,\\n    by Coqueret, G. and Guida, T. (2020).\\n\\n    Returns a Series or DataFrame of numerical or categorical returns over a given benchmark. The time index of the\\n    benchmark must match those of the price observations.\\n\\n    :param prices: (pd.Series or pd.DataFrame) Time indexed prices to compare returns against a benchmark.\\n    :param benchmark: (pd.Series or float) Benchmark of returns to compare the returns from prices against for labeling.\\n                    Can be a constant value, or a Series matching the index of prices. If no benchmark is given, then it\\n                    is assumed to have a constant value of 0.\\n    :param binary: (bool) If False, labels are given by their numerical value of return over benchmark. If True,\\n                labels are given according to the sign of their excess return.\\n    :param resample_by: (str) If not None, the resampling period for price data prior to calculating returns. 'B' = per\\n                        business day, 'W' = week, 'M' = month, etc. Will take the last observation for each period.\\n                        For full details see `here.\\n                        <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#dateoffset-objects>`_\\n    :param lag: (bool) If True, returns will be lagged to make them forward-looking.\\n    :return: (pd.Series or pd.DataFrame) Excess returns over benchmark. If binary, the labels are -1 if the\\n            return is below the benchmark, 1 if above, and 0 if it exactly matches the benchmark.\\n    \"\n    pass",
            "def return_over_benchmark(prices, benchmark=0, binary=False, resample_by=None, lag=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Return over benchmark labeling method. Sourced from Chapter 5.5.1 of Machine Learning for Factor Investing,\\n    by Coqueret, G. and Guida, T. (2020).\\n\\n    Returns a Series or DataFrame of numerical or categorical returns over a given benchmark. The time index of the\\n    benchmark must match those of the price observations.\\n\\n    :param prices: (pd.Series or pd.DataFrame) Time indexed prices to compare returns against a benchmark.\\n    :param benchmark: (pd.Series or float) Benchmark of returns to compare the returns from prices against for labeling.\\n                    Can be a constant value, or a Series matching the index of prices. If no benchmark is given, then it\\n                    is assumed to have a constant value of 0.\\n    :param binary: (bool) If False, labels are given by their numerical value of return over benchmark. If True,\\n                labels are given according to the sign of their excess return.\\n    :param resample_by: (str) If not None, the resampling period for price data prior to calculating returns. 'B' = per\\n                        business day, 'W' = week, 'M' = month, etc. Will take the last observation for each period.\\n                        For full details see `here.\\n                        <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#dateoffset-objects>`_\\n    :param lag: (bool) If True, returns will be lagged to make them forward-looking.\\n    :return: (pd.Series or pd.DataFrame) Excess returns over benchmark. If binary, the labels are -1 if the\\n            return is below the benchmark, 1 if above, and 0 if it exactly matches the benchmark.\\n    \"\n    pass"
        ]
    }
]