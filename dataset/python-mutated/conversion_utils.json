[
    {
        "func_name": "_apply_defaults_to_schema_field",
        "original": "def _apply_defaults_to_schema_field(field: Field, additional_default_values: Any) -> Field:\n    evr = validate_config(field.config_type, additional_default_values)\n    if not evr.success:\n        raise DagsterInvalidConfigError('Incorrect values passed to .configured', evr.errors, additional_default_values)\n    if field.default_provided:\n        defaults_processed_evr = resolve_defaults(field.config_type, additional_default_values)\n        check.invariant(defaults_processed_evr.success, 'Since validation passed, this should always work.')\n        default_to_pass = defaults_processed_evr.value\n        return copy_with_default(field, default_to_pass)\n    else:\n        return copy_with_default(field, additional_default_values)",
        "mutated": [
            "def _apply_defaults_to_schema_field(field: Field, additional_default_values: Any) -> Field:\n    if False:\n        i = 10\n    evr = validate_config(field.config_type, additional_default_values)\n    if not evr.success:\n        raise DagsterInvalidConfigError('Incorrect values passed to .configured', evr.errors, additional_default_values)\n    if field.default_provided:\n        defaults_processed_evr = resolve_defaults(field.config_type, additional_default_values)\n        check.invariant(defaults_processed_evr.success, 'Since validation passed, this should always work.')\n        default_to_pass = defaults_processed_evr.value\n        return copy_with_default(field, default_to_pass)\n    else:\n        return copy_with_default(field, additional_default_values)",
            "def _apply_defaults_to_schema_field(field: Field, additional_default_values: Any) -> Field:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    evr = validate_config(field.config_type, additional_default_values)\n    if not evr.success:\n        raise DagsterInvalidConfigError('Incorrect values passed to .configured', evr.errors, additional_default_values)\n    if field.default_provided:\n        defaults_processed_evr = resolve_defaults(field.config_type, additional_default_values)\n        check.invariant(defaults_processed_evr.success, 'Since validation passed, this should always work.')\n        default_to_pass = defaults_processed_evr.value\n        return copy_with_default(field, default_to_pass)\n    else:\n        return copy_with_default(field, additional_default_values)",
            "def _apply_defaults_to_schema_field(field: Field, additional_default_values: Any) -> Field:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    evr = validate_config(field.config_type, additional_default_values)\n    if not evr.success:\n        raise DagsterInvalidConfigError('Incorrect values passed to .configured', evr.errors, additional_default_values)\n    if field.default_provided:\n        defaults_processed_evr = resolve_defaults(field.config_type, additional_default_values)\n        check.invariant(defaults_processed_evr.success, 'Since validation passed, this should always work.')\n        default_to_pass = defaults_processed_evr.value\n        return copy_with_default(field, default_to_pass)\n    else:\n        return copy_with_default(field, additional_default_values)",
            "def _apply_defaults_to_schema_field(field: Field, additional_default_values: Any) -> Field:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    evr = validate_config(field.config_type, additional_default_values)\n    if not evr.success:\n        raise DagsterInvalidConfigError('Incorrect values passed to .configured', evr.errors, additional_default_values)\n    if field.default_provided:\n        defaults_processed_evr = resolve_defaults(field.config_type, additional_default_values)\n        check.invariant(defaults_processed_evr.success, 'Since validation passed, this should always work.')\n        default_to_pass = defaults_processed_evr.value\n        return copy_with_default(field, default_to_pass)\n    else:\n        return copy_with_default(field, additional_default_values)",
            "def _apply_defaults_to_schema_field(field: Field, additional_default_values: Any) -> Field:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    evr = validate_config(field.config_type, additional_default_values)\n    if not evr.success:\n        raise DagsterInvalidConfigError('Incorrect values passed to .configured', evr.errors, additional_default_values)\n    if field.default_provided:\n        defaults_processed_evr = resolve_defaults(field.config_type, additional_default_values)\n        check.invariant(defaults_processed_evr.success, 'Since validation passed, this should always work.')\n        default_to_pass = defaults_processed_evr.value\n        return copy_with_default(field, default_to_pass)\n    else:\n        return copy_with_default(field, additional_default_values)"
        ]
    },
    {
        "func_name": "copy_with_default",
        "original": "def copy_with_default(old_field: Field, new_config_value: Any) -> Field:\n    return Field(config=old_field.config_type, default_value=new_config_value, is_required=False, description=old_field.description)",
        "mutated": [
            "def copy_with_default(old_field: Field, new_config_value: Any) -> Field:\n    if False:\n        i = 10\n    return Field(config=old_field.config_type, default_value=new_config_value, is_required=False, description=old_field.description)",
            "def copy_with_default(old_field: Field, new_config_value: Any) -> Field:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return Field(config=old_field.config_type, default_value=new_config_value, is_required=False, description=old_field.description)",
            "def copy_with_default(old_field: Field, new_config_value: Any) -> Field:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return Field(config=old_field.config_type, default_value=new_config_value, is_required=False, description=old_field.description)",
            "def copy_with_default(old_field: Field, new_config_value: Any) -> Field:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return Field(config=old_field.config_type, default_value=new_config_value, is_required=False, description=old_field.description)",
            "def copy_with_default(old_field: Field, new_config_value: Any) -> Field:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return Field(config=old_field.config_type, default_value=new_config_value, is_required=False, description=old_field.description)"
        ]
    },
    {
        "func_name": "_curry_config_schema",
        "original": "def _curry_config_schema(schema_field: Field, data: Any) -> DefinitionConfigSchema:\n    \"\"\"Return a new config schema configured with the passed in data.\"\"\"\n    return DefinitionConfigSchema(_apply_defaults_to_schema_field(schema_field, data))",
        "mutated": [
            "def _curry_config_schema(schema_field: Field, data: Any) -> DefinitionConfigSchema:\n    if False:\n        i = 10\n    'Return a new config schema configured with the passed in data.'\n    return DefinitionConfigSchema(_apply_defaults_to_schema_field(schema_field, data))",
            "def _curry_config_schema(schema_field: Field, data: Any) -> DefinitionConfigSchema:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Return a new config schema configured with the passed in data.'\n    return DefinitionConfigSchema(_apply_defaults_to_schema_field(schema_field, data))",
            "def _curry_config_schema(schema_field: Field, data: Any) -> DefinitionConfigSchema:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Return a new config schema configured with the passed in data.'\n    return DefinitionConfigSchema(_apply_defaults_to_schema_field(schema_field, data))",
            "def _curry_config_schema(schema_field: Field, data: Any) -> DefinitionConfigSchema:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Return a new config schema configured with the passed in data.'\n    return DefinitionConfigSchema(_apply_defaults_to_schema_field(schema_field, data))",
            "def _curry_config_schema(schema_field: Field, data: Any) -> DefinitionConfigSchema:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Return a new config schema configured with the passed in data.'\n    return DefinitionConfigSchema(_apply_defaults_to_schema_field(schema_field, data))"
        ]
    },
    {
        "func_name": "_convert_pydantic_field",
        "original": "def _convert_pydantic_field(pydantic_field: ModelFieldCompat, model_cls: Optional[Type]=None) -> Field:\n    \"\"\"Transforms a Pydantic field into a corresponding Dagster config field.\n\n\n    Args:\n        pydantic_field (ModelFieldCompat): The Pydantic field to convert.\n        model_cls (Optional[Type]): The Pydantic model class that the field belongs to. This is\n            used for error messages.\n    \"\"\"\n    from .config import Config, infer_schema_from_config_class\n    if pydantic_field.discriminator:\n        return _convert_pydantic_discriminated_union_field(pydantic_field)\n    field_type = pydantic_field.annotation\n    if safe_is_subclass(field_type, Config):\n        inferred_field = infer_schema_from_config_class(field_type, description=pydantic_field.description)\n        return inferred_field\n    else:\n        if not pydantic_field.is_required() and (not is_optional(field_type)):\n            field_type = Optional[field_type]\n        config_type = _config_type_for_type_on_pydantic_field(field_type)\n        return Field(config=config_type, description=pydantic_field.description, is_required=pydantic_field.is_required() and (not is_optional(field_type)), default_value=pydantic_field.default if pydantic_field.default is not PydanticUndefined else FIELD_NO_DEFAULT_PROVIDED)",
        "mutated": [
            "def _convert_pydantic_field(pydantic_field: ModelFieldCompat, model_cls: Optional[Type]=None) -> Field:\n    if False:\n        i = 10\n    'Transforms a Pydantic field into a corresponding Dagster config field.\\n\\n\\n    Args:\\n        pydantic_field (ModelFieldCompat): The Pydantic field to convert.\\n        model_cls (Optional[Type]): The Pydantic model class that the field belongs to. This is\\n            used for error messages.\\n    '\n    from .config import Config, infer_schema_from_config_class\n    if pydantic_field.discriminator:\n        return _convert_pydantic_discriminated_union_field(pydantic_field)\n    field_type = pydantic_field.annotation\n    if safe_is_subclass(field_type, Config):\n        inferred_field = infer_schema_from_config_class(field_type, description=pydantic_field.description)\n        return inferred_field\n    else:\n        if not pydantic_field.is_required() and (not is_optional(field_type)):\n            field_type = Optional[field_type]\n        config_type = _config_type_for_type_on_pydantic_field(field_type)\n        return Field(config=config_type, description=pydantic_field.description, is_required=pydantic_field.is_required() and (not is_optional(field_type)), default_value=pydantic_field.default if pydantic_field.default is not PydanticUndefined else FIELD_NO_DEFAULT_PROVIDED)",
            "def _convert_pydantic_field(pydantic_field: ModelFieldCompat, model_cls: Optional[Type]=None) -> Field:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Transforms a Pydantic field into a corresponding Dagster config field.\\n\\n\\n    Args:\\n        pydantic_field (ModelFieldCompat): The Pydantic field to convert.\\n        model_cls (Optional[Type]): The Pydantic model class that the field belongs to. This is\\n            used for error messages.\\n    '\n    from .config import Config, infer_schema_from_config_class\n    if pydantic_field.discriminator:\n        return _convert_pydantic_discriminated_union_field(pydantic_field)\n    field_type = pydantic_field.annotation\n    if safe_is_subclass(field_type, Config):\n        inferred_field = infer_schema_from_config_class(field_type, description=pydantic_field.description)\n        return inferred_field\n    else:\n        if not pydantic_field.is_required() and (not is_optional(field_type)):\n            field_type = Optional[field_type]\n        config_type = _config_type_for_type_on_pydantic_field(field_type)\n        return Field(config=config_type, description=pydantic_field.description, is_required=pydantic_field.is_required() and (not is_optional(field_type)), default_value=pydantic_field.default if pydantic_field.default is not PydanticUndefined else FIELD_NO_DEFAULT_PROVIDED)",
            "def _convert_pydantic_field(pydantic_field: ModelFieldCompat, model_cls: Optional[Type]=None) -> Field:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Transforms a Pydantic field into a corresponding Dagster config field.\\n\\n\\n    Args:\\n        pydantic_field (ModelFieldCompat): The Pydantic field to convert.\\n        model_cls (Optional[Type]): The Pydantic model class that the field belongs to. This is\\n            used for error messages.\\n    '\n    from .config import Config, infer_schema_from_config_class\n    if pydantic_field.discriminator:\n        return _convert_pydantic_discriminated_union_field(pydantic_field)\n    field_type = pydantic_field.annotation\n    if safe_is_subclass(field_type, Config):\n        inferred_field = infer_schema_from_config_class(field_type, description=pydantic_field.description)\n        return inferred_field\n    else:\n        if not pydantic_field.is_required() and (not is_optional(field_type)):\n            field_type = Optional[field_type]\n        config_type = _config_type_for_type_on_pydantic_field(field_type)\n        return Field(config=config_type, description=pydantic_field.description, is_required=pydantic_field.is_required() and (not is_optional(field_type)), default_value=pydantic_field.default if pydantic_field.default is not PydanticUndefined else FIELD_NO_DEFAULT_PROVIDED)",
            "def _convert_pydantic_field(pydantic_field: ModelFieldCompat, model_cls: Optional[Type]=None) -> Field:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Transforms a Pydantic field into a corresponding Dagster config field.\\n\\n\\n    Args:\\n        pydantic_field (ModelFieldCompat): The Pydantic field to convert.\\n        model_cls (Optional[Type]): The Pydantic model class that the field belongs to. This is\\n            used for error messages.\\n    '\n    from .config import Config, infer_schema_from_config_class\n    if pydantic_field.discriminator:\n        return _convert_pydantic_discriminated_union_field(pydantic_field)\n    field_type = pydantic_field.annotation\n    if safe_is_subclass(field_type, Config):\n        inferred_field = infer_schema_from_config_class(field_type, description=pydantic_field.description)\n        return inferred_field\n    else:\n        if not pydantic_field.is_required() and (not is_optional(field_type)):\n            field_type = Optional[field_type]\n        config_type = _config_type_for_type_on_pydantic_field(field_type)\n        return Field(config=config_type, description=pydantic_field.description, is_required=pydantic_field.is_required() and (not is_optional(field_type)), default_value=pydantic_field.default if pydantic_field.default is not PydanticUndefined else FIELD_NO_DEFAULT_PROVIDED)",
            "def _convert_pydantic_field(pydantic_field: ModelFieldCompat, model_cls: Optional[Type]=None) -> Field:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Transforms a Pydantic field into a corresponding Dagster config field.\\n\\n\\n    Args:\\n        pydantic_field (ModelFieldCompat): The Pydantic field to convert.\\n        model_cls (Optional[Type]): The Pydantic model class that the field belongs to. This is\\n            used for error messages.\\n    '\n    from .config import Config, infer_schema_from_config_class\n    if pydantic_field.discriminator:\n        return _convert_pydantic_discriminated_union_field(pydantic_field)\n    field_type = pydantic_field.annotation\n    if safe_is_subclass(field_type, Config):\n        inferred_field = infer_schema_from_config_class(field_type, description=pydantic_field.description)\n        return inferred_field\n    else:\n        if not pydantic_field.is_required() and (not is_optional(field_type)):\n            field_type = Optional[field_type]\n        config_type = _config_type_for_type_on_pydantic_field(field_type)\n        return Field(config=config_type, description=pydantic_field.description, is_required=pydantic_field.is_required() and (not is_optional(field_type)), default_value=pydantic_field.default if pydantic_field.default is not PydanticUndefined else FIELD_NO_DEFAULT_PROVIDED)"
        ]
    },
    {
        "func_name": "strip_wrapping_annotated_types",
        "original": "def strip_wrapping_annotated_types(potentially_annotated_type: Any) -> Any:\n    \"\"\"For a type that is wrapped in Annotated, return the unwrapped type. Recursive,\n    so it will unwrap nested Annotated types.\n\n    e.g. Annotated[Annotated[List[str], \"foo\"], \"bar] -> List[str]\n    \"\"\"\n    while get_origin(potentially_annotated_type) == Annotated:\n        potentially_annotated_type = get_args(potentially_annotated_type)[0]\n    return potentially_annotated_type",
        "mutated": [
            "def strip_wrapping_annotated_types(potentially_annotated_type: Any) -> Any:\n    if False:\n        i = 10\n    'For a type that is wrapped in Annotated, return the unwrapped type. Recursive,\\n    so it will unwrap nested Annotated types.\\n\\n    e.g. Annotated[Annotated[List[str], \"foo\"], \"bar] -> List[str]\\n    '\n    while get_origin(potentially_annotated_type) == Annotated:\n        potentially_annotated_type = get_args(potentially_annotated_type)[0]\n    return potentially_annotated_type",
            "def strip_wrapping_annotated_types(potentially_annotated_type: Any) -> Any:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'For a type that is wrapped in Annotated, return the unwrapped type. Recursive,\\n    so it will unwrap nested Annotated types.\\n\\n    e.g. Annotated[Annotated[List[str], \"foo\"], \"bar] -> List[str]\\n    '\n    while get_origin(potentially_annotated_type) == Annotated:\n        potentially_annotated_type = get_args(potentially_annotated_type)[0]\n    return potentially_annotated_type",
            "def strip_wrapping_annotated_types(potentially_annotated_type: Any) -> Any:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'For a type that is wrapped in Annotated, return the unwrapped type. Recursive,\\n    so it will unwrap nested Annotated types.\\n\\n    e.g. Annotated[Annotated[List[str], \"foo\"], \"bar] -> List[str]\\n    '\n    while get_origin(potentially_annotated_type) == Annotated:\n        potentially_annotated_type = get_args(potentially_annotated_type)[0]\n    return potentially_annotated_type",
            "def strip_wrapping_annotated_types(potentially_annotated_type: Any) -> Any:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'For a type that is wrapped in Annotated, return the unwrapped type. Recursive,\\n    so it will unwrap nested Annotated types.\\n\\n    e.g. Annotated[Annotated[List[str], \"foo\"], \"bar] -> List[str]\\n    '\n    while get_origin(potentially_annotated_type) == Annotated:\n        potentially_annotated_type = get_args(potentially_annotated_type)[0]\n    return potentially_annotated_type",
            "def strip_wrapping_annotated_types(potentially_annotated_type: Any) -> Any:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'For a type that is wrapped in Annotated, return the unwrapped type. Recursive,\\n    so it will unwrap nested Annotated types.\\n\\n    e.g. Annotated[Annotated[List[str], \"foo\"], \"bar] -> List[str]\\n    '\n    while get_origin(potentially_annotated_type) == Annotated:\n        potentially_annotated_type = get_args(potentially_annotated_type)[0]\n    return potentially_annotated_type"
        ]
    },
    {
        "func_name": "_config_type_for_type_on_pydantic_field",
        "original": "def _config_type_for_type_on_pydantic_field(potential_dagster_type: Any) -> ConfigType:\n    \"\"\"Generates a Dagster ConfigType from a Pydantic field's Python type.\n\n    Args:\n        potential_dagster_type (Any): The Python type of the Pydantic field.\n    \"\"\"\n    potential_dagster_type = strip_wrapping_annotated_types(potential_dagster_type)\n    try:\n        from pydantic import ConstrainedFloat, ConstrainedInt, ConstrainedStr\n        if safe_is_subclass(potential_dagster_type, ConstrainedStr):\n            return StringSource\n        elif safe_is_subclass(potential_dagster_type, ConstrainedFloat):\n            potential_dagster_type = float\n        elif safe_is_subclass(potential_dagster_type, ConstrainedInt):\n            return IntSource\n    except ImportError:\n        pass\n    if safe_is_subclass(get_origin(potential_dagster_type), List):\n        list_inner_type = get_args(potential_dagster_type)[0]\n        return Array(_config_type_for_type_on_pydantic_field(list_inner_type))\n    elif is_optional(potential_dagster_type):\n        optional_inner_type = next((arg for arg in get_args(potential_dagster_type) if arg is not type(None)))\n        return Noneable(_config_type_for_type_on_pydantic_field(optional_inner_type))\n    elif safe_is_subclass(get_origin(potential_dagster_type), Dict) or safe_is_subclass(get_origin(potential_dagster_type), Mapping):\n        (key_type, value_type) = get_args(potential_dagster_type)\n        return Map(key_type, _config_type_for_type_on_pydantic_field(value_type))\n    from .config import Config, infer_schema_from_config_class\n    if safe_is_subclass(potential_dagster_type, Config):\n        inferred_field = infer_schema_from_config_class(potential_dagster_type)\n        return inferred_field.config_type\n    if safe_is_subclass(potential_dagster_type, Enum):\n        return DagsterEnum.from_python_enum_direct_values(potential_dagster_type)\n    if potential_dagster_type is str:\n        return StringSource\n    elif potential_dagster_type is int:\n        return IntSource\n    elif potential_dagster_type is bool:\n        return BoolSource\n    else:\n        return convert_potential_field(potential_dagster_type).config_type",
        "mutated": [
            "def _config_type_for_type_on_pydantic_field(potential_dagster_type: Any) -> ConfigType:\n    if False:\n        i = 10\n    \"Generates a Dagster ConfigType from a Pydantic field's Python type.\\n\\n    Args:\\n        potential_dagster_type (Any): The Python type of the Pydantic field.\\n    \"\n    potential_dagster_type = strip_wrapping_annotated_types(potential_dagster_type)\n    try:\n        from pydantic import ConstrainedFloat, ConstrainedInt, ConstrainedStr\n        if safe_is_subclass(potential_dagster_type, ConstrainedStr):\n            return StringSource\n        elif safe_is_subclass(potential_dagster_type, ConstrainedFloat):\n            potential_dagster_type = float\n        elif safe_is_subclass(potential_dagster_type, ConstrainedInt):\n            return IntSource\n    except ImportError:\n        pass\n    if safe_is_subclass(get_origin(potential_dagster_type), List):\n        list_inner_type = get_args(potential_dagster_type)[0]\n        return Array(_config_type_for_type_on_pydantic_field(list_inner_type))\n    elif is_optional(potential_dagster_type):\n        optional_inner_type = next((arg for arg in get_args(potential_dagster_type) if arg is not type(None)))\n        return Noneable(_config_type_for_type_on_pydantic_field(optional_inner_type))\n    elif safe_is_subclass(get_origin(potential_dagster_type), Dict) or safe_is_subclass(get_origin(potential_dagster_type), Mapping):\n        (key_type, value_type) = get_args(potential_dagster_type)\n        return Map(key_type, _config_type_for_type_on_pydantic_field(value_type))\n    from .config import Config, infer_schema_from_config_class\n    if safe_is_subclass(potential_dagster_type, Config):\n        inferred_field = infer_schema_from_config_class(potential_dagster_type)\n        return inferred_field.config_type\n    if safe_is_subclass(potential_dagster_type, Enum):\n        return DagsterEnum.from_python_enum_direct_values(potential_dagster_type)\n    if potential_dagster_type is str:\n        return StringSource\n    elif potential_dagster_type is int:\n        return IntSource\n    elif potential_dagster_type is bool:\n        return BoolSource\n    else:\n        return convert_potential_field(potential_dagster_type).config_type",
            "def _config_type_for_type_on_pydantic_field(potential_dagster_type: Any) -> ConfigType:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Generates a Dagster ConfigType from a Pydantic field's Python type.\\n\\n    Args:\\n        potential_dagster_type (Any): The Python type of the Pydantic field.\\n    \"\n    potential_dagster_type = strip_wrapping_annotated_types(potential_dagster_type)\n    try:\n        from pydantic import ConstrainedFloat, ConstrainedInt, ConstrainedStr\n        if safe_is_subclass(potential_dagster_type, ConstrainedStr):\n            return StringSource\n        elif safe_is_subclass(potential_dagster_type, ConstrainedFloat):\n            potential_dagster_type = float\n        elif safe_is_subclass(potential_dagster_type, ConstrainedInt):\n            return IntSource\n    except ImportError:\n        pass\n    if safe_is_subclass(get_origin(potential_dagster_type), List):\n        list_inner_type = get_args(potential_dagster_type)[0]\n        return Array(_config_type_for_type_on_pydantic_field(list_inner_type))\n    elif is_optional(potential_dagster_type):\n        optional_inner_type = next((arg for arg in get_args(potential_dagster_type) if arg is not type(None)))\n        return Noneable(_config_type_for_type_on_pydantic_field(optional_inner_type))\n    elif safe_is_subclass(get_origin(potential_dagster_type), Dict) or safe_is_subclass(get_origin(potential_dagster_type), Mapping):\n        (key_type, value_type) = get_args(potential_dagster_type)\n        return Map(key_type, _config_type_for_type_on_pydantic_field(value_type))\n    from .config import Config, infer_schema_from_config_class\n    if safe_is_subclass(potential_dagster_type, Config):\n        inferred_field = infer_schema_from_config_class(potential_dagster_type)\n        return inferred_field.config_type\n    if safe_is_subclass(potential_dagster_type, Enum):\n        return DagsterEnum.from_python_enum_direct_values(potential_dagster_type)\n    if potential_dagster_type is str:\n        return StringSource\n    elif potential_dagster_type is int:\n        return IntSource\n    elif potential_dagster_type is bool:\n        return BoolSource\n    else:\n        return convert_potential_field(potential_dagster_type).config_type",
            "def _config_type_for_type_on_pydantic_field(potential_dagster_type: Any) -> ConfigType:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Generates a Dagster ConfigType from a Pydantic field's Python type.\\n\\n    Args:\\n        potential_dagster_type (Any): The Python type of the Pydantic field.\\n    \"\n    potential_dagster_type = strip_wrapping_annotated_types(potential_dagster_type)\n    try:\n        from pydantic import ConstrainedFloat, ConstrainedInt, ConstrainedStr\n        if safe_is_subclass(potential_dagster_type, ConstrainedStr):\n            return StringSource\n        elif safe_is_subclass(potential_dagster_type, ConstrainedFloat):\n            potential_dagster_type = float\n        elif safe_is_subclass(potential_dagster_type, ConstrainedInt):\n            return IntSource\n    except ImportError:\n        pass\n    if safe_is_subclass(get_origin(potential_dagster_type), List):\n        list_inner_type = get_args(potential_dagster_type)[0]\n        return Array(_config_type_for_type_on_pydantic_field(list_inner_type))\n    elif is_optional(potential_dagster_type):\n        optional_inner_type = next((arg for arg in get_args(potential_dagster_type) if arg is not type(None)))\n        return Noneable(_config_type_for_type_on_pydantic_field(optional_inner_type))\n    elif safe_is_subclass(get_origin(potential_dagster_type), Dict) or safe_is_subclass(get_origin(potential_dagster_type), Mapping):\n        (key_type, value_type) = get_args(potential_dagster_type)\n        return Map(key_type, _config_type_for_type_on_pydantic_field(value_type))\n    from .config import Config, infer_schema_from_config_class\n    if safe_is_subclass(potential_dagster_type, Config):\n        inferred_field = infer_schema_from_config_class(potential_dagster_type)\n        return inferred_field.config_type\n    if safe_is_subclass(potential_dagster_type, Enum):\n        return DagsterEnum.from_python_enum_direct_values(potential_dagster_type)\n    if potential_dagster_type is str:\n        return StringSource\n    elif potential_dagster_type is int:\n        return IntSource\n    elif potential_dagster_type is bool:\n        return BoolSource\n    else:\n        return convert_potential_field(potential_dagster_type).config_type",
            "def _config_type_for_type_on_pydantic_field(potential_dagster_type: Any) -> ConfigType:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Generates a Dagster ConfigType from a Pydantic field's Python type.\\n\\n    Args:\\n        potential_dagster_type (Any): The Python type of the Pydantic field.\\n    \"\n    potential_dagster_type = strip_wrapping_annotated_types(potential_dagster_type)\n    try:\n        from pydantic import ConstrainedFloat, ConstrainedInt, ConstrainedStr\n        if safe_is_subclass(potential_dagster_type, ConstrainedStr):\n            return StringSource\n        elif safe_is_subclass(potential_dagster_type, ConstrainedFloat):\n            potential_dagster_type = float\n        elif safe_is_subclass(potential_dagster_type, ConstrainedInt):\n            return IntSource\n    except ImportError:\n        pass\n    if safe_is_subclass(get_origin(potential_dagster_type), List):\n        list_inner_type = get_args(potential_dagster_type)[0]\n        return Array(_config_type_for_type_on_pydantic_field(list_inner_type))\n    elif is_optional(potential_dagster_type):\n        optional_inner_type = next((arg for arg in get_args(potential_dagster_type) if arg is not type(None)))\n        return Noneable(_config_type_for_type_on_pydantic_field(optional_inner_type))\n    elif safe_is_subclass(get_origin(potential_dagster_type), Dict) or safe_is_subclass(get_origin(potential_dagster_type), Mapping):\n        (key_type, value_type) = get_args(potential_dagster_type)\n        return Map(key_type, _config_type_for_type_on_pydantic_field(value_type))\n    from .config import Config, infer_schema_from_config_class\n    if safe_is_subclass(potential_dagster_type, Config):\n        inferred_field = infer_schema_from_config_class(potential_dagster_type)\n        return inferred_field.config_type\n    if safe_is_subclass(potential_dagster_type, Enum):\n        return DagsterEnum.from_python_enum_direct_values(potential_dagster_type)\n    if potential_dagster_type is str:\n        return StringSource\n    elif potential_dagster_type is int:\n        return IntSource\n    elif potential_dagster_type is bool:\n        return BoolSource\n    else:\n        return convert_potential_field(potential_dagster_type).config_type",
            "def _config_type_for_type_on_pydantic_field(potential_dagster_type: Any) -> ConfigType:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Generates a Dagster ConfigType from a Pydantic field's Python type.\\n\\n    Args:\\n        potential_dagster_type (Any): The Python type of the Pydantic field.\\n    \"\n    potential_dagster_type = strip_wrapping_annotated_types(potential_dagster_type)\n    try:\n        from pydantic import ConstrainedFloat, ConstrainedInt, ConstrainedStr\n        if safe_is_subclass(potential_dagster_type, ConstrainedStr):\n            return StringSource\n        elif safe_is_subclass(potential_dagster_type, ConstrainedFloat):\n            potential_dagster_type = float\n        elif safe_is_subclass(potential_dagster_type, ConstrainedInt):\n            return IntSource\n    except ImportError:\n        pass\n    if safe_is_subclass(get_origin(potential_dagster_type), List):\n        list_inner_type = get_args(potential_dagster_type)[0]\n        return Array(_config_type_for_type_on_pydantic_field(list_inner_type))\n    elif is_optional(potential_dagster_type):\n        optional_inner_type = next((arg for arg in get_args(potential_dagster_type) if arg is not type(None)))\n        return Noneable(_config_type_for_type_on_pydantic_field(optional_inner_type))\n    elif safe_is_subclass(get_origin(potential_dagster_type), Dict) or safe_is_subclass(get_origin(potential_dagster_type), Mapping):\n        (key_type, value_type) = get_args(potential_dagster_type)\n        return Map(key_type, _config_type_for_type_on_pydantic_field(value_type))\n    from .config import Config, infer_schema_from_config_class\n    if safe_is_subclass(potential_dagster_type, Config):\n        inferred_field = infer_schema_from_config_class(potential_dagster_type)\n        return inferred_field.config_type\n    if safe_is_subclass(potential_dagster_type, Enum):\n        return DagsterEnum.from_python_enum_direct_values(potential_dagster_type)\n    if potential_dagster_type is str:\n        return StringSource\n    elif potential_dagster_type is int:\n        return IntSource\n    elif potential_dagster_type is bool:\n        return BoolSource\n    else:\n        return convert_potential_field(potential_dagster_type).config_type"
        ]
    },
    {
        "func_name": "_convert_pydantic_discriminated_union_field",
        "original": "def _convert_pydantic_discriminated_union_field(pydantic_field: ModelFieldCompat) -> Field:\n    \"\"\"Builds a Selector config field from a Pydantic field which is a discriminated union.\n\n    For example:\n\n    class Cat(Config):\n        pet_type: Literal[\"cat\"]\n        meows: int\n\n    class Dog(Config):\n        pet_type: Literal[\"dog\"]\n        barks: float\n\n    class OpConfigWithUnion(Config):\n        pet: Union[Cat, Dog] = Field(..., discriminator=\"pet_type\")\n\n    Becomes:\n\n    Shape({\n      \"pet\": Selector({\n          \"cat\": Shape({\"meows\": Int}),\n          \"dog\": Shape({\"barks\": Float}),\n      })\n    })\n    \"\"\"\n    from .config import Config, infer_schema_from_config_class\n    field_type = pydantic_field.annotation\n    discriminator = pydantic_field.discriminator if pydantic_field.discriminator else None\n    if not get_origin(field_type) == Union:\n        raise DagsterInvalidDefinitionError('Discriminated union must be a Union type.')\n    sub_fields = get_args(field_type)\n    if not all((issubclass(sub_field, Config) for sub_field in sub_fields)):\n        raise NotImplementedError('Discriminated unions with non-Config types are not supported.')\n    sub_fields_mapping = {}\n    if discriminator:\n        for sub_field in sub_fields:\n            sub_field_annotation = model_fields(sub_field)[discriminator].annotation\n            for sub_field_key in get_args(sub_field_annotation):\n                sub_fields_mapping[sub_field_key] = sub_field\n    dagster_config_field_mapping = {discriminator_value: infer_schema_from_config_class(field, fields_to_omit={discriminator} if discriminator else None) for (discriminator_value, field) in sub_fields_mapping.items()}\n    return Field(config=Selector(fields=dagster_config_field_mapping))",
        "mutated": [
            "def _convert_pydantic_discriminated_union_field(pydantic_field: ModelFieldCompat) -> Field:\n    if False:\n        i = 10\n    'Builds a Selector config field from a Pydantic field which is a discriminated union.\\n\\n    For example:\\n\\n    class Cat(Config):\\n        pet_type: Literal[\"cat\"]\\n        meows: int\\n\\n    class Dog(Config):\\n        pet_type: Literal[\"dog\"]\\n        barks: float\\n\\n    class OpConfigWithUnion(Config):\\n        pet: Union[Cat, Dog] = Field(..., discriminator=\"pet_type\")\\n\\n    Becomes:\\n\\n    Shape({\\n      \"pet\": Selector({\\n          \"cat\": Shape({\"meows\": Int}),\\n          \"dog\": Shape({\"barks\": Float}),\\n      })\\n    })\\n    '\n    from .config import Config, infer_schema_from_config_class\n    field_type = pydantic_field.annotation\n    discriminator = pydantic_field.discriminator if pydantic_field.discriminator else None\n    if not get_origin(field_type) == Union:\n        raise DagsterInvalidDefinitionError('Discriminated union must be a Union type.')\n    sub_fields = get_args(field_type)\n    if not all((issubclass(sub_field, Config) for sub_field in sub_fields)):\n        raise NotImplementedError('Discriminated unions with non-Config types are not supported.')\n    sub_fields_mapping = {}\n    if discriminator:\n        for sub_field in sub_fields:\n            sub_field_annotation = model_fields(sub_field)[discriminator].annotation\n            for sub_field_key in get_args(sub_field_annotation):\n                sub_fields_mapping[sub_field_key] = sub_field\n    dagster_config_field_mapping = {discriminator_value: infer_schema_from_config_class(field, fields_to_omit={discriminator} if discriminator else None) for (discriminator_value, field) in sub_fields_mapping.items()}\n    return Field(config=Selector(fields=dagster_config_field_mapping))",
            "def _convert_pydantic_discriminated_union_field(pydantic_field: ModelFieldCompat) -> Field:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Builds a Selector config field from a Pydantic field which is a discriminated union.\\n\\n    For example:\\n\\n    class Cat(Config):\\n        pet_type: Literal[\"cat\"]\\n        meows: int\\n\\n    class Dog(Config):\\n        pet_type: Literal[\"dog\"]\\n        barks: float\\n\\n    class OpConfigWithUnion(Config):\\n        pet: Union[Cat, Dog] = Field(..., discriminator=\"pet_type\")\\n\\n    Becomes:\\n\\n    Shape({\\n      \"pet\": Selector({\\n          \"cat\": Shape({\"meows\": Int}),\\n          \"dog\": Shape({\"barks\": Float}),\\n      })\\n    })\\n    '\n    from .config import Config, infer_schema_from_config_class\n    field_type = pydantic_field.annotation\n    discriminator = pydantic_field.discriminator if pydantic_field.discriminator else None\n    if not get_origin(field_type) == Union:\n        raise DagsterInvalidDefinitionError('Discriminated union must be a Union type.')\n    sub_fields = get_args(field_type)\n    if not all((issubclass(sub_field, Config) for sub_field in sub_fields)):\n        raise NotImplementedError('Discriminated unions with non-Config types are not supported.')\n    sub_fields_mapping = {}\n    if discriminator:\n        for sub_field in sub_fields:\n            sub_field_annotation = model_fields(sub_field)[discriminator].annotation\n            for sub_field_key in get_args(sub_field_annotation):\n                sub_fields_mapping[sub_field_key] = sub_field\n    dagster_config_field_mapping = {discriminator_value: infer_schema_from_config_class(field, fields_to_omit={discriminator} if discriminator else None) for (discriminator_value, field) in sub_fields_mapping.items()}\n    return Field(config=Selector(fields=dagster_config_field_mapping))",
            "def _convert_pydantic_discriminated_union_field(pydantic_field: ModelFieldCompat) -> Field:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Builds a Selector config field from a Pydantic field which is a discriminated union.\\n\\n    For example:\\n\\n    class Cat(Config):\\n        pet_type: Literal[\"cat\"]\\n        meows: int\\n\\n    class Dog(Config):\\n        pet_type: Literal[\"dog\"]\\n        barks: float\\n\\n    class OpConfigWithUnion(Config):\\n        pet: Union[Cat, Dog] = Field(..., discriminator=\"pet_type\")\\n\\n    Becomes:\\n\\n    Shape({\\n      \"pet\": Selector({\\n          \"cat\": Shape({\"meows\": Int}),\\n          \"dog\": Shape({\"barks\": Float}),\\n      })\\n    })\\n    '\n    from .config import Config, infer_schema_from_config_class\n    field_type = pydantic_field.annotation\n    discriminator = pydantic_field.discriminator if pydantic_field.discriminator else None\n    if not get_origin(field_type) == Union:\n        raise DagsterInvalidDefinitionError('Discriminated union must be a Union type.')\n    sub_fields = get_args(field_type)\n    if not all((issubclass(sub_field, Config) for sub_field in sub_fields)):\n        raise NotImplementedError('Discriminated unions with non-Config types are not supported.')\n    sub_fields_mapping = {}\n    if discriminator:\n        for sub_field in sub_fields:\n            sub_field_annotation = model_fields(sub_field)[discriminator].annotation\n            for sub_field_key in get_args(sub_field_annotation):\n                sub_fields_mapping[sub_field_key] = sub_field\n    dagster_config_field_mapping = {discriminator_value: infer_schema_from_config_class(field, fields_to_omit={discriminator} if discriminator else None) for (discriminator_value, field) in sub_fields_mapping.items()}\n    return Field(config=Selector(fields=dagster_config_field_mapping))",
            "def _convert_pydantic_discriminated_union_field(pydantic_field: ModelFieldCompat) -> Field:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Builds a Selector config field from a Pydantic field which is a discriminated union.\\n\\n    For example:\\n\\n    class Cat(Config):\\n        pet_type: Literal[\"cat\"]\\n        meows: int\\n\\n    class Dog(Config):\\n        pet_type: Literal[\"dog\"]\\n        barks: float\\n\\n    class OpConfigWithUnion(Config):\\n        pet: Union[Cat, Dog] = Field(..., discriminator=\"pet_type\")\\n\\n    Becomes:\\n\\n    Shape({\\n      \"pet\": Selector({\\n          \"cat\": Shape({\"meows\": Int}),\\n          \"dog\": Shape({\"barks\": Float}),\\n      })\\n    })\\n    '\n    from .config import Config, infer_schema_from_config_class\n    field_type = pydantic_field.annotation\n    discriminator = pydantic_field.discriminator if pydantic_field.discriminator else None\n    if not get_origin(field_type) == Union:\n        raise DagsterInvalidDefinitionError('Discriminated union must be a Union type.')\n    sub_fields = get_args(field_type)\n    if not all((issubclass(sub_field, Config) for sub_field in sub_fields)):\n        raise NotImplementedError('Discriminated unions with non-Config types are not supported.')\n    sub_fields_mapping = {}\n    if discriminator:\n        for sub_field in sub_fields:\n            sub_field_annotation = model_fields(sub_field)[discriminator].annotation\n            for sub_field_key in get_args(sub_field_annotation):\n                sub_fields_mapping[sub_field_key] = sub_field\n    dagster_config_field_mapping = {discriminator_value: infer_schema_from_config_class(field, fields_to_omit={discriminator} if discriminator else None) for (discriminator_value, field) in sub_fields_mapping.items()}\n    return Field(config=Selector(fields=dagster_config_field_mapping))",
            "def _convert_pydantic_discriminated_union_field(pydantic_field: ModelFieldCompat) -> Field:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Builds a Selector config field from a Pydantic field which is a discriminated union.\\n\\n    For example:\\n\\n    class Cat(Config):\\n        pet_type: Literal[\"cat\"]\\n        meows: int\\n\\n    class Dog(Config):\\n        pet_type: Literal[\"dog\"]\\n        barks: float\\n\\n    class OpConfigWithUnion(Config):\\n        pet: Union[Cat, Dog] = Field(..., discriminator=\"pet_type\")\\n\\n    Becomes:\\n\\n    Shape({\\n      \"pet\": Selector({\\n          \"cat\": Shape({\"meows\": Int}),\\n          \"dog\": Shape({\"barks\": Float}),\\n      })\\n    })\\n    '\n    from .config import Config, infer_schema_from_config_class\n    field_type = pydantic_field.annotation\n    discriminator = pydantic_field.discriminator if pydantic_field.discriminator else None\n    if not get_origin(field_type) == Union:\n        raise DagsterInvalidDefinitionError('Discriminated union must be a Union type.')\n    sub_fields = get_args(field_type)\n    if not all((issubclass(sub_field, Config) for sub_field in sub_fields)):\n        raise NotImplementedError('Discriminated unions with non-Config types are not supported.')\n    sub_fields_mapping = {}\n    if discriminator:\n        for sub_field in sub_fields:\n            sub_field_annotation = model_fields(sub_field)[discriminator].annotation\n            for sub_field_key in get_args(sub_field_annotation):\n                sub_fields_mapping[sub_field_key] = sub_field\n    dagster_config_field_mapping = {discriminator_value: infer_schema_from_config_class(field, fields_to_omit={discriminator} if discriminator else None) for (discriminator_value, field) in sub_fields_mapping.items()}\n    return Field(config=Selector(fields=dagster_config_field_mapping))"
        ]
    },
    {
        "func_name": "infer_schema_from_config_annotation",
        "original": "def infer_schema_from_config_annotation(model_cls: Any, config_arg_default: Any) -> Field:\n    \"\"\"Parses a structured config class or primitive type and returns a corresponding Dagster config Field.\"\"\"\n    from .config import Config, infer_schema_from_config_class\n    if safe_is_subclass(model_cls, Config):\n        check.invariant(config_arg_default is inspect.Parameter.empty, 'Cannot provide a default value when using a Config class')\n        return infer_schema_from_config_class(model_cls)\n    try:\n        inner_config_type = _config_type_for_type_on_pydantic_field(model_cls)\n    except (DagsterInvalidDefinitionError, DagsterInvalidConfigDefinitionError):\n        raise DagsterInvalidPythonicConfigDefinitionError(invalid_type=model_cls, config_class=None, field_name=None)\n    return Field(config=inner_config_type, default_value=FIELD_NO_DEFAULT_PROVIDED if config_arg_default is inspect.Parameter.empty else config_arg_default)",
        "mutated": [
            "def infer_schema_from_config_annotation(model_cls: Any, config_arg_default: Any) -> Field:\n    if False:\n        i = 10\n    'Parses a structured config class or primitive type and returns a corresponding Dagster config Field.'\n    from .config import Config, infer_schema_from_config_class\n    if safe_is_subclass(model_cls, Config):\n        check.invariant(config_arg_default is inspect.Parameter.empty, 'Cannot provide a default value when using a Config class')\n        return infer_schema_from_config_class(model_cls)\n    try:\n        inner_config_type = _config_type_for_type_on_pydantic_field(model_cls)\n    except (DagsterInvalidDefinitionError, DagsterInvalidConfigDefinitionError):\n        raise DagsterInvalidPythonicConfigDefinitionError(invalid_type=model_cls, config_class=None, field_name=None)\n    return Field(config=inner_config_type, default_value=FIELD_NO_DEFAULT_PROVIDED if config_arg_default is inspect.Parameter.empty else config_arg_default)",
            "def infer_schema_from_config_annotation(model_cls: Any, config_arg_default: Any) -> Field:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Parses a structured config class or primitive type and returns a corresponding Dagster config Field.'\n    from .config import Config, infer_schema_from_config_class\n    if safe_is_subclass(model_cls, Config):\n        check.invariant(config_arg_default is inspect.Parameter.empty, 'Cannot provide a default value when using a Config class')\n        return infer_schema_from_config_class(model_cls)\n    try:\n        inner_config_type = _config_type_for_type_on_pydantic_field(model_cls)\n    except (DagsterInvalidDefinitionError, DagsterInvalidConfigDefinitionError):\n        raise DagsterInvalidPythonicConfigDefinitionError(invalid_type=model_cls, config_class=None, field_name=None)\n    return Field(config=inner_config_type, default_value=FIELD_NO_DEFAULT_PROVIDED if config_arg_default is inspect.Parameter.empty else config_arg_default)",
            "def infer_schema_from_config_annotation(model_cls: Any, config_arg_default: Any) -> Field:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Parses a structured config class or primitive type and returns a corresponding Dagster config Field.'\n    from .config import Config, infer_schema_from_config_class\n    if safe_is_subclass(model_cls, Config):\n        check.invariant(config_arg_default is inspect.Parameter.empty, 'Cannot provide a default value when using a Config class')\n        return infer_schema_from_config_class(model_cls)\n    try:\n        inner_config_type = _config_type_for_type_on_pydantic_field(model_cls)\n    except (DagsterInvalidDefinitionError, DagsterInvalidConfigDefinitionError):\n        raise DagsterInvalidPythonicConfigDefinitionError(invalid_type=model_cls, config_class=None, field_name=None)\n    return Field(config=inner_config_type, default_value=FIELD_NO_DEFAULT_PROVIDED if config_arg_default is inspect.Parameter.empty else config_arg_default)",
            "def infer_schema_from_config_annotation(model_cls: Any, config_arg_default: Any) -> Field:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Parses a structured config class or primitive type and returns a corresponding Dagster config Field.'\n    from .config import Config, infer_schema_from_config_class\n    if safe_is_subclass(model_cls, Config):\n        check.invariant(config_arg_default is inspect.Parameter.empty, 'Cannot provide a default value when using a Config class')\n        return infer_schema_from_config_class(model_cls)\n    try:\n        inner_config_type = _config_type_for_type_on_pydantic_field(model_cls)\n    except (DagsterInvalidDefinitionError, DagsterInvalidConfigDefinitionError):\n        raise DagsterInvalidPythonicConfigDefinitionError(invalid_type=model_cls, config_class=None, field_name=None)\n    return Field(config=inner_config_type, default_value=FIELD_NO_DEFAULT_PROVIDED if config_arg_default is inspect.Parameter.empty else config_arg_default)",
            "def infer_schema_from_config_annotation(model_cls: Any, config_arg_default: Any) -> Field:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Parses a structured config class or primitive type and returns a corresponding Dagster config Field.'\n    from .config import Config, infer_schema_from_config_class\n    if safe_is_subclass(model_cls, Config):\n        check.invariant(config_arg_default is inspect.Parameter.empty, 'Cannot provide a default value when using a Config class')\n        return infer_schema_from_config_class(model_cls)\n    try:\n        inner_config_type = _config_type_for_type_on_pydantic_field(model_cls)\n    except (DagsterInvalidDefinitionError, DagsterInvalidConfigDefinitionError):\n        raise DagsterInvalidPythonicConfigDefinitionError(invalid_type=model_cls, config_class=None, field_name=None)\n    return Field(config=inner_config_type, default_value=FIELD_NO_DEFAULT_PROVIDED if config_arg_default is inspect.Parameter.empty else config_arg_default)"
        ]
    }
]