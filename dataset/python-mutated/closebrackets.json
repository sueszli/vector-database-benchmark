[
    {
        "func_name": "on_state_changed",
        "original": "def on_state_changed(self, state):\n    \"\"\"Connect/disconnect sig_key_pressed signal.\"\"\"\n    if state:\n        self.editor.sig_key_pressed.connect(self._on_key_pressed)\n    else:\n        self.editor.sig_key_pressed.disconnect(self._on_key_pressed)",
        "mutated": [
            "def on_state_changed(self, state):\n    if False:\n        i = 10\n    'Connect/disconnect sig_key_pressed signal.'\n    if state:\n        self.editor.sig_key_pressed.connect(self._on_key_pressed)\n    else:\n        self.editor.sig_key_pressed.disconnect(self._on_key_pressed)",
            "def on_state_changed(self, state):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Connect/disconnect sig_key_pressed signal.'\n    if state:\n        self.editor.sig_key_pressed.connect(self._on_key_pressed)\n    else:\n        self.editor.sig_key_pressed.disconnect(self._on_key_pressed)",
            "def on_state_changed(self, state):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Connect/disconnect sig_key_pressed signal.'\n    if state:\n        self.editor.sig_key_pressed.connect(self._on_key_pressed)\n    else:\n        self.editor.sig_key_pressed.disconnect(self._on_key_pressed)",
            "def on_state_changed(self, state):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Connect/disconnect sig_key_pressed signal.'\n    if state:\n        self.editor.sig_key_pressed.connect(self._on_key_pressed)\n    else:\n        self.editor.sig_key_pressed.disconnect(self._on_key_pressed)",
            "def on_state_changed(self, state):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Connect/disconnect sig_key_pressed signal.'\n    if state:\n        self.editor.sig_key_pressed.connect(self._on_key_pressed)\n    else:\n        self.editor.sig_key_pressed.disconnect(self._on_key_pressed)"
        ]
    },
    {
        "func_name": "_on_key_pressed",
        "original": "def _on_key_pressed(self, event):\n    if event.isAccepted():\n        return\n    char = event.text()\n    if char in self.BRACKETS_CHAR and self.enabled:\n        self.editor.completion_widget.hide()\n        self._autoinsert_brackets(char)\n        event.accept()",
        "mutated": [
            "def _on_key_pressed(self, event):\n    if False:\n        i = 10\n    if event.isAccepted():\n        return\n    char = event.text()\n    if char in self.BRACKETS_CHAR and self.enabled:\n        self.editor.completion_widget.hide()\n        self._autoinsert_brackets(char)\n        event.accept()",
            "def _on_key_pressed(self, event):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if event.isAccepted():\n        return\n    char = event.text()\n    if char in self.BRACKETS_CHAR and self.enabled:\n        self.editor.completion_widget.hide()\n        self._autoinsert_brackets(char)\n        event.accept()",
            "def _on_key_pressed(self, event):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if event.isAccepted():\n        return\n    char = event.text()\n    if char in self.BRACKETS_CHAR and self.enabled:\n        self.editor.completion_widget.hide()\n        self._autoinsert_brackets(char)\n        event.accept()",
            "def _on_key_pressed(self, event):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if event.isAccepted():\n        return\n    char = event.text()\n    if char in self.BRACKETS_CHAR and self.enabled:\n        self.editor.completion_widget.hide()\n        self._autoinsert_brackets(char)\n        event.accept()",
            "def _on_key_pressed(self, event):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if event.isAccepted():\n        return\n    char = event.text()\n    if char in self.BRACKETS_CHAR and self.enabled:\n        self.editor.completion_widget.hide()\n        self._autoinsert_brackets(char)\n        event.accept()"
        ]
    },
    {
        "func_name": "unmatched_brackets_in_line",
        "original": "def unmatched_brackets_in_line(self, text, closing_brackets_type=None, autoinsert=False):\n    \"\"\"\n        Checks if there is an unmatched brackets in the 'text'.\n\n        The brackets type can be general or specified by closing_brackets_type\n        (')', ']' or '}')\n        \"\"\"\n    if closing_brackets_type is None:\n        opening_brackets = self.BRACKETS_LEFT\n        closing_brackets = self.BRACKETS_RIGHT\n    else:\n        closing_brackets = [closing_brackets_type]\n        opening_brackets = [{')': '(', '}': '{', ']': '['}[closing_brackets_type]]\n    block = self.editor.textCursor().block()\n    line_pos = block.position()\n    for (pos, char) in enumerate(text):\n        if char in opening_brackets:\n            match = self.editor.find_brace_match(line_pos + pos, char, forward=True)\n            if match is None or match > line_pos + len(text):\n                return True\n        if char in closing_brackets:\n            match = self.editor.find_brace_match(line_pos + pos, char, forward=False)\n            if match is None or (match < line_pos and (not autoinsert)):\n                return True\n    return False",
        "mutated": [
            "def unmatched_brackets_in_line(self, text, closing_brackets_type=None, autoinsert=False):\n    if False:\n        i = 10\n    \"\\n        Checks if there is an unmatched brackets in the 'text'.\\n\\n        The brackets type can be general or specified by closing_brackets_type\\n        (')', ']' or '}')\\n        \"\n    if closing_brackets_type is None:\n        opening_brackets = self.BRACKETS_LEFT\n        closing_brackets = self.BRACKETS_RIGHT\n    else:\n        closing_brackets = [closing_brackets_type]\n        opening_brackets = [{')': '(', '}': '{', ']': '['}[closing_brackets_type]]\n    block = self.editor.textCursor().block()\n    line_pos = block.position()\n    for (pos, char) in enumerate(text):\n        if char in opening_brackets:\n            match = self.editor.find_brace_match(line_pos + pos, char, forward=True)\n            if match is None or match > line_pos + len(text):\n                return True\n        if char in closing_brackets:\n            match = self.editor.find_brace_match(line_pos + pos, char, forward=False)\n            if match is None or (match < line_pos and (not autoinsert)):\n                return True\n    return False",
            "def unmatched_brackets_in_line(self, text, closing_brackets_type=None, autoinsert=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n        Checks if there is an unmatched brackets in the 'text'.\\n\\n        The brackets type can be general or specified by closing_brackets_type\\n        (')', ']' or '}')\\n        \"\n    if closing_brackets_type is None:\n        opening_brackets = self.BRACKETS_LEFT\n        closing_brackets = self.BRACKETS_RIGHT\n    else:\n        closing_brackets = [closing_brackets_type]\n        opening_brackets = [{')': '(', '}': '{', ']': '['}[closing_brackets_type]]\n    block = self.editor.textCursor().block()\n    line_pos = block.position()\n    for (pos, char) in enumerate(text):\n        if char in opening_brackets:\n            match = self.editor.find_brace_match(line_pos + pos, char, forward=True)\n            if match is None or match > line_pos + len(text):\n                return True\n        if char in closing_brackets:\n            match = self.editor.find_brace_match(line_pos + pos, char, forward=False)\n            if match is None or (match < line_pos and (not autoinsert)):\n                return True\n    return False",
            "def unmatched_brackets_in_line(self, text, closing_brackets_type=None, autoinsert=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n        Checks if there is an unmatched brackets in the 'text'.\\n\\n        The brackets type can be general or specified by closing_brackets_type\\n        (')', ']' or '}')\\n        \"\n    if closing_brackets_type is None:\n        opening_brackets = self.BRACKETS_LEFT\n        closing_brackets = self.BRACKETS_RIGHT\n    else:\n        closing_brackets = [closing_brackets_type]\n        opening_brackets = [{')': '(', '}': '{', ']': '['}[closing_brackets_type]]\n    block = self.editor.textCursor().block()\n    line_pos = block.position()\n    for (pos, char) in enumerate(text):\n        if char in opening_brackets:\n            match = self.editor.find_brace_match(line_pos + pos, char, forward=True)\n            if match is None or match > line_pos + len(text):\n                return True\n        if char in closing_brackets:\n            match = self.editor.find_brace_match(line_pos + pos, char, forward=False)\n            if match is None or (match < line_pos and (not autoinsert)):\n                return True\n    return False",
            "def unmatched_brackets_in_line(self, text, closing_brackets_type=None, autoinsert=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n        Checks if there is an unmatched brackets in the 'text'.\\n\\n        The brackets type can be general or specified by closing_brackets_type\\n        (')', ']' or '}')\\n        \"\n    if closing_brackets_type is None:\n        opening_brackets = self.BRACKETS_LEFT\n        closing_brackets = self.BRACKETS_RIGHT\n    else:\n        closing_brackets = [closing_brackets_type]\n        opening_brackets = [{')': '(', '}': '{', ']': '['}[closing_brackets_type]]\n    block = self.editor.textCursor().block()\n    line_pos = block.position()\n    for (pos, char) in enumerate(text):\n        if char in opening_brackets:\n            match = self.editor.find_brace_match(line_pos + pos, char, forward=True)\n            if match is None or match > line_pos + len(text):\n                return True\n        if char in closing_brackets:\n            match = self.editor.find_brace_match(line_pos + pos, char, forward=False)\n            if match is None or (match < line_pos and (not autoinsert)):\n                return True\n    return False",
            "def unmatched_brackets_in_line(self, text, closing_brackets_type=None, autoinsert=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n        Checks if there is an unmatched brackets in the 'text'.\\n\\n        The brackets type can be general or specified by closing_brackets_type\\n        (')', ']' or '}')\\n        \"\n    if closing_brackets_type is None:\n        opening_brackets = self.BRACKETS_LEFT\n        closing_brackets = self.BRACKETS_RIGHT\n    else:\n        closing_brackets = [closing_brackets_type]\n        opening_brackets = [{')': '(', '}': '{', ']': '['}[closing_brackets_type]]\n    block = self.editor.textCursor().block()\n    line_pos = block.position()\n    for (pos, char) in enumerate(text):\n        if char in opening_brackets:\n            match = self.editor.find_brace_match(line_pos + pos, char, forward=True)\n            if match is None or match > line_pos + len(text):\n                return True\n        if char in closing_brackets:\n            match = self.editor.find_brace_match(line_pos + pos, char, forward=False)\n            if match is None or (match < line_pos and (not autoinsert)):\n                return True\n    return False"
        ]
    },
    {
        "func_name": "_autoinsert_brackets",
        "original": "def _autoinsert_brackets(self, char):\n    \"\"\"Control automatic insertation of brackets in various situations.\"\"\"\n    pair = self.BRACKETS_PAIR[char]\n    cursor = self.editor.textCursor()\n    trailing_text = self.editor.get_text('cursor', 'eol').strip()\n    if self.editor.has_selected_text():\n        text = self.editor.get_selected_text()\n        self.editor.insert_text('{0}{1}{2}'.format(pair[0], text, pair[1]))\n        cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n        cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n        self.editor.setTextCursor(cursor)\n    elif char in self.BRACKETS_LEFT:\n        if not trailing_text or trailing_text[0] in self.BRACKETS_RIGHT or trailing_text[0] in [',', ':', ';']:\n            self.editor.insert_text(pair)\n            cursor.movePosition(QTextCursor.PreviousCharacter)\n            self.editor.setTextCursor(cursor)\n        else:\n            self.editor.insert_text(char)\n        if char in self.editor.signature_completion_characters:\n            self.editor.request_signature()\n    elif char in self.BRACKETS_RIGHT:\n        if self.editor.next_char() == char and (not self.editor.textCursor().atBlockEnd()) and (not self.unmatched_brackets_in_line(cursor.block().text(), char, autoinsert=True)):\n            cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.KeepAnchor, 1)\n            cursor.clearSelection()\n            self.editor.setTextCursor(cursor)\n        else:\n            self.editor.insert_text(char)",
        "mutated": [
            "def _autoinsert_brackets(self, char):\n    if False:\n        i = 10\n    'Control automatic insertation of brackets in various situations.'\n    pair = self.BRACKETS_PAIR[char]\n    cursor = self.editor.textCursor()\n    trailing_text = self.editor.get_text('cursor', 'eol').strip()\n    if self.editor.has_selected_text():\n        text = self.editor.get_selected_text()\n        self.editor.insert_text('{0}{1}{2}'.format(pair[0], text, pair[1]))\n        cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n        cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n        self.editor.setTextCursor(cursor)\n    elif char in self.BRACKETS_LEFT:\n        if not trailing_text or trailing_text[0] in self.BRACKETS_RIGHT or trailing_text[0] in [',', ':', ';']:\n            self.editor.insert_text(pair)\n            cursor.movePosition(QTextCursor.PreviousCharacter)\n            self.editor.setTextCursor(cursor)\n        else:\n            self.editor.insert_text(char)\n        if char in self.editor.signature_completion_characters:\n            self.editor.request_signature()\n    elif char in self.BRACKETS_RIGHT:\n        if self.editor.next_char() == char and (not self.editor.textCursor().atBlockEnd()) and (not self.unmatched_brackets_in_line(cursor.block().text(), char, autoinsert=True)):\n            cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.KeepAnchor, 1)\n            cursor.clearSelection()\n            self.editor.setTextCursor(cursor)\n        else:\n            self.editor.insert_text(char)",
            "def _autoinsert_brackets(self, char):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Control automatic insertation of brackets in various situations.'\n    pair = self.BRACKETS_PAIR[char]\n    cursor = self.editor.textCursor()\n    trailing_text = self.editor.get_text('cursor', 'eol').strip()\n    if self.editor.has_selected_text():\n        text = self.editor.get_selected_text()\n        self.editor.insert_text('{0}{1}{2}'.format(pair[0], text, pair[1]))\n        cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n        cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n        self.editor.setTextCursor(cursor)\n    elif char in self.BRACKETS_LEFT:\n        if not trailing_text or trailing_text[0] in self.BRACKETS_RIGHT or trailing_text[0] in [',', ':', ';']:\n            self.editor.insert_text(pair)\n            cursor.movePosition(QTextCursor.PreviousCharacter)\n            self.editor.setTextCursor(cursor)\n        else:\n            self.editor.insert_text(char)\n        if char in self.editor.signature_completion_characters:\n            self.editor.request_signature()\n    elif char in self.BRACKETS_RIGHT:\n        if self.editor.next_char() == char and (not self.editor.textCursor().atBlockEnd()) and (not self.unmatched_brackets_in_line(cursor.block().text(), char, autoinsert=True)):\n            cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.KeepAnchor, 1)\n            cursor.clearSelection()\n            self.editor.setTextCursor(cursor)\n        else:\n            self.editor.insert_text(char)",
            "def _autoinsert_brackets(self, char):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Control automatic insertation of brackets in various situations.'\n    pair = self.BRACKETS_PAIR[char]\n    cursor = self.editor.textCursor()\n    trailing_text = self.editor.get_text('cursor', 'eol').strip()\n    if self.editor.has_selected_text():\n        text = self.editor.get_selected_text()\n        self.editor.insert_text('{0}{1}{2}'.format(pair[0], text, pair[1]))\n        cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n        cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n        self.editor.setTextCursor(cursor)\n    elif char in self.BRACKETS_LEFT:\n        if not trailing_text or trailing_text[0] in self.BRACKETS_RIGHT or trailing_text[0] in [',', ':', ';']:\n            self.editor.insert_text(pair)\n            cursor.movePosition(QTextCursor.PreviousCharacter)\n            self.editor.setTextCursor(cursor)\n        else:\n            self.editor.insert_text(char)\n        if char in self.editor.signature_completion_characters:\n            self.editor.request_signature()\n    elif char in self.BRACKETS_RIGHT:\n        if self.editor.next_char() == char and (not self.editor.textCursor().atBlockEnd()) and (not self.unmatched_brackets_in_line(cursor.block().text(), char, autoinsert=True)):\n            cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.KeepAnchor, 1)\n            cursor.clearSelection()\n            self.editor.setTextCursor(cursor)\n        else:\n            self.editor.insert_text(char)",
            "def _autoinsert_brackets(self, char):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Control automatic insertation of brackets in various situations.'\n    pair = self.BRACKETS_PAIR[char]\n    cursor = self.editor.textCursor()\n    trailing_text = self.editor.get_text('cursor', 'eol').strip()\n    if self.editor.has_selected_text():\n        text = self.editor.get_selected_text()\n        self.editor.insert_text('{0}{1}{2}'.format(pair[0], text, pair[1]))\n        cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n        cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n        self.editor.setTextCursor(cursor)\n    elif char in self.BRACKETS_LEFT:\n        if not trailing_text or trailing_text[0] in self.BRACKETS_RIGHT or trailing_text[0] in [',', ':', ';']:\n            self.editor.insert_text(pair)\n            cursor.movePosition(QTextCursor.PreviousCharacter)\n            self.editor.setTextCursor(cursor)\n        else:\n            self.editor.insert_text(char)\n        if char in self.editor.signature_completion_characters:\n            self.editor.request_signature()\n    elif char in self.BRACKETS_RIGHT:\n        if self.editor.next_char() == char and (not self.editor.textCursor().atBlockEnd()) and (not self.unmatched_brackets_in_line(cursor.block().text(), char, autoinsert=True)):\n            cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.KeepAnchor, 1)\n            cursor.clearSelection()\n            self.editor.setTextCursor(cursor)\n        else:\n            self.editor.insert_text(char)",
            "def _autoinsert_brackets(self, char):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Control automatic insertation of brackets in various situations.'\n    pair = self.BRACKETS_PAIR[char]\n    cursor = self.editor.textCursor()\n    trailing_text = self.editor.get_text('cursor', 'eol').strip()\n    if self.editor.has_selected_text():\n        text = self.editor.get_selected_text()\n        self.editor.insert_text('{0}{1}{2}'.format(pair[0], text, pair[1]))\n        cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n        cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n        self.editor.setTextCursor(cursor)\n    elif char in self.BRACKETS_LEFT:\n        if not trailing_text or trailing_text[0] in self.BRACKETS_RIGHT or trailing_text[0] in [',', ':', ';']:\n            self.editor.insert_text(pair)\n            cursor.movePosition(QTextCursor.PreviousCharacter)\n            self.editor.setTextCursor(cursor)\n        else:\n            self.editor.insert_text(char)\n        if char in self.editor.signature_completion_characters:\n            self.editor.request_signature()\n    elif char in self.BRACKETS_RIGHT:\n        if self.editor.next_char() == char and (not self.editor.textCursor().atBlockEnd()) and (not self.unmatched_brackets_in_line(cursor.block().text(), char, autoinsert=True)):\n            cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.KeepAnchor, 1)\n            cursor.clearSelection()\n            self.editor.setTextCursor(cursor)\n        else:\n            self.editor.insert_text(char)"
        ]
    }
]