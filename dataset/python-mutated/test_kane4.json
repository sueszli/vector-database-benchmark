[
    {
        "func_name": "test_replace_qdots_in_force",
        "original": "def test_replace_qdots_in_force():\n    (q1, q2) = dynamicsymbols('q1, q2')\n    (qd1, qd2) = dynamicsymbols('q1, q2', level=1)\n    (u1, u2) = dynamicsymbols('u1, u2')\n    (l, m) = symbols('l, m')\n    N = ReferenceFrame('N')\n    A = N.orientnew('A', 'Axis', (q1, N.z))\n    B = A.orientnew('B', 'Axis', (q2, N.z))\n    O = Point('O')\n    O.set_vel(N, 0)\n    P = O.locatenew('P', l * A.x)\n    P.v2pt_theory(O, N, A)\n    Q = P.locatenew('Q', l * B.x)\n    Q.v2pt_theory(P, N, B)\n    Ap = Particle('Ap', P, m)\n    Bp = Particle('Bp', Q, m)\n    (sig, delta) = symbols('sigma, delta')\n    Ta = (sig * q2 + delta * qd2) * N.z\n    forces = [(A, Ta), (B, -Ta)]\n    kde1 = [u1 - qd1, u2 - qd2]\n    kde2 = [u1 - qd1, u2 - (qd1 + qd2)]\n    KM1 = KanesMethod(N, [q1, q2], [u1, u2], kd_eqs=kde1)\n    (fr1, fstar1) = KM1.kanes_equations([Ap, Bp], forces)\n    KM2 = KanesMethod(N, [q1, q2], [u1, u2], kd_eqs=kde2)\n    (fr2, fstar2) = KM2.kanes_equations([Ap, Bp], forces)\n    forcing_matrix_expected = Matrix([[m * l ** 2 * sin(q2) * u2 ** 2 + sig * q2 + delta * (u2 - u1)], [m * l ** 2 * sin(q2) * -u1 ** 2 - sig * q2 - delta * (u2 - u1)]])\n    mass_matrix_expected = Matrix([[2 * m * l ** 2, m * l ** 2 * cos(q2)], [m * l ** 2 * cos(q2), m * l ** 2]])\n    assert KM2.mass_matrix.expand() == mass_matrix_expected.expand()\n    assert KM2.forcing.expand() == forcing_matrix_expected.expand()\n    fr1_expected = Matrix([0, -(sig * q2 + delta * u2)])\n    assert fr1.expand() == fr1_expected.expand()\n    fr2_expected = Matrix([sig * q2 + delta * (u2 - u1), -sig * q2 - delta * (u2 - u1)])\n    assert fr2.expand() == fr2_expected.expand()\n    Ta = (sig * q2 + delta * u2) * N.z\n    forces = [(A, Ta), (B, -Ta)]\n    KM1 = KanesMethod(N, [q1, q2], [u1, u2], kd_eqs=kde1)\n    (fr1, fstar1) = KM1.kanes_equations([Ap, Bp], forces)\n    assert fr1.expand() == fr1_expected.expand()\n    Ta = (sig * q2 + delta * (u2 - u1)) * N.z\n    forces = [(A, Ta), (B, -Ta)]\n    KM2 = KanesMethod(N, [q1, q2], [u1, u2], kd_eqs=kde2)\n    (fr2, fstar2) = KM2.kanes_equations([Ap, Bp], forces)\n    assert fr2.expand() == fr2_expected.expand()\n    Ta = (sig * q2 + delta * qd2 ** 3) * N.z\n    forces = [(A, Ta), (B, -Ta)]\n    KM1 = KanesMethod(N, [q1, q2], [u1, u2], kd_eqs=kde1)\n    (fr1, fstar1) = KM1.kanes_equations([Ap, Bp], forces)\n    fr1_cubic_expected = Matrix([0, -(sig * q2 + delta * u2 ** 3)])\n    assert fr1.expand() == fr1_cubic_expected.expand()\n    KM2 = KanesMethod(N, [q1, q2], [u1, u2], kd_eqs=kde2)\n    (fr2, fstar2) = KM2.kanes_equations([Ap, Bp], forces)\n    fr2_cubic_expected = Matrix([sig * q2 + delta * (u2 - u1) ** 3, -sig * q2 - delta * (u2 - u1) ** 3])\n    assert fr2.expand() == fr2_cubic_expected.expand()",
        "mutated": [
            "def test_replace_qdots_in_force():\n    if False:\n        i = 10\n    (q1, q2) = dynamicsymbols('q1, q2')\n    (qd1, qd2) = dynamicsymbols('q1, q2', level=1)\n    (u1, u2) = dynamicsymbols('u1, u2')\n    (l, m) = symbols('l, m')\n    N = ReferenceFrame('N')\n    A = N.orientnew('A', 'Axis', (q1, N.z))\n    B = A.orientnew('B', 'Axis', (q2, N.z))\n    O = Point('O')\n    O.set_vel(N, 0)\n    P = O.locatenew('P', l * A.x)\n    P.v2pt_theory(O, N, A)\n    Q = P.locatenew('Q', l * B.x)\n    Q.v2pt_theory(P, N, B)\n    Ap = Particle('Ap', P, m)\n    Bp = Particle('Bp', Q, m)\n    (sig, delta) = symbols('sigma, delta')\n    Ta = (sig * q2 + delta * qd2) * N.z\n    forces = [(A, Ta), (B, -Ta)]\n    kde1 = [u1 - qd1, u2 - qd2]\n    kde2 = [u1 - qd1, u2 - (qd1 + qd2)]\n    KM1 = KanesMethod(N, [q1, q2], [u1, u2], kd_eqs=kde1)\n    (fr1, fstar1) = KM1.kanes_equations([Ap, Bp], forces)\n    KM2 = KanesMethod(N, [q1, q2], [u1, u2], kd_eqs=kde2)\n    (fr2, fstar2) = KM2.kanes_equations([Ap, Bp], forces)\n    forcing_matrix_expected = Matrix([[m * l ** 2 * sin(q2) * u2 ** 2 + sig * q2 + delta * (u2 - u1)], [m * l ** 2 * sin(q2) * -u1 ** 2 - sig * q2 - delta * (u2 - u1)]])\n    mass_matrix_expected = Matrix([[2 * m * l ** 2, m * l ** 2 * cos(q2)], [m * l ** 2 * cos(q2), m * l ** 2]])\n    assert KM2.mass_matrix.expand() == mass_matrix_expected.expand()\n    assert KM2.forcing.expand() == forcing_matrix_expected.expand()\n    fr1_expected = Matrix([0, -(sig * q2 + delta * u2)])\n    assert fr1.expand() == fr1_expected.expand()\n    fr2_expected = Matrix([sig * q2 + delta * (u2 - u1), -sig * q2 - delta * (u2 - u1)])\n    assert fr2.expand() == fr2_expected.expand()\n    Ta = (sig * q2 + delta * u2) * N.z\n    forces = [(A, Ta), (B, -Ta)]\n    KM1 = KanesMethod(N, [q1, q2], [u1, u2], kd_eqs=kde1)\n    (fr1, fstar1) = KM1.kanes_equations([Ap, Bp], forces)\n    assert fr1.expand() == fr1_expected.expand()\n    Ta = (sig * q2 + delta * (u2 - u1)) * N.z\n    forces = [(A, Ta), (B, -Ta)]\n    KM2 = KanesMethod(N, [q1, q2], [u1, u2], kd_eqs=kde2)\n    (fr2, fstar2) = KM2.kanes_equations([Ap, Bp], forces)\n    assert fr2.expand() == fr2_expected.expand()\n    Ta = (sig * q2 + delta * qd2 ** 3) * N.z\n    forces = [(A, Ta), (B, -Ta)]\n    KM1 = KanesMethod(N, [q1, q2], [u1, u2], kd_eqs=kde1)\n    (fr1, fstar1) = KM1.kanes_equations([Ap, Bp], forces)\n    fr1_cubic_expected = Matrix([0, -(sig * q2 + delta * u2 ** 3)])\n    assert fr1.expand() == fr1_cubic_expected.expand()\n    KM2 = KanesMethod(N, [q1, q2], [u1, u2], kd_eqs=kde2)\n    (fr2, fstar2) = KM2.kanes_equations([Ap, Bp], forces)\n    fr2_cubic_expected = Matrix([sig * q2 + delta * (u2 - u1) ** 3, -sig * q2 - delta * (u2 - u1) ** 3])\n    assert fr2.expand() == fr2_cubic_expected.expand()",
            "def test_replace_qdots_in_force():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (q1, q2) = dynamicsymbols('q1, q2')\n    (qd1, qd2) = dynamicsymbols('q1, q2', level=1)\n    (u1, u2) = dynamicsymbols('u1, u2')\n    (l, m) = symbols('l, m')\n    N = ReferenceFrame('N')\n    A = N.orientnew('A', 'Axis', (q1, N.z))\n    B = A.orientnew('B', 'Axis', (q2, N.z))\n    O = Point('O')\n    O.set_vel(N, 0)\n    P = O.locatenew('P', l * A.x)\n    P.v2pt_theory(O, N, A)\n    Q = P.locatenew('Q', l * B.x)\n    Q.v2pt_theory(P, N, B)\n    Ap = Particle('Ap', P, m)\n    Bp = Particle('Bp', Q, m)\n    (sig, delta) = symbols('sigma, delta')\n    Ta = (sig * q2 + delta * qd2) * N.z\n    forces = [(A, Ta), (B, -Ta)]\n    kde1 = [u1 - qd1, u2 - qd2]\n    kde2 = [u1 - qd1, u2 - (qd1 + qd2)]\n    KM1 = KanesMethod(N, [q1, q2], [u1, u2], kd_eqs=kde1)\n    (fr1, fstar1) = KM1.kanes_equations([Ap, Bp], forces)\n    KM2 = KanesMethod(N, [q1, q2], [u1, u2], kd_eqs=kde2)\n    (fr2, fstar2) = KM2.kanes_equations([Ap, Bp], forces)\n    forcing_matrix_expected = Matrix([[m * l ** 2 * sin(q2) * u2 ** 2 + sig * q2 + delta * (u2 - u1)], [m * l ** 2 * sin(q2) * -u1 ** 2 - sig * q2 - delta * (u2 - u1)]])\n    mass_matrix_expected = Matrix([[2 * m * l ** 2, m * l ** 2 * cos(q2)], [m * l ** 2 * cos(q2), m * l ** 2]])\n    assert KM2.mass_matrix.expand() == mass_matrix_expected.expand()\n    assert KM2.forcing.expand() == forcing_matrix_expected.expand()\n    fr1_expected = Matrix([0, -(sig * q2 + delta * u2)])\n    assert fr1.expand() == fr1_expected.expand()\n    fr2_expected = Matrix([sig * q2 + delta * (u2 - u1), -sig * q2 - delta * (u2 - u1)])\n    assert fr2.expand() == fr2_expected.expand()\n    Ta = (sig * q2 + delta * u2) * N.z\n    forces = [(A, Ta), (B, -Ta)]\n    KM1 = KanesMethod(N, [q1, q2], [u1, u2], kd_eqs=kde1)\n    (fr1, fstar1) = KM1.kanes_equations([Ap, Bp], forces)\n    assert fr1.expand() == fr1_expected.expand()\n    Ta = (sig * q2 + delta * (u2 - u1)) * N.z\n    forces = [(A, Ta), (B, -Ta)]\n    KM2 = KanesMethod(N, [q1, q2], [u1, u2], kd_eqs=kde2)\n    (fr2, fstar2) = KM2.kanes_equations([Ap, Bp], forces)\n    assert fr2.expand() == fr2_expected.expand()\n    Ta = (sig * q2 + delta * qd2 ** 3) * N.z\n    forces = [(A, Ta), (B, -Ta)]\n    KM1 = KanesMethod(N, [q1, q2], [u1, u2], kd_eqs=kde1)\n    (fr1, fstar1) = KM1.kanes_equations([Ap, Bp], forces)\n    fr1_cubic_expected = Matrix([0, -(sig * q2 + delta * u2 ** 3)])\n    assert fr1.expand() == fr1_cubic_expected.expand()\n    KM2 = KanesMethod(N, [q1, q2], [u1, u2], kd_eqs=kde2)\n    (fr2, fstar2) = KM2.kanes_equations([Ap, Bp], forces)\n    fr2_cubic_expected = Matrix([sig * q2 + delta * (u2 - u1) ** 3, -sig * q2 - delta * (u2 - u1) ** 3])\n    assert fr2.expand() == fr2_cubic_expected.expand()",
            "def test_replace_qdots_in_force():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (q1, q2) = dynamicsymbols('q1, q2')\n    (qd1, qd2) = dynamicsymbols('q1, q2', level=1)\n    (u1, u2) = dynamicsymbols('u1, u2')\n    (l, m) = symbols('l, m')\n    N = ReferenceFrame('N')\n    A = N.orientnew('A', 'Axis', (q1, N.z))\n    B = A.orientnew('B', 'Axis', (q2, N.z))\n    O = Point('O')\n    O.set_vel(N, 0)\n    P = O.locatenew('P', l * A.x)\n    P.v2pt_theory(O, N, A)\n    Q = P.locatenew('Q', l * B.x)\n    Q.v2pt_theory(P, N, B)\n    Ap = Particle('Ap', P, m)\n    Bp = Particle('Bp', Q, m)\n    (sig, delta) = symbols('sigma, delta')\n    Ta = (sig * q2 + delta * qd2) * N.z\n    forces = [(A, Ta), (B, -Ta)]\n    kde1 = [u1 - qd1, u2 - qd2]\n    kde2 = [u1 - qd1, u2 - (qd1 + qd2)]\n    KM1 = KanesMethod(N, [q1, q2], [u1, u2], kd_eqs=kde1)\n    (fr1, fstar1) = KM1.kanes_equations([Ap, Bp], forces)\n    KM2 = KanesMethod(N, [q1, q2], [u1, u2], kd_eqs=kde2)\n    (fr2, fstar2) = KM2.kanes_equations([Ap, Bp], forces)\n    forcing_matrix_expected = Matrix([[m * l ** 2 * sin(q2) * u2 ** 2 + sig * q2 + delta * (u2 - u1)], [m * l ** 2 * sin(q2) * -u1 ** 2 - sig * q2 - delta * (u2 - u1)]])\n    mass_matrix_expected = Matrix([[2 * m * l ** 2, m * l ** 2 * cos(q2)], [m * l ** 2 * cos(q2), m * l ** 2]])\n    assert KM2.mass_matrix.expand() == mass_matrix_expected.expand()\n    assert KM2.forcing.expand() == forcing_matrix_expected.expand()\n    fr1_expected = Matrix([0, -(sig * q2 + delta * u2)])\n    assert fr1.expand() == fr1_expected.expand()\n    fr2_expected = Matrix([sig * q2 + delta * (u2 - u1), -sig * q2 - delta * (u2 - u1)])\n    assert fr2.expand() == fr2_expected.expand()\n    Ta = (sig * q2 + delta * u2) * N.z\n    forces = [(A, Ta), (B, -Ta)]\n    KM1 = KanesMethod(N, [q1, q2], [u1, u2], kd_eqs=kde1)\n    (fr1, fstar1) = KM1.kanes_equations([Ap, Bp], forces)\n    assert fr1.expand() == fr1_expected.expand()\n    Ta = (sig * q2 + delta * (u2 - u1)) * N.z\n    forces = [(A, Ta), (B, -Ta)]\n    KM2 = KanesMethod(N, [q1, q2], [u1, u2], kd_eqs=kde2)\n    (fr2, fstar2) = KM2.kanes_equations([Ap, Bp], forces)\n    assert fr2.expand() == fr2_expected.expand()\n    Ta = (sig * q2 + delta * qd2 ** 3) * N.z\n    forces = [(A, Ta), (B, -Ta)]\n    KM1 = KanesMethod(N, [q1, q2], [u1, u2], kd_eqs=kde1)\n    (fr1, fstar1) = KM1.kanes_equations([Ap, Bp], forces)\n    fr1_cubic_expected = Matrix([0, -(sig * q2 + delta * u2 ** 3)])\n    assert fr1.expand() == fr1_cubic_expected.expand()\n    KM2 = KanesMethod(N, [q1, q2], [u1, u2], kd_eqs=kde2)\n    (fr2, fstar2) = KM2.kanes_equations([Ap, Bp], forces)\n    fr2_cubic_expected = Matrix([sig * q2 + delta * (u2 - u1) ** 3, -sig * q2 - delta * (u2 - u1) ** 3])\n    assert fr2.expand() == fr2_cubic_expected.expand()",
            "def test_replace_qdots_in_force():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (q1, q2) = dynamicsymbols('q1, q2')\n    (qd1, qd2) = dynamicsymbols('q1, q2', level=1)\n    (u1, u2) = dynamicsymbols('u1, u2')\n    (l, m) = symbols('l, m')\n    N = ReferenceFrame('N')\n    A = N.orientnew('A', 'Axis', (q1, N.z))\n    B = A.orientnew('B', 'Axis', (q2, N.z))\n    O = Point('O')\n    O.set_vel(N, 0)\n    P = O.locatenew('P', l * A.x)\n    P.v2pt_theory(O, N, A)\n    Q = P.locatenew('Q', l * B.x)\n    Q.v2pt_theory(P, N, B)\n    Ap = Particle('Ap', P, m)\n    Bp = Particle('Bp', Q, m)\n    (sig, delta) = symbols('sigma, delta')\n    Ta = (sig * q2 + delta * qd2) * N.z\n    forces = [(A, Ta), (B, -Ta)]\n    kde1 = [u1 - qd1, u2 - qd2]\n    kde2 = [u1 - qd1, u2 - (qd1 + qd2)]\n    KM1 = KanesMethod(N, [q1, q2], [u1, u2], kd_eqs=kde1)\n    (fr1, fstar1) = KM1.kanes_equations([Ap, Bp], forces)\n    KM2 = KanesMethod(N, [q1, q2], [u1, u2], kd_eqs=kde2)\n    (fr2, fstar2) = KM2.kanes_equations([Ap, Bp], forces)\n    forcing_matrix_expected = Matrix([[m * l ** 2 * sin(q2) * u2 ** 2 + sig * q2 + delta * (u2 - u1)], [m * l ** 2 * sin(q2) * -u1 ** 2 - sig * q2 - delta * (u2 - u1)]])\n    mass_matrix_expected = Matrix([[2 * m * l ** 2, m * l ** 2 * cos(q2)], [m * l ** 2 * cos(q2), m * l ** 2]])\n    assert KM2.mass_matrix.expand() == mass_matrix_expected.expand()\n    assert KM2.forcing.expand() == forcing_matrix_expected.expand()\n    fr1_expected = Matrix([0, -(sig * q2 + delta * u2)])\n    assert fr1.expand() == fr1_expected.expand()\n    fr2_expected = Matrix([sig * q2 + delta * (u2 - u1), -sig * q2 - delta * (u2 - u1)])\n    assert fr2.expand() == fr2_expected.expand()\n    Ta = (sig * q2 + delta * u2) * N.z\n    forces = [(A, Ta), (B, -Ta)]\n    KM1 = KanesMethod(N, [q1, q2], [u1, u2], kd_eqs=kde1)\n    (fr1, fstar1) = KM1.kanes_equations([Ap, Bp], forces)\n    assert fr1.expand() == fr1_expected.expand()\n    Ta = (sig * q2 + delta * (u2 - u1)) * N.z\n    forces = [(A, Ta), (B, -Ta)]\n    KM2 = KanesMethod(N, [q1, q2], [u1, u2], kd_eqs=kde2)\n    (fr2, fstar2) = KM2.kanes_equations([Ap, Bp], forces)\n    assert fr2.expand() == fr2_expected.expand()\n    Ta = (sig * q2 + delta * qd2 ** 3) * N.z\n    forces = [(A, Ta), (B, -Ta)]\n    KM1 = KanesMethod(N, [q1, q2], [u1, u2], kd_eqs=kde1)\n    (fr1, fstar1) = KM1.kanes_equations([Ap, Bp], forces)\n    fr1_cubic_expected = Matrix([0, -(sig * q2 + delta * u2 ** 3)])\n    assert fr1.expand() == fr1_cubic_expected.expand()\n    KM2 = KanesMethod(N, [q1, q2], [u1, u2], kd_eqs=kde2)\n    (fr2, fstar2) = KM2.kanes_equations([Ap, Bp], forces)\n    fr2_cubic_expected = Matrix([sig * q2 + delta * (u2 - u1) ** 3, -sig * q2 - delta * (u2 - u1) ** 3])\n    assert fr2.expand() == fr2_cubic_expected.expand()",
            "def test_replace_qdots_in_force():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (q1, q2) = dynamicsymbols('q1, q2')\n    (qd1, qd2) = dynamicsymbols('q1, q2', level=1)\n    (u1, u2) = dynamicsymbols('u1, u2')\n    (l, m) = symbols('l, m')\n    N = ReferenceFrame('N')\n    A = N.orientnew('A', 'Axis', (q1, N.z))\n    B = A.orientnew('B', 'Axis', (q2, N.z))\n    O = Point('O')\n    O.set_vel(N, 0)\n    P = O.locatenew('P', l * A.x)\n    P.v2pt_theory(O, N, A)\n    Q = P.locatenew('Q', l * B.x)\n    Q.v2pt_theory(P, N, B)\n    Ap = Particle('Ap', P, m)\n    Bp = Particle('Bp', Q, m)\n    (sig, delta) = symbols('sigma, delta')\n    Ta = (sig * q2 + delta * qd2) * N.z\n    forces = [(A, Ta), (B, -Ta)]\n    kde1 = [u1 - qd1, u2 - qd2]\n    kde2 = [u1 - qd1, u2 - (qd1 + qd2)]\n    KM1 = KanesMethod(N, [q1, q2], [u1, u2], kd_eqs=kde1)\n    (fr1, fstar1) = KM1.kanes_equations([Ap, Bp], forces)\n    KM2 = KanesMethod(N, [q1, q2], [u1, u2], kd_eqs=kde2)\n    (fr2, fstar2) = KM2.kanes_equations([Ap, Bp], forces)\n    forcing_matrix_expected = Matrix([[m * l ** 2 * sin(q2) * u2 ** 2 + sig * q2 + delta * (u2 - u1)], [m * l ** 2 * sin(q2) * -u1 ** 2 - sig * q2 - delta * (u2 - u1)]])\n    mass_matrix_expected = Matrix([[2 * m * l ** 2, m * l ** 2 * cos(q2)], [m * l ** 2 * cos(q2), m * l ** 2]])\n    assert KM2.mass_matrix.expand() == mass_matrix_expected.expand()\n    assert KM2.forcing.expand() == forcing_matrix_expected.expand()\n    fr1_expected = Matrix([0, -(sig * q2 + delta * u2)])\n    assert fr1.expand() == fr1_expected.expand()\n    fr2_expected = Matrix([sig * q2 + delta * (u2 - u1), -sig * q2 - delta * (u2 - u1)])\n    assert fr2.expand() == fr2_expected.expand()\n    Ta = (sig * q2 + delta * u2) * N.z\n    forces = [(A, Ta), (B, -Ta)]\n    KM1 = KanesMethod(N, [q1, q2], [u1, u2], kd_eqs=kde1)\n    (fr1, fstar1) = KM1.kanes_equations([Ap, Bp], forces)\n    assert fr1.expand() == fr1_expected.expand()\n    Ta = (sig * q2 + delta * (u2 - u1)) * N.z\n    forces = [(A, Ta), (B, -Ta)]\n    KM2 = KanesMethod(N, [q1, q2], [u1, u2], kd_eqs=kde2)\n    (fr2, fstar2) = KM2.kanes_equations([Ap, Bp], forces)\n    assert fr2.expand() == fr2_expected.expand()\n    Ta = (sig * q2 + delta * qd2 ** 3) * N.z\n    forces = [(A, Ta), (B, -Ta)]\n    KM1 = KanesMethod(N, [q1, q2], [u1, u2], kd_eqs=kde1)\n    (fr1, fstar1) = KM1.kanes_equations([Ap, Bp], forces)\n    fr1_cubic_expected = Matrix([0, -(sig * q2 + delta * u2 ** 3)])\n    assert fr1.expand() == fr1_cubic_expected.expand()\n    KM2 = KanesMethod(N, [q1, q2], [u1, u2], kd_eqs=kde2)\n    (fr2, fstar2) = KM2.kanes_equations([Ap, Bp], forces)\n    fr2_cubic_expected = Matrix([sig * q2 + delta * (u2 - u1) ** 3, -sig * q2 - delta * (u2 - u1) ** 3])\n    assert fr2.expand() == fr2_cubic_expected.expand()"
        ]
    }
]