[
    {
        "func_name": "recursive_filelisting",
        "original": "def recursive_filelisting(base_directories: Iterable[str], error: List[bool]) -> Generator[str, None, None]:\n    \"\"\"Iterator on filenames in base_directories. Ugly hack: error is a\n    one-element list that will be set to True if one of the directories in\n    base_directories does not exist.\n\n    \"\"\"\n    for base_directory in base_directories:\n        if not os.path.exists(base_directory):\n            ivre.utils.LOGGER.warning('directory %r does not exist', base_directory)\n            error[0] = True\n            continue\n        if not os.path.isdir(base_directory):\n            yield base_directory\n            continue\n        for (root, _, files) in os.walk(base_directory):\n            for leaffile in files:\n                yield os.path.join(root, leaffile)",
        "mutated": [
            "def recursive_filelisting(base_directories: Iterable[str], error: List[bool]) -> Generator[str, None, None]:\n    if False:\n        i = 10\n    'Iterator on filenames in base_directories. Ugly hack: error is a\\n    one-element list that will be set to True if one of the directories in\\n    base_directories does not exist.\\n\\n    '\n    for base_directory in base_directories:\n        if not os.path.exists(base_directory):\n            ivre.utils.LOGGER.warning('directory %r does not exist', base_directory)\n            error[0] = True\n            continue\n        if not os.path.isdir(base_directory):\n            yield base_directory\n            continue\n        for (root, _, files) in os.walk(base_directory):\n            for leaffile in files:\n                yield os.path.join(root, leaffile)",
            "def recursive_filelisting(base_directories: Iterable[str], error: List[bool]) -> Generator[str, None, None]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Iterator on filenames in base_directories. Ugly hack: error is a\\n    one-element list that will be set to True if one of the directories in\\n    base_directories does not exist.\\n\\n    '\n    for base_directory in base_directories:\n        if not os.path.exists(base_directory):\n            ivre.utils.LOGGER.warning('directory %r does not exist', base_directory)\n            error[0] = True\n            continue\n        if not os.path.isdir(base_directory):\n            yield base_directory\n            continue\n        for (root, _, files) in os.walk(base_directory):\n            for leaffile in files:\n                yield os.path.join(root, leaffile)",
            "def recursive_filelisting(base_directories: Iterable[str], error: List[bool]) -> Generator[str, None, None]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Iterator on filenames in base_directories. Ugly hack: error is a\\n    one-element list that will be set to True if one of the directories in\\n    base_directories does not exist.\\n\\n    '\n    for base_directory in base_directories:\n        if not os.path.exists(base_directory):\n            ivre.utils.LOGGER.warning('directory %r does not exist', base_directory)\n            error[0] = True\n            continue\n        if not os.path.isdir(base_directory):\n            yield base_directory\n            continue\n        for (root, _, files) in os.walk(base_directory):\n            for leaffile in files:\n                yield os.path.join(root, leaffile)",
            "def recursive_filelisting(base_directories: Iterable[str], error: List[bool]) -> Generator[str, None, None]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Iterator on filenames in base_directories. Ugly hack: error is a\\n    one-element list that will be set to True if one of the directories in\\n    base_directories does not exist.\\n\\n    '\n    for base_directory in base_directories:\n        if not os.path.exists(base_directory):\n            ivre.utils.LOGGER.warning('directory %r does not exist', base_directory)\n            error[0] = True\n            continue\n        if not os.path.isdir(base_directory):\n            yield base_directory\n            continue\n        for (root, _, files) in os.walk(base_directory):\n            for leaffile in files:\n                yield os.path.join(root, leaffile)",
            "def recursive_filelisting(base_directories: Iterable[str], error: List[bool]) -> Generator[str, None, None]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Iterator on filenames in base_directories. Ugly hack: error is a\\n    one-element list that will be set to True if one of the directories in\\n    base_directories does not exist.\\n\\n    '\n    for base_directory in base_directories:\n        if not os.path.exists(base_directory):\n            ivre.utils.LOGGER.warning('directory %r does not exist', base_directory)\n            error[0] = True\n            continue\n        if not os.path.isdir(base_directory):\n            yield base_directory\n            continue\n        for (root, _, files) in os.walk(base_directory):\n            for leaffile in files:\n                yield os.path.join(root, leaffile)"
        ]
    },
    {
        "func_name": "callback",
        "original": "def callback(x: Record) -> None:\n    result = nmap_record_to_view(x)\n    set_auto_tags(result, update_openports=False)\n    set_openports_attribute(result)\n    result['infos'] = {}\n    for func in [ivre.db.db.data.country_byip, ivre.db.db.data.as_byip, ivre.db.db.data.location_byip]:\n        result['infos'].update(func(result['addr']) or {})\n    ivre.db.db.view.store_or_merge_host(result)",
        "mutated": [
            "def callback(x: Record) -> None:\n    if False:\n        i = 10\n    result = nmap_record_to_view(x)\n    set_auto_tags(result, update_openports=False)\n    set_openports_attribute(result)\n    result['infos'] = {}\n    for func in [ivre.db.db.data.country_byip, ivre.db.db.data.as_byip, ivre.db.db.data.location_byip]:\n        result['infos'].update(func(result['addr']) or {})\n    ivre.db.db.view.store_or_merge_host(result)",
            "def callback(x: Record) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    result = nmap_record_to_view(x)\n    set_auto_tags(result, update_openports=False)\n    set_openports_attribute(result)\n    result['infos'] = {}\n    for func in [ivre.db.db.data.country_byip, ivre.db.db.data.as_byip, ivre.db.db.data.location_byip]:\n        result['infos'].update(func(result['addr']) or {})\n    ivre.db.db.view.store_or_merge_host(result)",
            "def callback(x: Record) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    result = nmap_record_to_view(x)\n    set_auto_tags(result, update_openports=False)\n    set_openports_attribute(result)\n    result['infos'] = {}\n    for func in [ivre.db.db.data.country_byip, ivre.db.db.data.as_byip, ivre.db.db.data.location_byip]:\n        result['infos'].update(func(result['addr']) or {})\n    ivre.db.db.view.store_or_merge_host(result)",
            "def callback(x: Record) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    result = nmap_record_to_view(x)\n    set_auto_tags(result, update_openports=False)\n    set_openports_attribute(result)\n    result['infos'] = {}\n    for func in [ivre.db.db.data.country_byip, ivre.db.db.data.as_byip, ivre.db.db.data.location_byip]:\n        result['infos'].update(func(result['addr']) or {})\n    ivre.db.db.view.store_or_merge_host(result)",
            "def callback(x: Record) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    result = nmap_record_to_view(x)\n    set_auto_tags(result, update_openports=False)\n    set_openports_attribute(result)\n    result['infos'] = {}\n    for func in [ivre.db.db.data.country_byip, ivre.db.db.data.as_byip, ivre.db.db.data.location_byip]:\n        result['infos'].update(func(result['addr']) or {})\n    ivre.db.db.view.store_or_merge_host(result)"
        ]
    },
    {
        "func_name": "main",
        "original": "def main() -> None:\n    parser = ArgumentParser(description=__doc__)\n    parser.add_argument('scan', nargs='*', metavar='SCAN', help='Scan results')\n    parser.add_argument('-c', '--categories', default='', help='Scan categories.')\n    parser.add_argument('-s', '--source', default=None, help='Scan source.')\n    parser.add_argument('-t', '--test', action='store_true', help='Test mode (JSON output).')\n    parser.add_argument('--tags', metavar='TAG:LEVEL:INFO[,TAG:LEVEL:INFO]', help='Add tags to the results; e.g. --tags=CDN:info:\"My CDN\",Honeypot:warning:\"My Masscanned Honeypot\"')\n    parser.add_argument('--test-normal', action='store_true', help='Test mode (\"normal\" Nmap output).')\n    parser.add_argument('--ports', '--port', action='store_true', help='Store only hosts with a \"ports\" element.')\n    parser.add_argument('--open-ports', action='store_true', help='Store only hosts with open ports.')\n    parser.add_argument('--masscan-probes', nargs='+', metavar='PROBE', help='Additional Nmap probes to use when trying to match Masscan results against Nmap service fingerprints.')\n    parser.add_argument('--zgrab-port', metavar='PORT', help='Port used for the zgrab scan. This might be needed since the port number does not appear in theresult.')\n    parser.add_argument('-r', '--recursive', action='store_true', help='Import all files from given directories.')\n    parser.add_argument('--update-view', action='store_true', help='Merge hosts in current view')\n    parser.add_argument('--no-update-view', action='store_true', help='Do not merge hosts in current view (default)')\n    args = parser.parse_args()\n    database = ivre.db.db.nmap\n    categories = args.categories.split(',') if args.categories else []\n    tags = [{'value': value, 'type': type_, 'info': [info]} if info else {'value': value, 'type': type_} for (value, type_, info) in (tag.split(':', 3) for tag in (args.tags.split(',') if args.tags else []))]\n    if args.test:\n        args.update_view = False\n        args.no_update_view = True\n        database = ivre.db.DBNmap()\n    if args.test_normal:\n        args.update_view = False\n        args.no_update_view = True\n        database = ivre.db.DBNmap(output_mode='normal')\n    error = [False]\n    if args.recursive:\n        scans = recursive_filelisting(args.scan, error)\n    else:\n        scans = args.scan\n    if not args.update_view or args.no_update_view:\n        callback = None\n    else:\n\n        def callback(x: Record) -> None:\n            result = nmap_record_to_view(x)\n            set_auto_tags(result, update_openports=False)\n            set_openports_attribute(result)\n            result['infos'] = {}\n            for func in [ivre.db.db.data.country_byip, ivre.db.db.data.as_byip, ivre.db.db.data.location_byip]:\n                result['infos'].update(func(result['addr']) or {})\n            ivre.db.db.view.store_or_merge_host(result)\n        ivre.db.db.view.start_store_hosts()\n    count = 0\n    for scan in scans:\n        if not os.path.exists(scan):\n            ivre.utils.LOGGER.warning('file %r does not exist', scan)\n            error[0] = True\n            continue\n        try:\n            if database.store_scan(scan, categories=categories, source=args.source, tags=tags, needports=args.ports, needopenports=args.open_ports, masscan_probes=args.masscan_probes, callback=callback, zgrab_port=args.zgrab_port):\n                count += 1\n        except Exception:\n            ivre.utils.LOGGER.warning('Exception (file %r)', scan, exc_info=True)\n            error[0] = True\n    if callback is not None:\n        ivre.db.db.view.stop_store_hosts()\n    ivre.utils.LOGGER.info('%d results imported.', count)\n    sys.exit(error[0])",
        "mutated": [
            "def main() -> None:\n    if False:\n        i = 10\n    parser = ArgumentParser(description=__doc__)\n    parser.add_argument('scan', nargs='*', metavar='SCAN', help='Scan results')\n    parser.add_argument('-c', '--categories', default='', help='Scan categories.')\n    parser.add_argument('-s', '--source', default=None, help='Scan source.')\n    parser.add_argument('-t', '--test', action='store_true', help='Test mode (JSON output).')\n    parser.add_argument('--tags', metavar='TAG:LEVEL:INFO[,TAG:LEVEL:INFO]', help='Add tags to the results; e.g. --tags=CDN:info:\"My CDN\",Honeypot:warning:\"My Masscanned Honeypot\"')\n    parser.add_argument('--test-normal', action='store_true', help='Test mode (\"normal\" Nmap output).')\n    parser.add_argument('--ports', '--port', action='store_true', help='Store only hosts with a \"ports\" element.')\n    parser.add_argument('--open-ports', action='store_true', help='Store only hosts with open ports.')\n    parser.add_argument('--masscan-probes', nargs='+', metavar='PROBE', help='Additional Nmap probes to use when trying to match Masscan results against Nmap service fingerprints.')\n    parser.add_argument('--zgrab-port', metavar='PORT', help='Port used for the zgrab scan. This might be needed since the port number does not appear in theresult.')\n    parser.add_argument('-r', '--recursive', action='store_true', help='Import all files from given directories.')\n    parser.add_argument('--update-view', action='store_true', help='Merge hosts in current view')\n    parser.add_argument('--no-update-view', action='store_true', help='Do not merge hosts in current view (default)')\n    args = parser.parse_args()\n    database = ivre.db.db.nmap\n    categories = args.categories.split(',') if args.categories else []\n    tags = [{'value': value, 'type': type_, 'info': [info]} if info else {'value': value, 'type': type_} for (value, type_, info) in (tag.split(':', 3) for tag in (args.tags.split(',') if args.tags else []))]\n    if args.test:\n        args.update_view = False\n        args.no_update_view = True\n        database = ivre.db.DBNmap()\n    if args.test_normal:\n        args.update_view = False\n        args.no_update_view = True\n        database = ivre.db.DBNmap(output_mode='normal')\n    error = [False]\n    if args.recursive:\n        scans = recursive_filelisting(args.scan, error)\n    else:\n        scans = args.scan\n    if not args.update_view or args.no_update_view:\n        callback = None\n    else:\n\n        def callback(x: Record) -> None:\n            result = nmap_record_to_view(x)\n            set_auto_tags(result, update_openports=False)\n            set_openports_attribute(result)\n            result['infos'] = {}\n            for func in [ivre.db.db.data.country_byip, ivre.db.db.data.as_byip, ivre.db.db.data.location_byip]:\n                result['infos'].update(func(result['addr']) or {})\n            ivre.db.db.view.store_or_merge_host(result)\n        ivre.db.db.view.start_store_hosts()\n    count = 0\n    for scan in scans:\n        if not os.path.exists(scan):\n            ivre.utils.LOGGER.warning('file %r does not exist', scan)\n            error[0] = True\n            continue\n        try:\n            if database.store_scan(scan, categories=categories, source=args.source, tags=tags, needports=args.ports, needopenports=args.open_ports, masscan_probes=args.masscan_probes, callback=callback, zgrab_port=args.zgrab_port):\n                count += 1\n        except Exception:\n            ivre.utils.LOGGER.warning('Exception (file %r)', scan, exc_info=True)\n            error[0] = True\n    if callback is not None:\n        ivre.db.db.view.stop_store_hosts()\n    ivre.utils.LOGGER.info('%d results imported.', count)\n    sys.exit(error[0])",
            "def main() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    parser = ArgumentParser(description=__doc__)\n    parser.add_argument('scan', nargs='*', metavar='SCAN', help='Scan results')\n    parser.add_argument('-c', '--categories', default='', help='Scan categories.')\n    parser.add_argument('-s', '--source', default=None, help='Scan source.')\n    parser.add_argument('-t', '--test', action='store_true', help='Test mode (JSON output).')\n    parser.add_argument('--tags', metavar='TAG:LEVEL:INFO[,TAG:LEVEL:INFO]', help='Add tags to the results; e.g. --tags=CDN:info:\"My CDN\",Honeypot:warning:\"My Masscanned Honeypot\"')\n    parser.add_argument('--test-normal', action='store_true', help='Test mode (\"normal\" Nmap output).')\n    parser.add_argument('--ports', '--port', action='store_true', help='Store only hosts with a \"ports\" element.')\n    parser.add_argument('--open-ports', action='store_true', help='Store only hosts with open ports.')\n    parser.add_argument('--masscan-probes', nargs='+', metavar='PROBE', help='Additional Nmap probes to use when trying to match Masscan results against Nmap service fingerprints.')\n    parser.add_argument('--zgrab-port', metavar='PORT', help='Port used for the zgrab scan. This might be needed since the port number does not appear in theresult.')\n    parser.add_argument('-r', '--recursive', action='store_true', help='Import all files from given directories.')\n    parser.add_argument('--update-view', action='store_true', help='Merge hosts in current view')\n    parser.add_argument('--no-update-view', action='store_true', help='Do not merge hosts in current view (default)')\n    args = parser.parse_args()\n    database = ivre.db.db.nmap\n    categories = args.categories.split(',') if args.categories else []\n    tags = [{'value': value, 'type': type_, 'info': [info]} if info else {'value': value, 'type': type_} for (value, type_, info) in (tag.split(':', 3) for tag in (args.tags.split(',') if args.tags else []))]\n    if args.test:\n        args.update_view = False\n        args.no_update_view = True\n        database = ivre.db.DBNmap()\n    if args.test_normal:\n        args.update_view = False\n        args.no_update_view = True\n        database = ivre.db.DBNmap(output_mode='normal')\n    error = [False]\n    if args.recursive:\n        scans = recursive_filelisting(args.scan, error)\n    else:\n        scans = args.scan\n    if not args.update_view or args.no_update_view:\n        callback = None\n    else:\n\n        def callback(x: Record) -> None:\n            result = nmap_record_to_view(x)\n            set_auto_tags(result, update_openports=False)\n            set_openports_attribute(result)\n            result['infos'] = {}\n            for func in [ivre.db.db.data.country_byip, ivre.db.db.data.as_byip, ivre.db.db.data.location_byip]:\n                result['infos'].update(func(result['addr']) or {})\n            ivre.db.db.view.store_or_merge_host(result)\n        ivre.db.db.view.start_store_hosts()\n    count = 0\n    for scan in scans:\n        if not os.path.exists(scan):\n            ivre.utils.LOGGER.warning('file %r does not exist', scan)\n            error[0] = True\n            continue\n        try:\n            if database.store_scan(scan, categories=categories, source=args.source, tags=tags, needports=args.ports, needopenports=args.open_ports, masscan_probes=args.masscan_probes, callback=callback, zgrab_port=args.zgrab_port):\n                count += 1\n        except Exception:\n            ivre.utils.LOGGER.warning('Exception (file %r)', scan, exc_info=True)\n            error[0] = True\n    if callback is not None:\n        ivre.db.db.view.stop_store_hosts()\n    ivre.utils.LOGGER.info('%d results imported.', count)\n    sys.exit(error[0])",
            "def main() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    parser = ArgumentParser(description=__doc__)\n    parser.add_argument('scan', nargs='*', metavar='SCAN', help='Scan results')\n    parser.add_argument('-c', '--categories', default='', help='Scan categories.')\n    parser.add_argument('-s', '--source', default=None, help='Scan source.')\n    parser.add_argument('-t', '--test', action='store_true', help='Test mode (JSON output).')\n    parser.add_argument('--tags', metavar='TAG:LEVEL:INFO[,TAG:LEVEL:INFO]', help='Add tags to the results; e.g. --tags=CDN:info:\"My CDN\",Honeypot:warning:\"My Masscanned Honeypot\"')\n    parser.add_argument('--test-normal', action='store_true', help='Test mode (\"normal\" Nmap output).')\n    parser.add_argument('--ports', '--port', action='store_true', help='Store only hosts with a \"ports\" element.')\n    parser.add_argument('--open-ports', action='store_true', help='Store only hosts with open ports.')\n    parser.add_argument('--masscan-probes', nargs='+', metavar='PROBE', help='Additional Nmap probes to use when trying to match Masscan results against Nmap service fingerprints.')\n    parser.add_argument('--zgrab-port', metavar='PORT', help='Port used for the zgrab scan. This might be needed since the port number does not appear in theresult.')\n    parser.add_argument('-r', '--recursive', action='store_true', help='Import all files from given directories.')\n    parser.add_argument('--update-view', action='store_true', help='Merge hosts in current view')\n    parser.add_argument('--no-update-view', action='store_true', help='Do not merge hosts in current view (default)')\n    args = parser.parse_args()\n    database = ivre.db.db.nmap\n    categories = args.categories.split(',') if args.categories else []\n    tags = [{'value': value, 'type': type_, 'info': [info]} if info else {'value': value, 'type': type_} for (value, type_, info) in (tag.split(':', 3) for tag in (args.tags.split(',') if args.tags else []))]\n    if args.test:\n        args.update_view = False\n        args.no_update_view = True\n        database = ivre.db.DBNmap()\n    if args.test_normal:\n        args.update_view = False\n        args.no_update_view = True\n        database = ivre.db.DBNmap(output_mode='normal')\n    error = [False]\n    if args.recursive:\n        scans = recursive_filelisting(args.scan, error)\n    else:\n        scans = args.scan\n    if not args.update_view or args.no_update_view:\n        callback = None\n    else:\n\n        def callback(x: Record) -> None:\n            result = nmap_record_to_view(x)\n            set_auto_tags(result, update_openports=False)\n            set_openports_attribute(result)\n            result['infos'] = {}\n            for func in [ivre.db.db.data.country_byip, ivre.db.db.data.as_byip, ivre.db.db.data.location_byip]:\n                result['infos'].update(func(result['addr']) or {})\n            ivre.db.db.view.store_or_merge_host(result)\n        ivre.db.db.view.start_store_hosts()\n    count = 0\n    for scan in scans:\n        if not os.path.exists(scan):\n            ivre.utils.LOGGER.warning('file %r does not exist', scan)\n            error[0] = True\n            continue\n        try:\n            if database.store_scan(scan, categories=categories, source=args.source, tags=tags, needports=args.ports, needopenports=args.open_ports, masscan_probes=args.masscan_probes, callback=callback, zgrab_port=args.zgrab_port):\n                count += 1\n        except Exception:\n            ivre.utils.LOGGER.warning('Exception (file %r)', scan, exc_info=True)\n            error[0] = True\n    if callback is not None:\n        ivre.db.db.view.stop_store_hosts()\n    ivre.utils.LOGGER.info('%d results imported.', count)\n    sys.exit(error[0])",
            "def main() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    parser = ArgumentParser(description=__doc__)\n    parser.add_argument('scan', nargs='*', metavar='SCAN', help='Scan results')\n    parser.add_argument('-c', '--categories', default='', help='Scan categories.')\n    parser.add_argument('-s', '--source', default=None, help='Scan source.')\n    parser.add_argument('-t', '--test', action='store_true', help='Test mode (JSON output).')\n    parser.add_argument('--tags', metavar='TAG:LEVEL:INFO[,TAG:LEVEL:INFO]', help='Add tags to the results; e.g. --tags=CDN:info:\"My CDN\",Honeypot:warning:\"My Masscanned Honeypot\"')\n    parser.add_argument('--test-normal', action='store_true', help='Test mode (\"normal\" Nmap output).')\n    parser.add_argument('--ports', '--port', action='store_true', help='Store only hosts with a \"ports\" element.')\n    parser.add_argument('--open-ports', action='store_true', help='Store only hosts with open ports.')\n    parser.add_argument('--masscan-probes', nargs='+', metavar='PROBE', help='Additional Nmap probes to use when trying to match Masscan results against Nmap service fingerprints.')\n    parser.add_argument('--zgrab-port', metavar='PORT', help='Port used for the zgrab scan. This might be needed since the port number does not appear in theresult.')\n    parser.add_argument('-r', '--recursive', action='store_true', help='Import all files from given directories.')\n    parser.add_argument('--update-view', action='store_true', help='Merge hosts in current view')\n    parser.add_argument('--no-update-view', action='store_true', help='Do not merge hosts in current view (default)')\n    args = parser.parse_args()\n    database = ivre.db.db.nmap\n    categories = args.categories.split(',') if args.categories else []\n    tags = [{'value': value, 'type': type_, 'info': [info]} if info else {'value': value, 'type': type_} for (value, type_, info) in (tag.split(':', 3) for tag in (args.tags.split(',') if args.tags else []))]\n    if args.test:\n        args.update_view = False\n        args.no_update_view = True\n        database = ivre.db.DBNmap()\n    if args.test_normal:\n        args.update_view = False\n        args.no_update_view = True\n        database = ivre.db.DBNmap(output_mode='normal')\n    error = [False]\n    if args.recursive:\n        scans = recursive_filelisting(args.scan, error)\n    else:\n        scans = args.scan\n    if not args.update_view or args.no_update_view:\n        callback = None\n    else:\n\n        def callback(x: Record) -> None:\n            result = nmap_record_to_view(x)\n            set_auto_tags(result, update_openports=False)\n            set_openports_attribute(result)\n            result['infos'] = {}\n            for func in [ivre.db.db.data.country_byip, ivre.db.db.data.as_byip, ivre.db.db.data.location_byip]:\n                result['infos'].update(func(result['addr']) or {})\n            ivre.db.db.view.store_or_merge_host(result)\n        ivre.db.db.view.start_store_hosts()\n    count = 0\n    for scan in scans:\n        if not os.path.exists(scan):\n            ivre.utils.LOGGER.warning('file %r does not exist', scan)\n            error[0] = True\n            continue\n        try:\n            if database.store_scan(scan, categories=categories, source=args.source, tags=tags, needports=args.ports, needopenports=args.open_ports, masscan_probes=args.masscan_probes, callback=callback, zgrab_port=args.zgrab_port):\n                count += 1\n        except Exception:\n            ivre.utils.LOGGER.warning('Exception (file %r)', scan, exc_info=True)\n            error[0] = True\n    if callback is not None:\n        ivre.db.db.view.stop_store_hosts()\n    ivre.utils.LOGGER.info('%d results imported.', count)\n    sys.exit(error[0])",
            "def main() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    parser = ArgumentParser(description=__doc__)\n    parser.add_argument('scan', nargs='*', metavar='SCAN', help='Scan results')\n    parser.add_argument('-c', '--categories', default='', help='Scan categories.')\n    parser.add_argument('-s', '--source', default=None, help='Scan source.')\n    parser.add_argument('-t', '--test', action='store_true', help='Test mode (JSON output).')\n    parser.add_argument('--tags', metavar='TAG:LEVEL:INFO[,TAG:LEVEL:INFO]', help='Add tags to the results; e.g. --tags=CDN:info:\"My CDN\",Honeypot:warning:\"My Masscanned Honeypot\"')\n    parser.add_argument('--test-normal', action='store_true', help='Test mode (\"normal\" Nmap output).')\n    parser.add_argument('--ports', '--port', action='store_true', help='Store only hosts with a \"ports\" element.')\n    parser.add_argument('--open-ports', action='store_true', help='Store only hosts with open ports.')\n    parser.add_argument('--masscan-probes', nargs='+', metavar='PROBE', help='Additional Nmap probes to use when trying to match Masscan results against Nmap service fingerprints.')\n    parser.add_argument('--zgrab-port', metavar='PORT', help='Port used for the zgrab scan. This might be needed since the port number does not appear in theresult.')\n    parser.add_argument('-r', '--recursive', action='store_true', help='Import all files from given directories.')\n    parser.add_argument('--update-view', action='store_true', help='Merge hosts in current view')\n    parser.add_argument('--no-update-view', action='store_true', help='Do not merge hosts in current view (default)')\n    args = parser.parse_args()\n    database = ivre.db.db.nmap\n    categories = args.categories.split(',') if args.categories else []\n    tags = [{'value': value, 'type': type_, 'info': [info]} if info else {'value': value, 'type': type_} for (value, type_, info) in (tag.split(':', 3) for tag in (args.tags.split(',') if args.tags else []))]\n    if args.test:\n        args.update_view = False\n        args.no_update_view = True\n        database = ivre.db.DBNmap()\n    if args.test_normal:\n        args.update_view = False\n        args.no_update_view = True\n        database = ivre.db.DBNmap(output_mode='normal')\n    error = [False]\n    if args.recursive:\n        scans = recursive_filelisting(args.scan, error)\n    else:\n        scans = args.scan\n    if not args.update_view or args.no_update_view:\n        callback = None\n    else:\n\n        def callback(x: Record) -> None:\n            result = nmap_record_to_view(x)\n            set_auto_tags(result, update_openports=False)\n            set_openports_attribute(result)\n            result['infos'] = {}\n            for func in [ivre.db.db.data.country_byip, ivre.db.db.data.as_byip, ivre.db.db.data.location_byip]:\n                result['infos'].update(func(result['addr']) or {})\n            ivre.db.db.view.store_or_merge_host(result)\n        ivre.db.db.view.start_store_hosts()\n    count = 0\n    for scan in scans:\n        if not os.path.exists(scan):\n            ivre.utils.LOGGER.warning('file %r does not exist', scan)\n            error[0] = True\n            continue\n        try:\n            if database.store_scan(scan, categories=categories, source=args.source, tags=tags, needports=args.ports, needopenports=args.open_ports, masscan_probes=args.masscan_probes, callback=callback, zgrab_port=args.zgrab_port):\n                count += 1\n        except Exception:\n            ivre.utils.LOGGER.warning('Exception (file %r)', scan, exc_info=True)\n            error[0] = True\n    if callback is not None:\n        ivre.db.db.view.stop_store_hosts()\n    ivre.utils.LOGGER.info('%d results imported.', count)\n    sys.exit(error[0])"
        ]
    }
]