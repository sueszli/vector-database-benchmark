"""Generate Cython PYX wrappers for Boost stats distributions."""
from typing import NamedTuple
from warnings import warn
from textwrap import dedent
import pathlib
import argparse
from gen_func_defs_pxd import _gen_func_defs_pxd
from _info import _x_funcs, _no_x_funcs, _klass_mapper

class _MethodDef(NamedTuple):
    ufunc_name: str
    num_inputs: int
    boost_func_name: str

def _ufunc_gen(scipy_dist: str, types: list, ctor_args: tuple, filename: str, boost_dist: str, x_funcs: list, no_x_funcs: list):
    if False:
        while True:
            i = 10
    '\n    We need methods defined for each rv_continuous/_discrete internal method:\n        i.e.: _pdf, _cdf, etc.\n    Some of these methods take constructor arguments and 1 extra argument,\n        e.g.: _pdf(x, *ctor_args), _ppf(q, *ctor_args)\n    while some of the methods take only constructor arguments:\n        e.g.: _stats(*ctor_args)\n    '
    num_ctor_args = len(ctor_args)
    methods = [_MethodDef(ufunc_name=f'_{scipy_dist}_{x_func}', num_inputs=num_ctor_args + 1, boost_func_name=x_func if boost_dist != 'beta_distribution' else 'pdf_beta' if x_func == 'pdf' else x_func) for x_func in x_funcs]
    methods += [_MethodDef(ufunc_name=f'_{scipy_dist}_{func}', num_inputs=num_ctor_args, boost_func_name=func) for func in no_x_funcs]
    no_input_methods = [m for m in methods if m.num_inputs == 0]
    if no_input_methods:
        raise ValueError(f'ufuncs must have >0 arguments! Cannot construct these ufuncs: {no_input_methods}')
    boost_hdr_name = boost_dist.split('_distribution')[0]
    unique_num_inputs = set({m.num_inputs for m in methods})
    has_NPY_FLOAT16 = 'NPY_FLOAT16' in types
    line_joiner = ',\n    ' + ' ' * 12
    num_types = len(types)
    loop_fun = 'PyUFunc_T'
    func_defs_cimports = line_joiner.join((f'boost_{m.boost_func_name}{num_ctor_args}' for m in methods))
    nontype_params = line_joiner[1:].join((f'ctypedef int NINPUTS{n} "{n}"' for n in unique_num_inputs))
    with open(filename, 'w') as fp:
        boost_hdr = f'boost/math/distributions/{boost_hdr_name}.hpp'
        relimport = '.'
        fp.write(dedent(f'''            # cython: language_level=3\n\n            # This file was generated by stats/_boost/include/code_gen.py\n            # All modifications to this file will be overwritten.\n\n            from numpy cimport (\n                import_array,\n                import_ufunc,\n                PyUFunc_FromFuncAndData,\n                PyUFuncGenericFunction,\n                PyUFunc_None,\n                {line_joiner.join(types)}\n            )\n            from {relimport}templated_pyufunc cimport PyUFunc_T\n            from {relimport}func_defs cimport (\n                {func_defs_cimports},\n            )\n            cdef extern from "{boost_hdr}" namespace "boost::math" nogil:\n                cdef cppclass {boost_dist} nogil:\n                    pass\n\n            # Workaround for Cython's lack of non-type template parameter\n            # support\n            cdef extern from * nogil:\n                {nontype_params}\n\n            _DUMMY = ""\n            import_array()\n            import_ufunc()\n            '''))
        if has_NPY_FLOAT16:
            warn('Boost stats NPY_FLOAT16 ufunc generation not currently not supported!')
        for (ii, m) in enumerate(methods):
            fp.write(dedent(f'\n                cdef PyUFuncGenericFunction loop_func{ii}[{num_types}]\n                cdef void* func{ii}[1*{num_types}]\n                cdef char types{ii}[{m.num_inputs + 1}*{num_types}]\n                '))
            for (jj, T) in enumerate(types):
                ctype = {'NPY_DOUBLE': 'double', 'NPY_FLOAT': 'float', 'NPY_FLOAT16': 'npy_half'}[T]
                boost_fun = f'boost_{m.boost_func_name}{num_ctor_args}'
                type_str = ', '.join([ctype] * (1 + num_ctor_args))
                boost_tmpl = f'{boost_dist}, {type_str}'
                N = m.num_inputs
                fp.write(f'loop_func{ii}[{jj}] = <PyUFuncGenericFunction>{loop_fun}[{ctype}, NINPUTS{N}]\nfunc{ii}[{jj}] = <void*>{boost_fun}[{boost_tmpl}]\n')
                for tidx in range(m.num_inputs + 1):
                    fp.write(f'types{ii}[{tidx}+{jj}*{m.num_inputs + 1}] = {T}\n')
            arg_list_str = ', '.join(ctor_args)
            if m.boost_func_name in x_funcs:
                arg_list_str = 'x, ' + arg_list_str
            fp.write(dedent(f'\n                {m.ufunc_name} = PyUFunc_FromFuncAndData(\n                    loop_func{ii},\n                    func{ii},\n                    types{ii},\n                    {num_types},  # number of supported input types\n                    {m.num_inputs},  # number of input args\n                    1,  # number of output args\n                    PyUFunc_None,  # `identity` element, never mind this\n                    "{m.ufunc_name}",  # function name\n                    ("{m.ufunc_name}({arg_list_str}) -> computes "\n                     "{m.boost_func_name} of {scipy_dist} distribution"),\n                    0  # unused\n                )\n                '))
if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('-o', '--outdir', type=str, help='Path to the output directory')
    args = parser.parse_args()
    _boost_dir = pathlib.Path(__file__).resolve().parent.parent
    if not args.outdir:
        raise ValueError('A path to the output directory is required')
    else:
        src_dir = pathlib.Path(args.outdir)
    _gen_func_defs_pxd(f'{src_dir}/func_defs.pxd', x_funcs=_x_funcs, no_x_funcs=_no_x_funcs)
    float_types = ['NPY_FLOAT', 'NPY_DOUBLE']
    for (b, s) in _klass_mapper.items():
        _ufunc_gen(scipy_dist=s.scipy_name, types=float_types, ctor_args=s.ctor_args, filename=f'{src_dir}/{s.scipy_name}_ufunc.pyx', boost_dist=f'{b}_distribution', x_funcs=_x_funcs, no_x_funcs=_no_x_funcs)