[
    {
        "func_name": "listObjects",
        "original": "def listObjects(self, context):\n    objs = []\n    for (index, object) in enumerate(bpy.context.scene.objects):\n        if object.type == 'MESH':\n            objs.append((str(index), object.name, 'Object named ' + object.name))\n    return objs",
        "mutated": [
            "def listObjects(self, context):\n    if False:\n        i = 10\n    objs = []\n    for (index, object) in enumerate(bpy.context.scene.objects):\n        if object.type == 'MESH':\n            objs.append((str(index), object.name, 'Object named ' + object.name))\n    return objs",
            "def listObjects(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    objs = []\n    for (index, object) in enumerate(bpy.context.scene.objects):\n        if object.type == 'MESH':\n            objs.append((str(index), object.name, 'Object named ' + object.name))\n    return objs",
            "def listObjects(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    objs = []\n    for (index, object) in enumerate(bpy.context.scene.objects):\n        if object.type == 'MESH':\n            objs.append((str(index), object.name, 'Object named ' + object.name))\n    return objs",
            "def listObjects(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    objs = []\n    for (index, object) in enumerate(bpy.context.scene.objects):\n        if object.type == 'MESH':\n            objs.append((str(index), object.name, 'Object named ' + object.name))\n    return objs",
            "def listObjects(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    objs = []\n    for (index, object) in enumerate(bpy.context.scene.objects):\n        if object.type == 'MESH':\n            objs.append((str(index), object.name, 'Object named ' + object.name))\n    return objs"
        ]
    },
    {
        "func_name": "listPredefCRS",
        "original": "def listPredefCRS(self, context):\n    return PredefCRS.getEnumItems()",
        "mutated": [
            "def listPredefCRS(self, context):\n    if False:\n        i = 10\n    return PredefCRS.getEnumItems()",
            "def listPredefCRS(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return PredefCRS.getEnumItems()",
            "def listPredefCRS(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return PredefCRS.getEnumItems()",
            "def listPredefCRS(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return PredefCRS.getEnumItems()",
            "def listPredefCRS(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return PredefCRS.getEnumItems()"
        ]
    },
    {
        "func_name": "listSubdivisionModes",
        "original": "def listSubdivisionModes(self, context):\n    items = [('subsurf', 'Subsurf', 'Add a subsurf modifier'), ('none', 'None', 'No subdivision')]\n    if not self.demOnMesh:\n        items.append(('mesh', 'Mesh', 'Create vertices at each pixels'))\n    return items",
        "mutated": [
            "def listSubdivisionModes(self, context):\n    if False:\n        i = 10\n    items = [('subsurf', 'Subsurf', 'Add a subsurf modifier'), ('none', 'None', 'No subdivision')]\n    if not self.demOnMesh:\n        items.append(('mesh', 'Mesh', 'Create vertices at each pixels'))\n    return items",
            "def listSubdivisionModes(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    items = [('subsurf', 'Subsurf', 'Add a subsurf modifier'), ('none', 'None', 'No subdivision')]\n    if not self.demOnMesh:\n        items.append(('mesh', 'Mesh', 'Create vertices at each pixels'))\n    return items",
            "def listSubdivisionModes(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    items = [('subsurf', 'Subsurf', 'Add a subsurf modifier'), ('none', 'None', 'No subdivision')]\n    if not self.demOnMesh:\n        items.append(('mesh', 'Mesh', 'Create vertices at each pixels'))\n    return items",
            "def listSubdivisionModes(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    items = [('subsurf', 'Subsurf', 'Add a subsurf modifier'), ('none', 'None', 'No subdivision')]\n    if not self.demOnMesh:\n        items.append(('mesh', 'Mesh', 'Create vertices at each pixels'))\n    return items",
            "def listSubdivisionModes(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    items = [('subsurf', 'Subsurf', 'Add a subsurf modifier'), ('none', 'None', 'No subdivision')]\n    if not self.demOnMesh:\n        items.append(('mesh', 'Mesh', 'Create vertices at each pixels'))\n    return items"
        ]
    },
    {
        "func_name": "draw",
        "original": "def draw(self, context):\n    layout = self.layout\n    layout.prop(self, 'importMode')\n    scn = bpy.context.scene\n    geoscn = GeoScene(scn)\n    if self.importMode == 'PLANE':\n        pass\n    if self.importMode == 'BKG':\n        pass\n    if self.importMode == 'MESH':\n        if geoscn.isGeoref and len(self.objectsLst) > 0:\n            layout.prop(self, 'objectsLst')\n        else:\n            layout.label(text=\"There isn't georef mesh to UVmap on\")\n    if self.importMode == 'DEM':\n        layout.prop(self, 'demOnMesh')\n        if self.demOnMesh:\n            if geoscn.isGeoref and len(self.objectsLst) > 0:\n                layout.prop(self, 'objectsLst')\n                layout.prop(self, 'clip')\n            else:\n                layout.label(text=\"There isn't georef mesh to apply on\")\n        layout.prop(self, 'subdivision')\n        layout.prop(self, 'demInterpolation')\n        if self.subdivision == 'mesh':\n            layout.prop(self, 'step')\n        layout.prop(self, 'fillNodata')\n    if self.importMode == 'DEM_RAW':\n        layout.prop(self, 'buildFaces')\n        layout.prop(self, 'step')\n        layout.prop(self, 'clip')\n        if self.clip:\n            if geoscn.isGeoref and len(self.objectsLst) > 0:\n                layout.prop(self, 'objectsLst')\n            else:\n                layout.label(text=\"There isn't georef mesh to refer\")\n    if geoscn.isPartiallyGeoref:\n        layout.prop(self, 'reprojection')\n        if self.reprojection:\n            self.crsInputLayout(context)\n        georefManagerLayout(self, context)\n    else:\n        self.crsInputLayout(context)",
        "mutated": [
            "def draw(self, context):\n    if False:\n        i = 10\n    layout = self.layout\n    layout.prop(self, 'importMode')\n    scn = bpy.context.scene\n    geoscn = GeoScene(scn)\n    if self.importMode == 'PLANE':\n        pass\n    if self.importMode == 'BKG':\n        pass\n    if self.importMode == 'MESH':\n        if geoscn.isGeoref and len(self.objectsLst) > 0:\n            layout.prop(self, 'objectsLst')\n        else:\n            layout.label(text=\"There isn't georef mesh to UVmap on\")\n    if self.importMode == 'DEM':\n        layout.prop(self, 'demOnMesh')\n        if self.demOnMesh:\n            if geoscn.isGeoref and len(self.objectsLst) > 0:\n                layout.prop(self, 'objectsLst')\n                layout.prop(self, 'clip')\n            else:\n                layout.label(text=\"There isn't georef mesh to apply on\")\n        layout.prop(self, 'subdivision')\n        layout.prop(self, 'demInterpolation')\n        if self.subdivision == 'mesh':\n            layout.prop(self, 'step')\n        layout.prop(self, 'fillNodata')\n    if self.importMode == 'DEM_RAW':\n        layout.prop(self, 'buildFaces')\n        layout.prop(self, 'step')\n        layout.prop(self, 'clip')\n        if self.clip:\n            if geoscn.isGeoref and len(self.objectsLst) > 0:\n                layout.prop(self, 'objectsLst')\n            else:\n                layout.label(text=\"There isn't georef mesh to refer\")\n    if geoscn.isPartiallyGeoref:\n        layout.prop(self, 'reprojection')\n        if self.reprojection:\n            self.crsInputLayout(context)\n        georefManagerLayout(self, context)\n    else:\n        self.crsInputLayout(context)",
            "def draw(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    layout = self.layout\n    layout.prop(self, 'importMode')\n    scn = bpy.context.scene\n    geoscn = GeoScene(scn)\n    if self.importMode == 'PLANE':\n        pass\n    if self.importMode == 'BKG':\n        pass\n    if self.importMode == 'MESH':\n        if geoscn.isGeoref and len(self.objectsLst) > 0:\n            layout.prop(self, 'objectsLst')\n        else:\n            layout.label(text=\"There isn't georef mesh to UVmap on\")\n    if self.importMode == 'DEM':\n        layout.prop(self, 'demOnMesh')\n        if self.demOnMesh:\n            if geoscn.isGeoref and len(self.objectsLst) > 0:\n                layout.prop(self, 'objectsLst')\n                layout.prop(self, 'clip')\n            else:\n                layout.label(text=\"There isn't georef mesh to apply on\")\n        layout.prop(self, 'subdivision')\n        layout.prop(self, 'demInterpolation')\n        if self.subdivision == 'mesh':\n            layout.prop(self, 'step')\n        layout.prop(self, 'fillNodata')\n    if self.importMode == 'DEM_RAW':\n        layout.prop(self, 'buildFaces')\n        layout.prop(self, 'step')\n        layout.prop(self, 'clip')\n        if self.clip:\n            if geoscn.isGeoref and len(self.objectsLst) > 0:\n                layout.prop(self, 'objectsLst')\n            else:\n                layout.label(text=\"There isn't georef mesh to refer\")\n    if geoscn.isPartiallyGeoref:\n        layout.prop(self, 'reprojection')\n        if self.reprojection:\n            self.crsInputLayout(context)\n        georefManagerLayout(self, context)\n    else:\n        self.crsInputLayout(context)",
            "def draw(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    layout = self.layout\n    layout.prop(self, 'importMode')\n    scn = bpy.context.scene\n    geoscn = GeoScene(scn)\n    if self.importMode == 'PLANE':\n        pass\n    if self.importMode == 'BKG':\n        pass\n    if self.importMode == 'MESH':\n        if geoscn.isGeoref and len(self.objectsLst) > 0:\n            layout.prop(self, 'objectsLst')\n        else:\n            layout.label(text=\"There isn't georef mesh to UVmap on\")\n    if self.importMode == 'DEM':\n        layout.prop(self, 'demOnMesh')\n        if self.demOnMesh:\n            if geoscn.isGeoref and len(self.objectsLst) > 0:\n                layout.prop(self, 'objectsLst')\n                layout.prop(self, 'clip')\n            else:\n                layout.label(text=\"There isn't georef mesh to apply on\")\n        layout.prop(self, 'subdivision')\n        layout.prop(self, 'demInterpolation')\n        if self.subdivision == 'mesh':\n            layout.prop(self, 'step')\n        layout.prop(self, 'fillNodata')\n    if self.importMode == 'DEM_RAW':\n        layout.prop(self, 'buildFaces')\n        layout.prop(self, 'step')\n        layout.prop(self, 'clip')\n        if self.clip:\n            if geoscn.isGeoref and len(self.objectsLst) > 0:\n                layout.prop(self, 'objectsLst')\n            else:\n                layout.label(text=\"There isn't georef mesh to refer\")\n    if geoscn.isPartiallyGeoref:\n        layout.prop(self, 'reprojection')\n        if self.reprojection:\n            self.crsInputLayout(context)\n        georefManagerLayout(self, context)\n    else:\n        self.crsInputLayout(context)",
            "def draw(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    layout = self.layout\n    layout.prop(self, 'importMode')\n    scn = bpy.context.scene\n    geoscn = GeoScene(scn)\n    if self.importMode == 'PLANE':\n        pass\n    if self.importMode == 'BKG':\n        pass\n    if self.importMode == 'MESH':\n        if geoscn.isGeoref and len(self.objectsLst) > 0:\n            layout.prop(self, 'objectsLst')\n        else:\n            layout.label(text=\"There isn't georef mesh to UVmap on\")\n    if self.importMode == 'DEM':\n        layout.prop(self, 'demOnMesh')\n        if self.demOnMesh:\n            if geoscn.isGeoref and len(self.objectsLst) > 0:\n                layout.prop(self, 'objectsLst')\n                layout.prop(self, 'clip')\n            else:\n                layout.label(text=\"There isn't georef mesh to apply on\")\n        layout.prop(self, 'subdivision')\n        layout.prop(self, 'demInterpolation')\n        if self.subdivision == 'mesh':\n            layout.prop(self, 'step')\n        layout.prop(self, 'fillNodata')\n    if self.importMode == 'DEM_RAW':\n        layout.prop(self, 'buildFaces')\n        layout.prop(self, 'step')\n        layout.prop(self, 'clip')\n        if self.clip:\n            if geoscn.isGeoref and len(self.objectsLst) > 0:\n                layout.prop(self, 'objectsLst')\n            else:\n                layout.label(text=\"There isn't georef mesh to refer\")\n    if geoscn.isPartiallyGeoref:\n        layout.prop(self, 'reprojection')\n        if self.reprojection:\n            self.crsInputLayout(context)\n        georefManagerLayout(self, context)\n    else:\n        self.crsInputLayout(context)",
            "def draw(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    layout = self.layout\n    layout.prop(self, 'importMode')\n    scn = bpy.context.scene\n    geoscn = GeoScene(scn)\n    if self.importMode == 'PLANE':\n        pass\n    if self.importMode == 'BKG':\n        pass\n    if self.importMode == 'MESH':\n        if geoscn.isGeoref and len(self.objectsLst) > 0:\n            layout.prop(self, 'objectsLst')\n        else:\n            layout.label(text=\"There isn't georef mesh to UVmap on\")\n    if self.importMode == 'DEM':\n        layout.prop(self, 'demOnMesh')\n        if self.demOnMesh:\n            if geoscn.isGeoref and len(self.objectsLst) > 0:\n                layout.prop(self, 'objectsLst')\n                layout.prop(self, 'clip')\n            else:\n                layout.label(text=\"There isn't georef mesh to apply on\")\n        layout.prop(self, 'subdivision')\n        layout.prop(self, 'demInterpolation')\n        if self.subdivision == 'mesh':\n            layout.prop(self, 'step')\n        layout.prop(self, 'fillNodata')\n    if self.importMode == 'DEM_RAW':\n        layout.prop(self, 'buildFaces')\n        layout.prop(self, 'step')\n        layout.prop(self, 'clip')\n        if self.clip:\n            if geoscn.isGeoref and len(self.objectsLst) > 0:\n                layout.prop(self, 'objectsLst')\n            else:\n                layout.label(text=\"There isn't georef mesh to refer\")\n    if geoscn.isPartiallyGeoref:\n        layout.prop(self, 'reprojection')\n        if self.reprojection:\n            self.crsInputLayout(context)\n        georefManagerLayout(self, context)\n    else:\n        self.crsInputLayout(context)"
        ]
    },
    {
        "func_name": "crsInputLayout",
        "original": "def crsInputLayout(self, context):\n    layout = self.layout\n    row = layout.row(align=True)\n    split = row.split(factor=0.35, align=True)\n    split.label(text='CRS:')\n    split.prop(self, 'rastCRS', text='')\n    row.operator('bgis.add_predef_crs', text='', icon='ADD')",
        "mutated": [
            "def crsInputLayout(self, context):\n    if False:\n        i = 10\n    layout = self.layout\n    row = layout.row(align=True)\n    split = row.split(factor=0.35, align=True)\n    split.label(text='CRS:')\n    split.prop(self, 'rastCRS', text='')\n    row.operator('bgis.add_predef_crs', text='', icon='ADD')",
            "def crsInputLayout(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    layout = self.layout\n    row = layout.row(align=True)\n    split = row.split(factor=0.35, align=True)\n    split.label(text='CRS:')\n    split.prop(self, 'rastCRS', text='')\n    row.operator('bgis.add_predef_crs', text='', icon='ADD')",
            "def crsInputLayout(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    layout = self.layout\n    row = layout.row(align=True)\n    split = row.split(factor=0.35, align=True)\n    split.label(text='CRS:')\n    split.prop(self, 'rastCRS', text='')\n    row.operator('bgis.add_predef_crs', text='', icon='ADD')",
            "def crsInputLayout(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    layout = self.layout\n    row = layout.row(align=True)\n    split = row.split(factor=0.35, align=True)\n    split.label(text='CRS:')\n    split.prop(self, 'rastCRS', text='')\n    row.operator('bgis.add_predef_crs', text='', icon='ADD')",
            "def crsInputLayout(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    layout = self.layout\n    row = layout.row(align=True)\n    split = row.split(factor=0.35, align=True)\n    split.label(text='CRS:')\n    split.prop(self, 'rastCRS', text='')\n    row.operator('bgis.add_predef_crs', text='', icon='ADD')"
        ]
    },
    {
        "func_name": "poll",
        "original": "@classmethod\ndef poll(cls, context):\n    return context.mode == 'OBJECT'",
        "mutated": [
            "@classmethod\ndef poll(cls, context):\n    if False:\n        i = 10\n    return context.mode == 'OBJECT'",
            "@classmethod\ndef poll(cls, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return context.mode == 'OBJECT'",
            "@classmethod\ndef poll(cls, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return context.mode == 'OBJECT'",
            "@classmethod\ndef poll(cls, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return context.mode == 'OBJECT'",
            "@classmethod\ndef poll(cls, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return context.mode == 'OBJECT'"
        ]
    },
    {
        "func_name": "execute",
        "original": "def execute(self, context):\n    prefs = context.preferences.addons[PKG].preferences\n    bpy.ops.object.select_all(action='DESELECT')\n    scn = bpy.context.scene\n    geoscn = GeoScene(scn)\n    if geoscn.isBroken:\n        self.report({'ERROR'}, 'Scene georef is broken, please fix it beforehand')\n        return {'CANCELLED'}\n    scale = geoscn.scale\n    if geoscn.isGeoref:\n        (dx, dy) = geoscn.getOriginPrj()\n        if self.reprojection:\n            rastCRS = self.rastCRS\n        else:\n            rastCRS = geoscn.crs\n    else:\n        rastCRS = self.rastCRS\n        try:\n            geoscn.crs = rastCRS\n        except Exception as e:\n            log.error('Cannot set scene crs', exc_info=True)\n            self.report({'ERROR'}, 'Cannot set scene crs, check logs for more infos')\n            return {'CANCELLED'}\n    if geoscn.crs != rastCRS:\n        rprj = True\n        rprjToRaster = Reproj(geoscn.crs, rastCRS)\n        rprjToScene = Reproj(rastCRS, geoscn.crs)\n    else:\n        rprj = False\n        rprjToRaster = None\n        rprjToScene = None\n    filePath = self.filepath\n    name = os.path.basename(filePath)[:-4]\n    if self.importMode == 'PLANE':\n        try:\n            rast = bpyGeoRaster(filePath)\n        except IOError as e:\n            log.error('Unable to open raster', exc_info=True)\n            self.report({'ERROR'}, 'Unable to open raster, check logs for more infos')\n            return {'CANCELLED'}\n        if not geoscn.isGeoref:\n            (dx, dy) = (rast.center.x, rast.center.y)\n            if rprj:\n                (dx, dy) = rprjToScene.pt(dx, dy)\n            geoscn.setOriginPrj(dx, dy)\n        mesh = rasterExtentToMesh(name, rast, dx, dy, reproj=rprjToScene)\n        obj = placeObj(mesh, name)\n        uvTxtLayer = mesh.uv_layers.new(name='rastUVmap')\n        geoRastUVmap(obj, uvTxtLayer, rast, dx, dy, reproj=rprjToRaster)\n        mat = bpy.data.materials.new('rastMat')\n        obj.data.materials.append(mat)\n        addTexture(mat, rast.bpyImg, uvTxtLayer, name='rastText')\n    if self.importMode == 'BKG':\n        if rprj:\n            self.report({'ERROR'}, 'Raster reprojection is not possible in background mode')\n            return {'CANCELLED'}\n        try:\n            rast = bpyGeoRaster(filePath)\n        except IOError as e:\n            log.error('Unable to open raster', exc_info=True)\n            self.report({'ERROR'}, 'Unable to open raster, check logs for more infos')\n            return {'CANCELLED'}\n        if rast.rotation.xy != [0, 0]:\n            self.report({'ERROR'}, 'Cannot apply a rotation in background image mode')\n            return {'CANCELLED'}\n        if abs(round(rast.pxSize.x, 3)) != abs(round(rast.pxSize.y, 3)):\n            self.report({'ERROR'}, 'Background image needs equal pixel size in map units in both x ans y axis')\n            return {'CANCELLED'}\n        trueSizeX = rast.geoSize.x\n        trueSizeY = rast.geoSize.y\n        ratio = rast.size.x / rast.size.y\n        if geoscn.isGeoref:\n            (offx, offy) = (rast.center.x - dx, rast.center.y - dy)\n        else:\n            (dx, dy) = (rast.center.x, rast.center.y)\n            geoscn.setOriginPrj(dx, dy)\n            (offx, offy) = (0, 0)\n        bkg = bpy.data.objects.new(self.name, None)\n        bkg.empty_display_type = 'IMAGE'\n        bkg.empty_image_depth = 'BACK'\n        bkg.data = rast.bpyImg\n        scn.collection.objects.link(bkg)\n        bkg.empty_display_size = 1\n        bkg.scale = (trueSizeX, trueSizeY * ratio, 1)\n        bkg.location = (offx, offy, 0)\n        bpy.context.view_layer.objects.active = bkg\n        bkg.select_set(True)\n        if prefs.adjust3Dview:\n            adjust3Dview(context, rast.bbox)\n    if self.importMode == 'MESH':\n        if not geoscn.isGeoref or len(self.objectsLst) == 0:\n            self.report({'ERROR'}, \"There isn't georef mesh to apply on\")\n            return {'CANCELLED'}\n        obj = scn.objects[int(self.objectsLst)]\n        obj.select_set(True)\n        context.view_layer.objects.active = obj\n        subBox = getBBOX.fromObj(obj).toGeo(geoscn)\n        if rprj:\n            subBox = rprjToRaster.bbox(subBox)\n        try:\n            rast = bpyGeoRaster(filePath, subBoxGeo=subBox)\n        except IOError as e:\n            log.error('Unable to open raster', exc_info=True)\n            self.report({'ERROR'}, 'Unable to open raster, check logs for more infos')\n            return {'CANCELLED'}\n        except OverlapError:\n            self.report({'ERROR'}, 'Non overlap data')\n            return {'CANCELLED'}\n        mesh = obj.data\n        uvTxtLayer = mesh.uv_layers.new(name='rastUVmap')\n        uvTxtLayer.active = True\n        geoRastUVmap(obj, uvTxtLayer, rast, dx, dy, reproj=rprjToRaster)\n        mat = bpy.data.materials.new('rastMat')\n        obj.data.materials.append(mat)\n        addTexture(mat, rast.bpyImg, uvTxtLayer, name='rastText')\n    if self.importMode == 'DEM':\n        if self.demOnMesh:\n            if not geoscn.isGeoref or len(self.objectsLst) == 0:\n                self.report({'ERROR'}, \"There isn't georef mesh to apply on\")\n                return {'CANCELLED'}\n            obj = scn.objects[int(self.objectsLst)]\n            mesh = obj.data\n            obj.select_set(True)\n            context.view_layer.objects.active = obj\n            subBox = getBBOX.fromObj(obj).toGeo(geoscn)\n            if rprj:\n                subBox = rprjToRaster.bbox(subBox)\n        else:\n            subBox = None\n        try:\n            grid = bpyGeoRaster(filePath, subBoxGeo=subBox, clip=self.clip, fillNodata=self.fillNodata, useGDAL=HAS_GDAL, raw=True)\n        except IOError as e:\n            log.error('Unable to open raster', exc_info=True)\n            self.report({'ERROR'}, 'Unable to open raster, check logs for more infos')\n            return {'CANCELLED'}\n        except OverlapError:\n            self.report({'ERROR'}, 'Non overlap data')\n            return {'CANCELLED'}\n        if not self.demOnMesh:\n            if not geoscn.isGeoref:\n                (dx, dy) = (grid.center.x, grid.center.y)\n                if rprj:\n                    (dx, dy) = rprjToScene.pt(dx, dy)\n                geoscn.setOriginPrj(dx, dy)\n            if self.subdivision == 'mesh':\n                mesh = exportAsMesh(grid, dx, dy, self.step, reproj=rprjToScene, flat=True)\n            else:\n                mesh = rasterExtentToMesh(name, grid, dx, dy, pxLoc='CENTER', reproj=rprjToScene)\n            obj = placeObj(mesh, name)\n            subBox = getBBOX.fromObj(obj).toGeo(geoscn)\n        previousUVmapIdx = mesh.uv_layers.active_index\n        uvTxtLayer = mesh.uv_layers.new(name='demUVmap')\n        geoRastUVmap(obj, uvTxtLayer, grid, dx, dy, reproj=rprjToRaster)\n        if previousUVmapIdx != -1:\n            mesh.uv_layers.active_index = previousUVmapIdx\n        if self.subdivision == 'subsurf':\n            if not 'SUBSURF' in [mod.type for mod in obj.modifiers]:\n                subsurf = obj.modifiers.new('DEM', type='SUBSURF')\n                subsurf.subdivision_type = 'SIMPLE'\n                subsurf.levels = 6\n                subsurf.render_levels = 6\n        dsp = setDisplacer(obj, grid, uvTxtLayer, interpolation=self.demInterpolation)\n    if self.importMode == 'DEM_RAW':\n        subBox = None\n        if self.clip:\n            if not geoscn.isGeoref or len(self.objectsLst) == 0:\n                self.report({'ERROR'}, 'No working extent')\n                return {'CANCELLED'}\n            obj = scn.objects[int(self.objectsLst)]\n            subBox = getBBOX.fromObj(obj).toGeo(geoscn)\n            if rprj:\n                subBox = rprjToRaster.bbox(subBox)\n        try:\n            grid = GeoRaster(filePath, subBoxGeo=subBox, useGDAL=HAS_GDAL)\n        except IOError as e:\n            log.error('Unable to open raster', exc_info=True)\n            self.report({'ERROR'}, 'Unable to open raster, check logs for more infos')\n            return {'CANCELLED'}\n        except OverlapError:\n            self.report({'ERROR'}, 'Non overlap data')\n            return {'CANCELLED'}\n        if not geoscn.isGeoref:\n            (dx, dy) = (grid.center.x, grid.center.y)\n            if rprj:\n                (dx, dy) = rprjToScene.pt(dx, dy)\n            geoscn.setOriginPrj(dx, dy)\n        mesh = exportAsMesh(grid, dx, dy, self.step, reproj=rprjToScene, subset=self.clip, flat=False, buildFaces=self.buildFaces)\n        obj = placeObj(mesh, name)\n    if self.importMode == 'PLANE' or (self.importMode == 'DEM' and (not self.demOnMesh)) or self.importMode == 'DEM_RAW':\n        newObjCreated = True\n    else:\n        newObjCreated = False\n    if newObjCreated and prefs.adjust3Dview:\n        bb = getBBOX.fromObj(obj)\n        adjust3Dview(context, bb)\n    if prefs.forceTexturedSolid:\n        showTextures(context)\n    return {'FINISHED'}",
        "mutated": [
            "def execute(self, context):\n    if False:\n        i = 10\n    prefs = context.preferences.addons[PKG].preferences\n    bpy.ops.object.select_all(action='DESELECT')\n    scn = bpy.context.scene\n    geoscn = GeoScene(scn)\n    if geoscn.isBroken:\n        self.report({'ERROR'}, 'Scene georef is broken, please fix it beforehand')\n        return {'CANCELLED'}\n    scale = geoscn.scale\n    if geoscn.isGeoref:\n        (dx, dy) = geoscn.getOriginPrj()\n        if self.reprojection:\n            rastCRS = self.rastCRS\n        else:\n            rastCRS = geoscn.crs\n    else:\n        rastCRS = self.rastCRS\n        try:\n            geoscn.crs = rastCRS\n        except Exception as e:\n            log.error('Cannot set scene crs', exc_info=True)\n            self.report({'ERROR'}, 'Cannot set scene crs, check logs for more infos')\n            return {'CANCELLED'}\n    if geoscn.crs != rastCRS:\n        rprj = True\n        rprjToRaster = Reproj(geoscn.crs, rastCRS)\n        rprjToScene = Reproj(rastCRS, geoscn.crs)\n    else:\n        rprj = False\n        rprjToRaster = None\n        rprjToScene = None\n    filePath = self.filepath\n    name = os.path.basename(filePath)[:-4]\n    if self.importMode == 'PLANE':\n        try:\n            rast = bpyGeoRaster(filePath)\n        except IOError as e:\n            log.error('Unable to open raster', exc_info=True)\n            self.report({'ERROR'}, 'Unable to open raster, check logs for more infos')\n            return {'CANCELLED'}\n        if not geoscn.isGeoref:\n            (dx, dy) = (rast.center.x, rast.center.y)\n            if rprj:\n                (dx, dy) = rprjToScene.pt(dx, dy)\n            geoscn.setOriginPrj(dx, dy)\n        mesh = rasterExtentToMesh(name, rast, dx, dy, reproj=rprjToScene)\n        obj = placeObj(mesh, name)\n        uvTxtLayer = mesh.uv_layers.new(name='rastUVmap')\n        geoRastUVmap(obj, uvTxtLayer, rast, dx, dy, reproj=rprjToRaster)\n        mat = bpy.data.materials.new('rastMat')\n        obj.data.materials.append(mat)\n        addTexture(mat, rast.bpyImg, uvTxtLayer, name='rastText')\n    if self.importMode == 'BKG':\n        if rprj:\n            self.report({'ERROR'}, 'Raster reprojection is not possible in background mode')\n            return {'CANCELLED'}\n        try:\n            rast = bpyGeoRaster(filePath)\n        except IOError as e:\n            log.error('Unable to open raster', exc_info=True)\n            self.report({'ERROR'}, 'Unable to open raster, check logs for more infos')\n            return {'CANCELLED'}\n        if rast.rotation.xy != [0, 0]:\n            self.report({'ERROR'}, 'Cannot apply a rotation in background image mode')\n            return {'CANCELLED'}\n        if abs(round(rast.pxSize.x, 3)) != abs(round(rast.pxSize.y, 3)):\n            self.report({'ERROR'}, 'Background image needs equal pixel size in map units in both x ans y axis')\n            return {'CANCELLED'}\n        trueSizeX = rast.geoSize.x\n        trueSizeY = rast.geoSize.y\n        ratio = rast.size.x / rast.size.y\n        if geoscn.isGeoref:\n            (offx, offy) = (rast.center.x - dx, rast.center.y - dy)\n        else:\n            (dx, dy) = (rast.center.x, rast.center.y)\n            geoscn.setOriginPrj(dx, dy)\n            (offx, offy) = (0, 0)\n        bkg = bpy.data.objects.new(self.name, None)\n        bkg.empty_display_type = 'IMAGE'\n        bkg.empty_image_depth = 'BACK'\n        bkg.data = rast.bpyImg\n        scn.collection.objects.link(bkg)\n        bkg.empty_display_size = 1\n        bkg.scale = (trueSizeX, trueSizeY * ratio, 1)\n        bkg.location = (offx, offy, 0)\n        bpy.context.view_layer.objects.active = bkg\n        bkg.select_set(True)\n        if prefs.adjust3Dview:\n            adjust3Dview(context, rast.bbox)\n    if self.importMode == 'MESH':\n        if not geoscn.isGeoref or len(self.objectsLst) == 0:\n            self.report({'ERROR'}, \"There isn't georef mesh to apply on\")\n            return {'CANCELLED'}\n        obj = scn.objects[int(self.objectsLst)]\n        obj.select_set(True)\n        context.view_layer.objects.active = obj\n        subBox = getBBOX.fromObj(obj).toGeo(geoscn)\n        if rprj:\n            subBox = rprjToRaster.bbox(subBox)\n        try:\n            rast = bpyGeoRaster(filePath, subBoxGeo=subBox)\n        except IOError as e:\n            log.error('Unable to open raster', exc_info=True)\n            self.report({'ERROR'}, 'Unable to open raster, check logs for more infos')\n            return {'CANCELLED'}\n        except OverlapError:\n            self.report({'ERROR'}, 'Non overlap data')\n            return {'CANCELLED'}\n        mesh = obj.data\n        uvTxtLayer = mesh.uv_layers.new(name='rastUVmap')\n        uvTxtLayer.active = True\n        geoRastUVmap(obj, uvTxtLayer, rast, dx, dy, reproj=rprjToRaster)\n        mat = bpy.data.materials.new('rastMat')\n        obj.data.materials.append(mat)\n        addTexture(mat, rast.bpyImg, uvTxtLayer, name='rastText')\n    if self.importMode == 'DEM':\n        if self.demOnMesh:\n            if not geoscn.isGeoref or len(self.objectsLst) == 0:\n                self.report({'ERROR'}, \"There isn't georef mesh to apply on\")\n                return {'CANCELLED'}\n            obj = scn.objects[int(self.objectsLst)]\n            mesh = obj.data\n            obj.select_set(True)\n            context.view_layer.objects.active = obj\n            subBox = getBBOX.fromObj(obj).toGeo(geoscn)\n            if rprj:\n                subBox = rprjToRaster.bbox(subBox)\n        else:\n            subBox = None\n        try:\n            grid = bpyGeoRaster(filePath, subBoxGeo=subBox, clip=self.clip, fillNodata=self.fillNodata, useGDAL=HAS_GDAL, raw=True)\n        except IOError as e:\n            log.error('Unable to open raster', exc_info=True)\n            self.report({'ERROR'}, 'Unable to open raster, check logs for more infos')\n            return {'CANCELLED'}\n        except OverlapError:\n            self.report({'ERROR'}, 'Non overlap data')\n            return {'CANCELLED'}\n        if not self.demOnMesh:\n            if not geoscn.isGeoref:\n                (dx, dy) = (grid.center.x, grid.center.y)\n                if rprj:\n                    (dx, dy) = rprjToScene.pt(dx, dy)\n                geoscn.setOriginPrj(dx, dy)\n            if self.subdivision == 'mesh':\n                mesh = exportAsMesh(grid, dx, dy, self.step, reproj=rprjToScene, flat=True)\n            else:\n                mesh = rasterExtentToMesh(name, grid, dx, dy, pxLoc='CENTER', reproj=rprjToScene)\n            obj = placeObj(mesh, name)\n            subBox = getBBOX.fromObj(obj).toGeo(geoscn)\n        previousUVmapIdx = mesh.uv_layers.active_index\n        uvTxtLayer = mesh.uv_layers.new(name='demUVmap')\n        geoRastUVmap(obj, uvTxtLayer, grid, dx, dy, reproj=rprjToRaster)\n        if previousUVmapIdx != -1:\n            mesh.uv_layers.active_index = previousUVmapIdx\n        if self.subdivision == 'subsurf':\n            if not 'SUBSURF' in [mod.type for mod in obj.modifiers]:\n                subsurf = obj.modifiers.new('DEM', type='SUBSURF')\n                subsurf.subdivision_type = 'SIMPLE'\n                subsurf.levels = 6\n                subsurf.render_levels = 6\n        dsp = setDisplacer(obj, grid, uvTxtLayer, interpolation=self.demInterpolation)\n    if self.importMode == 'DEM_RAW':\n        subBox = None\n        if self.clip:\n            if not geoscn.isGeoref or len(self.objectsLst) == 0:\n                self.report({'ERROR'}, 'No working extent')\n                return {'CANCELLED'}\n            obj = scn.objects[int(self.objectsLst)]\n            subBox = getBBOX.fromObj(obj).toGeo(geoscn)\n            if rprj:\n                subBox = rprjToRaster.bbox(subBox)\n        try:\n            grid = GeoRaster(filePath, subBoxGeo=subBox, useGDAL=HAS_GDAL)\n        except IOError as e:\n            log.error('Unable to open raster', exc_info=True)\n            self.report({'ERROR'}, 'Unable to open raster, check logs for more infos')\n            return {'CANCELLED'}\n        except OverlapError:\n            self.report({'ERROR'}, 'Non overlap data')\n            return {'CANCELLED'}\n        if not geoscn.isGeoref:\n            (dx, dy) = (grid.center.x, grid.center.y)\n            if rprj:\n                (dx, dy) = rprjToScene.pt(dx, dy)\n            geoscn.setOriginPrj(dx, dy)\n        mesh = exportAsMesh(grid, dx, dy, self.step, reproj=rprjToScene, subset=self.clip, flat=False, buildFaces=self.buildFaces)\n        obj = placeObj(mesh, name)\n    if self.importMode == 'PLANE' or (self.importMode == 'DEM' and (not self.demOnMesh)) or self.importMode == 'DEM_RAW':\n        newObjCreated = True\n    else:\n        newObjCreated = False\n    if newObjCreated and prefs.adjust3Dview:\n        bb = getBBOX.fromObj(obj)\n        adjust3Dview(context, bb)\n    if prefs.forceTexturedSolid:\n        showTextures(context)\n    return {'FINISHED'}",
            "def execute(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    prefs = context.preferences.addons[PKG].preferences\n    bpy.ops.object.select_all(action='DESELECT')\n    scn = bpy.context.scene\n    geoscn = GeoScene(scn)\n    if geoscn.isBroken:\n        self.report({'ERROR'}, 'Scene georef is broken, please fix it beforehand')\n        return {'CANCELLED'}\n    scale = geoscn.scale\n    if geoscn.isGeoref:\n        (dx, dy) = geoscn.getOriginPrj()\n        if self.reprojection:\n            rastCRS = self.rastCRS\n        else:\n            rastCRS = geoscn.crs\n    else:\n        rastCRS = self.rastCRS\n        try:\n            geoscn.crs = rastCRS\n        except Exception as e:\n            log.error('Cannot set scene crs', exc_info=True)\n            self.report({'ERROR'}, 'Cannot set scene crs, check logs for more infos')\n            return {'CANCELLED'}\n    if geoscn.crs != rastCRS:\n        rprj = True\n        rprjToRaster = Reproj(geoscn.crs, rastCRS)\n        rprjToScene = Reproj(rastCRS, geoscn.crs)\n    else:\n        rprj = False\n        rprjToRaster = None\n        rprjToScene = None\n    filePath = self.filepath\n    name = os.path.basename(filePath)[:-4]\n    if self.importMode == 'PLANE':\n        try:\n            rast = bpyGeoRaster(filePath)\n        except IOError as e:\n            log.error('Unable to open raster', exc_info=True)\n            self.report({'ERROR'}, 'Unable to open raster, check logs for more infos')\n            return {'CANCELLED'}\n        if not geoscn.isGeoref:\n            (dx, dy) = (rast.center.x, rast.center.y)\n            if rprj:\n                (dx, dy) = rprjToScene.pt(dx, dy)\n            geoscn.setOriginPrj(dx, dy)\n        mesh = rasterExtentToMesh(name, rast, dx, dy, reproj=rprjToScene)\n        obj = placeObj(mesh, name)\n        uvTxtLayer = mesh.uv_layers.new(name='rastUVmap')\n        geoRastUVmap(obj, uvTxtLayer, rast, dx, dy, reproj=rprjToRaster)\n        mat = bpy.data.materials.new('rastMat')\n        obj.data.materials.append(mat)\n        addTexture(mat, rast.bpyImg, uvTxtLayer, name='rastText')\n    if self.importMode == 'BKG':\n        if rprj:\n            self.report({'ERROR'}, 'Raster reprojection is not possible in background mode')\n            return {'CANCELLED'}\n        try:\n            rast = bpyGeoRaster(filePath)\n        except IOError as e:\n            log.error('Unable to open raster', exc_info=True)\n            self.report({'ERROR'}, 'Unable to open raster, check logs for more infos')\n            return {'CANCELLED'}\n        if rast.rotation.xy != [0, 0]:\n            self.report({'ERROR'}, 'Cannot apply a rotation in background image mode')\n            return {'CANCELLED'}\n        if abs(round(rast.pxSize.x, 3)) != abs(round(rast.pxSize.y, 3)):\n            self.report({'ERROR'}, 'Background image needs equal pixel size in map units in both x ans y axis')\n            return {'CANCELLED'}\n        trueSizeX = rast.geoSize.x\n        trueSizeY = rast.geoSize.y\n        ratio = rast.size.x / rast.size.y\n        if geoscn.isGeoref:\n            (offx, offy) = (rast.center.x - dx, rast.center.y - dy)\n        else:\n            (dx, dy) = (rast.center.x, rast.center.y)\n            geoscn.setOriginPrj(dx, dy)\n            (offx, offy) = (0, 0)\n        bkg = bpy.data.objects.new(self.name, None)\n        bkg.empty_display_type = 'IMAGE'\n        bkg.empty_image_depth = 'BACK'\n        bkg.data = rast.bpyImg\n        scn.collection.objects.link(bkg)\n        bkg.empty_display_size = 1\n        bkg.scale = (trueSizeX, trueSizeY * ratio, 1)\n        bkg.location = (offx, offy, 0)\n        bpy.context.view_layer.objects.active = bkg\n        bkg.select_set(True)\n        if prefs.adjust3Dview:\n            adjust3Dview(context, rast.bbox)\n    if self.importMode == 'MESH':\n        if not geoscn.isGeoref or len(self.objectsLst) == 0:\n            self.report({'ERROR'}, \"There isn't georef mesh to apply on\")\n            return {'CANCELLED'}\n        obj = scn.objects[int(self.objectsLst)]\n        obj.select_set(True)\n        context.view_layer.objects.active = obj\n        subBox = getBBOX.fromObj(obj).toGeo(geoscn)\n        if rprj:\n            subBox = rprjToRaster.bbox(subBox)\n        try:\n            rast = bpyGeoRaster(filePath, subBoxGeo=subBox)\n        except IOError as e:\n            log.error('Unable to open raster', exc_info=True)\n            self.report({'ERROR'}, 'Unable to open raster, check logs for more infos')\n            return {'CANCELLED'}\n        except OverlapError:\n            self.report({'ERROR'}, 'Non overlap data')\n            return {'CANCELLED'}\n        mesh = obj.data\n        uvTxtLayer = mesh.uv_layers.new(name='rastUVmap')\n        uvTxtLayer.active = True\n        geoRastUVmap(obj, uvTxtLayer, rast, dx, dy, reproj=rprjToRaster)\n        mat = bpy.data.materials.new('rastMat')\n        obj.data.materials.append(mat)\n        addTexture(mat, rast.bpyImg, uvTxtLayer, name='rastText')\n    if self.importMode == 'DEM':\n        if self.demOnMesh:\n            if not geoscn.isGeoref or len(self.objectsLst) == 0:\n                self.report({'ERROR'}, \"There isn't georef mesh to apply on\")\n                return {'CANCELLED'}\n            obj = scn.objects[int(self.objectsLst)]\n            mesh = obj.data\n            obj.select_set(True)\n            context.view_layer.objects.active = obj\n            subBox = getBBOX.fromObj(obj).toGeo(geoscn)\n            if rprj:\n                subBox = rprjToRaster.bbox(subBox)\n        else:\n            subBox = None\n        try:\n            grid = bpyGeoRaster(filePath, subBoxGeo=subBox, clip=self.clip, fillNodata=self.fillNodata, useGDAL=HAS_GDAL, raw=True)\n        except IOError as e:\n            log.error('Unable to open raster', exc_info=True)\n            self.report({'ERROR'}, 'Unable to open raster, check logs for more infos')\n            return {'CANCELLED'}\n        except OverlapError:\n            self.report({'ERROR'}, 'Non overlap data')\n            return {'CANCELLED'}\n        if not self.demOnMesh:\n            if not geoscn.isGeoref:\n                (dx, dy) = (grid.center.x, grid.center.y)\n                if rprj:\n                    (dx, dy) = rprjToScene.pt(dx, dy)\n                geoscn.setOriginPrj(dx, dy)\n            if self.subdivision == 'mesh':\n                mesh = exportAsMesh(grid, dx, dy, self.step, reproj=rprjToScene, flat=True)\n            else:\n                mesh = rasterExtentToMesh(name, grid, dx, dy, pxLoc='CENTER', reproj=rprjToScene)\n            obj = placeObj(mesh, name)\n            subBox = getBBOX.fromObj(obj).toGeo(geoscn)\n        previousUVmapIdx = mesh.uv_layers.active_index\n        uvTxtLayer = mesh.uv_layers.new(name='demUVmap')\n        geoRastUVmap(obj, uvTxtLayer, grid, dx, dy, reproj=rprjToRaster)\n        if previousUVmapIdx != -1:\n            mesh.uv_layers.active_index = previousUVmapIdx\n        if self.subdivision == 'subsurf':\n            if not 'SUBSURF' in [mod.type for mod in obj.modifiers]:\n                subsurf = obj.modifiers.new('DEM', type='SUBSURF')\n                subsurf.subdivision_type = 'SIMPLE'\n                subsurf.levels = 6\n                subsurf.render_levels = 6\n        dsp = setDisplacer(obj, grid, uvTxtLayer, interpolation=self.demInterpolation)\n    if self.importMode == 'DEM_RAW':\n        subBox = None\n        if self.clip:\n            if not geoscn.isGeoref or len(self.objectsLst) == 0:\n                self.report({'ERROR'}, 'No working extent')\n                return {'CANCELLED'}\n            obj = scn.objects[int(self.objectsLst)]\n            subBox = getBBOX.fromObj(obj).toGeo(geoscn)\n            if rprj:\n                subBox = rprjToRaster.bbox(subBox)\n        try:\n            grid = GeoRaster(filePath, subBoxGeo=subBox, useGDAL=HAS_GDAL)\n        except IOError as e:\n            log.error('Unable to open raster', exc_info=True)\n            self.report({'ERROR'}, 'Unable to open raster, check logs for more infos')\n            return {'CANCELLED'}\n        except OverlapError:\n            self.report({'ERROR'}, 'Non overlap data')\n            return {'CANCELLED'}\n        if not geoscn.isGeoref:\n            (dx, dy) = (grid.center.x, grid.center.y)\n            if rprj:\n                (dx, dy) = rprjToScene.pt(dx, dy)\n            geoscn.setOriginPrj(dx, dy)\n        mesh = exportAsMesh(grid, dx, dy, self.step, reproj=rprjToScene, subset=self.clip, flat=False, buildFaces=self.buildFaces)\n        obj = placeObj(mesh, name)\n    if self.importMode == 'PLANE' or (self.importMode == 'DEM' and (not self.demOnMesh)) or self.importMode == 'DEM_RAW':\n        newObjCreated = True\n    else:\n        newObjCreated = False\n    if newObjCreated and prefs.adjust3Dview:\n        bb = getBBOX.fromObj(obj)\n        adjust3Dview(context, bb)\n    if prefs.forceTexturedSolid:\n        showTextures(context)\n    return {'FINISHED'}",
            "def execute(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    prefs = context.preferences.addons[PKG].preferences\n    bpy.ops.object.select_all(action='DESELECT')\n    scn = bpy.context.scene\n    geoscn = GeoScene(scn)\n    if geoscn.isBroken:\n        self.report({'ERROR'}, 'Scene georef is broken, please fix it beforehand')\n        return {'CANCELLED'}\n    scale = geoscn.scale\n    if geoscn.isGeoref:\n        (dx, dy) = geoscn.getOriginPrj()\n        if self.reprojection:\n            rastCRS = self.rastCRS\n        else:\n            rastCRS = geoscn.crs\n    else:\n        rastCRS = self.rastCRS\n        try:\n            geoscn.crs = rastCRS\n        except Exception as e:\n            log.error('Cannot set scene crs', exc_info=True)\n            self.report({'ERROR'}, 'Cannot set scene crs, check logs for more infos')\n            return {'CANCELLED'}\n    if geoscn.crs != rastCRS:\n        rprj = True\n        rprjToRaster = Reproj(geoscn.crs, rastCRS)\n        rprjToScene = Reproj(rastCRS, geoscn.crs)\n    else:\n        rprj = False\n        rprjToRaster = None\n        rprjToScene = None\n    filePath = self.filepath\n    name = os.path.basename(filePath)[:-4]\n    if self.importMode == 'PLANE':\n        try:\n            rast = bpyGeoRaster(filePath)\n        except IOError as e:\n            log.error('Unable to open raster', exc_info=True)\n            self.report({'ERROR'}, 'Unable to open raster, check logs for more infos')\n            return {'CANCELLED'}\n        if not geoscn.isGeoref:\n            (dx, dy) = (rast.center.x, rast.center.y)\n            if rprj:\n                (dx, dy) = rprjToScene.pt(dx, dy)\n            geoscn.setOriginPrj(dx, dy)\n        mesh = rasterExtentToMesh(name, rast, dx, dy, reproj=rprjToScene)\n        obj = placeObj(mesh, name)\n        uvTxtLayer = mesh.uv_layers.new(name='rastUVmap')\n        geoRastUVmap(obj, uvTxtLayer, rast, dx, dy, reproj=rprjToRaster)\n        mat = bpy.data.materials.new('rastMat')\n        obj.data.materials.append(mat)\n        addTexture(mat, rast.bpyImg, uvTxtLayer, name='rastText')\n    if self.importMode == 'BKG':\n        if rprj:\n            self.report({'ERROR'}, 'Raster reprojection is not possible in background mode')\n            return {'CANCELLED'}\n        try:\n            rast = bpyGeoRaster(filePath)\n        except IOError as e:\n            log.error('Unable to open raster', exc_info=True)\n            self.report({'ERROR'}, 'Unable to open raster, check logs for more infos')\n            return {'CANCELLED'}\n        if rast.rotation.xy != [0, 0]:\n            self.report({'ERROR'}, 'Cannot apply a rotation in background image mode')\n            return {'CANCELLED'}\n        if abs(round(rast.pxSize.x, 3)) != abs(round(rast.pxSize.y, 3)):\n            self.report({'ERROR'}, 'Background image needs equal pixel size in map units in both x ans y axis')\n            return {'CANCELLED'}\n        trueSizeX = rast.geoSize.x\n        trueSizeY = rast.geoSize.y\n        ratio = rast.size.x / rast.size.y\n        if geoscn.isGeoref:\n            (offx, offy) = (rast.center.x - dx, rast.center.y - dy)\n        else:\n            (dx, dy) = (rast.center.x, rast.center.y)\n            geoscn.setOriginPrj(dx, dy)\n            (offx, offy) = (0, 0)\n        bkg = bpy.data.objects.new(self.name, None)\n        bkg.empty_display_type = 'IMAGE'\n        bkg.empty_image_depth = 'BACK'\n        bkg.data = rast.bpyImg\n        scn.collection.objects.link(bkg)\n        bkg.empty_display_size = 1\n        bkg.scale = (trueSizeX, trueSizeY * ratio, 1)\n        bkg.location = (offx, offy, 0)\n        bpy.context.view_layer.objects.active = bkg\n        bkg.select_set(True)\n        if prefs.adjust3Dview:\n            adjust3Dview(context, rast.bbox)\n    if self.importMode == 'MESH':\n        if not geoscn.isGeoref or len(self.objectsLst) == 0:\n            self.report({'ERROR'}, \"There isn't georef mesh to apply on\")\n            return {'CANCELLED'}\n        obj = scn.objects[int(self.objectsLst)]\n        obj.select_set(True)\n        context.view_layer.objects.active = obj\n        subBox = getBBOX.fromObj(obj).toGeo(geoscn)\n        if rprj:\n            subBox = rprjToRaster.bbox(subBox)\n        try:\n            rast = bpyGeoRaster(filePath, subBoxGeo=subBox)\n        except IOError as e:\n            log.error('Unable to open raster', exc_info=True)\n            self.report({'ERROR'}, 'Unable to open raster, check logs for more infos')\n            return {'CANCELLED'}\n        except OverlapError:\n            self.report({'ERROR'}, 'Non overlap data')\n            return {'CANCELLED'}\n        mesh = obj.data\n        uvTxtLayer = mesh.uv_layers.new(name='rastUVmap')\n        uvTxtLayer.active = True\n        geoRastUVmap(obj, uvTxtLayer, rast, dx, dy, reproj=rprjToRaster)\n        mat = bpy.data.materials.new('rastMat')\n        obj.data.materials.append(mat)\n        addTexture(mat, rast.bpyImg, uvTxtLayer, name='rastText')\n    if self.importMode == 'DEM':\n        if self.demOnMesh:\n            if not geoscn.isGeoref or len(self.objectsLst) == 0:\n                self.report({'ERROR'}, \"There isn't georef mesh to apply on\")\n                return {'CANCELLED'}\n            obj = scn.objects[int(self.objectsLst)]\n            mesh = obj.data\n            obj.select_set(True)\n            context.view_layer.objects.active = obj\n            subBox = getBBOX.fromObj(obj).toGeo(geoscn)\n            if rprj:\n                subBox = rprjToRaster.bbox(subBox)\n        else:\n            subBox = None\n        try:\n            grid = bpyGeoRaster(filePath, subBoxGeo=subBox, clip=self.clip, fillNodata=self.fillNodata, useGDAL=HAS_GDAL, raw=True)\n        except IOError as e:\n            log.error('Unable to open raster', exc_info=True)\n            self.report({'ERROR'}, 'Unable to open raster, check logs for more infos')\n            return {'CANCELLED'}\n        except OverlapError:\n            self.report({'ERROR'}, 'Non overlap data')\n            return {'CANCELLED'}\n        if not self.demOnMesh:\n            if not geoscn.isGeoref:\n                (dx, dy) = (grid.center.x, grid.center.y)\n                if rprj:\n                    (dx, dy) = rprjToScene.pt(dx, dy)\n                geoscn.setOriginPrj(dx, dy)\n            if self.subdivision == 'mesh':\n                mesh = exportAsMesh(grid, dx, dy, self.step, reproj=rprjToScene, flat=True)\n            else:\n                mesh = rasterExtentToMesh(name, grid, dx, dy, pxLoc='CENTER', reproj=rprjToScene)\n            obj = placeObj(mesh, name)\n            subBox = getBBOX.fromObj(obj).toGeo(geoscn)\n        previousUVmapIdx = mesh.uv_layers.active_index\n        uvTxtLayer = mesh.uv_layers.new(name='demUVmap')\n        geoRastUVmap(obj, uvTxtLayer, grid, dx, dy, reproj=rprjToRaster)\n        if previousUVmapIdx != -1:\n            mesh.uv_layers.active_index = previousUVmapIdx\n        if self.subdivision == 'subsurf':\n            if not 'SUBSURF' in [mod.type for mod in obj.modifiers]:\n                subsurf = obj.modifiers.new('DEM', type='SUBSURF')\n                subsurf.subdivision_type = 'SIMPLE'\n                subsurf.levels = 6\n                subsurf.render_levels = 6\n        dsp = setDisplacer(obj, grid, uvTxtLayer, interpolation=self.demInterpolation)\n    if self.importMode == 'DEM_RAW':\n        subBox = None\n        if self.clip:\n            if not geoscn.isGeoref or len(self.objectsLst) == 0:\n                self.report({'ERROR'}, 'No working extent')\n                return {'CANCELLED'}\n            obj = scn.objects[int(self.objectsLst)]\n            subBox = getBBOX.fromObj(obj).toGeo(geoscn)\n            if rprj:\n                subBox = rprjToRaster.bbox(subBox)\n        try:\n            grid = GeoRaster(filePath, subBoxGeo=subBox, useGDAL=HAS_GDAL)\n        except IOError as e:\n            log.error('Unable to open raster', exc_info=True)\n            self.report({'ERROR'}, 'Unable to open raster, check logs for more infos')\n            return {'CANCELLED'}\n        except OverlapError:\n            self.report({'ERROR'}, 'Non overlap data')\n            return {'CANCELLED'}\n        if not geoscn.isGeoref:\n            (dx, dy) = (grid.center.x, grid.center.y)\n            if rprj:\n                (dx, dy) = rprjToScene.pt(dx, dy)\n            geoscn.setOriginPrj(dx, dy)\n        mesh = exportAsMesh(grid, dx, dy, self.step, reproj=rprjToScene, subset=self.clip, flat=False, buildFaces=self.buildFaces)\n        obj = placeObj(mesh, name)\n    if self.importMode == 'PLANE' or (self.importMode == 'DEM' and (not self.demOnMesh)) or self.importMode == 'DEM_RAW':\n        newObjCreated = True\n    else:\n        newObjCreated = False\n    if newObjCreated and prefs.adjust3Dview:\n        bb = getBBOX.fromObj(obj)\n        adjust3Dview(context, bb)\n    if prefs.forceTexturedSolid:\n        showTextures(context)\n    return {'FINISHED'}",
            "def execute(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    prefs = context.preferences.addons[PKG].preferences\n    bpy.ops.object.select_all(action='DESELECT')\n    scn = bpy.context.scene\n    geoscn = GeoScene(scn)\n    if geoscn.isBroken:\n        self.report({'ERROR'}, 'Scene georef is broken, please fix it beforehand')\n        return {'CANCELLED'}\n    scale = geoscn.scale\n    if geoscn.isGeoref:\n        (dx, dy) = geoscn.getOriginPrj()\n        if self.reprojection:\n            rastCRS = self.rastCRS\n        else:\n            rastCRS = geoscn.crs\n    else:\n        rastCRS = self.rastCRS\n        try:\n            geoscn.crs = rastCRS\n        except Exception as e:\n            log.error('Cannot set scene crs', exc_info=True)\n            self.report({'ERROR'}, 'Cannot set scene crs, check logs for more infos')\n            return {'CANCELLED'}\n    if geoscn.crs != rastCRS:\n        rprj = True\n        rprjToRaster = Reproj(geoscn.crs, rastCRS)\n        rprjToScene = Reproj(rastCRS, geoscn.crs)\n    else:\n        rprj = False\n        rprjToRaster = None\n        rprjToScene = None\n    filePath = self.filepath\n    name = os.path.basename(filePath)[:-4]\n    if self.importMode == 'PLANE':\n        try:\n            rast = bpyGeoRaster(filePath)\n        except IOError as e:\n            log.error('Unable to open raster', exc_info=True)\n            self.report({'ERROR'}, 'Unable to open raster, check logs for more infos')\n            return {'CANCELLED'}\n        if not geoscn.isGeoref:\n            (dx, dy) = (rast.center.x, rast.center.y)\n            if rprj:\n                (dx, dy) = rprjToScene.pt(dx, dy)\n            geoscn.setOriginPrj(dx, dy)\n        mesh = rasterExtentToMesh(name, rast, dx, dy, reproj=rprjToScene)\n        obj = placeObj(mesh, name)\n        uvTxtLayer = mesh.uv_layers.new(name='rastUVmap')\n        geoRastUVmap(obj, uvTxtLayer, rast, dx, dy, reproj=rprjToRaster)\n        mat = bpy.data.materials.new('rastMat')\n        obj.data.materials.append(mat)\n        addTexture(mat, rast.bpyImg, uvTxtLayer, name='rastText')\n    if self.importMode == 'BKG':\n        if rprj:\n            self.report({'ERROR'}, 'Raster reprojection is not possible in background mode')\n            return {'CANCELLED'}\n        try:\n            rast = bpyGeoRaster(filePath)\n        except IOError as e:\n            log.error('Unable to open raster', exc_info=True)\n            self.report({'ERROR'}, 'Unable to open raster, check logs for more infos')\n            return {'CANCELLED'}\n        if rast.rotation.xy != [0, 0]:\n            self.report({'ERROR'}, 'Cannot apply a rotation in background image mode')\n            return {'CANCELLED'}\n        if abs(round(rast.pxSize.x, 3)) != abs(round(rast.pxSize.y, 3)):\n            self.report({'ERROR'}, 'Background image needs equal pixel size in map units in both x ans y axis')\n            return {'CANCELLED'}\n        trueSizeX = rast.geoSize.x\n        trueSizeY = rast.geoSize.y\n        ratio = rast.size.x / rast.size.y\n        if geoscn.isGeoref:\n            (offx, offy) = (rast.center.x - dx, rast.center.y - dy)\n        else:\n            (dx, dy) = (rast.center.x, rast.center.y)\n            geoscn.setOriginPrj(dx, dy)\n            (offx, offy) = (0, 0)\n        bkg = bpy.data.objects.new(self.name, None)\n        bkg.empty_display_type = 'IMAGE'\n        bkg.empty_image_depth = 'BACK'\n        bkg.data = rast.bpyImg\n        scn.collection.objects.link(bkg)\n        bkg.empty_display_size = 1\n        bkg.scale = (trueSizeX, trueSizeY * ratio, 1)\n        bkg.location = (offx, offy, 0)\n        bpy.context.view_layer.objects.active = bkg\n        bkg.select_set(True)\n        if prefs.adjust3Dview:\n            adjust3Dview(context, rast.bbox)\n    if self.importMode == 'MESH':\n        if not geoscn.isGeoref or len(self.objectsLst) == 0:\n            self.report({'ERROR'}, \"There isn't georef mesh to apply on\")\n            return {'CANCELLED'}\n        obj = scn.objects[int(self.objectsLst)]\n        obj.select_set(True)\n        context.view_layer.objects.active = obj\n        subBox = getBBOX.fromObj(obj).toGeo(geoscn)\n        if rprj:\n            subBox = rprjToRaster.bbox(subBox)\n        try:\n            rast = bpyGeoRaster(filePath, subBoxGeo=subBox)\n        except IOError as e:\n            log.error('Unable to open raster', exc_info=True)\n            self.report({'ERROR'}, 'Unable to open raster, check logs for more infos')\n            return {'CANCELLED'}\n        except OverlapError:\n            self.report({'ERROR'}, 'Non overlap data')\n            return {'CANCELLED'}\n        mesh = obj.data\n        uvTxtLayer = mesh.uv_layers.new(name='rastUVmap')\n        uvTxtLayer.active = True\n        geoRastUVmap(obj, uvTxtLayer, rast, dx, dy, reproj=rprjToRaster)\n        mat = bpy.data.materials.new('rastMat')\n        obj.data.materials.append(mat)\n        addTexture(mat, rast.bpyImg, uvTxtLayer, name='rastText')\n    if self.importMode == 'DEM':\n        if self.demOnMesh:\n            if not geoscn.isGeoref or len(self.objectsLst) == 0:\n                self.report({'ERROR'}, \"There isn't georef mesh to apply on\")\n                return {'CANCELLED'}\n            obj = scn.objects[int(self.objectsLst)]\n            mesh = obj.data\n            obj.select_set(True)\n            context.view_layer.objects.active = obj\n            subBox = getBBOX.fromObj(obj).toGeo(geoscn)\n            if rprj:\n                subBox = rprjToRaster.bbox(subBox)\n        else:\n            subBox = None\n        try:\n            grid = bpyGeoRaster(filePath, subBoxGeo=subBox, clip=self.clip, fillNodata=self.fillNodata, useGDAL=HAS_GDAL, raw=True)\n        except IOError as e:\n            log.error('Unable to open raster', exc_info=True)\n            self.report({'ERROR'}, 'Unable to open raster, check logs for more infos')\n            return {'CANCELLED'}\n        except OverlapError:\n            self.report({'ERROR'}, 'Non overlap data')\n            return {'CANCELLED'}\n        if not self.demOnMesh:\n            if not geoscn.isGeoref:\n                (dx, dy) = (grid.center.x, grid.center.y)\n                if rprj:\n                    (dx, dy) = rprjToScene.pt(dx, dy)\n                geoscn.setOriginPrj(dx, dy)\n            if self.subdivision == 'mesh':\n                mesh = exportAsMesh(grid, dx, dy, self.step, reproj=rprjToScene, flat=True)\n            else:\n                mesh = rasterExtentToMesh(name, grid, dx, dy, pxLoc='CENTER', reproj=rprjToScene)\n            obj = placeObj(mesh, name)\n            subBox = getBBOX.fromObj(obj).toGeo(geoscn)\n        previousUVmapIdx = mesh.uv_layers.active_index\n        uvTxtLayer = mesh.uv_layers.new(name='demUVmap')\n        geoRastUVmap(obj, uvTxtLayer, grid, dx, dy, reproj=rprjToRaster)\n        if previousUVmapIdx != -1:\n            mesh.uv_layers.active_index = previousUVmapIdx\n        if self.subdivision == 'subsurf':\n            if not 'SUBSURF' in [mod.type for mod in obj.modifiers]:\n                subsurf = obj.modifiers.new('DEM', type='SUBSURF')\n                subsurf.subdivision_type = 'SIMPLE'\n                subsurf.levels = 6\n                subsurf.render_levels = 6\n        dsp = setDisplacer(obj, grid, uvTxtLayer, interpolation=self.demInterpolation)\n    if self.importMode == 'DEM_RAW':\n        subBox = None\n        if self.clip:\n            if not geoscn.isGeoref or len(self.objectsLst) == 0:\n                self.report({'ERROR'}, 'No working extent')\n                return {'CANCELLED'}\n            obj = scn.objects[int(self.objectsLst)]\n            subBox = getBBOX.fromObj(obj).toGeo(geoscn)\n            if rprj:\n                subBox = rprjToRaster.bbox(subBox)\n        try:\n            grid = GeoRaster(filePath, subBoxGeo=subBox, useGDAL=HAS_GDAL)\n        except IOError as e:\n            log.error('Unable to open raster', exc_info=True)\n            self.report({'ERROR'}, 'Unable to open raster, check logs for more infos')\n            return {'CANCELLED'}\n        except OverlapError:\n            self.report({'ERROR'}, 'Non overlap data')\n            return {'CANCELLED'}\n        if not geoscn.isGeoref:\n            (dx, dy) = (grid.center.x, grid.center.y)\n            if rprj:\n                (dx, dy) = rprjToScene.pt(dx, dy)\n            geoscn.setOriginPrj(dx, dy)\n        mesh = exportAsMesh(grid, dx, dy, self.step, reproj=rprjToScene, subset=self.clip, flat=False, buildFaces=self.buildFaces)\n        obj = placeObj(mesh, name)\n    if self.importMode == 'PLANE' or (self.importMode == 'DEM' and (not self.demOnMesh)) or self.importMode == 'DEM_RAW':\n        newObjCreated = True\n    else:\n        newObjCreated = False\n    if newObjCreated and prefs.adjust3Dview:\n        bb = getBBOX.fromObj(obj)\n        adjust3Dview(context, bb)\n    if prefs.forceTexturedSolid:\n        showTextures(context)\n    return {'FINISHED'}",
            "def execute(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    prefs = context.preferences.addons[PKG].preferences\n    bpy.ops.object.select_all(action='DESELECT')\n    scn = bpy.context.scene\n    geoscn = GeoScene(scn)\n    if geoscn.isBroken:\n        self.report({'ERROR'}, 'Scene georef is broken, please fix it beforehand')\n        return {'CANCELLED'}\n    scale = geoscn.scale\n    if geoscn.isGeoref:\n        (dx, dy) = geoscn.getOriginPrj()\n        if self.reprojection:\n            rastCRS = self.rastCRS\n        else:\n            rastCRS = geoscn.crs\n    else:\n        rastCRS = self.rastCRS\n        try:\n            geoscn.crs = rastCRS\n        except Exception as e:\n            log.error('Cannot set scene crs', exc_info=True)\n            self.report({'ERROR'}, 'Cannot set scene crs, check logs for more infos')\n            return {'CANCELLED'}\n    if geoscn.crs != rastCRS:\n        rprj = True\n        rprjToRaster = Reproj(geoscn.crs, rastCRS)\n        rprjToScene = Reproj(rastCRS, geoscn.crs)\n    else:\n        rprj = False\n        rprjToRaster = None\n        rprjToScene = None\n    filePath = self.filepath\n    name = os.path.basename(filePath)[:-4]\n    if self.importMode == 'PLANE':\n        try:\n            rast = bpyGeoRaster(filePath)\n        except IOError as e:\n            log.error('Unable to open raster', exc_info=True)\n            self.report({'ERROR'}, 'Unable to open raster, check logs for more infos')\n            return {'CANCELLED'}\n        if not geoscn.isGeoref:\n            (dx, dy) = (rast.center.x, rast.center.y)\n            if rprj:\n                (dx, dy) = rprjToScene.pt(dx, dy)\n            geoscn.setOriginPrj(dx, dy)\n        mesh = rasterExtentToMesh(name, rast, dx, dy, reproj=rprjToScene)\n        obj = placeObj(mesh, name)\n        uvTxtLayer = mesh.uv_layers.new(name='rastUVmap')\n        geoRastUVmap(obj, uvTxtLayer, rast, dx, dy, reproj=rprjToRaster)\n        mat = bpy.data.materials.new('rastMat')\n        obj.data.materials.append(mat)\n        addTexture(mat, rast.bpyImg, uvTxtLayer, name='rastText')\n    if self.importMode == 'BKG':\n        if rprj:\n            self.report({'ERROR'}, 'Raster reprojection is not possible in background mode')\n            return {'CANCELLED'}\n        try:\n            rast = bpyGeoRaster(filePath)\n        except IOError as e:\n            log.error('Unable to open raster', exc_info=True)\n            self.report({'ERROR'}, 'Unable to open raster, check logs for more infos')\n            return {'CANCELLED'}\n        if rast.rotation.xy != [0, 0]:\n            self.report({'ERROR'}, 'Cannot apply a rotation in background image mode')\n            return {'CANCELLED'}\n        if abs(round(rast.pxSize.x, 3)) != abs(round(rast.pxSize.y, 3)):\n            self.report({'ERROR'}, 'Background image needs equal pixel size in map units in both x ans y axis')\n            return {'CANCELLED'}\n        trueSizeX = rast.geoSize.x\n        trueSizeY = rast.geoSize.y\n        ratio = rast.size.x / rast.size.y\n        if geoscn.isGeoref:\n            (offx, offy) = (rast.center.x - dx, rast.center.y - dy)\n        else:\n            (dx, dy) = (rast.center.x, rast.center.y)\n            geoscn.setOriginPrj(dx, dy)\n            (offx, offy) = (0, 0)\n        bkg = bpy.data.objects.new(self.name, None)\n        bkg.empty_display_type = 'IMAGE'\n        bkg.empty_image_depth = 'BACK'\n        bkg.data = rast.bpyImg\n        scn.collection.objects.link(bkg)\n        bkg.empty_display_size = 1\n        bkg.scale = (trueSizeX, trueSizeY * ratio, 1)\n        bkg.location = (offx, offy, 0)\n        bpy.context.view_layer.objects.active = bkg\n        bkg.select_set(True)\n        if prefs.adjust3Dview:\n            adjust3Dview(context, rast.bbox)\n    if self.importMode == 'MESH':\n        if not geoscn.isGeoref or len(self.objectsLst) == 0:\n            self.report({'ERROR'}, \"There isn't georef mesh to apply on\")\n            return {'CANCELLED'}\n        obj = scn.objects[int(self.objectsLst)]\n        obj.select_set(True)\n        context.view_layer.objects.active = obj\n        subBox = getBBOX.fromObj(obj).toGeo(geoscn)\n        if rprj:\n            subBox = rprjToRaster.bbox(subBox)\n        try:\n            rast = bpyGeoRaster(filePath, subBoxGeo=subBox)\n        except IOError as e:\n            log.error('Unable to open raster', exc_info=True)\n            self.report({'ERROR'}, 'Unable to open raster, check logs for more infos')\n            return {'CANCELLED'}\n        except OverlapError:\n            self.report({'ERROR'}, 'Non overlap data')\n            return {'CANCELLED'}\n        mesh = obj.data\n        uvTxtLayer = mesh.uv_layers.new(name='rastUVmap')\n        uvTxtLayer.active = True\n        geoRastUVmap(obj, uvTxtLayer, rast, dx, dy, reproj=rprjToRaster)\n        mat = bpy.data.materials.new('rastMat')\n        obj.data.materials.append(mat)\n        addTexture(mat, rast.bpyImg, uvTxtLayer, name='rastText')\n    if self.importMode == 'DEM':\n        if self.demOnMesh:\n            if not geoscn.isGeoref or len(self.objectsLst) == 0:\n                self.report({'ERROR'}, \"There isn't georef mesh to apply on\")\n                return {'CANCELLED'}\n            obj = scn.objects[int(self.objectsLst)]\n            mesh = obj.data\n            obj.select_set(True)\n            context.view_layer.objects.active = obj\n            subBox = getBBOX.fromObj(obj).toGeo(geoscn)\n            if rprj:\n                subBox = rprjToRaster.bbox(subBox)\n        else:\n            subBox = None\n        try:\n            grid = bpyGeoRaster(filePath, subBoxGeo=subBox, clip=self.clip, fillNodata=self.fillNodata, useGDAL=HAS_GDAL, raw=True)\n        except IOError as e:\n            log.error('Unable to open raster', exc_info=True)\n            self.report({'ERROR'}, 'Unable to open raster, check logs for more infos')\n            return {'CANCELLED'}\n        except OverlapError:\n            self.report({'ERROR'}, 'Non overlap data')\n            return {'CANCELLED'}\n        if not self.demOnMesh:\n            if not geoscn.isGeoref:\n                (dx, dy) = (grid.center.x, grid.center.y)\n                if rprj:\n                    (dx, dy) = rprjToScene.pt(dx, dy)\n                geoscn.setOriginPrj(dx, dy)\n            if self.subdivision == 'mesh':\n                mesh = exportAsMesh(grid, dx, dy, self.step, reproj=rprjToScene, flat=True)\n            else:\n                mesh = rasterExtentToMesh(name, grid, dx, dy, pxLoc='CENTER', reproj=rprjToScene)\n            obj = placeObj(mesh, name)\n            subBox = getBBOX.fromObj(obj).toGeo(geoscn)\n        previousUVmapIdx = mesh.uv_layers.active_index\n        uvTxtLayer = mesh.uv_layers.new(name='demUVmap')\n        geoRastUVmap(obj, uvTxtLayer, grid, dx, dy, reproj=rprjToRaster)\n        if previousUVmapIdx != -1:\n            mesh.uv_layers.active_index = previousUVmapIdx\n        if self.subdivision == 'subsurf':\n            if not 'SUBSURF' in [mod.type for mod in obj.modifiers]:\n                subsurf = obj.modifiers.new('DEM', type='SUBSURF')\n                subsurf.subdivision_type = 'SIMPLE'\n                subsurf.levels = 6\n                subsurf.render_levels = 6\n        dsp = setDisplacer(obj, grid, uvTxtLayer, interpolation=self.demInterpolation)\n    if self.importMode == 'DEM_RAW':\n        subBox = None\n        if self.clip:\n            if not geoscn.isGeoref or len(self.objectsLst) == 0:\n                self.report({'ERROR'}, 'No working extent')\n                return {'CANCELLED'}\n            obj = scn.objects[int(self.objectsLst)]\n            subBox = getBBOX.fromObj(obj).toGeo(geoscn)\n            if rprj:\n                subBox = rprjToRaster.bbox(subBox)\n        try:\n            grid = GeoRaster(filePath, subBoxGeo=subBox, useGDAL=HAS_GDAL)\n        except IOError as e:\n            log.error('Unable to open raster', exc_info=True)\n            self.report({'ERROR'}, 'Unable to open raster, check logs for more infos')\n            return {'CANCELLED'}\n        except OverlapError:\n            self.report({'ERROR'}, 'Non overlap data')\n            return {'CANCELLED'}\n        if not geoscn.isGeoref:\n            (dx, dy) = (grid.center.x, grid.center.y)\n            if rprj:\n                (dx, dy) = rprjToScene.pt(dx, dy)\n            geoscn.setOriginPrj(dx, dy)\n        mesh = exportAsMesh(grid, dx, dy, self.step, reproj=rprjToScene, subset=self.clip, flat=False, buildFaces=self.buildFaces)\n        obj = placeObj(mesh, name)\n    if self.importMode == 'PLANE' or (self.importMode == 'DEM' and (not self.demOnMesh)) or self.importMode == 'DEM_RAW':\n        newObjCreated = True\n    else:\n        newObjCreated = False\n    if newObjCreated and prefs.adjust3Dview:\n        bb = getBBOX.fromObj(obj)\n        adjust3Dview(context, bb)\n    if prefs.forceTexturedSolid:\n        showTextures(context)\n    return {'FINISHED'}"
        ]
    },
    {
        "func_name": "register",
        "original": "def register():\n    try:\n        bpy.utils.register_class(IMPORTGIS_OT_georaster)\n    except ValueError as e:\n        log.warning('{} is already registered, now unregister and retry... '.format(IMPORTGIS_OT_georaster))\n        unregister()\n        bpy.utils.register_class(IMPORTGIS_OT_georaster)",
        "mutated": [
            "def register():\n    if False:\n        i = 10\n    try:\n        bpy.utils.register_class(IMPORTGIS_OT_georaster)\n    except ValueError as e:\n        log.warning('{} is already registered, now unregister and retry... '.format(IMPORTGIS_OT_georaster))\n        unregister()\n        bpy.utils.register_class(IMPORTGIS_OT_georaster)",
            "def register():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    try:\n        bpy.utils.register_class(IMPORTGIS_OT_georaster)\n    except ValueError as e:\n        log.warning('{} is already registered, now unregister and retry... '.format(IMPORTGIS_OT_georaster))\n        unregister()\n        bpy.utils.register_class(IMPORTGIS_OT_georaster)",
            "def register():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    try:\n        bpy.utils.register_class(IMPORTGIS_OT_georaster)\n    except ValueError as e:\n        log.warning('{} is already registered, now unregister and retry... '.format(IMPORTGIS_OT_georaster))\n        unregister()\n        bpy.utils.register_class(IMPORTGIS_OT_georaster)",
            "def register():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    try:\n        bpy.utils.register_class(IMPORTGIS_OT_georaster)\n    except ValueError as e:\n        log.warning('{} is already registered, now unregister and retry... '.format(IMPORTGIS_OT_georaster))\n        unregister()\n        bpy.utils.register_class(IMPORTGIS_OT_georaster)",
            "def register():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    try:\n        bpy.utils.register_class(IMPORTGIS_OT_georaster)\n    except ValueError as e:\n        log.warning('{} is already registered, now unregister and retry... '.format(IMPORTGIS_OT_georaster))\n        unregister()\n        bpy.utils.register_class(IMPORTGIS_OT_georaster)"
        ]
    },
    {
        "func_name": "unregister",
        "original": "def unregister():\n    bpy.utils.unregister_class(IMPORTGIS_OT_georaster)",
        "mutated": [
            "def unregister():\n    if False:\n        i = 10\n    bpy.utils.unregister_class(IMPORTGIS_OT_georaster)",
            "def unregister():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    bpy.utils.unregister_class(IMPORTGIS_OT_georaster)",
            "def unregister():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    bpy.utils.unregister_class(IMPORTGIS_OT_georaster)",
            "def unregister():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    bpy.utils.unregister_class(IMPORTGIS_OT_georaster)",
            "def unregister():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    bpy.utils.unregister_class(IMPORTGIS_OT_georaster)"
        ]
    }
]