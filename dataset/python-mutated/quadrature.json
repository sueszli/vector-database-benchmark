[
    {
        "func_name": "gauss_legendre",
        "original": "def gauss_legendre(n, n_digits):\n    \"\"\"\n    Computes the Gauss-Legendre quadrature [1]_ points and weights.\n\n    Explanation\n    ===========\n\n    The Gauss-Legendre quadrature approximates the integral:\n\n    .. math::\n        \\\\int_{-1}^1 f(x)\\\\,dx \\\\approx \\\\sum_{i=1}^n w_i f(x_i)\n\n    The nodes `x_i` of an order `n` quadrature rule are the roots of `P_n`\n    and the weights `w_i` are given by:\n\n    .. math::\n        w_i = \\\\frac{2}{\\\\left(1-x_i^2\\\\right) \\\\left(P'_n(x_i)\\\\right)^2}\n\n    Parameters\n    ==========\n\n    n :\n        The order of quadrature.\n    n_digits :\n        Number of significant digits of the points and weights to return.\n\n    Returns\n    =======\n\n    (x, w) : the ``x`` and ``w`` are lists of points and weights as Floats.\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\n             tuple of lists.\n\n    Examples\n    ========\n\n    >>> from sympy.integrals.quadrature import gauss_legendre\n    >>> x, w = gauss_legendre(3, 5)\n    >>> x\n    [-0.7746, 0, 0.7746]\n    >>> w\n    [0.55556, 0.88889, 0.55556]\n    >>> x, w = gauss_legendre(4, 5)\n    >>> x\n    [-0.86114, -0.33998, 0.33998, 0.86114]\n    >>> w\n    [0.34785, 0.65215, 0.65215, 0.34785]\n\n    See Also\n    ========\n\n    gauss_laguerre, gauss_gen_laguerre, gauss_hermite, gauss_chebyshev_t, gauss_chebyshev_u, gauss_jacobi, gauss_lobatto\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Gaussian_quadrature\n    .. [2] https://people.sc.fsu.edu/~jburkardt/cpp_src/legendre_rule/legendre_rule.html\n    \"\"\"\n    x = Dummy('x')\n    p = legendre_poly(n, x, polys=True)\n    pd = p.diff(x)\n    xi = []\n    w = []\n    for r in p.real_roots():\n        if isinstance(r, RootOf):\n            r = r.eval_rational(S.One / 10 ** (n_digits + 2))\n        xi.append(r.n(n_digits))\n        w.append((2 / ((1 - r ** 2) * pd.subs(x, r) ** 2)).n(n_digits))\n    return (xi, w)",
        "mutated": [
            "def gauss_legendre(n, n_digits):\n    if False:\n        i = 10\n    \"\\n    Computes the Gauss-Legendre quadrature [1]_ points and weights.\\n\\n    Explanation\\n    ===========\\n\\n    The Gauss-Legendre quadrature approximates the integral:\\n\\n    .. math::\\n        \\\\int_{-1}^1 f(x)\\\\,dx \\\\approx \\\\sum_{i=1}^n w_i f(x_i)\\n\\n    The nodes `x_i` of an order `n` quadrature rule are the roots of `P_n`\\n    and the weights `w_i` are given by:\\n\\n    .. math::\\n        w_i = \\\\frac{2}{\\\\left(1-x_i^2\\\\right) \\\\left(P'_n(x_i)\\\\right)^2}\\n\\n    Parameters\\n    ==========\\n\\n    n :\\n        The order of quadrature.\\n    n_digits :\\n        Number of significant digits of the points and weights to return.\\n\\n    Returns\\n    =======\\n\\n    (x, w) : the ``x`` and ``w`` are lists of points and weights as Floats.\\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\\n             tuple of lists.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.integrals.quadrature import gauss_legendre\\n    >>> x, w = gauss_legendre(3, 5)\\n    >>> x\\n    [-0.7746, 0, 0.7746]\\n    >>> w\\n    [0.55556, 0.88889, 0.55556]\\n    >>> x, w = gauss_legendre(4, 5)\\n    >>> x\\n    [-0.86114, -0.33998, 0.33998, 0.86114]\\n    >>> w\\n    [0.34785, 0.65215, 0.65215, 0.34785]\\n\\n    See Also\\n    ========\\n\\n    gauss_laguerre, gauss_gen_laguerre, gauss_hermite, gauss_chebyshev_t, gauss_chebyshev_u, gauss_jacobi, gauss_lobatto\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Gaussian_quadrature\\n    .. [2] https://people.sc.fsu.edu/~jburkardt/cpp_src/legendre_rule/legendre_rule.html\\n    \"\n    x = Dummy('x')\n    p = legendre_poly(n, x, polys=True)\n    pd = p.diff(x)\n    xi = []\n    w = []\n    for r in p.real_roots():\n        if isinstance(r, RootOf):\n            r = r.eval_rational(S.One / 10 ** (n_digits + 2))\n        xi.append(r.n(n_digits))\n        w.append((2 / ((1 - r ** 2) * pd.subs(x, r) ** 2)).n(n_digits))\n    return (xi, w)",
            "def gauss_legendre(n, n_digits):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Computes the Gauss-Legendre quadrature [1]_ points and weights.\\n\\n    Explanation\\n    ===========\\n\\n    The Gauss-Legendre quadrature approximates the integral:\\n\\n    .. math::\\n        \\\\int_{-1}^1 f(x)\\\\,dx \\\\approx \\\\sum_{i=1}^n w_i f(x_i)\\n\\n    The nodes `x_i` of an order `n` quadrature rule are the roots of `P_n`\\n    and the weights `w_i` are given by:\\n\\n    .. math::\\n        w_i = \\\\frac{2}{\\\\left(1-x_i^2\\\\right) \\\\left(P'_n(x_i)\\\\right)^2}\\n\\n    Parameters\\n    ==========\\n\\n    n :\\n        The order of quadrature.\\n    n_digits :\\n        Number of significant digits of the points and weights to return.\\n\\n    Returns\\n    =======\\n\\n    (x, w) : the ``x`` and ``w`` are lists of points and weights as Floats.\\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\\n             tuple of lists.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.integrals.quadrature import gauss_legendre\\n    >>> x, w = gauss_legendre(3, 5)\\n    >>> x\\n    [-0.7746, 0, 0.7746]\\n    >>> w\\n    [0.55556, 0.88889, 0.55556]\\n    >>> x, w = gauss_legendre(4, 5)\\n    >>> x\\n    [-0.86114, -0.33998, 0.33998, 0.86114]\\n    >>> w\\n    [0.34785, 0.65215, 0.65215, 0.34785]\\n\\n    See Also\\n    ========\\n\\n    gauss_laguerre, gauss_gen_laguerre, gauss_hermite, gauss_chebyshev_t, gauss_chebyshev_u, gauss_jacobi, gauss_lobatto\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Gaussian_quadrature\\n    .. [2] https://people.sc.fsu.edu/~jburkardt/cpp_src/legendre_rule/legendre_rule.html\\n    \"\n    x = Dummy('x')\n    p = legendre_poly(n, x, polys=True)\n    pd = p.diff(x)\n    xi = []\n    w = []\n    for r in p.real_roots():\n        if isinstance(r, RootOf):\n            r = r.eval_rational(S.One / 10 ** (n_digits + 2))\n        xi.append(r.n(n_digits))\n        w.append((2 / ((1 - r ** 2) * pd.subs(x, r) ** 2)).n(n_digits))\n    return (xi, w)",
            "def gauss_legendre(n, n_digits):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Computes the Gauss-Legendre quadrature [1]_ points and weights.\\n\\n    Explanation\\n    ===========\\n\\n    The Gauss-Legendre quadrature approximates the integral:\\n\\n    .. math::\\n        \\\\int_{-1}^1 f(x)\\\\,dx \\\\approx \\\\sum_{i=1}^n w_i f(x_i)\\n\\n    The nodes `x_i` of an order `n` quadrature rule are the roots of `P_n`\\n    and the weights `w_i` are given by:\\n\\n    .. math::\\n        w_i = \\\\frac{2}{\\\\left(1-x_i^2\\\\right) \\\\left(P'_n(x_i)\\\\right)^2}\\n\\n    Parameters\\n    ==========\\n\\n    n :\\n        The order of quadrature.\\n    n_digits :\\n        Number of significant digits of the points and weights to return.\\n\\n    Returns\\n    =======\\n\\n    (x, w) : the ``x`` and ``w`` are lists of points and weights as Floats.\\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\\n             tuple of lists.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.integrals.quadrature import gauss_legendre\\n    >>> x, w = gauss_legendre(3, 5)\\n    >>> x\\n    [-0.7746, 0, 0.7746]\\n    >>> w\\n    [0.55556, 0.88889, 0.55556]\\n    >>> x, w = gauss_legendre(4, 5)\\n    >>> x\\n    [-0.86114, -0.33998, 0.33998, 0.86114]\\n    >>> w\\n    [0.34785, 0.65215, 0.65215, 0.34785]\\n\\n    See Also\\n    ========\\n\\n    gauss_laguerre, gauss_gen_laguerre, gauss_hermite, gauss_chebyshev_t, gauss_chebyshev_u, gauss_jacobi, gauss_lobatto\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Gaussian_quadrature\\n    .. [2] https://people.sc.fsu.edu/~jburkardt/cpp_src/legendre_rule/legendre_rule.html\\n    \"\n    x = Dummy('x')\n    p = legendre_poly(n, x, polys=True)\n    pd = p.diff(x)\n    xi = []\n    w = []\n    for r in p.real_roots():\n        if isinstance(r, RootOf):\n            r = r.eval_rational(S.One / 10 ** (n_digits + 2))\n        xi.append(r.n(n_digits))\n        w.append((2 / ((1 - r ** 2) * pd.subs(x, r) ** 2)).n(n_digits))\n    return (xi, w)",
            "def gauss_legendre(n, n_digits):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Computes the Gauss-Legendre quadrature [1]_ points and weights.\\n\\n    Explanation\\n    ===========\\n\\n    The Gauss-Legendre quadrature approximates the integral:\\n\\n    .. math::\\n        \\\\int_{-1}^1 f(x)\\\\,dx \\\\approx \\\\sum_{i=1}^n w_i f(x_i)\\n\\n    The nodes `x_i` of an order `n` quadrature rule are the roots of `P_n`\\n    and the weights `w_i` are given by:\\n\\n    .. math::\\n        w_i = \\\\frac{2}{\\\\left(1-x_i^2\\\\right) \\\\left(P'_n(x_i)\\\\right)^2}\\n\\n    Parameters\\n    ==========\\n\\n    n :\\n        The order of quadrature.\\n    n_digits :\\n        Number of significant digits of the points and weights to return.\\n\\n    Returns\\n    =======\\n\\n    (x, w) : the ``x`` and ``w`` are lists of points and weights as Floats.\\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\\n             tuple of lists.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.integrals.quadrature import gauss_legendre\\n    >>> x, w = gauss_legendre(3, 5)\\n    >>> x\\n    [-0.7746, 0, 0.7746]\\n    >>> w\\n    [0.55556, 0.88889, 0.55556]\\n    >>> x, w = gauss_legendre(4, 5)\\n    >>> x\\n    [-0.86114, -0.33998, 0.33998, 0.86114]\\n    >>> w\\n    [0.34785, 0.65215, 0.65215, 0.34785]\\n\\n    See Also\\n    ========\\n\\n    gauss_laguerre, gauss_gen_laguerre, gauss_hermite, gauss_chebyshev_t, gauss_chebyshev_u, gauss_jacobi, gauss_lobatto\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Gaussian_quadrature\\n    .. [2] https://people.sc.fsu.edu/~jburkardt/cpp_src/legendre_rule/legendre_rule.html\\n    \"\n    x = Dummy('x')\n    p = legendre_poly(n, x, polys=True)\n    pd = p.diff(x)\n    xi = []\n    w = []\n    for r in p.real_roots():\n        if isinstance(r, RootOf):\n            r = r.eval_rational(S.One / 10 ** (n_digits + 2))\n        xi.append(r.n(n_digits))\n        w.append((2 / ((1 - r ** 2) * pd.subs(x, r) ** 2)).n(n_digits))\n    return (xi, w)",
            "def gauss_legendre(n, n_digits):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Computes the Gauss-Legendre quadrature [1]_ points and weights.\\n\\n    Explanation\\n    ===========\\n\\n    The Gauss-Legendre quadrature approximates the integral:\\n\\n    .. math::\\n        \\\\int_{-1}^1 f(x)\\\\,dx \\\\approx \\\\sum_{i=1}^n w_i f(x_i)\\n\\n    The nodes `x_i` of an order `n` quadrature rule are the roots of `P_n`\\n    and the weights `w_i` are given by:\\n\\n    .. math::\\n        w_i = \\\\frac{2}{\\\\left(1-x_i^2\\\\right) \\\\left(P'_n(x_i)\\\\right)^2}\\n\\n    Parameters\\n    ==========\\n\\n    n :\\n        The order of quadrature.\\n    n_digits :\\n        Number of significant digits of the points and weights to return.\\n\\n    Returns\\n    =======\\n\\n    (x, w) : the ``x`` and ``w`` are lists of points and weights as Floats.\\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\\n             tuple of lists.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.integrals.quadrature import gauss_legendre\\n    >>> x, w = gauss_legendre(3, 5)\\n    >>> x\\n    [-0.7746, 0, 0.7746]\\n    >>> w\\n    [0.55556, 0.88889, 0.55556]\\n    >>> x, w = gauss_legendre(4, 5)\\n    >>> x\\n    [-0.86114, -0.33998, 0.33998, 0.86114]\\n    >>> w\\n    [0.34785, 0.65215, 0.65215, 0.34785]\\n\\n    See Also\\n    ========\\n\\n    gauss_laguerre, gauss_gen_laguerre, gauss_hermite, gauss_chebyshev_t, gauss_chebyshev_u, gauss_jacobi, gauss_lobatto\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Gaussian_quadrature\\n    .. [2] https://people.sc.fsu.edu/~jburkardt/cpp_src/legendre_rule/legendre_rule.html\\n    \"\n    x = Dummy('x')\n    p = legendre_poly(n, x, polys=True)\n    pd = p.diff(x)\n    xi = []\n    w = []\n    for r in p.real_roots():\n        if isinstance(r, RootOf):\n            r = r.eval_rational(S.One / 10 ** (n_digits + 2))\n        xi.append(r.n(n_digits))\n        w.append((2 / ((1 - r ** 2) * pd.subs(x, r) ** 2)).n(n_digits))\n    return (xi, w)"
        ]
    },
    {
        "func_name": "gauss_laguerre",
        "original": "def gauss_laguerre(n, n_digits):\n    \"\"\"\n    Computes the Gauss-Laguerre quadrature [1]_ points and weights.\n\n    Explanation\n    ===========\n\n    The Gauss-Laguerre quadrature approximates the integral:\n\n    .. math::\n        \\\\int_0^{\\\\infty} e^{-x} f(x)\\\\,dx \\\\approx \\\\sum_{i=1}^n w_i f(x_i)\n\n\n    The nodes `x_i` of an order `n` quadrature rule are the roots of `L_n`\n    and the weights `w_i` are given by:\n\n    .. math::\n        w_i = \\\\frac{x_i}{(n+1)^2 \\\\left(L_{n+1}(x_i)\\\\right)^2}\n\n    Parameters\n    ==========\n\n    n :\n        The order of quadrature.\n    n_digits :\n        Number of significant digits of the points and weights to return.\n\n    Returns\n    =======\n\n    (x, w) : The ``x`` and ``w`` are lists of points and weights as Floats.\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\n             tuple of lists.\n\n    Examples\n    ========\n\n    >>> from sympy.integrals.quadrature import gauss_laguerre\n    >>> x, w = gauss_laguerre(3, 5)\n    >>> x\n    [0.41577, 2.2943, 6.2899]\n    >>> w\n    [0.71109, 0.27852, 0.010389]\n    >>> x, w = gauss_laguerre(6, 5)\n    >>> x\n    [0.22285, 1.1889, 2.9927, 5.7751, 9.8375, 15.983]\n    >>> w\n    [0.45896, 0.417, 0.11337, 0.010399, 0.00026102, 8.9855e-7]\n\n    See Also\n    ========\n\n    gauss_legendre, gauss_gen_laguerre, gauss_hermite, gauss_chebyshev_t, gauss_chebyshev_u, gauss_jacobi, gauss_lobatto\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Gauss%E2%80%93Laguerre_quadrature\n    .. [2] https://people.sc.fsu.edu/~jburkardt/cpp_src/laguerre_rule/laguerre_rule.html\n    \"\"\"\n    x = Dummy('x')\n    p = laguerre_poly(n, x, polys=True)\n    p1 = laguerre_poly(n + 1, x, polys=True)\n    xi = []\n    w = []\n    for r in p.real_roots():\n        if isinstance(r, RootOf):\n            r = r.eval_rational(S.One / 10 ** (n_digits + 2))\n        xi.append(r.n(n_digits))\n        w.append((r / ((n + 1) ** 2 * p1.subs(x, r) ** 2)).n(n_digits))\n    return (xi, w)",
        "mutated": [
            "def gauss_laguerre(n, n_digits):\n    if False:\n        i = 10\n    '\\n    Computes the Gauss-Laguerre quadrature [1]_ points and weights.\\n\\n    Explanation\\n    ===========\\n\\n    The Gauss-Laguerre quadrature approximates the integral:\\n\\n    .. math::\\n        \\\\int_0^{\\\\infty} e^{-x} f(x)\\\\,dx \\\\approx \\\\sum_{i=1}^n w_i f(x_i)\\n\\n\\n    The nodes `x_i` of an order `n` quadrature rule are the roots of `L_n`\\n    and the weights `w_i` are given by:\\n\\n    .. math::\\n        w_i = \\\\frac{x_i}{(n+1)^2 \\\\left(L_{n+1}(x_i)\\\\right)^2}\\n\\n    Parameters\\n    ==========\\n\\n    n :\\n        The order of quadrature.\\n    n_digits :\\n        Number of significant digits of the points and weights to return.\\n\\n    Returns\\n    =======\\n\\n    (x, w) : The ``x`` and ``w`` are lists of points and weights as Floats.\\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\\n             tuple of lists.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.integrals.quadrature import gauss_laguerre\\n    >>> x, w = gauss_laguerre(3, 5)\\n    >>> x\\n    [0.41577, 2.2943, 6.2899]\\n    >>> w\\n    [0.71109, 0.27852, 0.010389]\\n    >>> x, w = gauss_laguerre(6, 5)\\n    >>> x\\n    [0.22285, 1.1889, 2.9927, 5.7751, 9.8375, 15.983]\\n    >>> w\\n    [0.45896, 0.417, 0.11337, 0.010399, 0.00026102, 8.9855e-7]\\n\\n    See Also\\n    ========\\n\\n    gauss_legendre, gauss_gen_laguerre, gauss_hermite, gauss_chebyshev_t, gauss_chebyshev_u, gauss_jacobi, gauss_lobatto\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Gauss%E2%80%93Laguerre_quadrature\\n    .. [2] https://people.sc.fsu.edu/~jburkardt/cpp_src/laguerre_rule/laguerre_rule.html\\n    '\n    x = Dummy('x')\n    p = laguerre_poly(n, x, polys=True)\n    p1 = laguerre_poly(n + 1, x, polys=True)\n    xi = []\n    w = []\n    for r in p.real_roots():\n        if isinstance(r, RootOf):\n            r = r.eval_rational(S.One / 10 ** (n_digits + 2))\n        xi.append(r.n(n_digits))\n        w.append((r / ((n + 1) ** 2 * p1.subs(x, r) ** 2)).n(n_digits))\n    return (xi, w)",
            "def gauss_laguerre(n, n_digits):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Computes the Gauss-Laguerre quadrature [1]_ points and weights.\\n\\n    Explanation\\n    ===========\\n\\n    The Gauss-Laguerre quadrature approximates the integral:\\n\\n    .. math::\\n        \\\\int_0^{\\\\infty} e^{-x} f(x)\\\\,dx \\\\approx \\\\sum_{i=1}^n w_i f(x_i)\\n\\n\\n    The nodes `x_i` of an order `n` quadrature rule are the roots of `L_n`\\n    and the weights `w_i` are given by:\\n\\n    .. math::\\n        w_i = \\\\frac{x_i}{(n+1)^2 \\\\left(L_{n+1}(x_i)\\\\right)^2}\\n\\n    Parameters\\n    ==========\\n\\n    n :\\n        The order of quadrature.\\n    n_digits :\\n        Number of significant digits of the points and weights to return.\\n\\n    Returns\\n    =======\\n\\n    (x, w) : The ``x`` and ``w`` are lists of points and weights as Floats.\\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\\n             tuple of lists.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.integrals.quadrature import gauss_laguerre\\n    >>> x, w = gauss_laguerre(3, 5)\\n    >>> x\\n    [0.41577, 2.2943, 6.2899]\\n    >>> w\\n    [0.71109, 0.27852, 0.010389]\\n    >>> x, w = gauss_laguerre(6, 5)\\n    >>> x\\n    [0.22285, 1.1889, 2.9927, 5.7751, 9.8375, 15.983]\\n    >>> w\\n    [0.45896, 0.417, 0.11337, 0.010399, 0.00026102, 8.9855e-7]\\n\\n    See Also\\n    ========\\n\\n    gauss_legendre, gauss_gen_laguerre, gauss_hermite, gauss_chebyshev_t, gauss_chebyshev_u, gauss_jacobi, gauss_lobatto\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Gauss%E2%80%93Laguerre_quadrature\\n    .. [2] https://people.sc.fsu.edu/~jburkardt/cpp_src/laguerre_rule/laguerre_rule.html\\n    '\n    x = Dummy('x')\n    p = laguerre_poly(n, x, polys=True)\n    p1 = laguerre_poly(n + 1, x, polys=True)\n    xi = []\n    w = []\n    for r in p.real_roots():\n        if isinstance(r, RootOf):\n            r = r.eval_rational(S.One / 10 ** (n_digits + 2))\n        xi.append(r.n(n_digits))\n        w.append((r / ((n + 1) ** 2 * p1.subs(x, r) ** 2)).n(n_digits))\n    return (xi, w)",
            "def gauss_laguerre(n, n_digits):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Computes the Gauss-Laguerre quadrature [1]_ points and weights.\\n\\n    Explanation\\n    ===========\\n\\n    The Gauss-Laguerre quadrature approximates the integral:\\n\\n    .. math::\\n        \\\\int_0^{\\\\infty} e^{-x} f(x)\\\\,dx \\\\approx \\\\sum_{i=1}^n w_i f(x_i)\\n\\n\\n    The nodes `x_i` of an order `n` quadrature rule are the roots of `L_n`\\n    and the weights `w_i` are given by:\\n\\n    .. math::\\n        w_i = \\\\frac{x_i}{(n+1)^2 \\\\left(L_{n+1}(x_i)\\\\right)^2}\\n\\n    Parameters\\n    ==========\\n\\n    n :\\n        The order of quadrature.\\n    n_digits :\\n        Number of significant digits of the points and weights to return.\\n\\n    Returns\\n    =======\\n\\n    (x, w) : The ``x`` and ``w`` are lists of points and weights as Floats.\\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\\n             tuple of lists.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.integrals.quadrature import gauss_laguerre\\n    >>> x, w = gauss_laguerre(3, 5)\\n    >>> x\\n    [0.41577, 2.2943, 6.2899]\\n    >>> w\\n    [0.71109, 0.27852, 0.010389]\\n    >>> x, w = gauss_laguerre(6, 5)\\n    >>> x\\n    [0.22285, 1.1889, 2.9927, 5.7751, 9.8375, 15.983]\\n    >>> w\\n    [0.45896, 0.417, 0.11337, 0.010399, 0.00026102, 8.9855e-7]\\n\\n    See Also\\n    ========\\n\\n    gauss_legendre, gauss_gen_laguerre, gauss_hermite, gauss_chebyshev_t, gauss_chebyshev_u, gauss_jacobi, gauss_lobatto\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Gauss%E2%80%93Laguerre_quadrature\\n    .. [2] https://people.sc.fsu.edu/~jburkardt/cpp_src/laguerre_rule/laguerre_rule.html\\n    '\n    x = Dummy('x')\n    p = laguerre_poly(n, x, polys=True)\n    p1 = laguerre_poly(n + 1, x, polys=True)\n    xi = []\n    w = []\n    for r in p.real_roots():\n        if isinstance(r, RootOf):\n            r = r.eval_rational(S.One / 10 ** (n_digits + 2))\n        xi.append(r.n(n_digits))\n        w.append((r / ((n + 1) ** 2 * p1.subs(x, r) ** 2)).n(n_digits))\n    return (xi, w)",
            "def gauss_laguerre(n, n_digits):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Computes the Gauss-Laguerre quadrature [1]_ points and weights.\\n\\n    Explanation\\n    ===========\\n\\n    The Gauss-Laguerre quadrature approximates the integral:\\n\\n    .. math::\\n        \\\\int_0^{\\\\infty} e^{-x} f(x)\\\\,dx \\\\approx \\\\sum_{i=1}^n w_i f(x_i)\\n\\n\\n    The nodes `x_i` of an order `n` quadrature rule are the roots of `L_n`\\n    and the weights `w_i` are given by:\\n\\n    .. math::\\n        w_i = \\\\frac{x_i}{(n+1)^2 \\\\left(L_{n+1}(x_i)\\\\right)^2}\\n\\n    Parameters\\n    ==========\\n\\n    n :\\n        The order of quadrature.\\n    n_digits :\\n        Number of significant digits of the points and weights to return.\\n\\n    Returns\\n    =======\\n\\n    (x, w) : The ``x`` and ``w`` are lists of points and weights as Floats.\\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\\n             tuple of lists.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.integrals.quadrature import gauss_laguerre\\n    >>> x, w = gauss_laguerre(3, 5)\\n    >>> x\\n    [0.41577, 2.2943, 6.2899]\\n    >>> w\\n    [0.71109, 0.27852, 0.010389]\\n    >>> x, w = gauss_laguerre(6, 5)\\n    >>> x\\n    [0.22285, 1.1889, 2.9927, 5.7751, 9.8375, 15.983]\\n    >>> w\\n    [0.45896, 0.417, 0.11337, 0.010399, 0.00026102, 8.9855e-7]\\n\\n    See Also\\n    ========\\n\\n    gauss_legendre, gauss_gen_laguerre, gauss_hermite, gauss_chebyshev_t, gauss_chebyshev_u, gauss_jacobi, gauss_lobatto\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Gauss%E2%80%93Laguerre_quadrature\\n    .. [2] https://people.sc.fsu.edu/~jburkardt/cpp_src/laguerre_rule/laguerre_rule.html\\n    '\n    x = Dummy('x')\n    p = laguerre_poly(n, x, polys=True)\n    p1 = laguerre_poly(n + 1, x, polys=True)\n    xi = []\n    w = []\n    for r in p.real_roots():\n        if isinstance(r, RootOf):\n            r = r.eval_rational(S.One / 10 ** (n_digits + 2))\n        xi.append(r.n(n_digits))\n        w.append((r / ((n + 1) ** 2 * p1.subs(x, r) ** 2)).n(n_digits))\n    return (xi, w)",
            "def gauss_laguerre(n, n_digits):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Computes the Gauss-Laguerre quadrature [1]_ points and weights.\\n\\n    Explanation\\n    ===========\\n\\n    The Gauss-Laguerre quadrature approximates the integral:\\n\\n    .. math::\\n        \\\\int_0^{\\\\infty} e^{-x} f(x)\\\\,dx \\\\approx \\\\sum_{i=1}^n w_i f(x_i)\\n\\n\\n    The nodes `x_i` of an order `n` quadrature rule are the roots of `L_n`\\n    and the weights `w_i` are given by:\\n\\n    .. math::\\n        w_i = \\\\frac{x_i}{(n+1)^2 \\\\left(L_{n+1}(x_i)\\\\right)^2}\\n\\n    Parameters\\n    ==========\\n\\n    n :\\n        The order of quadrature.\\n    n_digits :\\n        Number of significant digits of the points and weights to return.\\n\\n    Returns\\n    =======\\n\\n    (x, w) : The ``x`` and ``w`` are lists of points and weights as Floats.\\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\\n             tuple of lists.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.integrals.quadrature import gauss_laguerre\\n    >>> x, w = gauss_laguerre(3, 5)\\n    >>> x\\n    [0.41577, 2.2943, 6.2899]\\n    >>> w\\n    [0.71109, 0.27852, 0.010389]\\n    >>> x, w = gauss_laguerre(6, 5)\\n    >>> x\\n    [0.22285, 1.1889, 2.9927, 5.7751, 9.8375, 15.983]\\n    >>> w\\n    [0.45896, 0.417, 0.11337, 0.010399, 0.00026102, 8.9855e-7]\\n\\n    See Also\\n    ========\\n\\n    gauss_legendre, gauss_gen_laguerre, gauss_hermite, gauss_chebyshev_t, gauss_chebyshev_u, gauss_jacobi, gauss_lobatto\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Gauss%E2%80%93Laguerre_quadrature\\n    .. [2] https://people.sc.fsu.edu/~jburkardt/cpp_src/laguerre_rule/laguerre_rule.html\\n    '\n    x = Dummy('x')\n    p = laguerre_poly(n, x, polys=True)\n    p1 = laguerre_poly(n + 1, x, polys=True)\n    xi = []\n    w = []\n    for r in p.real_roots():\n        if isinstance(r, RootOf):\n            r = r.eval_rational(S.One / 10 ** (n_digits + 2))\n        xi.append(r.n(n_digits))\n        w.append((r / ((n + 1) ** 2 * p1.subs(x, r) ** 2)).n(n_digits))\n    return (xi, w)"
        ]
    },
    {
        "func_name": "gauss_hermite",
        "original": "def gauss_hermite(n, n_digits):\n    \"\"\"\n    Computes the Gauss-Hermite quadrature [1]_ points and weights.\n\n    Explanation\n    ===========\n\n    The Gauss-Hermite quadrature approximates the integral:\n\n    .. math::\n        \\\\int_{-\\\\infty}^{\\\\infty} e^{-x^2} f(x)\\\\,dx \\\\approx\n            \\\\sum_{i=1}^n w_i f(x_i)\n\n    The nodes `x_i` of an order `n` quadrature rule are the roots of `H_n`\n    and the weights `w_i` are given by:\n\n    .. math::\n        w_i = \\\\frac{2^{n-1} n! \\\\sqrt{\\\\pi}}{n^2 \\\\left(H_{n-1}(x_i)\\\\right)^2}\n\n    Parameters\n    ==========\n\n    n :\n        The order of quadrature.\n    n_digits :\n        Number of significant digits of the points and weights to return.\n\n    Returns\n    =======\n\n    (x, w) : The ``x`` and ``w`` are lists of points and weights as Floats.\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\n             tuple of lists.\n\n    Examples\n    ========\n\n    >>> from sympy.integrals.quadrature import gauss_hermite\n    >>> x, w = gauss_hermite(3, 5)\n    >>> x\n    [-1.2247, 0, 1.2247]\n    >>> w\n    [0.29541, 1.1816, 0.29541]\n\n    >>> x, w = gauss_hermite(6, 5)\n    >>> x\n    [-2.3506, -1.3358, -0.43608, 0.43608, 1.3358, 2.3506]\n    >>> w\n    [0.00453, 0.15707, 0.72463, 0.72463, 0.15707, 0.00453]\n\n    See Also\n    ========\n\n    gauss_legendre, gauss_laguerre, gauss_gen_laguerre, gauss_chebyshev_t, gauss_chebyshev_u, gauss_jacobi, gauss_lobatto\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Gauss-Hermite_Quadrature\n    .. [2] https://people.sc.fsu.edu/~jburkardt/cpp_src/hermite_rule/hermite_rule.html\n    .. [3] https://people.sc.fsu.edu/~jburkardt/cpp_src/gen_hermite_rule/gen_hermite_rule.html\n    \"\"\"\n    x = Dummy('x')\n    p = hermite_poly(n, x, polys=True)\n    p1 = hermite_poly(n - 1, x, polys=True)\n    xi = []\n    w = []\n    for r in p.real_roots():\n        if isinstance(r, RootOf):\n            r = r.eval_rational(S.One / 10 ** (n_digits + 2))\n        xi.append(r.n(n_digits))\n        w.append((2 ** (n - 1) * factorial(n) * sqrt(pi) / (n ** 2 * p1.subs(x, r) ** 2)).n(n_digits))\n    return (xi, w)",
        "mutated": [
            "def gauss_hermite(n, n_digits):\n    if False:\n        i = 10\n    '\\n    Computes the Gauss-Hermite quadrature [1]_ points and weights.\\n\\n    Explanation\\n    ===========\\n\\n    The Gauss-Hermite quadrature approximates the integral:\\n\\n    .. math::\\n        \\\\int_{-\\\\infty}^{\\\\infty} e^{-x^2} f(x)\\\\,dx \\\\approx\\n            \\\\sum_{i=1}^n w_i f(x_i)\\n\\n    The nodes `x_i` of an order `n` quadrature rule are the roots of `H_n`\\n    and the weights `w_i` are given by:\\n\\n    .. math::\\n        w_i = \\\\frac{2^{n-1} n! \\\\sqrt{\\\\pi}}{n^2 \\\\left(H_{n-1}(x_i)\\\\right)^2}\\n\\n    Parameters\\n    ==========\\n\\n    n :\\n        The order of quadrature.\\n    n_digits :\\n        Number of significant digits of the points and weights to return.\\n\\n    Returns\\n    =======\\n\\n    (x, w) : The ``x`` and ``w`` are lists of points and weights as Floats.\\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\\n             tuple of lists.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.integrals.quadrature import gauss_hermite\\n    >>> x, w = gauss_hermite(3, 5)\\n    >>> x\\n    [-1.2247, 0, 1.2247]\\n    >>> w\\n    [0.29541, 1.1816, 0.29541]\\n\\n    >>> x, w = gauss_hermite(6, 5)\\n    >>> x\\n    [-2.3506, -1.3358, -0.43608, 0.43608, 1.3358, 2.3506]\\n    >>> w\\n    [0.00453, 0.15707, 0.72463, 0.72463, 0.15707, 0.00453]\\n\\n    See Also\\n    ========\\n\\n    gauss_legendre, gauss_laguerre, gauss_gen_laguerre, gauss_chebyshev_t, gauss_chebyshev_u, gauss_jacobi, gauss_lobatto\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Gauss-Hermite_Quadrature\\n    .. [2] https://people.sc.fsu.edu/~jburkardt/cpp_src/hermite_rule/hermite_rule.html\\n    .. [3] https://people.sc.fsu.edu/~jburkardt/cpp_src/gen_hermite_rule/gen_hermite_rule.html\\n    '\n    x = Dummy('x')\n    p = hermite_poly(n, x, polys=True)\n    p1 = hermite_poly(n - 1, x, polys=True)\n    xi = []\n    w = []\n    for r in p.real_roots():\n        if isinstance(r, RootOf):\n            r = r.eval_rational(S.One / 10 ** (n_digits + 2))\n        xi.append(r.n(n_digits))\n        w.append((2 ** (n - 1) * factorial(n) * sqrt(pi) / (n ** 2 * p1.subs(x, r) ** 2)).n(n_digits))\n    return (xi, w)",
            "def gauss_hermite(n, n_digits):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Computes the Gauss-Hermite quadrature [1]_ points and weights.\\n\\n    Explanation\\n    ===========\\n\\n    The Gauss-Hermite quadrature approximates the integral:\\n\\n    .. math::\\n        \\\\int_{-\\\\infty}^{\\\\infty} e^{-x^2} f(x)\\\\,dx \\\\approx\\n            \\\\sum_{i=1}^n w_i f(x_i)\\n\\n    The nodes `x_i` of an order `n` quadrature rule are the roots of `H_n`\\n    and the weights `w_i` are given by:\\n\\n    .. math::\\n        w_i = \\\\frac{2^{n-1} n! \\\\sqrt{\\\\pi}}{n^2 \\\\left(H_{n-1}(x_i)\\\\right)^2}\\n\\n    Parameters\\n    ==========\\n\\n    n :\\n        The order of quadrature.\\n    n_digits :\\n        Number of significant digits of the points and weights to return.\\n\\n    Returns\\n    =======\\n\\n    (x, w) : The ``x`` and ``w`` are lists of points and weights as Floats.\\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\\n             tuple of lists.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.integrals.quadrature import gauss_hermite\\n    >>> x, w = gauss_hermite(3, 5)\\n    >>> x\\n    [-1.2247, 0, 1.2247]\\n    >>> w\\n    [0.29541, 1.1816, 0.29541]\\n\\n    >>> x, w = gauss_hermite(6, 5)\\n    >>> x\\n    [-2.3506, -1.3358, -0.43608, 0.43608, 1.3358, 2.3506]\\n    >>> w\\n    [0.00453, 0.15707, 0.72463, 0.72463, 0.15707, 0.00453]\\n\\n    See Also\\n    ========\\n\\n    gauss_legendre, gauss_laguerre, gauss_gen_laguerre, gauss_chebyshev_t, gauss_chebyshev_u, gauss_jacobi, gauss_lobatto\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Gauss-Hermite_Quadrature\\n    .. [2] https://people.sc.fsu.edu/~jburkardt/cpp_src/hermite_rule/hermite_rule.html\\n    .. [3] https://people.sc.fsu.edu/~jburkardt/cpp_src/gen_hermite_rule/gen_hermite_rule.html\\n    '\n    x = Dummy('x')\n    p = hermite_poly(n, x, polys=True)\n    p1 = hermite_poly(n - 1, x, polys=True)\n    xi = []\n    w = []\n    for r in p.real_roots():\n        if isinstance(r, RootOf):\n            r = r.eval_rational(S.One / 10 ** (n_digits + 2))\n        xi.append(r.n(n_digits))\n        w.append((2 ** (n - 1) * factorial(n) * sqrt(pi) / (n ** 2 * p1.subs(x, r) ** 2)).n(n_digits))\n    return (xi, w)",
            "def gauss_hermite(n, n_digits):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Computes the Gauss-Hermite quadrature [1]_ points and weights.\\n\\n    Explanation\\n    ===========\\n\\n    The Gauss-Hermite quadrature approximates the integral:\\n\\n    .. math::\\n        \\\\int_{-\\\\infty}^{\\\\infty} e^{-x^2} f(x)\\\\,dx \\\\approx\\n            \\\\sum_{i=1}^n w_i f(x_i)\\n\\n    The nodes `x_i` of an order `n` quadrature rule are the roots of `H_n`\\n    and the weights `w_i` are given by:\\n\\n    .. math::\\n        w_i = \\\\frac{2^{n-1} n! \\\\sqrt{\\\\pi}}{n^2 \\\\left(H_{n-1}(x_i)\\\\right)^2}\\n\\n    Parameters\\n    ==========\\n\\n    n :\\n        The order of quadrature.\\n    n_digits :\\n        Number of significant digits of the points and weights to return.\\n\\n    Returns\\n    =======\\n\\n    (x, w) : The ``x`` and ``w`` are lists of points and weights as Floats.\\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\\n             tuple of lists.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.integrals.quadrature import gauss_hermite\\n    >>> x, w = gauss_hermite(3, 5)\\n    >>> x\\n    [-1.2247, 0, 1.2247]\\n    >>> w\\n    [0.29541, 1.1816, 0.29541]\\n\\n    >>> x, w = gauss_hermite(6, 5)\\n    >>> x\\n    [-2.3506, -1.3358, -0.43608, 0.43608, 1.3358, 2.3506]\\n    >>> w\\n    [0.00453, 0.15707, 0.72463, 0.72463, 0.15707, 0.00453]\\n\\n    See Also\\n    ========\\n\\n    gauss_legendre, gauss_laguerre, gauss_gen_laguerre, gauss_chebyshev_t, gauss_chebyshev_u, gauss_jacobi, gauss_lobatto\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Gauss-Hermite_Quadrature\\n    .. [2] https://people.sc.fsu.edu/~jburkardt/cpp_src/hermite_rule/hermite_rule.html\\n    .. [3] https://people.sc.fsu.edu/~jburkardt/cpp_src/gen_hermite_rule/gen_hermite_rule.html\\n    '\n    x = Dummy('x')\n    p = hermite_poly(n, x, polys=True)\n    p1 = hermite_poly(n - 1, x, polys=True)\n    xi = []\n    w = []\n    for r in p.real_roots():\n        if isinstance(r, RootOf):\n            r = r.eval_rational(S.One / 10 ** (n_digits + 2))\n        xi.append(r.n(n_digits))\n        w.append((2 ** (n - 1) * factorial(n) * sqrt(pi) / (n ** 2 * p1.subs(x, r) ** 2)).n(n_digits))\n    return (xi, w)",
            "def gauss_hermite(n, n_digits):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Computes the Gauss-Hermite quadrature [1]_ points and weights.\\n\\n    Explanation\\n    ===========\\n\\n    The Gauss-Hermite quadrature approximates the integral:\\n\\n    .. math::\\n        \\\\int_{-\\\\infty}^{\\\\infty} e^{-x^2} f(x)\\\\,dx \\\\approx\\n            \\\\sum_{i=1}^n w_i f(x_i)\\n\\n    The nodes `x_i` of an order `n` quadrature rule are the roots of `H_n`\\n    and the weights `w_i` are given by:\\n\\n    .. math::\\n        w_i = \\\\frac{2^{n-1} n! \\\\sqrt{\\\\pi}}{n^2 \\\\left(H_{n-1}(x_i)\\\\right)^2}\\n\\n    Parameters\\n    ==========\\n\\n    n :\\n        The order of quadrature.\\n    n_digits :\\n        Number of significant digits of the points and weights to return.\\n\\n    Returns\\n    =======\\n\\n    (x, w) : The ``x`` and ``w`` are lists of points and weights as Floats.\\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\\n             tuple of lists.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.integrals.quadrature import gauss_hermite\\n    >>> x, w = gauss_hermite(3, 5)\\n    >>> x\\n    [-1.2247, 0, 1.2247]\\n    >>> w\\n    [0.29541, 1.1816, 0.29541]\\n\\n    >>> x, w = gauss_hermite(6, 5)\\n    >>> x\\n    [-2.3506, -1.3358, -0.43608, 0.43608, 1.3358, 2.3506]\\n    >>> w\\n    [0.00453, 0.15707, 0.72463, 0.72463, 0.15707, 0.00453]\\n\\n    See Also\\n    ========\\n\\n    gauss_legendre, gauss_laguerre, gauss_gen_laguerre, gauss_chebyshev_t, gauss_chebyshev_u, gauss_jacobi, gauss_lobatto\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Gauss-Hermite_Quadrature\\n    .. [2] https://people.sc.fsu.edu/~jburkardt/cpp_src/hermite_rule/hermite_rule.html\\n    .. [3] https://people.sc.fsu.edu/~jburkardt/cpp_src/gen_hermite_rule/gen_hermite_rule.html\\n    '\n    x = Dummy('x')\n    p = hermite_poly(n, x, polys=True)\n    p1 = hermite_poly(n - 1, x, polys=True)\n    xi = []\n    w = []\n    for r in p.real_roots():\n        if isinstance(r, RootOf):\n            r = r.eval_rational(S.One / 10 ** (n_digits + 2))\n        xi.append(r.n(n_digits))\n        w.append((2 ** (n - 1) * factorial(n) * sqrt(pi) / (n ** 2 * p1.subs(x, r) ** 2)).n(n_digits))\n    return (xi, w)",
            "def gauss_hermite(n, n_digits):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Computes the Gauss-Hermite quadrature [1]_ points and weights.\\n\\n    Explanation\\n    ===========\\n\\n    The Gauss-Hermite quadrature approximates the integral:\\n\\n    .. math::\\n        \\\\int_{-\\\\infty}^{\\\\infty} e^{-x^2} f(x)\\\\,dx \\\\approx\\n            \\\\sum_{i=1}^n w_i f(x_i)\\n\\n    The nodes `x_i` of an order `n` quadrature rule are the roots of `H_n`\\n    and the weights `w_i` are given by:\\n\\n    .. math::\\n        w_i = \\\\frac{2^{n-1} n! \\\\sqrt{\\\\pi}}{n^2 \\\\left(H_{n-1}(x_i)\\\\right)^2}\\n\\n    Parameters\\n    ==========\\n\\n    n :\\n        The order of quadrature.\\n    n_digits :\\n        Number of significant digits of the points and weights to return.\\n\\n    Returns\\n    =======\\n\\n    (x, w) : The ``x`` and ``w`` are lists of points and weights as Floats.\\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\\n             tuple of lists.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.integrals.quadrature import gauss_hermite\\n    >>> x, w = gauss_hermite(3, 5)\\n    >>> x\\n    [-1.2247, 0, 1.2247]\\n    >>> w\\n    [0.29541, 1.1816, 0.29541]\\n\\n    >>> x, w = gauss_hermite(6, 5)\\n    >>> x\\n    [-2.3506, -1.3358, -0.43608, 0.43608, 1.3358, 2.3506]\\n    >>> w\\n    [0.00453, 0.15707, 0.72463, 0.72463, 0.15707, 0.00453]\\n\\n    See Also\\n    ========\\n\\n    gauss_legendre, gauss_laguerre, gauss_gen_laguerre, gauss_chebyshev_t, gauss_chebyshev_u, gauss_jacobi, gauss_lobatto\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Gauss-Hermite_Quadrature\\n    .. [2] https://people.sc.fsu.edu/~jburkardt/cpp_src/hermite_rule/hermite_rule.html\\n    .. [3] https://people.sc.fsu.edu/~jburkardt/cpp_src/gen_hermite_rule/gen_hermite_rule.html\\n    '\n    x = Dummy('x')\n    p = hermite_poly(n, x, polys=True)\n    p1 = hermite_poly(n - 1, x, polys=True)\n    xi = []\n    w = []\n    for r in p.real_roots():\n        if isinstance(r, RootOf):\n            r = r.eval_rational(S.One / 10 ** (n_digits + 2))\n        xi.append(r.n(n_digits))\n        w.append((2 ** (n - 1) * factorial(n) * sqrt(pi) / (n ** 2 * p1.subs(x, r) ** 2)).n(n_digits))\n    return (xi, w)"
        ]
    },
    {
        "func_name": "gauss_gen_laguerre",
        "original": "def gauss_gen_laguerre(n, alpha, n_digits):\n    \"\"\"\n    Computes the generalized Gauss-Laguerre quadrature [1]_ points and weights.\n\n    Explanation\n    ===========\n\n    The generalized Gauss-Laguerre quadrature approximates the integral:\n\n    .. math::\n        \\\\int_{0}^\\\\infty x^{\\\\alpha} e^{-x} f(x)\\\\,dx \\\\approx\n            \\\\sum_{i=1}^n w_i f(x_i)\n\n    The nodes `x_i` of an order `n` quadrature rule are the roots of\n    `L^{\\\\alpha}_n` and the weights `w_i` are given by:\n\n    .. math::\n        w_i = \\\\frac{\\\\Gamma(\\\\alpha+n)}\n                {n \\\\Gamma(n) L^{\\\\alpha}_{n-1}(x_i) L^{\\\\alpha+1}_{n-1}(x_i)}\n\n    Parameters\n    ==========\n\n    n :\n        The order of quadrature.\n\n    alpha :\n        The exponent of the singularity, `\\\\alpha > -1`.\n\n    n_digits :\n        Number of significant digits of the points and weights to return.\n\n    Returns\n    =======\n\n    (x, w) : the ``x`` and ``w`` are lists of points and weights as Floats.\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\n             tuple of lists.\n\n    Examples\n    ========\n\n    >>> from sympy import S\n    >>> from sympy.integrals.quadrature import gauss_gen_laguerre\n    >>> x, w = gauss_gen_laguerre(3, -S.Half, 5)\n    >>> x\n    [0.19016, 1.7845, 5.5253]\n    >>> w\n    [1.4493, 0.31413, 0.00906]\n\n    >>> x, w = gauss_gen_laguerre(4, 3*S.Half, 5)\n    >>> x\n    [0.97851, 2.9904, 6.3193, 11.712]\n    >>> w\n    [0.53087, 0.67721, 0.11895, 0.0023152]\n\n    See Also\n    ========\n\n    gauss_legendre, gauss_laguerre, gauss_hermite, gauss_chebyshev_t, gauss_chebyshev_u, gauss_jacobi, gauss_lobatto\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Gauss%E2%80%93Laguerre_quadrature\n    .. [2] https://people.sc.fsu.edu/~jburkardt/cpp_src/gen_laguerre_rule/gen_laguerre_rule.html\n    \"\"\"\n    x = Dummy('x')\n    p = laguerre_poly(n, x, alpha=alpha, polys=True)\n    p1 = laguerre_poly(n - 1, x, alpha=alpha, polys=True)\n    p2 = laguerre_poly(n - 1, x, alpha=alpha + 1, polys=True)\n    xi = []\n    w = []\n    for r in p.real_roots():\n        if isinstance(r, RootOf):\n            r = r.eval_rational(S.One / 10 ** (n_digits + 2))\n        xi.append(r.n(n_digits))\n        w.append((gamma(alpha + n) / (n * gamma(n) * p1.subs(x, r) * p2.subs(x, r))).n(n_digits))\n    return (xi, w)",
        "mutated": [
            "def gauss_gen_laguerre(n, alpha, n_digits):\n    if False:\n        i = 10\n    '\\n    Computes the generalized Gauss-Laguerre quadrature [1]_ points and weights.\\n\\n    Explanation\\n    ===========\\n\\n    The generalized Gauss-Laguerre quadrature approximates the integral:\\n\\n    .. math::\\n        \\\\int_{0}^\\\\infty x^{\\\\alpha} e^{-x} f(x)\\\\,dx \\\\approx\\n            \\\\sum_{i=1}^n w_i f(x_i)\\n\\n    The nodes `x_i` of an order `n` quadrature rule are the roots of\\n    `L^{\\\\alpha}_n` and the weights `w_i` are given by:\\n\\n    .. math::\\n        w_i = \\\\frac{\\\\Gamma(\\\\alpha+n)}\\n                {n \\\\Gamma(n) L^{\\\\alpha}_{n-1}(x_i) L^{\\\\alpha+1}_{n-1}(x_i)}\\n\\n    Parameters\\n    ==========\\n\\n    n :\\n        The order of quadrature.\\n\\n    alpha :\\n        The exponent of the singularity, `\\\\alpha > -1`.\\n\\n    n_digits :\\n        Number of significant digits of the points and weights to return.\\n\\n    Returns\\n    =======\\n\\n    (x, w) : the ``x`` and ``w`` are lists of points and weights as Floats.\\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\\n             tuple of lists.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import S\\n    >>> from sympy.integrals.quadrature import gauss_gen_laguerre\\n    >>> x, w = gauss_gen_laguerre(3, -S.Half, 5)\\n    >>> x\\n    [0.19016, 1.7845, 5.5253]\\n    >>> w\\n    [1.4493, 0.31413, 0.00906]\\n\\n    >>> x, w = gauss_gen_laguerre(4, 3*S.Half, 5)\\n    >>> x\\n    [0.97851, 2.9904, 6.3193, 11.712]\\n    >>> w\\n    [0.53087, 0.67721, 0.11895, 0.0023152]\\n\\n    See Also\\n    ========\\n\\n    gauss_legendre, gauss_laguerre, gauss_hermite, gauss_chebyshev_t, gauss_chebyshev_u, gauss_jacobi, gauss_lobatto\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Gauss%E2%80%93Laguerre_quadrature\\n    .. [2] https://people.sc.fsu.edu/~jburkardt/cpp_src/gen_laguerre_rule/gen_laguerre_rule.html\\n    '\n    x = Dummy('x')\n    p = laguerre_poly(n, x, alpha=alpha, polys=True)\n    p1 = laguerre_poly(n - 1, x, alpha=alpha, polys=True)\n    p2 = laguerre_poly(n - 1, x, alpha=alpha + 1, polys=True)\n    xi = []\n    w = []\n    for r in p.real_roots():\n        if isinstance(r, RootOf):\n            r = r.eval_rational(S.One / 10 ** (n_digits + 2))\n        xi.append(r.n(n_digits))\n        w.append((gamma(alpha + n) / (n * gamma(n) * p1.subs(x, r) * p2.subs(x, r))).n(n_digits))\n    return (xi, w)",
            "def gauss_gen_laguerre(n, alpha, n_digits):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Computes the generalized Gauss-Laguerre quadrature [1]_ points and weights.\\n\\n    Explanation\\n    ===========\\n\\n    The generalized Gauss-Laguerre quadrature approximates the integral:\\n\\n    .. math::\\n        \\\\int_{0}^\\\\infty x^{\\\\alpha} e^{-x} f(x)\\\\,dx \\\\approx\\n            \\\\sum_{i=1}^n w_i f(x_i)\\n\\n    The nodes `x_i` of an order `n` quadrature rule are the roots of\\n    `L^{\\\\alpha}_n` and the weights `w_i` are given by:\\n\\n    .. math::\\n        w_i = \\\\frac{\\\\Gamma(\\\\alpha+n)}\\n                {n \\\\Gamma(n) L^{\\\\alpha}_{n-1}(x_i) L^{\\\\alpha+1}_{n-1}(x_i)}\\n\\n    Parameters\\n    ==========\\n\\n    n :\\n        The order of quadrature.\\n\\n    alpha :\\n        The exponent of the singularity, `\\\\alpha > -1`.\\n\\n    n_digits :\\n        Number of significant digits of the points and weights to return.\\n\\n    Returns\\n    =======\\n\\n    (x, w) : the ``x`` and ``w`` are lists of points and weights as Floats.\\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\\n             tuple of lists.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import S\\n    >>> from sympy.integrals.quadrature import gauss_gen_laguerre\\n    >>> x, w = gauss_gen_laguerre(3, -S.Half, 5)\\n    >>> x\\n    [0.19016, 1.7845, 5.5253]\\n    >>> w\\n    [1.4493, 0.31413, 0.00906]\\n\\n    >>> x, w = gauss_gen_laguerre(4, 3*S.Half, 5)\\n    >>> x\\n    [0.97851, 2.9904, 6.3193, 11.712]\\n    >>> w\\n    [0.53087, 0.67721, 0.11895, 0.0023152]\\n\\n    See Also\\n    ========\\n\\n    gauss_legendre, gauss_laguerre, gauss_hermite, gauss_chebyshev_t, gauss_chebyshev_u, gauss_jacobi, gauss_lobatto\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Gauss%E2%80%93Laguerre_quadrature\\n    .. [2] https://people.sc.fsu.edu/~jburkardt/cpp_src/gen_laguerre_rule/gen_laguerre_rule.html\\n    '\n    x = Dummy('x')\n    p = laguerre_poly(n, x, alpha=alpha, polys=True)\n    p1 = laguerre_poly(n - 1, x, alpha=alpha, polys=True)\n    p2 = laguerre_poly(n - 1, x, alpha=alpha + 1, polys=True)\n    xi = []\n    w = []\n    for r in p.real_roots():\n        if isinstance(r, RootOf):\n            r = r.eval_rational(S.One / 10 ** (n_digits + 2))\n        xi.append(r.n(n_digits))\n        w.append((gamma(alpha + n) / (n * gamma(n) * p1.subs(x, r) * p2.subs(x, r))).n(n_digits))\n    return (xi, w)",
            "def gauss_gen_laguerre(n, alpha, n_digits):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Computes the generalized Gauss-Laguerre quadrature [1]_ points and weights.\\n\\n    Explanation\\n    ===========\\n\\n    The generalized Gauss-Laguerre quadrature approximates the integral:\\n\\n    .. math::\\n        \\\\int_{0}^\\\\infty x^{\\\\alpha} e^{-x} f(x)\\\\,dx \\\\approx\\n            \\\\sum_{i=1}^n w_i f(x_i)\\n\\n    The nodes `x_i` of an order `n` quadrature rule are the roots of\\n    `L^{\\\\alpha}_n` and the weights `w_i` are given by:\\n\\n    .. math::\\n        w_i = \\\\frac{\\\\Gamma(\\\\alpha+n)}\\n                {n \\\\Gamma(n) L^{\\\\alpha}_{n-1}(x_i) L^{\\\\alpha+1}_{n-1}(x_i)}\\n\\n    Parameters\\n    ==========\\n\\n    n :\\n        The order of quadrature.\\n\\n    alpha :\\n        The exponent of the singularity, `\\\\alpha > -1`.\\n\\n    n_digits :\\n        Number of significant digits of the points and weights to return.\\n\\n    Returns\\n    =======\\n\\n    (x, w) : the ``x`` and ``w`` are lists of points and weights as Floats.\\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\\n             tuple of lists.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import S\\n    >>> from sympy.integrals.quadrature import gauss_gen_laguerre\\n    >>> x, w = gauss_gen_laguerre(3, -S.Half, 5)\\n    >>> x\\n    [0.19016, 1.7845, 5.5253]\\n    >>> w\\n    [1.4493, 0.31413, 0.00906]\\n\\n    >>> x, w = gauss_gen_laguerre(4, 3*S.Half, 5)\\n    >>> x\\n    [0.97851, 2.9904, 6.3193, 11.712]\\n    >>> w\\n    [0.53087, 0.67721, 0.11895, 0.0023152]\\n\\n    See Also\\n    ========\\n\\n    gauss_legendre, gauss_laguerre, gauss_hermite, gauss_chebyshev_t, gauss_chebyshev_u, gauss_jacobi, gauss_lobatto\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Gauss%E2%80%93Laguerre_quadrature\\n    .. [2] https://people.sc.fsu.edu/~jburkardt/cpp_src/gen_laguerre_rule/gen_laguerre_rule.html\\n    '\n    x = Dummy('x')\n    p = laguerre_poly(n, x, alpha=alpha, polys=True)\n    p1 = laguerre_poly(n - 1, x, alpha=alpha, polys=True)\n    p2 = laguerre_poly(n - 1, x, alpha=alpha + 1, polys=True)\n    xi = []\n    w = []\n    for r in p.real_roots():\n        if isinstance(r, RootOf):\n            r = r.eval_rational(S.One / 10 ** (n_digits + 2))\n        xi.append(r.n(n_digits))\n        w.append((gamma(alpha + n) / (n * gamma(n) * p1.subs(x, r) * p2.subs(x, r))).n(n_digits))\n    return (xi, w)",
            "def gauss_gen_laguerre(n, alpha, n_digits):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Computes the generalized Gauss-Laguerre quadrature [1]_ points and weights.\\n\\n    Explanation\\n    ===========\\n\\n    The generalized Gauss-Laguerre quadrature approximates the integral:\\n\\n    .. math::\\n        \\\\int_{0}^\\\\infty x^{\\\\alpha} e^{-x} f(x)\\\\,dx \\\\approx\\n            \\\\sum_{i=1}^n w_i f(x_i)\\n\\n    The nodes `x_i` of an order `n` quadrature rule are the roots of\\n    `L^{\\\\alpha}_n` and the weights `w_i` are given by:\\n\\n    .. math::\\n        w_i = \\\\frac{\\\\Gamma(\\\\alpha+n)}\\n                {n \\\\Gamma(n) L^{\\\\alpha}_{n-1}(x_i) L^{\\\\alpha+1}_{n-1}(x_i)}\\n\\n    Parameters\\n    ==========\\n\\n    n :\\n        The order of quadrature.\\n\\n    alpha :\\n        The exponent of the singularity, `\\\\alpha > -1`.\\n\\n    n_digits :\\n        Number of significant digits of the points and weights to return.\\n\\n    Returns\\n    =======\\n\\n    (x, w) : the ``x`` and ``w`` are lists of points and weights as Floats.\\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\\n             tuple of lists.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import S\\n    >>> from sympy.integrals.quadrature import gauss_gen_laguerre\\n    >>> x, w = gauss_gen_laguerre(3, -S.Half, 5)\\n    >>> x\\n    [0.19016, 1.7845, 5.5253]\\n    >>> w\\n    [1.4493, 0.31413, 0.00906]\\n\\n    >>> x, w = gauss_gen_laguerre(4, 3*S.Half, 5)\\n    >>> x\\n    [0.97851, 2.9904, 6.3193, 11.712]\\n    >>> w\\n    [0.53087, 0.67721, 0.11895, 0.0023152]\\n\\n    See Also\\n    ========\\n\\n    gauss_legendre, gauss_laguerre, gauss_hermite, gauss_chebyshev_t, gauss_chebyshev_u, gauss_jacobi, gauss_lobatto\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Gauss%E2%80%93Laguerre_quadrature\\n    .. [2] https://people.sc.fsu.edu/~jburkardt/cpp_src/gen_laguerre_rule/gen_laguerre_rule.html\\n    '\n    x = Dummy('x')\n    p = laguerre_poly(n, x, alpha=alpha, polys=True)\n    p1 = laguerre_poly(n - 1, x, alpha=alpha, polys=True)\n    p2 = laguerre_poly(n - 1, x, alpha=alpha + 1, polys=True)\n    xi = []\n    w = []\n    for r in p.real_roots():\n        if isinstance(r, RootOf):\n            r = r.eval_rational(S.One / 10 ** (n_digits + 2))\n        xi.append(r.n(n_digits))\n        w.append((gamma(alpha + n) / (n * gamma(n) * p1.subs(x, r) * p2.subs(x, r))).n(n_digits))\n    return (xi, w)",
            "def gauss_gen_laguerre(n, alpha, n_digits):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Computes the generalized Gauss-Laguerre quadrature [1]_ points and weights.\\n\\n    Explanation\\n    ===========\\n\\n    The generalized Gauss-Laguerre quadrature approximates the integral:\\n\\n    .. math::\\n        \\\\int_{0}^\\\\infty x^{\\\\alpha} e^{-x} f(x)\\\\,dx \\\\approx\\n            \\\\sum_{i=1}^n w_i f(x_i)\\n\\n    The nodes `x_i` of an order `n` quadrature rule are the roots of\\n    `L^{\\\\alpha}_n` and the weights `w_i` are given by:\\n\\n    .. math::\\n        w_i = \\\\frac{\\\\Gamma(\\\\alpha+n)}\\n                {n \\\\Gamma(n) L^{\\\\alpha}_{n-1}(x_i) L^{\\\\alpha+1}_{n-1}(x_i)}\\n\\n    Parameters\\n    ==========\\n\\n    n :\\n        The order of quadrature.\\n\\n    alpha :\\n        The exponent of the singularity, `\\\\alpha > -1`.\\n\\n    n_digits :\\n        Number of significant digits of the points and weights to return.\\n\\n    Returns\\n    =======\\n\\n    (x, w) : the ``x`` and ``w`` are lists of points and weights as Floats.\\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\\n             tuple of lists.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import S\\n    >>> from sympy.integrals.quadrature import gauss_gen_laguerre\\n    >>> x, w = gauss_gen_laguerre(3, -S.Half, 5)\\n    >>> x\\n    [0.19016, 1.7845, 5.5253]\\n    >>> w\\n    [1.4493, 0.31413, 0.00906]\\n\\n    >>> x, w = gauss_gen_laguerre(4, 3*S.Half, 5)\\n    >>> x\\n    [0.97851, 2.9904, 6.3193, 11.712]\\n    >>> w\\n    [0.53087, 0.67721, 0.11895, 0.0023152]\\n\\n    See Also\\n    ========\\n\\n    gauss_legendre, gauss_laguerre, gauss_hermite, gauss_chebyshev_t, gauss_chebyshev_u, gauss_jacobi, gauss_lobatto\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Gauss%E2%80%93Laguerre_quadrature\\n    .. [2] https://people.sc.fsu.edu/~jburkardt/cpp_src/gen_laguerre_rule/gen_laguerre_rule.html\\n    '\n    x = Dummy('x')\n    p = laguerre_poly(n, x, alpha=alpha, polys=True)\n    p1 = laguerre_poly(n - 1, x, alpha=alpha, polys=True)\n    p2 = laguerre_poly(n - 1, x, alpha=alpha + 1, polys=True)\n    xi = []\n    w = []\n    for r in p.real_roots():\n        if isinstance(r, RootOf):\n            r = r.eval_rational(S.One / 10 ** (n_digits + 2))\n        xi.append(r.n(n_digits))\n        w.append((gamma(alpha + n) / (n * gamma(n) * p1.subs(x, r) * p2.subs(x, r))).n(n_digits))\n    return (xi, w)"
        ]
    },
    {
        "func_name": "gauss_chebyshev_t",
        "original": "def gauss_chebyshev_t(n, n_digits):\n    \"\"\"\n    Computes the Gauss-Chebyshev quadrature [1]_ points and weights of\n    the first kind.\n\n    Explanation\n    ===========\n\n    The Gauss-Chebyshev quadrature of the first kind approximates the integral:\n\n    .. math::\n        \\\\int_{-1}^{1} \\\\frac{1}{\\\\sqrt{1-x^2}} f(x)\\\\,dx \\\\approx\n            \\\\sum_{i=1}^n w_i f(x_i)\n\n    The nodes `x_i` of an order `n` quadrature rule are the roots of `T_n`\n    and the weights `w_i` are given by:\n\n    .. math::\n        w_i = \\\\frac{\\\\pi}{n}\n\n    Parameters\n    ==========\n\n    n :\n        The order of quadrature.\n\n    n_digits :\n        Number of significant digits of the points and weights to return.\n\n    Returns\n    =======\n\n    (x, w) : the ``x`` and ``w`` are lists of points and weights as Floats.\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\n             tuple of lists.\n\n    Examples\n    ========\n\n    >>> from sympy.integrals.quadrature import gauss_chebyshev_t\n    >>> x, w = gauss_chebyshev_t(3, 5)\n    >>> x\n    [0.86602, 0, -0.86602]\n    >>> w\n    [1.0472, 1.0472, 1.0472]\n\n    >>> x, w = gauss_chebyshev_t(6, 5)\n    >>> x\n    [0.96593, 0.70711, 0.25882, -0.25882, -0.70711, -0.96593]\n    >>> w\n    [0.5236, 0.5236, 0.5236, 0.5236, 0.5236, 0.5236]\n\n    See Also\n    ========\n\n    gauss_legendre, gauss_laguerre, gauss_hermite, gauss_gen_laguerre, gauss_chebyshev_u, gauss_jacobi, gauss_lobatto\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Chebyshev%E2%80%93Gauss_quadrature\n    .. [2] https://people.sc.fsu.edu/~jburkardt/cpp_src/chebyshev1_rule/chebyshev1_rule.html\n    \"\"\"\n    xi = []\n    w = []\n    for i in range(1, n + 1):\n        xi.append(cos((2 * i - S.One) / (2 * n) * S.Pi).n(n_digits))\n        w.append((S.Pi / n).n(n_digits))\n    return (xi, w)",
        "mutated": [
            "def gauss_chebyshev_t(n, n_digits):\n    if False:\n        i = 10\n    '\\n    Computes the Gauss-Chebyshev quadrature [1]_ points and weights of\\n    the first kind.\\n\\n    Explanation\\n    ===========\\n\\n    The Gauss-Chebyshev quadrature of the first kind approximates the integral:\\n\\n    .. math::\\n        \\\\int_{-1}^{1} \\\\frac{1}{\\\\sqrt{1-x^2}} f(x)\\\\,dx \\\\approx\\n            \\\\sum_{i=1}^n w_i f(x_i)\\n\\n    The nodes `x_i` of an order `n` quadrature rule are the roots of `T_n`\\n    and the weights `w_i` are given by:\\n\\n    .. math::\\n        w_i = \\\\frac{\\\\pi}{n}\\n\\n    Parameters\\n    ==========\\n\\n    n :\\n        The order of quadrature.\\n\\n    n_digits :\\n        Number of significant digits of the points and weights to return.\\n\\n    Returns\\n    =======\\n\\n    (x, w) : the ``x`` and ``w`` are lists of points and weights as Floats.\\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\\n             tuple of lists.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.integrals.quadrature import gauss_chebyshev_t\\n    >>> x, w = gauss_chebyshev_t(3, 5)\\n    >>> x\\n    [0.86602, 0, -0.86602]\\n    >>> w\\n    [1.0472, 1.0472, 1.0472]\\n\\n    >>> x, w = gauss_chebyshev_t(6, 5)\\n    >>> x\\n    [0.96593, 0.70711, 0.25882, -0.25882, -0.70711, -0.96593]\\n    >>> w\\n    [0.5236, 0.5236, 0.5236, 0.5236, 0.5236, 0.5236]\\n\\n    See Also\\n    ========\\n\\n    gauss_legendre, gauss_laguerre, gauss_hermite, gauss_gen_laguerre, gauss_chebyshev_u, gauss_jacobi, gauss_lobatto\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Chebyshev%E2%80%93Gauss_quadrature\\n    .. [2] https://people.sc.fsu.edu/~jburkardt/cpp_src/chebyshev1_rule/chebyshev1_rule.html\\n    '\n    xi = []\n    w = []\n    for i in range(1, n + 1):\n        xi.append(cos((2 * i - S.One) / (2 * n) * S.Pi).n(n_digits))\n        w.append((S.Pi / n).n(n_digits))\n    return (xi, w)",
            "def gauss_chebyshev_t(n, n_digits):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Computes the Gauss-Chebyshev quadrature [1]_ points and weights of\\n    the first kind.\\n\\n    Explanation\\n    ===========\\n\\n    The Gauss-Chebyshev quadrature of the first kind approximates the integral:\\n\\n    .. math::\\n        \\\\int_{-1}^{1} \\\\frac{1}{\\\\sqrt{1-x^2}} f(x)\\\\,dx \\\\approx\\n            \\\\sum_{i=1}^n w_i f(x_i)\\n\\n    The nodes `x_i` of an order `n` quadrature rule are the roots of `T_n`\\n    and the weights `w_i` are given by:\\n\\n    .. math::\\n        w_i = \\\\frac{\\\\pi}{n}\\n\\n    Parameters\\n    ==========\\n\\n    n :\\n        The order of quadrature.\\n\\n    n_digits :\\n        Number of significant digits of the points and weights to return.\\n\\n    Returns\\n    =======\\n\\n    (x, w) : the ``x`` and ``w`` are lists of points and weights as Floats.\\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\\n             tuple of lists.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.integrals.quadrature import gauss_chebyshev_t\\n    >>> x, w = gauss_chebyshev_t(3, 5)\\n    >>> x\\n    [0.86602, 0, -0.86602]\\n    >>> w\\n    [1.0472, 1.0472, 1.0472]\\n\\n    >>> x, w = gauss_chebyshev_t(6, 5)\\n    >>> x\\n    [0.96593, 0.70711, 0.25882, -0.25882, -0.70711, -0.96593]\\n    >>> w\\n    [0.5236, 0.5236, 0.5236, 0.5236, 0.5236, 0.5236]\\n\\n    See Also\\n    ========\\n\\n    gauss_legendre, gauss_laguerre, gauss_hermite, gauss_gen_laguerre, gauss_chebyshev_u, gauss_jacobi, gauss_lobatto\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Chebyshev%E2%80%93Gauss_quadrature\\n    .. [2] https://people.sc.fsu.edu/~jburkardt/cpp_src/chebyshev1_rule/chebyshev1_rule.html\\n    '\n    xi = []\n    w = []\n    for i in range(1, n + 1):\n        xi.append(cos((2 * i - S.One) / (2 * n) * S.Pi).n(n_digits))\n        w.append((S.Pi / n).n(n_digits))\n    return (xi, w)",
            "def gauss_chebyshev_t(n, n_digits):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Computes the Gauss-Chebyshev quadrature [1]_ points and weights of\\n    the first kind.\\n\\n    Explanation\\n    ===========\\n\\n    The Gauss-Chebyshev quadrature of the first kind approximates the integral:\\n\\n    .. math::\\n        \\\\int_{-1}^{1} \\\\frac{1}{\\\\sqrt{1-x^2}} f(x)\\\\,dx \\\\approx\\n            \\\\sum_{i=1}^n w_i f(x_i)\\n\\n    The nodes `x_i` of an order `n` quadrature rule are the roots of `T_n`\\n    and the weights `w_i` are given by:\\n\\n    .. math::\\n        w_i = \\\\frac{\\\\pi}{n}\\n\\n    Parameters\\n    ==========\\n\\n    n :\\n        The order of quadrature.\\n\\n    n_digits :\\n        Number of significant digits of the points and weights to return.\\n\\n    Returns\\n    =======\\n\\n    (x, w) : the ``x`` and ``w`` are lists of points and weights as Floats.\\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\\n             tuple of lists.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.integrals.quadrature import gauss_chebyshev_t\\n    >>> x, w = gauss_chebyshev_t(3, 5)\\n    >>> x\\n    [0.86602, 0, -0.86602]\\n    >>> w\\n    [1.0472, 1.0472, 1.0472]\\n\\n    >>> x, w = gauss_chebyshev_t(6, 5)\\n    >>> x\\n    [0.96593, 0.70711, 0.25882, -0.25882, -0.70711, -0.96593]\\n    >>> w\\n    [0.5236, 0.5236, 0.5236, 0.5236, 0.5236, 0.5236]\\n\\n    See Also\\n    ========\\n\\n    gauss_legendre, gauss_laguerre, gauss_hermite, gauss_gen_laguerre, gauss_chebyshev_u, gauss_jacobi, gauss_lobatto\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Chebyshev%E2%80%93Gauss_quadrature\\n    .. [2] https://people.sc.fsu.edu/~jburkardt/cpp_src/chebyshev1_rule/chebyshev1_rule.html\\n    '\n    xi = []\n    w = []\n    for i in range(1, n + 1):\n        xi.append(cos((2 * i - S.One) / (2 * n) * S.Pi).n(n_digits))\n        w.append((S.Pi / n).n(n_digits))\n    return (xi, w)",
            "def gauss_chebyshev_t(n, n_digits):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Computes the Gauss-Chebyshev quadrature [1]_ points and weights of\\n    the first kind.\\n\\n    Explanation\\n    ===========\\n\\n    The Gauss-Chebyshev quadrature of the first kind approximates the integral:\\n\\n    .. math::\\n        \\\\int_{-1}^{1} \\\\frac{1}{\\\\sqrt{1-x^2}} f(x)\\\\,dx \\\\approx\\n            \\\\sum_{i=1}^n w_i f(x_i)\\n\\n    The nodes `x_i` of an order `n` quadrature rule are the roots of `T_n`\\n    and the weights `w_i` are given by:\\n\\n    .. math::\\n        w_i = \\\\frac{\\\\pi}{n}\\n\\n    Parameters\\n    ==========\\n\\n    n :\\n        The order of quadrature.\\n\\n    n_digits :\\n        Number of significant digits of the points and weights to return.\\n\\n    Returns\\n    =======\\n\\n    (x, w) : the ``x`` and ``w`` are lists of points and weights as Floats.\\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\\n             tuple of lists.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.integrals.quadrature import gauss_chebyshev_t\\n    >>> x, w = gauss_chebyshev_t(3, 5)\\n    >>> x\\n    [0.86602, 0, -0.86602]\\n    >>> w\\n    [1.0472, 1.0472, 1.0472]\\n\\n    >>> x, w = gauss_chebyshev_t(6, 5)\\n    >>> x\\n    [0.96593, 0.70711, 0.25882, -0.25882, -0.70711, -0.96593]\\n    >>> w\\n    [0.5236, 0.5236, 0.5236, 0.5236, 0.5236, 0.5236]\\n\\n    See Also\\n    ========\\n\\n    gauss_legendre, gauss_laguerre, gauss_hermite, gauss_gen_laguerre, gauss_chebyshev_u, gauss_jacobi, gauss_lobatto\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Chebyshev%E2%80%93Gauss_quadrature\\n    .. [2] https://people.sc.fsu.edu/~jburkardt/cpp_src/chebyshev1_rule/chebyshev1_rule.html\\n    '\n    xi = []\n    w = []\n    for i in range(1, n + 1):\n        xi.append(cos((2 * i - S.One) / (2 * n) * S.Pi).n(n_digits))\n        w.append((S.Pi / n).n(n_digits))\n    return (xi, w)",
            "def gauss_chebyshev_t(n, n_digits):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Computes the Gauss-Chebyshev quadrature [1]_ points and weights of\\n    the first kind.\\n\\n    Explanation\\n    ===========\\n\\n    The Gauss-Chebyshev quadrature of the first kind approximates the integral:\\n\\n    .. math::\\n        \\\\int_{-1}^{1} \\\\frac{1}{\\\\sqrt{1-x^2}} f(x)\\\\,dx \\\\approx\\n            \\\\sum_{i=1}^n w_i f(x_i)\\n\\n    The nodes `x_i` of an order `n` quadrature rule are the roots of `T_n`\\n    and the weights `w_i` are given by:\\n\\n    .. math::\\n        w_i = \\\\frac{\\\\pi}{n}\\n\\n    Parameters\\n    ==========\\n\\n    n :\\n        The order of quadrature.\\n\\n    n_digits :\\n        Number of significant digits of the points and weights to return.\\n\\n    Returns\\n    =======\\n\\n    (x, w) : the ``x`` and ``w`` are lists of points and weights as Floats.\\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\\n             tuple of lists.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.integrals.quadrature import gauss_chebyshev_t\\n    >>> x, w = gauss_chebyshev_t(3, 5)\\n    >>> x\\n    [0.86602, 0, -0.86602]\\n    >>> w\\n    [1.0472, 1.0472, 1.0472]\\n\\n    >>> x, w = gauss_chebyshev_t(6, 5)\\n    >>> x\\n    [0.96593, 0.70711, 0.25882, -0.25882, -0.70711, -0.96593]\\n    >>> w\\n    [0.5236, 0.5236, 0.5236, 0.5236, 0.5236, 0.5236]\\n\\n    See Also\\n    ========\\n\\n    gauss_legendre, gauss_laguerre, gauss_hermite, gauss_gen_laguerre, gauss_chebyshev_u, gauss_jacobi, gauss_lobatto\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Chebyshev%E2%80%93Gauss_quadrature\\n    .. [2] https://people.sc.fsu.edu/~jburkardt/cpp_src/chebyshev1_rule/chebyshev1_rule.html\\n    '\n    xi = []\n    w = []\n    for i in range(1, n + 1):\n        xi.append(cos((2 * i - S.One) / (2 * n) * S.Pi).n(n_digits))\n        w.append((S.Pi / n).n(n_digits))\n    return (xi, w)"
        ]
    },
    {
        "func_name": "gauss_chebyshev_u",
        "original": "def gauss_chebyshev_u(n, n_digits):\n    \"\"\"\n    Computes the Gauss-Chebyshev quadrature [1]_ points and weights of\n    the second kind.\n\n    Explanation\n    ===========\n\n    The Gauss-Chebyshev quadrature of the second kind approximates the\n    integral:\n\n    .. math::\n        \\\\int_{-1}^{1} \\\\sqrt{1-x^2} f(x)\\\\,dx \\\\approx \\\\sum_{i=1}^n w_i f(x_i)\n\n    The nodes `x_i` of an order `n` quadrature rule are the roots of `U_n`\n    and the weights `w_i` are given by:\n\n    .. math::\n        w_i = \\\\frac{\\\\pi}{n+1} \\\\sin^2 \\\\left(\\\\frac{i}{n+1}\\\\pi\\\\right)\n\n    Parameters\n    ==========\n\n    n : the order of quadrature\n\n    n_digits : number of significant digits of the points and weights to return\n\n    Returns\n    =======\n\n    (x, w) : the ``x`` and ``w`` are lists of points and weights as Floats.\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\n             tuple of lists.\n\n    Examples\n    ========\n\n    >>> from sympy.integrals.quadrature import gauss_chebyshev_u\n    >>> x, w = gauss_chebyshev_u(3, 5)\n    >>> x\n    [0.70711, 0, -0.70711]\n    >>> w\n    [0.3927, 0.7854, 0.3927]\n\n    >>> x, w = gauss_chebyshev_u(6, 5)\n    >>> x\n    [0.90097, 0.62349, 0.22252, -0.22252, -0.62349, -0.90097]\n    >>> w\n    [0.084489, 0.27433, 0.42658, 0.42658, 0.27433, 0.084489]\n\n    See Also\n    ========\n\n    gauss_legendre, gauss_laguerre, gauss_hermite, gauss_gen_laguerre, gauss_chebyshev_t, gauss_jacobi, gauss_lobatto\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Chebyshev%E2%80%93Gauss_quadrature\n    .. [2] https://people.sc.fsu.edu/~jburkardt/cpp_src/chebyshev2_rule/chebyshev2_rule.html\n    \"\"\"\n    xi = []\n    w = []\n    for i in range(1, n + 1):\n        xi.append(cos(i / (n + S.One) * S.Pi).n(n_digits))\n        w.append((S.Pi / (n + S.One) * sin(i * S.Pi / (n + S.One)) ** 2).n(n_digits))\n    return (xi, w)",
        "mutated": [
            "def gauss_chebyshev_u(n, n_digits):\n    if False:\n        i = 10\n    '\\n    Computes the Gauss-Chebyshev quadrature [1]_ points and weights of\\n    the second kind.\\n\\n    Explanation\\n    ===========\\n\\n    The Gauss-Chebyshev quadrature of the second kind approximates the\\n    integral:\\n\\n    .. math::\\n        \\\\int_{-1}^{1} \\\\sqrt{1-x^2} f(x)\\\\,dx \\\\approx \\\\sum_{i=1}^n w_i f(x_i)\\n\\n    The nodes `x_i` of an order `n` quadrature rule are the roots of `U_n`\\n    and the weights `w_i` are given by:\\n\\n    .. math::\\n        w_i = \\\\frac{\\\\pi}{n+1} \\\\sin^2 \\\\left(\\\\frac{i}{n+1}\\\\pi\\\\right)\\n\\n    Parameters\\n    ==========\\n\\n    n : the order of quadrature\\n\\n    n_digits : number of significant digits of the points and weights to return\\n\\n    Returns\\n    =======\\n\\n    (x, w) : the ``x`` and ``w`` are lists of points and weights as Floats.\\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\\n             tuple of lists.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.integrals.quadrature import gauss_chebyshev_u\\n    >>> x, w = gauss_chebyshev_u(3, 5)\\n    >>> x\\n    [0.70711, 0, -0.70711]\\n    >>> w\\n    [0.3927, 0.7854, 0.3927]\\n\\n    >>> x, w = gauss_chebyshev_u(6, 5)\\n    >>> x\\n    [0.90097, 0.62349, 0.22252, -0.22252, -0.62349, -0.90097]\\n    >>> w\\n    [0.084489, 0.27433, 0.42658, 0.42658, 0.27433, 0.084489]\\n\\n    See Also\\n    ========\\n\\n    gauss_legendre, gauss_laguerre, gauss_hermite, gauss_gen_laguerre, gauss_chebyshev_t, gauss_jacobi, gauss_lobatto\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Chebyshev%E2%80%93Gauss_quadrature\\n    .. [2] https://people.sc.fsu.edu/~jburkardt/cpp_src/chebyshev2_rule/chebyshev2_rule.html\\n    '\n    xi = []\n    w = []\n    for i in range(1, n + 1):\n        xi.append(cos(i / (n + S.One) * S.Pi).n(n_digits))\n        w.append((S.Pi / (n + S.One) * sin(i * S.Pi / (n + S.One)) ** 2).n(n_digits))\n    return (xi, w)",
            "def gauss_chebyshev_u(n, n_digits):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Computes the Gauss-Chebyshev quadrature [1]_ points and weights of\\n    the second kind.\\n\\n    Explanation\\n    ===========\\n\\n    The Gauss-Chebyshev quadrature of the second kind approximates the\\n    integral:\\n\\n    .. math::\\n        \\\\int_{-1}^{1} \\\\sqrt{1-x^2} f(x)\\\\,dx \\\\approx \\\\sum_{i=1}^n w_i f(x_i)\\n\\n    The nodes `x_i` of an order `n` quadrature rule are the roots of `U_n`\\n    and the weights `w_i` are given by:\\n\\n    .. math::\\n        w_i = \\\\frac{\\\\pi}{n+1} \\\\sin^2 \\\\left(\\\\frac{i}{n+1}\\\\pi\\\\right)\\n\\n    Parameters\\n    ==========\\n\\n    n : the order of quadrature\\n\\n    n_digits : number of significant digits of the points and weights to return\\n\\n    Returns\\n    =======\\n\\n    (x, w) : the ``x`` and ``w`` are lists of points and weights as Floats.\\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\\n             tuple of lists.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.integrals.quadrature import gauss_chebyshev_u\\n    >>> x, w = gauss_chebyshev_u(3, 5)\\n    >>> x\\n    [0.70711, 0, -0.70711]\\n    >>> w\\n    [0.3927, 0.7854, 0.3927]\\n\\n    >>> x, w = gauss_chebyshev_u(6, 5)\\n    >>> x\\n    [0.90097, 0.62349, 0.22252, -0.22252, -0.62349, -0.90097]\\n    >>> w\\n    [0.084489, 0.27433, 0.42658, 0.42658, 0.27433, 0.084489]\\n\\n    See Also\\n    ========\\n\\n    gauss_legendre, gauss_laguerre, gauss_hermite, gauss_gen_laguerre, gauss_chebyshev_t, gauss_jacobi, gauss_lobatto\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Chebyshev%E2%80%93Gauss_quadrature\\n    .. [2] https://people.sc.fsu.edu/~jburkardt/cpp_src/chebyshev2_rule/chebyshev2_rule.html\\n    '\n    xi = []\n    w = []\n    for i in range(1, n + 1):\n        xi.append(cos(i / (n + S.One) * S.Pi).n(n_digits))\n        w.append((S.Pi / (n + S.One) * sin(i * S.Pi / (n + S.One)) ** 2).n(n_digits))\n    return (xi, w)",
            "def gauss_chebyshev_u(n, n_digits):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Computes the Gauss-Chebyshev quadrature [1]_ points and weights of\\n    the second kind.\\n\\n    Explanation\\n    ===========\\n\\n    The Gauss-Chebyshev quadrature of the second kind approximates the\\n    integral:\\n\\n    .. math::\\n        \\\\int_{-1}^{1} \\\\sqrt{1-x^2} f(x)\\\\,dx \\\\approx \\\\sum_{i=1}^n w_i f(x_i)\\n\\n    The nodes `x_i` of an order `n` quadrature rule are the roots of `U_n`\\n    and the weights `w_i` are given by:\\n\\n    .. math::\\n        w_i = \\\\frac{\\\\pi}{n+1} \\\\sin^2 \\\\left(\\\\frac{i}{n+1}\\\\pi\\\\right)\\n\\n    Parameters\\n    ==========\\n\\n    n : the order of quadrature\\n\\n    n_digits : number of significant digits of the points and weights to return\\n\\n    Returns\\n    =======\\n\\n    (x, w) : the ``x`` and ``w`` are lists of points and weights as Floats.\\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\\n             tuple of lists.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.integrals.quadrature import gauss_chebyshev_u\\n    >>> x, w = gauss_chebyshev_u(3, 5)\\n    >>> x\\n    [0.70711, 0, -0.70711]\\n    >>> w\\n    [0.3927, 0.7854, 0.3927]\\n\\n    >>> x, w = gauss_chebyshev_u(6, 5)\\n    >>> x\\n    [0.90097, 0.62349, 0.22252, -0.22252, -0.62349, -0.90097]\\n    >>> w\\n    [0.084489, 0.27433, 0.42658, 0.42658, 0.27433, 0.084489]\\n\\n    See Also\\n    ========\\n\\n    gauss_legendre, gauss_laguerre, gauss_hermite, gauss_gen_laguerre, gauss_chebyshev_t, gauss_jacobi, gauss_lobatto\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Chebyshev%E2%80%93Gauss_quadrature\\n    .. [2] https://people.sc.fsu.edu/~jburkardt/cpp_src/chebyshev2_rule/chebyshev2_rule.html\\n    '\n    xi = []\n    w = []\n    for i in range(1, n + 1):\n        xi.append(cos(i / (n + S.One) * S.Pi).n(n_digits))\n        w.append((S.Pi / (n + S.One) * sin(i * S.Pi / (n + S.One)) ** 2).n(n_digits))\n    return (xi, w)",
            "def gauss_chebyshev_u(n, n_digits):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Computes the Gauss-Chebyshev quadrature [1]_ points and weights of\\n    the second kind.\\n\\n    Explanation\\n    ===========\\n\\n    The Gauss-Chebyshev quadrature of the second kind approximates the\\n    integral:\\n\\n    .. math::\\n        \\\\int_{-1}^{1} \\\\sqrt{1-x^2} f(x)\\\\,dx \\\\approx \\\\sum_{i=1}^n w_i f(x_i)\\n\\n    The nodes `x_i` of an order `n` quadrature rule are the roots of `U_n`\\n    and the weights `w_i` are given by:\\n\\n    .. math::\\n        w_i = \\\\frac{\\\\pi}{n+1} \\\\sin^2 \\\\left(\\\\frac{i}{n+1}\\\\pi\\\\right)\\n\\n    Parameters\\n    ==========\\n\\n    n : the order of quadrature\\n\\n    n_digits : number of significant digits of the points and weights to return\\n\\n    Returns\\n    =======\\n\\n    (x, w) : the ``x`` and ``w`` are lists of points and weights as Floats.\\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\\n             tuple of lists.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.integrals.quadrature import gauss_chebyshev_u\\n    >>> x, w = gauss_chebyshev_u(3, 5)\\n    >>> x\\n    [0.70711, 0, -0.70711]\\n    >>> w\\n    [0.3927, 0.7854, 0.3927]\\n\\n    >>> x, w = gauss_chebyshev_u(6, 5)\\n    >>> x\\n    [0.90097, 0.62349, 0.22252, -0.22252, -0.62349, -0.90097]\\n    >>> w\\n    [0.084489, 0.27433, 0.42658, 0.42658, 0.27433, 0.084489]\\n\\n    See Also\\n    ========\\n\\n    gauss_legendre, gauss_laguerre, gauss_hermite, gauss_gen_laguerre, gauss_chebyshev_t, gauss_jacobi, gauss_lobatto\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Chebyshev%E2%80%93Gauss_quadrature\\n    .. [2] https://people.sc.fsu.edu/~jburkardt/cpp_src/chebyshev2_rule/chebyshev2_rule.html\\n    '\n    xi = []\n    w = []\n    for i in range(1, n + 1):\n        xi.append(cos(i / (n + S.One) * S.Pi).n(n_digits))\n        w.append((S.Pi / (n + S.One) * sin(i * S.Pi / (n + S.One)) ** 2).n(n_digits))\n    return (xi, w)",
            "def gauss_chebyshev_u(n, n_digits):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Computes the Gauss-Chebyshev quadrature [1]_ points and weights of\\n    the second kind.\\n\\n    Explanation\\n    ===========\\n\\n    The Gauss-Chebyshev quadrature of the second kind approximates the\\n    integral:\\n\\n    .. math::\\n        \\\\int_{-1}^{1} \\\\sqrt{1-x^2} f(x)\\\\,dx \\\\approx \\\\sum_{i=1}^n w_i f(x_i)\\n\\n    The nodes `x_i` of an order `n` quadrature rule are the roots of `U_n`\\n    and the weights `w_i` are given by:\\n\\n    .. math::\\n        w_i = \\\\frac{\\\\pi}{n+1} \\\\sin^2 \\\\left(\\\\frac{i}{n+1}\\\\pi\\\\right)\\n\\n    Parameters\\n    ==========\\n\\n    n : the order of quadrature\\n\\n    n_digits : number of significant digits of the points and weights to return\\n\\n    Returns\\n    =======\\n\\n    (x, w) : the ``x`` and ``w`` are lists of points and weights as Floats.\\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\\n             tuple of lists.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.integrals.quadrature import gauss_chebyshev_u\\n    >>> x, w = gauss_chebyshev_u(3, 5)\\n    >>> x\\n    [0.70711, 0, -0.70711]\\n    >>> w\\n    [0.3927, 0.7854, 0.3927]\\n\\n    >>> x, w = gauss_chebyshev_u(6, 5)\\n    >>> x\\n    [0.90097, 0.62349, 0.22252, -0.22252, -0.62349, -0.90097]\\n    >>> w\\n    [0.084489, 0.27433, 0.42658, 0.42658, 0.27433, 0.084489]\\n\\n    See Also\\n    ========\\n\\n    gauss_legendre, gauss_laguerre, gauss_hermite, gauss_gen_laguerre, gauss_chebyshev_t, gauss_jacobi, gauss_lobatto\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Chebyshev%E2%80%93Gauss_quadrature\\n    .. [2] https://people.sc.fsu.edu/~jburkardt/cpp_src/chebyshev2_rule/chebyshev2_rule.html\\n    '\n    xi = []\n    w = []\n    for i in range(1, n + 1):\n        xi.append(cos(i / (n + S.One) * S.Pi).n(n_digits))\n        w.append((S.Pi / (n + S.One) * sin(i * S.Pi / (n + S.One)) ** 2).n(n_digits))\n    return (xi, w)"
        ]
    },
    {
        "func_name": "gauss_jacobi",
        "original": "def gauss_jacobi(n, alpha, beta, n_digits):\n    \"\"\"\n    Computes the Gauss-Jacobi quadrature [1]_ points and weights.\n\n    Explanation\n    ===========\n\n    The Gauss-Jacobi quadrature of the first kind approximates the integral:\n\n    .. math::\n        \\\\int_{-1}^1 (1-x)^\\\\alpha (1+x)^\\\\beta f(x)\\\\,dx \\\\approx\n            \\\\sum_{i=1}^n w_i f(x_i)\n\n    The nodes `x_i` of an order `n` quadrature rule are the roots of\n    `P^{(\\\\alpha,\\\\beta)}_n` and the weights `w_i` are given by:\n\n    .. math::\n        w_i = -\\\\frac{2n+\\\\alpha+\\\\beta+2}{n+\\\\alpha+\\\\beta+1}\n              \\\\frac{\\\\Gamma(n+\\\\alpha+1)\\\\Gamma(n+\\\\beta+1)}\n              {\\\\Gamma(n+\\\\alpha+\\\\beta+1)(n+1)!}\n              \\\\frac{2^{\\\\alpha+\\\\beta}}{P'_n(x_i)\n              P^{(\\\\alpha,\\\\beta)}_{n+1}(x_i)}\n\n    Parameters\n    ==========\n\n    n : the order of quadrature\n\n    alpha : the first parameter of the Jacobi Polynomial, `\\\\alpha > -1`\n\n    beta : the second parameter of the Jacobi Polynomial, `\\\\beta > -1`\n\n    n_digits : number of significant digits of the points and weights to return\n\n    Returns\n    =======\n\n    (x, w) : the ``x`` and ``w`` are lists of points and weights as Floats.\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\n             tuple of lists.\n\n    Examples\n    ========\n\n    >>> from sympy import S\n    >>> from sympy.integrals.quadrature import gauss_jacobi\n    >>> x, w = gauss_jacobi(3, S.Half, -S.Half, 5)\n    >>> x\n    [-0.90097, -0.22252, 0.62349]\n    >>> w\n    [1.7063, 1.0973, 0.33795]\n\n    >>> x, w = gauss_jacobi(6, 1, 1, 5)\n    >>> x\n    [-0.87174, -0.5917, -0.2093, 0.2093, 0.5917, 0.87174]\n    >>> w\n    [0.050584, 0.22169, 0.39439, 0.39439, 0.22169, 0.050584]\n\n    See Also\n    ========\n\n    gauss_legendre, gauss_laguerre, gauss_hermite, gauss_gen_laguerre,\n    gauss_chebyshev_t, gauss_chebyshev_u, gauss_lobatto\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Gauss%E2%80%93Jacobi_quadrature\n    .. [2] https://people.sc.fsu.edu/~jburkardt/cpp_src/jacobi_rule/jacobi_rule.html\n    .. [3] https://people.sc.fsu.edu/~jburkardt/cpp_src/gegenbauer_rule/gegenbauer_rule.html\n    \"\"\"\n    x = Dummy('x')\n    p = jacobi_poly(n, alpha, beta, x, polys=True)\n    pd = p.diff(x)\n    pn = jacobi_poly(n + 1, alpha, beta, x, polys=True)\n    xi = []\n    w = []\n    for r in p.real_roots():\n        if isinstance(r, RootOf):\n            r = r.eval_rational(S.One / 10 ** (n_digits + 2))\n        xi.append(r.n(n_digits))\n        w.append((-(2 * n + alpha + beta + 2) / (n + alpha + beta + S.One) * (gamma(n + alpha + 1) * gamma(n + beta + 1)) / (gamma(n + alpha + beta + S.One) * gamma(n + 2)) * 2 ** (alpha + beta) / (pd.subs(x, r) * pn.subs(x, r))).n(n_digits))\n    return (xi, w)",
        "mutated": [
            "def gauss_jacobi(n, alpha, beta, n_digits):\n    if False:\n        i = 10\n    \"\\n    Computes the Gauss-Jacobi quadrature [1]_ points and weights.\\n\\n    Explanation\\n    ===========\\n\\n    The Gauss-Jacobi quadrature of the first kind approximates the integral:\\n\\n    .. math::\\n        \\\\int_{-1}^1 (1-x)^\\\\alpha (1+x)^\\\\beta f(x)\\\\,dx \\\\approx\\n            \\\\sum_{i=1}^n w_i f(x_i)\\n\\n    The nodes `x_i` of an order `n` quadrature rule are the roots of\\n    `P^{(\\\\alpha,\\\\beta)}_n` and the weights `w_i` are given by:\\n\\n    .. math::\\n        w_i = -\\\\frac{2n+\\\\alpha+\\\\beta+2}{n+\\\\alpha+\\\\beta+1}\\n              \\\\frac{\\\\Gamma(n+\\\\alpha+1)\\\\Gamma(n+\\\\beta+1)}\\n              {\\\\Gamma(n+\\\\alpha+\\\\beta+1)(n+1)!}\\n              \\\\frac{2^{\\\\alpha+\\\\beta}}{P'_n(x_i)\\n              P^{(\\\\alpha,\\\\beta)}_{n+1}(x_i)}\\n\\n    Parameters\\n    ==========\\n\\n    n : the order of quadrature\\n\\n    alpha : the first parameter of the Jacobi Polynomial, `\\\\alpha > -1`\\n\\n    beta : the second parameter of the Jacobi Polynomial, `\\\\beta > -1`\\n\\n    n_digits : number of significant digits of the points and weights to return\\n\\n    Returns\\n    =======\\n\\n    (x, w) : the ``x`` and ``w`` are lists of points and weights as Floats.\\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\\n             tuple of lists.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import S\\n    >>> from sympy.integrals.quadrature import gauss_jacobi\\n    >>> x, w = gauss_jacobi(3, S.Half, -S.Half, 5)\\n    >>> x\\n    [-0.90097, -0.22252, 0.62349]\\n    >>> w\\n    [1.7063, 1.0973, 0.33795]\\n\\n    >>> x, w = gauss_jacobi(6, 1, 1, 5)\\n    >>> x\\n    [-0.87174, -0.5917, -0.2093, 0.2093, 0.5917, 0.87174]\\n    >>> w\\n    [0.050584, 0.22169, 0.39439, 0.39439, 0.22169, 0.050584]\\n\\n    See Also\\n    ========\\n\\n    gauss_legendre, gauss_laguerre, gauss_hermite, gauss_gen_laguerre,\\n    gauss_chebyshev_t, gauss_chebyshev_u, gauss_lobatto\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Gauss%E2%80%93Jacobi_quadrature\\n    .. [2] https://people.sc.fsu.edu/~jburkardt/cpp_src/jacobi_rule/jacobi_rule.html\\n    .. [3] https://people.sc.fsu.edu/~jburkardt/cpp_src/gegenbauer_rule/gegenbauer_rule.html\\n    \"\n    x = Dummy('x')\n    p = jacobi_poly(n, alpha, beta, x, polys=True)\n    pd = p.diff(x)\n    pn = jacobi_poly(n + 1, alpha, beta, x, polys=True)\n    xi = []\n    w = []\n    for r in p.real_roots():\n        if isinstance(r, RootOf):\n            r = r.eval_rational(S.One / 10 ** (n_digits + 2))\n        xi.append(r.n(n_digits))\n        w.append((-(2 * n + alpha + beta + 2) / (n + alpha + beta + S.One) * (gamma(n + alpha + 1) * gamma(n + beta + 1)) / (gamma(n + alpha + beta + S.One) * gamma(n + 2)) * 2 ** (alpha + beta) / (pd.subs(x, r) * pn.subs(x, r))).n(n_digits))\n    return (xi, w)",
            "def gauss_jacobi(n, alpha, beta, n_digits):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Computes the Gauss-Jacobi quadrature [1]_ points and weights.\\n\\n    Explanation\\n    ===========\\n\\n    The Gauss-Jacobi quadrature of the first kind approximates the integral:\\n\\n    .. math::\\n        \\\\int_{-1}^1 (1-x)^\\\\alpha (1+x)^\\\\beta f(x)\\\\,dx \\\\approx\\n            \\\\sum_{i=1}^n w_i f(x_i)\\n\\n    The nodes `x_i` of an order `n` quadrature rule are the roots of\\n    `P^{(\\\\alpha,\\\\beta)}_n` and the weights `w_i` are given by:\\n\\n    .. math::\\n        w_i = -\\\\frac{2n+\\\\alpha+\\\\beta+2}{n+\\\\alpha+\\\\beta+1}\\n              \\\\frac{\\\\Gamma(n+\\\\alpha+1)\\\\Gamma(n+\\\\beta+1)}\\n              {\\\\Gamma(n+\\\\alpha+\\\\beta+1)(n+1)!}\\n              \\\\frac{2^{\\\\alpha+\\\\beta}}{P'_n(x_i)\\n              P^{(\\\\alpha,\\\\beta)}_{n+1}(x_i)}\\n\\n    Parameters\\n    ==========\\n\\n    n : the order of quadrature\\n\\n    alpha : the first parameter of the Jacobi Polynomial, `\\\\alpha > -1`\\n\\n    beta : the second parameter of the Jacobi Polynomial, `\\\\beta > -1`\\n\\n    n_digits : number of significant digits of the points and weights to return\\n\\n    Returns\\n    =======\\n\\n    (x, w) : the ``x`` and ``w`` are lists of points and weights as Floats.\\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\\n             tuple of lists.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import S\\n    >>> from sympy.integrals.quadrature import gauss_jacobi\\n    >>> x, w = gauss_jacobi(3, S.Half, -S.Half, 5)\\n    >>> x\\n    [-0.90097, -0.22252, 0.62349]\\n    >>> w\\n    [1.7063, 1.0973, 0.33795]\\n\\n    >>> x, w = gauss_jacobi(6, 1, 1, 5)\\n    >>> x\\n    [-0.87174, -0.5917, -0.2093, 0.2093, 0.5917, 0.87174]\\n    >>> w\\n    [0.050584, 0.22169, 0.39439, 0.39439, 0.22169, 0.050584]\\n\\n    See Also\\n    ========\\n\\n    gauss_legendre, gauss_laguerre, gauss_hermite, gauss_gen_laguerre,\\n    gauss_chebyshev_t, gauss_chebyshev_u, gauss_lobatto\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Gauss%E2%80%93Jacobi_quadrature\\n    .. [2] https://people.sc.fsu.edu/~jburkardt/cpp_src/jacobi_rule/jacobi_rule.html\\n    .. [3] https://people.sc.fsu.edu/~jburkardt/cpp_src/gegenbauer_rule/gegenbauer_rule.html\\n    \"\n    x = Dummy('x')\n    p = jacobi_poly(n, alpha, beta, x, polys=True)\n    pd = p.diff(x)\n    pn = jacobi_poly(n + 1, alpha, beta, x, polys=True)\n    xi = []\n    w = []\n    for r in p.real_roots():\n        if isinstance(r, RootOf):\n            r = r.eval_rational(S.One / 10 ** (n_digits + 2))\n        xi.append(r.n(n_digits))\n        w.append((-(2 * n + alpha + beta + 2) / (n + alpha + beta + S.One) * (gamma(n + alpha + 1) * gamma(n + beta + 1)) / (gamma(n + alpha + beta + S.One) * gamma(n + 2)) * 2 ** (alpha + beta) / (pd.subs(x, r) * pn.subs(x, r))).n(n_digits))\n    return (xi, w)",
            "def gauss_jacobi(n, alpha, beta, n_digits):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Computes the Gauss-Jacobi quadrature [1]_ points and weights.\\n\\n    Explanation\\n    ===========\\n\\n    The Gauss-Jacobi quadrature of the first kind approximates the integral:\\n\\n    .. math::\\n        \\\\int_{-1}^1 (1-x)^\\\\alpha (1+x)^\\\\beta f(x)\\\\,dx \\\\approx\\n            \\\\sum_{i=1}^n w_i f(x_i)\\n\\n    The nodes `x_i` of an order `n` quadrature rule are the roots of\\n    `P^{(\\\\alpha,\\\\beta)}_n` and the weights `w_i` are given by:\\n\\n    .. math::\\n        w_i = -\\\\frac{2n+\\\\alpha+\\\\beta+2}{n+\\\\alpha+\\\\beta+1}\\n              \\\\frac{\\\\Gamma(n+\\\\alpha+1)\\\\Gamma(n+\\\\beta+1)}\\n              {\\\\Gamma(n+\\\\alpha+\\\\beta+1)(n+1)!}\\n              \\\\frac{2^{\\\\alpha+\\\\beta}}{P'_n(x_i)\\n              P^{(\\\\alpha,\\\\beta)}_{n+1}(x_i)}\\n\\n    Parameters\\n    ==========\\n\\n    n : the order of quadrature\\n\\n    alpha : the first parameter of the Jacobi Polynomial, `\\\\alpha > -1`\\n\\n    beta : the second parameter of the Jacobi Polynomial, `\\\\beta > -1`\\n\\n    n_digits : number of significant digits of the points and weights to return\\n\\n    Returns\\n    =======\\n\\n    (x, w) : the ``x`` and ``w`` are lists of points and weights as Floats.\\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\\n             tuple of lists.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import S\\n    >>> from sympy.integrals.quadrature import gauss_jacobi\\n    >>> x, w = gauss_jacobi(3, S.Half, -S.Half, 5)\\n    >>> x\\n    [-0.90097, -0.22252, 0.62349]\\n    >>> w\\n    [1.7063, 1.0973, 0.33795]\\n\\n    >>> x, w = gauss_jacobi(6, 1, 1, 5)\\n    >>> x\\n    [-0.87174, -0.5917, -0.2093, 0.2093, 0.5917, 0.87174]\\n    >>> w\\n    [0.050584, 0.22169, 0.39439, 0.39439, 0.22169, 0.050584]\\n\\n    See Also\\n    ========\\n\\n    gauss_legendre, gauss_laguerre, gauss_hermite, gauss_gen_laguerre,\\n    gauss_chebyshev_t, gauss_chebyshev_u, gauss_lobatto\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Gauss%E2%80%93Jacobi_quadrature\\n    .. [2] https://people.sc.fsu.edu/~jburkardt/cpp_src/jacobi_rule/jacobi_rule.html\\n    .. [3] https://people.sc.fsu.edu/~jburkardt/cpp_src/gegenbauer_rule/gegenbauer_rule.html\\n    \"\n    x = Dummy('x')\n    p = jacobi_poly(n, alpha, beta, x, polys=True)\n    pd = p.diff(x)\n    pn = jacobi_poly(n + 1, alpha, beta, x, polys=True)\n    xi = []\n    w = []\n    for r in p.real_roots():\n        if isinstance(r, RootOf):\n            r = r.eval_rational(S.One / 10 ** (n_digits + 2))\n        xi.append(r.n(n_digits))\n        w.append((-(2 * n + alpha + beta + 2) / (n + alpha + beta + S.One) * (gamma(n + alpha + 1) * gamma(n + beta + 1)) / (gamma(n + alpha + beta + S.One) * gamma(n + 2)) * 2 ** (alpha + beta) / (pd.subs(x, r) * pn.subs(x, r))).n(n_digits))\n    return (xi, w)",
            "def gauss_jacobi(n, alpha, beta, n_digits):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Computes the Gauss-Jacobi quadrature [1]_ points and weights.\\n\\n    Explanation\\n    ===========\\n\\n    The Gauss-Jacobi quadrature of the first kind approximates the integral:\\n\\n    .. math::\\n        \\\\int_{-1}^1 (1-x)^\\\\alpha (1+x)^\\\\beta f(x)\\\\,dx \\\\approx\\n            \\\\sum_{i=1}^n w_i f(x_i)\\n\\n    The nodes `x_i` of an order `n` quadrature rule are the roots of\\n    `P^{(\\\\alpha,\\\\beta)}_n` and the weights `w_i` are given by:\\n\\n    .. math::\\n        w_i = -\\\\frac{2n+\\\\alpha+\\\\beta+2}{n+\\\\alpha+\\\\beta+1}\\n              \\\\frac{\\\\Gamma(n+\\\\alpha+1)\\\\Gamma(n+\\\\beta+1)}\\n              {\\\\Gamma(n+\\\\alpha+\\\\beta+1)(n+1)!}\\n              \\\\frac{2^{\\\\alpha+\\\\beta}}{P'_n(x_i)\\n              P^{(\\\\alpha,\\\\beta)}_{n+1}(x_i)}\\n\\n    Parameters\\n    ==========\\n\\n    n : the order of quadrature\\n\\n    alpha : the first parameter of the Jacobi Polynomial, `\\\\alpha > -1`\\n\\n    beta : the second parameter of the Jacobi Polynomial, `\\\\beta > -1`\\n\\n    n_digits : number of significant digits of the points and weights to return\\n\\n    Returns\\n    =======\\n\\n    (x, w) : the ``x`` and ``w`` are lists of points and weights as Floats.\\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\\n             tuple of lists.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import S\\n    >>> from sympy.integrals.quadrature import gauss_jacobi\\n    >>> x, w = gauss_jacobi(3, S.Half, -S.Half, 5)\\n    >>> x\\n    [-0.90097, -0.22252, 0.62349]\\n    >>> w\\n    [1.7063, 1.0973, 0.33795]\\n\\n    >>> x, w = gauss_jacobi(6, 1, 1, 5)\\n    >>> x\\n    [-0.87174, -0.5917, -0.2093, 0.2093, 0.5917, 0.87174]\\n    >>> w\\n    [0.050584, 0.22169, 0.39439, 0.39439, 0.22169, 0.050584]\\n\\n    See Also\\n    ========\\n\\n    gauss_legendre, gauss_laguerre, gauss_hermite, gauss_gen_laguerre,\\n    gauss_chebyshev_t, gauss_chebyshev_u, gauss_lobatto\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Gauss%E2%80%93Jacobi_quadrature\\n    .. [2] https://people.sc.fsu.edu/~jburkardt/cpp_src/jacobi_rule/jacobi_rule.html\\n    .. [3] https://people.sc.fsu.edu/~jburkardt/cpp_src/gegenbauer_rule/gegenbauer_rule.html\\n    \"\n    x = Dummy('x')\n    p = jacobi_poly(n, alpha, beta, x, polys=True)\n    pd = p.diff(x)\n    pn = jacobi_poly(n + 1, alpha, beta, x, polys=True)\n    xi = []\n    w = []\n    for r in p.real_roots():\n        if isinstance(r, RootOf):\n            r = r.eval_rational(S.One / 10 ** (n_digits + 2))\n        xi.append(r.n(n_digits))\n        w.append((-(2 * n + alpha + beta + 2) / (n + alpha + beta + S.One) * (gamma(n + alpha + 1) * gamma(n + beta + 1)) / (gamma(n + alpha + beta + S.One) * gamma(n + 2)) * 2 ** (alpha + beta) / (pd.subs(x, r) * pn.subs(x, r))).n(n_digits))\n    return (xi, w)",
            "def gauss_jacobi(n, alpha, beta, n_digits):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Computes the Gauss-Jacobi quadrature [1]_ points and weights.\\n\\n    Explanation\\n    ===========\\n\\n    The Gauss-Jacobi quadrature of the first kind approximates the integral:\\n\\n    .. math::\\n        \\\\int_{-1}^1 (1-x)^\\\\alpha (1+x)^\\\\beta f(x)\\\\,dx \\\\approx\\n            \\\\sum_{i=1}^n w_i f(x_i)\\n\\n    The nodes `x_i` of an order `n` quadrature rule are the roots of\\n    `P^{(\\\\alpha,\\\\beta)}_n` and the weights `w_i` are given by:\\n\\n    .. math::\\n        w_i = -\\\\frac{2n+\\\\alpha+\\\\beta+2}{n+\\\\alpha+\\\\beta+1}\\n              \\\\frac{\\\\Gamma(n+\\\\alpha+1)\\\\Gamma(n+\\\\beta+1)}\\n              {\\\\Gamma(n+\\\\alpha+\\\\beta+1)(n+1)!}\\n              \\\\frac{2^{\\\\alpha+\\\\beta}}{P'_n(x_i)\\n              P^{(\\\\alpha,\\\\beta)}_{n+1}(x_i)}\\n\\n    Parameters\\n    ==========\\n\\n    n : the order of quadrature\\n\\n    alpha : the first parameter of the Jacobi Polynomial, `\\\\alpha > -1`\\n\\n    beta : the second parameter of the Jacobi Polynomial, `\\\\beta > -1`\\n\\n    n_digits : number of significant digits of the points and weights to return\\n\\n    Returns\\n    =======\\n\\n    (x, w) : the ``x`` and ``w`` are lists of points and weights as Floats.\\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\\n             tuple of lists.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import S\\n    >>> from sympy.integrals.quadrature import gauss_jacobi\\n    >>> x, w = gauss_jacobi(3, S.Half, -S.Half, 5)\\n    >>> x\\n    [-0.90097, -0.22252, 0.62349]\\n    >>> w\\n    [1.7063, 1.0973, 0.33795]\\n\\n    >>> x, w = gauss_jacobi(6, 1, 1, 5)\\n    >>> x\\n    [-0.87174, -0.5917, -0.2093, 0.2093, 0.5917, 0.87174]\\n    >>> w\\n    [0.050584, 0.22169, 0.39439, 0.39439, 0.22169, 0.050584]\\n\\n    See Also\\n    ========\\n\\n    gauss_legendre, gauss_laguerre, gauss_hermite, gauss_gen_laguerre,\\n    gauss_chebyshev_t, gauss_chebyshev_u, gauss_lobatto\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Gauss%E2%80%93Jacobi_quadrature\\n    .. [2] https://people.sc.fsu.edu/~jburkardt/cpp_src/jacobi_rule/jacobi_rule.html\\n    .. [3] https://people.sc.fsu.edu/~jburkardt/cpp_src/gegenbauer_rule/gegenbauer_rule.html\\n    \"\n    x = Dummy('x')\n    p = jacobi_poly(n, alpha, beta, x, polys=True)\n    pd = p.diff(x)\n    pn = jacobi_poly(n + 1, alpha, beta, x, polys=True)\n    xi = []\n    w = []\n    for r in p.real_roots():\n        if isinstance(r, RootOf):\n            r = r.eval_rational(S.One / 10 ** (n_digits + 2))\n        xi.append(r.n(n_digits))\n        w.append((-(2 * n + alpha + beta + 2) / (n + alpha + beta + S.One) * (gamma(n + alpha + 1) * gamma(n + beta + 1)) / (gamma(n + alpha + beta + S.One) * gamma(n + 2)) * 2 ** (alpha + beta) / (pd.subs(x, r) * pn.subs(x, r))).n(n_digits))\n    return (xi, w)"
        ]
    },
    {
        "func_name": "gauss_lobatto",
        "original": "def gauss_lobatto(n, n_digits):\n    \"\"\"\n    Computes the Gauss-Lobatto quadrature [1]_ points and weights.\n\n    Explanation\n    ===========\n\n    The Gauss-Lobatto quadrature approximates the integral:\n\n    .. math::\n        \\\\int_{-1}^1 f(x)\\\\,dx \\\\approx \\\\sum_{i=1}^n w_i f(x_i)\n\n    The nodes `x_i` of an order `n` quadrature rule are the roots of `P'_(n-1)`\n    and the weights `w_i` are given by:\n\n    .. math::\n        &w_i = \\\\frac{2}{n(n-1) \\\\left[P_{n-1}(x_i)\\\\right]^2},\\\\quad x\\\\neq\\\\pm 1\\\\\\\\\n        &w_i = \\\\frac{2}{n(n-1)},\\\\quad x=\\\\pm 1\n\n    Parameters\n    ==========\n\n    n : the order of quadrature\n\n    n_digits : number of significant digits of the points and weights to return\n\n    Returns\n    =======\n\n    (x, w) : the ``x`` and ``w`` are lists of points and weights as Floats.\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\n             tuple of lists.\n\n    Examples\n    ========\n\n    >>> from sympy.integrals.quadrature import gauss_lobatto\n    >>> x, w = gauss_lobatto(3, 5)\n    >>> x\n    [-1, 0, 1]\n    >>> w\n    [0.33333, 1.3333, 0.33333]\n    >>> x, w = gauss_lobatto(4, 5)\n    >>> x\n    [-1, -0.44721, 0.44721, 1]\n    >>> w\n    [0.16667, 0.83333, 0.83333, 0.16667]\n\n    See Also\n    ========\n\n    gauss_legendre,gauss_laguerre, gauss_gen_laguerre, gauss_hermite, gauss_chebyshev_t, gauss_chebyshev_u, gauss_jacobi\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Gaussian_quadrature#Gauss.E2.80.93Lobatto_rules\n    .. [2] https://web.archive.org/web/20200118141346/http://people.math.sfu.ca/~cbm/aands/page_888.htm\n    \"\"\"\n    x = Dummy('x')\n    p = legendre_poly(n - 1, x, polys=True)\n    pd = p.diff(x)\n    xi = []\n    w = []\n    for r in pd.real_roots():\n        if isinstance(r, RootOf):\n            r = r.eval_rational(S.One / 10 ** (n_digits + 2))\n        xi.append(r.n(n_digits))\n        w.append((2 / (n * (n - 1) * p.subs(x, r) ** 2)).n(n_digits))\n    xi.insert(0, -1)\n    xi.append(1)\n    w.insert(0, (S(2) / (n * (n - 1))).n(n_digits))\n    w.append((S(2) / (n * (n - 1))).n(n_digits))\n    return (xi, w)",
        "mutated": [
            "def gauss_lobatto(n, n_digits):\n    if False:\n        i = 10\n    \"\\n    Computes the Gauss-Lobatto quadrature [1]_ points and weights.\\n\\n    Explanation\\n    ===========\\n\\n    The Gauss-Lobatto quadrature approximates the integral:\\n\\n    .. math::\\n        \\\\int_{-1}^1 f(x)\\\\,dx \\\\approx \\\\sum_{i=1}^n w_i f(x_i)\\n\\n    The nodes `x_i` of an order `n` quadrature rule are the roots of `P'_(n-1)`\\n    and the weights `w_i` are given by:\\n\\n    .. math::\\n        &w_i = \\\\frac{2}{n(n-1) \\\\left[P_{n-1}(x_i)\\\\right]^2},\\\\quad x\\\\neq\\\\pm 1\\\\\\\\\\n        &w_i = \\\\frac{2}{n(n-1)},\\\\quad x=\\\\pm 1\\n\\n    Parameters\\n    ==========\\n\\n    n : the order of quadrature\\n\\n    n_digits : number of significant digits of the points and weights to return\\n\\n    Returns\\n    =======\\n\\n    (x, w) : the ``x`` and ``w`` are lists of points and weights as Floats.\\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\\n             tuple of lists.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.integrals.quadrature import gauss_lobatto\\n    >>> x, w = gauss_lobatto(3, 5)\\n    >>> x\\n    [-1, 0, 1]\\n    >>> w\\n    [0.33333, 1.3333, 0.33333]\\n    >>> x, w = gauss_lobatto(4, 5)\\n    >>> x\\n    [-1, -0.44721, 0.44721, 1]\\n    >>> w\\n    [0.16667, 0.83333, 0.83333, 0.16667]\\n\\n    See Also\\n    ========\\n\\n    gauss_legendre,gauss_laguerre, gauss_gen_laguerre, gauss_hermite, gauss_chebyshev_t, gauss_chebyshev_u, gauss_jacobi\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Gaussian_quadrature#Gauss.E2.80.93Lobatto_rules\\n    .. [2] https://web.archive.org/web/20200118141346/http://people.math.sfu.ca/~cbm/aands/page_888.htm\\n    \"\n    x = Dummy('x')\n    p = legendre_poly(n - 1, x, polys=True)\n    pd = p.diff(x)\n    xi = []\n    w = []\n    for r in pd.real_roots():\n        if isinstance(r, RootOf):\n            r = r.eval_rational(S.One / 10 ** (n_digits + 2))\n        xi.append(r.n(n_digits))\n        w.append((2 / (n * (n - 1) * p.subs(x, r) ** 2)).n(n_digits))\n    xi.insert(0, -1)\n    xi.append(1)\n    w.insert(0, (S(2) / (n * (n - 1))).n(n_digits))\n    w.append((S(2) / (n * (n - 1))).n(n_digits))\n    return (xi, w)",
            "def gauss_lobatto(n, n_digits):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Computes the Gauss-Lobatto quadrature [1]_ points and weights.\\n\\n    Explanation\\n    ===========\\n\\n    The Gauss-Lobatto quadrature approximates the integral:\\n\\n    .. math::\\n        \\\\int_{-1}^1 f(x)\\\\,dx \\\\approx \\\\sum_{i=1}^n w_i f(x_i)\\n\\n    The nodes `x_i` of an order `n` quadrature rule are the roots of `P'_(n-1)`\\n    and the weights `w_i` are given by:\\n\\n    .. math::\\n        &w_i = \\\\frac{2}{n(n-1) \\\\left[P_{n-1}(x_i)\\\\right]^2},\\\\quad x\\\\neq\\\\pm 1\\\\\\\\\\n        &w_i = \\\\frac{2}{n(n-1)},\\\\quad x=\\\\pm 1\\n\\n    Parameters\\n    ==========\\n\\n    n : the order of quadrature\\n\\n    n_digits : number of significant digits of the points and weights to return\\n\\n    Returns\\n    =======\\n\\n    (x, w) : the ``x`` and ``w`` are lists of points and weights as Floats.\\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\\n             tuple of lists.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.integrals.quadrature import gauss_lobatto\\n    >>> x, w = gauss_lobatto(3, 5)\\n    >>> x\\n    [-1, 0, 1]\\n    >>> w\\n    [0.33333, 1.3333, 0.33333]\\n    >>> x, w = gauss_lobatto(4, 5)\\n    >>> x\\n    [-1, -0.44721, 0.44721, 1]\\n    >>> w\\n    [0.16667, 0.83333, 0.83333, 0.16667]\\n\\n    See Also\\n    ========\\n\\n    gauss_legendre,gauss_laguerre, gauss_gen_laguerre, gauss_hermite, gauss_chebyshev_t, gauss_chebyshev_u, gauss_jacobi\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Gaussian_quadrature#Gauss.E2.80.93Lobatto_rules\\n    .. [2] https://web.archive.org/web/20200118141346/http://people.math.sfu.ca/~cbm/aands/page_888.htm\\n    \"\n    x = Dummy('x')\n    p = legendre_poly(n - 1, x, polys=True)\n    pd = p.diff(x)\n    xi = []\n    w = []\n    for r in pd.real_roots():\n        if isinstance(r, RootOf):\n            r = r.eval_rational(S.One / 10 ** (n_digits + 2))\n        xi.append(r.n(n_digits))\n        w.append((2 / (n * (n - 1) * p.subs(x, r) ** 2)).n(n_digits))\n    xi.insert(0, -1)\n    xi.append(1)\n    w.insert(0, (S(2) / (n * (n - 1))).n(n_digits))\n    w.append((S(2) / (n * (n - 1))).n(n_digits))\n    return (xi, w)",
            "def gauss_lobatto(n, n_digits):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Computes the Gauss-Lobatto quadrature [1]_ points and weights.\\n\\n    Explanation\\n    ===========\\n\\n    The Gauss-Lobatto quadrature approximates the integral:\\n\\n    .. math::\\n        \\\\int_{-1}^1 f(x)\\\\,dx \\\\approx \\\\sum_{i=1}^n w_i f(x_i)\\n\\n    The nodes `x_i` of an order `n` quadrature rule are the roots of `P'_(n-1)`\\n    and the weights `w_i` are given by:\\n\\n    .. math::\\n        &w_i = \\\\frac{2}{n(n-1) \\\\left[P_{n-1}(x_i)\\\\right]^2},\\\\quad x\\\\neq\\\\pm 1\\\\\\\\\\n        &w_i = \\\\frac{2}{n(n-1)},\\\\quad x=\\\\pm 1\\n\\n    Parameters\\n    ==========\\n\\n    n : the order of quadrature\\n\\n    n_digits : number of significant digits of the points and weights to return\\n\\n    Returns\\n    =======\\n\\n    (x, w) : the ``x`` and ``w`` are lists of points and weights as Floats.\\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\\n             tuple of lists.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.integrals.quadrature import gauss_lobatto\\n    >>> x, w = gauss_lobatto(3, 5)\\n    >>> x\\n    [-1, 0, 1]\\n    >>> w\\n    [0.33333, 1.3333, 0.33333]\\n    >>> x, w = gauss_lobatto(4, 5)\\n    >>> x\\n    [-1, -0.44721, 0.44721, 1]\\n    >>> w\\n    [0.16667, 0.83333, 0.83333, 0.16667]\\n\\n    See Also\\n    ========\\n\\n    gauss_legendre,gauss_laguerre, gauss_gen_laguerre, gauss_hermite, gauss_chebyshev_t, gauss_chebyshev_u, gauss_jacobi\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Gaussian_quadrature#Gauss.E2.80.93Lobatto_rules\\n    .. [2] https://web.archive.org/web/20200118141346/http://people.math.sfu.ca/~cbm/aands/page_888.htm\\n    \"\n    x = Dummy('x')\n    p = legendre_poly(n - 1, x, polys=True)\n    pd = p.diff(x)\n    xi = []\n    w = []\n    for r in pd.real_roots():\n        if isinstance(r, RootOf):\n            r = r.eval_rational(S.One / 10 ** (n_digits + 2))\n        xi.append(r.n(n_digits))\n        w.append((2 / (n * (n - 1) * p.subs(x, r) ** 2)).n(n_digits))\n    xi.insert(0, -1)\n    xi.append(1)\n    w.insert(0, (S(2) / (n * (n - 1))).n(n_digits))\n    w.append((S(2) / (n * (n - 1))).n(n_digits))\n    return (xi, w)",
            "def gauss_lobatto(n, n_digits):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Computes the Gauss-Lobatto quadrature [1]_ points and weights.\\n\\n    Explanation\\n    ===========\\n\\n    The Gauss-Lobatto quadrature approximates the integral:\\n\\n    .. math::\\n        \\\\int_{-1}^1 f(x)\\\\,dx \\\\approx \\\\sum_{i=1}^n w_i f(x_i)\\n\\n    The nodes `x_i` of an order `n` quadrature rule are the roots of `P'_(n-1)`\\n    and the weights `w_i` are given by:\\n\\n    .. math::\\n        &w_i = \\\\frac{2}{n(n-1) \\\\left[P_{n-1}(x_i)\\\\right]^2},\\\\quad x\\\\neq\\\\pm 1\\\\\\\\\\n        &w_i = \\\\frac{2}{n(n-1)},\\\\quad x=\\\\pm 1\\n\\n    Parameters\\n    ==========\\n\\n    n : the order of quadrature\\n\\n    n_digits : number of significant digits of the points and weights to return\\n\\n    Returns\\n    =======\\n\\n    (x, w) : the ``x`` and ``w`` are lists of points and weights as Floats.\\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\\n             tuple of lists.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.integrals.quadrature import gauss_lobatto\\n    >>> x, w = gauss_lobatto(3, 5)\\n    >>> x\\n    [-1, 0, 1]\\n    >>> w\\n    [0.33333, 1.3333, 0.33333]\\n    >>> x, w = gauss_lobatto(4, 5)\\n    >>> x\\n    [-1, -0.44721, 0.44721, 1]\\n    >>> w\\n    [0.16667, 0.83333, 0.83333, 0.16667]\\n\\n    See Also\\n    ========\\n\\n    gauss_legendre,gauss_laguerre, gauss_gen_laguerre, gauss_hermite, gauss_chebyshev_t, gauss_chebyshev_u, gauss_jacobi\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Gaussian_quadrature#Gauss.E2.80.93Lobatto_rules\\n    .. [2] https://web.archive.org/web/20200118141346/http://people.math.sfu.ca/~cbm/aands/page_888.htm\\n    \"\n    x = Dummy('x')\n    p = legendre_poly(n - 1, x, polys=True)\n    pd = p.diff(x)\n    xi = []\n    w = []\n    for r in pd.real_roots():\n        if isinstance(r, RootOf):\n            r = r.eval_rational(S.One / 10 ** (n_digits + 2))\n        xi.append(r.n(n_digits))\n        w.append((2 / (n * (n - 1) * p.subs(x, r) ** 2)).n(n_digits))\n    xi.insert(0, -1)\n    xi.append(1)\n    w.insert(0, (S(2) / (n * (n - 1))).n(n_digits))\n    w.append((S(2) / (n * (n - 1))).n(n_digits))\n    return (xi, w)",
            "def gauss_lobatto(n, n_digits):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Computes the Gauss-Lobatto quadrature [1]_ points and weights.\\n\\n    Explanation\\n    ===========\\n\\n    The Gauss-Lobatto quadrature approximates the integral:\\n\\n    .. math::\\n        \\\\int_{-1}^1 f(x)\\\\,dx \\\\approx \\\\sum_{i=1}^n w_i f(x_i)\\n\\n    The nodes `x_i` of an order `n` quadrature rule are the roots of `P'_(n-1)`\\n    and the weights `w_i` are given by:\\n\\n    .. math::\\n        &w_i = \\\\frac{2}{n(n-1) \\\\left[P_{n-1}(x_i)\\\\right]^2},\\\\quad x\\\\neq\\\\pm 1\\\\\\\\\\n        &w_i = \\\\frac{2}{n(n-1)},\\\\quad x=\\\\pm 1\\n\\n    Parameters\\n    ==========\\n\\n    n : the order of quadrature\\n\\n    n_digits : number of significant digits of the points and weights to return\\n\\n    Returns\\n    =======\\n\\n    (x, w) : the ``x`` and ``w`` are lists of points and weights as Floats.\\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\\n             tuple of lists.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.integrals.quadrature import gauss_lobatto\\n    >>> x, w = gauss_lobatto(3, 5)\\n    >>> x\\n    [-1, 0, 1]\\n    >>> w\\n    [0.33333, 1.3333, 0.33333]\\n    >>> x, w = gauss_lobatto(4, 5)\\n    >>> x\\n    [-1, -0.44721, 0.44721, 1]\\n    >>> w\\n    [0.16667, 0.83333, 0.83333, 0.16667]\\n\\n    See Also\\n    ========\\n\\n    gauss_legendre,gauss_laguerre, gauss_gen_laguerre, gauss_hermite, gauss_chebyshev_t, gauss_chebyshev_u, gauss_jacobi\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Gaussian_quadrature#Gauss.E2.80.93Lobatto_rules\\n    .. [2] https://web.archive.org/web/20200118141346/http://people.math.sfu.ca/~cbm/aands/page_888.htm\\n    \"\n    x = Dummy('x')\n    p = legendre_poly(n - 1, x, polys=True)\n    pd = p.diff(x)\n    xi = []\n    w = []\n    for r in pd.real_roots():\n        if isinstance(r, RootOf):\n            r = r.eval_rational(S.One / 10 ** (n_digits + 2))\n        xi.append(r.n(n_digits))\n        w.append((2 / (n * (n - 1) * p.subs(x, r) ** 2)).n(n_digits))\n    xi.insert(0, -1)\n    xi.append(1)\n    w.insert(0, (S(2) / (n * (n - 1))).n(n_digits))\n    w.append((S(2) / (n * (n - 1))).n(n_digits))\n    return (xi, w)"
        ]
    }
]