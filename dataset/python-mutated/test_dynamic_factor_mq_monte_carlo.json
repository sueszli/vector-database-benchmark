[
    {
        "func_name": "simulate_k_factor1",
        "original": "def simulate_k_factor1(nobs=1000):\n    mod_sim = dynamic_factor.DynamicFactor(np.zeros((1, 4)), k_factors=1, factor_order=1, error_order=1)\n    loadings = [1.0, -0.75, 0.25, -0.3, 0.5]\n    p = np.r_[loadings[:mod_sim.k_endog], [10] * mod_sim.k_endog, 0.5, [0.0] * mod_sim.k_endog]\n    ix = pd.period_range(start='1935-01', periods=nobs, freq='M')\n    endog = pd.DataFrame(mod_sim.simulate(p, nobs), index=ix)\n    true = pd.Series(p, index=mod_sim.param_names)\n    ix = pd.period_range(start=endog.index[0] - 1, end=endog.index[-1], freq=endog.index.freq)\n    levels_M = 1 + endog.reindex(ix) / 100\n    levels_M.iloc[0] = 100\n    levels_M = levels_M.cumprod()\n    log_levels_M = np.log(levels_M) * 100\n    log_levels_Q = np.log(levels_M).resample('Q', convention='e').sum().iloc[:-1] * 100\n    endog_M = log_levels_M.iloc[:, :3].diff()\n    endog_Q = log_levels_Q.iloc[:, 3:].diff()\n    return (endog_M, endog_Q, log_levels_M, log_levels_Q, true)",
        "mutated": [
            "def simulate_k_factor1(nobs=1000):\n    if False:\n        i = 10\n    mod_sim = dynamic_factor.DynamicFactor(np.zeros((1, 4)), k_factors=1, factor_order=1, error_order=1)\n    loadings = [1.0, -0.75, 0.25, -0.3, 0.5]\n    p = np.r_[loadings[:mod_sim.k_endog], [10] * mod_sim.k_endog, 0.5, [0.0] * mod_sim.k_endog]\n    ix = pd.period_range(start='1935-01', periods=nobs, freq='M')\n    endog = pd.DataFrame(mod_sim.simulate(p, nobs), index=ix)\n    true = pd.Series(p, index=mod_sim.param_names)\n    ix = pd.period_range(start=endog.index[0] - 1, end=endog.index[-1], freq=endog.index.freq)\n    levels_M = 1 + endog.reindex(ix) / 100\n    levels_M.iloc[0] = 100\n    levels_M = levels_M.cumprod()\n    log_levels_M = np.log(levels_M) * 100\n    log_levels_Q = np.log(levels_M).resample('Q', convention='e').sum().iloc[:-1] * 100\n    endog_M = log_levels_M.iloc[:, :3].diff()\n    endog_Q = log_levels_Q.iloc[:, 3:].diff()\n    return (endog_M, endog_Q, log_levels_M, log_levels_Q, true)",
            "def simulate_k_factor1(nobs=1000):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    mod_sim = dynamic_factor.DynamicFactor(np.zeros((1, 4)), k_factors=1, factor_order=1, error_order=1)\n    loadings = [1.0, -0.75, 0.25, -0.3, 0.5]\n    p = np.r_[loadings[:mod_sim.k_endog], [10] * mod_sim.k_endog, 0.5, [0.0] * mod_sim.k_endog]\n    ix = pd.period_range(start='1935-01', periods=nobs, freq='M')\n    endog = pd.DataFrame(mod_sim.simulate(p, nobs), index=ix)\n    true = pd.Series(p, index=mod_sim.param_names)\n    ix = pd.period_range(start=endog.index[0] - 1, end=endog.index[-1], freq=endog.index.freq)\n    levels_M = 1 + endog.reindex(ix) / 100\n    levels_M.iloc[0] = 100\n    levels_M = levels_M.cumprod()\n    log_levels_M = np.log(levels_M) * 100\n    log_levels_Q = np.log(levels_M).resample('Q', convention='e').sum().iloc[:-1] * 100\n    endog_M = log_levels_M.iloc[:, :3].diff()\n    endog_Q = log_levels_Q.iloc[:, 3:].diff()\n    return (endog_M, endog_Q, log_levels_M, log_levels_Q, true)",
            "def simulate_k_factor1(nobs=1000):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    mod_sim = dynamic_factor.DynamicFactor(np.zeros((1, 4)), k_factors=1, factor_order=1, error_order=1)\n    loadings = [1.0, -0.75, 0.25, -0.3, 0.5]\n    p = np.r_[loadings[:mod_sim.k_endog], [10] * mod_sim.k_endog, 0.5, [0.0] * mod_sim.k_endog]\n    ix = pd.period_range(start='1935-01', periods=nobs, freq='M')\n    endog = pd.DataFrame(mod_sim.simulate(p, nobs), index=ix)\n    true = pd.Series(p, index=mod_sim.param_names)\n    ix = pd.period_range(start=endog.index[0] - 1, end=endog.index[-1], freq=endog.index.freq)\n    levels_M = 1 + endog.reindex(ix) / 100\n    levels_M.iloc[0] = 100\n    levels_M = levels_M.cumprod()\n    log_levels_M = np.log(levels_M) * 100\n    log_levels_Q = np.log(levels_M).resample('Q', convention='e').sum().iloc[:-1] * 100\n    endog_M = log_levels_M.iloc[:, :3].diff()\n    endog_Q = log_levels_Q.iloc[:, 3:].diff()\n    return (endog_M, endog_Q, log_levels_M, log_levels_Q, true)",
            "def simulate_k_factor1(nobs=1000):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    mod_sim = dynamic_factor.DynamicFactor(np.zeros((1, 4)), k_factors=1, factor_order=1, error_order=1)\n    loadings = [1.0, -0.75, 0.25, -0.3, 0.5]\n    p = np.r_[loadings[:mod_sim.k_endog], [10] * mod_sim.k_endog, 0.5, [0.0] * mod_sim.k_endog]\n    ix = pd.period_range(start='1935-01', periods=nobs, freq='M')\n    endog = pd.DataFrame(mod_sim.simulate(p, nobs), index=ix)\n    true = pd.Series(p, index=mod_sim.param_names)\n    ix = pd.period_range(start=endog.index[0] - 1, end=endog.index[-1], freq=endog.index.freq)\n    levels_M = 1 + endog.reindex(ix) / 100\n    levels_M.iloc[0] = 100\n    levels_M = levels_M.cumprod()\n    log_levels_M = np.log(levels_M) * 100\n    log_levels_Q = np.log(levels_M).resample('Q', convention='e').sum().iloc[:-1] * 100\n    endog_M = log_levels_M.iloc[:, :3].diff()\n    endog_Q = log_levels_Q.iloc[:, 3:].diff()\n    return (endog_M, endog_Q, log_levels_M, log_levels_Q, true)",
            "def simulate_k_factor1(nobs=1000):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    mod_sim = dynamic_factor.DynamicFactor(np.zeros((1, 4)), k_factors=1, factor_order=1, error_order=1)\n    loadings = [1.0, -0.75, 0.25, -0.3, 0.5]\n    p = np.r_[loadings[:mod_sim.k_endog], [10] * mod_sim.k_endog, 0.5, [0.0] * mod_sim.k_endog]\n    ix = pd.period_range(start='1935-01', periods=nobs, freq='M')\n    endog = pd.DataFrame(mod_sim.simulate(p, nobs), index=ix)\n    true = pd.Series(p, index=mod_sim.param_names)\n    ix = pd.period_range(start=endog.index[0] - 1, end=endog.index[-1], freq=endog.index.freq)\n    levels_M = 1 + endog.reindex(ix) / 100\n    levels_M.iloc[0] = 100\n    levels_M = levels_M.cumprod()\n    log_levels_M = np.log(levels_M) * 100\n    log_levels_Q = np.log(levels_M).resample('Q', convention='e').sum().iloc[:-1] * 100\n    endog_M = log_levels_M.iloc[:, :3].diff()\n    endog_Q = log_levels_Q.iloc[:, 3:].diff()\n    return (endog_M, endog_Q, log_levels_M, log_levels_Q, true)"
        ]
    },
    {
        "func_name": "simulate_k_factors3_blocks2",
        "original": "def simulate_k_factors3_blocks2(nobs=1000, idiosyncratic_ar1=False):\n    ix = pd.period_range(start='2000-01', periods=1, freq='M')\n    endog = pd.DataFrame(np.zeros((1, 2)), columns=['f1', 'f2'], index=ix)\n    mod_f_12 = varmax.VARMAX(endog, order=(1, 0), trend='n')\n    params = [0.5, 0.1, -0.2, 0.9, 1.0, 0, 1.0]\n    f_12 = mod_f_12.simulate(params, nobs)\n    endog = pd.Series([0], name='f3', index=ix)\n    mod_f_3 = sarimax.SARIMAX(endog, order=(2, 0, 0))\n    params = [0.7, 0.1, 1.0]\n    f_3 = mod_f_3.simulate(params, nobs)\n    f = pd.concat([f_12, f_3], axis=1)\n    k_endog = 8\n    design = np.zeros((k_endog, 3))\n    design[0] = [1.0, 1.0, 1.0]\n    design[1] = [0.5, -0.8, 0.0]\n    design[2] = [1.0, 0.0, 0.0]\n    design[3] = [0.2, 0.0, -0.1]\n    design[4] = [0.5, 0.0, 0.0]\n    design[5] = [-0.2, 0.0, 0.0]\n    design[6] = [1.0, 1.0, 1.0]\n    design[7] = [-1.0, 0.0, 0.0]\n    rho = np.array([0.5, 0.2, -0.1, 0.0, 0.4, 0.9, 0.05, 0.05])\n    if not idiosyncratic_ar1:\n        rho *= 0.0\n    eps = [lfilter([1], [1, -rho[i]], np.random.normal(size=nobs)) for i in range(k_endog)]\n    endog = (design @ f.T).T + eps\n    endog.columns = [f'y{i + 1}' for i in range(k_endog)]\n    tmp1 = design.ravel()\n    tmp2 = np.linalg.cholesky(mod_f_12['state_cov'])\n    tmp3 = rho if idiosyncratic_ar1 else []\n    true = np.r_[tmp1[tmp1 != 0], mod_f_12['transition', :2, :].ravel(), mod_f_3['transition', :, 0], tmp2[np.tril_indices_from(tmp2)], mod_f_3['state_cov', 0, 0], tmp3, [1] * k_endog]\n    ix = pd.period_range(endog.index[0] - 1, endog.index[-1], freq='M')\n    levels_M = 1 + endog.reindex(ix) / 100\n    levels_M.iloc[0] = 100\n    levels_M = levels_M.cumprod()\n    log_levels_M = np.log(levels_M) * 100\n    log_levels_Q = np.log(levels_M).resample('Q', convention='e').sum().iloc[:-1] * 100\n    endog_M = log_levels_M.iloc[:, :7].diff().iloc[1:]\n    endog_Q = log_levels_Q.iloc[:, 7:].diff().iloc[2:]\n    factor_names = np.array(['global', 'second', 'third'])\n    factors = {endog.columns[i]: factor_names[design[i] != 0] for i in range(k_endog)}\n    factor_orders = {('global', 'second'): 1, 'third': 2}\n    return (endog_M, endog_Q, log_levels_M, log_levels_Q, factors, factor_orders, true, f)",
        "mutated": [
            "def simulate_k_factors3_blocks2(nobs=1000, idiosyncratic_ar1=False):\n    if False:\n        i = 10\n    ix = pd.period_range(start='2000-01', periods=1, freq='M')\n    endog = pd.DataFrame(np.zeros((1, 2)), columns=['f1', 'f2'], index=ix)\n    mod_f_12 = varmax.VARMAX(endog, order=(1, 0), trend='n')\n    params = [0.5, 0.1, -0.2, 0.9, 1.0, 0, 1.0]\n    f_12 = mod_f_12.simulate(params, nobs)\n    endog = pd.Series([0], name='f3', index=ix)\n    mod_f_3 = sarimax.SARIMAX(endog, order=(2, 0, 0))\n    params = [0.7, 0.1, 1.0]\n    f_3 = mod_f_3.simulate(params, nobs)\n    f = pd.concat([f_12, f_3], axis=1)\n    k_endog = 8\n    design = np.zeros((k_endog, 3))\n    design[0] = [1.0, 1.0, 1.0]\n    design[1] = [0.5, -0.8, 0.0]\n    design[2] = [1.0, 0.0, 0.0]\n    design[3] = [0.2, 0.0, -0.1]\n    design[4] = [0.5, 0.0, 0.0]\n    design[5] = [-0.2, 0.0, 0.0]\n    design[6] = [1.0, 1.0, 1.0]\n    design[7] = [-1.0, 0.0, 0.0]\n    rho = np.array([0.5, 0.2, -0.1, 0.0, 0.4, 0.9, 0.05, 0.05])\n    if not idiosyncratic_ar1:\n        rho *= 0.0\n    eps = [lfilter([1], [1, -rho[i]], np.random.normal(size=nobs)) for i in range(k_endog)]\n    endog = (design @ f.T).T + eps\n    endog.columns = [f'y{i + 1}' for i in range(k_endog)]\n    tmp1 = design.ravel()\n    tmp2 = np.linalg.cholesky(mod_f_12['state_cov'])\n    tmp3 = rho if idiosyncratic_ar1 else []\n    true = np.r_[tmp1[tmp1 != 0], mod_f_12['transition', :2, :].ravel(), mod_f_3['transition', :, 0], tmp2[np.tril_indices_from(tmp2)], mod_f_3['state_cov', 0, 0], tmp3, [1] * k_endog]\n    ix = pd.period_range(endog.index[0] - 1, endog.index[-1], freq='M')\n    levels_M = 1 + endog.reindex(ix) / 100\n    levels_M.iloc[0] = 100\n    levels_M = levels_M.cumprod()\n    log_levels_M = np.log(levels_M) * 100\n    log_levels_Q = np.log(levels_M).resample('Q', convention='e').sum().iloc[:-1] * 100\n    endog_M = log_levels_M.iloc[:, :7].diff().iloc[1:]\n    endog_Q = log_levels_Q.iloc[:, 7:].diff().iloc[2:]\n    factor_names = np.array(['global', 'second', 'third'])\n    factors = {endog.columns[i]: factor_names[design[i] != 0] for i in range(k_endog)}\n    factor_orders = {('global', 'second'): 1, 'third': 2}\n    return (endog_M, endog_Q, log_levels_M, log_levels_Q, factors, factor_orders, true, f)",
            "def simulate_k_factors3_blocks2(nobs=1000, idiosyncratic_ar1=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ix = pd.period_range(start='2000-01', periods=1, freq='M')\n    endog = pd.DataFrame(np.zeros((1, 2)), columns=['f1', 'f2'], index=ix)\n    mod_f_12 = varmax.VARMAX(endog, order=(1, 0), trend='n')\n    params = [0.5, 0.1, -0.2, 0.9, 1.0, 0, 1.0]\n    f_12 = mod_f_12.simulate(params, nobs)\n    endog = pd.Series([0], name='f3', index=ix)\n    mod_f_3 = sarimax.SARIMAX(endog, order=(2, 0, 0))\n    params = [0.7, 0.1, 1.0]\n    f_3 = mod_f_3.simulate(params, nobs)\n    f = pd.concat([f_12, f_3], axis=1)\n    k_endog = 8\n    design = np.zeros((k_endog, 3))\n    design[0] = [1.0, 1.0, 1.0]\n    design[1] = [0.5, -0.8, 0.0]\n    design[2] = [1.0, 0.0, 0.0]\n    design[3] = [0.2, 0.0, -0.1]\n    design[4] = [0.5, 0.0, 0.0]\n    design[5] = [-0.2, 0.0, 0.0]\n    design[6] = [1.0, 1.0, 1.0]\n    design[7] = [-1.0, 0.0, 0.0]\n    rho = np.array([0.5, 0.2, -0.1, 0.0, 0.4, 0.9, 0.05, 0.05])\n    if not idiosyncratic_ar1:\n        rho *= 0.0\n    eps = [lfilter([1], [1, -rho[i]], np.random.normal(size=nobs)) for i in range(k_endog)]\n    endog = (design @ f.T).T + eps\n    endog.columns = [f'y{i + 1}' for i in range(k_endog)]\n    tmp1 = design.ravel()\n    tmp2 = np.linalg.cholesky(mod_f_12['state_cov'])\n    tmp3 = rho if idiosyncratic_ar1 else []\n    true = np.r_[tmp1[tmp1 != 0], mod_f_12['transition', :2, :].ravel(), mod_f_3['transition', :, 0], tmp2[np.tril_indices_from(tmp2)], mod_f_3['state_cov', 0, 0], tmp3, [1] * k_endog]\n    ix = pd.period_range(endog.index[0] - 1, endog.index[-1], freq='M')\n    levels_M = 1 + endog.reindex(ix) / 100\n    levels_M.iloc[0] = 100\n    levels_M = levels_M.cumprod()\n    log_levels_M = np.log(levels_M) * 100\n    log_levels_Q = np.log(levels_M).resample('Q', convention='e').sum().iloc[:-1] * 100\n    endog_M = log_levels_M.iloc[:, :7].diff().iloc[1:]\n    endog_Q = log_levels_Q.iloc[:, 7:].diff().iloc[2:]\n    factor_names = np.array(['global', 'second', 'third'])\n    factors = {endog.columns[i]: factor_names[design[i] != 0] for i in range(k_endog)}\n    factor_orders = {('global', 'second'): 1, 'third': 2}\n    return (endog_M, endog_Q, log_levels_M, log_levels_Q, factors, factor_orders, true, f)",
            "def simulate_k_factors3_blocks2(nobs=1000, idiosyncratic_ar1=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ix = pd.period_range(start='2000-01', periods=1, freq='M')\n    endog = pd.DataFrame(np.zeros((1, 2)), columns=['f1', 'f2'], index=ix)\n    mod_f_12 = varmax.VARMAX(endog, order=(1, 0), trend='n')\n    params = [0.5, 0.1, -0.2, 0.9, 1.0, 0, 1.0]\n    f_12 = mod_f_12.simulate(params, nobs)\n    endog = pd.Series([0], name='f3', index=ix)\n    mod_f_3 = sarimax.SARIMAX(endog, order=(2, 0, 0))\n    params = [0.7, 0.1, 1.0]\n    f_3 = mod_f_3.simulate(params, nobs)\n    f = pd.concat([f_12, f_3], axis=1)\n    k_endog = 8\n    design = np.zeros((k_endog, 3))\n    design[0] = [1.0, 1.0, 1.0]\n    design[1] = [0.5, -0.8, 0.0]\n    design[2] = [1.0, 0.0, 0.0]\n    design[3] = [0.2, 0.0, -0.1]\n    design[4] = [0.5, 0.0, 0.0]\n    design[5] = [-0.2, 0.0, 0.0]\n    design[6] = [1.0, 1.0, 1.0]\n    design[7] = [-1.0, 0.0, 0.0]\n    rho = np.array([0.5, 0.2, -0.1, 0.0, 0.4, 0.9, 0.05, 0.05])\n    if not idiosyncratic_ar1:\n        rho *= 0.0\n    eps = [lfilter([1], [1, -rho[i]], np.random.normal(size=nobs)) for i in range(k_endog)]\n    endog = (design @ f.T).T + eps\n    endog.columns = [f'y{i + 1}' for i in range(k_endog)]\n    tmp1 = design.ravel()\n    tmp2 = np.linalg.cholesky(mod_f_12['state_cov'])\n    tmp3 = rho if idiosyncratic_ar1 else []\n    true = np.r_[tmp1[tmp1 != 0], mod_f_12['transition', :2, :].ravel(), mod_f_3['transition', :, 0], tmp2[np.tril_indices_from(tmp2)], mod_f_3['state_cov', 0, 0], tmp3, [1] * k_endog]\n    ix = pd.period_range(endog.index[0] - 1, endog.index[-1], freq='M')\n    levels_M = 1 + endog.reindex(ix) / 100\n    levels_M.iloc[0] = 100\n    levels_M = levels_M.cumprod()\n    log_levels_M = np.log(levels_M) * 100\n    log_levels_Q = np.log(levels_M).resample('Q', convention='e').sum().iloc[:-1] * 100\n    endog_M = log_levels_M.iloc[:, :7].diff().iloc[1:]\n    endog_Q = log_levels_Q.iloc[:, 7:].diff().iloc[2:]\n    factor_names = np.array(['global', 'second', 'third'])\n    factors = {endog.columns[i]: factor_names[design[i] != 0] for i in range(k_endog)}\n    factor_orders = {('global', 'second'): 1, 'third': 2}\n    return (endog_M, endog_Q, log_levels_M, log_levels_Q, factors, factor_orders, true, f)",
            "def simulate_k_factors3_blocks2(nobs=1000, idiosyncratic_ar1=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ix = pd.period_range(start='2000-01', periods=1, freq='M')\n    endog = pd.DataFrame(np.zeros((1, 2)), columns=['f1', 'f2'], index=ix)\n    mod_f_12 = varmax.VARMAX(endog, order=(1, 0), trend='n')\n    params = [0.5, 0.1, -0.2, 0.9, 1.0, 0, 1.0]\n    f_12 = mod_f_12.simulate(params, nobs)\n    endog = pd.Series([0], name='f3', index=ix)\n    mod_f_3 = sarimax.SARIMAX(endog, order=(2, 0, 0))\n    params = [0.7, 0.1, 1.0]\n    f_3 = mod_f_3.simulate(params, nobs)\n    f = pd.concat([f_12, f_3], axis=1)\n    k_endog = 8\n    design = np.zeros((k_endog, 3))\n    design[0] = [1.0, 1.0, 1.0]\n    design[1] = [0.5, -0.8, 0.0]\n    design[2] = [1.0, 0.0, 0.0]\n    design[3] = [0.2, 0.0, -0.1]\n    design[4] = [0.5, 0.0, 0.0]\n    design[5] = [-0.2, 0.0, 0.0]\n    design[6] = [1.0, 1.0, 1.0]\n    design[7] = [-1.0, 0.0, 0.0]\n    rho = np.array([0.5, 0.2, -0.1, 0.0, 0.4, 0.9, 0.05, 0.05])\n    if not idiosyncratic_ar1:\n        rho *= 0.0\n    eps = [lfilter([1], [1, -rho[i]], np.random.normal(size=nobs)) for i in range(k_endog)]\n    endog = (design @ f.T).T + eps\n    endog.columns = [f'y{i + 1}' for i in range(k_endog)]\n    tmp1 = design.ravel()\n    tmp2 = np.linalg.cholesky(mod_f_12['state_cov'])\n    tmp3 = rho if idiosyncratic_ar1 else []\n    true = np.r_[tmp1[tmp1 != 0], mod_f_12['transition', :2, :].ravel(), mod_f_3['transition', :, 0], tmp2[np.tril_indices_from(tmp2)], mod_f_3['state_cov', 0, 0], tmp3, [1] * k_endog]\n    ix = pd.period_range(endog.index[0] - 1, endog.index[-1], freq='M')\n    levels_M = 1 + endog.reindex(ix) / 100\n    levels_M.iloc[0] = 100\n    levels_M = levels_M.cumprod()\n    log_levels_M = np.log(levels_M) * 100\n    log_levels_Q = np.log(levels_M).resample('Q', convention='e').sum().iloc[:-1] * 100\n    endog_M = log_levels_M.iloc[:, :7].diff().iloc[1:]\n    endog_Q = log_levels_Q.iloc[:, 7:].diff().iloc[2:]\n    factor_names = np.array(['global', 'second', 'third'])\n    factors = {endog.columns[i]: factor_names[design[i] != 0] for i in range(k_endog)}\n    factor_orders = {('global', 'second'): 1, 'third': 2}\n    return (endog_M, endog_Q, log_levels_M, log_levels_Q, factors, factor_orders, true, f)",
            "def simulate_k_factors3_blocks2(nobs=1000, idiosyncratic_ar1=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ix = pd.period_range(start='2000-01', periods=1, freq='M')\n    endog = pd.DataFrame(np.zeros((1, 2)), columns=['f1', 'f2'], index=ix)\n    mod_f_12 = varmax.VARMAX(endog, order=(1, 0), trend='n')\n    params = [0.5, 0.1, -0.2, 0.9, 1.0, 0, 1.0]\n    f_12 = mod_f_12.simulate(params, nobs)\n    endog = pd.Series([0], name='f3', index=ix)\n    mod_f_3 = sarimax.SARIMAX(endog, order=(2, 0, 0))\n    params = [0.7, 0.1, 1.0]\n    f_3 = mod_f_3.simulate(params, nobs)\n    f = pd.concat([f_12, f_3], axis=1)\n    k_endog = 8\n    design = np.zeros((k_endog, 3))\n    design[0] = [1.0, 1.0, 1.0]\n    design[1] = [0.5, -0.8, 0.0]\n    design[2] = [1.0, 0.0, 0.0]\n    design[3] = [0.2, 0.0, -0.1]\n    design[4] = [0.5, 0.0, 0.0]\n    design[5] = [-0.2, 0.0, 0.0]\n    design[6] = [1.0, 1.0, 1.0]\n    design[7] = [-1.0, 0.0, 0.0]\n    rho = np.array([0.5, 0.2, -0.1, 0.0, 0.4, 0.9, 0.05, 0.05])\n    if not idiosyncratic_ar1:\n        rho *= 0.0\n    eps = [lfilter([1], [1, -rho[i]], np.random.normal(size=nobs)) for i in range(k_endog)]\n    endog = (design @ f.T).T + eps\n    endog.columns = [f'y{i + 1}' for i in range(k_endog)]\n    tmp1 = design.ravel()\n    tmp2 = np.linalg.cholesky(mod_f_12['state_cov'])\n    tmp3 = rho if idiosyncratic_ar1 else []\n    true = np.r_[tmp1[tmp1 != 0], mod_f_12['transition', :2, :].ravel(), mod_f_3['transition', :, 0], tmp2[np.tril_indices_from(tmp2)], mod_f_3['state_cov', 0, 0], tmp3, [1] * k_endog]\n    ix = pd.period_range(endog.index[0] - 1, endog.index[-1], freq='M')\n    levels_M = 1 + endog.reindex(ix) / 100\n    levels_M.iloc[0] = 100\n    levels_M = levels_M.cumprod()\n    log_levels_M = np.log(levels_M) * 100\n    log_levels_Q = np.log(levels_M).resample('Q', convention='e').sum().iloc[:-1] * 100\n    endog_M = log_levels_M.iloc[:, :7].diff().iloc[1:]\n    endog_Q = log_levels_Q.iloc[:, 7:].diff().iloc[2:]\n    factor_names = np.array(['global', 'second', 'third'])\n    factors = {endog.columns[i]: factor_names[design[i] != 0] for i in range(k_endog)}\n    factor_orders = {('global', 'second'): 1, 'third': 2}\n    return (endog_M, endog_Q, log_levels_M, log_levels_Q, factors, factor_orders, true, f)"
        ]
    },
    {
        "func_name": "test_k_factor1",
        "original": "@pytest.mark.skip(reason='Monte carlo test, very slow, kept for manual runs')\ndef test_k_factor1(reset_randomstate):\n    np.random.seed(1234)\n    (endog_M, endog_Q, _, _, true_params, _) = simulate_k_factor1(nobs=100000)\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M, endog_quarterly=endog_Q, factors=1, factor_orders=1, idiosyncratic_ar1=False)\n    with mod.fix_params({'fb(0).cov.chol[1,1]': 1.0}):\n        mod.fit(method='lbfgs', disp=False)",
        "mutated": [
            "@pytest.mark.skip(reason='Monte carlo test, very slow, kept for manual runs')\ndef test_k_factor1(reset_randomstate):\n    if False:\n        i = 10\n    np.random.seed(1234)\n    (endog_M, endog_Q, _, _, true_params, _) = simulate_k_factor1(nobs=100000)\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M, endog_quarterly=endog_Q, factors=1, factor_orders=1, idiosyncratic_ar1=False)\n    with mod.fix_params({'fb(0).cov.chol[1,1]': 1.0}):\n        mod.fit(method='lbfgs', disp=False)",
            "@pytest.mark.skip(reason='Monte carlo test, very slow, kept for manual runs')\ndef test_k_factor1(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    np.random.seed(1234)\n    (endog_M, endog_Q, _, _, true_params, _) = simulate_k_factor1(nobs=100000)\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M, endog_quarterly=endog_Q, factors=1, factor_orders=1, idiosyncratic_ar1=False)\n    with mod.fix_params({'fb(0).cov.chol[1,1]': 1.0}):\n        mod.fit(method='lbfgs', disp=False)",
            "@pytest.mark.skip(reason='Monte carlo test, very slow, kept for manual runs')\ndef test_k_factor1(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    np.random.seed(1234)\n    (endog_M, endog_Q, _, _, true_params, _) = simulate_k_factor1(nobs=100000)\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M, endog_quarterly=endog_Q, factors=1, factor_orders=1, idiosyncratic_ar1=False)\n    with mod.fix_params({'fb(0).cov.chol[1,1]': 1.0}):\n        mod.fit(method='lbfgs', disp=False)",
            "@pytest.mark.skip(reason='Monte carlo test, very slow, kept for manual runs')\ndef test_k_factor1(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    np.random.seed(1234)\n    (endog_M, endog_Q, _, _, true_params, _) = simulate_k_factor1(nobs=100000)\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M, endog_quarterly=endog_Q, factors=1, factor_orders=1, idiosyncratic_ar1=False)\n    with mod.fix_params({'fb(0).cov.chol[1,1]': 1.0}):\n        mod.fit(method='lbfgs', disp=False)",
            "@pytest.mark.skip(reason='Monte carlo test, very slow, kept for manual runs')\ndef test_k_factor1(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    np.random.seed(1234)\n    (endog_M, endog_Q, _, _, true_params, _) = simulate_k_factor1(nobs=100000)\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M, endog_quarterly=endog_Q, factors=1, factor_orders=1, idiosyncratic_ar1=False)\n    with mod.fix_params({'fb(0).cov.chol[1,1]': 1.0}):\n        mod.fit(method='lbfgs', disp=False)"
        ]
    },
    {
        "func_name": "gen_k_factor1_nonstationary",
        "original": "def gen_k_factor1_nonstationary(nobs=1000, k=1, idiosyncratic_ar1=False, idiosyncratic_var=0.4, k_ar=1):\n    ix = pd.period_range(start='1950-01', periods=1, freq='M')\n    faux = pd.Series([0], index=ix)\n    mod = sarimax.SARIMAX(faux, order=(k_ar, 0, 0), initialization='diffuse')\n    params = np.r_[[0] * (k_ar - 1), [1.0001], 1.0]\n    factor = mod.simulate(params, nobs)\n    if idiosyncratic_ar1:\n        mod_idio = sarimax.SARIMAX(faux, order=(1, 0, 0))\n        endog = pd.concat([factor + mod_idio.simulate([0.7, idiosyncratic_var], nobs) for i in range(2 * k)], axis=1)\n    else:\n        endog = pd.concat([factor + np.random.normal(scale=idiosyncratic_var ** 0.5, size=nobs) for i in range(2 * k)], axis=1)\n    levels_M = 1 + endog / 100\n    levels_M.iloc[0] = 100\n    levels_M = levels_M.cumprod()\n    log_levels_M = np.log(levels_M) * 100\n    log_levels_Q = np.log(levels_M).resample('Q', convention='e').sum().iloc[:-1] * 100\n    endog_M = log_levels_M.diff().iloc[1:, :k]\n    if k > 1:\n        endog_M.columns = ['yM%d_f1' % (i + 1) for i in range(k)]\n    else:\n        endog_M.columns = ['yM_f1']\n    endog_Q = log_levels_Q.diff().iloc[1:, k:]\n    if k > 1:\n        endog_Q.columns = ['yQ%d_f1' % (i + 1) for i in range(k)]\n    else:\n        endog_Q.columns = ['yQ_f1']\n    return (endog_M, endog_Q, factor)",
        "mutated": [
            "def gen_k_factor1_nonstationary(nobs=1000, k=1, idiosyncratic_ar1=False, idiosyncratic_var=0.4, k_ar=1):\n    if False:\n        i = 10\n    ix = pd.period_range(start='1950-01', periods=1, freq='M')\n    faux = pd.Series([0], index=ix)\n    mod = sarimax.SARIMAX(faux, order=(k_ar, 0, 0), initialization='diffuse')\n    params = np.r_[[0] * (k_ar - 1), [1.0001], 1.0]\n    factor = mod.simulate(params, nobs)\n    if idiosyncratic_ar1:\n        mod_idio = sarimax.SARIMAX(faux, order=(1, 0, 0))\n        endog = pd.concat([factor + mod_idio.simulate([0.7, idiosyncratic_var], nobs) for i in range(2 * k)], axis=1)\n    else:\n        endog = pd.concat([factor + np.random.normal(scale=idiosyncratic_var ** 0.5, size=nobs) for i in range(2 * k)], axis=1)\n    levels_M = 1 + endog / 100\n    levels_M.iloc[0] = 100\n    levels_M = levels_M.cumprod()\n    log_levels_M = np.log(levels_M) * 100\n    log_levels_Q = np.log(levels_M).resample('Q', convention='e').sum().iloc[:-1] * 100\n    endog_M = log_levels_M.diff().iloc[1:, :k]\n    if k > 1:\n        endog_M.columns = ['yM%d_f1' % (i + 1) for i in range(k)]\n    else:\n        endog_M.columns = ['yM_f1']\n    endog_Q = log_levels_Q.diff().iloc[1:, k:]\n    if k > 1:\n        endog_Q.columns = ['yQ%d_f1' % (i + 1) for i in range(k)]\n    else:\n        endog_Q.columns = ['yQ_f1']\n    return (endog_M, endog_Q, factor)",
            "def gen_k_factor1_nonstationary(nobs=1000, k=1, idiosyncratic_ar1=False, idiosyncratic_var=0.4, k_ar=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ix = pd.period_range(start='1950-01', periods=1, freq='M')\n    faux = pd.Series([0], index=ix)\n    mod = sarimax.SARIMAX(faux, order=(k_ar, 0, 0), initialization='diffuse')\n    params = np.r_[[0] * (k_ar - 1), [1.0001], 1.0]\n    factor = mod.simulate(params, nobs)\n    if idiosyncratic_ar1:\n        mod_idio = sarimax.SARIMAX(faux, order=(1, 0, 0))\n        endog = pd.concat([factor + mod_idio.simulate([0.7, idiosyncratic_var], nobs) for i in range(2 * k)], axis=1)\n    else:\n        endog = pd.concat([factor + np.random.normal(scale=idiosyncratic_var ** 0.5, size=nobs) for i in range(2 * k)], axis=1)\n    levels_M = 1 + endog / 100\n    levels_M.iloc[0] = 100\n    levels_M = levels_M.cumprod()\n    log_levels_M = np.log(levels_M) * 100\n    log_levels_Q = np.log(levels_M).resample('Q', convention='e').sum().iloc[:-1] * 100\n    endog_M = log_levels_M.diff().iloc[1:, :k]\n    if k > 1:\n        endog_M.columns = ['yM%d_f1' % (i + 1) for i in range(k)]\n    else:\n        endog_M.columns = ['yM_f1']\n    endog_Q = log_levels_Q.diff().iloc[1:, k:]\n    if k > 1:\n        endog_Q.columns = ['yQ%d_f1' % (i + 1) for i in range(k)]\n    else:\n        endog_Q.columns = ['yQ_f1']\n    return (endog_M, endog_Q, factor)",
            "def gen_k_factor1_nonstationary(nobs=1000, k=1, idiosyncratic_ar1=False, idiosyncratic_var=0.4, k_ar=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ix = pd.period_range(start='1950-01', periods=1, freq='M')\n    faux = pd.Series([0], index=ix)\n    mod = sarimax.SARIMAX(faux, order=(k_ar, 0, 0), initialization='diffuse')\n    params = np.r_[[0] * (k_ar - 1), [1.0001], 1.0]\n    factor = mod.simulate(params, nobs)\n    if idiosyncratic_ar1:\n        mod_idio = sarimax.SARIMAX(faux, order=(1, 0, 0))\n        endog = pd.concat([factor + mod_idio.simulate([0.7, idiosyncratic_var], nobs) for i in range(2 * k)], axis=1)\n    else:\n        endog = pd.concat([factor + np.random.normal(scale=idiosyncratic_var ** 0.5, size=nobs) for i in range(2 * k)], axis=1)\n    levels_M = 1 + endog / 100\n    levels_M.iloc[0] = 100\n    levels_M = levels_M.cumprod()\n    log_levels_M = np.log(levels_M) * 100\n    log_levels_Q = np.log(levels_M).resample('Q', convention='e').sum().iloc[:-1] * 100\n    endog_M = log_levels_M.diff().iloc[1:, :k]\n    if k > 1:\n        endog_M.columns = ['yM%d_f1' % (i + 1) for i in range(k)]\n    else:\n        endog_M.columns = ['yM_f1']\n    endog_Q = log_levels_Q.diff().iloc[1:, k:]\n    if k > 1:\n        endog_Q.columns = ['yQ%d_f1' % (i + 1) for i in range(k)]\n    else:\n        endog_Q.columns = ['yQ_f1']\n    return (endog_M, endog_Q, factor)",
            "def gen_k_factor1_nonstationary(nobs=1000, k=1, idiosyncratic_ar1=False, idiosyncratic_var=0.4, k_ar=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ix = pd.period_range(start='1950-01', periods=1, freq='M')\n    faux = pd.Series([0], index=ix)\n    mod = sarimax.SARIMAX(faux, order=(k_ar, 0, 0), initialization='diffuse')\n    params = np.r_[[0] * (k_ar - 1), [1.0001], 1.0]\n    factor = mod.simulate(params, nobs)\n    if idiosyncratic_ar1:\n        mod_idio = sarimax.SARIMAX(faux, order=(1, 0, 0))\n        endog = pd.concat([factor + mod_idio.simulate([0.7, idiosyncratic_var], nobs) for i in range(2 * k)], axis=1)\n    else:\n        endog = pd.concat([factor + np.random.normal(scale=idiosyncratic_var ** 0.5, size=nobs) for i in range(2 * k)], axis=1)\n    levels_M = 1 + endog / 100\n    levels_M.iloc[0] = 100\n    levels_M = levels_M.cumprod()\n    log_levels_M = np.log(levels_M) * 100\n    log_levels_Q = np.log(levels_M).resample('Q', convention='e').sum().iloc[:-1] * 100\n    endog_M = log_levels_M.diff().iloc[1:, :k]\n    if k > 1:\n        endog_M.columns = ['yM%d_f1' % (i + 1) for i in range(k)]\n    else:\n        endog_M.columns = ['yM_f1']\n    endog_Q = log_levels_Q.diff().iloc[1:, k:]\n    if k > 1:\n        endog_Q.columns = ['yQ%d_f1' % (i + 1) for i in range(k)]\n    else:\n        endog_Q.columns = ['yQ_f1']\n    return (endog_M, endog_Q, factor)",
            "def gen_k_factor1_nonstationary(nobs=1000, k=1, idiosyncratic_ar1=False, idiosyncratic_var=0.4, k_ar=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ix = pd.period_range(start='1950-01', periods=1, freq='M')\n    faux = pd.Series([0], index=ix)\n    mod = sarimax.SARIMAX(faux, order=(k_ar, 0, 0), initialization='diffuse')\n    params = np.r_[[0] * (k_ar - 1), [1.0001], 1.0]\n    factor = mod.simulate(params, nobs)\n    if idiosyncratic_ar1:\n        mod_idio = sarimax.SARIMAX(faux, order=(1, 0, 0))\n        endog = pd.concat([factor + mod_idio.simulate([0.7, idiosyncratic_var], nobs) for i in range(2 * k)], axis=1)\n    else:\n        endog = pd.concat([factor + np.random.normal(scale=idiosyncratic_var ** 0.5, size=nobs) for i in range(2 * k)], axis=1)\n    levels_M = 1 + endog / 100\n    levels_M.iloc[0] = 100\n    levels_M = levels_M.cumprod()\n    log_levels_M = np.log(levels_M) * 100\n    log_levels_Q = np.log(levels_M).resample('Q', convention='e').sum().iloc[:-1] * 100\n    endog_M = log_levels_M.diff().iloc[1:, :k]\n    if k > 1:\n        endog_M.columns = ['yM%d_f1' % (i + 1) for i in range(k)]\n    else:\n        endog_M.columns = ['yM_f1']\n    endog_Q = log_levels_Q.diff().iloc[1:, k:]\n    if k > 1:\n        endog_Q.columns = ['yQ%d_f1' % (i + 1) for i in range(k)]\n    else:\n        endog_Q.columns = ['yQ_f1']\n    return (endog_M, endog_Q, factor)"
        ]
    },
    {
        "func_name": "test_em_nonstationary",
        "original": "def test_em_nonstationary(reset_randomstate):\n    ix = pd.period_range(start='2000', periods=20, freq='M')\n    endog_M = pd.Series(np.arange(20), index=ix, dtype=float)\n    endog_M.iloc[10:12] += [0.4, -0.2]\n    ix = pd.period_range(start='2000', periods=5, freq='Q')\n    endog_Q = pd.Series(np.arange(5), index=ix)\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M, endog_quarterly=endog_Q, idiosyncratic_ar1=False, standardize=False, factors=['global'])\n    msg = 'Non-stationary parameters found at EM iteration 1, which is not compatible with stationary initialization. Initialization was switched to diffuse for the following:  \\\\[\"factor block: \\\\(\\\\\\'global\\\\\\',\\\\)\"\\\\], and fitting was restarted.'\n    with pytest.warns(UserWarning, match=msg):\n        mod.fit(maxiter=2, em_initialization=False)",
        "mutated": [
            "def test_em_nonstationary(reset_randomstate):\n    if False:\n        i = 10\n    ix = pd.period_range(start='2000', periods=20, freq='M')\n    endog_M = pd.Series(np.arange(20), index=ix, dtype=float)\n    endog_M.iloc[10:12] += [0.4, -0.2]\n    ix = pd.period_range(start='2000', periods=5, freq='Q')\n    endog_Q = pd.Series(np.arange(5), index=ix)\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M, endog_quarterly=endog_Q, idiosyncratic_ar1=False, standardize=False, factors=['global'])\n    msg = 'Non-stationary parameters found at EM iteration 1, which is not compatible with stationary initialization. Initialization was switched to diffuse for the following:  \\\\[\"factor block: \\\\(\\\\\\'global\\\\\\',\\\\)\"\\\\], and fitting was restarted.'\n    with pytest.warns(UserWarning, match=msg):\n        mod.fit(maxiter=2, em_initialization=False)",
            "def test_em_nonstationary(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ix = pd.period_range(start='2000', periods=20, freq='M')\n    endog_M = pd.Series(np.arange(20), index=ix, dtype=float)\n    endog_M.iloc[10:12] += [0.4, -0.2]\n    ix = pd.period_range(start='2000', periods=5, freq='Q')\n    endog_Q = pd.Series(np.arange(5), index=ix)\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M, endog_quarterly=endog_Q, idiosyncratic_ar1=False, standardize=False, factors=['global'])\n    msg = 'Non-stationary parameters found at EM iteration 1, which is not compatible with stationary initialization. Initialization was switched to diffuse for the following:  \\\\[\"factor block: \\\\(\\\\\\'global\\\\\\',\\\\)\"\\\\], and fitting was restarted.'\n    with pytest.warns(UserWarning, match=msg):\n        mod.fit(maxiter=2, em_initialization=False)",
            "def test_em_nonstationary(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ix = pd.period_range(start='2000', periods=20, freq='M')\n    endog_M = pd.Series(np.arange(20), index=ix, dtype=float)\n    endog_M.iloc[10:12] += [0.4, -0.2]\n    ix = pd.period_range(start='2000', periods=5, freq='Q')\n    endog_Q = pd.Series(np.arange(5), index=ix)\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M, endog_quarterly=endog_Q, idiosyncratic_ar1=False, standardize=False, factors=['global'])\n    msg = 'Non-stationary parameters found at EM iteration 1, which is not compatible with stationary initialization. Initialization was switched to diffuse for the following:  \\\\[\"factor block: \\\\(\\\\\\'global\\\\\\',\\\\)\"\\\\], and fitting was restarted.'\n    with pytest.warns(UserWarning, match=msg):\n        mod.fit(maxiter=2, em_initialization=False)",
            "def test_em_nonstationary(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ix = pd.period_range(start='2000', periods=20, freq='M')\n    endog_M = pd.Series(np.arange(20), index=ix, dtype=float)\n    endog_M.iloc[10:12] += [0.4, -0.2]\n    ix = pd.period_range(start='2000', periods=5, freq='Q')\n    endog_Q = pd.Series(np.arange(5), index=ix)\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M, endog_quarterly=endog_Q, idiosyncratic_ar1=False, standardize=False, factors=['global'])\n    msg = 'Non-stationary parameters found at EM iteration 1, which is not compatible with stationary initialization. Initialization was switched to diffuse for the following:  \\\\[\"factor block: \\\\(\\\\\\'global\\\\\\',\\\\)\"\\\\], and fitting was restarted.'\n    with pytest.warns(UserWarning, match=msg):\n        mod.fit(maxiter=2, em_initialization=False)",
            "def test_em_nonstationary(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ix = pd.period_range(start='2000', periods=20, freq='M')\n    endog_M = pd.Series(np.arange(20), index=ix, dtype=float)\n    endog_M.iloc[10:12] += [0.4, -0.2]\n    ix = pd.period_range(start='2000', periods=5, freq='Q')\n    endog_Q = pd.Series(np.arange(5), index=ix)\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M, endog_quarterly=endog_Q, idiosyncratic_ar1=False, standardize=False, factors=['global'])\n    msg = 'Non-stationary parameters found at EM iteration 1, which is not compatible with stationary initialization. Initialization was switched to diffuse for the following:  \\\\[\"factor block: \\\\(\\\\\\'global\\\\\\',\\\\)\"\\\\], and fitting was restarted.'\n    with pytest.warns(UserWarning, match=msg):\n        mod.fit(maxiter=2, em_initialization=False)"
        ]
    },
    {
        "func_name": "gen_k_factor1",
        "original": "def gen_k_factor1(nobs=10000, k=1, idiosyncratic_ar1=False, idiosyncratic_var=0.4, k_ar=6):\n    ix = pd.period_range(start='1950-01', periods=1, freq='M')\n    faux = pd.Series([0], index=ix)\n    mod = sarimax.SARIMAX(faux, order=(k_ar, 0, 0))\n    params = np.r_[[0] * (k_ar - 1), [0.5], 1.0]\n    factor = mod.simulate(params, nobs)\n    if idiosyncratic_ar1:\n        mod_idio = sarimax.SARIMAX(faux, order=(1, 0, 0))\n        endog = pd.concat([factor + mod_idio.simulate([0.7, idiosyncratic_var], nobs) for i in range(2 * k)], axis=1)\n    else:\n        endog = pd.concat([factor + np.random.normal(scale=idiosyncratic_var ** 0.5, size=nobs) for i in range(2 * k)], axis=1)\n    levels_M = 1 + endog / 100\n    levels_M.iloc[0] = 100\n    levels_M = levels_M.cumprod()\n    log_levels_M = np.log(levels_M) * 100\n    log_levels_Q = np.log(levels_M).resample('Q', convention='e').sum().iloc[:-1] * 100\n    endog_M = log_levels_M.diff().iloc[1:, :k]\n    if k > 1:\n        endog_M.columns = ['yM%d_f1' % (i + 1) for i in range(k)]\n    else:\n        endog_M.columns = ['yM_f1']\n    endog_Q = log_levels_Q.diff().iloc[1:, k:]\n    if k > 1:\n        endog_Q.columns = ['yQ%d_f1' % (i + 1) for i in range(k)]\n    else:\n        endog_Q.columns = ['yQ_f1']\n    return (endog_M, endog_Q, factor)",
        "mutated": [
            "def gen_k_factor1(nobs=10000, k=1, idiosyncratic_ar1=False, idiosyncratic_var=0.4, k_ar=6):\n    if False:\n        i = 10\n    ix = pd.period_range(start='1950-01', periods=1, freq='M')\n    faux = pd.Series([0], index=ix)\n    mod = sarimax.SARIMAX(faux, order=(k_ar, 0, 0))\n    params = np.r_[[0] * (k_ar - 1), [0.5], 1.0]\n    factor = mod.simulate(params, nobs)\n    if idiosyncratic_ar1:\n        mod_idio = sarimax.SARIMAX(faux, order=(1, 0, 0))\n        endog = pd.concat([factor + mod_idio.simulate([0.7, idiosyncratic_var], nobs) for i in range(2 * k)], axis=1)\n    else:\n        endog = pd.concat([factor + np.random.normal(scale=idiosyncratic_var ** 0.5, size=nobs) for i in range(2 * k)], axis=1)\n    levels_M = 1 + endog / 100\n    levels_M.iloc[0] = 100\n    levels_M = levels_M.cumprod()\n    log_levels_M = np.log(levels_M) * 100\n    log_levels_Q = np.log(levels_M).resample('Q', convention='e').sum().iloc[:-1] * 100\n    endog_M = log_levels_M.diff().iloc[1:, :k]\n    if k > 1:\n        endog_M.columns = ['yM%d_f1' % (i + 1) for i in range(k)]\n    else:\n        endog_M.columns = ['yM_f1']\n    endog_Q = log_levels_Q.diff().iloc[1:, k:]\n    if k > 1:\n        endog_Q.columns = ['yQ%d_f1' % (i + 1) for i in range(k)]\n    else:\n        endog_Q.columns = ['yQ_f1']\n    return (endog_M, endog_Q, factor)",
            "def gen_k_factor1(nobs=10000, k=1, idiosyncratic_ar1=False, idiosyncratic_var=0.4, k_ar=6):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ix = pd.period_range(start='1950-01', periods=1, freq='M')\n    faux = pd.Series([0], index=ix)\n    mod = sarimax.SARIMAX(faux, order=(k_ar, 0, 0))\n    params = np.r_[[0] * (k_ar - 1), [0.5], 1.0]\n    factor = mod.simulate(params, nobs)\n    if idiosyncratic_ar1:\n        mod_idio = sarimax.SARIMAX(faux, order=(1, 0, 0))\n        endog = pd.concat([factor + mod_idio.simulate([0.7, idiosyncratic_var], nobs) for i in range(2 * k)], axis=1)\n    else:\n        endog = pd.concat([factor + np.random.normal(scale=idiosyncratic_var ** 0.5, size=nobs) for i in range(2 * k)], axis=1)\n    levels_M = 1 + endog / 100\n    levels_M.iloc[0] = 100\n    levels_M = levels_M.cumprod()\n    log_levels_M = np.log(levels_M) * 100\n    log_levels_Q = np.log(levels_M).resample('Q', convention='e').sum().iloc[:-1] * 100\n    endog_M = log_levels_M.diff().iloc[1:, :k]\n    if k > 1:\n        endog_M.columns = ['yM%d_f1' % (i + 1) for i in range(k)]\n    else:\n        endog_M.columns = ['yM_f1']\n    endog_Q = log_levels_Q.diff().iloc[1:, k:]\n    if k > 1:\n        endog_Q.columns = ['yQ%d_f1' % (i + 1) for i in range(k)]\n    else:\n        endog_Q.columns = ['yQ_f1']\n    return (endog_M, endog_Q, factor)",
            "def gen_k_factor1(nobs=10000, k=1, idiosyncratic_ar1=False, idiosyncratic_var=0.4, k_ar=6):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ix = pd.period_range(start='1950-01', periods=1, freq='M')\n    faux = pd.Series([0], index=ix)\n    mod = sarimax.SARIMAX(faux, order=(k_ar, 0, 0))\n    params = np.r_[[0] * (k_ar - 1), [0.5], 1.0]\n    factor = mod.simulate(params, nobs)\n    if idiosyncratic_ar1:\n        mod_idio = sarimax.SARIMAX(faux, order=(1, 0, 0))\n        endog = pd.concat([factor + mod_idio.simulate([0.7, idiosyncratic_var], nobs) for i in range(2 * k)], axis=1)\n    else:\n        endog = pd.concat([factor + np.random.normal(scale=idiosyncratic_var ** 0.5, size=nobs) for i in range(2 * k)], axis=1)\n    levels_M = 1 + endog / 100\n    levels_M.iloc[0] = 100\n    levels_M = levels_M.cumprod()\n    log_levels_M = np.log(levels_M) * 100\n    log_levels_Q = np.log(levels_M).resample('Q', convention='e').sum().iloc[:-1] * 100\n    endog_M = log_levels_M.diff().iloc[1:, :k]\n    if k > 1:\n        endog_M.columns = ['yM%d_f1' % (i + 1) for i in range(k)]\n    else:\n        endog_M.columns = ['yM_f1']\n    endog_Q = log_levels_Q.diff().iloc[1:, k:]\n    if k > 1:\n        endog_Q.columns = ['yQ%d_f1' % (i + 1) for i in range(k)]\n    else:\n        endog_Q.columns = ['yQ_f1']\n    return (endog_M, endog_Q, factor)",
            "def gen_k_factor1(nobs=10000, k=1, idiosyncratic_ar1=False, idiosyncratic_var=0.4, k_ar=6):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ix = pd.period_range(start='1950-01', periods=1, freq='M')\n    faux = pd.Series([0], index=ix)\n    mod = sarimax.SARIMAX(faux, order=(k_ar, 0, 0))\n    params = np.r_[[0] * (k_ar - 1), [0.5], 1.0]\n    factor = mod.simulate(params, nobs)\n    if idiosyncratic_ar1:\n        mod_idio = sarimax.SARIMAX(faux, order=(1, 0, 0))\n        endog = pd.concat([factor + mod_idio.simulate([0.7, idiosyncratic_var], nobs) for i in range(2 * k)], axis=1)\n    else:\n        endog = pd.concat([factor + np.random.normal(scale=idiosyncratic_var ** 0.5, size=nobs) for i in range(2 * k)], axis=1)\n    levels_M = 1 + endog / 100\n    levels_M.iloc[0] = 100\n    levels_M = levels_M.cumprod()\n    log_levels_M = np.log(levels_M) * 100\n    log_levels_Q = np.log(levels_M).resample('Q', convention='e').sum().iloc[:-1] * 100\n    endog_M = log_levels_M.diff().iloc[1:, :k]\n    if k > 1:\n        endog_M.columns = ['yM%d_f1' % (i + 1) for i in range(k)]\n    else:\n        endog_M.columns = ['yM_f1']\n    endog_Q = log_levels_Q.diff().iloc[1:, k:]\n    if k > 1:\n        endog_Q.columns = ['yQ%d_f1' % (i + 1) for i in range(k)]\n    else:\n        endog_Q.columns = ['yQ_f1']\n    return (endog_M, endog_Q, factor)",
            "def gen_k_factor1(nobs=10000, k=1, idiosyncratic_ar1=False, idiosyncratic_var=0.4, k_ar=6):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ix = pd.period_range(start='1950-01', periods=1, freq='M')\n    faux = pd.Series([0], index=ix)\n    mod = sarimax.SARIMAX(faux, order=(k_ar, 0, 0))\n    params = np.r_[[0] * (k_ar - 1), [0.5], 1.0]\n    factor = mod.simulate(params, nobs)\n    if idiosyncratic_ar1:\n        mod_idio = sarimax.SARIMAX(faux, order=(1, 0, 0))\n        endog = pd.concat([factor + mod_idio.simulate([0.7, idiosyncratic_var], nobs) for i in range(2 * k)], axis=1)\n    else:\n        endog = pd.concat([factor + np.random.normal(scale=idiosyncratic_var ** 0.5, size=nobs) for i in range(2 * k)], axis=1)\n    levels_M = 1 + endog / 100\n    levels_M.iloc[0] = 100\n    levels_M = levels_M.cumprod()\n    log_levels_M = np.log(levels_M) * 100\n    log_levels_Q = np.log(levels_M).resample('Q', convention='e').sum().iloc[:-1] * 100\n    endog_M = log_levels_M.diff().iloc[1:, :k]\n    if k > 1:\n        endog_M.columns = ['yM%d_f1' % (i + 1) for i in range(k)]\n    else:\n        endog_M.columns = ['yM_f1']\n    endog_Q = log_levels_Q.diff().iloc[1:, k:]\n    if k > 1:\n        endog_Q.columns = ['yQ%d_f1' % (i + 1) for i in range(k)]\n    else:\n        endog_Q.columns = ['yQ_f1']\n    return (endog_M, endog_Q, factor)"
        ]
    },
    {
        "func_name": "test_k_factor1_factor_order_6",
        "original": "@pytest.mark.filterwarnings('ignore:Log-likelihood decreased')\ndef test_k_factor1_factor_order_6(reset_randomstate):\n    (endog_M, endog_Q, _) = gen_k_factor1(nobs=100, idiosyncratic_var=0.0)\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M, endog_quarterly=endog_Q, factor_orders=6, idiosyncratic_ar1=False, standardize=False)\n    mod.fit()",
        "mutated": [
            "@pytest.mark.filterwarnings('ignore:Log-likelihood decreased')\ndef test_k_factor1_factor_order_6(reset_randomstate):\n    if False:\n        i = 10\n    (endog_M, endog_Q, _) = gen_k_factor1(nobs=100, idiosyncratic_var=0.0)\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M, endog_quarterly=endog_Q, factor_orders=6, idiosyncratic_ar1=False, standardize=False)\n    mod.fit()",
            "@pytest.mark.filterwarnings('ignore:Log-likelihood decreased')\ndef test_k_factor1_factor_order_6(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (endog_M, endog_Q, _) = gen_k_factor1(nobs=100, idiosyncratic_var=0.0)\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M, endog_quarterly=endog_Q, factor_orders=6, idiosyncratic_ar1=False, standardize=False)\n    mod.fit()",
            "@pytest.mark.filterwarnings('ignore:Log-likelihood decreased')\ndef test_k_factor1_factor_order_6(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (endog_M, endog_Q, _) = gen_k_factor1(nobs=100, idiosyncratic_var=0.0)\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M, endog_quarterly=endog_Q, factor_orders=6, idiosyncratic_ar1=False, standardize=False)\n    mod.fit()",
            "@pytest.mark.filterwarnings('ignore:Log-likelihood decreased')\ndef test_k_factor1_factor_order_6(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (endog_M, endog_Q, _) = gen_k_factor1(nobs=100, idiosyncratic_var=0.0)\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M, endog_quarterly=endog_Q, factor_orders=6, idiosyncratic_ar1=False, standardize=False)\n    mod.fit()",
            "@pytest.mark.filterwarnings('ignore:Log-likelihood decreased')\ndef test_k_factor1_factor_order_6(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (endog_M, endog_Q, _) = gen_k_factor1(nobs=100, idiosyncratic_var=0.0)\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M, endog_quarterly=endog_Q, factor_orders=6, idiosyncratic_ar1=False, standardize=False)\n    mod.fit()"
        ]
    },
    {
        "func_name": "gen_k_factor2",
        "original": "def gen_k_factor2(nobs=10000, k=2, idiosyncratic_ar1=False, idiosyncratic_var=0.4, k_ar=6):\n    ix = pd.period_range(start='1950-01', periods=1, freq='M')\n    faux = pd.DataFrame([[0, 0]], index=ix, columns=['f1', 'f2'])\n    mod = varmax.VARMAX(faux, order=(k_ar, 0), trend='n')\n    A = np.zeros((2, 2 * k_ar))\n    A[:, -2:] = np.array([[0.5, -0.2], [0.1, 0.3]])\n    Q = np.array([[1.5, 0.2], [0.2, 0.5]])\n    L = np.linalg.cholesky(Q)\n    params = np.r_[A.ravel(), L[np.tril_indices_from(L)]]\n    factors = mod.simulate(params, nobs)\n    faux = pd.Series([0], index=ix)\n    mod_idio = sarimax.SARIMAX(faux, order=(1, 0, 0))\n    phi = [0.7, -0.2] if idiosyncratic_ar1 else [0, 0.0]\n    tmp = factors.iloc[:, 0] + factors.iloc[:, 1]\n    endog_M = pd.concat([tmp.copy() for i in range(k)], axis=1)\n    columns = []\n    for i in range(k):\n        endog_M.iloc[:, i] = endog_M.iloc[:, i] + mod_idio.simulate([phi[0], idiosyncratic_var], nobs)\n        columns += [f'yM{i + 1}_f2']\n    endog_M.columns = columns\n    endog_Q_M = pd.concat([tmp.copy() for i in range(k)], axis=1)\n    columns = []\n    for i in range(k):\n        endog_Q_M.iloc[:, i] = endog_Q_M.iloc[:, i] + mod_idio.simulate([phi[0], idiosyncratic_var], nobs)\n        columns += [f'yQ{i + 1}_f2']\n    endog_Q_M.columns = columns\n    levels_M = 1 + endog_Q_M / 100\n    levels_M.iloc[0] = 100\n    levels_M = levels_M.cumprod()\n    log_levels_Q = np.log(levels_M).resample('Q', convention='e').sum().iloc[:-1] * 100\n    endog_Q = log_levels_Q.diff()\n    return (endog_M, endog_Q, factors)",
        "mutated": [
            "def gen_k_factor2(nobs=10000, k=2, idiosyncratic_ar1=False, idiosyncratic_var=0.4, k_ar=6):\n    if False:\n        i = 10\n    ix = pd.period_range(start='1950-01', periods=1, freq='M')\n    faux = pd.DataFrame([[0, 0]], index=ix, columns=['f1', 'f2'])\n    mod = varmax.VARMAX(faux, order=(k_ar, 0), trend='n')\n    A = np.zeros((2, 2 * k_ar))\n    A[:, -2:] = np.array([[0.5, -0.2], [0.1, 0.3]])\n    Q = np.array([[1.5, 0.2], [0.2, 0.5]])\n    L = np.linalg.cholesky(Q)\n    params = np.r_[A.ravel(), L[np.tril_indices_from(L)]]\n    factors = mod.simulate(params, nobs)\n    faux = pd.Series([0], index=ix)\n    mod_idio = sarimax.SARIMAX(faux, order=(1, 0, 0))\n    phi = [0.7, -0.2] if idiosyncratic_ar1 else [0, 0.0]\n    tmp = factors.iloc[:, 0] + factors.iloc[:, 1]\n    endog_M = pd.concat([tmp.copy() for i in range(k)], axis=1)\n    columns = []\n    for i in range(k):\n        endog_M.iloc[:, i] = endog_M.iloc[:, i] + mod_idio.simulate([phi[0], idiosyncratic_var], nobs)\n        columns += [f'yM{i + 1}_f2']\n    endog_M.columns = columns\n    endog_Q_M = pd.concat([tmp.copy() for i in range(k)], axis=1)\n    columns = []\n    for i in range(k):\n        endog_Q_M.iloc[:, i] = endog_Q_M.iloc[:, i] + mod_idio.simulate([phi[0], idiosyncratic_var], nobs)\n        columns += [f'yQ{i + 1}_f2']\n    endog_Q_M.columns = columns\n    levels_M = 1 + endog_Q_M / 100\n    levels_M.iloc[0] = 100\n    levels_M = levels_M.cumprod()\n    log_levels_Q = np.log(levels_M).resample('Q', convention='e').sum().iloc[:-1] * 100\n    endog_Q = log_levels_Q.diff()\n    return (endog_M, endog_Q, factors)",
            "def gen_k_factor2(nobs=10000, k=2, idiosyncratic_ar1=False, idiosyncratic_var=0.4, k_ar=6):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ix = pd.period_range(start='1950-01', periods=1, freq='M')\n    faux = pd.DataFrame([[0, 0]], index=ix, columns=['f1', 'f2'])\n    mod = varmax.VARMAX(faux, order=(k_ar, 0), trend='n')\n    A = np.zeros((2, 2 * k_ar))\n    A[:, -2:] = np.array([[0.5, -0.2], [0.1, 0.3]])\n    Q = np.array([[1.5, 0.2], [0.2, 0.5]])\n    L = np.linalg.cholesky(Q)\n    params = np.r_[A.ravel(), L[np.tril_indices_from(L)]]\n    factors = mod.simulate(params, nobs)\n    faux = pd.Series([0], index=ix)\n    mod_idio = sarimax.SARIMAX(faux, order=(1, 0, 0))\n    phi = [0.7, -0.2] if idiosyncratic_ar1 else [0, 0.0]\n    tmp = factors.iloc[:, 0] + factors.iloc[:, 1]\n    endog_M = pd.concat([tmp.copy() for i in range(k)], axis=1)\n    columns = []\n    for i in range(k):\n        endog_M.iloc[:, i] = endog_M.iloc[:, i] + mod_idio.simulate([phi[0], idiosyncratic_var], nobs)\n        columns += [f'yM{i + 1}_f2']\n    endog_M.columns = columns\n    endog_Q_M = pd.concat([tmp.copy() for i in range(k)], axis=1)\n    columns = []\n    for i in range(k):\n        endog_Q_M.iloc[:, i] = endog_Q_M.iloc[:, i] + mod_idio.simulate([phi[0], idiosyncratic_var], nobs)\n        columns += [f'yQ{i + 1}_f2']\n    endog_Q_M.columns = columns\n    levels_M = 1 + endog_Q_M / 100\n    levels_M.iloc[0] = 100\n    levels_M = levels_M.cumprod()\n    log_levels_Q = np.log(levels_M).resample('Q', convention='e').sum().iloc[:-1] * 100\n    endog_Q = log_levels_Q.diff()\n    return (endog_M, endog_Q, factors)",
            "def gen_k_factor2(nobs=10000, k=2, idiosyncratic_ar1=False, idiosyncratic_var=0.4, k_ar=6):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ix = pd.period_range(start='1950-01', periods=1, freq='M')\n    faux = pd.DataFrame([[0, 0]], index=ix, columns=['f1', 'f2'])\n    mod = varmax.VARMAX(faux, order=(k_ar, 0), trend='n')\n    A = np.zeros((2, 2 * k_ar))\n    A[:, -2:] = np.array([[0.5, -0.2], [0.1, 0.3]])\n    Q = np.array([[1.5, 0.2], [0.2, 0.5]])\n    L = np.linalg.cholesky(Q)\n    params = np.r_[A.ravel(), L[np.tril_indices_from(L)]]\n    factors = mod.simulate(params, nobs)\n    faux = pd.Series([0], index=ix)\n    mod_idio = sarimax.SARIMAX(faux, order=(1, 0, 0))\n    phi = [0.7, -0.2] if idiosyncratic_ar1 else [0, 0.0]\n    tmp = factors.iloc[:, 0] + factors.iloc[:, 1]\n    endog_M = pd.concat([tmp.copy() for i in range(k)], axis=1)\n    columns = []\n    for i in range(k):\n        endog_M.iloc[:, i] = endog_M.iloc[:, i] + mod_idio.simulate([phi[0], idiosyncratic_var], nobs)\n        columns += [f'yM{i + 1}_f2']\n    endog_M.columns = columns\n    endog_Q_M = pd.concat([tmp.copy() for i in range(k)], axis=1)\n    columns = []\n    for i in range(k):\n        endog_Q_M.iloc[:, i] = endog_Q_M.iloc[:, i] + mod_idio.simulate([phi[0], idiosyncratic_var], nobs)\n        columns += [f'yQ{i + 1}_f2']\n    endog_Q_M.columns = columns\n    levels_M = 1 + endog_Q_M / 100\n    levels_M.iloc[0] = 100\n    levels_M = levels_M.cumprod()\n    log_levels_Q = np.log(levels_M).resample('Q', convention='e').sum().iloc[:-1] * 100\n    endog_Q = log_levels_Q.diff()\n    return (endog_M, endog_Q, factors)",
            "def gen_k_factor2(nobs=10000, k=2, idiosyncratic_ar1=False, idiosyncratic_var=0.4, k_ar=6):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ix = pd.period_range(start='1950-01', periods=1, freq='M')\n    faux = pd.DataFrame([[0, 0]], index=ix, columns=['f1', 'f2'])\n    mod = varmax.VARMAX(faux, order=(k_ar, 0), trend='n')\n    A = np.zeros((2, 2 * k_ar))\n    A[:, -2:] = np.array([[0.5, -0.2], [0.1, 0.3]])\n    Q = np.array([[1.5, 0.2], [0.2, 0.5]])\n    L = np.linalg.cholesky(Q)\n    params = np.r_[A.ravel(), L[np.tril_indices_from(L)]]\n    factors = mod.simulate(params, nobs)\n    faux = pd.Series([0], index=ix)\n    mod_idio = sarimax.SARIMAX(faux, order=(1, 0, 0))\n    phi = [0.7, -0.2] if idiosyncratic_ar1 else [0, 0.0]\n    tmp = factors.iloc[:, 0] + factors.iloc[:, 1]\n    endog_M = pd.concat([tmp.copy() for i in range(k)], axis=1)\n    columns = []\n    for i in range(k):\n        endog_M.iloc[:, i] = endog_M.iloc[:, i] + mod_idio.simulate([phi[0], idiosyncratic_var], nobs)\n        columns += [f'yM{i + 1}_f2']\n    endog_M.columns = columns\n    endog_Q_M = pd.concat([tmp.copy() for i in range(k)], axis=1)\n    columns = []\n    for i in range(k):\n        endog_Q_M.iloc[:, i] = endog_Q_M.iloc[:, i] + mod_idio.simulate([phi[0], idiosyncratic_var], nobs)\n        columns += [f'yQ{i + 1}_f2']\n    endog_Q_M.columns = columns\n    levels_M = 1 + endog_Q_M / 100\n    levels_M.iloc[0] = 100\n    levels_M = levels_M.cumprod()\n    log_levels_Q = np.log(levels_M).resample('Q', convention='e').sum().iloc[:-1] * 100\n    endog_Q = log_levels_Q.diff()\n    return (endog_M, endog_Q, factors)",
            "def gen_k_factor2(nobs=10000, k=2, idiosyncratic_ar1=False, idiosyncratic_var=0.4, k_ar=6):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ix = pd.period_range(start='1950-01', periods=1, freq='M')\n    faux = pd.DataFrame([[0, 0]], index=ix, columns=['f1', 'f2'])\n    mod = varmax.VARMAX(faux, order=(k_ar, 0), trend='n')\n    A = np.zeros((2, 2 * k_ar))\n    A[:, -2:] = np.array([[0.5, -0.2], [0.1, 0.3]])\n    Q = np.array([[1.5, 0.2], [0.2, 0.5]])\n    L = np.linalg.cholesky(Q)\n    params = np.r_[A.ravel(), L[np.tril_indices_from(L)]]\n    factors = mod.simulate(params, nobs)\n    faux = pd.Series([0], index=ix)\n    mod_idio = sarimax.SARIMAX(faux, order=(1, 0, 0))\n    phi = [0.7, -0.2] if idiosyncratic_ar1 else [0, 0.0]\n    tmp = factors.iloc[:, 0] + factors.iloc[:, 1]\n    endog_M = pd.concat([tmp.copy() for i in range(k)], axis=1)\n    columns = []\n    for i in range(k):\n        endog_M.iloc[:, i] = endog_M.iloc[:, i] + mod_idio.simulate([phi[0], idiosyncratic_var], nobs)\n        columns += [f'yM{i + 1}_f2']\n    endog_M.columns = columns\n    endog_Q_M = pd.concat([tmp.copy() for i in range(k)], axis=1)\n    columns = []\n    for i in range(k):\n        endog_Q_M.iloc[:, i] = endog_Q_M.iloc[:, i] + mod_idio.simulate([phi[0], idiosyncratic_var], nobs)\n        columns += [f'yQ{i + 1}_f2']\n    endog_Q_M.columns = columns\n    levels_M = 1 + endog_Q_M / 100\n    levels_M.iloc[0] = 100\n    levels_M = levels_M.cumprod()\n    log_levels_Q = np.log(levels_M).resample('Q', convention='e').sum().iloc[:-1] * 100\n    endog_Q = log_levels_Q.diff()\n    return (endog_M, endog_Q, factors)"
        ]
    },
    {
        "func_name": "test_k_factor2_factor_order_6",
        "original": "@pytest.mark.skip(reason='Monte carlo test, very slow, kept for manual runs')\ndef test_k_factor2_factor_order_6(reset_randomstate):\n    (endog_M, endog_Q, factors) = gen_k_factor2()\n    endog_M_aug = pd.concat([factors, endog_M], axis=1)\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M_aug, endog_quarterly=endog_Q, factor_multiplicities=2, factor_orders=6, idiosyncratic_ar1=False, standardize=False)\n    res = mod.fit()\n    M = np.kron(np.eye(6), mod['design', :2, :2])\n    Mi = np.linalg.inv(M)\n    Z = mod['design', :, :12]\n    A = mod['transition', :12, :12]\n    R = mod['selection', :12, :2]\n    Q = mod['state_cov', :2, :2]\n    RQR = R @ Q @ R.T\n    Z2 = Z @ Mi\n    A2 = M @ A @ Mi\n    Q2 = M @ RQR @ M.T\n    print(Z2.round(2))\n    desired = np.array([[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 2, 2, 3, 3, 2, 2, 1, 1, 0, 0], [1, 1, 2, 2, 3, 3, 2, 2, 1, 1, 0, 0]])\n    assert_allclose(Z2, desired, atol=0.1)\n    print(A2.round(2))\n    desired = np.array([[0, 0, 0.02, 0, 0.01, -0.03, 0.01, 0.02, 0, -0.01, 0.5, -0.2], [0, 0, 0, 0.02, 0, -0.01, 0, 0, 0, 0.01, 0.1, 0.3], [1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0]])\n    assert_allclose(A2, desired, atol=0.01)\n    print(Q2.round(2))\n    desired = np.array([[1.49, 0.21], [0.21, 0.49]])\n    assert_allclose(Q2[:2, :2], desired, atol=0.01)\n    assert_allclose(Q2[:2, 2:], 0, atol=0.01)\n    assert_allclose(Q2[2:, :2], 0, atol=0.01)\n    assert_allclose(Q2[2:, 2:], 0, atol=0.01)\n    a = res.states.smoothed\n    a2 = (M @ a.T.iloc[:12]).T\n    assert_allclose(endog_M.values, a2.iloc[:, :2].values, atol=1e-10)",
        "mutated": [
            "@pytest.mark.skip(reason='Monte carlo test, very slow, kept for manual runs')\ndef test_k_factor2_factor_order_6(reset_randomstate):\n    if False:\n        i = 10\n    (endog_M, endog_Q, factors) = gen_k_factor2()\n    endog_M_aug = pd.concat([factors, endog_M], axis=1)\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M_aug, endog_quarterly=endog_Q, factor_multiplicities=2, factor_orders=6, idiosyncratic_ar1=False, standardize=False)\n    res = mod.fit()\n    M = np.kron(np.eye(6), mod['design', :2, :2])\n    Mi = np.linalg.inv(M)\n    Z = mod['design', :, :12]\n    A = mod['transition', :12, :12]\n    R = mod['selection', :12, :2]\n    Q = mod['state_cov', :2, :2]\n    RQR = R @ Q @ R.T\n    Z2 = Z @ Mi\n    A2 = M @ A @ Mi\n    Q2 = M @ RQR @ M.T\n    print(Z2.round(2))\n    desired = np.array([[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 2, 2, 3, 3, 2, 2, 1, 1, 0, 0], [1, 1, 2, 2, 3, 3, 2, 2, 1, 1, 0, 0]])\n    assert_allclose(Z2, desired, atol=0.1)\n    print(A2.round(2))\n    desired = np.array([[0, 0, 0.02, 0, 0.01, -0.03, 0.01, 0.02, 0, -0.01, 0.5, -0.2], [0, 0, 0, 0.02, 0, -0.01, 0, 0, 0, 0.01, 0.1, 0.3], [1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0]])\n    assert_allclose(A2, desired, atol=0.01)\n    print(Q2.round(2))\n    desired = np.array([[1.49, 0.21], [0.21, 0.49]])\n    assert_allclose(Q2[:2, :2], desired, atol=0.01)\n    assert_allclose(Q2[:2, 2:], 0, atol=0.01)\n    assert_allclose(Q2[2:, :2], 0, atol=0.01)\n    assert_allclose(Q2[2:, 2:], 0, atol=0.01)\n    a = res.states.smoothed\n    a2 = (M @ a.T.iloc[:12]).T\n    assert_allclose(endog_M.values, a2.iloc[:, :2].values, atol=1e-10)",
            "@pytest.mark.skip(reason='Monte carlo test, very slow, kept for manual runs')\ndef test_k_factor2_factor_order_6(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (endog_M, endog_Q, factors) = gen_k_factor2()\n    endog_M_aug = pd.concat([factors, endog_M], axis=1)\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M_aug, endog_quarterly=endog_Q, factor_multiplicities=2, factor_orders=6, idiosyncratic_ar1=False, standardize=False)\n    res = mod.fit()\n    M = np.kron(np.eye(6), mod['design', :2, :2])\n    Mi = np.linalg.inv(M)\n    Z = mod['design', :, :12]\n    A = mod['transition', :12, :12]\n    R = mod['selection', :12, :2]\n    Q = mod['state_cov', :2, :2]\n    RQR = R @ Q @ R.T\n    Z2 = Z @ Mi\n    A2 = M @ A @ Mi\n    Q2 = M @ RQR @ M.T\n    print(Z2.round(2))\n    desired = np.array([[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 2, 2, 3, 3, 2, 2, 1, 1, 0, 0], [1, 1, 2, 2, 3, 3, 2, 2, 1, 1, 0, 0]])\n    assert_allclose(Z2, desired, atol=0.1)\n    print(A2.round(2))\n    desired = np.array([[0, 0, 0.02, 0, 0.01, -0.03, 0.01, 0.02, 0, -0.01, 0.5, -0.2], [0, 0, 0, 0.02, 0, -0.01, 0, 0, 0, 0.01, 0.1, 0.3], [1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0]])\n    assert_allclose(A2, desired, atol=0.01)\n    print(Q2.round(2))\n    desired = np.array([[1.49, 0.21], [0.21, 0.49]])\n    assert_allclose(Q2[:2, :2], desired, atol=0.01)\n    assert_allclose(Q2[:2, 2:], 0, atol=0.01)\n    assert_allclose(Q2[2:, :2], 0, atol=0.01)\n    assert_allclose(Q2[2:, 2:], 0, atol=0.01)\n    a = res.states.smoothed\n    a2 = (M @ a.T.iloc[:12]).T\n    assert_allclose(endog_M.values, a2.iloc[:, :2].values, atol=1e-10)",
            "@pytest.mark.skip(reason='Monte carlo test, very slow, kept for manual runs')\ndef test_k_factor2_factor_order_6(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (endog_M, endog_Q, factors) = gen_k_factor2()\n    endog_M_aug = pd.concat([factors, endog_M], axis=1)\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M_aug, endog_quarterly=endog_Q, factor_multiplicities=2, factor_orders=6, idiosyncratic_ar1=False, standardize=False)\n    res = mod.fit()\n    M = np.kron(np.eye(6), mod['design', :2, :2])\n    Mi = np.linalg.inv(M)\n    Z = mod['design', :, :12]\n    A = mod['transition', :12, :12]\n    R = mod['selection', :12, :2]\n    Q = mod['state_cov', :2, :2]\n    RQR = R @ Q @ R.T\n    Z2 = Z @ Mi\n    A2 = M @ A @ Mi\n    Q2 = M @ RQR @ M.T\n    print(Z2.round(2))\n    desired = np.array([[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 2, 2, 3, 3, 2, 2, 1, 1, 0, 0], [1, 1, 2, 2, 3, 3, 2, 2, 1, 1, 0, 0]])\n    assert_allclose(Z2, desired, atol=0.1)\n    print(A2.round(2))\n    desired = np.array([[0, 0, 0.02, 0, 0.01, -0.03, 0.01, 0.02, 0, -0.01, 0.5, -0.2], [0, 0, 0, 0.02, 0, -0.01, 0, 0, 0, 0.01, 0.1, 0.3], [1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0]])\n    assert_allclose(A2, desired, atol=0.01)\n    print(Q2.round(2))\n    desired = np.array([[1.49, 0.21], [0.21, 0.49]])\n    assert_allclose(Q2[:2, :2], desired, atol=0.01)\n    assert_allclose(Q2[:2, 2:], 0, atol=0.01)\n    assert_allclose(Q2[2:, :2], 0, atol=0.01)\n    assert_allclose(Q2[2:, 2:], 0, atol=0.01)\n    a = res.states.smoothed\n    a2 = (M @ a.T.iloc[:12]).T\n    assert_allclose(endog_M.values, a2.iloc[:, :2].values, atol=1e-10)",
            "@pytest.mark.skip(reason='Monte carlo test, very slow, kept for manual runs')\ndef test_k_factor2_factor_order_6(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (endog_M, endog_Q, factors) = gen_k_factor2()\n    endog_M_aug = pd.concat([factors, endog_M], axis=1)\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M_aug, endog_quarterly=endog_Q, factor_multiplicities=2, factor_orders=6, idiosyncratic_ar1=False, standardize=False)\n    res = mod.fit()\n    M = np.kron(np.eye(6), mod['design', :2, :2])\n    Mi = np.linalg.inv(M)\n    Z = mod['design', :, :12]\n    A = mod['transition', :12, :12]\n    R = mod['selection', :12, :2]\n    Q = mod['state_cov', :2, :2]\n    RQR = R @ Q @ R.T\n    Z2 = Z @ Mi\n    A2 = M @ A @ Mi\n    Q2 = M @ RQR @ M.T\n    print(Z2.round(2))\n    desired = np.array([[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 2, 2, 3, 3, 2, 2, 1, 1, 0, 0], [1, 1, 2, 2, 3, 3, 2, 2, 1, 1, 0, 0]])\n    assert_allclose(Z2, desired, atol=0.1)\n    print(A2.round(2))\n    desired = np.array([[0, 0, 0.02, 0, 0.01, -0.03, 0.01, 0.02, 0, -0.01, 0.5, -0.2], [0, 0, 0, 0.02, 0, -0.01, 0, 0, 0, 0.01, 0.1, 0.3], [1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0]])\n    assert_allclose(A2, desired, atol=0.01)\n    print(Q2.round(2))\n    desired = np.array([[1.49, 0.21], [0.21, 0.49]])\n    assert_allclose(Q2[:2, :2], desired, atol=0.01)\n    assert_allclose(Q2[:2, 2:], 0, atol=0.01)\n    assert_allclose(Q2[2:, :2], 0, atol=0.01)\n    assert_allclose(Q2[2:, 2:], 0, atol=0.01)\n    a = res.states.smoothed\n    a2 = (M @ a.T.iloc[:12]).T\n    assert_allclose(endog_M.values, a2.iloc[:, :2].values, atol=1e-10)",
            "@pytest.mark.skip(reason='Monte carlo test, very slow, kept for manual runs')\ndef test_k_factor2_factor_order_6(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (endog_M, endog_Q, factors) = gen_k_factor2()\n    endog_M_aug = pd.concat([factors, endog_M], axis=1)\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M_aug, endog_quarterly=endog_Q, factor_multiplicities=2, factor_orders=6, idiosyncratic_ar1=False, standardize=False)\n    res = mod.fit()\n    M = np.kron(np.eye(6), mod['design', :2, :2])\n    Mi = np.linalg.inv(M)\n    Z = mod['design', :, :12]\n    A = mod['transition', :12, :12]\n    R = mod['selection', :12, :2]\n    Q = mod['state_cov', :2, :2]\n    RQR = R @ Q @ R.T\n    Z2 = Z @ Mi\n    A2 = M @ A @ Mi\n    Q2 = M @ RQR @ M.T\n    print(Z2.round(2))\n    desired = np.array([[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 2, 2, 3, 3, 2, 2, 1, 1, 0, 0], [1, 1, 2, 2, 3, 3, 2, 2, 1, 1, 0, 0]])\n    assert_allclose(Z2, desired, atol=0.1)\n    print(A2.round(2))\n    desired = np.array([[0, 0, 0.02, 0, 0.01, -0.03, 0.01, 0.02, 0, -0.01, 0.5, -0.2], [0, 0, 0, 0.02, 0, -0.01, 0, 0, 0, 0.01, 0.1, 0.3], [1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0]])\n    assert_allclose(A2, desired, atol=0.01)\n    print(Q2.round(2))\n    desired = np.array([[1.49, 0.21], [0.21, 0.49]])\n    assert_allclose(Q2[:2, :2], desired, atol=0.01)\n    assert_allclose(Q2[:2, 2:], 0, atol=0.01)\n    assert_allclose(Q2[2:, :2], 0, atol=0.01)\n    assert_allclose(Q2[2:, 2:], 0, atol=0.01)\n    a = res.states.smoothed\n    a2 = (M @ a.T.iloc[:12]).T\n    assert_allclose(endog_M.values, a2.iloc[:, :2].values, atol=1e-10)"
        ]
    },
    {
        "func_name": "test_two_blocks_factor_orders_6",
        "original": "@pytest.mark.skip(reason='Monte carlo test, very slow, kept for manual runs')\ndef test_two_blocks_factor_orders_6(reset_randomstate):\n    nobs = 1000\n    idiosyncratic_ar1 = True\n    k1 = 3\n    k2 = 10\n    (endog1_M, endog1_Q, f1) = gen_k_factor1(nobs, k=k1, idiosyncratic_ar1=idiosyncratic_ar1)\n    (endog2_M, endog2_Q, f2) = gen_k_factor2(nobs, k=k2, idiosyncratic_ar1=idiosyncratic_ar1)\n    endog_M = pd.concat([endog1_M, f2, endog2_M], axis=1)\n    endog_Q = pd.concat([endog1_Q, endog2_Q], axis=1)\n    factors = {f'yM{i + 1}_f1': ['a'] for i in range(k1)}\n    factors.update({f'yQ{i + 1}_f1': ['a'] for i in range(k1)})\n    factors.update({f'f{i + 1}': ['b'] for i in range(2)})\n    factors.update({f'yM{i + 1}_f2': ['b'] for i in range(k2)})\n    factors.update({f'yQ{i + 1}_f2': ['b'] for i in range(k2)})\n    factor_multiplicities = {'b': 2}\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M, endog_quarterly=endog_Q, factors=factors, factor_multiplicities=factor_multiplicities, factor_orders=6, idiosyncratic_ar1=idiosyncratic_ar1, standardize=False)\n    mod.fit()\n    from scipy.linalg import block_diag\n    M1 = np.kron(np.eye(6), mod['design', 3:5, :2])\n    M2 = np.kron(np.eye(6), mod['design', 0:1, 12:13])\n    M = block_diag(M1, M2)\n    Mi = np.linalg.inv(M)\n    Z = mod['design', :, :18]\n    A = mod['transition', :18, :18]\n    R = mod['selection', :18, :3]\n    Q = block_diag(mod['state_cov', :2, :2], mod['state_cov', 12:13, 12:13])\n    RQR = R @ Q @ R.T\n    Z2 = Z @ Mi\n    A2 = M @ A @ Mi\n    Q2 = M @ RQR @ M.T\n    print(Z2.round(2))\n    print(A2.round(2))\n    print(Q2.round(2))",
        "mutated": [
            "@pytest.mark.skip(reason='Monte carlo test, very slow, kept for manual runs')\ndef test_two_blocks_factor_orders_6(reset_randomstate):\n    if False:\n        i = 10\n    nobs = 1000\n    idiosyncratic_ar1 = True\n    k1 = 3\n    k2 = 10\n    (endog1_M, endog1_Q, f1) = gen_k_factor1(nobs, k=k1, idiosyncratic_ar1=idiosyncratic_ar1)\n    (endog2_M, endog2_Q, f2) = gen_k_factor2(nobs, k=k2, idiosyncratic_ar1=idiosyncratic_ar1)\n    endog_M = pd.concat([endog1_M, f2, endog2_M], axis=1)\n    endog_Q = pd.concat([endog1_Q, endog2_Q], axis=1)\n    factors = {f'yM{i + 1}_f1': ['a'] for i in range(k1)}\n    factors.update({f'yQ{i + 1}_f1': ['a'] for i in range(k1)})\n    factors.update({f'f{i + 1}': ['b'] for i in range(2)})\n    factors.update({f'yM{i + 1}_f2': ['b'] for i in range(k2)})\n    factors.update({f'yQ{i + 1}_f2': ['b'] for i in range(k2)})\n    factor_multiplicities = {'b': 2}\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M, endog_quarterly=endog_Q, factors=factors, factor_multiplicities=factor_multiplicities, factor_orders=6, idiosyncratic_ar1=idiosyncratic_ar1, standardize=False)\n    mod.fit()\n    from scipy.linalg import block_diag\n    M1 = np.kron(np.eye(6), mod['design', 3:5, :2])\n    M2 = np.kron(np.eye(6), mod['design', 0:1, 12:13])\n    M = block_diag(M1, M2)\n    Mi = np.linalg.inv(M)\n    Z = mod['design', :, :18]\n    A = mod['transition', :18, :18]\n    R = mod['selection', :18, :3]\n    Q = block_diag(mod['state_cov', :2, :2], mod['state_cov', 12:13, 12:13])\n    RQR = R @ Q @ R.T\n    Z2 = Z @ Mi\n    A2 = M @ A @ Mi\n    Q2 = M @ RQR @ M.T\n    print(Z2.round(2))\n    print(A2.round(2))\n    print(Q2.round(2))",
            "@pytest.mark.skip(reason='Monte carlo test, very slow, kept for manual runs')\ndef test_two_blocks_factor_orders_6(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    nobs = 1000\n    idiosyncratic_ar1 = True\n    k1 = 3\n    k2 = 10\n    (endog1_M, endog1_Q, f1) = gen_k_factor1(nobs, k=k1, idiosyncratic_ar1=idiosyncratic_ar1)\n    (endog2_M, endog2_Q, f2) = gen_k_factor2(nobs, k=k2, idiosyncratic_ar1=idiosyncratic_ar1)\n    endog_M = pd.concat([endog1_M, f2, endog2_M], axis=1)\n    endog_Q = pd.concat([endog1_Q, endog2_Q], axis=1)\n    factors = {f'yM{i + 1}_f1': ['a'] for i in range(k1)}\n    factors.update({f'yQ{i + 1}_f1': ['a'] for i in range(k1)})\n    factors.update({f'f{i + 1}': ['b'] for i in range(2)})\n    factors.update({f'yM{i + 1}_f2': ['b'] for i in range(k2)})\n    factors.update({f'yQ{i + 1}_f2': ['b'] for i in range(k2)})\n    factor_multiplicities = {'b': 2}\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M, endog_quarterly=endog_Q, factors=factors, factor_multiplicities=factor_multiplicities, factor_orders=6, idiosyncratic_ar1=idiosyncratic_ar1, standardize=False)\n    mod.fit()\n    from scipy.linalg import block_diag\n    M1 = np.kron(np.eye(6), mod['design', 3:5, :2])\n    M2 = np.kron(np.eye(6), mod['design', 0:1, 12:13])\n    M = block_diag(M1, M2)\n    Mi = np.linalg.inv(M)\n    Z = mod['design', :, :18]\n    A = mod['transition', :18, :18]\n    R = mod['selection', :18, :3]\n    Q = block_diag(mod['state_cov', :2, :2], mod['state_cov', 12:13, 12:13])\n    RQR = R @ Q @ R.T\n    Z2 = Z @ Mi\n    A2 = M @ A @ Mi\n    Q2 = M @ RQR @ M.T\n    print(Z2.round(2))\n    print(A2.round(2))\n    print(Q2.round(2))",
            "@pytest.mark.skip(reason='Monte carlo test, very slow, kept for manual runs')\ndef test_two_blocks_factor_orders_6(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    nobs = 1000\n    idiosyncratic_ar1 = True\n    k1 = 3\n    k2 = 10\n    (endog1_M, endog1_Q, f1) = gen_k_factor1(nobs, k=k1, idiosyncratic_ar1=idiosyncratic_ar1)\n    (endog2_M, endog2_Q, f2) = gen_k_factor2(nobs, k=k2, idiosyncratic_ar1=idiosyncratic_ar1)\n    endog_M = pd.concat([endog1_M, f2, endog2_M], axis=1)\n    endog_Q = pd.concat([endog1_Q, endog2_Q], axis=1)\n    factors = {f'yM{i + 1}_f1': ['a'] for i in range(k1)}\n    factors.update({f'yQ{i + 1}_f1': ['a'] for i in range(k1)})\n    factors.update({f'f{i + 1}': ['b'] for i in range(2)})\n    factors.update({f'yM{i + 1}_f2': ['b'] for i in range(k2)})\n    factors.update({f'yQ{i + 1}_f2': ['b'] for i in range(k2)})\n    factor_multiplicities = {'b': 2}\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M, endog_quarterly=endog_Q, factors=factors, factor_multiplicities=factor_multiplicities, factor_orders=6, idiosyncratic_ar1=idiosyncratic_ar1, standardize=False)\n    mod.fit()\n    from scipy.linalg import block_diag\n    M1 = np.kron(np.eye(6), mod['design', 3:5, :2])\n    M2 = np.kron(np.eye(6), mod['design', 0:1, 12:13])\n    M = block_diag(M1, M2)\n    Mi = np.linalg.inv(M)\n    Z = mod['design', :, :18]\n    A = mod['transition', :18, :18]\n    R = mod['selection', :18, :3]\n    Q = block_diag(mod['state_cov', :2, :2], mod['state_cov', 12:13, 12:13])\n    RQR = R @ Q @ R.T\n    Z2 = Z @ Mi\n    A2 = M @ A @ Mi\n    Q2 = M @ RQR @ M.T\n    print(Z2.round(2))\n    print(A2.round(2))\n    print(Q2.round(2))",
            "@pytest.mark.skip(reason='Monte carlo test, very slow, kept for manual runs')\ndef test_two_blocks_factor_orders_6(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    nobs = 1000\n    idiosyncratic_ar1 = True\n    k1 = 3\n    k2 = 10\n    (endog1_M, endog1_Q, f1) = gen_k_factor1(nobs, k=k1, idiosyncratic_ar1=idiosyncratic_ar1)\n    (endog2_M, endog2_Q, f2) = gen_k_factor2(nobs, k=k2, idiosyncratic_ar1=idiosyncratic_ar1)\n    endog_M = pd.concat([endog1_M, f2, endog2_M], axis=1)\n    endog_Q = pd.concat([endog1_Q, endog2_Q], axis=1)\n    factors = {f'yM{i + 1}_f1': ['a'] for i in range(k1)}\n    factors.update({f'yQ{i + 1}_f1': ['a'] for i in range(k1)})\n    factors.update({f'f{i + 1}': ['b'] for i in range(2)})\n    factors.update({f'yM{i + 1}_f2': ['b'] for i in range(k2)})\n    factors.update({f'yQ{i + 1}_f2': ['b'] for i in range(k2)})\n    factor_multiplicities = {'b': 2}\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M, endog_quarterly=endog_Q, factors=factors, factor_multiplicities=factor_multiplicities, factor_orders=6, idiosyncratic_ar1=idiosyncratic_ar1, standardize=False)\n    mod.fit()\n    from scipy.linalg import block_diag\n    M1 = np.kron(np.eye(6), mod['design', 3:5, :2])\n    M2 = np.kron(np.eye(6), mod['design', 0:1, 12:13])\n    M = block_diag(M1, M2)\n    Mi = np.linalg.inv(M)\n    Z = mod['design', :, :18]\n    A = mod['transition', :18, :18]\n    R = mod['selection', :18, :3]\n    Q = block_diag(mod['state_cov', :2, :2], mod['state_cov', 12:13, 12:13])\n    RQR = R @ Q @ R.T\n    Z2 = Z @ Mi\n    A2 = M @ A @ Mi\n    Q2 = M @ RQR @ M.T\n    print(Z2.round(2))\n    print(A2.round(2))\n    print(Q2.round(2))",
            "@pytest.mark.skip(reason='Monte carlo test, very slow, kept for manual runs')\ndef test_two_blocks_factor_orders_6(reset_randomstate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    nobs = 1000\n    idiosyncratic_ar1 = True\n    k1 = 3\n    k2 = 10\n    (endog1_M, endog1_Q, f1) = gen_k_factor1(nobs, k=k1, idiosyncratic_ar1=idiosyncratic_ar1)\n    (endog2_M, endog2_Q, f2) = gen_k_factor2(nobs, k=k2, idiosyncratic_ar1=idiosyncratic_ar1)\n    endog_M = pd.concat([endog1_M, f2, endog2_M], axis=1)\n    endog_Q = pd.concat([endog1_Q, endog2_Q], axis=1)\n    factors = {f'yM{i + 1}_f1': ['a'] for i in range(k1)}\n    factors.update({f'yQ{i + 1}_f1': ['a'] for i in range(k1)})\n    factors.update({f'f{i + 1}': ['b'] for i in range(2)})\n    factors.update({f'yM{i + 1}_f2': ['b'] for i in range(k2)})\n    factors.update({f'yQ{i + 1}_f2': ['b'] for i in range(k2)})\n    factor_multiplicities = {'b': 2}\n    mod = dynamic_factor_mq.DynamicFactorMQ(endog_M, endog_quarterly=endog_Q, factors=factors, factor_multiplicities=factor_multiplicities, factor_orders=6, idiosyncratic_ar1=idiosyncratic_ar1, standardize=False)\n    mod.fit()\n    from scipy.linalg import block_diag\n    M1 = np.kron(np.eye(6), mod['design', 3:5, :2])\n    M2 = np.kron(np.eye(6), mod['design', 0:1, 12:13])\n    M = block_diag(M1, M2)\n    Mi = np.linalg.inv(M)\n    Z = mod['design', :, :18]\n    A = mod['transition', :18, :18]\n    R = mod['selection', :18, :3]\n    Q = block_diag(mod['state_cov', :2, :2], mod['state_cov', 12:13, 12:13])\n    RQR = R @ Q @ R.T\n    Z2 = Z @ Mi\n    A2 = M @ A @ Mi\n    Q2 = M @ RQR @ M.T\n    print(Z2.round(2))\n    print(A2.round(2))\n    print(Q2.round(2))"
        ]
    }
]