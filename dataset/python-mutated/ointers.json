[
    {
        "func_name": "parent",
        "original": "def parent(obj, objtype, ignore=()):\n    \"\"\"\n>>> listiter = iter([4,5,6,7])\n>>> obj = parent(listiter, list)\n>>> obj == [4,5,6,7]  # actually 'is', but don't have handle any longer\nTrue\n\nNOTE: objtype can be a single type (e.g. int or list) or a tuple of types.\n\nWARNING: if obj is a sequence (e.g. list), may produce unexpected results.\nParent finds *one* parent (e.g. the last member of the sequence).\n    \"\"\"\n    depth = 1\n    chain = parents(obj, objtype, depth, ignore)\n    parent = chain.pop()\n    if parent is obj:\n        return None\n    return parent",
        "mutated": [
            "def parent(obj, objtype, ignore=()):\n    if False:\n        i = 10\n    \"\\n>>> listiter = iter([4,5,6,7])\\n>>> obj = parent(listiter, list)\\n>>> obj == [4,5,6,7]  # actually 'is', but don't have handle any longer\\nTrue\\n\\nNOTE: objtype can be a single type (e.g. int or list) or a tuple of types.\\n\\nWARNING: if obj is a sequence (e.g. list), may produce unexpected results.\\nParent finds *one* parent (e.g. the last member of the sequence).\\n    \"\n    depth = 1\n    chain = parents(obj, objtype, depth, ignore)\n    parent = chain.pop()\n    if parent is obj:\n        return None\n    return parent",
            "def parent(obj, objtype, ignore=()):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n>>> listiter = iter([4,5,6,7])\\n>>> obj = parent(listiter, list)\\n>>> obj == [4,5,6,7]  # actually 'is', but don't have handle any longer\\nTrue\\n\\nNOTE: objtype can be a single type (e.g. int or list) or a tuple of types.\\n\\nWARNING: if obj is a sequence (e.g. list), may produce unexpected results.\\nParent finds *one* parent (e.g. the last member of the sequence).\\n    \"\n    depth = 1\n    chain = parents(obj, objtype, depth, ignore)\n    parent = chain.pop()\n    if parent is obj:\n        return None\n    return parent",
            "def parent(obj, objtype, ignore=()):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n>>> listiter = iter([4,5,6,7])\\n>>> obj = parent(listiter, list)\\n>>> obj == [4,5,6,7]  # actually 'is', but don't have handle any longer\\nTrue\\n\\nNOTE: objtype can be a single type (e.g. int or list) or a tuple of types.\\n\\nWARNING: if obj is a sequence (e.g. list), may produce unexpected results.\\nParent finds *one* parent (e.g. the last member of the sequence).\\n    \"\n    depth = 1\n    chain = parents(obj, objtype, depth, ignore)\n    parent = chain.pop()\n    if parent is obj:\n        return None\n    return parent",
            "def parent(obj, objtype, ignore=()):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n>>> listiter = iter([4,5,6,7])\\n>>> obj = parent(listiter, list)\\n>>> obj == [4,5,6,7]  # actually 'is', but don't have handle any longer\\nTrue\\n\\nNOTE: objtype can be a single type (e.g. int or list) or a tuple of types.\\n\\nWARNING: if obj is a sequence (e.g. list), may produce unexpected results.\\nParent finds *one* parent (e.g. the last member of the sequence).\\n    \"\n    depth = 1\n    chain = parents(obj, objtype, depth, ignore)\n    parent = chain.pop()\n    if parent is obj:\n        return None\n    return parent",
            "def parent(obj, objtype, ignore=()):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n>>> listiter = iter([4,5,6,7])\\n>>> obj = parent(listiter, list)\\n>>> obj == [4,5,6,7]  # actually 'is', but don't have handle any longer\\nTrue\\n\\nNOTE: objtype can be a single type (e.g. int or list) or a tuple of types.\\n\\nWARNING: if obj is a sequence (e.g. list), may produce unexpected results.\\nParent finds *one* parent (e.g. the last member of the sequence).\\n    \"\n    depth = 1\n    chain = parents(obj, objtype, depth, ignore)\n    parent = chain.pop()\n    if parent is obj:\n        return None\n    return parent"
        ]
    },
    {
        "func_name": "parents",
        "original": "def parents(obj, objtype, depth=1, ignore=()):\n    \"\"\"Find the chain of referents for obj. Chain will end with obj.\n\n    objtype: an object type or tuple of types to search for\n    depth: search depth (e.g. depth=2 is 'grandparents')\n    ignore: an object or tuple of objects to ignore in the search\n    \"\"\"\n    edge_func = gc.get_referents\n    predicate = lambda x: isinstance(x, objtype)\n    ignore = (ignore,) if not hasattr(ignore, '__len__') else ignore\n    ignore = (id(obj) for obj in ignore)\n    chain = find_chain(obj, predicate, edge_func, depth)[::-1]\n    return chain",
        "mutated": [
            "def parents(obj, objtype, depth=1, ignore=()):\n    if False:\n        i = 10\n    \"Find the chain of referents for obj. Chain will end with obj.\\n\\n    objtype: an object type or tuple of types to search for\\n    depth: search depth (e.g. depth=2 is 'grandparents')\\n    ignore: an object or tuple of objects to ignore in the search\\n    \"\n    edge_func = gc.get_referents\n    predicate = lambda x: isinstance(x, objtype)\n    ignore = (ignore,) if not hasattr(ignore, '__len__') else ignore\n    ignore = (id(obj) for obj in ignore)\n    chain = find_chain(obj, predicate, edge_func, depth)[::-1]\n    return chain",
            "def parents(obj, objtype, depth=1, ignore=()):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Find the chain of referents for obj. Chain will end with obj.\\n\\n    objtype: an object type or tuple of types to search for\\n    depth: search depth (e.g. depth=2 is 'grandparents')\\n    ignore: an object or tuple of objects to ignore in the search\\n    \"\n    edge_func = gc.get_referents\n    predicate = lambda x: isinstance(x, objtype)\n    ignore = (ignore,) if not hasattr(ignore, '__len__') else ignore\n    ignore = (id(obj) for obj in ignore)\n    chain = find_chain(obj, predicate, edge_func, depth)[::-1]\n    return chain",
            "def parents(obj, objtype, depth=1, ignore=()):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Find the chain of referents for obj. Chain will end with obj.\\n\\n    objtype: an object type or tuple of types to search for\\n    depth: search depth (e.g. depth=2 is 'grandparents')\\n    ignore: an object or tuple of objects to ignore in the search\\n    \"\n    edge_func = gc.get_referents\n    predicate = lambda x: isinstance(x, objtype)\n    ignore = (ignore,) if not hasattr(ignore, '__len__') else ignore\n    ignore = (id(obj) for obj in ignore)\n    chain = find_chain(obj, predicate, edge_func, depth)[::-1]\n    return chain",
            "def parents(obj, objtype, depth=1, ignore=()):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Find the chain of referents for obj. Chain will end with obj.\\n\\n    objtype: an object type or tuple of types to search for\\n    depth: search depth (e.g. depth=2 is 'grandparents')\\n    ignore: an object or tuple of objects to ignore in the search\\n    \"\n    edge_func = gc.get_referents\n    predicate = lambda x: isinstance(x, objtype)\n    ignore = (ignore,) if not hasattr(ignore, '__len__') else ignore\n    ignore = (id(obj) for obj in ignore)\n    chain = find_chain(obj, predicate, edge_func, depth)[::-1]\n    return chain",
            "def parents(obj, objtype, depth=1, ignore=()):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Find the chain of referents for obj. Chain will end with obj.\\n\\n    objtype: an object type or tuple of types to search for\\n    depth: search depth (e.g. depth=2 is 'grandparents')\\n    ignore: an object or tuple of objects to ignore in the search\\n    \"\n    edge_func = gc.get_referents\n    predicate = lambda x: isinstance(x, objtype)\n    ignore = (ignore,) if not hasattr(ignore, '__len__') else ignore\n    ignore = (id(obj) for obj in ignore)\n    chain = find_chain(obj, predicate, edge_func, depth)[::-1]\n    return chain"
        ]
    },
    {
        "func_name": "children",
        "original": "def children(obj, objtype, depth=1, ignore=()):\n    \"\"\"Find the chain of referrers for obj. Chain will start with obj.\n\n    objtype: an object type or tuple of types to search for\n    depth: search depth (e.g. depth=2 is 'grandchildren')\n    ignore: an object or tuple of objects to ignore in the search\n\n    NOTE: a common thing to ignore is all globals, 'ignore=(globals(),)'\n\n    NOTE: repeated calls may yield different results, as python stores\n    the last value in the special variable '_'; thus, it is often good\n    to execute something to replace '_' (e.g. >>> 1+1).\n    \"\"\"\n    edge_func = gc.get_referrers\n    predicate = lambda x: isinstance(x, objtype)\n    ignore = (ignore,) if not hasattr(ignore, '__len__') else ignore\n    ignore = (id(obj) for obj in ignore)\n    chain = find_chain(obj, predicate, edge_func, depth, ignore)\n    return chain",
        "mutated": [
            "def children(obj, objtype, depth=1, ignore=()):\n    if False:\n        i = 10\n    \"Find the chain of referrers for obj. Chain will start with obj.\\n\\n    objtype: an object type or tuple of types to search for\\n    depth: search depth (e.g. depth=2 is 'grandchildren')\\n    ignore: an object or tuple of objects to ignore in the search\\n\\n    NOTE: a common thing to ignore is all globals, 'ignore=(globals(),)'\\n\\n    NOTE: repeated calls may yield different results, as python stores\\n    the last value in the special variable '_'; thus, it is often good\\n    to execute something to replace '_' (e.g. >>> 1+1).\\n    \"\n    edge_func = gc.get_referrers\n    predicate = lambda x: isinstance(x, objtype)\n    ignore = (ignore,) if not hasattr(ignore, '__len__') else ignore\n    ignore = (id(obj) for obj in ignore)\n    chain = find_chain(obj, predicate, edge_func, depth, ignore)\n    return chain",
            "def children(obj, objtype, depth=1, ignore=()):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Find the chain of referrers for obj. Chain will start with obj.\\n\\n    objtype: an object type or tuple of types to search for\\n    depth: search depth (e.g. depth=2 is 'grandchildren')\\n    ignore: an object or tuple of objects to ignore in the search\\n\\n    NOTE: a common thing to ignore is all globals, 'ignore=(globals(),)'\\n\\n    NOTE: repeated calls may yield different results, as python stores\\n    the last value in the special variable '_'; thus, it is often good\\n    to execute something to replace '_' (e.g. >>> 1+1).\\n    \"\n    edge_func = gc.get_referrers\n    predicate = lambda x: isinstance(x, objtype)\n    ignore = (ignore,) if not hasattr(ignore, '__len__') else ignore\n    ignore = (id(obj) for obj in ignore)\n    chain = find_chain(obj, predicate, edge_func, depth, ignore)\n    return chain",
            "def children(obj, objtype, depth=1, ignore=()):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Find the chain of referrers for obj. Chain will start with obj.\\n\\n    objtype: an object type or tuple of types to search for\\n    depth: search depth (e.g. depth=2 is 'grandchildren')\\n    ignore: an object or tuple of objects to ignore in the search\\n\\n    NOTE: a common thing to ignore is all globals, 'ignore=(globals(),)'\\n\\n    NOTE: repeated calls may yield different results, as python stores\\n    the last value in the special variable '_'; thus, it is often good\\n    to execute something to replace '_' (e.g. >>> 1+1).\\n    \"\n    edge_func = gc.get_referrers\n    predicate = lambda x: isinstance(x, objtype)\n    ignore = (ignore,) if not hasattr(ignore, '__len__') else ignore\n    ignore = (id(obj) for obj in ignore)\n    chain = find_chain(obj, predicate, edge_func, depth, ignore)\n    return chain",
            "def children(obj, objtype, depth=1, ignore=()):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Find the chain of referrers for obj. Chain will start with obj.\\n\\n    objtype: an object type or tuple of types to search for\\n    depth: search depth (e.g. depth=2 is 'grandchildren')\\n    ignore: an object or tuple of objects to ignore in the search\\n\\n    NOTE: a common thing to ignore is all globals, 'ignore=(globals(),)'\\n\\n    NOTE: repeated calls may yield different results, as python stores\\n    the last value in the special variable '_'; thus, it is often good\\n    to execute something to replace '_' (e.g. >>> 1+1).\\n    \"\n    edge_func = gc.get_referrers\n    predicate = lambda x: isinstance(x, objtype)\n    ignore = (ignore,) if not hasattr(ignore, '__len__') else ignore\n    ignore = (id(obj) for obj in ignore)\n    chain = find_chain(obj, predicate, edge_func, depth, ignore)\n    return chain",
            "def children(obj, objtype, depth=1, ignore=()):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Find the chain of referrers for obj. Chain will start with obj.\\n\\n    objtype: an object type or tuple of types to search for\\n    depth: search depth (e.g. depth=2 is 'grandchildren')\\n    ignore: an object or tuple of objects to ignore in the search\\n\\n    NOTE: a common thing to ignore is all globals, 'ignore=(globals(),)'\\n\\n    NOTE: repeated calls may yield different results, as python stores\\n    the last value in the special variable '_'; thus, it is often good\\n    to execute something to replace '_' (e.g. >>> 1+1).\\n    \"\n    edge_func = gc.get_referrers\n    predicate = lambda x: isinstance(x, objtype)\n    ignore = (ignore,) if not hasattr(ignore, '__len__') else ignore\n    ignore = (id(obj) for obj in ignore)\n    chain = find_chain(obj, predicate, edge_func, depth, ignore)\n    return chain"
        ]
    },
    {
        "func_name": "find_chain",
        "original": "def find_chain(obj, predicate, edge_func, max_depth=20, extra_ignore=()):\n    queue = [obj]\n    depth = {id(obj): 0}\n    parent = {id(obj): None}\n    ignore = set(extra_ignore)\n    ignore.add(id(extra_ignore))\n    ignore.add(id(queue))\n    ignore.add(id(depth))\n    ignore.add(id(parent))\n    ignore.add(id(ignore))\n    ignore.add(id(sys._getframe()))\n    ignore.add(id(sys._getframe(1)))\n    gc.collect()\n    while queue:\n        target = queue.pop(0)\n        if predicate(target):\n            chain = [target]\n            while parent[id(target)] is not None:\n                target = parent[id(target)]\n                chain.append(target)\n            return chain\n        tdepth = depth[id(target)]\n        if tdepth < max_depth:\n            referrers = edge_func(target)\n            ignore.add(id(referrers))\n            for source in referrers:\n                if id(source) in ignore:\n                    continue\n                if id(source) not in depth:\n                    depth[id(source)] = tdepth + 1\n                    parent[id(source)] = target\n                    queue.append(source)\n    return [obj]",
        "mutated": [
            "def find_chain(obj, predicate, edge_func, max_depth=20, extra_ignore=()):\n    if False:\n        i = 10\n    queue = [obj]\n    depth = {id(obj): 0}\n    parent = {id(obj): None}\n    ignore = set(extra_ignore)\n    ignore.add(id(extra_ignore))\n    ignore.add(id(queue))\n    ignore.add(id(depth))\n    ignore.add(id(parent))\n    ignore.add(id(ignore))\n    ignore.add(id(sys._getframe()))\n    ignore.add(id(sys._getframe(1)))\n    gc.collect()\n    while queue:\n        target = queue.pop(0)\n        if predicate(target):\n            chain = [target]\n            while parent[id(target)] is not None:\n                target = parent[id(target)]\n                chain.append(target)\n            return chain\n        tdepth = depth[id(target)]\n        if tdepth < max_depth:\n            referrers = edge_func(target)\n            ignore.add(id(referrers))\n            for source in referrers:\n                if id(source) in ignore:\n                    continue\n                if id(source) not in depth:\n                    depth[id(source)] = tdepth + 1\n                    parent[id(source)] = target\n                    queue.append(source)\n    return [obj]",
            "def find_chain(obj, predicate, edge_func, max_depth=20, extra_ignore=()):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    queue = [obj]\n    depth = {id(obj): 0}\n    parent = {id(obj): None}\n    ignore = set(extra_ignore)\n    ignore.add(id(extra_ignore))\n    ignore.add(id(queue))\n    ignore.add(id(depth))\n    ignore.add(id(parent))\n    ignore.add(id(ignore))\n    ignore.add(id(sys._getframe()))\n    ignore.add(id(sys._getframe(1)))\n    gc.collect()\n    while queue:\n        target = queue.pop(0)\n        if predicate(target):\n            chain = [target]\n            while parent[id(target)] is not None:\n                target = parent[id(target)]\n                chain.append(target)\n            return chain\n        tdepth = depth[id(target)]\n        if tdepth < max_depth:\n            referrers = edge_func(target)\n            ignore.add(id(referrers))\n            for source in referrers:\n                if id(source) in ignore:\n                    continue\n                if id(source) not in depth:\n                    depth[id(source)] = tdepth + 1\n                    parent[id(source)] = target\n                    queue.append(source)\n    return [obj]",
            "def find_chain(obj, predicate, edge_func, max_depth=20, extra_ignore=()):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    queue = [obj]\n    depth = {id(obj): 0}\n    parent = {id(obj): None}\n    ignore = set(extra_ignore)\n    ignore.add(id(extra_ignore))\n    ignore.add(id(queue))\n    ignore.add(id(depth))\n    ignore.add(id(parent))\n    ignore.add(id(ignore))\n    ignore.add(id(sys._getframe()))\n    ignore.add(id(sys._getframe(1)))\n    gc.collect()\n    while queue:\n        target = queue.pop(0)\n        if predicate(target):\n            chain = [target]\n            while parent[id(target)] is not None:\n                target = parent[id(target)]\n                chain.append(target)\n            return chain\n        tdepth = depth[id(target)]\n        if tdepth < max_depth:\n            referrers = edge_func(target)\n            ignore.add(id(referrers))\n            for source in referrers:\n                if id(source) in ignore:\n                    continue\n                if id(source) not in depth:\n                    depth[id(source)] = tdepth + 1\n                    parent[id(source)] = target\n                    queue.append(source)\n    return [obj]",
            "def find_chain(obj, predicate, edge_func, max_depth=20, extra_ignore=()):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    queue = [obj]\n    depth = {id(obj): 0}\n    parent = {id(obj): None}\n    ignore = set(extra_ignore)\n    ignore.add(id(extra_ignore))\n    ignore.add(id(queue))\n    ignore.add(id(depth))\n    ignore.add(id(parent))\n    ignore.add(id(ignore))\n    ignore.add(id(sys._getframe()))\n    ignore.add(id(sys._getframe(1)))\n    gc.collect()\n    while queue:\n        target = queue.pop(0)\n        if predicate(target):\n            chain = [target]\n            while parent[id(target)] is not None:\n                target = parent[id(target)]\n                chain.append(target)\n            return chain\n        tdepth = depth[id(target)]\n        if tdepth < max_depth:\n            referrers = edge_func(target)\n            ignore.add(id(referrers))\n            for source in referrers:\n                if id(source) in ignore:\n                    continue\n                if id(source) not in depth:\n                    depth[id(source)] = tdepth + 1\n                    parent[id(source)] = target\n                    queue.append(source)\n    return [obj]",
            "def find_chain(obj, predicate, edge_func, max_depth=20, extra_ignore=()):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    queue = [obj]\n    depth = {id(obj): 0}\n    parent = {id(obj): None}\n    ignore = set(extra_ignore)\n    ignore.add(id(extra_ignore))\n    ignore.add(id(queue))\n    ignore.add(id(depth))\n    ignore.add(id(parent))\n    ignore.add(id(ignore))\n    ignore.add(id(sys._getframe()))\n    ignore.add(id(sys._getframe(1)))\n    gc.collect()\n    while queue:\n        target = queue.pop(0)\n        if predicate(target):\n            chain = [target]\n            while parent[id(target)] is not None:\n                target = parent[id(target)]\n                chain.append(target)\n            return chain\n        tdepth = depth[id(target)]\n        if tdepth < max_depth:\n            referrers = edge_func(target)\n            ignore.add(id(referrers))\n            for source in referrers:\n                if id(source) in ignore:\n                    continue\n                if id(source) not in depth:\n                    depth[id(source)] = tdepth + 1\n                    parent[id(source)] = target\n                    queue.append(source)\n    return [obj]"
        ]
    }
]