[
    {
        "func_name": "__init__",
        "original": "def __init__(self, lags: Optional[LAGS_TYPE]=None, lags_past_covariates: Optional[LAGS_TYPE]=None, lags_future_covariates: Optional[FUTURE_LAGS_TYPE]=None, output_chunk_length: int=1, add_encoders: Optional[dict]=None, likelihood: Optional[str]=None, quantiles: Optional[List[float]]=None, random_state: Optional[int]=None, multi_models: Optional[bool]=True, use_static_covariates: bool=True, **kwargs):\n    \"\"\"Linear regression model.\n\n        Parameters\n        ----------\n        lags\n            Lagged target `series` values used to predict the next time step/s.\n            If an integer, must be > 0. Uses the last `n=lags` past lags; e.g. `(-1, -2, ..., -lags)`, where `0`\n            corresponds the first predicted time step of each sample.\n            If a list of integers, each value must be < 0. Uses only the specified values as lags.\n            If a dictionary, the keys correspond to the `series` component names (of the first series when\n            using multiple series) and the values correspond to the component lags (integer or list of integers). The\n            key 'default_lags' can be used to provide default lags for un-specified components. Raises and error if some\n            components are missing and the 'default_lags' key is not provided.\n        lags_past_covariates\n            Lagged `past_covariates` values used to predict the next time step/s.\n            If an integer, must be > 0. Uses the last `n=lags_past_covariates` past lags; e.g. `(-1, -2, ..., -lags)`,\n            where `0` corresponds to the first predicted time step of each sample.\n            If a list of integers, each value must be < 0. Uses only the specified values as lags.\n            If a dictionary, the keys correspond to the `past_covariates` component names (of the first series when\n            using multiple series) and the values correspond to the component lags (integer or list of integers). The\n            key 'default_lags' can be used to provide default lags for un-specified components. Raises and error if some\n            components are missing and the 'default_lags' key is not provided.\n        lags_future_covariates\n            Lagged `future_covariates` values used to predict the next time step/s.\n            If a tuple of `(past, future)`, both values must be > 0. Uses the last `n=past` past lags and `n=future`\n            future lags; e.g. `(-past, -(past - 1), ..., -1, 0, 1, .... future - 1)`, where `0`\n            corresponds the first predicted time step of each sample.\n            If a list of integers, uses only the specified values as lags.\n            If a dictionary, the keys correspond to the `future_covariates` component names (of the first series when\n            using multiple series) and the values correspond to the component lags (tuple or list of integers). The key\n            'default_lags' can be used to provide default lags for un-specified components. Raises and error if some\n            components are missing and the 'default_lags' key is not provided.\n        output_chunk_length\n            Number of time steps predicted at once by the internal regression model. Does not have to equal the forecast\n            horizon `n` used in `predict()`. However, setting `output_chunk_length` equal to the forecast horizon may\n            be useful if the covariates don't extend far enough into the future.\n        add_encoders\n            A large number of past and future covariates can be automatically generated with `add_encoders`.\n            This can be done by adding multiple pre-defined index encoders and/or custom user-made functions that\n            will be used as index encoders. Additionally, a transformer such as Darts' :class:`Scaler` can be added to\n            transform the generated covariates. This happens all under one hood and only needs to be specified at\n            model creation.\n            Read :meth:`SequentialEncoder <darts.dataprocessing.encoders.SequentialEncoder>` to find out more about\n            ``add_encoders``. Default: ``None``. An example showing some of ``add_encoders`` features:\n\n            .. highlight:: python\n            .. code-block:: python\n\n                def encode_year(idx):\n                    return (idx.year - 1950) / 50\n\n                add_encoders={\n                    'cyclic': {'future': ['month']},\n                    'datetime_attribute': {'future': ['hour', 'dayofweek']},\n                    'position': {'past': ['relative'], 'future': ['relative']},\n                    'custom': {'past': [encode_year]},\n                    'transformer': Scaler(),\n                    'tz': 'CET'\n                }\n            ..\n        likelihood\n            Can be set to `quantile` or `poisson`. If set, the model will be probabilistic, allowing sampling at\n            prediction time. If set to `quantile`, the `sklearn.linear_model.QuantileRegressor` is used. Similarly, if\n            set to `poisson`, the `sklearn.linear_model.PoissonRegressor` is used.\n        quantiles\n            Fit the model to these quantiles if the `likelihood` is set to `quantile`.\n        random_state\n            Control the randomness of the sampling. Used as seed for\n            `numpy.random.Generator\n            <https://numpy.org/doc/stable/reference/random/generator.html#numpy.random.Generator>`_. Ignored when\n            no `likelihood` is set.\n            Default: ``None``.\n        multi_models\n            If True, a separate model will be trained for each future lag to predict. If False, a single model is\n            trained to predict at step 'output_chunk_length' in the future. Default: True.\n        use_static_covariates\n            Whether the model should use static covariate information in case the input `series` passed to ``fit()``\n            contain static covariates. If ``True``, and static covariates are available at fitting time, will enforce\n            that all target `series` have the same static covariate dimensionality in ``fit()`` and ``predict()``.\n        **kwargs\n            Additional keyword arguments passed to `sklearn.linear_model.LinearRegression` (by default), to\n            `sklearn.linear_model.PoissonRegressor` (if `likelihood=\"poisson\"`), or to\n            `sklearn.linear_model.QuantileRegressor` (if `likelihood=\"quantile\"`).\n\n        Examples\n        --------\n        Deterministic forecasting, using past/future covariates (optional)\n\n        >>> from darts.datasets import WeatherDataset\n        >>> from darts.models import LinearRegressionModel\n        >>> series = WeatherDataset().load()\n        >>> # predicting atmospheric pressure\n        >>> target = series['p (mbar)'][:100]\n        >>> # optionally, use past observed rainfall (pretending to be unknown beyond index 100)\n        >>> past_cov = series['rain (mm)'][:100]\n        >>> # optionally, use future temperatures (pretending this component is a forecast)\n        >>> future_cov = series['T (degC)'][:106]\n        >>> # predict 6 pressure values using the 12 past values of pressure and rainfall, as well as the 6 temperature\n        >>> # values corresponding to the forecasted period\n        >>> model = LinearRegressionModel(\n        >>>     lags=12,\n        >>>     lags_past_covariates=12,\n        >>>     lags_future_covariates=[0,1,2,3,4,5],\n        >>>     output_chunk_length=6,\n        >>> )\n        >>> model.fit(target, past_covariates=past_cov, future_covariates=future_cov)\n        >>> pred = model.predict(6)\n        >>> pred.values()\n        array([[1005.72085839],\n               [1005.6548696 ],\n               [1005.65403772],\n               [1005.6846175 ],\n               [1005.75753605],\n               [1005.81830675]])\n        \"\"\"\n    self.kwargs = kwargs\n    self._median_idx = None\n    self._model_container = None\n    self.quantiles = None\n    self.likelihood = likelihood\n    self._rng = None\n    available_likelihoods = ['quantile', 'poisson']\n    if likelihood is not None:\n        self._check_likelihood(likelihood, available_likelihoods)\n        self._rng = np.random.default_rng(seed=random_state)\n        if likelihood == 'poisson':\n            model = PoissonRegressor(**kwargs)\n        if likelihood == 'quantile':\n            model = QuantileRegressor(**kwargs)\n            (self.quantiles, self._median_idx) = self._prepare_quantiles(quantiles)\n            self._model_container = self._get_model_container()\n    else:\n        model = LinearRegression(**kwargs)\n    super().__init__(lags=lags, lags_past_covariates=lags_past_covariates, lags_future_covariates=lags_future_covariates, output_chunk_length=output_chunk_length, add_encoders=add_encoders, model=model, multi_models=multi_models, use_static_covariates=use_static_covariates)",
        "mutated": [
            "def __init__(self, lags: Optional[LAGS_TYPE]=None, lags_past_covariates: Optional[LAGS_TYPE]=None, lags_future_covariates: Optional[FUTURE_LAGS_TYPE]=None, output_chunk_length: int=1, add_encoders: Optional[dict]=None, likelihood: Optional[str]=None, quantiles: Optional[List[float]]=None, random_state: Optional[int]=None, multi_models: Optional[bool]=True, use_static_covariates: bool=True, **kwargs):\n    if False:\n        i = 10\n    'Linear regression model.\\n\\n        Parameters\\n        ----------\\n        lags\\n            Lagged target `series` values used to predict the next time step/s.\\n            If an integer, must be > 0. Uses the last `n=lags` past lags; e.g. `(-1, -2, ..., -lags)`, where `0`\\n            corresponds the first predicted time step of each sample.\\n            If a list of integers, each value must be < 0. Uses only the specified values as lags.\\n            If a dictionary, the keys correspond to the `series` component names (of the first series when\\n            using multiple series) and the values correspond to the component lags (integer or list of integers). The\\n            key \\'default_lags\\' can be used to provide default lags for un-specified components. Raises and error if some\\n            components are missing and the \\'default_lags\\' key is not provided.\\n        lags_past_covariates\\n            Lagged `past_covariates` values used to predict the next time step/s.\\n            If an integer, must be > 0. Uses the last `n=lags_past_covariates` past lags; e.g. `(-1, -2, ..., -lags)`,\\n            where `0` corresponds to the first predicted time step of each sample.\\n            If a list of integers, each value must be < 0. Uses only the specified values as lags.\\n            If a dictionary, the keys correspond to the `past_covariates` component names (of the first series when\\n            using multiple series) and the values correspond to the component lags (integer or list of integers). The\\n            key \\'default_lags\\' can be used to provide default lags for un-specified components. Raises and error if some\\n            components are missing and the \\'default_lags\\' key is not provided.\\n        lags_future_covariates\\n            Lagged `future_covariates` values used to predict the next time step/s.\\n            If a tuple of `(past, future)`, both values must be > 0. Uses the last `n=past` past lags and `n=future`\\n            future lags; e.g. `(-past, -(past - 1), ..., -1, 0, 1, .... future - 1)`, where `0`\\n            corresponds the first predicted time step of each sample.\\n            If a list of integers, uses only the specified values as lags.\\n            If a dictionary, the keys correspond to the `future_covariates` component names (of the first series when\\n            using multiple series) and the values correspond to the component lags (tuple or list of integers). The key\\n            \\'default_lags\\' can be used to provide default lags for un-specified components. Raises and error if some\\n            components are missing and the \\'default_lags\\' key is not provided.\\n        output_chunk_length\\n            Number of time steps predicted at once by the internal regression model. Does not have to equal the forecast\\n            horizon `n` used in `predict()`. However, setting `output_chunk_length` equal to the forecast horizon may\\n            be useful if the covariates don\\'t extend far enough into the future.\\n        add_encoders\\n            A large number of past and future covariates can be automatically generated with `add_encoders`.\\n            This can be done by adding multiple pre-defined index encoders and/or custom user-made functions that\\n            will be used as index encoders. Additionally, a transformer such as Darts\\' :class:`Scaler` can be added to\\n            transform the generated covariates. This happens all under one hood and only needs to be specified at\\n            model creation.\\n            Read :meth:`SequentialEncoder <darts.dataprocessing.encoders.SequentialEncoder>` to find out more about\\n            ``add_encoders``. Default: ``None``. An example showing some of ``add_encoders`` features:\\n\\n            .. highlight:: python\\n            .. code-block:: python\\n\\n                def encode_year(idx):\\n                    return (idx.year - 1950) / 50\\n\\n                add_encoders={\\n                    \\'cyclic\\': {\\'future\\': [\\'month\\']},\\n                    \\'datetime_attribute\\': {\\'future\\': [\\'hour\\', \\'dayofweek\\']},\\n                    \\'position\\': {\\'past\\': [\\'relative\\'], \\'future\\': [\\'relative\\']},\\n                    \\'custom\\': {\\'past\\': [encode_year]},\\n                    \\'transformer\\': Scaler(),\\n                    \\'tz\\': \\'CET\\'\\n                }\\n            ..\\n        likelihood\\n            Can be set to `quantile` or `poisson`. If set, the model will be probabilistic, allowing sampling at\\n            prediction time. If set to `quantile`, the `sklearn.linear_model.QuantileRegressor` is used. Similarly, if\\n            set to `poisson`, the `sklearn.linear_model.PoissonRegressor` is used.\\n        quantiles\\n            Fit the model to these quantiles if the `likelihood` is set to `quantile`.\\n        random_state\\n            Control the randomness of the sampling. Used as seed for\\n            `numpy.random.Generator\\n            <https://numpy.org/doc/stable/reference/random/generator.html#numpy.random.Generator>`_. Ignored when\\n            no `likelihood` is set.\\n            Default: ``None``.\\n        multi_models\\n            If True, a separate model will be trained for each future lag to predict. If False, a single model is\\n            trained to predict at step \\'output_chunk_length\\' in the future. Default: True.\\n        use_static_covariates\\n            Whether the model should use static covariate information in case the input `series` passed to ``fit()``\\n            contain static covariates. If ``True``, and static covariates are available at fitting time, will enforce\\n            that all target `series` have the same static covariate dimensionality in ``fit()`` and ``predict()``.\\n        **kwargs\\n            Additional keyword arguments passed to `sklearn.linear_model.LinearRegression` (by default), to\\n            `sklearn.linear_model.PoissonRegressor` (if `likelihood=\"poisson\"`), or to\\n            `sklearn.linear_model.QuantileRegressor` (if `likelihood=\"quantile\"`).\\n\\n        Examples\\n        --------\\n        Deterministic forecasting, using past/future covariates (optional)\\n\\n        >>> from darts.datasets import WeatherDataset\\n        >>> from darts.models import LinearRegressionModel\\n        >>> series = WeatherDataset().load()\\n        >>> # predicting atmospheric pressure\\n        >>> target = series[\\'p (mbar)\\'][:100]\\n        >>> # optionally, use past observed rainfall (pretending to be unknown beyond index 100)\\n        >>> past_cov = series[\\'rain (mm)\\'][:100]\\n        >>> # optionally, use future temperatures (pretending this component is a forecast)\\n        >>> future_cov = series[\\'T (degC)\\'][:106]\\n        >>> # predict 6 pressure values using the 12 past values of pressure and rainfall, as well as the 6 temperature\\n        >>> # values corresponding to the forecasted period\\n        >>> model = LinearRegressionModel(\\n        >>>     lags=12,\\n        >>>     lags_past_covariates=12,\\n        >>>     lags_future_covariates=[0,1,2,3,4,5],\\n        >>>     output_chunk_length=6,\\n        >>> )\\n        >>> model.fit(target, past_covariates=past_cov, future_covariates=future_cov)\\n        >>> pred = model.predict(6)\\n        >>> pred.values()\\n        array([[1005.72085839],\\n               [1005.6548696 ],\\n               [1005.65403772],\\n               [1005.6846175 ],\\n               [1005.75753605],\\n               [1005.81830675]])\\n        '\n    self.kwargs = kwargs\n    self._median_idx = None\n    self._model_container = None\n    self.quantiles = None\n    self.likelihood = likelihood\n    self._rng = None\n    available_likelihoods = ['quantile', 'poisson']\n    if likelihood is not None:\n        self._check_likelihood(likelihood, available_likelihoods)\n        self._rng = np.random.default_rng(seed=random_state)\n        if likelihood == 'poisson':\n            model = PoissonRegressor(**kwargs)\n        if likelihood == 'quantile':\n            model = QuantileRegressor(**kwargs)\n            (self.quantiles, self._median_idx) = self._prepare_quantiles(quantiles)\n            self._model_container = self._get_model_container()\n    else:\n        model = LinearRegression(**kwargs)\n    super().__init__(lags=lags, lags_past_covariates=lags_past_covariates, lags_future_covariates=lags_future_covariates, output_chunk_length=output_chunk_length, add_encoders=add_encoders, model=model, multi_models=multi_models, use_static_covariates=use_static_covariates)",
            "def __init__(self, lags: Optional[LAGS_TYPE]=None, lags_past_covariates: Optional[LAGS_TYPE]=None, lags_future_covariates: Optional[FUTURE_LAGS_TYPE]=None, output_chunk_length: int=1, add_encoders: Optional[dict]=None, likelihood: Optional[str]=None, quantiles: Optional[List[float]]=None, random_state: Optional[int]=None, multi_models: Optional[bool]=True, use_static_covariates: bool=True, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Linear regression model.\\n\\n        Parameters\\n        ----------\\n        lags\\n            Lagged target `series` values used to predict the next time step/s.\\n            If an integer, must be > 0. Uses the last `n=lags` past lags; e.g. `(-1, -2, ..., -lags)`, where `0`\\n            corresponds the first predicted time step of each sample.\\n            If a list of integers, each value must be < 0. Uses only the specified values as lags.\\n            If a dictionary, the keys correspond to the `series` component names (of the first series when\\n            using multiple series) and the values correspond to the component lags (integer or list of integers). The\\n            key \\'default_lags\\' can be used to provide default lags for un-specified components. Raises and error if some\\n            components are missing and the \\'default_lags\\' key is not provided.\\n        lags_past_covariates\\n            Lagged `past_covariates` values used to predict the next time step/s.\\n            If an integer, must be > 0. Uses the last `n=lags_past_covariates` past lags; e.g. `(-1, -2, ..., -lags)`,\\n            where `0` corresponds to the first predicted time step of each sample.\\n            If a list of integers, each value must be < 0. Uses only the specified values as lags.\\n            If a dictionary, the keys correspond to the `past_covariates` component names (of the first series when\\n            using multiple series) and the values correspond to the component lags (integer or list of integers). The\\n            key \\'default_lags\\' can be used to provide default lags for un-specified components. Raises and error if some\\n            components are missing and the \\'default_lags\\' key is not provided.\\n        lags_future_covariates\\n            Lagged `future_covariates` values used to predict the next time step/s.\\n            If a tuple of `(past, future)`, both values must be > 0. Uses the last `n=past` past lags and `n=future`\\n            future lags; e.g. `(-past, -(past - 1), ..., -1, 0, 1, .... future - 1)`, where `0`\\n            corresponds the first predicted time step of each sample.\\n            If a list of integers, uses only the specified values as lags.\\n            If a dictionary, the keys correspond to the `future_covariates` component names (of the first series when\\n            using multiple series) and the values correspond to the component lags (tuple or list of integers). The key\\n            \\'default_lags\\' can be used to provide default lags for un-specified components. Raises and error if some\\n            components are missing and the \\'default_lags\\' key is not provided.\\n        output_chunk_length\\n            Number of time steps predicted at once by the internal regression model. Does not have to equal the forecast\\n            horizon `n` used in `predict()`. However, setting `output_chunk_length` equal to the forecast horizon may\\n            be useful if the covariates don\\'t extend far enough into the future.\\n        add_encoders\\n            A large number of past and future covariates can be automatically generated with `add_encoders`.\\n            This can be done by adding multiple pre-defined index encoders and/or custom user-made functions that\\n            will be used as index encoders. Additionally, a transformer such as Darts\\' :class:`Scaler` can be added to\\n            transform the generated covariates. This happens all under one hood and only needs to be specified at\\n            model creation.\\n            Read :meth:`SequentialEncoder <darts.dataprocessing.encoders.SequentialEncoder>` to find out more about\\n            ``add_encoders``. Default: ``None``. An example showing some of ``add_encoders`` features:\\n\\n            .. highlight:: python\\n            .. code-block:: python\\n\\n                def encode_year(idx):\\n                    return (idx.year - 1950) / 50\\n\\n                add_encoders={\\n                    \\'cyclic\\': {\\'future\\': [\\'month\\']},\\n                    \\'datetime_attribute\\': {\\'future\\': [\\'hour\\', \\'dayofweek\\']},\\n                    \\'position\\': {\\'past\\': [\\'relative\\'], \\'future\\': [\\'relative\\']},\\n                    \\'custom\\': {\\'past\\': [encode_year]},\\n                    \\'transformer\\': Scaler(),\\n                    \\'tz\\': \\'CET\\'\\n                }\\n            ..\\n        likelihood\\n            Can be set to `quantile` or `poisson`. If set, the model will be probabilistic, allowing sampling at\\n            prediction time. If set to `quantile`, the `sklearn.linear_model.QuantileRegressor` is used. Similarly, if\\n            set to `poisson`, the `sklearn.linear_model.PoissonRegressor` is used.\\n        quantiles\\n            Fit the model to these quantiles if the `likelihood` is set to `quantile`.\\n        random_state\\n            Control the randomness of the sampling. Used as seed for\\n            `numpy.random.Generator\\n            <https://numpy.org/doc/stable/reference/random/generator.html#numpy.random.Generator>`_. Ignored when\\n            no `likelihood` is set.\\n            Default: ``None``.\\n        multi_models\\n            If True, a separate model will be trained for each future lag to predict. If False, a single model is\\n            trained to predict at step \\'output_chunk_length\\' in the future. Default: True.\\n        use_static_covariates\\n            Whether the model should use static covariate information in case the input `series` passed to ``fit()``\\n            contain static covariates. If ``True``, and static covariates are available at fitting time, will enforce\\n            that all target `series` have the same static covariate dimensionality in ``fit()`` and ``predict()``.\\n        **kwargs\\n            Additional keyword arguments passed to `sklearn.linear_model.LinearRegression` (by default), to\\n            `sklearn.linear_model.PoissonRegressor` (if `likelihood=\"poisson\"`), or to\\n            `sklearn.linear_model.QuantileRegressor` (if `likelihood=\"quantile\"`).\\n\\n        Examples\\n        --------\\n        Deterministic forecasting, using past/future covariates (optional)\\n\\n        >>> from darts.datasets import WeatherDataset\\n        >>> from darts.models import LinearRegressionModel\\n        >>> series = WeatherDataset().load()\\n        >>> # predicting atmospheric pressure\\n        >>> target = series[\\'p (mbar)\\'][:100]\\n        >>> # optionally, use past observed rainfall (pretending to be unknown beyond index 100)\\n        >>> past_cov = series[\\'rain (mm)\\'][:100]\\n        >>> # optionally, use future temperatures (pretending this component is a forecast)\\n        >>> future_cov = series[\\'T (degC)\\'][:106]\\n        >>> # predict 6 pressure values using the 12 past values of pressure and rainfall, as well as the 6 temperature\\n        >>> # values corresponding to the forecasted period\\n        >>> model = LinearRegressionModel(\\n        >>>     lags=12,\\n        >>>     lags_past_covariates=12,\\n        >>>     lags_future_covariates=[0,1,2,3,4,5],\\n        >>>     output_chunk_length=6,\\n        >>> )\\n        >>> model.fit(target, past_covariates=past_cov, future_covariates=future_cov)\\n        >>> pred = model.predict(6)\\n        >>> pred.values()\\n        array([[1005.72085839],\\n               [1005.6548696 ],\\n               [1005.65403772],\\n               [1005.6846175 ],\\n               [1005.75753605],\\n               [1005.81830675]])\\n        '\n    self.kwargs = kwargs\n    self._median_idx = None\n    self._model_container = None\n    self.quantiles = None\n    self.likelihood = likelihood\n    self._rng = None\n    available_likelihoods = ['quantile', 'poisson']\n    if likelihood is not None:\n        self._check_likelihood(likelihood, available_likelihoods)\n        self._rng = np.random.default_rng(seed=random_state)\n        if likelihood == 'poisson':\n            model = PoissonRegressor(**kwargs)\n        if likelihood == 'quantile':\n            model = QuantileRegressor(**kwargs)\n            (self.quantiles, self._median_idx) = self._prepare_quantiles(quantiles)\n            self._model_container = self._get_model_container()\n    else:\n        model = LinearRegression(**kwargs)\n    super().__init__(lags=lags, lags_past_covariates=lags_past_covariates, lags_future_covariates=lags_future_covariates, output_chunk_length=output_chunk_length, add_encoders=add_encoders, model=model, multi_models=multi_models, use_static_covariates=use_static_covariates)",
            "def __init__(self, lags: Optional[LAGS_TYPE]=None, lags_past_covariates: Optional[LAGS_TYPE]=None, lags_future_covariates: Optional[FUTURE_LAGS_TYPE]=None, output_chunk_length: int=1, add_encoders: Optional[dict]=None, likelihood: Optional[str]=None, quantiles: Optional[List[float]]=None, random_state: Optional[int]=None, multi_models: Optional[bool]=True, use_static_covariates: bool=True, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Linear regression model.\\n\\n        Parameters\\n        ----------\\n        lags\\n            Lagged target `series` values used to predict the next time step/s.\\n            If an integer, must be > 0. Uses the last `n=lags` past lags; e.g. `(-1, -2, ..., -lags)`, where `0`\\n            corresponds the first predicted time step of each sample.\\n            If a list of integers, each value must be < 0. Uses only the specified values as lags.\\n            If a dictionary, the keys correspond to the `series` component names (of the first series when\\n            using multiple series) and the values correspond to the component lags (integer or list of integers). The\\n            key \\'default_lags\\' can be used to provide default lags for un-specified components. Raises and error if some\\n            components are missing and the \\'default_lags\\' key is not provided.\\n        lags_past_covariates\\n            Lagged `past_covariates` values used to predict the next time step/s.\\n            If an integer, must be > 0. Uses the last `n=lags_past_covariates` past lags; e.g. `(-1, -2, ..., -lags)`,\\n            where `0` corresponds to the first predicted time step of each sample.\\n            If a list of integers, each value must be < 0. Uses only the specified values as lags.\\n            If a dictionary, the keys correspond to the `past_covariates` component names (of the first series when\\n            using multiple series) and the values correspond to the component lags (integer or list of integers). The\\n            key \\'default_lags\\' can be used to provide default lags for un-specified components. Raises and error if some\\n            components are missing and the \\'default_lags\\' key is not provided.\\n        lags_future_covariates\\n            Lagged `future_covariates` values used to predict the next time step/s.\\n            If a tuple of `(past, future)`, both values must be > 0. Uses the last `n=past` past lags and `n=future`\\n            future lags; e.g. `(-past, -(past - 1), ..., -1, 0, 1, .... future - 1)`, where `0`\\n            corresponds the first predicted time step of each sample.\\n            If a list of integers, uses only the specified values as lags.\\n            If a dictionary, the keys correspond to the `future_covariates` component names (of the first series when\\n            using multiple series) and the values correspond to the component lags (tuple or list of integers). The key\\n            \\'default_lags\\' can be used to provide default lags for un-specified components. Raises and error if some\\n            components are missing and the \\'default_lags\\' key is not provided.\\n        output_chunk_length\\n            Number of time steps predicted at once by the internal regression model. Does not have to equal the forecast\\n            horizon `n` used in `predict()`. However, setting `output_chunk_length` equal to the forecast horizon may\\n            be useful if the covariates don\\'t extend far enough into the future.\\n        add_encoders\\n            A large number of past and future covariates can be automatically generated with `add_encoders`.\\n            This can be done by adding multiple pre-defined index encoders and/or custom user-made functions that\\n            will be used as index encoders. Additionally, a transformer such as Darts\\' :class:`Scaler` can be added to\\n            transform the generated covariates. This happens all under one hood and only needs to be specified at\\n            model creation.\\n            Read :meth:`SequentialEncoder <darts.dataprocessing.encoders.SequentialEncoder>` to find out more about\\n            ``add_encoders``. Default: ``None``. An example showing some of ``add_encoders`` features:\\n\\n            .. highlight:: python\\n            .. code-block:: python\\n\\n                def encode_year(idx):\\n                    return (idx.year - 1950) / 50\\n\\n                add_encoders={\\n                    \\'cyclic\\': {\\'future\\': [\\'month\\']},\\n                    \\'datetime_attribute\\': {\\'future\\': [\\'hour\\', \\'dayofweek\\']},\\n                    \\'position\\': {\\'past\\': [\\'relative\\'], \\'future\\': [\\'relative\\']},\\n                    \\'custom\\': {\\'past\\': [encode_year]},\\n                    \\'transformer\\': Scaler(),\\n                    \\'tz\\': \\'CET\\'\\n                }\\n            ..\\n        likelihood\\n            Can be set to `quantile` or `poisson`. If set, the model will be probabilistic, allowing sampling at\\n            prediction time. If set to `quantile`, the `sklearn.linear_model.QuantileRegressor` is used. Similarly, if\\n            set to `poisson`, the `sklearn.linear_model.PoissonRegressor` is used.\\n        quantiles\\n            Fit the model to these quantiles if the `likelihood` is set to `quantile`.\\n        random_state\\n            Control the randomness of the sampling. Used as seed for\\n            `numpy.random.Generator\\n            <https://numpy.org/doc/stable/reference/random/generator.html#numpy.random.Generator>`_. Ignored when\\n            no `likelihood` is set.\\n            Default: ``None``.\\n        multi_models\\n            If True, a separate model will be trained for each future lag to predict. If False, a single model is\\n            trained to predict at step \\'output_chunk_length\\' in the future. Default: True.\\n        use_static_covariates\\n            Whether the model should use static covariate information in case the input `series` passed to ``fit()``\\n            contain static covariates. If ``True``, and static covariates are available at fitting time, will enforce\\n            that all target `series` have the same static covariate dimensionality in ``fit()`` and ``predict()``.\\n        **kwargs\\n            Additional keyword arguments passed to `sklearn.linear_model.LinearRegression` (by default), to\\n            `sklearn.linear_model.PoissonRegressor` (if `likelihood=\"poisson\"`), or to\\n            `sklearn.linear_model.QuantileRegressor` (if `likelihood=\"quantile\"`).\\n\\n        Examples\\n        --------\\n        Deterministic forecasting, using past/future covariates (optional)\\n\\n        >>> from darts.datasets import WeatherDataset\\n        >>> from darts.models import LinearRegressionModel\\n        >>> series = WeatherDataset().load()\\n        >>> # predicting atmospheric pressure\\n        >>> target = series[\\'p (mbar)\\'][:100]\\n        >>> # optionally, use past observed rainfall (pretending to be unknown beyond index 100)\\n        >>> past_cov = series[\\'rain (mm)\\'][:100]\\n        >>> # optionally, use future temperatures (pretending this component is a forecast)\\n        >>> future_cov = series[\\'T (degC)\\'][:106]\\n        >>> # predict 6 pressure values using the 12 past values of pressure and rainfall, as well as the 6 temperature\\n        >>> # values corresponding to the forecasted period\\n        >>> model = LinearRegressionModel(\\n        >>>     lags=12,\\n        >>>     lags_past_covariates=12,\\n        >>>     lags_future_covariates=[0,1,2,3,4,5],\\n        >>>     output_chunk_length=6,\\n        >>> )\\n        >>> model.fit(target, past_covariates=past_cov, future_covariates=future_cov)\\n        >>> pred = model.predict(6)\\n        >>> pred.values()\\n        array([[1005.72085839],\\n               [1005.6548696 ],\\n               [1005.65403772],\\n               [1005.6846175 ],\\n               [1005.75753605],\\n               [1005.81830675]])\\n        '\n    self.kwargs = kwargs\n    self._median_idx = None\n    self._model_container = None\n    self.quantiles = None\n    self.likelihood = likelihood\n    self._rng = None\n    available_likelihoods = ['quantile', 'poisson']\n    if likelihood is not None:\n        self._check_likelihood(likelihood, available_likelihoods)\n        self._rng = np.random.default_rng(seed=random_state)\n        if likelihood == 'poisson':\n            model = PoissonRegressor(**kwargs)\n        if likelihood == 'quantile':\n            model = QuantileRegressor(**kwargs)\n            (self.quantiles, self._median_idx) = self._prepare_quantiles(quantiles)\n            self._model_container = self._get_model_container()\n    else:\n        model = LinearRegression(**kwargs)\n    super().__init__(lags=lags, lags_past_covariates=lags_past_covariates, lags_future_covariates=lags_future_covariates, output_chunk_length=output_chunk_length, add_encoders=add_encoders, model=model, multi_models=multi_models, use_static_covariates=use_static_covariates)",
            "def __init__(self, lags: Optional[LAGS_TYPE]=None, lags_past_covariates: Optional[LAGS_TYPE]=None, lags_future_covariates: Optional[FUTURE_LAGS_TYPE]=None, output_chunk_length: int=1, add_encoders: Optional[dict]=None, likelihood: Optional[str]=None, quantiles: Optional[List[float]]=None, random_state: Optional[int]=None, multi_models: Optional[bool]=True, use_static_covariates: bool=True, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Linear regression model.\\n\\n        Parameters\\n        ----------\\n        lags\\n            Lagged target `series` values used to predict the next time step/s.\\n            If an integer, must be > 0. Uses the last `n=lags` past lags; e.g. `(-1, -2, ..., -lags)`, where `0`\\n            corresponds the first predicted time step of each sample.\\n            If a list of integers, each value must be < 0. Uses only the specified values as lags.\\n            If a dictionary, the keys correspond to the `series` component names (of the first series when\\n            using multiple series) and the values correspond to the component lags (integer or list of integers). The\\n            key \\'default_lags\\' can be used to provide default lags for un-specified components. Raises and error if some\\n            components are missing and the \\'default_lags\\' key is not provided.\\n        lags_past_covariates\\n            Lagged `past_covariates` values used to predict the next time step/s.\\n            If an integer, must be > 0. Uses the last `n=lags_past_covariates` past lags; e.g. `(-1, -2, ..., -lags)`,\\n            where `0` corresponds to the first predicted time step of each sample.\\n            If a list of integers, each value must be < 0. Uses only the specified values as lags.\\n            If a dictionary, the keys correspond to the `past_covariates` component names (of the first series when\\n            using multiple series) and the values correspond to the component lags (integer or list of integers). The\\n            key \\'default_lags\\' can be used to provide default lags for un-specified components. Raises and error if some\\n            components are missing and the \\'default_lags\\' key is not provided.\\n        lags_future_covariates\\n            Lagged `future_covariates` values used to predict the next time step/s.\\n            If a tuple of `(past, future)`, both values must be > 0. Uses the last `n=past` past lags and `n=future`\\n            future lags; e.g. `(-past, -(past - 1), ..., -1, 0, 1, .... future - 1)`, where `0`\\n            corresponds the first predicted time step of each sample.\\n            If a list of integers, uses only the specified values as lags.\\n            If a dictionary, the keys correspond to the `future_covariates` component names (of the first series when\\n            using multiple series) and the values correspond to the component lags (tuple or list of integers). The key\\n            \\'default_lags\\' can be used to provide default lags for un-specified components. Raises and error if some\\n            components are missing and the \\'default_lags\\' key is not provided.\\n        output_chunk_length\\n            Number of time steps predicted at once by the internal regression model. Does not have to equal the forecast\\n            horizon `n` used in `predict()`. However, setting `output_chunk_length` equal to the forecast horizon may\\n            be useful if the covariates don\\'t extend far enough into the future.\\n        add_encoders\\n            A large number of past and future covariates can be automatically generated with `add_encoders`.\\n            This can be done by adding multiple pre-defined index encoders and/or custom user-made functions that\\n            will be used as index encoders. Additionally, a transformer such as Darts\\' :class:`Scaler` can be added to\\n            transform the generated covariates. This happens all under one hood and only needs to be specified at\\n            model creation.\\n            Read :meth:`SequentialEncoder <darts.dataprocessing.encoders.SequentialEncoder>` to find out more about\\n            ``add_encoders``. Default: ``None``. An example showing some of ``add_encoders`` features:\\n\\n            .. highlight:: python\\n            .. code-block:: python\\n\\n                def encode_year(idx):\\n                    return (idx.year - 1950) / 50\\n\\n                add_encoders={\\n                    \\'cyclic\\': {\\'future\\': [\\'month\\']},\\n                    \\'datetime_attribute\\': {\\'future\\': [\\'hour\\', \\'dayofweek\\']},\\n                    \\'position\\': {\\'past\\': [\\'relative\\'], \\'future\\': [\\'relative\\']},\\n                    \\'custom\\': {\\'past\\': [encode_year]},\\n                    \\'transformer\\': Scaler(),\\n                    \\'tz\\': \\'CET\\'\\n                }\\n            ..\\n        likelihood\\n            Can be set to `quantile` or `poisson`. If set, the model will be probabilistic, allowing sampling at\\n            prediction time. If set to `quantile`, the `sklearn.linear_model.QuantileRegressor` is used. Similarly, if\\n            set to `poisson`, the `sklearn.linear_model.PoissonRegressor` is used.\\n        quantiles\\n            Fit the model to these quantiles if the `likelihood` is set to `quantile`.\\n        random_state\\n            Control the randomness of the sampling. Used as seed for\\n            `numpy.random.Generator\\n            <https://numpy.org/doc/stable/reference/random/generator.html#numpy.random.Generator>`_. Ignored when\\n            no `likelihood` is set.\\n            Default: ``None``.\\n        multi_models\\n            If True, a separate model will be trained for each future lag to predict. If False, a single model is\\n            trained to predict at step \\'output_chunk_length\\' in the future. Default: True.\\n        use_static_covariates\\n            Whether the model should use static covariate information in case the input `series` passed to ``fit()``\\n            contain static covariates. If ``True``, and static covariates are available at fitting time, will enforce\\n            that all target `series` have the same static covariate dimensionality in ``fit()`` and ``predict()``.\\n        **kwargs\\n            Additional keyword arguments passed to `sklearn.linear_model.LinearRegression` (by default), to\\n            `sklearn.linear_model.PoissonRegressor` (if `likelihood=\"poisson\"`), or to\\n            `sklearn.linear_model.QuantileRegressor` (if `likelihood=\"quantile\"`).\\n\\n        Examples\\n        --------\\n        Deterministic forecasting, using past/future covariates (optional)\\n\\n        >>> from darts.datasets import WeatherDataset\\n        >>> from darts.models import LinearRegressionModel\\n        >>> series = WeatherDataset().load()\\n        >>> # predicting atmospheric pressure\\n        >>> target = series[\\'p (mbar)\\'][:100]\\n        >>> # optionally, use past observed rainfall (pretending to be unknown beyond index 100)\\n        >>> past_cov = series[\\'rain (mm)\\'][:100]\\n        >>> # optionally, use future temperatures (pretending this component is a forecast)\\n        >>> future_cov = series[\\'T (degC)\\'][:106]\\n        >>> # predict 6 pressure values using the 12 past values of pressure and rainfall, as well as the 6 temperature\\n        >>> # values corresponding to the forecasted period\\n        >>> model = LinearRegressionModel(\\n        >>>     lags=12,\\n        >>>     lags_past_covariates=12,\\n        >>>     lags_future_covariates=[0,1,2,3,4,5],\\n        >>>     output_chunk_length=6,\\n        >>> )\\n        >>> model.fit(target, past_covariates=past_cov, future_covariates=future_cov)\\n        >>> pred = model.predict(6)\\n        >>> pred.values()\\n        array([[1005.72085839],\\n               [1005.6548696 ],\\n               [1005.65403772],\\n               [1005.6846175 ],\\n               [1005.75753605],\\n               [1005.81830675]])\\n        '\n    self.kwargs = kwargs\n    self._median_idx = None\n    self._model_container = None\n    self.quantiles = None\n    self.likelihood = likelihood\n    self._rng = None\n    available_likelihoods = ['quantile', 'poisson']\n    if likelihood is not None:\n        self._check_likelihood(likelihood, available_likelihoods)\n        self._rng = np.random.default_rng(seed=random_state)\n        if likelihood == 'poisson':\n            model = PoissonRegressor(**kwargs)\n        if likelihood == 'quantile':\n            model = QuantileRegressor(**kwargs)\n            (self.quantiles, self._median_idx) = self._prepare_quantiles(quantiles)\n            self._model_container = self._get_model_container()\n    else:\n        model = LinearRegression(**kwargs)\n    super().__init__(lags=lags, lags_past_covariates=lags_past_covariates, lags_future_covariates=lags_future_covariates, output_chunk_length=output_chunk_length, add_encoders=add_encoders, model=model, multi_models=multi_models, use_static_covariates=use_static_covariates)",
            "def __init__(self, lags: Optional[LAGS_TYPE]=None, lags_past_covariates: Optional[LAGS_TYPE]=None, lags_future_covariates: Optional[FUTURE_LAGS_TYPE]=None, output_chunk_length: int=1, add_encoders: Optional[dict]=None, likelihood: Optional[str]=None, quantiles: Optional[List[float]]=None, random_state: Optional[int]=None, multi_models: Optional[bool]=True, use_static_covariates: bool=True, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Linear regression model.\\n\\n        Parameters\\n        ----------\\n        lags\\n            Lagged target `series` values used to predict the next time step/s.\\n            If an integer, must be > 0. Uses the last `n=lags` past lags; e.g. `(-1, -2, ..., -lags)`, where `0`\\n            corresponds the first predicted time step of each sample.\\n            If a list of integers, each value must be < 0. Uses only the specified values as lags.\\n            If a dictionary, the keys correspond to the `series` component names (of the first series when\\n            using multiple series) and the values correspond to the component lags (integer or list of integers). The\\n            key \\'default_lags\\' can be used to provide default lags for un-specified components. Raises and error if some\\n            components are missing and the \\'default_lags\\' key is not provided.\\n        lags_past_covariates\\n            Lagged `past_covariates` values used to predict the next time step/s.\\n            If an integer, must be > 0. Uses the last `n=lags_past_covariates` past lags; e.g. `(-1, -2, ..., -lags)`,\\n            where `0` corresponds to the first predicted time step of each sample.\\n            If a list of integers, each value must be < 0. Uses only the specified values as lags.\\n            If a dictionary, the keys correspond to the `past_covariates` component names (of the first series when\\n            using multiple series) and the values correspond to the component lags (integer or list of integers). The\\n            key \\'default_lags\\' can be used to provide default lags for un-specified components. Raises and error if some\\n            components are missing and the \\'default_lags\\' key is not provided.\\n        lags_future_covariates\\n            Lagged `future_covariates` values used to predict the next time step/s.\\n            If a tuple of `(past, future)`, both values must be > 0. Uses the last `n=past` past lags and `n=future`\\n            future lags; e.g. `(-past, -(past - 1), ..., -1, 0, 1, .... future - 1)`, where `0`\\n            corresponds the first predicted time step of each sample.\\n            If a list of integers, uses only the specified values as lags.\\n            If a dictionary, the keys correspond to the `future_covariates` component names (of the first series when\\n            using multiple series) and the values correspond to the component lags (tuple or list of integers). The key\\n            \\'default_lags\\' can be used to provide default lags for un-specified components. Raises and error if some\\n            components are missing and the \\'default_lags\\' key is not provided.\\n        output_chunk_length\\n            Number of time steps predicted at once by the internal regression model. Does not have to equal the forecast\\n            horizon `n` used in `predict()`. However, setting `output_chunk_length` equal to the forecast horizon may\\n            be useful if the covariates don\\'t extend far enough into the future.\\n        add_encoders\\n            A large number of past and future covariates can be automatically generated with `add_encoders`.\\n            This can be done by adding multiple pre-defined index encoders and/or custom user-made functions that\\n            will be used as index encoders. Additionally, a transformer such as Darts\\' :class:`Scaler` can be added to\\n            transform the generated covariates. This happens all under one hood and only needs to be specified at\\n            model creation.\\n            Read :meth:`SequentialEncoder <darts.dataprocessing.encoders.SequentialEncoder>` to find out more about\\n            ``add_encoders``. Default: ``None``. An example showing some of ``add_encoders`` features:\\n\\n            .. highlight:: python\\n            .. code-block:: python\\n\\n                def encode_year(idx):\\n                    return (idx.year - 1950) / 50\\n\\n                add_encoders={\\n                    \\'cyclic\\': {\\'future\\': [\\'month\\']},\\n                    \\'datetime_attribute\\': {\\'future\\': [\\'hour\\', \\'dayofweek\\']},\\n                    \\'position\\': {\\'past\\': [\\'relative\\'], \\'future\\': [\\'relative\\']},\\n                    \\'custom\\': {\\'past\\': [encode_year]},\\n                    \\'transformer\\': Scaler(),\\n                    \\'tz\\': \\'CET\\'\\n                }\\n            ..\\n        likelihood\\n            Can be set to `quantile` or `poisson`. If set, the model will be probabilistic, allowing sampling at\\n            prediction time. If set to `quantile`, the `sklearn.linear_model.QuantileRegressor` is used. Similarly, if\\n            set to `poisson`, the `sklearn.linear_model.PoissonRegressor` is used.\\n        quantiles\\n            Fit the model to these quantiles if the `likelihood` is set to `quantile`.\\n        random_state\\n            Control the randomness of the sampling. Used as seed for\\n            `numpy.random.Generator\\n            <https://numpy.org/doc/stable/reference/random/generator.html#numpy.random.Generator>`_. Ignored when\\n            no `likelihood` is set.\\n            Default: ``None``.\\n        multi_models\\n            If True, a separate model will be trained for each future lag to predict. If False, a single model is\\n            trained to predict at step \\'output_chunk_length\\' in the future. Default: True.\\n        use_static_covariates\\n            Whether the model should use static covariate information in case the input `series` passed to ``fit()``\\n            contain static covariates. If ``True``, and static covariates are available at fitting time, will enforce\\n            that all target `series` have the same static covariate dimensionality in ``fit()`` and ``predict()``.\\n        **kwargs\\n            Additional keyword arguments passed to `sklearn.linear_model.LinearRegression` (by default), to\\n            `sklearn.linear_model.PoissonRegressor` (if `likelihood=\"poisson\"`), or to\\n            `sklearn.linear_model.QuantileRegressor` (if `likelihood=\"quantile\"`).\\n\\n        Examples\\n        --------\\n        Deterministic forecasting, using past/future covariates (optional)\\n\\n        >>> from darts.datasets import WeatherDataset\\n        >>> from darts.models import LinearRegressionModel\\n        >>> series = WeatherDataset().load()\\n        >>> # predicting atmospheric pressure\\n        >>> target = series[\\'p (mbar)\\'][:100]\\n        >>> # optionally, use past observed rainfall (pretending to be unknown beyond index 100)\\n        >>> past_cov = series[\\'rain (mm)\\'][:100]\\n        >>> # optionally, use future temperatures (pretending this component is a forecast)\\n        >>> future_cov = series[\\'T (degC)\\'][:106]\\n        >>> # predict 6 pressure values using the 12 past values of pressure and rainfall, as well as the 6 temperature\\n        >>> # values corresponding to the forecasted period\\n        >>> model = LinearRegressionModel(\\n        >>>     lags=12,\\n        >>>     lags_past_covariates=12,\\n        >>>     lags_future_covariates=[0,1,2,3,4,5],\\n        >>>     output_chunk_length=6,\\n        >>> )\\n        >>> model.fit(target, past_covariates=past_cov, future_covariates=future_cov)\\n        >>> pred = model.predict(6)\\n        >>> pred.values()\\n        array([[1005.72085839],\\n               [1005.6548696 ],\\n               [1005.65403772],\\n               [1005.6846175 ],\\n               [1005.75753605],\\n               [1005.81830675]])\\n        '\n    self.kwargs = kwargs\n    self._median_idx = None\n    self._model_container = None\n    self.quantiles = None\n    self.likelihood = likelihood\n    self._rng = None\n    available_likelihoods = ['quantile', 'poisson']\n    if likelihood is not None:\n        self._check_likelihood(likelihood, available_likelihoods)\n        self._rng = np.random.default_rng(seed=random_state)\n        if likelihood == 'poisson':\n            model = PoissonRegressor(**kwargs)\n        if likelihood == 'quantile':\n            model = QuantileRegressor(**kwargs)\n            (self.quantiles, self._median_idx) = self._prepare_quantiles(quantiles)\n            self._model_container = self._get_model_container()\n    else:\n        model = LinearRegression(**kwargs)\n    super().__init__(lags=lags, lags_past_covariates=lags_past_covariates, lags_future_covariates=lags_future_covariates, output_chunk_length=output_chunk_length, add_encoders=add_encoders, model=model, multi_models=multi_models, use_static_covariates=use_static_covariates)"
        ]
    },
    {
        "func_name": "fit",
        "original": "def fit(self, series: Union[TimeSeries, Sequence[TimeSeries]], past_covariates: Optional[Union[TimeSeries, Sequence[TimeSeries]]]=None, future_covariates: Optional[Union[TimeSeries, Sequence[TimeSeries]]]=None, max_samples_per_ts: Optional[int]=None, n_jobs_multioutput_wrapper: Optional[int]=None, **kwargs):\n    \"\"\"\n        Fit/train the model on one or multiple series.\n\n        Parameters\n        ----------\n        series\n            TimeSeries or Sequence[TimeSeries] object containing the target values.\n        past_covariates\n            Optionally, a series or sequence of series specifying past-observed covariates\n        future_covariates\n            Optionally, a series or sequence of series specifying future-known covariates\n        max_samples_per_ts\n            This is an integer upper bound on the number of tuples that can be produced\n            per time series. It can be used in order to have an upper bound on the total size of the dataset and\n            ensure proper sampling. If `None`, it will read all of the individual time series in advance (at dataset\n            creation) to know their sizes, which might be expensive on big datasets.\n            If some series turn out to have a length that would allow more than `max_samples_per_ts`, only the\n            most recent `max_samples_per_ts` samples will be considered.\n        n_jobs_multioutput_wrapper\n            Number of jobs of the MultiOutputRegressor wrapper to run in parallel. Only used if the model doesn't\n            support multi-output regression natively.\n        **kwargs\n            Additional keyword arguments passed to the `fit` method of the model.\n        \"\"\"\n    if self.likelihood == 'quantile':\n        if 'solver' not in self.kwargs:\n            self.kwargs['solver'] = 'highs'\n        c = [1]\n        try:\n            linprog(c=c, method=self.kwargs['solver'])\n        except ValueError as ve:\n            logger.warning(f'{ve}. Upgrading scipy enables significantly faster solvers')\n            self.kwargs['solver'] = 'interior-point'\n        self._model_container.clear()\n        for quantile in self.quantiles:\n            self.kwargs['quantile'] = quantile\n            self.model = QuantileRegressor(**self.kwargs)\n            super().fit(series=series, past_covariates=past_covariates, future_covariates=future_covariates, max_samples_per_ts=max_samples_per_ts, **kwargs)\n            self._model_container[quantile] = self.model\n        return self\n    else:\n        super().fit(series=series, past_covariates=past_covariates, future_covariates=future_covariates, max_samples_per_ts=max_samples_per_ts, **kwargs)\n        return self",
        "mutated": [
            "def fit(self, series: Union[TimeSeries, Sequence[TimeSeries]], past_covariates: Optional[Union[TimeSeries, Sequence[TimeSeries]]]=None, future_covariates: Optional[Union[TimeSeries, Sequence[TimeSeries]]]=None, max_samples_per_ts: Optional[int]=None, n_jobs_multioutput_wrapper: Optional[int]=None, **kwargs):\n    if False:\n        i = 10\n    \"\\n        Fit/train the model on one or multiple series.\\n\\n        Parameters\\n        ----------\\n        series\\n            TimeSeries or Sequence[TimeSeries] object containing the target values.\\n        past_covariates\\n            Optionally, a series or sequence of series specifying past-observed covariates\\n        future_covariates\\n            Optionally, a series or sequence of series specifying future-known covariates\\n        max_samples_per_ts\\n            This is an integer upper bound on the number of tuples that can be produced\\n            per time series. It can be used in order to have an upper bound on the total size of the dataset and\\n            ensure proper sampling. If `None`, it will read all of the individual time series in advance (at dataset\\n            creation) to know their sizes, which might be expensive on big datasets.\\n            If some series turn out to have a length that would allow more than `max_samples_per_ts`, only the\\n            most recent `max_samples_per_ts` samples will be considered.\\n        n_jobs_multioutput_wrapper\\n            Number of jobs of the MultiOutputRegressor wrapper to run in parallel. Only used if the model doesn't\\n            support multi-output regression natively.\\n        **kwargs\\n            Additional keyword arguments passed to the `fit` method of the model.\\n        \"\n    if self.likelihood == 'quantile':\n        if 'solver' not in self.kwargs:\n            self.kwargs['solver'] = 'highs'\n        c = [1]\n        try:\n            linprog(c=c, method=self.kwargs['solver'])\n        except ValueError as ve:\n            logger.warning(f'{ve}. Upgrading scipy enables significantly faster solvers')\n            self.kwargs['solver'] = 'interior-point'\n        self._model_container.clear()\n        for quantile in self.quantiles:\n            self.kwargs['quantile'] = quantile\n            self.model = QuantileRegressor(**self.kwargs)\n            super().fit(series=series, past_covariates=past_covariates, future_covariates=future_covariates, max_samples_per_ts=max_samples_per_ts, **kwargs)\n            self._model_container[quantile] = self.model\n        return self\n    else:\n        super().fit(series=series, past_covariates=past_covariates, future_covariates=future_covariates, max_samples_per_ts=max_samples_per_ts, **kwargs)\n        return self",
            "def fit(self, series: Union[TimeSeries, Sequence[TimeSeries]], past_covariates: Optional[Union[TimeSeries, Sequence[TimeSeries]]]=None, future_covariates: Optional[Union[TimeSeries, Sequence[TimeSeries]]]=None, max_samples_per_ts: Optional[int]=None, n_jobs_multioutput_wrapper: Optional[int]=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n        Fit/train the model on one or multiple series.\\n\\n        Parameters\\n        ----------\\n        series\\n            TimeSeries or Sequence[TimeSeries] object containing the target values.\\n        past_covariates\\n            Optionally, a series or sequence of series specifying past-observed covariates\\n        future_covariates\\n            Optionally, a series or sequence of series specifying future-known covariates\\n        max_samples_per_ts\\n            This is an integer upper bound on the number of tuples that can be produced\\n            per time series. It can be used in order to have an upper bound on the total size of the dataset and\\n            ensure proper sampling. If `None`, it will read all of the individual time series in advance (at dataset\\n            creation) to know their sizes, which might be expensive on big datasets.\\n            If some series turn out to have a length that would allow more than `max_samples_per_ts`, only the\\n            most recent `max_samples_per_ts` samples will be considered.\\n        n_jobs_multioutput_wrapper\\n            Number of jobs of the MultiOutputRegressor wrapper to run in parallel. Only used if the model doesn't\\n            support multi-output regression natively.\\n        **kwargs\\n            Additional keyword arguments passed to the `fit` method of the model.\\n        \"\n    if self.likelihood == 'quantile':\n        if 'solver' not in self.kwargs:\n            self.kwargs['solver'] = 'highs'\n        c = [1]\n        try:\n            linprog(c=c, method=self.kwargs['solver'])\n        except ValueError as ve:\n            logger.warning(f'{ve}. Upgrading scipy enables significantly faster solvers')\n            self.kwargs['solver'] = 'interior-point'\n        self._model_container.clear()\n        for quantile in self.quantiles:\n            self.kwargs['quantile'] = quantile\n            self.model = QuantileRegressor(**self.kwargs)\n            super().fit(series=series, past_covariates=past_covariates, future_covariates=future_covariates, max_samples_per_ts=max_samples_per_ts, **kwargs)\n            self._model_container[quantile] = self.model\n        return self\n    else:\n        super().fit(series=series, past_covariates=past_covariates, future_covariates=future_covariates, max_samples_per_ts=max_samples_per_ts, **kwargs)\n        return self",
            "def fit(self, series: Union[TimeSeries, Sequence[TimeSeries]], past_covariates: Optional[Union[TimeSeries, Sequence[TimeSeries]]]=None, future_covariates: Optional[Union[TimeSeries, Sequence[TimeSeries]]]=None, max_samples_per_ts: Optional[int]=None, n_jobs_multioutput_wrapper: Optional[int]=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n        Fit/train the model on one or multiple series.\\n\\n        Parameters\\n        ----------\\n        series\\n            TimeSeries or Sequence[TimeSeries] object containing the target values.\\n        past_covariates\\n            Optionally, a series or sequence of series specifying past-observed covariates\\n        future_covariates\\n            Optionally, a series or sequence of series specifying future-known covariates\\n        max_samples_per_ts\\n            This is an integer upper bound on the number of tuples that can be produced\\n            per time series. It can be used in order to have an upper bound on the total size of the dataset and\\n            ensure proper sampling. If `None`, it will read all of the individual time series in advance (at dataset\\n            creation) to know their sizes, which might be expensive on big datasets.\\n            If some series turn out to have a length that would allow more than `max_samples_per_ts`, only the\\n            most recent `max_samples_per_ts` samples will be considered.\\n        n_jobs_multioutput_wrapper\\n            Number of jobs of the MultiOutputRegressor wrapper to run in parallel. Only used if the model doesn't\\n            support multi-output regression natively.\\n        **kwargs\\n            Additional keyword arguments passed to the `fit` method of the model.\\n        \"\n    if self.likelihood == 'quantile':\n        if 'solver' not in self.kwargs:\n            self.kwargs['solver'] = 'highs'\n        c = [1]\n        try:\n            linprog(c=c, method=self.kwargs['solver'])\n        except ValueError as ve:\n            logger.warning(f'{ve}. Upgrading scipy enables significantly faster solvers')\n            self.kwargs['solver'] = 'interior-point'\n        self._model_container.clear()\n        for quantile in self.quantiles:\n            self.kwargs['quantile'] = quantile\n            self.model = QuantileRegressor(**self.kwargs)\n            super().fit(series=series, past_covariates=past_covariates, future_covariates=future_covariates, max_samples_per_ts=max_samples_per_ts, **kwargs)\n            self._model_container[quantile] = self.model\n        return self\n    else:\n        super().fit(series=series, past_covariates=past_covariates, future_covariates=future_covariates, max_samples_per_ts=max_samples_per_ts, **kwargs)\n        return self",
            "def fit(self, series: Union[TimeSeries, Sequence[TimeSeries]], past_covariates: Optional[Union[TimeSeries, Sequence[TimeSeries]]]=None, future_covariates: Optional[Union[TimeSeries, Sequence[TimeSeries]]]=None, max_samples_per_ts: Optional[int]=None, n_jobs_multioutput_wrapper: Optional[int]=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n        Fit/train the model on one or multiple series.\\n\\n        Parameters\\n        ----------\\n        series\\n            TimeSeries or Sequence[TimeSeries] object containing the target values.\\n        past_covariates\\n            Optionally, a series or sequence of series specifying past-observed covariates\\n        future_covariates\\n            Optionally, a series or sequence of series specifying future-known covariates\\n        max_samples_per_ts\\n            This is an integer upper bound on the number of tuples that can be produced\\n            per time series. It can be used in order to have an upper bound on the total size of the dataset and\\n            ensure proper sampling. If `None`, it will read all of the individual time series in advance (at dataset\\n            creation) to know their sizes, which might be expensive on big datasets.\\n            If some series turn out to have a length that would allow more than `max_samples_per_ts`, only the\\n            most recent `max_samples_per_ts` samples will be considered.\\n        n_jobs_multioutput_wrapper\\n            Number of jobs of the MultiOutputRegressor wrapper to run in parallel. Only used if the model doesn't\\n            support multi-output regression natively.\\n        **kwargs\\n            Additional keyword arguments passed to the `fit` method of the model.\\n        \"\n    if self.likelihood == 'quantile':\n        if 'solver' not in self.kwargs:\n            self.kwargs['solver'] = 'highs'\n        c = [1]\n        try:\n            linprog(c=c, method=self.kwargs['solver'])\n        except ValueError as ve:\n            logger.warning(f'{ve}. Upgrading scipy enables significantly faster solvers')\n            self.kwargs['solver'] = 'interior-point'\n        self._model_container.clear()\n        for quantile in self.quantiles:\n            self.kwargs['quantile'] = quantile\n            self.model = QuantileRegressor(**self.kwargs)\n            super().fit(series=series, past_covariates=past_covariates, future_covariates=future_covariates, max_samples_per_ts=max_samples_per_ts, **kwargs)\n            self._model_container[quantile] = self.model\n        return self\n    else:\n        super().fit(series=series, past_covariates=past_covariates, future_covariates=future_covariates, max_samples_per_ts=max_samples_per_ts, **kwargs)\n        return self",
            "def fit(self, series: Union[TimeSeries, Sequence[TimeSeries]], past_covariates: Optional[Union[TimeSeries, Sequence[TimeSeries]]]=None, future_covariates: Optional[Union[TimeSeries, Sequence[TimeSeries]]]=None, max_samples_per_ts: Optional[int]=None, n_jobs_multioutput_wrapper: Optional[int]=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n        Fit/train the model on one or multiple series.\\n\\n        Parameters\\n        ----------\\n        series\\n            TimeSeries or Sequence[TimeSeries] object containing the target values.\\n        past_covariates\\n            Optionally, a series or sequence of series specifying past-observed covariates\\n        future_covariates\\n            Optionally, a series or sequence of series specifying future-known covariates\\n        max_samples_per_ts\\n            This is an integer upper bound on the number of tuples that can be produced\\n            per time series. It can be used in order to have an upper bound on the total size of the dataset and\\n            ensure proper sampling. If `None`, it will read all of the individual time series in advance (at dataset\\n            creation) to know their sizes, which might be expensive on big datasets.\\n            If some series turn out to have a length that would allow more than `max_samples_per_ts`, only the\\n            most recent `max_samples_per_ts` samples will be considered.\\n        n_jobs_multioutput_wrapper\\n            Number of jobs of the MultiOutputRegressor wrapper to run in parallel. Only used if the model doesn't\\n            support multi-output regression natively.\\n        **kwargs\\n            Additional keyword arguments passed to the `fit` method of the model.\\n        \"\n    if self.likelihood == 'quantile':\n        if 'solver' not in self.kwargs:\n            self.kwargs['solver'] = 'highs'\n        c = [1]\n        try:\n            linprog(c=c, method=self.kwargs['solver'])\n        except ValueError as ve:\n            logger.warning(f'{ve}. Upgrading scipy enables significantly faster solvers')\n            self.kwargs['solver'] = 'interior-point'\n        self._model_container.clear()\n        for quantile in self.quantiles:\n            self.kwargs['quantile'] = quantile\n            self.model = QuantileRegressor(**self.kwargs)\n            super().fit(series=series, past_covariates=past_covariates, future_covariates=future_covariates, max_samples_per_ts=max_samples_per_ts, **kwargs)\n            self._model_container[quantile] = self.model\n        return self\n    else:\n        super().fit(series=series, past_covariates=past_covariates, future_covariates=future_covariates, max_samples_per_ts=max_samples_per_ts, **kwargs)\n        return self"
        ]
    },
    {
        "func_name": "_predict_and_sample",
        "original": "def _predict_and_sample(self, x: np.ndarray, num_samples: int, predict_likelihood_parameters: bool, **kwargs) -> np.ndarray:\n    if self.likelihood is not None:\n        return self._predict_and_sample_likelihood(x, num_samples, self.likelihood, predict_likelihood_parameters, **kwargs)\n    else:\n        return super()._predict_and_sample(x, num_samples, predict_likelihood_parameters, **kwargs)",
        "mutated": [
            "def _predict_and_sample(self, x: np.ndarray, num_samples: int, predict_likelihood_parameters: bool, **kwargs) -> np.ndarray:\n    if False:\n        i = 10\n    if self.likelihood is not None:\n        return self._predict_and_sample_likelihood(x, num_samples, self.likelihood, predict_likelihood_parameters, **kwargs)\n    else:\n        return super()._predict_and_sample(x, num_samples, predict_likelihood_parameters, **kwargs)",
            "def _predict_and_sample(self, x: np.ndarray, num_samples: int, predict_likelihood_parameters: bool, **kwargs) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self.likelihood is not None:\n        return self._predict_and_sample_likelihood(x, num_samples, self.likelihood, predict_likelihood_parameters, **kwargs)\n    else:\n        return super()._predict_and_sample(x, num_samples, predict_likelihood_parameters, **kwargs)",
            "def _predict_and_sample(self, x: np.ndarray, num_samples: int, predict_likelihood_parameters: bool, **kwargs) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self.likelihood is not None:\n        return self._predict_and_sample_likelihood(x, num_samples, self.likelihood, predict_likelihood_parameters, **kwargs)\n    else:\n        return super()._predict_and_sample(x, num_samples, predict_likelihood_parameters, **kwargs)",
            "def _predict_and_sample(self, x: np.ndarray, num_samples: int, predict_likelihood_parameters: bool, **kwargs) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self.likelihood is not None:\n        return self._predict_and_sample_likelihood(x, num_samples, self.likelihood, predict_likelihood_parameters, **kwargs)\n    else:\n        return super()._predict_and_sample(x, num_samples, predict_likelihood_parameters, **kwargs)",
            "def _predict_and_sample(self, x: np.ndarray, num_samples: int, predict_likelihood_parameters: bool, **kwargs) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self.likelihood is not None:\n        return self._predict_and_sample_likelihood(x, num_samples, self.likelihood, predict_likelihood_parameters, **kwargs)\n    else:\n        return super()._predict_and_sample(x, num_samples, predict_likelihood_parameters, **kwargs)"
        ]
    },
    {
        "func_name": "_is_probabilistic",
        "original": "@property\ndef _is_probabilistic(self) -> bool:\n    return self.likelihood is not None",
        "mutated": [
            "@property\ndef _is_probabilistic(self) -> bool:\n    if False:\n        i = 10\n    return self.likelihood is not None",
            "@property\ndef _is_probabilistic(self) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return self.likelihood is not None",
            "@property\ndef _is_probabilistic(self) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return self.likelihood is not None",
            "@property\ndef _is_probabilistic(self) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return self.likelihood is not None",
            "@property\ndef _is_probabilistic(self) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return self.likelihood is not None"
        ]
    }
]