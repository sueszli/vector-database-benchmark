[
    {
        "func_name": "test_mmtf",
        "original": "def test_mmtf(self):\n    chain = next(self.mmtf_1A8O.get_chains())\n    ic_chain = IC_Chain(chain)\n    self.assertEqual(len(ic_chain.ordered_aa_ic_list), 70)",
        "mutated": [
            "def test_mmtf(self):\n    if False:\n        i = 10\n    chain = next(self.mmtf_1A8O.get_chains())\n    ic_chain = IC_Chain(chain)\n    self.assertEqual(len(ic_chain.ordered_aa_ic_list), 70)",
            "def test_mmtf(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    chain = next(self.mmtf_1A8O.get_chains())\n    ic_chain = IC_Chain(chain)\n    self.assertEqual(len(ic_chain.ordered_aa_ic_list), 70)",
            "def test_mmtf(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    chain = next(self.mmtf_1A8O.get_chains())\n    ic_chain = IC_Chain(chain)\n    self.assertEqual(len(ic_chain.ordered_aa_ic_list), 70)",
            "def test_mmtf(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    chain = next(self.mmtf_1A8O.get_chains())\n    ic_chain = IC_Chain(chain)\n    self.assertEqual(len(ic_chain.ordered_aa_ic_list), 70)",
            "def test_mmtf(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    chain = next(self.mmtf_1A8O.get_chains())\n    ic_chain = IC_Chain(chain)\n    self.assertEqual(len(ic_chain.ordered_aa_ic_list), 70)"
        ]
    },
    {
        "func_name": "test_rebuild_1a8o",
        "original": "def test_rebuild_1a8o(self):\n    \"\"\"Duplicate tutorial doctests which fail under linux.\"\"\"\n    IC_Chain.MaxPeptideBond = 4.0\n    r = structure_rebuild_test(self.pdb_1A8O, False)\n    self.assertTrue(r['pass'])\n    cic = list(self.pdb_1A8O.get_chains())[0].internal_coord\n    distances = cic.distance_plot()\n    chirality = cic.dihedral_signs()\n    c2 = IC_duplicate(cic.chain)[0]['A']\n    cic2 = c2.internal_coord\n    cic2.atomArray = np.zeros((cic2.AAsiz, 4), dtype=np.float64)\n    cic2.dihedraAngle[:] = 0.0\n    cic2.hedraAngle[:] = 0.0\n    cic2.hedraL12[:] = 0.0\n    cic2.hedraL23[:] = 0.0\n    cic2.copy_initNCaCs(cic)\n    cic2.distplot_to_dh_arrays(distances, chirality)\n    cic2.distance_to_internal_coordinates()\n    c2.internal_to_atom_coordinates()\n    np.allclose(cic2.atomArray, cic.atomArray)",
        "mutated": [
            "def test_rebuild_1a8o(self):\n    if False:\n        i = 10\n    'Duplicate tutorial doctests which fail under linux.'\n    IC_Chain.MaxPeptideBond = 4.0\n    r = structure_rebuild_test(self.pdb_1A8O, False)\n    self.assertTrue(r['pass'])\n    cic = list(self.pdb_1A8O.get_chains())[0].internal_coord\n    distances = cic.distance_plot()\n    chirality = cic.dihedral_signs()\n    c2 = IC_duplicate(cic.chain)[0]['A']\n    cic2 = c2.internal_coord\n    cic2.atomArray = np.zeros((cic2.AAsiz, 4), dtype=np.float64)\n    cic2.dihedraAngle[:] = 0.0\n    cic2.hedraAngle[:] = 0.0\n    cic2.hedraL12[:] = 0.0\n    cic2.hedraL23[:] = 0.0\n    cic2.copy_initNCaCs(cic)\n    cic2.distplot_to_dh_arrays(distances, chirality)\n    cic2.distance_to_internal_coordinates()\n    c2.internal_to_atom_coordinates()\n    np.allclose(cic2.atomArray, cic.atomArray)",
            "def test_rebuild_1a8o(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Duplicate tutorial doctests which fail under linux.'\n    IC_Chain.MaxPeptideBond = 4.0\n    r = structure_rebuild_test(self.pdb_1A8O, False)\n    self.assertTrue(r['pass'])\n    cic = list(self.pdb_1A8O.get_chains())[0].internal_coord\n    distances = cic.distance_plot()\n    chirality = cic.dihedral_signs()\n    c2 = IC_duplicate(cic.chain)[0]['A']\n    cic2 = c2.internal_coord\n    cic2.atomArray = np.zeros((cic2.AAsiz, 4), dtype=np.float64)\n    cic2.dihedraAngle[:] = 0.0\n    cic2.hedraAngle[:] = 0.0\n    cic2.hedraL12[:] = 0.0\n    cic2.hedraL23[:] = 0.0\n    cic2.copy_initNCaCs(cic)\n    cic2.distplot_to_dh_arrays(distances, chirality)\n    cic2.distance_to_internal_coordinates()\n    c2.internal_to_atom_coordinates()\n    np.allclose(cic2.atomArray, cic.atomArray)",
            "def test_rebuild_1a8o(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Duplicate tutorial doctests which fail under linux.'\n    IC_Chain.MaxPeptideBond = 4.0\n    r = structure_rebuild_test(self.pdb_1A8O, False)\n    self.assertTrue(r['pass'])\n    cic = list(self.pdb_1A8O.get_chains())[0].internal_coord\n    distances = cic.distance_plot()\n    chirality = cic.dihedral_signs()\n    c2 = IC_duplicate(cic.chain)[0]['A']\n    cic2 = c2.internal_coord\n    cic2.atomArray = np.zeros((cic2.AAsiz, 4), dtype=np.float64)\n    cic2.dihedraAngle[:] = 0.0\n    cic2.hedraAngle[:] = 0.0\n    cic2.hedraL12[:] = 0.0\n    cic2.hedraL23[:] = 0.0\n    cic2.copy_initNCaCs(cic)\n    cic2.distplot_to_dh_arrays(distances, chirality)\n    cic2.distance_to_internal_coordinates()\n    c2.internal_to_atom_coordinates()\n    np.allclose(cic2.atomArray, cic.atomArray)",
            "def test_rebuild_1a8o(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Duplicate tutorial doctests which fail under linux.'\n    IC_Chain.MaxPeptideBond = 4.0\n    r = structure_rebuild_test(self.pdb_1A8O, False)\n    self.assertTrue(r['pass'])\n    cic = list(self.pdb_1A8O.get_chains())[0].internal_coord\n    distances = cic.distance_plot()\n    chirality = cic.dihedral_signs()\n    c2 = IC_duplicate(cic.chain)[0]['A']\n    cic2 = c2.internal_coord\n    cic2.atomArray = np.zeros((cic2.AAsiz, 4), dtype=np.float64)\n    cic2.dihedraAngle[:] = 0.0\n    cic2.hedraAngle[:] = 0.0\n    cic2.hedraL12[:] = 0.0\n    cic2.hedraL23[:] = 0.0\n    cic2.copy_initNCaCs(cic)\n    cic2.distplot_to_dh_arrays(distances, chirality)\n    cic2.distance_to_internal_coordinates()\n    c2.internal_to_atom_coordinates()\n    np.allclose(cic2.atomArray, cic.atomArray)",
            "def test_rebuild_1a8o(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Duplicate tutorial doctests which fail under linux.'\n    IC_Chain.MaxPeptideBond = 4.0\n    r = structure_rebuild_test(self.pdb_1A8O, False)\n    self.assertTrue(r['pass'])\n    cic = list(self.pdb_1A8O.get_chains())[0].internal_coord\n    distances = cic.distance_plot()\n    chirality = cic.dihedral_signs()\n    c2 = IC_duplicate(cic.chain)[0]['A']\n    cic2 = c2.internal_coord\n    cic2.atomArray = np.zeros((cic2.AAsiz, 4), dtype=np.float64)\n    cic2.dihedraAngle[:] = 0.0\n    cic2.hedraAngle[:] = 0.0\n    cic2.hedraL12[:] = 0.0\n    cic2.hedraL23[:] = 0.0\n    cic2.copy_initNCaCs(cic)\n    cic2.distplot_to_dh_arrays(distances, chirality)\n    cic2.distance_to_internal_coordinates()\n    c2.internal_to_atom_coordinates()\n    np.allclose(cic2.atomArray, cic.atomArray)"
        ]
    },
    {
        "func_name": "test_rebuild_multichain_missing",
        "original": "def test_rebuild_multichain_missing(self):\n    \"\"\"Convert multichain missing atom struct to, from internal coords.\"\"\"\n    r = structure_rebuild_test(self.pdb_2XHE, False)\n    self.assertEqual(r['residues'], 787)\n    self.assertEqual(r['rCount'], 835)\n    self.assertEqual(r['rMatchCount'], 835)\n    self.assertEqual(r['aCount'], 6267)\n    self.assertEqual(r['disAtmCount'], 0)\n    self.assertEqual(r['aCoordMatchCount'], 6267)\n    self.assertEqual(len(r['chains']), 2)\n    self.assertTrue(r['pass'])",
        "mutated": [
            "def test_rebuild_multichain_missing(self):\n    if False:\n        i = 10\n    'Convert multichain missing atom struct to, from internal coords.'\n    r = structure_rebuild_test(self.pdb_2XHE, False)\n    self.assertEqual(r['residues'], 787)\n    self.assertEqual(r['rCount'], 835)\n    self.assertEqual(r['rMatchCount'], 835)\n    self.assertEqual(r['aCount'], 6267)\n    self.assertEqual(r['disAtmCount'], 0)\n    self.assertEqual(r['aCoordMatchCount'], 6267)\n    self.assertEqual(len(r['chains']), 2)\n    self.assertTrue(r['pass'])",
            "def test_rebuild_multichain_missing(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Convert multichain missing atom struct to, from internal coords.'\n    r = structure_rebuild_test(self.pdb_2XHE, False)\n    self.assertEqual(r['residues'], 787)\n    self.assertEqual(r['rCount'], 835)\n    self.assertEqual(r['rMatchCount'], 835)\n    self.assertEqual(r['aCount'], 6267)\n    self.assertEqual(r['disAtmCount'], 0)\n    self.assertEqual(r['aCoordMatchCount'], 6267)\n    self.assertEqual(len(r['chains']), 2)\n    self.assertTrue(r['pass'])",
            "def test_rebuild_multichain_missing(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Convert multichain missing atom struct to, from internal coords.'\n    r = structure_rebuild_test(self.pdb_2XHE, False)\n    self.assertEqual(r['residues'], 787)\n    self.assertEqual(r['rCount'], 835)\n    self.assertEqual(r['rMatchCount'], 835)\n    self.assertEqual(r['aCount'], 6267)\n    self.assertEqual(r['disAtmCount'], 0)\n    self.assertEqual(r['aCoordMatchCount'], 6267)\n    self.assertEqual(len(r['chains']), 2)\n    self.assertTrue(r['pass'])",
            "def test_rebuild_multichain_missing(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Convert multichain missing atom struct to, from internal coords.'\n    r = structure_rebuild_test(self.pdb_2XHE, False)\n    self.assertEqual(r['residues'], 787)\n    self.assertEqual(r['rCount'], 835)\n    self.assertEqual(r['rMatchCount'], 835)\n    self.assertEqual(r['aCount'], 6267)\n    self.assertEqual(r['disAtmCount'], 0)\n    self.assertEqual(r['aCoordMatchCount'], 6267)\n    self.assertEqual(len(r['chains']), 2)\n    self.assertTrue(r['pass'])",
            "def test_rebuild_multichain_missing(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Convert multichain missing atom struct to, from internal coords.'\n    r = structure_rebuild_test(self.pdb_2XHE, False)\n    self.assertEqual(r['residues'], 787)\n    self.assertEqual(r['rCount'], 835)\n    self.assertEqual(r['rMatchCount'], 835)\n    self.assertEqual(r['aCount'], 6267)\n    self.assertEqual(r['disAtmCount'], 0)\n    self.assertEqual(r['aCoordMatchCount'], 6267)\n    self.assertEqual(len(r['chains']), 2)\n    self.assertTrue(r['pass'])"
        ]
    },
    {
        "func_name": "test_rebuild_disordered_atoms_residues",
        "original": "def test_rebuild_disordered_atoms_residues(self):\n    \"\"\"Convert disordered protein to internal coordinates and back.\"\"\"\n    with warnings.catch_warnings(record=True):\n        warnings.simplefilter('always', PDBConstructionWarning)\n        r = structure_rebuild_test(self.cif_3JQH, False)\n    self.assertEqual(r['residues'], 26)\n    self.assertEqual(r['rCount'], 47)\n    self.assertEqual(r['rMatchCount'], 47)\n    self.assertEqual(r['aCount'], 217)\n    self.assertEqual(r['disAtmCount'], 50)\n    self.assertEqual(r['aCoordMatchCount'], 217)\n    self.assertEqual(len(r['chains']), 1)\n    self.assertTrue(r['pass'])\n    IC_Residue.no_altloc = True\n    with warnings.catch_warnings(record=True):\n        warnings.simplefilter('always', PDBConstructionWarning)\n        r = structure_rebuild_test(self.cif_3JQH2, verbose=False, quick=True)\n    self.assertEqual(r['aCoordMatchCount'], 167, msg='no_altloc fail')\n    self.assertTrue(r['pass'], msg='no_altloc fail')\n    IC_Residue.no_altloc = False",
        "mutated": [
            "def test_rebuild_disordered_atoms_residues(self):\n    if False:\n        i = 10\n    'Convert disordered protein to internal coordinates and back.'\n    with warnings.catch_warnings(record=True):\n        warnings.simplefilter('always', PDBConstructionWarning)\n        r = structure_rebuild_test(self.cif_3JQH, False)\n    self.assertEqual(r['residues'], 26)\n    self.assertEqual(r['rCount'], 47)\n    self.assertEqual(r['rMatchCount'], 47)\n    self.assertEqual(r['aCount'], 217)\n    self.assertEqual(r['disAtmCount'], 50)\n    self.assertEqual(r['aCoordMatchCount'], 217)\n    self.assertEqual(len(r['chains']), 1)\n    self.assertTrue(r['pass'])\n    IC_Residue.no_altloc = True\n    with warnings.catch_warnings(record=True):\n        warnings.simplefilter('always', PDBConstructionWarning)\n        r = structure_rebuild_test(self.cif_3JQH2, verbose=False, quick=True)\n    self.assertEqual(r['aCoordMatchCount'], 167, msg='no_altloc fail')\n    self.assertTrue(r['pass'], msg='no_altloc fail')\n    IC_Residue.no_altloc = False",
            "def test_rebuild_disordered_atoms_residues(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Convert disordered protein to internal coordinates and back.'\n    with warnings.catch_warnings(record=True):\n        warnings.simplefilter('always', PDBConstructionWarning)\n        r = structure_rebuild_test(self.cif_3JQH, False)\n    self.assertEqual(r['residues'], 26)\n    self.assertEqual(r['rCount'], 47)\n    self.assertEqual(r['rMatchCount'], 47)\n    self.assertEqual(r['aCount'], 217)\n    self.assertEqual(r['disAtmCount'], 50)\n    self.assertEqual(r['aCoordMatchCount'], 217)\n    self.assertEqual(len(r['chains']), 1)\n    self.assertTrue(r['pass'])\n    IC_Residue.no_altloc = True\n    with warnings.catch_warnings(record=True):\n        warnings.simplefilter('always', PDBConstructionWarning)\n        r = structure_rebuild_test(self.cif_3JQH2, verbose=False, quick=True)\n    self.assertEqual(r['aCoordMatchCount'], 167, msg='no_altloc fail')\n    self.assertTrue(r['pass'], msg='no_altloc fail')\n    IC_Residue.no_altloc = False",
            "def test_rebuild_disordered_atoms_residues(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Convert disordered protein to internal coordinates and back.'\n    with warnings.catch_warnings(record=True):\n        warnings.simplefilter('always', PDBConstructionWarning)\n        r = structure_rebuild_test(self.cif_3JQH, False)\n    self.assertEqual(r['residues'], 26)\n    self.assertEqual(r['rCount'], 47)\n    self.assertEqual(r['rMatchCount'], 47)\n    self.assertEqual(r['aCount'], 217)\n    self.assertEqual(r['disAtmCount'], 50)\n    self.assertEqual(r['aCoordMatchCount'], 217)\n    self.assertEqual(len(r['chains']), 1)\n    self.assertTrue(r['pass'])\n    IC_Residue.no_altloc = True\n    with warnings.catch_warnings(record=True):\n        warnings.simplefilter('always', PDBConstructionWarning)\n        r = structure_rebuild_test(self.cif_3JQH2, verbose=False, quick=True)\n    self.assertEqual(r['aCoordMatchCount'], 167, msg='no_altloc fail')\n    self.assertTrue(r['pass'], msg='no_altloc fail')\n    IC_Residue.no_altloc = False",
            "def test_rebuild_disordered_atoms_residues(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Convert disordered protein to internal coordinates and back.'\n    with warnings.catch_warnings(record=True):\n        warnings.simplefilter('always', PDBConstructionWarning)\n        r = structure_rebuild_test(self.cif_3JQH, False)\n    self.assertEqual(r['residues'], 26)\n    self.assertEqual(r['rCount'], 47)\n    self.assertEqual(r['rMatchCount'], 47)\n    self.assertEqual(r['aCount'], 217)\n    self.assertEqual(r['disAtmCount'], 50)\n    self.assertEqual(r['aCoordMatchCount'], 217)\n    self.assertEqual(len(r['chains']), 1)\n    self.assertTrue(r['pass'])\n    IC_Residue.no_altloc = True\n    with warnings.catch_warnings(record=True):\n        warnings.simplefilter('always', PDBConstructionWarning)\n        r = structure_rebuild_test(self.cif_3JQH2, verbose=False, quick=True)\n    self.assertEqual(r['aCoordMatchCount'], 167, msg='no_altloc fail')\n    self.assertTrue(r['pass'], msg='no_altloc fail')\n    IC_Residue.no_altloc = False",
            "def test_rebuild_disordered_atoms_residues(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Convert disordered protein to internal coordinates and back.'\n    with warnings.catch_warnings(record=True):\n        warnings.simplefilter('always', PDBConstructionWarning)\n        r = structure_rebuild_test(self.cif_3JQH, False)\n    self.assertEqual(r['residues'], 26)\n    self.assertEqual(r['rCount'], 47)\n    self.assertEqual(r['rMatchCount'], 47)\n    self.assertEqual(r['aCount'], 217)\n    self.assertEqual(r['disAtmCount'], 50)\n    self.assertEqual(r['aCoordMatchCount'], 217)\n    self.assertEqual(len(r['chains']), 1)\n    self.assertTrue(r['pass'])\n    IC_Residue.no_altloc = True\n    with warnings.catch_warnings(record=True):\n        warnings.simplefilter('always', PDBConstructionWarning)\n        r = structure_rebuild_test(self.cif_3JQH2, verbose=False, quick=True)\n    self.assertEqual(r['aCoordMatchCount'], 167, msg='no_altloc fail')\n    self.assertTrue(r['pass'], msg='no_altloc fail')\n    IC_Residue.no_altloc = False"
        ]
    },
    {
        "func_name": "test_no_crosstalk",
        "original": "def test_no_crosstalk(self):\n    \"\"\"Deep copy, change few internal coords, test nothing else changes.\"\"\"\n    self.cif_4CUP.atom_to_internal_coordinates()\n    cpy4cup = copy.deepcopy(self.cif_4CUP)\n    cic0 = self.cif_4CUP.child_list[0].child_list[0].internal_coord\n    cic1 = cpy4cup.child_list[0].child_list[0].internal_coord\n    alist = ['omg', 'phi', 'psi', 'chi1', 'chi2', 'chi3', 'chi4', 'chi5', 'tau']\n    delta = 33\n    tdelta = delta / 10.0\n    targPos = 1\n    for ang in alist:\n        ricTarg = cic0.chain.child_list[targPos].internal_coord\n        targPos += 2\n        try:\n            edr = ricTarg.pick_angle(ang)\n            andx = edr.ndx\n            if ang == 'tau':\n                cic0.hedraAngle[andx] += tdelta\n                cic0.hAtoms_needs_update[andx] = True\n                cic0.atomArrayValid[cic0.h2aa[andx]] = False\n                cic0.hAtoms_needs_update[:] = True\n                cic0.atomArrayValid[:] = False\n                cic0.dAtoms_needs_update[:] = True\n            else:\n                cic0.dihedraAngle[andx] += delta\n                if cic0.dihedraAngle[andx] > 180.0:\n                    cic0.dihedraAngle[andx] -= 360.0\n                cic0.dihedraAngleRads[andx] = np.deg2rad(cic0.dihedraAngle[andx])\n                cic0.dAtoms_needs_update[andx] = True\n                cic0.atomArrayValid[cic0.d2aa[andx]] = False\n                pfd = IC_Residue.picFlagsDict\n                if ricTarg.rbase[2] == 'P' and ang == 'omg':\n                    self.assertEqual(edr.bits(), pfd['omg'] | pfd['pomg'])\n                else:\n                    self.assertEqual(edr.bits(), pfd[ang])\n        except AttributeError:\n            pass\n    cic0.internal_to_atom_coordinates()\n    cic0.atom_to_internal_coordinates()\n    hdelta = cic0.hedraAngle - cic1.hedraAngle\n    hdelta[np.abs(hdelta) < 1e-05] = 0.0\n    ddelta = cic0.dihedraAngle - cic1.dihedraAngle\n    ddelta[np.abs(ddelta) < 1e-05] = 0.0\n    ddelta[ddelta < -180.0] += 360.0\n    targPos = 1\n    for ang in alist:\n        ricTarg = cic0.chain.child_list[targPos].internal_coord\n        targPos += 2\n        try:\n            andx = ricTarg.pick_angle(ang).ndx\n            if ang == 'tau':\n                self.assertAlmostEqual(hdelta[andx], tdelta, places=4)\n                hdelta[andx] = 0.0\n                adjAngNdx = ricTarg.pick_angle('N:CA:CB').ndx\n                self.assertNotAlmostEqual(hdelta[adjAngNdx], 0.0, places=1)\n                hdelta[adjAngNdx] = 0.0\n            else:\n                self.assertAlmostEqual(ddelta[andx], delta, places=4)\n                ddelta[andx] = 0.0\n        except AttributeError:\n            pass\n    hsum = hdelta.sum()\n    self.assertEqual(hsum, 0.0)\n    dsum = ddelta.sum()\n    self.assertEqual(dsum, 0.0)\n    hed = list(cic0.hedra.values())[10]\n    val = hed.len12 + 0.5\n    hed.len12 = val\n    self.assertEqual(hed.len12, val)\n    val = hed.len23 + 0.5\n    hed.len23 = val\n    self.assertEqual(hed.len23, val)\n    val = hed.angle + 1\n    hed.angle = val\n    self.assertEqual(hed.angle, val)\n    dihed = list(cic0.dihedra.values())[10]\n    val = dihed.angle + 196\n    dihed.angle = val\n    if val > 180.0:\n        val -= 360.0\n    if val < -180.0:\n        val += 360.0\n    self.assertEqual(dihed.angle, val)",
        "mutated": [
            "def test_no_crosstalk(self):\n    if False:\n        i = 10\n    'Deep copy, change few internal coords, test nothing else changes.'\n    self.cif_4CUP.atom_to_internal_coordinates()\n    cpy4cup = copy.deepcopy(self.cif_4CUP)\n    cic0 = self.cif_4CUP.child_list[0].child_list[0].internal_coord\n    cic1 = cpy4cup.child_list[0].child_list[0].internal_coord\n    alist = ['omg', 'phi', 'psi', 'chi1', 'chi2', 'chi3', 'chi4', 'chi5', 'tau']\n    delta = 33\n    tdelta = delta / 10.0\n    targPos = 1\n    for ang in alist:\n        ricTarg = cic0.chain.child_list[targPos].internal_coord\n        targPos += 2\n        try:\n            edr = ricTarg.pick_angle(ang)\n            andx = edr.ndx\n            if ang == 'tau':\n                cic0.hedraAngle[andx] += tdelta\n                cic0.hAtoms_needs_update[andx] = True\n                cic0.atomArrayValid[cic0.h2aa[andx]] = False\n                cic0.hAtoms_needs_update[:] = True\n                cic0.atomArrayValid[:] = False\n                cic0.dAtoms_needs_update[:] = True\n            else:\n                cic0.dihedraAngle[andx] += delta\n                if cic0.dihedraAngle[andx] > 180.0:\n                    cic0.dihedraAngle[andx] -= 360.0\n                cic0.dihedraAngleRads[andx] = np.deg2rad(cic0.dihedraAngle[andx])\n                cic0.dAtoms_needs_update[andx] = True\n                cic0.atomArrayValid[cic0.d2aa[andx]] = False\n                pfd = IC_Residue.picFlagsDict\n                if ricTarg.rbase[2] == 'P' and ang == 'omg':\n                    self.assertEqual(edr.bits(), pfd['omg'] | pfd['pomg'])\n                else:\n                    self.assertEqual(edr.bits(), pfd[ang])\n        except AttributeError:\n            pass\n    cic0.internal_to_atom_coordinates()\n    cic0.atom_to_internal_coordinates()\n    hdelta = cic0.hedraAngle - cic1.hedraAngle\n    hdelta[np.abs(hdelta) < 1e-05] = 0.0\n    ddelta = cic0.dihedraAngle - cic1.dihedraAngle\n    ddelta[np.abs(ddelta) < 1e-05] = 0.0\n    ddelta[ddelta < -180.0] += 360.0\n    targPos = 1\n    for ang in alist:\n        ricTarg = cic0.chain.child_list[targPos].internal_coord\n        targPos += 2\n        try:\n            andx = ricTarg.pick_angle(ang).ndx\n            if ang == 'tau':\n                self.assertAlmostEqual(hdelta[andx], tdelta, places=4)\n                hdelta[andx] = 0.0\n                adjAngNdx = ricTarg.pick_angle('N:CA:CB').ndx\n                self.assertNotAlmostEqual(hdelta[adjAngNdx], 0.0, places=1)\n                hdelta[adjAngNdx] = 0.0\n            else:\n                self.assertAlmostEqual(ddelta[andx], delta, places=4)\n                ddelta[andx] = 0.0\n        except AttributeError:\n            pass\n    hsum = hdelta.sum()\n    self.assertEqual(hsum, 0.0)\n    dsum = ddelta.sum()\n    self.assertEqual(dsum, 0.0)\n    hed = list(cic0.hedra.values())[10]\n    val = hed.len12 + 0.5\n    hed.len12 = val\n    self.assertEqual(hed.len12, val)\n    val = hed.len23 + 0.5\n    hed.len23 = val\n    self.assertEqual(hed.len23, val)\n    val = hed.angle + 1\n    hed.angle = val\n    self.assertEqual(hed.angle, val)\n    dihed = list(cic0.dihedra.values())[10]\n    val = dihed.angle + 196\n    dihed.angle = val\n    if val > 180.0:\n        val -= 360.0\n    if val < -180.0:\n        val += 360.0\n    self.assertEqual(dihed.angle, val)",
            "def test_no_crosstalk(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Deep copy, change few internal coords, test nothing else changes.'\n    self.cif_4CUP.atom_to_internal_coordinates()\n    cpy4cup = copy.deepcopy(self.cif_4CUP)\n    cic0 = self.cif_4CUP.child_list[0].child_list[0].internal_coord\n    cic1 = cpy4cup.child_list[0].child_list[0].internal_coord\n    alist = ['omg', 'phi', 'psi', 'chi1', 'chi2', 'chi3', 'chi4', 'chi5', 'tau']\n    delta = 33\n    tdelta = delta / 10.0\n    targPos = 1\n    for ang in alist:\n        ricTarg = cic0.chain.child_list[targPos].internal_coord\n        targPos += 2\n        try:\n            edr = ricTarg.pick_angle(ang)\n            andx = edr.ndx\n            if ang == 'tau':\n                cic0.hedraAngle[andx] += tdelta\n                cic0.hAtoms_needs_update[andx] = True\n                cic0.atomArrayValid[cic0.h2aa[andx]] = False\n                cic0.hAtoms_needs_update[:] = True\n                cic0.atomArrayValid[:] = False\n                cic0.dAtoms_needs_update[:] = True\n            else:\n                cic0.dihedraAngle[andx] += delta\n                if cic0.dihedraAngle[andx] > 180.0:\n                    cic0.dihedraAngle[andx] -= 360.0\n                cic0.dihedraAngleRads[andx] = np.deg2rad(cic0.dihedraAngle[andx])\n                cic0.dAtoms_needs_update[andx] = True\n                cic0.atomArrayValid[cic0.d2aa[andx]] = False\n                pfd = IC_Residue.picFlagsDict\n                if ricTarg.rbase[2] == 'P' and ang == 'omg':\n                    self.assertEqual(edr.bits(), pfd['omg'] | pfd['pomg'])\n                else:\n                    self.assertEqual(edr.bits(), pfd[ang])\n        except AttributeError:\n            pass\n    cic0.internal_to_atom_coordinates()\n    cic0.atom_to_internal_coordinates()\n    hdelta = cic0.hedraAngle - cic1.hedraAngle\n    hdelta[np.abs(hdelta) < 1e-05] = 0.0\n    ddelta = cic0.dihedraAngle - cic1.dihedraAngle\n    ddelta[np.abs(ddelta) < 1e-05] = 0.0\n    ddelta[ddelta < -180.0] += 360.0\n    targPos = 1\n    for ang in alist:\n        ricTarg = cic0.chain.child_list[targPos].internal_coord\n        targPos += 2\n        try:\n            andx = ricTarg.pick_angle(ang).ndx\n            if ang == 'tau':\n                self.assertAlmostEqual(hdelta[andx], tdelta, places=4)\n                hdelta[andx] = 0.0\n                adjAngNdx = ricTarg.pick_angle('N:CA:CB').ndx\n                self.assertNotAlmostEqual(hdelta[adjAngNdx], 0.0, places=1)\n                hdelta[adjAngNdx] = 0.0\n            else:\n                self.assertAlmostEqual(ddelta[andx], delta, places=4)\n                ddelta[andx] = 0.0\n        except AttributeError:\n            pass\n    hsum = hdelta.sum()\n    self.assertEqual(hsum, 0.0)\n    dsum = ddelta.sum()\n    self.assertEqual(dsum, 0.0)\n    hed = list(cic0.hedra.values())[10]\n    val = hed.len12 + 0.5\n    hed.len12 = val\n    self.assertEqual(hed.len12, val)\n    val = hed.len23 + 0.5\n    hed.len23 = val\n    self.assertEqual(hed.len23, val)\n    val = hed.angle + 1\n    hed.angle = val\n    self.assertEqual(hed.angle, val)\n    dihed = list(cic0.dihedra.values())[10]\n    val = dihed.angle + 196\n    dihed.angle = val\n    if val > 180.0:\n        val -= 360.0\n    if val < -180.0:\n        val += 360.0\n    self.assertEqual(dihed.angle, val)",
            "def test_no_crosstalk(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Deep copy, change few internal coords, test nothing else changes.'\n    self.cif_4CUP.atom_to_internal_coordinates()\n    cpy4cup = copy.deepcopy(self.cif_4CUP)\n    cic0 = self.cif_4CUP.child_list[0].child_list[0].internal_coord\n    cic1 = cpy4cup.child_list[0].child_list[0].internal_coord\n    alist = ['omg', 'phi', 'psi', 'chi1', 'chi2', 'chi3', 'chi4', 'chi5', 'tau']\n    delta = 33\n    tdelta = delta / 10.0\n    targPos = 1\n    for ang in alist:\n        ricTarg = cic0.chain.child_list[targPos].internal_coord\n        targPos += 2\n        try:\n            edr = ricTarg.pick_angle(ang)\n            andx = edr.ndx\n            if ang == 'tau':\n                cic0.hedraAngle[andx] += tdelta\n                cic0.hAtoms_needs_update[andx] = True\n                cic0.atomArrayValid[cic0.h2aa[andx]] = False\n                cic0.hAtoms_needs_update[:] = True\n                cic0.atomArrayValid[:] = False\n                cic0.dAtoms_needs_update[:] = True\n            else:\n                cic0.dihedraAngle[andx] += delta\n                if cic0.dihedraAngle[andx] > 180.0:\n                    cic0.dihedraAngle[andx] -= 360.0\n                cic0.dihedraAngleRads[andx] = np.deg2rad(cic0.dihedraAngle[andx])\n                cic0.dAtoms_needs_update[andx] = True\n                cic0.atomArrayValid[cic0.d2aa[andx]] = False\n                pfd = IC_Residue.picFlagsDict\n                if ricTarg.rbase[2] == 'P' and ang == 'omg':\n                    self.assertEqual(edr.bits(), pfd['omg'] | pfd['pomg'])\n                else:\n                    self.assertEqual(edr.bits(), pfd[ang])\n        except AttributeError:\n            pass\n    cic0.internal_to_atom_coordinates()\n    cic0.atom_to_internal_coordinates()\n    hdelta = cic0.hedraAngle - cic1.hedraAngle\n    hdelta[np.abs(hdelta) < 1e-05] = 0.0\n    ddelta = cic0.dihedraAngle - cic1.dihedraAngle\n    ddelta[np.abs(ddelta) < 1e-05] = 0.0\n    ddelta[ddelta < -180.0] += 360.0\n    targPos = 1\n    for ang in alist:\n        ricTarg = cic0.chain.child_list[targPos].internal_coord\n        targPos += 2\n        try:\n            andx = ricTarg.pick_angle(ang).ndx\n            if ang == 'tau':\n                self.assertAlmostEqual(hdelta[andx], tdelta, places=4)\n                hdelta[andx] = 0.0\n                adjAngNdx = ricTarg.pick_angle('N:CA:CB').ndx\n                self.assertNotAlmostEqual(hdelta[adjAngNdx], 0.0, places=1)\n                hdelta[adjAngNdx] = 0.0\n            else:\n                self.assertAlmostEqual(ddelta[andx], delta, places=4)\n                ddelta[andx] = 0.0\n        except AttributeError:\n            pass\n    hsum = hdelta.sum()\n    self.assertEqual(hsum, 0.0)\n    dsum = ddelta.sum()\n    self.assertEqual(dsum, 0.0)\n    hed = list(cic0.hedra.values())[10]\n    val = hed.len12 + 0.5\n    hed.len12 = val\n    self.assertEqual(hed.len12, val)\n    val = hed.len23 + 0.5\n    hed.len23 = val\n    self.assertEqual(hed.len23, val)\n    val = hed.angle + 1\n    hed.angle = val\n    self.assertEqual(hed.angle, val)\n    dihed = list(cic0.dihedra.values())[10]\n    val = dihed.angle + 196\n    dihed.angle = val\n    if val > 180.0:\n        val -= 360.0\n    if val < -180.0:\n        val += 360.0\n    self.assertEqual(dihed.angle, val)",
            "def test_no_crosstalk(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Deep copy, change few internal coords, test nothing else changes.'\n    self.cif_4CUP.atom_to_internal_coordinates()\n    cpy4cup = copy.deepcopy(self.cif_4CUP)\n    cic0 = self.cif_4CUP.child_list[0].child_list[0].internal_coord\n    cic1 = cpy4cup.child_list[0].child_list[0].internal_coord\n    alist = ['omg', 'phi', 'psi', 'chi1', 'chi2', 'chi3', 'chi4', 'chi5', 'tau']\n    delta = 33\n    tdelta = delta / 10.0\n    targPos = 1\n    for ang in alist:\n        ricTarg = cic0.chain.child_list[targPos].internal_coord\n        targPos += 2\n        try:\n            edr = ricTarg.pick_angle(ang)\n            andx = edr.ndx\n            if ang == 'tau':\n                cic0.hedraAngle[andx] += tdelta\n                cic0.hAtoms_needs_update[andx] = True\n                cic0.atomArrayValid[cic0.h2aa[andx]] = False\n                cic0.hAtoms_needs_update[:] = True\n                cic0.atomArrayValid[:] = False\n                cic0.dAtoms_needs_update[:] = True\n            else:\n                cic0.dihedraAngle[andx] += delta\n                if cic0.dihedraAngle[andx] > 180.0:\n                    cic0.dihedraAngle[andx] -= 360.0\n                cic0.dihedraAngleRads[andx] = np.deg2rad(cic0.dihedraAngle[andx])\n                cic0.dAtoms_needs_update[andx] = True\n                cic0.atomArrayValid[cic0.d2aa[andx]] = False\n                pfd = IC_Residue.picFlagsDict\n                if ricTarg.rbase[2] == 'P' and ang == 'omg':\n                    self.assertEqual(edr.bits(), pfd['omg'] | pfd['pomg'])\n                else:\n                    self.assertEqual(edr.bits(), pfd[ang])\n        except AttributeError:\n            pass\n    cic0.internal_to_atom_coordinates()\n    cic0.atom_to_internal_coordinates()\n    hdelta = cic0.hedraAngle - cic1.hedraAngle\n    hdelta[np.abs(hdelta) < 1e-05] = 0.0\n    ddelta = cic0.dihedraAngle - cic1.dihedraAngle\n    ddelta[np.abs(ddelta) < 1e-05] = 0.0\n    ddelta[ddelta < -180.0] += 360.0\n    targPos = 1\n    for ang in alist:\n        ricTarg = cic0.chain.child_list[targPos].internal_coord\n        targPos += 2\n        try:\n            andx = ricTarg.pick_angle(ang).ndx\n            if ang == 'tau':\n                self.assertAlmostEqual(hdelta[andx], tdelta, places=4)\n                hdelta[andx] = 0.0\n                adjAngNdx = ricTarg.pick_angle('N:CA:CB').ndx\n                self.assertNotAlmostEqual(hdelta[adjAngNdx], 0.0, places=1)\n                hdelta[adjAngNdx] = 0.0\n            else:\n                self.assertAlmostEqual(ddelta[andx], delta, places=4)\n                ddelta[andx] = 0.0\n        except AttributeError:\n            pass\n    hsum = hdelta.sum()\n    self.assertEqual(hsum, 0.0)\n    dsum = ddelta.sum()\n    self.assertEqual(dsum, 0.0)\n    hed = list(cic0.hedra.values())[10]\n    val = hed.len12 + 0.5\n    hed.len12 = val\n    self.assertEqual(hed.len12, val)\n    val = hed.len23 + 0.5\n    hed.len23 = val\n    self.assertEqual(hed.len23, val)\n    val = hed.angle + 1\n    hed.angle = val\n    self.assertEqual(hed.angle, val)\n    dihed = list(cic0.dihedra.values())[10]\n    val = dihed.angle + 196\n    dihed.angle = val\n    if val > 180.0:\n        val -= 360.0\n    if val < -180.0:\n        val += 360.0\n    self.assertEqual(dihed.angle, val)",
            "def test_no_crosstalk(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Deep copy, change few internal coords, test nothing else changes.'\n    self.cif_4CUP.atom_to_internal_coordinates()\n    cpy4cup = copy.deepcopy(self.cif_4CUP)\n    cic0 = self.cif_4CUP.child_list[0].child_list[0].internal_coord\n    cic1 = cpy4cup.child_list[0].child_list[0].internal_coord\n    alist = ['omg', 'phi', 'psi', 'chi1', 'chi2', 'chi3', 'chi4', 'chi5', 'tau']\n    delta = 33\n    tdelta = delta / 10.0\n    targPos = 1\n    for ang in alist:\n        ricTarg = cic0.chain.child_list[targPos].internal_coord\n        targPos += 2\n        try:\n            edr = ricTarg.pick_angle(ang)\n            andx = edr.ndx\n            if ang == 'tau':\n                cic0.hedraAngle[andx] += tdelta\n                cic0.hAtoms_needs_update[andx] = True\n                cic0.atomArrayValid[cic0.h2aa[andx]] = False\n                cic0.hAtoms_needs_update[:] = True\n                cic0.atomArrayValid[:] = False\n                cic0.dAtoms_needs_update[:] = True\n            else:\n                cic0.dihedraAngle[andx] += delta\n                if cic0.dihedraAngle[andx] > 180.0:\n                    cic0.dihedraAngle[andx] -= 360.0\n                cic0.dihedraAngleRads[andx] = np.deg2rad(cic0.dihedraAngle[andx])\n                cic0.dAtoms_needs_update[andx] = True\n                cic0.atomArrayValid[cic0.d2aa[andx]] = False\n                pfd = IC_Residue.picFlagsDict\n                if ricTarg.rbase[2] == 'P' and ang == 'omg':\n                    self.assertEqual(edr.bits(), pfd['omg'] | pfd['pomg'])\n                else:\n                    self.assertEqual(edr.bits(), pfd[ang])\n        except AttributeError:\n            pass\n    cic0.internal_to_atom_coordinates()\n    cic0.atom_to_internal_coordinates()\n    hdelta = cic0.hedraAngle - cic1.hedraAngle\n    hdelta[np.abs(hdelta) < 1e-05] = 0.0\n    ddelta = cic0.dihedraAngle - cic1.dihedraAngle\n    ddelta[np.abs(ddelta) < 1e-05] = 0.0\n    ddelta[ddelta < -180.0] += 360.0\n    targPos = 1\n    for ang in alist:\n        ricTarg = cic0.chain.child_list[targPos].internal_coord\n        targPos += 2\n        try:\n            andx = ricTarg.pick_angle(ang).ndx\n            if ang == 'tau':\n                self.assertAlmostEqual(hdelta[andx], tdelta, places=4)\n                hdelta[andx] = 0.0\n                adjAngNdx = ricTarg.pick_angle('N:CA:CB').ndx\n                self.assertNotAlmostEqual(hdelta[adjAngNdx], 0.0, places=1)\n                hdelta[adjAngNdx] = 0.0\n            else:\n                self.assertAlmostEqual(ddelta[andx], delta, places=4)\n                ddelta[andx] = 0.0\n        except AttributeError:\n            pass\n    hsum = hdelta.sum()\n    self.assertEqual(hsum, 0.0)\n    dsum = ddelta.sum()\n    self.assertEqual(dsum, 0.0)\n    hed = list(cic0.hedra.values())[10]\n    val = hed.len12 + 0.5\n    hed.len12 = val\n    self.assertEqual(hed.len12, val)\n    val = hed.len23 + 0.5\n    hed.len23 = val\n    self.assertEqual(hed.len23, val)\n    val = hed.angle + 1\n    hed.angle = val\n    self.assertEqual(hed.angle, val)\n    dihed = list(cic0.dihedra.values())[10]\n    val = dihed.angle + 196\n    dihed.angle = val\n    if val > 180.0:\n        val -= 360.0\n    if val < -180.0:\n        val += 360.0\n    self.assertEqual(dihed.angle, val)"
        ]
    },
    {
        "func_name": "test_model_change_internal_coords",
        "original": "def test_model_change_internal_coords(self):\n    \"\"\"Get model internal coords, modify psi and chi1 values and check.\"\"\"\n    mdl = self.pdb_1LCD[1]\n    mdl.atom_to_internal_coordinates()\n    mdl.internal_to_atom_coordinates()\n    nvt = {}\n    nvc1 = {}\n    nvpsi = {}\n    nvlen = {}\n    nvlen2 = {}\n    tcount = 0\n    l2count = 0\n    c1count = 0\n    psicount = 0\n    lcount = 0\n    for r in mdl.get_residues():\n        ric = r.internal_coord\n        if ric:\n            tau = ric.get_angle('tau')\n            if ric.rprev != [] and tau is not None:\n                tcount += 1\n                nv = tau + 0.5\n                ric.set_angle('tau', nv)\n                nvt[str(r)] = nv\n                l2count += 1\n                leng2 = ric.get_length('N:CA')\n                nv = leng2 + 0.05\n                ric.set_length('N:CA', nv)\n                nvlen2[str(r)] = nv\n            chi1 = ric.get_angle('chi1')\n            if chi1 is not None:\n                c1count += 1\n                nv = chi1 + 90\n                if nv > 180.0:\n                    nv -= 360.0\n                ric.bond_set('chi1', nv)\n                nvc1[str(r)] = nv\n            psi = ric.get_angle('psi')\n            if psi is not None:\n                psicount += 1\n                nv = psi - 90\n                if nv < -180.0:\n                    nv += 360.0\n                ric.set_angle('psi', nv)\n                nvpsi[str(r)] = nv\n            leng = ric.get_length('CA:CB')\n            if leng is not None:\n                lcount += 1\n                nv = leng + 0.05\n                ric.set_length('CA:CB', nv)\n                nvlen[str(r)] = nv\n    mdl.internal_to_atom_coordinates()\n    for chn in mdl.get_chains():\n        if hasattr(chn, 'hedraLen'):\n            delattr(chn.internal_coord, 'hedraLen')\n            delattr(chn.internal_coord, 'dihedraLen')\n            delattr(chn.internal_coord, 'hedraAngle')\n            delattr(chn.internal_coord, 'dihedraAngle')\n            for r in chn.get_residues():\n                r.internal_coord.hedra = {}\n                r.internal_coord.dihedra = {}\n    mdl.atom_to_internal_coordinates()\n    ttcount = 0\n    l2tcount = 0\n    c1tcount = 0\n    psitcount = 0\n    ltcount = 0\n    for r in mdl.get_residues():\n        ric = r.internal_coord\n        if ric:\n            tau = ric.get_angle('tau')\n            if ric.rprev != [] and tau is not None:\n                ttcount += 1\n                self.assertAlmostEqual(tau, nvt[str(r)], places=3)\n                l2tcount += 1\n                l2 = ric.get_length('N:CA')\n                self.assertAlmostEqual(l2, nvlen2[str(r)], places=3)\n            chi1 = ric.get_angle('chi1')\n            if chi1 is not None:\n                c1tcount += 1\n                self.assertAlmostEqual(chi1, nvc1[str(r)], places=3)\n            psi = ric.get_angle('psi')\n            if psi is not None:\n                psitcount += 1\n                self.assertAlmostEqual(psi, nvpsi[str(r)], places=3)\n            leng = ric.get_length('CA:CB')\n            if leng is not None:\n                ltcount += 1\n                self.assertAlmostEqual(leng, nvlen[str(r)], places=3)\n    self.assertEqual(tcount, ttcount)\n    self.assertEqual(l2count, l2tcount)\n    self.assertEqual(c1count, c1tcount)\n    self.assertEqual(psicount, psitcount)\n    self.assertEqual(lcount, ltcount)\n    self.assertGreater(ttcount, 0)\n    self.assertGreater(c1count, 0)\n    self.assertGreater(psicount, 0)\n    self.assertGreater(lcount, 0)",
        "mutated": [
            "def test_model_change_internal_coords(self):\n    if False:\n        i = 10\n    'Get model internal coords, modify psi and chi1 values and check.'\n    mdl = self.pdb_1LCD[1]\n    mdl.atom_to_internal_coordinates()\n    mdl.internal_to_atom_coordinates()\n    nvt = {}\n    nvc1 = {}\n    nvpsi = {}\n    nvlen = {}\n    nvlen2 = {}\n    tcount = 0\n    l2count = 0\n    c1count = 0\n    psicount = 0\n    lcount = 0\n    for r in mdl.get_residues():\n        ric = r.internal_coord\n        if ric:\n            tau = ric.get_angle('tau')\n            if ric.rprev != [] and tau is not None:\n                tcount += 1\n                nv = tau + 0.5\n                ric.set_angle('tau', nv)\n                nvt[str(r)] = nv\n                l2count += 1\n                leng2 = ric.get_length('N:CA')\n                nv = leng2 + 0.05\n                ric.set_length('N:CA', nv)\n                nvlen2[str(r)] = nv\n            chi1 = ric.get_angle('chi1')\n            if chi1 is not None:\n                c1count += 1\n                nv = chi1 + 90\n                if nv > 180.0:\n                    nv -= 360.0\n                ric.bond_set('chi1', nv)\n                nvc1[str(r)] = nv\n            psi = ric.get_angle('psi')\n            if psi is not None:\n                psicount += 1\n                nv = psi - 90\n                if nv < -180.0:\n                    nv += 360.0\n                ric.set_angle('psi', nv)\n                nvpsi[str(r)] = nv\n            leng = ric.get_length('CA:CB')\n            if leng is not None:\n                lcount += 1\n                nv = leng + 0.05\n                ric.set_length('CA:CB', nv)\n                nvlen[str(r)] = nv\n    mdl.internal_to_atom_coordinates()\n    for chn in mdl.get_chains():\n        if hasattr(chn, 'hedraLen'):\n            delattr(chn.internal_coord, 'hedraLen')\n            delattr(chn.internal_coord, 'dihedraLen')\n            delattr(chn.internal_coord, 'hedraAngle')\n            delattr(chn.internal_coord, 'dihedraAngle')\n            for r in chn.get_residues():\n                r.internal_coord.hedra = {}\n                r.internal_coord.dihedra = {}\n    mdl.atom_to_internal_coordinates()\n    ttcount = 0\n    l2tcount = 0\n    c1tcount = 0\n    psitcount = 0\n    ltcount = 0\n    for r in mdl.get_residues():\n        ric = r.internal_coord\n        if ric:\n            tau = ric.get_angle('tau')\n            if ric.rprev != [] and tau is not None:\n                ttcount += 1\n                self.assertAlmostEqual(tau, nvt[str(r)], places=3)\n                l2tcount += 1\n                l2 = ric.get_length('N:CA')\n                self.assertAlmostEqual(l2, nvlen2[str(r)], places=3)\n            chi1 = ric.get_angle('chi1')\n            if chi1 is not None:\n                c1tcount += 1\n                self.assertAlmostEqual(chi1, nvc1[str(r)], places=3)\n            psi = ric.get_angle('psi')\n            if psi is not None:\n                psitcount += 1\n                self.assertAlmostEqual(psi, nvpsi[str(r)], places=3)\n            leng = ric.get_length('CA:CB')\n            if leng is not None:\n                ltcount += 1\n                self.assertAlmostEqual(leng, nvlen[str(r)], places=3)\n    self.assertEqual(tcount, ttcount)\n    self.assertEqual(l2count, l2tcount)\n    self.assertEqual(c1count, c1tcount)\n    self.assertEqual(psicount, psitcount)\n    self.assertEqual(lcount, ltcount)\n    self.assertGreater(ttcount, 0)\n    self.assertGreater(c1count, 0)\n    self.assertGreater(psicount, 0)\n    self.assertGreater(lcount, 0)",
            "def test_model_change_internal_coords(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Get model internal coords, modify psi and chi1 values and check.'\n    mdl = self.pdb_1LCD[1]\n    mdl.atom_to_internal_coordinates()\n    mdl.internal_to_atom_coordinates()\n    nvt = {}\n    nvc1 = {}\n    nvpsi = {}\n    nvlen = {}\n    nvlen2 = {}\n    tcount = 0\n    l2count = 0\n    c1count = 0\n    psicount = 0\n    lcount = 0\n    for r in mdl.get_residues():\n        ric = r.internal_coord\n        if ric:\n            tau = ric.get_angle('tau')\n            if ric.rprev != [] and tau is not None:\n                tcount += 1\n                nv = tau + 0.5\n                ric.set_angle('tau', nv)\n                nvt[str(r)] = nv\n                l2count += 1\n                leng2 = ric.get_length('N:CA')\n                nv = leng2 + 0.05\n                ric.set_length('N:CA', nv)\n                nvlen2[str(r)] = nv\n            chi1 = ric.get_angle('chi1')\n            if chi1 is not None:\n                c1count += 1\n                nv = chi1 + 90\n                if nv > 180.0:\n                    nv -= 360.0\n                ric.bond_set('chi1', nv)\n                nvc1[str(r)] = nv\n            psi = ric.get_angle('psi')\n            if psi is not None:\n                psicount += 1\n                nv = psi - 90\n                if nv < -180.0:\n                    nv += 360.0\n                ric.set_angle('psi', nv)\n                nvpsi[str(r)] = nv\n            leng = ric.get_length('CA:CB')\n            if leng is not None:\n                lcount += 1\n                nv = leng + 0.05\n                ric.set_length('CA:CB', nv)\n                nvlen[str(r)] = nv\n    mdl.internal_to_atom_coordinates()\n    for chn in mdl.get_chains():\n        if hasattr(chn, 'hedraLen'):\n            delattr(chn.internal_coord, 'hedraLen')\n            delattr(chn.internal_coord, 'dihedraLen')\n            delattr(chn.internal_coord, 'hedraAngle')\n            delattr(chn.internal_coord, 'dihedraAngle')\n            for r in chn.get_residues():\n                r.internal_coord.hedra = {}\n                r.internal_coord.dihedra = {}\n    mdl.atom_to_internal_coordinates()\n    ttcount = 0\n    l2tcount = 0\n    c1tcount = 0\n    psitcount = 0\n    ltcount = 0\n    for r in mdl.get_residues():\n        ric = r.internal_coord\n        if ric:\n            tau = ric.get_angle('tau')\n            if ric.rprev != [] and tau is not None:\n                ttcount += 1\n                self.assertAlmostEqual(tau, nvt[str(r)], places=3)\n                l2tcount += 1\n                l2 = ric.get_length('N:CA')\n                self.assertAlmostEqual(l2, nvlen2[str(r)], places=3)\n            chi1 = ric.get_angle('chi1')\n            if chi1 is not None:\n                c1tcount += 1\n                self.assertAlmostEqual(chi1, nvc1[str(r)], places=3)\n            psi = ric.get_angle('psi')\n            if psi is not None:\n                psitcount += 1\n                self.assertAlmostEqual(psi, nvpsi[str(r)], places=3)\n            leng = ric.get_length('CA:CB')\n            if leng is not None:\n                ltcount += 1\n                self.assertAlmostEqual(leng, nvlen[str(r)], places=3)\n    self.assertEqual(tcount, ttcount)\n    self.assertEqual(l2count, l2tcount)\n    self.assertEqual(c1count, c1tcount)\n    self.assertEqual(psicount, psitcount)\n    self.assertEqual(lcount, ltcount)\n    self.assertGreater(ttcount, 0)\n    self.assertGreater(c1count, 0)\n    self.assertGreater(psicount, 0)\n    self.assertGreater(lcount, 0)",
            "def test_model_change_internal_coords(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Get model internal coords, modify psi and chi1 values and check.'\n    mdl = self.pdb_1LCD[1]\n    mdl.atom_to_internal_coordinates()\n    mdl.internal_to_atom_coordinates()\n    nvt = {}\n    nvc1 = {}\n    nvpsi = {}\n    nvlen = {}\n    nvlen2 = {}\n    tcount = 0\n    l2count = 0\n    c1count = 0\n    psicount = 0\n    lcount = 0\n    for r in mdl.get_residues():\n        ric = r.internal_coord\n        if ric:\n            tau = ric.get_angle('tau')\n            if ric.rprev != [] and tau is not None:\n                tcount += 1\n                nv = tau + 0.5\n                ric.set_angle('tau', nv)\n                nvt[str(r)] = nv\n                l2count += 1\n                leng2 = ric.get_length('N:CA')\n                nv = leng2 + 0.05\n                ric.set_length('N:CA', nv)\n                nvlen2[str(r)] = nv\n            chi1 = ric.get_angle('chi1')\n            if chi1 is not None:\n                c1count += 1\n                nv = chi1 + 90\n                if nv > 180.0:\n                    nv -= 360.0\n                ric.bond_set('chi1', nv)\n                nvc1[str(r)] = nv\n            psi = ric.get_angle('psi')\n            if psi is not None:\n                psicount += 1\n                nv = psi - 90\n                if nv < -180.0:\n                    nv += 360.0\n                ric.set_angle('psi', nv)\n                nvpsi[str(r)] = nv\n            leng = ric.get_length('CA:CB')\n            if leng is not None:\n                lcount += 1\n                nv = leng + 0.05\n                ric.set_length('CA:CB', nv)\n                nvlen[str(r)] = nv\n    mdl.internal_to_atom_coordinates()\n    for chn in mdl.get_chains():\n        if hasattr(chn, 'hedraLen'):\n            delattr(chn.internal_coord, 'hedraLen')\n            delattr(chn.internal_coord, 'dihedraLen')\n            delattr(chn.internal_coord, 'hedraAngle')\n            delattr(chn.internal_coord, 'dihedraAngle')\n            for r in chn.get_residues():\n                r.internal_coord.hedra = {}\n                r.internal_coord.dihedra = {}\n    mdl.atom_to_internal_coordinates()\n    ttcount = 0\n    l2tcount = 0\n    c1tcount = 0\n    psitcount = 0\n    ltcount = 0\n    for r in mdl.get_residues():\n        ric = r.internal_coord\n        if ric:\n            tau = ric.get_angle('tau')\n            if ric.rprev != [] and tau is not None:\n                ttcount += 1\n                self.assertAlmostEqual(tau, nvt[str(r)], places=3)\n                l2tcount += 1\n                l2 = ric.get_length('N:CA')\n                self.assertAlmostEqual(l2, nvlen2[str(r)], places=3)\n            chi1 = ric.get_angle('chi1')\n            if chi1 is not None:\n                c1tcount += 1\n                self.assertAlmostEqual(chi1, nvc1[str(r)], places=3)\n            psi = ric.get_angle('psi')\n            if psi is not None:\n                psitcount += 1\n                self.assertAlmostEqual(psi, nvpsi[str(r)], places=3)\n            leng = ric.get_length('CA:CB')\n            if leng is not None:\n                ltcount += 1\n                self.assertAlmostEqual(leng, nvlen[str(r)], places=3)\n    self.assertEqual(tcount, ttcount)\n    self.assertEqual(l2count, l2tcount)\n    self.assertEqual(c1count, c1tcount)\n    self.assertEqual(psicount, psitcount)\n    self.assertEqual(lcount, ltcount)\n    self.assertGreater(ttcount, 0)\n    self.assertGreater(c1count, 0)\n    self.assertGreater(psicount, 0)\n    self.assertGreater(lcount, 0)",
            "def test_model_change_internal_coords(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Get model internal coords, modify psi and chi1 values and check.'\n    mdl = self.pdb_1LCD[1]\n    mdl.atom_to_internal_coordinates()\n    mdl.internal_to_atom_coordinates()\n    nvt = {}\n    nvc1 = {}\n    nvpsi = {}\n    nvlen = {}\n    nvlen2 = {}\n    tcount = 0\n    l2count = 0\n    c1count = 0\n    psicount = 0\n    lcount = 0\n    for r in mdl.get_residues():\n        ric = r.internal_coord\n        if ric:\n            tau = ric.get_angle('tau')\n            if ric.rprev != [] and tau is not None:\n                tcount += 1\n                nv = tau + 0.5\n                ric.set_angle('tau', nv)\n                nvt[str(r)] = nv\n                l2count += 1\n                leng2 = ric.get_length('N:CA')\n                nv = leng2 + 0.05\n                ric.set_length('N:CA', nv)\n                nvlen2[str(r)] = nv\n            chi1 = ric.get_angle('chi1')\n            if chi1 is not None:\n                c1count += 1\n                nv = chi1 + 90\n                if nv > 180.0:\n                    nv -= 360.0\n                ric.bond_set('chi1', nv)\n                nvc1[str(r)] = nv\n            psi = ric.get_angle('psi')\n            if psi is not None:\n                psicount += 1\n                nv = psi - 90\n                if nv < -180.0:\n                    nv += 360.0\n                ric.set_angle('psi', nv)\n                nvpsi[str(r)] = nv\n            leng = ric.get_length('CA:CB')\n            if leng is not None:\n                lcount += 1\n                nv = leng + 0.05\n                ric.set_length('CA:CB', nv)\n                nvlen[str(r)] = nv\n    mdl.internal_to_atom_coordinates()\n    for chn in mdl.get_chains():\n        if hasattr(chn, 'hedraLen'):\n            delattr(chn.internal_coord, 'hedraLen')\n            delattr(chn.internal_coord, 'dihedraLen')\n            delattr(chn.internal_coord, 'hedraAngle')\n            delattr(chn.internal_coord, 'dihedraAngle')\n            for r in chn.get_residues():\n                r.internal_coord.hedra = {}\n                r.internal_coord.dihedra = {}\n    mdl.atom_to_internal_coordinates()\n    ttcount = 0\n    l2tcount = 0\n    c1tcount = 0\n    psitcount = 0\n    ltcount = 0\n    for r in mdl.get_residues():\n        ric = r.internal_coord\n        if ric:\n            tau = ric.get_angle('tau')\n            if ric.rprev != [] and tau is not None:\n                ttcount += 1\n                self.assertAlmostEqual(tau, nvt[str(r)], places=3)\n                l2tcount += 1\n                l2 = ric.get_length('N:CA')\n                self.assertAlmostEqual(l2, nvlen2[str(r)], places=3)\n            chi1 = ric.get_angle('chi1')\n            if chi1 is not None:\n                c1tcount += 1\n                self.assertAlmostEqual(chi1, nvc1[str(r)], places=3)\n            psi = ric.get_angle('psi')\n            if psi is not None:\n                psitcount += 1\n                self.assertAlmostEqual(psi, nvpsi[str(r)], places=3)\n            leng = ric.get_length('CA:CB')\n            if leng is not None:\n                ltcount += 1\n                self.assertAlmostEqual(leng, nvlen[str(r)], places=3)\n    self.assertEqual(tcount, ttcount)\n    self.assertEqual(l2count, l2tcount)\n    self.assertEqual(c1count, c1tcount)\n    self.assertEqual(psicount, psitcount)\n    self.assertEqual(lcount, ltcount)\n    self.assertGreater(ttcount, 0)\n    self.assertGreater(c1count, 0)\n    self.assertGreater(psicount, 0)\n    self.assertGreater(lcount, 0)",
            "def test_model_change_internal_coords(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Get model internal coords, modify psi and chi1 values and check.'\n    mdl = self.pdb_1LCD[1]\n    mdl.atom_to_internal_coordinates()\n    mdl.internal_to_atom_coordinates()\n    nvt = {}\n    nvc1 = {}\n    nvpsi = {}\n    nvlen = {}\n    nvlen2 = {}\n    tcount = 0\n    l2count = 0\n    c1count = 0\n    psicount = 0\n    lcount = 0\n    for r in mdl.get_residues():\n        ric = r.internal_coord\n        if ric:\n            tau = ric.get_angle('tau')\n            if ric.rprev != [] and tau is not None:\n                tcount += 1\n                nv = tau + 0.5\n                ric.set_angle('tau', nv)\n                nvt[str(r)] = nv\n                l2count += 1\n                leng2 = ric.get_length('N:CA')\n                nv = leng2 + 0.05\n                ric.set_length('N:CA', nv)\n                nvlen2[str(r)] = nv\n            chi1 = ric.get_angle('chi1')\n            if chi1 is not None:\n                c1count += 1\n                nv = chi1 + 90\n                if nv > 180.0:\n                    nv -= 360.0\n                ric.bond_set('chi1', nv)\n                nvc1[str(r)] = nv\n            psi = ric.get_angle('psi')\n            if psi is not None:\n                psicount += 1\n                nv = psi - 90\n                if nv < -180.0:\n                    nv += 360.0\n                ric.set_angle('psi', nv)\n                nvpsi[str(r)] = nv\n            leng = ric.get_length('CA:CB')\n            if leng is not None:\n                lcount += 1\n                nv = leng + 0.05\n                ric.set_length('CA:CB', nv)\n                nvlen[str(r)] = nv\n    mdl.internal_to_atom_coordinates()\n    for chn in mdl.get_chains():\n        if hasattr(chn, 'hedraLen'):\n            delattr(chn.internal_coord, 'hedraLen')\n            delattr(chn.internal_coord, 'dihedraLen')\n            delattr(chn.internal_coord, 'hedraAngle')\n            delattr(chn.internal_coord, 'dihedraAngle')\n            for r in chn.get_residues():\n                r.internal_coord.hedra = {}\n                r.internal_coord.dihedra = {}\n    mdl.atom_to_internal_coordinates()\n    ttcount = 0\n    l2tcount = 0\n    c1tcount = 0\n    psitcount = 0\n    ltcount = 0\n    for r in mdl.get_residues():\n        ric = r.internal_coord\n        if ric:\n            tau = ric.get_angle('tau')\n            if ric.rprev != [] and tau is not None:\n                ttcount += 1\n                self.assertAlmostEqual(tau, nvt[str(r)], places=3)\n                l2tcount += 1\n                l2 = ric.get_length('N:CA')\n                self.assertAlmostEqual(l2, nvlen2[str(r)], places=3)\n            chi1 = ric.get_angle('chi1')\n            if chi1 is not None:\n                c1tcount += 1\n                self.assertAlmostEqual(chi1, nvc1[str(r)], places=3)\n            psi = ric.get_angle('psi')\n            if psi is not None:\n                psitcount += 1\n                self.assertAlmostEqual(psi, nvpsi[str(r)], places=3)\n            leng = ric.get_length('CA:CB')\n            if leng is not None:\n                ltcount += 1\n                self.assertAlmostEqual(leng, nvlen[str(r)], places=3)\n    self.assertEqual(tcount, ttcount)\n    self.assertEqual(l2count, l2tcount)\n    self.assertEqual(c1count, c1tcount)\n    self.assertEqual(psicount, psitcount)\n    self.assertEqual(lcount, ltcount)\n    self.assertGreater(ttcount, 0)\n    self.assertGreater(c1count, 0)\n    self.assertGreater(psicount, 0)\n    self.assertGreater(lcount, 0)"
        ]
    },
    {
        "func_name": "test_write_SCAD",
        "original": "def test_write_SCAD(self):\n    \"\"\"Check SCAD output plus MaxPeptideBond and Gly CB.\n\n        SCAD tests: scaling, transform mtx, extra bond created (allBonds)\n        \"\"\"\n    sf = StringIO()\n    write_SCAD(self.cif_4CUP2, sf, 10.0, pdbid='4cup', backboneOnly=True, includeCode=False)\n    sf.seek(0)\n    next_one = False\n    with as_handle(sf, mode='r') as handle:\n        for aline in handle.readlines():\n            if '// (1856_S_CB, 1856_S_CA, 1856_S_C)' in aline:\n                m = re.search('\\\\[\\\\s+(\\\\d+\\\\.\\\\d+)\\\\,', aline)\n                if m:\n                    self.assertAlmostEqual(float(m.group(1)), 15.30582, places=3)\n                else:\n                    self.fail('scaled atom bond length not found')\n            elif '[ 1, \"1857M\",' in aline:\n                next_one = True\n            elif next_one:\n                next_one = False\n                target = [-12.413, -3.303, 35.771, 1.0]\n                ms = re.findall('\\\\s+(-?\\\\d+\\\\.\\\\d+)\\\\s+\\\\]', aline)\n                if ms:\n                    for i in range(3):\n                        self.assertAlmostEqual(float(ms[i]), target[i], places=0)\n                else:\n                    self.fail('transform not found')\n    sf.seek(0)\n    IC_Residue.gly_Cbeta = True\n    IC_Chain.MaxPeptideBond = 100.0\n    chn = self.pdb_2XHE2[0]['A']\n    chn.atom_to_internal_coordinates()\n    rt0 = chn.internal_coord.ordered_aa_ic_list[12]\n    rt1 = chn.internal_coord.ordered_aa_ic_list[16]\n    rt0.set_flexible()\n    rt1.set_hbond()\n    write_SCAD(self.pdb_2XHE2[0]['A'], sf, 10.0, pdbid='2xhe', includeCode=False, start=10, fin=570)\n    sf.seek(0)\n    allBondsPass = False\n    maxPeptideBondPass = False\n    glyCbetaFound = False\n    startPass = True\n    finPass = True\n    flexPass = False\n    hbPass = False\n    with as_handle(sf, mode='r') as handle:\n        for aline in handle.readlines():\n            if '\"Cres\", 0, 0, 1, 0, StdBond, \"W\", 24, \"CD2CE3CZ3\"' in aline:\n                allBondsPass = True\n            if '509_K' in aline and '561_E' in aline:\n                maxPeptideBondPass = True\n            if '(21_G_CB, 21_G_CA, 21_G_C)' in aline:\n                glyCbetaFound = True\n                target = [15.3363, 110.17513, 15.13861]\n                ms = re.findall('\\\\s+(-?\\\\d+\\\\.\\\\d+)', aline)\n                if ms:\n                    for i in range(3):\n                        self.assertAlmostEqual(float(ms[i]), target[i], places=0)\n                else:\n                    self.fail('Cbeta internal coords not found')\n            if '8_K_CA' in aline:\n                startPass = False\n            if '572_N_CA' in aline:\n                finPass = False\n            if 'FemaleJoinBond, FemaleJoinBond, \"N\", 13, \"NCAC\"' in aline:\n                flexPass = True\n            if 'HBond, \"R\", 16, \"CACO\"' in aline:\n                hbPass = True\n    self.assertTrue(allBondsPass, msg='missing extra ring close bonds')\n    self.assertTrue(glyCbetaFound, msg='gly CB not created')\n    self.assertTrue(maxPeptideBondPass, msg='ignored maxPeptideBond setting')\n    self.assertTrue(startPass, msg='writeSCAD wrote residue before start')\n    self.assertTrue(finPass, msg='writeSCAD wrote residue past fin')\n    self.assertTrue(flexPass, msg='writeSCAD residue 12 not flexible')\n    self.assertTrue(hbPass, msg='writeSCAD residue 16 no hbond')",
        "mutated": [
            "def test_write_SCAD(self):\n    if False:\n        i = 10\n    'Check SCAD output plus MaxPeptideBond and Gly CB.\\n\\n        SCAD tests: scaling, transform mtx, extra bond created (allBonds)\\n        '\n    sf = StringIO()\n    write_SCAD(self.cif_4CUP2, sf, 10.0, pdbid='4cup', backboneOnly=True, includeCode=False)\n    sf.seek(0)\n    next_one = False\n    with as_handle(sf, mode='r') as handle:\n        for aline in handle.readlines():\n            if '// (1856_S_CB, 1856_S_CA, 1856_S_C)' in aline:\n                m = re.search('\\\\[\\\\s+(\\\\d+\\\\.\\\\d+)\\\\,', aline)\n                if m:\n                    self.assertAlmostEqual(float(m.group(1)), 15.30582, places=3)\n                else:\n                    self.fail('scaled atom bond length not found')\n            elif '[ 1, \"1857M\",' in aline:\n                next_one = True\n            elif next_one:\n                next_one = False\n                target = [-12.413, -3.303, 35.771, 1.0]\n                ms = re.findall('\\\\s+(-?\\\\d+\\\\.\\\\d+)\\\\s+\\\\]', aline)\n                if ms:\n                    for i in range(3):\n                        self.assertAlmostEqual(float(ms[i]), target[i], places=0)\n                else:\n                    self.fail('transform not found')\n    sf.seek(0)\n    IC_Residue.gly_Cbeta = True\n    IC_Chain.MaxPeptideBond = 100.0\n    chn = self.pdb_2XHE2[0]['A']\n    chn.atom_to_internal_coordinates()\n    rt0 = chn.internal_coord.ordered_aa_ic_list[12]\n    rt1 = chn.internal_coord.ordered_aa_ic_list[16]\n    rt0.set_flexible()\n    rt1.set_hbond()\n    write_SCAD(self.pdb_2XHE2[0]['A'], sf, 10.0, pdbid='2xhe', includeCode=False, start=10, fin=570)\n    sf.seek(0)\n    allBondsPass = False\n    maxPeptideBondPass = False\n    glyCbetaFound = False\n    startPass = True\n    finPass = True\n    flexPass = False\n    hbPass = False\n    with as_handle(sf, mode='r') as handle:\n        for aline in handle.readlines():\n            if '\"Cres\", 0, 0, 1, 0, StdBond, \"W\", 24, \"CD2CE3CZ3\"' in aline:\n                allBondsPass = True\n            if '509_K' in aline and '561_E' in aline:\n                maxPeptideBondPass = True\n            if '(21_G_CB, 21_G_CA, 21_G_C)' in aline:\n                glyCbetaFound = True\n                target = [15.3363, 110.17513, 15.13861]\n                ms = re.findall('\\\\s+(-?\\\\d+\\\\.\\\\d+)', aline)\n                if ms:\n                    for i in range(3):\n                        self.assertAlmostEqual(float(ms[i]), target[i], places=0)\n                else:\n                    self.fail('Cbeta internal coords not found')\n            if '8_K_CA' in aline:\n                startPass = False\n            if '572_N_CA' in aline:\n                finPass = False\n            if 'FemaleJoinBond, FemaleJoinBond, \"N\", 13, \"NCAC\"' in aline:\n                flexPass = True\n            if 'HBond, \"R\", 16, \"CACO\"' in aline:\n                hbPass = True\n    self.assertTrue(allBondsPass, msg='missing extra ring close bonds')\n    self.assertTrue(glyCbetaFound, msg='gly CB not created')\n    self.assertTrue(maxPeptideBondPass, msg='ignored maxPeptideBond setting')\n    self.assertTrue(startPass, msg='writeSCAD wrote residue before start')\n    self.assertTrue(finPass, msg='writeSCAD wrote residue past fin')\n    self.assertTrue(flexPass, msg='writeSCAD residue 12 not flexible')\n    self.assertTrue(hbPass, msg='writeSCAD residue 16 no hbond')",
            "def test_write_SCAD(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Check SCAD output plus MaxPeptideBond and Gly CB.\\n\\n        SCAD tests: scaling, transform mtx, extra bond created (allBonds)\\n        '\n    sf = StringIO()\n    write_SCAD(self.cif_4CUP2, sf, 10.0, pdbid='4cup', backboneOnly=True, includeCode=False)\n    sf.seek(0)\n    next_one = False\n    with as_handle(sf, mode='r') as handle:\n        for aline in handle.readlines():\n            if '// (1856_S_CB, 1856_S_CA, 1856_S_C)' in aline:\n                m = re.search('\\\\[\\\\s+(\\\\d+\\\\.\\\\d+)\\\\,', aline)\n                if m:\n                    self.assertAlmostEqual(float(m.group(1)), 15.30582, places=3)\n                else:\n                    self.fail('scaled atom bond length not found')\n            elif '[ 1, \"1857M\",' in aline:\n                next_one = True\n            elif next_one:\n                next_one = False\n                target = [-12.413, -3.303, 35.771, 1.0]\n                ms = re.findall('\\\\s+(-?\\\\d+\\\\.\\\\d+)\\\\s+\\\\]', aline)\n                if ms:\n                    for i in range(3):\n                        self.assertAlmostEqual(float(ms[i]), target[i], places=0)\n                else:\n                    self.fail('transform not found')\n    sf.seek(0)\n    IC_Residue.gly_Cbeta = True\n    IC_Chain.MaxPeptideBond = 100.0\n    chn = self.pdb_2XHE2[0]['A']\n    chn.atom_to_internal_coordinates()\n    rt0 = chn.internal_coord.ordered_aa_ic_list[12]\n    rt1 = chn.internal_coord.ordered_aa_ic_list[16]\n    rt0.set_flexible()\n    rt1.set_hbond()\n    write_SCAD(self.pdb_2XHE2[0]['A'], sf, 10.0, pdbid='2xhe', includeCode=False, start=10, fin=570)\n    sf.seek(0)\n    allBondsPass = False\n    maxPeptideBondPass = False\n    glyCbetaFound = False\n    startPass = True\n    finPass = True\n    flexPass = False\n    hbPass = False\n    with as_handle(sf, mode='r') as handle:\n        for aline in handle.readlines():\n            if '\"Cres\", 0, 0, 1, 0, StdBond, \"W\", 24, \"CD2CE3CZ3\"' in aline:\n                allBondsPass = True\n            if '509_K' in aline and '561_E' in aline:\n                maxPeptideBondPass = True\n            if '(21_G_CB, 21_G_CA, 21_G_C)' in aline:\n                glyCbetaFound = True\n                target = [15.3363, 110.17513, 15.13861]\n                ms = re.findall('\\\\s+(-?\\\\d+\\\\.\\\\d+)', aline)\n                if ms:\n                    for i in range(3):\n                        self.assertAlmostEqual(float(ms[i]), target[i], places=0)\n                else:\n                    self.fail('Cbeta internal coords not found')\n            if '8_K_CA' in aline:\n                startPass = False\n            if '572_N_CA' in aline:\n                finPass = False\n            if 'FemaleJoinBond, FemaleJoinBond, \"N\", 13, \"NCAC\"' in aline:\n                flexPass = True\n            if 'HBond, \"R\", 16, \"CACO\"' in aline:\n                hbPass = True\n    self.assertTrue(allBondsPass, msg='missing extra ring close bonds')\n    self.assertTrue(glyCbetaFound, msg='gly CB not created')\n    self.assertTrue(maxPeptideBondPass, msg='ignored maxPeptideBond setting')\n    self.assertTrue(startPass, msg='writeSCAD wrote residue before start')\n    self.assertTrue(finPass, msg='writeSCAD wrote residue past fin')\n    self.assertTrue(flexPass, msg='writeSCAD residue 12 not flexible')\n    self.assertTrue(hbPass, msg='writeSCAD residue 16 no hbond')",
            "def test_write_SCAD(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Check SCAD output plus MaxPeptideBond and Gly CB.\\n\\n        SCAD tests: scaling, transform mtx, extra bond created (allBonds)\\n        '\n    sf = StringIO()\n    write_SCAD(self.cif_4CUP2, sf, 10.0, pdbid='4cup', backboneOnly=True, includeCode=False)\n    sf.seek(0)\n    next_one = False\n    with as_handle(sf, mode='r') as handle:\n        for aline in handle.readlines():\n            if '// (1856_S_CB, 1856_S_CA, 1856_S_C)' in aline:\n                m = re.search('\\\\[\\\\s+(\\\\d+\\\\.\\\\d+)\\\\,', aline)\n                if m:\n                    self.assertAlmostEqual(float(m.group(1)), 15.30582, places=3)\n                else:\n                    self.fail('scaled atom bond length not found')\n            elif '[ 1, \"1857M\",' in aline:\n                next_one = True\n            elif next_one:\n                next_one = False\n                target = [-12.413, -3.303, 35.771, 1.0]\n                ms = re.findall('\\\\s+(-?\\\\d+\\\\.\\\\d+)\\\\s+\\\\]', aline)\n                if ms:\n                    for i in range(3):\n                        self.assertAlmostEqual(float(ms[i]), target[i], places=0)\n                else:\n                    self.fail('transform not found')\n    sf.seek(0)\n    IC_Residue.gly_Cbeta = True\n    IC_Chain.MaxPeptideBond = 100.0\n    chn = self.pdb_2XHE2[0]['A']\n    chn.atom_to_internal_coordinates()\n    rt0 = chn.internal_coord.ordered_aa_ic_list[12]\n    rt1 = chn.internal_coord.ordered_aa_ic_list[16]\n    rt0.set_flexible()\n    rt1.set_hbond()\n    write_SCAD(self.pdb_2XHE2[0]['A'], sf, 10.0, pdbid='2xhe', includeCode=False, start=10, fin=570)\n    sf.seek(0)\n    allBondsPass = False\n    maxPeptideBondPass = False\n    glyCbetaFound = False\n    startPass = True\n    finPass = True\n    flexPass = False\n    hbPass = False\n    with as_handle(sf, mode='r') as handle:\n        for aline in handle.readlines():\n            if '\"Cres\", 0, 0, 1, 0, StdBond, \"W\", 24, \"CD2CE3CZ3\"' in aline:\n                allBondsPass = True\n            if '509_K' in aline and '561_E' in aline:\n                maxPeptideBondPass = True\n            if '(21_G_CB, 21_G_CA, 21_G_C)' in aline:\n                glyCbetaFound = True\n                target = [15.3363, 110.17513, 15.13861]\n                ms = re.findall('\\\\s+(-?\\\\d+\\\\.\\\\d+)', aline)\n                if ms:\n                    for i in range(3):\n                        self.assertAlmostEqual(float(ms[i]), target[i], places=0)\n                else:\n                    self.fail('Cbeta internal coords not found')\n            if '8_K_CA' in aline:\n                startPass = False\n            if '572_N_CA' in aline:\n                finPass = False\n            if 'FemaleJoinBond, FemaleJoinBond, \"N\", 13, \"NCAC\"' in aline:\n                flexPass = True\n            if 'HBond, \"R\", 16, \"CACO\"' in aline:\n                hbPass = True\n    self.assertTrue(allBondsPass, msg='missing extra ring close bonds')\n    self.assertTrue(glyCbetaFound, msg='gly CB not created')\n    self.assertTrue(maxPeptideBondPass, msg='ignored maxPeptideBond setting')\n    self.assertTrue(startPass, msg='writeSCAD wrote residue before start')\n    self.assertTrue(finPass, msg='writeSCAD wrote residue past fin')\n    self.assertTrue(flexPass, msg='writeSCAD residue 12 not flexible')\n    self.assertTrue(hbPass, msg='writeSCAD residue 16 no hbond')",
            "def test_write_SCAD(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Check SCAD output plus MaxPeptideBond and Gly CB.\\n\\n        SCAD tests: scaling, transform mtx, extra bond created (allBonds)\\n        '\n    sf = StringIO()\n    write_SCAD(self.cif_4CUP2, sf, 10.0, pdbid='4cup', backboneOnly=True, includeCode=False)\n    sf.seek(0)\n    next_one = False\n    with as_handle(sf, mode='r') as handle:\n        for aline in handle.readlines():\n            if '// (1856_S_CB, 1856_S_CA, 1856_S_C)' in aline:\n                m = re.search('\\\\[\\\\s+(\\\\d+\\\\.\\\\d+)\\\\,', aline)\n                if m:\n                    self.assertAlmostEqual(float(m.group(1)), 15.30582, places=3)\n                else:\n                    self.fail('scaled atom bond length not found')\n            elif '[ 1, \"1857M\",' in aline:\n                next_one = True\n            elif next_one:\n                next_one = False\n                target = [-12.413, -3.303, 35.771, 1.0]\n                ms = re.findall('\\\\s+(-?\\\\d+\\\\.\\\\d+)\\\\s+\\\\]', aline)\n                if ms:\n                    for i in range(3):\n                        self.assertAlmostEqual(float(ms[i]), target[i], places=0)\n                else:\n                    self.fail('transform not found')\n    sf.seek(0)\n    IC_Residue.gly_Cbeta = True\n    IC_Chain.MaxPeptideBond = 100.0\n    chn = self.pdb_2XHE2[0]['A']\n    chn.atom_to_internal_coordinates()\n    rt0 = chn.internal_coord.ordered_aa_ic_list[12]\n    rt1 = chn.internal_coord.ordered_aa_ic_list[16]\n    rt0.set_flexible()\n    rt1.set_hbond()\n    write_SCAD(self.pdb_2XHE2[0]['A'], sf, 10.0, pdbid='2xhe', includeCode=False, start=10, fin=570)\n    sf.seek(0)\n    allBondsPass = False\n    maxPeptideBondPass = False\n    glyCbetaFound = False\n    startPass = True\n    finPass = True\n    flexPass = False\n    hbPass = False\n    with as_handle(sf, mode='r') as handle:\n        for aline in handle.readlines():\n            if '\"Cres\", 0, 0, 1, 0, StdBond, \"W\", 24, \"CD2CE3CZ3\"' in aline:\n                allBondsPass = True\n            if '509_K' in aline and '561_E' in aline:\n                maxPeptideBondPass = True\n            if '(21_G_CB, 21_G_CA, 21_G_C)' in aline:\n                glyCbetaFound = True\n                target = [15.3363, 110.17513, 15.13861]\n                ms = re.findall('\\\\s+(-?\\\\d+\\\\.\\\\d+)', aline)\n                if ms:\n                    for i in range(3):\n                        self.assertAlmostEqual(float(ms[i]), target[i], places=0)\n                else:\n                    self.fail('Cbeta internal coords not found')\n            if '8_K_CA' in aline:\n                startPass = False\n            if '572_N_CA' in aline:\n                finPass = False\n            if 'FemaleJoinBond, FemaleJoinBond, \"N\", 13, \"NCAC\"' in aline:\n                flexPass = True\n            if 'HBond, \"R\", 16, \"CACO\"' in aline:\n                hbPass = True\n    self.assertTrue(allBondsPass, msg='missing extra ring close bonds')\n    self.assertTrue(glyCbetaFound, msg='gly CB not created')\n    self.assertTrue(maxPeptideBondPass, msg='ignored maxPeptideBond setting')\n    self.assertTrue(startPass, msg='writeSCAD wrote residue before start')\n    self.assertTrue(finPass, msg='writeSCAD wrote residue past fin')\n    self.assertTrue(flexPass, msg='writeSCAD residue 12 not flexible')\n    self.assertTrue(hbPass, msg='writeSCAD residue 16 no hbond')",
            "def test_write_SCAD(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Check SCAD output plus MaxPeptideBond and Gly CB.\\n\\n        SCAD tests: scaling, transform mtx, extra bond created (allBonds)\\n        '\n    sf = StringIO()\n    write_SCAD(self.cif_4CUP2, sf, 10.0, pdbid='4cup', backboneOnly=True, includeCode=False)\n    sf.seek(0)\n    next_one = False\n    with as_handle(sf, mode='r') as handle:\n        for aline in handle.readlines():\n            if '// (1856_S_CB, 1856_S_CA, 1856_S_C)' in aline:\n                m = re.search('\\\\[\\\\s+(\\\\d+\\\\.\\\\d+)\\\\,', aline)\n                if m:\n                    self.assertAlmostEqual(float(m.group(1)), 15.30582, places=3)\n                else:\n                    self.fail('scaled atom bond length not found')\n            elif '[ 1, \"1857M\",' in aline:\n                next_one = True\n            elif next_one:\n                next_one = False\n                target = [-12.413, -3.303, 35.771, 1.0]\n                ms = re.findall('\\\\s+(-?\\\\d+\\\\.\\\\d+)\\\\s+\\\\]', aline)\n                if ms:\n                    for i in range(3):\n                        self.assertAlmostEqual(float(ms[i]), target[i], places=0)\n                else:\n                    self.fail('transform not found')\n    sf.seek(0)\n    IC_Residue.gly_Cbeta = True\n    IC_Chain.MaxPeptideBond = 100.0\n    chn = self.pdb_2XHE2[0]['A']\n    chn.atom_to_internal_coordinates()\n    rt0 = chn.internal_coord.ordered_aa_ic_list[12]\n    rt1 = chn.internal_coord.ordered_aa_ic_list[16]\n    rt0.set_flexible()\n    rt1.set_hbond()\n    write_SCAD(self.pdb_2XHE2[0]['A'], sf, 10.0, pdbid='2xhe', includeCode=False, start=10, fin=570)\n    sf.seek(0)\n    allBondsPass = False\n    maxPeptideBondPass = False\n    glyCbetaFound = False\n    startPass = True\n    finPass = True\n    flexPass = False\n    hbPass = False\n    with as_handle(sf, mode='r') as handle:\n        for aline in handle.readlines():\n            if '\"Cres\", 0, 0, 1, 0, StdBond, \"W\", 24, \"CD2CE3CZ3\"' in aline:\n                allBondsPass = True\n            if '509_K' in aline and '561_E' in aline:\n                maxPeptideBondPass = True\n            if '(21_G_CB, 21_G_CA, 21_G_C)' in aline:\n                glyCbetaFound = True\n                target = [15.3363, 110.17513, 15.13861]\n                ms = re.findall('\\\\s+(-?\\\\d+\\\\.\\\\d+)', aline)\n                if ms:\n                    for i in range(3):\n                        self.assertAlmostEqual(float(ms[i]), target[i], places=0)\n                else:\n                    self.fail('Cbeta internal coords not found')\n            if '8_K_CA' in aline:\n                startPass = False\n            if '572_N_CA' in aline:\n                finPass = False\n            if 'FemaleJoinBond, FemaleJoinBond, \"N\", 13, \"NCAC\"' in aline:\n                flexPass = True\n            if 'HBond, \"R\", 16, \"CACO\"' in aline:\n                hbPass = True\n    self.assertTrue(allBondsPass, msg='missing extra ring close bonds')\n    self.assertTrue(glyCbetaFound, msg='gly CB not created')\n    self.assertTrue(maxPeptideBondPass, msg='ignored maxPeptideBond setting')\n    self.assertTrue(startPass, msg='writeSCAD wrote residue before start')\n    self.assertTrue(finPass, msg='writeSCAD wrote residue past fin')\n    self.assertTrue(flexPass, msg='writeSCAD residue 12 not flexible')\n    self.assertTrue(hbPass, msg='writeSCAD residue 16 no hbond')"
        ]
    },
    {
        "func_name": "test_i2a_start_fin",
        "original": "def test_i2a_start_fin(self):\n    \"\"\"Test assemble start/fin, default NCaC coordinates, IC_duplicate.\"\"\"\n    chn = self.pdb_1LCD[2]['A']\n    cpy = IC_duplicate(chn)[2]['A']\n    cpy.internal_to_atom_coordinates(start=31, fin=45)\n    cdict = compare_residues(chn, cpy, quick=True)\n    self.assertFalse(cdict['pass'])\n    res = chn[31]\n    psi = res.internal_coord.pick_angle('psi')\n    cst = np.transpose(psi.cst)\n    chn.internal_coord.atomArray[:] = chn.internal_coord.atomArray.dot(cst)\n    cdict = compare_residues(chn, cpy, rtol=0.001, atol=1e-05)\n    self.assertEqual(cdict['residues'], 51)\n    self.assertEqual(cdict['rMatchCount'], 77)\n    self.assertEqual(cdict['aCount'], 497)\n    self.assertEqual(cdict['disAtmCount'], 0)\n    self.assertEqual(cdict['aCoordMatchCount'], 140)\n    self.assertEqual(cdict['aFullIdMatchCount'], 140)\n    self.assertEqual(len(cdict['chains']), 1)\n    self.assertEqual(cdict['rCount'], 77)\n    self.assertFalse(cdict['pass'])",
        "mutated": [
            "def test_i2a_start_fin(self):\n    if False:\n        i = 10\n    'Test assemble start/fin, default NCaC coordinates, IC_duplicate.'\n    chn = self.pdb_1LCD[2]['A']\n    cpy = IC_duplicate(chn)[2]['A']\n    cpy.internal_to_atom_coordinates(start=31, fin=45)\n    cdict = compare_residues(chn, cpy, quick=True)\n    self.assertFalse(cdict['pass'])\n    res = chn[31]\n    psi = res.internal_coord.pick_angle('psi')\n    cst = np.transpose(psi.cst)\n    chn.internal_coord.atomArray[:] = chn.internal_coord.atomArray.dot(cst)\n    cdict = compare_residues(chn, cpy, rtol=0.001, atol=1e-05)\n    self.assertEqual(cdict['residues'], 51)\n    self.assertEqual(cdict['rMatchCount'], 77)\n    self.assertEqual(cdict['aCount'], 497)\n    self.assertEqual(cdict['disAtmCount'], 0)\n    self.assertEqual(cdict['aCoordMatchCount'], 140)\n    self.assertEqual(cdict['aFullIdMatchCount'], 140)\n    self.assertEqual(len(cdict['chains']), 1)\n    self.assertEqual(cdict['rCount'], 77)\n    self.assertFalse(cdict['pass'])",
            "def test_i2a_start_fin(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test assemble start/fin, default NCaC coordinates, IC_duplicate.'\n    chn = self.pdb_1LCD[2]['A']\n    cpy = IC_duplicate(chn)[2]['A']\n    cpy.internal_to_atom_coordinates(start=31, fin=45)\n    cdict = compare_residues(chn, cpy, quick=True)\n    self.assertFalse(cdict['pass'])\n    res = chn[31]\n    psi = res.internal_coord.pick_angle('psi')\n    cst = np.transpose(psi.cst)\n    chn.internal_coord.atomArray[:] = chn.internal_coord.atomArray.dot(cst)\n    cdict = compare_residues(chn, cpy, rtol=0.001, atol=1e-05)\n    self.assertEqual(cdict['residues'], 51)\n    self.assertEqual(cdict['rMatchCount'], 77)\n    self.assertEqual(cdict['aCount'], 497)\n    self.assertEqual(cdict['disAtmCount'], 0)\n    self.assertEqual(cdict['aCoordMatchCount'], 140)\n    self.assertEqual(cdict['aFullIdMatchCount'], 140)\n    self.assertEqual(len(cdict['chains']), 1)\n    self.assertEqual(cdict['rCount'], 77)\n    self.assertFalse(cdict['pass'])",
            "def test_i2a_start_fin(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test assemble start/fin, default NCaC coordinates, IC_duplicate.'\n    chn = self.pdb_1LCD[2]['A']\n    cpy = IC_duplicate(chn)[2]['A']\n    cpy.internal_to_atom_coordinates(start=31, fin=45)\n    cdict = compare_residues(chn, cpy, quick=True)\n    self.assertFalse(cdict['pass'])\n    res = chn[31]\n    psi = res.internal_coord.pick_angle('psi')\n    cst = np.transpose(psi.cst)\n    chn.internal_coord.atomArray[:] = chn.internal_coord.atomArray.dot(cst)\n    cdict = compare_residues(chn, cpy, rtol=0.001, atol=1e-05)\n    self.assertEqual(cdict['residues'], 51)\n    self.assertEqual(cdict['rMatchCount'], 77)\n    self.assertEqual(cdict['aCount'], 497)\n    self.assertEqual(cdict['disAtmCount'], 0)\n    self.assertEqual(cdict['aCoordMatchCount'], 140)\n    self.assertEqual(cdict['aFullIdMatchCount'], 140)\n    self.assertEqual(len(cdict['chains']), 1)\n    self.assertEqual(cdict['rCount'], 77)\n    self.assertFalse(cdict['pass'])",
            "def test_i2a_start_fin(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test assemble start/fin, default NCaC coordinates, IC_duplicate.'\n    chn = self.pdb_1LCD[2]['A']\n    cpy = IC_duplicate(chn)[2]['A']\n    cpy.internal_to_atom_coordinates(start=31, fin=45)\n    cdict = compare_residues(chn, cpy, quick=True)\n    self.assertFalse(cdict['pass'])\n    res = chn[31]\n    psi = res.internal_coord.pick_angle('psi')\n    cst = np.transpose(psi.cst)\n    chn.internal_coord.atomArray[:] = chn.internal_coord.atomArray.dot(cst)\n    cdict = compare_residues(chn, cpy, rtol=0.001, atol=1e-05)\n    self.assertEqual(cdict['residues'], 51)\n    self.assertEqual(cdict['rMatchCount'], 77)\n    self.assertEqual(cdict['aCount'], 497)\n    self.assertEqual(cdict['disAtmCount'], 0)\n    self.assertEqual(cdict['aCoordMatchCount'], 140)\n    self.assertEqual(cdict['aFullIdMatchCount'], 140)\n    self.assertEqual(len(cdict['chains']), 1)\n    self.assertEqual(cdict['rCount'], 77)\n    self.assertFalse(cdict['pass'])",
            "def test_i2a_start_fin(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test assemble start/fin, default NCaC coordinates, IC_duplicate.'\n    chn = self.pdb_1LCD[2]['A']\n    cpy = IC_duplicate(chn)[2]['A']\n    cpy.internal_to_atom_coordinates(start=31, fin=45)\n    cdict = compare_residues(chn, cpy, quick=True)\n    self.assertFalse(cdict['pass'])\n    res = chn[31]\n    psi = res.internal_coord.pick_angle('psi')\n    cst = np.transpose(psi.cst)\n    chn.internal_coord.atomArray[:] = chn.internal_coord.atomArray.dot(cst)\n    cdict = compare_residues(chn, cpy, rtol=0.001, atol=1e-05)\n    self.assertEqual(cdict['residues'], 51)\n    self.assertEqual(cdict['rMatchCount'], 77)\n    self.assertEqual(cdict['aCount'], 497)\n    self.assertEqual(cdict['disAtmCount'], 0)\n    self.assertEqual(cdict['aCoordMatchCount'], 140)\n    self.assertEqual(cdict['aFullIdMatchCount'], 140)\n    self.assertEqual(len(cdict['chains']), 1)\n    self.assertEqual(cdict['rCount'], 77)\n    self.assertFalse(cdict['pass'])"
        ]
    },
    {
        "func_name": "test_distplot_rebuild",
        "original": "def test_distplot_rebuild(self):\n    \"\"\"Build identical structure from distplot and chirality data.\"\"\"\n    for _chn1 in self.cif_4ZHL.get_chains():\n        break\n    _chn1.atom_to_internal_coordinates()\n    _c1ic = _chn1.internal_coord\n    atmNameNdx = AtomKey.fields.atm\n    CaSelect = [_c1ic.atomArrayIndex.get(k) for k in _c1ic.atomArrayIndex.keys() if k.akl[atmNameNdx] == 'CA']\n    dplot0 = _chn1.internal_coord.distance_plot(filter=CaSelect)\n    self.assertAlmostEqual(dplot0[3, 9], 16.296, places=3, msg='fail generate distance plot with filter')\n    dplot1 = _chn1.internal_coord.distance_plot()\n    dsigns = _chn1.internal_coord.dihedral_signs()\n    for _chn2 in self.cif_4ZHL2.get_chains():\n        break\n    cic2 = _chn2.internal_coord = IC_Chain(_chn2)\n    cic2.init_edra()\n    cic2.distplot_to_dh_arrays(dplot1, dsigns)\n    cic2.distance_to_internal_coordinates()\n    cic2.atomArray = np.zeros((cic2.AAsiz, 4), dtype=np.float64)\n    cic2.atomArray[:, 3] = 1.0\n    cic2.copy_initNCaCs(_chn1.internal_coord)\n    cic2.internal_to_atom_coordinates()\n    dp2 = cic2.distance_plot()\n    dpdiff = np.abs(dplot1 - dp2)\n    self.assertTrue(np.amax(dpdiff) < 1e-06)",
        "mutated": [
            "def test_distplot_rebuild(self):\n    if False:\n        i = 10\n    'Build identical structure from distplot and chirality data.'\n    for _chn1 in self.cif_4ZHL.get_chains():\n        break\n    _chn1.atom_to_internal_coordinates()\n    _c1ic = _chn1.internal_coord\n    atmNameNdx = AtomKey.fields.atm\n    CaSelect = [_c1ic.atomArrayIndex.get(k) for k in _c1ic.atomArrayIndex.keys() if k.akl[atmNameNdx] == 'CA']\n    dplot0 = _chn1.internal_coord.distance_plot(filter=CaSelect)\n    self.assertAlmostEqual(dplot0[3, 9], 16.296, places=3, msg='fail generate distance plot with filter')\n    dplot1 = _chn1.internal_coord.distance_plot()\n    dsigns = _chn1.internal_coord.dihedral_signs()\n    for _chn2 in self.cif_4ZHL2.get_chains():\n        break\n    cic2 = _chn2.internal_coord = IC_Chain(_chn2)\n    cic2.init_edra()\n    cic2.distplot_to_dh_arrays(dplot1, dsigns)\n    cic2.distance_to_internal_coordinates()\n    cic2.atomArray = np.zeros((cic2.AAsiz, 4), dtype=np.float64)\n    cic2.atomArray[:, 3] = 1.0\n    cic2.copy_initNCaCs(_chn1.internal_coord)\n    cic2.internal_to_atom_coordinates()\n    dp2 = cic2.distance_plot()\n    dpdiff = np.abs(dplot1 - dp2)\n    self.assertTrue(np.amax(dpdiff) < 1e-06)",
            "def test_distplot_rebuild(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Build identical structure from distplot and chirality data.'\n    for _chn1 in self.cif_4ZHL.get_chains():\n        break\n    _chn1.atom_to_internal_coordinates()\n    _c1ic = _chn1.internal_coord\n    atmNameNdx = AtomKey.fields.atm\n    CaSelect = [_c1ic.atomArrayIndex.get(k) for k in _c1ic.atomArrayIndex.keys() if k.akl[atmNameNdx] == 'CA']\n    dplot0 = _chn1.internal_coord.distance_plot(filter=CaSelect)\n    self.assertAlmostEqual(dplot0[3, 9], 16.296, places=3, msg='fail generate distance plot with filter')\n    dplot1 = _chn1.internal_coord.distance_plot()\n    dsigns = _chn1.internal_coord.dihedral_signs()\n    for _chn2 in self.cif_4ZHL2.get_chains():\n        break\n    cic2 = _chn2.internal_coord = IC_Chain(_chn2)\n    cic2.init_edra()\n    cic2.distplot_to_dh_arrays(dplot1, dsigns)\n    cic2.distance_to_internal_coordinates()\n    cic2.atomArray = np.zeros((cic2.AAsiz, 4), dtype=np.float64)\n    cic2.atomArray[:, 3] = 1.0\n    cic2.copy_initNCaCs(_chn1.internal_coord)\n    cic2.internal_to_atom_coordinates()\n    dp2 = cic2.distance_plot()\n    dpdiff = np.abs(dplot1 - dp2)\n    self.assertTrue(np.amax(dpdiff) < 1e-06)",
            "def test_distplot_rebuild(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Build identical structure from distplot and chirality data.'\n    for _chn1 in self.cif_4ZHL.get_chains():\n        break\n    _chn1.atom_to_internal_coordinates()\n    _c1ic = _chn1.internal_coord\n    atmNameNdx = AtomKey.fields.atm\n    CaSelect = [_c1ic.atomArrayIndex.get(k) for k in _c1ic.atomArrayIndex.keys() if k.akl[atmNameNdx] == 'CA']\n    dplot0 = _chn1.internal_coord.distance_plot(filter=CaSelect)\n    self.assertAlmostEqual(dplot0[3, 9], 16.296, places=3, msg='fail generate distance plot with filter')\n    dplot1 = _chn1.internal_coord.distance_plot()\n    dsigns = _chn1.internal_coord.dihedral_signs()\n    for _chn2 in self.cif_4ZHL2.get_chains():\n        break\n    cic2 = _chn2.internal_coord = IC_Chain(_chn2)\n    cic2.init_edra()\n    cic2.distplot_to_dh_arrays(dplot1, dsigns)\n    cic2.distance_to_internal_coordinates()\n    cic2.atomArray = np.zeros((cic2.AAsiz, 4), dtype=np.float64)\n    cic2.atomArray[:, 3] = 1.0\n    cic2.copy_initNCaCs(_chn1.internal_coord)\n    cic2.internal_to_atom_coordinates()\n    dp2 = cic2.distance_plot()\n    dpdiff = np.abs(dplot1 - dp2)\n    self.assertTrue(np.amax(dpdiff) < 1e-06)",
            "def test_distplot_rebuild(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Build identical structure from distplot and chirality data.'\n    for _chn1 in self.cif_4ZHL.get_chains():\n        break\n    _chn1.atom_to_internal_coordinates()\n    _c1ic = _chn1.internal_coord\n    atmNameNdx = AtomKey.fields.atm\n    CaSelect = [_c1ic.atomArrayIndex.get(k) for k in _c1ic.atomArrayIndex.keys() if k.akl[atmNameNdx] == 'CA']\n    dplot0 = _chn1.internal_coord.distance_plot(filter=CaSelect)\n    self.assertAlmostEqual(dplot0[3, 9], 16.296, places=3, msg='fail generate distance plot with filter')\n    dplot1 = _chn1.internal_coord.distance_plot()\n    dsigns = _chn1.internal_coord.dihedral_signs()\n    for _chn2 in self.cif_4ZHL2.get_chains():\n        break\n    cic2 = _chn2.internal_coord = IC_Chain(_chn2)\n    cic2.init_edra()\n    cic2.distplot_to_dh_arrays(dplot1, dsigns)\n    cic2.distance_to_internal_coordinates()\n    cic2.atomArray = np.zeros((cic2.AAsiz, 4), dtype=np.float64)\n    cic2.atomArray[:, 3] = 1.0\n    cic2.copy_initNCaCs(_chn1.internal_coord)\n    cic2.internal_to_atom_coordinates()\n    dp2 = cic2.distance_plot()\n    dpdiff = np.abs(dplot1 - dp2)\n    self.assertTrue(np.amax(dpdiff) < 1e-06)",
            "def test_distplot_rebuild(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Build identical structure from distplot and chirality data.'\n    for _chn1 in self.cif_4ZHL.get_chains():\n        break\n    _chn1.atom_to_internal_coordinates()\n    _c1ic = _chn1.internal_coord\n    atmNameNdx = AtomKey.fields.atm\n    CaSelect = [_c1ic.atomArrayIndex.get(k) for k in _c1ic.atomArrayIndex.keys() if k.akl[atmNameNdx] == 'CA']\n    dplot0 = _chn1.internal_coord.distance_plot(filter=CaSelect)\n    self.assertAlmostEqual(dplot0[3, 9], 16.296, places=3, msg='fail generate distance plot with filter')\n    dplot1 = _chn1.internal_coord.distance_plot()\n    dsigns = _chn1.internal_coord.dihedral_signs()\n    for _chn2 in self.cif_4ZHL2.get_chains():\n        break\n    cic2 = _chn2.internal_coord = IC_Chain(_chn2)\n    cic2.init_edra()\n    cic2.distplot_to_dh_arrays(dplot1, dsigns)\n    cic2.distance_to_internal_coordinates()\n    cic2.atomArray = np.zeros((cic2.AAsiz, 4), dtype=np.float64)\n    cic2.atomArray[:, 3] = 1.0\n    cic2.copy_initNCaCs(_chn1.internal_coord)\n    cic2.internal_to_atom_coordinates()\n    dp2 = cic2.distance_plot()\n    dpdiff = np.abs(dplot1 - dp2)\n    self.assertTrue(np.amax(dpdiff) < 1e-06)"
        ]
    },
    {
        "func_name": "test_seq_as_PIC",
        "original": "def test_seq_as_PIC(self):\n    \"\"\"Read seq as PIC data, extend chain, set each chi angle, check various.\"\"\"\n    pdb_structure = read_PIC_seq(SeqRecord(Seq('GAVLIMFPSTCNQYWDEHKR'), id='1RND', description='my 20aa sequence'))\n    chn = next(pdb_structure.get_chains())\n    cic = chn.internal_coord\n    cic.make_extended()\n    for chi in range(1, 6):\n        for ric in chn.internal_coord.ordered_aa_ic_list:\n            targ = 'chi' + str(chi)\n            rchi = ric.get_angle(targ)\n            if rchi is not None:\n                nangl = rchi + 60.0\n                ric.set_angle(targ, nangl)\n    pdb_structure.internal_to_atom_coordinates()\n    self.assertEqual(len(cic.atomArrayValid), 168, msg='wrong number atoms from sequence')\n    posnDict = {'1_G_CA': [0.0, 0.0, 0.0, 1.0], '2_A_CB': [-0.411, 2.505, 4.035, 1.0], '3_V_CG2': [-2.246, -2.942, 4.865, 1.0], '4_L_CD2': [-4.673, 2.124, 6.06, 1.0], '5_I_CD1': [-4.26, -4.0, 10.546, 1.0], '6_M_CE': [-10.035, 4.22, 12.322, 1.0], '7_F_CE2': [-5.835, -1.076, 15.391, 1.0], '8_P_CD': [-15.06, -2.368, 17.751, 1.0], '9_S_OG': [-12.733, 0.388, 24.504, 1.0], '10_T_CG2': [-19.084, -0.423, 22.65, 1.0], '11_C_SG': [-15.455, 2.166, 27.172, 1.0], '12_N_ND2': [-20.734, -3.99, 27.233, 1.0], '13_Q_NE2': [-19.362, 4.465, 30.847, 1.0], '14_Y_CE2': [-20.685, -3.571, 32.854, 1.0], '15_W_CH2': [-23.295, 1.706, 32.883, 1.0], '16_D_OD2': [-24.285, -3.683, 40.62, 1.0], '17_E_OE2': [-31.719, 2.385, 38.887, 1.0], '18_H_NE2': [-25.763, -0.071, 46.356, 1.0], '19_K_NZ': [-36.073, -0.926, 42.383, 1.0], '20_R_NH2': [-28.792, 3.687, 51.738, 1.0]}\n    for (k, v) in posnDict.items():\n        atm = AtomKey(k)\n        ndx = cic.atomArrayIndex[atm]\n        coord = np.round(cic.atomArray[ndx], 3)\n        self.assertTrue(np.array_equal(coord, v), msg=f'position error on atom {k}')\n    cic.update_dCoordSpace()\n    rt = cic.ordered_aa_ic_list[5]\n    chi1 = rt.pick_angle('chi1')\n    rt.applyMtx(chi1.cst)\n    coord = rt.residue.child_dict['CA'].coord\n    self.assertTrue(np.allclose(coord, [0.0, 0.0, 0.0]), msg='dCoordSpace transform error')\n    psi = rt.pick_angle('psi')\n    self.assertEqual(psi.__repr__(), \"4-6_M_N:6_M_CA:6_M_C:7_F_N MNMCAMCFN 123.0 ('1RND', 0, 'A', (' ', 6, ' '))\", msg='dihedron __repr__ error for M6 psi')\n    m = 'Edron rich comparison failed'\n    self.assertTrue(chi1 != psi, msg=m)\n    self.assertFalse(chi1 == psi, msg=m)\n    self.assertTrue(psi < chi1, msg=m)\n    self.assertTrue(psi <= chi1, msg=m)\n    self.assertTrue(chi1 > psi, msg=m)\n    self.assertTrue(chi1 >= psi, msg=m)\n    self.assertTrue(chi1.cre_class == 'NsbCsbCsbCsb', msg='covalent radii assignment error for chi1')\n    self.assertTrue(all((ak in rt for ak in chi1.atomkeys)))\n    self.assertFalse(all((ak in rt for ak in psi.atomkeys)))\n    tau = rt.pick_angle('tau')\n    self.assertEqual(tau.__repr__(), '3-6_M_N:6_M_CA:6_M_C MNMCAMC 1.46091 110.97184 1.52499', msg='hedron __repr__ error for M11 tau')\n    (a0, a1) = (tau.atomkeys[0], tau.atomkeys[1])\n    m = 'AtomKey rich comparison failed'\n    self.assertTrue(a1 > a0, msg=m)\n    self.assertTrue(a1 >= a0, msg=m)\n    self.assertTrue(a0 <= a1, msg=m)",
        "mutated": [
            "def test_seq_as_PIC(self):\n    if False:\n        i = 10\n    'Read seq as PIC data, extend chain, set each chi angle, check various.'\n    pdb_structure = read_PIC_seq(SeqRecord(Seq('GAVLIMFPSTCNQYWDEHKR'), id='1RND', description='my 20aa sequence'))\n    chn = next(pdb_structure.get_chains())\n    cic = chn.internal_coord\n    cic.make_extended()\n    for chi in range(1, 6):\n        for ric in chn.internal_coord.ordered_aa_ic_list:\n            targ = 'chi' + str(chi)\n            rchi = ric.get_angle(targ)\n            if rchi is not None:\n                nangl = rchi + 60.0\n                ric.set_angle(targ, nangl)\n    pdb_structure.internal_to_atom_coordinates()\n    self.assertEqual(len(cic.atomArrayValid), 168, msg='wrong number atoms from sequence')\n    posnDict = {'1_G_CA': [0.0, 0.0, 0.0, 1.0], '2_A_CB': [-0.411, 2.505, 4.035, 1.0], '3_V_CG2': [-2.246, -2.942, 4.865, 1.0], '4_L_CD2': [-4.673, 2.124, 6.06, 1.0], '5_I_CD1': [-4.26, -4.0, 10.546, 1.0], '6_M_CE': [-10.035, 4.22, 12.322, 1.0], '7_F_CE2': [-5.835, -1.076, 15.391, 1.0], '8_P_CD': [-15.06, -2.368, 17.751, 1.0], '9_S_OG': [-12.733, 0.388, 24.504, 1.0], '10_T_CG2': [-19.084, -0.423, 22.65, 1.0], '11_C_SG': [-15.455, 2.166, 27.172, 1.0], '12_N_ND2': [-20.734, -3.99, 27.233, 1.0], '13_Q_NE2': [-19.362, 4.465, 30.847, 1.0], '14_Y_CE2': [-20.685, -3.571, 32.854, 1.0], '15_W_CH2': [-23.295, 1.706, 32.883, 1.0], '16_D_OD2': [-24.285, -3.683, 40.62, 1.0], '17_E_OE2': [-31.719, 2.385, 38.887, 1.0], '18_H_NE2': [-25.763, -0.071, 46.356, 1.0], '19_K_NZ': [-36.073, -0.926, 42.383, 1.0], '20_R_NH2': [-28.792, 3.687, 51.738, 1.0]}\n    for (k, v) in posnDict.items():\n        atm = AtomKey(k)\n        ndx = cic.atomArrayIndex[atm]\n        coord = np.round(cic.atomArray[ndx], 3)\n        self.assertTrue(np.array_equal(coord, v), msg=f'position error on atom {k}')\n    cic.update_dCoordSpace()\n    rt = cic.ordered_aa_ic_list[5]\n    chi1 = rt.pick_angle('chi1')\n    rt.applyMtx(chi1.cst)\n    coord = rt.residue.child_dict['CA'].coord\n    self.assertTrue(np.allclose(coord, [0.0, 0.0, 0.0]), msg='dCoordSpace transform error')\n    psi = rt.pick_angle('psi')\n    self.assertEqual(psi.__repr__(), \"4-6_M_N:6_M_CA:6_M_C:7_F_N MNMCAMCFN 123.0 ('1RND', 0, 'A', (' ', 6, ' '))\", msg='dihedron __repr__ error for M6 psi')\n    m = 'Edron rich comparison failed'\n    self.assertTrue(chi1 != psi, msg=m)\n    self.assertFalse(chi1 == psi, msg=m)\n    self.assertTrue(psi < chi1, msg=m)\n    self.assertTrue(psi <= chi1, msg=m)\n    self.assertTrue(chi1 > psi, msg=m)\n    self.assertTrue(chi1 >= psi, msg=m)\n    self.assertTrue(chi1.cre_class == 'NsbCsbCsbCsb', msg='covalent radii assignment error for chi1')\n    self.assertTrue(all((ak in rt for ak in chi1.atomkeys)))\n    self.assertFalse(all((ak in rt for ak in psi.atomkeys)))\n    tau = rt.pick_angle('tau')\n    self.assertEqual(tau.__repr__(), '3-6_M_N:6_M_CA:6_M_C MNMCAMC 1.46091 110.97184 1.52499', msg='hedron __repr__ error for M11 tau')\n    (a0, a1) = (tau.atomkeys[0], tau.atomkeys[1])\n    m = 'AtomKey rich comparison failed'\n    self.assertTrue(a1 > a0, msg=m)\n    self.assertTrue(a1 >= a0, msg=m)\n    self.assertTrue(a0 <= a1, msg=m)",
            "def test_seq_as_PIC(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Read seq as PIC data, extend chain, set each chi angle, check various.'\n    pdb_structure = read_PIC_seq(SeqRecord(Seq('GAVLIMFPSTCNQYWDEHKR'), id='1RND', description='my 20aa sequence'))\n    chn = next(pdb_structure.get_chains())\n    cic = chn.internal_coord\n    cic.make_extended()\n    for chi in range(1, 6):\n        for ric in chn.internal_coord.ordered_aa_ic_list:\n            targ = 'chi' + str(chi)\n            rchi = ric.get_angle(targ)\n            if rchi is not None:\n                nangl = rchi + 60.0\n                ric.set_angle(targ, nangl)\n    pdb_structure.internal_to_atom_coordinates()\n    self.assertEqual(len(cic.atomArrayValid), 168, msg='wrong number atoms from sequence')\n    posnDict = {'1_G_CA': [0.0, 0.0, 0.0, 1.0], '2_A_CB': [-0.411, 2.505, 4.035, 1.0], '3_V_CG2': [-2.246, -2.942, 4.865, 1.0], '4_L_CD2': [-4.673, 2.124, 6.06, 1.0], '5_I_CD1': [-4.26, -4.0, 10.546, 1.0], '6_M_CE': [-10.035, 4.22, 12.322, 1.0], '7_F_CE2': [-5.835, -1.076, 15.391, 1.0], '8_P_CD': [-15.06, -2.368, 17.751, 1.0], '9_S_OG': [-12.733, 0.388, 24.504, 1.0], '10_T_CG2': [-19.084, -0.423, 22.65, 1.0], '11_C_SG': [-15.455, 2.166, 27.172, 1.0], '12_N_ND2': [-20.734, -3.99, 27.233, 1.0], '13_Q_NE2': [-19.362, 4.465, 30.847, 1.0], '14_Y_CE2': [-20.685, -3.571, 32.854, 1.0], '15_W_CH2': [-23.295, 1.706, 32.883, 1.0], '16_D_OD2': [-24.285, -3.683, 40.62, 1.0], '17_E_OE2': [-31.719, 2.385, 38.887, 1.0], '18_H_NE2': [-25.763, -0.071, 46.356, 1.0], '19_K_NZ': [-36.073, -0.926, 42.383, 1.0], '20_R_NH2': [-28.792, 3.687, 51.738, 1.0]}\n    for (k, v) in posnDict.items():\n        atm = AtomKey(k)\n        ndx = cic.atomArrayIndex[atm]\n        coord = np.round(cic.atomArray[ndx], 3)\n        self.assertTrue(np.array_equal(coord, v), msg=f'position error on atom {k}')\n    cic.update_dCoordSpace()\n    rt = cic.ordered_aa_ic_list[5]\n    chi1 = rt.pick_angle('chi1')\n    rt.applyMtx(chi1.cst)\n    coord = rt.residue.child_dict['CA'].coord\n    self.assertTrue(np.allclose(coord, [0.0, 0.0, 0.0]), msg='dCoordSpace transform error')\n    psi = rt.pick_angle('psi')\n    self.assertEqual(psi.__repr__(), \"4-6_M_N:6_M_CA:6_M_C:7_F_N MNMCAMCFN 123.0 ('1RND', 0, 'A', (' ', 6, ' '))\", msg='dihedron __repr__ error for M6 psi')\n    m = 'Edron rich comparison failed'\n    self.assertTrue(chi1 != psi, msg=m)\n    self.assertFalse(chi1 == psi, msg=m)\n    self.assertTrue(psi < chi1, msg=m)\n    self.assertTrue(psi <= chi1, msg=m)\n    self.assertTrue(chi1 > psi, msg=m)\n    self.assertTrue(chi1 >= psi, msg=m)\n    self.assertTrue(chi1.cre_class == 'NsbCsbCsbCsb', msg='covalent radii assignment error for chi1')\n    self.assertTrue(all((ak in rt for ak in chi1.atomkeys)))\n    self.assertFalse(all((ak in rt for ak in psi.atomkeys)))\n    tau = rt.pick_angle('tau')\n    self.assertEqual(tau.__repr__(), '3-6_M_N:6_M_CA:6_M_C MNMCAMC 1.46091 110.97184 1.52499', msg='hedron __repr__ error for M11 tau')\n    (a0, a1) = (tau.atomkeys[0], tau.atomkeys[1])\n    m = 'AtomKey rich comparison failed'\n    self.assertTrue(a1 > a0, msg=m)\n    self.assertTrue(a1 >= a0, msg=m)\n    self.assertTrue(a0 <= a1, msg=m)",
            "def test_seq_as_PIC(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Read seq as PIC data, extend chain, set each chi angle, check various.'\n    pdb_structure = read_PIC_seq(SeqRecord(Seq('GAVLIMFPSTCNQYWDEHKR'), id='1RND', description='my 20aa sequence'))\n    chn = next(pdb_structure.get_chains())\n    cic = chn.internal_coord\n    cic.make_extended()\n    for chi in range(1, 6):\n        for ric in chn.internal_coord.ordered_aa_ic_list:\n            targ = 'chi' + str(chi)\n            rchi = ric.get_angle(targ)\n            if rchi is not None:\n                nangl = rchi + 60.0\n                ric.set_angle(targ, nangl)\n    pdb_structure.internal_to_atom_coordinates()\n    self.assertEqual(len(cic.atomArrayValid), 168, msg='wrong number atoms from sequence')\n    posnDict = {'1_G_CA': [0.0, 0.0, 0.0, 1.0], '2_A_CB': [-0.411, 2.505, 4.035, 1.0], '3_V_CG2': [-2.246, -2.942, 4.865, 1.0], '4_L_CD2': [-4.673, 2.124, 6.06, 1.0], '5_I_CD1': [-4.26, -4.0, 10.546, 1.0], '6_M_CE': [-10.035, 4.22, 12.322, 1.0], '7_F_CE2': [-5.835, -1.076, 15.391, 1.0], '8_P_CD': [-15.06, -2.368, 17.751, 1.0], '9_S_OG': [-12.733, 0.388, 24.504, 1.0], '10_T_CG2': [-19.084, -0.423, 22.65, 1.0], '11_C_SG': [-15.455, 2.166, 27.172, 1.0], '12_N_ND2': [-20.734, -3.99, 27.233, 1.0], '13_Q_NE2': [-19.362, 4.465, 30.847, 1.0], '14_Y_CE2': [-20.685, -3.571, 32.854, 1.0], '15_W_CH2': [-23.295, 1.706, 32.883, 1.0], '16_D_OD2': [-24.285, -3.683, 40.62, 1.0], '17_E_OE2': [-31.719, 2.385, 38.887, 1.0], '18_H_NE2': [-25.763, -0.071, 46.356, 1.0], '19_K_NZ': [-36.073, -0.926, 42.383, 1.0], '20_R_NH2': [-28.792, 3.687, 51.738, 1.0]}\n    for (k, v) in posnDict.items():\n        atm = AtomKey(k)\n        ndx = cic.atomArrayIndex[atm]\n        coord = np.round(cic.atomArray[ndx], 3)\n        self.assertTrue(np.array_equal(coord, v), msg=f'position error on atom {k}')\n    cic.update_dCoordSpace()\n    rt = cic.ordered_aa_ic_list[5]\n    chi1 = rt.pick_angle('chi1')\n    rt.applyMtx(chi1.cst)\n    coord = rt.residue.child_dict['CA'].coord\n    self.assertTrue(np.allclose(coord, [0.0, 0.0, 0.0]), msg='dCoordSpace transform error')\n    psi = rt.pick_angle('psi')\n    self.assertEqual(psi.__repr__(), \"4-6_M_N:6_M_CA:6_M_C:7_F_N MNMCAMCFN 123.0 ('1RND', 0, 'A', (' ', 6, ' '))\", msg='dihedron __repr__ error for M6 psi')\n    m = 'Edron rich comparison failed'\n    self.assertTrue(chi1 != psi, msg=m)\n    self.assertFalse(chi1 == psi, msg=m)\n    self.assertTrue(psi < chi1, msg=m)\n    self.assertTrue(psi <= chi1, msg=m)\n    self.assertTrue(chi1 > psi, msg=m)\n    self.assertTrue(chi1 >= psi, msg=m)\n    self.assertTrue(chi1.cre_class == 'NsbCsbCsbCsb', msg='covalent radii assignment error for chi1')\n    self.assertTrue(all((ak in rt for ak in chi1.atomkeys)))\n    self.assertFalse(all((ak in rt for ak in psi.atomkeys)))\n    tau = rt.pick_angle('tau')\n    self.assertEqual(tau.__repr__(), '3-6_M_N:6_M_CA:6_M_C MNMCAMC 1.46091 110.97184 1.52499', msg='hedron __repr__ error for M11 tau')\n    (a0, a1) = (tau.atomkeys[0], tau.atomkeys[1])\n    m = 'AtomKey rich comparison failed'\n    self.assertTrue(a1 > a0, msg=m)\n    self.assertTrue(a1 >= a0, msg=m)\n    self.assertTrue(a0 <= a1, msg=m)",
            "def test_seq_as_PIC(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Read seq as PIC data, extend chain, set each chi angle, check various.'\n    pdb_structure = read_PIC_seq(SeqRecord(Seq('GAVLIMFPSTCNQYWDEHKR'), id='1RND', description='my 20aa sequence'))\n    chn = next(pdb_structure.get_chains())\n    cic = chn.internal_coord\n    cic.make_extended()\n    for chi in range(1, 6):\n        for ric in chn.internal_coord.ordered_aa_ic_list:\n            targ = 'chi' + str(chi)\n            rchi = ric.get_angle(targ)\n            if rchi is not None:\n                nangl = rchi + 60.0\n                ric.set_angle(targ, nangl)\n    pdb_structure.internal_to_atom_coordinates()\n    self.assertEqual(len(cic.atomArrayValid), 168, msg='wrong number atoms from sequence')\n    posnDict = {'1_G_CA': [0.0, 0.0, 0.0, 1.0], '2_A_CB': [-0.411, 2.505, 4.035, 1.0], '3_V_CG2': [-2.246, -2.942, 4.865, 1.0], '4_L_CD2': [-4.673, 2.124, 6.06, 1.0], '5_I_CD1': [-4.26, -4.0, 10.546, 1.0], '6_M_CE': [-10.035, 4.22, 12.322, 1.0], '7_F_CE2': [-5.835, -1.076, 15.391, 1.0], '8_P_CD': [-15.06, -2.368, 17.751, 1.0], '9_S_OG': [-12.733, 0.388, 24.504, 1.0], '10_T_CG2': [-19.084, -0.423, 22.65, 1.0], '11_C_SG': [-15.455, 2.166, 27.172, 1.0], '12_N_ND2': [-20.734, -3.99, 27.233, 1.0], '13_Q_NE2': [-19.362, 4.465, 30.847, 1.0], '14_Y_CE2': [-20.685, -3.571, 32.854, 1.0], '15_W_CH2': [-23.295, 1.706, 32.883, 1.0], '16_D_OD2': [-24.285, -3.683, 40.62, 1.0], '17_E_OE2': [-31.719, 2.385, 38.887, 1.0], '18_H_NE2': [-25.763, -0.071, 46.356, 1.0], '19_K_NZ': [-36.073, -0.926, 42.383, 1.0], '20_R_NH2': [-28.792, 3.687, 51.738, 1.0]}\n    for (k, v) in posnDict.items():\n        atm = AtomKey(k)\n        ndx = cic.atomArrayIndex[atm]\n        coord = np.round(cic.atomArray[ndx], 3)\n        self.assertTrue(np.array_equal(coord, v), msg=f'position error on atom {k}')\n    cic.update_dCoordSpace()\n    rt = cic.ordered_aa_ic_list[5]\n    chi1 = rt.pick_angle('chi1')\n    rt.applyMtx(chi1.cst)\n    coord = rt.residue.child_dict['CA'].coord\n    self.assertTrue(np.allclose(coord, [0.0, 0.0, 0.0]), msg='dCoordSpace transform error')\n    psi = rt.pick_angle('psi')\n    self.assertEqual(psi.__repr__(), \"4-6_M_N:6_M_CA:6_M_C:7_F_N MNMCAMCFN 123.0 ('1RND', 0, 'A', (' ', 6, ' '))\", msg='dihedron __repr__ error for M6 psi')\n    m = 'Edron rich comparison failed'\n    self.assertTrue(chi1 != psi, msg=m)\n    self.assertFalse(chi1 == psi, msg=m)\n    self.assertTrue(psi < chi1, msg=m)\n    self.assertTrue(psi <= chi1, msg=m)\n    self.assertTrue(chi1 > psi, msg=m)\n    self.assertTrue(chi1 >= psi, msg=m)\n    self.assertTrue(chi1.cre_class == 'NsbCsbCsbCsb', msg='covalent radii assignment error for chi1')\n    self.assertTrue(all((ak in rt for ak in chi1.atomkeys)))\n    self.assertFalse(all((ak in rt for ak in psi.atomkeys)))\n    tau = rt.pick_angle('tau')\n    self.assertEqual(tau.__repr__(), '3-6_M_N:6_M_CA:6_M_C MNMCAMC 1.46091 110.97184 1.52499', msg='hedron __repr__ error for M11 tau')\n    (a0, a1) = (tau.atomkeys[0], tau.atomkeys[1])\n    m = 'AtomKey rich comparison failed'\n    self.assertTrue(a1 > a0, msg=m)\n    self.assertTrue(a1 >= a0, msg=m)\n    self.assertTrue(a0 <= a1, msg=m)",
            "def test_seq_as_PIC(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Read seq as PIC data, extend chain, set each chi angle, check various.'\n    pdb_structure = read_PIC_seq(SeqRecord(Seq('GAVLIMFPSTCNQYWDEHKR'), id='1RND', description='my 20aa sequence'))\n    chn = next(pdb_structure.get_chains())\n    cic = chn.internal_coord\n    cic.make_extended()\n    for chi in range(1, 6):\n        for ric in chn.internal_coord.ordered_aa_ic_list:\n            targ = 'chi' + str(chi)\n            rchi = ric.get_angle(targ)\n            if rchi is not None:\n                nangl = rchi + 60.0\n                ric.set_angle(targ, nangl)\n    pdb_structure.internal_to_atom_coordinates()\n    self.assertEqual(len(cic.atomArrayValid), 168, msg='wrong number atoms from sequence')\n    posnDict = {'1_G_CA': [0.0, 0.0, 0.0, 1.0], '2_A_CB': [-0.411, 2.505, 4.035, 1.0], '3_V_CG2': [-2.246, -2.942, 4.865, 1.0], '4_L_CD2': [-4.673, 2.124, 6.06, 1.0], '5_I_CD1': [-4.26, -4.0, 10.546, 1.0], '6_M_CE': [-10.035, 4.22, 12.322, 1.0], '7_F_CE2': [-5.835, -1.076, 15.391, 1.0], '8_P_CD': [-15.06, -2.368, 17.751, 1.0], '9_S_OG': [-12.733, 0.388, 24.504, 1.0], '10_T_CG2': [-19.084, -0.423, 22.65, 1.0], '11_C_SG': [-15.455, 2.166, 27.172, 1.0], '12_N_ND2': [-20.734, -3.99, 27.233, 1.0], '13_Q_NE2': [-19.362, 4.465, 30.847, 1.0], '14_Y_CE2': [-20.685, -3.571, 32.854, 1.0], '15_W_CH2': [-23.295, 1.706, 32.883, 1.0], '16_D_OD2': [-24.285, -3.683, 40.62, 1.0], '17_E_OE2': [-31.719, 2.385, 38.887, 1.0], '18_H_NE2': [-25.763, -0.071, 46.356, 1.0], '19_K_NZ': [-36.073, -0.926, 42.383, 1.0], '20_R_NH2': [-28.792, 3.687, 51.738, 1.0]}\n    for (k, v) in posnDict.items():\n        atm = AtomKey(k)\n        ndx = cic.atomArrayIndex[atm]\n        coord = np.round(cic.atomArray[ndx], 3)\n        self.assertTrue(np.array_equal(coord, v), msg=f'position error on atom {k}')\n    cic.update_dCoordSpace()\n    rt = cic.ordered_aa_ic_list[5]\n    chi1 = rt.pick_angle('chi1')\n    rt.applyMtx(chi1.cst)\n    coord = rt.residue.child_dict['CA'].coord\n    self.assertTrue(np.allclose(coord, [0.0, 0.0, 0.0]), msg='dCoordSpace transform error')\n    psi = rt.pick_angle('psi')\n    self.assertEqual(psi.__repr__(), \"4-6_M_N:6_M_CA:6_M_C:7_F_N MNMCAMCFN 123.0 ('1RND', 0, 'A', (' ', 6, ' '))\", msg='dihedron __repr__ error for M6 psi')\n    m = 'Edron rich comparison failed'\n    self.assertTrue(chi1 != psi, msg=m)\n    self.assertFalse(chi1 == psi, msg=m)\n    self.assertTrue(psi < chi1, msg=m)\n    self.assertTrue(psi <= chi1, msg=m)\n    self.assertTrue(chi1 > psi, msg=m)\n    self.assertTrue(chi1 >= psi, msg=m)\n    self.assertTrue(chi1.cre_class == 'NsbCsbCsbCsb', msg='covalent radii assignment error for chi1')\n    self.assertTrue(all((ak in rt for ak in chi1.atomkeys)))\n    self.assertFalse(all((ak in rt for ak in psi.atomkeys)))\n    tau = rt.pick_angle('tau')\n    self.assertEqual(tau.__repr__(), '3-6_M_N:6_M_CA:6_M_C MNMCAMC 1.46091 110.97184 1.52499', msg='hedron __repr__ error for M11 tau')\n    (a0, a1) = (tau.atomkeys[0], tau.atomkeys[1])\n    m = 'AtomKey rich comparison failed'\n    self.assertTrue(a1 > a0, msg=m)\n    self.assertTrue(a1 >= a0, msg=m)\n    self.assertTrue(a0 <= a1, msg=m)"
        ]
    },
    {
        "func_name": "test_angle_fns",
        "original": "def test_angle_fns(self):\n    \"\"\"Test angle_dif and angle_avg across +/-180 boundaries.\"\"\"\n    arr1 = np.array([179.0, 90.0, 88.0, 1.0])\n    arr2 = np.array([-179.0, -90.0, -91.0, -1.0])\n    assert (Dihedron.angle_dif(arr1, arr2) == np.array([2.0, 180.0, -179.0, -2.0])).all()\n    assert Dihedron.angle_avg(np.array([179.0, -179.0])) == 180.0\n    assert Dihedron.angle_avg(np.array([1.0, -1.0])) == 0.0\n    assert Dihedron.angle_avg(np.array([90.0, -90.0])) == 0.0\n    assert Dihedron.angle_avg(np.array([91.0, -91.0])) == 180.0",
        "mutated": [
            "def test_angle_fns(self):\n    if False:\n        i = 10\n    'Test angle_dif and angle_avg across +/-180 boundaries.'\n    arr1 = np.array([179.0, 90.0, 88.0, 1.0])\n    arr2 = np.array([-179.0, -90.0, -91.0, -1.0])\n    assert (Dihedron.angle_dif(arr1, arr2) == np.array([2.0, 180.0, -179.0, -2.0])).all()\n    assert Dihedron.angle_avg(np.array([179.0, -179.0])) == 180.0\n    assert Dihedron.angle_avg(np.array([1.0, -1.0])) == 0.0\n    assert Dihedron.angle_avg(np.array([90.0, -90.0])) == 0.0\n    assert Dihedron.angle_avg(np.array([91.0, -91.0])) == 180.0",
            "def test_angle_fns(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test angle_dif and angle_avg across +/-180 boundaries.'\n    arr1 = np.array([179.0, 90.0, 88.0, 1.0])\n    arr2 = np.array([-179.0, -90.0, -91.0, -1.0])\n    assert (Dihedron.angle_dif(arr1, arr2) == np.array([2.0, 180.0, -179.0, -2.0])).all()\n    assert Dihedron.angle_avg(np.array([179.0, -179.0])) == 180.0\n    assert Dihedron.angle_avg(np.array([1.0, -1.0])) == 0.0\n    assert Dihedron.angle_avg(np.array([90.0, -90.0])) == 0.0\n    assert Dihedron.angle_avg(np.array([91.0, -91.0])) == 180.0",
            "def test_angle_fns(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test angle_dif and angle_avg across +/-180 boundaries.'\n    arr1 = np.array([179.0, 90.0, 88.0, 1.0])\n    arr2 = np.array([-179.0, -90.0, -91.0, -1.0])\n    assert (Dihedron.angle_dif(arr1, arr2) == np.array([2.0, 180.0, -179.0, -2.0])).all()\n    assert Dihedron.angle_avg(np.array([179.0, -179.0])) == 180.0\n    assert Dihedron.angle_avg(np.array([1.0, -1.0])) == 0.0\n    assert Dihedron.angle_avg(np.array([90.0, -90.0])) == 0.0\n    assert Dihedron.angle_avg(np.array([91.0, -91.0])) == 180.0",
            "def test_angle_fns(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test angle_dif and angle_avg across +/-180 boundaries.'\n    arr1 = np.array([179.0, 90.0, 88.0, 1.0])\n    arr2 = np.array([-179.0, -90.0, -91.0, -1.0])\n    assert (Dihedron.angle_dif(arr1, arr2) == np.array([2.0, 180.0, -179.0, -2.0])).all()\n    assert Dihedron.angle_avg(np.array([179.0, -179.0])) == 180.0\n    assert Dihedron.angle_avg(np.array([1.0, -1.0])) == 0.0\n    assert Dihedron.angle_avg(np.array([90.0, -90.0])) == 0.0\n    assert Dihedron.angle_avg(np.array([91.0, -91.0])) == 180.0",
            "def test_angle_fns(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test angle_dif and angle_avg across +/-180 boundaries.'\n    arr1 = np.array([179.0, 90.0, 88.0, 1.0])\n    arr2 = np.array([-179.0, -90.0, -91.0, -1.0])\n    assert (Dihedron.angle_dif(arr1, arr2) == np.array([2.0, 180.0, -179.0, -2.0])).all()\n    assert Dihedron.angle_avg(np.array([179.0, -179.0])) == 180.0\n    assert Dihedron.angle_avg(np.array([1.0, -1.0])) == 0.0\n    assert Dihedron.angle_avg(np.array([90.0, -90.0])) == 0.0\n    assert Dihedron.angle_avg(np.array([91.0, -91.0])) == 180.0"
        ]
    }
]