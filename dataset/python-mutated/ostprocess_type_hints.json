[
    {
        "func_name": "stub_files_match",
        "original": "def stub_files_match(a: str, b: str) -> bool:\n    a = ''.join([x for x in a.split('\\n') if x.strip() and x.strip() not in LINES_TO_IGNORE_FOR_MATCH])\n    b = ''.join([x for x in b.split('\\n') if x.strip() and x.strip() not in LINES_TO_IGNORE_FOR_MATCH])\n    return a == b",
        "mutated": [
            "def stub_files_match(a: str, b: str) -> bool:\n    if False:\n        i = 10\n    a = ''.join([x for x in a.split('\\n') if x.strip() and x.strip() not in LINES_TO_IGNORE_FOR_MATCH])\n    b = ''.join([x for x in b.split('\\n') if x.strip() and x.strip() not in LINES_TO_IGNORE_FOR_MATCH])\n    return a == b",
            "def stub_files_match(a: str, b: str) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    a = ''.join([x for x in a.split('\\n') if x.strip() and x.strip() not in LINES_TO_IGNORE_FOR_MATCH])\n    b = ''.join([x for x in b.split('\\n') if x.strip() and x.strip() not in LINES_TO_IGNORE_FOR_MATCH])\n    return a == b",
            "def stub_files_match(a: str, b: str) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    a = ''.join([x for x in a.split('\\n') if x.strip() and x.strip() not in LINES_TO_IGNORE_FOR_MATCH])\n    b = ''.join([x for x in b.split('\\n') if x.strip() and x.strip() not in LINES_TO_IGNORE_FOR_MATCH])\n    return a == b",
            "def stub_files_match(a: str, b: str) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    a = ''.join([x for x in a.split('\\n') if x.strip() and x.strip() not in LINES_TO_IGNORE_FOR_MATCH])\n    b = ''.join([x for x in b.split('\\n') if x.strip() and x.strip() not in LINES_TO_IGNORE_FOR_MATCH])\n    return a == b",
            "def stub_files_match(a: str, b: str) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    a = ''.join([x for x in a.split('\\n') if x.strip() and x.strip() not in LINES_TO_IGNORE_FOR_MATCH])\n    b = ''.join([x for x in b.split('\\n') if x.strip() and x.strip() not in LINES_TO_IGNORE_FOR_MATCH])\n    return a == b"
        ]
    },
    {
        "func_name": "main",
        "original": "def main(args=None):\n    parser = argparse.ArgumentParser(description='Post-process type hint files produced by pybind11-stubgen for Pedalboard.')\n    parser.add_argument('source_directory', default=os.path.join(REPO_ROOT, 'pybind11-stubgen-output'))\n    parser.add_argument('target_directory', default=os.path.join(REPO_ROOT, 'pedalboard'))\n    parser.add_argument('--check', action='store_true', help=\"Return a non-zero exit code if files on disk don't match what this script would generate.\")\n    args = parser.parse_args(args)\n    output_file_to_source_files = defaultdict(list)\n    for source_path in Path(args.source_directory).rglob('*.pyi'):\n        output_file_to_source_files[str(source_path)].append(str(source_path))\n    for (output_file_name, source_files) in output_file_to_source_files.items():\n        os.makedirs(os.path.dirname(output_file_name), exist_ok=True)\n        print(f'Writing stub file {output_file_name}...')\n        file_contents = io.StringIO()\n        end_of_file_contents = io.StringIO()\n        for source_file in source_files:\n            module_name = output_file_name.replace('__init__.pyi', '').replace('/', '.').rstrip('.')\n            with open(source_file) as f:\n                source_file_contents = f.read()\n                for (find, replace) in MULTILINE_REPLACEMENTS:\n                    source_file_contents = re.sub(find, replace, source_file_contents, flags=re.DOTALL)\n                lines = [x + '\\n' for x in source_file_contents.split('\\n')]\n                in_excluded_indented_block = False\n                in_moved_indented_block = False\n                for line in lines:\n                    if all((x not in line for x in OMIT_LINES_CONTAINING)):\n                        if any((line.startswith(x) for x in REMOVE_INDENTED_BLOCKS_STARTING_WITH)):\n                            in_excluded_indented_block = True\n                            continue\n                        elif any((line.startswith(x) for x in INDENTED_BLOCKS_TO_MOVE_TO_END)):\n                            in_moved_indented_block = True\n                        elif line.strip() and (not line.startswith(' ')):\n                            in_excluded_indented_block = False\n                            in_moved_indented_block = False\n                        if in_excluded_indented_block:\n                            continue\n                        for _tuple in REPLACEMENTS:\n                            if len(_tuple) == 2:\n                                (find, replace) = _tuple\n                                only_in_module = None\n                            else:\n                                (find, replace, only_in_module) = _tuple\n                            if only_in_module and only_in_module != module_name:\n                                continue\n                            results = re.findall(find, line)\n                            if results:\n                                line = re.sub(find, replace, line)\n                        if in_moved_indented_block:\n                            end_of_file_contents.write(line)\n                        else:\n                            file_contents.write(line)\n                print(f'\\tRead {f.tell():,} bytes of stubs from {source_file}.')\n        file_contents.write('\\n')\n        file_contents.write(end_of_file_contents.getvalue())\n        try:\n            output = black.format_file_contents(file_contents.getvalue(), fast=False, mode=black.FileMode(is_pyi=True, line_length=100))\n        except black.report.NothingChanged:\n            output = file_contents.getvalue()\n        if args.check:\n            with open(output_file_name, 'r') as f:\n                existing = f.read()\n                if not stub_files_match(existing, output):\n                    error = f'File that would be generated ({output_file_name}) '\n                    error += 'does not match existing file!\\n'\n                    error += f'Existing file had {len(existing):,} bytes, '\n                    error += f'expected {len(output):,} bytes.\\nDiff was:\\n'\n                    diff = difflib.context_diff(existing.split('\\n'), output.split('\\n'))\n                    error += '\\n'.join([x.strip() for x in diff])\n                    raise ValueError(error)\n        else:\n            with open(output_file_name, 'w') as o:\n                o.write(output)\n                print(f'\\tWrote {o.tell():,} bytes of stubs to {output_file_name}.')\n    print('Done!')",
        "mutated": [
            "def main(args=None):\n    if False:\n        i = 10\n    parser = argparse.ArgumentParser(description='Post-process type hint files produced by pybind11-stubgen for Pedalboard.')\n    parser.add_argument('source_directory', default=os.path.join(REPO_ROOT, 'pybind11-stubgen-output'))\n    parser.add_argument('target_directory', default=os.path.join(REPO_ROOT, 'pedalboard'))\n    parser.add_argument('--check', action='store_true', help=\"Return a non-zero exit code if files on disk don't match what this script would generate.\")\n    args = parser.parse_args(args)\n    output_file_to_source_files = defaultdict(list)\n    for source_path in Path(args.source_directory).rglob('*.pyi'):\n        output_file_to_source_files[str(source_path)].append(str(source_path))\n    for (output_file_name, source_files) in output_file_to_source_files.items():\n        os.makedirs(os.path.dirname(output_file_name), exist_ok=True)\n        print(f'Writing stub file {output_file_name}...')\n        file_contents = io.StringIO()\n        end_of_file_contents = io.StringIO()\n        for source_file in source_files:\n            module_name = output_file_name.replace('__init__.pyi', '').replace('/', '.').rstrip('.')\n            with open(source_file) as f:\n                source_file_contents = f.read()\n                for (find, replace) in MULTILINE_REPLACEMENTS:\n                    source_file_contents = re.sub(find, replace, source_file_contents, flags=re.DOTALL)\n                lines = [x + '\\n' for x in source_file_contents.split('\\n')]\n                in_excluded_indented_block = False\n                in_moved_indented_block = False\n                for line in lines:\n                    if all((x not in line for x in OMIT_LINES_CONTAINING)):\n                        if any((line.startswith(x) for x in REMOVE_INDENTED_BLOCKS_STARTING_WITH)):\n                            in_excluded_indented_block = True\n                            continue\n                        elif any((line.startswith(x) for x in INDENTED_BLOCKS_TO_MOVE_TO_END)):\n                            in_moved_indented_block = True\n                        elif line.strip() and (not line.startswith(' ')):\n                            in_excluded_indented_block = False\n                            in_moved_indented_block = False\n                        if in_excluded_indented_block:\n                            continue\n                        for _tuple in REPLACEMENTS:\n                            if len(_tuple) == 2:\n                                (find, replace) = _tuple\n                                only_in_module = None\n                            else:\n                                (find, replace, only_in_module) = _tuple\n                            if only_in_module and only_in_module != module_name:\n                                continue\n                            results = re.findall(find, line)\n                            if results:\n                                line = re.sub(find, replace, line)\n                        if in_moved_indented_block:\n                            end_of_file_contents.write(line)\n                        else:\n                            file_contents.write(line)\n                print(f'\\tRead {f.tell():,} bytes of stubs from {source_file}.')\n        file_contents.write('\\n')\n        file_contents.write(end_of_file_contents.getvalue())\n        try:\n            output = black.format_file_contents(file_contents.getvalue(), fast=False, mode=black.FileMode(is_pyi=True, line_length=100))\n        except black.report.NothingChanged:\n            output = file_contents.getvalue()\n        if args.check:\n            with open(output_file_name, 'r') as f:\n                existing = f.read()\n                if not stub_files_match(existing, output):\n                    error = f'File that would be generated ({output_file_name}) '\n                    error += 'does not match existing file!\\n'\n                    error += f'Existing file had {len(existing):,} bytes, '\n                    error += f'expected {len(output):,} bytes.\\nDiff was:\\n'\n                    diff = difflib.context_diff(existing.split('\\n'), output.split('\\n'))\n                    error += '\\n'.join([x.strip() for x in diff])\n                    raise ValueError(error)\n        else:\n            with open(output_file_name, 'w') as o:\n                o.write(output)\n                print(f'\\tWrote {o.tell():,} bytes of stubs to {output_file_name}.')\n    print('Done!')",
            "def main(args=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    parser = argparse.ArgumentParser(description='Post-process type hint files produced by pybind11-stubgen for Pedalboard.')\n    parser.add_argument('source_directory', default=os.path.join(REPO_ROOT, 'pybind11-stubgen-output'))\n    parser.add_argument('target_directory', default=os.path.join(REPO_ROOT, 'pedalboard'))\n    parser.add_argument('--check', action='store_true', help=\"Return a non-zero exit code if files on disk don't match what this script would generate.\")\n    args = parser.parse_args(args)\n    output_file_to_source_files = defaultdict(list)\n    for source_path in Path(args.source_directory).rglob('*.pyi'):\n        output_file_to_source_files[str(source_path)].append(str(source_path))\n    for (output_file_name, source_files) in output_file_to_source_files.items():\n        os.makedirs(os.path.dirname(output_file_name), exist_ok=True)\n        print(f'Writing stub file {output_file_name}...')\n        file_contents = io.StringIO()\n        end_of_file_contents = io.StringIO()\n        for source_file in source_files:\n            module_name = output_file_name.replace('__init__.pyi', '').replace('/', '.').rstrip('.')\n            with open(source_file) as f:\n                source_file_contents = f.read()\n                for (find, replace) in MULTILINE_REPLACEMENTS:\n                    source_file_contents = re.sub(find, replace, source_file_contents, flags=re.DOTALL)\n                lines = [x + '\\n' for x in source_file_contents.split('\\n')]\n                in_excluded_indented_block = False\n                in_moved_indented_block = False\n                for line in lines:\n                    if all((x not in line for x in OMIT_LINES_CONTAINING)):\n                        if any((line.startswith(x) for x in REMOVE_INDENTED_BLOCKS_STARTING_WITH)):\n                            in_excluded_indented_block = True\n                            continue\n                        elif any((line.startswith(x) for x in INDENTED_BLOCKS_TO_MOVE_TO_END)):\n                            in_moved_indented_block = True\n                        elif line.strip() and (not line.startswith(' ')):\n                            in_excluded_indented_block = False\n                            in_moved_indented_block = False\n                        if in_excluded_indented_block:\n                            continue\n                        for _tuple in REPLACEMENTS:\n                            if len(_tuple) == 2:\n                                (find, replace) = _tuple\n                                only_in_module = None\n                            else:\n                                (find, replace, only_in_module) = _tuple\n                            if only_in_module and only_in_module != module_name:\n                                continue\n                            results = re.findall(find, line)\n                            if results:\n                                line = re.sub(find, replace, line)\n                        if in_moved_indented_block:\n                            end_of_file_contents.write(line)\n                        else:\n                            file_contents.write(line)\n                print(f'\\tRead {f.tell():,} bytes of stubs from {source_file}.')\n        file_contents.write('\\n')\n        file_contents.write(end_of_file_contents.getvalue())\n        try:\n            output = black.format_file_contents(file_contents.getvalue(), fast=False, mode=black.FileMode(is_pyi=True, line_length=100))\n        except black.report.NothingChanged:\n            output = file_contents.getvalue()\n        if args.check:\n            with open(output_file_name, 'r') as f:\n                existing = f.read()\n                if not stub_files_match(existing, output):\n                    error = f'File that would be generated ({output_file_name}) '\n                    error += 'does not match existing file!\\n'\n                    error += f'Existing file had {len(existing):,} bytes, '\n                    error += f'expected {len(output):,} bytes.\\nDiff was:\\n'\n                    diff = difflib.context_diff(existing.split('\\n'), output.split('\\n'))\n                    error += '\\n'.join([x.strip() for x in diff])\n                    raise ValueError(error)\n        else:\n            with open(output_file_name, 'w') as o:\n                o.write(output)\n                print(f'\\tWrote {o.tell():,} bytes of stubs to {output_file_name}.')\n    print('Done!')",
            "def main(args=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    parser = argparse.ArgumentParser(description='Post-process type hint files produced by pybind11-stubgen for Pedalboard.')\n    parser.add_argument('source_directory', default=os.path.join(REPO_ROOT, 'pybind11-stubgen-output'))\n    parser.add_argument('target_directory', default=os.path.join(REPO_ROOT, 'pedalboard'))\n    parser.add_argument('--check', action='store_true', help=\"Return a non-zero exit code if files on disk don't match what this script would generate.\")\n    args = parser.parse_args(args)\n    output_file_to_source_files = defaultdict(list)\n    for source_path in Path(args.source_directory).rglob('*.pyi'):\n        output_file_to_source_files[str(source_path)].append(str(source_path))\n    for (output_file_name, source_files) in output_file_to_source_files.items():\n        os.makedirs(os.path.dirname(output_file_name), exist_ok=True)\n        print(f'Writing stub file {output_file_name}...')\n        file_contents = io.StringIO()\n        end_of_file_contents = io.StringIO()\n        for source_file in source_files:\n            module_name = output_file_name.replace('__init__.pyi', '').replace('/', '.').rstrip('.')\n            with open(source_file) as f:\n                source_file_contents = f.read()\n                for (find, replace) in MULTILINE_REPLACEMENTS:\n                    source_file_contents = re.sub(find, replace, source_file_contents, flags=re.DOTALL)\n                lines = [x + '\\n' for x in source_file_contents.split('\\n')]\n                in_excluded_indented_block = False\n                in_moved_indented_block = False\n                for line in lines:\n                    if all((x not in line for x in OMIT_LINES_CONTAINING)):\n                        if any((line.startswith(x) for x in REMOVE_INDENTED_BLOCKS_STARTING_WITH)):\n                            in_excluded_indented_block = True\n                            continue\n                        elif any((line.startswith(x) for x in INDENTED_BLOCKS_TO_MOVE_TO_END)):\n                            in_moved_indented_block = True\n                        elif line.strip() and (not line.startswith(' ')):\n                            in_excluded_indented_block = False\n                            in_moved_indented_block = False\n                        if in_excluded_indented_block:\n                            continue\n                        for _tuple in REPLACEMENTS:\n                            if len(_tuple) == 2:\n                                (find, replace) = _tuple\n                                only_in_module = None\n                            else:\n                                (find, replace, only_in_module) = _tuple\n                            if only_in_module and only_in_module != module_name:\n                                continue\n                            results = re.findall(find, line)\n                            if results:\n                                line = re.sub(find, replace, line)\n                        if in_moved_indented_block:\n                            end_of_file_contents.write(line)\n                        else:\n                            file_contents.write(line)\n                print(f'\\tRead {f.tell():,} bytes of stubs from {source_file}.')\n        file_contents.write('\\n')\n        file_contents.write(end_of_file_contents.getvalue())\n        try:\n            output = black.format_file_contents(file_contents.getvalue(), fast=False, mode=black.FileMode(is_pyi=True, line_length=100))\n        except black.report.NothingChanged:\n            output = file_contents.getvalue()\n        if args.check:\n            with open(output_file_name, 'r') as f:\n                existing = f.read()\n                if not stub_files_match(existing, output):\n                    error = f'File that would be generated ({output_file_name}) '\n                    error += 'does not match existing file!\\n'\n                    error += f'Existing file had {len(existing):,} bytes, '\n                    error += f'expected {len(output):,} bytes.\\nDiff was:\\n'\n                    diff = difflib.context_diff(existing.split('\\n'), output.split('\\n'))\n                    error += '\\n'.join([x.strip() for x in diff])\n                    raise ValueError(error)\n        else:\n            with open(output_file_name, 'w') as o:\n                o.write(output)\n                print(f'\\tWrote {o.tell():,} bytes of stubs to {output_file_name}.')\n    print('Done!')",
            "def main(args=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    parser = argparse.ArgumentParser(description='Post-process type hint files produced by pybind11-stubgen for Pedalboard.')\n    parser.add_argument('source_directory', default=os.path.join(REPO_ROOT, 'pybind11-stubgen-output'))\n    parser.add_argument('target_directory', default=os.path.join(REPO_ROOT, 'pedalboard'))\n    parser.add_argument('--check', action='store_true', help=\"Return a non-zero exit code if files on disk don't match what this script would generate.\")\n    args = parser.parse_args(args)\n    output_file_to_source_files = defaultdict(list)\n    for source_path in Path(args.source_directory).rglob('*.pyi'):\n        output_file_to_source_files[str(source_path)].append(str(source_path))\n    for (output_file_name, source_files) in output_file_to_source_files.items():\n        os.makedirs(os.path.dirname(output_file_name), exist_ok=True)\n        print(f'Writing stub file {output_file_name}...')\n        file_contents = io.StringIO()\n        end_of_file_contents = io.StringIO()\n        for source_file in source_files:\n            module_name = output_file_name.replace('__init__.pyi', '').replace('/', '.').rstrip('.')\n            with open(source_file) as f:\n                source_file_contents = f.read()\n                for (find, replace) in MULTILINE_REPLACEMENTS:\n                    source_file_contents = re.sub(find, replace, source_file_contents, flags=re.DOTALL)\n                lines = [x + '\\n' for x in source_file_contents.split('\\n')]\n                in_excluded_indented_block = False\n                in_moved_indented_block = False\n                for line in lines:\n                    if all((x not in line for x in OMIT_LINES_CONTAINING)):\n                        if any((line.startswith(x) for x in REMOVE_INDENTED_BLOCKS_STARTING_WITH)):\n                            in_excluded_indented_block = True\n                            continue\n                        elif any((line.startswith(x) for x in INDENTED_BLOCKS_TO_MOVE_TO_END)):\n                            in_moved_indented_block = True\n                        elif line.strip() and (not line.startswith(' ')):\n                            in_excluded_indented_block = False\n                            in_moved_indented_block = False\n                        if in_excluded_indented_block:\n                            continue\n                        for _tuple in REPLACEMENTS:\n                            if len(_tuple) == 2:\n                                (find, replace) = _tuple\n                                only_in_module = None\n                            else:\n                                (find, replace, only_in_module) = _tuple\n                            if only_in_module and only_in_module != module_name:\n                                continue\n                            results = re.findall(find, line)\n                            if results:\n                                line = re.sub(find, replace, line)\n                        if in_moved_indented_block:\n                            end_of_file_contents.write(line)\n                        else:\n                            file_contents.write(line)\n                print(f'\\tRead {f.tell():,} bytes of stubs from {source_file}.')\n        file_contents.write('\\n')\n        file_contents.write(end_of_file_contents.getvalue())\n        try:\n            output = black.format_file_contents(file_contents.getvalue(), fast=False, mode=black.FileMode(is_pyi=True, line_length=100))\n        except black.report.NothingChanged:\n            output = file_contents.getvalue()\n        if args.check:\n            with open(output_file_name, 'r') as f:\n                existing = f.read()\n                if not stub_files_match(existing, output):\n                    error = f'File that would be generated ({output_file_name}) '\n                    error += 'does not match existing file!\\n'\n                    error += f'Existing file had {len(existing):,} bytes, '\n                    error += f'expected {len(output):,} bytes.\\nDiff was:\\n'\n                    diff = difflib.context_diff(existing.split('\\n'), output.split('\\n'))\n                    error += '\\n'.join([x.strip() for x in diff])\n                    raise ValueError(error)\n        else:\n            with open(output_file_name, 'w') as o:\n                o.write(output)\n                print(f'\\tWrote {o.tell():,} bytes of stubs to {output_file_name}.')\n    print('Done!')",
            "def main(args=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    parser = argparse.ArgumentParser(description='Post-process type hint files produced by pybind11-stubgen for Pedalboard.')\n    parser.add_argument('source_directory', default=os.path.join(REPO_ROOT, 'pybind11-stubgen-output'))\n    parser.add_argument('target_directory', default=os.path.join(REPO_ROOT, 'pedalboard'))\n    parser.add_argument('--check', action='store_true', help=\"Return a non-zero exit code if files on disk don't match what this script would generate.\")\n    args = parser.parse_args(args)\n    output_file_to_source_files = defaultdict(list)\n    for source_path in Path(args.source_directory).rglob('*.pyi'):\n        output_file_to_source_files[str(source_path)].append(str(source_path))\n    for (output_file_name, source_files) in output_file_to_source_files.items():\n        os.makedirs(os.path.dirname(output_file_name), exist_ok=True)\n        print(f'Writing stub file {output_file_name}...')\n        file_contents = io.StringIO()\n        end_of_file_contents = io.StringIO()\n        for source_file in source_files:\n            module_name = output_file_name.replace('__init__.pyi', '').replace('/', '.').rstrip('.')\n            with open(source_file) as f:\n                source_file_contents = f.read()\n                for (find, replace) in MULTILINE_REPLACEMENTS:\n                    source_file_contents = re.sub(find, replace, source_file_contents, flags=re.DOTALL)\n                lines = [x + '\\n' for x in source_file_contents.split('\\n')]\n                in_excluded_indented_block = False\n                in_moved_indented_block = False\n                for line in lines:\n                    if all((x not in line for x in OMIT_LINES_CONTAINING)):\n                        if any((line.startswith(x) for x in REMOVE_INDENTED_BLOCKS_STARTING_WITH)):\n                            in_excluded_indented_block = True\n                            continue\n                        elif any((line.startswith(x) for x in INDENTED_BLOCKS_TO_MOVE_TO_END)):\n                            in_moved_indented_block = True\n                        elif line.strip() and (not line.startswith(' ')):\n                            in_excluded_indented_block = False\n                            in_moved_indented_block = False\n                        if in_excluded_indented_block:\n                            continue\n                        for _tuple in REPLACEMENTS:\n                            if len(_tuple) == 2:\n                                (find, replace) = _tuple\n                                only_in_module = None\n                            else:\n                                (find, replace, only_in_module) = _tuple\n                            if only_in_module and only_in_module != module_name:\n                                continue\n                            results = re.findall(find, line)\n                            if results:\n                                line = re.sub(find, replace, line)\n                        if in_moved_indented_block:\n                            end_of_file_contents.write(line)\n                        else:\n                            file_contents.write(line)\n                print(f'\\tRead {f.tell():,} bytes of stubs from {source_file}.')\n        file_contents.write('\\n')\n        file_contents.write(end_of_file_contents.getvalue())\n        try:\n            output = black.format_file_contents(file_contents.getvalue(), fast=False, mode=black.FileMode(is_pyi=True, line_length=100))\n        except black.report.NothingChanged:\n            output = file_contents.getvalue()\n        if args.check:\n            with open(output_file_name, 'r') as f:\n                existing = f.read()\n                if not stub_files_match(existing, output):\n                    error = f'File that would be generated ({output_file_name}) '\n                    error += 'does not match existing file!\\n'\n                    error += f'Existing file had {len(existing):,} bytes, '\n                    error += f'expected {len(output):,} bytes.\\nDiff was:\\n'\n                    diff = difflib.context_diff(existing.split('\\n'), output.split('\\n'))\n                    error += '\\n'.join([x.strip() for x in diff])\n                    raise ValueError(error)\n        else:\n            with open(output_file_name, 'w') as o:\n                o.write(output)\n                print(f'\\tWrote {o.tell():,} bytes of stubs to {output_file_name}.')\n    print('Done!')"
        ]
    }
]