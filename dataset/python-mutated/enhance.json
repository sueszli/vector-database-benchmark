[
    {
        "func_name": "good_instr",
        "original": "def good_instr(i) -> bool:\n    return not any((bad in i for bad in bad_instrs))",
        "mutated": [
            "def good_instr(i) -> bool:\n    if False:\n        i = 10\n    return not any((bad in i for bad in bad_instrs))",
            "def good_instr(i) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return not any((bad in i for bad in bad_instrs))",
            "def good_instr(i) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return not any((bad in i for bad in bad_instrs))",
            "def good_instr(i) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return not any((bad in i for bad in bad_instrs))",
            "def good_instr(i) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return not any((bad in i for bad in bad_instrs))"
        ]
    },
    {
        "func_name": "int_str",
        "original": "def int_str(value: int) -> str:\n    retval = '%#x' % int(value & pwndbg.gdblib.arch.ptrmask)\n    packed = pwndbg.gdblib.arch.pack(int(value))\n    if all((c in string.printable.encode('utf-8') for c in packed)):\n        if len(retval) > 4:\n            retval = '{} ({!r})'.format(retval, str(packed.decode('ascii', 'ignore')))\n    return retval",
        "mutated": [
            "def int_str(value: int) -> str:\n    if False:\n        i = 10\n    retval = '%#x' % int(value & pwndbg.gdblib.arch.ptrmask)\n    packed = pwndbg.gdblib.arch.pack(int(value))\n    if all((c in string.printable.encode('utf-8') for c in packed)):\n        if len(retval) > 4:\n            retval = '{} ({!r})'.format(retval, str(packed.decode('ascii', 'ignore')))\n    return retval",
            "def int_str(value: int) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    retval = '%#x' % int(value & pwndbg.gdblib.arch.ptrmask)\n    packed = pwndbg.gdblib.arch.pack(int(value))\n    if all((c in string.printable.encode('utf-8') for c in packed)):\n        if len(retval) > 4:\n            retval = '{} ({!r})'.format(retval, str(packed.decode('ascii', 'ignore')))\n    return retval",
            "def int_str(value: int) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    retval = '%#x' % int(value & pwndbg.gdblib.arch.ptrmask)\n    packed = pwndbg.gdblib.arch.pack(int(value))\n    if all((c in string.printable.encode('utf-8') for c in packed)):\n        if len(retval) > 4:\n            retval = '{} ({!r})'.format(retval, str(packed.decode('ascii', 'ignore')))\n    return retval",
            "def int_str(value: int) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    retval = '%#x' % int(value & pwndbg.gdblib.arch.ptrmask)\n    packed = pwndbg.gdblib.arch.pack(int(value))\n    if all((c in string.printable.encode('utf-8') for c in packed)):\n        if len(retval) > 4:\n            retval = '{} ({!r})'.format(retval, str(packed.decode('ascii', 'ignore')))\n    return retval",
            "def int_str(value: int) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    retval = '%#x' % int(value & pwndbg.gdblib.arch.ptrmask)\n    packed = pwndbg.gdblib.arch.pack(int(value))\n    if all((c in string.printable.encode('utf-8') for c in packed)):\n        if len(retval) > 4:\n            retval = '{} ({!r})'.format(retval, str(packed.decode('ascii', 'ignore')))\n    return retval"
        ]
    },
    {
        "func_name": "enhance",
        "original": "def enhance(value: int, code: bool=True, safe_linking: bool=False) -> str:\n    \"\"\"\n    Given the last pointer in a chain, attempt to characterize\n\n    Note that 'the last pointer in a chain' may not at all actually be a pointer.\n\n    Additionally, optimizations are made based on various sources of data for\n    'value'. For example, if it is set to RWX, we try to get information on whether\n    it resides on the stack, or in a RW section that *happens* to be RWX, to\n    determine which order to print the fields.\n\n    Arguments:\n        value(obj): Value to enhance\n        code(bool): Hint that indicates the value may be an instruction\n        safe_linking(bool): Whether this chain use safe-linking\n    \"\"\"\n    value = int(value)\n    name = pwndbg.gdblib.symbol.get(value) or None\n    page = pwndbg.gdblib.vmmap.find(value)\n    can_read = True\n    if not page or None is pwndbg.gdblib.memory.peek(value):\n        can_read = False\n    if not can_read:\n        return E.integer(int_str(value))\n    instr = None\n    exe = page and page.execute\n    rwx = page and page.rwx\n    if '[stack' in page.objfile or '[heap' in page.objfile:\n        rwx = exe = False\n    if pwndbg.ida.available() and (not pwndbg.ida.GetFunctionName(value)):\n        rwx = exe = False\n    if exe:\n        instr = pwndbg.disasm.one(value)\n        if instr:\n            instr = f'{instr.mnemonic} {instr.op_str}'\n            if pwndbg.gdblib.config.syntax_highlight:\n                instr = syntax_highlight(instr)\n    szval = pwndbg.gdblib.strings.get(value) or None\n    szval0 = szval\n    if szval:\n        szval = E.string(repr(szval))\n    if value + pwndbg.gdblib.arch.ptrsize > page.end:\n        return E.integer(int_str(value))\n    intval = int(pwndbg.gdblib.memory.poi(pwndbg.gdblib.typeinfo.pvoid, value))\n    if safe_linking:\n        intval ^= value >> 12\n    intval0 = intval\n    if 0 <= intval < 10:\n        intval = E.integer(str(intval))\n    else:\n        intval = E.integer('%#x' % int(intval & pwndbg.gdblib.arch.ptrmask))\n    retval = []\n    if not code:\n        instr = None\n    if instr and 'stack' in page.objfile:\n        retval = [intval, szval]\n    elif instr and rwx and (intval0 < 4096):\n        retval = [intval, szval]\n    elif instr and exe:\n        if not rwx:\n            if szval:\n                retval = [instr, szval]\n            else:\n                retval = [instr]\n        else:\n            retval = [instr, intval, szval]\n    elif szval:\n        if len(szval0) < pwndbg.gdblib.arch.ptrsize:\n            retval = [intval, szval]\n        else:\n            retval = [szval]\n    else:\n        return E.integer(int_str(intval0))\n    retval = tuple(filter(lambda x: x is not None, retval))\n    if len(retval) == 0:\n        return E.unknown('???')\n    if len(retval) == 1:\n        return retval[0]\n    return retval[0] + E.comment(color.strip(f\" /* {'; '.join(retval[1:])} */\"))",
        "mutated": [
            "def enhance(value: int, code: bool=True, safe_linking: bool=False) -> str:\n    if False:\n        i = 10\n    \"\\n    Given the last pointer in a chain, attempt to characterize\\n\\n    Note that 'the last pointer in a chain' may not at all actually be a pointer.\\n\\n    Additionally, optimizations are made based on various sources of data for\\n    'value'. For example, if it is set to RWX, we try to get information on whether\\n    it resides on the stack, or in a RW section that *happens* to be RWX, to\\n    determine which order to print the fields.\\n\\n    Arguments:\\n        value(obj): Value to enhance\\n        code(bool): Hint that indicates the value may be an instruction\\n        safe_linking(bool): Whether this chain use safe-linking\\n    \"\n    value = int(value)\n    name = pwndbg.gdblib.symbol.get(value) or None\n    page = pwndbg.gdblib.vmmap.find(value)\n    can_read = True\n    if not page or None is pwndbg.gdblib.memory.peek(value):\n        can_read = False\n    if not can_read:\n        return E.integer(int_str(value))\n    instr = None\n    exe = page and page.execute\n    rwx = page and page.rwx\n    if '[stack' in page.objfile or '[heap' in page.objfile:\n        rwx = exe = False\n    if pwndbg.ida.available() and (not pwndbg.ida.GetFunctionName(value)):\n        rwx = exe = False\n    if exe:\n        instr = pwndbg.disasm.one(value)\n        if instr:\n            instr = f'{instr.mnemonic} {instr.op_str}'\n            if pwndbg.gdblib.config.syntax_highlight:\n                instr = syntax_highlight(instr)\n    szval = pwndbg.gdblib.strings.get(value) or None\n    szval0 = szval\n    if szval:\n        szval = E.string(repr(szval))\n    if value + pwndbg.gdblib.arch.ptrsize > page.end:\n        return E.integer(int_str(value))\n    intval = int(pwndbg.gdblib.memory.poi(pwndbg.gdblib.typeinfo.pvoid, value))\n    if safe_linking:\n        intval ^= value >> 12\n    intval0 = intval\n    if 0 <= intval < 10:\n        intval = E.integer(str(intval))\n    else:\n        intval = E.integer('%#x' % int(intval & pwndbg.gdblib.arch.ptrmask))\n    retval = []\n    if not code:\n        instr = None\n    if instr and 'stack' in page.objfile:\n        retval = [intval, szval]\n    elif instr and rwx and (intval0 < 4096):\n        retval = [intval, szval]\n    elif instr and exe:\n        if not rwx:\n            if szval:\n                retval = [instr, szval]\n            else:\n                retval = [instr]\n        else:\n            retval = [instr, intval, szval]\n    elif szval:\n        if len(szval0) < pwndbg.gdblib.arch.ptrsize:\n            retval = [intval, szval]\n        else:\n            retval = [szval]\n    else:\n        return E.integer(int_str(intval0))\n    retval = tuple(filter(lambda x: x is not None, retval))\n    if len(retval) == 0:\n        return E.unknown('???')\n    if len(retval) == 1:\n        return retval[0]\n    return retval[0] + E.comment(color.strip(f\" /* {'; '.join(retval[1:])} */\"))",
            "def enhance(value: int, code: bool=True, safe_linking: bool=False) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Given the last pointer in a chain, attempt to characterize\\n\\n    Note that 'the last pointer in a chain' may not at all actually be a pointer.\\n\\n    Additionally, optimizations are made based on various sources of data for\\n    'value'. For example, if it is set to RWX, we try to get information on whether\\n    it resides on the stack, or in a RW section that *happens* to be RWX, to\\n    determine which order to print the fields.\\n\\n    Arguments:\\n        value(obj): Value to enhance\\n        code(bool): Hint that indicates the value may be an instruction\\n        safe_linking(bool): Whether this chain use safe-linking\\n    \"\n    value = int(value)\n    name = pwndbg.gdblib.symbol.get(value) or None\n    page = pwndbg.gdblib.vmmap.find(value)\n    can_read = True\n    if not page or None is pwndbg.gdblib.memory.peek(value):\n        can_read = False\n    if not can_read:\n        return E.integer(int_str(value))\n    instr = None\n    exe = page and page.execute\n    rwx = page and page.rwx\n    if '[stack' in page.objfile or '[heap' in page.objfile:\n        rwx = exe = False\n    if pwndbg.ida.available() and (not pwndbg.ida.GetFunctionName(value)):\n        rwx = exe = False\n    if exe:\n        instr = pwndbg.disasm.one(value)\n        if instr:\n            instr = f'{instr.mnemonic} {instr.op_str}'\n            if pwndbg.gdblib.config.syntax_highlight:\n                instr = syntax_highlight(instr)\n    szval = pwndbg.gdblib.strings.get(value) or None\n    szval0 = szval\n    if szval:\n        szval = E.string(repr(szval))\n    if value + pwndbg.gdblib.arch.ptrsize > page.end:\n        return E.integer(int_str(value))\n    intval = int(pwndbg.gdblib.memory.poi(pwndbg.gdblib.typeinfo.pvoid, value))\n    if safe_linking:\n        intval ^= value >> 12\n    intval0 = intval\n    if 0 <= intval < 10:\n        intval = E.integer(str(intval))\n    else:\n        intval = E.integer('%#x' % int(intval & pwndbg.gdblib.arch.ptrmask))\n    retval = []\n    if not code:\n        instr = None\n    if instr and 'stack' in page.objfile:\n        retval = [intval, szval]\n    elif instr and rwx and (intval0 < 4096):\n        retval = [intval, szval]\n    elif instr and exe:\n        if not rwx:\n            if szval:\n                retval = [instr, szval]\n            else:\n                retval = [instr]\n        else:\n            retval = [instr, intval, szval]\n    elif szval:\n        if len(szval0) < pwndbg.gdblib.arch.ptrsize:\n            retval = [intval, szval]\n        else:\n            retval = [szval]\n    else:\n        return E.integer(int_str(intval0))\n    retval = tuple(filter(lambda x: x is not None, retval))\n    if len(retval) == 0:\n        return E.unknown('???')\n    if len(retval) == 1:\n        return retval[0]\n    return retval[0] + E.comment(color.strip(f\" /* {'; '.join(retval[1:])} */\"))",
            "def enhance(value: int, code: bool=True, safe_linking: bool=False) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Given the last pointer in a chain, attempt to characterize\\n\\n    Note that 'the last pointer in a chain' may not at all actually be a pointer.\\n\\n    Additionally, optimizations are made based on various sources of data for\\n    'value'. For example, if it is set to RWX, we try to get information on whether\\n    it resides on the stack, or in a RW section that *happens* to be RWX, to\\n    determine which order to print the fields.\\n\\n    Arguments:\\n        value(obj): Value to enhance\\n        code(bool): Hint that indicates the value may be an instruction\\n        safe_linking(bool): Whether this chain use safe-linking\\n    \"\n    value = int(value)\n    name = pwndbg.gdblib.symbol.get(value) or None\n    page = pwndbg.gdblib.vmmap.find(value)\n    can_read = True\n    if not page or None is pwndbg.gdblib.memory.peek(value):\n        can_read = False\n    if not can_read:\n        return E.integer(int_str(value))\n    instr = None\n    exe = page and page.execute\n    rwx = page and page.rwx\n    if '[stack' in page.objfile or '[heap' in page.objfile:\n        rwx = exe = False\n    if pwndbg.ida.available() and (not pwndbg.ida.GetFunctionName(value)):\n        rwx = exe = False\n    if exe:\n        instr = pwndbg.disasm.one(value)\n        if instr:\n            instr = f'{instr.mnemonic} {instr.op_str}'\n            if pwndbg.gdblib.config.syntax_highlight:\n                instr = syntax_highlight(instr)\n    szval = pwndbg.gdblib.strings.get(value) or None\n    szval0 = szval\n    if szval:\n        szval = E.string(repr(szval))\n    if value + pwndbg.gdblib.arch.ptrsize > page.end:\n        return E.integer(int_str(value))\n    intval = int(pwndbg.gdblib.memory.poi(pwndbg.gdblib.typeinfo.pvoid, value))\n    if safe_linking:\n        intval ^= value >> 12\n    intval0 = intval\n    if 0 <= intval < 10:\n        intval = E.integer(str(intval))\n    else:\n        intval = E.integer('%#x' % int(intval & pwndbg.gdblib.arch.ptrmask))\n    retval = []\n    if not code:\n        instr = None\n    if instr and 'stack' in page.objfile:\n        retval = [intval, szval]\n    elif instr and rwx and (intval0 < 4096):\n        retval = [intval, szval]\n    elif instr and exe:\n        if not rwx:\n            if szval:\n                retval = [instr, szval]\n            else:\n                retval = [instr]\n        else:\n            retval = [instr, intval, szval]\n    elif szval:\n        if len(szval0) < pwndbg.gdblib.arch.ptrsize:\n            retval = [intval, szval]\n        else:\n            retval = [szval]\n    else:\n        return E.integer(int_str(intval0))\n    retval = tuple(filter(lambda x: x is not None, retval))\n    if len(retval) == 0:\n        return E.unknown('???')\n    if len(retval) == 1:\n        return retval[0]\n    return retval[0] + E.comment(color.strip(f\" /* {'; '.join(retval[1:])} */\"))",
            "def enhance(value: int, code: bool=True, safe_linking: bool=False) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Given the last pointer in a chain, attempt to characterize\\n\\n    Note that 'the last pointer in a chain' may not at all actually be a pointer.\\n\\n    Additionally, optimizations are made based on various sources of data for\\n    'value'. For example, if it is set to RWX, we try to get information on whether\\n    it resides on the stack, or in a RW section that *happens* to be RWX, to\\n    determine which order to print the fields.\\n\\n    Arguments:\\n        value(obj): Value to enhance\\n        code(bool): Hint that indicates the value may be an instruction\\n        safe_linking(bool): Whether this chain use safe-linking\\n    \"\n    value = int(value)\n    name = pwndbg.gdblib.symbol.get(value) or None\n    page = pwndbg.gdblib.vmmap.find(value)\n    can_read = True\n    if not page or None is pwndbg.gdblib.memory.peek(value):\n        can_read = False\n    if not can_read:\n        return E.integer(int_str(value))\n    instr = None\n    exe = page and page.execute\n    rwx = page and page.rwx\n    if '[stack' in page.objfile or '[heap' in page.objfile:\n        rwx = exe = False\n    if pwndbg.ida.available() and (not pwndbg.ida.GetFunctionName(value)):\n        rwx = exe = False\n    if exe:\n        instr = pwndbg.disasm.one(value)\n        if instr:\n            instr = f'{instr.mnemonic} {instr.op_str}'\n            if pwndbg.gdblib.config.syntax_highlight:\n                instr = syntax_highlight(instr)\n    szval = pwndbg.gdblib.strings.get(value) or None\n    szval0 = szval\n    if szval:\n        szval = E.string(repr(szval))\n    if value + pwndbg.gdblib.arch.ptrsize > page.end:\n        return E.integer(int_str(value))\n    intval = int(pwndbg.gdblib.memory.poi(pwndbg.gdblib.typeinfo.pvoid, value))\n    if safe_linking:\n        intval ^= value >> 12\n    intval0 = intval\n    if 0 <= intval < 10:\n        intval = E.integer(str(intval))\n    else:\n        intval = E.integer('%#x' % int(intval & pwndbg.gdblib.arch.ptrmask))\n    retval = []\n    if not code:\n        instr = None\n    if instr and 'stack' in page.objfile:\n        retval = [intval, szval]\n    elif instr and rwx and (intval0 < 4096):\n        retval = [intval, szval]\n    elif instr and exe:\n        if not rwx:\n            if szval:\n                retval = [instr, szval]\n            else:\n                retval = [instr]\n        else:\n            retval = [instr, intval, szval]\n    elif szval:\n        if len(szval0) < pwndbg.gdblib.arch.ptrsize:\n            retval = [intval, szval]\n        else:\n            retval = [szval]\n    else:\n        return E.integer(int_str(intval0))\n    retval = tuple(filter(lambda x: x is not None, retval))\n    if len(retval) == 0:\n        return E.unknown('???')\n    if len(retval) == 1:\n        return retval[0]\n    return retval[0] + E.comment(color.strip(f\" /* {'; '.join(retval[1:])} */\"))",
            "def enhance(value: int, code: bool=True, safe_linking: bool=False) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Given the last pointer in a chain, attempt to characterize\\n\\n    Note that 'the last pointer in a chain' may not at all actually be a pointer.\\n\\n    Additionally, optimizations are made based on various sources of data for\\n    'value'. For example, if it is set to RWX, we try to get information on whether\\n    it resides on the stack, or in a RW section that *happens* to be RWX, to\\n    determine which order to print the fields.\\n\\n    Arguments:\\n        value(obj): Value to enhance\\n        code(bool): Hint that indicates the value may be an instruction\\n        safe_linking(bool): Whether this chain use safe-linking\\n    \"\n    value = int(value)\n    name = pwndbg.gdblib.symbol.get(value) or None\n    page = pwndbg.gdblib.vmmap.find(value)\n    can_read = True\n    if not page or None is pwndbg.gdblib.memory.peek(value):\n        can_read = False\n    if not can_read:\n        return E.integer(int_str(value))\n    instr = None\n    exe = page and page.execute\n    rwx = page and page.rwx\n    if '[stack' in page.objfile or '[heap' in page.objfile:\n        rwx = exe = False\n    if pwndbg.ida.available() and (not pwndbg.ida.GetFunctionName(value)):\n        rwx = exe = False\n    if exe:\n        instr = pwndbg.disasm.one(value)\n        if instr:\n            instr = f'{instr.mnemonic} {instr.op_str}'\n            if pwndbg.gdblib.config.syntax_highlight:\n                instr = syntax_highlight(instr)\n    szval = pwndbg.gdblib.strings.get(value) or None\n    szval0 = szval\n    if szval:\n        szval = E.string(repr(szval))\n    if value + pwndbg.gdblib.arch.ptrsize > page.end:\n        return E.integer(int_str(value))\n    intval = int(pwndbg.gdblib.memory.poi(pwndbg.gdblib.typeinfo.pvoid, value))\n    if safe_linking:\n        intval ^= value >> 12\n    intval0 = intval\n    if 0 <= intval < 10:\n        intval = E.integer(str(intval))\n    else:\n        intval = E.integer('%#x' % int(intval & pwndbg.gdblib.arch.ptrmask))\n    retval = []\n    if not code:\n        instr = None\n    if instr and 'stack' in page.objfile:\n        retval = [intval, szval]\n    elif instr and rwx and (intval0 < 4096):\n        retval = [intval, szval]\n    elif instr and exe:\n        if not rwx:\n            if szval:\n                retval = [instr, szval]\n            else:\n                retval = [instr]\n        else:\n            retval = [instr, intval, szval]\n    elif szval:\n        if len(szval0) < pwndbg.gdblib.arch.ptrsize:\n            retval = [intval, szval]\n        else:\n            retval = [szval]\n    else:\n        return E.integer(int_str(intval0))\n    retval = tuple(filter(lambda x: x is not None, retval))\n    if len(retval) == 0:\n        return E.unknown('???')\n    if len(retval) == 1:\n        return retval[0]\n    return retval[0] + E.comment(color.strip(f\" /* {'; '.join(retval[1:])} */\"))"
        ]
    }
]