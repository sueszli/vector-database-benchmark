[
    {
        "func_name": "forward_rates",
        "original": "def forward_rates(df_start_dates, df_end_dates, daycount_fractions, dtype=None, name=None):\n    \"\"\"Computes forward rates from daycount fractions and discount factors.\n\n  #### Example\n  ```python\n  # Discount factors at start dates\n  df_start_dates = [[0.95, 0.9, 0.75], [0.95, 0.99, 0.85]]\n  # Discount factors at end dates\n  df_end_dates = [[0.8, 0.6, 0.5], [0.8, 0.9, 0.5]]\n  # Daycount fractions between the dates\n  daycount_fractions = [[0.5, 1.0, 2], [0.6, 0.4, 4.0]]\n  # Expected:\n  #  [[0.375 , 0.5   , 0.25  ],\n  #   [0.3125, 0.25  , 0.175 ]]\n  forward_rates(df_start_dates, df_end_dates, daycount_fractions,\n                dtype=tf.float64)\n  ```\n\n  Args:\n    df_start_dates: A real `Tensor` representing discount factors at the start\n      dates.\n    df_end_dates: A real `Tensor` representing discount factors at the end\n      dates.\n    daycount_fractions: A real `Tensor` representing  year fractions for the\n      coupon accrual.\n    dtype: `tf.Dtype`. If supplied the dtype for the input and output `Tensor`s.\n      Default value: None which maps to the default dtype inferred from\n      `df_start_dates`.\n    name: Python str. The name to give to the ops created by this function.\n      Default value: None which maps to 'forward_rates'.\n\n  Returns:\n\n  \"\"\"\n    name = name or 'forward_rates'\n    with tf.name_scope(name):\n        df_start_dates = tf.convert_to_tensor(df_start_dates, dtype, name='df_start_dates')\n        dtype = dtype or df_start_dates.dtype\n        df_end_dates = tf.convert_to_tensor(df_end_dates, dtype, name='df_end_dates')\n        daycount_fractions = tf.convert_to_tensor(daycount_fractions, dtype, name='daycount_fractions')\n        return tf.math.divide_no_nan(tf.math.divide_no_nan(df_start_dates, df_end_dates) - 1, daycount_fractions)",
        "mutated": [
            "def forward_rates(df_start_dates, df_end_dates, daycount_fractions, dtype=None, name=None):\n    if False:\n        i = 10\n    \"Computes forward rates from daycount fractions and discount factors.\\n\\n  #### Example\\n  ```python\\n  # Discount factors at start dates\\n  df_start_dates = [[0.95, 0.9, 0.75], [0.95, 0.99, 0.85]]\\n  # Discount factors at end dates\\n  df_end_dates = [[0.8, 0.6, 0.5], [0.8, 0.9, 0.5]]\\n  # Daycount fractions between the dates\\n  daycount_fractions = [[0.5, 1.0, 2], [0.6, 0.4, 4.0]]\\n  # Expected:\\n  #  [[0.375 , 0.5   , 0.25  ],\\n  #   [0.3125, 0.25  , 0.175 ]]\\n  forward_rates(df_start_dates, df_end_dates, daycount_fractions,\\n                dtype=tf.float64)\\n  ```\\n\\n  Args:\\n    df_start_dates: A real `Tensor` representing discount factors at the start\\n      dates.\\n    df_end_dates: A real `Tensor` representing discount factors at the end\\n      dates.\\n    daycount_fractions: A real `Tensor` representing  year fractions for the\\n      coupon accrual.\\n    dtype: `tf.Dtype`. If supplied the dtype for the input and output `Tensor`s.\\n      Default value: None which maps to the default dtype inferred from\\n      `df_start_dates`.\\n    name: Python str. The name to give to the ops created by this function.\\n      Default value: None which maps to 'forward_rates'.\\n\\n  Returns:\\n\\n  \"\n    name = name or 'forward_rates'\n    with tf.name_scope(name):\n        df_start_dates = tf.convert_to_tensor(df_start_dates, dtype, name='df_start_dates')\n        dtype = dtype or df_start_dates.dtype\n        df_end_dates = tf.convert_to_tensor(df_end_dates, dtype, name='df_end_dates')\n        daycount_fractions = tf.convert_to_tensor(daycount_fractions, dtype, name='daycount_fractions')\n        return tf.math.divide_no_nan(tf.math.divide_no_nan(df_start_dates, df_end_dates) - 1, daycount_fractions)",
            "def forward_rates(df_start_dates, df_end_dates, daycount_fractions, dtype=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Computes forward rates from daycount fractions and discount factors.\\n\\n  #### Example\\n  ```python\\n  # Discount factors at start dates\\n  df_start_dates = [[0.95, 0.9, 0.75], [0.95, 0.99, 0.85]]\\n  # Discount factors at end dates\\n  df_end_dates = [[0.8, 0.6, 0.5], [0.8, 0.9, 0.5]]\\n  # Daycount fractions between the dates\\n  daycount_fractions = [[0.5, 1.0, 2], [0.6, 0.4, 4.0]]\\n  # Expected:\\n  #  [[0.375 , 0.5   , 0.25  ],\\n  #   [0.3125, 0.25  , 0.175 ]]\\n  forward_rates(df_start_dates, df_end_dates, daycount_fractions,\\n                dtype=tf.float64)\\n  ```\\n\\n  Args:\\n    df_start_dates: A real `Tensor` representing discount factors at the start\\n      dates.\\n    df_end_dates: A real `Tensor` representing discount factors at the end\\n      dates.\\n    daycount_fractions: A real `Tensor` representing  year fractions for the\\n      coupon accrual.\\n    dtype: `tf.Dtype`. If supplied the dtype for the input and output `Tensor`s.\\n      Default value: None which maps to the default dtype inferred from\\n      `df_start_dates`.\\n    name: Python str. The name to give to the ops created by this function.\\n      Default value: None which maps to 'forward_rates'.\\n\\n  Returns:\\n\\n  \"\n    name = name or 'forward_rates'\n    with tf.name_scope(name):\n        df_start_dates = tf.convert_to_tensor(df_start_dates, dtype, name='df_start_dates')\n        dtype = dtype or df_start_dates.dtype\n        df_end_dates = tf.convert_to_tensor(df_end_dates, dtype, name='df_end_dates')\n        daycount_fractions = tf.convert_to_tensor(daycount_fractions, dtype, name='daycount_fractions')\n        return tf.math.divide_no_nan(tf.math.divide_no_nan(df_start_dates, df_end_dates) - 1, daycount_fractions)",
            "def forward_rates(df_start_dates, df_end_dates, daycount_fractions, dtype=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Computes forward rates from daycount fractions and discount factors.\\n\\n  #### Example\\n  ```python\\n  # Discount factors at start dates\\n  df_start_dates = [[0.95, 0.9, 0.75], [0.95, 0.99, 0.85]]\\n  # Discount factors at end dates\\n  df_end_dates = [[0.8, 0.6, 0.5], [0.8, 0.9, 0.5]]\\n  # Daycount fractions between the dates\\n  daycount_fractions = [[0.5, 1.0, 2], [0.6, 0.4, 4.0]]\\n  # Expected:\\n  #  [[0.375 , 0.5   , 0.25  ],\\n  #   [0.3125, 0.25  , 0.175 ]]\\n  forward_rates(df_start_dates, df_end_dates, daycount_fractions,\\n                dtype=tf.float64)\\n  ```\\n\\n  Args:\\n    df_start_dates: A real `Tensor` representing discount factors at the start\\n      dates.\\n    df_end_dates: A real `Tensor` representing discount factors at the end\\n      dates.\\n    daycount_fractions: A real `Tensor` representing  year fractions for the\\n      coupon accrual.\\n    dtype: `tf.Dtype`. If supplied the dtype for the input and output `Tensor`s.\\n      Default value: None which maps to the default dtype inferred from\\n      `df_start_dates`.\\n    name: Python str. The name to give to the ops created by this function.\\n      Default value: None which maps to 'forward_rates'.\\n\\n  Returns:\\n\\n  \"\n    name = name or 'forward_rates'\n    with tf.name_scope(name):\n        df_start_dates = tf.convert_to_tensor(df_start_dates, dtype, name='df_start_dates')\n        dtype = dtype or df_start_dates.dtype\n        df_end_dates = tf.convert_to_tensor(df_end_dates, dtype, name='df_end_dates')\n        daycount_fractions = tf.convert_to_tensor(daycount_fractions, dtype, name='daycount_fractions')\n        return tf.math.divide_no_nan(tf.math.divide_no_nan(df_start_dates, df_end_dates) - 1, daycount_fractions)",
            "def forward_rates(df_start_dates, df_end_dates, daycount_fractions, dtype=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Computes forward rates from daycount fractions and discount factors.\\n\\n  #### Example\\n  ```python\\n  # Discount factors at start dates\\n  df_start_dates = [[0.95, 0.9, 0.75], [0.95, 0.99, 0.85]]\\n  # Discount factors at end dates\\n  df_end_dates = [[0.8, 0.6, 0.5], [0.8, 0.9, 0.5]]\\n  # Daycount fractions between the dates\\n  daycount_fractions = [[0.5, 1.0, 2], [0.6, 0.4, 4.0]]\\n  # Expected:\\n  #  [[0.375 , 0.5   , 0.25  ],\\n  #   [0.3125, 0.25  , 0.175 ]]\\n  forward_rates(df_start_dates, df_end_dates, daycount_fractions,\\n                dtype=tf.float64)\\n  ```\\n\\n  Args:\\n    df_start_dates: A real `Tensor` representing discount factors at the start\\n      dates.\\n    df_end_dates: A real `Tensor` representing discount factors at the end\\n      dates.\\n    daycount_fractions: A real `Tensor` representing  year fractions for the\\n      coupon accrual.\\n    dtype: `tf.Dtype`. If supplied the dtype for the input and output `Tensor`s.\\n      Default value: None which maps to the default dtype inferred from\\n      `df_start_dates`.\\n    name: Python str. The name to give to the ops created by this function.\\n      Default value: None which maps to 'forward_rates'.\\n\\n  Returns:\\n\\n  \"\n    name = name or 'forward_rates'\n    with tf.name_scope(name):\n        df_start_dates = tf.convert_to_tensor(df_start_dates, dtype, name='df_start_dates')\n        dtype = dtype or df_start_dates.dtype\n        df_end_dates = tf.convert_to_tensor(df_end_dates, dtype, name='df_end_dates')\n        daycount_fractions = tf.convert_to_tensor(daycount_fractions, dtype, name='daycount_fractions')\n        return tf.math.divide_no_nan(tf.math.divide_no_nan(df_start_dates, df_end_dates) - 1, daycount_fractions)",
            "def forward_rates(df_start_dates, df_end_dates, daycount_fractions, dtype=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Computes forward rates from daycount fractions and discount factors.\\n\\n  #### Example\\n  ```python\\n  # Discount factors at start dates\\n  df_start_dates = [[0.95, 0.9, 0.75], [0.95, 0.99, 0.85]]\\n  # Discount factors at end dates\\n  df_end_dates = [[0.8, 0.6, 0.5], [0.8, 0.9, 0.5]]\\n  # Daycount fractions between the dates\\n  daycount_fractions = [[0.5, 1.0, 2], [0.6, 0.4, 4.0]]\\n  # Expected:\\n  #  [[0.375 , 0.5   , 0.25  ],\\n  #   [0.3125, 0.25  , 0.175 ]]\\n  forward_rates(df_start_dates, df_end_dates, daycount_fractions,\\n                dtype=tf.float64)\\n  ```\\n\\n  Args:\\n    df_start_dates: A real `Tensor` representing discount factors at the start\\n      dates.\\n    df_end_dates: A real `Tensor` representing discount factors at the end\\n      dates.\\n    daycount_fractions: A real `Tensor` representing  year fractions for the\\n      coupon accrual.\\n    dtype: `tf.Dtype`. If supplied the dtype for the input and output `Tensor`s.\\n      Default value: None which maps to the default dtype inferred from\\n      `df_start_dates`.\\n    name: Python str. The name to give to the ops created by this function.\\n      Default value: None which maps to 'forward_rates'.\\n\\n  Returns:\\n\\n  \"\n    name = name or 'forward_rates'\n    with tf.name_scope(name):\n        df_start_dates = tf.convert_to_tensor(df_start_dates, dtype, name='df_start_dates')\n        dtype = dtype or df_start_dates.dtype\n        df_end_dates = tf.convert_to_tensor(df_end_dates, dtype, name='df_end_dates')\n        daycount_fractions = tf.convert_to_tensor(daycount_fractions, dtype, name='daycount_fractions')\n        return tf.math.divide_no_nan(tf.math.divide_no_nan(df_start_dates, df_end_dates) - 1, daycount_fractions)"
        ]
    },
    {
        "func_name": "forward_rates_from_yields",
        "original": "def forward_rates_from_yields(yields, times, groups=None, dtype=None, name=None):\n    \"\"\"Computes forward rates given a set of zero rates.\n\n  Denote the price of a zero coupon bond maturing at time `t` by `Z(t)`. Then\n  the zero rate to time `t` is defined as\n\n  ```None\n    r(t) = - ln(Z(t)) / t       (1)\n\n  ```\n\n  This is the (continuously compounded) interest rate that applies between time\n  `0` and time `t` as seen at time `0`. The forward rate between times `t1` and\n  `t2` is defined as the interest rate that applies to the period `[t1, t2]`\n  as seen from today. It is related to the zero coupon bond prices by\n\n  ```None\n    exp(-f(t1, t2)(t2-t1)) = Z(t2) / Z(t1)                 (2)\n    f(t1, t2) = - (ln Z(t2) - ln Z(t1)) / (t2 - t1)        (3)\n    f(t1, t2) = (t2 * r(t2) - t1 * r(t1)) / (t2 - t1)      (4)\n  ```\n\n  Given a sequence of increasing times `[t1, t2, ... tn]` and the zero rates\n  for those times, this function computes the forward rates that apply to the\n  consecutive time intervals i.e. `[0, t1], [t1, t2], ... [t_{n-1}, tn]` using\n  Eq. (4) above. Note that for the interval `[0, t1]` the forward rate is the\n  same as the zero rate.\n\n  Additionally, this function supports this computation for a batch of such\n  rates. Batching is made slightly complicated by the fact that different\n  zero curves may have different numbers of tenors (the parameter `n` above).\n  Instead of a batch as an extra dimension, we support the concept of groups\n  (also see documentation for `tf.segment_sum` which uses the same concept).\n\n  #### Example\n\n  The following example illustrates this method along with the concept of\n  groups. Assuming there are two sets of zero rates (e.g. for different\n  currencies) whose implied forward rates are needed. The first set has a total\n  of three marked tenors at `[0.25, 0.5, 1.0]`. The second set\n  has four marked tenors at `[0.25, 0.5, 1.0, 1.5]`.\n  Suppose, the zero rates for the first set are:\n  `[0.04, 0.041, 0.044]` and the second are `[0.022, 0.025, 0.028, 0.036]`.\n  Then this data is batched together as follows:\n  Groups: [0,    0    0,   1,    1,   1    1  ]\n  First three times for group 0, next four for group 1.\n  Times:  [0.25, 0.5, 1.0, 0.25, 0.5, 1.0, 1.5]\n  First three rates for group 0, next four for group 1.\n  Rates:  [0.04, 0.041, 0.044, 0.022, 0.025, 0.028, 0.036]\n\n\n  ```python\n    dtype = np.float64\n    groups = np.array([0, 0, 0, 1, 1, 1, 1])\n    times = np.array([0.25, 0.5, 1.0, 0.25, 0.5, 1.0, 1.5], dtype=dtype)\n    rates = np.array([0.04, 0.041, 0.044, 0.022, 0.025, 0.028, 0.036],\n                     dtype=dtype)\n    forward_rates = forward_rates_from_yields(\n        rates, times, groups=groups, dtype=dtype)\n  ```\n\n  #### References:\n\n  [1]: John C. Hull. Options, Futures and Other Derivatives. Ninth Edition.\n    June 2006.\n\n  Args:\n    yields: Real rank 1 `Tensor` of size `n`. The discount/zero rates.\n    times: Real positive rank 1 `Tensor` of size `n`. The set of times\n      corresponding to the supplied zero rates. If no `groups` is supplied, then\n      the whole array should be sorted in an increasing order. If `groups` are\n      supplied, then the times within a group should be in an increasing order.\n    groups: Optional int `Tensor` of size `n` containing values between 0 and\n      `k-1` where `k` is the number of different curves.\n      Default value: None. This implies that all the rates are treated as a\n        single group.\n    dtype: `tf.Dtype`. If supplied the dtype for the `yields` and `times`.\n      Default value: None which maps to the default dtype inferred from\n      `yields`.\n    name: Python str. The name to give to the ops created by this function.\n      Default value: None which maps to 'forward_rates_from_yields'.\n\n  Returns:\n    Real rank 1 `Tensor` of size `n` containing the forward rate that applies\n    for each successive time interval (within each group if groups are\n    specified).\n  \"\"\"\n    with tf.compat.v1.name_scope(name, default_name='forward_rates_from_yields', values=[yields, times, groups]):\n        yields = tf.convert_to_tensor(yields, dtype=dtype, name='yields')\n        dtype = dtype or yields.dtype\n        times = tf.convert_to_tensor(times, dtype=dtype, name='times')\n        if groups is not None:\n            groups = tf.convert_to_tensor(groups, name='groups')\n        rate_times = yields * times\n        diff_rate_times = segment_ops.segment_diff(rate_times, order=1, exclusive=False, segment_ids=groups)\n        diff_times = segment_ops.segment_diff(times, order=1, exclusive=False, segment_ids=groups)\n        return diff_rate_times / diff_times",
        "mutated": [
            "def forward_rates_from_yields(yields, times, groups=None, dtype=None, name=None):\n    if False:\n        i = 10\n    \"Computes forward rates given a set of zero rates.\\n\\n  Denote the price of a zero coupon bond maturing at time `t` by `Z(t)`. Then\\n  the zero rate to time `t` is defined as\\n\\n  ```None\\n    r(t) = - ln(Z(t)) / t       (1)\\n\\n  ```\\n\\n  This is the (continuously compounded) interest rate that applies between time\\n  `0` and time `t` as seen at time `0`. The forward rate between times `t1` and\\n  `t2` is defined as the interest rate that applies to the period `[t1, t2]`\\n  as seen from today. It is related to the zero coupon bond prices by\\n\\n  ```None\\n    exp(-f(t1, t2)(t2-t1)) = Z(t2) / Z(t1)                 (2)\\n    f(t1, t2) = - (ln Z(t2) - ln Z(t1)) / (t2 - t1)        (3)\\n    f(t1, t2) = (t2 * r(t2) - t1 * r(t1)) / (t2 - t1)      (4)\\n  ```\\n\\n  Given a sequence of increasing times `[t1, t2, ... tn]` and the zero rates\\n  for those times, this function computes the forward rates that apply to the\\n  consecutive time intervals i.e. `[0, t1], [t1, t2], ... [t_{n-1}, tn]` using\\n  Eq. (4) above. Note that for the interval `[0, t1]` the forward rate is the\\n  same as the zero rate.\\n\\n  Additionally, this function supports this computation for a batch of such\\n  rates. Batching is made slightly complicated by the fact that different\\n  zero curves may have different numbers of tenors (the parameter `n` above).\\n  Instead of a batch as an extra dimension, we support the concept of groups\\n  (also see documentation for `tf.segment_sum` which uses the same concept).\\n\\n  #### Example\\n\\n  The following example illustrates this method along with the concept of\\n  groups. Assuming there are two sets of zero rates (e.g. for different\\n  currencies) whose implied forward rates are needed. The first set has a total\\n  of three marked tenors at `[0.25, 0.5, 1.0]`. The second set\\n  has four marked tenors at `[0.25, 0.5, 1.0, 1.5]`.\\n  Suppose, the zero rates for the first set are:\\n  `[0.04, 0.041, 0.044]` and the second are `[0.022, 0.025, 0.028, 0.036]`.\\n  Then this data is batched together as follows:\\n  Groups: [0,    0    0,   1,    1,   1    1  ]\\n  First three times for group 0, next four for group 1.\\n  Times:  [0.25, 0.5, 1.0, 0.25, 0.5, 1.0, 1.5]\\n  First three rates for group 0, next four for group 1.\\n  Rates:  [0.04, 0.041, 0.044, 0.022, 0.025, 0.028, 0.036]\\n\\n\\n  ```python\\n    dtype = np.float64\\n    groups = np.array([0, 0, 0, 1, 1, 1, 1])\\n    times = np.array([0.25, 0.5, 1.0, 0.25, 0.5, 1.0, 1.5], dtype=dtype)\\n    rates = np.array([0.04, 0.041, 0.044, 0.022, 0.025, 0.028, 0.036],\\n                     dtype=dtype)\\n    forward_rates = forward_rates_from_yields(\\n        rates, times, groups=groups, dtype=dtype)\\n  ```\\n\\n  #### References:\\n\\n  [1]: John C. Hull. Options, Futures and Other Derivatives. Ninth Edition.\\n    June 2006.\\n\\n  Args:\\n    yields: Real rank 1 `Tensor` of size `n`. The discount/zero rates.\\n    times: Real positive rank 1 `Tensor` of size `n`. The set of times\\n      corresponding to the supplied zero rates. If no `groups` is supplied, then\\n      the whole array should be sorted in an increasing order. If `groups` are\\n      supplied, then the times within a group should be in an increasing order.\\n    groups: Optional int `Tensor` of size `n` containing values between 0 and\\n      `k-1` where `k` is the number of different curves.\\n      Default value: None. This implies that all the rates are treated as a\\n        single group.\\n    dtype: `tf.Dtype`. If supplied the dtype for the `yields` and `times`.\\n      Default value: None which maps to the default dtype inferred from\\n      `yields`.\\n    name: Python str. The name to give to the ops created by this function.\\n      Default value: None which maps to 'forward_rates_from_yields'.\\n\\n  Returns:\\n    Real rank 1 `Tensor` of size `n` containing the forward rate that applies\\n    for each successive time interval (within each group if groups are\\n    specified).\\n  \"\n    with tf.compat.v1.name_scope(name, default_name='forward_rates_from_yields', values=[yields, times, groups]):\n        yields = tf.convert_to_tensor(yields, dtype=dtype, name='yields')\n        dtype = dtype or yields.dtype\n        times = tf.convert_to_tensor(times, dtype=dtype, name='times')\n        if groups is not None:\n            groups = tf.convert_to_tensor(groups, name='groups')\n        rate_times = yields * times\n        diff_rate_times = segment_ops.segment_diff(rate_times, order=1, exclusive=False, segment_ids=groups)\n        diff_times = segment_ops.segment_diff(times, order=1, exclusive=False, segment_ids=groups)\n        return diff_rate_times / diff_times",
            "def forward_rates_from_yields(yields, times, groups=None, dtype=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Computes forward rates given a set of zero rates.\\n\\n  Denote the price of a zero coupon bond maturing at time `t` by `Z(t)`. Then\\n  the zero rate to time `t` is defined as\\n\\n  ```None\\n    r(t) = - ln(Z(t)) / t       (1)\\n\\n  ```\\n\\n  This is the (continuously compounded) interest rate that applies between time\\n  `0` and time `t` as seen at time `0`. The forward rate between times `t1` and\\n  `t2` is defined as the interest rate that applies to the period `[t1, t2]`\\n  as seen from today. It is related to the zero coupon bond prices by\\n\\n  ```None\\n    exp(-f(t1, t2)(t2-t1)) = Z(t2) / Z(t1)                 (2)\\n    f(t1, t2) = - (ln Z(t2) - ln Z(t1)) / (t2 - t1)        (3)\\n    f(t1, t2) = (t2 * r(t2) - t1 * r(t1)) / (t2 - t1)      (4)\\n  ```\\n\\n  Given a sequence of increasing times `[t1, t2, ... tn]` and the zero rates\\n  for those times, this function computes the forward rates that apply to the\\n  consecutive time intervals i.e. `[0, t1], [t1, t2], ... [t_{n-1}, tn]` using\\n  Eq. (4) above. Note that for the interval `[0, t1]` the forward rate is the\\n  same as the zero rate.\\n\\n  Additionally, this function supports this computation for a batch of such\\n  rates. Batching is made slightly complicated by the fact that different\\n  zero curves may have different numbers of tenors (the parameter `n` above).\\n  Instead of a batch as an extra dimension, we support the concept of groups\\n  (also see documentation for `tf.segment_sum` which uses the same concept).\\n\\n  #### Example\\n\\n  The following example illustrates this method along with the concept of\\n  groups. Assuming there are two sets of zero rates (e.g. for different\\n  currencies) whose implied forward rates are needed. The first set has a total\\n  of three marked tenors at `[0.25, 0.5, 1.0]`. The second set\\n  has four marked tenors at `[0.25, 0.5, 1.0, 1.5]`.\\n  Suppose, the zero rates for the first set are:\\n  `[0.04, 0.041, 0.044]` and the second are `[0.022, 0.025, 0.028, 0.036]`.\\n  Then this data is batched together as follows:\\n  Groups: [0,    0    0,   1,    1,   1    1  ]\\n  First three times for group 0, next four for group 1.\\n  Times:  [0.25, 0.5, 1.0, 0.25, 0.5, 1.0, 1.5]\\n  First three rates for group 0, next four for group 1.\\n  Rates:  [0.04, 0.041, 0.044, 0.022, 0.025, 0.028, 0.036]\\n\\n\\n  ```python\\n    dtype = np.float64\\n    groups = np.array([0, 0, 0, 1, 1, 1, 1])\\n    times = np.array([0.25, 0.5, 1.0, 0.25, 0.5, 1.0, 1.5], dtype=dtype)\\n    rates = np.array([0.04, 0.041, 0.044, 0.022, 0.025, 0.028, 0.036],\\n                     dtype=dtype)\\n    forward_rates = forward_rates_from_yields(\\n        rates, times, groups=groups, dtype=dtype)\\n  ```\\n\\n  #### References:\\n\\n  [1]: John C. Hull. Options, Futures and Other Derivatives. Ninth Edition.\\n    June 2006.\\n\\n  Args:\\n    yields: Real rank 1 `Tensor` of size `n`. The discount/zero rates.\\n    times: Real positive rank 1 `Tensor` of size `n`. The set of times\\n      corresponding to the supplied zero rates. If no `groups` is supplied, then\\n      the whole array should be sorted in an increasing order. If `groups` are\\n      supplied, then the times within a group should be in an increasing order.\\n    groups: Optional int `Tensor` of size `n` containing values between 0 and\\n      `k-1` where `k` is the number of different curves.\\n      Default value: None. This implies that all the rates are treated as a\\n        single group.\\n    dtype: `tf.Dtype`. If supplied the dtype for the `yields` and `times`.\\n      Default value: None which maps to the default dtype inferred from\\n      `yields`.\\n    name: Python str. The name to give to the ops created by this function.\\n      Default value: None which maps to 'forward_rates_from_yields'.\\n\\n  Returns:\\n    Real rank 1 `Tensor` of size `n` containing the forward rate that applies\\n    for each successive time interval (within each group if groups are\\n    specified).\\n  \"\n    with tf.compat.v1.name_scope(name, default_name='forward_rates_from_yields', values=[yields, times, groups]):\n        yields = tf.convert_to_tensor(yields, dtype=dtype, name='yields')\n        dtype = dtype or yields.dtype\n        times = tf.convert_to_tensor(times, dtype=dtype, name='times')\n        if groups is not None:\n            groups = tf.convert_to_tensor(groups, name='groups')\n        rate_times = yields * times\n        diff_rate_times = segment_ops.segment_diff(rate_times, order=1, exclusive=False, segment_ids=groups)\n        diff_times = segment_ops.segment_diff(times, order=1, exclusive=False, segment_ids=groups)\n        return diff_rate_times / diff_times",
            "def forward_rates_from_yields(yields, times, groups=None, dtype=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Computes forward rates given a set of zero rates.\\n\\n  Denote the price of a zero coupon bond maturing at time `t` by `Z(t)`. Then\\n  the zero rate to time `t` is defined as\\n\\n  ```None\\n    r(t) = - ln(Z(t)) / t       (1)\\n\\n  ```\\n\\n  This is the (continuously compounded) interest rate that applies between time\\n  `0` and time `t` as seen at time `0`. The forward rate between times `t1` and\\n  `t2` is defined as the interest rate that applies to the period `[t1, t2]`\\n  as seen from today. It is related to the zero coupon bond prices by\\n\\n  ```None\\n    exp(-f(t1, t2)(t2-t1)) = Z(t2) / Z(t1)                 (2)\\n    f(t1, t2) = - (ln Z(t2) - ln Z(t1)) / (t2 - t1)        (3)\\n    f(t1, t2) = (t2 * r(t2) - t1 * r(t1)) / (t2 - t1)      (4)\\n  ```\\n\\n  Given a sequence of increasing times `[t1, t2, ... tn]` and the zero rates\\n  for those times, this function computes the forward rates that apply to the\\n  consecutive time intervals i.e. `[0, t1], [t1, t2], ... [t_{n-1}, tn]` using\\n  Eq. (4) above. Note that for the interval `[0, t1]` the forward rate is the\\n  same as the zero rate.\\n\\n  Additionally, this function supports this computation for a batch of such\\n  rates. Batching is made slightly complicated by the fact that different\\n  zero curves may have different numbers of tenors (the parameter `n` above).\\n  Instead of a batch as an extra dimension, we support the concept of groups\\n  (also see documentation for `tf.segment_sum` which uses the same concept).\\n\\n  #### Example\\n\\n  The following example illustrates this method along with the concept of\\n  groups. Assuming there are two sets of zero rates (e.g. for different\\n  currencies) whose implied forward rates are needed. The first set has a total\\n  of three marked tenors at `[0.25, 0.5, 1.0]`. The second set\\n  has four marked tenors at `[0.25, 0.5, 1.0, 1.5]`.\\n  Suppose, the zero rates for the first set are:\\n  `[0.04, 0.041, 0.044]` and the second are `[0.022, 0.025, 0.028, 0.036]`.\\n  Then this data is batched together as follows:\\n  Groups: [0,    0    0,   1,    1,   1    1  ]\\n  First three times for group 0, next four for group 1.\\n  Times:  [0.25, 0.5, 1.0, 0.25, 0.5, 1.0, 1.5]\\n  First three rates for group 0, next four for group 1.\\n  Rates:  [0.04, 0.041, 0.044, 0.022, 0.025, 0.028, 0.036]\\n\\n\\n  ```python\\n    dtype = np.float64\\n    groups = np.array([0, 0, 0, 1, 1, 1, 1])\\n    times = np.array([0.25, 0.5, 1.0, 0.25, 0.5, 1.0, 1.5], dtype=dtype)\\n    rates = np.array([0.04, 0.041, 0.044, 0.022, 0.025, 0.028, 0.036],\\n                     dtype=dtype)\\n    forward_rates = forward_rates_from_yields(\\n        rates, times, groups=groups, dtype=dtype)\\n  ```\\n\\n  #### References:\\n\\n  [1]: John C. Hull. Options, Futures and Other Derivatives. Ninth Edition.\\n    June 2006.\\n\\n  Args:\\n    yields: Real rank 1 `Tensor` of size `n`. The discount/zero rates.\\n    times: Real positive rank 1 `Tensor` of size `n`. The set of times\\n      corresponding to the supplied zero rates. If no `groups` is supplied, then\\n      the whole array should be sorted in an increasing order. If `groups` are\\n      supplied, then the times within a group should be in an increasing order.\\n    groups: Optional int `Tensor` of size `n` containing values between 0 and\\n      `k-1` where `k` is the number of different curves.\\n      Default value: None. This implies that all the rates are treated as a\\n        single group.\\n    dtype: `tf.Dtype`. If supplied the dtype for the `yields` and `times`.\\n      Default value: None which maps to the default dtype inferred from\\n      `yields`.\\n    name: Python str. The name to give to the ops created by this function.\\n      Default value: None which maps to 'forward_rates_from_yields'.\\n\\n  Returns:\\n    Real rank 1 `Tensor` of size `n` containing the forward rate that applies\\n    for each successive time interval (within each group if groups are\\n    specified).\\n  \"\n    with tf.compat.v1.name_scope(name, default_name='forward_rates_from_yields', values=[yields, times, groups]):\n        yields = tf.convert_to_tensor(yields, dtype=dtype, name='yields')\n        dtype = dtype or yields.dtype\n        times = tf.convert_to_tensor(times, dtype=dtype, name='times')\n        if groups is not None:\n            groups = tf.convert_to_tensor(groups, name='groups')\n        rate_times = yields * times\n        diff_rate_times = segment_ops.segment_diff(rate_times, order=1, exclusive=False, segment_ids=groups)\n        diff_times = segment_ops.segment_diff(times, order=1, exclusive=False, segment_ids=groups)\n        return diff_rate_times / diff_times",
            "def forward_rates_from_yields(yields, times, groups=None, dtype=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Computes forward rates given a set of zero rates.\\n\\n  Denote the price of a zero coupon bond maturing at time `t` by `Z(t)`. Then\\n  the zero rate to time `t` is defined as\\n\\n  ```None\\n    r(t) = - ln(Z(t)) / t       (1)\\n\\n  ```\\n\\n  This is the (continuously compounded) interest rate that applies between time\\n  `0` and time `t` as seen at time `0`. The forward rate between times `t1` and\\n  `t2` is defined as the interest rate that applies to the period `[t1, t2]`\\n  as seen from today. It is related to the zero coupon bond prices by\\n\\n  ```None\\n    exp(-f(t1, t2)(t2-t1)) = Z(t2) / Z(t1)                 (2)\\n    f(t1, t2) = - (ln Z(t2) - ln Z(t1)) / (t2 - t1)        (3)\\n    f(t1, t2) = (t2 * r(t2) - t1 * r(t1)) / (t2 - t1)      (4)\\n  ```\\n\\n  Given a sequence of increasing times `[t1, t2, ... tn]` and the zero rates\\n  for those times, this function computes the forward rates that apply to the\\n  consecutive time intervals i.e. `[0, t1], [t1, t2], ... [t_{n-1}, tn]` using\\n  Eq. (4) above. Note that for the interval `[0, t1]` the forward rate is the\\n  same as the zero rate.\\n\\n  Additionally, this function supports this computation for a batch of such\\n  rates. Batching is made slightly complicated by the fact that different\\n  zero curves may have different numbers of tenors (the parameter `n` above).\\n  Instead of a batch as an extra dimension, we support the concept of groups\\n  (also see documentation for `tf.segment_sum` which uses the same concept).\\n\\n  #### Example\\n\\n  The following example illustrates this method along with the concept of\\n  groups. Assuming there are two sets of zero rates (e.g. for different\\n  currencies) whose implied forward rates are needed. The first set has a total\\n  of three marked tenors at `[0.25, 0.5, 1.0]`. The second set\\n  has four marked tenors at `[0.25, 0.5, 1.0, 1.5]`.\\n  Suppose, the zero rates for the first set are:\\n  `[0.04, 0.041, 0.044]` and the second are `[0.022, 0.025, 0.028, 0.036]`.\\n  Then this data is batched together as follows:\\n  Groups: [0,    0    0,   1,    1,   1    1  ]\\n  First three times for group 0, next four for group 1.\\n  Times:  [0.25, 0.5, 1.0, 0.25, 0.5, 1.0, 1.5]\\n  First three rates for group 0, next four for group 1.\\n  Rates:  [0.04, 0.041, 0.044, 0.022, 0.025, 0.028, 0.036]\\n\\n\\n  ```python\\n    dtype = np.float64\\n    groups = np.array([0, 0, 0, 1, 1, 1, 1])\\n    times = np.array([0.25, 0.5, 1.0, 0.25, 0.5, 1.0, 1.5], dtype=dtype)\\n    rates = np.array([0.04, 0.041, 0.044, 0.022, 0.025, 0.028, 0.036],\\n                     dtype=dtype)\\n    forward_rates = forward_rates_from_yields(\\n        rates, times, groups=groups, dtype=dtype)\\n  ```\\n\\n  #### References:\\n\\n  [1]: John C. Hull. Options, Futures and Other Derivatives. Ninth Edition.\\n    June 2006.\\n\\n  Args:\\n    yields: Real rank 1 `Tensor` of size `n`. The discount/zero rates.\\n    times: Real positive rank 1 `Tensor` of size `n`. The set of times\\n      corresponding to the supplied zero rates. If no `groups` is supplied, then\\n      the whole array should be sorted in an increasing order. If `groups` are\\n      supplied, then the times within a group should be in an increasing order.\\n    groups: Optional int `Tensor` of size `n` containing values between 0 and\\n      `k-1` where `k` is the number of different curves.\\n      Default value: None. This implies that all the rates are treated as a\\n        single group.\\n    dtype: `tf.Dtype`. If supplied the dtype for the `yields` and `times`.\\n      Default value: None which maps to the default dtype inferred from\\n      `yields`.\\n    name: Python str. The name to give to the ops created by this function.\\n      Default value: None which maps to 'forward_rates_from_yields'.\\n\\n  Returns:\\n    Real rank 1 `Tensor` of size `n` containing the forward rate that applies\\n    for each successive time interval (within each group if groups are\\n    specified).\\n  \"\n    with tf.compat.v1.name_scope(name, default_name='forward_rates_from_yields', values=[yields, times, groups]):\n        yields = tf.convert_to_tensor(yields, dtype=dtype, name='yields')\n        dtype = dtype or yields.dtype\n        times = tf.convert_to_tensor(times, dtype=dtype, name='times')\n        if groups is not None:\n            groups = tf.convert_to_tensor(groups, name='groups')\n        rate_times = yields * times\n        diff_rate_times = segment_ops.segment_diff(rate_times, order=1, exclusive=False, segment_ids=groups)\n        diff_times = segment_ops.segment_diff(times, order=1, exclusive=False, segment_ids=groups)\n        return diff_rate_times / diff_times",
            "def forward_rates_from_yields(yields, times, groups=None, dtype=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Computes forward rates given a set of zero rates.\\n\\n  Denote the price of a zero coupon bond maturing at time `t` by `Z(t)`. Then\\n  the zero rate to time `t` is defined as\\n\\n  ```None\\n    r(t) = - ln(Z(t)) / t       (1)\\n\\n  ```\\n\\n  This is the (continuously compounded) interest rate that applies between time\\n  `0` and time `t` as seen at time `0`. The forward rate between times `t1` and\\n  `t2` is defined as the interest rate that applies to the period `[t1, t2]`\\n  as seen from today. It is related to the zero coupon bond prices by\\n\\n  ```None\\n    exp(-f(t1, t2)(t2-t1)) = Z(t2) / Z(t1)                 (2)\\n    f(t1, t2) = - (ln Z(t2) - ln Z(t1)) / (t2 - t1)        (3)\\n    f(t1, t2) = (t2 * r(t2) - t1 * r(t1)) / (t2 - t1)      (4)\\n  ```\\n\\n  Given a sequence of increasing times `[t1, t2, ... tn]` and the zero rates\\n  for those times, this function computes the forward rates that apply to the\\n  consecutive time intervals i.e. `[0, t1], [t1, t2], ... [t_{n-1}, tn]` using\\n  Eq. (4) above. Note that for the interval `[0, t1]` the forward rate is the\\n  same as the zero rate.\\n\\n  Additionally, this function supports this computation for a batch of such\\n  rates. Batching is made slightly complicated by the fact that different\\n  zero curves may have different numbers of tenors (the parameter `n` above).\\n  Instead of a batch as an extra dimension, we support the concept of groups\\n  (also see documentation for `tf.segment_sum` which uses the same concept).\\n\\n  #### Example\\n\\n  The following example illustrates this method along with the concept of\\n  groups. Assuming there are two sets of zero rates (e.g. for different\\n  currencies) whose implied forward rates are needed. The first set has a total\\n  of three marked tenors at `[0.25, 0.5, 1.0]`. The second set\\n  has four marked tenors at `[0.25, 0.5, 1.0, 1.5]`.\\n  Suppose, the zero rates for the first set are:\\n  `[0.04, 0.041, 0.044]` and the second are `[0.022, 0.025, 0.028, 0.036]`.\\n  Then this data is batched together as follows:\\n  Groups: [0,    0    0,   1,    1,   1    1  ]\\n  First three times for group 0, next four for group 1.\\n  Times:  [0.25, 0.5, 1.0, 0.25, 0.5, 1.0, 1.5]\\n  First three rates for group 0, next four for group 1.\\n  Rates:  [0.04, 0.041, 0.044, 0.022, 0.025, 0.028, 0.036]\\n\\n\\n  ```python\\n    dtype = np.float64\\n    groups = np.array([0, 0, 0, 1, 1, 1, 1])\\n    times = np.array([0.25, 0.5, 1.0, 0.25, 0.5, 1.0, 1.5], dtype=dtype)\\n    rates = np.array([0.04, 0.041, 0.044, 0.022, 0.025, 0.028, 0.036],\\n                     dtype=dtype)\\n    forward_rates = forward_rates_from_yields(\\n        rates, times, groups=groups, dtype=dtype)\\n  ```\\n\\n  #### References:\\n\\n  [1]: John C. Hull. Options, Futures and Other Derivatives. Ninth Edition.\\n    June 2006.\\n\\n  Args:\\n    yields: Real rank 1 `Tensor` of size `n`. The discount/zero rates.\\n    times: Real positive rank 1 `Tensor` of size `n`. The set of times\\n      corresponding to the supplied zero rates. If no `groups` is supplied, then\\n      the whole array should be sorted in an increasing order. If `groups` are\\n      supplied, then the times within a group should be in an increasing order.\\n    groups: Optional int `Tensor` of size `n` containing values between 0 and\\n      `k-1` where `k` is the number of different curves.\\n      Default value: None. This implies that all the rates are treated as a\\n        single group.\\n    dtype: `tf.Dtype`. If supplied the dtype for the `yields` and `times`.\\n      Default value: None which maps to the default dtype inferred from\\n      `yields`.\\n    name: Python str. The name to give to the ops created by this function.\\n      Default value: None which maps to 'forward_rates_from_yields'.\\n\\n  Returns:\\n    Real rank 1 `Tensor` of size `n` containing the forward rate that applies\\n    for each successive time interval (within each group if groups are\\n    specified).\\n  \"\n    with tf.compat.v1.name_scope(name, default_name='forward_rates_from_yields', values=[yields, times, groups]):\n        yields = tf.convert_to_tensor(yields, dtype=dtype, name='yields')\n        dtype = dtype or yields.dtype\n        times = tf.convert_to_tensor(times, dtype=dtype, name='times')\n        if groups is not None:\n            groups = tf.convert_to_tensor(groups, name='groups')\n        rate_times = yields * times\n        diff_rate_times = segment_ops.segment_diff(rate_times, order=1, exclusive=False, segment_ids=groups)\n        diff_times = segment_ops.segment_diff(times, order=1, exclusive=False, segment_ids=groups)\n        return diff_rate_times / diff_times"
        ]
    },
    {
        "func_name": "yields_from_forward_rates",
        "original": "def yields_from_forward_rates(discrete_forwards, times, groups=None, dtype=None, name=None):\n    \"\"\"Computes yield rates from discrete forward rates.\n\n  Denote the price of a zero coupon bond maturing at time `t` by `Z(t)`. Then\n  the zero rate to time `t` is defined as\n\n  ```None\n    r(t) = - ln(Z(t)) / t       (1)\n\n  ```\n\n  This is the (continuously compounded) interest rate that applies between time\n  `0` and time `t` as seen at time `0`. The forward rate between times `t1` and\n  `t2` is defined as the interest rate that applies to the period `[t1, t2]`\n  as seen from today. It is related to the zero coupon bond prices by\n\n  ```None\n    exp(-f(t1, t2)(t2-t1)) = Z(t2) / Z(t1)                 (2)\n    f(t1, t2) = - (ln Z(t2) - ln Z(t1)) / (t2 - t1)        (3)\n    f(t1, t2) = (t2 * r(t2) - t1 * r(t1)) / (t2 - t1)      (4)\n  ```\n\n  Given a sequence of increasing times `[t1, t2, ... tn]` and the forward rates\n  for the consecutive time intervals, i.e. `[0, t1]`, `[t1, t2]` to\n  `[t_{n-1}, tn]`, this function computes the yields to maturity for maturities\n  `[t1, t2, ... tn]` using Eq. (4) above.\n\n  Additionally, this function supports this computation for a batch of such\n  forward rates. Batching is made slightly complicated by the fact that\n  different zero curves may have different numbers of tenors (the parameter `n`\n  above). Instead of a batch as an extra dimension, we support the concept of\n  groups (also see documentation for `tf.segment_sum` which uses the same\n  concept).\n\n  #### Example\n\n  The following example illustrates this method along with the concept of\n  groups. Assuming there are two sets of zero rates (e.g. for different\n  currencies) whose implied forward rates are needed. The first set has a total\n  of three marked tenors at `[0.25, 0.5, 1.0]`. The second set\n  has four marked tenors at `[0.25, 0.5, 1.0, 1.5]`.\n  Suppose, the forward rates for the first set are:\n  `[0.04, 0.041, 0.044]` and the second are `[0.022, 0.025, 0.028, 0.036]`.\n  Then this data is batched together as follows:\n  Groups:   [0,    0    0,   1,    1,   1    1  ]\n  First three times for group 0, next four for group 1.\n  Times:    [0.25, 0.5, 1.0, 0.25, 0.5, 1.0, 1.5]\n  First three discrete forwards for group 0, next four for group 1.\n  Forwards: [0.04, 0.042, 0.047, 0.022, 0.028, 0.031, 0.052]\n\n  ```python\n    dtype = np.float64\n    groups = np.array([0, 0, 0, 1, 1, 1, 1])\n    times = np.array([0.25, 0.5, 1.0, 0.25, 0.5, 1.0, 1.5], dtype=dtype)\n    discrete_forwards = np.array(\n        [0.04, 0.042, 0.047, 0.022, 0.028, 0.031, 0.052], dtype=dtype)\n    yields = yields_from_forward_rates(discrete_forwards, times,\n                                       groups=groups, dtype=dtype)\n    # Produces: [0.04, 0.041, 0.044, 0.022, 0.025, 0.028, 0.036]\n  ```\n\n  #### References:\n\n  [1]: John C. Hull. Options, Futures and Other Derivatives. Ninth Edition.\n    June 2006.\n\n  Args:\n    discrete_forwards: Real rank 1 `Tensor` of size `n`. The forward rates for\n      the time periods specified. Note that the first value applies between `0`\n      and time `times[0]`.\n    times: Real positive rank 1 `Tensor` of size `n`. The set of times\n      corresponding to the supplied zero rates. If no `groups` is supplied, then\n      the whole array should be sorted in an increasing order. If `groups` are\n      supplied, then the times within a group should be in an increasing order.\n    groups: Optional int `Tensor` of size `n` containing values between 0 and\n      `k-1` where `k` is the number of different curves.\n      Default value: None. This implies that all the rates are treated as a\n        single group.\n    dtype: `tf.Dtype`. If supplied the dtype for the `discrete_forwards` and\n      `times`.\n      Default value: None which maps to the default dtype inferred from\n      `discrete_forwards`.\n    name: Python str. The name to give to the ops created by this function.\n      Default value: None which maps to 'yields_from_forward_rates'.\n\n  Returns:\n    yields: Real rank 1 `Tensor` of size `n` containing the zero coupon yields\n    that for the supplied maturities (within each group if groups are\n    specified).\n  \"\"\"\n    with tf.compat.v1.name_scope(name, default_name='yields_from_forward_rates', values=[discrete_forwards, times, groups]):\n        discrete_forwards = tf.convert_to_tensor(discrete_forwards, dtype=dtype, name='discrete_forwards')\n        dtype = dtype or discrete_forwards.dtype\n        times = tf.convert_to_tensor(times, dtype=dtype, name='times')\n        if groups is not None:\n            groups = tf.convert_to_tensor(groups, name='groups')\n        intervals = segment_ops.segment_diff(times, order=1, exclusive=False, segment_ids=groups)\n        x = intervals * discrete_forwards\n        y = segment_ops.segment_cumsum(x, exclusive=False, segment_ids=groups)\n        return tf.math.divide_no_nan(y, times)",
        "mutated": [
            "def yields_from_forward_rates(discrete_forwards, times, groups=None, dtype=None, name=None):\n    if False:\n        i = 10\n    \"Computes yield rates from discrete forward rates.\\n\\n  Denote the price of a zero coupon bond maturing at time `t` by `Z(t)`. Then\\n  the zero rate to time `t` is defined as\\n\\n  ```None\\n    r(t) = - ln(Z(t)) / t       (1)\\n\\n  ```\\n\\n  This is the (continuously compounded) interest rate that applies between time\\n  `0` and time `t` as seen at time `0`. The forward rate between times `t1` and\\n  `t2` is defined as the interest rate that applies to the period `[t1, t2]`\\n  as seen from today. It is related to the zero coupon bond prices by\\n\\n  ```None\\n    exp(-f(t1, t2)(t2-t1)) = Z(t2) / Z(t1)                 (2)\\n    f(t1, t2) = - (ln Z(t2) - ln Z(t1)) / (t2 - t1)        (3)\\n    f(t1, t2) = (t2 * r(t2) - t1 * r(t1)) / (t2 - t1)      (4)\\n  ```\\n\\n  Given a sequence of increasing times `[t1, t2, ... tn]` and the forward rates\\n  for the consecutive time intervals, i.e. `[0, t1]`, `[t1, t2]` to\\n  `[t_{n-1}, tn]`, this function computes the yields to maturity for maturities\\n  `[t1, t2, ... tn]` using Eq. (4) above.\\n\\n  Additionally, this function supports this computation for a batch of such\\n  forward rates. Batching is made slightly complicated by the fact that\\n  different zero curves may have different numbers of tenors (the parameter `n`\\n  above). Instead of a batch as an extra dimension, we support the concept of\\n  groups (also see documentation for `tf.segment_sum` which uses the same\\n  concept).\\n\\n  #### Example\\n\\n  The following example illustrates this method along with the concept of\\n  groups. Assuming there are two sets of zero rates (e.g. for different\\n  currencies) whose implied forward rates are needed. The first set has a total\\n  of three marked tenors at `[0.25, 0.5, 1.0]`. The second set\\n  has four marked tenors at `[0.25, 0.5, 1.0, 1.5]`.\\n  Suppose, the forward rates for the first set are:\\n  `[0.04, 0.041, 0.044]` and the second are `[0.022, 0.025, 0.028, 0.036]`.\\n  Then this data is batched together as follows:\\n  Groups:   [0,    0    0,   1,    1,   1    1  ]\\n  First three times for group 0, next four for group 1.\\n  Times:    [0.25, 0.5, 1.0, 0.25, 0.5, 1.0, 1.5]\\n  First three discrete forwards for group 0, next four for group 1.\\n  Forwards: [0.04, 0.042, 0.047, 0.022, 0.028, 0.031, 0.052]\\n\\n  ```python\\n    dtype = np.float64\\n    groups = np.array([0, 0, 0, 1, 1, 1, 1])\\n    times = np.array([0.25, 0.5, 1.0, 0.25, 0.5, 1.0, 1.5], dtype=dtype)\\n    discrete_forwards = np.array(\\n        [0.04, 0.042, 0.047, 0.022, 0.028, 0.031, 0.052], dtype=dtype)\\n    yields = yields_from_forward_rates(discrete_forwards, times,\\n                                       groups=groups, dtype=dtype)\\n    # Produces: [0.04, 0.041, 0.044, 0.022, 0.025, 0.028, 0.036]\\n  ```\\n\\n  #### References:\\n\\n  [1]: John C. Hull. Options, Futures and Other Derivatives. Ninth Edition.\\n    June 2006.\\n\\n  Args:\\n    discrete_forwards: Real rank 1 `Tensor` of size `n`. The forward rates for\\n      the time periods specified. Note that the first value applies between `0`\\n      and time `times[0]`.\\n    times: Real positive rank 1 `Tensor` of size `n`. The set of times\\n      corresponding to the supplied zero rates. If no `groups` is supplied, then\\n      the whole array should be sorted in an increasing order. If `groups` are\\n      supplied, then the times within a group should be in an increasing order.\\n    groups: Optional int `Tensor` of size `n` containing values between 0 and\\n      `k-1` where `k` is the number of different curves.\\n      Default value: None. This implies that all the rates are treated as a\\n        single group.\\n    dtype: `tf.Dtype`. If supplied the dtype for the `discrete_forwards` and\\n      `times`.\\n      Default value: None which maps to the default dtype inferred from\\n      `discrete_forwards`.\\n    name: Python str. The name to give to the ops created by this function.\\n      Default value: None which maps to 'yields_from_forward_rates'.\\n\\n  Returns:\\n    yields: Real rank 1 `Tensor` of size `n` containing the zero coupon yields\\n    that for the supplied maturities (within each group if groups are\\n    specified).\\n  \"\n    with tf.compat.v1.name_scope(name, default_name='yields_from_forward_rates', values=[discrete_forwards, times, groups]):\n        discrete_forwards = tf.convert_to_tensor(discrete_forwards, dtype=dtype, name='discrete_forwards')\n        dtype = dtype or discrete_forwards.dtype\n        times = tf.convert_to_tensor(times, dtype=dtype, name='times')\n        if groups is not None:\n            groups = tf.convert_to_tensor(groups, name='groups')\n        intervals = segment_ops.segment_diff(times, order=1, exclusive=False, segment_ids=groups)\n        x = intervals * discrete_forwards\n        y = segment_ops.segment_cumsum(x, exclusive=False, segment_ids=groups)\n        return tf.math.divide_no_nan(y, times)",
            "def yields_from_forward_rates(discrete_forwards, times, groups=None, dtype=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Computes yield rates from discrete forward rates.\\n\\n  Denote the price of a zero coupon bond maturing at time `t` by `Z(t)`. Then\\n  the zero rate to time `t` is defined as\\n\\n  ```None\\n    r(t) = - ln(Z(t)) / t       (1)\\n\\n  ```\\n\\n  This is the (continuously compounded) interest rate that applies between time\\n  `0` and time `t` as seen at time `0`. The forward rate between times `t1` and\\n  `t2` is defined as the interest rate that applies to the period `[t1, t2]`\\n  as seen from today. It is related to the zero coupon bond prices by\\n\\n  ```None\\n    exp(-f(t1, t2)(t2-t1)) = Z(t2) / Z(t1)                 (2)\\n    f(t1, t2) = - (ln Z(t2) - ln Z(t1)) / (t2 - t1)        (3)\\n    f(t1, t2) = (t2 * r(t2) - t1 * r(t1)) / (t2 - t1)      (4)\\n  ```\\n\\n  Given a sequence of increasing times `[t1, t2, ... tn]` and the forward rates\\n  for the consecutive time intervals, i.e. `[0, t1]`, `[t1, t2]` to\\n  `[t_{n-1}, tn]`, this function computes the yields to maturity for maturities\\n  `[t1, t2, ... tn]` using Eq. (4) above.\\n\\n  Additionally, this function supports this computation for a batch of such\\n  forward rates. Batching is made slightly complicated by the fact that\\n  different zero curves may have different numbers of tenors (the parameter `n`\\n  above). Instead of a batch as an extra dimension, we support the concept of\\n  groups (also see documentation for `tf.segment_sum` which uses the same\\n  concept).\\n\\n  #### Example\\n\\n  The following example illustrates this method along with the concept of\\n  groups. Assuming there are two sets of zero rates (e.g. for different\\n  currencies) whose implied forward rates are needed. The first set has a total\\n  of three marked tenors at `[0.25, 0.5, 1.0]`. The second set\\n  has four marked tenors at `[0.25, 0.5, 1.0, 1.5]`.\\n  Suppose, the forward rates for the first set are:\\n  `[0.04, 0.041, 0.044]` and the second are `[0.022, 0.025, 0.028, 0.036]`.\\n  Then this data is batched together as follows:\\n  Groups:   [0,    0    0,   1,    1,   1    1  ]\\n  First three times for group 0, next four for group 1.\\n  Times:    [0.25, 0.5, 1.0, 0.25, 0.5, 1.0, 1.5]\\n  First three discrete forwards for group 0, next four for group 1.\\n  Forwards: [0.04, 0.042, 0.047, 0.022, 0.028, 0.031, 0.052]\\n\\n  ```python\\n    dtype = np.float64\\n    groups = np.array([0, 0, 0, 1, 1, 1, 1])\\n    times = np.array([0.25, 0.5, 1.0, 0.25, 0.5, 1.0, 1.5], dtype=dtype)\\n    discrete_forwards = np.array(\\n        [0.04, 0.042, 0.047, 0.022, 0.028, 0.031, 0.052], dtype=dtype)\\n    yields = yields_from_forward_rates(discrete_forwards, times,\\n                                       groups=groups, dtype=dtype)\\n    # Produces: [0.04, 0.041, 0.044, 0.022, 0.025, 0.028, 0.036]\\n  ```\\n\\n  #### References:\\n\\n  [1]: John C. Hull. Options, Futures and Other Derivatives. Ninth Edition.\\n    June 2006.\\n\\n  Args:\\n    discrete_forwards: Real rank 1 `Tensor` of size `n`. The forward rates for\\n      the time periods specified. Note that the first value applies between `0`\\n      and time `times[0]`.\\n    times: Real positive rank 1 `Tensor` of size `n`. The set of times\\n      corresponding to the supplied zero rates. If no `groups` is supplied, then\\n      the whole array should be sorted in an increasing order. If `groups` are\\n      supplied, then the times within a group should be in an increasing order.\\n    groups: Optional int `Tensor` of size `n` containing values between 0 and\\n      `k-1` where `k` is the number of different curves.\\n      Default value: None. This implies that all the rates are treated as a\\n        single group.\\n    dtype: `tf.Dtype`. If supplied the dtype for the `discrete_forwards` and\\n      `times`.\\n      Default value: None which maps to the default dtype inferred from\\n      `discrete_forwards`.\\n    name: Python str. The name to give to the ops created by this function.\\n      Default value: None which maps to 'yields_from_forward_rates'.\\n\\n  Returns:\\n    yields: Real rank 1 `Tensor` of size `n` containing the zero coupon yields\\n    that for the supplied maturities (within each group if groups are\\n    specified).\\n  \"\n    with tf.compat.v1.name_scope(name, default_name='yields_from_forward_rates', values=[discrete_forwards, times, groups]):\n        discrete_forwards = tf.convert_to_tensor(discrete_forwards, dtype=dtype, name='discrete_forwards')\n        dtype = dtype or discrete_forwards.dtype\n        times = tf.convert_to_tensor(times, dtype=dtype, name='times')\n        if groups is not None:\n            groups = tf.convert_to_tensor(groups, name='groups')\n        intervals = segment_ops.segment_diff(times, order=1, exclusive=False, segment_ids=groups)\n        x = intervals * discrete_forwards\n        y = segment_ops.segment_cumsum(x, exclusive=False, segment_ids=groups)\n        return tf.math.divide_no_nan(y, times)",
            "def yields_from_forward_rates(discrete_forwards, times, groups=None, dtype=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Computes yield rates from discrete forward rates.\\n\\n  Denote the price of a zero coupon bond maturing at time `t` by `Z(t)`. Then\\n  the zero rate to time `t` is defined as\\n\\n  ```None\\n    r(t) = - ln(Z(t)) / t       (1)\\n\\n  ```\\n\\n  This is the (continuously compounded) interest rate that applies between time\\n  `0` and time `t` as seen at time `0`. The forward rate between times `t1` and\\n  `t2` is defined as the interest rate that applies to the period `[t1, t2]`\\n  as seen from today. It is related to the zero coupon bond prices by\\n\\n  ```None\\n    exp(-f(t1, t2)(t2-t1)) = Z(t2) / Z(t1)                 (2)\\n    f(t1, t2) = - (ln Z(t2) - ln Z(t1)) / (t2 - t1)        (3)\\n    f(t1, t2) = (t2 * r(t2) - t1 * r(t1)) / (t2 - t1)      (4)\\n  ```\\n\\n  Given a sequence of increasing times `[t1, t2, ... tn]` and the forward rates\\n  for the consecutive time intervals, i.e. `[0, t1]`, `[t1, t2]` to\\n  `[t_{n-1}, tn]`, this function computes the yields to maturity for maturities\\n  `[t1, t2, ... tn]` using Eq. (4) above.\\n\\n  Additionally, this function supports this computation for a batch of such\\n  forward rates. Batching is made slightly complicated by the fact that\\n  different zero curves may have different numbers of tenors (the parameter `n`\\n  above). Instead of a batch as an extra dimension, we support the concept of\\n  groups (also see documentation for `tf.segment_sum` which uses the same\\n  concept).\\n\\n  #### Example\\n\\n  The following example illustrates this method along with the concept of\\n  groups. Assuming there are two sets of zero rates (e.g. for different\\n  currencies) whose implied forward rates are needed. The first set has a total\\n  of three marked tenors at `[0.25, 0.5, 1.0]`. The second set\\n  has four marked tenors at `[0.25, 0.5, 1.0, 1.5]`.\\n  Suppose, the forward rates for the first set are:\\n  `[0.04, 0.041, 0.044]` and the second are `[0.022, 0.025, 0.028, 0.036]`.\\n  Then this data is batched together as follows:\\n  Groups:   [0,    0    0,   1,    1,   1    1  ]\\n  First three times for group 0, next four for group 1.\\n  Times:    [0.25, 0.5, 1.0, 0.25, 0.5, 1.0, 1.5]\\n  First three discrete forwards for group 0, next four for group 1.\\n  Forwards: [0.04, 0.042, 0.047, 0.022, 0.028, 0.031, 0.052]\\n\\n  ```python\\n    dtype = np.float64\\n    groups = np.array([0, 0, 0, 1, 1, 1, 1])\\n    times = np.array([0.25, 0.5, 1.0, 0.25, 0.5, 1.0, 1.5], dtype=dtype)\\n    discrete_forwards = np.array(\\n        [0.04, 0.042, 0.047, 0.022, 0.028, 0.031, 0.052], dtype=dtype)\\n    yields = yields_from_forward_rates(discrete_forwards, times,\\n                                       groups=groups, dtype=dtype)\\n    # Produces: [0.04, 0.041, 0.044, 0.022, 0.025, 0.028, 0.036]\\n  ```\\n\\n  #### References:\\n\\n  [1]: John C. Hull. Options, Futures and Other Derivatives. Ninth Edition.\\n    June 2006.\\n\\n  Args:\\n    discrete_forwards: Real rank 1 `Tensor` of size `n`. The forward rates for\\n      the time periods specified. Note that the first value applies between `0`\\n      and time `times[0]`.\\n    times: Real positive rank 1 `Tensor` of size `n`. The set of times\\n      corresponding to the supplied zero rates. If no `groups` is supplied, then\\n      the whole array should be sorted in an increasing order. If `groups` are\\n      supplied, then the times within a group should be in an increasing order.\\n    groups: Optional int `Tensor` of size `n` containing values between 0 and\\n      `k-1` where `k` is the number of different curves.\\n      Default value: None. This implies that all the rates are treated as a\\n        single group.\\n    dtype: `tf.Dtype`. If supplied the dtype for the `discrete_forwards` and\\n      `times`.\\n      Default value: None which maps to the default dtype inferred from\\n      `discrete_forwards`.\\n    name: Python str. The name to give to the ops created by this function.\\n      Default value: None which maps to 'yields_from_forward_rates'.\\n\\n  Returns:\\n    yields: Real rank 1 `Tensor` of size `n` containing the zero coupon yields\\n    that for the supplied maturities (within each group if groups are\\n    specified).\\n  \"\n    with tf.compat.v1.name_scope(name, default_name='yields_from_forward_rates', values=[discrete_forwards, times, groups]):\n        discrete_forwards = tf.convert_to_tensor(discrete_forwards, dtype=dtype, name='discrete_forwards')\n        dtype = dtype or discrete_forwards.dtype\n        times = tf.convert_to_tensor(times, dtype=dtype, name='times')\n        if groups is not None:\n            groups = tf.convert_to_tensor(groups, name='groups')\n        intervals = segment_ops.segment_diff(times, order=1, exclusive=False, segment_ids=groups)\n        x = intervals * discrete_forwards\n        y = segment_ops.segment_cumsum(x, exclusive=False, segment_ids=groups)\n        return tf.math.divide_no_nan(y, times)",
            "def yields_from_forward_rates(discrete_forwards, times, groups=None, dtype=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Computes yield rates from discrete forward rates.\\n\\n  Denote the price of a zero coupon bond maturing at time `t` by `Z(t)`. Then\\n  the zero rate to time `t` is defined as\\n\\n  ```None\\n    r(t) = - ln(Z(t)) / t       (1)\\n\\n  ```\\n\\n  This is the (continuously compounded) interest rate that applies between time\\n  `0` and time `t` as seen at time `0`. The forward rate between times `t1` and\\n  `t2` is defined as the interest rate that applies to the period `[t1, t2]`\\n  as seen from today. It is related to the zero coupon bond prices by\\n\\n  ```None\\n    exp(-f(t1, t2)(t2-t1)) = Z(t2) / Z(t1)                 (2)\\n    f(t1, t2) = - (ln Z(t2) - ln Z(t1)) / (t2 - t1)        (3)\\n    f(t1, t2) = (t2 * r(t2) - t1 * r(t1)) / (t2 - t1)      (4)\\n  ```\\n\\n  Given a sequence of increasing times `[t1, t2, ... tn]` and the forward rates\\n  for the consecutive time intervals, i.e. `[0, t1]`, `[t1, t2]` to\\n  `[t_{n-1}, tn]`, this function computes the yields to maturity for maturities\\n  `[t1, t2, ... tn]` using Eq. (4) above.\\n\\n  Additionally, this function supports this computation for a batch of such\\n  forward rates. Batching is made slightly complicated by the fact that\\n  different zero curves may have different numbers of tenors (the parameter `n`\\n  above). Instead of a batch as an extra dimension, we support the concept of\\n  groups (also see documentation for `tf.segment_sum` which uses the same\\n  concept).\\n\\n  #### Example\\n\\n  The following example illustrates this method along with the concept of\\n  groups. Assuming there are two sets of zero rates (e.g. for different\\n  currencies) whose implied forward rates are needed. The first set has a total\\n  of three marked tenors at `[0.25, 0.5, 1.0]`. The second set\\n  has four marked tenors at `[0.25, 0.5, 1.0, 1.5]`.\\n  Suppose, the forward rates for the first set are:\\n  `[0.04, 0.041, 0.044]` and the second are `[0.022, 0.025, 0.028, 0.036]`.\\n  Then this data is batched together as follows:\\n  Groups:   [0,    0    0,   1,    1,   1    1  ]\\n  First three times for group 0, next four for group 1.\\n  Times:    [0.25, 0.5, 1.0, 0.25, 0.5, 1.0, 1.5]\\n  First three discrete forwards for group 0, next four for group 1.\\n  Forwards: [0.04, 0.042, 0.047, 0.022, 0.028, 0.031, 0.052]\\n\\n  ```python\\n    dtype = np.float64\\n    groups = np.array([0, 0, 0, 1, 1, 1, 1])\\n    times = np.array([0.25, 0.5, 1.0, 0.25, 0.5, 1.0, 1.5], dtype=dtype)\\n    discrete_forwards = np.array(\\n        [0.04, 0.042, 0.047, 0.022, 0.028, 0.031, 0.052], dtype=dtype)\\n    yields = yields_from_forward_rates(discrete_forwards, times,\\n                                       groups=groups, dtype=dtype)\\n    # Produces: [0.04, 0.041, 0.044, 0.022, 0.025, 0.028, 0.036]\\n  ```\\n\\n  #### References:\\n\\n  [1]: John C. Hull. Options, Futures and Other Derivatives. Ninth Edition.\\n    June 2006.\\n\\n  Args:\\n    discrete_forwards: Real rank 1 `Tensor` of size `n`. The forward rates for\\n      the time periods specified. Note that the first value applies between `0`\\n      and time `times[0]`.\\n    times: Real positive rank 1 `Tensor` of size `n`. The set of times\\n      corresponding to the supplied zero rates. If no `groups` is supplied, then\\n      the whole array should be sorted in an increasing order. If `groups` are\\n      supplied, then the times within a group should be in an increasing order.\\n    groups: Optional int `Tensor` of size `n` containing values between 0 and\\n      `k-1` where `k` is the number of different curves.\\n      Default value: None. This implies that all the rates are treated as a\\n        single group.\\n    dtype: `tf.Dtype`. If supplied the dtype for the `discrete_forwards` and\\n      `times`.\\n      Default value: None which maps to the default dtype inferred from\\n      `discrete_forwards`.\\n    name: Python str. The name to give to the ops created by this function.\\n      Default value: None which maps to 'yields_from_forward_rates'.\\n\\n  Returns:\\n    yields: Real rank 1 `Tensor` of size `n` containing the zero coupon yields\\n    that for the supplied maturities (within each group if groups are\\n    specified).\\n  \"\n    with tf.compat.v1.name_scope(name, default_name='yields_from_forward_rates', values=[discrete_forwards, times, groups]):\n        discrete_forwards = tf.convert_to_tensor(discrete_forwards, dtype=dtype, name='discrete_forwards')\n        dtype = dtype or discrete_forwards.dtype\n        times = tf.convert_to_tensor(times, dtype=dtype, name='times')\n        if groups is not None:\n            groups = tf.convert_to_tensor(groups, name='groups')\n        intervals = segment_ops.segment_diff(times, order=1, exclusive=False, segment_ids=groups)\n        x = intervals * discrete_forwards\n        y = segment_ops.segment_cumsum(x, exclusive=False, segment_ids=groups)\n        return tf.math.divide_no_nan(y, times)",
            "def yields_from_forward_rates(discrete_forwards, times, groups=None, dtype=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Computes yield rates from discrete forward rates.\\n\\n  Denote the price of a zero coupon bond maturing at time `t` by `Z(t)`. Then\\n  the zero rate to time `t` is defined as\\n\\n  ```None\\n    r(t) = - ln(Z(t)) / t       (1)\\n\\n  ```\\n\\n  This is the (continuously compounded) interest rate that applies between time\\n  `0` and time `t` as seen at time `0`. The forward rate between times `t1` and\\n  `t2` is defined as the interest rate that applies to the period `[t1, t2]`\\n  as seen from today. It is related to the zero coupon bond prices by\\n\\n  ```None\\n    exp(-f(t1, t2)(t2-t1)) = Z(t2) / Z(t1)                 (2)\\n    f(t1, t2) = - (ln Z(t2) - ln Z(t1)) / (t2 - t1)        (3)\\n    f(t1, t2) = (t2 * r(t2) - t1 * r(t1)) / (t2 - t1)      (4)\\n  ```\\n\\n  Given a sequence of increasing times `[t1, t2, ... tn]` and the forward rates\\n  for the consecutive time intervals, i.e. `[0, t1]`, `[t1, t2]` to\\n  `[t_{n-1}, tn]`, this function computes the yields to maturity for maturities\\n  `[t1, t2, ... tn]` using Eq. (4) above.\\n\\n  Additionally, this function supports this computation for a batch of such\\n  forward rates. Batching is made slightly complicated by the fact that\\n  different zero curves may have different numbers of tenors (the parameter `n`\\n  above). Instead of a batch as an extra dimension, we support the concept of\\n  groups (also see documentation for `tf.segment_sum` which uses the same\\n  concept).\\n\\n  #### Example\\n\\n  The following example illustrates this method along with the concept of\\n  groups. Assuming there are two sets of zero rates (e.g. for different\\n  currencies) whose implied forward rates are needed. The first set has a total\\n  of three marked tenors at `[0.25, 0.5, 1.0]`. The second set\\n  has four marked tenors at `[0.25, 0.5, 1.0, 1.5]`.\\n  Suppose, the forward rates for the first set are:\\n  `[0.04, 0.041, 0.044]` and the second are `[0.022, 0.025, 0.028, 0.036]`.\\n  Then this data is batched together as follows:\\n  Groups:   [0,    0    0,   1,    1,   1    1  ]\\n  First three times for group 0, next four for group 1.\\n  Times:    [0.25, 0.5, 1.0, 0.25, 0.5, 1.0, 1.5]\\n  First three discrete forwards for group 0, next four for group 1.\\n  Forwards: [0.04, 0.042, 0.047, 0.022, 0.028, 0.031, 0.052]\\n\\n  ```python\\n    dtype = np.float64\\n    groups = np.array([0, 0, 0, 1, 1, 1, 1])\\n    times = np.array([0.25, 0.5, 1.0, 0.25, 0.5, 1.0, 1.5], dtype=dtype)\\n    discrete_forwards = np.array(\\n        [0.04, 0.042, 0.047, 0.022, 0.028, 0.031, 0.052], dtype=dtype)\\n    yields = yields_from_forward_rates(discrete_forwards, times,\\n                                       groups=groups, dtype=dtype)\\n    # Produces: [0.04, 0.041, 0.044, 0.022, 0.025, 0.028, 0.036]\\n  ```\\n\\n  #### References:\\n\\n  [1]: John C. Hull. Options, Futures and Other Derivatives. Ninth Edition.\\n    June 2006.\\n\\n  Args:\\n    discrete_forwards: Real rank 1 `Tensor` of size `n`. The forward rates for\\n      the time periods specified. Note that the first value applies between `0`\\n      and time `times[0]`.\\n    times: Real positive rank 1 `Tensor` of size `n`. The set of times\\n      corresponding to the supplied zero rates. If no `groups` is supplied, then\\n      the whole array should be sorted in an increasing order. If `groups` are\\n      supplied, then the times within a group should be in an increasing order.\\n    groups: Optional int `Tensor` of size `n` containing values between 0 and\\n      `k-1` where `k` is the number of different curves.\\n      Default value: None. This implies that all the rates are treated as a\\n        single group.\\n    dtype: `tf.Dtype`. If supplied the dtype for the `discrete_forwards` and\\n      `times`.\\n      Default value: None which maps to the default dtype inferred from\\n      `discrete_forwards`.\\n    name: Python str. The name to give to the ops created by this function.\\n      Default value: None which maps to 'yields_from_forward_rates'.\\n\\n  Returns:\\n    yields: Real rank 1 `Tensor` of size `n` containing the zero coupon yields\\n    that for the supplied maturities (within each group if groups are\\n    specified).\\n  \"\n    with tf.compat.v1.name_scope(name, default_name='yields_from_forward_rates', values=[discrete_forwards, times, groups]):\n        discrete_forwards = tf.convert_to_tensor(discrete_forwards, dtype=dtype, name='discrete_forwards')\n        dtype = dtype or discrete_forwards.dtype\n        times = tf.convert_to_tensor(times, dtype=dtype, name='times')\n        if groups is not None:\n            groups = tf.convert_to_tensor(groups, name='groups')\n        intervals = segment_ops.segment_diff(times, order=1, exclusive=False, segment_ids=groups)\n        x = intervals * discrete_forwards\n        y = segment_ops.segment_cumsum(x, exclusive=False, segment_ids=groups)\n        return tf.math.divide_no_nan(y, times)"
        ]
    }
]