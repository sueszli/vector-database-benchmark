[
    {
        "func_name": "_scale_residue",
        "original": "def _scale_residue(res, scale, scaleMtx):\n    if res.internal_coord:\n        res.internal_coord.applyMtx(scaleMtx)\n        if res.internal_coord.gly_Cbeta:\n            res.internal_coord.scale = scale",
        "mutated": [
            "def _scale_residue(res, scale, scaleMtx):\n    if False:\n        i = 10\n    if res.internal_coord:\n        res.internal_coord.applyMtx(scaleMtx)\n        if res.internal_coord.gly_Cbeta:\n            res.internal_coord.scale = scale",
            "def _scale_residue(res, scale, scaleMtx):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if res.internal_coord:\n        res.internal_coord.applyMtx(scaleMtx)\n        if res.internal_coord.gly_Cbeta:\n            res.internal_coord.scale = scale",
            "def _scale_residue(res, scale, scaleMtx):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if res.internal_coord:\n        res.internal_coord.applyMtx(scaleMtx)\n        if res.internal_coord.gly_Cbeta:\n            res.internal_coord.scale = scale",
            "def _scale_residue(res, scale, scaleMtx):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if res.internal_coord:\n        res.internal_coord.applyMtx(scaleMtx)\n        if res.internal_coord.gly_Cbeta:\n            res.internal_coord.scale = scale",
            "def _scale_residue(res, scale, scaleMtx):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if res.internal_coord:\n        res.internal_coord.applyMtx(scaleMtx)\n        if res.internal_coord.gly_Cbeta:\n            res.internal_coord.scale = scale"
        ]
    },
    {
        "func_name": "write_SCAD",
        "original": "def write_SCAD(entity, file, scale=None, pdbid=None, backboneOnly=False, includeCode=True, maxPeptideBond=None, start=None, fin=None, handle='protein'):\n    \"\"\"Write hedron assembly to file as OpenSCAD matrices.\n\n    This routine calls both :meth:`.IC_Chain.internal_to_atom_coordinates` and\n    :meth:`.IC_Chain.atom_to_internal_coordinates` due to requirements for\n    scaling, explicit bonds around rings, and setting the coordinate space of\n    the output model.\n\n    Output data format is primarily:\n\n    - matrix for each hedron:\n        len1, angle2, len3, atom covalent bond class, flags to indicate\n        atom/bond represented in previous hedron (OpenSCAD very slow with\n        redundant overlapping elements), flags for bond features\n    - transform matrices to assemble each hedron into residue dihedra sets\n    - transform matrices for each residue to position in chain\n\n    OpenSCAD software is included in this Python file to process these\n    matrices into a model suitable for a 3D printing project.\n\n    :param entity: Biopython PDB :class:`.Structure` entity\n        structure data to export\n    :param file: Bipoython :func:`.as_handle` filename or open file pointer\n        file to write data to\n    :param float scale:\n        units (usually mm) per angstrom for STL output, written in output\n    :param str pdbid:\n        PDB idcode, written in output. Defaults to '0PDB' if not supplied\n        and no 'idcode' set in entity\n    :param bool backboneOnly: default False.\n        Do not output side chain data past Cbeta if True\n    :param bool includeCode: default True.\n        Include OpenSCAD software (inline below) so output file can be loaded\n        into OpenSCAD; if False, output data matrices only\n    :param float maxPeptideBond: Optional default None.\n        Override the cut-off in IC_Chain class (default 1.4) for detecting\n        chain breaks.  If your target has chain breaks, pass a large number\n        here to create a very long 'bond' spanning the break.\n    :param int start,fin: default None\n        Parameters for internal_to_atom_coords() to limit chain segment.\n    :param str handle: default 'protein'\n        name for top level of generated OpenSCAD matrix structure\n\n    See :meth:`.IC_Residue.set_flexible` to set flags for specific residues to\n    have rotatable bonds, and :meth:`.IC_Residue.set_hbond` to include cavities\n    for small magnets to work as hydrogen bonds.\n    See <https://www.thingiverse.com/thing:3957471> for implementation example.\n\n    The OpenSCAD code explicitly creates spheres and cylinders to\n    represent atoms and bonds in a 3D model.  Options are available\n    to support rotatable bonds and magnetic hydrogen bonds.\n\n    Matrices are written to link, enumerate and describe residues,\n    dihedra, hedra, and chains, mirroring contents of the relevant IC_*\n    data structures.\n\n    The OpenSCAD matrix of hedra has additional information as follows:\n\n    * the atom and bond state (single, double, resonance) are logged\n        so that covalent radii may be used for atom spheres in the 3D models\n\n    * bonds and atoms are tracked so that each is only created once\n\n    * bond options for rotation and magnet holders for hydrogen bonds\n        may be specified (see :meth:`.IC_Residue.set_flexible` and\n        :meth:`.IC_Residue.set_hbond` )\n\n    Note the application of :data:`Bio.PDB.internal_coords.IC_Chain.MaxPeptideBond`\n    :  missing residues may be linked (joining chain segments with arbitrarily\n    long bonds) by setting this to a large value.\n\n    Note this uses the serial assembly per residue, placing each residue at\n    the origin and supplying the coordinate space transform to OpenaSCAD\n\n    All ALTLOC (disordered) residues and atoms are written to the output\n    model.  (see :data:`Bio.PDB.internal_coords.IC_Residue.no_altloc`)\n    \"\"\"\n    if maxPeptideBond is not None:\n        mpbStash = IC_Chain.MaxPeptideBond\n        IC_Chain.MaxPeptideBond = float(maxPeptideBond)\n    added_IC_Atoms = False\n    if 'S' == entity.level or 'M' == entity.level:\n        for chn in entity.get_chains():\n            if not chn.internal_coord:\n                chn.internal_coord = IC_Chain(chn)\n                added_IC_Atoms = True\n    elif 'C' == entity.level:\n        if not entity.internal_coord:\n            entity.internal_coord = IC_Chain(entity)\n            added_IC_Atoms = True\n    else:\n        raise PDBException('level not S, M or C: ' + str(entity.level))\n    if added_IC_Atoms:\n        entity.atom_to_internal_coordinates()\n    else:\n        entity.internal_to_atom_coordinates(None)\n    if scale is not None:\n        scaleMtx = homog_scale_mtx(scale)\n        if 'C' == entity.level:\n            entity.internal_coord.atomArray = np.dot(entity.internal_coord.atomArray[:], scaleMtx)\n            entity.internal_coord.hAtoms_needs_update[:] = True\n            entity.internal_coord.scale = scale\n        else:\n            for chn in entity.get_chains():\n                if hasattr(chn.internal_coord, 'atomArray'):\n                    chn.internal_coord.atomArray = np.dot(chn.internal_coord.atomArray[:], scaleMtx)\n                    chn.internal_coord.hAtoms_needs_update[:] = True\n                    chn.internal_coord.scale = scale\n    allBondsStash = IC_Residue._AllBonds\n    IC_Residue._AllBonds = True\n    if 'C' == entity.level:\n        entity.internal_coord.ordered_aa_ic_list[0].hedra = {}\n        delattr(entity.internal_coord, 'hAtoms_needs_update')\n        delattr(entity.internal_coord, 'hedraLen')\n    else:\n        for chn in entity.get_chains():\n            chn.internal_coord.ordered_aa_ic_list[0].hedra = {}\n            delattr(chn.internal_coord, 'hAtoms_needs_update')\n            delattr(chn.internal_coord, 'hedraLen')\n    entity.atom_to_internal_coordinates()\n    IC_Residue._AllBonds = allBondsStash\n    entity.internal_to_atom_coordinates()\n    with as_handle(file, 'w') as fp:\n        if includeCode:\n            fp.write(peptide_scad)\n        if not pdbid and hasattr(entity, 'header'):\n            pdbid = entity.header.get('idcode', None)\n        if pdbid is None or '' == pdbid:\n            pdbid = '0PDB'\n        fp.write('protein = [ \"' + pdbid + '\", ' + str(scale) + ',  // ID, protein_scale\\n')\n        if 'S' == entity.level or 'M' == entity.level:\n            for chn in entity.get_chains():\n                fp.write(' [\\n')\n                chn.internal_coord._write_SCAD(fp, backboneOnly=backboneOnly, start=start, fin=fin)\n                fp.write(' ]\\n')\n        elif 'C' == entity.level:\n            fp.write(' [\\n')\n            entity.internal_coord._write_SCAD(fp, backboneOnly=backboneOnly, start=start, fin=fin)\n            fp.write(' ]\\n')\n        elif 'R' == entity.level:\n            raise NotImplementedError('writescad single residue not yet implemented.')\n        fp.write('\\n];\\n')\n    if maxPeptideBond is not None:\n        IC_Chain.MaxPeptideBond = mpbStash",
        "mutated": [
            "def write_SCAD(entity, file, scale=None, pdbid=None, backboneOnly=False, includeCode=True, maxPeptideBond=None, start=None, fin=None, handle='protein'):\n    if False:\n        i = 10\n    \"Write hedron assembly to file as OpenSCAD matrices.\\n\\n    This routine calls both :meth:`.IC_Chain.internal_to_atom_coordinates` and\\n    :meth:`.IC_Chain.atom_to_internal_coordinates` due to requirements for\\n    scaling, explicit bonds around rings, and setting the coordinate space of\\n    the output model.\\n\\n    Output data format is primarily:\\n\\n    - matrix for each hedron:\\n        len1, angle2, len3, atom covalent bond class, flags to indicate\\n        atom/bond represented in previous hedron (OpenSCAD very slow with\\n        redundant overlapping elements), flags for bond features\\n    - transform matrices to assemble each hedron into residue dihedra sets\\n    - transform matrices for each residue to position in chain\\n\\n    OpenSCAD software is included in this Python file to process these\\n    matrices into a model suitable for a 3D printing project.\\n\\n    :param entity: Biopython PDB :class:`.Structure` entity\\n        structure data to export\\n    :param file: Bipoython :func:`.as_handle` filename or open file pointer\\n        file to write data to\\n    :param float scale:\\n        units (usually mm) per angstrom for STL output, written in output\\n    :param str pdbid:\\n        PDB idcode, written in output. Defaults to '0PDB' if not supplied\\n        and no 'idcode' set in entity\\n    :param bool backboneOnly: default False.\\n        Do not output side chain data past Cbeta if True\\n    :param bool includeCode: default True.\\n        Include OpenSCAD software (inline below) so output file can be loaded\\n        into OpenSCAD; if False, output data matrices only\\n    :param float maxPeptideBond: Optional default None.\\n        Override the cut-off in IC_Chain class (default 1.4) for detecting\\n        chain breaks.  If your target has chain breaks, pass a large number\\n        here to create a very long 'bond' spanning the break.\\n    :param int start,fin: default None\\n        Parameters for internal_to_atom_coords() to limit chain segment.\\n    :param str handle: default 'protein'\\n        name for top level of generated OpenSCAD matrix structure\\n\\n    See :meth:`.IC_Residue.set_flexible` to set flags for specific residues to\\n    have rotatable bonds, and :meth:`.IC_Residue.set_hbond` to include cavities\\n    for small magnets to work as hydrogen bonds.\\n    See <https://www.thingiverse.com/thing:3957471> for implementation example.\\n\\n    The OpenSCAD code explicitly creates spheres and cylinders to\\n    represent atoms and bonds in a 3D model.  Options are available\\n    to support rotatable bonds and magnetic hydrogen bonds.\\n\\n    Matrices are written to link, enumerate and describe residues,\\n    dihedra, hedra, and chains, mirroring contents of the relevant IC_*\\n    data structures.\\n\\n    The OpenSCAD matrix of hedra has additional information as follows:\\n\\n    * the atom and bond state (single, double, resonance) are logged\\n        so that covalent radii may be used for atom spheres in the 3D models\\n\\n    * bonds and atoms are tracked so that each is only created once\\n\\n    * bond options for rotation and magnet holders for hydrogen bonds\\n        may be specified (see :meth:`.IC_Residue.set_flexible` and\\n        :meth:`.IC_Residue.set_hbond` )\\n\\n    Note the application of :data:`Bio.PDB.internal_coords.IC_Chain.MaxPeptideBond`\\n    :  missing residues may be linked (joining chain segments with arbitrarily\\n    long bonds) by setting this to a large value.\\n\\n    Note this uses the serial assembly per residue, placing each residue at\\n    the origin and supplying the coordinate space transform to OpenaSCAD\\n\\n    All ALTLOC (disordered) residues and atoms are written to the output\\n    model.  (see :data:`Bio.PDB.internal_coords.IC_Residue.no_altloc`)\\n    \"\n    if maxPeptideBond is not None:\n        mpbStash = IC_Chain.MaxPeptideBond\n        IC_Chain.MaxPeptideBond = float(maxPeptideBond)\n    added_IC_Atoms = False\n    if 'S' == entity.level or 'M' == entity.level:\n        for chn in entity.get_chains():\n            if not chn.internal_coord:\n                chn.internal_coord = IC_Chain(chn)\n                added_IC_Atoms = True\n    elif 'C' == entity.level:\n        if not entity.internal_coord:\n            entity.internal_coord = IC_Chain(entity)\n            added_IC_Atoms = True\n    else:\n        raise PDBException('level not S, M or C: ' + str(entity.level))\n    if added_IC_Atoms:\n        entity.atom_to_internal_coordinates()\n    else:\n        entity.internal_to_atom_coordinates(None)\n    if scale is not None:\n        scaleMtx = homog_scale_mtx(scale)\n        if 'C' == entity.level:\n            entity.internal_coord.atomArray = np.dot(entity.internal_coord.atomArray[:], scaleMtx)\n            entity.internal_coord.hAtoms_needs_update[:] = True\n            entity.internal_coord.scale = scale\n        else:\n            for chn in entity.get_chains():\n                if hasattr(chn.internal_coord, 'atomArray'):\n                    chn.internal_coord.atomArray = np.dot(chn.internal_coord.atomArray[:], scaleMtx)\n                    chn.internal_coord.hAtoms_needs_update[:] = True\n                    chn.internal_coord.scale = scale\n    allBondsStash = IC_Residue._AllBonds\n    IC_Residue._AllBonds = True\n    if 'C' == entity.level:\n        entity.internal_coord.ordered_aa_ic_list[0].hedra = {}\n        delattr(entity.internal_coord, 'hAtoms_needs_update')\n        delattr(entity.internal_coord, 'hedraLen')\n    else:\n        for chn in entity.get_chains():\n            chn.internal_coord.ordered_aa_ic_list[0].hedra = {}\n            delattr(chn.internal_coord, 'hAtoms_needs_update')\n            delattr(chn.internal_coord, 'hedraLen')\n    entity.atom_to_internal_coordinates()\n    IC_Residue._AllBonds = allBondsStash\n    entity.internal_to_atom_coordinates()\n    with as_handle(file, 'w') as fp:\n        if includeCode:\n            fp.write(peptide_scad)\n        if not pdbid and hasattr(entity, 'header'):\n            pdbid = entity.header.get('idcode', None)\n        if pdbid is None or '' == pdbid:\n            pdbid = '0PDB'\n        fp.write('protein = [ \"' + pdbid + '\", ' + str(scale) + ',  // ID, protein_scale\\n')\n        if 'S' == entity.level or 'M' == entity.level:\n            for chn in entity.get_chains():\n                fp.write(' [\\n')\n                chn.internal_coord._write_SCAD(fp, backboneOnly=backboneOnly, start=start, fin=fin)\n                fp.write(' ]\\n')\n        elif 'C' == entity.level:\n            fp.write(' [\\n')\n            entity.internal_coord._write_SCAD(fp, backboneOnly=backboneOnly, start=start, fin=fin)\n            fp.write(' ]\\n')\n        elif 'R' == entity.level:\n            raise NotImplementedError('writescad single residue not yet implemented.')\n        fp.write('\\n];\\n')\n    if maxPeptideBond is not None:\n        IC_Chain.MaxPeptideBond = mpbStash",
            "def write_SCAD(entity, file, scale=None, pdbid=None, backboneOnly=False, includeCode=True, maxPeptideBond=None, start=None, fin=None, handle='protein'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Write hedron assembly to file as OpenSCAD matrices.\\n\\n    This routine calls both :meth:`.IC_Chain.internal_to_atom_coordinates` and\\n    :meth:`.IC_Chain.atom_to_internal_coordinates` due to requirements for\\n    scaling, explicit bonds around rings, and setting the coordinate space of\\n    the output model.\\n\\n    Output data format is primarily:\\n\\n    - matrix for each hedron:\\n        len1, angle2, len3, atom covalent bond class, flags to indicate\\n        atom/bond represented in previous hedron (OpenSCAD very slow with\\n        redundant overlapping elements), flags for bond features\\n    - transform matrices to assemble each hedron into residue dihedra sets\\n    - transform matrices for each residue to position in chain\\n\\n    OpenSCAD software is included in this Python file to process these\\n    matrices into a model suitable for a 3D printing project.\\n\\n    :param entity: Biopython PDB :class:`.Structure` entity\\n        structure data to export\\n    :param file: Bipoython :func:`.as_handle` filename or open file pointer\\n        file to write data to\\n    :param float scale:\\n        units (usually mm) per angstrom for STL output, written in output\\n    :param str pdbid:\\n        PDB idcode, written in output. Defaults to '0PDB' if not supplied\\n        and no 'idcode' set in entity\\n    :param bool backboneOnly: default False.\\n        Do not output side chain data past Cbeta if True\\n    :param bool includeCode: default True.\\n        Include OpenSCAD software (inline below) so output file can be loaded\\n        into OpenSCAD; if False, output data matrices only\\n    :param float maxPeptideBond: Optional default None.\\n        Override the cut-off in IC_Chain class (default 1.4) for detecting\\n        chain breaks.  If your target has chain breaks, pass a large number\\n        here to create a very long 'bond' spanning the break.\\n    :param int start,fin: default None\\n        Parameters for internal_to_atom_coords() to limit chain segment.\\n    :param str handle: default 'protein'\\n        name for top level of generated OpenSCAD matrix structure\\n\\n    See :meth:`.IC_Residue.set_flexible` to set flags for specific residues to\\n    have rotatable bonds, and :meth:`.IC_Residue.set_hbond` to include cavities\\n    for small magnets to work as hydrogen bonds.\\n    See <https://www.thingiverse.com/thing:3957471> for implementation example.\\n\\n    The OpenSCAD code explicitly creates spheres and cylinders to\\n    represent atoms and bonds in a 3D model.  Options are available\\n    to support rotatable bonds and magnetic hydrogen bonds.\\n\\n    Matrices are written to link, enumerate and describe residues,\\n    dihedra, hedra, and chains, mirroring contents of the relevant IC_*\\n    data structures.\\n\\n    The OpenSCAD matrix of hedra has additional information as follows:\\n\\n    * the atom and bond state (single, double, resonance) are logged\\n        so that covalent radii may be used for atom spheres in the 3D models\\n\\n    * bonds and atoms are tracked so that each is only created once\\n\\n    * bond options for rotation and magnet holders for hydrogen bonds\\n        may be specified (see :meth:`.IC_Residue.set_flexible` and\\n        :meth:`.IC_Residue.set_hbond` )\\n\\n    Note the application of :data:`Bio.PDB.internal_coords.IC_Chain.MaxPeptideBond`\\n    :  missing residues may be linked (joining chain segments with arbitrarily\\n    long bonds) by setting this to a large value.\\n\\n    Note this uses the serial assembly per residue, placing each residue at\\n    the origin and supplying the coordinate space transform to OpenaSCAD\\n\\n    All ALTLOC (disordered) residues and atoms are written to the output\\n    model.  (see :data:`Bio.PDB.internal_coords.IC_Residue.no_altloc`)\\n    \"\n    if maxPeptideBond is not None:\n        mpbStash = IC_Chain.MaxPeptideBond\n        IC_Chain.MaxPeptideBond = float(maxPeptideBond)\n    added_IC_Atoms = False\n    if 'S' == entity.level or 'M' == entity.level:\n        for chn in entity.get_chains():\n            if not chn.internal_coord:\n                chn.internal_coord = IC_Chain(chn)\n                added_IC_Atoms = True\n    elif 'C' == entity.level:\n        if not entity.internal_coord:\n            entity.internal_coord = IC_Chain(entity)\n            added_IC_Atoms = True\n    else:\n        raise PDBException('level not S, M or C: ' + str(entity.level))\n    if added_IC_Atoms:\n        entity.atom_to_internal_coordinates()\n    else:\n        entity.internal_to_atom_coordinates(None)\n    if scale is not None:\n        scaleMtx = homog_scale_mtx(scale)\n        if 'C' == entity.level:\n            entity.internal_coord.atomArray = np.dot(entity.internal_coord.atomArray[:], scaleMtx)\n            entity.internal_coord.hAtoms_needs_update[:] = True\n            entity.internal_coord.scale = scale\n        else:\n            for chn in entity.get_chains():\n                if hasattr(chn.internal_coord, 'atomArray'):\n                    chn.internal_coord.atomArray = np.dot(chn.internal_coord.atomArray[:], scaleMtx)\n                    chn.internal_coord.hAtoms_needs_update[:] = True\n                    chn.internal_coord.scale = scale\n    allBondsStash = IC_Residue._AllBonds\n    IC_Residue._AllBonds = True\n    if 'C' == entity.level:\n        entity.internal_coord.ordered_aa_ic_list[0].hedra = {}\n        delattr(entity.internal_coord, 'hAtoms_needs_update')\n        delattr(entity.internal_coord, 'hedraLen')\n    else:\n        for chn in entity.get_chains():\n            chn.internal_coord.ordered_aa_ic_list[0].hedra = {}\n            delattr(chn.internal_coord, 'hAtoms_needs_update')\n            delattr(chn.internal_coord, 'hedraLen')\n    entity.atom_to_internal_coordinates()\n    IC_Residue._AllBonds = allBondsStash\n    entity.internal_to_atom_coordinates()\n    with as_handle(file, 'w') as fp:\n        if includeCode:\n            fp.write(peptide_scad)\n        if not pdbid and hasattr(entity, 'header'):\n            pdbid = entity.header.get('idcode', None)\n        if pdbid is None or '' == pdbid:\n            pdbid = '0PDB'\n        fp.write('protein = [ \"' + pdbid + '\", ' + str(scale) + ',  // ID, protein_scale\\n')\n        if 'S' == entity.level or 'M' == entity.level:\n            for chn in entity.get_chains():\n                fp.write(' [\\n')\n                chn.internal_coord._write_SCAD(fp, backboneOnly=backboneOnly, start=start, fin=fin)\n                fp.write(' ]\\n')\n        elif 'C' == entity.level:\n            fp.write(' [\\n')\n            entity.internal_coord._write_SCAD(fp, backboneOnly=backboneOnly, start=start, fin=fin)\n            fp.write(' ]\\n')\n        elif 'R' == entity.level:\n            raise NotImplementedError('writescad single residue not yet implemented.')\n        fp.write('\\n];\\n')\n    if maxPeptideBond is not None:\n        IC_Chain.MaxPeptideBond = mpbStash",
            "def write_SCAD(entity, file, scale=None, pdbid=None, backboneOnly=False, includeCode=True, maxPeptideBond=None, start=None, fin=None, handle='protein'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Write hedron assembly to file as OpenSCAD matrices.\\n\\n    This routine calls both :meth:`.IC_Chain.internal_to_atom_coordinates` and\\n    :meth:`.IC_Chain.atom_to_internal_coordinates` due to requirements for\\n    scaling, explicit bonds around rings, and setting the coordinate space of\\n    the output model.\\n\\n    Output data format is primarily:\\n\\n    - matrix for each hedron:\\n        len1, angle2, len3, atom covalent bond class, flags to indicate\\n        atom/bond represented in previous hedron (OpenSCAD very slow with\\n        redundant overlapping elements), flags for bond features\\n    - transform matrices to assemble each hedron into residue dihedra sets\\n    - transform matrices for each residue to position in chain\\n\\n    OpenSCAD software is included in this Python file to process these\\n    matrices into a model suitable for a 3D printing project.\\n\\n    :param entity: Biopython PDB :class:`.Structure` entity\\n        structure data to export\\n    :param file: Bipoython :func:`.as_handle` filename or open file pointer\\n        file to write data to\\n    :param float scale:\\n        units (usually mm) per angstrom for STL output, written in output\\n    :param str pdbid:\\n        PDB idcode, written in output. Defaults to '0PDB' if not supplied\\n        and no 'idcode' set in entity\\n    :param bool backboneOnly: default False.\\n        Do not output side chain data past Cbeta if True\\n    :param bool includeCode: default True.\\n        Include OpenSCAD software (inline below) so output file can be loaded\\n        into OpenSCAD; if False, output data matrices only\\n    :param float maxPeptideBond: Optional default None.\\n        Override the cut-off in IC_Chain class (default 1.4) for detecting\\n        chain breaks.  If your target has chain breaks, pass a large number\\n        here to create a very long 'bond' spanning the break.\\n    :param int start,fin: default None\\n        Parameters for internal_to_atom_coords() to limit chain segment.\\n    :param str handle: default 'protein'\\n        name for top level of generated OpenSCAD matrix structure\\n\\n    See :meth:`.IC_Residue.set_flexible` to set flags for specific residues to\\n    have rotatable bonds, and :meth:`.IC_Residue.set_hbond` to include cavities\\n    for small magnets to work as hydrogen bonds.\\n    See <https://www.thingiverse.com/thing:3957471> for implementation example.\\n\\n    The OpenSCAD code explicitly creates spheres and cylinders to\\n    represent atoms and bonds in a 3D model.  Options are available\\n    to support rotatable bonds and magnetic hydrogen bonds.\\n\\n    Matrices are written to link, enumerate and describe residues,\\n    dihedra, hedra, and chains, mirroring contents of the relevant IC_*\\n    data structures.\\n\\n    The OpenSCAD matrix of hedra has additional information as follows:\\n\\n    * the atom and bond state (single, double, resonance) are logged\\n        so that covalent radii may be used for atom spheres in the 3D models\\n\\n    * bonds and atoms are tracked so that each is only created once\\n\\n    * bond options for rotation and magnet holders for hydrogen bonds\\n        may be specified (see :meth:`.IC_Residue.set_flexible` and\\n        :meth:`.IC_Residue.set_hbond` )\\n\\n    Note the application of :data:`Bio.PDB.internal_coords.IC_Chain.MaxPeptideBond`\\n    :  missing residues may be linked (joining chain segments with arbitrarily\\n    long bonds) by setting this to a large value.\\n\\n    Note this uses the serial assembly per residue, placing each residue at\\n    the origin and supplying the coordinate space transform to OpenaSCAD\\n\\n    All ALTLOC (disordered) residues and atoms are written to the output\\n    model.  (see :data:`Bio.PDB.internal_coords.IC_Residue.no_altloc`)\\n    \"\n    if maxPeptideBond is not None:\n        mpbStash = IC_Chain.MaxPeptideBond\n        IC_Chain.MaxPeptideBond = float(maxPeptideBond)\n    added_IC_Atoms = False\n    if 'S' == entity.level or 'M' == entity.level:\n        for chn in entity.get_chains():\n            if not chn.internal_coord:\n                chn.internal_coord = IC_Chain(chn)\n                added_IC_Atoms = True\n    elif 'C' == entity.level:\n        if not entity.internal_coord:\n            entity.internal_coord = IC_Chain(entity)\n            added_IC_Atoms = True\n    else:\n        raise PDBException('level not S, M or C: ' + str(entity.level))\n    if added_IC_Atoms:\n        entity.atom_to_internal_coordinates()\n    else:\n        entity.internal_to_atom_coordinates(None)\n    if scale is not None:\n        scaleMtx = homog_scale_mtx(scale)\n        if 'C' == entity.level:\n            entity.internal_coord.atomArray = np.dot(entity.internal_coord.atomArray[:], scaleMtx)\n            entity.internal_coord.hAtoms_needs_update[:] = True\n            entity.internal_coord.scale = scale\n        else:\n            for chn in entity.get_chains():\n                if hasattr(chn.internal_coord, 'atomArray'):\n                    chn.internal_coord.atomArray = np.dot(chn.internal_coord.atomArray[:], scaleMtx)\n                    chn.internal_coord.hAtoms_needs_update[:] = True\n                    chn.internal_coord.scale = scale\n    allBondsStash = IC_Residue._AllBonds\n    IC_Residue._AllBonds = True\n    if 'C' == entity.level:\n        entity.internal_coord.ordered_aa_ic_list[0].hedra = {}\n        delattr(entity.internal_coord, 'hAtoms_needs_update')\n        delattr(entity.internal_coord, 'hedraLen')\n    else:\n        for chn in entity.get_chains():\n            chn.internal_coord.ordered_aa_ic_list[0].hedra = {}\n            delattr(chn.internal_coord, 'hAtoms_needs_update')\n            delattr(chn.internal_coord, 'hedraLen')\n    entity.atom_to_internal_coordinates()\n    IC_Residue._AllBonds = allBondsStash\n    entity.internal_to_atom_coordinates()\n    with as_handle(file, 'w') as fp:\n        if includeCode:\n            fp.write(peptide_scad)\n        if not pdbid and hasattr(entity, 'header'):\n            pdbid = entity.header.get('idcode', None)\n        if pdbid is None or '' == pdbid:\n            pdbid = '0PDB'\n        fp.write('protein = [ \"' + pdbid + '\", ' + str(scale) + ',  // ID, protein_scale\\n')\n        if 'S' == entity.level or 'M' == entity.level:\n            for chn in entity.get_chains():\n                fp.write(' [\\n')\n                chn.internal_coord._write_SCAD(fp, backboneOnly=backboneOnly, start=start, fin=fin)\n                fp.write(' ]\\n')\n        elif 'C' == entity.level:\n            fp.write(' [\\n')\n            entity.internal_coord._write_SCAD(fp, backboneOnly=backboneOnly, start=start, fin=fin)\n            fp.write(' ]\\n')\n        elif 'R' == entity.level:\n            raise NotImplementedError('writescad single residue not yet implemented.')\n        fp.write('\\n];\\n')\n    if maxPeptideBond is not None:\n        IC_Chain.MaxPeptideBond = mpbStash",
            "def write_SCAD(entity, file, scale=None, pdbid=None, backboneOnly=False, includeCode=True, maxPeptideBond=None, start=None, fin=None, handle='protein'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Write hedron assembly to file as OpenSCAD matrices.\\n\\n    This routine calls both :meth:`.IC_Chain.internal_to_atom_coordinates` and\\n    :meth:`.IC_Chain.atom_to_internal_coordinates` due to requirements for\\n    scaling, explicit bonds around rings, and setting the coordinate space of\\n    the output model.\\n\\n    Output data format is primarily:\\n\\n    - matrix for each hedron:\\n        len1, angle2, len3, atom covalent bond class, flags to indicate\\n        atom/bond represented in previous hedron (OpenSCAD very slow with\\n        redundant overlapping elements), flags for bond features\\n    - transform matrices to assemble each hedron into residue dihedra sets\\n    - transform matrices for each residue to position in chain\\n\\n    OpenSCAD software is included in this Python file to process these\\n    matrices into a model suitable for a 3D printing project.\\n\\n    :param entity: Biopython PDB :class:`.Structure` entity\\n        structure data to export\\n    :param file: Bipoython :func:`.as_handle` filename or open file pointer\\n        file to write data to\\n    :param float scale:\\n        units (usually mm) per angstrom for STL output, written in output\\n    :param str pdbid:\\n        PDB idcode, written in output. Defaults to '0PDB' if not supplied\\n        and no 'idcode' set in entity\\n    :param bool backboneOnly: default False.\\n        Do not output side chain data past Cbeta if True\\n    :param bool includeCode: default True.\\n        Include OpenSCAD software (inline below) so output file can be loaded\\n        into OpenSCAD; if False, output data matrices only\\n    :param float maxPeptideBond: Optional default None.\\n        Override the cut-off in IC_Chain class (default 1.4) for detecting\\n        chain breaks.  If your target has chain breaks, pass a large number\\n        here to create a very long 'bond' spanning the break.\\n    :param int start,fin: default None\\n        Parameters for internal_to_atom_coords() to limit chain segment.\\n    :param str handle: default 'protein'\\n        name for top level of generated OpenSCAD matrix structure\\n\\n    See :meth:`.IC_Residue.set_flexible` to set flags for specific residues to\\n    have rotatable bonds, and :meth:`.IC_Residue.set_hbond` to include cavities\\n    for small magnets to work as hydrogen bonds.\\n    See <https://www.thingiverse.com/thing:3957471> for implementation example.\\n\\n    The OpenSCAD code explicitly creates spheres and cylinders to\\n    represent atoms and bonds in a 3D model.  Options are available\\n    to support rotatable bonds and magnetic hydrogen bonds.\\n\\n    Matrices are written to link, enumerate and describe residues,\\n    dihedra, hedra, and chains, mirroring contents of the relevant IC_*\\n    data structures.\\n\\n    The OpenSCAD matrix of hedra has additional information as follows:\\n\\n    * the atom and bond state (single, double, resonance) are logged\\n        so that covalent radii may be used for atom spheres in the 3D models\\n\\n    * bonds and atoms are tracked so that each is only created once\\n\\n    * bond options for rotation and magnet holders for hydrogen bonds\\n        may be specified (see :meth:`.IC_Residue.set_flexible` and\\n        :meth:`.IC_Residue.set_hbond` )\\n\\n    Note the application of :data:`Bio.PDB.internal_coords.IC_Chain.MaxPeptideBond`\\n    :  missing residues may be linked (joining chain segments with arbitrarily\\n    long bonds) by setting this to a large value.\\n\\n    Note this uses the serial assembly per residue, placing each residue at\\n    the origin and supplying the coordinate space transform to OpenaSCAD\\n\\n    All ALTLOC (disordered) residues and atoms are written to the output\\n    model.  (see :data:`Bio.PDB.internal_coords.IC_Residue.no_altloc`)\\n    \"\n    if maxPeptideBond is not None:\n        mpbStash = IC_Chain.MaxPeptideBond\n        IC_Chain.MaxPeptideBond = float(maxPeptideBond)\n    added_IC_Atoms = False\n    if 'S' == entity.level or 'M' == entity.level:\n        for chn in entity.get_chains():\n            if not chn.internal_coord:\n                chn.internal_coord = IC_Chain(chn)\n                added_IC_Atoms = True\n    elif 'C' == entity.level:\n        if not entity.internal_coord:\n            entity.internal_coord = IC_Chain(entity)\n            added_IC_Atoms = True\n    else:\n        raise PDBException('level not S, M or C: ' + str(entity.level))\n    if added_IC_Atoms:\n        entity.atom_to_internal_coordinates()\n    else:\n        entity.internal_to_atom_coordinates(None)\n    if scale is not None:\n        scaleMtx = homog_scale_mtx(scale)\n        if 'C' == entity.level:\n            entity.internal_coord.atomArray = np.dot(entity.internal_coord.atomArray[:], scaleMtx)\n            entity.internal_coord.hAtoms_needs_update[:] = True\n            entity.internal_coord.scale = scale\n        else:\n            for chn in entity.get_chains():\n                if hasattr(chn.internal_coord, 'atomArray'):\n                    chn.internal_coord.atomArray = np.dot(chn.internal_coord.atomArray[:], scaleMtx)\n                    chn.internal_coord.hAtoms_needs_update[:] = True\n                    chn.internal_coord.scale = scale\n    allBondsStash = IC_Residue._AllBonds\n    IC_Residue._AllBonds = True\n    if 'C' == entity.level:\n        entity.internal_coord.ordered_aa_ic_list[0].hedra = {}\n        delattr(entity.internal_coord, 'hAtoms_needs_update')\n        delattr(entity.internal_coord, 'hedraLen')\n    else:\n        for chn in entity.get_chains():\n            chn.internal_coord.ordered_aa_ic_list[0].hedra = {}\n            delattr(chn.internal_coord, 'hAtoms_needs_update')\n            delattr(chn.internal_coord, 'hedraLen')\n    entity.atom_to_internal_coordinates()\n    IC_Residue._AllBonds = allBondsStash\n    entity.internal_to_atom_coordinates()\n    with as_handle(file, 'w') as fp:\n        if includeCode:\n            fp.write(peptide_scad)\n        if not pdbid and hasattr(entity, 'header'):\n            pdbid = entity.header.get('idcode', None)\n        if pdbid is None or '' == pdbid:\n            pdbid = '0PDB'\n        fp.write('protein = [ \"' + pdbid + '\", ' + str(scale) + ',  // ID, protein_scale\\n')\n        if 'S' == entity.level or 'M' == entity.level:\n            for chn in entity.get_chains():\n                fp.write(' [\\n')\n                chn.internal_coord._write_SCAD(fp, backboneOnly=backboneOnly, start=start, fin=fin)\n                fp.write(' ]\\n')\n        elif 'C' == entity.level:\n            fp.write(' [\\n')\n            entity.internal_coord._write_SCAD(fp, backboneOnly=backboneOnly, start=start, fin=fin)\n            fp.write(' ]\\n')\n        elif 'R' == entity.level:\n            raise NotImplementedError('writescad single residue not yet implemented.')\n        fp.write('\\n];\\n')\n    if maxPeptideBond is not None:\n        IC_Chain.MaxPeptideBond = mpbStash",
            "def write_SCAD(entity, file, scale=None, pdbid=None, backboneOnly=False, includeCode=True, maxPeptideBond=None, start=None, fin=None, handle='protein'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Write hedron assembly to file as OpenSCAD matrices.\\n\\n    This routine calls both :meth:`.IC_Chain.internal_to_atom_coordinates` and\\n    :meth:`.IC_Chain.atom_to_internal_coordinates` due to requirements for\\n    scaling, explicit bonds around rings, and setting the coordinate space of\\n    the output model.\\n\\n    Output data format is primarily:\\n\\n    - matrix for each hedron:\\n        len1, angle2, len3, atom covalent bond class, flags to indicate\\n        atom/bond represented in previous hedron (OpenSCAD very slow with\\n        redundant overlapping elements), flags for bond features\\n    - transform matrices to assemble each hedron into residue dihedra sets\\n    - transform matrices for each residue to position in chain\\n\\n    OpenSCAD software is included in this Python file to process these\\n    matrices into a model suitable for a 3D printing project.\\n\\n    :param entity: Biopython PDB :class:`.Structure` entity\\n        structure data to export\\n    :param file: Bipoython :func:`.as_handle` filename or open file pointer\\n        file to write data to\\n    :param float scale:\\n        units (usually mm) per angstrom for STL output, written in output\\n    :param str pdbid:\\n        PDB idcode, written in output. Defaults to '0PDB' if not supplied\\n        and no 'idcode' set in entity\\n    :param bool backboneOnly: default False.\\n        Do not output side chain data past Cbeta if True\\n    :param bool includeCode: default True.\\n        Include OpenSCAD software (inline below) so output file can be loaded\\n        into OpenSCAD; if False, output data matrices only\\n    :param float maxPeptideBond: Optional default None.\\n        Override the cut-off in IC_Chain class (default 1.4) for detecting\\n        chain breaks.  If your target has chain breaks, pass a large number\\n        here to create a very long 'bond' spanning the break.\\n    :param int start,fin: default None\\n        Parameters for internal_to_atom_coords() to limit chain segment.\\n    :param str handle: default 'protein'\\n        name for top level of generated OpenSCAD matrix structure\\n\\n    See :meth:`.IC_Residue.set_flexible` to set flags for specific residues to\\n    have rotatable bonds, and :meth:`.IC_Residue.set_hbond` to include cavities\\n    for small magnets to work as hydrogen bonds.\\n    See <https://www.thingiverse.com/thing:3957471> for implementation example.\\n\\n    The OpenSCAD code explicitly creates spheres and cylinders to\\n    represent atoms and bonds in a 3D model.  Options are available\\n    to support rotatable bonds and magnetic hydrogen bonds.\\n\\n    Matrices are written to link, enumerate and describe residues,\\n    dihedra, hedra, and chains, mirroring contents of the relevant IC_*\\n    data structures.\\n\\n    The OpenSCAD matrix of hedra has additional information as follows:\\n\\n    * the atom and bond state (single, double, resonance) are logged\\n        so that covalent radii may be used for atom spheres in the 3D models\\n\\n    * bonds and atoms are tracked so that each is only created once\\n\\n    * bond options for rotation and magnet holders for hydrogen bonds\\n        may be specified (see :meth:`.IC_Residue.set_flexible` and\\n        :meth:`.IC_Residue.set_hbond` )\\n\\n    Note the application of :data:`Bio.PDB.internal_coords.IC_Chain.MaxPeptideBond`\\n    :  missing residues may be linked (joining chain segments with arbitrarily\\n    long bonds) by setting this to a large value.\\n\\n    Note this uses the serial assembly per residue, placing each residue at\\n    the origin and supplying the coordinate space transform to OpenaSCAD\\n\\n    All ALTLOC (disordered) residues and atoms are written to the output\\n    model.  (see :data:`Bio.PDB.internal_coords.IC_Residue.no_altloc`)\\n    \"\n    if maxPeptideBond is not None:\n        mpbStash = IC_Chain.MaxPeptideBond\n        IC_Chain.MaxPeptideBond = float(maxPeptideBond)\n    added_IC_Atoms = False\n    if 'S' == entity.level or 'M' == entity.level:\n        for chn in entity.get_chains():\n            if not chn.internal_coord:\n                chn.internal_coord = IC_Chain(chn)\n                added_IC_Atoms = True\n    elif 'C' == entity.level:\n        if not entity.internal_coord:\n            entity.internal_coord = IC_Chain(entity)\n            added_IC_Atoms = True\n    else:\n        raise PDBException('level not S, M or C: ' + str(entity.level))\n    if added_IC_Atoms:\n        entity.atom_to_internal_coordinates()\n    else:\n        entity.internal_to_atom_coordinates(None)\n    if scale is not None:\n        scaleMtx = homog_scale_mtx(scale)\n        if 'C' == entity.level:\n            entity.internal_coord.atomArray = np.dot(entity.internal_coord.atomArray[:], scaleMtx)\n            entity.internal_coord.hAtoms_needs_update[:] = True\n            entity.internal_coord.scale = scale\n        else:\n            for chn in entity.get_chains():\n                if hasattr(chn.internal_coord, 'atomArray'):\n                    chn.internal_coord.atomArray = np.dot(chn.internal_coord.atomArray[:], scaleMtx)\n                    chn.internal_coord.hAtoms_needs_update[:] = True\n                    chn.internal_coord.scale = scale\n    allBondsStash = IC_Residue._AllBonds\n    IC_Residue._AllBonds = True\n    if 'C' == entity.level:\n        entity.internal_coord.ordered_aa_ic_list[0].hedra = {}\n        delattr(entity.internal_coord, 'hAtoms_needs_update')\n        delattr(entity.internal_coord, 'hedraLen')\n    else:\n        for chn in entity.get_chains():\n            chn.internal_coord.ordered_aa_ic_list[0].hedra = {}\n            delattr(chn.internal_coord, 'hAtoms_needs_update')\n            delattr(chn.internal_coord, 'hedraLen')\n    entity.atom_to_internal_coordinates()\n    IC_Residue._AllBonds = allBondsStash\n    entity.internal_to_atom_coordinates()\n    with as_handle(file, 'w') as fp:\n        if includeCode:\n            fp.write(peptide_scad)\n        if not pdbid and hasattr(entity, 'header'):\n            pdbid = entity.header.get('idcode', None)\n        if pdbid is None or '' == pdbid:\n            pdbid = '0PDB'\n        fp.write('protein = [ \"' + pdbid + '\", ' + str(scale) + ',  // ID, protein_scale\\n')\n        if 'S' == entity.level or 'M' == entity.level:\n            for chn in entity.get_chains():\n                fp.write(' [\\n')\n                chn.internal_coord._write_SCAD(fp, backboneOnly=backboneOnly, start=start, fin=fin)\n                fp.write(' ]\\n')\n        elif 'C' == entity.level:\n            fp.write(' [\\n')\n            entity.internal_coord._write_SCAD(fp, backboneOnly=backboneOnly, start=start, fin=fin)\n            fp.write(' ]\\n')\n        elif 'R' == entity.level:\n            raise NotImplementedError('writescad single residue not yet implemented.')\n        fp.write('\\n];\\n')\n    if maxPeptideBond is not None:\n        IC_Chain.MaxPeptideBond = mpbStash"
        ]
    }
]