[
    {
        "func_name": "pyx_to_dll",
        "original": "def pyx_to_dll(filename, ext=None, force_rebuild=0, build_in_temp=False, pyxbuild_dir=None, setup_args=None, reload_support=False, inplace=False):\n    \"\"\"Compile a PYX file to a DLL and return the name of the generated .so\n       or .dll .\"\"\"\n    assert os.path.exists(filename), 'Could not find %s' % os.path.abspath(filename)\n    (path, name) = os.path.split(os.path.abspath(filename))\n    if not ext:\n        (modname, extension) = os.path.splitext(name)\n        assert extension in ('.pyx', '.py'), extension\n        if not HAS_CYTHON:\n            filename = filename[:-len(extension)] + '.c'\n        ext = Extension(name=modname, sources=[filename])\n    if setup_args is None:\n        setup_args = {}\n    if not pyxbuild_dir:\n        pyxbuild_dir = os.path.join(path, '_pyxbld')\n    package_base_dir = path\n    for package_name in ext.name.split('.')[-2::-1]:\n        (package_base_dir, pname) = os.path.split(package_base_dir)\n        if pname != package_name:\n            package_base_dir = None\n            break\n    script_args = setup_args.get('script_args', [])\n    if DEBUG or '--verbose' in script_args:\n        quiet = '--verbose'\n    else:\n        quiet = '--quiet'\n    if build_in_temp:\n        args = [quiet, 'build_ext', '--cython-c-in-temp']\n    else:\n        args = [quiet, 'build_ext']\n    if force_rebuild:\n        args.append('--force')\n    if inplace and package_base_dir:\n        args.extend(['--build-lib', package_base_dir])\n        if ext.name == '__init__' or ext.name.endswith('.__init__'):\n            if not hasattr(ext, 'cython_directives'):\n                ext.cython_directives = {'set_initial_path': 'SOURCEFILE'}\n            elif 'set_initial_path' not in ext.cython_directives:\n                ext.cython_directives['set_initial_path'] = 'SOURCEFILE'\n    sargs = setup_args.copy()\n    sargs.update({'script_name': None, 'script_args': args + script_args})\n    from distutils.dist import Distribution\n    dist = Distribution(sargs)\n    if not dist.ext_modules:\n        dist.ext_modules = []\n    dist.ext_modules.append(ext)\n    if HAS_CYTHON:\n        dist.cmdclass = {'build_ext': build_ext}\n    build = dist.get_command_obj('build')\n    build.build_base = pyxbuild_dir\n    cfgfiles = dist.find_config_files()\n    dist.parse_config_files(cfgfiles)\n    try:\n        ok = dist.parse_command_line()\n    except DistutilsArgError:\n        raise\n    if DEBUG:\n        print('options (after parsing command line):')\n        dist.dump_option_dicts()\n    assert ok\n    try:\n        obj_build_ext = dist.get_command_obj('build_ext')\n        dist.run_commands()\n        so_path = obj_build_ext.get_outputs()[0]\n        if obj_build_ext.inplace:\n            so_path = os.path.join(os.path.dirname(filename), os.path.basename(so_path))\n        if reload_support:\n            org_path = so_path\n            timestamp = os.path.getmtime(org_path)\n            global _reloads\n            (last_timestamp, last_path, count) = _reloads.get(org_path, (None, None, 0))\n            if last_timestamp == timestamp:\n                so_path = last_path\n            else:\n                basename = os.path.basename(org_path)\n                while count < 100:\n                    count += 1\n                    r_path = os.path.join(obj_build_ext.build_lib, basename + '.reload%s' % count)\n                    try:\n                        import shutil\n                        try:\n                            if os.path.isfile(r_path):\n                                os.unlink(r_path)\n                        except OSError:\n                            continue\n                        shutil.copy2(org_path, r_path)\n                        so_path = r_path\n                    except IOError:\n                        continue\n                    break\n                else:\n                    raise ImportError('reload count for %s reached maximum' % org_path)\n                _reloads[org_path] = (timestamp, so_path, count)\n        return so_path\n    except KeyboardInterrupt:\n        sys.exit(1)\n    except (IOError, os.error):\n        exc = sys.exc_info()[1]\n        error = grok_environment_error(exc)\n        if DEBUG:\n            sys.stderr.write(error + '\\n')\n        raise",
        "mutated": [
            "def pyx_to_dll(filename, ext=None, force_rebuild=0, build_in_temp=False, pyxbuild_dir=None, setup_args=None, reload_support=False, inplace=False):\n    if False:\n        i = 10\n    'Compile a PYX file to a DLL and return the name of the generated .so\\n       or .dll .'\n    assert os.path.exists(filename), 'Could not find %s' % os.path.abspath(filename)\n    (path, name) = os.path.split(os.path.abspath(filename))\n    if not ext:\n        (modname, extension) = os.path.splitext(name)\n        assert extension in ('.pyx', '.py'), extension\n        if not HAS_CYTHON:\n            filename = filename[:-len(extension)] + '.c'\n        ext = Extension(name=modname, sources=[filename])\n    if setup_args is None:\n        setup_args = {}\n    if not pyxbuild_dir:\n        pyxbuild_dir = os.path.join(path, '_pyxbld')\n    package_base_dir = path\n    for package_name in ext.name.split('.')[-2::-1]:\n        (package_base_dir, pname) = os.path.split(package_base_dir)\n        if pname != package_name:\n            package_base_dir = None\n            break\n    script_args = setup_args.get('script_args', [])\n    if DEBUG or '--verbose' in script_args:\n        quiet = '--verbose'\n    else:\n        quiet = '--quiet'\n    if build_in_temp:\n        args = [quiet, 'build_ext', '--cython-c-in-temp']\n    else:\n        args = [quiet, 'build_ext']\n    if force_rebuild:\n        args.append('--force')\n    if inplace and package_base_dir:\n        args.extend(['--build-lib', package_base_dir])\n        if ext.name == '__init__' or ext.name.endswith('.__init__'):\n            if not hasattr(ext, 'cython_directives'):\n                ext.cython_directives = {'set_initial_path': 'SOURCEFILE'}\n            elif 'set_initial_path' not in ext.cython_directives:\n                ext.cython_directives['set_initial_path'] = 'SOURCEFILE'\n    sargs = setup_args.copy()\n    sargs.update({'script_name': None, 'script_args': args + script_args})\n    from distutils.dist import Distribution\n    dist = Distribution(sargs)\n    if not dist.ext_modules:\n        dist.ext_modules = []\n    dist.ext_modules.append(ext)\n    if HAS_CYTHON:\n        dist.cmdclass = {'build_ext': build_ext}\n    build = dist.get_command_obj('build')\n    build.build_base = pyxbuild_dir\n    cfgfiles = dist.find_config_files()\n    dist.parse_config_files(cfgfiles)\n    try:\n        ok = dist.parse_command_line()\n    except DistutilsArgError:\n        raise\n    if DEBUG:\n        print('options (after parsing command line):')\n        dist.dump_option_dicts()\n    assert ok\n    try:\n        obj_build_ext = dist.get_command_obj('build_ext')\n        dist.run_commands()\n        so_path = obj_build_ext.get_outputs()[0]\n        if obj_build_ext.inplace:\n            so_path = os.path.join(os.path.dirname(filename), os.path.basename(so_path))\n        if reload_support:\n            org_path = so_path\n            timestamp = os.path.getmtime(org_path)\n            global _reloads\n            (last_timestamp, last_path, count) = _reloads.get(org_path, (None, None, 0))\n            if last_timestamp == timestamp:\n                so_path = last_path\n            else:\n                basename = os.path.basename(org_path)\n                while count < 100:\n                    count += 1\n                    r_path = os.path.join(obj_build_ext.build_lib, basename + '.reload%s' % count)\n                    try:\n                        import shutil\n                        try:\n                            if os.path.isfile(r_path):\n                                os.unlink(r_path)\n                        except OSError:\n                            continue\n                        shutil.copy2(org_path, r_path)\n                        so_path = r_path\n                    except IOError:\n                        continue\n                    break\n                else:\n                    raise ImportError('reload count for %s reached maximum' % org_path)\n                _reloads[org_path] = (timestamp, so_path, count)\n        return so_path\n    except KeyboardInterrupt:\n        sys.exit(1)\n    except (IOError, os.error):\n        exc = sys.exc_info()[1]\n        error = grok_environment_error(exc)\n        if DEBUG:\n            sys.stderr.write(error + '\\n')\n        raise",
            "def pyx_to_dll(filename, ext=None, force_rebuild=0, build_in_temp=False, pyxbuild_dir=None, setup_args=None, reload_support=False, inplace=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Compile a PYX file to a DLL and return the name of the generated .so\\n       or .dll .'\n    assert os.path.exists(filename), 'Could not find %s' % os.path.abspath(filename)\n    (path, name) = os.path.split(os.path.abspath(filename))\n    if not ext:\n        (modname, extension) = os.path.splitext(name)\n        assert extension in ('.pyx', '.py'), extension\n        if not HAS_CYTHON:\n            filename = filename[:-len(extension)] + '.c'\n        ext = Extension(name=modname, sources=[filename])\n    if setup_args is None:\n        setup_args = {}\n    if not pyxbuild_dir:\n        pyxbuild_dir = os.path.join(path, '_pyxbld')\n    package_base_dir = path\n    for package_name in ext.name.split('.')[-2::-1]:\n        (package_base_dir, pname) = os.path.split(package_base_dir)\n        if pname != package_name:\n            package_base_dir = None\n            break\n    script_args = setup_args.get('script_args', [])\n    if DEBUG or '--verbose' in script_args:\n        quiet = '--verbose'\n    else:\n        quiet = '--quiet'\n    if build_in_temp:\n        args = [quiet, 'build_ext', '--cython-c-in-temp']\n    else:\n        args = [quiet, 'build_ext']\n    if force_rebuild:\n        args.append('--force')\n    if inplace and package_base_dir:\n        args.extend(['--build-lib', package_base_dir])\n        if ext.name == '__init__' or ext.name.endswith('.__init__'):\n            if not hasattr(ext, 'cython_directives'):\n                ext.cython_directives = {'set_initial_path': 'SOURCEFILE'}\n            elif 'set_initial_path' not in ext.cython_directives:\n                ext.cython_directives['set_initial_path'] = 'SOURCEFILE'\n    sargs = setup_args.copy()\n    sargs.update({'script_name': None, 'script_args': args + script_args})\n    from distutils.dist import Distribution\n    dist = Distribution(sargs)\n    if not dist.ext_modules:\n        dist.ext_modules = []\n    dist.ext_modules.append(ext)\n    if HAS_CYTHON:\n        dist.cmdclass = {'build_ext': build_ext}\n    build = dist.get_command_obj('build')\n    build.build_base = pyxbuild_dir\n    cfgfiles = dist.find_config_files()\n    dist.parse_config_files(cfgfiles)\n    try:\n        ok = dist.parse_command_line()\n    except DistutilsArgError:\n        raise\n    if DEBUG:\n        print('options (after parsing command line):')\n        dist.dump_option_dicts()\n    assert ok\n    try:\n        obj_build_ext = dist.get_command_obj('build_ext')\n        dist.run_commands()\n        so_path = obj_build_ext.get_outputs()[0]\n        if obj_build_ext.inplace:\n            so_path = os.path.join(os.path.dirname(filename), os.path.basename(so_path))\n        if reload_support:\n            org_path = so_path\n            timestamp = os.path.getmtime(org_path)\n            global _reloads\n            (last_timestamp, last_path, count) = _reloads.get(org_path, (None, None, 0))\n            if last_timestamp == timestamp:\n                so_path = last_path\n            else:\n                basename = os.path.basename(org_path)\n                while count < 100:\n                    count += 1\n                    r_path = os.path.join(obj_build_ext.build_lib, basename + '.reload%s' % count)\n                    try:\n                        import shutil\n                        try:\n                            if os.path.isfile(r_path):\n                                os.unlink(r_path)\n                        except OSError:\n                            continue\n                        shutil.copy2(org_path, r_path)\n                        so_path = r_path\n                    except IOError:\n                        continue\n                    break\n                else:\n                    raise ImportError('reload count for %s reached maximum' % org_path)\n                _reloads[org_path] = (timestamp, so_path, count)\n        return so_path\n    except KeyboardInterrupt:\n        sys.exit(1)\n    except (IOError, os.error):\n        exc = sys.exc_info()[1]\n        error = grok_environment_error(exc)\n        if DEBUG:\n            sys.stderr.write(error + '\\n')\n        raise",
            "def pyx_to_dll(filename, ext=None, force_rebuild=0, build_in_temp=False, pyxbuild_dir=None, setup_args=None, reload_support=False, inplace=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Compile a PYX file to a DLL and return the name of the generated .so\\n       or .dll .'\n    assert os.path.exists(filename), 'Could not find %s' % os.path.abspath(filename)\n    (path, name) = os.path.split(os.path.abspath(filename))\n    if not ext:\n        (modname, extension) = os.path.splitext(name)\n        assert extension in ('.pyx', '.py'), extension\n        if not HAS_CYTHON:\n            filename = filename[:-len(extension)] + '.c'\n        ext = Extension(name=modname, sources=[filename])\n    if setup_args is None:\n        setup_args = {}\n    if not pyxbuild_dir:\n        pyxbuild_dir = os.path.join(path, '_pyxbld')\n    package_base_dir = path\n    for package_name in ext.name.split('.')[-2::-1]:\n        (package_base_dir, pname) = os.path.split(package_base_dir)\n        if pname != package_name:\n            package_base_dir = None\n            break\n    script_args = setup_args.get('script_args', [])\n    if DEBUG or '--verbose' in script_args:\n        quiet = '--verbose'\n    else:\n        quiet = '--quiet'\n    if build_in_temp:\n        args = [quiet, 'build_ext', '--cython-c-in-temp']\n    else:\n        args = [quiet, 'build_ext']\n    if force_rebuild:\n        args.append('--force')\n    if inplace and package_base_dir:\n        args.extend(['--build-lib', package_base_dir])\n        if ext.name == '__init__' or ext.name.endswith('.__init__'):\n            if not hasattr(ext, 'cython_directives'):\n                ext.cython_directives = {'set_initial_path': 'SOURCEFILE'}\n            elif 'set_initial_path' not in ext.cython_directives:\n                ext.cython_directives['set_initial_path'] = 'SOURCEFILE'\n    sargs = setup_args.copy()\n    sargs.update({'script_name': None, 'script_args': args + script_args})\n    from distutils.dist import Distribution\n    dist = Distribution(sargs)\n    if not dist.ext_modules:\n        dist.ext_modules = []\n    dist.ext_modules.append(ext)\n    if HAS_CYTHON:\n        dist.cmdclass = {'build_ext': build_ext}\n    build = dist.get_command_obj('build')\n    build.build_base = pyxbuild_dir\n    cfgfiles = dist.find_config_files()\n    dist.parse_config_files(cfgfiles)\n    try:\n        ok = dist.parse_command_line()\n    except DistutilsArgError:\n        raise\n    if DEBUG:\n        print('options (after parsing command line):')\n        dist.dump_option_dicts()\n    assert ok\n    try:\n        obj_build_ext = dist.get_command_obj('build_ext')\n        dist.run_commands()\n        so_path = obj_build_ext.get_outputs()[0]\n        if obj_build_ext.inplace:\n            so_path = os.path.join(os.path.dirname(filename), os.path.basename(so_path))\n        if reload_support:\n            org_path = so_path\n            timestamp = os.path.getmtime(org_path)\n            global _reloads\n            (last_timestamp, last_path, count) = _reloads.get(org_path, (None, None, 0))\n            if last_timestamp == timestamp:\n                so_path = last_path\n            else:\n                basename = os.path.basename(org_path)\n                while count < 100:\n                    count += 1\n                    r_path = os.path.join(obj_build_ext.build_lib, basename + '.reload%s' % count)\n                    try:\n                        import shutil\n                        try:\n                            if os.path.isfile(r_path):\n                                os.unlink(r_path)\n                        except OSError:\n                            continue\n                        shutil.copy2(org_path, r_path)\n                        so_path = r_path\n                    except IOError:\n                        continue\n                    break\n                else:\n                    raise ImportError('reload count for %s reached maximum' % org_path)\n                _reloads[org_path] = (timestamp, so_path, count)\n        return so_path\n    except KeyboardInterrupt:\n        sys.exit(1)\n    except (IOError, os.error):\n        exc = sys.exc_info()[1]\n        error = grok_environment_error(exc)\n        if DEBUG:\n            sys.stderr.write(error + '\\n')\n        raise",
            "def pyx_to_dll(filename, ext=None, force_rebuild=0, build_in_temp=False, pyxbuild_dir=None, setup_args=None, reload_support=False, inplace=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Compile a PYX file to a DLL and return the name of the generated .so\\n       or .dll .'\n    assert os.path.exists(filename), 'Could not find %s' % os.path.abspath(filename)\n    (path, name) = os.path.split(os.path.abspath(filename))\n    if not ext:\n        (modname, extension) = os.path.splitext(name)\n        assert extension in ('.pyx', '.py'), extension\n        if not HAS_CYTHON:\n            filename = filename[:-len(extension)] + '.c'\n        ext = Extension(name=modname, sources=[filename])\n    if setup_args is None:\n        setup_args = {}\n    if not pyxbuild_dir:\n        pyxbuild_dir = os.path.join(path, '_pyxbld')\n    package_base_dir = path\n    for package_name in ext.name.split('.')[-2::-1]:\n        (package_base_dir, pname) = os.path.split(package_base_dir)\n        if pname != package_name:\n            package_base_dir = None\n            break\n    script_args = setup_args.get('script_args', [])\n    if DEBUG or '--verbose' in script_args:\n        quiet = '--verbose'\n    else:\n        quiet = '--quiet'\n    if build_in_temp:\n        args = [quiet, 'build_ext', '--cython-c-in-temp']\n    else:\n        args = [quiet, 'build_ext']\n    if force_rebuild:\n        args.append('--force')\n    if inplace and package_base_dir:\n        args.extend(['--build-lib', package_base_dir])\n        if ext.name == '__init__' or ext.name.endswith('.__init__'):\n            if not hasattr(ext, 'cython_directives'):\n                ext.cython_directives = {'set_initial_path': 'SOURCEFILE'}\n            elif 'set_initial_path' not in ext.cython_directives:\n                ext.cython_directives['set_initial_path'] = 'SOURCEFILE'\n    sargs = setup_args.copy()\n    sargs.update({'script_name': None, 'script_args': args + script_args})\n    from distutils.dist import Distribution\n    dist = Distribution(sargs)\n    if not dist.ext_modules:\n        dist.ext_modules = []\n    dist.ext_modules.append(ext)\n    if HAS_CYTHON:\n        dist.cmdclass = {'build_ext': build_ext}\n    build = dist.get_command_obj('build')\n    build.build_base = pyxbuild_dir\n    cfgfiles = dist.find_config_files()\n    dist.parse_config_files(cfgfiles)\n    try:\n        ok = dist.parse_command_line()\n    except DistutilsArgError:\n        raise\n    if DEBUG:\n        print('options (after parsing command line):')\n        dist.dump_option_dicts()\n    assert ok\n    try:\n        obj_build_ext = dist.get_command_obj('build_ext')\n        dist.run_commands()\n        so_path = obj_build_ext.get_outputs()[0]\n        if obj_build_ext.inplace:\n            so_path = os.path.join(os.path.dirname(filename), os.path.basename(so_path))\n        if reload_support:\n            org_path = so_path\n            timestamp = os.path.getmtime(org_path)\n            global _reloads\n            (last_timestamp, last_path, count) = _reloads.get(org_path, (None, None, 0))\n            if last_timestamp == timestamp:\n                so_path = last_path\n            else:\n                basename = os.path.basename(org_path)\n                while count < 100:\n                    count += 1\n                    r_path = os.path.join(obj_build_ext.build_lib, basename + '.reload%s' % count)\n                    try:\n                        import shutil\n                        try:\n                            if os.path.isfile(r_path):\n                                os.unlink(r_path)\n                        except OSError:\n                            continue\n                        shutil.copy2(org_path, r_path)\n                        so_path = r_path\n                    except IOError:\n                        continue\n                    break\n                else:\n                    raise ImportError('reload count for %s reached maximum' % org_path)\n                _reloads[org_path] = (timestamp, so_path, count)\n        return so_path\n    except KeyboardInterrupt:\n        sys.exit(1)\n    except (IOError, os.error):\n        exc = sys.exc_info()[1]\n        error = grok_environment_error(exc)\n        if DEBUG:\n            sys.stderr.write(error + '\\n')\n        raise",
            "def pyx_to_dll(filename, ext=None, force_rebuild=0, build_in_temp=False, pyxbuild_dir=None, setup_args=None, reload_support=False, inplace=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Compile a PYX file to a DLL and return the name of the generated .so\\n       or .dll .'\n    assert os.path.exists(filename), 'Could not find %s' % os.path.abspath(filename)\n    (path, name) = os.path.split(os.path.abspath(filename))\n    if not ext:\n        (modname, extension) = os.path.splitext(name)\n        assert extension in ('.pyx', '.py'), extension\n        if not HAS_CYTHON:\n            filename = filename[:-len(extension)] + '.c'\n        ext = Extension(name=modname, sources=[filename])\n    if setup_args is None:\n        setup_args = {}\n    if not pyxbuild_dir:\n        pyxbuild_dir = os.path.join(path, '_pyxbld')\n    package_base_dir = path\n    for package_name in ext.name.split('.')[-2::-1]:\n        (package_base_dir, pname) = os.path.split(package_base_dir)\n        if pname != package_name:\n            package_base_dir = None\n            break\n    script_args = setup_args.get('script_args', [])\n    if DEBUG or '--verbose' in script_args:\n        quiet = '--verbose'\n    else:\n        quiet = '--quiet'\n    if build_in_temp:\n        args = [quiet, 'build_ext', '--cython-c-in-temp']\n    else:\n        args = [quiet, 'build_ext']\n    if force_rebuild:\n        args.append('--force')\n    if inplace and package_base_dir:\n        args.extend(['--build-lib', package_base_dir])\n        if ext.name == '__init__' or ext.name.endswith('.__init__'):\n            if not hasattr(ext, 'cython_directives'):\n                ext.cython_directives = {'set_initial_path': 'SOURCEFILE'}\n            elif 'set_initial_path' not in ext.cython_directives:\n                ext.cython_directives['set_initial_path'] = 'SOURCEFILE'\n    sargs = setup_args.copy()\n    sargs.update({'script_name': None, 'script_args': args + script_args})\n    from distutils.dist import Distribution\n    dist = Distribution(sargs)\n    if not dist.ext_modules:\n        dist.ext_modules = []\n    dist.ext_modules.append(ext)\n    if HAS_CYTHON:\n        dist.cmdclass = {'build_ext': build_ext}\n    build = dist.get_command_obj('build')\n    build.build_base = pyxbuild_dir\n    cfgfiles = dist.find_config_files()\n    dist.parse_config_files(cfgfiles)\n    try:\n        ok = dist.parse_command_line()\n    except DistutilsArgError:\n        raise\n    if DEBUG:\n        print('options (after parsing command line):')\n        dist.dump_option_dicts()\n    assert ok\n    try:\n        obj_build_ext = dist.get_command_obj('build_ext')\n        dist.run_commands()\n        so_path = obj_build_ext.get_outputs()[0]\n        if obj_build_ext.inplace:\n            so_path = os.path.join(os.path.dirname(filename), os.path.basename(so_path))\n        if reload_support:\n            org_path = so_path\n            timestamp = os.path.getmtime(org_path)\n            global _reloads\n            (last_timestamp, last_path, count) = _reloads.get(org_path, (None, None, 0))\n            if last_timestamp == timestamp:\n                so_path = last_path\n            else:\n                basename = os.path.basename(org_path)\n                while count < 100:\n                    count += 1\n                    r_path = os.path.join(obj_build_ext.build_lib, basename + '.reload%s' % count)\n                    try:\n                        import shutil\n                        try:\n                            if os.path.isfile(r_path):\n                                os.unlink(r_path)\n                        except OSError:\n                            continue\n                        shutil.copy2(org_path, r_path)\n                        so_path = r_path\n                    except IOError:\n                        continue\n                    break\n                else:\n                    raise ImportError('reload count for %s reached maximum' % org_path)\n                _reloads[org_path] = (timestamp, so_path, count)\n        return so_path\n    except KeyboardInterrupt:\n        sys.exit(1)\n    except (IOError, os.error):\n        exc = sys.exc_info()[1]\n        error = grok_environment_error(exc)\n        if DEBUG:\n            sys.stderr.write(error + '\\n')\n        raise"
        ]
    }
]