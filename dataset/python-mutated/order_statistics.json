[
    {
        "func_name": "_cpercentile",
        "original": "def _cpercentile(N, percent, key=lambda x: x):\n    \"\"\"\n    Find the percentile   of a list of values.\n\n    @parameter N - is a list of values. Note N MUST BE already sorted.\n    @parameter percent - a float value from 0.0 to 1.0.\n    @parameter key - optional key function to compute value from each element of N.\n\n    @return - the percentile  of the values\n    \"\"\"\n    N.sort()\n    k = (len(N) - 1) * percent\n    f = ivy.math.floor(k)\n    c = ivy.math.ceil(k)\n    if f == c:\n        return key(N[int(k)])\n    d0 = key(N[int(f)]) * (c - k)\n    d1 = key(N[int(c)]) * (k - f)\n    return d0 + d1",
        "mutated": [
            "def _cpercentile(N, percent, key=lambda x: x):\n    if False:\n        i = 10\n    '\\n    Find the percentile   of a list of values.\\n\\n    @parameter N - is a list of values. Note N MUST BE already sorted.\\n    @parameter percent - a float value from 0.0 to 1.0.\\n    @parameter key - optional key function to compute value from each element of N.\\n\\n    @return - the percentile  of the values\\n    '\n    N.sort()\n    k = (len(N) - 1) * percent\n    f = ivy.math.floor(k)\n    c = ivy.math.ceil(k)\n    if f == c:\n        return key(N[int(k)])\n    d0 = key(N[int(f)]) * (c - k)\n    d1 = key(N[int(c)]) * (k - f)\n    return d0 + d1",
            "def _cpercentile(N, percent, key=lambda x: x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Find the percentile   of a list of values.\\n\\n    @parameter N - is a list of values. Note N MUST BE already sorted.\\n    @parameter percent - a float value from 0.0 to 1.0.\\n    @parameter key - optional key function to compute value from each element of N.\\n\\n    @return - the percentile  of the values\\n    '\n    N.sort()\n    k = (len(N) - 1) * percent\n    f = ivy.math.floor(k)\n    c = ivy.math.ceil(k)\n    if f == c:\n        return key(N[int(k)])\n    d0 = key(N[int(f)]) * (c - k)\n    d1 = key(N[int(c)]) * (k - f)\n    return d0 + d1",
            "def _cpercentile(N, percent, key=lambda x: x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Find the percentile   of a list of values.\\n\\n    @parameter N - is a list of values. Note N MUST BE already sorted.\\n    @parameter percent - a float value from 0.0 to 1.0.\\n    @parameter key - optional key function to compute value from each element of N.\\n\\n    @return - the percentile  of the values\\n    '\n    N.sort()\n    k = (len(N) - 1) * percent\n    f = ivy.math.floor(k)\n    c = ivy.math.ceil(k)\n    if f == c:\n        return key(N[int(k)])\n    d0 = key(N[int(f)]) * (c - k)\n    d1 = key(N[int(c)]) * (k - f)\n    return d0 + d1",
            "def _cpercentile(N, percent, key=lambda x: x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Find the percentile   of a list of values.\\n\\n    @parameter N - is a list of values. Note N MUST BE already sorted.\\n    @parameter percent - a float value from 0.0 to 1.0.\\n    @parameter key - optional key function to compute value from each element of N.\\n\\n    @return - the percentile  of the values\\n    '\n    N.sort()\n    k = (len(N) - 1) * percent\n    f = ivy.math.floor(k)\n    c = ivy.math.ceil(k)\n    if f == c:\n        return key(N[int(k)])\n    d0 = key(N[int(f)]) * (c - k)\n    d1 = key(N[int(c)]) * (k - f)\n    return d0 + d1",
            "def _cpercentile(N, percent, key=lambda x: x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Find the percentile   of a list of values.\\n\\n    @parameter N - is a list of values. Note N MUST BE already sorted.\\n    @parameter percent - a float value from 0.0 to 1.0.\\n    @parameter key - optional key function to compute value from each element of N.\\n\\n    @return - the percentile  of the values\\n    '\n    N.sort()\n    k = (len(N) - 1) * percent\n    f = ivy.math.floor(k)\n    c = ivy.math.ceil(k)\n    if f == c:\n        return key(N[int(k)])\n    d0 = key(N[int(f)]) * (c - k)\n    d1 = key(N[int(c)]) * (k - f)\n    return d0 + d1"
        ]
    },
    {
        "func_name": "_quantile_is_valid",
        "original": "def _quantile_is_valid(q):\n    if q.ndim == 1 and q.size < 10:\n        for i in range(q.size):\n            if not 0.0 <= q[i] <= 1.0:\n                return False\n    elif not (ivy.all(q >= 0) and ivy.all(q <= 1)):\n        return False\n    return True",
        "mutated": [
            "def _quantile_is_valid(q):\n    if False:\n        i = 10\n    if q.ndim == 1 and q.size < 10:\n        for i in range(q.size):\n            if not 0.0 <= q[i] <= 1.0:\n                return False\n    elif not (ivy.all(q >= 0) and ivy.all(q <= 1)):\n        return False\n    return True",
            "def _quantile_is_valid(q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if q.ndim == 1 and q.size < 10:\n        for i in range(q.size):\n            if not 0.0 <= q[i] <= 1.0:\n                return False\n    elif not (ivy.all(q >= 0) and ivy.all(q <= 1)):\n        return False\n    return True",
            "def _quantile_is_valid(q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if q.ndim == 1 and q.size < 10:\n        for i in range(q.size):\n            if not 0.0 <= q[i] <= 1.0:\n                return False\n    elif not (ivy.all(q >= 0) and ivy.all(q <= 1)):\n        return False\n    return True",
            "def _quantile_is_valid(q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if q.ndim == 1 and q.size < 10:\n        for i in range(q.size):\n            if not 0.0 <= q[i] <= 1.0:\n                return False\n    elif not (ivy.all(q >= 0) and ivy.all(q <= 1)):\n        return False\n    return True",
            "def _quantile_is_valid(q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if q.ndim == 1 and q.size < 10:\n        for i in range(q.size):\n            if not 0.0 <= q[i] <= 1.0:\n                return False\n    elif not (ivy.all(q >= 0) and ivy.all(q <= 1)):\n        return False\n    return True"
        ]
    },
    {
        "func_name": "nanpercentile",
        "original": "def nanpercentile(a, /, *, q, axis=None, out=None, overwrite_input=False, method='linear', keepdims=False, interpolation=None):\n    a = ivy.array(a)\n    q = ivy.divide(q, 100.0)\n    q = ivy.array(q)\n    if not _quantile_is_valid(q):\n        ivy.logging.warning('percentile s must be in the range [0, 100]')\n        return []\n    if axis is None:\n        resultarray = []\n        nanlessarray = []\n        for x in a:\n            for i in x:\n                if not ivy.isnan(i):\n                    nanlessarray.append(i)\n        for i in q:\n            resultarray.append(_cpercentile(nanlessarray, i))\n        return resultarray\n    elif axis == 1:\n        resultarray = []\n        nanlessarrayofarrays = []\n        for i in a:\n            nanlessarray = []\n            for t in i:\n                if not ivy.isnan(t):\n                    nanlessarray.append(t)\n            nanlessarrayofarrays.append(nanlessarray)\n        for i in q:\n            arrayofpercentiles = []\n            for ii in nanlessarrayofarrays:\n                arrayofpercentiles.append(_cpercentile(ii, i))\n            resultarray.append(arrayofpercentiles)\n        return resultarray\n    elif axis == 0:\n        resultarray = []\n        try:\n            a = ivy.swapaxes(a, 0, 1)\n        except ivy.utils.exceptions.IvyError:\n            ivy.logging.warning(\"axis is 0 but couldn't swap\")\n        finally:\n            nanlessarrayofarrays = []\n            for i in a:\n                nanlessarray = []\n                for t in i:\n                    if not ivy.isnan(t):\n                        nanlessarray.append(t)\n                nanlessarrayofarrays.append(nanlessarray)\n            for i in q:\n                arrayofpercentiles = []\n                for ii in nanlessarrayofarrays:\n                    arrayofpercentiles.append(_cpercentile(ii, i))\n                resultarray.append(arrayofpercentiles)\n        return resultarray",
        "mutated": [
            "def nanpercentile(a, /, *, q, axis=None, out=None, overwrite_input=False, method='linear', keepdims=False, interpolation=None):\n    if False:\n        i = 10\n    a = ivy.array(a)\n    q = ivy.divide(q, 100.0)\n    q = ivy.array(q)\n    if not _quantile_is_valid(q):\n        ivy.logging.warning('percentile s must be in the range [0, 100]')\n        return []\n    if axis is None:\n        resultarray = []\n        nanlessarray = []\n        for x in a:\n            for i in x:\n                if not ivy.isnan(i):\n                    nanlessarray.append(i)\n        for i in q:\n            resultarray.append(_cpercentile(nanlessarray, i))\n        return resultarray\n    elif axis == 1:\n        resultarray = []\n        nanlessarrayofarrays = []\n        for i in a:\n            nanlessarray = []\n            for t in i:\n                if not ivy.isnan(t):\n                    nanlessarray.append(t)\n            nanlessarrayofarrays.append(nanlessarray)\n        for i in q:\n            arrayofpercentiles = []\n            for ii in nanlessarrayofarrays:\n                arrayofpercentiles.append(_cpercentile(ii, i))\n            resultarray.append(arrayofpercentiles)\n        return resultarray\n    elif axis == 0:\n        resultarray = []\n        try:\n            a = ivy.swapaxes(a, 0, 1)\n        except ivy.utils.exceptions.IvyError:\n            ivy.logging.warning(\"axis is 0 but couldn't swap\")\n        finally:\n            nanlessarrayofarrays = []\n            for i in a:\n                nanlessarray = []\n                for t in i:\n                    if not ivy.isnan(t):\n                        nanlessarray.append(t)\n                nanlessarrayofarrays.append(nanlessarray)\n            for i in q:\n                arrayofpercentiles = []\n                for ii in nanlessarrayofarrays:\n                    arrayofpercentiles.append(_cpercentile(ii, i))\n                resultarray.append(arrayofpercentiles)\n        return resultarray",
            "def nanpercentile(a, /, *, q, axis=None, out=None, overwrite_input=False, method='linear', keepdims=False, interpolation=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    a = ivy.array(a)\n    q = ivy.divide(q, 100.0)\n    q = ivy.array(q)\n    if not _quantile_is_valid(q):\n        ivy.logging.warning('percentile s must be in the range [0, 100]')\n        return []\n    if axis is None:\n        resultarray = []\n        nanlessarray = []\n        for x in a:\n            for i in x:\n                if not ivy.isnan(i):\n                    nanlessarray.append(i)\n        for i in q:\n            resultarray.append(_cpercentile(nanlessarray, i))\n        return resultarray\n    elif axis == 1:\n        resultarray = []\n        nanlessarrayofarrays = []\n        for i in a:\n            nanlessarray = []\n            for t in i:\n                if not ivy.isnan(t):\n                    nanlessarray.append(t)\n            nanlessarrayofarrays.append(nanlessarray)\n        for i in q:\n            arrayofpercentiles = []\n            for ii in nanlessarrayofarrays:\n                arrayofpercentiles.append(_cpercentile(ii, i))\n            resultarray.append(arrayofpercentiles)\n        return resultarray\n    elif axis == 0:\n        resultarray = []\n        try:\n            a = ivy.swapaxes(a, 0, 1)\n        except ivy.utils.exceptions.IvyError:\n            ivy.logging.warning(\"axis is 0 but couldn't swap\")\n        finally:\n            nanlessarrayofarrays = []\n            for i in a:\n                nanlessarray = []\n                for t in i:\n                    if not ivy.isnan(t):\n                        nanlessarray.append(t)\n                nanlessarrayofarrays.append(nanlessarray)\n            for i in q:\n                arrayofpercentiles = []\n                for ii in nanlessarrayofarrays:\n                    arrayofpercentiles.append(_cpercentile(ii, i))\n                resultarray.append(arrayofpercentiles)\n        return resultarray",
            "def nanpercentile(a, /, *, q, axis=None, out=None, overwrite_input=False, method='linear', keepdims=False, interpolation=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    a = ivy.array(a)\n    q = ivy.divide(q, 100.0)\n    q = ivy.array(q)\n    if not _quantile_is_valid(q):\n        ivy.logging.warning('percentile s must be in the range [0, 100]')\n        return []\n    if axis is None:\n        resultarray = []\n        nanlessarray = []\n        for x in a:\n            for i in x:\n                if not ivy.isnan(i):\n                    nanlessarray.append(i)\n        for i in q:\n            resultarray.append(_cpercentile(nanlessarray, i))\n        return resultarray\n    elif axis == 1:\n        resultarray = []\n        nanlessarrayofarrays = []\n        for i in a:\n            nanlessarray = []\n            for t in i:\n                if not ivy.isnan(t):\n                    nanlessarray.append(t)\n            nanlessarrayofarrays.append(nanlessarray)\n        for i in q:\n            arrayofpercentiles = []\n            for ii in nanlessarrayofarrays:\n                arrayofpercentiles.append(_cpercentile(ii, i))\n            resultarray.append(arrayofpercentiles)\n        return resultarray\n    elif axis == 0:\n        resultarray = []\n        try:\n            a = ivy.swapaxes(a, 0, 1)\n        except ivy.utils.exceptions.IvyError:\n            ivy.logging.warning(\"axis is 0 but couldn't swap\")\n        finally:\n            nanlessarrayofarrays = []\n            for i in a:\n                nanlessarray = []\n                for t in i:\n                    if not ivy.isnan(t):\n                        nanlessarray.append(t)\n                nanlessarrayofarrays.append(nanlessarray)\n            for i in q:\n                arrayofpercentiles = []\n                for ii in nanlessarrayofarrays:\n                    arrayofpercentiles.append(_cpercentile(ii, i))\n                resultarray.append(arrayofpercentiles)\n        return resultarray",
            "def nanpercentile(a, /, *, q, axis=None, out=None, overwrite_input=False, method='linear', keepdims=False, interpolation=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    a = ivy.array(a)\n    q = ivy.divide(q, 100.0)\n    q = ivy.array(q)\n    if not _quantile_is_valid(q):\n        ivy.logging.warning('percentile s must be in the range [0, 100]')\n        return []\n    if axis is None:\n        resultarray = []\n        nanlessarray = []\n        for x in a:\n            for i in x:\n                if not ivy.isnan(i):\n                    nanlessarray.append(i)\n        for i in q:\n            resultarray.append(_cpercentile(nanlessarray, i))\n        return resultarray\n    elif axis == 1:\n        resultarray = []\n        nanlessarrayofarrays = []\n        for i in a:\n            nanlessarray = []\n            for t in i:\n                if not ivy.isnan(t):\n                    nanlessarray.append(t)\n            nanlessarrayofarrays.append(nanlessarray)\n        for i in q:\n            arrayofpercentiles = []\n            for ii in nanlessarrayofarrays:\n                arrayofpercentiles.append(_cpercentile(ii, i))\n            resultarray.append(arrayofpercentiles)\n        return resultarray\n    elif axis == 0:\n        resultarray = []\n        try:\n            a = ivy.swapaxes(a, 0, 1)\n        except ivy.utils.exceptions.IvyError:\n            ivy.logging.warning(\"axis is 0 but couldn't swap\")\n        finally:\n            nanlessarrayofarrays = []\n            for i in a:\n                nanlessarray = []\n                for t in i:\n                    if not ivy.isnan(t):\n                        nanlessarray.append(t)\n                nanlessarrayofarrays.append(nanlessarray)\n            for i in q:\n                arrayofpercentiles = []\n                for ii in nanlessarrayofarrays:\n                    arrayofpercentiles.append(_cpercentile(ii, i))\n                resultarray.append(arrayofpercentiles)\n        return resultarray",
            "def nanpercentile(a, /, *, q, axis=None, out=None, overwrite_input=False, method='linear', keepdims=False, interpolation=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    a = ivy.array(a)\n    q = ivy.divide(q, 100.0)\n    q = ivy.array(q)\n    if not _quantile_is_valid(q):\n        ivy.logging.warning('percentile s must be in the range [0, 100]')\n        return []\n    if axis is None:\n        resultarray = []\n        nanlessarray = []\n        for x in a:\n            for i in x:\n                if not ivy.isnan(i):\n                    nanlessarray.append(i)\n        for i in q:\n            resultarray.append(_cpercentile(nanlessarray, i))\n        return resultarray\n    elif axis == 1:\n        resultarray = []\n        nanlessarrayofarrays = []\n        for i in a:\n            nanlessarray = []\n            for t in i:\n                if not ivy.isnan(t):\n                    nanlessarray.append(t)\n            nanlessarrayofarrays.append(nanlessarray)\n        for i in q:\n            arrayofpercentiles = []\n            for ii in nanlessarrayofarrays:\n                arrayofpercentiles.append(_cpercentile(ii, i))\n            resultarray.append(arrayofpercentiles)\n        return resultarray\n    elif axis == 0:\n        resultarray = []\n        try:\n            a = ivy.swapaxes(a, 0, 1)\n        except ivy.utils.exceptions.IvyError:\n            ivy.logging.warning(\"axis is 0 but couldn't swap\")\n        finally:\n            nanlessarrayofarrays = []\n            for i in a:\n                nanlessarray = []\n                for t in i:\n                    if not ivy.isnan(t):\n                        nanlessarray.append(t)\n                nanlessarrayofarrays.append(nanlessarray)\n            for i in q:\n                arrayofpercentiles = []\n                for ii in nanlessarrayofarrays:\n                    arrayofpercentiles.append(_cpercentile(ii, i))\n                resultarray.append(arrayofpercentiles)\n        return resultarray"
        ]
    },
    {
        "func_name": "ptp",
        "original": "@to_ivy_arrays_and_back\n@handle_numpy_out\ndef ptp(a, axis=None, out=None, keepdims=False):\n    x = ivy.max(a, axis=axis, keepdims=keepdims)\n    y = ivy.min(a, axis=axis, keepdims=keepdims)\n    ret = ivy.subtract(x, y)\n    return ret.astype(a.dtype, copy=False)",
        "mutated": [
            "@to_ivy_arrays_and_back\n@handle_numpy_out\ndef ptp(a, axis=None, out=None, keepdims=False):\n    if False:\n        i = 10\n    x = ivy.max(a, axis=axis, keepdims=keepdims)\n    y = ivy.min(a, axis=axis, keepdims=keepdims)\n    ret = ivy.subtract(x, y)\n    return ret.astype(a.dtype, copy=False)",
            "@to_ivy_arrays_and_back\n@handle_numpy_out\ndef ptp(a, axis=None, out=None, keepdims=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    x = ivy.max(a, axis=axis, keepdims=keepdims)\n    y = ivy.min(a, axis=axis, keepdims=keepdims)\n    ret = ivy.subtract(x, y)\n    return ret.astype(a.dtype, copy=False)",
            "@to_ivy_arrays_and_back\n@handle_numpy_out\ndef ptp(a, axis=None, out=None, keepdims=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    x = ivy.max(a, axis=axis, keepdims=keepdims)\n    y = ivy.min(a, axis=axis, keepdims=keepdims)\n    ret = ivy.subtract(x, y)\n    return ret.astype(a.dtype, copy=False)",
            "@to_ivy_arrays_and_back\n@handle_numpy_out\ndef ptp(a, axis=None, out=None, keepdims=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    x = ivy.max(a, axis=axis, keepdims=keepdims)\n    y = ivy.min(a, axis=axis, keepdims=keepdims)\n    ret = ivy.subtract(x, y)\n    return ret.astype(a.dtype, copy=False)",
            "@to_ivy_arrays_and_back\n@handle_numpy_out\ndef ptp(a, axis=None, out=None, keepdims=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    x = ivy.max(a, axis=axis, keepdims=keepdims)\n    y = ivy.min(a, axis=axis, keepdims=keepdims)\n    ret = ivy.subtract(x, y)\n    return ret.astype(a.dtype, copy=False)"
        ]
    }
]