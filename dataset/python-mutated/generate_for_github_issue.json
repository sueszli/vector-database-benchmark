[
    {
        "func_name": "run_command",
        "original": "def run_command(command):\n    subprocess.run(command, shell=True)",
        "mutated": [
            "def run_command(command):\n    if False:\n        i = 10\n    subprocess.run(command, shell=True)",
            "def run_command(command):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    subprocess.run(command, shell=True)",
            "def run_command(command):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    subprocess.run(command, shell=True)",
            "def run_command(command):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    subprocess.run(command, shell=True)",
            "def run_command(command):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    subprocess.run(command, shell=True)"
        ]
    },
    {
        "func_name": "extract_prompts",
        "original": "def extract_prompts(markdown_dict):\n    prompts = []\n    for (key, value) in markdown_dict.items():\n        if key == 'prompt':\n            prompts.append(value)\n        elif isinstance(value, (dict, OrderedDict)):\n            prompts.extend(extract_prompts(value))\n    return prompts",
        "mutated": [
            "def extract_prompts(markdown_dict):\n    if False:\n        i = 10\n    prompts = []\n    for (key, value) in markdown_dict.items():\n        if key == 'prompt':\n            prompts.append(value)\n        elif isinstance(value, (dict, OrderedDict)):\n            prompts.extend(extract_prompts(value))\n    return prompts",
            "def extract_prompts(markdown_dict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    prompts = []\n    for (key, value) in markdown_dict.items():\n        if key == 'prompt':\n            prompts.append(value)\n        elif isinstance(value, (dict, OrderedDict)):\n            prompts.extend(extract_prompts(value))\n    return prompts",
            "def extract_prompts(markdown_dict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    prompts = []\n    for (key, value) in markdown_dict.items():\n        if key == 'prompt':\n            prompts.append(value)\n        elif isinstance(value, (dict, OrderedDict)):\n            prompts.extend(extract_prompts(value))\n    return prompts",
            "def extract_prompts(markdown_dict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    prompts = []\n    for (key, value) in markdown_dict.items():\n        if key == 'prompt':\n            prompts.append(value)\n        elif isinstance(value, (dict, OrderedDict)):\n            prompts.extend(extract_prompts(value))\n    return prompts",
            "def extract_prompts(markdown_dict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    prompts = []\n    for (key, value) in markdown_dict.items():\n        if key == 'prompt':\n            prompts.append(value)\n        elif isinstance(value, (dict, OrderedDict)):\n            prompts.extend(extract_prompts(value))\n    return prompts"
        ]
    },
    {
        "func_name": "extract_urls",
        "original": "def extract_urls(markdown_dict):\n    urls = []\n    for (key, value) in markdown_dict.items():\n        if key == 'urls':\n            urls.extend(value)\n        elif isinstance(value, (dict, OrderedDict)):\n            urls.extend(extract_urls(value))\n    return urls",
        "mutated": [
            "def extract_urls(markdown_dict):\n    if False:\n        i = 10\n    urls = []\n    for (key, value) in markdown_dict.items():\n        if key == 'urls':\n            urls.extend(value)\n        elif isinstance(value, (dict, OrderedDict)):\n            urls.extend(extract_urls(value))\n    return urls",
            "def extract_urls(markdown_dict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    urls = []\n    for (key, value) in markdown_dict.items():\n        if key == 'urls':\n            urls.extend(value)\n        elif isinstance(value, (dict, OrderedDict)):\n            urls.extend(extract_urls(value))\n    return urls",
            "def extract_urls(markdown_dict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    urls = []\n    for (key, value) in markdown_dict.items():\n        if key == 'urls':\n            urls.extend(value)\n        elif isinstance(value, (dict, OrderedDict)):\n            urls.extend(extract_urls(value))\n    return urls",
            "def extract_urls(markdown_dict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    urls = []\n    for (key, value) in markdown_dict.items():\n        if key == 'urls':\n            urls.extend(value)\n        elif isinstance(value, (dict, OrderedDict)):\n            urls.extend(extract_urls(value))\n    return urls",
            "def extract_urls(markdown_dict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    urls = []\n    for (key, value) in markdown_dict.items():\n        if key == 'urls':\n            urls.extend(value)\n        elif isinstance(value, (dict, OrderedDict)):\n            urls.extend(extract_urls(value))\n    return urls"
        ]
    },
    {
        "func_name": "get_all_docs_urls",
        "original": "def get_all_docs_urls(markdown_dict):\n\n    def extract_urls(markdown_dict):\n        urls = []\n        for (key, value) in markdown_dict.items():\n            if key == 'urls':\n                urls.extend(value)\n            elif isinstance(value, (dict, OrderedDict)):\n                urls.extend(extract_urls(value))\n        return urls\n    all_urls = extract_urls(markdown_dict)\n    return unique_urls(all_urls)",
        "mutated": [
            "def get_all_docs_urls(markdown_dict):\n    if False:\n        i = 10\n\n    def extract_urls(markdown_dict):\n        urls = []\n        for (key, value) in markdown_dict.items():\n            if key == 'urls':\n                urls.extend(value)\n            elif isinstance(value, (dict, OrderedDict)):\n                urls.extend(extract_urls(value))\n        return urls\n    all_urls = extract_urls(markdown_dict)\n    return unique_urls(all_urls)",
            "def get_all_docs_urls(markdown_dict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    def extract_urls(markdown_dict):\n        urls = []\n        for (key, value) in markdown_dict.items():\n            if key == 'urls':\n                urls.extend(value)\n            elif isinstance(value, (dict, OrderedDict)):\n                urls.extend(extract_urls(value))\n        return urls\n    all_urls = extract_urls(markdown_dict)\n    return unique_urls(all_urls)",
            "def get_all_docs_urls(markdown_dict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    def extract_urls(markdown_dict):\n        urls = []\n        for (key, value) in markdown_dict.items():\n            if key == 'urls':\n                urls.extend(value)\n            elif isinstance(value, (dict, OrderedDict)):\n                urls.extend(extract_urls(value))\n        return urls\n    all_urls = extract_urls(markdown_dict)\n    return unique_urls(all_urls)",
            "def get_all_docs_urls(markdown_dict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    def extract_urls(markdown_dict):\n        urls = []\n        for (key, value) in markdown_dict.items():\n            if key == 'urls':\n                urls.extend(value)\n            elif isinstance(value, (dict, OrderedDict)):\n                urls.extend(extract_urls(value))\n        return urls\n    all_urls = extract_urls(markdown_dict)\n    return unique_urls(all_urls)",
            "def get_all_docs_urls(markdown_dict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    def extract_urls(markdown_dict):\n        urls = []\n        for (key, value) in markdown_dict.items():\n            if key == 'urls':\n                urls.extend(value)\n            elif isinstance(value, (dict, OrderedDict)):\n                urls.extend(extract_urls(value))\n        return urls\n    all_urls = extract_urls(markdown_dict)\n    return unique_urls(all_urls)"
        ]
    },
    {
        "func_name": "unique_urls",
        "original": "def unique_urls(urls):\n    return list(set([url.split('#')[0] for url in urls]))",
        "mutated": [
            "def unique_urls(urls):\n    if False:\n        i = 10\n    return list(set([url.split('#')[0] for url in urls]))",
            "def unique_urls(urls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return list(set([url.split('#')[0] for url in urls]))",
            "def unique_urls(urls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return list(set([url.split('#')[0] for url in urls]))",
            "def unique_urls(urls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return list(set([url.split('#')[0] for url in urls]))",
            "def unique_urls(urls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return list(set([url.split('#')[0] for url in urls]))"
        ]
    },
    {
        "func_name": "generate_app_file_prompt",
        "original": "def generate_app_file_prompt(requirements, app_file_content):\n    if app_file_content:\n        return f'Given the existing app file and the requirements below, generate an app file that provides propDefinitions and methods that solve the requirements:\\n## EXISTING APP FILE CODE\\n\\n{requirements}\\n\\n## REQUIREMENTS\\n\\n{app_file_content}'\n    return f'Generate an app file that provides propDefinitions and methods that solve the following requirements:\\n\\n{requirements}'",
        "mutated": [
            "def generate_app_file_prompt(requirements, app_file_content):\n    if False:\n        i = 10\n    if app_file_content:\n        return f'Given the existing app file and the requirements below, generate an app file that provides propDefinitions and methods that solve the requirements:\\n## EXISTING APP FILE CODE\\n\\n{requirements}\\n\\n## REQUIREMENTS\\n\\n{app_file_content}'\n    return f'Generate an app file that provides propDefinitions and methods that solve the following requirements:\\n\\n{requirements}'",
            "def generate_app_file_prompt(requirements, app_file_content):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if app_file_content:\n        return f'Given the existing app file and the requirements below, generate an app file that provides propDefinitions and methods that solve the requirements:\\n## EXISTING APP FILE CODE\\n\\n{requirements}\\n\\n## REQUIREMENTS\\n\\n{app_file_content}'\n    return f'Generate an app file that provides propDefinitions and methods that solve the following requirements:\\n\\n{requirements}'",
            "def generate_app_file_prompt(requirements, app_file_content):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if app_file_content:\n        return f'Given the existing app file and the requirements below, generate an app file that provides propDefinitions and methods that solve the requirements:\\n## EXISTING APP FILE CODE\\n\\n{requirements}\\n\\n## REQUIREMENTS\\n\\n{app_file_content}'\n    return f'Generate an app file that provides propDefinitions and methods that solve the following requirements:\\n\\n{requirements}'",
            "def generate_app_file_prompt(requirements, app_file_content):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if app_file_content:\n        return f'Given the existing app file and the requirements below, generate an app file that provides propDefinitions and methods that solve the requirements:\\n## EXISTING APP FILE CODE\\n\\n{requirements}\\n\\n## REQUIREMENTS\\n\\n{app_file_content}'\n    return f'Generate an app file that provides propDefinitions and methods that solve the following requirements:\\n\\n{requirements}'",
            "def generate_app_file_prompt(requirements, app_file_content):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if app_file_content:\n        return f'Given the existing app file and the requirements below, generate an app file that provides propDefinitions and methods that solve the requirements:\\n## EXISTING APP FILE CODE\\n\\n{requirements}\\n\\n## REQUIREMENTS\\n\\n{app_file_content}'\n    return f'Generate an app file that provides propDefinitions and methods that solve the following requirements:\\n\\n{requirements}'"
        ]
    },
    {
        "func_name": "generate",
        "original": "def generate(issue_number, output_dir, generate_pr=True, clean=False, verbose=False, tries=3, remote_name='origin'):\n    repo_path = os.path.abspath(os.path.join('..', '..'))\n    output_dir = os.path.abspath(output_dir)\n    if generate_pr:\n        output_dir = os.path.join(repo_path, 'components')\n        repo = git.Repo(repo_path)\n        if not clean and repo.index.diff(None):\n            logger.warn('Your git stage is not clean. Please stash/commit your changes or use --clean to discard them')\n            return\n        branch_name = f'issue-{issue_number}'\n        run_command(f'git fetch {remote_name}')\n        if any((reference.name == branch_name for reference in repo.references)):\n            run_command(f'git checkout {branch_name}')\n        else:\n            run_command(f'git checkout -b {branch_name}')\n        run_command(f'git reset --hard {remote_name}/master')\n    md = requests.get(f'https://api.github.com/repos/PipedreamHQ/pipedream/issues/{issue_number}').json()['body'].lower()\n    markdown = markdown_to_json.dictify(md)\n    app = list(markdown.keys())[0]\n    global_urls = []\n    requirements = []\n    app_base_path = os.path.join(output_dir, app)\n    file_path = os.path.join(app_base_path, f'{app}.app.mjs')\n    os.makedirs(os.path.dirname(file_path), exist_ok=True)\n    app_file_content = None\n    if os.path.exists(file_path):\n        with open(file_path, 'r') as f:\n            logger.debug('Reading existing app file')\n            app_file_content = f.read()\n    else:\n        logger.debug('No existing app file found, creating new one')\n    app_file_instructions = generate_app_file_prompt('\\n\\n'.join(extract_prompts(markdown)), app_file_content)\n    all_docs_urls = get_all_docs_urls(markdown)\n    logger.debug('Generating app file')\n    app_file_content = main('app', app, instructions=app_file_instructions, tries=tries, urls=all_docs_urls, verbose=verbose)\n    with open(file_path, 'w') as f:\n        logger.debug('Writing app file')\n        f.write(app_file_content)\n    for h2_header in markdown[app]:\n        if h2_header == 'urls':\n            global_urls += markdown[app][h2_header]\n            continue\n        for component_key in markdown[app][h2_header]:\n            component_data = markdown[app][h2_header][component_key]\n            instructions = f\"### Requirements\\n\\n{component_data['prompt']}\\n\\n### Use methods and propDefinitions from this app file\\n\\nUse the methods and propDefinitions in this app file to solve the requirements:\\n\\n{app_file_content}\\n\\nYou can call methods from the app file using `this.{app}.<method name>`. Think about it: you've already defined props and methods in the app file, so you should use these to promote code reuse.\\n\\n\"\n            urls = component_data.get('urls')\n            if not urls:\n                urls = []\n                logger.warn(f'No API docs URLs found for {component_key}')\n            if 'source' in h2_header:\n                component_type = 'webhook_source' if 'webhook' in h2_header else 'polling_source'\n            elif 'action' in h2_header:\n                component_type = 'action'\n            else:\n                continue\n            requirements.append({'type': component_type, 'key': component_key, 'instructions': f'The component key is {app}-{component_key}. {instructions}', 'urls': unique_urls(global_urls + urls)})\n    for component in requirements:\n        logger.info(f\"generating {component['key']}...\")\n        result = main(component['type'], app, component['instructions'], tries=tries, urls=component['urls'], verbose=verbose)\n        component_type = 'sources' if 'source' in component['type'] else 'actions'\n        file_path = f\"{output_dir}/{app}/{component_type}/{component['key']}/{component['key']}.mjs\"\n        logger.info(f'writing output to {file_path}')\n        os.makedirs(os.path.dirname(file_path), exist_ok=True)\n        with open(file_path, 'w') as f:\n            f.write(result)\n    if generate_pr:\n        run_command(f'npx eslint {app_base_path} --fix')\n        run_command(f'git add -f {app_base_path}')\n        run_command(f\"git commit --no-verify -m '{app} init'\")\n        run_command(f'git push -f --no-verify --set-upstream {remote_name} {branch_name}')\n        run_command(f\"gh pr create -d -l ai-assisted -t 'New Components - {app}' -b 'Resolves #{issue_number}.'\")",
        "mutated": [
            "def generate(issue_number, output_dir, generate_pr=True, clean=False, verbose=False, tries=3, remote_name='origin'):\n    if False:\n        i = 10\n    repo_path = os.path.abspath(os.path.join('..', '..'))\n    output_dir = os.path.abspath(output_dir)\n    if generate_pr:\n        output_dir = os.path.join(repo_path, 'components')\n        repo = git.Repo(repo_path)\n        if not clean and repo.index.diff(None):\n            logger.warn('Your git stage is not clean. Please stash/commit your changes or use --clean to discard them')\n            return\n        branch_name = f'issue-{issue_number}'\n        run_command(f'git fetch {remote_name}')\n        if any((reference.name == branch_name for reference in repo.references)):\n            run_command(f'git checkout {branch_name}')\n        else:\n            run_command(f'git checkout -b {branch_name}')\n        run_command(f'git reset --hard {remote_name}/master')\n    md = requests.get(f'https://api.github.com/repos/PipedreamHQ/pipedream/issues/{issue_number}').json()['body'].lower()\n    markdown = markdown_to_json.dictify(md)\n    app = list(markdown.keys())[0]\n    global_urls = []\n    requirements = []\n    app_base_path = os.path.join(output_dir, app)\n    file_path = os.path.join(app_base_path, f'{app}.app.mjs')\n    os.makedirs(os.path.dirname(file_path), exist_ok=True)\n    app_file_content = None\n    if os.path.exists(file_path):\n        with open(file_path, 'r') as f:\n            logger.debug('Reading existing app file')\n            app_file_content = f.read()\n    else:\n        logger.debug('No existing app file found, creating new one')\n    app_file_instructions = generate_app_file_prompt('\\n\\n'.join(extract_prompts(markdown)), app_file_content)\n    all_docs_urls = get_all_docs_urls(markdown)\n    logger.debug('Generating app file')\n    app_file_content = main('app', app, instructions=app_file_instructions, tries=tries, urls=all_docs_urls, verbose=verbose)\n    with open(file_path, 'w') as f:\n        logger.debug('Writing app file')\n        f.write(app_file_content)\n    for h2_header in markdown[app]:\n        if h2_header == 'urls':\n            global_urls += markdown[app][h2_header]\n            continue\n        for component_key in markdown[app][h2_header]:\n            component_data = markdown[app][h2_header][component_key]\n            instructions = f\"### Requirements\\n\\n{component_data['prompt']}\\n\\n### Use methods and propDefinitions from this app file\\n\\nUse the methods and propDefinitions in this app file to solve the requirements:\\n\\n{app_file_content}\\n\\nYou can call methods from the app file using `this.{app}.<method name>`. Think about it: you've already defined props and methods in the app file, so you should use these to promote code reuse.\\n\\n\"\n            urls = component_data.get('urls')\n            if not urls:\n                urls = []\n                logger.warn(f'No API docs URLs found for {component_key}')\n            if 'source' in h2_header:\n                component_type = 'webhook_source' if 'webhook' in h2_header else 'polling_source'\n            elif 'action' in h2_header:\n                component_type = 'action'\n            else:\n                continue\n            requirements.append({'type': component_type, 'key': component_key, 'instructions': f'The component key is {app}-{component_key}. {instructions}', 'urls': unique_urls(global_urls + urls)})\n    for component in requirements:\n        logger.info(f\"generating {component['key']}...\")\n        result = main(component['type'], app, component['instructions'], tries=tries, urls=component['urls'], verbose=verbose)\n        component_type = 'sources' if 'source' in component['type'] else 'actions'\n        file_path = f\"{output_dir}/{app}/{component_type}/{component['key']}/{component['key']}.mjs\"\n        logger.info(f'writing output to {file_path}')\n        os.makedirs(os.path.dirname(file_path), exist_ok=True)\n        with open(file_path, 'w') as f:\n            f.write(result)\n    if generate_pr:\n        run_command(f'npx eslint {app_base_path} --fix')\n        run_command(f'git add -f {app_base_path}')\n        run_command(f\"git commit --no-verify -m '{app} init'\")\n        run_command(f'git push -f --no-verify --set-upstream {remote_name} {branch_name}')\n        run_command(f\"gh pr create -d -l ai-assisted -t 'New Components - {app}' -b 'Resolves #{issue_number}.'\")",
            "def generate(issue_number, output_dir, generate_pr=True, clean=False, verbose=False, tries=3, remote_name='origin'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    repo_path = os.path.abspath(os.path.join('..', '..'))\n    output_dir = os.path.abspath(output_dir)\n    if generate_pr:\n        output_dir = os.path.join(repo_path, 'components')\n        repo = git.Repo(repo_path)\n        if not clean and repo.index.diff(None):\n            logger.warn('Your git stage is not clean. Please stash/commit your changes or use --clean to discard them')\n            return\n        branch_name = f'issue-{issue_number}'\n        run_command(f'git fetch {remote_name}')\n        if any((reference.name == branch_name for reference in repo.references)):\n            run_command(f'git checkout {branch_name}')\n        else:\n            run_command(f'git checkout -b {branch_name}')\n        run_command(f'git reset --hard {remote_name}/master')\n    md = requests.get(f'https://api.github.com/repos/PipedreamHQ/pipedream/issues/{issue_number}').json()['body'].lower()\n    markdown = markdown_to_json.dictify(md)\n    app = list(markdown.keys())[0]\n    global_urls = []\n    requirements = []\n    app_base_path = os.path.join(output_dir, app)\n    file_path = os.path.join(app_base_path, f'{app}.app.mjs')\n    os.makedirs(os.path.dirname(file_path), exist_ok=True)\n    app_file_content = None\n    if os.path.exists(file_path):\n        with open(file_path, 'r') as f:\n            logger.debug('Reading existing app file')\n            app_file_content = f.read()\n    else:\n        logger.debug('No existing app file found, creating new one')\n    app_file_instructions = generate_app_file_prompt('\\n\\n'.join(extract_prompts(markdown)), app_file_content)\n    all_docs_urls = get_all_docs_urls(markdown)\n    logger.debug('Generating app file')\n    app_file_content = main('app', app, instructions=app_file_instructions, tries=tries, urls=all_docs_urls, verbose=verbose)\n    with open(file_path, 'w') as f:\n        logger.debug('Writing app file')\n        f.write(app_file_content)\n    for h2_header in markdown[app]:\n        if h2_header == 'urls':\n            global_urls += markdown[app][h2_header]\n            continue\n        for component_key in markdown[app][h2_header]:\n            component_data = markdown[app][h2_header][component_key]\n            instructions = f\"### Requirements\\n\\n{component_data['prompt']}\\n\\n### Use methods and propDefinitions from this app file\\n\\nUse the methods and propDefinitions in this app file to solve the requirements:\\n\\n{app_file_content}\\n\\nYou can call methods from the app file using `this.{app}.<method name>`. Think about it: you've already defined props and methods in the app file, so you should use these to promote code reuse.\\n\\n\"\n            urls = component_data.get('urls')\n            if not urls:\n                urls = []\n                logger.warn(f'No API docs URLs found for {component_key}')\n            if 'source' in h2_header:\n                component_type = 'webhook_source' if 'webhook' in h2_header else 'polling_source'\n            elif 'action' in h2_header:\n                component_type = 'action'\n            else:\n                continue\n            requirements.append({'type': component_type, 'key': component_key, 'instructions': f'The component key is {app}-{component_key}. {instructions}', 'urls': unique_urls(global_urls + urls)})\n    for component in requirements:\n        logger.info(f\"generating {component['key']}...\")\n        result = main(component['type'], app, component['instructions'], tries=tries, urls=component['urls'], verbose=verbose)\n        component_type = 'sources' if 'source' in component['type'] else 'actions'\n        file_path = f\"{output_dir}/{app}/{component_type}/{component['key']}/{component['key']}.mjs\"\n        logger.info(f'writing output to {file_path}')\n        os.makedirs(os.path.dirname(file_path), exist_ok=True)\n        with open(file_path, 'w') as f:\n            f.write(result)\n    if generate_pr:\n        run_command(f'npx eslint {app_base_path} --fix')\n        run_command(f'git add -f {app_base_path}')\n        run_command(f\"git commit --no-verify -m '{app} init'\")\n        run_command(f'git push -f --no-verify --set-upstream {remote_name} {branch_name}')\n        run_command(f\"gh pr create -d -l ai-assisted -t 'New Components - {app}' -b 'Resolves #{issue_number}.'\")",
            "def generate(issue_number, output_dir, generate_pr=True, clean=False, verbose=False, tries=3, remote_name='origin'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    repo_path = os.path.abspath(os.path.join('..', '..'))\n    output_dir = os.path.abspath(output_dir)\n    if generate_pr:\n        output_dir = os.path.join(repo_path, 'components')\n        repo = git.Repo(repo_path)\n        if not clean and repo.index.diff(None):\n            logger.warn('Your git stage is not clean. Please stash/commit your changes or use --clean to discard them')\n            return\n        branch_name = f'issue-{issue_number}'\n        run_command(f'git fetch {remote_name}')\n        if any((reference.name == branch_name for reference in repo.references)):\n            run_command(f'git checkout {branch_name}')\n        else:\n            run_command(f'git checkout -b {branch_name}')\n        run_command(f'git reset --hard {remote_name}/master')\n    md = requests.get(f'https://api.github.com/repos/PipedreamHQ/pipedream/issues/{issue_number}').json()['body'].lower()\n    markdown = markdown_to_json.dictify(md)\n    app = list(markdown.keys())[0]\n    global_urls = []\n    requirements = []\n    app_base_path = os.path.join(output_dir, app)\n    file_path = os.path.join(app_base_path, f'{app}.app.mjs')\n    os.makedirs(os.path.dirname(file_path), exist_ok=True)\n    app_file_content = None\n    if os.path.exists(file_path):\n        with open(file_path, 'r') as f:\n            logger.debug('Reading existing app file')\n            app_file_content = f.read()\n    else:\n        logger.debug('No existing app file found, creating new one')\n    app_file_instructions = generate_app_file_prompt('\\n\\n'.join(extract_prompts(markdown)), app_file_content)\n    all_docs_urls = get_all_docs_urls(markdown)\n    logger.debug('Generating app file')\n    app_file_content = main('app', app, instructions=app_file_instructions, tries=tries, urls=all_docs_urls, verbose=verbose)\n    with open(file_path, 'w') as f:\n        logger.debug('Writing app file')\n        f.write(app_file_content)\n    for h2_header in markdown[app]:\n        if h2_header == 'urls':\n            global_urls += markdown[app][h2_header]\n            continue\n        for component_key in markdown[app][h2_header]:\n            component_data = markdown[app][h2_header][component_key]\n            instructions = f\"### Requirements\\n\\n{component_data['prompt']}\\n\\n### Use methods and propDefinitions from this app file\\n\\nUse the methods and propDefinitions in this app file to solve the requirements:\\n\\n{app_file_content}\\n\\nYou can call methods from the app file using `this.{app}.<method name>`. Think about it: you've already defined props and methods in the app file, so you should use these to promote code reuse.\\n\\n\"\n            urls = component_data.get('urls')\n            if not urls:\n                urls = []\n                logger.warn(f'No API docs URLs found for {component_key}')\n            if 'source' in h2_header:\n                component_type = 'webhook_source' if 'webhook' in h2_header else 'polling_source'\n            elif 'action' in h2_header:\n                component_type = 'action'\n            else:\n                continue\n            requirements.append({'type': component_type, 'key': component_key, 'instructions': f'The component key is {app}-{component_key}. {instructions}', 'urls': unique_urls(global_urls + urls)})\n    for component in requirements:\n        logger.info(f\"generating {component['key']}...\")\n        result = main(component['type'], app, component['instructions'], tries=tries, urls=component['urls'], verbose=verbose)\n        component_type = 'sources' if 'source' in component['type'] else 'actions'\n        file_path = f\"{output_dir}/{app}/{component_type}/{component['key']}/{component['key']}.mjs\"\n        logger.info(f'writing output to {file_path}')\n        os.makedirs(os.path.dirname(file_path), exist_ok=True)\n        with open(file_path, 'w') as f:\n            f.write(result)\n    if generate_pr:\n        run_command(f'npx eslint {app_base_path} --fix')\n        run_command(f'git add -f {app_base_path}')\n        run_command(f\"git commit --no-verify -m '{app} init'\")\n        run_command(f'git push -f --no-verify --set-upstream {remote_name} {branch_name}')\n        run_command(f\"gh pr create -d -l ai-assisted -t 'New Components - {app}' -b 'Resolves #{issue_number}.'\")",
            "def generate(issue_number, output_dir, generate_pr=True, clean=False, verbose=False, tries=3, remote_name='origin'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    repo_path = os.path.abspath(os.path.join('..', '..'))\n    output_dir = os.path.abspath(output_dir)\n    if generate_pr:\n        output_dir = os.path.join(repo_path, 'components')\n        repo = git.Repo(repo_path)\n        if not clean and repo.index.diff(None):\n            logger.warn('Your git stage is not clean. Please stash/commit your changes or use --clean to discard them')\n            return\n        branch_name = f'issue-{issue_number}'\n        run_command(f'git fetch {remote_name}')\n        if any((reference.name == branch_name for reference in repo.references)):\n            run_command(f'git checkout {branch_name}')\n        else:\n            run_command(f'git checkout -b {branch_name}')\n        run_command(f'git reset --hard {remote_name}/master')\n    md = requests.get(f'https://api.github.com/repos/PipedreamHQ/pipedream/issues/{issue_number}').json()['body'].lower()\n    markdown = markdown_to_json.dictify(md)\n    app = list(markdown.keys())[0]\n    global_urls = []\n    requirements = []\n    app_base_path = os.path.join(output_dir, app)\n    file_path = os.path.join(app_base_path, f'{app}.app.mjs')\n    os.makedirs(os.path.dirname(file_path), exist_ok=True)\n    app_file_content = None\n    if os.path.exists(file_path):\n        with open(file_path, 'r') as f:\n            logger.debug('Reading existing app file')\n            app_file_content = f.read()\n    else:\n        logger.debug('No existing app file found, creating new one')\n    app_file_instructions = generate_app_file_prompt('\\n\\n'.join(extract_prompts(markdown)), app_file_content)\n    all_docs_urls = get_all_docs_urls(markdown)\n    logger.debug('Generating app file')\n    app_file_content = main('app', app, instructions=app_file_instructions, tries=tries, urls=all_docs_urls, verbose=verbose)\n    with open(file_path, 'w') as f:\n        logger.debug('Writing app file')\n        f.write(app_file_content)\n    for h2_header in markdown[app]:\n        if h2_header == 'urls':\n            global_urls += markdown[app][h2_header]\n            continue\n        for component_key in markdown[app][h2_header]:\n            component_data = markdown[app][h2_header][component_key]\n            instructions = f\"### Requirements\\n\\n{component_data['prompt']}\\n\\n### Use methods and propDefinitions from this app file\\n\\nUse the methods and propDefinitions in this app file to solve the requirements:\\n\\n{app_file_content}\\n\\nYou can call methods from the app file using `this.{app}.<method name>`. Think about it: you've already defined props and methods in the app file, so you should use these to promote code reuse.\\n\\n\"\n            urls = component_data.get('urls')\n            if not urls:\n                urls = []\n                logger.warn(f'No API docs URLs found for {component_key}')\n            if 'source' in h2_header:\n                component_type = 'webhook_source' if 'webhook' in h2_header else 'polling_source'\n            elif 'action' in h2_header:\n                component_type = 'action'\n            else:\n                continue\n            requirements.append({'type': component_type, 'key': component_key, 'instructions': f'The component key is {app}-{component_key}. {instructions}', 'urls': unique_urls(global_urls + urls)})\n    for component in requirements:\n        logger.info(f\"generating {component['key']}...\")\n        result = main(component['type'], app, component['instructions'], tries=tries, urls=component['urls'], verbose=verbose)\n        component_type = 'sources' if 'source' in component['type'] else 'actions'\n        file_path = f\"{output_dir}/{app}/{component_type}/{component['key']}/{component['key']}.mjs\"\n        logger.info(f'writing output to {file_path}')\n        os.makedirs(os.path.dirname(file_path), exist_ok=True)\n        with open(file_path, 'w') as f:\n            f.write(result)\n    if generate_pr:\n        run_command(f'npx eslint {app_base_path} --fix')\n        run_command(f'git add -f {app_base_path}')\n        run_command(f\"git commit --no-verify -m '{app} init'\")\n        run_command(f'git push -f --no-verify --set-upstream {remote_name} {branch_name}')\n        run_command(f\"gh pr create -d -l ai-assisted -t 'New Components - {app}' -b 'Resolves #{issue_number}.'\")",
            "def generate(issue_number, output_dir, generate_pr=True, clean=False, verbose=False, tries=3, remote_name='origin'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    repo_path = os.path.abspath(os.path.join('..', '..'))\n    output_dir = os.path.abspath(output_dir)\n    if generate_pr:\n        output_dir = os.path.join(repo_path, 'components')\n        repo = git.Repo(repo_path)\n        if not clean and repo.index.diff(None):\n            logger.warn('Your git stage is not clean. Please stash/commit your changes or use --clean to discard them')\n            return\n        branch_name = f'issue-{issue_number}'\n        run_command(f'git fetch {remote_name}')\n        if any((reference.name == branch_name for reference in repo.references)):\n            run_command(f'git checkout {branch_name}')\n        else:\n            run_command(f'git checkout -b {branch_name}')\n        run_command(f'git reset --hard {remote_name}/master')\n    md = requests.get(f'https://api.github.com/repos/PipedreamHQ/pipedream/issues/{issue_number}').json()['body'].lower()\n    markdown = markdown_to_json.dictify(md)\n    app = list(markdown.keys())[0]\n    global_urls = []\n    requirements = []\n    app_base_path = os.path.join(output_dir, app)\n    file_path = os.path.join(app_base_path, f'{app}.app.mjs')\n    os.makedirs(os.path.dirname(file_path), exist_ok=True)\n    app_file_content = None\n    if os.path.exists(file_path):\n        with open(file_path, 'r') as f:\n            logger.debug('Reading existing app file')\n            app_file_content = f.read()\n    else:\n        logger.debug('No existing app file found, creating new one')\n    app_file_instructions = generate_app_file_prompt('\\n\\n'.join(extract_prompts(markdown)), app_file_content)\n    all_docs_urls = get_all_docs_urls(markdown)\n    logger.debug('Generating app file')\n    app_file_content = main('app', app, instructions=app_file_instructions, tries=tries, urls=all_docs_urls, verbose=verbose)\n    with open(file_path, 'w') as f:\n        logger.debug('Writing app file')\n        f.write(app_file_content)\n    for h2_header in markdown[app]:\n        if h2_header == 'urls':\n            global_urls += markdown[app][h2_header]\n            continue\n        for component_key in markdown[app][h2_header]:\n            component_data = markdown[app][h2_header][component_key]\n            instructions = f\"### Requirements\\n\\n{component_data['prompt']}\\n\\n### Use methods and propDefinitions from this app file\\n\\nUse the methods and propDefinitions in this app file to solve the requirements:\\n\\n{app_file_content}\\n\\nYou can call methods from the app file using `this.{app}.<method name>`. Think about it: you've already defined props and methods in the app file, so you should use these to promote code reuse.\\n\\n\"\n            urls = component_data.get('urls')\n            if not urls:\n                urls = []\n                logger.warn(f'No API docs URLs found for {component_key}')\n            if 'source' in h2_header:\n                component_type = 'webhook_source' if 'webhook' in h2_header else 'polling_source'\n            elif 'action' in h2_header:\n                component_type = 'action'\n            else:\n                continue\n            requirements.append({'type': component_type, 'key': component_key, 'instructions': f'The component key is {app}-{component_key}. {instructions}', 'urls': unique_urls(global_urls + urls)})\n    for component in requirements:\n        logger.info(f\"generating {component['key']}...\")\n        result = main(component['type'], app, component['instructions'], tries=tries, urls=component['urls'], verbose=verbose)\n        component_type = 'sources' if 'source' in component['type'] else 'actions'\n        file_path = f\"{output_dir}/{app}/{component_type}/{component['key']}/{component['key']}.mjs\"\n        logger.info(f'writing output to {file_path}')\n        os.makedirs(os.path.dirname(file_path), exist_ok=True)\n        with open(file_path, 'w') as f:\n            f.write(result)\n    if generate_pr:\n        run_command(f'npx eslint {app_base_path} --fix')\n        run_command(f'git add -f {app_base_path}')\n        run_command(f\"git commit --no-verify -m '{app} init'\")\n        run_command(f'git push -f --no-verify --set-upstream {remote_name} {branch_name}')\n        run_command(f\"gh pr create -d -l ai-assisted -t 'New Components - {app}' -b 'Resolves #{issue_number}.'\")"
        ]
    }
]