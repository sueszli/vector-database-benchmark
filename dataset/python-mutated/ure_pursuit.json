[
    {
        "func_name": "__init__",
        "original": "def __init__(self, x=0.0, y=0.0, yaw=0.0, v=0.0):\n    self.x = x\n    self.y = y\n    self.yaw = yaw\n    self.v = v\n    self.rear_x = self.x - WB / 2 * math.cos(self.yaw)\n    self.rear_y = self.y - WB / 2 * math.sin(self.yaw)",
        "mutated": [
            "def __init__(self, x=0.0, y=0.0, yaw=0.0, v=0.0):\n    if False:\n        i = 10\n    self.x = x\n    self.y = y\n    self.yaw = yaw\n    self.v = v\n    self.rear_x = self.x - WB / 2 * math.cos(self.yaw)\n    self.rear_y = self.y - WB / 2 * math.sin(self.yaw)",
            "def __init__(self, x=0.0, y=0.0, yaw=0.0, v=0.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.x = x\n    self.y = y\n    self.yaw = yaw\n    self.v = v\n    self.rear_x = self.x - WB / 2 * math.cos(self.yaw)\n    self.rear_y = self.y - WB / 2 * math.sin(self.yaw)",
            "def __init__(self, x=0.0, y=0.0, yaw=0.0, v=0.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.x = x\n    self.y = y\n    self.yaw = yaw\n    self.v = v\n    self.rear_x = self.x - WB / 2 * math.cos(self.yaw)\n    self.rear_y = self.y - WB / 2 * math.sin(self.yaw)",
            "def __init__(self, x=0.0, y=0.0, yaw=0.0, v=0.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.x = x\n    self.y = y\n    self.yaw = yaw\n    self.v = v\n    self.rear_x = self.x - WB / 2 * math.cos(self.yaw)\n    self.rear_y = self.y - WB / 2 * math.sin(self.yaw)",
            "def __init__(self, x=0.0, y=0.0, yaw=0.0, v=0.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.x = x\n    self.y = y\n    self.yaw = yaw\n    self.v = v\n    self.rear_x = self.x - WB / 2 * math.cos(self.yaw)\n    self.rear_y = self.y - WB / 2 * math.sin(self.yaw)"
        ]
    },
    {
        "func_name": "update",
        "original": "def update(self, a, delta):\n    self.x += self.v * math.cos(self.yaw) * dt\n    self.y += self.v * math.sin(self.yaw) * dt\n    self.yaw += self.v / WB * math.tan(delta) * dt\n    self.v += a * dt\n    self.rear_x = self.x - WB / 2 * math.cos(self.yaw)\n    self.rear_y = self.y - WB / 2 * math.sin(self.yaw)",
        "mutated": [
            "def update(self, a, delta):\n    if False:\n        i = 10\n    self.x += self.v * math.cos(self.yaw) * dt\n    self.y += self.v * math.sin(self.yaw) * dt\n    self.yaw += self.v / WB * math.tan(delta) * dt\n    self.v += a * dt\n    self.rear_x = self.x - WB / 2 * math.cos(self.yaw)\n    self.rear_y = self.y - WB / 2 * math.sin(self.yaw)",
            "def update(self, a, delta):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.x += self.v * math.cos(self.yaw) * dt\n    self.y += self.v * math.sin(self.yaw) * dt\n    self.yaw += self.v / WB * math.tan(delta) * dt\n    self.v += a * dt\n    self.rear_x = self.x - WB / 2 * math.cos(self.yaw)\n    self.rear_y = self.y - WB / 2 * math.sin(self.yaw)",
            "def update(self, a, delta):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.x += self.v * math.cos(self.yaw) * dt\n    self.y += self.v * math.sin(self.yaw) * dt\n    self.yaw += self.v / WB * math.tan(delta) * dt\n    self.v += a * dt\n    self.rear_x = self.x - WB / 2 * math.cos(self.yaw)\n    self.rear_y = self.y - WB / 2 * math.sin(self.yaw)",
            "def update(self, a, delta):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.x += self.v * math.cos(self.yaw) * dt\n    self.y += self.v * math.sin(self.yaw) * dt\n    self.yaw += self.v / WB * math.tan(delta) * dt\n    self.v += a * dt\n    self.rear_x = self.x - WB / 2 * math.cos(self.yaw)\n    self.rear_y = self.y - WB / 2 * math.sin(self.yaw)",
            "def update(self, a, delta):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.x += self.v * math.cos(self.yaw) * dt\n    self.y += self.v * math.sin(self.yaw) * dt\n    self.yaw += self.v / WB * math.tan(delta) * dt\n    self.v += a * dt\n    self.rear_x = self.x - WB / 2 * math.cos(self.yaw)\n    self.rear_y = self.y - WB / 2 * math.sin(self.yaw)"
        ]
    },
    {
        "func_name": "calc_distance",
        "original": "def calc_distance(self, point_x, point_y):\n    dx = self.rear_x - point_x\n    dy = self.rear_y - point_y\n    return math.hypot(dx, dy)",
        "mutated": [
            "def calc_distance(self, point_x, point_y):\n    if False:\n        i = 10\n    dx = self.rear_x - point_x\n    dy = self.rear_y - point_y\n    return math.hypot(dx, dy)",
            "def calc_distance(self, point_x, point_y):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    dx = self.rear_x - point_x\n    dy = self.rear_y - point_y\n    return math.hypot(dx, dy)",
            "def calc_distance(self, point_x, point_y):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    dx = self.rear_x - point_x\n    dy = self.rear_y - point_y\n    return math.hypot(dx, dy)",
            "def calc_distance(self, point_x, point_y):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    dx = self.rear_x - point_x\n    dy = self.rear_y - point_y\n    return math.hypot(dx, dy)",
            "def calc_distance(self, point_x, point_y):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    dx = self.rear_x - point_x\n    dy = self.rear_y - point_y\n    return math.hypot(dx, dy)"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self):\n    self.x = []\n    self.y = []\n    self.yaw = []\n    self.v = []\n    self.t = []",
        "mutated": [
            "def __init__(self):\n    if False:\n        i = 10\n    self.x = []\n    self.y = []\n    self.yaw = []\n    self.v = []\n    self.t = []",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.x = []\n    self.y = []\n    self.yaw = []\n    self.v = []\n    self.t = []",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.x = []\n    self.y = []\n    self.yaw = []\n    self.v = []\n    self.t = []",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.x = []\n    self.y = []\n    self.yaw = []\n    self.v = []\n    self.t = []",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.x = []\n    self.y = []\n    self.yaw = []\n    self.v = []\n    self.t = []"
        ]
    },
    {
        "func_name": "append",
        "original": "def append(self, t, state):\n    self.x.append(state.x)\n    self.y.append(state.y)\n    self.yaw.append(state.yaw)\n    self.v.append(state.v)\n    self.t.append(t)",
        "mutated": [
            "def append(self, t, state):\n    if False:\n        i = 10\n    self.x.append(state.x)\n    self.y.append(state.y)\n    self.yaw.append(state.yaw)\n    self.v.append(state.v)\n    self.t.append(t)",
            "def append(self, t, state):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.x.append(state.x)\n    self.y.append(state.y)\n    self.yaw.append(state.yaw)\n    self.v.append(state.v)\n    self.t.append(t)",
            "def append(self, t, state):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.x.append(state.x)\n    self.y.append(state.y)\n    self.yaw.append(state.yaw)\n    self.v.append(state.v)\n    self.t.append(t)",
            "def append(self, t, state):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.x.append(state.x)\n    self.y.append(state.y)\n    self.yaw.append(state.yaw)\n    self.v.append(state.v)\n    self.t.append(t)",
            "def append(self, t, state):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.x.append(state.x)\n    self.y.append(state.y)\n    self.yaw.append(state.yaw)\n    self.v.append(state.v)\n    self.t.append(t)"
        ]
    },
    {
        "func_name": "proportional_control",
        "original": "def proportional_control(target, current):\n    a = Kp * (target - current)\n    return a",
        "mutated": [
            "def proportional_control(target, current):\n    if False:\n        i = 10\n    a = Kp * (target - current)\n    return a",
            "def proportional_control(target, current):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    a = Kp * (target - current)\n    return a",
            "def proportional_control(target, current):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    a = Kp * (target - current)\n    return a",
            "def proportional_control(target, current):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    a = Kp * (target - current)\n    return a",
            "def proportional_control(target, current):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    a = Kp * (target - current)\n    return a"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, cx, cy):\n    self.cx = cx\n    self.cy = cy\n    self.old_nearest_point_index = None",
        "mutated": [
            "def __init__(self, cx, cy):\n    if False:\n        i = 10\n    self.cx = cx\n    self.cy = cy\n    self.old_nearest_point_index = None",
            "def __init__(self, cx, cy):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.cx = cx\n    self.cy = cy\n    self.old_nearest_point_index = None",
            "def __init__(self, cx, cy):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.cx = cx\n    self.cy = cy\n    self.old_nearest_point_index = None",
            "def __init__(self, cx, cy):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.cx = cx\n    self.cy = cy\n    self.old_nearest_point_index = None",
            "def __init__(self, cx, cy):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.cx = cx\n    self.cy = cy\n    self.old_nearest_point_index = None"
        ]
    },
    {
        "func_name": "search_target_index",
        "original": "def search_target_index(self, state):\n    if self.old_nearest_point_index is None:\n        dx = [state.rear_x - icx for icx in self.cx]\n        dy = [state.rear_y - icy for icy in self.cy]\n        d = np.hypot(dx, dy)\n        ind = np.argmin(d)\n        self.old_nearest_point_index = ind\n    else:\n        ind = self.old_nearest_point_index\n        distance_this_index = state.calc_distance(self.cx[ind], self.cy[ind])\n        while True:\n            distance_next_index = state.calc_distance(self.cx[ind + 1], self.cy[ind + 1])\n            if distance_this_index < distance_next_index:\n                break\n            ind = ind + 1 if ind + 1 < len(self.cx) else ind\n            distance_this_index = distance_next_index\n        self.old_nearest_point_index = ind\n    Lf = k * state.v + Lfc\n    while Lf > state.calc_distance(self.cx[ind], self.cy[ind]):\n        if ind + 1 >= len(self.cx):\n            break\n        ind += 1\n    return (ind, Lf)",
        "mutated": [
            "def search_target_index(self, state):\n    if False:\n        i = 10\n    if self.old_nearest_point_index is None:\n        dx = [state.rear_x - icx for icx in self.cx]\n        dy = [state.rear_y - icy for icy in self.cy]\n        d = np.hypot(dx, dy)\n        ind = np.argmin(d)\n        self.old_nearest_point_index = ind\n    else:\n        ind = self.old_nearest_point_index\n        distance_this_index = state.calc_distance(self.cx[ind], self.cy[ind])\n        while True:\n            distance_next_index = state.calc_distance(self.cx[ind + 1], self.cy[ind + 1])\n            if distance_this_index < distance_next_index:\n                break\n            ind = ind + 1 if ind + 1 < len(self.cx) else ind\n            distance_this_index = distance_next_index\n        self.old_nearest_point_index = ind\n    Lf = k * state.v + Lfc\n    while Lf > state.calc_distance(self.cx[ind], self.cy[ind]):\n        if ind + 1 >= len(self.cx):\n            break\n        ind += 1\n    return (ind, Lf)",
            "def search_target_index(self, state):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self.old_nearest_point_index is None:\n        dx = [state.rear_x - icx for icx in self.cx]\n        dy = [state.rear_y - icy for icy in self.cy]\n        d = np.hypot(dx, dy)\n        ind = np.argmin(d)\n        self.old_nearest_point_index = ind\n    else:\n        ind = self.old_nearest_point_index\n        distance_this_index = state.calc_distance(self.cx[ind], self.cy[ind])\n        while True:\n            distance_next_index = state.calc_distance(self.cx[ind + 1], self.cy[ind + 1])\n            if distance_this_index < distance_next_index:\n                break\n            ind = ind + 1 if ind + 1 < len(self.cx) else ind\n            distance_this_index = distance_next_index\n        self.old_nearest_point_index = ind\n    Lf = k * state.v + Lfc\n    while Lf > state.calc_distance(self.cx[ind], self.cy[ind]):\n        if ind + 1 >= len(self.cx):\n            break\n        ind += 1\n    return (ind, Lf)",
            "def search_target_index(self, state):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self.old_nearest_point_index is None:\n        dx = [state.rear_x - icx for icx in self.cx]\n        dy = [state.rear_y - icy for icy in self.cy]\n        d = np.hypot(dx, dy)\n        ind = np.argmin(d)\n        self.old_nearest_point_index = ind\n    else:\n        ind = self.old_nearest_point_index\n        distance_this_index = state.calc_distance(self.cx[ind], self.cy[ind])\n        while True:\n            distance_next_index = state.calc_distance(self.cx[ind + 1], self.cy[ind + 1])\n            if distance_this_index < distance_next_index:\n                break\n            ind = ind + 1 if ind + 1 < len(self.cx) else ind\n            distance_this_index = distance_next_index\n        self.old_nearest_point_index = ind\n    Lf = k * state.v + Lfc\n    while Lf > state.calc_distance(self.cx[ind], self.cy[ind]):\n        if ind + 1 >= len(self.cx):\n            break\n        ind += 1\n    return (ind, Lf)",
            "def search_target_index(self, state):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self.old_nearest_point_index is None:\n        dx = [state.rear_x - icx for icx in self.cx]\n        dy = [state.rear_y - icy for icy in self.cy]\n        d = np.hypot(dx, dy)\n        ind = np.argmin(d)\n        self.old_nearest_point_index = ind\n    else:\n        ind = self.old_nearest_point_index\n        distance_this_index = state.calc_distance(self.cx[ind], self.cy[ind])\n        while True:\n            distance_next_index = state.calc_distance(self.cx[ind + 1], self.cy[ind + 1])\n            if distance_this_index < distance_next_index:\n                break\n            ind = ind + 1 if ind + 1 < len(self.cx) else ind\n            distance_this_index = distance_next_index\n        self.old_nearest_point_index = ind\n    Lf = k * state.v + Lfc\n    while Lf > state.calc_distance(self.cx[ind], self.cy[ind]):\n        if ind + 1 >= len(self.cx):\n            break\n        ind += 1\n    return (ind, Lf)",
            "def search_target_index(self, state):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self.old_nearest_point_index is None:\n        dx = [state.rear_x - icx for icx in self.cx]\n        dy = [state.rear_y - icy for icy in self.cy]\n        d = np.hypot(dx, dy)\n        ind = np.argmin(d)\n        self.old_nearest_point_index = ind\n    else:\n        ind = self.old_nearest_point_index\n        distance_this_index = state.calc_distance(self.cx[ind], self.cy[ind])\n        while True:\n            distance_next_index = state.calc_distance(self.cx[ind + 1], self.cy[ind + 1])\n            if distance_this_index < distance_next_index:\n                break\n            ind = ind + 1 if ind + 1 < len(self.cx) else ind\n            distance_this_index = distance_next_index\n        self.old_nearest_point_index = ind\n    Lf = k * state.v + Lfc\n    while Lf > state.calc_distance(self.cx[ind], self.cy[ind]):\n        if ind + 1 >= len(self.cx):\n            break\n        ind += 1\n    return (ind, Lf)"
        ]
    },
    {
        "func_name": "pure_pursuit_steer_control",
        "original": "def pure_pursuit_steer_control(state, trajectory, pind):\n    (ind, Lf) = trajectory.search_target_index(state)\n    if pind >= ind:\n        ind = pind\n    if ind < len(trajectory.cx):\n        tx = trajectory.cx[ind]\n        ty = trajectory.cy[ind]\n    else:\n        tx = trajectory.cx[-1]\n        ty = trajectory.cy[-1]\n        ind = len(trajectory.cx) - 1\n    alpha = math.atan2(ty - state.rear_y, tx - state.rear_x) - state.yaw\n    delta = math.atan2(2.0 * WB * math.sin(alpha) / Lf, 1.0)\n    return (delta, ind)",
        "mutated": [
            "def pure_pursuit_steer_control(state, trajectory, pind):\n    if False:\n        i = 10\n    (ind, Lf) = trajectory.search_target_index(state)\n    if pind >= ind:\n        ind = pind\n    if ind < len(trajectory.cx):\n        tx = trajectory.cx[ind]\n        ty = trajectory.cy[ind]\n    else:\n        tx = trajectory.cx[-1]\n        ty = trajectory.cy[-1]\n        ind = len(trajectory.cx) - 1\n    alpha = math.atan2(ty - state.rear_y, tx - state.rear_x) - state.yaw\n    delta = math.atan2(2.0 * WB * math.sin(alpha) / Lf, 1.0)\n    return (delta, ind)",
            "def pure_pursuit_steer_control(state, trajectory, pind):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (ind, Lf) = trajectory.search_target_index(state)\n    if pind >= ind:\n        ind = pind\n    if ind < len(trajectory.cx):\n        tx = trajectory.cx[ind]\n        ty = trajectory.cy[ind]\n    else:\n        tx = trajectory.cx[-1]\n        ty = trajectory.cy[-1]\n        ind = len(trajectory.cx) - 1\n    alpha = math.atan2(ty - state.rear_y, tx - state.rear_x) - state.yaw\n    delta = math.atan2(2.0 * WB * math.sin(alpha) / Lf, 1.0)\n    return (delta, ind)",
            "def pure_pursuit_steer_control(state, trajectory, pind):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (ind, Lf) = trajectory.search_target_index(state)\n    if pind >= ind:\n        ind = pind\n    if ind < len(trajectory.cx):\n        tx = trajectory.cx[ind]\n        ty = trajectory.cy[ind]\n    else:\n        tx = trajectory.cx[-1]\n        ty = trajectory.cy[-1]\n        ind = len(trajectory.cx) - 1\n    alpha = math.atan2(ty - state.rear_y, tx - state.rear_x) - state.yaw\n    delta = math.atan2(2.0 * WB * math.sin(alpha) / Lf, 1.0)\n    return (delta, ind)",
            "def pure_pursuit_steer_control(state, trajectory, pind):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (ind, Lf) = trajectory.search_target_index(state)\n    if pind >= ind:\n        ind = pind\n    if ind < len(trajectory.cx):\n        tx = trajectory.cx[ind]\n        ty = trajectory.cy[ind]\n    else:\n        tx = trajectory.cx[-1]\n        ty = trajectory.cy[-1]\n        ind = len(trajectory.cx) - 1\n    alpha = math.atan2(ty - state.rear_y, tx - state.rear_x) - state.yaw\n    delta = math.atan2(2.0 * WB * math.sin(alpha) / Lf, 1.0)\n    return (delta, ind)",
            "def pure_pursuit_steer_control(state, trajectory, pind):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (ind, Lf) = trajectory.search_target_index(state)\n    if pind >= ind:\n        ind = pind\n    if ind < len(trajectory.cx):\n        tx = trajectory.cx[ind]\n        ty = trajectory.cy[ind]\n    else:\n        tx = trajectory.cx[-1]\n        ty = trajectory.cy[-1]\n        ind = len(trajectory.cx) - 1\n    alpha = math.atan2(ty - state.rear_y, tx - state.rear_x) - state.yaw\n    delta = math.atan2(2.0 * WB * math.sin(alpha) / Lf, 1.0)\n    return (delta, ind)"
        ]
    },
    {
        "func_name": "plot_arrow",
        "original": "def plot_arrow(x, y, yaw, length=1.0, width=0.5, fc='r', ec='k'):\n    \"\"\"\n    Plot arrow\n    \"\"\"\n    if not isinstance(x, float):\n        for (ix, iy, iyaw) in zip(x, y, yaw):\n            plot_arrow(ix, iy, iyaw)\n    else:\n        plt.arrow(x, y, length * math.cos(yaw), length * math.sin(yaw), fc=fc, ec=ec, head_width=width, head_length=width)\n        plt.plot(x, y)",
        "mutated": [
            "def plot_arrow(x, y, yaw, length=1.0, width=0.5, fc='r', ec='k'):\n    if False:\n        i = 10\n    '\\n    Plot arrow\\n    '\n    if not isinstance(x, float):\n        for (ix, iy, iyaw) in zip(x, y, yaw):\n            plot_arrow(ix, iy, iyaw)\n    else:\n        plt.arrow(x, y, length * math.cos(yaw), length * math.sin(yaw), fc=fc, ec=ec, head_width=width, head_length=width)\n        plt.plot(x, y)",
            "def plot_arrow(x, y, yaw, length=1.0, width=0.5, fc='r', ec='k'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Plot arrow\\n    '\n    if not isinstance(x, float):\n        for (ix, iy, iyaw) in zip(x, y, yaw):\n            plot_arrow(ix, iy, iyaw)\n    else:\n        plt.arrow(x, y, length * math.cos(yaw), length * math.sin(yaw), fc=fc, ec=ec, head_width=width, head_length=width)\n        plt.plot(x, y)",
            "def plot_arrow(x, y, yaw, length=1.0, width=0.5, fc='r', ec='k'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Plot arrow\\n    '\n    if not isinstance(x, float):\n        for (ix, iy, iyaw) in zip(x, y, yaw):\n            plot_arrow(ix, iy, iyaw)\n    else:\n        plt.arrow(x, y, length * math.cos(yaw), length * math.sin(yaw), fc=fc, ec=ec, head_width=width, head_length=width)\n        plt.plot(x, y)",
            "def plot_arrow(x, y, yaw, length=1.0, width=0.5, fc='r', ec='k'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Plot arrow\\n    '\n    if not isinstance(x, float):\n        for (ix, iy, iyaw) in zip(x, y, yaw):\n            plot_arrow(ix, iy, iyaw)\n    else:\n        plt.arrow(x, y, length * math.cos(yaw), length * math.sin(yaw), fc=fc, ec=ec, head_width=width, head_length=width)\n        plt.plot(x, y)",
            "def plot_arrow(x, y, yaw, length=1.0, width=0.5, fc='r', ec='k'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Plot arrow\\n    '\n    if not isinstance(x, float):\n        for (ix, iy, iyaw) in zip(x, y, yaw):\n            plot_arrow(ix, iy, iyaw)\n    else:\n        plt.arrow(x, y, length * math.cos(yaw), length * math.sin(yaw), fc=fc, ec=ec, head_width=width, head_length=width)\n        plt.plot(x, y)"
        ]
    },
    {
        "func_name": "main",
        "original": "def main():\n    cx = np.arange(0, 50, 0.5)\n    cy = [math.sin(ix / 5.0) * ix / 2.0 for ix in cx]\n    target_speed = 10.0 / 3.6\n    T = 100.0\n    state = State(x=-0.0, y=-3.0, yaw=0.0, v=0.0)\n    lastIndex = len(cx) - 1\n    time = 0.0\n    states = States()\n    states.append(time, state)\n    target_course = TargetCourse(cx, cy)\n    (target_ind, _) = target_course.search_target_index(state)\n    while T >= time and lastIndex > target_ind:\n        ai = proportional_control(target_speed, state.v)\n        (di, target_ind) = pure_pursuit_steer_control(state, target_course, target_ind)\n        state.update(ai, di)\n        time += dt\n        states.append(time, state)\n        if show_animation:\n            plt.cla()\n            plt.gcf().canvas.mpl_connect('key_release_event', lambda event: [exit(0) if event.key == 'escape' else None])\n            plot_arrow(state.x, state.y, state.yaw)\n            plt.plot(cx, cy, '-r', label='course')\n            plt.plot(states.x, states.y, '-b', label='trajectory')\n            plt.plot(cx[target_ind], cy[target_ind], 'xg', label='target')\n            plt.axis('equal')\n            plt.grid(True)\n            plt.title('Speed[km/h]:' + str(state.v * 3.6)[:4])\n            plt.pause(0.001)\n    assert lastIndex >= target_ind, 'Cannot goal'\n    if show_animation:\n        plt.cla()\n        plt.plot(cx, cy, '.r', label='course')\n        plt.plot(states.x, states.y, '-b', label='trajectory')\n        plt.legend()\n        plt.xlabel('x[m]')\n        plt.ylabel('y[m]')\n        plt.axis('equal')\n        plt.grid(True)\n        plt.subplots(1)\n        plt.plot(states.t, [iv * 3.6 for iv in states.v], '-r')\n        plt.xlabel('Time[s]')\n        plt.ylabel('Speed[km/h]')\n        plt.grid(True)\n        plt.show()",
        "mutated": [
            "def main():\n    if False:\n        i = 10\n    cx = np.arange(0, 50, 0.5)\n    cy = [math.sin(ix / 5.0) * ix / 2.0 for ix in cx]\n    target_speed = 10.0 / 3.6\n    T = 100.0\n    state = State(x=-0.0, y=-3.0, yaw=0.0, v=0.0)\n    lastIndex = len(cx) - 1\n    time = 0.0\n    states = States()\n    states.append(time, state)\n    target_course = TargetCourse(cx, cy)\n    (target_ind, _) = target_course.search_target_index(state)\n    while T >= time and lastIndex > target_ind:\n        ai = proportional_control(target_speed, state.v)\n        (di, target_ind) = pure_pursuit_steer_control(state, target_course, target_ind)\n        state.update(ai, di)\n        time += dt\n        states.append(time, state)\n        if show_animation:\n            plt.cla()\n            plt.gcf().canvas.mpl_connect('key_release_event', lambda event: [exit(0) if event.key == 'escape' else None])\n            plot_arrow(state.x, state.y, state.yaw)\n            plt.plot(cx, cy, '-r', label='course')\n            plt.plot(states.x, states.y, '-b', label='trajectory')\n            plt.plot(cx[target_ind], cy[target_ind], 'xg', label='target')\n            plt.axis('equal')\n            plt.grid(True)\n            plt.title('Speed[km/h]:' + str(state.v * 3.6)[:4])\n            plt.pause(0.001)\n    assert lastIndex >= target_ind, 'Cannot goal'\n    if show_animation:\n        plt.cla()\n        plt.plot(cx, cy, '.r', label='course')\n        plt.plot(states.x, states.y, '-b', label='trajectory')\n        plt.legend()\n        plt.xlabel('x[m]')\n        plt.ylabel('y[m]')\n        plt.axis('equal')\n        plt.grid(True)\n        plt.subplots(1)\n        plt.plot(states.t, [iv * 3.6 for iv in states.v], '-r')\n        plt.xlabel('Time[s]')\n        plt.ylabel('Speed[km/h]')\n        plt.grid(True)\n        plt.show()",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    cx = np.arange(0, 50, 0.5)\n    cy = [math.sin(ix / 5.0) * ix / 2.0 for ix in cx]\n    target_speed = 10.0 / 3.6\n    T = 100.0\n    state = State(x=-0.0, y=-3.0, yaw=0.0, v=0.0)\n    lastIndex = len(cx) - 1\n    time = 0.0\n    states = States()\n    states.append(time, state)\n    target_course = TargetCourse(cx, cy)\n    (target_ind, _) = target_course.search_target_index(state)\n    while T >= time and lastIndex > target_ind:\n        ai = proportional_control(target_speed, state.v)\n        (di, target_ind) = pure_pursuit_steer_control(state, target_course, target_ind)\n        state.update(ai, di)\n        time += dt\n        states.append(time, state)\n        if show_animation:\n            plt.cla()\n            plt.gcf().canvas.mpl_connect('key_release_event', lambda event: [exit(0) if event.key == 'escape' else None])\n            plot_arrow(state.x, state.y, state.yaw)\n            plt.plot(cx, cy, '-r', label='course')\n            plt.plot(states.x, states.y, '-b', label='trajectory')\n            plt.plot(cx[target_ind], cy[target_ind], 'xg', label='target')\n            plt.axis('equal')\n            plt.grid(True)\n            plt.title('Speed[km/h]:' + str(state.v * 3.6)[:4])\n            plt.pause(0.001)\n    assert lastIndex >= target_ind, 'Cannot goal'\n    if show_animation:\n        plt.cla()\n        plt.plot(cx, cy, '.r', label='course')\n        plt.plot(states.x, states.y, '-b', label='trajectory')\n        plt.legend()\n        plt.xlabel('x[m]')\n        plt.ylabel('y[m]')\n        plt.axis('equal')\n        plt.grid(True)\n        plt.subplots(1)\n        plt.plot(states.t, [iv * 3.6 for iv in states.v], '-r')\n        plt.xlabel('Time[s]')\n        plt.ylabel('Speed[km/h]')\n        plt.grid(True)\n        plt.show()",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    cx = np.arange(0, 50, 0.5)\n    cy = [math.sin(ix / 5.0) * ix / 2.0 for ix in cx]\n    target_speed = 10.0 / 3.6\n    T = 100.0\n    state = State(x=-0.0, y=-3.0, yaw=0.0, v=0.0)\n    lastIndex = len(cx) - 1\n    time = 0.0\n    states = States()\n    states.append(time, state)\n    target_course = TargetCourse(cx, cy)\n    (target_ind, _) = target_course.search_target_index(state)\n    while T >= time and lastIndex > target_ind:\n        ai = proportional_control(target_speed, state.v)\n        (di, target_ind) = pure_pursuit_steer_control(state, target_course, target_ind)\n        state.update(ai, di)\n        time += dt\n        states.append(time, state)\n        if show_animation:\n            plt.cla()\n            plt.gcf().canvas.mpl_connect('key_release_event', lambda event: [exit(0) if event.key == 'escape' else None])\n            plot_arrow(state.x, state.y, state.yaw)\n            plt.plot(cx, cy, '-r', label='course')\n            plt.plot(states.x, states.y, '-b', label='trajectory')\n            plt.plot(cx[target_ind], cy[target_ind], 'xg', label='target')\n            plt.axis('equal')\n            plt.grid(True)\n            plt.title('Speed[km/h]:' + str(state.v * 3.6)[:4])\n            plt.pause(0.001)\n    assert lastIndex >= target_ind, 'Cannot goal'\n    if show_animation:\n        plt.cla()\n        plt.plot(cx, cy, '.r', label='course')\n        plt.plot(states.x, states.y, '-b', label='trajectory')\n        plt.legend()\n        plt.xlabel('x[m]')\n        plt.ylabel('y[m]')\n        plt.axis('equal')\n        plt.grid(True)\n        plt.subplots(1)\n        plt.plot(states.t, [iv * 3.6 for iv in states.v], '-r')\n        plt.xlabel('Time[s]')\n        plt.ylabel('Speed[km/h]')\n        plt.grid(True)\n        plt.show()",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    cx = np.arange(0, 50, 0.5)\n    cy = [math.sin(ix / 5.0) * ix / 2.0 for ix in cx]\n    target_speed = 10.0 / 3.6\n    T = 100.0\n    state = State(x=-0.0, y=-3.0, yaw=0.0, v=0.0)\n    lastIndex = len(cx) - 1\n    time = 0.0\n    states = States()\n    states.append(time, state)\n    target_course = TargetCourse(cx, cy)\n    (target_ind, _) = target_course.search_target_index(state)\n    while T >= time and lastIndex > target_ind:\n        ai = proportional_control(target_speed, state.v)\n        (di, target_ind) = pure_pursuit_steer_control(state, target_course, target_ind)\n        state.update(ai, di)\n        time += dt\n        states.append(time, state)\n        if show_animation:\n            plt.cla()\n            plt.gcf().canvas.mpl_connect('key_release_event', lambda event: [exit(0) if event.key == 'escape' else None])\n            plot_arrow(state.x, state.y, state.yaw)\n            plt.plot(cx, cy, '-r', label='course')\n            plt.plot(states.x, states.y, '-b', label='trajectory')\n            plt.plot(cx[target_ind], cy[target_ind], 'xg', label='target')\n            plt.axis('equal')\n            plt.grid(True)\n            plt.title('Speed[km/h]:' + str(state.v * 3.6)[:4])\n            plt.pause(0.001)\n    assert lastIndex >= target_ind, 'Cannot goal'\n    if show_animation:\n        plt.cla()\n        plt.plot(cx, cy, '.r', label='course')\n        plt.plot(states.x, states.y, '-b', label='trajectory')\n        plt.legend()\n        plt.xlabel('x[m]')\n        plt.ylabel('y[m]')\n        plt.axis('equal')\n        plt.grid(True)\n        plt.subplots(1)\n        plt.plot(states.t, [iv * 3.6 for iv in states.v], '-r')\n        plt.xlabel('Time[s]')\n        plt.ylabel('Speed[km/h]')\n        plt.grid(True)\n        plt.show()",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    cx = np.arange(0, 50, 0.5)\n    cy = [math.sin(ix / 5.0) * ix / 2.0 for ix in cx]\n    target_speed = 10.0 / 3.6\n    T = 100.0\n    state = State(x=-0.0, y=-3.0, yaw=0.0, v=0.0)\n    lastIndex = len(cx) - 1\n    time = 0.0\n    states = States()\n    states.append(time, state)\n    target_course = TargetCourse(cx, cy)\n    (target_ind, _) = target_course.search_target_index(state)\n    while T >= time and lastIndex > target_ind:\n        ai = proportional_control(target_speed, state.v)\n        (di, target_ind) = pure_pursuit_steer_control(state, target_course, target_ind)\n        state.update(ai, di)\n        time += dt\n        states.append(time, state)\n        if show_animation:\n            plt.cla()\n            plt.gcf().canvas.mpl_connect('key_release_event', lambda event: [exit(0) if event.key == 'escape' else None])\n            plot_arrow(state.x, state.y, state.yaw)\n            plt.plot(cx, cy, '-r', label='course')\n            plt.plot(states.x, states.y, '-b', label='trajectory')\n            plt.plot(cx[target_ind], cy[target_ind], 'xg', label='target')\n            plt.axis('equal')\n            plt.grid(True)\n            plt.title('Speed[km/h]:' + str(state.v * 3.6)[:4])\n            plt.pause(0.001)\n    assert lastIndex >= target_ind, 'Cannot goal'\n    if show_animation:\n        plt.cla()\n        plt.plot(cx, cy, '.r', label='course')\n        plt.plot(states.x, states.y, '-b', label='trajectory')\n        plt.legend()\n        plt.xlabel('x[m]')\n        plt.ylabel('y[m]')\n        plt.axis('equal')\n        plt.grid(True)\n        plt.subplots(1)\n        plt.plot(states.t, [iv * 3.6 for iv in states.v], '-r')\n        plt.xlabel('Time[s]')\n        plt.ylabel('Speed[km/h]')\n        plt.grid(True)\n        plt.show()"
        ]
    }
]