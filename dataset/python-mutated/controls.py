import abc
import logbook
from datetime import datetime
import pandas as pd
from six import with_metaclass
from zipline.errors import AccountControlViolation, TradingControlViolation
from zipline.utils.input_validation import expect_bounded, expect_types
log = logbook.Logger('TradingControl')

class TradingControl(with_metaclass(abc.ABCMeta)):
    """
    Abstract base class representing a fail-safe control on the behavior of any
    algorithm.
    """

    def __init__(self, on_error, **kwargs):
        if False:
            print('Hello World!')
        '\n        Track any arguments that should be printed in the error message\n        generated by self.fail.\n        '
        self.on_error = on_error
        self.__fail_args = kwargs

    @abc.abstractmethod
    def validate(self, asset, amount, portfolio, algo_datetime, algo_current_data):
        if False:
            for i in range(10):
                print('nop')
        "\n        Before any order is executed by TradingAlgorithm, this method should be\n        called *exactly once* on each registered TradingControl object.\n\n        If the specified asset and amount do not violate this TradingControl's\n        restraint given the information in `portfolio`, this method should\n        return None and have no externally-visible side-effects.\n\n        If the desired order violates this TradingControl's contraint, this\n        method should call self.fail(asset, amount).\n        "
        raise NotImplementedError

    def _constraint_msg(self, metadata):
        if False:
            return 10
        constraint = repr(self)
        if metadata:
            constraint = '{constraint} (Metadata: {metadata})'.format(constraint=constraint, metadata=metadata)
        return constraint

    def handle_violation(self, asset, amount, datetime, metadata=None):
        if False:
            return 10
        '\n        Handle a TradingControlViolation, either by raising or logging and\n        error with information about the failure.\n\n        If dynamic information should be displayed as well, pass it in via\n        `metadata`.\n        '
        constraint = self._constraint_msg(metadata)
        if self.on_error == 'fail':
            raise TradingControlViolation(asset=asset, amount=amount, datetime=datetime, constraint=constraint)
        elif self.on_error == 'log':
            log.error('Order for {amount} shares of {asset} at {dt} violates trading constraint {constraint}', amount=amount, asset=asset, dt=datetime, constraint=constraint)

    def __repr__(self):
        if False:
            i = 10
            return i + 15
        return '{name}({attrs})'.format(name=self.__class__.__name__, attrs=self.__fail_args)

class MaxOrderCount(TradingControl):
    """
    TradingControl representing a limit on the number of orders that can be
    placed in a given trading day.
    """

    def __init__(self, on_error, max_count):
        if False:
            for i in range(10):
                print('nop')
        super(MaxOrderCount, self).__init__(on_error, max_count=max_count)
        self.orders_placed = 0
        self.max_count = max_count
        self.current_date = None

    def validate(self, asset, amount, portfolio, algo_datetime, algo_current_data):
        if False:
            return 10
        "\n        Fail if we've already placed self.max_count orders today.\n        "
        algo_date = algo_datetime.date()
        if self.current_date and self.current_date != algo_date:
            self.orders_placed = 0
        self.current_date = algo_date
        if self.orders_placed >= self.max_count:
            self.handle_violation(asset, amount, algo_datetime)
        self.orders_placed += 1

class RestrictedListOrder(TradingControl):
    """TradingControl representing a restricted list of assets that
    cannot be ordered by the algorithm.

    Parameters
    ----------
    restrictions : zipline.finance.asset_restrictions.Restrictions
        Object representing restrictions of a group of assets.
    """

    def __init__(self, on_error, restrictions):
        if False:
            for i in range(10):
                print('nop')
        super(RestrictedListOrder, self).__init__(on_error)
        self.restrictions = restrictions

    def validate(self, asset, amount, portfolio, algo_datetime, algo_current_data):
        if False:
            return 10
        '\n        Fail if the asset is in the restricted_list.\n        '
        if self.restrictions.is_restricted(asset, algo_datetime):
            self.handle_violation(asset, amount, algo_datetime)

class MaxOrderSize(TradingControl):
    """
    TradingControl representing a limit on the magnitude of any single order
    placed with the given asset.  Can be specified by share or by dollar
    value.
    """

    def __init__(self, on_error, asset=None, max_shares=None, max_notional=None):
        if False:
            return 10
        super(MaxOrderSize, self).__init__(on_error, asset=asset, max_shares=max_shares, max_notional=max_notional)
        self.asset = asset
        self.max_shares = max_shares
        self.max_notional = max_notional
        if max_shares is None and max_notional is None:
            raise ValueError('Must supply at least one of max_shares and max_notional')
        if max_shares and max_shares < 0:
            raise ValueError('max_shares cannot be negative.')
        if max_notional and max_notional < 0:
            raise ValueError('max_notional must be positive.')

    def validate(self, asset, amount, portfolio, algo_datetime, algo_current_data):
        if False:
            i = 10
            return i + 15
        '\n        Fail if the magnitude of the given order exceeds either self.max_shares\n        or self.max_notional.\n        '
        if self.asset is not None and self.asset != asset:
            return
        if self.max_shares is not None and abs(amount) > self.max_shares:
            self.handle_violation(asset, amount, algo_datetime)
        current_asset_price = algo_current_data.current(asset, 'price')
        order_value = amount * current_asset_price
        too_much_value = self.max_notional is not None and abs(order_value) > self.max_notional
        if too_much_value:
            self.handle_violation(asset, amount, algo_datetime)

class MaxPositionSize(TradingControl):
    """
    TradingControl representing a limit on the maximum position size that can
    be held by an algo for a given asset.
    """

    def __init__(self, on_error, asset=None, max_shares=None, max_notional=None):
        if False:
            print('Hello World!')
        super(MaxPositionSize, self).__init__(on_error, asset=asset, max_shares=max_shares, max_notional=max_notional)
        self.asset = asset
        self.max_shares = max_shares
        self.max_notional = max_notional
        if max_shares is None and max_notional is None:
            raise ValueError('Must supply at least one of max_shares and max_notional')
        if max_shares and max_shares < 0:
            raise ValueError('max_shares cannot be negative.')
        if max_notional and max_notional < 0:
            raise ValueError('max_notional must be positive.')

    def validate(self, asset, amount, portfolio, algo_datetime, algo_current_data):
        if False:
            for i in range(10):
                print('nop')
        '\n        Fail if the given order would cause the magnitude of our position to be\n        greater in shares than self.max_shares or greater in dollar value than\n        self.max_notional.\n        '
        if self.asset is not None and self.asset != asset:
            return
        current_share_count = portfolio.positions[asset].amount
        shares_post_order = current_share_count + amount
        too_many_shares = self.max_shares is not None and abs(shares_post_order) > self.max_shares
        if too_many_shares:
            self.handle_violation(asset, amount, algo_datetime)
        current_price = algo_current_data.current(asset, 'price')
        value_post_order = shares_post_order * current_price
        too_much_value = self.max_notional is not None and abs(value_post_order) > self.max_notional
        if too_much_value:
            self.handle_violation(asset, amount, algo_datetime)

class LongOnly(TradingControl):
    """
    TradingControl representing a prohibition against holding short positions.
    """

    def __init__(self, on_error):
        if False:
            i = 10
            return i + 15
        super(LongOnly, self).__init__(on_error)

    def validate(self, asset, amount, portfolio, algo_datetime, algo_current_data):
        if False:
            return 10
        '\n        Fail if we would hold negative shares of asset after completing this\n        order.\n        '
        if portfolio.positions[asset].amount + amount < 0:
            self.handle_violation(asset, amount, algo_datetime)

class AssetDateBounds(TradingControl):
    """
    TradingControl representing a prohibition against ordering an asset before
    its start_date, or after its end_date.
    """

    def __init__(self, on_error):
        if False:
            print('Hello World!')
        super(AssetDateBounds, self).__init__(on_error)

    def validate(self, asset, amount, portfolio, algo_datetime, algo_current_data):
        if False:
            i = 10
            return i + 15
        "\n        Fail if the algo has passed this Asset's end_date, or before the\n        Asset's start date.\n        "
        if amount == 0:
            return
        normalized_algo_dt = pd.Timestamp(algo_datetime).normalize()
        if asset.start_date:
            normalized_start = pd.Timestamp(asset.start_date).normalize()
            if normalized_algo_dt < normalized_start:
                metadata = {'asset_start_date': normalized_start}
                self.handle_violation(asset, amount, algo_datetime, metadata=metadata)
        if asset.end_date:
            normalized_end = pd.Timestamp(asset.end_date).normalize()
            if normalized_algo_dt > normalized_end:
                metadata = {'asset_end_date': normalized_end}
                self.handle_violation(asset, amount, algo_datetime, metadata=metadata)

class AccountControl(with_metaclass(abc.ABCMeta)):
    """
    Abstract base class representing a fail-safe control on the behavior of any
    algorithm.
    """

    def __init__(self, **kwargs):
        if False:
            i = 10
            return i + 15
        '\n        Track any arguments that should be printed in the error message\n        generated by self.fail.\n        '
        self.__fail_args = kwargs

    @abc.abstractmethod
    def validate(self, _portfolio, _account, _algo_datetime, _algo_current_data):
        if False:
            while True:
                i = 10
        "\n        On each call to handle data by TradingAlgorithm, this method should be\n        called *exactly once* on each registered AccountControl object.\n\n        If the check does not violate this AccountControl's restraint given\n        the information in `portfolio` and `account`, this method should\n        return None and have no externally-visible side-effects.\n\n        If the desired order violates this AccountControl's contraint, this\n        method should call self.fail().\n        "
        raise NotImplementedError

    def fail(self):
        if False:
            while True:
                i = 10
        '\n        Raise an AccountControlViolation with information about the failure.\n        '
        raise AccountControlViolation(constraint=repr(self))

    def __repr__(self):
        if False:
            return 10
        return '{name}({attrs})'.format(name=self.__class__.__name__, attrs=self.__fail_args)

class MaxLeverage(AccountControl):
    """
    AccountControl representing a limit on the maximum leverage allowed
    by the algorithm.
    """

    def __init__(self, max_leverage):
        if False:
            while True:
                i = 10
        '\n        max_leverage is the gross leverage in decimal form. For example,\n        2, limits an algorithm to trading at most double the account value.\n        '
        super(MaxLeverage, self).__init__(max_leverage=max_leverage)
        self.max_leverage = max_leverage
        if max_leverage is None:
            raise ValueError('Must supply max_leverage')
        if max_leverage < 0:
            raise ValueError('max_leverage must be positive')

    def validate(self, _portfolio, _account, _algo_datetime, _algo_current_data):
        if False:
            while True:
                i = 10
        '\n        Fail if the leverage is greater than the allowed leverage.\n        '
        if _account.leverage > self.max_leverage:
            self.fail()

class MinLeverage(AccountControl):
    """AccountControl representing a limit on the minimum leverage allowed
    by the algorithm after a threshold period of time.

    Parameters
    ----------
    min_leverage : float
        The gross leverage in decimal form.
    deadline : datetime
        The date the min leverage must be achieved by.

    For example, min_leverage=2 limits an algorithm to trading at minimum
    double the account value by the deadline date.
    """

    @expect_types(__funcname='MinLeverage', min_leverage=(int, float), deadline=datetime)
    @expect_bounded(__funcname='MinLeverage', min_leverage=(0, None))
    def __init__(self, min_leverage, deadline):
        if False:
            while True:
                i = 10
        super(MinLeverage, self).__init__(min_leverage=min_leverage, deadline=deadline)
        self.min_leverage = min_leverage
        self.deadline = deadline

    def validate(self, _portfolio, account, algo_datetime, _algo_current_data):
        if False:
            print('Hello World!')
        '\n        Make validation checks if we are after the deadline.\n        Fail if the leverage is less than the min leverage.\n        '
        if algo_datetime > self.deadline and account.leverage < self.min_leverage:
            self.fail()