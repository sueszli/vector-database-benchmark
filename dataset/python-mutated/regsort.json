[
    {
        "func_name": "check_cycle",
        "original": "def check_cycle(reg, assignments):\n    \"\"\"Walk down the assignment list of a register,\n    return the path walked if it is encountered again.\n\n    Returns:\n\n        The list of register involved in the cycle.\n        If there is no cycle, this is an empty list.\n\n    Example:\n\n        >>> check_cycle('a', {'a': 1})\n        []\n        >>> check_cycle('a', {'a': 'a'})\n        ['a']\n        >>> check_cycle('a', {'a': 'b', 'b': 'a'})\n        ['a', 'b']\n        >>> check_cycle('a', {'a': 'b', 'b': 'c', 'c': 'b', 'd': 'a'})\n        []\n        >>> check_cycle('a', {'a': 'b', 'b': 'c', 'c': 'd', 'd': 'a'})\n        ['a', 'b', 'c', 'd']\n    \"\"\"\n    return check_cycle_(reg, assignments, [])",
        "mutated": [
            "def check_cycle(reg, assignments):\n    if False:\n        i = 10\n    \"Walk down the assignment list of a register,\\n    return the path walked if it is encountered again.\\n\\n    Returns:\\n\\n        The list of register involved in the cycle.\\n        If there is no cycle, this is an empty list.\\n\\n    Example:\\n\\n        >>> check_cycle('a', {'a': 1})\\n        []\\n        >>> check_cycle('a', {'a': 'a'})\\n        ['a']\\n        >>> check_cycle('a', {'a': 'b', 'b': 'a'})\\n        ['a', 'b']\\n        >>> check_cycle('a', {'a': 'b', 'b': 'c', 'c': 'b', 'd': 'a'})\\n        []\\n        >>> check_cycle('a', {'a': 'b', 'b': 'c', 'c': 'd', 'd': 'a'})\\n        ['a', 'b', 'c', 'd']\\n    \"\n    return check_cycle_(reg, assignments, [])",
            "def check_cycle(reg, assignments):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Walk down the assignment list of a register,\\n    return the path walked if it is encountered again.\\n\\n    Returns:\\n\\n        The list of register involved in the cycle.\\n        If there is no cycle, this is an empty list.\\n\\n    Example:\\n\\n        >>> check_cycle('a', {'a': 1})\\n        []\\n        >>> check_cycle('a', {'a': 'a'})\\n        ['a']\\n        >>> check_cycle('a', {'a': 'b', 'b': 'a'})\\n        ['a', 'b']\\n        >>> check_cycle('a', {'a': 'b', 'b': 'c', 'c': 'b', 'd': 'a'})\\n        []\\n        >>> check_cycle('a', {'a': 'b', 'b': 'c', 'c': 'd', 'd': 'a'})\\n        ['a', 'b', 'c', 'd']\\n    \"\n    return check_cycle_(reg, assignments, [])",
            "def check_cycle(reg, assignments):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Walk down the assignment list of a register,\\n    return the path walked if it is encountered again.\\n\\n    Returns:\\n\\n        The list of register involved in the cycle.\\n        If there is no cycle, this is an empty list.\\n\\n    Example:\\n\\n        >>> check_cycle('a', {'a': 1})\\n        []\\n        >>> check_cycle('a', {'a': 'a'})\\n        ['a']\\n        >>> check_cycle('a', {'a': 'b', 'b': 'a'})\\n        ['a', 'b']\\n        >>> check_cycle('a', {'a': 'b', 'b': 'c', 'c': 'b', 'd': 'a'})\\n        []\\n        >>> check_cycle('a', {'a': 'b', 'b': 'c', 'c': 'd', 'd': 'a'})\\n        ['a', 'b', 'c', 'd']\\n    \"\n    return check_cycle_(reg, assignments, [])",
            "def check_cycle(reg, assignments):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Walk down the assignment list of a register,\\n    return the path walked if it is encountered again.\\n\\n    Returns:\\n\\n        The list of register involved in the cycle.\\n        If there is no cycle, this is an empty list.\\n\\n    Example:\\n\\n        >>> check_cycle('a', {'a': 1})\\n        []\\n        >>> check_cycle('a', {'a': 'a'})\\n        ['a']\\n        >>> check_cycle('a', {'a': 'b', 'b': 'a'})\\n        ['a', 'b']\\n        >>> check_cycle('a', {'a': 'b', 'b': 'c', 'c': 'b', 'd': 'a'})\\n        []\\n        >>> check_cycle('a', {'a': 'b', 'b': 'c', 'c': 'd', 'd': 'a'})\\n        ['a', 'b', 'c', 'd']\\n    \"\n    return check_cycle_(reg, assignments, [])",
            "def check_cycle(reg, assignments):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Walk down the assignment list of a register,\\n    return the path walked if it is encountered again.\\n\\n    Returns:\\n\\n        The list of register involved in the cycle.\\n        If there is no cycle, this is an empty list.\\n\\n    Example:\\n\\n        >>> check_cycle('a', {'a': 1})\\n        []\\n        >>> check_cycle('a', {'a': 'a'})\\n        ['a']\\n        >>> check_cycle('a', {'a': 'b', 'b': 'a'})\\n        ['a', 'b']\\n        >>> check_cycle('a', {'a': 'b', 'b': 'c', 'c': 'b', 'd': 'a'})\\n        []\\n        >>> check_cycle('a', {'a': 'b', 'b': 'c', 'c': 'd', 'd': 'a'})\\n        ['a', 'b', 'c', 'd']\\n    \"\n    return check_cycle_(reg, assignments, [])"
        ]
    },
    {
        "func_name": "check_cycle_",
        "original": "def check_cycle_(reg, assignments, path):\n    target = assignments[reg]\n    path.append(reg)\n    if target not in assignments:\n        return []\n    if target in path:\n        if target == path[0]:\n            return path\n        return []\n    return check_cycle_(target, assignments, path)",
        "mutated": [
            "def check_cycle_(reg, assignments, path):\n    if False:\n        i = 10\n    target = assignments[reg]\n    path.append(reg)\n    if target not in assignments:\n        return []\n    if target in path:\n        if target == path[0]:\n            return path\n        return []\n    return check_cycle_(target, assignments, path)",
            "def check_cycle_(reg, assignments, path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    target = assignments[reg]\n    path.append(reg)\n    if target not in assignments:\n        return []\n    if target in path:\n        if target == path[0]:\n            return path\n        return []\n    return check_cycle_(target, assignments, path)",
            "def check_cycle_(reg, assignments, path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    target = assignments[reg]\n    path.append(reg)\n    if target not in assignments:\n        return []\n    if target in path:\n        if target == path[0]:\n            return path\n        return []\n    return check_cycle_(target, assignments, path)",
            "def check_cycle_(reg, assignments, path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    target = assignments[reg]\n    path.append(reg)\n    if target not in assignments:\n        return []\n    if target in path:\n        if target == path[0]:\n            return path\n        return []\n    return check_cycle_(target, assignments, path)",
            "def check_cycle_(reg, assignments, path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    target = assignments[reg]\n    path.append(reg)\n    if target not in assignments:\n        return []\n    if target in path:\n        if target == path[0]:\n            return path\n        return []\n    return check_cycle_(target, assignments, path)"
        ]
    },
    {
        "func_name": "extract_dependencies",
        "original": "def extract_dependencies(reg, assignments):\n    \"\"\"Return a list of all registers which directly\n    depend on the specified register.\n\n    Example:\n\n        >>> extract_dependencies('a', {'a': 1})\n        []\n        >>> extract_dependencies('a', {'a': 'b', 'b': 1})\n        []\n        >>> extract_dependencies('a', {'a': 1, 'b': 'a'})\n        ['b']\n        >>> extract_dependencies('a', {'a': 1, 'b': 'a', 'c': 'a'})\n        ['b', 'c']\n    \"\"\"\n    return sorted([k for (k, v) in assignments.items() if v == reg])",
        "mutated": [
            "def extract_dependencies(reg, assignments):\n    if False:\n        i = 10\n    \"Return a list of all registers which directly\\n    depend on the specified register.\\n\\n    Example:\\n\\n        >>> extract_dependencies('a', {'a': 1})\\n        []\\n        >>> extract_dependencies('a', {'a': 'b', 'b': 1})\\n        []\\n        >>> extract_dependencies('a', {'a': 1, 'b': 'a'})\\n        ['b']\\n        >>> extract_dependencies('a', {'a': 1, 'b': 'a', 'c': 'a'})\\n        ['b', 'c']\\n    \"\n    return sorted([k for (k, v) in assignments.items() if v == reg])",
            "def extract_dependencies(reg, assignments):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Return a list of all registers which directly\\n    depend on the specified register.\\n\\n    Example:\\n\\n        >>> extract_dependencies('a', {'a': 1})\\n        []\\n        >>> extract_dependencies('a', {'a': 'b', 'b': 1})\\n        []\\n        >>> extract_dependencies('a', {'a': 1, 'b': 'a'})\\n        ['b']\\n        >>> extract_dependencies('a', {'a': 1, 'b': 'a', 'c': 'a'})\\n        ['b', 'c']\\n    \"\n    return sorted([k for (k, v) in assignments.items() if v == reg])",
            "def extract_dependencies(reg, assignments):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Return a list of all registers which directly\\n    depend on the specified register.\\n\\n    Example:\\n\\n        >>> extract_dependencies('a', {'a': 1})\\n        []\\n        >>> extract_dependencies('a', {'a': 'b', 'b': 1})\\n        []\\n        >>> extract_dependencies('a', {'a': 1, 'b': 'a'})\\n        ['b']\\n        >>> extract_dependencies('a', {'a': 1, 'b': 'a', 'c': 'a'})\\n        ['b', 'c']\\n    \"\n    return sorted([k for (k, v) in assignments.items() if v == reg])",
            "def extract_dependencies(reg, assignments):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Return a list of all registers which directly\\n    depend on the specified register.\\n\\n    Example:\\n\\n        >>> extract_dependencies('a', {'a': 1})\\n        []\\n        >>> extract_dependencies('a', {'a': 'b', 'b': 1})\\n        []\\n        >>> extract_dependencies('a', {'a': 1, 'b': 'a'})\\n        ['b']\\n        >>> extract_dependencies('a', {'a': 1, 'b': 'a', 'c': 'a'})\\n        ['b', 'c']\\n    \"\n    return sorted([k for (k, v) in assignments.items() if v == reg])",
            "def extract_dependencies(reg, assignments):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Return a list of all registers which directly\\n    depend on the specified register.\\n\\n    Example:\\n\\n        >>> extract_dependencies('a', {'a': 1})\\n        []\\n        >>> extract_dependencies('a', {'a': 'b', 'b': 1})\\n        []\\n        >>> extract_dependencies('a', {'a': 1, 'b': 'a'})\\n        ['b']\\n        >>> extract_dependencies('a', {'a': 1, 'b': 'a', 'c': 'a'})\\n        ['b', 'c']\\n    \"\n    return sorted([k for (k, v) in assignments.items() if v == reg])"
        ]
    },
    {
        "func_name": "resolve_order",
        "original": "def resolve_order(reg, deps):\n    \"\"\"\n    Resolve the order of all dependencies starting at a given register.\n\n    Example:\n\n        >>> want = {'a': 1, 'b': 'c', 'c': 'd', 'd': 7, 'x': 'd'}\n        >>> deps = {'a': [], 'b': [], 'c': ['b'], 'd': ['c', 'x'], 'x': []}\n        >>> resolve_order('a', deps)\n        ['a']\n        >>> resolve_order('b', deps)\n        ['b']\n        >>> resolve_order('c', deps)\n        ['b', 'c']\n        >>> resolve_order('d', deps)\n        ['b', 'c', 'x', 'd']\n    \"\"\"\n    x = []\n    for dep in deps[reg]:\n        x.extend(resolve_order(dep, deps))\n    x.append(reg)\n    return x",
        "mutated": [
            "def resolve_order(reg, deps):\n    if False:\n        i = 10\n    \"\\n    Resolve the order of all dependencies starting at a given register.\\n\\n    Example:\\n\\n        >>> want = {'a': 1, 'b': 'c', 'c': 'd', 'd': 7, 'x': 'd'}\\n        >>> deps = {'a': [], 'b': [], 'c': ['b'], 'd': ['c', 'x'], 'x': []}\\n        >>> resolve_order('a', deps)\\n        ['a']\\n        >>> resolve_order('b', deps)\\n        ['b']\\n        >>> resolve_order('c', deps)\\n        ['b', 'c']\\n        >>> resolve_order('d', deps)\\n        ['b', 'c', 'x', 'd']\\n    \"\n    x = []\n    for dep in deps[reg]:\n        x.extend(resolve_order(dep, deps))\n    x.append(reg)\n    return x",
            "def resolve_order(reg, deps):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Resolve the order of all dependencies starting at a given register.\\n\\n    Example:\\n\\n        >>> want = {'a': 1, 'b': 'c', 'c': 'd', 'd': 7, 'x': 'd'}\\n        >>> deps = {'a': [], 'b': [], 'c': ['b'], 'd': ['c', 'x'], 'x': []}\\n        >>> resolve_order('a', deps)\\n        ['a']\\n        >>> resolve_order('b', deps)\\n        ['b']\\n        >>> resolve_order('c', deps)\\n        ['b', 'c']\\n        >>> resolve_order('d', deps)\\n        ['b', 'c', 'x', 'd']\\n    \"\n    x = []\n    for dep in deps[reg]:\n        x.extend(resolve_order(dep, deps))\n    x.append(reg)\n    return x",
            "def resolve_order(reg, deps):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Resolve the order of all dependencies starting at a given register.\\n\\n    Example:\\n\\n        >>> want = {'a': 1, 'b': 'c', 'c': 'd', 'd': 7, 'x': 'd'}\\n        >>> deps = {'a': [], 'b': [], 'c': ['b'], 'd': ['c', 'x'], 'x': []}\\n        >>> resolve_order('a', deps)\\n        ['a']\\n        >>> resolve_order('b', deps)\\n        ['b']\\n        >>> resolve_order('c', deps)\\n        ['b', 'c']\\n        >>> resolve_order('d', deps)\\n        ['b', 'c', 'x', 'd']\\n    \"\n    x = []\n    for dep in deps[reg]:\n        x.extend(resolve_order(dep, deps))\n    x.append(reg)\n    return x",
            "def resolve_order(reg, deps):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Resolve the order of all dependencies starting at a given register.\\n\\n    Example:\\n\\n        >>> want = {'a': 1, 'b': 'c', 'c': 'd', 'd': 7, 'x': 'd'}\\n        >>> deps = {'a': [], 'b': [], 'c': ['b'], 'd': ['c', 'x'], 'x': []}\\n        >>> resolve_order('a', deps)\\n        ['a']\\n        >>> resolve_order('b', deps)\\n        ['b']\\n        >>> resolve_order('c', deps)\\n        ['b', 'c']\\n        >>> resolve_order('d', deps)\\n        ['b', 'c', 'x', 'd']\\n    \"\n    x = []\n    for dep in deps[reg]:\n        x.extend(resolve_order(dep, deps))\n    x.append(reg)\n    return x",
            "def resolve_order(reg, deps):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Resolve the order of all dependencies starting at a given register.\\n\\n    Example:\\n\\n        >>> want = {'a': 1, 'b': 'c', 'c': 'd', 'd': 7, 'x': 'd'}\\n        >>> deps = {'a': [], 'b': [], 'c': ['b'], 'd': ['c', 'x'], 'x': []}\\n        >>> resolve_order('a', deps)\\n        ['a']\\n        >>> resolve_order('b', deps)\\n        ['b']\\n        >>> resolve_order('c', deps)\\n        ['b', 'c']\\n        >>> resolve_order('d', deps)\\n        ['b', 'c', 'x', 'd']\\n    \"\n    x = []\n    for dep in deps[reg]:\n        x.extend(resolve_order(dep, deps))\n    x.append(reg)\n    return x"
        ]
    },
    {
        "func_name": "depends_on_cycle",
        "original": "def depends_on_cycle(reg, assignments, in_cycles):\n    while reg in assignments:\n        if reg in in_cycles:\n            return True\n        reg = assignments.get(reg, None)\n    return False",
        "mutated": [
            "def depends_on_cycle(reg, assignments, in_cycles):\n    if False:\n        i = 10\n    while reg in assignments:\n        if reg in in_cycles:\n            return True\n        reg = assignments.get(reg, None)\n    return False",
            "def depends_on_cycle(reg, assignments, in_cycles):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    while reg in assignments:\n        if reg in in_cycles:\n            return True\n        reg = assignments.get(reg, None)\n    return False",
            "def depends_on_cycle(reg, assignments, in_cycles):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    while reg in assignments:\n        if reg in in_cycles:\n            return True\n        reg = assignments.get(reg, None)\n    return False",
            "def depends_on_cycle(reg, assignments, in_cycles):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    while reg in assignments:\n        if reg in in_cycles:\n            return True\n        reg = assignments.get(reg, None)\n    return False",
            "def depends_on_cycle(reg, assignments, in_cycles):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    while reg in assignments:\n        if reg in in_cycles:\n            return True\n        reg = assignments.get(reg, None)\n    return False"
        ]
    },
    {
        "func_name": "regsort",
        "original": "def regsort(in_out, all_regs, tmp=None, xchg=True, randomize=None):\n    \"\"\"\n    Sorts register dependencies.\n\n    Given a dictionary of registers to desired register contents,\n    return the optimal order in which to set the registers to\n    those contents.\n\n    The implementation assumes that it is possible to move from\n    any register to any other register.\n\n    If a dependency cycle is encountered, one of the following will\n    occur:\n\n    - If ``xchg`` is :const:`True`, it is assumed that dependency cyles can\n      be broken by swapping the contents of two register (a la the\n      ``xchg`` instruction on i386).\n    - If ``xchg`` is not set, but not all destination registers in\n      ``in_out`` are involved in a cycle, one of the registers\n      outside the cycle will be used as a temporary register,\n      and then overwritten with its final value.\n    - If ``xchg`` is not set, and all registers are involved in\n      a dependency cycle, the named register ``temporary`` is used\n      as a temporary register.\n    - If the dependency cycle cannot be resolved as described above,\n      an exception is raised.\n\n    Arguments:\n\n        in_out(dict):\n            Dictionary of desired register states.\n            Keys are registers, values are either registers or any other value.\n        all_regs(list):\n            List of all possible registers.\n            Used to determine which values in ``in_out`` are registers, versus\n            regular values.\n        tmp(obj, str):\n            Named register (or other sentinel value) to use as a temporary\n            register.  If ``tmp`` is a named register **and** appears\n            as a source value in ``in_out``, dependencies are handled\n            appropriately.  ``tmp`` cannot be a destination register\n            in ``in_out``.\n            If ``bool(tmp)==True``, this mode is enabled.\n        xchg(obj):\n            Indicates the existence of an instruction which can swap the\n            contents of two registers without use of a third register.\n            If ``bool(xchg)==False``, this mode is disabled.\n        random(bool):\n            Randomize as much as possible about the order or registers.\n\n    Returns:\n\n        A list of tuples of ``(src, dest)``.\n\n        Each register may appear more than once, if a register is used\n        as a temporary register, and later overwritten with its final\n        value.\n\n        If ``xchg`` is :const:`True` and it is used to break a dependency cycle,\n        then ``reg_name`` will be :const:`None` and ``value`` will be a tuple\n        of the instructions to swap.\n\n    Example:\n\n        >>> R = ['a', 'b', 'c', 'd', 'x', 'y', 'z']\n\n        If order doesn't matter for any subsequence, alphabetic\n        order is used.\n\n        >>> regsort({'a': 1, 'b': 2}, R)\n        [('mov', 'a', 1), ('mov', 'b', 2)]\n        >>> regsort({'a': 'b', 'b': 'a'}, R)\n        [('xchg', 'a', 'b')]\n        >>> regsort({'a': 'b', 'b': 'a'}, R, tmp='X') #doctest: +NORMALIZE_WHITESPACE\n        [('mov', 'X', 'a'),\n         ('mov', 'a', 'b'),\n         ('mov', 'b', 'X')]\n        >>> regsort({'a': 1, 'b': 'a'}, R) #doctest: +NORMALIZE_WHITESPACE\n        [('mov', 'b', 'a'),\n         ('mov', 'a', 1)]\n        >>> regsort({'a': 'b', 'b': 'a', 'c': 3}, R) #doctest: +NORMALIZE_WHITESPACE\n        [('mov', 'c', 3),\n         ('xchg', 'a', 'b')]\n        >>> regsort({'a': 'b', 'b': 'a', 'c': 'b'}, R) #doctest: +NORMALIZE_WHITESPACE\n        [('mov', 'c', 'b'),\n         ('xchg', 'a', 'b')]\n        >>> regsort({'a':'b', 'b':'a', 'x':'b'}, R, tmp='y', xchg=False) #doctest: +NORMALIZE_WHITESPACE\n        [('mov', 'x', 'b'),\n         ('mov', 'y', 'a'),\n         ('mov', 'a', 'b'),\n         ('mov', 'b', 'y')]\n        >>> regsort({'a':'b', 'b':'a', 'x':'b'}, R, tmp='x', xchg=False) #doctest: +ELLIPSIS\n        Traceback (most recent call last):\n        ...\n        PwnlibException: Cannot break dependency cycles ...\n        >>> regsort({'a':'b','b':'c','c':'a','x':'1','y':'z','z':'c'}, R) #doctest: +NORMALIZE_WHITESPACE\n        [('mov', 'x', '1'),\n         ('mov', 'y', 'z'),\n         ('mov', 'z', 'c'),\n         ('xchg', 'a', 'b'),\n         ('xchg', 'b', 'c')]\n        >>> regsort({'a':'b','b':'c','c':'a','x':'1','y':'z','z':'c'}, R, tmp='x') #doctest: +NORMALIZE_WHITESPACE\n        [('mov', 'y', 'z'),\n         ('mov', 'z', 'c'),\n         ('mov', 'x', 'a'),\n         ('mov', 'a', 'b'),\n         ('mov', 'b', 'c'),\n         ('mov', 'c', 'x'),\n         ('mov', 'x', '1')]\n        >>> regsort({'a':'b','b':'c','c':'a','x':'1','y':'z','z':'c'}, R, xchg=0) #doctest: +NORMALIZE_WHITESPACE\n        [('mov', 'y', 'z'),\n         ('mov', 'z', 'c'),\n         ('mov', 'x', 'a'),\n         ('mov', 'a', 'b'),\n         ('mov', 'b', 'c'),\n         ('mov', 'c', 'x'),\n         ('mov', 'x', '1')]\n         >>> regsort({'a': 'b', 'b': 'c'}, ['a','b','c'], xchg=0)\n         [('mov', 'a', 'b'), ('mov', 'b', 'c')]\n    \"\"\"\n    if randomize is None:\n        randomize = context.randomize\n    sentinel = object()\n    in_out = {k: v for (k, v) in in_out.items() if k != v}\n    v_k = defaultdict(list)\n    for (k, v) in sorted(in_out.items()):\n        if v not in all_regs and v != 0:\n            v_k[v].append(k)\n    post_mov = {}\n    for (v, ks) in sorted(v_k.items(), key=repr):\n        for k in ks[1:]:\n            post_mov[k] = ks[0]\n            in_out.pop(k)\n    if not all((k in all_regs for k in in_out)):\n        log.error('Unknown register! Know: %r.  Got: %r' % (all_regs, list(in_out)))\n    if not any((v in in_out for (k, v) in in_out.items())):\n        result = [('mov', k, in_out[k]) for k in sorted(in_out)]\n        if randomize:\n            shuffle(result)\n        for (dreg, sreg) in sorted(post_mov.items()):\n            result.append(('mov', dreg, sreg))\n        return result\n    deps = {r: extract_dependencies(r, in_out) for r in in_out}\n    result = []\n    cycle_candidates = sorted(list(in_out))\n    cycles = []\n    in_cycle = []\n    not_in_cycle = []\n    if randomize:\n        shuffle(cycle_candidates)\n    while cycle_candidates:\n        reg = cycle_candidates[0]\n        cycle = check_cycle(reg, in_out)\n        if cycle:\n            if randomize:\n                x = randint(0, len(cycle))\n                cycle = cycle[x:] + cycle[:x]\n            cycles.append(cycle)\n            in_cycle.extend(cycle)\n            for reg in cycle:\n                cycle_candidates.remove(reg)\n        else:\n            not_in_cycle.append(cycle_candidates.pop(0))\n    if depends_on_cycle(tmp, in_out, in_cycle):\n        tmp = None\n    if in_cycle and (not (xchg or tmp)):\n        for reg in in_out:\n            if not depends_on_cycle(reg, in_out, in_cycle):\n                tmp = reg\n                break\n        else:\n            nope = sorted(((k, v) for (k, v) in in_out.items()))\n            log.error('Cannot break dependency cycles in %r' % nope)\n    if tmp in not_in_cycle:\n        not_in_cycle.remove(tmp)\n    if randomize:\n        shuffle(not_in_cycle)\n    while not_in_cycle:\n        reg = not_in_cycle[0]\n        order = resolve_order(reg, deps)\n        for reg in order:\n            if reg not in not_in_cycle:\n                continue\n            src = in_out[reg]\n            result.append(('mov', reg, src))\n            not_in_cycle.remove(reg)\n            if reg in deps.get(src, []):\n                deps[src].remove(reg)\n    if randomize:\n        shuffle(cycles)\n    if tmp:\n        for cycle in cycles:\n            first = cycle[0]\n            last = cycle[-1]\n            deps[first].remove(last)\n            in_out[last] = tmp\n            order = resolve_order(last, deps)\n            result.append(('mov', tmp, first))\n            for reg in order:\n                result.append(('mov', reg, in_out[reg]))\n    else:\n        for cycle in cycles:\n            size = len(cycle)\n            for i in range(size - 1):\n                result.append(('xchg', cycle[i], cycle[(i + 1) % size]))\n    if tmp and tmp in in_out:\n        result.append(('mov', tmp, in_out[tmp]))\n    for (dreg, sreg) in sorted(post_mov.items()):\n        result.append(('mov', dreg, sreg))\n    return result",
        "mutated": [
            "def regsort(in_out, all_regs, tmp=None, xchg=True, randomize=None):\n    if False:\n        i = 10\n    \"\\n    Sorts register dependencies.\\n\\n    Given a dictionary of registers to desired register contents,\\n    return the optimal order in which to set the registers to\\n    those contents.\\n\\n    The implementation assumes that it is possible to move from\\n    any register to any other register.\\n\\n    If a dependency cycle is encountered, one of the following will\\n    occur:\\n\\n    - If ``xchg`` is :const:`True`, it is assumed that dependency cyles can\\n      be broken by swapping the contents of two register (a la the\\n      ``xchg`` instruction on i386).\\n    - If ``xchg`` is not set, but not all destination registers in\\n      ``in_out`` are involved in a cycle, one of the registers\\n      outside the cycle will be used as a temporary register,\\n      and then overwritten with its final value.\\n    - If ``xchg`` is not set, and all registers are involved in\\n      a dependency cycle, the named register ``temporary`` is used\\n      as a temporary register.\\n    - If the dependency cycle cannot be resolved as described above,\\n      an exception is raised.\\n\\n    Arguments:\\n\\n        in_out(dict):\\n            Dictionary of desired register states.\\n            Keys are registers, values are either registers or any other value.\\n        all_regs(list):\\n            List of all possible registers.\\n            Used to determine which values in ``in_out`` are registers, versus\\n            regular values.\\n        tmp(obj, str):\\n            Named register (or other sentinel value) to use as a temporary\\n            register.  If ``tmp`` is a named register **and** appears\\n            as a source value in ``in_out``, dependencies are handled\\n            appropriately.  ``tmp`` cannot be a destination register\\n            in ``in_out``.\\n            If ``bool(tmp)==True``, this mode is enabled.\\n        xchg(obj):\\n            Indicates the existence of an instruction which can swap the\\n            contents of two registers without use of a third register.\\n            If ``bool(xchg)==False``, this mode is disabled.\\n        random(bool):\\n            Randomize as much as possible about the order or registers.\\n\\n    Returns:\\n\\n        A list of tuples of ``(src, dest)``.\\n\\n        Each register may appear more than once, if a register is used\\n        as a temporary register, and later overwritten with its final\\n        value.\\n\\n        If ``xchg`` is :const:`True` and it is used to break a dependency cycle,\\n        then ``reg_name`` will be :const:`None` and ``value`` will be a tuple\\n        of the instructions to swap.\\n\\n    Example:\\n\\n        >>> R = ['a', 'b', 'c', 'd', 'x', 'y', 'z']\\n\\n        If order doesn't matter for any subsequence, alphabetic\\n        order is used.\\n\\n        >>> regsort({'a': 1, 'b': 2}, R)\\n        [('mov', 'a', 1), ('mov', 'b', 2)]\\n        >>> regsort({'a': 'b', 'b': 'a'}, R)\\n        [('xchg', 'a', 'b')]\\n        >>> regsort({'a': 'b', 'b': 'a'}, R, tmp='X') #doctest: +NORMALIZE_WHITESPACE\\n        [('mov', 'X', 'a'),\\n         ('mov', 'a', 'b'),\\n         ('mov', 'b', 'X')]\\n        >>> regsort({'a': 1, 'b': 'a'}, R) #doctest: +NORMALIZE_WHITESPACE\\n        [('mov', 'b', 'a'),\\n         ('mov', 'a', 1)]\\n        >>> regsort({'a': 'b', 'b': 'a', 'c': 3}, R) #doctest: +NORMALIZE_WHITESPACE\\n        [('mov', 'c', 3),\\n         ('xchg', 'a', 'b')]\\n        >>> regsort({'a': 'b', 'b': 'a', 'c': 'b'}, R) #doctest: +NORMALIZE_WHITESPACE\\n        [('mov', 'c', 'b'),\\n         ('xchg', 'a', 'b')]\\n        >>> regsort({'a':'b', 'b':'a', 'x':'b'}, R, tmp='y', xchg=False) #doctest: +NORMALIZE_WHITESPACE\\n        [('mov', 'x', 'b'),\\n         ('mov', 'y', 'a'),\\n         ('mov', 'a', 'b'),\\n         ('mov', 'b', 'y')]\\n        >>> regsort({'a':'b', 'b':'a', 'x':'b'}, R, tmp='x', xchg=False) #doctest: +ELLIPSIS\\n        Traceback (most recent call last):\\n        ...\\n        PwnlibException: Cannot break dependency cycles ...\\n        >>> regsort({'a':'b','b':'c','c':'a','x':'1','y':'z','z':'c'}, R) #doctest: +NORMALIZE_WHITESPACE\\n        [('mov', 'x', '1'),\\n         ('mov', 'y', 'z'),\\n         ('mov', 'z', 'c'),\\n         ('xchg', 'a', 'b'),\\n         ('xchg', 'b', 'c')]\\n        >>> regsort({'a':'b','b':'c','c':'a','x':'1','y':'z','z':'c'}, R, tmp='x') #doctest: +NORMALIZE_WHITESPACE\\n        [('mov', 'y', 'z'),\\n         ('mov', 'z', 'c'),\\n         ('mov', 'x', 'a'),\\n         ('mov', 'a', 'b'),\\n         ('mov', 'b', 'c'),\\n         ('mov', 'c', 'x'),\\n         ('mov', 'x', '1')]\\n        >>> regsort({'a':'b','b':'c','c':'a','x':'1','y':'z','z':'c'}, R, xchg=0) #doctest: +NORMALIZE_WHITESPACE\\n        [('mov', 'y', 'z'),\\n         ('mov', 'z', 'c'),\\n         ('mov', 'x', 'a'),\\n         ('mov', 'a', 'b'),\\n         ('mov', 'b', 'c'),\\n         ('mov', 'c', 'x'),\\n         ('mov', 'x', '1')]\\n         >>> regsort({'a': 'b', 'b': 'c'}, ['a','b','c'], xchg=0)\\n         [('mov', 'a', 'b'), ('mov', 'b', 'c')]\\n    \"\n    if randomize is None:\n        randomize = context.randomize\n    sentinel = object()\n    in_out = {k: v for (k, v) in in_out.items() if k != v}\n    v_k = defaultdict(list)\n    for (k, v) in sorted(in_out.items()):\n        if v not in all_regs and v != 0:\n            v_k[v].append(k)\n    post_mov = {}\n    for (v, ks) in sorted(v_k.items(), key=repr):\n        for k in ks[1:]:\n            post_mov[k] = ks[0]\n            in_out.pop(k)\n    if not all((k in all_regs for k in in_out)):\n        log.error('Unknown register! Know: %r.  Got: %r' % (all_regs, list(in_out)))\n    if not any((v in in_out for (k, v) in in_out.items())):\n        result = [('mov', k, in_out[k]) for k in sorted(in_out)]\n        if randomize:\n            shuffle(result)\n        for (dreg, sreg) in sorted(post_mov.items()):\n            result.append(('mov', dreg, sreg))\n        return result\n    deps = {r: extract_dependencies(r, in_out) for r in in_out}\n    result = []\n    cycle_candidates = sorted(list(in_out))\n    cycles = []\n    in_cycle = []\n    not_in_cycle = []\n    if randomize:\n        shuffle(cycle_candidates)\n    while cycle_candidates:\n        reg = cycle_candidates[0]\n        cycle = check_cycle(reg, in_out)\n        if cycle:\n            if randomize:\n                x = randint(0, len(cycle))\n                cycle = cycle[x:] + cycle[:x]\n            cycles.append(cycle)\n            in_cycle.extend(cycle)\n            for reg in cycle:\n                cycle_candidates.remove(reg)\n        else:\n            not_in_cycle.append(cycle_candidates.pop(0))\n    if depends_on_cycle(tmp, in_out, in_cycle):\n        tmp = None\n    if in_cycle and (not (xchg or tmp)):\n        for reg in in_out:\n            if not depends_on_cycle(reg, in_out, in_cycle):\n                tmp = reg\n                break\n        else:\n            nope = sorted(((k, v) for (k, v) in in_out.items()))\n            log.error('Cannot break dependency cycles in %r' % nope)\n    if tmp in not_in_cycle:\n        not_in_cycle.remove(tmp)\n    if randomize:\n        shuffle(not_in_cycle)\n    while not_in_cycle:\n        reg = not_in_cycle[0]\n        order = resolve_order(reg, deps)\n        for reg in order:\n            if reg not in not_in_cycle:\n                continue\n            src = in_out[reg]\n            result.append(('mov', reg, src))\n            not_in_cycle.remove(reg)\n            if reg in deps.get(src, []):\n                deps[src].remove(reg)\n    if randomize:\n        shuffle(cycles)\n    if tmp:\n        for cycle in cycles:\n            first = cycle[0]\n            last = cycle[-1]\n            deps[first].remove(last)\n            in_out[last] = tmp\n            order = resolve_order(last, deps)\n            result.append(('mov', tmp, first))\n            for reg in order:\n                result.append(('mov', reg, in_out[reg]))\n    else:\n        for cycle in cycles:\n            size = len(cycle)\n            for i in range(size - 1):\n                result.append(('xchg', cycle[i], cycle[(i + 1) % size]))\n    if tmp and tmp in in_out:\n        result.append(('mov', tmp, in_out[tmp]))\n    for (dreg, sreg) in sorted(post_mov.items()):\n        result.append(('mov', dreg, sreg))\n    return result",
            "def regsort(in_out, all_regs, tmp=None, xchg=True, randomize=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Sorts register dependencies.\\n\\n    Given a dictionary of registers to desired register contents,\\n    return the optimal order in which to set the registers to\\n    those contents.\\n\\n    The implementation assumes that it is possible to move from\\n    any register to any other register.\\n\\n    If a dependency cycle is encountered, one of the following will\\n    occur:\\n\\n    - If ``xchg`` is :const:`True`, it is assumed that dependency cyles can\\n      be broken by swapping the contents of two register (a la the\\n      ``xchg`` instruction on i386).\\n    - If ``xchg`` is not set, but not all destination registers in\\n      ``in_out`` are involved in a cycle, one of the registers\\n      outside the cycle will be used as a temporary register,\\n      and then overwritten with its final value.\\n    - If ``xchg`` is not set, and all registers are involved in\\n      a dependency cycle, the named register ``temporary`` is used\\n      as a temporary register.\\n    - If the dependency cycle cannot be resolved as described above,\\n      an exception is raised.\\n\\n    Arguments:\\n\\n        in_out(dict):\\n            Dictionary of desired register states.\\n            Keys are registers, values are either registers or any other value.\\n        all_regs(list):\\n            List of all possible registers.\\n            Used to determine which values in ``in_out`` are registers, versus\\n            regular values.\\n        tmp(obj, str):\\n            Named register (or other sentinel value) to use as a temporary\\n            register.  If ``tmp`` is a named register **and** appears\\n            as a source value in ``in_out``, dependencies are handled\\n            appropriately.  ``tmp`` cannot be a destination register\\n            in ``in_out``.\\n            If ``bool(tmp)==True``, this mode is enabled.\\n        xchg(obj):\\n            Indicates the existence of an instruction which can swap the\\n            contents of two registers without use of a third register.\\n            If ``bool(xchg)==False``, this mode is disabled.\\n        random(bool):\\n            Randomize as much as possible about the order or registers.\\n\\n    Returns:\\n\\n        A list of tuples of ``(src, dest)``.\\n\\n        Each register may appear more than once, if a register is used\\n        as a temporary register, and later overwritten with its final\\n        value.\\n\\n        If ``xchg`` is :const:`True` and it is used to break a dependency cycle,\\n        then ``reg_name`` will be :const:`None` and ``value`` will be a tuple\\n        of the instructions to swap.\\n\\n    Example:\\n\\n        >>> R = ['a', 'b', 'c', 'd', 'x', 'y', 'z']\\n\\n        If order doesn't matter for any subsequence, alphabetic\\n        order is used.\\n\\n        >>> regsort({'a': 1, 'b': 2}, R)\\n        [('mov', 'a', 1), ('mov', 'b', 2)]\\n        >>> regsort({'a': 'b', 'b': 'a'}, R)\\n        [('xchg', 'a', 'b')]\\n        >>> regsort({'a': 'b', 'b': 'a'}, R, tmp='X') #doctest: +NORMALIZE_WHITESPACE\\n        [('mov', 'X', 'a'),\\n         ('mov', 'a', 'b'),\\n         ('mov', 'b', 'X')]\\n        >>> regsort({'a': 1, 'b': 'a'}, R) #doctest: +NORMALIZE_WHITESPACE\\n        [('mov', 'b', 'a'),\\n         ('mov', 'a', 1)]\\n        >>> regsort({'a': 'b', 'b': 'a', 'c': 3}, R) #doctest: +NORMALIZE_WHITESPACE\\n        [('mov', 'c', 3),\\n         ('xchg', 'a', 'b')]\\n        >>> regsort({'a': 'b', 'b': 'a', 'c': 'b'}, R) #doctest: +NORMALIZE_WHITESPACE\\n        [('mov', 'c', 'b'),\\n         ('xchg', 'a', 'b')]\\n        >>> regsort({'a':'b', 'b':'a', 'x':'b'}, R, tmp='y', xchg=False) #doctest: +NORMALIZE_WHITESPACE\\n        [('mov', 'x', 'b'),\\n         ('mov', 'y', 'a'),\\n         ('mov', 'a', 'b'),\\n         ('mov', 'b', 'y')]\\n        >>> regsort({'a':'b', 'b':'a', 'x':'b'}, R, tmp='x', xchg=False) #doctest: +ELLIPSIS\\n        Traceback (most recent call last):\\n        ...\\n        PwnlibException: Cannot break dependency cycles ...\\n        >>> regsort({'a':'b','b':'c','c':'a','x':'1','y':'z','z':'c'}, R) #doctest: +NORMALIZE_WHITESPACE\\n        [('mov', 'x', '1'),\\n         ('mov', 'y', 'z'),\\n         ('mov', 'z', 'c'),\\n         ('xchg', 'a', 'b'),\\n         ('xchg', 'b', 'c')]\\n        >>> regsort({'a':'b','b':'c','c':'a','x':'1','y':'z','z':'c'}, R, tmp='x') #doctest: +NORMALIZE_WHITESPACE\\n        [('mov', 'y', 'z'),\\n         ('mov', 'z', 'c'),\\n         ('mov', 'x', 'a'),\\n         ('mov', 'a', 'b'),\\n         ('mov', 'b', 'c'),\\n         ('mov', 'c', 'x'),\\n         ('mov', 'x', '1')]\\n        >>> regsort({'a':'b','b':'c','c':'a','x':'1','y':'z','z':'c'}, R, xchg=0) #doctest: +NORMALIZE_WHITESPACE\\n        [('mov', 'y', 'z'),\\n         ('mov', 'z', 'c'),\\n         ('mov', 'x', 'a'),\\n         ('mov', 'a', 'b'),\\n         ('mov', 'b', 'c'),\\n         ('mov', 'c', 'x'),\\n         ('mov', 'x', '1')]\\n         >>> regsort({'a': 'b', 'b': 'c'}, ['a','b','c'], xchg=0)\\n         [('mov', 'a', 'b'), ('mov', 'b', 'c')]\\n    \"\n    if randomize is None:\n        randomize = context.randomize\n    sentinel = object()\n    in_out = {k: v for (k, v) in in_out.items() if k != v}\n    v_k = defaultdict(list)\n    for (k, v) in sorted(in_out.items()):\n        if v not in all_regs and v != 0:\n            v_k[v].append(k)\n    post_mov = {}\n    for (v, ks) in sorted(v_k.items(), key=repr):\n        for k in ks[1:]:\n            post_mov[k] = ks[0]\n            in_out.pop(k)\n    if not all((k in all_regs for k in in_out)):\n        log.error('Unknown register! Know: %r.  Got: %r' % (all_regs, list(in_out)))\n    if not any((v in in_out for (k, v) in in_out.items())):\n        result = [('mov', k, in_out[k]) for k in sorted(in_out)]\n        if randomize:\n            shuffle(result)\n        for (dreg, sreg) in sorted(post_mov.items()):\n            result.append(('mov', dreg, sreg))\n        return result\n    deps = {r: extract_dependencies(r, in_out) for r in in_out}\n    result = []\n    cycle_candidates = sorted(list(in_out))\n    cycles = []\n    in_cycle = []\n    not_in_cycle = []\n    if randomize:\n        shuffle(cycle_candidates)\n    while cycle_candidates:\n        reg = cycle_candidates[0]\n        cycle = check_cycle(reg, in_out)\n        if cycle:\n            if randomize:\n                x = randint(0, len(cycle))\n                cycle = cycle[x:] + cycle[:x]\n            cycles.append(cycle)\n            in_cycle.extend(cycle)\n            for reg in cycle:\n                cycle_candidates.remove(reg)\n        else:\n            not_in_cycle.append(cycle_candidates.pop(0))\n    if depends_on_cycle(tmp, in_out, in_cycle):\n        tmp = None\n    if in_cycle and (not (xchg or tmp)):\n        for reg in in_out:\n            if not depends_on_cycle(reg, in_out, in_cycle):\n                tmp = reg\n                break\n        else:\n            nope = sorted(((k, v) for (k, v) in in_out.items()))\n            log.error('Cannot break dependency cycles in %r' % nope)\n    if tmp in not_in_cycle:\n        not_in_cycle.remove(tmp)\n    if randomize:\n        shuffle(not_in_cycle)\n    while not_in_cycle:\n        reg = not_in_cycle[0]\n        order = resolve_order(reg, deps)\n        for reg in order:\n            if reg not in not_in_cycle:\n                continue\n            src = in_out[reg]\n            result.append(('mov', reg, src))\n            not_in_cycle.remove(reg)\n            if reg in deps.get(src, []):\n                deps[src].remove(reg)\n    if randomize:\n        shuffle(cycles)\n    if tmp:\n        for cycle in cycles:\n            first = cycle[0]\n            last = cycle[-1]\n            deps[first].remove(last)\n            in_out[last] = tmp\n            order = resolve_order(last, deps)\n            result.append(('mov', tmp, first))\n            for reg in order:\n                result.append(('mov', reg, in_out[reg]))\n    else:\n        for cycle in cycles:\n            size = len(cycle)\n            for i in range(size - 1):\n                result.append(('xchg', cycle[i], cycle[(i + 1) % size]))\n    if tmp and tmp in in_out:\n        result.append(('mov', tmp, in_out[tmp]))\n    for (dreg, sreg) in sorted(post_mov.items()):\n        result.append(('mov', dreg, sreg))\n    return result",
            "def regsort(in_out, all_regs, tmp=None, xchg=True, randomize=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Sorts register dependencies.\\n\\n    Given a dictionary of registers to desired register contents,\\n    return the optimal order in which to set the registers to\\n    those contents.\\n\\n    The implementation assumes that it is possible to move from\\n    any register to any other register.\\n\\n    If a dependency cycle is encountered, one of the following will\\n    occur:\\n\\n    - If ``xchg`` is :const:`True`, it is assumed that dependency cyles can\\n      be broken by swapping the contents of two register (a la the\\n      ``xchg`` instruction on i386).\\n    - If ``xchg`` is not set, but not all destination registers in\\n      ``in_out`` are involved in a cycle, one of the registers\\n      outside the cycle will be used as a temporary register,\\n      and then overwritten with its final value.\\n    - If ``xchg`` is not set, and all registers are involved in\\n      a dependency cycle, the named register ``temporary`` is used\\n      as a temporary register.\\n    - If the dependency cycle cannot be resolved as described above,\\n      an exception is raised.\\n\\n    Arguments:\\n\\n        in_out(dict):\\n            Dictionary of desired register states.\\n            Keys are registers, values are either registers or any other value.\\n        all_regs(list):\\n            List of all possible registers.\\n            Used to determine which values in ``in_out`` are registers, versus\\n            regular values.\\n        tmp(obj, str):\\n            Named register (or other sentinel value) to use as a temporary\\n            register.  If ``tmp`` is a named register **and** appears\\n            as a source value in ``in_out``, dependencies are handled\\n            appropriately.  ``tmp`` cannot be a destination register\\n            in ``in_out``.\\n            If ``bool(tmp)==True``, this mode is enabled.\\n        xchg(obj):\\n            Indicates the existence of an instruction which can swap the\\n            contents of two registers without use of a third register.\\n            If ``bool(xchg)==False``, this mode is disabled.\\n        random(bool):\\n            Randomize as much as possible about the order or registers.\\n\\n    Returns:\\n\\n        A list of tuples of ``(src, dest)``.\\n\\n        Each register may appear more than once, if a register is used\\n        as a temporary register, and later overwritten with its final\\n        value.\\n\\n        If ``xchg`` is :const:`True` and it is used to break a dependency cycle,\\n        then ``reg_name`` will be :const:`None` and ``value`` will be a tuple\\n        of the instructions to swap.\\n\\n    Example:\\n\\n        >>> R = ['a', 'b', 'c', 'd', 'x', 'y', 'z']\\n\\n        If order doesn't matter for any subsequence, alphabetic\\n        order is used.\\n\\n        >>> regsort({'a': 1, 'b': 2}, R)\\n        [('mov', 'a', 1), ('mov', 'b', 2)]\\n        >>> regsort({'a': 'b', 'b': 'a'}, R)\\n        [('xchg', 'a', 'b')]\\n        >>> regsort({'a': 'b', 'b': 'a'}, R, tmp='X') #doctest: +NORMALIZE_WHITESPACE\\n        [('mov', 'X', 'a'),\\n         ('mov', 'a', 'b'),\\n         ('mov', 'b', 'X')]\\n        >>> regsort({'a': 1, 'b': 'a'}, R) #doctest: +NORMALIZE_WHITESPACE\\n        [('mov', 'b', 'a'),\\n         ('mov', 'a', 1)]\\n        >>> regsort({'a': 'b', 'b': 'a', 'c': 3}, R) #doctest: +NORMALIZE_WHITESPACE\\n        [('mov', 'c', 3),\\n         ('xchg', 'a', 'b')]\\n        >>> regsort({'a': 'b', 'b': 'a', 'c': 'b'}, R) #doctest: +NORMALIZE_WHITESPACE\\n        [('mov', 'c', 'b'),\\n         ('xchg', 'a', 'b')]\\n        >>> regsort({'a':'b', 'b':'a', 'x':'b'}, R, tmp='y', xchg=False) #doctest: +NORMALIZE_WHITESPACE\\n        [('mov', 'x', 'b'),\\n         ('mov', 'y', 'a'),\\n         ('mov', 'a', 'b'),\\n         ('mov', 'b', 'y')]\\n        >>> regsort({'a':'b', 'b':'a', 'x':'b'}, R, tmp='x', xchg=False) #doctest: +ELLIPSIS\\n        Traceback (most recent call last):\\n        ...\\n        PwnlibException: Cannot break dependency cycles ...\\n        >>> regsort({'a':'b','b':'c','c':'a','x':'1','y':'z','z':'c'}, R) #doctest: +NORMALIZE_WHITESPACE\\n        [('mov', 'x', '1'),\\n         ('mov', 'y', 'z'),\\n         ('mov', 'z', 'c'),\\n         ('xchg', 'a', 'b'),\\n         ('xchg', 'b', 'c')]\\n        >>> regsort({'a':'b','b':'c','c':'a','x':'1','y':'z','z':'c'}, R, tmp='x') #doctest: +NORMALIZE_WHITESPACE\\n        [('mov', 'y', 'z'),\\n         ('mov', 'z', 'c'),\\n         ('mov', 'x', 'a'),\\n         ('mov', 'a', 'b'),\\n         ('mov', 'b', 'c'),\\n         ('mov', 'c', 'x'),\\n         ('mov', 'x', '1')]\\n        >>> regsort({'a':'b','b':'c','c':'a','x':'1','y':'z','z':'c'}, R, xchg=0) #doctest: +NORMALIZE_WHITESPACE\\n        [('mov', 'y', 'z'),\\n         ('mov', 'z', 'c'),\\n         ('mov', 'x', 'a'),\\n         ('mov', 'a', 'b'),\\n         ('mov', 'b', 'c'),\\n         ('mov', 'c', 'x'),\\n         ('mov', 'x', '1')]\\n         >>> regsort({'a': 'b', 'b': 'c'}, ['a','b','c'], xchg=0)\\n         [('mov', 'a', 'b'), ('mov', 'b', 'c')]\\n    \"\n    if randomize is None:\n        randomize = context.randomize\n    sentinel = object()\n    in_out = {k: v for (k, v) in in_out.items() if k != v}\n    v_k = defaultdict(list)\n    for (k, v) in sorted(in_out.items()):\n        if v not in all_regs and v != 0:\n            v_k[v].append(k)\n    post_mov = {}\n    for (v, ks) in sorted(v_k.items(), key=repr):\n        for k in ks[1:]:\n            post_mov[k] = ks[0]\n            in_out.pop(k)\n    if not all((k in all_regs for k in in_out)):\n        log.error('Unknown register! Know: %r.  Got: %r' % (all_regs, list(in_out)))\n    if not any((v in in_out for (k, v) in in_out.items())):\n        result = [('mov', k, in_out[k]) for k in sorted(in_out)]\n        if randomize:\n            shuffle(result)\n        for (dreg, sreg) in sorted(post_mov.items()):\n            result.append(('mov', dreg, sreg))\n        return result\n    deps = {r: extract_dependencies(r, in_out) for r in in_out}\n    result = []\n    cycle_candidates = sorted(list(in_out))\n    cycles = []\n    in_cycle = []\n    not_in_cycle = []\n    if randomize:\n        shuffle(cycle_candidates)\n    while cycle_candidates:\n        reg = cycle_candidates[0]\n        cycle = check_cycle(reg, in_out)\n        if cycle:\n            if randomize:\n                x = randint(0, len(cycle))\n                cycle = cycle[x:] + cycle[:x]\n            cycles.append(cycle)\n            in_cycle.extend(cycle)\n            for reg in cycle:\n                cycle_candidates.remove(reg)\n        else:\n            not_in_cycle.append(cycle_candidates.pop(0))\n    if depends_on_cycle(tmp, in_out, in_cycle):\n        tmp = None\n    if in_cycle and (not (xchg or tmp)):\n        for reg in in_out:\n            if not depends_on_cycle(reg, in_out, in_cycle):\n                tmp = reg\n                break\n        else:\n            nope = sorted(((k, v) for (k, v) in in_out.items()))\n            log.error('Cannot break dependency cycles in %r' % nope)\n    if tmp in not_in_cycle:\n        not_in_cycle.remove(tmp)\n    if randomize:\n        shuffle(not_in_cycle)\n    while not_in_cycle:\n        reg = not_in_cycle[0]\n        order = resolve_order(reg, deps)\n        for reg in order:\n            if reg not in not_in_cycle:\n                continue\n            src = in_out[reg]\n            result.append(('mov', reg, src))\n            not_in_cycle.remove(reg)\n            if reg in deps.get(src, []):\n                deps[src].remove(reg)\n    if randomize:\n        shuffle(cycles)\n    if tmp:\n        for cycle in cycles:\n            first = cycle[0]\n            last = cycle[-1]\n            deps[first].remove(last)\n            in_out[last] = tmp\n            order = resolve_order(last, deps)\n            result.append(('mov', tmp, first))\n            for reg in order:\n                result.append(('mov', reg, in_out[reg]))\n    else:\n        for cycle in cycles:\n            size = len(cycle)\n            for i in range(size - 1):\n                result.append(('xchg', cycle[i], cycle[(i + 1) % size]))\n    if tmp and tmp in in_out:\n        result.append(('mov', tmp, in_out[tmp]))\n    for (dreg, sreg) in sorted(post_mov.items()):\n        result.append(('mov', dreg, sreg))\n    return result",
            "def regsort(in_out, all_regs, tmp=None, xchg=True, randomize=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Sorts register dependencies.\\n\\n    Given a dictionary of registers to desired register contents,\\n    return the optimal order in which to set the registers to\\n    those contents.\\n\\n    The implementation assumes that it is possible to move from\\n    any register to any other register.\\n\\n    If a dependency cycle is encountered, one of the following will\\n    occur:\\n\\n    - If ``xchg`` is :const:`True`, it is assumed that dependency cyles can\\n      be broken by swapping the contents of two register (a la the\\n      ``xchg`` instruction on i386).\\n    - If ``xchg`` is not set, but not all destination registers in\\n      ``in_out`` are involved in a cycle, one of the registers\\n      outside the cycle will be used as a temporary register,\\n      and then overwritten with its final value.\\n    - If ``xchg`` is not set, and all registers are involved in\\n      a dependency cycle, the named register ``temporary`` is used\\n      as a temporary register.\\n    - If the dependency cycle cannot be resolved as described above,\\n      an exception is raised.\\n\\n    Arguments:\\n\\n        in_out(dict):\\n            Dictionary of desired register states.\\n            Keys are registers, values are either registers or any other value.\\n        all_regs(list):\\n            List of all possible registers.\\n            Used to determine which values in ``in_out`` are registers, versus\\n            regular values.\\n        tmp(obj, str):\\n            Named register (or other sentinel value) to use as a temporary\\n            register.  If ``tmp`` is a named register **and** appears\\n            as a source value in ``in_out``, dependencies are handled\\n            appropriately.  ``tmp`` cannot be a destination register\\n            in ``in_out``.\\n            If ``bool(tmp)==True``, this mode is enabled.\\n        xchg(obj):\\n            Indicates the existence of an instruction which can swap the\\n            contents of two registers without use of a third register.\\n            If ``bool(xchg)==False``, this mode is disabled.\\n        random(bool):\\n            Randomize as much as possible about the order or registers.\\n\\n    Returns:\\n\\n        A list of tuples of ``(src, dest)``.\\n\\n        Each register may appear more than once, if a register is used\\n        as a temporary register, and later overwritten with its final\\n        value.\\n\\n        If ``xchg`` is :const:`True` and it is used to break a dependency cycle,\\n        then ``reg_name`` will be :const:`None` and ``value`` will be a tuple\\n        of the instructions to swap.\\n\\n    Example:\\n\\n        >>> R = ['a', 'b', 'c', 'd', 'x', 'y', 'z']\\n\\n        If order doesn't matter for any subsequence, alphabetic\\n        order is used.\\n\\n        >>> regsort({'a': 1, 'b': 2}, R)\\n        [('mov', 'a', 1), ('mov', 'b', 2)]\\n        >>> regsort({'a': 'b', 'b': 'a'}, R)\\n        [('xchg', 'a', 'b')]\\n        >>> regsort({'a': 'b', 'b': 'a'}, R, tmp='X') #doctest: +NORMALIZE_WHITESPACE\\n        [('mov', 'X', 'a'),\\n         ('mov', 'a', 'b'),\\n         ('mov', 'b', 'X')]\\n        >>> regsort({'a': 1, 'b': 'a'}, R) #doctest: +NORMALIZE_WHITESPACE\\n        [('mov', 'b', 'a'),\\n         ('mov', 'a', 1)]\\n        >>> regsort({'a': 'b', 'b': 'a', 'c': 3}, R) #doctest: +NORMALIZE_WHITESPACE\\n        [('mov', 'c', 3),\\n         ('xchg', 'a', 'b')]\\n        >>> regsort({'a': 'b', 'b': 'a', 'c': 'b'}, R) #doctest: +NORMALIZE_WHITESPACE\\n        [('mov', 'c', 'b'),\\n         ('xchg', 'a', 'b')]\\n        >>> regsort({'a':'b', 'b':'a', 'x':'b'}, R, tmp='y', xchg=False) #doctest: +NORMALIZE_WHITESPACE\\n        [('mov', 'x', 'b'),\\n         ('mov', 'y', 'a'),\\n         ('mov', 'a', 'b'),\\n         ('mov', 'b', 'y')]\\n        >>> regsort({'a':'b', 'b':'a', 'x':'b'}, R, tmp='x', xchg=False) #doctest: +ELLIPSIS\\n        Traceback (most recent call last):\\n        ...\\n        PwnlibException: Cannot break dependency cycles ...\\n        >>> regsort({'a':'b','b':'c','c':'a','x':'1','y':'z','z':'c'}, R) #doctest: +NORMALIZE_WHITESPACE\\n        [('mov', 'x', '1'),\\n         ('mov', 'y', 'z'),\\n         ('mov', 'z', 'c'),\\n         ('xchg', 'a', 'b'),\\n         ('xchg', 'b', 'c')]\\n        >>> regsort({'a':'b','b':'c','c':'a','x':'1','y':'z','z':'c'}, R, tmp='x') #doctest: +NORMALIZE_WHITESPACE\\n        [('mov', 'y', 'z'),\\n         ('mov', 'z', 'c'),\\n         ('mov', 'x', 'a'),\\n         ('mov', 'a', 'b'),\\n         ('mov', 'b', 'c'),\\n         ('mov', 'c', 'x'),\\n         ('mov', 'x', '1')]\\n        >>> regsort({'a':'b','b':'c','c':'a','x':'1','y':'z','z':'c'}, R, xchg=0) #doctest: +NORMALIZE_WHITESPACE\\n        [('mov', 'y', 'z'),\\n         ('mov', 'z', 'c'),\\n         ('mov', 'x', 'a'),\\n         ('mov', 'a', 'b'),\\n         ('mov', 'b', 'c'),\\n         ('mov', 'c', 'x'),\\n         ('mov', 'x', '1')]\\n         >>> regsort({'a': 'b', 'b': 'c'}, ['a','b','c'], xchg=0)\\n         [('mov', 'a', 'b'), ('mov', 'b', 'c')]\\n    \"\n    if randomize is None:\n        randomize = context.randomize\n    sentinel = object()\n    in_out = {k: v for (k, v) in in_out.items() if k != v}\n    v_k = defaultdict(list)\n    for (k, v) in sorted(in_out.items()):\n        if v not in all_regs and v != 0:\n            v_k[v].append(k)\n    post_mov = {}\n    for (v, ks) in sorted(v_k.items(), key=repr):\n        for k in ks[1:]:\n            post_mov[k] = ks[0]\n            in_out.pop(k)\n    if not all((k in all_regs for k in in_out)):\n        log.error('Unknown register! Know: %r.  Got: %r' % (all_regs, list(in_out)))\n    if not any((v in in_out for (k, v) in in_out.items())):\n        result = [('mov', k, in_out[k]) for k in sorted(in_out)]\n        if randomize:\n            shuffle(result)\n        for (dreg, sreg) in sorted(post_mov.items()):\n            result.append(('mov', dreg, sreg))\n        return result\n    deps = {r: extract_dependencies(r, in_out) for r in in_out}\n    result = []\n    cycle_candidates = sorted(list(in_out))\n    cycles = []\n    in_cycle = []\n    not_in_cycle = []\n    if randomize:\n        shuffle(cycle_candidates)\n    while cycle_candidates:\n        reg = cycle_candidates[0]\n        cycle = check_cycle(reg, in_out)\n        if cycle:\n            if randomize:\n                x = randint(0, len(cycle))\n                cycle = cycle[x:] + cycle[:x]\n            cycles.append(cycle)\n            in_cycle.extend(cycle)\n            for reg in cycle:\n                cycle_candidates.remove(reg)\n        else:\n            not_in_cycle.append(cycle_candidates.pop(0))\n    if depends_on_cycle(tmp, in_out, in_cycle):\n        tmp = None\n    if in_cycle and (not (xchg or tmp)):\n        for reg in in_out:\n            if not depends_on_cycle(reg, in_out, in_cycle):\n                tmp = reg\n                break\n        else:\n            nope = sorted(((k, v) for (k, v) in in_out.items()))\n            log.error('Cannot break dependency cycles in %r' % nope)\n    if tmp in not_in_cycle:\n        not_in_cycle.remove(tmp)\n    if randomize:\n        shuffle(not_in_cycle)\n    while not_in_cycle:\n        reg = not_in_cycle[0]\n        order = resolve_order(reg, deps)\n        for reg in order:\n            if reg not in not_in_cycle:\n                continue\n            src = in_out[reg]\n            result.append(('mov', reg, src))\n            not_in_cycle.remove(reg)\n            if reg in deps.get(src, []):\n                deps[src].remove(reg)\n    if randomize:\n        shuffle(cycles)\n    if tmp:\n        for cycle in cycles:\n            first = cycle[0]\n            last = cycle[-1]\n            deps[first].remove(last)\n            in_out[last] = tmp\n            order = resolve_order(last, deps)\n            result.append(('mov', tmp, first))\n            for reg in order:\n                result.append(('mov', reg, in_out[reg]))\n    else:\n        for cycle in cycles:\n            size = len(cycle)\n            for i in range(size - 1):\n                result.append(('xchg', cycle[i], cycle[(i + 1) % size]))\n    if tmp and tmp in in_out:\n        result.append(('mov', tmp, in_out[tmp]))\n    for (dreg, sreg) in sorted(post_mov.items()):\n        result.append(('mov', dreg, sreg))\n    return result",
            "def regsort(in_out, all_regs, tmp=None, xchg=True, randomize=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Sorts register dependencies.\\n\\n    Given a dictionary of registers to desired register contents,\\n    return the optimal order in which to set the registers to\\n    those contents.\\n\\n    The implementation assumes that it is possible to move from\\n    any register to any other register.\\n\\n    If a dependency cycle is encountered, one of the following will\\n    occur:\\n\\n    - If ``xchg`` is :const:`True`, it is assumed that dependency cyles can\\n      be broken by swapping the contents of two register (a la the\\n      ``xchg`` instruction on i386).\\n    - If ``xchg`` is not set, but not all destination registers in\\n      ``in_out`` are involved in a cycle, one of the registers\\n      outside the cycle will be used as a temporary register,\\n      and then overwritten with its final value.\\n    - If ``xchg`` is not set, and all registers are involved in\\n      a dependency cycle, the named register ``temporary`` is used\\n      as a temporary register.\\n    - If the dependency cycle cannot be resolved as described above,\\n      an exception is raised.\\n\\n    Arguments:\\n\\n        in_out(dict):\\n            Dictionary of desired register states.\\n            Keys are registers, values are either registers or any other value.\\n        all_regs(list):\\n            List of all possible registers.\\n            Used to determine which values in ``in_out`` are registers, versus\\n            regular values.\\n        tmp(obj, str):\\n            Named register (or other sentinel value) to use as a temporary\\n            register.  If ``tmp`` is a named register **and** appears\\n            as a source value in ``in_out``, dependencies are handled\\n            appropriately.  ``tmp`` cannot be a destination register\\n            in ``in_out``.\\n            If ``bool(tmp)==True``, this mode is enabled.\\n        xchg(obj):\\n            Indicates the existence of an instruction which can swap the\\n            contents of two registers without use of a third register.\\n            If ``bool(xchg)==False``, this mode is disabled.\\n        random(bool):\\n            Randomize as much as possible about the order or registers.\\n\\n    Returns:\\n\\n        A list of tuples of ``(src, dest)``.\\n\\n        Each register may appear more than once, if a register is used\\n        as a temporary register, and later overwritten with its final\\n        value.\\n\\n        If ``xchg`` is :const:`True` and it is used to break a dependency cycle,\\n        then ``reg_name`` will be :const:`None` and ``value`` will be a tuple\\n        of the instructions to swap.\\n\\n    Example:\\n\\n        >>> R = ['a', 'b', 'c', 'd', 'x', 'y', 'z']\\n\\n        If order doesn't matter for any subsequence, alphabetic\\n        order is used.\\n\\n        >>> regsort({'a': 1, 'b': 2}, R)\\n        [('mov', 'a', 1), ('mov', 'b', 2)]\\n        >>> regsort({'a': 'b', 'b': 'a'}, R)\\n        [('xchg', 'a', 'b')]\\n        >>> regsort({'a': 'b', 'b': 'a'}, R, tmp='X') #doctest: +NORMALIZE_WHITESPACE\\n        [('mov', 'X', 'a'),\\n         ('mov', 'a', 'b'),\\n         ('mov', 'b', 'X')]\\n        >>> regsort({'a': 1, 'b': 'a'}, R) #doctest: +NORMALIZE_WHITESPACE\\n        [('mov', 'b', 'a'),\\n         ('mov', 'a', 1)]\\n        >>> regsort({'a': 'b', 'b': 'a', 'c': 3}, R) #doctest: +NORMALIZE_WHITESPACE\\n        [('mov', 'c', 3),\\n         ('xchg', 'a', 'b')]\\n        >>> regsort({'a': 'b', 'b': 'a', 'c': 'b'}, R) #doctest: +NORMALIZE_WHITESPACE\\n        [('mov', 'c', 'b'),\\n         ('xchg', 'a', 'b')]\\n        >>> regsort({'a':'b', 'b':'a', 'x':'b'}, R, tmp='y', xchg=False) #doctest: +NORMALIZE_WHITESPACE\\n        [('mov', 'x', 'b'),\\n         ('mov', 'y', 'a'),\\n         ('mov', 'a', 'b'),\\n         ('mov', 'b', 'y')]\\n        >>> regsort({'a':'b', 'b':'a', 'x':'b'}, R, tmp='x', xchg=False) #doctest: +ELLIPSIS\\n        Traceback (most recent call last):\\n        ...\\n        PwnlibException: Cannot break dependency cycles ...\\n        >>> regsort({'a':'b','b':'c','c':'a','x':'1','y':'z','z':'c'}, R) #doctest: +NORMALIZE_WHITESPACE\\n        [('mov', 'x', '1'),\\n         ('mov', 'y', 'z'),\\n         ('mov', 'z', 'c'),\\n         ('xchg', 'a', 'b'),\\n         ('xchg', 'b', 'c')]\\n        >>> regsort({'a':'b','b':'c','c':'a','x':'1','y':'z','z':'c'}, R, tmp='x') #doctest: +NORMALIZE_WHITESPACE\\n        [('mov', 'y', 'z'),\\n         ('mov', 'z', 'c'),\\n         ('mov', 'x', 'a'),\\n         ('mov', 'a', 'b'),\\n         ('mov', 'b', 'c'),\\n         ('mov', 'c', 'x'),\\n         ('mov', 'x', '1')]\\n        >>> regsort({'a':'b','b':'c','c':'a','x':'1','y':'z','z':'c'}, R, xchg=0) #doctest: +NORMALIZE_WHITESPACE\\n        [('mov', 'y', 'z'),\\n         ('mov', 'z', 'c'),\\n         ('mov', 'x', 'a'),\\n         ('mov', 'a', 'b'),\\n         ('mov', 'b', 'c'),\\n         ('mov', 'c', 'x'),\\n         ('mov', 'x', '1')]\\n         >>> regsort({'a': 'b', 'b': 'c'}, ['a','b','c'], xchg=0)\\n         [('mov', 'a', 'b'), ('mov', 'b', 'c')]\\n    \"\n    if randomize is None:\n        randomize = context.randomize\n    sentinel = object()\n    in_out = {k: v for (k, v) in in_out.items() if k != v}\n    v_k = defaultdict(list)\n    for (k, v) in sorted(in_out.items()):\n        if v not in all_regs and v != 0:\n            v_k[v].append(k)\n    post_mov = {}\n    for (v, ks) in sorted(v_k.items(), key=repr):\n        for k in ks[1:]:\n            post_mov[k] = ks[0]\n            in_out.pop(k)\n    if not all((k in all_regs for k in in_out)):\n        log.error('Unknown register! Know: %r.  Got: %r' % (all_regs, list(in_out)))\n    if not any((v in in_out for (k, v) in in_out.items())):\n        result = [('mov', k, in_out[k]) for k in sorted(in_out)]\n        if randomize:\n            shuffle(result)\n        for (dreg, sreg) in sorted(post_mov.items()):\n            result.append(('mov', dreg, sreg))\n        return result\n    deps = {r: extract_dependencies(r, in_out) for r in in_out}\n    result = []\n    cycle_candidates = sorted(list(in_out))\n    cycles = []\n    in_cycle = []\n    not_in_cycle = []\n    if randomize:\n        shuffle(cycle_candidates)\n    while cycle_candidates:\n        reg = cycle_candidates[0]\n        cycle = check_cycle(reg, in_out)\n        if cycle:\n            if randomize:\n                x = randint(0, len(cycle))\n                cycle = cycle[x:] + cycle[:x]\n            cycles.append(cycle)\n            in_cycle.extend(cycle)\n            for reg in cycle:\n                cycle_candidates.remove(reg)\n        else:\n            not_in_cycle.append(cycle_candidates.pop(0))\n    if depends_on_cycle(tmp, in_out, in_cycle):\n        tmp = None\n    if in_cycle and (not (xchg or tmp)):\n        for reg in in_out:\n            if not depends_on_cycle(reg, in_out, in_cycle):\n                tmp = reg\n                break\n        else:\n            nope = sorted(((k, v) for (k, v) in in_out.items()))\n            log.error('Cannot break dependency cycles in %r' % nope)\n    if tmp in not_in_cycle:\n        not_in_cycle.remove(tmp)\n    if randomize:\n        shuffle(not_in_cycle)\n    while not_in_cycle:\n        reg = not_in_cycle[0]\n        order = resolve_order(reg, deps)\n        for reg in order:\n            if reg not in not_in_cycle:\n                continue\n            src = in_out[reg]\n            result.append(('mov', reg, src))\n            not_in_cycle.remove(reg)\n            if reg in deps.get(src, []):\n                deps[src].remove(reg)\n    if randomize:\n        shuffle(cycles)\n    if tmp:\n        for cycle in cycles:\n            first = cycle[0]\n            last = cycle[-1]\n            deps[first].remove(last)\n            in_out[last] = tmp\n            order = resolve_order(last, deps)\n            result.append(('mov', tmp, first))\n            for reg in order:\n                result.append(('mov', reg, in_out[reg]))\n    else:\n        for cycle in cycles:\n            size = len(cycle)\n            for i in range(size - 1):\n                result.append(('xchg', cycle[i], cycle[(i + 1) % size]))\n    if tmp and tmp in in_out:\n        result.append(('mov', tmp, in_out[tmp]))\n    for (dreg, sreg) in sorted(post_mov.items()):\n        result.append(('mov', dreg, sreg))\n    return result"
        ]
    }
]