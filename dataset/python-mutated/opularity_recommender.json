[
    {
        "func_name": "create",
        "original": "def create(observation_data, user_id='user_id', item_id='item_id', target=None, user_data=None, item_data=None, random_seed=0, verbose=True):\n    \"\"\"\n    Create a model that makes recommendations using item popularity. When no\n    target column is provided, the popularity is determined by the number of\n    observations involving each item. When a target is provided, popularity\n    is computed using the item's mean target value. When the target column\n    contains ratings, for example, the model computes the mean rating for\n    each item and uses this to rank items for recommendations.\n\n    Parameters\n    ----------\n    observation_data : SFrame\n        The dataset to use for training the model. It must contain a column of\n        user ids and a column of item ids. Each row represents an observed\n        interaction between the user and the item.  The (user, item) pairs\n        are stored with the model so that they can later be excluded from\n        recommendations if desired. It can optionally contain a target ratings\n        column. All other columns are interpreted by the underlying model as\n        side features for the observations.\n\n        The user id and item id columns must be of type 'int' or 'str'. The\n        target column must be of type 'int' or 'float'.\n\n    user_id : string, optional\n        The name of the column in `observation_data` that corresponds to the\n        user id.\n\n    item_id : string, optional\n        The name of the column in `observation_data` that corresponds to the\n        item id.\n\n    target : string, optional\n        The `observation_data` can optionally contain a column of scores\n        representing ratings given by the users. If present, the name of this\n        column may be specified variables `target`.\n\n    user_data : SFrame, optional\n        Side information for the users.  This SFrame must have a column with\n        the same name as what is specified by the `user_id` input parameter.\n        `user_data` can provide any amount of additional user-specific\n        information.\n\n    item_data : SFrame, optional\n        Side information for the items.  This SFrame must have a column with\n        the same name as what is specified by the `item_id` input parameter.\n        `item_data` can provide any amount of additional item-specific\n        information.\n\n    verbose : bool, optional\n        Enables verbose output.\n\n    Examples\n    --------\n    >>> sf = turicreate.SFrame({'user_id': [\"0\", \"0\", \"0\", \"1\", \"1\", \"2\", \"2\", \"2\"],\n    ...                       'item_id': [\"a\", \"b\", \"c\", \"a\", \"b\", \"b\", \"c\", \"d\"],\n    ...                       'rating': [1, 3, 2, 5, 4, 1, 4, 3]})\n    >>> m = turicreate.popularity_recommender.create(sf, target='rating')\n\n    See Also\n    --------\n    PopularityRecommender\n    \"\"\"\n    from turicreate._cython.cy_server import QuietProgress\n    if not isinstance(observation_data, _SFrame):\n        raise TypeError('observation_data input must be a SFrame')\n    opts = {}\n    model_proxy = _turicreate.extensions.popularity()\n    model_proxy.init_options(opts)\n    if user_data is None:\n        user_data = _turicreate.SFrame()\n    if item_data is None:\n        item_data = _turicreate.SFrame()\n    opts = {'user_id': user_id, 'item_id': item_id, 'target': target, 'random_seed': 1}\n    extra_data = {'nearest_items': _turicreate.SFrame()}\n    with QuietProgress(verbose):\n        model_proxy.train(observation_data, user_data, item_data, opts, extra_data)\n    return PopularityRecommender(model_proxy)",
        "mutated": [
            "def create(observation_data, user_id='user_id', item_id='item_id', target=None, user_data=None, item_data=None, random_seed=0, verbose=True):\n    if False:\n        i = 10\n    '\\n    Create a model that makes recommendations using item popularity. When no\\n    target column is provided, the popularity is determined by the number of\\n    observations involving each item. When a target is provided, popularity\\n    is computed using the item\\'s mean target value. When the target column\\n    contains ratings, for example, the model computes the mean rating for\\n    each item and uses this to rank items for recommendations.\\n\\n    Parameters\\n    ----------\\n    observation_data : SFrame\\n        The dataset to use for training the model. It must contain a column of\\n        user ids and a column of item ids. Each row represents an observed\\n        interaction between the user and the item.  The (user, item) pairs\\n        are stored with the model so that they can later be excluded from\\n        recommendations if desired. It can optionally contain a target ratings\\n        column. All other columns are interpreted by the underlying model as\\n        side features for the observations.\\n\\n        The user id and item id columns must be of type \\'int\\' or \\'str\\'. The\\n        target column must be of type \\'int\\' or \\'float\\'.\\n\\n    user_id : string, optional\\n        The name of the column in `observation_data` that corresponds to the\\n        user id.\\n\\n    item_id : string, optional\\n        The name of the column in `observation_data` that corresponds to the\\n        item id.\\n\\n    target : string, optional\\n        The `observation_data` can optionally contain a column of scores\\n        representing ratings given by the users. If present, the name of this\\n        column may be specified variables `target`.\\n\\n    user_data : SFrame, optional\\n        Side information for the users.  This SFrame must have a column with\\n        the same name as what is specified by the `user_id` input parameter.\\n        `user_data` can provide any amount of additional user-specific\\n        information.\\n\\n    item_data : SFrame, optional\\n        Side information for the items.  This SFrame must have a column with\\n        the same name as what is specified by the `item_id` input parameter.\\n        `item_data` can provide any amount of additional item-specific\\n        information.\\n\\n    verbose : bool, optional\\n        Enables verbose output.\\n\\n    Examples\\n    --------\\n    >>> sf = turicreate.SFrame({\\'user_id\\': [\"0\", \"0\", \"0\", \"1\", \"1\", \"2\", \"2\", \"2\"],\\n    ...                       \\'item_id\\': [\"a\", \"b\", \"c\", \"a\", \"b\", \"b\", \"c\", \"d\"],\\n    ...                       \\'rating\\': [1, 3, 2, 5, 4, 1, 4, 3]})\\n    >>> m = turicreate.popularity_recommender.create(sf, target=\\'rating\\')\\n\\n    See Also\\n    --------\\n    PopularityRecommender\\n    '\n    from turicreate._cython.cy_server import QuietProgress\n    if not isinstance(observation_data, _SFrame):\n        raise TypeError('observation_data input must be a SFrame')\n    opts = {}\n    model_proxy = _turicreate.extensions.popularity()\n    model_proxy.init_options(opts)\n    if user_data is None:\n        user_data = _turicreate.SFrame()\n    if item_data is None:\n        item_data = _turicreate.SFrame()\n    opts = {'user_id': user_id, 'item_id': item_id, 'target': target, 'random_seed': 1}\n    extra_data = {'nearest_items': _turicreate.SFrame()}\n    with QuietProgress(verbose):\n        model_proxy.train(observation_data, user_data, item_data, opts, extra_data)\n    return PopularityRecommender(model_proxy)",
            "def create(observation_data, user_id='user_id', item_id='item_id', target=None, user_data=None, item_data=None, random_seed=0, verbose=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Create a model that makes recommendations using item popularity. When no\\n    target column is provided, the popularity is determined by the number of\\n    observations involving each item. When a target is provided, popularity\\n    is computed using the item\\'s mean target value. When the target column\\n    contains ratings, for example, the model computes the mean rating for\\n    each item and uses this to rank items for recommendations.\\n\\n    Parameters\\n    ----------\\n    observation_data : SFrame\\n        The dataset to use for training the model. It must contain a column of\\n        user ids and a column of item ids. Each row represents an observed\\n        interaction between the user and the item.  The (user, item) pairs\\n        are stored with the model so that they can later be excluded from\\n        recommendations if desired. It can optionally contain a target ratings\\n        column. All other columns are interpreted by the underlying model as\\n        side features for the observations.\\n\\n        The user id and item id columns must be of type \\'int\\' or \\'str\\'. The\\n        target column must be of type \\'int\\' or \\'float\\'.\\n\\n    user_id : string, optional\\n        The name of the column in `observation_data` that corresponds to the\\n        user id.\\n\\n    item_id : string, optional\\n        The name of the column in `observation_data` that corresponds to the\\n        item id.\\n\\n    target : string, optional\\n        The `observation_data` can optionally contain a column of scores\\n        representing ratings given by the users. If present, the name of this\\n        column may be specified variables `target`.\\n\\n    user_data : SFrame, optional\\n        Side information for the users.  This SFrame must have a column with\\n        the same name as what is specified by the `user_id` input parameter.\\n        `user_data` can provide any amount of additional user-specific\\n        information.\\n\\n    item_data : SFrame, optional\\n        Side information for the items.  This SFrame must have a column with\\n        the same name as what is specified by the `item_id` input parameter.\\n        `item_data` can provide any amount of additional item-specific\\n        information.\\n\\n    verbose : bool, optional\\n        Enables verbose output.\\n\\n    Examples\\n    --------\\n    >>> sf = turicreate.SFrame({\\'user_id\\': [\"0\", \"0\", \"0\", \"1\", \"1\", \"2\", \"2\", \"2\"],\\n    ...                       \\'item_id\\': [\"a\", \"b\", \"c\", \"a\", \"b\", \"b\", \"c\", \"d\"],\\n    ...                       \\'rating\\': [1, 3, 2, 5, 4, 1, 4, 3]})\\n    >>> m = turicreate.popularity_recommender.create(sf, target=\\'rating\\')\\n\\n    See Also\\n    --------\\n    PopularityRecommender\\n    '\n    from turicreate._cython.cy_server import QuietProgress\n    if not isinstance(observation_data, _SFrame):\n        raise TypeError('observation_data input must be a SFrame')\n    opts = {}\n    model_proxy = _turicreate.extensions.popularity()\n    model_proxy.init_options(opts)\n    if user_data is None:\n        user_data = _turicreate.SFrame()\n    if item_data is None:\n        item_data = _turicreate.SFrame()\n    opts = {'user_id': user_id, 'item_id': item_id, 'target': target, 'random_seed': 1}\n    extra_data = {'nearest_items': _turicreate.SFrame()}\n    with QuietProgress(verbose):\n        model_proxy.train(observation_data, user_data, item_data, opts, extra_data)\n    return PopularityRecommender(model_proxy)",
            "def create(observation_data, user_id='user_id', item_id='item_id', target=None, user_data=None, item_data=None, random_seed=0, verbose=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Create a model that makes recommendations using item popularity. When no\\n    target column is provided, the popularity is determined by the number of\\n    observations involving each item. When a target is provided, popularity\\n    is computed using the item\\'s mean target value. When the target column\\n    contains ratings, for example, the model computes the mean rating for\\n    each item and uses this to rank items for recommendations.\\n\\n    Parameters\\n    ----------\\n    observation_data : SFrame\\n        The dataset to use for training the model. It must contain a column of\\n        user ids and a column of item ids. Each row represents an observed\\n        interaction between the user and the item.  The (user, item) pairs\\n        are stored with the model so that they can later be excluded from\\n        recommendations if desired. It can optionally contain a target ratings\\n        column. All other columns are interpreted by the underlying model as\\n        side features for the observations.\\n\\n        The user id and item id columns must be of type \\'int\\' or \\'str\\'. The\\n        target column must be of type \\'int\\' or \\'float\\'.\\n\\n    user_id : string, optional\\n        The name of the column in `observation_data` that corresponds to the\\n        user id.\\n\\n    item_id : string, optional\\n        The name of the column in `observation_data` that corresponds to the\\n        item id.\\n\\n    target : string, optional\\n        The `observation_data` can optionally contain a column of scores\\n        representing ratings given by the users. If present, the name of this\\n        column may be specified variables `target`.\\n\\n    user_data : SFrame, optional\\n        Side information for the users.  This SFrame must have a column with\\n        the same name as what is specified by the `user_id` input parameter.\\n        `user_data` can provide any amount of additional user-specific\\n        information.\\n\\n    item_data : SFrame, optional\\n        Side information for the items.  This SFrame must have a column with\\n        the same name as what is specified by the `item_id` input parameter.\\n        `item_data` can provide any amount of additional item-specific\\n        information.\\n\\n    verbose : bool, optional\\n        Enables verbose output.\\n\\n    Examples\\n    --------\\n    >>> sf = turicreate.SFrame({\\'user_id\\': [\"0\", \"0\", \"0\", \"1\", \"1\", \"2\", \"2\", \"2\"],\\n    ...                       \\'item_id\\': [\"a\", \"b\", \"c\", \"a\", \"b\", \"b\", \"c\", \"d\"],\\n    ...                       \\'rating\\': [1, 3, 2, 5, 4, 1, 4, 3]})\\n    >>> m = turicreate.popularity_recommender.create(sf, target=\\'rating\\')\\n\\n    See Also\\n    --------\\n    PopularityRecommender\\n    '\n    from turicreate._cython.cy_server import QuietProgress\n    if not isinstance(observation_data, _SFrame):\n        raise TypeError('observation_data input must be a SFrame')\n    opts = {}\n    model_proxy = _turicreate.extensions.popularity()\n    model_proxy.init_options(opts)\n    if user_data is None:\n        user_data = _turicreate.SFrame()\n    if item_data is None:\n        item_data = _turicreate.SFrame()\n    opts = {'user_id': user_id, 'item_id': item_id, 'target': target, 'random_seed': 1}\n    extra_data = {'nearest_items': _turicreate.SFrame()}\n    with QuietProgress(verbose):\n        model_proxy.train(observation_data, user_data, item_data, opts, extra_data)\n    return PopularityRecommender(model_proxy)",
            "def create(observation_data, user_id='user_id', item_id='item_id', target=None, user_data=None, item_data=None, random_seed=0, verbose=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Create a model that makes recommendations using item popularity. When no\\n    target column is provided, the popularity is determined by the number of\\n    observations involving each item. When a target is provided, popularity\\n    is computed using the item\\'s mean target value. When the target column\\n    contains ratings, for example, the model computes the mean rating for\\n    each item and uses this to rank items for recommendations.\\n\\n    Parameters\\n    ----------\\n    observation_data : SFrame\\n        The dataset to use for training the model. It must contain a column of\\n        user ids and a column of item ids. Each row represents an observed\\n        interaction between the user and the item.  The (user, item) pairs\\n        are stored with the model so that they can later be excluded from\\n        recommendations if desired. It can optionally contain a target ratings\\n        column. All other columns are interpreted by the underlying model as\\n        side features for the observations.\\n\\n        The user id and item id columns must be of type \\'int\\' or \\'str\\'. The\\n        target column must be of type \\'int\\' or \\'float\\'.\\n\\n    user_id : string, optional\\n        The name of the column in `observation_data` that corresponds to the\\n        user id.\\n\\n    item_id : string, optional\\n        The name of the column in `observation_data` that corresponds to the\\n        item id.\\n\\n    target : string, optional\\n        The `observation_data` can optionally contain a column of scores\\n        representing ratings given by the users. If present, the name of this\\n        column may be specified variables `target`.\\n\\n    user_data : SFrame, optional\\n        Side information for the users.  This SFrame must have a column with\\n        the same name as what is specified by the `user_id` input parameter.\\n        `user_data` can provide any amount of additional user-specific\\n        information.\\n\\n    item_data : SFrame, optional\\n        Side information for the items.  This SFrame must have a column with\\n        the same name as what is specified by the `item_id` input parameter.\\n        `item_data` can provide any amount of additional item-specific\\n        information.\\n\\n    verbose : bool, optional\\n        Enables verbose output.\\n\\n    Examples\\n    --------\\n    >>> sf = turicreate.SFrame({\\'user_id\\': [\"0\", \"0\", \"0\", \"1\", \"1\", \"2\", \"2\", \"2\"],\\n    ...                       \\'item_id\\': [\"a\", \"b\", \"c\", \"a\", \"b\", \"b\", \"c\", \"d\"],\\n    ...                       \\'rating\\': [1, 3, 2, 5, 4, 1, 4, 3]})\\n    >>> m = turicreate.popularity_recommender.create(sf, target=\\'rating\\')\\n\\n    See Also\\n    --------\\n    PopularityRecommender\\n    '\n    from turicreate._cython.cy_server import QuietProgress\n    if not isinstance(observation_data, _SFrame):\n        raise TypeError('observation_data input must be a SFrame')\n    opts = {}\n    model_proxy = _turicreate.extensions.popularity()\n    model_proxy.init_options(opts)\n    if user_data is None:\n        user_data = _turicreate.SFrame()\n    if item_data is None:\n        item_data = _turicreate.SFrame()\n    opts = {'user_id': user_id, 'item_id': item_id, 'target': target, 'random_seed': 1}\n    extra_data = {'nearest_items': _turicreate.SFrame()}\n    with QuietProgress(verbose):\n        model_proxy.train(observation_data, user_data, item_data, opts, extra_data)\n    return PopularityRecommender(model_proxy)",
            "def create(observation_data, user_id='user_id', item_id='item_id', target=None, user_data=None, item_data=None, random_seed=0, verbose=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Create a model that makes recommendations using item popularity. When no\\n    target column is provided, the popularity is determined by the number of\\n    observations involving each item. When a target is provided, popularity\\n    is computed using the item\\'s mean target value. When the target column\\n    contains ratings, for example, the model computes the mean rating for\\n    each item and uses this to rank items for recommendations.\\n\\n    Parameters\\n    ----------\\n    observation_data : SFrame\\n        The dataset to use for training the model. It must contain a column of\\n        user ids and a column of item ids. Each row represents an observed\\n        interaction between the user and the item.  The (user, item) pairs\\n        are stored with the model so that they can later be excluded from\\n        recommendations if desired. It can optionally contain a target ratings\\n        column. All other columns are interpreted by the underlying model as\\n        side features for the observations.\\n\\n        The user id and item id columns must be of type \\'int\\' or \\'str\\'. The\\n        target column must be of type \\'int\\' or \\'float\\'.\\n\\n    user_id : string, optional\\n        The name of the column in `observation_data` that corresponds to the\\n        user id.\\n\\n    item_id : string, optional\\n        The name of the column in `observation_data` that corresponds to the\\n        item id.\\n\\n    target : string, optional\\n        The `observation_data` can optionally contain a column of scores\\n        representing ratings given by the users. If present, the name of this\\n        column may be specified variables `target`.\\n\\n    user_data : SFrame, optional\\n        Side information for the users.  This SFrame must have a column with\\n        the same name as what is specified by the `user_id` input parameter.\\n        `user_data` can provide any amount of additional user-specific\\n        information.\\n\\n    item_data : SFrame, optional\\n        Side information for the items.  This SFrame must have a column with\\n        the same name as what is specified by the `item_id` input parameter.\\n        `item_data` can provide any amount of additional item-specific\\n        information.\\n\\n    verbose : bool, optional\\n        Enables verbose output.\\n\\n    Examples\\n    --------\\n    >>> sf = turicreate.SFrame({\\'user_id\\': [\"0\", \"0\", \"0\", \"1\", \"1\", \"2\", \"2\", \"2\"],\\n    ...                       \\'item_id\\': [\"a\", \"b\", \"c\", \"a\", \"b\", \"b\", \"c\", \"d\"],\\n    ...                       \\'rating\\': [1, 3, 2, 5, 4, 1, 4, 3]})\\n    >>> m = turicreate.popularity_recommender.create(sf, target=\\'rating\\')\\n\\n    See Also\\n    --------\\n    PopularityRecommender\\n    '\n    from turicreate._cython.cy_server import QuietProgress\n    if not isinstance(observation_data, _SFrame):\n        raise TypeError('observation_data input must be a SFrame')\n    opts = {}\n    model_proxy = _turicreate.extensions.popularity()\n    model_proxy.init_options(opts)\n    if user_data is None:\n        user_data = _turicreate.SFrame()\n    if item_data is None:\n        item_data = _turicreate.SFrame()\n    opts = {'user_id': user_id, 'item_id': item_id, 'target': target, 'random_seed': 1}\n    extra_data = {'nearest_items': _turicreate.SFrame()}\n    with QuietProgress(verbose):\n        model_proxy.train(observation_data, user_data, item_data, opts, extra_data)\n    return PopularityRecommender(model_proxy)"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, model_proxy):\n    \"\"\"__init__(self)\"\"\"\n    self.__proxy__ = model_proxy",
        "mutated": [
            "def __init__(self, model_proxy):\n    if False:\n        i = 10\n    '__init__(self)'\n    self.__proxy__ = model_proxy",
            "def __init__(self, model_proxy):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '__init__(self)'\n    self.__proxy__ = model_proxy",
            "def __init__(self, model_proxy):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '__init__(self)'\n    self.__proxy__ = model_proxy",
            "def __init__(self, model_proxy):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '__init__(self)'\n    self.__proxy__ = model_proxy",
            "def __init__(self, model_proxy):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '__init__(self)'\n    self.__proxy__ = model_proxy"
        ]
    },
    {
        "func_name": "_native_name",
        "original": "@classmethod\ndef _native_name(cls):\n    return 'popularity'",
        "mutated": [
            "@classmethod\ndef _native_name(cls):\n    if False:\n        i = 10\n    return 'popularity'",
            "@classmethod\ndef _native_name(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return 'popularity'",
            "@classmethod\ndef _native_name(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return 'popularity'",
            "@classmethod\ndef _native_name(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return 'popularity'",
            "@classmethod\ndef _native_name(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return 'popularity'"
        ]
    }
]