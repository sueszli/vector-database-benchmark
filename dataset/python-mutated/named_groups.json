[
    {
        "func_name": "AbelianGroup",
        "original": "def AbelianGroup(*cyclic_orders):\n    \"\"\"\n    Returns the direct product of cyclic groups with the given orders.\n\n    Explanation\n    ===========\n\n    According to the structure theorem for finite abelian groups ([1]),\n    every finite abelian group can be written as the direct product of\n    finitely many cyclic groups.\n\n    Examples\n    ========\n\n    >>> from sympy.combinatorics.named_groups import AbelianGroup\n    >>> AbelianGroup(3, 4)\n    PermutationGroup([\n            (6)(0 1 2),\n            (3 4 5 6)])\n    >>> _.is_group\n    True\n\n    See Also\n    ========\n\n    DirectProduct\n\n    References\n    ==========\n\n    .. [1] https://groupprops.subwiki.org/wiki/Structure_theorem_for_finitely_generated_abelian_groups\n\n    \"\"\"\n    groups = []\n    degree = 0\n    order = 1\n    for size in cyclic_orders:\n        degree += size\n        order *= size\n        groups.append(CyclicGroup(size))\n    G = DirectProduct(*groups)\n    G._is_abelian = True\n    G._degree = degree\n    G._order = order\n    return G",
        "mutated": [
            "def AbelianGroup(*cyclic_orders):\n    if False:\n        i = 10\n    '\\n    Returns the direct product of cyclic groups with the given orders.\\n\\n    Explanation\\n    ===========\\n\\n    According to the structure theorem for finite abelian groups ([1]),\\n    every finite abelian group can be written as the direct product of\\n    finitely many cyclic groups.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.combinatorics.named_groups import AbelianGroup\\n    >>> AbelianGroup(3, 4)\\n    PermutationGroup([\\n            (6)(0 1 2),\\n            (3 4 5 6)])\\n    >>> _.is_group\\n    True\\n\\n    See Also\\n    ========\\n\\n    DirectProduct\\n\\n    References\\n    ==========\\n\\n    .. [1] https://groupprops.subwiki.org/wiki/Structure_theorem_for_finitely_generated_abelian_groups\\n\\n    '\n    groups = []\n    degree = 0\n    order = 1\n    for size in cyclic_orders:\n        degree += size\n        order *= size\n        groups.append(CyclicGroup(size))\n    G = DirectProduct(*groups)\n    G._is_abelian = True\n    G._degree = degree\n    G._order = order\n    return G",
            "def AbelianGroup(*cyclic_orders):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Returns the direct product of cyclic groups with the given orders.\\n\\n    Explanation\\n    ===========\\n\\n    According to the structure theorem for finite abelian groups ([1]),\\n    every finite abelian group can be written as the direct product of\\n    finitely many cyclic groups.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.combinatorics.named_groups import AbelianGroup\\n    >>> AbelianGroup(3, 4)\\n    PermutationGroup([\\n            (6)(0 1 2),\\n            (3 4 5 6)])\\n    >>> _.is_group\\n    True\\n\\n    See Also\\n    ========\\n\\n    DirectProduct\\n\\n    References\\n    ==========\\n\\n    .. [1] https://groupprops.subwiki.org/wiki/Structure_theorem_for_finitely_generated_abelian_groups\\n\\n    '\n    groups = []\n    degree = 0\n    order = 1\n    for size in cyclic_orders:\n        degree += size\n        order *= size\n        groups.append(CyclicGroup(size))\n    G = DirectProduct(*groups)\n    G._is_abelian = True\n    G._degree = degree\n    G._order = order\n    return G",
            "def AbelianGroup(*cyclic_orders):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Returns the direct product of cyclic groups with the given orders.\\n\\n    Explanation\\n    ===========\\n\\n    According to the structure theorem for finite abelian groups ([1]),\\n    every finite abelian group can be written as the direct product of\\n    finitely many cyclic groups.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.combinatorics.named_groups import AbelianGroup\\n    >>> AbelianGroup(3, 4)\\n    PermutationGroup([\\n            (6)(0 1 2),\\n            (3 4 5 6)])\\n    >>> _.is_group\\n    True\\n\\n    See Also\\n    ========\\n\\n    DirectProduct\\n\\n    References\\n    ==========\\n\\n    .. [1] https://groupprops.subwiki.org/wiki/Structure_theorem_for_finitely_generated_abelian_groups\\n\\n    '\n    groups = []\n    degree = 0\n    order = 1\n    for size in cyclic_orders:\n        degree += size\n        order *= size\n        groups.append(CyclicGroup(size))\n    G = DirectProduct(*groups)\n    G._is_abelian = True\n    G._degree = degree\n    G._order = order\n    return G",
            "def AbelianGroup(*cyclic_orders):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Returns the direct product of cyclic groups with the given orders.\\n\\n    Explanation\\n    ===========\\n\\n    According to the structure theorem for finite abelian groups ([1]),\\n    every finite abelian group can be written as the direct product of\\n    finitely many cyclic groups.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.combinatorics.named_groups import AbelianGroup\\n    >>> AbelianGroup(3, 4)\\n    PermutationGroup([\\n            (6)(0 1 2),\\n            (3 4 5 6)])\\n    >>> _.is_group\\n    True\\n\\n    See Also\\n    ========\\n\\n    DirectProduct\\n\\n    References\\n    ==========\\n\\n    .. [1] https://groupprops.subwiki.org/wiki/Structure_theorem_for_finitely_generated_abelian_groups\\n\\n    '\n    groups = []\n    degree = 0\n    order = 1\n    for size in cyclic_orders:\n        degree += size\n        order *= size\n        groups.append(CyclicGroup(size))\n    G = DirectProduct(*groups)\n    G._is_abelian = True\n    G._degree = degree\n    G._order = order\n    return G",
            "def AbelianGroup(*cyclic_orders):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Returns the direct product of cyclic groups with the given orders.\\n\\n    Explanation\\n    ===========\\n\\n    According to the structure theorem for finite abelian groups ([1]),\\n    every finite abelian group can be written as the direct product of\\n    finitely many cyclic groups.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.combinatorics.named_groups import AbelianGroup\\n    >>> AbelianGroup(3, 4)\\n    PermutationGroup([\\n            (6)(0 1 2),\\n            (3 4 5 6)])\\n    >>> _.is_group\\n    True\\n\\n    See Also\\n    ========\\n\\n    DirectProduct\\n\\n    References\\n    ==========\\n\\n    .. [1] https://groupprops.subwiki.org/wiki/Structure_theorem_for_finitely_generated_abelian_groups\\n\\n    '\n    groups = []\n    degree = 0\n    order = 1\n    for size in cyclic_orders:\n        degree += size\n        order *= size\n        groups.append(CyclicGroup(size))\n    G = DirectProduct(*groups)\n    G._is_abelian = True\n    G._degree = degree\n    G._order = order\n    return G"
        ]
    },
    {
        "func_name": "AlternatingGroup",
        "original": "def AlternatingGroup(n):\n    \"\"\"\n    Generates the alternating group on ``n`` elements as a permutation group.\n\n    Explanation\n    ===========\n\n    For ``n > 2``, the generators taken are ``(0 1 2), (0 1 2 ... n-1)`` for\n    ``n`` odd\n    and ``(0 1 2), (1 2 ... n-1)`` for ``n`` even (See [1], p.31, ex.6.9.).\n    After the group is generated, some of its basic properties are set.\n    The cases ``n = 1, 2`` are handled separately.\n\n    Examples\n    ========\n\n    >>> from sympy.combinatorics.named_groups import AlternatingGroup\n    >>> G = AlternatingGroup(4)\n    >>> G.is_group\n    True\n    >>> a = list(G.generate_dimino())\n    >>> len(a)\n    12\n    >>> all(perm.is_even for perm in a)\n    True\n\n    See Also\n    ========\n\n    SymmetricGroup, CyclicGroup, DihedralGroup\n\n    References\n    ==========\n\n    .. [1] Armstrong, M. \"Groups and Symmetry\"\n\n    \"\"\"\n    if n in (1, 2):\n        return PermutationGroup([Permutation([0])])\n    a = list(range(n))\n    (a[0], a[1], a[2]) = (a[1], a[2], a[0])\n    gen1 = a\n    if n % 2:\n        a = list(range(1, n))\n        a.append(0)\n        gen2 = a\n    else:\n        a = list(range(2, n))\n        a.append(1)\n        a.insert(0, 0)\n        gen2 = a\n    gens = [gen1, gen2]\n    if gen1 == gen2:\n        gens = gens[:1]\n    G = PermutationGroup([_af_new(a) for a in gens], dups=False)\n    set_alternating_group_properties(G, n, n)\n    G._is_alt = True\n    return G",
        "mutated": [
            "def AlternatingGroup(n):\n    if False:\n        i = 10\n    '\\n    Generates the alternating group on ``n`` elements as a permutation group.\\n\\n    Explanation\\n    ===========\\n\\n    For ``n > 2``, the generators taken are ``(0 1 2), (0 1 2 ... n-1)`` for\\n    ``n`` odd\\n    and ``(0 1 2), (1 2 ... n-1)`` for ``n`` even (See [1], p.31, ex.6.9.).\\n    After the group is generated, some of its basic properties are set.\\n    The cases ``n = 1, 2`` are handled separately.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.combinatorics.named_groups import AlternatingGroup\\n    >>> G = AlternatingGroup(4)\\n    >>> G.is_group\\n    True\\n    >>> a = list(G.generate_dimino())\\n    >>> len(a)\\n    12\\n    >>> all(perm.is_even for perm in a)\\n    True\\n\\n    See Also\\n    ========\\n\\n    SymmetricGroup, CyclicGroup, DihedralGroup\\n\\n    References\\n    ==========\\n\\n    .. [1] Armstrong, M. \"Groups and Symmetry\"\\n\\n    '\n    if n in (1, 2):\n        return PermutationGroup([Permutation([0])])\n    a = list(range(n))\n    (a[0], a[1], a[2]) = (a[1], a[2], a[0])\n    gen1 = a\n    if n % 2:\n        a = list(range(1, n))\n        a.append(0)\n        gen2 = a\n    else:\n        a = list(range(2, n))\n        a.append(1)\n        a.insert(0, 0)\n        gen2 = a\n    gens = [gen1, gen2]\n    if gen1 == gen2:\n        gens = gens[:1]\n    G = PermutationGroup([_af_new(a) for a in gens], dups=False)\n    set_alternating_group_properties(G, n, n)\n    G._is_alt = True\n    return G",
            "def AlternatingGroup(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Generates the alternating group on ``n`` elements as a permutation group.\\n\\n    Explanation\\n    ===========\\n\\n    For ``n > 2``, the generators taken are ``(0 1 2), (0 1 2 ... n-1)`` for\\n    ``n`` odd\\n    and ``(0 1 2), (1 2 ... n-1)`` for ``n`` even (See [1], p.31, ex.6.9.).\\n    After the group is generated, some of its basic properties are set.\\n    The cases ``n = 1, 2`` are handled separately.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.combinatorics.named_groups import AlternatingGroup\\n    >>> G = AlternatingGroup(4)\\n    >>> G.is_group\\n    True\\n    >>> a = list(G.generate_dimino())\\n    >>> len(a)\\n    12\\n    >>> all(perm.is_even for perm in a)\\n    True\\n\\n    See Also\\n    ========\\n\\n    SymmetricGroup, CyclicGroup, DihedralGroup\\n\\n    References\\n    ==========\\n\\n    .. [1] Armstrong, M. \"Groups and Symmetry\"\\n\\n    '\n    if n in (1, 2):\n        return PermutationGroup([Permutation([0])])\n    a = list(range(n))\n    (a[0], a[1], a[2]) = (a[1], a[2], a[0])\n    gen1 = a\n    if n % 2:\n        a = list(range(1, n))\n        a.append(0)\n        gen2 = a\n    else:\n        a = list(range(2, n))\n        a.append(1)\n        a.insert(0, 0)\n        gen2 = a\n    gens = [gen1, gen2]\n    if gen1 == gen2:\n        gens = gens[:1]\n    G = PermutationGroup([_af_new(a) for a in gens], dups=False)\n    set_alternating_group_properties(G, n, n)\n    G._is_alt = True\n    return G",
            "def AlternatingGroup(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Generates the alternating group on ``n`` elements as a permutation group.\\n\\n    Explanation\\n    ===========\\n\\n    For ``n > 2``, the generators taken are ``(0 1 2), (0 1 2 ... n-1)`` for\\n    ``n`` odd\\n    and ``(0 1 2), (1 2 ... n-1)`` for ``n`` even (See [1], p.31, ex.6.9.).\\n    After the group is generated, some of its basic properties are set.\\n    The cases ``n = 1, 2`` are handled separately.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.combinatorics.named_groups import AlternatingGroup\\n    >>> G = AlternatingGroup(4)\\n    >>> G.is_group\\n    True\\n    >>> a = list(G.generate_dimino())\\n    >>> len(a)\\n    12\\n    >>> all(perm.is_even for perm in a)\\n    True\\n\\n    See Also\\n    ========\\n\\n    SymmetricGroup, CyclicGroup, DihedralGroup\\n\\n    References\\n    ==========\\n\\n    .. [1] Armstrong, M. \"Groups and Symmetry\"\\n\\n    '\n    if n in (1, 2):\n        return PermutationGroup([Permutation([0])])\n    a = list(range(n))\n    (a[0], a[1], a[2]) = (a[1], a[2], a[0])\n    gen1 = a\n    if n % 2:\n        a = list(range(1, n))\n        a.append(0)\n        gen2 = a\n    else:\n        a = list(range(2, n))\n        a.append(1)\n        a.insert(0, 0)\n        gen2 = a\n    gens = [gen1, gen2]\n    if gen1 == gen2:\n        gens = gens[:1]\n    G = PermutationGroup([_af_new(a) for a in gens], dups=False)\n    set_alternating_group_properties(G, n, n)\n    G._is_alt = True\n    return G",
            "def AlternatingGroup(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Generates the alternating group on ``n`` elements as a permutation group.\\n\\n    Explanation\\n    ===========\\n\\n    For ``n > 2``, the generators taken are ``(0 1 2), (0 1 2 ... n-1)`` for\\n    ``n`` odd\\n    and ``(0 1 2), (1 2 ... n-1)`` for ``n`` even (See [1], p.31, ex.6.9.).\\n    After the group is generated, some of its basic properties are set.\\n    The cases ``n = 1, 2`` are handled separately.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.combinatorics.named_groups import AlternatingGroup\\n    >>> G = AlternatingGroup(4)\\n    >>> G.is_group\\n    True\\n    >>> a = list(G.generate_dimino())\\n    >>> len(a)\\n    12\\n    >>> all(perm.is_even for perm in a)\\n    True\\n\\n    See Also\\n    ========\\n\\n    SymmetricGroup, CyclicGroup, DihedralGroup\\n\\n    References\\n    ==========\\n\\n    .. [1] Armstrong, M. \"Groups and Symmetry\"\\n\\n    '\n    if n in (1, 2):\n        return PermutationGroup([Permutation([0])])\n    a = list(range(n))\n    (a[0], a[1], a[2]) = (a[1], a[2], a[0])\n    gen1 = a\n    if n % 2:\n        a = list(range(1, n))\n        a.append(0)\n        gen2 = a\n    else:\n        a = list(range(2, n))\n        a.append(1)\n        a.insert(0, 0)\n        gen2 = a\n    gens = [gen1, gen2]\n    if gen1 == gen2:\n        gens = gens[:1]\n    G = PermutationGroup([_af_new(a) for a in gens], dups=False)\n    set_alternating_group_properties(G, n, n)\n    G._is_alt = True\n    return G",
            "def AlternatingGroup(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Generates the alternating group on ``n`` elements as a permutation group.\\n\\n    Explanation\\n    ===========\\n\\n    For ``n > 2``, the generators taken are ``(0 1 2), (0 1 2 ... n-1)`` for\\n    ``n`` odd\\n    and ``(0 1 2), (1 2 ... n-1)`` for ``n`` even (See [1], p.31, ex.6.9.).\\n    After the group is generated, some of its basic properties are set.\\n    The cases ``n = 1, 2`` are handled separately.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.combinatorics.named_groups import AlternatingGroup\\n    >>> G = AlternatingGroup(4)\\n    >>> G.is_group\\n    True\\n    >>> a = list(G.generate_dimino())\\n    >>> len(a)\\n    12\\n    >>> all(perm.is_even for perm in a)\\n    True\\n\\n    See Also\\n    ========\\n\\n    SymmetricGroup, CyclicGroup, DihedralGroup\\n\\n    References\\n    ==========\\n\\n    .. [1] Armstrong, M. \"Groups and Symmetry\"\\n\\n    '\n    if n in (1, 2):\n        return PermutationGroup([Permutation([0])])\n    a = list(range(n))\n    (a[0], a[1], a[2]) = (a[1], a[2], a[0])\n    gen1 = a\n    if n % 2:\n        a = list(range(1, n))\n        a.append(0)\n        gen2 = a\n    else:\n        a = list(range(2, n))\n        a.append(1)\n        a.insert(0, 0)\n        gen2 = a\n    gens = [gen1, gen2]\n    if gen1 == gen2:\n        gens = gens[:1]\n    G = PermutationGroup([_af_new(a) for a in gens], dups=False)\n    set_alternating_group_properties(G, n, n)\n    G._is_alt = True\n    return G"
        ]
    },
    {
        "func_name": "set_alternating_group_properties",
        "original": "def set_alternating_group_properties(G, n, degree):\n    \"\"\"Set known properties of an alternating group. \"\"\"\n    if n < 4:\n        G._is_abelian = True\n        G._is_nilpotent = True\n    else:\n        G._is_abelian = False\n        G._is_nilpotent = False\n    if n < 5:\n        G._is_solvable = True\n    else:\n        G._is_solvable = False\n    G._degree = degree\n    G._is_transitive = True\n    G._is_dihedral = False",
        "mutated": [
            "def set_alternating_group_properties(G, n, degree):\n    if False:\n        i = 10\n    'Set known properties of an alternating group. '\n    if n < 4:\n        G._is_abelian = True\n        G._is_nilpotent = True\n    else:\n        G._is_abelian = False\n        G._is_nilpotent = False\n    if n < 5:\n        G._is_solvable = True\n    else:\n        G._is_solvable = False\n    G._degree = degree\n    G._is_transitive = True\n    G._is_dihedral = False",
            "def set_alternating_group_properties(G, n, degree):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Set known properties of an alternating group. '\n    if n < 4:\n        G._is_abelian = True\n        G._is_nilpotent = True\n    else:\n        G._is_abelian = False\n        G._is_nilpotent = False\n    if n < 5:\n        G._is_solvable = True\n    else:\n        G._is_solvable = False\n    G._degree = degree\n    G._is_transitive = True\n    G._is_dihedral = False",
            "def set_alternating_group_properties(G, n, degree):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Set known properties of an alternating group. '\n    if n < 4:\n        G._is_abelian = True\n        G._is_nilpotent = True\n    else:\n        G._is_abelian = False\n        G._is_nilpotent = False\n    if n < 5:\n        G._is_solvable = True\n    else:\n        G._is_solvable = False\n    G._degree = degree\n    G._is_transitive = True\n    G._is_dihedral = False",
            "def set_alternating_group_properties(G, n, degree):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Set known properties of an alternating group. '\n    if n < 4:\n        G._is_abelian = True\n        G._is_nilpotent = True\n    else:\n        G._is_abelian = False\n        G._is_nilpotent = False\n    if n < 5:\n        G._is_solvable = True\n    else:\n        G._is_solvable = False\n    G._degree = degree\n    G._is_transitive = True\n    G._is_dihedral = False",
            "def set_alternating_group_properties(G, n, degree):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Set known properties of an alternating group. '\n    if n < 4:\n        G._is_abelian = True\n        G._is_nilpotent = True\n    else:\n        G._is_abelian = False\n        G._is_nilpotent = False\n    if n < 5:\n        G._is_solvable = True\n    else:\n        G._is_solvable = False\n    G._degree = degree\n    G._is_transitive = True\n    G._is_dihedral = False"
        ]
    },
    {
        "func_name": "CyclicGroup",
        "original": "def CyclicGroup(n):\n    \"\"\"\n    Generates the cyclic group of order ``n`` as a permutation group.\n\n    Explanation\n    ===========\n\n    The generator taken is the ``n``-cycle ``(0 1 2 ... n-1)``\n    (in cycle notation). After the group is generated, some of its basic\n    properties are set.\n\n    Examples\n    ========\n\n    >>> from sympy.combinatorics.named_groups import CyclicGroup\n    >>> G = CyclicGroup(6)\n    >>> G.is_group\n    True\n    >>> G.order()\n    6\n    >>> list(G.generate_schreier_sims(af=True))\n    [[0, 1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 0], [2, 3, 4, 5, 0, 1],\n    [3, 4, 5, 0, 1, 2], [4, 5, 0, 1, 2, 3], [5, 0, 1, 2, 3, 4]]\n\n    See Also\n    ========\n\n    SymmetricGroup, DihedralGroup, AlternatingGroup\n\n    \"\"\"\n    a = list(range(1, n))\n    a.append(0)\n    gen = _af_new(a)\n    G = PermutationGroup([gen])\n    G._is_abelian = True\n    G._is_nilpotent = True\n    G._is_solvable = True\n    G._degree = n\n    G._is_transitive = True\n    G._order = n\n    G._is_dihedral = n == 2\n    return G",
        "mutated": [
            "def CyclicGroup(n):\n    if False:\n        i = 10\n    '\\n    Generates the cyclic group of order ``n`` as a permutation group.\\n\\n    Explanation\\n    ===========\\n\\n    The generator taken is the ``n``-cycle ``(0 1 2 ... n-1)``\\n    (in cycle notation). After the group is generated, some of its basic\\n    properties are set.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.combinatorics.named_groups import CyclicGroup\\n    >>> G = CyclicGroup(6)\\n    >>> G.is_group\\n    True\\n    >>> G.order()\\n    6\\n    >>> list(G.generate_schreier_sims(af=True))\\n    [[0, 1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 0], [2, 3, 4, 5, 0, 1],\\n    [3, 4, 5, 0, 1, 2], [4, 5, 0, 1, 2, 3], [5, 0, 1, 2, 3, 4]]\\n\\n    See Also\\n    ========\\n\\n    SymmetricGroup, DihedralGroup, AlternatingGroup\\n\\n    '\n    a = list(range(1, n))\n    a.append(0)\n    gen = _af_new(a)\n    G = PermutationGroup([gen])\n    G._is_abelian = True\n    G._is_nilpotent = True\n    G._is_solvable = True\n    G._degree = n\n    G._is_transitive = True\n    G._order = n\n    G._is_dihedral = n == 2\n    return G",
            "def CyclicGroup(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Generates the cyclic group of order ``n`` as a permutation group.\\n\\n    Explanation\\n    ===========\\n\\n    The generator taken is the ``n``-cycle ``(0 1 2 ... n-1)``\\n    (in cycle notation). After the group is generated, some of its basic\\n    properties are set.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.combinatorics.named_groups import CyclicGroup\\n    >>> G = CyclicGroup(6)\\n    >>> G.is_group\\n    True\\n    >>> G.order()\\n    6\\n    >>> list(G.generate_schreier_sims(af=True))\\n    [[0, 1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 0], [2, 3, 4, 5, 0, 1],\\n    [3, 4, 5, 0, 1, 2], [4, 5, 0, 1, 2, 3], [5, 0, 1, 2, 3, 4]]\\n\\n    See Also\\n    ========\\n\\n    SymmetricGroup, DihedralGroup, AlternatingGroup\\n\\n    '\n    a = list(range(1, n))\n    a.append(0)\n    gen = _af_new(a)\n    G = PermutationGroup([gen])\n    G._is_abelian = True\n    G._is_nilpotent = True\n    G._is_solvable = True\n    G._degree = n\n    G._is_transitive = True\n    G._order = n\n    G._is_dihedral = n == 2\n    return G",
            "def CyclicGroup(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Generates the cyclic group of order ``n`` as a permutation group.\\n\\n    Explanation\\n    ===========\\n\\n    The generator taken is the ``n``-cycle ``(0 1 2 ... n-1)``\\n    (in cycle notation). After the group is generated, some of its basic\\n    properties are set.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.combinatorics.named_groups import CyclicGroup\\n    >>> G = CyclicGroup(6)\\n    >>> G.is_group\\n    True\\n    >>> G.order()\\n    6\\n    >>> list(G.generate_schreier_sims(af=True))\\n    [[0, 1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 0], [2, 3, 4, 5, 0, 1],\\n    [3, 4, 5, 0, 1, 2], [4, 5, 0, 1, 2, 3], [5, 0, 1, 2, 3, 4]]\\n\\n    See Also\\n    ========\\n\\n    SymmetricGroup, DihedralGroup, AlternatingGroup\\n\\n    '\n    a = list(range(1, n))\n    a.append(0)\n    gen = _af_new(a)\n    G = PermutationGroup([gen])\n    G._is_abelian = True\n    G._is_nilpotent = True\n    G._is_solvable = True\n    G._degree = n\n    G._is_transitive = True\n    G._order = n\n    G._is_dihedral = n == 2\n    return G",
            "def CyclicGroup(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Generates the cyclic group of order ``n`` as a permutation group.\\n\\n    Explanation\\n    ===========\\n\\n    The generator taken is the ``n``-cycle ``(0 1 2 ... n-1)``\\n    (in cycle notation). After the group is generated, some of its basic\\n    properties are set.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.combinatorics.named_groups import CyclicGroup\\n    >>> G = CyclicGroup(6)\\n    >>> G.is_group\\n    True\\n    >>> G.order()\\n    6\\n    >>> list(G.generate_schreier_sims(af=True))\\n    [[0, 1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 0], [2, 3, 4, 5, 0, 1],\\n    [3, 4, 5, 0, 1, 2], [4, 5, 0, 1, 2, 3], [5, 0, 1, 2, 3, 4]]\\n\\n    See Also\\n    ========\\n\\n    SymmetricGroup, DihedralGroup, AlternatingGroup\\n\\n    '\n    a = list(range(1, n))\n    a.append(0)\n    gen = _af_new(a)\n    G = PermutationGroup([gen])\n    G._is_abelian = True\n    G._is_nilpotent = True\n    G._is_solvable = True\n    G._degree = n\n    G._is_transitive = True\n    G._order = n\n    G._is_dihedral = n == 2\n    return G",
            "def CyclicGroup(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Generates the cyclic group of order ``n`` as a permutation group.\\n\\n    Explanation\\n    ===========\\n\\n    The generator taken is the ``n``-cycle ``(0 1 2 ... n-1)``\\n    (in cycle notation). After the group is generated, some of its basic\\n    properties are set.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.combinatorics.named_groups import CyclicGroup\\n    >>> G = CyclicGroup(6)\\n    >>> G.is_group\\n    True\\n    >>> G.order()\\n    6\\n    >>> list(G.generate_schreier_sims(af=True))\\n    [[0, 1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 0], [2, 3, 4, 5, 0, 1],\\n    [3, 4, 5, 0, 1, 2], [4, 5, 0, 1, 2, 3], [5, 0, 1, 2, 3, 4]]\\n\\n    See Also\\n    ========\\n\\n    SymmetricGroup, DihedralGroup, AlternatingGroup\\n\\n    '\n    a = list(range(1, n))\n    a.append(0)\n    gen = _af_new(a)\n    G = PermutationGroup([gen])\n    G._is_abelian = True\n    G._is_nilpotent = True\n    G._is_solvable = True\n    G._degree = n\n    G._is_transitive = True\n    G._order = n\n    G._is_dihedral = n == 2\n    return G"
        ]
    },
    {
        "func_name": "DihedralGroup",
        "original": "def DihedralGroup(n):\n    \"\"\"\n    Generates the dihedral group `D_n` as a permutation group.\n\n    Explanation\n    ===========\n\n    The dihedral group `D_n` is the group of symmetries of the regular\n    ``n``-gon. The generators taken are the ``n``-cycle ``a = (0 1 2 ... n-1)``\n    (a rotation of the ``n``-gon) and ``b = (0 n-1)(1 n-2)...``\n    (a reflection of the ``n``-gon) in cycle rotation. It is easy to see that\n    these satisfy ``a**n = b**2 = 1`` and ``bab = ~a`` so they indeed generate\n    `D_n` (See [1]). After the group is generated, some of its basic properties\n    are set.\n\n    Examples\n    ========\n\n    >>> from sympy.combinatorics.named_groups import DihedralGroup\n    >>> G = DihedralGroup(5)\n    >>> G.is_group\n    True\n    >>> a = list(G.generate_dimino())\n    >>> [perm.cyclic_form for perm in a]\n    [[], [[0, 1, 2, 3, 4]], [[0, 2, 4, 1, 3]],\n    [[0, 3, 1, 4, 2]], [[0, 4, 3, 2, 1]], [[0, 4], [1, 3]],\n    [[1, 4], [2, 3]], [[0, 1], [2, 4]], [[0, 2], [3, 4]],\n    [[0, 3], [1, 2]]]\n\n    See Also\n    ========\n\n    SymmetricGroup, CyclicGroup, AlternatingGroup\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Dihedral_group\n\n    \"\"\"\n    if n == 1:\n        return PermutationGroup([Permutation([1, 0])])\n    if n == 2:\n        return PermutationGroup([Permutation([1, 0, 3, 2]), Permutation([2, 3, 0, 1]), Permutation([3, 2, 1, 0])])\n    a = list(range(1, n))\n    a.append(0)\n    gen1 = _af_new(a)\n    a = list(range(n))\n    a.reverse()\n    gen2 = _af_new(a)\n    G = PermutationGroup([gen1, gen2])\n    if n & n - 1 == 0:\n        G._is_nilpotent = True\n    else:\n        G._is_nilpotent = False\n    G._is_dihedral = True\n    G._is_abelian = False\n    G._is_solvable = True\n    G._degree = n\n    G._is_transitive = True\n    G._order = 2 * n\n    return G",
        "mutated": [
            "def DihedralGroup(n):\n    if False:\n        i = 10\n    '\\n    Generates the dihedral group `D_n` as a permutation group.\\n\\n    Explanation\\n    ===========\\n\\n    The dihedral group `D_n` is the group of symmetries of the regular\\n    ``n``-gon. The generators taken are the ``n``-cycle ``a = (0 1 2 ... n-1)``\\n    (a rotation of the ``n``-gon) and ``b = (0 n-1)(1 n-2)...``\\n    (a reflection of the ``n``-gon) in cycle rotation. It is easy to see that\\n    these satisfy ``a**n = b**2 = 1`` and ``bab = ~a`` so they indeed generate\\n    `D_n` (See [1]). After the group is generated, some of its basic properties\\n    are set.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.combinatorics.named_groups import DihedralGroup\\n    >>> G = DihedralGroup(5)\\n    >>> G.is_group\\n    True\\n    >>> a = list(G.generate_dimino())\\n    >>> [perm.cyclic_form for perm in a]\\n    [[], [[0, 1, 2, 3, 4]], [[0, 2, 4, 1, 3]],\\n    [[0, 3, 1, 4, 2]], [[0, 4, 3, 2, 1]], [[0, 4], [1, 3]],\\n    [[1, 4], [2, 3]], [[0, 1], [2, 4]], [[0, 2], [3, 4]],\\n    [[0, 3], [1, 2]]]\\n\\n    See Also\\n    ========\\n\\n    SymmetricGroup, CyclicGroup, AlternatingGroup\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Dihedral_group\\n\\n    '\n    if n == 1:\n        return PermutationGroup([Permutation([1, 0])])\n    if n == 2:\n        return PermutationGroup([Permutation([1, 0, 3, 2]), Permutation([2, 3, 0, 1]), Permutation([3, 2, 1, 0])])\n    a = list(range(1, n))\n    a.append(0)\n    gen1 = _af_new(a)\n    a = list(range(n))\n    a.reverse()\n    gen2 = _af_new(a)\n    G = PermutationGroup([gen1, gen2])\n    if n & n - 1 == 0:\n        G._is_nilpotent = True\n    else:\n        G._is_nilpotent = False\n    G._is_dihedral = True\n    G._is_abelian = False\n    G._is_solvable = True\n    G._degree = n\n    G._is_transitive = True\n    G._order = 2 * n\n    return G",
            "def DihedralGroup(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Generates the dihedral group `D_n` as a permutation group.\\n\\n    Explanation\\n    ===========\\n\\n    The dihedral group `D_n` is the group of symmetries of the regular\\n    ``n``-gon. The generators taken are the ``n``-cycle ``a = (0 1 2 ... n-1)``\\n    (a rotation of the ``n``-gon) and ``b = (0 n-1)(1 n-2)...``\\n    (a reflection of the ``n``-gon) in cycle rotation. It is easy to see that\\n    these satisfy ``a**n = b**2 = 1`` and ``bab = ~a`` so they indeed generate\\n    `D_n` (See [1]). After the group is generated, some of its basic properties\\n    are set.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.combinatorics.named_groups import DihedralGroup\\n    >>> G = DihedralGroup(5)\\n    >>> G.is_group\\n    True\\n    >>> a = list(G.generate_dimino())\\n    >>> [perm.cyclic_form for perm in a]\\n    [[], [[0, 1, 2, 3, 4]], [[0, 2, 4, 1, 3]],\\n    [[0, 3, 1, 4, 2]], [[0, 4, 3, 2, 1]], [[0, 4], [1, 3]],\\n    [[1, 4], [2, 3]], [[0, 1], [2, 4]], [[0, 2], [3, 4]],\\n    [[0, 3], [1, 2]]]\\n\\n    See Also\\n    ========\\n\\n    SymmetricGroup, CyclicGroup, AlternatingGroup\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Dihedral_group\\n\\n    '\n    if n == 1:\n        return PermutationGroup([Permutation([1, 0])])\n    if n == 2:\n        return PermutationGroup([Permutation([1, 0, 3, 2]), Permutation([2, 3, 0, 1]), Permutation([3, 2, 1, 0])])\n    a = list(range(1, n))\n    a.append(0)\n    gen1 = _af_new(a)\n    a = list(range(n))\n    a.reverse()\n    gen2 = _af_new(a)\n    G = PermutationGroup([gen1, gen2])\n    if n & n - 1 == 0:\n        G._is_nilpotent = True\n    else:\n        G._is_nilpotent = False\n    G._is_dihedral = True\n    G._is_abelian = False\n    G._is_solvable = True\n    G._degree = n\n    G._is_transitive = True\n    G._order = 2 * n\n    return G",
            "def DihedralGroup(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Generates the dihedral group `D_n` as a permutation group.\\n\\n    Explanation\\n    ===========\\n\\n    The dihedral group `D_n` is the group of symmetries of the regular\\n    ``n``-gon. The generators taken are the ``n``-cycle ``a = (0 1 2 ... n-1)``\\n    (a rotation of the ``n``-gon) and ``b = (0 n-1)(1 n-2)...``\\n    (a reflection of the ``n``-gon) in cycle rotation. It is easy to see that\\n    these satisfy ``a**n = b**2 = 1`` and ``bab = ~a`` so they indeed generate\\n    `D_n` (See [1]). After the group is generated, some of its basic properties\\n    are set.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.combinatorics.named_groups import DihedralGroup\\n    >>> G = DihedralGroup(5)\\n    >>> G.is_group\\n    True\\n    >>> a = list(G.generate_dimino())\\n    >>> [perm.cyclic_form for perm in a]\\n    [[], [[0, 1, 2, 3, 4]], [[0, 2, 4, 1, 3]],\\n    [[0, 3, 1, 4, 2]], [[0, 4, 3, 2, 1]], [[0, 4], [1, 3]],\\n    [[1, 4], [2, 3]], [[0, 1], [2, 4]], [[0, 2], [3, 4]],\\n    [[0, 3], [1, 2]]]\\n\\n    See Also\\n    ========\\n\\n    SymmetricGroup, CyclicGroup, AlternatingGroup\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Dihedral_group\\n\\n    '\n    if n == 1:\n        return PermutationGroup([Permutation([1, 0])])\n    if n == 2:\n        return PermutationGroup([Permutation([1, 0, 3, 2]), Permutation([2, 3, 0, 1]), Permutation([3, 2, 1, 0])])\n    a = list(range(1, n))\n    a.append(0)\n    gen1 = _af_new(a)\n    a = list(range(n))\n    a.reverse()\n    gen2 = _af_new(a)\n    G = PermutationGroup([gen1, gen2])\n    if n & n - 1 == 0:\n        G._is_nilpotent = True\n    else:\n        G._is_nilpotent = False\n    G._is_dihedral = True\n    G._is_abelian = False\n    G._is_solvable = True\n    G._degree = n\n    G._is_transitive = True\n    G._order = 2 * n\n    return G",
            "def DihedralGroup(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Generates the dihedral group `D_n` as a permutation group.\\n\\n    Explanation\\n    ===========\\n\\n    The dihedral group `D_n` is the group of symmetries of the regular\\n    ``n``-gon. The generators taken are the ``n``-cycle ``a = (0 1 2 ... n-1)``\\n    (a rotation of the ``n``-gon) and ``b = (0 n-1)(1 n-2)...``\\n    (a reflection of the ``n``-gon) in cycle rotation. It is easy to see that\\n    these satisfy ``a**n = b**2 = 1`` and ``bab = ~a`` so they indeed generate\\n    `D_n` (See [1]). After the group is generated, some of its basic properties\\n    are set.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.combinatorics.named_groups import DihedralGroup\\n    >>> G = DihedralGroup(5)\\n    >>> G.is_group\\n    True\\n    >>> a = list(G.generate_dimino())\\n    >>> [perm.cyclic_form for perm in a]\\n    [[], [[0, 1, 2, 3, 4]], [[0, 2, 4, 1, 3]],\\n    [[0, 3, 1, 4, 2]], [[0, 4, 3, 2, 1]], [[0, 4], [1, 3]],\\n    [[1, 4], [2, 3]], [[0, 1], [2, 4]], [[0, 2], [3, 4]],\\n    [[0, 3], [1, 2]]]\\n\\n    See Also\\n    ========\\n\\n    SymmetricGroup, CyclicGroup, AlternatingGroup\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Dihedral_group\\n\\n    '\n    if n == 1:\n        return PermutationGroup([Permutation([1, 0])])\n    if n == 2:\n        return PermutationGroup([Permutation([1, 0, 3, 2]), Permutation([2, 3, 0, 1]), Permutation([3, 2, 1, 0])])\n    a = list(range(1, n))\n    a.append(0)\n    gen1 = _af_new(a)\n    a = list(range(n))\n    a.reverse()\n    gen2 = _af_new(a)\n    G = PermutationGroup([gen1, gen2])\n    if n & n - 1 == 0:\n        G._is_nilpotent = True\n    else:\n        G._is_nilpotent = False\n    G._is_dihedral = True\n    G._is_abelian = False\n    G._is_solvable = True\n    G._degree = n\n    G._is_transitive = True\n    G._order = 2 * n\n    return G",
            "def DihedralGroup(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Generates the dihedral group `D_n` as a permutation group.\\n\\n    Explanation\\n    ===========\\n\\n    The dihedral group `D_n` is the group of symmetries of the regular\\n    ``n``-gon. The generators taken are the ``n``-cycle ``a = (0 1 2 ... n-1)``\\n    (a rotation of the ``n``-gon) and ``b = (0 n-1)(1 n-2)...``\\n    (a reflection of the ``n``-gon) in cycle rotation. It is easy to see that\\n    these satisfy ``a**n = b**2 = 1`` and ``bab = ~a`` so they indeed generate\\n    `D_n` (See [1]). After the group is generated, some of its basic properties\\n    are set.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.combinatorics.named_groups import DihedralGroup\\n    >>> G = DihedralGroup(5)\\n    >>> G.is_group\\n    True\\n    >>> a = list(G.generate_dimino())\\n    >>> [perm.cyclic_form for perm in a]\\n    [[], [[0, 1, 2, 3, 4]], [[0, 2, 4, 1, 3]],\\n    [[0, 3, 1, 4, 2]], [[0, 4, 3, 2, 1]], [[0, 4], [1, 3]],\\n    [[1, 4], [2, 3]], [[0, 1], [2, 4]], [[0, 2], [3, 4]],\\n    [[0, 3], [1, 2]]]\\n\\n    See Also\\n    ========\\n\\n    SymmetricGroup, CyclicGroup, AlternatingGroup\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Dihedral_group\\n\\n    '\n    if n == 1:\n        return PermutationGroup([Permutation([1, 0])])\n    if n == 2:\n        return PermutationGroup([Permutation([1, 0, 3, 2]), Permutation([2, 3, 0, 1]), Permutation([3, 2, 1, 0])])\n    a = list(range(1, n))\n    a.append(0)\n    gen1 = _af_new(a)\n    a = list(range(n))\n    a.reverse()\n    gen2 = _af_new(a)\n    G = PermutationGroup([gen1, gen2])\n    if n & n - 1 == 0:\n        G._is_nilpotent = True\n    else:\n        G._is_nilpotent = False\n    G._is_dihedral = True\n    G._is_abelian = False\n    G._is_solvable = True\n    G._degree = n\n    G._is_transitive = True\n    G._order = 2 * n\n    return G"
        ]
    },
    {
        "func_name": "SymmetricGroup",
        "original": "def SymmetricGroup(n):\n    \"\"\"\n    Generates the symmetric group on ``n`` elements as a permutation group.\n\n    Explanation\n    ===========\n\n    The generators taken are the ``n``-cycle\n    ``(0 1 2 ... n-1)`` and the transposition ``(0 1)`` (in cycle notation).\n    (See [1]). After the group is generated, some of its basic properties\n    are set.\n\n    Examples\n    ========\n\n    >>> from sympy.combinatorics.named_groups import SymmetricGroup\n    >>> G = SymmetricGroup(4)\n    >>> G.is_group\n    True\n    >>> G.order()\n    24\n    >>> list(G.generate_schreier_sims(af=True))\n    [[0, 1, 2, 3], [1, 2, 3, 0], [2, 3, 0, 1], [3, 1, 2, 0], [0, 2, 3, 1],\n    [1, 3, 0, 2], [2, 0, 1, 3], [3, 2, 0, 1], [0, 3, 1, 2], [1, 0, 2, 3],\n    [2, 1, 3, 0], [3, 0, 1, 2], [0, 1, 3, 2], [1, 2, 0, 3], [2, 3, 1, 0],\n    [3, 1, 0, 2], [0, 2, 1, 3], [1, 3, 2, 0], [2, 0, 3, 1], [3, 2, 1, 0],\n    [0, 3, 2, 1], [1, 0, 3, 2], [2, 1, 0, 3], [3, 0, 2, 1]]\n\n    See Also\n    ========\n\n    CyclicGroup, DihedralGroup, AlternatingGroup\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Symmetric_group#Generators_and_relations\n\n    \"\"\"\n    if n == 1:\n        G = PermutationGroup([Permutation([0])])\n    elif n == 2:\n        G = PermutationGroup([Permutation([1, 0])])\n    else:\n        a = list(range(1, n))\n        a.append(0)\n        gen1 = _af_new(a)\n        a = list(range(n))\n        (a[0], a[1]) = (a[1], a[0])\n        gen2 = _af_new(a)\n        G = PermutationGroup([gen1, gen2])\n    set_symmetric_group_properties(G, n, n)\n    G._is_sym = True\n    return G",
        "mutated": [
            "def SymmetricGroup(n):\n    if False:\n        i = 10\n    '\\n    Generates the symmetric group on ``n`` elements as a permutation group.\\n\\n    Explanation\\n    ===========\\n\\n    The generators taken are the ``n``-cycle\\n    ``(0 1 2 ... n-1)`` and the transposition ``(0 1)`` (in cycle notation).\\n    (See [1]). After the group is generated, some of its basic properties\\n    are set.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.combinatorics.named_groups import SymmetricGroup\\n    >>> G = SymmetricGroup(4)\\n    >>> G.is_group\\n    True\\n    >>> G.order()\\n    24\\n    >>> list(G.generate_schreier_sims(af=True))\\n    [[0, 1, 2, 3], [1, 2, 3, 0], [2, 3, 0, 1], [3, 1, 2, 0], [0, 2, 3, 1],\\n    [1, 3, 0, 2], [2, 0, 1, 3], [3, 2, 0, 1], [0, 3, 1, 2], [1, 0, 2, 3],\\n    [2, 1, 3, 0], [3, 0, 1, 2], [0, 1, 3, 2], [1, 2, 0, 3], [2, 3, 1, 0],\\n    [3, 1, 0, 2], [0, 2, 1, 3], [1, 3, 2, 0], [2, 0, 3, 1], [3, 2, 1, 0],\\n    [0, 3, 2, 1], [1, 0, 3, 2], [2, 1, 0, 3], [3, 0, 2, 1]]\\n\\n    See Also\\n    ========\\n\\n    CyclicGroup, DihedralGroup, AlternatingGroup\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Symmetric_group#Generators_and_relations\\n\\n    '\n    if n == 1:\n        G = PermutationGroup([Permutation([0])])\n    elif n == 2:\n        G = PermutationGroup([Permutation([1, 0])])\n    else:\n        a = list(range(1, n))\n        a.append(0)\n        gen1 = _af_new(a)\n        a = list(range(n))\n        (a[0], a[1]) = (a[1], a[0])\n        gen2 = _af_new(a)\n        G = PermutationGroup([gen1, gen2])\n    set_symmetric_group_properties(G, n, n)\n    G._is_sym = True\n    return G",
            "def SymmetricGroup(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Generates the symmetric group on ``n`` elements as a permutation group.\\n\\n    Explanation\\n    ===========\\n\\n    The generators taken are the ``n``-cycle\\n    ``(0 1 2 ... n-1)`` and the transposition ``(0 1)`` (in cycle notation).\\n    (See [1]). After the group is generated, some of its basic properties\\n    are set.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.combinatorics.named_groups import SymmetricGroup\\n    >>> G = SymmetricGroup(4)\\n    >>> G.is_group\\n    True\\n    >>> G.order()\\n    24\\n    >>> list(G.generate_schreier_sims(af=True))\\n    [[0, 1, 2, 3], [1, 2, 3, 0], [2, 3, 0, 1], [3, 1, 2, 0], [0, 2, 3, 1],\\n    [1, 3, 0, 2], [2, 0, 1, 3], [3, 2, 0, 1], [0, 3, 1, 2], [1, 0, 2, 3],\\n    [2, 1, 3, 0], [3, 0, 1, 2], [0, 1, 3, 2], [1, 2, 0, 3], [2, 3, 1, 0],\\n    [3, 1, 0, 2], [0, 2, 1, 3], [1, 3, 2, 0], [2, 0, 3, 1], [3, 2, 1, 0],\\n    [0, 3, 2, 1], [1, 0, 3, 2], [2, 1, 0, 3], [3, 0, 2, 1]]\\n\\n    See Also\\n    ========\\n\\n    CyclicGroup, DihedralGroup, AlternatingGroup\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Symmetric_group#Generators_and_relations\\n\\n    '\n    if n == 1:\n        G = PermutationGroup([Permutation([0])])\n    elif n == 2:\n        G = PermutationGroup([Permutation([1, 0])])\n    else:\n        a = list(range(1, n))\n        a.append(0)\n        gen1 = _af_new(a)\n        a = list(range(n))\n        (a[0], a[1]) = (a[1], a[0])\n        gen2 = _af_new(a)\n        G = PermutationGroup([gen1, gen2])\n    set_symmetric_group_properties(G, n, n)\n    G._is_sym = True\n    return G",
            "def SymmetricGroup(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Generates the symmetric group on ``n`` elements as a permutation group.\\n\\n    Explanation\\n    ===========\\n\\n    The generators taken are the ``n``-cycle\\n    ``(0 1 2 ... n-1)`` and the transposition ``(0 1)`` (in cycle notation).\\n    (See [1]). After the group is generated, some of its basic properties\\n    are set.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.combinatorics.named_groups import SymmetricGroup\\n    >>> G = SymmetricGroup(4)\\n    >>> G.is_group\\n    True\\n    >>> G.order()\\n    24\\n    >>> list(G.generate_schreier_sims(af=True))\\n    [[0, 1, 2, 3], [1, 2, 3, 0], [2, 3, 0, 1], [3, 1, 2, 0], [0, 2, 3, 1],\\n    [1, 3, 0, 2], [2, 0, 1, 3], [3, 2, 0, 1], [0, 3, 1, 2], [1, 0, 2, 3],\\n    [2, 1, 3, 0], [3, 0, 1, 2], [0, 1, 3, 2], [1, 2, 0, 3], [2, 3, 1, 0],\\n    [3, 1, 0, 2], [0, 2, 1, 3], [1, 3, 2, 0], [2, 0, 3, 1], [3, 2, 1, 0],\\n    [0, 3, 2, 1], [1, 0, 3, 2], [2, 1, 0, 3], [3, 0, 2, 1]]\\n\\n    See Also\\n    ========\\n\\n    CyclicGroup, DihedralGroup, AlternatingGroup\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Symmetric_group#Generators_and_relations\\n\\n    '\n    if n == 1:\n        G = PermutationGroup([Permutation([0])])\n    elif n == 2:\n        G = PermutationGroup([Permutation([1, 0])])\n    else:\n        a = list(range(1, n))\n        a.append(0)\n        gen1 = _af_new(a)\n        a = list(range(n))\n        (a[0], a[1]) = (a[1], a[0])\n        gen2 = _af_new(a)\n        G = PermutationGroup([gen1, gen2])\n    set_symmetric_group_properties(G, n, n)\n    G._is_sym = True\n    return G",
            "def SymmetricGroup(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Generates the symmetric group on ``n`` elements as a permutation group.\\n\\n    Explanation\\n    ===========\\n\\n    The generators taken are the ``n``-cycle\\n    ``(0 1 2 ... n-1)`` and the transposition ``(0 1)`` (in cycle notation).\\n    (See [1]). After the group is generated, some of its basic properties\\n    are set.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.combinatorics.named_groups import SymmetricGroup\\n    >>> G = SymmetricGroup(4)\\n    >>> G.is_group\\n    True\\n    >>> G.order()\\n    24\\n    >>> list(G.generate_schreier_sims(af=True))\\n    [[0, 1, 2, 3], [1, 2, 3, 0], [2, 3, 0, 1], [3, 1, 2, 0], [0, 2, 3, 1],\\n    [1, 3, 0, 2], [2, 0, 1, 3], [3, 2, 0, 1], [0, 3, 1, 2], [1, 0, 2, 3],\\n    [2, 1, 3, 0], [3, 0, 1, 2], [0, 1, 3, 2], [1, 2, 0, 3], [2, 3, 1, 0],\\n    [3, 1, 0, 2], [0, 2, 1, 3], [1, 3, 2, 0], [2, 0, 3, 1], [3, 2, 1, 0],\\n    [0, 3, 2, 1], [1, 0, 3, 2], [2, 1, 0, 3], [3, 0, 2, 1]]\\n\\n    See Also\\n    ========\\n\\n    CyclicGroup, DihedralGroup, AlternatingGroup\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Symmetric_group#Generators_and_relations\\n\\n    '\n    if n == 1:\n        G = PermutationGroup([Permutation([0])])\n    elif n == 2:\n        G = PermutationGroup([Permutation([1, 0])])\n    else:\n        a = list(range(1, n))\n        a.append(0)\n        gen1 = _af_new(a)\n        a = list(range(n))\n        (a[0], a[1]) = (a[1], a[0])\n        gen2 = _af_new(a)\n        G = PermutationGroup([gen1, gen2])\n    set_symmetric_group_properties(G, n, n)\n    G._is_sym = True\n    return G",
            "def SymmetricGroup(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Generates the symmetric group on ``n`` elements as a permutation group.\\n\\n    Explanation\\n    ===========\\n\\n    The generators taken are the ``n``-cycle\\n    ``(0 1 2 ... n-1)`` and the transposition ``(0 1)`` (in cycle notation).\\n    (See [1]). After the group is generated, some of its basic properties\\n    are set.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.combinatorics.named_groups import SymmetricGroup\\n    >>> G = SymmetricGroup(4)\\n    >>> G.is_group\\n    True\\n    >>> G.order()\\n    24\\n    >>> list(G.generate_schreier_sims(af=True))\\n    [[0, 1, 2, 3], [1, 2, 3, 0], [2, 3, 0, 1], [3, 1, 2, 0], [0, 2, 3, 1],\\n    [1, 3, 0, 2], [2, 0, 1, 3], [3, 2, 0, 1], [0, 3, 1, 2], [1, 0, 2, 3],\\n    [2, 1, 3, 0], [3, 0, 1, 2], [0, 1, 3, 2], [1, 2, 0, 3], [2, 3, 1, 0],\\n    [3, 1, 0, 2], [0, 2, 1, 3], [1, 3, 2, 0], [2, 0, 3, 1], [3, 2, 1, 0],\\n    [0, 3, 2, 1], [1, 0, 3, 2], [2, 1, 0, 3], [3, 0, 2, 1]]\\n\\n    See Also\\n    ========\\n\\n    CyclicGroup, DihedralGroup, AlternatingGroup\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Symmetric_group#Generators_and_relations\\n\\n    '\n    if n == 1:\n        G = PermutationGroup([Permutation([0])])\n    elif n == 2:\n        G = PermutationGroup([Permutation([1, 0])])\n    else:\n        a = list(range(1, n))\n        a.append(0)\n        gen1 = _af_new(a)\n        a = list(range(n))\n        (a[0], a[1]) = (a[1], a[0])\n        gen2 = _af_new(a)\n        G = PermutationGroup([gen1, gen2])\n    set_symmetric_group_properties(G, n, n)\n    G._is_sym = True\n    return G"
        ]
    },
    {
        "func_name": "set_symmetric_group_properties",
        "original": "def set_symmetric_group_properties(G, n, degree):\n    \"\"\"Set known properties of a symmetric group. \"\"\"\n    if n < 3:\n        G._is_abelian = True\n        G._is_nilpotent = True\n    else:\n        G._is_abelian = False\n        G._is_nilpotent = False\n    if n < 5:\n        G._is_solvable = True\n    else:\n        G._is_solvable = False\n    G._degree = degree\n    G._is_transitive = True\n    G._is_dihedral = n in [2, 3]",
        "mutated": [
            "def set_symmetric_group_properties(G, n, degree):\n    if False:\n        i = 10\n    'Set known properties of a symmetric group. '\n    if n < 3:\n        G._is_abelian = True\n        G._is_nilpotent = True\n    else:\n        G._is_abelian = False\n        G._is_nilpotent = False\n    if n < 5:\n        G._is_solvable = True\n    else:\n        G._is_solvable = False\n    G._degree = degree\n    G._is_transitive = True\n    G._is_dihedral = n in [2, 3]",
            "def set_symmetric_group_properties(G, n, degree):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Set known properties of a symmetric group. '\n    if n < 3:\n        G._is_abelian = True\n        G._is_nilpotent = True\n    else:\n        G._is_abelian = False\n        G._is_nilpotent = False\n    if n < 5:\n        G._is_solvable = True\n    else:\n        G._is_solvable = False\n    G._degree = degree\n    G._is_transitive = True\n    G._is_dihedral = n in [2, 3]",
            "def set_symmetric_group_properties(G, n, degree):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Set known properties of a symmetric group. '\n    if n < 3:\n        G._is_abelian = True\n        G._is_nilpotent = True\n    else:\n        G._is_abelian = False\n        G._is_nilpotent = False\n    if n < 5:\n        G._is_solvable = True\n    else:\n        G._is_solvable = False\n    G._degree = degree\n    G._is_transitive = True\n    G._is_dihedral = n in [2, 3]",
            "def set_symmetric_group_properties(G, n, degree):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Set known properties of a symmetric group. '\n    if n < 3:\n        G._is_abelian = True\n        G._is_nilpotent = True\n    else:\n        G._is_abelian = False\n        G._is_nilpotent = False\n    if n < 5:\n        G._is_solvable = True\n    else:\n        G._is_solvable = False\n    G._degree = degree\n    G._is_transitive = True\n    G._is_dihedral = n in [2, 3]",
            "def set_symmetric_group_properties(G, n, degree):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Set known properties of a symmetric group. '\n    if n < 3:\n        G._is_abelian = True\n        G._is_nilpotent = True\n    else:\n        G._is_abelian = False\n        G._is_nilpotent = False\n    if n < 5:\n        G._is_solvable = True\n    else:\n        G._is_solvable = False\n    G._degree = degree\n    G._is_transitive = True\n    G._is_dihedral = n in [2, 3]"
        ]
    },
    {
        "func_name": "RubikGroup",
        "original": "def RubikGroup(n):\n    \"\"\"Return a group of Rubik's cube generators\n\n    >>> from sympy.combinatorics.named_groups import RubikGroup\n    >>> RubikGroup(2).is_group\n    True\n    \"\"\"\n    from sympy.combinatorics.generators import rubik\n    if n <= 1:\n        raise ValueError('Invalid cube. n has to be greater than 1')\n    return PermutationGroup(rubik(n))",
        "mutated": [
            "def RubikGroup(n):\n    if False:\n        i = 10\n    \"Return a group of Rubik's cube generators\\n\\n    >>> from sympy.combinatorics.named_groups import RubikGroup\\n    >>> RubikGroup(2).is_group\\n    True\\n    \"\n    from sympy.combinatorics.generators import rubik\n    if n <= 1:\n        raise ValueError('Invalid cube. n has to be greater than 1')\n    return PermutationGroup(rubik(n))",
            "def RubikGroup(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Return a group of Rubik's cube generators\\n\\n    >>> from sympy.combinatorics.named_groups import RubikGroup\\n    >>> RubikGroup(2).is_group\\n    True\\n    \"\n    from sympy.combinatorics.generators import rubik\n    if n <= 1:\n        raise ValueError('Invalid cube. n has to be greater than 1')\n    return PermutationGroup(rubik(n))",
            "def RubikGroup(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Return a group of Rubik's cube generators\\n\\n    >>> from sympy.combinatorics.named_groups import RubikGroup\\n    >>> RubikGroup(2).is_group\\n    True\\n    \"\n    from sympy.combinatorics.generators import rubik\n    if n <= 1:\n        raise ValueError('Invalid cube. n has to be greater than 1')\n    return PermutationGroup(rubik(n))",
            "def RubikGroup(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Return a group of Rubik's cube generators\\n\\n    >>> from sympy.combinatorics.named_groups import RubikGroup\\n    >>> RubikGroup(2).is_group\\n    True\\n    \"\n    from sympy.combinatorics.generators import rubik\n    if n <= 1:\n        raise ValueError('Invalid cube. n has to be greater than 1')\n    return PermutationGroup(rubik(n))",
            "def RubikGroup(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Return a group of Rubik's cube generators\\n\\n    >>> from sympy.combinatorics.named_groups import RubikGroup\\n    >>> RubikGroup(2).is_group\\n    True\\n    \"\n    from sympy.combinatorics.generators import rubik\n    if n <= 1:\n        raise ValueError('Invalid cube. n has to be greater than 1')\n    return PermutationGroup(rubik(n))"
        ]
    }
]