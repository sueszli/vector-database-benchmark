[
    {
        "func_name": "get_server_friendly_name",
        "original": "def get_server_friendly_name():\n    logger.info('Tautulli Pmsconnect :: Requesting name from server...')\n    server_name = PmsConnect().get_server_pref(pref='FriendlyName')\n    if not server_name:\n        servers_info = PmsConnect().get_servers_info()\n        for server in servers_info:\n            if server['machine_identifier'] == plexpy.CONFIG.PMS_IDENTIFIER:\n                server_name = server['name']\n                break\n    if server_name and server_name != plexpy.CONFIG.PMS_NAME:\n        plexpy.CONFIG.__setattr__('PMS_NAME', server_name)\n        plexpy.CONFIG.write()\n        logger.info('Tautulli Pmsconnect :: Server name retrieved.')\n    return server_name",
        "mutated": [
            "def get_server_friendly_name():\n    if False:\n        i = 10\n    logger.info('Tautulli Pmsconnect :: Requesting name from server...')\n    server_name = PmsConnect().get_server_pref(pref='FriendlyName')\n    if not server_name:\n        servers_info = PmsConnect().get_servers_info()\n        for server in servers_info:\n            if server['machine_identifier'] == plexpy.CONFIG.PMS_IDENTIFIER:\n                server_name = server['name']\n                break\n    if server_name and server_name != plexpy.CONFIG.PMS_NAME:\n        plexpy.CONFIG.__setattr__('PMS_NAME', server_name)\n        plexpy.CONFIG.write()\n        logger.info('Tautulli Pmsconnect :: Server name retrieved.')\n    return server_name",
            "def get_server_friendly_name():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    logger.info('Tautulli Pmsconnect :: Requesting name from server...')\n    server_name = PmsConnect().get_server_pref(pref='FriendlyName')\n    if not server_name:\n        servers_info = PmsConnect().get_servers_info()\n        for server in servers_info:\n            if server['machine_identifier'] == plexpy.CONFIG.PMS_IDENTIFIER:\n                server_name = server['name']\n                break\n    if server_name and server_name != plexpy.CONFIG.PMS_NAME:\n        plexpy.CONFIG.__setattr__('PMS_NAME', server_name)\n        plexpy.CONFIG.write()\n        logger.info('Tautulli Pmsconnect :: Server name retrieved.')\n    return server_name",
            "def get_server_friendly_name():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    logger.info('Tautulli Pmsconnect :: Requesting name from server...')\n    server_name = PmsConnect().get_server_pref(pref='FriendlyName')\n    if not server_name:\n        servers_info = PmsConnect().get_servers_info()\n        for server in servers_info:\n            if server['machine_identifier'] == plexpy.CONFIG.PMS_IDENTIFIER:\n                server_name = server['name']\n                break\n    if server_name and server_name != plexpy.CONFIG.PMS_NAME:\n        plexpy.CONFIG.__setattr__('PMS_NAME', server_name)\n        plexpy.CONFIG.write()\n        logger.info('Tautulli Pmsconnect :: Server name retrieved.')\n    return server_name",
            "def get_server_friendly_name():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    logger.info('Tautulli Pmsconnect :: Requesting name from server...')\n    server_name = PmsConnect().get_server_pref(pref='FriendlyName')\n    if not server_name:\n        servers_info = PmsConnect().get_servers_info()\n        for server in servers_info:\n            if server['machine_identifier'] == plexpy.CONFIG.PMS_IDENTIFIER:\n                server_name = server['name']\n                break\n    if server_name and server_name != plexpy.CONFIG.PMS_NAME:\n        plexpy.CONFIG.__setattr__('PMS_NAME', server_name)\n        plexpy.CONFIG.write()\n        logger.info('Tautulli Pmsconnect :: Server name retrieved.')\n    return server_name",
            "def get_server_friendly_name():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    logger.info('Tautulli Pmsconnect :: Requesting name from server...')\n    server_name = PmsConnect().get_server_pref(pref='FriendlyName')\n    if not server_name:\n        servers_info = PmsConnect().get_servers_info()\n        for server in servers_info:\n            if server['machine_identifier'] == plexpy.CONFIG.PMS_IDENTIFIER:\n                server_name = server['name']\n                break\n    if server_name and server_name != plexpy.CONFIG.PMS_NAME:\n        plexpy.CONFIG.__setattr__('PMS_NAME', server_name)\n        plexpy.CONFIG.write()\n        logger.info('Tautulli Pmsconnect :: Server name retrieved.')\n    return server_name"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, url=None, token=None):\n    self.url = url\n    self.token = token\n    if not self.url and plexpy.CONFIG.PMS_URL:\n        self.url = plexpy.CONFIG.PMS_URL\n    elif not self.url:\n        self.url = 'http://{hostname}:{port}'.format(hostname=plexpy.CONFIG.PMS_IP, port=plexpy.CONFIG.PMS_PORT)\n    self.timeout = plexpy.CONFIG.PMS_TIMEOUT\n    if not self.token:\n        if session.get_session_user_id():\n            user_data = users.Users()\n            user_tokens = user_data.get_tokens(user_id=session.get_session_user_id())\n            self.token = user_tokens['server_token']\n        else:\n            self.token = plexpy.CONFIG.PMS_TOKEN\n    self.ssl_verify = plexpy.CONFIG.VERIFY_SSL_CERT\n    self.request_handler = http_handler.HTTPHandler(urls=self.url, token=self.token, timeout=self.timeout, ssl_verify=self.ssl_verify)",
        "mutated": [
            "def __init__(self, url=None, token=None):\n    if False:\n        i = 10\n    self.url = url\n    self.token = token\n    if not self.url and plexpy.CONFIG.PMS_URL:\n        self.url = plexpy.CONFIG.PMS_URL\n    elif not self.url:\n        self.url = 'http://{hostname}:{port}'.format(hostname=plexpy.CONFIG.PMS_IP, port=plexpy.CONFIG.PMS_PORT)\n    self.timeout = plexpy.CONFIG.PMS_TIMEOUT\n    if not self.token:\n        if session.get_session_user_id():\n            user_data = users.Users()\n            user_tokens = user_data.get_tokens(user_id=session.get_session_user_id())\n            self.token = user_tokens['server_token']\n        else:\n            self.token = plexpy.CONFIG.PMS_TOKEN\n    self.ssl_verify = plexpy.CONFIG.VERIFY_SSL_CERT\n    self.request_handler = http_handler.HTTPHandler(urls=self.url, token=self.token, timeout=self.timeout, ssl_verify=self.ssl_verify)",
            "def __init__(self, url=None, token=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.url = url\n    self.token = token\n    if not self.url and plexpy.CONFIG.PMS_URL:\n        self.url = plexpy.CONFIG.PMS_URL\n    elif not self.url:\n        self.url = 'http://{hostname}:{port}'.format(hostname=plexpy.CONFIG.PMS_IP, port=plexpy.CONFIG.PMS_PORT)\n    self.timeout = plexpy.CONFIG.PMS_TIMEOUT\n    if not self.token:\n        if session.get_session_user_id():\n            user_data = users.Users()\n            user_tokens = user_data.get_tokens(user_id=session.get_session_user_id())\n            self.token = user_tokens['server_token']\n        else:\n            self.token = plexpy.CONFIG.PMS_TOKEN\n    self.ssl_verify = plexpy.CONFIG.VERIFY_SSL_CERT\n    self.request_handler = http_handler.HTTPHandler(urls=self.url, token=self.token, timeout=self.timeout, ssl_verify=self.ssl_verify)",
            "def __init__(self, url=None, token=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.url = url\n    self.token = token\n    if not self.url and plexpy.CONFIG.PMS_URL:\n        self.url = plexpy.CONFIG.PMS_URL\n    elif not self.url:\n        self.url = 'http://{hostname}:{port}'.format(hostname=plexpy.CONFIG.PMS_IP, port=plexpy.CONFIG.PMS_PORT)\n    self.timeout = plexpy.CONFIG.PMS_TIMEOUT\n    if not self.token:\n        if session.get_session_user_id():\n            user_data = users.Users()\n            user_tokens = user_data.get_tokens(user_id=session.get_session_user_id())\n            self.token = user_tokens['server_token']\n        else:\n            self.token = plexpy.CONFIG.PMS_TOKEN\n    self.ssl_verify = plexpy.CONFIG.VERIFY_SSL_CERT\n    self.request_handler = http_handler.HTTPHandler(urls=self.url, token=self.token, timeout=self.timeout, ssl_verify=self.ssl_verify)",
            "def __init__(self, url=None, token=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.url = url\n    self.token = token\n    if not self.url and plexpy.CONFIG.PMS_URL:\n        self.url = plexpy.CONFIG.PMS_URL\n    elif not self.url:\n        self.url = 'http://{hostname}:{port}'.format(hostname=plexpy.CONFIG.PMS_IP, port=plexpy.CONFIG.PMS_PORT)\n    self.timeout = plexpy.CONFIG.PMS_TIMEOUT\n    if not self.token:\n        if session.get_session_user_id():\n            user_data = users.Users()\n            user_tokens = user_data.get_tokens(user_id=session.get_session_user_id())\n            self.token = user_tokens['server_token']\n        else:\n            self.token = plexpy.CONFIG.PMS_TOKEN\n    self.ssl_verify = plexpy.CONFIG.VERIFY_SSL_CERT\n    self.request_handler = http_handler.HTTPHandler(urls=self.url, token=self.token, timeout=self.timeout, ssl_verify=self.ssl_verify)",
            "def __init__(self, url=None, token=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.url = url\n    self.token = token\n    if not self.url and plexpy.CONFIG.PMS_URL:\n        self.url = plexpy.CONFIG.PMS_URL\n    elif not self.url:\n        self.url = 'http://{hostname}:{port}'.format(hostname=plexpy.CONFIG.PMS_IP, port=plexpy.CONFIG.PMS_PORT)\n    self.timeout = plexpy.CONFIG.PMS_TIMEOUT\n    if not self.token:\n        if session.get_session_user_id():\n            user_data = users.Users()\n            user_tokens = user_data.get_tokens(user_id=session.get_session_user_id())\n            self.token = user_tokens['server_token']\n        else:\n            self.token = plexpy.CONFIG.PMS_TOKEN\n    self.ssl_verify = plexpy.CONFIG.VERIFY_SSL_CERT\n    self.request_handler = http_handler.HTTPHandler(urls=self.url, token=self.token, timeout=self.timeout, ssl_verify=self.ssl_verify)"
        ]
    },
    {
        "func_name": "get_sessions",
        "original": "def get_sessions(self, output_format=''):\n    \"\"\"\n        Return current sessions.\n\n        Optional parameters:    output_format { dict, json }\n\n        Output: array\n        \"\"\"\n    uri = '/status/sessions'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
        "mutated": [
            "def get_sessions(self, output_format=''):\n    if False:\n        i = 10\n    '\\n        Return current sessions.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/status/sessions'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_sessions(self, output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Return current sessions.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/status/sessions'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_sessions(self, output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Return current sessions.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/status/sessions'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_sessions(self, output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Return current sessions.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/status/sessions'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_sessions(self, output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Return current sessions.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/status/sessions'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request"
        ]
    },
    {
        "func_name": "get_sessions_terminate",
        "original": "def get_sessions_terminate(self, session_id='', reason=''):\n    \"\"\"\n        Return current sessions.\n\n        Optional parameters:    output_format { dict, json }\n\n        Output: array\n        \"\"\"\n    uri = '/status/sessions/terminate?sessionId=%s&reason=%s' % (session_id, quote_plus(reason))\n    request = self.request_handler.make_request(uri=uri, request_type='GET', return_response=True)\n    return request",
        "mutated": [
            "def get_sessions_terminate(self, session_id='', reason=''):\n    if False:\n        i = 10\n    '\\n        Return current sessions.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/status/sessions/terminate?sessionId=%s&reason=%s' % (session_id, quote_plus(reason))\n    request = self.request_handler.make_request(uri=uri, request_type='GET', return_response=True)\n    return request",
            "def get_sessions_terminate(self, session_id='', reason=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Return current sessions.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/status/sessions/terminate?sessionId=%s&reason=%s' % (session_id, quote_plus(reason))\n    request = self.request_handler.make_request(uri=uri, request_type='GET', return_response=True)\n    return request",
            "def get_sessions_terminate(self, session_id='', reason=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Return current sessions.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/status/sessions/terminate?sessionId=%s&reason=%s' % (session_id, quote_plus(reason))\n    request = self.request_handler.make_request(uri=uri, request_type='GET', return_response=True)\n    return request",
            "def get_sessions_terminate(self, session_id='', reason=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Return current sessions.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/status/sessions/terminate?sessionId=%s&reason=%s' % (session_id, quote_plus(reason))\n    request = self.request_handler.make_request(uri=uri, request_type='GET', return_response=True)\n    return request",
            "def get_sessions_terminate(self, session_id='', reason=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Return current sessions.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/status/sessions/terminate?sessionId=%s&reason=%s' % (session_id, quote_plus(reason))\n    request = self.request_handler.make_request(uri=uri, request_type='GET', return_response=True)\n    return request"
        ]
    },
    {
        "func_name": "get_metadata",
        "original": "def get_metadata(self, rating_key='', output_format=''):\n    \"\"\"\n        Return metadata for request item.\n\n        Parameters required:    rating_key { Plex ratingKey }\n        Optional parameters:    output_format { dict, json }\n\n        Output: array\n        \"\"\"\n    uri = '/library/metadata/' + rating_key + '?includeMarkers=1'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
        "mutated": [
            "def get_metadata(self, rating_key='', output_format=''):\n    if False:\n        i = 10\n    '\\n        Return metadata for request item.\\n\\n        Parameters required:    rating_key { Plex ratingKey }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/library/metadata/' + rating_key + '?includeMarkers=1'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_metadata(self, rating_key='', output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Return metadata for request item.\\n\\n        Parameters required:    rating_key { Plex ratingKey }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/library/metadata/' + rating_key + '?includeMarkers=1'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_metadata(self, rating_key='', output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Return metadata for request item.\\n\\n        Parameters required:    rating_key { Plex ratingKey }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/library/metadata/' + rating_key + '?includeMarkers=1'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_metadata(self, rating_key='', output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Return metadata for request item.\\n\\n        Parameters required:    rating_key { Plex ratingKey }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/library/metadata/' + rating_key + '?includeMarkers=1'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_metadata(self, rating_key='', output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Return metadata for request item.\\n\\n        Parameters required:    rating_key { Plex ratingKey }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/library/metadata/' + rating_key + '?includeMarkers=1'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request"
        ]
    },
    {
        "func_name": "get_metadata_children",
        "original": "def get_metadata_children(self, rating_key='', collection=False, output_format=''):\n    \"\"\"\n        Return metadata for children of the request item.\n\n        Parameters required:    rating_key { Plex ratingKey }\n        Optional parameters:    output_format { dict, json }\n\n        Output: array\n        \"\"\"\n    uri = '/library/{}/{}/children'.format('collections' if collection else 'metadata', rating_key)\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
        "mutated": [
            "def get_metadata_children(self, rating_key='', collection=False, output_format=''):\n    if False:\n        i = 10\n    '\\n        Return metadata for children of the request item.\\n\\n        Parameters required:    rating_key { Plex ratingKey }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/library/{}/{}/children'.format('collections' if collection else 'metadata', rating_key)\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_metadata_children(self, rating_key='', collection=False, output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Return metadata for children of the request item.\\n\\n        Parameters required:    rating_key { Plex ratingKey }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/library/{}/{}/children'.format('collections' if collection else 'metadata', rating_key)\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_metadata_children(self, rating_key='', collection=False, output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Return metadata for children of the request item.\\n\\n        Parameters required:    rating_key { Plex ratingKey }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/library/{}/{}/children'.format('collections' if collection else 'metadata', rating_key)\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_metadata_children(self, rating_key='', collection=False, output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Return metadata for children of the request item.\\n\\n        Parameters required:    rating_key { Plex ratingKey }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/library/{}/{}/children'.format('collections' if collection else 'metadata', rating_key)\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_metadata_children(self, rating_key='', collection=False, output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Return metadata for children of the request item.\\n\\n        Parameters required:    rating_key { Plex ratingKey }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/library/{}/{}/children'.format('collections' if collection else 'metadata', rating_key)\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request"
        ]
    },
    {
        "func_name": "get_metadata_grandchildren",
        "original": "def get_metadata_grandchildren(self, rating_key='', output_format=''):\n    \"\"\"\n        Return metadata for graandchildren of the request item.\n\n        Parameters required:    rating_key { Plex ratingKey }\n        Optional parameters:    output_format { dict, json }\n\n        Output: array\n        \"\"\"\n    uri = '/library/metadata/' + rating_key + '/grandchildren'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
        "mutated": [
            "def get_metadata_grandchildren(self, rating_key='', output_format=''):\n    if False:\n        i = 10\n    '\\n        Return metadata for graandchildren of the request item.\\n\\n        Parameters required:    rating_key { Plex ratingKey }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/library/metadata/' + rating_key + '/grandchildren'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_metadata_grandchildren(self, rating_key='', output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Return metadata for graandchildren of the request item.\\n\\n        Parameters required:    rating_key { Plex ratingKey }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/library/metadata/' + rating_key + '/grandchildren'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_metadata_grandchildren(self, rating_key='', output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Return metadata for graandchildren of the request item.\\n\\n        Parameters required:    rating_key { Plex ratingKey }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/library/metadata/' + rating_key + '/grandchildren'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_metadata_grandchildren(self, rating_key='', output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Return metadata for graandchildren of the request item.\\n\\n        Parameters required:    rating_key { Plex ratingKey }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/library/metadata/' + rating_key + '/grandchildren'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_metadata_grandchildren(self, rating_key='', output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Return metadata for graandchildren of the request item.\\n\\n        Parameters required:    rating_key { Plex ratingKey }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/library/metadata/' + rating_key + '/grandchildren'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request"
        ]
    },
    {
        "func_name": "get_playlist_items",
        "original": "def get_playlist_items(self, rating_key='', output_format=''):\n    \"\"\"\n        Return metadata for items of the requested playlist.\n\n        Parameters required:    rating_key { Plex ratingKey }\n        Optional parameters:    output_format { dict, json }\n\n        Output: array\n        \"\"\"\n    uri = '/playlists/' + rating_key + '/items'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
        "mutated": [
            "def get_playlist_items(self, rating_key='', output_format=''):\n    if False:\n        i = 10\n    '\\n        Return metadata for items of the requested playlist.\\n\\n        Parameters required:    rating_key { Plex ratingKey }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/playlists/' + rating_key + '/items'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_playlist_items(self, rating_key='', output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Return metadata for items of the requested playlist.\\n\\n        Parameters required:    rating_key { Plex ratingKey }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/playlists/' + rating_key + '/items'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_playlist_items(self, rating_key='', output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Return metadata for items of the requested playlist.\\n\\n        Parameters required:    rating_key { Plex ratingKey }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/playlists/' + rating_key + '/items'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_playlist_items(self, rating_key='', output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Return metadata for items of the requested playlist.\\n\\n        Parameters required:    rating_key { Plex ratingKey }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/playlists/' + rating_key + '/items'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_playlist_items(self, rating_key='', output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Return metadata for items of the requested playlist.\\n\\n        Parameters required:    rating_key { Plex ratingKey }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/playlists/' + rating_key + '/items'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request"
        ]
    },
    {
        "func_name": "get_recently_added",
        "original": "def get_recently_added(self, start='0', count='0', output_format=''):\n    \"\"\"\n        Return list of recently added items.\n\n        Parameters required:    count { number of results to return }\n        Optional parameters:    output_format { dict, json }\n\n        Output: array\n        \"\"\"\n    uri = '/library/recentlyAdded?X-Plex-Container-Start=%s&X-Plex-Container-Size=%s' % (start, count)\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
        "mutated": [
            "def get_recently_added(self, start='0', count='0', output_format=''):\n    if False:\n        i = 10\n    '\\n        Return list of recently added items.\\n\\n        Parameters required:    count { number of results to return }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/library/recentlyAdded?X-Plex-Container-Start=%s&X-Plex-Container-Size=%s' % (start, count)\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_recently_added(self, start='0', count='0', output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Return list of recently added items.\\n\\n        Parameters required:    count { number of results to return }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/library/recentlyAdded?X-Plex-Container-Start=%s&X-Plex-Container-Size=%s' % (start, count)\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_recently_added(self, start='0', count='0', output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Return list of recently added items.\\n\\n        Parameters required:    count { number of results to return }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/library/recentlyAdded?X-Plex-Container-Start=%s&X-Plex-Container-Size=%s' % (start, count)\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_recently_added(self, start='0', count='0', output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Return list of recently added items.\\n\\n        Parameters required:    count { number of results to return }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/library/recentlyAdded?X-Plex-Container-Start=%s&X-Plex-Container-Size=%s' % (start, count)\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_recently_added(self, start='0', count='0', output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Return list of recently added items.\\n\\n        Parameters required:    count { number of results to return }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/library/recentlyAdded?X-Plex-Container-Start=%s&X-Plex-Container-Size=%s' % (start, count)\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request"
        ]
    },
    {
        "func_name": "get_library_recently_added",
        "original": "def get_library_recently_added(self, section_id='', start='0', count='0', output_format=''):\n    \"\"\"\n        Return list of recently added items.\n\n        Parameters required:    count { number of results to return }\n        Optional parameters:    output_format { dict, json }\n\n        Output: array\n        \"\"\"\n    uri = '/library/sections/%s/recentlyAdded?X-Plex-Container-Start=%s&X-Plex-Container-Size=%s' % (section_id, start, count)\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
        "mutated": [
            "def get_library_recently_added(self, section_id='', start='0', count='0', output_format=''):\n    if False:\n        i = 10\n    '\\n        Return list of recently added items.\\n\\n        Parameters required:    count { number of results to return }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/library/sections/%s/recentlyAdded?X-Plex-Container-Start=%s&X-Plex-Container-Size=%s' % (section_id, start, count)\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_library_recently_added(self, section_id='', start='0', count='0', output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Return list of recently added items.\\n\\n        Parameters required:    count { number of results to return }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/library/sections/%s/recentlyAdded?X-Plex-Container-Start=%s&X-Plex-Container-Size=%s' % (section_id, start, count)\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_library_recently_added(self, section_id='', start='0', count='0', output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Return list of recently added items.\\n\\n        Parameters required:    count { number of results to return }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/library/sections/%s/recentlyAdded?X-Plex-Container-Start=%s&X-Plex-Container-Size=%s' % (section_id, start, count)\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_library_recently_added(self, section_id='', start='0', count='0', output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Return list of recently added items.\\n\\n        Parameters required:    count { number of results to return }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/library/sections/%s/recentlyAdded?X-Plex-Container-Start=%s&X-Plex-Container-Size=%s' % (section_id, start, count)\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_library_recently_added(self, section_id='', start='0', count='0', output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Return list of recently added items.\\n\\n        Parameters required:    count { number of results to return }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/library/sections/%s/recentlyAdded?X-Plex-Container-Start=%s&X-Plex-Container-Size=%s' % (section_id, start, count)\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request"
        ]
    },
    {
        "func_name": "get_children_list_related",
        "original": "def get_children_list_related(self, rating_key='', output_format=''):\n    \"\"\"\n        Return list of related children in requested collection item.\n\n        Parameters required:    rating_key { ratingKey of parent }\n        Optional parameters:    output_format { dict, json }\n\n        Output: array\n        \"\"\"\n    uri = '/hubs/metadata/' + rating_key + '/related'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
        "mutated": [
            "def get_children_list_related(self, rating_key='', output_format=''):\n    if False:\n        i = 10\n    '\\n        Return list of related children in requested collection item.\\n\\n        Parameters required:    rating_key { ratingKey of parent }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/hubs/metadata/' + rating_key + '/related'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_children_list_related(self, rating_key='', output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Return list of related children in requested collection item.\\n\\n        Parameters required:    rating_key { ratingKey of parent }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/hubs/metadata/' + rating_key + '/related'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_children_list_related(self, rating_key='', output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Return list of related children in requested collection item.\\n\\n        Parameters required:    rating_key { ratingKey of parent }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/hubs/metadata/' + rating_key + '/related'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_children_list_related(self, rating_key='', output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Return list of related children in requested collection item.\\n\\n        Parameters required:    rating_key { ratingKey of parent }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/hubs/metadata/' + rating_key + '/related'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_children_list_related(self, rating_key='', output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Return list of related children in requested collection item.\\n\\n        Parameters required:    rating_key { ratingKey of parent }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/hubs/metadata/' + rating_key + '/related'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request"
        ]
    },
    {
        "func_name": "get_childrens_list",
        "original": "def get_childrens_list(self, rating_key='', output_format=''):\n    \"\"\"\n        Return list of children in requested library item.\n\n        Parameters required:    rating_key { ratingKey of parent }\n        Optional parameters:    output_format { dict, json }\n\n        Output: array\n        \"\"\"\n    uri = '/library/metadata/' + rating_key + '/allLeaves'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
        "mutated": [
            "def get_childrens_list(self, rating_key='', output_format=''):\n    if False:\n        i = 10\n    '\\n        Return list of children in requested library item.\\n\\n        Parameters required:    rating_key { ratingKey of parent }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/library/metadata/' + rating_key + '/allLeaves'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_childrens_list(self, rating_key='', output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Return list of children in requested library item.\\n\\n        Parameters required:    rating_key { ratingKey of parent }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/library/metadata/' + rating_key + '/allLeaves'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_childrens_list(self, rating_key='', output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Return list of children in requested library item.\\n\\n        Parameters required:    rating_key { ratingKey of parent }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/library/metadata/' + rating_key + '/allLeaves'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_childrens_list(self, rating_key='', output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Return list of children in requested library item.\\n\\n        Parameters required:    rating_key { ratingKey of parent }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/library/metadata/' + rating_key + '/allLeaves'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_childrens_list(self, rating_key='', output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Return list of children in requested library item.\\n\\n        Parameters required:    rating_key { ratingKey of parent }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/library/metadata/' + rating_key + '/allLeaves'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request"
        ]
    },
    {
        "func_name": "get_server_list",
        "original": "def get_server_list(self, output_format=''):\n    \"\"\"\n        Return list of local servers.\n\n        Optional parameters:    output_format { dict, json }\n\n        Output: array\n        \"\"\"\n    uri = '/servers'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
        "mutated": [
            "def get_server_list(self, output_format=''):\n    if False:\n        i = 10\n    '\\n        Return list of local servers.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/servers'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_server_list(self, output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Return list of local servers.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/servers'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_server_list(self, output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Return list of local servers.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/servers'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_server_list(self, output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Return list of local servers.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/servers'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_server_list(self, output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Return list of local servers.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/servers'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request"
        ]
    },
    {
        "func_name": "get_server_prefs",
        "original": "def get_server_prefs(self, output_format=''):\n    \"\"\"\n        Return the local servers preferences.\n\n        Optional parameters:    output_format { dict, json }\n\n        Output: array\n        \"\"\"\n    uri = '/:/prefs'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
        "mutated": [
            "def get_server_prefs(self, output_format=''):\n    if False:\n        i = 10\n    '\\n        Return the local servers preferences.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/:/prefs'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_server_prefs(self, output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Return the local servers preferences.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/:/prefs'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_server_prefs(self, output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Return the local servers preferences.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/:/prefs'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_server_prefs(self, output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Return the local servers preferences.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/:/prefs'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_server_prefs(self, output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Return the local servers preferences.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/:/prefs'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request"
        ]
    },
    {
        "func_name": "get_local_server_identity",
        "original": "def get_local_server_identity(self, output_format=''):\n    \"\"\"\n        Return the local server identity.\n\n        Optional parameters:    output_format { dict, json }\n\n        Output: array\n        \"\"\"\n    uri = '/identity'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
        "mutated": [
            "def get_local_server_identity(self, output_format=''):\n    if False:\n        i = 10\n    '\\n        Return the local server identity.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/identity'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_local_server_identity(self, output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Return the local server identity.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/identity'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_local_server_identity(self, output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Return the local server identity.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/identity'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_local_server_identity(self, output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Return the local server identity.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/identity'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_local_server_identity(self, output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Return the local server identity.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/identity'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request"
        ]
    },
    {
        "func_name": "get_libraries_list",
        "original": "def get_libraries_list(self, output_format=''):\n    \"\"\"\n        Return list of libraries on server.\n\n        Optional parameters:    output_format { dict, json }\n\n        Output: array\n        \"\"\"\n    uri = '/library/sections'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
        "mutated": [
            "def get_libraries_list(self, output_format=''):\n    if False:\n        i = 10\n    '\\n        Return list of libraries on server.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/library/sections'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_libraries_list(self, output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Return list of libraries on server.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/library/sections'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_libraries_list(self, output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Return list of libraries on server.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/library/sections'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_libraries_list(self, output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Return list of libraries on server.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/library/sections'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_libraries_list(self, output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Return list of libraries on server.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/library/sections'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request"
        ]
    },
    {
        "func_name": "get_library_list",
        "original": "def get_library_list(self, section_id='', list_type='all', start=0, count=0, sort_type='', label_key='', output_format=''):\n    \"\"\"\n        Return list of items in library on server.\n\n        Optional parameters:    output_format { dict, json }\n\n        Output: array\n        \"\"\"\n    start = 'X-Plex-Container-Start=' + str(start)\n    count = 'X-Plex-Container-Size=' + str(count)\n    label_key = '&label=' + label_key if label_key else ''\n    uri = '/library/sections/' + section_id + '/' + list_type + '?' + start + '&' + count + sort_type + label_key\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
        "mutated": [
            "def get_library_list(self, section_id='', list_type='all', start=0, count=0, sort_type='', label_key='', output_format=''):\n    if False:\n        i = 10\n    '\\n        Return list of items in library on server.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    start = 'X-Plex-Container-Start=' + str(start)\n    count = 'X-Plex-Container-Size=' + str(count)\n    label_key = '&label=' + label_key if label_key else ''\n    uri = '/library/sections/' + section_id + '/' + list_type + '?' + start + '&' + count + sort_type + label_key\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_library_list(self, section_id='', list_type='all', start=0, count=0, sort_type='', label_key='', output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Return list of items in library on server.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    start = 'X-Plex-Container-Start=' + str(start)\n    count = 'X-Plex-Container-Size=' + str(count)\n    label_key = '&label=' + label_key if label_key else ''\n    uri = '/library/sections/' + section_id + '/' + list_type + '?' + start + '&' + count + sort_type + label_key\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_library_list(self, section_id='', list_type='all', start=0, count=0, sort_type='', label_key='', output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Return list of items in library on server.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    start = 'X-Plex-Container-Start=' + str(start)\n    count = 'X-Plex-Container-Size=' + str(count)\n    label_key = '&label=' + label_key if label_key else ''\n    uri = '/library/sections/' + section_id + '/' + list_type + '?' + start + '&' + count + sort_type + label_key\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_library_list(self, section_id='', list_type='all', start=0, count=0, sort_type='', label_key='', output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Return list of items in library on server.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    start = 'X-Plex-Container-Start=' + str(start)\n    count = 'X-Plex-Container-Size=' + str(count)\n    label_key = '&label=' + label_key if label_key else ''\n    uri = '/library/sections/' + section_id + '/' + list_type + '?' + start + '&' + count + sort_type + label_key\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_library_list(self, section_id='', list_type='all', start=0, count=0, sort_type='', label_key='', output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Return list of items in library on server.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    start = 'X-Plex-Container-Start=' + str(start)\n    count = 'X-Plex-Container-Size=' + str(count)\n    label_key = '&label=' + label_key if label_key else ''\n    uri = '/library/sections/' + section_id + '/' + list_type + '?' + start + '&' + count + sort_type + label_key\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request"
        ]
    },
    {
        "func_name": "fetch_library_list",
        "original": "def fetch_library_list(self, section_id='', list_type='all', count='', sort_type='', label_key='', output_format=''):\n    xml_head = []\n    start = 0\n    _count = int(count) if count else 100\n    while True:\n        library_data = self.get_library_list(section_id=str(section_id), list_type=list_type, start=start, count=_count, sort_type=sort_type, label_key=label_key, output_format=output_format)\n        try:\n            _xml_head = library_data.getElementsByTagName('MediaContainer')\n            library_count = int(helpers.get_xml_attr(_xml_head[0], 'totalSize'))\n            xml_head.extend(_xml_head)\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to parse XML for fetch_library_list: %s.' % e)\n            return xml_head\n        start += _count\n        if count or start >= library_count:\n            break\n    return xml_head",
        "mutated": [
            "def fetch_library_list(self, section_id='', list_type='all', count='', sort_type='', label_key='', output_format=''):\n    if False:\n        i = 10\n    xml_head = []\n    start = 0\n    _count = int(count) if count else 100\n    while True:\n        library_data = self.get_library_list(section_id=str(section_id), list_type=list_type, start=start, count=_count, sort_type=sort_type, label_key=label_key, output_format=output_format)\n        try:\n            _xml_head = library_data.getElementsByTagName('MediaContainer')\n            library_count = int(helpers.get_xml_attr(_xml_head[0], 'totalSize'))\n            xml_head.extend(_xml_head)\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to parse XML for fetch_library_list: %s.' % e)\n            return xml_head\n        start += _count\n        if count or start >= library_count:\n            break\n    return xml_head",
            "def fetch_library_list(self, section_id='', list_type='all', count='', sort_type='', label_key='', output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    xml_head = []\n    start = 0\n    _count = int(count) if count else 100\n    while True:\n        library_data = self.get_library_list(section_id=str(section_id), list_type=list_type, start=start, count=_count, sort_type=sort_type, label_key=label_key, output_format=output_format)\n        try:\n            _xml_head = library_data.getElementsByTagName('MediaContainer')\n            library_count = int(helpers.get_xml_attr(_xml_head[0], 'totalSize'))\n            xml_head.extend(_xml_head)\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to parse XML for fetch_library_list: %s.' % e)\n            return xml_head\n        start += _count\n        if count or start >= library_count:\n            break\n    return xml_head",
            "def fetch_library_list(self, section_id='', list_type='all', count='', sort_type='', label_key='', output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    xml_head = []\n    start = 0\n    _count = int(count) if count else 100\n    while True:\n        library_data = self.get_library_list(section_id=str(section_id), list_type=list_type, start=start, count=_count, sort_type=sort_type, label_key=label_key, output_format=output_format)\n        try:\n            _xml_head = library_data.getElementsByTagName('MediaContainer')\n            library_count = int(helpers.get_xml_attr(_xml_head[0], 'totalSize'))\n            xml_head.extend(_xml_head)\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to parse XML for fetch_library_list: %s.' % e)\n            return xml_head\n        start += _count\n        if count or start >= library_count:\n            break\n    return xml_head",
            "def fetch_library_list(self, section_id='', list_type='all', count='', sort_type='', label_key='', output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    xml_head = []\n    start = 0\n    _count = int(count) if count else 100\n    while True:\n        library_data = self.get_library_list(section_id=str(section_id), list_type=list_type, start=start, count=_count, sort_type=sort_type, label_key=label_key, output_format=output_format)\n        try:\n            _xml_head = library_data.getElementsByTagName('MediaContainer')\n            library_count = int(helpers.get_xml_attr(_xml_head[0], 'totalSize'))\n            xml_head.extend(_xml_head)\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to parse XML for fetch_library_list: %s.' % e)\n            return xml_head\n        start += _count\n        if count or start >= library_count:\n            break\n    return xml_head",
            "def fetch_library_list(self, section_id='', list_type='all', count='', sort_type='', label_key='', output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    xml_head = []\n    start = 0\n    _count = int(count) if count else 100\n    while True:\n        library_data = self.get_library_list(section_id=str(section_id), list_type=list_type, start=start, count=_count, sort_type=sort_type, label_key=label_key, output_format=output_format)\n        try:\n            _xml_head = library_data.getElementsByTagName('MediaContainer')\n            library_count = int(helpers.get_xml_attr(_xml_head[0], 'totalSize'))\n            xml_head.extend(_xml_head)\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to parse XML for fetch_library_list: %s.' % e)\n            return xml_head\n        start += _count\n        if count or start >= library_count:\n            break\n    return xml_head"
        ]
    },
    {
        "func_name": "get_library_labels",
        "original": "def get_library_labels(self, section_id='', output_format=''):\n    \"\"\"\n        Return list of labels for a library on server.\n\n        Optional parameters:    output_format { dict, json }\n\n        Output: array\n        \"\"\"\n    uri = '/library/sections/' + section_id + '/label'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
        "mutated": [
            "def get_library_labels(self, section_id='', output_format=''):\n    if False:\n        i = 10\n    '\\n        Return list of labels for a library on server.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/library/sections/' + section_id + '/label'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_library_labels(self, section_id='', output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Return list of labels for a library on server.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/library/sections/' + section_id + '/label'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_library_labels(self, section_id='', output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Return list of labels for a library on server.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/library/sections/' + section_id + '/label'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_library_labels(self, section_id='', output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Return list of labels for a library on server.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/library/sections/' + section_id + '/label'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_library_labels(self, section_id='', output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Return list of labels for a library on server.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/library/sections/' + section_id + '/label'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request"
        ]
    },
    {
        "func_name": "get_sync_item",
        "original": "def get_sync_item(self, sync_id='', output_format=''):\n    \"\"\"\n        Return sync item details.\n\n        Parameters required:    sync_id { unique sync id for item }\n        Optional parameters:    output_format { dict, json }\n\n        Output: array\n        \"\"\"\n    uri = '/sync/items/' + sync_id\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
        "mutated": [
            "def get_sync_item(self, sync_id='', output_format=''):\n    if False:\n        i = 10\n    '\\n        Return sync item details.\\n\\n        Parameters required:    sync_id { unique sync id for item }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/sync/items/' + sync_id\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_sync_item(self, sync_id='', output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Return sync item details.\\n\\n        Parameters required:    sync_id { unique sync id for item }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/sync/items/' + sync_id\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_sync_item(self, sync_id='', output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Return sync item details.\\n\\n        Parameters required:    sync_id { unique sync id for item }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/sync/items/' + sync_id\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_sync_item(self, sync_id='', output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Return sync item details.\\n\\n        Parameters required:    sync_id { unique sync id for item }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/sync/items/' + sync_id\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_sync_item(self, sync_id='', output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Return sync item details.\\n\\n        Parameters required:    sync_id { unique sync id for item }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/sync/items/' + sync_id\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request"
        ]
    },
    {
        "func_name": "get_sync_transcode_queue",
        "original": "def get_sync_transcode_queue(self, output_format=''):\n    \"\"\"\n        Return sync transcode queue.\n\n        Optional parameters:    output_format { dict, json }\n\n        Output: array\n        \"\"\"\n    uri = '/sync/transcodeQueue'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
        "mutated": [
            "def get_sync_transcode_queue(self, output_format=''):\n    if False:\n        i = 10\n    '\\n        Return sync transcode queue.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/sync/transcodeQueue'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_sync_transcode_queue(self, output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Return sync transcode queue.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/sync/transcodeQueue'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_sync_transcode_queue(self, output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Return sync transcode queue.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/sync/transcodeQueue'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_sync_transcode_queue(self, output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Return sync transcode queue.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/sync/transcodeQueue'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_sync_transcode_queue(self, output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Return sync transcode queue.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/sync/transcodeQueue'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request"
        ]
    },
    {
        "func_name": "get_search",
        "original": "def get_search(self, query='', limit='', output_format=''):\n    \"\"\"\n        Return search results.\n\n        Optional parameters:    output_format { dict, json }\n\n        Output: array\n        \"\"\"\n    uri = '/hubs/search?query=' + quote(query.encode('utf8')) + '&limit=' + limit + '&includeCollections=1'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
        "mutated": [
            "def get_search(self, query='', limit='', output_format=''):\n    if False:\n        i = 10\n    '\\n        Return search results.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/hubs/search?query=' + quote(query.encode('utf8')) + '&limit=' + limit + '&includeCollections=1'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_search(self, query='', limit='', output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Return search results.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/hubs/search?query=' + quote(query.encode('utf8')) + '&limit=' + limit + '&includeCollections=1'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_search(self, query='', limit='', output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Return search results.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/hubs/search?query=' + quote(query.encode('utf8')) + '&limit=' + limit + '&includeCollections=1'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_search(self, query='', limit='', output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Return search results.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/hubs/search?query=' + quote(query.encode('utf8')) + '&limit=' + limit + '&includeCollections=1'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_search(self, query='', limit='', output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Return search results.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/hubs/search?query=' + quote(query.encode('utf8')) + '&limit=' + limit + '&includeCollections=1'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request"
        ]
    },
    {
        "func_name": "get_account",
        "original": "def get_account(self, output_format=''):\n    \"\"\"\n        Return account details.\n\n        Optional parameters:    output_format { dict, json }\n\n        Output: array\n        \"\"\"\n    uri = '/myplex/account'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
        "mutated": [
            "def get_account(self, output_format=''):\n    if False:\n        i = 10\n    '\\n        Return account details.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/myplex/account'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_account(self, output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Return account details.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/myplex/account'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_account(self, output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Return account details.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/myplex/account'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_account(self, output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Return account details.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/myplex/account'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_account(self, output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Return account details.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/myplex/account'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request"
        ]
    },
    {
        "func_name": "put_refresh_reachability",
        "original": "def put_refresh_reachability(self):\n    \"\"\"\n        Refresh Plex remote access port mapping.\n\n        Optional parameters:    None\n\n        Output: None\n        \"\"\"\n    uri = '/myplex/refreshReachability'\n    request = self.request_handler.make_request(uri=uri, request_type='PUT')\n    return request",
        "mutated": [
            "def put_refresh_reachability(self):\n    if False:\n        i = 10\n    '\\n        Refresh Plex remote access port mapping.\\n\\n        Optional parameters:    None\\n\\n        Output: None\\n        '\n    uri = '/myplex/refreshReachability'\n    request = self.request_handler.make_request(uri=uri, request_type='PUT')\n    return request",
            "def put_refresh_reachability(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Refresh Plex remote access port mapping.\\n\\n        Optional parameters:    None\\n\\n        Output: None\\n        '\n    uri = '/myplex/refreshReachability'\n    request = self.request_handler.make_request(uri=uri, request_type='PUT')\n    return request",
            "def put_refresh_reachability(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Refresh Plex remote access port mapping.\\n\\n        Optional parameters:    None\\n\\n        Output: None\\n        '\n    uri = '/myplex/refreshReachability'\n    request = self.request_handler.make_request(uri=uri, request_type='PUT')\n    return request",
            "def put_refresh_reachability(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Refresh Plex remote access port mapping.\\n\\n        Optional parameters:    None\\n\\n        Output: None\\n        '\n    uri = '/myplex/refreshReachability'\n    request = self.request_handler.make_request(uri=uri, request_type='PUT')\n    return request",
            "def put_refresh_reachability(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Refresh Plex remote access port mapping.\\n\\n        Optional parameters:    None\\n\\n        Output: None\\n        '\n    uri = '/myplex/refreshReachability'\n    request = self.request_handler.make_request(uri=uri, request_type='PUT')\n    return request"
        ]
    },
    {
        "func_name": "put_updater",
        "original": "def put_updater(self, output_format=''):\n    \"\"\"\n        Refresh updater status.\n\n        Optional parameters:    output_format { dict, json }\n\n        Output: array\n        \"\"\"\n    uri = '/updater/check?download=0'\n    request = self.request_handler.make_request(uri=uri, request_type='PUT', output_format=output_format)\n    return request",
        "mutated": [
            "def put_updater(self, output_format=''):\n    if False:\n        i = 10\n    '\\n        Refresh updater status.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/updater/check?download=0'\n    request = self.request_handler.make_request(uri=uri, request_type='PUT', output_format=output_format)\n    return request",
            "def put_updater(self, output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Refresh updater status.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/updater/check?download=0'\n    request = self.request_handler.make_request(uri=uri, request_type='PUT', output_format=output_format)\n    return request",
            "def put_updater(self, output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Refresh updater status.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/updater/check?download=0'\n    request = self.request_handler.make_request(uri=uri, request_type='PUT', output_format=output_format)\n    return request",
            "def put_updater(self, output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Refresh updater status.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/updater/check?download=0'\n    request = self.request_handler.make_request(uri=uri, request_type='PUT', output_format=output_format)\n    return request",
            "def put_updater(self, output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Refresh updater status.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/updater/check?download=0'\n    request = self.request_handler.make_request(uri=uri, request_type='PUT', output_format=output_format)\n    return request"
        ]
    },
    {
        "func_name": "get_updater",
        "original": "def get_updater(self, output_format=''):\n    \"\"\"\n        Return updater status.\n\n        Optional parameters:    output_format { dict, json }\n\n        Output: array\n        \"\"\"\n    uri = '/updater/status'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
        "mutated": [
            "def get_updater(self, output_format=''):\n    if False:\n        i = 10\n    '\\n        Return updater status.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/updater/status'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_updater(self, output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Return updater status.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/updater/status'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_updater(self, output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Return updater status.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/updater/status'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_updater(self, output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Return updater status.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/updater/status'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_updater(self, output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Return updater status.\\n\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    uri = '/updater/status'\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request"
        ]
    },
    {
        "func_name": "get_hub_recently_added",
        "original": "def get_hub_recently_added(self, start='0', count='0', media_type='', other_video=False, output_format=''):\n    \"\"\"\n        Return Plex hub recently added.\n\n        Parameters required:    start { item number to start from }\n                                count { number of results to return }\n                                media_type { str }\n        Optional parameters:    output_format { dict, json }\n\n        Output: array\n        \"\"\"\n    personal = '&personal=1' if other_video else ''\n    uri = '/hubs/home/recentlyAdded?X-Plex-Container-Start=%s&X-Plex-Container-Size=%s&type=%s%s' % (start, count, media_type, personal)\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
        "mutated": [
            "def get_hub_recently_added(self, start='0', count='0', media_type='', other_video=False, output_format=''):\n    if False:\n        i = 10\n    '\\n        Return Plex hub recently added.\\n\\n        Parameters required:    start { item number to start from }\\n                                count { number of results to return }\\n                                media_type { str }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    personal = '&personal=1' if other_video else ''\n    uri = '/hubs/home/recentlyAdded?X-Plex-Container-Start=%s&X-Plex-Container-Size=%s&type=%s%s' % (start, count, media_type, personal)\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_hub_recently_added(self, start='0', count='0', media_type='', other_video=False, output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Return Plex hub recently added.\\n\\n        Parameters required:    start { item number to start from }\\n                                count { number of results to return }\\n                                media_type { str }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    personal = '&personal=1' if other_video else ''\n    uri = '/hubs/home/recentlyAdded?X-Plex-Container-Start=%s&X-Plex-Container-Size=%s&type=%s%s' % (start, count, media_type, personal)\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_hub_recently_added(self, start='0', count='0', media_type='', other_video=False, output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Return Plex hub recently added.\\n\\n        Parameters required:    start { item number to start from }\\n                                count { number of results to return }\\n                                media_type { str }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    personal = '&personal=1' if other_video else ''\n    uri = '/hubs/home/recentlyAdded?X-Plex-Container-Start=%s&X-Plex-Container-Size=%s&type=%s%s' % (start, count, media_type, personal)\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_hub_recently_added(self, start='0', count='0', media_type='', other_video=False, output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Return Plex hub recently added.\\n\\n        Parameters required:    start { item number to start from }\\n                                count { number of results to return }\\n                                media_type { str }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    personal = '&personal=1' if other_video else ''\n    uri = '/hubs/home/recentlyAdded?X-Plex-Container-Start=%s&X-Plex-Container-Size=%s&type=%s%s' % (start, count, media_type, personal)\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request",
            "def get_hub_recently_added(self, start='0', count='0', media_type='', other_video=False, output_format=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Return Plex hub recently added.\\n\\n        Parameters required:    start { item number to start from }\\n                                count { number of results to return }\\n                                media_type { str }\\n        Optional parameters:    output_format { dict, json }\\n\\n        Output: array\\n        '\n    personal = '&personal=1' if other_video else ''\n    uri = '/hubs/home/recentlyAdded?X-Plex-Container-Start=%s&X-Plex-Container-Size=%s&type=%s%s' % (start, count, media_type, personal)\n    request = self.request_handler.make_request(uri=uri, request_type='GET', output_format=output_format)\n    return request"
        ]
    },
    {
        "func_name": "get_recently_added_details",
        "original": "def get_recently_added_details(self, start='0', count='0', media_type='', section_id=''):\n    \"\"\"\n        Return processed and validated list of recently added items.\n\n        Parameters required:    count { number of results to return }\n\n        Output: array\n        \"\"\"\n    media_types = ('movie', 'show', 'artist', 'other_video')\n    recents_list = []\n    if media_type in media_types:\n        other_video = False\n        if media_type == 'movie':\n            media_type = '1'\n        elif media_type == 'show':\n            media_type = '2'\n        elif media_type == 'artist':\n            media_type = '8'\n        elif media_type == 'other_video':\n            media_type = '1'\n            other_video = True\n        recent = self.get_hub_recently_added(start, count, media_type, other_video, output_format='xml')\n    elif section_id:\n        recent = self.get_library_recently_added(section_id, start, count, output_format='xml')\n    else:\n        for media_type in media_types:\n            recents = self.get_recently_added_details(start, count, media_type)\n            recents_list += recents['recently_added']\n        output = {'recently_added': sorted(recents_list, key=lambda k: k['added_at'], reverse=True)[:int(count)]}\n        return output\n    try:\n        xml_head = recent.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_recently_added: %s.' % e)\n        return {'recently_added': []}\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                output = {'recently_added': []}\n                return output\n        recents_main = []\n        if a.getElementsByTagName('Directory'):\n            recents_main += a.getElementsByTagName('Directory')\n        if a.getElementsByTagName('Video'):\n            recents_main += a.getElementsByTagName('Video')\n        for m in recents_main:\n            directors = []\n            writers = []\n            actors = []\n            genres = []\n            labels = []\n            collections = []\n            guids = []\n            if m.getElementsByTagName('Director'):\n                for director in m.getElementsByTagName('Director'):\n                    directors.append(helpers.get_xml_attr(director, 'tag'))\n            if m.getElementsByTagName('Writer'):\n                for writer in m.getElementsByTagName('Writer'):\n                    writers.append(helpers.get_xml_attr(writer, 'tag'))\n            if m.getElementsByTagName('Role'):\n                for actor in m.getElementsByTagName('Role'):\n                    actors.append(helpers.get_xml_attr(actor, 'tag'))\n            if m.getElementsByTagName('Genre'):\n                for genre in m.getElementsByTagName('Genre'):\n                    genres.append(helpers.get_xml_attr(genre, 'tag'))\n            if m.getElementsByTagName('Label'):\n                for label in m.getElementsByTagName('Label'):\n                    labels.append(helpers.get_xml_attr(label, 'tag'))\n            if m.getElementsByTagName('Collection'):\n                for collection in m.getElementsByTagName('Collection'):\n                    collections.append(helpers.get_xml_attr(collection, 'tag'))\n            if m.getElementsByTagName('Guid'):\n                for guid in m.getElementsByTagName('Guid'):\n                    guids.append(helpers.get_xml_attr(guid, 'id'))\n            recent_item = {'media_type': helpers.get_xml_attr(m, 'type'), 'section_id': helpers.get_xml_attr(m, 'librarySectionID'), 'library_name': helpers.get_xml_attr(m, 'librarySectionTitle'), 'rating_key': helpers.get_xml_attr(m, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(m, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(m, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(m, 'title'), 'parent_title': helpers.get_xml_attr(m, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(m, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(m, 'originalTitle'), 'sort_title': helpers.get_xml_attr(m, 'titleSort'), 'media_index': helpers.get_xml_attr(m, 'index'), 'parent_media_index': helpers.get_xml_attr(m, 'parentIndex'), 'studio': helpers.get_xml_attr(m, 'studio'), 'content_rating': helpers.get_xml_attr(m, 'contentRating'), 'summary': helpers.get_xml_attr(m, 'summary'), 'tagline': helpers.get_xml_attr(m, 'tagline'), 'rating': helpers.get_xml_attr(m, 'rating'), 'rating_image': helpers.get_xml_attr(m, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(m, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(m, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(m, 'userRating'), 'duration': helpers.get_xml_attr(m, 'duration'), 'year': helpers.get_xml_attr(m, 'year'), 'thumb': helpers.get_xml_attr(m, 'thumb'), 'parent_thumb': helpers.get_xml_attr(m, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(m, 'grandparentThumb'), 'art': helpers.get_xml_attr(m, 'art'), 'banner': helpers.get_xml_attr(m, 'banner'), 'originally_available_at': helpers.get_xml_attr(m, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(m, 'addedAt'), 'updated_at': helpers.get_xml_attr(m, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(m, 'lastViewedAt'), 'guid': helpers.get_xml_attr(m, 'guid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'guids': guids, 'full_title': helpers.get_xml_attr(m, 'title'), 'child_count': helpers.get_xml_attr(m, 'childCount')}\n            recents_list.append(recent_item)\n    output = {'recently_added': sorted(recents_list, key=lambda k: k['added_at'], reverse=True)}\n    return output",
        "mutated": [
            "def get_recently_added_details(self, start='0', count='0', media_type='', section_id=''):\n    if False:\n        i = 10\n    '\\n        Return processed and validated list of recently added items.\\n\\n        Parameters required:    count { number of results to return }\\n\\n        Output: array\\n        '\n    media_types = ('movie', 'show', 'artist', 'other_video')\n    recents_list = []\n    if media_type in media_types:\n        other_video = False\n        if media_type == 'movie':\n            media_type = '1'\n        elif media_type == 'show':\n            media_type = '2'\n        elif media_type == 'artist':\n            media_type = '8'\n        elif media_type == 'other_video':\n            media_type = '1'\n            other_video = True\n        recent = self.get_hub_recently_added(start, count, media_type, other_video, output_format='xml')\n    elif section_id:\n        recent = self.get_library_recently_added(section_id, start, count, output_format='xml')\n    else:\n        for media_type in media_types:\n            recents = self.get_recently_added_details(start, count, media_type)\n            recents_list += recents['recently_added']\n        output = {'recently_added': sorted(recents_list, key=lambda k: k['added_at'], reverse=True)[:int(count)]}\n        return output\n    try:\n        xml_head = recent.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_recently_added: %s.' % e)\n        return {'recently_added': []}\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                output = {'recently_added': []}\n                return output\n        recents_main = []\n        if a.getElementsByTagName('Directory'):\n            recents_main += a.getElementsByTagName('Directory')\n        if a.getElementsByTagName('Video'):\n            recents_main += a.getElementsByTagName('Video')\n        for m in recents_main:\n            directors = []\n            writers = []\n            actors = []\n            genres = []\n            labels = []\n            collections = []\n            guids = []\n            if m.getElementsByTagName('Director'):\n                for director in m.getElementsByTagName('Director'):\n                    directors.append(helpers.get_xml_attr(director, 'tag'))\n            if m.getElementsByTagName('Writer'):\n                for writer in m.getElementsByTagName('Writer'):\n                    writers.append(helpers.get_xml_attr(writer, 'tag'))\n            if m.getElementsByTagName('Role'):\n                for actor in m.getElementsByTagName('Role'):\n                    actors.append(helpers.get_xml_attr(actor, 'tag'))\n            if m.getElementsByTagName('Genre'):\n                for genre in m.getElementsByTagName('Genre'):\n                    genres.append(helpers.get_xml_attr(genre, 'tag'))\n            if m.getElementsByTagName('Label'):\n                for label in m.getElementsByTagName('Label'):\n                    labels.append(helpers.get_xml_attr(label, 'tag'))\n            if m.getElementsByTagName('Collection'):\n                for collection in m.getElementsByTagName('Collection'):\n                    collections.append(helpers.get_xml_attr(collection, 'tag'))\n            if m.getElementsByTagName('Guid'):\n                for guid in m.getElementsByTagName('Guid'):\n                    guids.append(helpers.get_xml_attr(guid, 'id'))\n            recent_item = {'media_type': helpers.get_xml_attr(m, 'type'), 'section_id': helpers.get_xml_attr(m, 'librarySectionID'), 'library_name': helpers.get_xml_attr(m, 'librarySectionTitle'), 'rating_key': helpers.get_xml_attr(m, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(m, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(m, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(m, 'title'), 'parent_title': helpers.get_xml_attr(m, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(m, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(m, 'originalTitle'), 'sort_title': helpers.get_xml_attr(m, 'titleSort'), 'media_index': helpers.get_xml_attr(m, 'index'), 'parent_media_index': helpers.get_xml_attr(m, 'parentIndex'), 'studio': helpers.get_xml_attr(m, 'studio'), 'content_rating': helpers.get_xml_attr(m, 'contentRating'), 'summary': helpers.get_xml_attr(m, 'summary'), 'tagline': helpers.get_xml_attr(m, 'tagline'), 'rating': helpers.get_xml_attr(m, 'rating'), 'rating_image': helpers.get_xml_attr(m, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(m, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(m, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(m, 'userRating'), 'duration': helpers.get_xml_attr(m, 'duration'), 'year': helpers.get_xml_attr(m, 'year'), 'thumb': helpers.get_xml_attr(m, 'thumb'), 'parent_thumb': helpers.get_xml_attr(m, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(m, 'grandparentThumb'), 'art': helpers.get_xml_attr(m, 'art'), 'banner': helpers.get_xml_attr(m, 'banner'), 'originally_available_at': helpers.get_xml_attr(m, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(m, 'addedAt'), 'updated_at': helpers.get_xml_attr(m, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(m, 'lastViewedAt'), 'guid': helpers.get_xml_attr(m, 'guid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'guids': guids, 'full_title': helpers.get_xml_attr(m, 'title'), 'child_count': helpers.get_xml_attr(m, 'childCount')}\n            recents_list.append(recent_item)\n    output = {'recently_added': sorted(recents_list, key=lambda k: k['added_at'], reverse=True)}\n    return output",
            "def get_recently_added_details(self, start='0', count='0', media_type='', section_id=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Return processed and validated list of recently added items.\\n\\n        Parameters required:    count { number of results to return }\\n\\n        Output: array\\n        '\n    media_types = ('movie', 'show', 'artist', 'other_video')\n    recents_list = []\n    if media_type in media_types:\n        other_video = False\n        if media_type == 'movie':\n            media_type = '1'\n        elif media_type == 'show':\n            media_type = '2'\n        elif media_type == 'artist':\n            media_type = '8'\n        elif media_type == 'other_video':\n            media_type = '1'\n            other_video = True\n        recent = self.get_hub_recently_added(start, count, media_type, other_video, output_format='xml')\n    elif section_id:\n        recent = self.get_library_recently_added(section_id, start, count, output_format='xml')\n    else:\n        for media_type in media_types:\n            recents = self.get_recently_added_details(start, count, media_type)\n            recents_list += recents['recently_added']\n        output = {'recently_added': sorted(recents_list, key=lambda k: k['added_at'], reverse=True)[:int(count)]}\n        return output\n    try:\n        xml_head = recent.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_recently_added: %s.' % e)\n        return {'recently_added': []}\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                output = {'recently_added': []}\n                return output\n        recents_main = []\n        if a.getElementsByTagName('Directory'):\n            recents_main += a.getElementsByTagName('Directory')\n        if a.getElementsByTagName('Video'):\n            recents_main += a.getElementsByTagName('Video')\n        for m in recents_main:\n            directors = []\n            writers = []\n            actors = []\n            genres = []\n            labels = []\n            collections = []\n            guids = []\n            if m.getElementsByTagName('Director'):\n                for director in m.getElementsByTagName('Director'):\n                    directors.append(helpers.get_xml_attr(director, 'tag'))\n            if m.getElementsByTagName('Writer'):\n                for writer in m.getElementsByTagName('Writer'):\n                    writers.append(helpers.get_xml_attr(writer, 'tag'))\n            if m.getElementsByTagName('Role'):\n                for actor in m.getElementsByTagName('Role'):\n                    actors.append(helpers.get_xml_attr(actor, 'tag'))\n            if m.getElementsByTagName('Genre'):\n                for genre in m.getElementsByTagName('Genre'):\n                    genres.append(helpers.get_xml_attr(genre, 'tag'))\n            if m.getElementsByTagName('Label'):\n                for label in m.getElementsByTagName('Label'):\n                    labels.append(helpers.get_xml_attr(label, 'tag'))\n            if m.getElementsByTagName('Collection'):\n                for collection in m.getElementsByTagName('Collection'):\n                    collections.append(helpers.get_xml_attr(collection, 'tag'))\n            if m.getElementsByTagName('Guid'):\n                for guid in m.getElementsByTagName('Guid'):\n                    guids.append(helpers.get_xml_attr(guid, 'id'))\n            recent_item = {'media_type': helpers.get_xml_attr(m, 'type'), 'section_id': helpers.get_xml_attr(m, 'librarySectionID'), 'library_name': helpers.get_xml_attr(m, 'librarySectionTitle'), 'rating_key': helpers.get_xml_attr(m, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(m, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(m, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(m, 'title'), 'parent_title': helpers.get_xml_attr(m, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(m, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(m, 'originalTitle'), 'sort_title': helpers.get_xml_attr(m, 'titleSort'), 'media_index': helpers.get_xml_attr(m, 'index'), 'parent_media_index': helpers.get_xml_attr(m, 'parentIndex'), 'studio': helpers.get_xml_attr(m, 'studio'), 'content_rating': helpers.get_xml_attr(m, 'contentRating'), 'summary': helpers.get_xml_attr(m, 'summary'), 'tagline': helpers.get_xml_attr(m, 'tagline'), 'rating': helpers.get_xml_attr(m, 'rating'), 'rating_image': helpers.get_xml_attr(m, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(m, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(m, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(m, 'userRating'), 'duration': helpers.get_xml_attr(m, 'duration'), 'year': helpers.get_xml_attr(m, 'year'), 'thumb': helpers.get_xml_attr(m, 'thumb'), 'parent_thumb': helpers.get_xml_attr(m, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(m, 'grandparentThumb'), 'art': helpers.get_xml_attr(m, 'art'), 'banner': helpers.get_xml_attr(m, 'banner'), 'originally_available_at': helpers.get_xml_attr(m, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(m, 'addedAt'), 'updated_at': helpers.get_xml_attr(m, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(m, 'lastViewedAt'), 'guid': helpers.get_xml_attr(m, 'guid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'guids': guids, 'full_title': helpers.get_xml_attr(m, 'title'), 'child_count': helpers.get_xml_attr(m, 'childCount')}\n            recents_list.append(recent_item)\n    output = {'recently_added': sorted(recents_list, key=lambda k: k['added_at'], reverse=True)}\n    return output",
            "def get_recently_added_details(self, start='0', count='0', media_type='', section_id=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Return processed and validated list of recently added items.\\n\\n        Parameters required:    count { number of results to return }\\n\\n        Output: array\\n        '\n    media_types = ('movie', 'show', 'artist', 'other_video')\n    recents_list = []\n    if media_type in media_types:\n        other_video = False\n        if media_type == 'movie':\n            media_type = '1'\n        elif media_type == 'show':\n            media_type = '2'\n        elif media_type == 'artist':\n            media_type = '8'\n        elif media_type == 'other_video':\n            media_type = '1'\n            other_video = True\n        recent = self.get_hub_recently_added(start, count, media_type, other_video, output_format='xml')\n    elif section_id:\n        recent = self.get_library_recently_added(section_id, start, count, output_format='xml')\n    else:\n        for media_type in media_types:\n            recents = self.get_recently_added_details(start, count, media_type)\n            recents_list += recents['recently_added']\n        output = {'recently_added': sorted(recents_list, key=lambda k: k['added_at'], reverse=True)[:int(count)]}\n        return output\n    try:\n        xml_head = recent.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_recently_added: %s.' % e)\n        return {'recently_added': []}\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                output = {'recently_added': []}\n                return output\n        recents_main = []\n        if a.getElementsByTagName('Directory'):\n            recents_main += a.getElementsByTagName('Directory')\n        if a.getElementsByTagName('Video'):\n            recents_main += a.getElementsByTagName('Video')\n        for m in recents_main:\n            directors = []\n            writers = []\n            actors = []\n            genres = []\n            labels = []\n            collections = []\n            guids = []\n            if m.getElementsByTagName('Director'):\n                for director in m.getElementsByTagName('Director'):\n                    directors.append(helpers.get_xml_attr(director, 'tag'))\n            if m.getElementsByTagName('Writer'):\n                for writer in m.getElementsByTagName('Writer'):\n                    writers.append(helpers.get_xml_attr(writer, 'tag'))\n            if m.getElementsByTagName('Role'):\n                for actor in m.getElementsByTagName('Role'):\n                    actors.append(helpers.get_xml_attr(actor, 'tag'))\n            if m.getElementsByTagName('Genre'):\n                for genre in m.getElementsByTagName('Genre'):\n                    genres.append(helpers.get_xml_attr(genre, 'tag'))\n            if m.getElementsByTagName('Label'):\n                for label in m.getElementsByTagName('Label'):\n                    labels.append(helpers.get_xml_attr(label, 'tag'))\n            if m.getElementsByTagName('Collection'):\n                for collection in m.getElementsByTagName('Collection'):\n                    collections.append(helpers.get_xml_attr(collection, 'tag'))\n            if m.getElementsByTagName('Guid'):\n                for guid in m.getElementsByTagName('Guid'):\n                    guids.append(helpers.get_xml_attr(guid, 'id'))\n            recent_item = {'media_type': helpers.get_xml_attr(m, 'type'), 'section_id': helpers.get_xml_attr(m, 'librarySectionID'), 'library_name': helpers.get_xml_attr(m, 'librarySectionTitle'), 'rating_key': helpers.get_xml_attr(m, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(m, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(m, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(m, 'title'), 'parent_title': helpers.get_xml_attr(m, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(m, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(m, 'originalTitle'), 'sort_title': helpers.get_xml_attr(m, 'titleSort'), 'media_index': helpers.get_xml_attr(m, 'index'), 'parent_media_index': helpers.get_xml_attr(m, 'parentIndex'), 'studio': helpers.get_xml_attr(m, 'studio'), 'content_rating': helpers.get_xml_attr(m, 'contentRating'), 'summary': helpers.get_xml_attr(m, 'summary'), 'tagline': helpers.get_xml_attr(m, 'tagline'), 'rating': helpers.get_xml_attr(m, 'rating'), 'rating_image': helpers.get_xml_attr(m, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(m, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(m, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(m, 'userRating'), 'duration': helpers.get_xml_attr(m, 'duration'), 'year': helpers.get_xml_attr(m, 'year'), 'thumb': helpers.get_xml_attr(m, 'thumb'), 'parent_thumb': helpers.get_xml_attr(m, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(m, 'grandparentThumb'), 'art': helpers.get_xml_attr(m, 'art'), 'banner': helpers.get_xml_attr(m, 'banner'), 'originally_available_at': helpers.get_xml_attr(m, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(m, 'addedAt'), 'updated_at': helpers.get_xml_attr(m, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(m, 'lastViewedAt'), 'guid': helpers.get_xml_attr(m, 'guid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'guids': guids, 'full_title': helpers.get_xml_attr(m, 'title'), 'child_count': helpers.get_xml_attr(m, 'childCount')}\n            recents_list.append(recent_item)\n    output = {'recently_added': sorted(recents_list, key=lambda k: k['added_at'], reverse=True)}\n    return output",
            "def get_recently_added_details(self, start='0', count='0', media_type='', section_id=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Return processed and validated list of recently added items.\\n\\n        Parameters required:    count { number of results to return }\\n\\n        Output: array\\n        '\n    media_types = ('movie', 'show', 'artist', 'other_video')\n    recents_list = []\n    if media_type in media_types:\n        other_video = False\n        if media_type == 'movie':\n            media_type = '1'\n        elif media_type == 'show':\n            media_type = '2'\n        elif media_type == 'artist':\n            media_type = '8'\n        elif media_type == 'other_video':\n            media_type = '1'\n            other_video = True\n        recent = self.get_hub_recently_added(start, count, media_type, other_video, output_format='xml')\n    elif section_id:\n        recent = self.get_library_recently_added(section_id, start, count, output_format='xml')\n    else:\n        for media_type in media_types:\n            recents = self.get_recently_added_details(start, count, media_type)\n            recents_list += recents['recently_added']\n        output = {'recently_added': sorted(recents_list, key=lambda k: k['added_at'], reverse=True)[:int(count)]}\n        return output\n    try:\n        xml_head = recent.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_recently_added: %s.' % e)\n        return {'recently_added': []}\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                output = {'recently_added': []}\n                return output\n        recents_main = []\n        if a.getElementsByTagName('Directory'):\n            recents_main += a.getElementsByTagName('Directory')\n        if a.getElementsByTagName('Video'):\n            recents_main += a.getElementsByTagName('Video')\n        for m in recents_main:\n            directors = []\n            writers = []\n            actors = []\n            genres = []\n            labels = []\n            collections = []\n            guids = []\n            if m.getElementsByTagName('Director'):\n                for director in m.getElementsByTagName('Director'):\n                    directors.append(helpers.get_xml_attr(director, 'tag'))\n            if m.getElementsByTagName('Writer'):\n                for writer in m.getElementsByTagName('Writer'):\n                    writers.append(helpers.get_xml_attr(writer, 'tag'))\n            if m.getElementsByTagName('Role'):\n                for actor in m.getElementsByTagName('Role'):\n                    actors.append(helpers.get_xml_attr(actor, 'tag'))\n            if m.getElementsByTagName('Genre'):\n                for genre in m.getElementsByTagName('Genre'):\n                    genres.append(helpers.get_xml_attr(genre, 'tag'))\n            if m.getElementsByTagName('Label'):\n                for label in m.getElementsByTagName('Label'):\n                    labels.append(helpers.get_xml_attr(label, 'tag'))\n            if m.getElementsByTagName('Collection'):\n                for collection in m.getElementsByTagName('Collection'):\n                    collections.append(helpers.get_xml_attr(collection, 'tag'))\n            if m.getElementsByTagName('Guid'):\n                for guid in m.getElementsByTagName('Guid'):\n                    guids.append(helpers.get_xml_attr(guid, 'id'))\n            recent_item = {'media_type': helpers.get_xml_attr(m, 'type'), 'section_id': helpers.get_xml_attr(m, 'librarySectionID'), 'library_name': helpers.get_xml_attr(m, 'librarySectionTitle'), 'rating_key': helpers.get_xml_attr(m, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(m, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(m, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(m, 'title'), 'parent_title': helpers.get_xml_attr(m, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(m, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(m, 'originalTitle'), 'sort_title': helpers.get_xml_attr(m, 'titleSort'), 'media_index': helpers.get_xml_attr(m, 'index'), 'parent_media_index': helpers.get_xml_attr(m, 'parentIndex'), 'studio': helpers.get_xml_attr(m, 'studio'), 'content_rating': helpers.get_xml_attr(m, 'contentRating'), 'summary': helpers.get_xml_attr(m, 'summary'), 'tagline': helpers.get_xml_attr(m, 'tagline'), 'rating': helpers.get_xml_attr(m, 'rating'), 'rating_image': helpers.get_xml_attr(m, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(m, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(m, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(m, 'userRating'), 'duration': helpers.get_xml_attr(m, 'duration'), 'year': helpers.get_xml_attr(m, 'year'), 'thumb': helpers.get_xml_attr(m, 'thumb'), 'parent_thumb': helpers.get_xml_attr(m, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(m, 'grandparentThumb'), 'art': helpers.get_xml_attr(m, 'art'), 'banner': helpers.get_xml_attr(m, 'banner'), 'originally_available_at': helpers.get_xml_attr(m, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(m, 'addedAt'), 'updated_at': helpers.get_xml_attr(m, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(m, 'lastViewedAt'), 'guid': helpers.get_xml_attr(m, 'guid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'guids': guids, 'full_title': helpers.get_xml_attr(m, 'title'), 'child_count': helpers.get_xml_attr(m, 'childCount')}\n            recents_list.append(recent_item)\n    output = {'recently_added': sorted(recents_list, key=lambda k: k['added_at'], reverse=True)}\n    return output",
            "def get_recently_added_details(self, start='0', count='0', media_type='', section_id=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Return processed and validated list of recently added items.\\n\\n        Parameters required:    count { number of results to return }\\n\\n        Output: array\\n        '\n    media_types = ('movie', 'show', 'artist', 'other_video')\n    recents_list = []\n    if media_type in media_types:\n        other_video = False\n        if media_type == 'movie':\n            media_type = '1'\n        elif media_type == 'show':\n            media_type = '2'\n        elif media_type == 'artist':\n            media_type = '8'\n        elif media_type == 'other_video':\n            media_type = '1'\n            other_video = True\n        recent = self.get_hub_recently_added(start, count, media_type, other_video, output_format='xml')\n    elif section_id:\n        recent = self.get_library_recently_added(section_id, start, count, output_format='xml')\n    else:\n        for media_type in media_types:\n            recents = self.get_recently_added_details(start, count, media_type)\n            recents_list += recents['recently_added']\n        output = {'recently_added': sorted(recents_list, key=lambda k: k['added_at'], reverse=True)[:int(count)]}\n        return output\n    try:\n        xml_head = recent.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_recently_added: %s.' % e)\n        return {'recently_added': []}\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                output = {'recently_added': []}\n                return output\n        recents_main = []\n        if a.getElementsByTagName('Directory'):\n            recents_main += a.getElementsByTagName('Directory')\n        if a.getElementsByTagName('Video'):\n            recents_main += a.getElementsByTagName('Video')\n        for m in recents_main:\n            directors = []\n            writers = []\n            actors = []\n            genres = []\n            labels = []\n            collections = []\n            guids = []\n            if m.getElementsByTagName('Director'):\n                for director in m.getElementsByTagName('Director'):\n                    directors.append(helpers.get_xml_attr(director, 'tag'))\n            if m.getElementsByTagName('Writer'):\n                for writer in m.getElementsByTagName('Writer'):\n                    writers.append(helpers.get_xml_attr(writer, 'tag'))\n            if m.getElementsByTagName('Role'):\n                for actor in m.getElementsByTagName('Role'):\n                    actors.append(helpers.get_xml_attr(actor, 'tag'))\n            if m.getElementsByTagName('Genre'):\n                for genre in m.getElementsByTagName('Genre'):\n                    genres.append(helpers.get_xml_attr(genre, 'tag'))\n            if m.getElementsByTagName('Label'):\n                for label in m.getElementsByTagName('Label'):\n                    labels.append(helpers.get_xml_attr(label, 'tag'))\n            if m.getElementsByTagName('Collection'):\n                for collection in m.getElementsByTagName('Collection'):\n                    collections.append(helpers.get_xml_attr(collection, 'tag'))\n            if m.getElementsByTagName('Guid'):\n                for guid in m.getElementsByTagName('Guid'):\n                    guids.append(helpers.get_xml_attr(guid, 'id'))\n            recent_item = {'media_type': helpers.get_xml_attr(m, 'type'), 'section_id': helpers.get_xml_attr(m, 'librarySectionID'), 'library_name': helpers.get_xml_attr(m, 'librarySectionTitle'), 'rating_key': helpers.get_xml_attr(m, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(m, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(m, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(m, 'title'), 'parent_title': helpers.get_xml_attr(m, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(m, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(m, 'originalTitle'), 'sort_title': helpers.get_xml_attr(m, 'titleSort'), 'media_index': helpers.get_xml_attr(m, 'index'), 'parent_media_index': helpers.get_xml_attr(m, 'parentIndex'), 'studio': helpers.get_xml_attr(m, 'studio'), 'content_rating': helpers.get_xml_attr(m, 'contentRating'), 'summary': helpers.get_xml_attr(m, 'summary'), 'tagline': helpers.get_xml_attr(m, 'tagline'), 'rating': helpers.get_xml_attr(m, 'rating'), 'rating_image': helpers.get_xml_attr(m, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(m, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(m, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(m, 'userRating'), 'duration': helpers.get_xml_attr(m, 'duration'), 'year': helpers.get_xml_attr(m, 'year'), 'thumb': helpers.get_xml_attr(m, 'thumb'), 'parent_thumb': helpers.get_xml_attr(m, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(m, 'grandparentThumb'), 'art': helpers.get_xml_attr(m, 'art'), 'banner': helpers.get_xml_attr(m, 'banner'), 'originally_available_at': helpers.get_xml_attr(m, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(m, 'addedAt'), 'updated_at': helpers.get_xml_attr(m, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(m, 'lastViewedAt'), 'guid': helpers.get_xml_attr(m, 'guid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'guids': guids, 'full_title': helpers.get_xml_attr(m, 'title'), 'child_count': helpers.get_xml_attr(m, 'childCount')}\n            recents_list.append(recent_item)\n    output = {'recently_added': sorted(recents_list, key=lambda k: k['added_at'], reverse=True)}\n    return output"
        ]
    },
    {
        "func_name": "get_metadata_details",
        "original": "def get_metadata_details(self, rating_key='', sync_id='', plex_guid='', section_id='', skip_cache=False, cache_key=None, return_cache=False, media_info=True):\n    \"\"\"\n        Return processed and validated metadata list for requested item.\n\n        Parameters required:    rating_key { Plex ratingKey }\n\n        Output: array\n        \"\"\"\n    metadata = {}\n    if not skip_cache and cache_key:\n        in_file_folder = os.path.join(plexpy.CONFIG.CACHE_DIR, 'session_metadata')\n        in_file_path = os.path.join(in_file_folder, 'metadata-sessionKey-%s.json' % cache_key)\n        if not os.path.exists(in_file_folder):\n            os.mkdir(in_file_folder)\n        try:\n            with open(in_file_path, 'r') as inFile:\n                metadata = json.load(inFile)\n        except (IOError, ValueError) as e:\n            pass\n        if metadata:\n            _cache_time = metadata.pop('_cache_time', 0)\n            if return_cache or helpers.timestamp() - _cache_time <= plexpy.CONFIG.METADATA_CACHE_SECONDS:\n                return metadata\n    if rating_key:\n        metadata_xml = self.get_metadata(str(rating_key), output_format='xml')\n    elif sync_id:\n        metadata_xml = self.get_sync_item(str(sync_id), output_format='xml')\n    elif plex_guid.startswith(('plex://movie', 'plex://episode')):\n        rating_key = plex_guid.rsplit('/', 1)[-1]\n        plextv_metadata = PmsConnect(url='https://metadata.provider.plex.tv', token=plexpy.CONFIG.PMS_TOKEN)\n        metadata_xml = plextv_metadata.get_metadata(rating_key, output_format='xml')\n    else:\n        return metadata\n    try:\n        xml_head = metadata_xml.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_metadata_details: %s.' % e)\n        return {}\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                return metadata\n        if a.getElementsByTagName('Directory'):\n            metadata_main_list = a.getElementsByTagName('Directory')\n        elif a.getElementsByTagName('Video'):\n            metadata_main_list = a.getElementsByTagName('Video')\n        elif a.getElementsByTagName('Track'):\n            metadata_main_list = a.getElementsByTagName('Track')\n        elif a.getElementsByTagName('Photo'):\n            metadata_main_list = a.getElementsByTagName('Photo')\n        elif a.getElementsByTagName('Playlist'):\n            metadata_main_list = a.getElementsByTagName('Playlist')\n        else:\n            logger.debug('Tautulli Pmsconnect :: Metadata failed')\n            return {}\n        if sync_id and len(metadata_main_list) > 1:\n            for metadata_main in metadata_main_list:\n                if helpers.get_xml_attr(metadata_main, 'ratingKey') == rating_key:\n                    break\n        else:\n            metadata_main = metadata_main_list[0]\n        metadata_type = helpers.get_xml_attr(metadata_main, 'type')\n        if metadata_main.nodeName == 'Directory' and metadata_type == 'photo':\n            metadata_type = 'photo_album'\n        section_id = helpers.get_xml_attr(a, 'librarySectionID') or section_id\n        library_name = helpers.get_xml_attr(a, 'librarySectionTitle')\n        if not library_name and section_id:\n            library_data = libraries.Libraries().get_details(section_id)\n            library_name = library_data['section_name']\n    directors = []\n    writers = []\n    actors = []\n    genres = []\n    labels = []\n    collections = []\n    guids = []\n    markers = []\n    if metadata_main.getElementsByTagName('Director'):\n        for director in metadata_main.getElementsByTagName('Director'):\n            directors.append(helpers.get_xml_attr(director, 'tag'))\n    if metadata_main.getElementsByTagName('Writer'):\n        for writer in metadata_main.getElementsByTagName('Writer'):\n            writers.append(helpers.get_xml_attr(writer, 'tag'))\n    if metadata_main.getElementsByTagName('Role'):\n        for actor in metadata_main.getElementsByTagName('Role'):\n            actors.append(helpers.get_xml_attr(actor, 'tag'))\n    if metadata_main.getElementsByTagName('Genre'):\n        for genre in metadata_main.getElementsByTagName('Genre'):\n            genres.append(helpers.get_xml_attr(genre, 'tag'))\n    if metadata_main.getElementsByTagName('Label'):\n        for label in metadata_main.getElementsByTagName('Label'):\n            labels.append(helpers.get_xml_attr(label, 'tag'))\n    if metadata_main.getElementsByTagName('Collection'):\n        for collection in metadata_main.getElementsByTagName('Collection'):\n            collections.append(helpers.get_xml_attr(collection, 'tag'))\n    if metadata_main.getElementsByTagName('Guid'):\n        for guid in metadata_main.getElementsByTagName('Guid'):\n            guids.append(helpers.get_xml_attr(guid, 'id'))\n    if metadata_main.getElementsByTagName('Marker'):\n        first = None\n        for marker in metadata_main.getElementsByTagName('Marker'):\n            marker_type = helpers.get_xml_attr(marker, 'type')\n            if marker_type == 'credits':\n                first = bool(first is None)\n            final = helpers.bool_true(helpers.get_xml_attr(marker, 'final'))\n            markers.append({'id': helpers.cast_to_int(helpers.get_xml_attr(marker, 'id')), 'type': marker_type, 'start_time_offset': helpers.cast_to_int(helpers.get_xml_attr(marker, 'startTimeOffset')), 'end_time_offset': helpers.cast_to_int(helpers.get_xml_attr(marker, 'endTimeOffset')), 'first': first if marker_type == 'credits' else None, 'final': final if marker_type == 'credits' else None})\n    if metadata_type == 'movie':\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': helpers.get_xml_attr(metadata_main, 'banner'), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'guids': guids, 'markers': markers, 'parent_guids': [], 'grandparent_guids': [], 'full_title': helpers.get_xml_attr(metadata_main, 'title'), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'show':\n        duration = helpers.get_xml_attr(metadata_main, 'duration')\n        if duration.isdigit() and int(duration) < 1000:\n            duration = str(int(duration) * 60 * 1000)\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': duration, 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': helpers.get_xml_attr(metadata_main, 'banner'), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'guids': guids, 'markers': markers, 'parent_guids': [], 'grandparent_guids': [], 'full_title': helpers.get_xml_attr(metadata_main, 'title'), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'season':\n        parent_rating_key = helpers.get_xml_attr(metadata_main, 'parentRatingKey')\n        parent_guid = helpers.get_xml_attr(metadata_main, 'parentGuid')\n        show_details = {}\n        if plex_guid and parent_guid:\n            show_details = self.get_metadata_details(plex_guid=parent_guid)\n        elif not plex_guid and parent_rating_key:\n            show_details = self.get_metadata_details(parent_rating_key)\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': show_details.get('studio', ''), 'content_rating': show_details.get('content_rating', ''), 'summary': helpers.get_xml_attr(metadata_main, 'summary') or show_details.get('summary', ''), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': show_details.get('duration', ''), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': show_details.get('year', ''), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb') or show_details.get('thumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': show_details.get('banner', ''), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': show_details.get('directors', []), 'writers': show_details.get('writers', []), 'actors': show_details.get('actors', []), 'genres': show_details.get('genres', []), 'labels': show_details.get('labels', []), 'collections': show_details.get('collections', []), 'guids': guids, 'markers': markers, 'parent_guids': show_details.get('guids', []), 'grandparent_guids': [], 'full_title': '{} - {}'.format(helpers.get_xml_attr(metadata_main, 'parentTitle'), helpers.get_xml_attr(metadata_main, 'title')), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'episode':\n        grandparent_rating_key = helpers.get_xml_attr(metadata_main, 'grandparentRatingKey')\n        grandparent_guid = helpers.get_xml_attr(metadata_main, 'grandparentGuid')\n        show_details = {}\n        if plex_guid and grandparent_guid:\n            show_details = self.get_metadata_details(plex_guid=grandparent_guid)\n        elif not plex_guid and grandparent_rating_key:\n            show_details = self.get_metadata_details(grandparent_rating_key)\n        parent_rating_key = helpers.get_xml_attr(metadata_main, 'parentRatingKey')\n        parent_media_index = helpers.get_xml_attr(metadata_main, 'parentIndex')\n        parent_thumb = helpers.get_xml_attr(metadata_main, 'parentThumb')\n        season_details = self.get_metadata_details(parent_rating_key) if parent_rating_key else {}\n        if not plex_guid and (not parent_rating_key):\n            if parent_thumb.startswith('/library/metadata/'):\n                parent_rating_key = parent_thumb.split('/')[3]\n            if not parent_rating_key and grandparent_rating_key:\n                children_list = self.get_item_children(grandparent_rating_key)\n                parent_rating_key = next((c['rating_key'] for c in children_list['children_list'] if c['media_index'] == parent_media_index), '')\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': parent_rating_key, 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': parent_media_index, 'studio': show_details.get('studio', ''), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': season_details.get('year', ''), 'grandparent_year': show_details.get('year', ''), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': parent_thumb or show_details.get('thumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': show_details.get('banner', ''), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': show_details.get('actors', []), 'genres': show_details.get('genres', []), 'labels': show_details.get('labels', []), 'collections': show_details.get('collections', []), 'guids': guids, 'markers': markers, 'parent_guids': season_details.get('guids', []), 'grandparent_guids': show_details.get('guids', []), 'full_title': '{} - {}'.format(helpers.get_xml_attr(metadata_main, 'grandparentTitle'), helpers.get_xml_attr(metadata_main, 'title')), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'artist':\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': helpers.get_xml_attr(metadata_main, 'banner'), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'guids': guids, 'markers': markers, 'parent_guids': [], 'grandparent_guids': [], 'full_title': helpers.get_xml_attr(metadata_main, 'title'), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'album':\n        parent_rating_key = helpers.get_xml_attr(metadata_main, 'parentRatingKey')\n        artist_details = self.get_metadata_details(parent_rating_key) if parent_rating_key else {}\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary') or artist_details.get('summary', ''), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': artist_details.get('banner', ''), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'guids': guids, 'markers': markers, 'parent_guids': artist_details.get('guids', []), 'grandparent_guids': [], 'full_title': '{} - {}'.format(helpers.get_xml_attr(metadata_main, 'parentTitle'), helpers.get_xml_attr(metadata_main, 'title')), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'track':\n        parent_rating_key = helpers.get_xml_attr(metadata_main, 'parentRatingKey')\n        album_details = self.get_metadata_details(parent_rating_key) if parent_rating_key else {}\n        track_artist = helpers.get_xml_attr(metadata_main, 'originalTitle') or helpers.get_xml_attr(metadata_main, 'grandparentTitle')\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': album_details.get('year', ''), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': album_details.get('banner', ''), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': album_details.get('genres', []), 'labels': album_details.get('labels', []), 'collections': album_details.get('collections', []), 'guids': guids, 'markers': markers, 'parent_guids': album_details.get('guids', []), 'grandparent_guids': album_details.get('parent_guids', []), 'full_title': '{} - {}'.format(helpers.get_xml_attr(metadata_main, 'title'), track_artist), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'photo_album':\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': helpers.get_xml_attr(metadata_main, 'banner'), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'guids': guids, 'markers': markers, 'parent_guids': [], 'grandparent_guids': [], 'full_title': helpers.get_xml_attr(metadata_main, 'title'), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'photo':\n        parent_rating_key = helpers.get_xml_attr(metadata_main, 'parentRatingKey')\n        photo_album_details = self.get_metadata_details(parent_rating_key) if parent_rating_key else {}\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': photo_album_details.get('banner', ''), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': photo_album_details.get('genres', []), 'labels': photo_album_details.get('labels', []), 'collections': photo_album_details.get('collections', []), 'guids': [], 'markers': markers, 'parent_guids': photo_album_details.get('guids', []), 'grandparent_guids': [], 'full_title': '{} - {}'.format(helpers.get_xml_attr(metadata_main, 'parentTitle') or library_name, helpers.get_xml_attr(metadata_main, 'title')), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'collection':\n        metadata = {'media_type': metadata_type, 'sub_media_type': helpers.get_xml_attr(metadata_main, 'subtype'), 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'min_year': helpers.get_xml_attr(metadata_main, 'minYear'), 'max_year': helpers.get_xml_attr(metadata_main, 'maxYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb').split('?')[0], 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': helpers.get_xml_attr(metadata_main, 'banner'), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'child_count': helpers.get_xml_attr(metadata_main, 'childCount'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'guids': guids, 'markers': markers, 'parent_guids': [], 'grandparent_guids': [], 'full_title': helpers.get_xml_attr(metadata_main, 'title'), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'childCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1'), 'smart': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'smart'))}\n    elif metadata_type == 'playlist':\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'composite': helpers.get_xml_attr(metadata_main, 'composite'), 'thumb': helpers.get_xml_attr(metadata_main, 'composite'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'smart': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'smart')), 'playlist_type': helpers.get_xml_attr(metadata_main, 'playlistType'), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'clip':\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': helpers.get_xml_attr(metadata_main, 'banner'), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'guids': guids, 'markers': markers, 'parent_guids': [], 'grandparent_guids': [], 'full_title': helpers.get_xml_attr(metadata_main, 'title'), 'extra_type': helpers.get_xml_attr(metadata_main, 'extraType'), 'sub_type': helpers.get_xml_attr(metadata_main, 'subtype'), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    else:\n        return metadata\n    if not plex_guid and metadata['live']:\n        metadata['section_id'] = common.LIVE_TV_SECTION_ID\n        metadata['library_name'] = common.LIVE_TV_SECTION_NAME\n        plextv_metadata = self.get_metadata_details(plex_guid=metadata['guid'])\n        if plextv_metadata:\n            keys_to_update = ['summary', 'rating', 'thumb', 'grandparent_thumb', 'duration', 'guid', 'grandparent_guid', 'genres']\n            for key in keys_to_update:\n                metadata[key] = plextv_metadata[key]\n            metadata['originally_available_at'] = helpers.iso_to_YMD(plextv_metadata['originally_available_at'])\n    if metadata and media_info:\n        medias = []\n        media_items = metadata_main.getElementsByTagName('Media')\n        for media in media_items:\n            video_full_resolution_scan_type = ''\n            parts = []\n            part_items = media.getElementsByTagName('Part')\n            for part in part_items:\n                streams = []\n                stream_items = part.getElementsByTagName('Stream')\n                for stream in stream_items:\n                    if helpers.get_xml_attr(stream, 'streamType') == '1':\n                        video_scan_type = helpers.get_xml_attr(stream, 'scanType')\n                        video_full_resolution_scan_type = video_full_resolution_scan_type or video_scan_type\n                        streams.append({'id': helpers.get_xml_attr(stream, 'id'), 'type': helpers.get_xml_attr(stream, 'streamType'), 'video_codec': helpers.get_xml_attr(stream, 'codec'), 'video_codec_level': helpers.get_xml_attr(stream, 'level'), 'video_bitrate': helpers.get_xml_attr(stream, 'bitrate'), 'video_bit_depth': helpers.get_xml_attr(stream, 'bitDepth'), 'video_chroma_subsampling': helpers.get_xml_attr(stream, 'chromaSubsampling'), 'video_color_primaries': helpers.get_xml_attr(stream, 'colorPrimaries'), 'video_color_range': helpers.get_xml_attr(stream, 'colorRange'), 'video_color_space': helpers.get_xml_attr(stream, 'colorSpace'), 'video_color_trc': helpers.get_xml_attr(stream, 'colorTrc'), 'video_dynamic_range': self.get_dynamic_range(stream), 'video_frame_rate': helpers.get_xml_attr(stream, 'frameRate'), 'video_ref_frames': helpers.get_xml_attr(stream, 'refFrames'), 'video_height': helpers.get_xml_attr(stream, 'height'), 'video_width': helpers.get_xml_attr(stream, 'width'), 'video_language': helpers.get_xml_attr(stream, 'language'), 'video_language_code': helpers.get_xml_attr(stream, 'languageCode'), 'video_profile': helpers.get_xml_attr(stream, 'profile'), 'video_scan_type': helpers.get_xml_attr(stream, 'scanType'), 'selected': int(helpers.get_xml_attr(stream, 'selected') == '1')})\n                    elif helpers.get_xml_attr(stream, 'streamType') == '2':\n                        streams.append({'id': helpers.get_xml_attr(stream, 'id'), 'type': helpers.get_xml_attr(stream, 'streamType'), 'audio_codec': helpers.get_xml_attr(stream, 'codec'), 'audio_bitrate': helpers.get_xml_attr(stream, 'bitrate'), 'audio_bitrate_mode': helpers.get_xml_attr(stream, 'bitrateMode'), 'audio_channels': helpers.get_xml_attr(stream, 'channels'), 'audio_channel_layout': helpers.get_xml_attr(stream, 'audioChannelLayout'), 'audio_sample_rate': helpers.get_xml_attr(stream, 'samplingRate'), 'audio_language': helpers.get_xml_attr(stream, 'language'), 'audio_language_code': helpers.get_xml_attr(stream, 'languageCode'), 'audio_profile': helpers.get_xml_attr(stream, 'profile'), 'selected': int(helpers.get_xml_attr(stream, 'selected') == '1')})\n                    elif helpers.get_xml_attr(stream, 'streamType') == '3':\n                        streams.append({'id': helpers.get_xml_attr(stream, 'id'), 'type': helpers.get_xml_attr(stream, 'streamType'), 'subtitle_codec': helpers.get_xml_attr(stream, 'codec'), 'subtitle_container': helpers.get_xml_attr(stream, 'container'), 'subtitle_format': helpers.get_xml_attr(stream, 'format'), 'subtitle_forced': int(helpers.get_xml_attr(stream, 'forced') == '1'), 'subtitle_location': 'external' if helpers.get_xml_attr(stream, 'key') else 'embedded', 'subtitle_language': helpers.get_xml_attr(stream, 'language'), 'subtitle_language_code': helpers.get_xml_attr(stream, 'languageCode'), 'selected': int(helpers.get_xml_attr(stream, 'selected') == '1')})\n                parts.append({'id': helpers.get_xml_attr(part, 'id'), 'file': helpers.get_xml_attr(part, 'file'), 'file_size': helpers.get_xml_attr(part, 'size'), 'indexes': int(helpers.get_xml_attr(part, 'indexes') == 'sd'), 'streams': streams, 'selected': int(helpers.get_xml_attr(part, 'selected') == '1')})\n            video_resolution = helpers.get_xml_attr(media, 'videoResolution').lower().rstrip('ip')\n            video_full_resolution = common.VIDEO_RESOLUTION_OVERRIDES.get(video_resolution, video_resolution + (video_full_resolution_scan_type[:1] or 'p'))\n            audio_channels = helpers.get_xml_attr(media, 'audioChannels')\n            media_info = {'id': helpers.get_xml_attr(media, 'id'), 'container': helpers.get_xml_attr(media, 'container'), 'bitrate': helpers.get_xml_attr(media, 'bitrate'), 'height': helpers.get_xml_attr(media, 'height'), 'width': helpers.get_xml_attr(media, 'width'), 'aspect_ratio': helpers.get_xml_attr(media, 'aspectRatio'), 'video_codec': helpers.get_xml_attr(media, 'videoCodec'), 'video_resolution': video_resolution, 'video_full_resolution': video_full_resolution, 'video_framerate': helpers.get_xml_attr(media, 'videoFrameRate'), 'video_profile': helpers.get_xml_attr(media, 'videoProfile'), 'audio_codec': helpers.get_xml_attr(media, 'audioCodec'), 'audio_channels': audio_channels, 'audio_channel_layout': common.AUDIO_CHANNELS.get(audio_channels, audio_channels), 'audio_profile': helpers.get_xml_attr(media, 'audioProfile'), 'optimized_version': int(helpers.get_xml_attr(media, 'proxyType') == '42'), 'channel_call_sign': helpers.get_xml_attr(media, 'channelCallSign'), 'channel_identifier': helpers.get_xml_attr(media, 'channelIdentifier'), 'channel_thumb': helpers.get_xml_attr(media, 'channelThumb'), 'parts': parts}\n            medias.append(media_info)\n        metadata['media_info'] = medias\n    if metadata:\n        if cache_key:\n            metadata['_cache_time'] = helpers.timestamp()\n            out_file_folder = os.path.join(plexpy.CONFIG.CACHE_DIR, 'session_metadata')\n            out_file_path = os.path.join(out_file_folder, 'metadata-sessionKey-%s.json' % cache_key)\n            if not os.path.exists(out_file_folder):\n                os.mkdir(out_file_folder)\n            try:\n                with open(out_file_path, 'w') as outFile:\n                    json.dump(metadata, outFile)\n            except (IOError, ValueError) as e:\n                logger.error('Tautulli Pmsconnect :: Unable to create cache file for metadata (sessionKey %s): %s' % (cache_key, e))\n        return metadata\n    else:\n        return metadata",
        "mutated": [
            "def get_metadata_details(self, rating_key='', sync_id='', plex_guid='', section_id='', skip_cache=False, cache_key=None, return_cache=False, media_info=True):\n    if False:\n        i = 10\n    '\\n        Return processed and validated metadata list for requested item.\\n\\n        Parameters required:    rating_key { Plex ratingKey }\\n\\n        Output: array\\n        '\n    metadata = {}\n    if not skip_cache and cache_key:\n        in_file_folder = os.path.join(plexpy.CONFIG.CACHE_DIR, 'session_metadata')\n        in_file_path = os.path.join(in_file_folder, 'metadata-sessionKey-%s.json' % cache_key)\n        if not os.path.exists(in_file_folder):\n            os.mkdir(in_file_folder)\n        try:\n            with open(in_file_path, 'r') as inFile:\n                metadata = json.load(inFile)\n        except (IOError, ValueError) as e:\n            pass\n        if metadata:\n            _cache_time = metadata.pop('_cache_time', 0)\n            if return_cache or helpers.timestamp() - _cache_time <= plexpy.CONFIG.METADATA_CACHE_SECONDS:\n                return metadata\n    if rating_key:\n        metadata_xml = self.get_metadata(str(rating_key), output_format='xml')\n    elif sync_id:\n        metadata_xml = self.get_sync_item(str(sync_id), output_format='xml')\n    elif plex_guid.startswith(('plex://movie', 'plex://episode')):\n        rating_key = plex_guid.rsplit('/', 1)[-1]\n        plextv_metadata = PmsConnect(url='https://metadata.provider.plex.tv', token=plexpy.CONFIG.PMS_TOKEN)\n        metadata_xml = plextv_metadata.get_metadata(rating_key, output_format='xml')\n    else:\n        return metadata\n    try:\n        xml_head = metadata_xml.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_metadata_details: %s.' % e)\n        return {}\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                return metadata\n        if a.getElementsByTagName('Directory'):\n            metadata_main_list = a.getElementsByTagName('Directory')\n        elif a.getElementsByTagName('Video'):\n            metadata_main_list = a.getElementsByTagName('Video')\n        elif a.getElementsByTagName('Track'):\n            metadata_main_list = a.getElementsByTagName('Track')\n        elif a.getElementsByTagName('Photo'):\n            metadata_main_list = a.getElementsByTagName('Photo')\n        elif a.getElementsByTagName('Playlist'):\n            metadata_main_list = a.getElementsByTagName('Playlist')\n        else:\n            logger.debug('Tautulli Pmsconnect :: Metadata failed')\n            return {}\n        if sync_id and len(metadata_main_list) > 1:\n            for metadata_main in metadata_main_list:\n                if helpers.get_xml_attr(metadata_main, 'ratingKey') == rating_key:\n                    break\n        else:\n            metadata_main = metadata_main_list[0]\n        metadata_type = helpers.get_xml_attr(metadata_main, 'type')\n        if metadata_main.nodeName == 'Directory' and metadata_type == 'photo':\n            metadata_type = 'photo_album'\n        section_id = helpers.get_xml_attr(a, 'librarySectionID') or section_id\n        library_name = helpers.get_xml_attr(a, 'librarySectionTitle')\n        if not library_name and section_id:\n            library_data = libraries.Libraries().get_details(section_id)\n            library_name = library_data['section_name']\n    directors = []\n    writers = []\n    actors = []\n    genres = []\n    labels = []\n    collections = []\n    guids = []\n    markers = []\n    if metadata_main.getElementsByTagName('Director'):\n        for director in metadata_main.getElementsByTagName('Director'):\n            directors.append(helpers.get_xml_attr(director, 'tag'))\n    if metadata_main.getElementsByTagName('Writer'):\n        for writer in metadata_main.getElementsByTagName('Writer'):\n            writers.append(helpers.get_xml_attr(writer, 'tag'))\n    if metadata_main.getElementsByTagName('Role'):\n        for actor in metadata_main.getElementsByTagName('Role'):\n            actors.append(helpers.get_xml_attr(actor, 'tag'))\n    if metadata_main.getElementsByTagName('Genre'):\n        for genre in metadata_main.getElementsByTagName('Genre'):\n            genres.append(helpers.get_xml_attr(genre, 'tag'))\n    if metadata_main.getElementsByTagName('Label'):\n        for label in metadata_main.getElementsByTagName('Label'):\n            labels.append(helpers.get_xml_attr(label, 'tag'))\n    if metadata_main.getElementsByTagName('Collection'):\n        for collection in metadata_main.getElementsByTagName('Collection'):\n            collections.append(helpers.get_xml_attr(collection, 'tag'))\n    if metadata_main.getElementsByTagName('Guid'):\n        for guid in metadata_main.getElementsByTagName('Guid'):\n            guids.append(helpers.get_xml_attr(guid, 'id'))\n    if metadata_main.getElementsByTagName('Marker'):\n        first = None\n        for marker in metadata_main.getElementsByTagName('Marker'):\n            marker_type = helpers.get_xml_attr(marker, 'type')\n            if marker_type == 'credits':\n                first = bool(first is None)\n            final = helpers.bool_true(helpers.get_xml_attr(marker, 'final'))\n            markers.append({'id': helpers.cast_to_int(helpers.get_xml_attr(marker, 'id')), 'type': marker_type, 'start_time_offset': helpers.cast_to_int(helpers.get_xml_attr(marker, 'startTimeOffset')), 'end_time_offset': helpers.cast_to_int(helpers.get_xml_attr(marker, 'endTimeOffset')), 'first': first if marker_type == 'credits' else None, 'final': final if marker_type == 'credits' else None})\n    if metadata_type == 'movie':\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': helpers.get_xml_attr(metadata_main, 'banner'), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'guids': guids, 'markers': markers, 'parent_guids': [], 'grandparent_guids': [], 'full_title': helpers.get_xml_attr(metadata_main, 'title'), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'show':\n        duration = helpers.get_xml_attr(metadata_main, 'duration')\n        if duration.isdigit() and int(duration) < 1000:\n            duration = str(int(duration) * 60 * 1000)\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': duration, 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': helpers.get_xml_attr(metadata_main, 'banner'), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'guids': guids, 'markers': markers, 'parent_guids': [], 'grandparent_guids': [], 'full_title': helpers.get_xml_attr(metadata_main, 'title'), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'season':\n        parent_rating_key = helpers.get_xml_attr(metadata_main, 'parentRatingKey')\n        parent_guid = helpers.get_xml_attr(metadata_main, 'parentGuid')\n        show_details = {}\n        if plex_guid and parent_guid:\n            show_details = self.get_metadata_details(plex_guid=parent_guid)\n        elif not plex_guid and parent_rating_key:\n            show_details = self.get_metadata_details(parent_rating_key)\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': show_details.get('studio', ''), 'content_rating': show_details.get('content_rating', ''), 'summary': helpers.get_xml_attr(metadata_main, 'summary') or show_details.get('summary', ''), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': show_details.get('duration', ''), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': show_details.get('year', ''), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb') or show_details.get('thumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': show_details.get('banner', ''), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': show_details.get('directors', []), 'writers': show_details.get('writers', []), 'actors': show_details.get('actors', []), 'genres': show_details.get('genres', []), 'labels': show_details.get('labels', []), 'collections': show_details.get('collections', []), 'guids': guids, 'markers': markers, 'parent_guids': show_details.get('guids', []), 'grandparent_guids': [], 'full_title': '{} - {}'.format(helpers.get_xml_attr(metadata_main, 'parentTitle'), helpers.get_xml_attr(metadata_main, 'title')), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'episode':\n        grandparent_rating_key = helpers.get_xml_attr(metadata_main, 'grandparentRatingKey')\n        grandparent_guid = helpers.get_xml_attr(metadata_main, 'grandparentGuid')\n        show_details = {}\n        if plex_guid and grandparent_guid:\n            show_details = self.get_metadata_details(plex_guid=grandparent_guid)\n        elif not plex_guid and grandparent_rating_key:\n            show_details = self.get_metadata_details(grandparent_rating_key)\n        parent_rating_key = helpers.get_xml_attr(metadata_main, 'parentRatingKey')\n        parent_media_index = helpers.get_xml_attr(metadata_main, 'parentIndex')\n        parent_thumb = helpers.get_xml_attr(metadata_main, 'parentThumb')\n        season_details = self.get_metadata_details(parent_rating_key) if parent_rating_key else {}\n        if not plex_guid and (not parent_rating_key):\n            if parent_thumb.startswith('/library/metadata/'):\n                parent_rating_key = parent_thumb.split('/')[3]\n            if not parent_rating_key and grandparent_rating_key:\n                children_list = self.get_item_children(grandparent_rating_key)\n                parent_rating_key = next((c['rating_key'] for c in children_list['children_list'] if c['media_index'] == parent_media_index), '')\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': parent_rating_key, 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': parent_media_index, 'studio': show_details.get('studio', ''), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': season_details.get('year', ''), 'grandparent_year': show_details.get('year', ''), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': parent_thumb or show_details.get('thumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': show_details.get('banner', ''), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': show_details.get('actors', []), 'genres': show_details.get('genres', []), 'labels': show_details.get('labels', []), 'collections': show_details.get('collections', []), 'guids': guids, 'markers': markers, 'parent_guids': season_details.get('guids', []), 'grandparent_guids': show_details.get('guids', []), 'full_title': '{} - {}'.format(helpers.get_xml_attr(metadata_main, 'grandparentTitle'), helpers.get_xml_attr(metadata_main, 'title')), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'artist':\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': helpers.get_xml_attr(metadata_main, 'banner'), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'guids': guids, 'markers': markers, 'parent_guids': [], 'grandparent_guids': [], 'full_title': helpers.get_xml_attr(metadata_main, 'title'), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'album':\n        parent_rating_key = helpers.get_xml_attr(metadata_main, 'parentRatingKey')\n        artist_details = self.get_metadata_details(parent_rating_key) if parent_rating_key else {}\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary') or artist_details.get('summary', ''), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': artist_details.get('banner', ''), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'guids': guids, 'markers': markers, 'parent_guids': artist_details.get('guids', []), 'grandparent_guids': [], 'full_title': '{} - {}'.format(helpers.get_xml_attr(metadata_main, 'parentTitle'), helpers.get_xml_attr(metadata_main, 'title')), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'track':\n        parent_rating_key = helpers.get_xml_attr(metadata_main, 'parentRatingKey')\n        album_details = self.get_metadata_details(parent_rating_key) if parent_rating_key else {}\n        track_artist = helpers.get_xml_attr(metadata_main, 'originalTitle') or helpers.get_xml_attr(metadata_main, 'grandparentTitle')\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': album_details.get('year', ''), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': album_details.get('banner', ''), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': album_details.get('genres', []), 'labels': album_details.get('labels', []), 'collections': album_details.get('collections', []), 'guids': guids, 'markers': markers, 'parent_guids': album_details.get('guids', []), 'grandparent_guids': album_details.get('parent_guids', []), 'full_title': '{} - {}'.format(helpers.get_xml_attr(metadata_main, 'title'), track_artist), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'photo_album':\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': helpers.get_xml_attr(metadata_main, 'banner'), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'guids': guids, 'markers': markers, 'parent_guids': [], 'grandparent_guids': [], 'full_title': helpers.get_xml_attr(metadata_main, 'title'), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'photo':\n        parent_rating_key = helpers.get_xml_attr(metadata_main, 'parentRatingKey')\n        photo_album_details = self.get_metadata_details(parent_rating_key) if parent_rating_key else {}\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': photo_album_details.get('banner', ''), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': photo_album_details.get('genres', []), 'labels': photo_album_details.get('labels', []), 'collections': photo_album_details.get('collections', []), 'guids': [], 'markers': markers, 'parent_guids': photo_album_details.get('guids', []), 'grandparent_guids': [], 'full_title': '{} - {}'.format(helpers.get_xml_attr(metadata_main, 'parentTitle') or library_name, helpers.get_xml_attr(metadata_main, 'title')), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'collection':\n        metadata = {'media_type': metadata_type, 'sub_media_type': helpers.get_xml_attr(metadata_main, 'subtype'), 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'min_year': helpers.get_xml_attr(metadata_main, 'minYear'), 'max_year': helpers.get_xml_attr(metadata_main, 'maxYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb').split('?')[0], 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': helpers.get_xml_attr(metadata_main, 'banner'), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'child_count': helpers.get_xml_attr(metadata_main, 'childCount'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'guids': guids, 'markers': markers, 'parent_guids': [], 'grandparent_guids': [], 'full_title': helpers.get_xml_attr(metadata_main, 'title'), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'childCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1'), 'smart': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'smart'))}\n    elif metadata_type == 'playlist':\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'composite': helpers.get_xml_attr(metadata_main, 'composite'), 'thumb': helpers.get_xml_attr(metadata_main, 'composite'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'smart': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'smart')), 'playlist_type': helpers.get_xml_attr(metadata_main, 'playlistType'), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'clip':\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': helpers.get_xml_attr(metadata_main, 'banner'), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'guids': guids, 'markers': markers, 'parent_guids': [], 'grandparent_guids': [], 'full_title': helpers.get_xml_attr(metadata_main, 'title'), 'extra_type': helpers.get_xml_attr(metadata_main, 'extraType'), 'sub_type': helpers.get_xml_attr(metadata_main, 'subtype'), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    else:\n        return metadata\n    if not plex_guid and metadata['live']:\n        metadata['section_id'] = common.LIVE_TV_SECTION_ID\n        metadata['library_name'] = common.LIVE_TV_SECTION_NAME\n        plextv_metadata = self.get_metadata_details(plex_guid=metadata['guid'])\n        if plextv_metadata:\n            keys_to_update = ['summary', 'rating', 'thumb', 'grandparent_thumb', 'duration', 'guid', 'grandparent_guid', 'genres']\n            for key in keys_to_update:\n                metadata[key] = plextv_metadata[key]\n            metadata['originally_available_at'] = helpers.iso_to_YMD(plextv_metadata['originally_available_at'])\n    if metadata and media_info:\n        medias = []\n        media_items = metadata_main.getElementsByTagName('Media')\n        for media in media_items:\n            video_full_resolution_scan_type = ''\n            parts = []\n            part_items = media.getElementsByTagName('Part')\n            for part in part_items:\n                streams = []\n                stream_items = part.getElementsByTagName('Stream')\n                for stream in stream_items:\n                    if helpers.get_xml_attr(stream, 'streamType') == '1':\n                        video_scan_type = helpers.get_xml_attr(stream, 'scanType')\n                        video_full_resolution_scan_type = video_full_resolution_scan_type or video_scan_type\n                        streams.append({'id': helpers.get_xml_attr(stream, 'id'), 'type': helpers.get_xml_attr(stream, 'streamType'), 'video_codec': helpers.get_xml_attr(stream, 'codec'), 'video_codec_level': helpers.get_xml_attr(stream, 'level'), 'video_bitrate': helpers.get_xml_attr(stream, 'bitrate'), 'video_bit_depth': helpers.get_xml_attr(stream, 'bitDepth'), 'video_chroma_subsampling': helpers.get_xml_attr(stream, 'chromaSubsampling'), 'video_color_primaries': helpers.get_xml_attr(stream, 'colorPrimaries'), 'video_color_range': helpers.get_xml_attr(stream, 'colorRange'), 'video_color_space': helpers.get_xml_attr(stream, 'colorSpace'), 'video_color_trc': helpers.get_xml_attr(stream, 'colorTrc'), 'video_dynamic_range': self.get_dynamic_range(stream), 'video_frame_rate': helpers.get_xml_attr(stream, 'frameRate'), 'video_ref_frames': helpers.get_xml_attr(stream, 'refFrames'), 'video_height': helpers.get_xml_attr(stream, 'height'), 'video_width': helpers.get_xml_attr(stream, 'width'), 'video_language': helpers.get_xml_attr(stream, 'language'), 'video_language_code': helpers.get_xml_attr(stream, 'languageCode'), 'video_profile': helpers.get_xml_attr(stream, 'profile'), 'video_scan_type': helpers.get_xml_attr(stream, 'scanType'), 'selected': int(helpers.get_xml_attr(stream, 'selected') == '1')})\n                    elif helpers.get_xml_attr(stream, 'streamType') == '2':\n                        streams.append({'id': helpers.get_xml_attr(stream, 'id'), 'type': helpers.get_xml_attr(stream, 'streamType'), 'audio_codec': helpers.get_xml_attr(stream, 'codec'), 'audio_bitrate': helpers.get_xml_attr(stream, 'bitrate'), 'audio_bitrate_mode': helpers.get_xml_attr(stream, 'bitrateMode'), 'audio_channels': helpers.get_xml_attr(stream, 'channels'), 'audio_channel_layout': helpers.get_xml_attr(stream, 'audioChannelLayout'), 'audio_sample_rate': helpers.get_xml_attr(stream, 'samplingRate'), 'audio_language': helpers.get_xml_attr(stream, 'language'), 'audio_language_code': helpers.get_xml_attr(stream, 'languageCode'), 'audio_profile': helpers.get_xml_attr(stream, 'profile'), 'selected': int(helpers.get_xml_attr(stream, 'selected') == '1')})\n                    elif helpers.get_xml_attr(stream, 'streamType') == '3':\n                        streams.append({'id': helpers.get_xml_attr(stream, 'id'), 'type': helpers.get_xml_attr(stream, 'streamType'), 'subtitle_codec': helpers.get_xml_attr(stream, 'codec'), 'subtitle_container': helpers.get_xml_attr(stream, 'container'), 'subtitle_format': helpers.get_xml_attr(stream, 'format'), 'subtitle_forced': int(helpers.get_xml_attr(stream, 'forced') == '1'), 'subtitle_location': 'external' if helpers.get_xml_attr(stream, 'key') else 'embedded', 'subtitle_language': helpers.get_xml_attr(stream, 'language'), 'subtitle_language_code': helpers.get_xml_attr(stream, 'languageCode'), 'selected': int(helpers.get_xml_attr(stream, 'selected') == '1')})\n                parts.append({'id': helpers.get_xml_attr(part, 'id'), 'file': helpers.get_xml_attr(part, 'file'), 'file_size': helpers.get_xml_attr(part, 'size'), 'indexes': int(helpers.get_xml_attr(part, 'indexes') == 'sd'), 'streams': streams, 'selected': int(helpers.get_xml_attr(part, 'selected') == '1')})\n            video_resolution = helpers.get_xml_attr(media, 'videoResolution').lower().rstrip('ip')\n            video_full_resolution = common.VIDEO_RESOLUTION_OVERRIDES.get(video_resolution, video_resolution + (video_full_resolution_scan_type[:1] or 'p'))\n            audio_channels = helpers.get_xml_attr(media, 'audioChannels')\n            media_info = {'id': helpers.get_xml_attr(media, 'id'), 'container': helpers.get_xml_attr(media, 'container'), 'bitrate': helpers.get_xml_attr(media, 'bitrate'), 'height': helpers.get_xml_attr(media, 'height'), 'width': helpers.get_xml_attr(media, 'width'), 'aspect_ratio': helpers.get_xml_attr(media, 'aspectRatio'), 'video_codec': helpers.get_xml_attr(media, 'videoCodec'), 'video_resolution': video_resolution, 'video_full_resolution': video_full_resolution, 'video_framerate': helpers.get_xml_attr(media, 'videoFrameRate'), 'video_profile': helpers.get_xml_attr(media, 'videoProfile'), 'audio_codec': helpers.get_xml_attr(media, 'audioCodec'), 'audio_channels': audio_channels, 'audio_channel_layout': common.AUDIO_CHANNELS.get(audio_channels, audio_channels), 'audio_profile': helpers.get_xml_attr(media, 'audioProfile'), 'optimized_version': int(helpers.get_xml_attr(media, 'proxyType') == '42'), 'channel_call_sign': helpers.get_xml_attr(media, 'channelCallSign'), 'channel_identifier': helpers.get_xml_attr(media, 'channelIdentifier'), 'channel_thumb': helpers.get_xml_attr(media, 'channelThumb'), 'parts': parts}\n            medias.append(media_info)\n        metadata['media_info'] = medias\n    if metadata:\n        if cache_key:\n            metadata['_cache_time'] = helpers.timestamp()\n            out_file_folder = os.path.join(plexpy.CONFIG.CACHE_DIR, 'session_metadata')\n            out_file_path = os.path.join(out_file_folder, 'metadata-sessionKey-%s.json' % cache_key)\n            if not os.path.exists(out_file_folder):\n                os.mkdir(out_file_folder)\n            try:\n                with open(out_file_path, 'w') as outFile:\n                    json.dump(metadata, outFile)\n            except (IOError, ValueError) as e:\n                logger.error('Tautulli Pmsconnect :: Unable to create cache file for metadata (sessionKey %s): %s' % (cache_key, e))\n        return metadata\n    else:\n        return metadata",
            "def get_metadata_details(self, rating_key='', sync_id='', plex_guid='', section_id='', skip_cache=False, cache_key=None, return_cache=False, media_info=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Return processed and validated metadata list for requested item.\\n\\n        Parameters required:    rating_key { Plex ratingKey }\\n\\n        Output: array\\n        '\n    metadata = {}\n    if not skip_cache and cache_key:\n        in_file_folder = os.path.join(plexpy.CONFIG.CACHE_DIR, 'session_metadata')\n        in_file_path = os.path.join(in_file_folder, 'metadata-sessionKey-%s.json' % cache_key)\n        if not os.path.exists(in_file_folder):\n            os.mkdir(in_file_folder)\n        try:\n            with open(in_file_path, 'r') as inFile:\n                metadata = json.load(inFile)\n        except (IOError, ValueError) as e:\n            pass\n        if metadata:\n            _cache_time = metadata.pop('_cache_time', 0)\n            if return_cache or helpers.timestamp() - _cache_time <= plexpy.CONFIG.METADATA_CACHE_SECONDS:\n                return metadata\n    if rating_key:\n        metadata_xml = self.get_metadata(str(rating_key), output_format='xml')\n    elif sync_id:\n        metadata_xml = self.get_sync_item(str(sync_id), output_format='xml')\n    elif plex_guid.startswith(('plex://movie', 'plex://episode')):\n        rating_key = plex_guid.rsplit('/', 1)[-1]\n        plextv_metadata = PmsConnect(url='https://metadata.provider.plex.tv', token=plexpy.CONFIG.PMS_TOKEN)\n        metadata_xml = plextv_metadata.get_metadata(rating_key, output_format='xml')\n    else:\n        return metadata\n    try:\n        xml_head = metadata_xml.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_metadata_details: %s.' % e)\n        return {}\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                return metadata\n        if a.getElementsByTagName('Directory'):\n            metadata_main_list = a.getElementsByTagName('Directory')\n        elif a.getElementsByTagName('Video'):\n            metadata_main_list = a.getElementsByTagName('Video')\n        elif a.getElementsByTagName('Track'):\n            metadata_main_list = a.getElementsByTagName('Track')\n        elif a.getElementsByTagName('Photo'):\n            metadata_main_list = a.getElementsByTagName('Photo')\n        elif a.getElementsByTagName('Playlist'):\n            metadata_main_list = a.getElementsByTagName('Playlist')\n        else:\n            logger.debug('Tautulli Pmsconnect :: Metadata failed')\n            return {}\n        if sync_id and len(metadata_main_list) > 1:\n            for metadata_main in metadata_main_list:\n                if helpers.get_xml_attr(metadata_main, 'ratingKey') == rating_key:\n                    break\n        else:\n            metadata_main = metadata_main_list[0]\n        metadata_type = helpers.get_xml_attr(metadata_main, 'type')\n        if metadata_main.nodeName == 'Directory' and metadata_type == 'photo':\n            metadata_type = 'photo_album'\n        section_id = helpers.get_xml_attr(a, 'librarySectionID') or section_id\n        library_name = helpers.get_xml_attr(a, 'librarySectionTitle')\n        if not library_name and section_id:\n            library_data = libraries.Libraries().get_details(section_id)\n            library_name = library_data['section_name']\n    directors = []\n    writers = []\n    actors = []\n    genres = []\n    labels = []\n    collections = []\n    guids = []\n    markers = []\n    if metadata_main.getElementsByTagName('Director'):\n        for director in metadata_main.getElementsByTagName('Director'):\n            directors.append(helpers.get_xml_attr(director, 'tag'))\n    if metadata_main.getElementsByTagName('Writer'):\n        for writer in metadata_main.getElementsByTagName('Writer'):\n            writers.append(helpers.get_xml_attr(writer, 'tag'))\n    if metadata_main.getElementsByTagName('Role'):\n        for actor in metadata_main.getElementsByTagName('Role'):\n            actors.append(helpers.get_xml_attr(actor, 'tag'))\n    if metadata_main.getElementsByTagName('Genre'):\n        for genre in metadata_main.getElementsByTagName('Genre'):\n            genres.append(helpers.get_xml_attr(genre, 'tag'))\n    if metadata_main.getElementsByTagName('Label'):\n        for label in metadata_main.getElementsByTagName('Label'):\n            labels.append(helpers.get_xml_attr(label, 'tag'))\n    if metadata_main.getElementsByTagName('Collection'):\n        for collection in metadata_main.getElementsByTagName('Collection'):\n            collections.append(helpers.get_xml_attr(collection, 'tag'))\n    if metadata_main.getElementsByTagName('Guid'):\n        for guid in metadata_main.getElementsByTagName('Guid'):\n            guids.append(helpers.get_xml_attr(guid, 'id'))\n    if metadata_main.getElementsByTagName('Marker'):\n        first = None\n        for marker in metadata_main.getElementsByTagName('Marker'):\n            marker_type = helpers.get_xml_attr(marker, 'type')\n            if marker_type == 'credits':\n                first = bool(first is None)\n            final = helpers.bool_true(helpers.get_xml_attr(marker, 'final'))\n            markers.append({'id': helpers.cast_to_int(helpers.get_xml_attr(marker, 'id')), 'type': marker_type, 'start_time_offset': helpers.cast_to_int(helpers.get_xml_attr(marker, 'startTimeOffset')), 'end_time_offset': helpers.cast_to_int(helpers.get_xml_attr(marker, 'endTimeOffset')), 'first': first if marker_type == 'credits' else None, 'final': final if marker_type == 'credits' else None})\n    if metadata_type == 'movie':\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': helpers.get_xml_attr(metadata_main, 'banner'), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'guids': guids, 'markers': markers, 'parent_guids': [], 'grandparent_guids': [], 'full_title': helpers.get_xml_attr(metadata_main, 'title'), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'show':\n        duration = helpers.get_xml_attr(metadata_main, 'duration')\n        if duration.isdigit() and int(duration) < 1000:\n            duration = str(int(duration) * 60 * 1000)\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': duration, 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': helpers.get_xml_attr(metadata_main, 'banner'), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'guids': guids, 'markers': markers, 'parent_guids': [], 'grandparent_guids': [], 'full_title': helpers.get_xml_attr(metadata_main, 'title'), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'season':\n        parent_rating_key = helpers.get_xml_attr(metadata_main, 'parentRatingKey')\n        parent_guid = helpers.get_xml_attr(metadata_main, 'parentGuid')\n        show_details = {}\n        if plex_guid and parent_guid:\n            show_details = self.get_metadata_details(plex_guid=parent_guid)\n        elif not plex_guid and parent_rating_key:\n            show_details = self.get_metadata_details(parent_rating_key)\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': show_details.get('studio', ''), 'content_rating': show_details.get('content_rating', ''), 'summary': helpers.get_xml_attr(metadata_main, 'summary') or show_details.get('summary', ''), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': show_details.get('duration', ''), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': show_details.get('year', ''), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb') or show_details.get('thumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': show_details.get('banner', ''), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': show_details.get('directors', []), 'writers': show_details.get('writers', []), 'actors': show_details.get('actors', []), 'genres': show_details.get('genres', []), 'labels': show_details.get('labels', []), 'collections': show_details.get('collections', []), 'guids': guids, 'markers': markers, 'parent_guids': show_details.get('guids', []), 'grandparent_guids': [], 'full_title': '{} - {}'.format(helpers.get_xml_attr(metadata_main, 'parentTitle'), helpers.get_xml_attr(metadata_main, 'title')), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'episode':\n        grandparent_rating_key = helpers.get_xml_attr(metadata_main, 'grandparentRatingKey')\n        grandparent_guid = helpers.get_xml_attr(metadata_main, 'grandparentGuid')\n        show_details = {}\n        if plex_guid and grandparent_guid:\n            show_details = self.get_metadata_details(plex_guid=grandparent_guid)\n        elif not plex_guid and grandparent_rating_key:\n            show_details = self.get_metadata_details(grandparent_rating_key)\n        parent_rating_key = helpers.get_xml_attr(metadata_main, 'parentRatingKey')\n        parent_media_index = helpers.get_xml_attr(metadata_main, 'parentIndex')\n        parent_thumb = helpers.get_xml_attr(metadata_main, 'parentThumb')\n        season_details = self.get_metadata_details(parent_rating_key) if parent_rating_key else {}\n        if not plex_guid and (not parent_rating_key):\n            if parent_thumb.startswith('/library/metadata/'):\n                parent_rating_key = parent_thumb.split('/')[3]\n            if not parent_rating_key and grandparent_rating_key:\n                children_list = self.get_item_children(grandparent_rating_key)\n                parent_rating_key = next((c['rating_key'] for c in children_list['children_list'] if c['media_index'] == parent_media_index), '')\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': parent_rating_key, 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': parent_media_index, 'studio': show_details.get('studio', ''), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': season_details.get('year', ''), 'grandparent_year': show_details.get('year', ''), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': parent_thumb or show_details.get('thumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': show_details.get('banner', ''), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': show_details.get('actors', []), 'genres': show_details.get('genres', []), 'labels': show_details.get('labels', []), 'collections': show_details.get('collections', []), 'guids': guids, 'markers': markers, 'parent_guids': season_details.get('guids', []), 'grandparent_guids': show_details.get('guids', []), 'full_title': '{} - {}'.format(helpers.get_xml_attr(metadata_main, 'grandparentTitle'), helpers.get_xml_attr(metadata_main, 'title')), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'artist':\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': helpers.get_xml_attr(metadata_main, 'banner'), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'guids': guids, 'markers': markers, 'parent_guids': [], 'grandparent_guids': [], 'full_title': helpers.get_xml_attr(metadata_main, 'title'), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'album':\n        parent_rating_key = helpers.get_xml_attr(metadata_main, 'parentRatingKey')\n        artist_details = self.get_metadata_details(parent_rating_key) if parent_rating_key else {}\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary') or artist_details.get('summary', ''), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': artist_details.get('banner', ''), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'guids': guids, 'markers': markers, 'parent_guids': artist_details.get('guids', []), 'grandparent_guids': [], 'full_title': '{} - {}'.format(helpers.get_xml_attr(metadata_main, 'parentTitle'), helpers.get_xml_attr(metadata_main, 'title')), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'track':\n        parent_rating_key = helpers.get_xml_attr(metadata_main, 'parentRatingKey')\n        album_details = self.get_metadata_details(parent_rating_key) if parent_rating_key else {}\n        track_artist = helpers.get_xml_attr(metadata_main, 'originalTitle') or helpers.get_xml_attr(metadata_main, 'grandparentTitle')\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': album_details.get('year', ''), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': album_details.get('banner', ''), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': album_details.get('genres', []), 'labels': album_details.get('labels', []), 'collections': album_details.get('collections', []), 'guids': guids, 'markers': markers, 'parent_guids': album_details.get('guids', []), 'grandparent_guids': album_details.get('parent_guids', []), 'full_title': '{} - {}'.format(helpers.get_xml_attr(metadata_main, 'title'), track_artist), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'photo_album':\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': helpers.get_xml_attr(metadata_main, 'banner'), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'guids': guids, 'markers': markers, 'parent_guids': [], 'grandparent_guids': [], 'full_title': helpers.get_xml_attr(metadata_main, 'title'), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'photo':\n        parent_rating_key = helpers.get_xml_attr(metadata_main, 'parentRatingKey')\n        photo_album_details = self.get_metadata_details(parent_rating_key) if parent_rating_key else {}\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': photo_album_details.get('banner', ''), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': photo_album_details.get('genres', []), 'labels': photo_album_details.get('labels', []), 'collections': photo_album_details.get('collections', []), 'guids': [], 'markers': markers, 'parent_guids': photo_album_details.get('guids', []), 'grandparent_guids': [], 'full_title': '{} - {}'.format(helpers.get_xml_attr(metadata_main, 'parentTitle') or library_name, helpers.get_xml_attr(metadata_main, 'title')), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'collection':\n        metadata = {'media_type': metadata_type, 'sub_media_type': helpers.get_xml_attr(metadata_main, 'subtype'), 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'min_year': helpers.get_xml_attr(metadata_main, 'minYear'), 'max_year': helpers.get_xml_attr(metadata_main, 'maxYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb').split('?')[0], 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': helpers.get_xml_attr(metadata_main, 'banner'), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'child_count': helpers.get_xml_attr(metadata_main, 'childCount'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'guids': guids, 'markers': markers, 'parent_guids': [], 'grandparent_guids': [], 'full_title': helpers.get_xml_attr(metadata_main, 'title'), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'childCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1'), 'smart': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'smart'))}\n    elif metadata_type == 'playlist':\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'composite': helpers.get_xml_attr(metadata_main, 'composite'), 'thumb': helpers.get_xml_attr(metadata_main, 'composite'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'smart': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'smart')), 'playlist_type': helpers.get_xml_attr(metadata_main, 'playlistType'), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'clip':\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': helpers.get_xml_attr(metadata_main, 'banner'), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'guids': guids, 'markers': markers, 'parent_guids': [], 'grandparent_guids': [], 'full_title': helpers.get_xml_attr(metadata_main, 'title'), 'extra_type': helpers.get_xml_attr(metadata_main, 'extraType'), 'sub_type': helpers.get_xml_attr(metadata_main, 'subtype'), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    else:\n        return metadata\n    if not plex_guid and metadata['live']:\n        metadata['section_id'] = common.LIVE_TV_SECTION_ID\n        metadata['library_name'] = common.LIVE_TV_SECTION_NAME\n        plextv_metadata = self.get_metadata_details(plex_guid=metadata['guid'])\n        if plextv_metadata:\n            keys_to_update = ['summary', 'rating', 'thumb', 'grandparent_thumb', 'duration', 'guid', 'grandparent_guid', 'genres']\n            for key in keys_to_update:\n                metadata[key] = plextv_metadata[key]\n            metadata['originally_available_at'] = helpers.iso_to_YMD(plextv_metadata['originally_available_at'])\n    if metadata and media_info:\n        medias = []\n        media_items = metadata_main.getElementsByTagName('Media')\n        for media in media_items:\n            video_full_resolution_scan_type = ''\n            parts = []\n            part_items = media.getElementsByTagName('Part')\n            for part in part_items:\n                streams = []\n                stream_items = part.getElementsByTagName('Stream')\n                for stream in stream_items:\n                    if helpers.get_xml_attr(stream, 'streamType') == '1':\n                        video_scan_type = helpers.get_xml_attr(stream, 'scanType')\n                        video_full_resolution_scan_type = video_full_resolution_scan_type or video_scan_type\n                        streams.append({'id': helpers.get_xml_attr(stream, 'id'), 'type': helpers.get_xml_attr(stream, 'streamType'), 'video_codec': helpers.get_xml_attr(stream, 'codec'), 'video_codec_level': helpers.get_xml_attr(stream, 'level'), 'video_bitrate': helpers.get_xml_attr(stream, 'bitrate'), 'video_bit_depth': helpers.get_xml_attr(stream, 'bitDepth'), 'video_chroma_subsampling': helpers.get_xml_attr(stream, 'chromaSubsampling'), 'video_color_primaries': helpers.get_xml_attr(stream, 'colorPrimaries'), 'video_color_range': helpers.get_xml_attr(stream, 'colorRange'), 'video_color_space': helpers.get_xml_attr(stream, 'colorSpace'), 'video_color_trc': helpers.get_xml_attr(stream, 'colorTrc'), 'video_dynamic_range': self.get_dynamic_range(stream), 'video_frame_rate': helpers.get_xml_attr(stream, 'frameRate'), 'video_ref_frames': helpers.get_xml_attr(stream, 'refFrames'), 'video_height': helpers.get_xml_attr(stream, 'height'), 'video_width': helpers.get_xml_attr(stream, 'width'), 'video_language': helpers.get_xml_attr(stream, 'language'), 'video_language_code': helpers.get_xml_attr(stream, 'languageCode'), 'video_profile': helpers.get_xml_attr(stream, 'profile'), 'video_scan_type': helpers.get_xml_attr(stream, 'scanType'), 'selected': int(helpers.get_xml_attr(stream, 'selected') == '1')})\n                    elif helpers.get_xml_attr(stream, 'streamType') == '2':\n                        streams.append({'id': helpers.get_xml_attr(stream, 'id'), 'type': helpers.get_xml_attr(stream, 'streamType'), 'audio_codec': helpers.get_xml_attr(stream, 'codec'), 'audio_bitrate': helpers.get_xml_attr(stream, 'bitrate'), 'audio_bitrate_mode': helpers.get_xml_attr(stream, 'bitrateMode'), 'audio_channels': helpers.get_xml_attr(stream, 'channels'), 'audio_channel_layout': helpers.get_xml_attr(stream, 'audioChannelLayout'), 'audio_sample_rate': helpers.get_xml_attr(stream, 'samplingRate'), 'audio_language': helpers.get_xml_attr(stream, 'language'), 'audio_language_code': helpers.get_xml_attr(stream, 'languageCode'), 'audio_profile': helpers.get_xml_attr(stream, 'profile'), 'selected': int(helpers.get_xml_attr(stream, 'selected') == '1')})\n                    elif helpers.get_xml_attr(stream, 'streamType') == '3':\n                        streams.append({'id': helpers.get_xml_attr(stream, 'id'), 'type': helpers.get_xml_attr(stream, 'streamType'), 'subtitle_codec': helpers.get_xml_attr(stream, 'codec'), 'subtitle_container': helpers.get_xml_attr(stream, 'container'), 'subtitle_format': helpers.get_xml_attr(stream, 'format'), 'subtitle_forced': int(helpers.get_xml_attr(stream, 'forced') == '1'), 'subtitle_location': 'external' if helpers.get_xml_attr(stream, 'key') else 'embedded', 'subtitle_language': helpers.get_xml_attr(stream, 'language'), 'subtitle_language_code': helpers.get_xml_attr(stream, 'languageCode'), 'selected': int(helpers.get_xml_attr(stream, 'selected') == '1')})\n                parts.append({'id': helpers.get_xml_attr(part, 'id'), 'file': helpers.get_xml_attr(part, 'file'), 'file_size': helpers.get_xml_attr(part, 'size'), 'indexes': int(helpers.get_xml_attr(part, 'indexes') == 'sd'), 'streams': streams, 'selected': int(helpers.get_xml_attr(part, 'selected') == '1')})\n            video_resolution = helpers.get_xml_attr(media, 'videoResolution').lower().rstrip('ip')\n            video_full_resolution = common.VIDEO_RESOLUTION_OVERRIDES.get(video_resolution, video_resolution + (video_full_resolution_scan_type[:1] or 'p'))\n            audio_channels = helpers.get_xml_attr(media, 'audioChannels')\n            media_info = {'id': helpers.get_xml_attr(media, 'id'), 'container': helpers.get_xml_attr(media, 'container'), 'bitrate': helpers.get_xml_attr(media, 'bitrate'), 'height': helpers.get_xml_attr(media, 'height'), 'width': helpers.get_xml_attr(media, 'width'), 'aspect_ratio': helpers.get_xml_attr(media, 'aspectRatio'), 'video_codec': helpers.get_xml_attr(media, 'videoCodec'), 'video_resolution': video_resolution, 'video_full_resolution': video_full_resolution, 'video_framerate': helpers.get_xml_attr(media, 'videoFrameRate'), 'video_profile': helpers.get_xml_attr(media, 'videoProfile'), 'audio_codec': helpers.get_xml_attr(media, 'audioCodec'), 'audio_channels': audio_channels, 'audio_channel_layout': common.AUDIO_CHANNELS.get(audio_channels, audio_channels), 'audio_profile': helpers.get_xml_attr(media, 'audioProfile'), 'optimized_version': int(helpers.get_xml_attr(media, 'proxyType') == '42'), 'channel_call_sign': helpers.get_xml_attr(media, 'channelCallSign'), 'channel_identifier': helpers.get_xml_attr(media, 'channelIdentifier'), 'channel_thumb': helpers.get_xml_attr(media, 'channelThumb'), 'parts': parts}\n            medias.append(media_info)\n        metadata['media_info'] = medias\n    if metadata:\n        if cache_key:\n            metadata['_cache_time'] = helpers.timestamp()\n            out_file_folder = os.path.join(plexpy.CONFIG.CACHE_DIR, 'session_metadata')\n            out_file_path = os.path.join(out_file_folder, 'metadata-sessionKey-%s.json' % cache_key)\n            if not os.path.exists(out_file_folder):\n                os.mkdir(out_file_folder)\n            try:\n                with open(out_file_path, 'w') as outFile:\n                    json.dump(metadata, outFile)\n            except (IOError, ValueError) as e:\n                logger.error('Tautulli Pmsconnect :: Unable to create cache file for metadata (sessionKey %s): %s' % (cache_key, e))\n        return metadata\n    else:\n        return metadata",
            "def get_metadata_details(self, rating_key='', sync_id='', plex_guid='', section_id='', skip_cache=False, cache_key=None, return_cache=False, media_info=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Return processed and validated metadata list for requested item.\\n\\n        Parameters required:    rating_key { Plex ratingKey }\\n\\n        Output: array\\n        '\n    metadata = {}\n    if not skip_cache and cache_key:\n        in_file_folder = os.path.join(plexpy.CONFIG.CACHE_DIR, 'session_metadata')\n        in_file_path = os.path.join(in_file_folder, 'metadata-sessionKey-%s.json' % cache_key)\n        if not os.path.exists(in_file_folder):\n            os.mkdir(in_file_folder)\n        try:\n            with open(in_file_path, 'r') as inFile:\n                metadata = json.load(inFile)\n        except (IOError, ValueError) as e:\n            pass\n        if metadata:\n            _cache_time = metadata.pop('_cache_time', 0)\n            if return_cache or helpers.timestamp() - _cache_time <= plexpy.CONFIG.METADATA_CACHE_SECONDS:\n                return metadata\n    if rating_key:\n        metadata_xml = self.get_metadata(str(rating_key), output_format='xml')\n    elif sync_id:\n        metadata_xml = self.get_sync_item(str(sync_id), output_format='xml')\n    elif plex_guid.startswith(('plex://movie', 'plex://episode')):\n        rating_key = plex_guid.rsplit('/', 1)[-1]\n        plextv_metadata = PmsConnect(url='https://metadata.provider.plex.tv', token=plexpy.CONFIG.PMS_TOKEN)\n        metadata_xml = plextv_metadata.get_metadata(rating_key, output_format='xml')\n    else:\n        return metadata\n    try:\n        xml_head = metadata_xml.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_metadata_details: %s.' % e)\n        return {}\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                return metadata\n        if a.getElementsByTagName('Directory'):\n            metadata_main_list = a.getElementsByTagName('Directory')\n        elif a.getElementsByTagName('Video'):\n            metadata_main_list = a.getElementsByTagName('Video')\n        elif a.getElementsByTagName('Track'):\n            metadata_main_list = a.getElementsByTagName('Track')\n        elif a.getElementsByTagName('Photo'):\n            metadata_main_list = a.getElementsByTagName('Photo')\n        elif a.getElementsByTagName('Playlist'):\n            metadata_main_list = a.getElementsByTagName('Playlist')\n        else:\n            logger.debug('Tautulli Pmsconnect :: Metadata failed')\n            return {}\n        if sync_id and len(metadata_main_list) > 1:\n            for metadata_main in metadata_main_list:\n                if helpers.get_xml_attr(metadata_main, 'ratingKey') == rating_key:\n                    break\n        else:\n            metadata_main = metadata_main_list[0]\n        metadata_type = helpers.get_xml_attr(metadata_main, 'type')\n        if metadata_main.nodeName == 'Directory' and metadata_type == 'photo':\n            metadata_type = 'photo_album'\n        section_id = helpers.get_xml_attr(a, 'librarySectionID') or section_id\n        library_name = helpers.get_xml_attr(a, 'librarySectionTitle')\n        if not library_name and section_id:\n            library_data = libraries.Libraries().get_details(section_id)\n            library_name = library_data['section_name']\n    directors = []\n    writers = []\n    actors = []\n    genres = []\n    labels = []\n    collections = []\n    guids = []\n    markers = []\n    if metadata_main.getElementsByTagName('Director'):\n        for director in metadata_main.getElementsByTagName('Director'):\n            directors.append(helpers.get_xml_attr(director, 'tag'))\n    if metadata_main.getElementsByTagName('Writer'):\n        for writer in metadata_main.getElementsByTagName('Writer'):\n            writers.append(helpers.get_xml_attr(writer, 'tag'))\n    if metadata_main.getElementsByTagName('Role'):\n        for actor in metadata_main.getElementsByTagName('Role'):\n            actors.append(helpers.get_xml_attr(actor, 'tag'))\n    if metadata_main.getElementsByTagName('Genre'):\n        for genre in metadata_main.getElementsByTagName('Genre'):\n            genres.append(helpers.get_xml_attr(genre, 'tag'))\n    if metadata_main.getElementsByTagName('Label'):\n        for label in metadata_main.getElementsByTagName('Label'):\n            labels.append(helpers.get_xml_attr(label, 'tag'))\n    if metadata_main.getElementsByTagName('Collection'):\n        for collection in metadata_main.getElementsByTagName('Collection'):\n            collections.append(helpers.get_xml_attr(collection, 'tag'))\n    if metadata_main.getElementsByTagName('Guid'):\n        for guid in metadata_main.getElementsByTagName('Guid'):\n            guids.append(helpers.get_xml_attr(guid, 'id'))\n    if metadata_main.getElementsByTagName('Marker'):\n        first = None\n        for marker in metadata_main.getElementsByTagName('Marker'):\n            marker_type = helpers.get_xml_attr(marker, 'type')\n            if marker_type == 'credits':\n                first = bool(first is None)\n            final = helpers.bool_true(helpers.get_xml_attr(marker, 'final'))\n            markers.append({'id': helpers.cast_to_int(helpers.get_xml_attr(marker, 'id')), 'type': marker_type, 'start_time_offset': helpers.cast_to_int(helpers.get_xml_attr(marker, 'startTimeOffset')), 'end_time_offset': helpers.cast_to_int(helpers.get_xml_attr(marker, 'endTimeOffset')), 'first': first if marker_type == 'credits' else None, 'final': final if marker_type == 'credits' else None})\n    if metadata_type == 'movie':\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': helpers.get_xml_attr(metadata_main, 'banner'), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'guids': guids, 'markers': markers, 'parent_guids': [], 'grandparent_guids': [], 'full_title': helpers.get_xml_attr(metadata_main, 'title'), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'show':\n        duration = helpers.get_xml_attr(metadata_main, 'duration')\n        if duration.isdigit() and int(duration) < 1000:\n            duration = str(int(duration) * 60 * 1000)\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': duration, 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': helpers.get_xml_attr(metadata_main, 'banner'), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'guids': guids, 'markers': markers, 'parent_guids': [], 'grandparent_guids': [], 'full_title': helpers.get_xml_attr(metadata_main, 'title'), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'season':\n        parent_rating_key = helpers.get_xml_attr(metadata_main, 'parentRatingKey')\n        parent_guid = helpers.get_xml_attr(metadata_main, 'parentGuid')\n        show_details = {}\n        if plex_guid and parent_guid:\n            show_details = self.get_metadata_details(plex_guid=parent_guid)\n        elif not plex_guid and parent_rating_key:\n            show_details = self.get_metadata_details(parent_rating_key)\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': show_details.get('studio', ''), 'content_rating': show_details.get('content_rating', ''), 'summary': helpers.get_xml_attr(metadata_main, 'summary') or show_details.get('summary', ''), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': show_details.get('duration', ''), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': show_details.get('year', ''), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb') or show_details.get('thumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': show_details.get('banner', ''), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': show_details.get('directors', []), 'writers': show_details.get('writers', []), 'actors': show_details.get('actors', []), 'genres': show_details.get('genres', []), 'labels': show_details.get('labels', []), 'collections': show_details.get('collections', []), 'guids': guids, 'markers': markers, 'parent_guids': show_details.get('guids', []), 'grandparent_guids': [], 'full_title': '{} - {}'.format(helpers.get_xml_attr(metadata_main, 'parentTitle'), helpers.get_xml_attr(metadata_main, 'title')), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'episode':\n        grandparent_rating_key = helpers.get_xml_attr(metadata_main, 'grandparentRatingKey')\n        grandparent_guid = helpers.get_xml_attr(metadata_main, 'grandparentGuid')\n        show_details = {}\n        if plex_guid and grandparent_guid:\n            show_details = self.get_metadata_details(plex_guid=grandparent_guid)\n        elif not plex_guid and grandparent_rating_key:\n            show_details = self.get_metadata_details(grandparent_rating_key)\n        parent_rating_key = helpers.get_xml_attr(metadata_main, 'parentRatingKey')\n        parent_media_index = helpers.get_xml_attr(metadata_main, 'parentIndex')\n        parent_thumb = helpers.get_xml_attr(metadata_main, 'parentThumb')\n        season_details = self.get_metadata_details(parent_rating_key) if parent_rating_key else {}\n        if not plex_guid and (not parent_rating_key):\n            if parent_thumb.startswith('/library/metadata/'):\n                parent_rating_key = parent_thumb.split('/')[3]\n            if not parent_rating_key and grandparent_rating_key:\n                children_list = self.get_item_children(grandparent_rating_key)\n                parent_rating_key = next((c['rating_key'] for c in children_list['children_list'] if c['media_index'] == parent_media_index), '')\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': parent_rating_key, 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': parent_media_index, 'studio': show_details.get('studio', ''), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': season_details.get('year', ''), 'grandparent_year': show_details.get('year', ''), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': parent_thumb or show_details.get('thumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': show_details.get('banner', ''), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': show_details.get('actors', []), 'genres': show_details.get('genres', []), 'labels': show_details.get('labels', []), 'collections': show_details.get('collections', []), 'guids': guids, 'markers': markers, 'parent_guids': season_details.get('guids', []), 'grandparent_guids': show_details.get('guids', []), 'full_title': '{} - {}'.format(helpers.get_xml_attr(metadata_main, 'grandparentTitle'), helpers.get_xml_attr(metadata_main, 'title')), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'artist':\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': helpers.get_xml_attr(metadata_main, 'banner'), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'guids': guids, 'markers': markers, 'parent_guids': [], 'grandparent_guids': [], 'full_title': helpers.get_xml_attr(metadata_main, 'title'), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'album':\n        parent_rating_key = helpers.get_xml_attr(metadata_main, 'parentRatingKey')\n        artist_details = self.get_metadata_details(parent_rating_key) if parent_rating_key else {}\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary') or artist_details.get('summary', ''), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': artist_details.get('banner', ''), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'guids': guids, 'markers': markers, 'parent_guids': artist_details.get('guids', []), 'grandparent_guids': [], 'full_title': '{} - {}'.format(helpers.get_xml_attr(metadata_main, 'parentTitle'), helpers.get_xml_attr(metadata_main, 'title')), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'track':\n        parent_rating_key = helpers.get_xml_attr(metadata_main, 'parentRatingKey')\n        album_details = self.get_metadata_details(parent_rating_key) if parent_rating_key else {}\n        track_artist = helpers.get_xml_attr(metadata_main, 'originalTitle') or helpers.get_xml_attr(metadata_main, 'grandparentTitle')\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': album_details.get('year', ''), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': album_details.get('banner', ''), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': album_details.get('genres', []), 'labels': album_details.get('labels', []), 'collections': album_details.get('collections', []), 'guids': guids, 'markers': markers, 'parent_guids': album_details.get('guids', []), 'grandparent_guids': album_details.get('parent_guids', []), 'full_title': '{} - {}'.format(helpers.get_xml_attr(metadata_main, 'title'), track_artist), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'photo_album':\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': helpers.get_xml_attr(metadata_main, 'banner'), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'guids': guids, 'markers': markers, 'parent_guids': [], 'grandparent_guids': [], 'full_title': helpers.get_xml_attr(metadata_main, 'title'), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'photo':\n        parent_rating_key = helpers.get_xml_attr(metadata_main, 'parentRatingKey')\n        photo_album_details = self.get_metadata_details(parent_rating_key) if parent_rating_key else {}\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': photo_album_details.get('banner', ''), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': photo_album_details.get('genres', []), 'labels': photo_album_details.get('labels', []), 'collections': photo_album_details.get('collections', []), 'guids': [], 'markers': markers, 'parent_guids': photo_album_details.get('guids', []), 'grandparent_guids': [], 'full_title': '{} - {}'.format(helpers.get_xml_attr(metadata_main, 'parentTitle') or library_name, helpers.get_xml_attr(metadata_main, 'title')), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'collection':\n        metadata = {'media_type': metadata_type, 'sub_media_type': helpers.get_xml_attr(metadata_main, 'subtype'), 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'min_year': helpers.get_xml_attr(metadata_main, 'minYear'), 'max_year': helpers.get_xml_attr(metadata_main, 'maxYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb').split('?')[0], 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': helpers.get_xml_attr(metadata_main, 'banner'), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'child_count': helpers.get_xml_attr(metadata_main, 'childCount'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'guids': guids, 'markers': markers, 'parent_guids': [], 'grandparent_guids': [], 'full_title': helpers.get_xml_attr(metadata_main, 'title'), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'childCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1'), 'smart': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'smart'))}\n    elif metadata_type == 'playlist':\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'composite': helpers.get_xml_attr(metadata_main, 'composite'), 'thumb': helpers.get_xml_attr(metadata_main, 'composite'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'smart': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'smart')), 'playlist_type': helpers.get_xml_attr(metadata_main, 'playlistType'), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'clip':\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': helpers.get_xml_attr(metadata_main, 'banner'), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'guids': guids, 'markers': markers, 'parent_guids': [], 'grandparent_guids': [], 'full_title': helpers.get_xml_attr(metadata_main, 'title'), 'extra_type': helpers.get_xml_attr(metadata_main, 'extraType'), 'sub_type': helpers.get_xml_attr(metadata_main, 'subtype'), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    else:\n        return metadata\n    if not plex_guid and metadata['live']:\n        metadata['section_id'] = common.LIVE_TV_SECTION_ID\n        metadata['library_name'] = common.LIVE_TV_SECTION_NAME\n        plextv_metadata = self.get_metadata_details(plex_guid=metadata['guid'])\n        if plextv_metadata:\n            keys_to_update = ['summary', 'rating', 'thumb', 'grandparent_thumb', 'duration', 'guid', 'grandparent_guid', 'genres']\n            for key in keys_to_update:\n                metadata[key] = plextv_metadata[key]\n            metadata['originally_available_at'] = helpers.iso_to_YMD(plextv_metadata['originally_available_at'])\n    if metadata and media_info:\n        medias = []\n        media_items = metadata_main.getElementsByTagName('Media')\n        for media in media_items:\n            video_full_resolution_scan_type = ''\n            parts = []\n            part_items = media.getElementsByTagName('Part')\n            for part in part_items:\n                streams = []\n                stream_items = part.getElementsByTagName('Stream')\n                for stream in stream_items:\n                    if helpers.get_xml_attr(stream, 'streamType') == '1':\n                        video_scan_type = helpers.get_xml_attr(stream, 'scanType')\n                        video_full_resolution_scan_type = video_full_resolution_scan_type or video_scan_type\n                        streams.append({'id': helpers.get_xml_attr(stream, 'id'), 'type': helpers.get_xml_attr(stream, 'streamType'), 'video_codec': helpers.get_xml_attr(stream, 'codec'), 'video_codec_level': helpers.get_xml_attr(stream, 'level'), 'video_bitrate': helpers.get_xml_attr(stream, 'bitrate'), 'video_bit_depth': helpers.get_xml_attr(stream, 'bitDepth'), 'video_chroma_subsampling': helpers.get_xml_attr(stream, 'chromaSubsampling'), 'video_color_primaries': helpers.get_xml_attr(stream, 'colorPrimaries'), 'video_color_range': helpers.get_xml_attr(stream, 'colorRange'), 'video_color_space': helpers.get_xml_attr(stream, 'colorSpace'), 'video_color_trc': helpers.get_xml_attr(stream, 'colorTrc'), 'video_dynamic_range': self.get_dynamic_range(stream), 'video_frame_rate': helpers.get_xml_attr(stream, 'frameRate'), 'video_ref_frames': helpers.get_xml_attr(stream, 'refFrames'), 'video_height': helpers.get_xml_attr(stream, 'height'), 'video_width': helpers.get_xml_attr(stream, 'width'), 'video_language': helpers.get_xml_attr(stream, 'language'), 'video_language_code': helpers.get_xml_attr(stream, 'languageCode'), 'video_profile': helpers.get_xml_attr(stream, 'profile'), 'video_scan_type': helpers.get_xml_attr(stream, 'scanType'), 'selected': int(helpers.get_xml_attr(stream, 'selected') == '1')})\n                    elif helpers.get_xml_attr(stream, 'streamType') == '2':\n                        streams.append({'id': helpers.get_xml_attr(stream, 'id'), 'type': helpers.get_xml_attr(stream, 'streamType'), 'audio_codec': helpers.get_xml_attr(stream, 'codec'), 'audio_bitrate': helpers.get_xml_attr(stream, 'bitrate'), 'audio_bitrate_mode': helpers.get_xml_attr(stream, 'bitrateMode'), 'audio_channels': helpers.get_xml_attr(stream, 'channels'), 'audio_channel_layout': helpers.get_xml_attr(stream, 'audioChannelLayout'), 'audio_sample_rate': helpers.get_xml_attr(stream, 'samplingRate'), 'audio_language': helpers.get_xml_attr(stream, 'language'), 'audio_language_code': helpers.get_xml_attr(stream, 'languageCode'), 'audio_profile': helpers.get_xml_attr(stream, 'profile'), 'selected': int(helpers.get_xml_attr(stream, 'selected') == '1')})\n                    elif helpers.get_xml_attr(stream, 'streamType') == '3':\n                        streams.append({'id': helpers.get_xml_attr(stream, 'id'), 'type': helpers.get_xml_attr(stream, 'streamType'), 'subtitle_codec': helpers.get_xml_attr(stream, 'codec'), 'subtitle_container': helpers.get_xml_attr(stream, 'container'), 'subtitle_format': helpers.get_xml_attr(stream, 'format'), 'subtitle_forced': int(helpers.get_xml_attr(stream, 'forced') == '1'), 'subtitle_location': 'external' if helpers.get_xml_attr(stream, 'key') else 'embedded', 'subtitle_language': helpers.get_xml_attr(stream, 'language'), 'subtitle_language_code': helpers.get_xml_attr(stream, 'languageCode'), 'selected': int(helpers.get_xml_attr(stream, 'selected') == '1')})\n                parts.append({'id': helpers.get_xml_attr(part, 'id'), 'file': helpers.get_xml_attr(part, 'file'), 'file_size': helpers.get_xml_attr(part, 'size'), 'indexes': int(helpers.get_xml_attr(part, 'indexes') == 'sd'), 'streams': streams, 'selected': int(helpers.get_xml_attr(part, 'selected') == '1')})\n            video_resolution = helpers.get_xml_attr(media, 'videoResolution').lower().rstrip('ip')\n            video_full_resolution = common.VIDEO_RESOLUTION_OVERRIDES.get(video_resolution, video_resolution + (video_full_resolution_scan_type[:1] or 'p'))\n            audio_channels = helpers.get_xml_attr(media, 'audioChannels')\n            media_info = {'id': helpers.get_xml_attr(media, 'id'), 'container': helpers.get_xml_attr(media, 'container'), 'bitrate': helpers.get_xml_attr(media, 'bitrate'), 'height': helpers.get_xml_attr(media, 'height'), 'width': helpers.get_xml_attr(media, 'width'), 'aspect_ratio': helpers.get_xml_attr(media, 'aspectRatio'), 'video_codec': helpers.get_xml_attr(media, 'videoCodec'), 'video_resolution': video_resolution, 'video_full_resolution': video_full_resolution, 'video_framerate': helpers.get_xml_attr(media, 'videoFrameRate'), 'video_profile': helpers.get_xml_attr(media, 'videoProfile'), 'audio_codec': helpers.get_xml_attr(media, 'audioCodec'), 'audio_channels': audio_channels, 'audio_channel_layout': common.AUDIO_CHANNELS.get(audio_channels, audio_channels), 'audio_profile': helpers.get_xml_attr(media, 'audioProfile'), 'optimized_version': int(helpers.get_xml_attr(media, 'proxyType') == '42'), 'channel_call_sign': helpers.get_xml_attr(media, 'channelCallSign'), 'channel_identifier': helpers.get_xml_attr(media, 'channelIdentifier'), 'channel_thumb': helpers.get_xml_attr(media, 'channelThumb'), 'parts': parts}\n            medias.append(media_info)\n        metadata['media_info'] = medias\n    if metadata:\n        if cache_key:\n            metadata['_cache_time'] = helpers.timestamp()\n            out_file_folder = os.path.join(plexpy.CONFIG.CACHE_DIR, 'session_metadata')\n            out_file_path = os.path.join(out_file_folder, 'metadata-sessionKey-%s.json' % cache_key)\n            if not os.path.exists(out_file_folder):\n                os.mkdir(out_file_folder)\n            try:\n                with open(out_file_path, 'w') as outFile:\n                    json.dump(metadata, outFile)\n            except (IOError, ValueError) as e:\n                logger.error('Tautulli Pmsconnect :: Unable to create cache file for metadata (sessionKey %s): %s' % (cache_key, e))\n        return metadata\n    else:\n        return metadata",
            "def get_metadata_details(self, rating_key='', sync_id='', plex_guid='', section_id='', skip_cache=False, cache_key=None, return_cache=False, media_info=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Return processed and validated metadata list for requested item.\\n\\n        Parameters required:    rating_key { Plex ratingKey }\\n\\n        Output: array\\n        '\n    metadata = {}\n    if not skip_cache and cache_key:\n        in_file_folder = os.path.join(plexpy.CONFIG.CACHE_DIR, 'session_metadata')\n        in_file_path = os.path.join(in_file_folder, 'metadata-sessionKey-%s.json' % cache_key)\n        if not os.path.exists(in_file_folder):\n            os.mkdir(in_file_folder)\n        try:\n            with open(in_file_path, 'r') as inFile:\n                metadata = json.load(inFile)\n        except (IOError, ValueError) as e:\n            pass\n        if metadata:\n            _cache_time = metadata.pop('_cache_time', 0)\n            if return_cache or helpers.timestamp() - _cache_time <= plexpy.CONFIG.METADATA_CACHE_SECONDS:\n                return metadata\n    if rating_key:\n        metadata_xml = self.get_metadata(str(rating_key), output_format='xml')\n    elif sync_id:\n        metadata_xml = self.get_sync_item(str(sync_id), output_format='xml')\n    elif plex_guid.startswith(('plex://movie', 'plex://episode')):\n        rating_key = plex_guid.rsplit('/', 1)[-1]\n        plextv_metadata = PmsConnect(url='https://metadata.provider.plex.tv', token=plexpy.CONFIG.PMS_TOKEN)\n        metadata_xml = plextv_metadata.get_metadata(rating_key, output_format='xml')\n    else:\n        return metadata\n    try:\n        xml_head = metadata_xml.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_metadata_details: %s.' % e)\n        return {}\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                return metadata\n        if a.getElementsByTagName('Directory'):\n            metadata_main_list = a.getElementsByTagName('Directory')\n        elif a.getElementsByTagName('Video'):\n            metadata_main_list = a.getElementsByTagName('Video')\n        elif a.getElementsByTagName('Track'):\n            metadata_main_list = a.getElementsByTagName('Track')\n        elif a.getElementsByTagName('Photo'):\n            metadata_main_list = a.getElementsByTagName('Photo')\n        elif a.getElementsByTagName('Playlist'):\n            metadata_main_list = a.getElementsByTagName('Playlist')\n        else:\n            logger.debug('Tautulli Pmsconnect :: Metadata failed')\n            return {}\n        if sync_id and len(metadata_main_list) > 1:\n            for metadata_main in metadata_main_list:\n                if helpers.get_xml_attr(metadata_main, 'ratingKey') == rating_key:\n                    break\n        else:\n            metadata_main = metadata_main_list[0]\n        metadata_type = helpers.get_xml_attr(metadata_main, 'type')\n        if metadata_main.nodeName == 'Directory' and metadata_type == 'photo':\n            metadata_type = 'photo_album'\n        section_id = helpers.get_xml_attr(a, 'librarySectionID') or section_id\n        library_name = helpers.get_xml_attr(a, 'librarySectionTitle')\n        if not library_name and section_id:\n            library_data = libraries.Libraries().get_details(section_id)\n            library_name = library_data['section_name']\n    directors = []\n    writers = []\n    actors = []\n    genres = []\n    labels = []\n    collections = []\n    guids = []\n    markers = []\n    if metadata_main.getElementsByTagName('Director'):\n        for director in metadata_main.getElementsByTagName('Director'):\n            directors.append(helpers.get_xml_attr(director, 'tag'))\n    if metadata_main.getElementsByTagName('Writer'):\n        for writer in metadata_main.getElementsByTagName('Writer'):\n            writers.append(helpers.get_xml_attr(writer, 'tag'))\n    if metadata_main.getElementsByTagName('Role'):\n        for actor in metadata_main.getElementsByTagName('Role'):\n            actors.append(helpers.get_xml_attr(actor, 'tag'))\n    if metadata_main.getElementsByTagName('Genre'):\n        for genre in metadata_main.getElementsByTagName('Genre'):\n            genres.append(helpers.get_xml_attr(genre, 'tag'))\n    if metadata_main.getElementsByTagName('Label'):\n        for label in metadata_main.getElementsByTagName('Label'):\n            labels.append(helpers.get_xml_attr(label, 'tag'))\n    if metadata_main.getElementsByTagName('Collection'):\n        for collection in metadata_main.getElementsByTagName('Collection'):\n            collections.append(helpers.get_xml_attr(collection, 'tag'))\n    if metadata_main.getElementsByTagName('Guid'):\n        for guid in metadata_main.getElementsByTagName('Guid'):\n            guids.append(helpers.get_xml_attr(guid, 'id'))\n    if metadata_main.getElementsByTagName('Marker'):\n        first = None\n        for marker in metadata_main.getElementsByTagName('Marker'):\n            marker_type = helpers.get_xml_attr(marker, 'type')\n            if marker_type == 'credits':\n                first = bool(first is None)\n            final = helpers.bool_true(helpers.get_xml_attr(marker, 'final'))\n            markers.append({'id': helpers.cast_to_int(helpers.get_xml_attr(marker, 'id')), 'type': marker_type, 'start_time_offset': helpers.cast_to_int(helpers.get_xml_attr(marker, 'startTimeOffset')), 'end_time_offset': helpers.cast_to_int(helpers.get_xml_attr(marker, 'endTimeOffset')), 'first': first if marker_type == 'credits' else None, 'final': final if marker_type == 'credits' else None})\n    if metadata_type == 'movie':\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': helpers.get_xml_attr(metadata_main, 'banner'), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'guids': guids, 'markers': markers, 'parent_guids': [], 'grandparent_guids': [], 'full_title': helpers.get_xml_attr(metadata_main, 'title'), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'show':\n        duration = helpers.get_xml_attr(metadata_main, 'duration')\n        if duration.isdigit() and int(duration) < 1000:\n            duration = str(int(duration) * 60 * 1000)\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': duration, 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': helpers.get_xml_attr(metadata_main, 'banner'), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'guids': guids, 'markers': markers, 'parent_guids': [], 'grandparent_guids': [], 'full_title': helpers.get_xml_attr(metadata_main, 'title'), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'season':\n        parent_rating_key = helpers.get_xml_attr(metadata_main, 'parentRatingKey')\n        parent_guid = helpers.get_xml_attr(metadata_main, 'parentGuid')\n        show_details = {}\n        if plex_guid and parent_guid:\n            show_details = self.get_metadata_details(plex_guid=parent_guid)\n        elif not plex_guid and parent_rating_key:\n            show_details = self.get_metadata_details(parent_rating_key)\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': show_details.get('studio', ''), 'content_rating': show_details.get('content_rating', ''), 'summary': helpers.get_xml_attr(metadata_main, 'summary') or show_details.get('summary', ''), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': show_details.get('duration', ''), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': show_details.get('year', ''), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb') or show_details.get('thumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': show_details.get('banner', ''), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': show_details.get('directors', []), 'writers': show_details.get('writers', []), 'actors': show_details.get('actors', []), 'genres': show_details.get('genres', []), 'labels': show_details.get('labels', []), 'collections': show_details.get('collections', []), 'guids': guids, 'markers': markers, 'parent_guids': show_details.get('guids', []), 'grandparent_guids': [], 'full_title': '{} - {}'.format(helpers.get_xml_attr(metadata_main, 'parentTitle'), helpers.get_xml_attr(metadata_main, 'title')), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'episode':\n        grandparent_rating_key = helpers.get_xml_attr(metadata_main, 'grandparentRatingKey')\n        grandparent_guid = helpers.get_xml_attr(metadata_main, 'grandparentGuid')\n        show_details = {}\n        if plex_guid and grandparent_guid:\n            show_details = self.get_metadata_details(plex_guid=grandparent_guid)\n        elif not plex_guid and grandparent_rating_key:\n            show_details = self.get_metadata_details(grandparent_rating_key)\n        parent_rating_key = helpers.get_xml_attr(metadata_main, 'parentRatingKey')\n        parent_media_index = helpers.get_xml_attr(metadata_main, 'parentIndex')\n        parent_thumb = helpers.get_xml_attr(metadata_main, 'parentThumb')\n        season_details = self.get_metadata_details(parent_rating_key) if parent_rating_key else {}\n        if not plex_guid and (not parent_rating_key):\n            if parent_thumb.startswith('/library/metadata/'):\n                parent_rating_key = parent_thumb.split('/')[3]\n            if not parent_rating_key and grandparent_rating_key:\n                children_list = self.get_item_children(grandparent_rating_key)\n                parent_rating_key = next((c['rating_key'] for c in children_list['children_list'] if c['media_index'] == parent_media_index), '')\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': parent_rating_key, 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': parent_media_index, 'studio': show_details.get('studio', ''), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': season_details.get('year', ''), 'grandparent_year': show_details.get('year', ''), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': parent_thumb or show_details.get('thumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': show_details.get('banner', ''), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': show_details.get('actors', []), 'genres': show_details.get('genres', []), 'labels': show_details.get('labels', []), 'collections': show_details.get('collections', []), 'guids': guids, 'markers': markers, 'parent_guids': season_details.get('guids', []), 'grandparent_guids': show_details.get('guids', []), 'full_title': '{} - {}'.format(helpers.get_xml_attr(metadata_main, 'grandparentTitle'), helpers.get_xml_attr(metadata_main, 'title')), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'artist':\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': helpers.get_xml_attr(metadata_main, 'banner'), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'guids': guids, 'markers': markers, 'parent_guids': [], 'grandparent_guids': [], 'full_title': helpers.get_xml_attr(metadata_main, 'title'), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'album':\n        parent_rating_key = helpers.get_xml_attr(metadata_main, 'parentRatingKey')\n        artist_details = self.get_metadata_details(parent_rating_key) if parent_rating_key else {}\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary') or artist_details.get('summary', ''), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': artist_details.get('banner', ''), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'guids': guids, 'markers': markers, 'parent_guids': artist_details.get('guids', []), 'grandparent_guids': [], 'full_title': '{} - {}'.format(helpers.get_xml_attr(metadata_main, 'parentTitle'), helpers.get_xml_attr(metadata_main, 'title')), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'track':\n        parent_rating_key = helpers.get_xml_attr(metadata_main, 'parentRatingKey')\n        album_details = self.get_metadata_details(parent_rating_key) if parent_rating_key else {}\n        track_artist = helpers.get_xml_attr(metadata_main, 'originalTitle') or helpers.get_xml_attr(metadata_main, 'grandparentTitle')\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': album_details.get('year', ''), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': album_details.get('banner', ''), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': album_details.get('genres', []), 'labels': album_details.get('labels', []), 'collections': album_details.get('collections', []), 'guids': guids, 'markers': markers, 'parent_guids': album_details.get('guids', []), 'grandparent_guids': album_details.get('parent_guids', []), 'full_title': '{} - {}'.format(helpers.get_xml_attr(metadata_main, 'title'), track_artist), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'photo_album':\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': helpers.get_xml_attr(metadata_main, 'banner'), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'guids': guids, 'markers': markers, 'parent_guids': [], 'grandparent_guids': [], 'full_title': helpers.get_xml_attr(metadata_main, 'title'), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'photo':\n        parent_rating_key = helpers.get_xml_attr(metadata_main, 'parentRatingKey')\n        photo_album_details = self.get_metadata_details(parent_rating_key) if parent_rating_key else {}\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': photo_album_details.get('banner', ''), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': photo_album_details.get('genres', []), 'labels': photo_album_details.get('labels', []), 'collections': photo_album_details.get('collections', []), 'guids': [], 'markers': markers, 'parent_guids': photo_album_details.get('guids', []), 'grandparent_guids': [], 'full_title': '{} - {}'.format(helpers.get_xml_attr(metadata_main, 'parentTitle') or library_name, helpers.get_xml_attr(metadata_main, 'title')), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'collection':\n        metadata = {'media_type': metadata_type, 'sub_media_type': helpers.get_xml_attr(metadata_main, 'subtype'), 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'min_year': helpers.get_xml_attr(metadata_main, 'minYear'), 'max_year': helpers.get_xml_attr(metadata_main, 'maxYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb').split('?')[0], 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': helpers.get_xml_attr(metadata_main, 'banner'), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'child_count': helpers.get_xml_attr(metadata_main, 'childCount'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'guids': guids, 'markers': markers, 'parent_guids': [], 'grandparent_guids': [], 'full_title': helpers.get_xml_attr(metadata_main, 'title'), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'childCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1'), 'smart': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'smart'))}\n    elif metadata_type == 'playlist':\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'composite': helpers.get_xml_attr(metadata_main, 'composite'), 'thumb': helpers.get_xml_attr(metadata_main, 'composite'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'smart': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'smart')), 'playlist_type': helpers.get_xml_attr(metadata_main, 'playlistType'), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'clip':\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': helpers.get_xml_attr(metadata_main, 'banner'), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'guids': guids, 'markers': markers, 'parent_guids': [], 'grandparent_guids': [], 'full_title': helpers.get_xml_attr(metadata_main, 'title'), 'extra_type': helpers.get_xml_attr(metadata_main, 'extraType'), 'sub_type': helpers.get_xml_attr(metadata_main, 'subtype'), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    else:\n        return metadata\n    if not plex_guid and metadata['live']:\n        metadata['section_id'] = common.LIVE_TV_SECTION_ID\n        metadata['library_name'] = common.LIVE_TV_SECTION_NAME\n        plextv_metadata = self.get_metadata_details(plex_guid=metadata['guid'])\n        if plextv_metadata:\n            keys_to_update = ['summary', 'rating', 'thumb', 'grandparent_thumb', 'duration', 'guid', 'grandparent_guid', 'genres']\n            for key in keys_to_update:\n                metadata[key] = plextv_metadata[key]\n            metadata['originally_available_at'] = helpers.iso_to_YMD(plextv_metadata['originally_available_at'])\n    if metadata and media_info:\n        medias = []\n        media_items = metadata_main.getElementsByTagName('Media')\n        for media in media_items:\n            video_full_resolution_scan_type = ''\n            parts = []\n            part_items = media.getElementsByTagName('Part')\n            for part in part_items:\n                streams = []\n                stream_items = part.getElementsByTagName('Stream')\n                for stream in stream_items:\n                    if helpers.get_xml_attr(stream, 'streamType') == '1':\n                        video_scan_type = helpers.get_xml_attr(stream, 'scanType')\n                        video_full_resolution_scan_type = video_full_resolution_scan_type or video_scan_type\n                        streams.append({'id': helpers.get_xml_attr(stream, 'id'), 'type': helpers.get_xml_attr(stream, 'streamType'), 'video_codec': helpers.get_xml_attr(stream, 'codec'), 'video_codec_level': helpers.get_xml_attr(stream, 'level'), 'video_bitrate': helpers.get_xml_attr(stream, 'bitrate'), 'video_bit_depth': helpers.get_xml_attr(stream, 'bitDepth'), 'video_chroma_subsampling': helpers.get_xml_attr(stream, 'chromaSubsampling'), 'video_color_primaries': helpers.get_xml_attr(stream, 'colorPrimaries'), 'video_color_range': helpers.get_xml_attr(stream, 'colorRange'), 'video_color_space': helpers.get_xml_attr(stream, 'colorSpace'), 'video_color_trc': helpers.get_xml_attr(stream, 'colorTrc'), 'video_dynamic_range': self.get_dynamic_range(stream), 'video_frame_rate': helpers.get_xml_attr(stream, 'frameRate'), 'video_ref_frames': helpers.get_xml_attr(stream, 'refFrames'), 'video_height': helpers.get_xml_attr(stream, 'height'), 'video_width': helpers.get_xml_attr(stream, 'width'), 'video_language': helpers.get_xml_attr(stream, 'language'), 'video_language_code': helpers.get_xml_attr(stream, 'languageCode'), 'video_profile': helpers.get_xml_attr(stream, 'profile'), 'video_scan_type': helpers.get_xml_attr(stream, 'scanType'), 'selected': int(helpers.get_xml_attr(stream, 'selected') == '1')})\n                    elif helpers.get_xml_attr(stream, 'streamType') == '2':\n                        streams.append({'id': helpers.get_xml_attr(stream, 'id'), 'type': helpers.get_xml_attr(stream, 'streamType'), 'audio_codec': helpers.get_xml_attr(stream, 'codec'), 'audio_bitrate': helpers.get_xml_attr(stream, 'bitrate'), 'audio_bitrate_mode': helpers.get_xml_attr(stream, 'bitrateMode'), 'audio_channels': helpers.get_xml_attr(stream, 'channels'), 'audio_channel_layout': helpers.get_xml_attr(stream, 'audioChannelLayout'), 'audio_sample_rate': helpers.get_xml_attr(stream, 'samplingRate'), 'audio_language': helpers.get_xml_attr(stream, 'language'), 'audio_language_code': helpers.get_xml_attr(stream, 'languageCode'), 'audio_profile': helpers.get_xml_attr(stream, 'profile'), 'selected': int(helpers.get_xml_attr(stream, 'selected') == '1')})\n                    elif helpers.get_xml_attr(stream, 'streamType') == '3':\n                        streams.append({'id': helpers.get_xml_attr(stream, 'id'), 'type': helpers.get_xml_attr(stream, 'streamType'), 'subtitle_codec': helpers.get_xml_attr(stream, 'codec'), 'subtitle_container': helpers.get_xml_attr(stream, 'container'), 'subtitle_format': helpers.get_xml_attr(stream, 'format'), 'subtitle_forced': int(helpers.get_xml_attr(stream, 'forced') == '1'), 'subtitle_location': 'external' if helpers.get_xml_attr(stream, 'key') else 'embedded', 'subtitle_language': helpers.get_xml_attr(stream, 'language'), 'subtitle_language_code': helpers.get_xml_attr(stream, 'languageCode'), 'selected': int(helpers.get_xml_attr(stream, 'selected') == '1')})\n                parts.append({'id': helpers.get_xml_attr(part, 'id'), 'file': helpers.get_xml_attr(part, 'file'), 'file_size': helpers.get_xml_attr(part, 'size'), 'indexes': int(helpers.get_xml_attr(part, 'indexes') == 'sd'), 'streams': streams, 'selected': int(helpers.get_xml_attr(part, 'selected') == '1')})\n            video_resolution = helpers.get_xml_attr(media, 'videoResolution').lower().rstrip('ip')\n            video_full_resolution = common.VIDEO_RESOLUTION_OVERRIDES.get(video_resolution, video_resolution + (video_full_resolution_scan_type[:1] or 'p'))\n            audio_channels = helpers.get_xml_attr(media, 'audioChannels')\n            media_info = {'id': helpers.get_xml_attr(media, 'id'), 'container': helpers.get_xml_attr(media, 'container'), 'bitrate': helpers.get_xml_attr(media, 'bitrate'), 'height': helpers.get_xml_attr(media, 'height'), 'width': helpers.get_xml_attr(media, 'width'), 'aspect_ratio': helpers.get_xml_attr(media, 'aspectRatio'), 'video_codec': helpers.get_xml_attr(media, 'videoCodec'), 'video_resolution': video_resolution, 'video_full_resolution': video_full_resolution, 'video_framerate': helpers.get_xml_attr(media, 'videoFrameRate'), 'video_profile': helpers.get_xml_attr(media, 'videoProfile'), 'audio_codec': helpers.get_xml_attr(media, 'audioCodec'), 'audio_channels': audio_channels, 'audio_channel_layout': common.AUDIO_CHANNELS.get(audio_channels, audio_channels), 'audio_profile': helpers.get_xml_attr(media, 'audioProfile'), 'optimized_version': int(helpers.get_xml_attr(media, 'proxyType') == '42'), 'channel_call_sign': helpers.get_xml_attr(media, 'channelCallSign'), 'channel_identifier': helpers.get_xml_attr(media, 'channelIdentifier'), 'channel_thumb': helpers.get_xml_attr(media, 'channelThumb'), 'parts': parts}\n            medias.append(media_info)\n        metadata['media_info'] = medias\n    if metadata:\n        if cache_key:\n            metadata['_cache_time'] = helpers.timestamp()\n            out_file_folder = os.path.join(plexpy.CONFIG.CACHE_DIR, 'session_metadata')\n            out_file_path = os.path.join(out_file_folder, 'metadata-sessionKey-%s.json' % cache_key)\n            if not os.path.exists(out_file_folder):\n                os.mkdir(out_file_folder)\n            try:\n                with open(out_file_path, 'w') as outFile:\n                    json.dump(metadata, outFile)\n            except (IOError, ValueError) as e:\n                logger.error('Tautulli Pmsconnect :: Unable to create cache file for metadata (sessionKey %s): %s' % (cache_key, e))\n        return metadata\n    else:\n        return metadata",
            "def get_metadata_details(self, rating_key='', sync_id='', plex_guid='', section_id='', skip_cache=False, cache_key=None, return_cache=False, media_info=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Return processed and validated metadata list for requested item.\\n\\n        Parameters required:    rating_key { Plex ratingKey }\\n\\n        Output: array\\n        '\n    metadata = {}\n    if not skip_cache and cache_key:\n        in_file_folder = os.path.join(plexpy.CONFIG.CACHE_DIR, 'session_metadata')\n        in_file_path = os.path.join(in_file_folder, 'metadata-sessionKey-%s.json' % cache_key)\n        if not os.path.exists(in_file_folder):\n            os.mkdir(in_file_folder)\n        try:\n            with open(in_file_path, 'r') as inFile:\n                metadata = json.load(inFile)\n        except (IOError, ValueError) as e:\n            pass\n        if metadata:\n            _cache_time = metadata.pop('_cache_time', 0)\n            if return_cache or helpers.timestamp() - _cache_time <= plexpy.CONFIG.METADATA_CACHE_SECONDS:\n                return metadata\n    if rating_key:\n        metadata_xml = self.get_metadata(str(rating_key), output_format='xml')\n    elif sync_id:\n        metadata_xml = self.get_sync_item(str(sync_id), output_format='xml')\n    elif plex_guid.startswith(('plex://movie', 'plex://episode')):\n        rating_key = plex_guid.rsplit('/', 1)[-1]\n        plextv_metadata = PmsConnect(url='https://metadata.provider.plex.tv', token=plexpy.CONFIG.PMS_TOKEN)\n        metadata_xml = plextv_metadata.get_metadata(rating_key, output_format='xml')\n    else:\n        return metadata\n    try:\n        xml_head = metadata_xml.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_metadata_details: %s.' % e)\n        return {}\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                return metadata\n        if a.getElementsByTagName('Directory'):\n            metadata_main_list = a.getElementsByTagName('Directory')\n        elif a.getElementsByTagName('Video'):\n            metadata_main_list = a.getElementsByTagName('Video')\n        elif a.getElementsByTagName('Track'):\n            metadata_main_list = a.getElementsByTagName('Track')\n        elif a.getElementsByTagName('Photo'):\n            metadata_main_list = a.getElementsByTagName('Photo')\n        elif a.getElementsByTagName('Playlist'):\n            metadata_main_list = a.getElementsByTagName('Playlist')\n        else:\n            logger.debug('Tautulli Pmsconnect :: Metadata failed')\n            return {}\n        if sync_id and len(metadata_main_list) > 1:\n            for metadata_main in metadata_main_list:\n                if helpers.get_xml_attr(metadata_main, 'ratingKey') == rating_key:\n                    break\n        else:\n            metadata_main = metadata_main_list[0]\n        metadata_type = helpers.get_xml_attr(metadata_main, 'type')\n        if metadata_main.nodeName == 'Directory' and metadata_type == 'photo':\n            metadata_type = 'photo_album'\n        section_id = helpers.get_xml_attr(a, 'librarySectionID') or section_id\n        library_name = helpers.get_xml_attr(a, 'librarySectionTitle')\n        if not library_name and section_id:\n            library_data = libraries.Libraries().get_details(section_id)\n            library_name = library_data['section_name']\n    directors = []\n    writers = []\n    actors = []\n    genres = []\n    labels = []\n    collections = []\n    guids = []\n    markers = []\n    if metadata_main.getElementsByTagName('Director'):\n        for director in metadata_main.getElementsByTagName('Director'):\n            directors.append(helpers.get_xml_attr(director, 'tag'))\n    if metadata_main.getElementsByTagName('Writer'):\n        for writer in metadata_main.getElementsByTagName('Writer'):\n            writers.append(helpers.get_xml_attr(writer, 'tag'))\n    if metadata_main.getElementsByTagName('Role'):\n        for actor in metadata_main.getElementsByTagName('Role'):\n            actors.append(helpers.get_xml_attr(actor, 'tag'))\n    if metadata_main.getElementsByTagName('Genre'):\n        for genre in metadata_main.getElementsByTagName('Genre'):\n            genres.append(helpers.get_xml_attr(genre, 'tag'))\n    if metadata_main.getElementsByTagName('Label'):\n        for label in metadata_main.getElementsByTagName('Label'):\n            labels.append(helpers.get_xml_attr(label, 'tag'))\n    if metadata_main.getElementsByTagName('Collection'):\n        for collection in metadata_main.getElementsByTagName('Collection'):\n            collections.append(helpers.get_xml_attr(collection, 'tag'))\n    if metadata_main.getElementsByTagName('Guid'):\n        for guid in metadata_main.getElementsByTagName('Guid'):\n            guids.append(helpers.get_xml_attr(guid, 'id'))\n    if metadata_main.getElementsByTagName('Marker'):\n        first = None\n        for marker in metadata_main.getElementsByTagName('Marker'):\n            marker_type = helpers.get_xml_attr(marker, 'type')\n            if marker_type == 'credits':\n                first = bool(first is None)\n            final = helpers.bool_true(helpers.get_xml_attr(marker, 'final'))\n            markers.append({'id': helpers.cast_to_int(helpers.get_xml_attr(marker, 'id')), 'type': marker_type, 'start_time_offset': helpers.cast_to_int(helpers.get_xml_attr(marker, 'startTimeOffset')), 'end_time_offset': helpers.cast_to_int(helpers.get_xml_attr(marker, 'endTimeOffset')), 'first': first if marker_type == 'credits' else None, 'final': final if marker_type == 'credits' else None})\n    if metadata_type == 'movie':\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': helpers.get_xml_attr(metadata_main, 'banner'), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'guids': guids, 'markers': markers, 'parent_guids': [], 'grandparent_guids': [], 'full_title': helpers.get_xml_attr(metadata_main, 'title'), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'show':\n        duration = helpers.get_xml_attr(metadata_main, 'duration')\n        if duration.isdigit() and int(duration) < 1000:\n            duration = str(int(duration) * 60 * 1000)\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': duration, 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': helpers.get_xml_attr(metadata_main, 'banner'), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'guids': guids, 'markers': markers, 'parent_guids': [], 'grandparent_guids': [], 'full_title': helpers.get_xml_attr(metadata_main, 'title'), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'season':\n        parent_rating_key = helpers.get_xml_attr(metadata_main, 'parentRatingKey')\n        parent_guid = helpers.get_xml_attr(metadata_main, 'parentGuid')\n        show_details = {}\n        if plex_guid and parent_guid:\n            show_details = self.get_metadata_details(plex_guid=parent_guid)\n        elif not plex_guid and parent_rating_key:\n            show_details = self.get_metadata_details(parent_rating_key)\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': show_details.get('studio', ''), 'content_rating': show_details.get('content_rating', ''), 'summary': helpers.get_xml_attr(metadata_main, 'summary') or show_details.get('summary', ''), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': show_details.get('duration', ''), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': show_details.get('year', ''), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb') or show_details.get('thumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': show_details.get('banner', ''), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': show_details.get('directors', []), 'writers': show_details.get('writers', []), 'actors': show_details.get('actors', []), 'genres': show_details.get('genres', []), 'labels': show_details.get('labels', []), 'collections': show_details.get('collections', []), 'guids': guids, 'markers': markers, 'parent_guids': show_details.get('guids', []), 'grandparent_guids': [], 'full_title': '{} - {}'.format(helpers.get_xml_attr(metadata_main, 'parentTitle'), helpers.get_xml_attr(metadata_main, 'title')), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'episode':\n        grandparent_rating_key = helpers.get_xml_attr(metadata_main, 'grandparentRatingKey')\n        grandparent_guid = helpers.get_xml_attr(metadata_main, 'grandparentGuid')\n        show_details = {}\n        if plex_guid and grandparent_guid:\n            show_details = self.get_metadata_details(plex_guid=grandparent_guid)\n        elif not plex_guid and grandparent_rating_key:\n            show_details = self.get_metadata_details(grandparent_rating_key)\n        parent_rating_key = helpers.get_xml_attr(metadata_main, 'parentRatingKey')\n        parent_media_index = helpers.get_xml_attr(metadata_main, 'parentIndex')\n        parent_thumb = helpers.get_xml_attr(metadata_main, 'parentThumb')\n        season_details = self.get_metadata_details(parent_rating_key) if parent_rating_key else {}\n        if not plex_guid and (not parent_rating_key):\n            if parent_thumb.startswith('/library/metadata/'):\n                parent_rating_key = parent_thumb.split('/')[3]\n            if not parent_rating_key and grandparent_rating_key:\n                children_list = self.get_item_children(grandparent_rating_key)\n                parent_rating_key = next((c['rating_key'] for c in children_list['children_list'] if c['media_index'] == parent_media_index), '')\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': parent_rating_key, 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': parent_media_index, 'studio': show_details.get('studio', ''), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': season_details.get('year', ''), 'grandparent_year': show_details.get('year', ''), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': parent_thumb or show_details.get('thumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': show_details.get('banner', ''), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': show_details.get('actors', []), 'genres': show_details.get('genres', []), 'labels': show_details.get('labels', []), 'collections': show_details.get('collections', []), 'guids': guids, 'markers': markers, 'parent_guids': season_details.get('guids', []), 'grandparent_guids': show_details.get('guids', []), 'full_title': '{} - {}'.format(helpers.get_xml_attr(metadata_main, 'grandparentTitle'), helpers.get_xml_attr(metadata_main, 'title')), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'artist':\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': helpers.get_xml_attr(metadata_main, 'banner'), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'guids': guids, 'markers': markers, 'parent_guids': [], 'grandparent_guids': [], 'full_title': helpers.get_xml_attr(metadata_main, 'title'), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'album':\n        parent_rating_key = helpers.get_xml_attr(metadata_main, 'parentRatingKey')\n        artist_details = self.get_metadata_details(parent_rating_key) if parent_rating_key else {}\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary') or artist_details.get('summary', ''), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': artist_details.get('banner', ''), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'guids': guids, 'markers': markers, 'parent_guids': artist_details.get('guids', []), 'grandparent_guids': [], 'full_title': '{} - {}'.format(helpers.get_xml_attr(metadata_main, 'parentTitle'), helpers.get_xml_attr(metadata_main, 'title')), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'track':\n        parent_rating_key = helpers.get_xml_attr(metadata_main, 'parentRatingKey')\n        album_details = self.get_metadata_details(parent_rating_key) if parent_rating_key else {}\n        track_artist = helpers.get_xml_attr(metadata_main, 'originalTitle') or helpers.get_xml_attr(metadata_main, 'grandparentTitle')\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': album_details.get('year', ''), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': album_details.get('banner', ''), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': album_details.get('genres', []), 'labels': album_details.get('labels', []), 'collections': album_details.get('collections', []), 'guids': guids, 'markers': markers, 'parent_guids': album_details.get('guids', []), 'grandparent_guids': album_details.get('parent_guids', []), 'full_title': '{} - {}'.format(helpers.get_xml_attr(metadata_main, 'title'), track_artist), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'photo_album':\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': helpers.get_xml_attr(metadata_main, 'banner'), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'guids': guids, 'markers': markers, 'parent_guids': [], 'grandparent_guids': [], 'full_title': helpers.get_xml_attr(metadata_main, 'title'), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'photo':\n        parent_rating_key = helpers.get_xml_attr(metadata_main, 'parentRatingKey')\n        photo_album_details = self.get_metadata_details(parent_rating_key) if parent_rating_key else {}\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': photo_album_details.get('banner', ''), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': photo_album_details.get('genres', []), 'labels': photo_album_details.get('labels', []), 'collections': photo_album_details.get('collections', []), 'guids': [], 'markers': markers, 'parent_guids': photo_album_details.get('guids', []), 'grandparent_guids': [], 'full_title': '{} - {}'.format(helpers.get_xml_attr(metadata_main, 'parentTitle') or library_name, helpers.get_xml_attr(metadata_main, 'title')), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'collection':\n        metadata = {'media_type': metadata_type, 'sub_media_type': helpers.get_xml_attr(metadata_main, 'subtype'), 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'grandparent_year': helpers.get_xml_attr(metadata_main, 'grandparentYear'), 'min_year': helpers.get_xml_attr(metadata_main, 'minYear'), 'max_year': helpers.get_xml_attr(metadata_main, 'maxYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb').split('?')[0], 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': helpers.get_xml_attr(metadata_main, 'banner'), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'child_count': helpers.get_xml_attr(metadata_main, 'childCount'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'guids': guids, 'markers': markers, 'parent_guids': [], 'grandparent_guids': [], 'full_title': helpers.get_xml_attr(metadata_main, 'title'), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'childCount')), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1'), 'smart': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'smart'))}\n    elif metadata_type == 'playlist':\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'composite': helpers.get_xml_attr(metadata_main, 'composite'), 'thumb': helpers.get_xml_attr(metadata_main, 'composite'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'children_count': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'leafCount')), 'smart': helpers.cast_to_int(helpers.get_xml_attr(metadata_main, 'smart')), 'playlist_type': helpers.get_xml_attr(metadata_main, 'playlistType'), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    elif metadata_type == 'clip':\n        metadata = {'media_type': metadata_type, 'section_id': section_id, 'library_name': library_name, 'rating_key': helpers.get_xml_attr(metadata_main, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(metadata_main, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(metadata_main, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(metadata_main, 'title'), 'parent_title': helpers.get_xml_attr(metadata_main, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(metadata_main, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(metadata_main, 'originalTitle'), 'sort_title': helpers.get_xml_attr(metadata_main, 'titleSort'), 'edition_title': helpers.get_xml_attr(metadata_main, 'editionTitle'), 'media_index': helpers.get_xml_attr(metadata_main, 'index'), 'parent_media_index': helpers.get_xml_attr(metadata_main, 'parentIndex'), 'studio': helpers.get_xml_attr(metadata_main, 'studio'), 'content_rating': helpers.get_xml_attr(metadata_main, 'contentRating'), 'summary': helpers.get_xml_attr(metadata_main, 'summary'), 'tagline': helpers.get_xml_attr(metadata_main, 'tagline'), 'rating': helpers.get_xml_attr(metadata_main, 'rating'), 'rating_image': helpers.get_xml_attr(metadata_main, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(metadata_main, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(metadata_main, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(metadata_main, 'userRating'), 'duration': helpers.get_xml_attr(metadata_main, 'duration'), 'year': helpers.get_xml_attr(metadata_main, 'year'), 'parent_year': helpers.get_xml_attr(metadata_main, 'parentYear'), 'thumb': helpers.get_xml_attr(metadata_main, 'thumb'), 'parent_thumb': helpers.get_xml_attr(metadata_main, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(metadata_main, 'grandparentThumb'), 'art': helpers.get_xml_attr(metadata_main, 'art'), 'banner': helpers.get_xml_attr(metadata_main, 'banner'), 'originally_available_at': helpers.get_xml_attr(metadata_main, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(metadata_main, 'addedAt'), 'updated_at': helpers.get_xml_attr(metadata_main, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(metadata_main, 'lastViewedAt'), 'guid': helpers.get_xml_attr(metadata_main, 'guid'), 'parent_guid': helpers.get_xml_attr(metadata_main, 'parentGuid'), 'grandparent_guid': helpers.get_xml_attr(metadata_main, 'grandparentGuid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'guids': guids, 'markers': markers, 'parent_guids': [], 'grandparent_guids': [], 'full_title': helpers.get_xml_attr(metadata_main, 'title'), 'extra_type': helpers.get_xml_attr(metadata_main, 'extraType'), 'sub_type': helpers.get_xml_attr(metadata_main, 'subtype'), 'live': int(helpers.get_xml_attr(metadata_main, 'live') == '1')}\n    else:\n        return metadata\n    if not plex_guid and metadata['live']:\n        metadata['section_id'] = common.LIVE_TV_SECTION_ID\n        metadata['library_name'] = common.LIVE_TV_SECTION_NAME\n        plextv_metadata = self.get_metadata_details(plex_guid=metadata['guid'])\n        if plextv_metadata:\n            keys_to_update = ['summary', 'rating', 'thumb', 'grandparent_thumb', 'duration', 'guid', 'grandparent_guid', 'genres']\n            for key in keys_to_update:\n                metadata[key] = plextv_metadata[key]\n            metadata['originally_available_at'] = helpers.iso_to_YMD(plextv_metadata['originally_available_at'])\n    if metadata and media_info:\n        medias = []\n        media_items = metadata_main.getElementsByTagName('Media')\n        for media in media_items:\n            video_full_resolution_scan_type = ''\n            parts = []\n            part_items = media.getElementsByTagName('Part')\n            for part in part_items:\n                streams = []\n                stream_items = part.getElementsByTagName('Stream')\n                for stream in stream_items:\n                    if helpers.get_xml_attr(stream, 'streamType') == '1':\n                        video_scan_type = helpers.get_xml_attr(stream, 'scanType')\n                        video_full_resolution_scan_type = video_full_resolution_scan_type or video_scan_type\n                        streams.append({'id': helpers.get_xml_attr(stream, 'id'), 'type': helpers.get_xml_attr(stream, 'streamType'), 'video_codec': helpers.get_xml_attr(stream, 'codec'), 'video_codec_level': helpers.get_xml_attr(stream, 'level'), 'video_bitrate': helpers.get_xml_attr(stream, 'bitrate'), 'video_bit_depth': helpers.get_xml_attr(stream, 'bitDepth'), 'video_chroma_subsampling': helpers.get_xml_attr(stream, 'chromaSubsampling'), 'video_color_primaries': helpers.get_xml_attr(stream, 'colorPrimaries'), 'video_color_range': helpers.get_xml_attr(stream, 'colorRange'), 'video_color_space': helpers.get_xml_attr(stream, 'colorSpace'), 'video_color_trc': helpers.get_xml_attr(stream, 'colorTrc'), 'video_dynamic_range': self.get_dynamic_range(stream), 'video_frame_rate': helpers.get_xml_attr(stream, 'frameRate'), 'video_ref_frames': helpers.get_xml_attr(stream, 'refFrames'), 'video_height': helpers.get_xml_attr(stream, 'height'), 'video_width': helpers.get_xml_attr(stream, 'width'), 'video_language': helpers.get_xml_attr(stream, 'language'), 'video_language_code': helpers.get_xml_attr(stream, 'languageCode'), 'video_profile': helpers.get_xml_attr(stream, 'profile'), 'video_scan_type': helpers.get_xml_attr(stream, 'scanType'), 'selected': int(helpers.get_xml_attr(stream, 'selected') == '1')})\n                    elif helpers.get_xml_attr(stream, 'streamType') == '2':\n                        streams.append({'id': helpers.get_xml_attr(stream, 'id'), 'type': helpers.get_xml_attr(stream, 'streamType'), 'audio_codec': helpers.get_xml_attr(stream, 'codec'), 'audio_bitrate': helpers.get_xml_attr(stream, 'bitrate'), 'audio_bitrate_mode': helpers.get_xml_attr(stream, 'bitrateMode'), 'audio_channels': helpers.get_xml_attr(stream, 'channels'), 'audio_channel_layout': helpers.get_xml_attr(stream, 'audioChannelLayout'), 'audio_sample_rate': helpers.get_xml_attr(stream, 'samplingRate'), 'audio_language': helpers.get_xml_attr(stream, 'language'), 'audio_language_code': helpers.get_xml_attr(stream, 'languageCode'), 'audio_profile': helpers.get_xml_attr(stream, 'profile'), 'selected': int(helpers.get_xml_attr(stream, 'selected') == '1')})\n                    elif helpers.get_xml_attr(stream, 'streamType') == '3':\n                        streams.append({'id': helpers.get_xml_attr(stream, 'id'), 'type': helpers.get_xml_attr(stream, 'streamType'), 'subtitle_codec': helpers.get_xml_attr(stream, 'codec'), 'subtitle_container': helpers.get_xml_attr(stream, 'container'), 'subtitle_format': helpers.get_xml_attr(stream, 'format'), 'subtitle_forced': int(helpers.get_xml_attr(stream, 'forced') == '1'), 'subtitle_location': 'external' if helpers.get_xml_attr(stream, 'key') else 'embedded', 'subtitle_language': helpers.get_xml_attr(stream, 'language'), 'subtitle_language_code': helpers.get_xml_attr(stream, 'languageCode'), 'selected': int(helpers.get_xml_attr(stream, 'selected') == '1')})\n                parts.append({'id': helpers.get_xml_attr(part, 'id'), 'file': helpers.get_xml_attr(part, 'file'), 'file_size': helpers.get_xml_attr(part, 'size'), 'indexes': int(helpers.get_xml_attr(part, 'indexes') == 'sd'), 'streams': streams, 'selected': int(helpers.get_xml_attr(part, 'selected') == '1')})\n            video_resolution = helpers.get_xml_attr(media, 'videoResolution').lower().rstrip('ip')\n            video_full_resolution = common.VIDEO_RESOLUTION_OVERRIDES.get(video_resolution, video_resolution + (video_full_resolution_scan_type[:1] or 'p'))\n            audio_channels = helpers.get_xml_attr(media, 'audioChannels')\n            media_info = {'id': helpers.get_xml_attr(media, 'id'), 'container': helpers.get_xml_attr(media, 'container'), 'bitrate': helpers.get_xml_attr(media, 'bitrate'), 'height': helpers.get_xml_attr(media, 'height'), 'width': helpers.get_xml_attr(media, 'width'), 'aspect_ratio': helpers.get_xml_attr(media, 'aspectRatio'), 'video_codec': helpers.get_xml_attr(media, 'videoCodec'), 'video_resolution': video_resolution, 'video_full_resolution': video_full_resolution, 'video_framerate': helpers.get_xml_attr(media, 'videoFrameRate'), 'video_profile': helpers.get_xml_attr(media, 'videoProfile'), 'audio_codec': helpers.get_xml_attr(media, 'audioCodec'), 'audio_channels': audio_channels, 'audio_channel_layout': common.AUDIO_CHANNELS.get(audio_channels, audio_channels), 'audio_profile': helpers.get_xml_attr(media, 'audioProfile'), 'optimized_version': int(helpers.get_xml_attr(media, 'proxyType') == '42'), 'channel_call_sign': helpers.get_xml_attr(media, 'channelCallSign'), 'channel_identifier': helpers.get_xml_attr(media, 'channelIdentifier'), 'channel_thumb': helpers.get_xml_attr(media, 'channelThumb'), 'parts': parts}\n            medias.append(media_info)\n        metadata['media_info'] = medias\n    if metadata:\n        if cache_key:\n            metadata['_cache_time'] = helpers.timestamp()\n            out_file_folder = os.path.join(plexpy.CONFIG.CACHE_DIR, 'session_metadata')\n            out_file_path = os.path.join(out_file_folder, 'metadata-sessionKey-%s.json' % cache_key)\n            if not os.path.exists(out_file_folder):\n                os.mkdir(out_file_folder)\n            try:\n                with open(out_file_path, 'w') as outFile:\n                    json.dump(metadata, outFile)\n            except (IOError, ValueError) as e:\n                logger.error('Tautulli Pmsconnect :: Unable to create cache file for metadata (sessionKey %s): %s' % (cache_key, e))\n        return metadata\n    else:\n        return metadata"
        ]
    },
    {
        "func_name": "get_metadata_children_details",
        "original": "def get_metadata_children_details(self, rating_key='', get_children=False, media_type=None, section_id=None):\n    \"\"\"\n        Return processed and validated metadata list for all children of requested item.\n\n        Parameters required:    rating_key { Plex ratingKey }\n\n        Output: array\n        \"\"\"\n    if media_type == 'artist':\n        sort_type = '&artist.id={}&type=9'.format(rating_key)\n        xml_head = self.fetch_library_list(section_id=str(section_id), sort_type=sort_type, output_format='xml')\n    else:\n        metadata = self.get_metadata_children(str(rating_key), output_format='xml')\n        try:\n            xml_head = metadata.getElementsByTagName('MediaContainer')\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_metadata_children: %s.' % e)\n            return []\n    metadata_list = []\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                return metadata_list\n        if a.getElementsByTagName('Video'):\n            metadata_main = a.getElementsByTagName('Video')\n            for item in metadata_main:\n                child_rating_key = helpers.get_xml_attr(item, 'ratingKey')\n                metadata = self.get_metadata_details(str(child_rating_key))\n                if metadata:\n                    metadata_list.append(metadata)\n        elif a.getElementsByTagName('Track'):\n            metadata_main = a.getElementsByTagName('Track')\n            for item in metadata_main:\n                child_rating_key = helpers.get_xml_attr(item, 'ratingKey')\n                metadata = self.get_metadata_details(str(child_rating_key))\n                if metadata:\n                    metadata_list.append(metadata)\n        elif get_children and a.getElementsByTagName('Directory'):\n            dir_main = a.getElementsByTagName('Directory')\n            metadata_main = [d for d in dir_main if helpers.get_xml_attr(d, 'ratingKey')]\n            for item in metadata_main:\n                child_rating_key = helpers.get_xml_attr(item, 'ratingKey')\n                metadata = self.get_metadata_children_details(str(child_rating_key), get_children)\n                if metadata:\n                    metadata_list.extend(metadata)\n    return metadata_list",
        "mutated": [
            "def get_metadata_children_details(self, rating_key='', get_children=False, media_type=None, section_id=None):\n    if False:\n        i = 10\n    '\\n        Return processed and validated metadata list for all children of requested item.\\n\\n        Parameters required:    rating_key { Plex ratingKey }\\n\\n        Output: array\\n        '\n    if media_type == 'artist':\n        sort_type = '&artist.id={}&type=9'.format(rating_key)\n        xml_head = self.fetch_library_list(section_id=str(section_id), sort_type=sort_type, output_format='xml')\n    else:\n        metadata = self.get_metadata_children(str(rating_key), output_format='xml')\n        try:\n            xml_head = metadata.getElementsByTagName('MediaContainer')\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_metadata_children: %s.' % e)\n            return []\n    metadata_list = []\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                return metadata_list\n        if a.getElementsByTagName('Video'):\n            metadata_main = a.getElementsByTagName('Video')\n            for item in metadata_main:\n                child_rating_key = helpers.get_xml_attr(item, 'ratingKey')\n                metadata = self.get_metadata_details(str(child_rating_key))\n                if metadata:\n                    metadata_list.append(metadata)\n        elif a.getElementsByTagName('Track'):\n            metadata_main = a.getElementsByTagName('Track')\n            for item in metadata_main:\n                child_rating_key = helpers.get_xml_attr(item, 'ratingKey')\n                metadata = self.get_metadata_details(str(child_rating_key))\n                if metadata:\n                    metadata_list.append(metadata)\n        elif get_children and a.getElementsByTagName('Directory'):\n            dir_main = a.getElementsByTagName('Directory')\n            metadata_main = [d for d in dir_main if helpers.get_xml_attr(d, 'ratingKey')]\n            for item in metadata_main:\n                child_rating_key = helpers.get_xml_attr(item, 'ratingKey')\n                metadata = self.get_metadata_children_details(str(child_rating_key), get_children)\n                if metadata:\n                    metadata_list.extend(metadata)\n    return metadata_list",
            "def get_metadata_children_details(self, rating_key='', get_children=False, media_type=None, section_id=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Return processed and validated metadata list for all children of requested item.\\n\\n        Parameters required:    rating_key { Plex ratingKey }\\n\\n        Output: array\\n        '\n    if media_type == 'artist':\n        sort_type = '&artist.id={}&type=9'.format(rating_key)\n        xml_head = self.fetch_library_list(section_id=str(section_id), sort_type=sort_type, output_format='xml')\n    else:\n        metadata = self.get_metadata_children(str(rating_key), output_format='xml')\n        try:\n            xml_head = metadata.getElementsByTagName('MediaContainer')\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_metadata_children: %s.' % e)\n            return []\n    metadata_list = []\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                return metadata_list\n        if a.getElementsByTagName('Video'):\n            metadata_main = a.getElementsByTagName('Video')\n            for item in metadata_main:\n                child_rating_key = helpers.get_xml_attr(item, 'ratingKey')\n                metadata = self.get_metadata_details(str(child_rating_key))\n                if metadata:\n                    metadata_list.append(metadata)\n        elif a.getElementsByTagName('Track'):\n            metadata_main = a.getElementsByTagName('Track')\n            for item in metadata_main:\n                child_rating_key = helpers.get_xml_attr(item, 'ratingKey')\n                metadata = self.get_metadata_details(str(child_rating_key))\n                if metadata:\n                    metadata_list.append(metadata)\n        elif get_children and a.getElementsByTagName('Directory'):\n            dir_main = a.getElementsByTagName('Directory')\n            metadata_main = [d for d in dir_main if helpers.get_xml_attr(d, 'ratingKey')]\n            for item in metadata_main:\n                child_rating_key = helpers.get_xml_attr(item, 'ratingKey')\n                metadata = self.get_metadata_children_details(str(child_rating_key), get_children)\n                if metadata:\n                    metadata_list.extend(metadata)\n    return metadata_list",
            "def get_metadata_children_details(self, rating_key='', get_children=False, media_type=None, section_id=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Return processed and validated metadata list for all children of requested item.\\n\\n        Parameters required:    rating_key { Plex ratingKey }\\n\\n        Output: array\\n        '\n    if media_type == 'artist':\n        sort_type = '&artist.id={}&type=9'.format(rating_key)\n        xml_head = self.fetch_library_list(section_id=str(section_id), sort_type=sort_type, output_format='xml')\n    else:\n        metadata = self.get_metadata_children(str(rating_key), output_format='xml')\n        try:\n            xml_head = metadata.getElementsByTagName('MediaContainer')\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_metadata_children: %s.' % e)\n            return []\n    metadata_list = []\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                return metadata_list\n        if a.getElementsByTagName('Video'):\n            metadata_main = a.getElementsByTagName('Video')\n            for item in metadata_main:\n                child_rating_key = helpers.get_xml_attr(item, 'ratingKey')\n                metadata = self.get_metadata_details(str(child_rating_key))\n                if metadata:\n                    metadata_list.append(metadata)\n        elif a.getElementsByTagName('Track'):\n            metadata_main = a.getElementsByTagName('Track')\n            for item in metadata_main:\n                child_rating_key = helpers.get_xml_attr(item, 'ratingKey')\n                metadata = self.get_metadata_details(str(child_rating_key))\n                if metadata:\n                    metadata_list.append(metadata)\n        elif get_children and a.getElementsByTagName('Directory'):\n            dir_main = a.getElementsByTagName('Directory')\n            metadata_main = [d for d in dir_main if helpers.get_xml_attr(d, 'ratingKey')]\n            for item in metadata_main:\n                child_rating_key = helpers.get_xml_attr(item, 'ratingKey')\n                metadata = self.get_metadata_children_details(str(child_rating_key), get_children)\n                if metadata:\n                    metadata_list.extend(metadata)\n    return metadata_list",
            "def get_metadata_children_details(self, rating_key='', get_children=False, media_type=None, section_id=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Return processed and validated metadata list for all children of requested item.\\n\\n        Parameters required:    rating_key { Plex ratingKey }\\n\\n        Output: array\\n        '\n    if media_type == 'artist':\n        sort_type = '&artist.id={}&type=9'.format(rating_key)\n        xml_head = self.fetch_library_list(section_id=str(section_id), sort_type=sort_type, output_format='xml')\n    else:\n        metadata = self.get_metadata_children(str(rating_key), output_format='xml')\n        try:\n            xml_head = metadata.getElementsByTagName('MediaContainer')\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_metadata_children: %s.' % e)\n            return []\n    metadata_list = []\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                return metadata_list\n        if a.getElementsByTagName('Video'):\n            metadata_main = a.getElementsByTagName('Video')\n            for item in metadata_main:\n                child_rating_key = helpers.get_xml_attr(item, 'ratingKey')\n                metadata = self.get_metadata_details(str(child_rating_key))\n                if metadata:\n                    metadata_list.append(metadata)\n        elif a.getElementsByTagName('Track'):\n            metadata_main = a.getElementsByTagName('Track')\n            for item in metadata_main:\n                child_rating_key = helpers.get_xml_attr(item, 'ratingKey')\n                metadata = self.get_metadata_details(str(child_rating_key))\n                if metadata:\n                    metadata_list.append(metadata)\n        elif get_children and a.getElementsByTagName('Directory'):\n            dir_main = a.getElementsByTagName('Directory')\n            metadata_main = [d for d in dir_main if helpers.get_xml_attr(d, 'ratingKey')]\n            for item in metadata_main:\n                child_rating_key = helpers.get_xml_attr(item, 'ratingKey')\n                metadata = self.get_metadata_children_details(str(child_rating_key), get_children)\n                if metadata:\n                    metadata_list.extend(metadata)\n    return metadata_list",
            "def get_metadata_children_details(self, rating_key='', get_children=False, media_type=None, section_id=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Return processed and validated metadata list for all children of requested item.\\n\\n        Parameters required:    rating_key { Plex ratingKey }\\n\\n        Output: array\\n        '\n    if media_type == 'artist':\n        sort_type = '&artist.id={}&type=9'.format(rating_key)\n        xml_head = self.fetch_library_list(section_id=str(section_id), sort_type=sort_type, output_format='xml')\n    else:\n        metadata = self.get_metadata_children(str(rating_key), output_format='xml')\n        try:\n            xml_head = metadata.getElementsByTagName('MediaContainer')\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_metadata_children: %s.' % e)\n            return []\n    metadata_list = []\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                return metadata_list\n        if a.getElementsByTagName('Video'):\n            metadata_main = a.getElementsByTagName('Video')\n            for item in metadata_main:\n                child_rating_key = helpers.get_xml_attr(item, 'ratingKey')\n                metadata = self.get_metadata_details(str(child_rating_key))\n                if metadata:\n                    metadata_list.append(metadata)\n        elif a.getElementsByTagName('Track'):\n            metadata_main = a.getElementsByTagName('Track')\n            for item in metadata_main:\n                child_rating_key = helpers.get_xml_attr(item, 'ratingKey')\n                metadata = self.get_metadata_details(str(child_rating_key))\n                if metadata:\n                    metadata_list.append(metadata)\n        elif get_children and a.getElementsByTagName('Directory'):\n            dir_main = a.getElementsByTagName('Directory')\n            metadata_main = [d for d in dir_main if helpers.get_xml_attr(d, 'ratingKey')]\n            for item in metadata_main:\n                child_rating_key = helpers.get_xml_attr(item, 'ratingKey')\n                metadata = self.get_metadata_children_details(str(child_rating_key), get_children)\n                if metadata:\n                    metadata_list.extend(metadata)\n    return metadata_list"
        ]
    },
    {
        "func_name": "get_library_metadata_details",
        "original": "def get_library_metadata_details(self, section_id=''):\n    \"\"\"\n        Return processed and validated metadata list for requested library.\n\n        Parameters required:    section_id { Plex library key }\n\n        Output: array\n        \"\"\"\n    libraries_data = self.get_libraries_list(output_format='xml')\n    try:\n        xml_head = libraries_data.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_library_metadata_details: %s.' % e)\n        return []\n    metadata_list = []\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                metadata_list = {'metadata': None}\n                return metadata_list\n        if a.getElementsByTagName('Directory'):\n            result_data = a.getElementsByTagName('Directory')\n            for result in result_data:\n                key = helpers.get_xml_attr(result, 'key')\n                if key == section_id:\n                    metadata = {'media_type': 'library', 'section_id': helpers.get_xml_attr(result, 'key'), 'library': helpers.get_xml_attr(result, 'type'), 'title': helpers.get_xml_attr(result, 'title'), 'art': helpers.get_xml_attr(result, 'art'), 'thumb': helpers.get_xml_attr(result, 'thumb')}\n                    if metadata['library'] == 'movie':\n                        metadata['section_type'] = 'movie'\n                    elif metadata['library'] == 'show':\n                        metadata['section_type'] = 'episode'\n                    elif metadata['library'] == 'artist':\n                        metadata['section_type'] = 'track'\n        metadata_list = {'metadata': metadata}\n    return metadata_list",
        "mutated": [
            "def get_library_metadata_details(self, section_id=''):\n    if False:\n        i = 10\n    '\\n        Return processed and validated metadata list for requested library.\\n\\n        Parameters required:    section_id { Plex library key }\\n\\n        Output: array\\n        '\n    libraries_data = self.get_libraries_list(output_format='xml')\n    try:\n        xml_head = libraries_data.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_library_metadata_details: %s.' % e)\n        return []\n    metadata_list = []\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                metadata_list = {'metadata': None}\n                return metadata_list\n        if a.getElementsByTagName('Directory'):\n            result_data = a.getElementsByTagName('Directory')\n            for result in result_data:\n                key = helpers.get_xml_attr(result, 'key')\n                if key == section_id:\n                    metadata = {'media_type': 'library', 'section_id': helpers.get_xml_attr(result, 'key'), 'library': helpers.get_xml_attr(result, 'type'), 'title': helpers.get_xml_attr(result, 'title'), 'art': helpers.get_xml_attr(result, 'art'), 'thumb': helpers.get_xml_attr(result, 'thumb')}\n                    if metadata['library'] == 'movie':\n                        metadata['section_type'] = 'movie'\n                    elif metadata['library'] == 'show':\n                        metadata['section_type'] = 'episode'\n                    elif metadata['library'] == 'artist':\n                        metadata['section_type'] = 'track'\n        metadata_list = {'metadata': metadata}\n    return metadata_list",
            "def get_library_metadata_details(self, section_id=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Return processed and validated metadata list for requested library.\\n\\n        Parameters required:    section_id { Plex library key }\\n\\n        Output: array\\n        '\n    libraries_data = self.get_libraries_list(output_format='xml')\n    try:\n        xml_head = libraries_data.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_library_metadata_details: %s.' % e)\n        return []\n    metadata_list = []\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                metadata_list = {'metadata': None}\n                return metadata_list\n        if a.getElementsByTagName('Directory'):\n            result_data = a.getElementsByTagName('Directory')\n            for result in result_data:\n                key = helpers.get_xml_attr(result, 'key')\n                if key == section_id:\n                    metadata = {'media_type': 'library', 'section_id': helpers.get_xml_attr(result, 'key'), 'library': helpers.get_xml_attr(result, 'type'), 'title': helpers.get_xml_attr(result, 'title'), 'art': helpers.get_xml_attr(result, 'art'), 'thumb': helpers.get_xml_attr(result, 'thumb')}\n                    if metadata['library'] == 'movie':\n                        metadata['section_type'] = 'movie'\n                    elif metadata['library'] == 'show':\n                        metadata['section_type'] = 'episode'\n                    elif metadata['library'] == 'artist':\n                        metadata['section_type'] = 'track'\n        metadata_list = {'metadata': metadata}\n    return metadata_list",
            "def get_library_metadata_details(self, section_id=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Return processed and validated metadata list for requested library.\\n\\n        Parameters required:    section_id { Plex library key }\\n\\n        Output: array\\n        '\n    libraries_data = self.get_libraries_list(output_format='xml')\n    try:\n        xml_head = libraries_data.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_library_metadata_details: %s.' % e)\n        return []\n    metadata_list = []\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                metadata_list = {'metadata': None}\n                return metadata_list\n        if a.getElementsByTagName('Directory'):\n            result_data = a.getElementsByTagName('Directory')\n            for result in result_data:\n                key = helpers.get_xml_attr(result, 'key')\n                if key == section_id:\n                    metadata = {'media_type': 'library', 'section_id': helpers.get_xml_attr(result, 'key'), 'library': helpers.get_xml_attr(result, 'type'), 'title': helpers.get_xml_attr(result, 'title'), 'art': helpers.get_xml_attr(result, 'art'), 'thumb': helpers.get_xml_attr(result, 'thumb')}\n                    if metadata['library'] == 'movie':\n                        metadata['section_type'] = 'movie'\n                    elif metadata['library'] == 'show':\n                        metadata['section_type'] = 'episode'\n                    elif metadata['library'] == 'artist':\n                        metadata['section_type'] = 'track'\n        metadata_list = {'metadata': metadata}\n    return metadata_list",
            "def get_library_metadata_details(self, section_id=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Return processed and validated metadata list for requested library.\\n\\n        Parameters required:    section_id { Plex library key }\\n\\n        Output: array\\n        '\n    libraries_data = self.get_libraries_list(output_format='xml')\n    try:\n        xml_head = libraries_data.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_library_metadata_details: %s.' % e)\n        return []\n    metadata_list = []\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                metadata_list = {'metadata': None}\n                return metadata_list\n        if a.getElementsByTagName('Directory'):\n            result_data = a.getElementsByTagName('Directory')\n            for result in result_data:\n                key = helpers.get_xml_attr(result, 'key')\n                if key == section_id:\n                    metadata = {'media_type': 'library', 'section_id': helpers.get_xml_attr(result, 'key'), 'library': helpers.get_xml_attr(result, 'type'), 'title': helpers.get_xml_attr(result, 'title'), 'art': helpers.get_xml_attr(result, 'art'), 'thumb': helpers.get_xml_attr(result, 'thumb')}\n                    if metadata['library'] == 'movie':\n                        metadata['section_type'] = 'movie'\n                    elif metadata['library'] == 'show':\n                        metadata['section_type'] = 'episode'\n                    elif metadata['library'] == 'artist':\n                        metadata['section_type'] = 'track'\n        metadata_list = {'metadata': metadata}\n    return metadata_list",
            "def get_library_metadata_details(self, section_id=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Return processed and validated metadata list for requested library.\\n\\n        Parameters required:    section_id { Plex library key }\\n\\n        Output: array\\n        '\n    libraries_data = self.get_libraries_list(output_format='xml')\n    try:\n        xml_head = libraries_data.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_library_metadata_details: %s.' % e)\n        return []\n    metadata_list = []\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                metadata_list = {'metadata': None}\n                return metadata_list\n        if a.getElementsByTagName('Directory'):\n            result_data = a.getElementsByTagName('Directory')\n            for result in result_data:\n                key = helpers.get_xml_attr(result, 'key')\n                if key == section_id:\n                    metadata = {'media_type': 'library', 'section_id': helpers.get_xml_attr(result, 'key'), 'library': helpers.get_xml_attr(result, 'type'), 'title': helpers.get_xml_attr(result, 'title'), 'art': helpers.get_xml_attr(result, 'art'), 'thumb': helpers.get_xml_attr(result, 'thumb')}\n                    if metadata['library'] == 'movie':\n                        metadata['section_type'] = 'movie'\n                    elif metadata['library'] == 'show':\n                        metadata['section_type'] = 'episode'\n                    elif metadata['library'] == 'artist':\n                        metadata['section_type'] = 'track'\n        metadata_list = {'metadata': metadata}\n    return metadata_list"
        ]
    },
    {
        "func_name": "get_current_activity",
        "original": "def get_current_activity(self, skip_cache=False):\n    \"\"\"\n        Return processed and validated session list.\n\n        Output: array\n        \"\"\"\n    session_data = self.get_sessions(output_format='xml')\n    try:\n        xml_head = session_data.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_current_activity: %s.' % e)\n        return []\n    session_list = []\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                session_list = {'stream_count': '0', 'sessions': []}\n                return session_list\n        if a.getElementsByTagName('Track'):\n            session_data = a.getElementsByTagName('Track')\n            for session_ in session_data:\n                if helpers.get_xml_attr(session_, 'guid').startswith('library://'):\n                    continue\n                session_output = self.get_session_each(session_, skip_cache=skip_cache)\n                session_list.append(session_output)\n        if a.getElementsByTagName('Video'):\n            session_data = a.getElementsByTagName('Video')\n            for session_ in session_data:\n                session_output = self.get_session_each(session_, skip_cache=skip_cache)\n                session_list.append(session_output)\n        if a.getElementsByTagName('Photo'):\n            session_data = a.getElementsByTagName('Photo')\n            for session_ in session_data:\n                session_output = self.get_session_each(session_, skip_cache=skip_cache)\n                session_list.append(session_output)\n    session_list = sorted(session_list, key=lambda k: k['session_key'])\n    output = {'stream_count': helpers.get_xml_attr(xml_head[0], 'size'), 'sessions': session.mask_session_info(session_list)}\n    return output",
        "mutated": [
            "def get_current_activity(self, skip_cache=False):\n    if False:\n        i = 10\n    '\\n        Return processed and validated session list.\\n\\n        Output: array\\n        '\n    session_data = self.get_sessions(output_format='xml')\n    try:\n        xml_head = session_data.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_current_activity: %s.' % e)\n        return []\n    session_list = []\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                session_list = {'stream_count': '0', 'sessions': []}\n                return session_list\n        if a.getElementsByTagName('Track'):\n            session_data = a.getElementsByTagName('Track')\n            for session_ in session_data:\n                if helpers.get_xml_attr(session_, 'guid').startswith('library://'):\n                    continue\n                session_output = self.get_session_each(session_, skip_cache=skip_cache)\n                session_list.append(session_output)\n        if a.getElementsByTagName('Video'):\n            session_data = a.getElementsByTagName('Video')\n            for session_ in session_data:\n                session_output = self.get_session_each(session_, skip_cache=skip_cache)\n                session_list.append(session_output)\n        if a.getElementsByTagName('Photo'):\n            session_data = a.getElementsByTagName('Photo')\n            for session_ in session_data:\n                session_output = self.get_session_each(session_, skip_cache=skip_cache)\n                session_list.append(session_output)\n    session_list = sorted(session_list, key=lambda k: k['session_key'])\n    output = {'stream_count': helpers.get_xml_attr(xml_head[0], 'size'), 'sessions': session.mask_session_info(session_list)}\n    return output",
            "def get_current_activity(self, skip_cache=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Return processed and validated session list.\\n\\n        Output: array\\n        '\n    session_data = self.get_sessions(output_format='xml')\n    try:\n        xml_head = session_data.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_current_activity: %s.' % e)\n        return []\n    session_list = []\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                session_list = {'stream_count': '0', 'sessions': []}\n                return session_list\n        if a.getElementsByTagName('Track'):\n            session_data = a.getElementsByTagName('Track')\n            for session_ in session_data:\n                if helpers.get_xml_attr(session_, 'guid').startswith('library://'):\n                    continue\n                session_output = self.get_session_each(session_, skip_cache=skip_cache)\n                session_list.append(session_output)\n        if a.getElementsByTagName('Video'):\n            session_data = a.getElementsByTagName('Video')\n            for session_ in session_data:\n                session_output = self.get_session_each(session_, skip_cache=skip_cache)\n                session_list.append(session_output)\n        if a.getElementsByTagName('Photo'):\n            session_data = a.getElementsByTagName('Photo')\n            for session_ in session_data:\n                session_output = self.get_session_each(session_, skip_cache=skip_cache)\n                session_list.append(session_output)\n    session_list = sorted(session_list, key=lambda k: k['session_key'])\n    output = {'stream_count': helpers.get_xml_attr(xml_head[0], 'size'), 'sessions': session.mask_session_info(session_list)}\n    return output",
            "def get_current_activity(self, skip_cache=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Return processed and validated session list.\\n\\n        Output: array\\n        '\n    session_data = self.get_sessions(output_format='xml')\n    try:\n        xml_head = session_data.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_current_activity: %s.' % e)\n        return []\n    session_list = []\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                session_list = {'stream_count': '0', 'sessions': []}\n                return session_list\n        if a.getElementsByTagName('Track'):\n            session_data = a.getElementsByTagName('Track')\n            for session_ in session_data:\n                if helpers.get_xml_attr(session_, 'guid').startswith('library://'):\n                    continue\n                session_output = self.get_session_each(session_, skip_cache=skip_cache)\n                session_list.append(session_output)\n        if a.getElementsByTagName('Video'):\n            session_data = a.getElementsByTagName('Video')\n            for session_ in session_data:\n                session_output = self.get_session_each(session_, skip_cache=skip_cache)\n                session_list.append(session_output)\n        if a.getElementsByTagName('Photo'):\n            session_data = a.getElementsByTagName('Photo')\n            for session_ in session_data:\n                session_output = self.get_session_each(session_, skip_cache=skip_cache)\n                session_list.append(session_output)\n    session_list = sorted(session_list, key=lambda k: k['session_key'])\n    output = {'stream_count': helpers.get_xml_attr(xml_head[0], 'size'), 'sessions': session.mask_session_info(session_list)}\n    return output",
            "def get_current_activity(self, skip_cache=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Return processed and validated session list.\\n\\n        Output: array\\n        '\n    session_data = self.get_sessions(output_format='xml')\n    try:\n        xml_head = session_data.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_current_activity: %s.' % e)\n        return []\n    session_list = []\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                session_list = {'stream_count': '0', 'sessions': []}\n                return session_list\n        if a.getElementsByTagName('Track'):\n            session_data = a.getElementsByTagName('Track')\n            for session_ in session_data:\n                if helpers.get_xml_attr(session_, 'guid').startswith('library://'):\n                    continue\n                session_output = self.get_session_each(session_, skip_cache=skip_cache)\n                session_list.append(session_output)\n        if a.getElementsByTagName('Video'):\n            session_data = a.getElementsByTagName('Video')\n            for session_ in session_data:\n                session_output = self.get_session_each(session_, skip_cache=skip_cache)\n                session_list.append(session_output)\n        if a.getElementsByTagName('Photo'):\n            session_data = a.getElementsByTagName('Photo')\n            for session_ in session_data:\n                session_output = self.get_session_each(session_, skip_cache=skip_cache)\n                session_list.append(session_output)\n    session_list = sorted(session_list, key=lambda k: k['session_key'])\n    output = {'stream_count': helpers.get_xml_attr(xml_head[0], 'size'), 'sessions': session.mask_session_info(session_list)}\n    return output",
            "def get_current_activity(self, skip_cache=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Return processed and validated session list.\\n\\n        Output: array\\n        '\n    session_data = self.get_sessions(output_format='xml')\n    try:\n        xml_head = session_data.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_current_activity: %s.' % e)\n        return []\n    session_list = []\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                session_list = {'stream_count': '0', 'sessions': []}\n                return session_list\n        if a.getElementsByTagName('Track'):\n            session_data = a.getElementsByTagName('Track')\n            for session_ in session_data:\n                if helpers.get_xml_attr(session_, 'guid').startswith('library://'):\n                    continue\n                session_output = self.get_session_each(session_, skip_cache=skip_cache)\n                session_list.append(session_output)\n        if a.getElementsByTagName('Video'):\n            session_data = a.getElementsByTagName('Video')\n            for session_ in session_data:\n                session_output = self.get_session_each(session_, skip_cache=skip_cache)\n                session_list.append(session_output)\n        if a.getElementsByTagName('Photo'):\n            session_data = a.getElementsByTagName('Photo')\n            for session_ in session_data:\n                session_output = self.get_session_each(session_, skip_cache=skip_cache)\n                session_list.append(session_output)\n    session_list = sorted(session_list, key=lambda k: k['session_key'])\n    output = {'stream_count': helpers.get_xml_attr(xml_head[0], 'size'), 'sessions': session.mask_session_info(session_list)}\n    return output"
        ]
    },
    {
        "func_name": "get_session_each",
        "original": "def get_session_each(self, session=None, skip_cache=False):\n    \"\"\"\n        Return selected data from current sessions.\n        This function processes and validates session data\n\n        Parameters required:    session { the session dictionary }\n        Output: dict\n        \"\"\"\n    media_type = helpers.get_xml_attr(session, 'type')\n    rating_key = helpers.get_xml_attr(session, 'ratingKey')\n    session_key = helpers.get_xml_attr(session, 'sessionKey')\n    user_info = session.getElementsByTagName('User')[0]\n    user_id = helpers.get_xml_attr(user_info, 'id')\n    if user_id == '1':\n        user_details = users.Users().get_details(user=helpers.get_xml_attr(user_info, 'title'))\n    else:\n        user_details = users.Users().get_details(user_id=user_id)\n    player_info = session.getElementsByTagName('Player')[0]\n    platform = helpers.get_xml_attr(player_info, 'platform')\n    platform = common.PLATFORM_NAME_OVERRIDES.get(platform, platform)\n    if not platform and helpers.get_xml_attr(player_info, 'product') == 'DLNA':\n        platform = 'DLNA'\n    platform_name = next((v for (k, v) in common.PLATFORM_NAMES.items() if k in platform.lower()), 'default')\n    player_details = {'ip_address': helpers.get_xml_attr(player_info, 'address').split('::ffff:')[-1], 'ip_address_public': helpers.get_xml_attr(player_info, 'remotePublicAddress').split('::ffff:')[-1], 'device': helpers.get_xml_attr(player_info, 'device'), 'platform': platform, 'platform_name': platform_name, 'platform_version': helpers.get_xml_attr(player_info, 'platformVersion'), 'product': helpers.get_xml_attr(player_info, 'product'), 'product_version': helpers.get_xml_attr(player_info, 'version'), 'profile': helpers.get_xml_attr(player_info, 'profile'), 'player': helpers.get_xml_attr(player_info, 'title') or helpers.get_xml_attr(player_info, 'product'), 'machine_id': helpers.get_xml_attr(player_info, 'machineIdentifier'), 'state': helpers.get_xml_attr(player_info, 'state'), 'local': int(helpers.get_xml_attr(player_info, 'local') == '1'), 'relayed': helpers.get_xml_attr(player_info, 'relayed', default_return=None), 'secure': helpers.get_xml_attr(player_info, 'secure', default_return=None)}\n    if session.getElementsByTagName('Session'):\n        session_info = session.getElementsByTagName('Session')[0]\n        session_details = {'session_id': helpers.get_xml_attr(session_info, 'id'), 'bandwidth': helpers.get_xml_attr(session_info, 'bandwidth'), 'location': helpers.get_xml_attr(session_info, 'location')}\n    else:\n        session_details = {'session_id': '', 'bandwidth': '', 'location': 'lan' if player_details['local'] else 'wan'}\n    if player_details['relayed'] is None:\n        player_details['relayed'] = int(session_details['location'] != 'lan' and player_details['ip_address_public'] == '127.0.0.1')\n    else:\n        player_details['relayed'] = helpers.cast_to_int(player_details['relayed'])\n    if player_details['secure'] is not None:\n        player_details['secure'] = int(player_details['secure'] == '1')\n    if session.getElementsByTagName('TranscodeSession'):\n        transcode_session = True\n        transcode_info = session.getElementsByTagName('TranscodeSession')[0]\n        transcode_progress = helpers.get_xml_attr(transcode_info, 'progress')\n        transcode_speed = helpers.get_xml_attr(transcode_info, 'speed')\n        transcode_min_offset = helpers.get_xml_attr(transcode_info, 'minOffsetAvailable')\n        transcode_max_offset = helpers.get_xml_attr(transcode_info, 'maxOffsetAvailable')\n        transcode_details = {'transcode_key': helpers.get_xml_attr(transcode_info, 'key'), 'transcode_throttled': int(helpers.get_xml_attr(transcode_info, 'throttled') == '1'), 'transcode_progress': int(round(helpers.cast_to_float(transcode_progress), 0)), 'transcode_speed': str(round(helpers.cast_to_float(transcode_speed), 1)), 'transcode_audio_channels': helpers.get_xml_attr(transcode_info, 'audioChannels'), 'transcode_audio_codec': helpers.get_xml_attr(transcode_info, 'audioCodec'), 'transcode_video_codec': helpers.get_xml_attr(transcode_info, 'videoCodec'), 'transcode_width': helpers.get_xml_attr(transcode_info, 'width'), 'transcode_height': helpers.get_xml_attr(transcode_info, 'height'), 'transcode_container': helpers.get_xml_attr(transcode_info, 'container'), 'transcode_protocol': helpers.get_xml_attr(transcode_info, 'protocol'), 'transcode_min_offset_available': int(round(helpers.cast_to_float(transcode_min_offset), 0)), 'transcode_max_offset_available': int(round(helpers.cast_to_float(transcode_max_offset), 0)), 'transcode_hw_requested': int(helpers.get_xml_attr(transcode_info, 'transcodeHwRequested') == '1'), 'transcode_hw_decode': helpers.get_xml_attr(transcode_info, 'transcodeHwDecoding'), 'transcode_hw_decode_title': helpers.get_xml_attr(transcode_info, 'transcodeHwDecodingTitle'), 'transcode_hw_encode': helpers.get_xml_attr(transcode_info, 'transcodeHwEncoding'), 'transcode_hw_encode_title': helpers.get_xml_attr(transcode_info, 'transcodeHwEncodingTitle'), 'transcode_hw_full_pipeline': int(helpers.get_xml_attr(transcode_info, 'transcodeHwFullPipeline') == '1'), 'audio_decision': helpers.get_xml_attr(transcode_info, 'audioDecision'), 'video_decision': helpers.get_xml_attr(transcode_info, 'videoDecision'), 'subtitle_decision': helpers.get_xml_attr(transcode_info, 'subtitleDecision'), 'throttled': '1' if helpers.get_xml_attr(transcode_info, 'throttled') == '1' else '0'}\n    else:\n        transcode_session = False\n        transcode_details = {'transcode_key': '', 'transcode_throttled': 0, 'transcode_progress': 0, 'transcode_speed': '', 'transcode_audio_channels': '', 'transcode_audio_codec': '', 'transcode_video_codec': '', 'transcode_width': '', 'transcode_height': '', 'transcode_container': '', 'transcode_protocol': '', 'transcode_min_offset_available': 0, 'transcode_max_offset_available': 0, 'transcode_hw_requested': 0, 'transcode_hw_decode': '', 'transcode_hw_decode_title': '', 'transcode_hw_encode': '', 'transcode_hw_encode_title': '', 'transcode_hw_full_pipeline': 0, 'audio_decision': 'direct play', 'video_decision': 'direct play', 'subtitle_decision': '', 'throttled': '0'}\n    transcode_details['transcode_hw_decoding'] = int(transcode_details['transcode_hw_decode'].lower() in common.HW_DECODERS)\n    transcode_details['transcode_hw_encoding'] = int(transcode_details['transcode_hw_encode'].lower() in common.HW_ENCODERS)\n    media_info_all = session.getElementsByTagName('Media')\n    stream_media_info = next((m for m in media_info_all if helpers.get_xml_attr(m, 'selected') == '1'), media_info_all[0])\n    part_info_all = stream_media_info.getElementsByTagName('Part')\n    stream_media_parts_info = next((p for p in part_info_all if helpers.get_xml_attr(p, 'selected') == '1'), part_info_all[0])\n    video_stream_info = audio_stream_info = subtitle_stream_info = None\n    for stream in stream_media_parts_info.getElementsByTagName('Stream'):\n        if helpers.get_xml_attr(stream, 'streamType') == '1':\n            if video_stream_info is None or helpers.get_xml_attr(stream, 'selected') == '1':\n                video_stream_info = stream\n        elif helpers.get_xml_attr(stream, 'streamType') == '2':\n            if audio_stream_info is None or helpers.get_xml_attr(stream, 'selected') == '1':\n                audio_stream_info = stream\n        elif helpers.get_xml_attr(stream, 'streamType') == '3':\n            if subtitle_stream_info is None or helpers.get_xml_attr(stream, 'selected') == '1':\n                subtitle_stream_info = stream\n    video_id = audio_id = subtitle_id = None\n    if video_stream_info:\n        video_id = helpers.get_xml_attr(video_stream_info, 'id')\n        video_details = {'stream_video_bitrate': helpers.get_xml_attr(video_stream_info, 'bitrate'), 'stream_video_bit_depth': helpers.get_xml_attr(video_stream_info, 'bitDepth'), 'stream_video_chroma_subsampling': helpers.get_xml_attr(video_stream_info, 'chromaSubsampling'), 'stream_video_codec': helpers.get_xml_attr(video_stream_info, 'codec'), 'stream_video_codec_level': helpers.get_xml_attr(video_stream_info, 'level'), 'stream_video_color_primaries': helpers.get_xml_attr(video_stream_info, 'colorPrimaries'), 'stream_video_color_range': helpers.get_xml_attr(video_stream_info, 'colorRange'), 'stream_video_color_space': helpers.get_xml_attr(video_stream_info, 'colorSpace'), 'stream_video_color_trc': helpers.get_xml_attr(video_stream_info, 'colorTrc'), 'stream_video_dynamic_range': self.get_dynamic_range(video_stream_info), 'stream_video_height': helpers.get_xml_attr(video_stream_info, 'height'), 'stream_video_width': helpers.get_xml_attr(video_stream_info, 'width'), 'stream_video_ref_frames': helpers.get_xml_attr(video_stream_info, 'refFrames'), 'stream_video_language': helpers.get_xml_attr(video_stream_info, 'language'), 'stream_video_language_code': helpers.get_xml_attr(video_stream_info, 'languageCode'), 'stream_video_scan_type': helpers.get_xml_attr(video_stream_info, 'scanType'), 'stream_video_decision': helpers.get_xml_attr(video_stream_info, 'decision') or 'direct play'}\n    else:\n        video_details = {'stream_video_bitrate': '', 'stream_video_bit_depth': '', 'stream_video_chroma_subsampling': '', 'stream_video_codec': '', 'stream_video_codec_level': '', 'stream_video_color_primaries': '', 'stream_video_color_range': '', 'stream_video_color_space': '', 'stream_video_color_trc': '', 'stream_video_dynamic_range': '', 'stream_video_height': '', 'stream_video_width': '', 'stream_video_ref_frames': '', 'stream_video_language': '', 'stream_video_language_code': '', 'stream_video_scan_type': '', 'stream_video_decision': ''}\n    if audio_stream_info:\n        audio_id = helpers.get_xml_attr(audio_stream_info, 'id')\n        stream_audio_channels = helpers.get_xml_attr(audio_stream_info, 'channels')\n        stream_audio_channel_layouts_ = helpers.get_xml_attr(audio_stream_info, 'audioChannelLayout')\n        audio_details = {'stream_audio_bitrate': helpers.get_xml_attr(audio_stream_info, 'bitrate'), 'stream_audio_bitrate_mode': helpers.get_xml_attr(audio_stream_info, 'bitrateMode'), 'stream_audio_channels': stream_audio_channels, 'stream_audio_channel_layout': stream_audio_channel_layouts_ or common.AUDIO_CHANNELS.get(stream_audio_channels, stream_audio_channels), 'stream_audio_codec': helpers.get_xml_attr(audio_stream_info, 'codec'), 'stream_audio_sample_rate': helpers.get_xml_attr(audio_stream_info, 'samplingRate'), 'stream_audio_channel_layout_': stream_audio_channel_layouts_, 'stream_audio_language': helpers.get_xml_attr(audio_stream_info, 'language'), 'stream_audio_language_code': helpers.get_xml_attr(audio_stream_info, 'languageCode'), 'stream_audio_decision': helpers.get_xml_attr(audio_stream_info, 'decision') or 'direct play'}\n    else:\n        audio_details = {'stream_audio_bitrate': '', 'stream_audio_bitrate_mode': '', 'stream_audio_channels': '', 'stream_audio_channel_layout': '', 'stream_audio_codec': '', 'stream_audio_sample_rate': '', 'stream_audio_channel_layout_': '', 'stream_audio_language': '', 'stream_audio_language_code': '', 'stream_audio_decision': ''}\n    if subtitle_stream_info:\n        subtitle_id = helpers.get_xml_attr(subtitle_stream_info, 'id')\n        subtitle_selected = helpers.get_xml_attr(subtitle_stream_info, 'selected')\n        subtitle_details = {'stream_subtitle_codec': helpers.get_xml_attr(subtitle_stream_info, 'codec'), 'stream_subtitle_container': helpers.get_xml_attr(subtitle_stream_info, 'container'), 'stream_subtitle_format': helpers.get_xml_attr(subtitle_stream_info, 'format'), 'stream_subtitle_forced': int(helpers.get_xml_attr(subtitle_stream_info, 'forced') == '1'), 'stream_subtitle_location': helpers.get_xml_attr(subtitle_stream_info, 'location'), 'stream_subtitle_language': helpers.get_xml_attr(subtitle_stream_info, 'language'), 'stream_subtitle_language_code': helpers.get_xml_attr(subtitle_stream_info, 'languageCode'), 'stream_subtitle_decision': helpers.get_xml_attr(subtitle_stream_info, 'decision') or transcode_details['subtitle_decision'], 'stream_subtitle_transient': int(helpers.get_xml_attr(subtitle_stream_info, 'transient') == '1')}\n    else:\n        subtitle_selected = None\n        subtitle_details = {'stream_subtitle_codec': '', 'stream_subtitle_container': '', 'stream_subtitle_format': '', 'stream_subtitle_forced': 0, 'stream_subtitle_location': '', 'stream_subtitle_language': '', 'stream_subtitle_language_code': '', 'stream_subtitle_decision': '', 'stream_subtitle_transient': 0}\n    indexes = helpers.get_xml_attr(stream_media_parts_info, 'indexes')\n    view_offset = helpers.get_xml_attr(session, 'viewOffset')\n    if indexes == 'sd':\n        part_id = helpers.get_xml_attr(stream_media_parts_info, 'id')\n        bif_thumb = '/library/parts/{part_id}/indexes/sd/{view_offset}'.format(part_id=part_id, view_offset=view_offset)\n    else:\n        bif_thumb = ''\n    if helpers.cast_to_int(video_details['stream_video_width']) >= 3840:\n        stream_video_resolution = '4k'\n    else:\n        stream_video_resolution = helpers.get_xml_attr(stream_media_info, 'videoResolution').lower().rstrip('ip')\n    stream_details = {'stream_container': helpers.get_xml_attr(stream_media_info, 'container'), 'stream_bitrate': helpers.get_xml_attr(stream_media_info, 'bitrate'), 'stream_aspect_ratio': helpers.get_xml_attr(stream_media_info, 'aspectRatio'), 'stream_video_framerate': helpers.get_xml_attr(stream_media_info, 'videoFrameRate'), 'stream_video_resolution': stream_video_resolution, 'stream_duration': helpers.get_xml_attr(stream_media_info, 'duration') or helpers.get_xml_attr(session, 'duration'), 'stream_container_decision': helpers.get_xml_attr(stream_media_parts_info, 'decision').replace('directplay', 'direct play'), 'optimized_version': int(helpers.get_xml_attr(stream_media_info, 'proxyType') == '42'), 'optimized_version_title': helpers.get_xml_attr(stream_media_info, 'title'), 'synced_version': 0, 'live': int(helpers.get_xml_attr(session, 'live') == '1'), 'live_uuid': helpers.get_xml_attr(stream_media_info, 'uuid'), 'indexes': int(indexes == 'sd'), 'bif_thumb': bif_thumb, 'subtitles': 1 if subtitle_id and subtitle_selected else 0}\n    source_media_details = source_media_part_details = source_video_details = source_audio_details = source_subtitle_details = {}\n    if not helpers.get_xml_attr(session, 'ratingKey').isdigit():\n        channel_stream = 1\n        audio_channels = helpers.get_xml_attr(stream_media_info, 'audioChannels')\n        metadata_details = {'media_type': media_type, 'section_id': helpers.get_xml_attr(session, 'librarySectionID'), 'library_name': helpers.get_xml_attr(session, 'librarySectionTitle'), 'rating_key': helpers.get_xml_attr(session, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(session, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(session, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(session, 'title'), 'parent_title': helpers.get_xml_attr(session, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(session, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(session, 'originalTitle'), 'sort_title': helpers.get_xml_attr(session, 'titleSort'), 'media_index': helpers.get_xml_attr(session, 'index'), 'parent_media_index': helpers.get_xml_attr(session, 'parentIndex'), 'studio': helpers.get_xml_attr(session, 'studio'), 'content_rating': helpers.get_xml_attr(session, 'contentRating'), 'summary': helpers.get_xml_attr(session, 'summary'), 'tagline': helpers.get_xml_attr(session, 'tagline'), 'rating': helpers.get_xml_attr(session, 'rating'), 'rating_image': helpers.get_xml_attr(session, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(session, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(session, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(session, 'userRating'), 'duration': helpers.get_xml_attr(session, 'duration'), 'year': helpers.get_xml_attr(session, 'year'), 'thumb': helpers.get_xml_attr(session, 'thumb'), 'parent_thumb': helpers.get_xml_attr(session, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(session, 'grandparentThumb'), 'art': helpers.get_xml_attr(session, 'art'), 'banner': helpers.get_xml_attr(session, 'banner'), 'originally_available_at': helpers.get_xml_attr(session, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(session, 'addedAt'), 'updated_at': helpers.get_xml_attr(session, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(session, 'lastViewedAt'), 'guid': helpers.get_xml_attr(session, 'guid'), 'directors': [], 'writers': [], 'actors': [], 'genres': [], 'labels': [], 'full_title': helpers.get_xml_attr(session, 'title'), 'container': helpers.get_xml_attr(stream_media_info, 'container') or helpers.get_xml_attr(stream_media_parts_info, 'container'), 'bitrate': helpers.get_xml_attr(stream_media_info, 'bitrate'), 'height': helpers.get_xml_attr(stream_media_info, 'height'), 'width': helpers.get_xml_attr(stream_media_info, 'width'), 'aspect_ratio': helpers.get_xml_attr(stream_media_info, 'aspectRatio'), 'video_codec': helpers.get_xml_attr(stream_media_info, 'videoCodec'), 'video_resolution': helpers.get_xml_attr(stream_media_info, 'videoResolution').lower(), 'video_full_resolution': helpers.get_xml_attr(stream_media_info, 'videoResolution').lower(), 'video_framerate': helpers.get_xml_attr(stream_media_info, 'videoFrameRate'), 'video_profile': helpers.get_xml_attr(stream_media_info, 'videoProfile'), 'audio_codec': helpers.get_xml_attr(stream_media_info, 'audioCodec'), 'audio_channels': audio_channels, 'audio_channel_layout': common.AUDIO_CHANNELS.get(audio_channels, audio_channels), 'audio_profile': helpers.get_xml_attr(stream_media_info, 'audioProfile'), 'channel_icon': helpers.get_xml_attr(session, 'sourceIcon'), 'channel_title': helpers.get_xml_attr(session, 'sourceTitle'), 'extra_type': helpers.get_xml_attr(session, 'extraType'), 'sub_type': helpers.get_xml_attr(session, 'subtype')}\n    else:\n        channel_stream = 0\n        media_id = helpers.get_xml_attr(stream_media_info, 'id')\n        part_id = helpers.get_xml_attr(stream_media_parts_info, 'id')\n        metadata_details = self.get_metadata_details(rating_key=rating_key, skip_cache=skip_cache, cache_key=session_key)\n        source_medias = metadata_details.pop('media_info', [])\n        source_media_details = next((m for m in source_medias if m['id'] == media_id), next((m for m in source_medias), {}))\n        source_media_parts = source_media_details.pop('parts', [])\n        source_media_part_details = next((p for p in source_media_parts if p['id'] == part_id), next((p for p in source_media_parts), {}))\n        source_media_part_streams = source_media_part_details.pop('streams', [])\n        source_video_details = {'id': '', 'type': '', 'video_codec': '', 'video_codec_level': '', 'video_bitrate': '', 'video_bit_depth': '', 'video_chroma_subsampling': '', 'video_color_primaries': '', 'video_color_range': '', 'video_color_space': '', 'video_color_trc': '', 'video_dynamic_range': '', 'video_frame_rate': '', 'video_ref_frames': '', 'video_height': '', 'video_width': '', 'video_language': '', 'video_language_code': '', 'video_scan_type': '', 'video_profile': ''}\n        source_audio_details = {'id': '', 'type': '', 'audio_codec': '', 'audio_bitrate': '', 'audio_bitrate_mode': '', 'audio_channels': '', 'audio_channel_layout': '', 'audio_sample_rate': '', 'audio_language': '', 'audio_language_code': '', 'audio_profile': ''}\n        source_subtitle_details = {'id': '', 'type': '', 'subtitle_codec': '', 'subtitle_container': '', 'subtitle_format': '', 'subtitle_forced': 0, 'subtitle_location': '', 'subtitle_language': '', 'subtitle_language_code': ''}\n        if video_id:\n            source_video_details = next((p for p in source_media_part_streams if p['id'] == video_id), next((p for p in source_media_part_streams if p['type'] == '1'), source_video_details))\n        if audio_id:\n            source_audio_details = next((p for p in source_media_part_streams if p['id'] == audio_id), next((p for p in source_media_part_streams if p['type'] == '2'), source_audio_details))\n        if subtitle_id:\n            source_subtitle_details = next((p for p in source_media_part_streams if p['id'] == subtitle_id), next((p for p in source_media_part_streams if p['type'] == '3'), source_subtitle_details))\n    if media_type == 'clip' and metadata_details.get('extra_type') and metadata_details['art']:\n        metadata_details['thumb'] = metadata_details['art'].replace('/art', '/thumb')\n    if stream_details['live'] and transcode_session:\n        stream_details['stream_container_decision'] = 'transcode'\n        stream_details['stream_container'] = transcode_details['transcode_container']\n        video_details['stream_video_decision'] = transcode_details['video_decision']\n        video_details['stream_video_codec'] = transcode_details['transcode_video_codec']\n        audio_details['stream_audio_decision'] = transcode_details['audio_decision']\n        audio_details['stream_audio_codec'] = transcode_details['transcode_audio_codec']\n        audio_details['stream_audio_channels'] = transcode_details['transcode_audio_channels']\n        audio_details['stream_audio_channel_layout'] = common.AUDIO_CHANNELS.get(transcode_details['transcode_audio_channels'], transcode_details['transcode_audio_channels'])\n    if video_details['stream_video_decision'] == 'transcode' or audio_details['stream_audio_decision'] == 'transcode':\n        transcode_decision = 'transcode'\n    elif video_details['stream_video_decision'] == 'copy' or audio_details['stream_audio_decision'] == 'copy':\n        transcode_decision = 'copy'\n    else:\n        transcode_decision = 'direct play'\n    stream_details['transcode_decision'] = transcode_decision\n    stream_details['container_decision'] = stream_details['stream_container_decision']\n    if audio_details['stream_audio_codec'] == '*':\n        audio_details['stream_audio_codec'] = source_audio_details.get('audio_codec', '')\n    if transcode_details['transcode_audio_codec'] == '*':\n        transcode_details['transcode_audio_codec'] = source_audio_details.get('audio_codec', '')\n    if video_details['stream_video_codec'] == '*':\n        video_details['stream_video_codec'] = source_video_details.get('video_codec', '')\n    if transcode_details['transcode_video_codec'] == '*':\n        transcode_details['transcode_video_codec'] = source_video_details.get('video_codec', '')\n    if media_type in ('movie', 'episode', 'clip'):\n        stream_details['stream_video_full_resolution'] = common.VIDEO_RESOLUTION_OVERRIDES.get(stream_details['stream_video_resolution'], stream_details['stream_video_resolution'] + (video_details['stream_video_scan_type'][:1] or 'p'))\n    if media_type in ('movie', 'episode', 'clip') and 'stream_bitrate' in stream_details:\n        if video_details['stream_video_decision'] == 'transcode':\n            synced_version_profile = ''\n            stream_bitrate = helpers.cast_to_int(stream_details['stream_bitrate'])\n            source_bitrate = helpers.cast_to_int(source_media_details.get('bitrate'))\n            try:\n                quailtiy_bitrate = min((b for b in common.VIDEO_QUALITY_PROFILES if stream_bitrate <= b <= source_bitrate))\n                quality_profile = common.VIDEO_QUALITY_PROFILES[quailtiy_bitrate]\n            except ValueError:\n                quality_profile = 'Original'\n        else:\n            synced_version_profile = ''\n            quality_profile = 'Original'\n        if stream_details['optimized_version']:\n            source_bitrate = helpers.cast_to_int(source_media_details.get('bitrate'))\n            optimized_version_profile = '{} Mbps {}'.format(round(source_bitrate / 1000.0, 1), source_media_details.get('video_full_resolution'))\n        else:\n            optimized_version_profile = ''\n    elif media_type == 'track' and 'stream_bitrate' in stream_details:\n        synced_version_profile = ''\n        stream_bitrate = helpers.cast_to_int(stream_details['stream_bitrate'])\n        source_bitrate = helpers.cast_to_int(source_media_details.get('bitrate'))\n        try:\n            quailtiy_bitrate = min((b for b in common.AUDIO_QUALITY_PROFILES if stream_bitrate <= b <= source_bitrate))\n            quality_profile = common.AUDIO_QUALITY_PROFILES[quailtiy_bitrate]\n        except ValueError:\n            quality_profile = 'Original'\n        optimized_version_profile = ''\n    elif media_type == 'photo':\n        quality_profile = 'Original'\n        synced_version_profile = ''\n        optimized_version_profile = ''\n    else:\n        quality_profile = 'Unknown'\n        synced_version_profile = ''\n        optimized_version_profile = ''\n    session_output = {'session_key': session_key, 'media_type': media_type, 'view_offset': view_offset, 'progress_percent': str(helpers.get_percent(view_offset, stream_details['stream_duration'])), 'quality_profile': quality_profile, 'synced_version_profile': synced_version_profile, 'optimized_version_profile': optimized_version_profile, 'user': user_details['username'], 'channel_stream': channel_stream}\n    session_output.update(metadata_details)\n    session_output.update(source_media_details)\n    session_output.update(source_media_part_details)\n    session_output.update(source_video_details)\n    session_output.update(source_audio_details)\n    session_output.update(source_subtitle_details)\n    session_output.update(user_details)\n    session_output.update(player_details)\n    session_output.update(session_details)\n    session_output.update(transcode_details)\n    session_output.update(stream_details)\n    session_output.update(video_details)\n    session_output.update(audio_details)\n    session_output.update(subtitle_details)\n    return session_output",
        "mutated": [
            "def get_session_each(self, session=None, skip_cache=False):\n    if False:\n        i = 10\n    '\\n        Return selected data from current sessions.\\n        This function processes and validates session data\\n\\n        Parameters required:    session { the session dictionary }\\n        Output: dict\\n        '\n    media_type = helpers.get_xml_attr(session, 'type')\n    rating_key = helpers.get_xml_attr(session, 'ratingKey')\n    session_key = helpers.get_xml_attr(session, 'sessionKey')\n    user_info = session.getElementsByTagName('User')[0]\n    user_id = helpers.get_xml_attr(user_info, 'id')\n    if user_id == '1':\n        user_details = users.Users().get_details(user=helpers.get_xml_attr(user_info, 'title'))\n    else:\n        user_details = users.Users().get_details(user_id=user_id)\n    player_info = session.getElementsByTagName('Player')[0]\n    platform = helpers.get_xml_attr(player_info, 'platform')\n    platform = common.PLATFORM_NAME_OVERRIDES.get(platform, platform)\n    if not platform and helpers.get_xml_attr(player_info, 'product') == 'DLNA':\n        platform = 'DLNA'\n    platform_name = next((v for (k, v) in common.PLATFORM_NAMES.items() if k in platform.lower()), 'default')\n    player_details = {'ip_address': helpers.get_xml_attr(player_info, 'address').split('::ffff:')[-1], 'ip_address_public': helpers.get_xml_attr(player_info, 'remotePublicAddress').split('::ffff:')[-1], 'device': helpers.get_xml_attr(player_info, 'device'), 'platform': platform, 'platform_name': platform_name, 'platform_version': helpers.get_xml_attr(player_info, 'platformVersion'), 'product': helpers.get_xml_attr(player_info, 'product'), 'product_version': helpers.get_xml_attr(player_info, 'version'), 'profile': helpers.get_xml_attr(player_info, 'profile'), 'player': helpers.get_xml_attr(player_info, 'title') or helpers.get_xml_attr(player_info, 'product'), 'machine_id': helpers.get_xml_attr(player_info, 'machineIdentifier'), 'state': helpers.get_xml_attr(player_info, 'state'), 'local': int(helpers.get_xml_attr(player_info, 'local') == '1'), 'relayed': helpers.get_xml_attr(player_info, 'relayed', default_return=None), 'secure': helpers.get_xml_attr(player_info, 'secure', default_return=None)}\n    if session.getElementsByTagName('Session'):\n        session_info = session.getElementsByTagName('Session')[0]\n        session_details = {'session_id': helpers.get_xml_attr(session_info, 'id'), 'bandwidth': helpers.get_xml_attr(session_info, 'bandwidth'), 'location': helpers.get_xml_attr(session_info, 'location')}\n    else:\n        session_details = {'session_id': '', 'bandwidth': '', 'location': 'lan' if player_details['local'] else 'wan'}\n    if player_details['relayed'] is None:\n        player_details['relayed'] = int(session_details['location'] != 'lan' and player_details['ip_address_public'] == '127.0.0.1')\n    else:\n        player_details['relayed'] = helpers.cast_to_int(player_details['relayed'])\n    if player_details['secure'] is not None:\n        player_details['secure'] = int(player_details['secure'] == '1')\n    if session.getElementsByTagName('TranscodeSession'):\n        transcode_session = True\n        transcode_info = session.getElementsByTagName('TranscodeSession')[0]\n        transcode_progress = helpers.get_xml_attr(transcode_info, 'progress')\n        transcode_speed = helpers.get_xml_attr(transcode_info, 'speed')\n        transcode_min_offset = helpers.get_xml_attr(transcode_info, 'minOffsetAvailable')\n        transcode_max_offset = helpers.get_xml_attr(transcode_info, 'maxOffsetAvailable')\n        transcode_details = {'transcode_key': helpers.get_xml_attr(transcode_info, 'key'), 'transcode_throttled': int(helpers.get_xml_attr(transcode_info, 'throttled') == '1'), 'transcode_progress': int(round(helpers.cast_to_float(transcode_progress), 0)), 'transcode_speed': str(round(helpers.cast_to_float(transcode_speed), 1)), 'transcode_audio_channels': helpers.get_xml_attr(transcode_info, 'audioChannels'), 'transcode_audio_codec': helpers.get_xml_attr(transcode_info, 'audioCodec'), 'transcode_video_codec': helpers.get_xml_attr(transcode_info, 'videoCodec'), 'transcode_width': helpers.get_xml_attr(transcode_info, 'width'), 'transcode_height': helpers.get_xml_attr(transcode_info, 'height'), 'transcode_container': helpers.get_xml_attr(transcode_info, 'container'), 'transcode_protocol': helpers.get_xml_attr(transcode_info, 'protocol'), 'transcode_min_offset_available': int(round(helpers.cast_to_float(transcode_min_offset), 0)), 'transcode_max_offset_available': int(round(helpers.cast_to_float(transcode_max_offset), 0)), 'transcode_hw_requested': int(helpers.get_xml_attr(transcode_info, 'transcodeHwRequested') == '1'), 'transcode_hw_decode': helpers.get_xml_attr(transcode_info, 'transcodeHwDecoding'), 'transcode_hw_decode_title': helpers.get_xml_attr(transcode_info, 'transcodeHwDecodingTitle'), 'transcode_hw_encode': helpers.get_xml_attr(transcode_info, 'transcodeHwEncoding'), 'transcode_hw_encode_title': helpers.get_xml_attr(transcode_info, 'transcodeHwEncodingTitle'), 'transcode_hw_full_pipeline': int(helpers.get_xml_attr(transcode_info, 'transcodeHwFullPipeline') == '1'), 'audio_decision': helpers.get_xml_attr(transcode_info, 'audioDecision'), 'video_decision': helpers.get_xml_attr(transcode_info, 'videoDecision'), 'subtitle_decision': helpers.get_xml_attr(transcode_info, 'subtitleDecision'), 'throttled': '1' if helpers.get_xml_attr(transcode_info, 'throttled') == '1' else '0'}\n    else:\n        transcode_session = False\n        transcode_details = {'transcode_key': '', 'transcode_throttled': 0, 'transcode_progress': 0, 'transcode_speed': '', 'transcode_audio_channels': '', 'transcode_audio_codec': '', 'transcode_video_codec': '', 'transcode_width': '', 'transcode_height': '', 'transcode_container': '', 'transcode_protocol': '', 'transcode_min_offset_available': 0, 'transcode_max_offset_available': 0, 'transcode_hw_requested': 0, 'transcode_hw_decode': '', 'transcode_hw_decode_title': '', 'transcode_hw_encode': '', 'transcode_hw_encode_title': '', 'transcode_hw_full_pipeline': 0, 'audio_decision': 'direct play', 'video_decision': 'direct play', 'subtitle_decision': '', 'throttled': '0'}\n    transcode_details['transcode_hw_decoding'] = int(transcode_details['transcode_hw_decode'].lower() in common.HW_DECODERS)\n    transcode_details['transcode_hw_encoding'] = int(transcode_details['transcode_hw_encode'].lower() in common.HW_ENCODERS)\n    media_info_all = session.getElementsByTagName('Media')\n    stream_media_info = next((m for m in media_info_all if helpers.get_xml_attr(m, 'selected') == '1'), media_info_all[0])\n    part_info_all = stream_media_info.getElementsByTagName('Part')\n    stream_media_parts_info = next((p for p in part_info_all if helpers.get_xml_attr(p, 'selected') == '1'), part_info_all[0])\n    video_stream_info = audio_stream_info = subtitle_stream_info = None\n    for stream in stream_media_parts_info.getElementsByTagName('Stream'):\n        if helpers.get_xml_attr(stream, 'streamType') == '1':\n            if video_stream_info is None or helpers.get_xml_attr(stream, 'selected') == '1':\n                video_stream_info = stream\n        elif helpers.get_xml_attr(stream, 'streamType') == '2':\n            if audio_stream_info is None or helpers.get_xml_attr(stream, 'selected') == '1':\n                audio_stream_info = stream\n        elif helpers.get_xml_attr(stream, 'streamType') == '3':\n            if subtitle_stream_info is None or helpers.get_xml_attr(stream, 'selected') == '1':\n                subtitle_stream_info = stream\n    video_id = audio_id = subtitle_id = None\n    if video_stream_info:\n        video_id = helpers.get_xml_attr(video_stream_info, 'id')\n        video_details = {'stream_video_bitrate': helpers.get_xml_attr(video_stream_info, 'bitrate'), 'stream_video_bit_depth': helpers.get_xml_attr(video_stream_info, 'bitDepth'), 'stream_video_chroma_subsampling': helpers.get_xml_attr(video_stream_info, 'chromaSubsampling'), 'stream_video_codec': helpers.get_xml_attr(video_stream_info, 'codec'), 'stream_video_codec_level': helpers.get_xml_attr(video_stream_info, 'level'), 'stream_video_color_primaries': helpers.get_xml_attr(video_stream_info, 'colorPrimaries'), 'stream_video_color_range': helpers.get_xml_attr(video_stream_info, 'colorRange'), 'stream_video_color_space': helpers.get_xml_attr(video_stream_info, 'colorSpace'), 'stream_video_color_trc': helpers.get_xml_attr(video_stream_info, 'colorTrc'), 'stream_video_dynamic_range': self.get_dynamic_range(video_stream_info), 'stream_video_height': helpers.get_xml_attr(video_stream_info, 'height'), 'stream_video_width': helpers.get_xml_attr(video_stream_info, 'width'), 'stream_video_ref_frames': helpers.get_xml_attr(video_stream_info, 'refFrames'), 'stream_video_language': helpers.get_xml_attr(video_stream_info, 'language'), 'stream_video_language_code': helpers.get_xml_attr(video_stream_info, 'languageCode'), 'stream_video_scan_type': helpers.get_xml_attr(video_stream_info, 'scanType'), 'stream_video_decision': helpers.get_xml_attr(video_stream_info, 'decision') or 'direct play'}\n    else:\n        video_details = {'stream_video_bitrate': '', 'stream_video_bit_depth': '', 'stream_video_chroma_subsampling': '', 'stream_video_codec': '', 'stream_video_codec_level': '', 'stream_video_color_primaries': '', 'stream_video_color_range': '', 'stream_video_color_space': '', 'stream_video_color_trc': '', 'stream_video_dynamic_range': '', 'stream_video_height': '', 'stream_video_width': '', 'stream_video_ref_frames': '', 'stream_video_language': '', 'stream_video_language_code': '', 'stream_video_scan_type': '', 'stream_video_decision': ''}\n    if audio_stream_info:\n        audio_id = helpers.get_xml_attr(audio_stream_info, 'id')\n        stream_audio_channels = helpers.get_xml_attr(audio_stream_info, 'channels')\n        stream_audio_channel_layouts_ = helpers.get_xml_attr(audio_stream_info, 'audioChannelLayout')\n        audio_details = {'stream_audio_bitrate': helpers.get_xml_attr(audio_stream_info, 'bitrate'), 'stream_audio_bitrate_mode': helpers.get_xml_attr(audio_stream_info, 'bitrateMode'), 'stream_audio_channels': stream_audio_channels, 'stream_audio_channel_layout': stream_audio_channel_layouts_ or common.AUDIO_CHANNELS.get(stream_audio_channels, stream_audio_channels), 'stream_audio_codec': helpers.get_xml_attr(audio_stream_info, 'codec'), 'stream_audio_sample_rate': helpers.get_xml_attr(audio_stream_info, 'samplingRate'), 'stream_audio_channel_layout_': stream_audio_channel_layouts_, 'stream_audio_language': helpers.get_xml_attr(audio_stream_info, 'language'), 'stream_audio_language_code': helpers.get_xml_attr(audio_stream_info, 'languageCode'), 'stream_audio_decision': helpers.get_xml_attr(audio_stream_info, 'decision') or 'direct play'}\n    else:\n        audio_details = {'stream_audio_bitrate': '', 'stream_audio_bitrate_mode': '', 'stream_audio_channels': '', 'stream_audio_channel_layout': '', 'stream_audio_codec': '', 'stream_audio_sample_rate': '', 'stream_audio_channel_layout_': '', 'stream_audio_language': '', 'stream_audio_language_code': '', 'stream_audio_decision': ''}\n    if subtitle_stream_info:\n        subtitle_id = helpers.get_xml_attr(subtitle_stream_info, 'id')\n        subtitle_selected = helpers.get_xml_attr(subtitle_stream_info, 'selected')\n        subtitle_details = {'stream_subtitle_codec': helpers.get_xml_attr(subtitle_stream_info, 'codec'), 'stream_subtitle_container': helpers.get_xml_attr(subtitle_stream_info, 'container'), 'stream_subtitle_format': helpers.get_xml_attr(subtitle_stream_info, 'format'), 'stream_subtitle_forced': int(helpers.get_xml_attr(subtitle_stream_info, 'forced') == '1'), 'stream_subtitle_location': helpers.get_xml_attr(subtitle_stream_info, 'location'), 'stream_subtitle_language': helpers.get_xml_attr(subtitle_stream_info, 'language'), 'stream_subtitle_language_code': helpers.get_xml_attr(subtitle_stream_info, 'languageCode'), 'stream_subtitle_decision': helpers.get_xml_attr(subtitle_stream_info, 'decision') or transcode_details['subtitle_decision'], 'stream_subtitle_transient': int(helpers.get_xml_attr(subtitle_stream_info, 'transient') == '1')}\n    else:\n        subtitle_selected = None\n        subtitle_details = {'stream_subtitle_codec': '', 'stream_subtitle_container': '', 'stream_subtitle_format': '', 'stream_subtitle_forced': 0, 'stream_subtitle_location': '', 'stream_subtitle_language': '', 'stream_subtitle_language_code': '', 'stream_subtitle_decision': '', 'stream_subtitle_transient': 0}\n    indexes = helpers.get_xml_attr(stream_media_parts_info, 'indexes')\n    view_offset = helpers.get_xml_attr(session, 'viewOffset')\n    if indexes == 'sd':\n        part_id = helpers.get_xml_attr(stream_media_parts_info, 'id')\n        bif_thumb = '/library/parts/{part_id}/indexes/sd/{view_offset}'.format(part_id=part_id, view_offset=view_offset)\n    else:\n        bif_thumb = ''\n    if helpers.cast_to_int(video_details['stream_video_width']) >= 3840:\n        stream_video_resolution = '4k'\n    else:\n        stream_video_resolution = helpers.get_xml_attr(stream_media_info, 'videoResolution').lower().rstrip('ip')\n    stream_details = {'stream_container': helpers.get_xml_attr(stream_media_info, 'container'), 'stream_bitrate': helpers.get_xml_attr(stream_media_info, 'bitrate'), 'stream_aspect_ratio': helpers.get_xml_attr(stream_media_info, 'aspectRatio'), 'stream_video_framerate': helpers.get_xml_attr(stream_media_info, 'videoFrameRate'), 'stream_video_resolution': stream_video_resolution, 'stream_duration': helpers.get_xml_attr(stream_media_info, 'duration') or helpers.get_xml_attr(session, 'duration'), 'stream_container_decision': helpers.get_xml_attr(stream_media_parts_info, 'decision').replace('directplay', 'direct play'), 'optimized_version': int(helpers.get_xml_attr(stream_media_info, 'proxyType') == '42'), 'optimized_version_title': helpers.get_xml_attr(stream_media_info, 'title'), 'synced_version': 0, 'live': int(helpers.get_xml_attr(session, 'live') == '1'), 'live_uuid': helpers.get_xml_attr(stream_media_info, 'uuid'), 'indexes': int(indexes == 'sd'), 'bif_thumb': bif_thumb, 'subtitles': 1 if subtitle_id and subtitle_selected else 0}\n    source_media_details = source_media_part_details = source_video_details = source_audio_details = source_subtitle_details = {}\n    if not helpers.get_xml_attr(session, 'ratingKey').isdigit():\n        channel_stream = 1\n        audio_channels = helpers.get_xml_attr(stream_media_info, 'audioChannels')\n        metadata_details = {'media_type': media_type, 'section_id': helpers.get_xml_attr(session, 'librarySectionID'), 'library_name': helpers.get_xml_attr(session, 'librarySectionTitle'), 'rating_key': helpers.get_xml_attr(session, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(session, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(session, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(session, 'title'), 'parent_title': helpers.get_xml_attr(session, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(session, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(session, 'originalTitle'), 'sort_title': helpers.get_xml_attr(session, 'titleSort'), 'media_index': helpers.get_xml_attr(session, 'index'), 'parent_media_index': helpers.get_xml_attr(session, 'parentIndex'), 'studio': helpers.get_xml_attr(session, 'studio'), 'content_rating': helpers.get_xml_attr(session, 'contentRating'), 'summary': helpers.get_xml_attr(session, 'summary'), 'tagline': helpers.get_xml_attr(session, 'tagline'), 'rating': helpers.get_xml_attr(session, 'rating'), 'rating_image': helpers.get_xml_attr(session, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(session, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(session, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(session, 'userRating'), 'duration': helpers.get_xml_attr(session, 'duration'), 'year': helpers.get_xml_attr(session, 'year'), 'thumb': helpers.get_xml_attr(session, 'thumb'), 'parent_thumb': helpers.get_xml_attr(session, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(session, 'grandparentThumb'), 'art': helpers.get_xml_attr(session, 'art'), 'banner': helpers.get_xml_attr(session, 'banner'), 'originally_available_at': helpers.get_xml_attr(session, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(session, 'addedAt'), 'updated_at': helpers.get_xml_attr(session, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(session, 'lastViewedAt'), 'guid': helpers.get_xml_attr(session, 'guid'), 'directors': [], 'writers': [], 'actors': [], 'genres': [], 'labels': [], 'full_title': helpers.get_xml_attr(session, 'title'), 'container': helpers.get_xml_attr(stream_media_info, 'container') or helpers.get_xml_attr(stream_media_parts_info, 'container'), 'bitrate': helpers.get_xml_attr(stream_media_info, 'bitrate'), 'height': helpers.get_xml_attr(stream_media_info, 'height'), 'width': helpers.get_xml_attr(stream_media_info, 'width'), 'aspect_ratio': helpers.get_xml_attr(stream_media_info, 'aspectRatio'), 'video_codec': helpers.get_xml_attr(stream_media_info, 'videoCodec'), 'video_resolution': helpers.get_xml_attr(stream_media_info, 'videoResolution').lower(), 'video_full_resolution': helpers.get_xml_attr(stream_media_info, 'videoResolution').lower(), 'video_framerate': helpers.get_xml_attr(stream_media_info, 'videoFrameRate'), 'video_profile': helpers.get_xml_attr(stream_media_info, 'videoProfile'), 'audio_codec': helpers.get_xml_attr(stream_media_info, 'audioCodec'), 'audio_channels': audio_channels, 'audio_channel_layout': common.AUDIO_CHANNELS.get(audio_channels, audio_channels), 'audio_profile': helpers.get_xml_attr(stream_media_info, 'audioProfile'), 'channel_icon': helpers.get_xml_attr(session, 'sourceIcon'), 'channel_title': helpers.get_xml_attr(session, 'sourceTitle'), 'extra_type': helpers.get_xml_attr(session, 'extraType'), 'sub_type': helpers.get_xml_attr(session, 'subtype')}\n    else:\n        channel_stream = 0\n        media_id = helpers.get_xml_attr(stream_media_info, 'id')\n        part_id = helpers.get_xml_attr(stream_media_parts_info, 'id')\n        metadata_details = self.get_metadata_details(rating_key=rating_key, skip_cache=skip_cache, cache_key=session_key)\n        source_medias = metadata_details.pop('media_info', [])\n        source_media_details = next((m for m in source_medias if m['id'] == media_id), next((m for m in source_medias), {}))\n        source_media_parts = source_media_details.pop('parts', [])\n        source_media_part_details = next((p for p in source_media_parts if p['id'] == part_id), next((p for p in source_media_parts), {}))\n        source_media_part_streams = source_media_part_details.pop('streams', [])\n        source_video_details = {'id': '', 'type': '', 'video_codec': '', 'video_codec_level': '', 'video_bitrate': '', 'video_bit_depth': '', 'video_chroma_subsampling': '', 'video_color_primaries': '', 'video_color_range': '', 'video_color_space': '', 'video_color_trc': '', 'video_dynamic_range': '', 'video_frame_rate': '', 'video_ref_frames': '', 'video_height': '', 'video_width': '', 'video_language': '', 'video_language_code': '', 'video_scan_type': '', 'video_profile': ''}\n        source_audio_details = {'id': '', 'type': '', 'audio_codec': '', 'audio_bitrate': '', 'audio_bitrate_mode': '', 'audio_channels': '', 'audio_channel_layout': '', 'audio_sample_rate': '', 'audio_language': '', 'audio_language_code': '', 'audio_profile': ''}\n        source_subtitle_details = {'id': '', 'type': '', 'subtitle_codec': '', 'subtitle_container': '', 'subtitle_format': '', 'subtitle_forced': 0, 'subtitle_location': '', 'subtitle_language': '', 'subtitle_language_code': ''}\n        if video_id:\n            source_video_details = next((p for p in source_media_part_streams if p['id'] == video_id), next((p for p in source_media_part_streams if p['type'] == '1'), source_video_details))\n        if audio_id:\n            source_audio_details = next((p for p in source_media_part_streams if p['id'] == audio_id), next((p for p in source_media_part_streams if p['type'] == '2'), source_audio_details))\n        if subtitle_id:\n            source_subtitle_details = next((p for p in source_media_part_streams if p['id'] == subtitle_id), next((p for p in source_media_part_streams if p['type'] == '3'), source_subtitle_details))\n    if media_type == 'clip' and metadata_details.get('extra_type') and metadata_details['art']:\n        metadata_details['thumb'] = metadata_details['art'].replace('/art', '/thumb')\n    if stream_details['live'] and transcode_session:\n        stream_details['stream_container_decision'] = 'transcode'\n        stream_details['stream_container'] = transcode_details['transcode_container']\n        video_details['stream_video_decision'] = transcode_details['video_decision']\n        video_details['stream_video_codec'] = transcode_details['transcode_video_codec']\n        audio_details['stream_audio_decision'] = transcode_details['audio_decision']\n        audio_details['stream_audio_codec'] = transcode_details['transcode_audio_codec']\n        audio_details['stream_audio_channels'] = transcode_details['transcode_audio_channels']\n        audio_details['stream_audio_channel_layout'] = common.AUDIO_CHANNELS.get(transcode_details['transcode_audio_channels'], transcode_details['transcode_audio_channels'])\n    if video_details['stream_video_decision'] == 'transcode' or audio_details['stream_audio_decision'] == 'transcode':\n        transcode_decision = 'transcode'\n    elif video_details['stream_video_decision'] == 'copy' or audio_details['stream_audio_decision'] == 'copy':\n        transcode_decision = 'copy'\n    else:\n        transcode_decision = 'direct play'\n    stream_details['transcode_decision'] = transcode_decision\n    stream_details['container_decision'] = stream_details['stream_container_decision']\n    if audio_details['stream_audio_codec'] == '*':\n        audio_details['stream_audio_codec'] = source_audio_details.get('audio_codec', '')\n    if transcode_details['transcode_audio_codec'] == '*':\n        transcode_details['transcode_audio_codec'] = source_audio_details.get('audio_codec', '')\n    if video_details['stream_video_codec'] == '*':\n        video_details['stream_video_codec'] = source_video_details.get('video_codec', '')\n    if transcode_details['transcode_video_codec'] == '*':\n        transcode_details['transcode_video_codec'] = source_video_details.get('video_codec', '')\n    if media_type in ('movie', 'episode', 'clip'):\n        stream_details['stream_video_full_resolution'] = common.VIDEO_RESOLUTION_OVERRIDES.get(stream_details['stream_video_resolution'], stream_details['stream_video_resolution'] + (video_details['stream_video_scan_type'][:1] or 'p'))\n    if media_type in ('movie', 'episode', 'clip') and 'stream_bitrate' in stream_details:\n        if video_details['stream_video_decision'] == 'transcode':\n            synced_version_profile = ''\n            stream_bitrate = helpers.cast_to_int(stream_details['stream_bitrate'])\n            source_bitrate = helpers.cast_to_int(source_media_details.get('bitrate'))\n            try:\n                quailtiy_bitrate = min((b for b in common.VIDEO_QUALITY_PROFILES if stream_bitrate <= b <= source_bitrate))\n                quality_profile = common.VIDEO_QUALITY_PROFILES[quailtiy_bitrate]\n            except ValueError:\n                quality_profile = 'Original'\n        else:\n            synced_version_profile = ''\n            quality_profile = 'Original'\n        if stream_details['optimized_version']:\n            source_bitrate = helpers.cast_to_int(source_media_details.get('bitrate'))\n            optimized_version_profile = '{} Mbps {}'.format(round(source_bitrate / 1000.0, 1), source_media_details.get('video_full_resolution'))\n        else:\n            optimized_version_profile = ''\n    elif media_type == 'track' and 'stream_bitrate' in stream_details:\n        synced_version_profile = ''\n        stream_bitrate = helpers.cast_to_int(stream_details['stream_bitrate'])\n        source_bitrate = helpers.cast_to_int(source_media_details.get('bitrate'))\n        try:\n            quailtiy_bitrate = min((b for b in common.AUDIO_QUALITY_PROFILES if stream_bitrate <= b <= source_bitrate))\n            quality_profile = common.AUDIO_QUALITY_PROFILES[quailtiy_bitrate]\n        except ValueError:\n            quality_profile = 'Original'\n        optimized_version_profile = ''\n    elif media_type == 'photo':\n        quality_profile = 'Original'\n        synced_version_profile = ''\n        optimized_version_profile = ''\n    else:\n        quality_profile = 'Unknown'\n        synced_version_profile = ''\n        optimized_version_profile = ''\n    session_output = {'session_key': session_key, 'media_type': media_type, 'view_offset': view_offset, 'progress_percent': str(helpers.get_percent(view_offset, stream_details['stream_duration'])), 'quality_profile': quality_profile, 'synced_version_profile': synced_version_profile, 'optimized_version_profile': optimized_version_profile, 'user': user_details['username'], 'channel_stream': channel_stream}\n    session_output.update(metadata_details)\n    session_output.update(source_media_details)\n    session_output.update(source_media_part_details)\n    session_output.update(source_video_details)\n    session_output.update(source_audio_details)\n    session_output.update(source_subtitle_details)\n    session_output.update(user_details)\n    session_output.update(player_details)\n    session_output.update(session_details)\n    session_output.update(transcode_details)\n    session_output.update(stream_details)\n    session_output.update(video_details)\n    session_output.update(audio_details)\n    session_output.update(subtitle_details)\n    return session_output",
            "def get_session_each(self, session=None, skip_cache=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Return selected data from current sessions.\\n        This function processes and validates session data\\n\\n        Parameters required:    session { the session dictionary }\\n        Output: dict\\n        '\n    media_type = helpers.get_xml_attr(session, 'type')\n    rating_key = helpers.get_xml_attr(session, 'ratingKey')\n    session_key = helpers.get_xml_attr(session, 'sessionKey')\n    user_info = session.getElementsByTagName('User')[0]\n    user_id = helpers.get_xml_attr(user_info, 'id')\n    if user_id == '1':\n        user_details = users.Users().get_details(user=helpers.get_xml_attr(user_info, 'title'))\n    else:\n        user_details = users.Users().get_details(user_id=user_id)\n    player_info = session.getElementsByTagName('Player')[0]\n    platform = helpers.get_xml_attr(player_info, 'platform')\n    platform = common.PLATFORM_NAME_OVERRIDES.get(platform, platform)\n    if not platform and helpers.get_xml_attr(player_info, 'product') == 'DLNA':\n        platform = 'DLNA'\n    platform_name = next((v for (k, v) in common.PLATFORM_NAMES.items() if k in platform.lower()), 'default')\n    player_details = {'ip_address': helpers.get_xml_attr(player_info, 'address').split('::ffff:')[-1], 'ip_address_public': helpers.get_xml_attr(player_info, 'remotePublicAddress').split('::ffff:')[-1], 'device': helpers.get_xml_attr(player_info, 'device'), 'platform': platform, 'platform_name': platform_name, 'platform_version': helpers.get_xml_attr(player_info, 'platformVersion'), 'product': helpers.get_xml_attr(player_info, 'product'), 'product_version': helpers.get_xml_attr(player_info, 'version'), 'profile': helpers.get_xml_attr(player_info, 'profile'), 'player': helpers.get_xml_attr(player_info, 'title') or helpers.get_xml_attr(player_info, 'product'), 'machine_id': helpers.get_xml_attr(player_info, 'machineIdentifier'), 'state': helpers.get_xml_attr(player_info, 'state'), 'local': int(helpers.get_xml_attr(player_info, 'local') == '1'), 'relayed': helpers.get_xml_attr(player_info, 'relayed', default_return=None), 'secure': helpers.get_xml_attr(player_info, 'secure', default_return=None)}\n    if session.getElementsByTagName('Session'):\n        session_info = session.getElementsByTagName('Session')[0]\n        session_details = {'session_id': helpers.get_xml_attr(session_info, 'id'), 'bandwidth': helpers.get_xml_attr(session_info, 'bandwidth'), 'location': helpers.get_xml_attr(session_info, 'location')}\n    else:\n        session_details = {'session_id': '', 'bandwidth': '', 'location': 'lan' if player_details['local'] else 'wan'}\n    if player_details['relayed'] is None:\n        player_details['relayed'] = int(session_details['location'] != 'lan' and player_details['ip_address_public'] == '127.0.0.1')\n    else:\n        player_details['relayed'] = helpers.cast_to_int(player_details['relayed'])\n    if player_details['secure'] is not None:\n        player_details['secure'] = int(player_details['secure'] == '1')\n    if session.getElementsByTagName('TranscodeSession'):\n        transcode_session = True\n        transcode_info = session.getElementsByTagName('TranscodeSession')[0]\n        transcode_progress = helpers.get_xml_attr(transcode_info, 'progress')\n        transcode_speed = helpers.get_xml_attr(transcode_info, 'speed')\n        transcode_min_offset = helpers.get_xml_attr(transcode_info, 'minOffsetAvailable')\n        transcode_max_offset = helpers.get_xml_attr(transcode_info, 'maxOffsetAvailable')\n        transcode_details = {'transcode_key': helpers.get_xml_attr(transcode_info, 'key'), 'transcode_throttled': int(helpers.get_xml_attr(transcode_info, 'throttled') == '1'), 'transcode_progress': int(round(helpers.cast_to_float(transcode_progress), 0)), 'transcode_speed': str(round(helpers.cast_to_float(transcode_speed), 1)), 'transcode_audio_channels': helpers.get_xml_attr(transcode_info, 'audioChannels'), 'transcode_audio_codec': helpers.get_xml_attr(transcode_info, 'audioCodec'), 'transcode_video_codec': helpers.get_xml_attr(transcode_info, 'videoCodec'), 'transcode_width': helpers.get_xml_attr(transcode_info, 'width'), 'transcode_height': helpers.get_xml_attr(transcode_info, 'height'), 'transcode_container': helpers.get_xml_attr(transcode_info, 'container'), 'transcode_protocol': helpers.get_xml_attr(transcode_info, 'protocol'), 'transcode_min_offset_available': int(round(helpers.cast_to_float(transcode_min_offset), 0)), 'transcode_max_offset_available': int(round(helpers.cast_to_float(transcode_max_offset), 0)), 'transcode_hw_requested': int(helpers.get_xml_attr(transcode_info, 'transcodeHwRequested') == '1'), 'transcode_hw_decode': helpers.get_xml_attr(transcode_info, 'transcodeHwDecoding'), 'transcode_hw_decode_title': helpers.get_xml_attr(transcode_info, 'transcodeHwDecodingTitle'), 'transcode_hw_encode': helpers.get_xml_attr(transcode_info, 'transcodeHwEncoding'), 'transcode_hw_encode_title': helpers.get_xml_attr(transcode_info, 'transcodeHwEncodingTitle'), 'transcode_hw_full_pipeline': int(helpers.get_xml_attr(transcode_info, 'transcodeHwFullPipeline') == '1'), 'audio_decision': helpers.get_xml_attr(transcode_info, 'audioDecision'), 'video_decision': helpers.get_xml_attr(transcode_info, 'videoDecision'), 'subtitle_decision': helpers.get_xml_attr(transcode_info, 'subtitleDecision'), 'throttled': '1' if helpers.get_xml_attr(transcode_info, 'throttled') == '1' else '0'}\n    else:\n        transcode_session = False\n        transcode_details = {'transcode_key': '', 'transcode_throttled': 0, 'transcode_progress': 0, 'transcode_speed': '', 'transcode_audio_channels': '', 'transcode_audio_codec': '', 'transcode_video_codec': '', 'transcode_width': '', 'transcode_height': '', 'transcode_container': '', 'transcode_protocol': '', 'transcode_min_offset_available': 0, 'transcode_max_offset_available': 0, 'transcode_hw_requested': 0, 'transcode_hw_decode': '', 'transcode_hw_decode_title': '', 'transcode_hw_encode': '', 'transcode_hw_encode_title': '', 'transcode_hw_full_pipeline': 0, 'audio_decision': 'direct play', 'video_decision': 'direct play', 'subtitle_decision': '', 'throttled': '0'}\n    transcode_details['transcode_hw_decoding'] = int(transcode_details['transcode_hw_decode'].lower() in common.HW_DECODERS)\n    transcode_details['transcode_hw_encoding'] = int(transcode_details['transcode_hw_encode'].lower() in common.HW_ENCODERS)\n    media_info_all = session.getElementsByTagName('Media')\n    stream_media_info = next((m for m in media_info_all if helpers.get_xml_attr(m, 'selected') == '1'), media_info_all[0])\n    part_info_all = stream_media_info.getElementsByTagName('Part')\n    stream_media_parts_info = next((p for p in part_info_all if helpers.get_xml_attr(p, 'selected') == '1'), part_info_all[0])\n    video_stream_info = audio_stream_info = subtitle_stream_info = None\n    for stream in stream_media_parts_info.getElementsByTagName('Stream'):\n        if helpers.get_xml_attr(stream, 'streamType') == '1':\n            if video_stream_info is None or helpers.get_xml_attr(stream, 'selected') == '1':\n                video_stream_info = stream\n        elif helpers.get_xml_attr(stream, 'streamType') == '2':\n            if audio_stream_info is None or helpers.get_xml_attr(stream, 'selected') == '1':\n                audio_stream_info = stream\n        elif helpers.get_xml_attr(stream, 'streamType') == '3':\n            if subtitle_stream_info is None or helpers.get_xml_attr(stream, 'selected') == '1':\n                subtitle_stream_info = stream\n    video_id = audio_id = subtitle_id = None\n    if video_stream_info:\n        video_id = helpers.get_xml_attr(video_stream_info, 'id')\n        video_details = {'stream_video_bitrate': helpers.get_xml_attr(video_stream_info, 'bitrate'), 'stream_video_bit_depth': helpers.get_xml_attr(video_stream_info, 'bitDepth'), 'stream_video_chroma_subsampling': helpers.get_xml_attr(video_stream_info, 'chromaSubsampling'), 'stream_video_codec': helpers.get_xml_attr(video_stream_info, 'codec'), 'stream_video_codec_level': helpers.get_xml_attr(video_stream_info, 'level'), 'stream_video_color_primaries': helpers.get_xml_attr(video_stream_info, 'colorPrimaries'), 'stream_video_color_range': helpers.get_xml_attr(video_stream_info, 'colorRange'), 'stream_video_color_space': helpers.get_xml_attr(video_stream_info, 'colorSpace'), 'stream_video_color_trc': helpers.get_xml_attr(video_stream_info, 'colorTrc'), 'stream_video_dynamic_range': self.get_dynamic_range(video_stream_info), 'stream_video_height': helpers.get_xml_attr(video_stream_info, 'height'), 'stream_video_width': helpers.get_xml_attr(video_stream_info, 'width'), 'stream_video_ref_frames': helpers.get_xml_attr(video_stream_info, 'refFrames'), 'stream_video_language': helpers.get_xml_attr(video_stream_info, 'language'), 'stream_video_language_code': helpers.get_xml_attr(video_stream_info, 'languageCode'), 'stream_video_scan_type': helpers.get_xml_attr(video_stream_info, 'scanType'), 'stream_video_decision': helpers.get_xml_attr(video_stream_info, 'decision') or 'direct play'}\n    else:\n        video_details = {'stream_video_bitrate': '', 'stream_video_bit_depth': '', 'stream_video_chroma_subsampling': '', 'stream_video_codec': '', 'stream_video_codec_level': '', 'stream_video_color_primaries': '', 'stream_video_color_range': '', 'stream_video_color_space': '', 'stream_video_color_trc': '', 'stream_video_dynamic_range': '', 'stream_video_height': '', 'stream_video_width': '', 'stream_video_ref_frames': '', 'stream_video_language': '', 'stream_video_language_code': '', 'stream_video_scan_type': '', 'stream_video_decision': ''}\n    if audio_stream_info:\n        audio_id = helpers.get_xml_attr(audio_stream_info, 'id')\n        stream_audio_channels = helpers.get_xml_attr(audio_stream_info, 'channels')\n        stream_audio_channel_layouts_ = helpers.get_xml_attr(audio_stream_info, 'audioChannelLayout')\n        audio_details = {'stream_audio_bitrate': helpers.get_xml_attr(audio_stream_info, 'bitrate'), 'stream_audio_bitrate_mode': helpers.get_xml_attr(audio_stream_info, 'bitrateMode'), 'stream_audio_channels': stream_audio_channels, 'stream_audio_channel_layout': stream_audio_channel_layouts_ or common.AUDIO_CHANNELS.get(stream_audio_channels, stream_audio_channels), 'stream_audio_codec': helpers.get_xml_attr(audio_stream_info, 'codec'), 'stream_audio_sample_rate': helpers.get_xml_attr(audio_stream_info, 'samplingRate'), 'stream_audio_channel_layout_': stream_audio_channel_layouts_, 'stream_audio_language': helpers.get_xml_attr(audio_stream_info, 'language'), 'stream_audio_language_code': helpers.get_xml_attr(audio_stream_info, 'languageCode'), 'stream_audio_decision': helpers.get_xml_attr(audio_stream_info, 'decision') or 'direct play'}\n    else:\n        audio_details = {'stream_audio_bitrate': '', 'stream_audio_bitrate_mode': '', 'stream_audio_channels': '', 'stream_audio_channel_layout': '', 'stream_audio_codec': '', 'stream_audio_sample_rate': '', 'stream_audio_channel_layout_': '', 'stream_audio_language': '', 'stream_audio_language_code': '', 'stream_audio_decision': ''}\n    if subtitle_stream_info:\n        subtitle_id = helpers.get_xml_attr(subtitle_stream_info, 'id')\n        subtitle_selected = helpers.get_xml_attr(subtitle_stream_info, 'selected')\n        subtitle_details = {'stream_subtitle_codec': helpers.get_xml_attr(subtitle_stream_info, 'codec'), 'stream_subtitle_container': helpers.get_xml_attr(subtitle_stream_info, 'container'), 'stream_subtitle_format': helpers.get_xml_attr(subtitle_stream_info, 'format'), 'stream_subtitle_forced': int(helpers.get_xml_attr(subtitle_stream_info, 'forced') == '1'), 'stream_subtitle_location': helpers.get_xml_attr(subtitle_stream_info, 'location'), 'stream_subtitle_language': helpers.get_xml_attr(subtitle_stream_info, 'language'), 'stream_subtitle_language_code': helpers.get_xml_attr(subtitle_stream_info, 'languageCode'), 'stream_subtitle_decision': helpers.get_xml_attr(subtitle_stream_info, 'decision') or transcode_details['subtitle_decision'], 'stream_subtitle_transient': int(helpers.get_xml_attr(subtitle_stream_info, 'transient') == '1')}\n    else:\n        subtitle_selected = None\n        subtitle_details = {'stream_subtitle_codec': '', 'stream_subtitle_container': '', 'stream_subtitle_format': '', 'stream_subtitle_forced': 0, 'stream_subtitle_location': '', 'stream_subtitle_language': '', 'stream_subtitle_language_code': '', 'stream_subtitle_decision': '', 'stream_subtitle_transient': 0}\n    indexes = helpers.get_xml_attr(stream_media_parts_info, 'indexes')\n    view_offset = helpers.get_xml_attr(session, 'viewOffset')\n    if indexes == 'sd':\n        part_id = helpers.get_xml_attr(stream_media_parts_info, 'id')\n        bif_thumb = '/library/parts/{part_id}/indexes/sd/{view_offset}'.format(part_id=part_id, view_offset=view_offset)\n    else:\n        bif_thumb = ''\n    if helpers.cast_to_int(video_details['stream_video_width']) >= 3840:\n        stream_video_resolution = '4k'\n    else:\n        stream_video_resolution = helpers.get_xml_attr(stream_media_info, 'videoResolution').lower().rstrip('ip')\n    stream_details = {'stream_container': helpers.get_xml_attr(stream_media_info, 'container'), 'stream_bitrate': helpers.get_xml_attr(stream_media_info, 'bitrate'), 'stream_aspect_ratio': helpers.get_xml_attr(stream_media_info, 'aspectRatio'), 'stream_video_framerate': helpers.get_xml_attr(stream_media_info, 'videoFrameRate'), 'stream_video_resolution': stream_video_resolution, 'stream_duration': helpers.get_xml_attr(stream_media_info, 'duration') or helpers.get_xml_attr(session, 'duration'), 'stream_container_decision': helpers.get_xml_attr(stream_media_parts_info, 'decision').replace('directplay', 'direct play'), 'optimized_version': int(helpers.get_xml_attr(stream_media_info, 'proxyType') == '42'), 'optimized_version_title': helpers.get_xml_attr(stream_media_info, 'title'), 'synced_version': 0, 'live': int(helpers.get_xml_attr(session, 'live') == '1'), 'live_uuid': helpers.get_xml_attr(stream_media_info, 'uuid'), 'indexes': int(indexes == 'sd'), 'bif_thumb': bif_thumb, 'subtitles': 1 if subtitle_id and subtitle_selected else 0}\n    source_media_details = source_media_part_details = source_video_details = source_audio_details = source_subtitle_details = {}\n    if not helpers.get_xml_attr(session, 'ratingKey').isdigit():\n        channel_stream = 1\n        audio_channels = helpers.get_xml_attr(stream_media_info, 'audioChannels')\n        metadata_details = {'media_type': media_type, 'section_id': helpers.get_xml_attr(session, 'librarySectionID'), 'library_name': helpers.get_xml_attr(session, 'librarySectionTitle'), 'rating_key': helpers.get_xml_attr(session, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(session, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(session, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(session, 'title'), 'parent_title': helpers.get_xml_attr(session, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(session, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(session, 'originalTitle'), 'sort_title': helpers.get_xml_attr(session, 'titleSort'), 'media_index': helpers.get_xml_attr(session, 'index'), 'parent_media_index': helpers.get_xml_attr(session, 'parentIndex'), 'studio': helpers.get_xml_attr(session, 'studio'), 'content_rating': helpers.get_xml_attr(session, 'contentRating'), 'summary': helpers.get_xml_attr(session, 'summary'), 'tagline': helpers.get_xml_attr(session, 'tagline'), 'rating': helpers.get_xml_attr(session, 'rating'), 'rating_image': helpers.get_xml_attr(session, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(session, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(session, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(session, 'userRating'), 'duration': helpers.get_xml_attr(session, 'duration'), 'year': helpers.get_xml_attr(session, 'year'), 'thumb': helpers.get_xml_attr(session, 'thumb'), 'parent_thumb': helpers.get_xml_attr(session, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(session, 'grandparentThumb'), 'art': helpers.get_xml_attr(session, 'art'), 'banner': helpers.get_xml_attr(session, 'banner'), 'originally_available_at': helpers.get_xml_attr(session, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(session, 'addedAt'), 'updated_at': helpers.get_xml_attr(session, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(session, 'lastViewedAt'), 'guid': helpers.get_xml_attr(session, 'guid'), 'directors': [], 'writers': [], 'actors': [], 'genres': [], 'labels': [], 'full_title': helpers.get_xml_attr(session, 'title'), 'container': helpers.get_xml_attr(stream_media_info, 'container') or helpers.get_xml_attr(stream_media_parts_info, 'container'), 'bitrate': helpers.get_xml_attr(stream_media_info, 'bitrate'), 'height': helpers.get_xml_attr(stream_media_info, 'height'), 'width': helpers.get_xml_attr(stream_media_info, 'width'), 'aspect_ratio': helpers.get_xml_attr(stream_media_info, 'aspectRatio'), 'video_codec': helpers.get_xml_attr(stream_media_info, 'videoCodec'), 'video_resolution': helpers.get_xml_attr(stream_media_info, 'videoResolution').lower(), 'video_full_resolution': helpers.get_xml_attr(stream_media_info, 'videoResolution').lower(), 'video_framerate': helpers.get_xml_attr(stream_media_info, 'videoFrameRate'), 'video_profile': helpers.get_xml_attr(stream_media_info, 'videoProfile'), 'audio_codec': helpers.get_xml_attr(stream_media_info, 'audioCodec'), 'audio_channels': audio_channels, 'audio_channel_layout': common.AUDIO_CHANNELS.get(audio_channels, audio_channels), 'audio_profile': helpers.get_xml_attr(stream_media_info, 'audioProfile'), 'channel_icon': helpers.get_xml_attr(session, 'sourceIcon'), 'channel_title': helpers.get_xml_attr(session, 'sourceTitle'), 'extra_type': helpers.get_xml_attr(session, 'extraType'), 'sub_type': helpers.get_xml_attr(session, 'subtype')}\n    else:\n        channel_stream = 0\n        media_id = helpers.get_xml_attr(stream_media_info, 'id')\n        part_id = helpers.get_xml_attr(stream_media_parts_info, 'id')\n        metadata_details = self.get_metadata_details(rating_key=rating_key, skip_cache=skip_cache, cache_key=session_key)\n        source_medias = metadata_details.pop('media_info', [])\n        source_media_details = next((m for m in source_medias if m['id'] == media_id), next((m for m in source_medias), {}))\n        source_media_parts = source_media_details.pop('parts', [])\n        source_media_part_details = next((p for p in source_media_parts if p['id'] == part_id), next((p for p in source_media_parts), {}))\n        source_media_part_streams = source_media_part_details.pop('streams', [])\n        source_video_details = {'id': '', 'type': '', 'video_codec': '', 'video_codec_level': '', 'video_bitrate': '', 'video_bit_depth': '', 'video_chroma_subsampling': '', 'video_color_primaries': '', 'video_color_range': '', 'video_color_space': '', 'video_color_trc': '', 'video_dynamic_range': '', 'video_frame_rate': '', 'video_ref_frames': '', 'video_height': '', 'video_width': '', 'video_language': '', 'video_language_code': '', 'video_scan_type': '', 'video_profile': ''}\n        source_audio_details = {'id': '', 'type': '', 'audio_codec': '', 'audio_bitrate': '', 'audio_bitrate_mode': '', 'audio_channels': '', 'audio_channel_layout': '', 'audio_sample_rate': '', 'audio_language': '', 'audio_language_code': '', 'audio_profile': ''}\n        source_subtitle_details = {'id': '', 'type': '', 'subtitle_codec': '', 'subtitle_container': '', 'subtitle_format': '', 'subtitle_forced': 0, 'subtitle_location': '', 'subtitle_language': '', 'subtitle_language_code': ''}\n        if video_id:\n            source_video_details = next((p for p in source_media_part_streams if p['id'] == video_id), next((p for p in source_media_part_streams if p['type'] == '1'), source_video_details))\n        if audio_id:\n            source_audio_details = next((p for p in source_media_part_streams if p['id'] == audio_id), next((p for p in source_media_part_streams if p['type'] == '2'), source_audio_details))\n        if subtitle_id:\n            source_subtitle_details = next((p for p in source_media_part_streams if p['id'] == subtitle_id), next((p for p in source_media_part_streams if p['type'] == '3'), source_subtitle_details))\n    if media_type == 'clip' and metadata_details.get('extra_type') and metadata_details['art']:\n        metadata_details['thumb'] = metadata_details['art'].replace('/art', '/thumb')\n    if stream_details['live'] and transcode_session:\n        stream_details['stream_container_decision'] = 'transcode'\n        stream_details['stream_container'] = transcode_details['transcode_container']\n        video_details['stream_video_decision'] = transcode_details['video_decision']\n        video_details['stream_video_codec'] = transcode_details['transcode_video_codec']\n        audio_details['stream_audio_decision'] = transcode_details['audio_decision']\n        audio_details['stream_audio_codec'] = transcode_details['transcode_audio_codec']\n        audio_details['stream_audio_channels'] = transcode_details['transcode_audio_channels']\n        audio_details['stream_audio_channel_layout'] = common.AUDIO_CHANNELS.get(transcode_details['transcode_audio_channels'], transcode_details['transcode_audio_channels'])\n    if video_details['stream_video_decision'] == 'transcode' or audio_details['stream_audio_decision'] == 'transcode':\n        transcode_decision = 'transcode'\n    elif video_details['stream_video_decision'] == 'copy' or audio_details['stream_audio_decision'] == 'copy':\n        transcode_decision = 'copy'\n    else:\n        transcode_decision = 'direct play'\n    stream_details['transcode_decision'] = transcode_decision\n    stream_details['container_decision'] = stream_details['stream_container_decision']\n    if audio_details['stream_audio_codec'] == '*':\n        audio_details['stream_audio_codec'] = source_audio_details.get('audio_codec', '')\n    if transcode_details['transcode_audio_codec'] == '*':\n        transcode_details['transcode_audio_codec'] = source_audio_details.get('audio_codec', '')\n    if video_details['stream_video_codec'] == '*':\n        video_details['stream_video_codec'] = source_video_details.get('video_codec', '')\n    if transcode_details['transcode_video_codec'] == '*':\n        transcode_details['transcode_video_codec'] = source_video_details.get('video_codec', '')\n    if media_type in ('movie', 'episode', 'clip'):\n        stream_details['stream_video_full_resolution'] = common.VIDEO_RESOLUTION_OVERRIDES.get(stream_details['stream_video_resolution'], stream_details['stream_video_resolution'] + (video_details['stream_video_scan_type'][:1] or 'p'))\n    if media_type in ('movie', 'episode', 'clip') and 'stream_bitrate' in stream_details:\n        if video_details['stream_video_decision'] == 'transcode':\n            synced_version_profile = ''\n            stream_bitrate = helpers.cast_to_int(stream_details['stream_bitrate'])\n            source_bitrate = helpers.cast_to_int(source_media_details.get('bitrate'))\n            try:\n                quailtiy_bitrate = min((b for b in common.VIDEO_QUALITY_PROFILES if stream_bitrate <= b <= source_bitrate))\n                quality_profile = common.VIDEO_QUALITY_PROFILES[quailtiy_bitrate]\n            except ValueError:\n                quality_profile = 'Original'\n        else:\n            synced_version_profile = ''\n            quality_profile = 'Original'\n        if stream_details['optimized_version']:\n            source_bitrate = helpers.cast_to_int(source_media_details.get('bitrate'))\n            optimized_version_profile = '{} Mbps {}'.format(round(source_bitrate / 1000.0, 1), source_media_details.get('video_full_resolution'))\n        else:\n            optimized_version_profile = ''\n    elif media_type == 'track' and 'stream_bitrate' in stream_details:\n        synced_version_profile = ''\n        stream_bitrate = helpers.cast_to_int(stream_details['stream_bitrate'])\n        source_bitrate = helpers.cast_to_int(source_media_details.get('bitrate'))\n        try:\n            quailtiy_bitrate = min((b for b in common.AUDIO_QUALITY_PROFILES if stream_bitrate <= b <= source_bitrate))\n            quality_profile = common.AUDIO_QUALITY_PROFILES[quailtiy_bitrate]\n        except ValueError:\n            quality_profile = 'Original'\n        optimized_version_profile = ''\n    elif media_type == 'photo':\n        quality_profile = 'Original'\n        synced_version_profile = ''\n        optimized_version_profile = ''\n    else:\n        quality_profile = 'Unknown'\n        synced_version_profile = ''\n        optimized_version_profile = ''\n    session_output = {'session_key': session_key, 'media_type': media_type, 'view_offset': view_offset, 'progress_percent': str(helpers.get_percent(view_offset, stream_details['stream_duration'])), 'quality_profile': quality_profile, 'synced_version_profile': synced_version_profile, 'optimized_version_profile': optimized_version_profile, 'user': user_details['username'], 'channel_stream': channel_stream}\n    session_output.update(metadata_details)\n    session_output.update(source_media_details)\n    session_output.update(source_media_part_details)\n    session_output.update(source_video_details)\n    session_output.update(source_audio_details)\n    session_output.update(source_subtitle_details)\n    session_output.update(user_details)\n    session_output.update(player_details)\n    session_output.update(session_details)\n    session_output.update(transcode_details)\n    session_output.update(stream_details)\n    session_output.update(video_details)\n    session_output.update(audio_details)\n    session_output.update(subtitle_details)\n    return session_output",
            "def get_session_each(self, session=None, skip_cache=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Return selected data from current sessions.\\n        This function processes and validates session data\\n\\n        Parameters required:    session { the session dictionary }\\n        Output: dict\\n        '\n    media_type = helpers.get_xml_attr(session, 'type')\n    rating_key = helpers.get_xml_attr(session, 'ratingKey')\n    session_key = helpers.get_xml_attr(session, 'sessionKey')\n    user_info = session.getElementsByTagName('User')[0]\n    user_id = helpers.get_xml_attr(user_info, 'id')\n    if user_id == '1':\n        user_details = users.Users().get_details(user=helpers.get_xml_attr(user_info, 'title'))\n    else:\n        user_details = users.Users().get_details(user_id=user_id)\n    player_info = session.getElementsByTagName('Player')[0]\n    platform = helpers.get_xml_attr(player_info, 'platform')\n    platform = common.PLATFORM_NAME_OVERRIDES.get(platform, platform)\n    if not platform and helpers.get_xml_attr(player_info, 'product') == 'DLNA':\n        platform = 'DLNA'\n    platform_name = next((v for (k, v) in common.PLATFORM_NAMES.items() if k in platform.lower()), 'default')\n    player_details = {'ip_address': helpers.get_xml_attr(player_info, 'address').split('::ffff:')[-1], 'ip_address_public': helpers.get_xml_attr(player_info, 'remotePublicAddress').split('::ffff:')[-1], 'device': helpers.get_xml_attr(player_info, 'device'), 'platform': platform, 'platform_name': platform_name, 'platform_version': helpers.get_xml_attr(player_info, 'platformVersion'), 'product': helpers.get_xml_attr(player_info, 'product'), 'product_version': helpers.get_xml_attr(player_info, 'version'), 'profile': helpers.get_xml_attr(player_info, 'profile'), 'player': helpers.get_xml_attr(player_info, 'title') or helpers.get_xml_attr(player_info, 'product'), 'machine_id': helpers.get_xml_attr(player_info, 'machineIdentifier'), 'state': helpers.get_xml_attr(player_info, 'state'), 'local': int(helpers.get_xml_attr(player_info, 'local') == '1'), 'relayed': helpers.get_xml_attr(player_info, 'relayed', default_return=None), 'secure': helpers.get_xml_attr(player_info, 'secure', default_return=None)}\n    if session.getElementsByTagName('Session'):\n        session_info = session.getElementsByTagName('Session')[0]\n        session_details = {'session_id': helpers.get_xml_attr(session_info, 'id'), 'bandwidth': helpers.get_xml_attr(session_info, 'bandwidth'), 'location': helpers.get_xml_attr(session_info, 'location')}\n    else:\n        session_details = {'session_id': '', 'bandwidth': '', 'location': 'lan' if player_details['local'] else 'wan'}\n    if player_details['relayed'] is None:\n        player_details['relayed'] = int(session_details['location'] != 'lan' and player_details['ip_address_public'] == '127.0.0.1')\n    else:\n        player_details['relayed'] = helpers.cast_to_int(player_details['relayed'])\n    if player_details['secure'] is not None:\n        player_details['secure'] = int(player_details['secure'] == '1')\n    if session.getElementsByTagName('TranscodeSession'):\n        transcode_session = True\n        transcode_info = session.getElementsByTagName('TranscodeSession')[0]\n        transcode_progress = helpers.get_xml_attr(transcode_info, 'progress')\n        transcode_speed = helpers.get_xml_attr(transcode_info, 'speed')\n        transcode_min_offset = helpers.get_xml_attr(transcode_info, 'minOffsetAvailable')\n        transcode_max_offset = helpers.get_xml_attr(transcode_info, 'maxOffsetAvailable')\n        transcode_details = {'transcode_key': helpers.get_xml_attr(transcode_info, 'key'), 'transcode_throttled': int(helpers.get_xml_attr(transcode_info, 'throttled') == '1'), 'transcode_progress': int(round(helpers.cast_to_float(transcode_progress), 0)), 'transcode_speed': str(round(helpers.cast_to_float(transcode_speed), 1)), 'transcode_audio_channels': helpers.get_xml_attr(transcode_info, 'audioChannels'), 'transcode_audio_codec': helpers.get_xml_attr(transcode_info, 'audioCodec'), 'transcode_video_codec': helpers.get_xml_attr(transcode_info, 'videoCodec'), 'transcode_width': helpers.get_xml_attr(transcode_info, 'width'), 'transcode_height': helpers.get_xml_attr(transcode_info, 'height'), 'transcode_container': helpers.get_xml_attr(transcode_info, 'container'), 'transcode_protocol': helpers.get_xml_attr(transcode_info, 'protocol'), 'transcode_min_offset_available': int(round(helpers.cast_to_float(transcode_min_offset), 0)), 'transcode_max_offset_available': int(round(helpers.cast_to_float(transcode_max_offset), 0)), 'transcode_hw_requested': int(helpers.get_xml_attr(transcode_info, 'transcodeHwRequested') == '1'), 'transcode_hw_decode': helpers.get_xml_attr(transcode_info, 'transcodeHwDecoding'), 'transcode_hw_decode_title': helpers.get_xml_attr(transcode_info, 'transcodeHwDecodingTitle'), 'transcode_hw_encode': helpers.get_xml_attr(transcode_info, 'transcodeHwEncoding'), 'transcode_hw_encode_title': helpers.get_xml_attr(transcode_info, 'transcodeHwEncodingTitle'), 'transcode_hw_full_pipeline': int(helpers.get_xml_attr(transcode_info, 'transcodeHwFullPipeline') == '1'), 'audio_decision': helpers.get_xml_attr(transcode_info, 'audioDecision'), 'video_decision': helpers.get_xml_attr(transcode_info, 'videoDecision'), 'subtitle_decision': helpers.get_xml_attr(transcode_info, 'subtitleDecision'), 'throttled': '1' if helpers.get_xml_attr(transcode_info, 'throttled') == '1' else '0'}\n    else:\n        transcode_session = False\n        transcode_details = {'transcode_key': '', 'transcode_throttled': 0, 'transcode_progress': 0, 'transcode_speed': '', 'transcode_audio_channels': '', 'transcode_audio_codec': '', 'transcode_video_codec': '', 'transcode_width': '', 'transcode_height': '', 'transcode_container': '', 'transcode_protocol': '', 'transcode_min_offset_available': 0, 'transcode_max_offset_available': 0, 'transcode_hw_requested': 0, 'transcode_hw_decode': '', 'transcode_hw_decode_title': '', 'transcode_hw_encode': '', 'transcode_hw_encode_title': '', 'transcode_hw_full_pipeline': 0, 'audio_decision': 'direct play', 'video_decision': 'direct play', 'subtitle_decision': '', 'throttled': '0'}\n    transcode_details['transcode_hw_decoding'] = int(transcode_details['transcode_hw_decode'].lower() in common.HW_DECODERS)\n    transcode_details['transcode_hw_encoding'] = int(transcode_details['transcode_hw_encode'].lower() in common.HW_ENCODERS)\n    media_info_all = session.getElementsByTagName('Media')\n    stream_media_info = next((m for m in media_info_all if helpers.get_xml_attr(m, 'selected') == '1'), media_info_all[0])\n    part_info_all = stream_media_info.getElementsByTagName('Part')\n    stream_media_parts_info = next((p for p in part_info_all if helpers.get_xml_attr(p, 'selected') == '1'), part_info_all[0])\n    video_stream_info = audio_stream_info = subtitle_stream_info = None\n    for stream in stream_media_parts_info.getElementsByTagName('Stream'):\n        if helpers.get_xml_attr(stream, 'streamType') == '1':\n            if video_stream_info is None or helpers.get_xml_attr(stream, 'selected') == '1':\n                video_stream_info = stream\n        elif helpers.get_xml_attr(stream, 'streamType') == '2':\n            if audio_stream_info is None or helpers.get_xml_attr(stream, 'selected') == '1':\n                audio_stream_info = stream\n        elif helpers.get_xml_attr(stream, 'streamType') == '3':\n            if subtitle_stream_info is None or helpers.get_xml_attr(stream, 'selected') == '1':\n                subtitle_stream_info = stream\n    video_id = audio_id = subtitle_id = None\n    if video_stream_info:\n        video_id = helpers.get_xml_attr(video_stream_info, 'id')\n        video_details = {'stream_video_bitrate': helpers.get_xml_attr(video_stream_info, 'bitrate'), 'stream_video_bit_depth': helpers.get_xml_attr(video_stream_info, 'bitDepth'), 'stream_video_chroma_subsampling': helpers.get_xml_attr(video_stream_info, 'chromaSubsampling'), 'stream_video_codec': helpers.get_xml_attr(video_stream_info, 'codec'), 'stream_video_codec_level': helpers.get_xml_attr(video_stream_info, 'level'), 'stream_video_color_primaries': helpers.get_xml_attr(video_stream_info, 'colorPrimaries'), 'stream_video_color_range': helpers.get_xml_attr(video_stream_info, 'colorRange'), 'stream_video_color_space': helpers.get_xml_attr(video_stream_info, 'colorSpace'), 'stream_video_color_trc': helpers.get_xml_attr(video_stream_info, 'colorTrc'), 'stream_video_dynamic_range': self.get_dynamic_range(video_stream_info), 'stream_video_height': helpers.get_xml_attr(video_stream_info, 'height'), 'stream_video_width': helpers.get_xml_attr(video_stream_info, 'width'), 'stream_video_ref_frames': helpers.get_xml_attr(video_stream_info, 'refFrames'), 'stream_video_language': helpers.get_xml_attr(video_stream_info, 'language'), 'stream_video_language_code': helpers.get_xml_attr(video_stream_info, 'languageCode'), 'stream_video_scan_type': helpers.get_xml_attr(video_stream_info, 'scanType'), 'stream_video_decision': helpers.get_xml_attr(video_stream_info, 'decision') or 'direct play'}\n    else:\n        video_details = {'stream_video_bitrate': '', 'stream_video_bit_depth': '', 'stream_video_chroma_subsampling': '', 'stream_video_codec': '', 'stream_video_codec_level': '', 'stream_video_color_primaries': '', 'stream_video_color_range': '', 'stream_video_color_space': '', 'stream_video_color_trc': '', 'stream_video_dynamic_range': '', 'stream_video_height': '', 'stream_video_width': '', 'stream_video_ref_frames': '', 'stream_video_language': '', 'stream_video_language_code': '', 'stream_video_scan_type': '', 'stream_video_decision': ''}\n    if audio_stream_info:\n        audio_id = helpers.get_xml_attr(audio_stream_info, 'id')\n        stream_audio_channels = helpers.get_xml_attr(audio_stream_info, 'channels')\n        stream_audio_channel_layouts_ = helpers.get_xml_attr(audio_stream_info, 'audioChannelLayout')\n        audio_details = {'stream_audio_bitrate': helpers.get_xml_attr(audio_stream_info, 'bitrate'), 'stream_audio_bitrate_mode': helpers.get_xml_attr(audio_stream_info, 'bitrateMode'), 'stream_audio_channels': stream_audio_channels, 'stream_audio_channel_layout': stream_audio_channel_layouts_ or common.AUDIO_CHANNELS.get(stream_audio_channels, stream_audio_channels), 'stream_audio_codec': helpers.get_xml_attr(audio_stream_info, 'codec'), 'stream_audio_sample_rate': helpers.get_xml_attr(audio_stream_info, 'samplingRate'), 'stream_audio_channel_layout_': stream_audio_channel_layouts_, 'stream_audio_language': helpers.get_xml_attr(audio_stream_info, 'language'), 'stream_audio_language_code': helpers.get_xml_attr(audio_stream_info, 'languageCode'), 'stream_audio_decision': helpers.get_xml_attr(audio_stream_info, 'decision') or 'direct play'}\n    else:\n        audio_details = {'stream_audio_bitrate': '', 'stream_audio_bitrate_mode': '', 'stream_audio_channels': '', 'stream_audio_channel_layout': '', 'stream_audio_codec': '', 'stream_audio_sample_rate': '', 'stream_audio_channel_layout_': '', 'stream_audio_language': '', 'stream_audio_language_code': '', 'stream_audio_decision': ''}\n    if subtitle_stream_info:\n        subtitle_id = helpers.get_xml_attr(subtitle_stream_info, 'id')\n        subtitle_selected = helpers.get_xml_attr(subtitle_stream_info, 'selected')\n        subtitle_details = {'stream_subtitle_codec': helpers.get_xml_attr(subtitle_stream_info, 'codec'), 'stream_subtitle_container': helpers.get_xml_attr(subtitle_stream_info, 'container'), 'stream_subtitle_format': helpers.get_xml_attr(subtitle_stream_info, 'format'), 'stream_subtitle_forced': int(helpers.get_xml_attr(subtitle_stream_info, 'forced') == '1'), 'stream_subtitle_location': helpers.get_xml_attr(subtitle_stream_info, 'location'), 'stream_subtitle_language': helpers.get_xml_attr(subtitle_stream_info, 'language'), 'stream_subtitle_language_code': helpers.get_xml_attr(subtitle_stream_info, 'languageCode'), 'stream_subtitle_decision': helpers.get_xml_attr(subtitle_stream_info, 'decision') or transcode_details['subtitle_decision'], 'stream_subtitle_transient': int(helpers.get_xml_attr(subtitle_stream_info, 'transient') == '1')}\n    else:\n        subtitle_selected = None\n        subtitle_details = {'stream_subtitle_codec': '', 'stream_subtitle_container': '', 'stream_subtitle_format': '', 'stream_subtitle_forced': 0, 'stream_subtitle_location': '', 'stream_subtitle_language': '', 'stream_subtitle_language_code': '', 'stream_subtitle_decision': '', 'stream_subtitle_transient': 0}\n    indexes = helpers.get_xml_attr(stream_media_parts_info, 'indexes')\n    view_offset = helpers.get_xml_attr(session, 'viewOffset')\n    if indexes == 'sd':\n        part_id = helpers.get_xml_attr(stream_media_parts_info, 'id')\n        bif_thumb = '/library/parts/{part_id}/indexes/sd/{view_offset}'.format(part_id=part_id, view_offset=view_offset)\n    else:\n        bif_thumb = ''\n    if helpers.cast_to_int(video_details['stream_video_width']) >= 3840:\n        stream_video_resolution = '4k'\n    else:\n        stream_video_resolution = helpers.get_xml_attr(stream_media_info, 'videoResolution').lower().rstrip('ip')\n    stream_details = {'stream_container': helpers.get_xml_attr(stream_media_info, 'container'), 'stream_bitrate': helpers.get_xml_attr(stream_media_info, 'bitrate'), 'stream_aspect_ratio': helpers.get_xml_attr(stream_media_info, 'aspectRatio'), 'stream_video_framerate': helpers.get_xml_attr(stream_media_info, 'videoFrameRate'), 'stream_video_resolution': stream_video_resolution, 'stream_duration': helpers.get_xml_attr(stream_media_info, 'duration') or helpers.get_xml_attr(session, 'duration'), 'stream_container_decision': helpers.get_xml_attr(stream_media_parts_info, 'decision').replace('directplay', 'direct play'), 'optimized_version': int(helpers.get_xml_attr(stream_media_info, 'proxyType') == '42'), 'optimized_version_title': helpers.get_xml_attr(stream_media_info, 'title'), 'synced_version': 0, 'live': int(helpers.get_xml_attr(session, 'live') == '1'), 'live_uuid': helpers.get_xml_attr(stream_media_info, 'uuid'), 'indexes': int(indexes == 'sd'), 'bif_thumb': bif_thumb, 'subtitles': 1 if subtitle_id and subtitle_selected else 0}\n    source_media_details = source_media_part_details = source_video_details = source_audio_details = source_subtitle_details = {}\n    if not helpers.get_xml_attr(session, 'ratingKey').isdigit():\n        channel_stream = 1\n        audio_channels = helpers.get_xml_attr(stream_media_info, 'audioChannels')\n        metadata_details = {'media_type': media_type, 'section_id': helpers.get_xml_attr(session, 'librarySectionID'), 'library_name': helpers.get_xml_attr(session, 'librarySectionTitle'), 'rating_key': helpers.get_xml_attr(session, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(session, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(session, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(session, 'title'), 'parent_title': helpers.get_xml_attr(session, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(session, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(session, 'originalTitle'), 'sort_title': helpers.get_xml_attr(session, 'titleSort'), 'media_index': helpers.get_xml_attr(session, 'index'), 'parent_media_index': helpers.get_xml_attr(session, 'parentIndex'), 'studio': helpers.get_xml_attr(session, 'studio'), 'content_rating': helpers.get_xml_attr(session, 'contentRating'), 'summary': helpers.get_xml_attr(session, 'summary'), 'tagline': helpers.get_xml_attr(session, 'tagline'), 'rating': helpers.get_xml_attr(session, 'rating'), 'rating_image': helpers.get_xml_attr(session, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(session, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(session, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(session, 'userRating'), 'duration': helpers.get_xml_attr(session, 'duration'), 'year': helpers.get_xml_attr(session, 'year'), 'thumb': helpers.get_xml_attr(session, 'thumb'), 'parent_thumb': helpers.get_xml_attr(session, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(session, 'grandparentThumb'), 'art': helpers.get_xml_attr(session, 'art'), 'banner': helpers.get_xml_attr(session, 'banner'), 'originally_available_at': helpers.get_xml_attr(session, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(session, 'addedAt'), 'updated_at': helpers.get_xml_attr(session, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(session, 'lastViewedAt'), 'guid': helpers.get_xml_attr(session, 'guid'), 'directors': [], 'writers': [], 'actors': [], 'genres': [], 'labels': [], 'full_title': helpers.get_xml_attr(session, 'title'), 'container': helpers.get_xml_attr(stream_media_info, 'container') or helpers.get_xml_attr(stream_media_parts_info, 'container'), 'bitrate': helpers.get_xml_attr(stream_media_info, 'bitrate'), 'height': helpers.get_xml_attr(stream_media_info, 'height'), 'width': helpers.get_xml_attr(stream_media_info, 'width'), 'aspect_ratio': helpers.get_xml_attr(stream_media_info, 'aspectRatio'), 'video_codec': helpers.get_xml_attr(stream_media_info, 'videoCodec'), 'video_resolution': helpers.get_xml_attr(stream_media_info, 'videoResolution').lower(), 'video_full_resolution': helpers.get_xml_attr(stream_media_info, 'videoResolution').lower(), 'video_framerate': helpers.get_xml_attr(stream_media_info, 'videoFrameRate'), 'video_profile': helpers.get_xml_attr(stream_media_info, 'videoProfile'), 'audio_codec': helpers.get_xml_attr(stream_media_info, 'audioCodec'), 'audio_channels': audio_channels, 'audio_channel_layout': common.AUDIO_CHANNELS.get(audio_channels, audio_channels), 'audio_profile': helpers.get_xml_attr(stream_media_info, 'audioProfile'), 'channel_icon': helpers.get_xml_attr(session, 'sourceIcon'), 'channel_title': helpers.get_xml_attr(session, 'sourceTitle'), 'extra_type': helpers.get_xml_attr(session, 'extraType'), 'sub_type': helpers.get_xml_attr(session, 'subtype')}\n    else:\n        channel_stream = 0\n        media_id = helpers.get_xml_attr(stream_media_info, 'id')\n        part_id = helpers.get_xml_attr(stream_media_parts_info, 'id')\n        metadata_details = self.get_metadata_details(rating_key=rating_key, skip_cache=skip_cache, cache_key=session_key)\n        source_medias = metadata_details.pop('media_info', [])\n        source_media_details = next((m for m in source_medias if m['id'] == media_id), next((m for m in source_medias), {}))\n        source_media_parts = source_media_details.pop('parts', [])\n        source_media_part_details = next((p for p in source_media_parts if p['id'] == part_id), next((p for p in source_media_parts), {}))\n        source_media_part_streams = source_media_part_details.pop('streams', [])\n        source_video_details = {'id': '', 'type': '', 'video_codec': '', 'video_codec_level': '', 'video_bitrate': '', 'video_bit_depth': '', 'video_chroma_subsampling': '', 'video_color_primaries': '', 'video_color_range': '', 'video_color_space': '', 'video_color_trc': '', 'video_dynamic_range': '', 'video_frame_rate': '', 'video_ref_frames': '', 'video_height': '', 'video_width': '', 'video_language': '', 'video_language_code': '', 'video_scan_type': '', 'video_profile': ''}\n        source_audio_details = {'id': '', 'type': '', 'audio_codec': '', 'audio_bitrate': '', 'audio_bitrate_mode': '', 'audio_channels': '', 'audio_channel_layout': '', 'audio_sample_rate': '', 'audio_language': '', 'audio_language_code': '', 'audio_profile': ''}\n        source_subtitle_details = {'id': '', 'type': '', 'subtitle_codec': '', 'subtitle_container': '', 'subtitle_format': '', 'subtitle_forced': 0, 'subtitle_location': '', 'subtitle_language': '', 'subtitle_language_code': ''}\n        if video_id:\n            source_video_details = next((p for p in source_media_part_streams if p['id'] == video_id), next((p for p in source_media_part_streams if p['type'] == '1'), source_video_details))\n        if audio_id:\n            source_audio_details = next((p for p in source_media_part_streams if p['id'] == audio_id), next((p for p in source_media_part_streams if p['type'] == '2'), source_audio_details))\n        if subtitle_id:\n            source_subtitle_details = next((p for p in source_media_part_streams if p['id'] == subtitle_id), next((p for p in source_media_part_streams if p['type'] == '3'), source_subtitle_details))\n    if media_type == 'clip' and metadata_details.get('extra_type') and metadata_details['art']:\n        metadata_details['thumb'] = metadata_details['art'].replace('/art', '/thumb')\n    if stream_details['live'] and transcode_session:\n        stream_details['stream_container_decision'] = 'transcode'\n        stream_details['stream_container'] = transcode_details['transcode_container']\n        video_details['stream_video_decision'] = transcode_details['video_decision']\n        video_details['stream_video_codec'] = transcode_details['transcode_video_codec']\n        audio_details['stream_audio_decision'] = transcode_details['audio_decision']\n        audio_details['stream_audio_codec'] = transcode_details['transcode_audio_codec']\n        audio_details['stream_audio_channels'] = transcode_details['transcode_audio_channels']\n        audio_details['stream_audio_channel_layout'] = common.AUDIO_CHANNELS.get(transcode_details['transcode_audio_channels'], transcode_details['transcode_audio_channels'])\n    if video_details['stream_video_decision'] == 'transcode' or audio_details['stream_audio_decision'] == 'transcode':\n        transcode_decision = 'transcode'\n    elif video_details['stream_video_decision'] == 'copy' or audio_details['stream_audio_decision'] == 'copy':\n        transcode_decision = 'copy'\n    else:\n        transcode_decision = 'direct play'\n    stream_details['transcode_decision'] = transcode_decision\n    stream_details['container_decision'] = stream_details['stream_container_decision']\n    if audio_details['stream_audio_codec'] == '*':\n        audio_details['stream_audio_codec'] = source_audio_details.get('audio_codec', '')\n    if transcode_details['transcode_audio_codec'] == '*':\n        transcode_details['transcode_audio_codec'] = source_audio_details.get('audio_codec', '')\n    if video_details['stream_video_codec'] == '*':\n        video_details['stream_video_codec'] = source_video_details.get('video_codec', '')\n    if transcode_details['transcode_video_codec'] == '*':\n        transcode_details['transcode_video_codec'] = source_video_details.get('video_codec', '')\n    if media_type in ('movie', 'episode', 'clip'):\n        stream_details['stream_video_full_resolution'] = common.VIDEO_RESOLUTION_OVERRIDES.get(stream_details['stream_video_resolution'], stream_details['stream_video_resolution'] + (video_details['stream_video_scan_type'][:1] or 'p'))\n    if media_type in ('movie', 'episode', 'clip') and 'stream_bitrate' in stream_details:\n        if video_details['stream_video_decision'] == 'transcode':\n            synced_version_profile = ''\n            stream_bitrate = helpers.cast_to_int(stream_details['stream_bitrate'])\n            source_bitrate = helpers.cast_to_int(source_media_details.get('bitrate'))\n            try:\n                quailtiy_bitrate = min((b for b in common.VIDEO_QUALITY_PROFILES if stream_bitrate <= b <= source_bitrate))\n                quality_profile = common.VIDEO_QUALITY_PROFILES[quailtiy_bitrate]\n            except ValueError:\n                quality_profile = 'Original'\n        else:\n            synced_version_profile = ''\n            quality_profile = 'Original'\n        if stream_details['optimized_version']:\n            source_bitrate = helpers.cast_to_int(source_media_details.get('bitrate'))\n            optimized_version_profile = '{} Mbps {}'.format(round(source_bitrate / 1000.0, 1), source_media_details.get('video_full_resolution'))\n        else:\n            optimized_version_profile = ''\n    elif media_type == 'track' and 'stream_bitrate' in stream_details:\n        synced_version_profile = ''\n        stream_bitrate = helpers.cast_to_int(stream_details['stream_bitrate'])\n        source_bitrate = helpers.cast_to_int(source_media_details.get('bitrate'))\n        try:\n            quailtiy_bitrate = min((b for b in common.AUDIO_QUALITY_PROFILES if stream_bitrate <= b <= source_bitrate))\n            quality_profile = common.AUDIO_QUALITY_PROFILES[quailtiy_bitrate]\n        except ValueError:\n            quality_profile = 'Original'\n        optimized_version_profile = ''\n    elif media_type == 'photo':\n        quality_profile = 'Original'\n        synced_version_profile = ''\n        optimized_version_profile = ''\n    else:\n        quality_profile = 'Unknown'\n        synced_version_profile = ''\n        optimized_version_profile = ''\n    session_output = {'session_key': session_key, 'media_type': media_type, 'view_offset': view_offset, 'progress_percent': str(helpers.get_percent(view_offset, stream_details['stream_duration'])), 'quality_profile': quality_profile, 'synced_version_profile': synced_version_profile, 'optimized_version_profile': optimized_version_profile, 'user': user_details['username'], 'channel_stream': channel_stream}\n    session_output.update(metadata_details)\n    session_output.update(source_media_details)\n    session_output.update(source_media_part_details)\n    session_output.update(source_video_details)\n    session_output.update(source_audio_details)\n    session_output.update(source_subtitle_details)\n    session_output.update(user_details)\n    session_output.update(player_details)\n    session_output.update(session_details)\n    session_output.update(transcode_details)\n    session_output.update(stream_details)\n    session_output.update(video_details)\n    session_output.update(audio_details)\n    session_output.update(subtitle_details)\n    return session_output",
            "def get_session_each(self, session=None, skip_cache=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Return selected data from current sessions.\\n        This function processes and validates session data\\n\\n        Parameters required:    session { the session dictionary }\\n        Output: dict\\n        '\n    media_type = helpers.get_xml_attr(session, 'type')\n    rating_key = helpers.get_xml_attr(session, 'ratingKey')\n    session_key = helpers.get_xml_attr(session, 'sessionKey')\n    user_info = session.getElementsByTagName('User')[0]\n    user_id = helpers.get_xml_attr(user_info, 'id')\n    if user_id == '1':\n        user_details = users.Users().get_details(user=helpers.get_xml_attr(user_info, 'title'))\n    else:\n        user_details = users.Users().get_details(user_id=user_id)\n    player_info = session.getElementsByTagName('Player')[0]\n    platform = helpers.get_xml_attr(player_info, 'platform')\n    platform = common.PLATFORM_NAME_OVERRIDES.get(platform, platform)\n    if not platform and helpers.get_xml_attr(player_info, 'product') == 'DLNA':\n        platform = 'DLNA'\n    platform_name = next((v for (k, v) in common.PLATFORM_NAMES.items() if k in platform.lower()), 'default')\n    player_details = {'ip_address': helpers.get_xml_attr(player_info, 'address').split('::ffff:')[-1], 'ip_address_public': helpers.get_xml_attr(player_info, 'remotePublicAddress').split('::ffff:')[-1], 'device': helpers.get_xml_attr(player_info, 'device'), 'platform': platform, 'platform_name': platform_name, 'platform_version': helpers.get_xml_attr(player_info, 'platformVersion'), 'product': helpers.get_xml_attr(player_info, 'product'), 'product_version': helpers.get_xml_attr(player_info, 'version'), 'profile': helpers.get_xml_attr(player_info, 'profile'), 'player': helpers.get_xml_attr(player_info, 'title') or helpers.get_xml_attr(player_info, 'product'), 'machine_id': helpers.get_xml_attr(player_info, 'machineIdentifier'), 'state': helpers.get_xml_attr(player_info, 'state'), 'local': int(helpers.get_xml_attr(player_info, 'local') == '1'), 'relayed': helpers.get_xml_attr(player_info, 'relayed', default_return=None), 'secure': helpers.get_xml_attr(player_info, 'secure', default_return=None)}\n    if session.getElementsByTagName('Session'):\n        session_info = session.getElementsByTagName('Session')[0]\n        session_details = {'session_id': helpers.get_xml_attr(session_info, 'id'), 'bandwidth': helpers.get_xml_attr(session_info, 'bandwidth'), 'location': helpers.get_xml_attr(session_info, 'location')}\n    else:\n        session_details = {'session_id': '', 'bandwidth': '', 'location': 'lan' if player_details['local'] else 'wan'}\n    if player_details['relayed'] is None:\n        player_details['relayed'] = int(session_details['location'] != 'lan' and player_details['ip_address_public'] == '127.0.0.1')\n    else:\n        player_details['relayed'] = helpers.cast_to_int(player_details['relayed'])\n    if player_details['secure'] is not None:\n        player_details['secure'] = int(player_details['secure'] == '1')\n    if session.getElementsByTagName('TranscodeSession'):\n        transcode_session = True\n        transcode_info = session.getElementsByTagName('TranscodeSession')[0]\n        transcode_progress = helpers.get_xml_attr(transcode_info, 'progress')\n        transcode_speed = helpers.get_xml_attr(transcode_info, 'speed')\n        transcode_min_offset = helpers.get_xml_attr(transcode_info, 'minOffsetAvailable')\n        transcode_max_offset = helpers.get_xml_attr(transcode_info, 'maxOffsetAvailable')\n        transcode_details = {'transcode_key': helpers.get_xml_attr(transcode_info, 'key'), 'transcode_throttled': int(helpers.get_xml_attr(transcode_info, 'throttled') == '1'), 'transcode_progress': int(round(helpers.cast_to_float(transcode_progress), 0)), 'transcode_speed': str(round(helpers.cast_to_float(transcode_speed), 1)), 'transcode_audio_channels': helpers.get_xml_attr(transcode_info, 'audioChannels'), 'transcode_audio_codec': helpers.get_xml_attr(transcode_info, 'audioCodec'), 'transcode_video_codec': helpers.get_xml_attr(transcode_info, 'videoCodec'), 'transcode_width': helpers.get_xml_attr(transcode_info, 'width'), 'transcode_height': helpers.get_xml_attr(transcode_info, 'height'), 'transcode_container': helpers.get_xml_attr(transcode_info, 'container'), 'transcode_protocol': helpers.get_xml_attr(transcode_info, 'protocol'), 'transcode_min_offset_available': int(round(helpers.cast_to_float(transcode_min_offset), 0)), 'transcode_max_offset_available': int(round(helpers.cast_to_float(transcode_max_offset), 0)), 'transcode_hw_requested': int(helpers.get_xml_attr(transcode_info, 'transcodeHwRequested') == '1'), 'transcode_hw_decode': helpers.get_xml_attr(transcode_info, 'transcodeHwDecoding'), 'transcode_hw_decode_title': helpers.get_xml_attr(transcode_info, 'transcodeHwDecodingTitle'), 'transcode_hw_encode': helpers.get_xml_attr(transcode_info, 'transcodeHwEncoding'), 'transcode_hw_encode_title': helpers.get_xml_attr(transcode_info, 'transcodeHwEncodingTitle'), 'transcode_hw_full_pipeline': int(helpers.get_xml_attr(transcode_info, 'transcodeHwFullPipeline') == '1'), 'audio_decision': helpers.get_xml_attr(transcode_info, 'audioDecision'), 'video_decision': helpers.get_xml_attr(transcode_info, 'videoDecision'), 'subtitle_decision': helpers.get_xml_attr(transcode_info, 'subtitleDecision'), 'throttled': '1' if helpers.get_xml_attr(transcode_info, 'throttled') == '1' else '0'}\n    else:\n        transcode_session = False\n        transcode_details = {'transcode_key': '', 'transcode_throttled': 0, 'transcode_progress': 0, 'transcode_speed': '', 'transcode_audio_channels': '', 'transcode_audio_codec': '', 'transcode_video_codec': '', 'transcode_width': '', 'transcode_height': '', 'transcode_container': '', 'transcode_protocol': '', 'transcode_min_offset_available': 0, 'transcode_max_offset_available': 0, 'transcode_hw_requested': 0, 'transcode_hw_decode': '', 'transcode_hw_decode_title': '', 'transcode_hw_encode': '', 'transcode_hw_encode_title': '', 'transcode_hw_full_pipeline': 0, 'audio_decision': 'direct play', 'video_decision': 'direct play', 'subtitle_decision': '', 'throttled': '0'}\n    transcode_details['transcode_hw_decoding'] = int(transcode_details['transcode_hw_decode'].lower() in common.HW_DECODERS)\n    transcode_details['transcode_hw_encoding'] = int(transcode_details['transcode_hw_encode'].lower() in common.HW_ENCODERS)\n    media_info_all = session.getElementsByTagName('Media')\n    stream_media_info = next((m for m in media_info_all if helpers.get_xml_attr(m, 'selected') == '1'), media_info_all[0])\n    part_info_all = stream_media_info.getElementsByTagName('Part')\n    stream_media_parts_info = next((p for p in part_info_all if helpers.get_xml_attr(p, 'selected') == '1'), part_info_all[0])\n    video_stream_info = audio_stream_info = subtitle_stream_info = None\n    for stream in stream_media_parts_info.getElementsByTagName('Stream'):\n        if helpers.get_xml_attr(stream, 'streamType') == '1':\n            if video_stream_info is None or helpers.get_xml_attr(stream, 'selected') == '1':\n                video_stream_info = stream\n        elif helpers.get_xml_attr(stream, 'streamType') == '2':\n            if audio_stream_info is None or helpers.get_xml_attr(stream, 'selected') == '1':\n                audio_stream_info = stream\n        elif helpers.get_xml_attr(stream, 'streamType') == '3':\n            if subtitle_stream_info is None or helpers.get_xml_attr(stream, 'selected') == '1':\n                subtitle_stream_info = stream\n    video_id = audio_id = subtitle_id = None\n    if video_stream_info:\n        video_id = helpers.get_xml_attr(video_stream_info, 'id')\n        video_details = {'stream_video_bitrate': helpers.get_xml_attr(video_stream_info, 'bitrate'), 'stream_video_bit_depth': helpers.get_xml_attr(video_stream_info, 'bitDepth'), 'stream_video_chroma_subsampling': helpers.get_xml_attr(video_stream_info, 'chromaSubsampling'), 'stream_video_codec': helpers.get_xml_attr(video_stream_info, 'codec'), 'stream_video_codec_level': helpers.get_xml_attr(video_stream_info, 'level'), 'stream_video_color_primaries': helpers.get_xml_attr(video_stream_info, 'colorPrimaries'), 'stream_video_color_range': helpers.get_xml_attr(video_stream_info, 'colorRange'), 'stream_video_color_space': helpers.get_xml_attr(video_stream_info, 'colorSpace'), 'stream_video_color_trc': helpers.get_xml_attr(video_stream_info, 'colorTrc'), 'stream_video_dynamic_range': self.get_dynamic_range(video_stream_info), 'stream_video_height': helpers.get_xml_attr(video_stream_info, 'height'), 'stream_video_width': helpers.get_xml_attr(video_stream_info, 'width'), 'stream_video_ref_frames': helpers.get_xml_attr(video_stream_info, 'refFrames'), 'stream_video_language': helpers.get_xml_attr(video_stream_info, 'language'), 'stream_video_language_code': helpers.get_xml_attr(video_stream_info, 'languageCode'), 'stream_video_scan_type': helpers.get_xml_attr(video_stream_info, 'scanType'), 'stream_video_decision': helpers.get_xml_attr(video_stream_info, 'decision') or 'direct play'}\n    else:\n        video_details = {'stream_video_bitrate': '', 'stream_video_bit_depth': '', 'stream_video_chroma_subsampling': '', 'stream_video_codec': '', 'stream_video_codec_level': '', 'stream_video_color_primaries': '', 'stream_video_color_range': '', 'stream_video_color_space': '', 'stream_video_color_trc': '', 'stream_video_dynamic_range': '', 'stream_video_height': '', 'stream_video_width': '', 'stream_video_ref_frames': '', 'stream_video_language': '', 'stream_video_language_code': '', 'stream_video_scan_type': '', 'stream_video_decision': ''}\n    if audio_stream_info:\n        audio_id = helpers.get_xml_attr(audio_stream_info, 'id')\n        stream_audio_channels = helpers.get_xml_attr(audio_stream_info, 'channels')\n        stream_audio_channel_layouts_ = helpers.get_xml_attr(audio_stream_info, 'audioChannelLayout')\n        audio_details = {'stream_audio_bitrate': helpers.get_xml_attr(audio_stream_info, 'bitrate'), 'stream_audio_bitrate_mode': helpers.get_xml_attr(audio_stream_info, 'bitrateMode'), 'stream_audio_channels': stream_audio_channels, 'stream_audio_channel_layout': stream_audio_channel_layouts_ or common.AUDIO_CHANNELS.get(stream_audio_channels, stream_audio_channels), 'stream_audio_codec': helpers.get_xml_attr(audio_stream_info, 'codec'), 'stream_audio_sample_rate': helpers.get_xml_attr(audio_stream_info, 'samplingRate'), 'stream_audio_channel_layout_': stream_audio_channel_layouts_, 'stream_audio_language': helpers.get_xml_attr(audio_stream_info, 'language'), 'stream_audio_language_code': helpers.get_xml_attr(audio_stream_info, 'languageCode'), 'stream_audio_decision': helpers.get_xml_attr(audio_stream_info, 'decision') or 'direct play'}\n    else:\n        audio_details = {'stream_audio_bitrate': '', 'stream_audio_bitrate_mode': '', 'stream_audio_channels': '', 'stream_audio_channel_layout': '', 'stream_audio_codec': '', 'stream_audio_sample_rate': '', 'stream_audio_channel_layout_': '', 'stream_audio_language': '', 'stream_audio_language_code': '', 'stream_audio_decision': ''}\n    if subtitle_stream_info:\n        subtitle_id = helpers.get_xml_attr(subtitle_stream_info, 'id')\n        subtitle_selected = helpers.get_xml_attr(subtitle_stream_info, 'selected')\n        subtitle_details = {'stream_subtitle_codec': helpers.get_xml_attr(subtitle_stream_info, 'codec'), 'stream_subtitle_container': helpers.get_xml_attr(subtitle_stream_info, 'container'), 'stream_subtitle_format': helpers.get_xml_attr(subtitle_stream_info, 'format'), 'stream_subtitle_forced': int(helpers.get_xml_attr(subtitle_stream_info, 'forced') == '1'), 'stream_subtitle_location': helpers.get_xml_attr(subtitle_stream_info, 'location'), 'stream_subtitle_language': helpers.get_xml_attr(subtitle_stream_info, 'language'), 'stream_subtitle_language_code': helpers.get_xml_attr(subtitle_stream_info, 'languageCode'), 'stream_subtitle_decision': helpers.get_xml_attr(subtitle_stream_info, 'decision') or transcode_details['subtitle_decision'], 'stream_subtitle_transient': int(helpers.get_xml_attr(subtitle_stream_info, 'transient') == '1')}\n    else:\n        subtitle_selected = None\n        subtitle_details = {'stream_subtitle_codec': '', 'stream_subtitle_container': '', 'stream_subtitle_format': '', 'stream_subtitle_forced': 0, 'stream_subtitle_location': '', 'stream_subtitle_language': '', 'stream_subtitle_language_code': '', 'stream_subtitle_decision': '', 'stream_subtitle_transient': 0}\n    indexes = helpers.get_xml_attr(stream_media_parts_info, 'indexes')\n    view_offset = helpers.get_xml_attr(session, 'viewOffset')\n    if indexes == 'sd':\n        part_id = helpers.get_xml_attr(stream_media_parts_info, 'id')\n        bif_thumb = '/library/parts/{part_id}/indexes/sd/{view_offset}'.format(part_id=part_id, view_offset=view_offset)\n    else:\n        bif_thumb = ''\n    if helpers.cast_to_int(video_details['stream_video_width']) >= 3840:\n        stream_video_resolution = '4k'\n    else:\n        stream_video_resolution = helpers.get_xml_attr(stream_media_info, 'videoResolution').lower().rstrip('ip')\n    stream_details = {'stream_container': helpers.get_xml_attr(stream_media_info, 'container'), 'stream_bitrate': helpers.get_xml_attr(stream_media_info, 'bitrate'), 'stream_aspect_ratio': helpers.get_xml_attr(stream_media_info, 'aspectRatio'), 'stream_video_framerate': helpers.get_xml_attr(stream_media_info, 'videoFrameRate'), 'stream_video_resolution': stream_video_resolution, 'stream_duration': helpers.get_xml_attr(stream_media_info, 'duration') or helpers.get_xml_attr(session, 'duration'), 'stream_container_decision': helpers.get_xml_attr(stream_media_parts_info, 'decision').replace('directplay', 'direct play'), 'optimized_version': int(helpers.get_xml_attr(stream_media_info, 'proxyType') == '42'), 'optimized_version_title': helpers.get_xml_attr(stream_media_info, 'title'), 'synced_version': 0, 'live': int(helpers.get_xml_attr(session, 'live') == '1'), 'live_uuid': helpers.get_xml_attr(stream_media_info, 'uuid'), 'indexes': int(indexes == 'sd'), 'bif_thumb': bif_thumb, 'subtitles': 1 if subtitle_id and subtitle_selected else 0}\n    source_media_details = source_media_part_details = source_video_details = source_audio_details = source_subtitle_details = {}\n    if not helpers.get_xml_attr(session, 'ratingKey').isdigit():\n        channel_stream = 1\n        audio_channels = helpers.get_xml_attr(stream_media_info, 'audioChannels')\n        metadata_details = {'media_type': media_type, 'section_id': helpers.get_xml_attr(session, 'librarySectionID'), 'library_name': helpers.get_xml_attr(session, 'librarySectionTitle'), 'rating_key': helpers.get_xml_attr(session, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(session, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(session, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(session, 'title'), 'parent_title': helpers.get_xml_attr(session, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(session, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(session, 'originalTitle'), 'sort_title': helpers.get_xml_attr(session, 'titleSort'), 'media_index': helpers.get_xml_attr(session, 'index'), 'parent_media_index': helpers.get_xml_attr(session, 'parentIndex'), 'studio': helpers.get_xml_attr(session, 'studio'), 'content_rating': helpers.get_xml_attr(session, 'contentRating'), 'summary': helpers.get_xml_attr(session, 'summary'), 'tagline': helpers.get_xml_attr(session, 'tagline'), 'rating': helpers.get_xml_attr(session, 'rating'), 'rating_image': helpers.get_xml_attr(session, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(session, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(session, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(session, 'userRating'), 'duration': helpers.get_xml_attr(session, 'duration'), 'year': helpers.get_xml_attr(session, 'year'), 'thumb': helpers.get_xml_attr(session, 'thumb'), 'parent_thumb': helpers.get_xml_attr(session, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(session, 'grandparentThumb'), 'art': helpers.get_xml_attr(session, 'art'), 'banner': helpers.get_xml_attr(session, 'banner'), 'originally_available_at': helpers.get_xml_attr(session, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(session, 'addedAt'), 'updated_at': helpers.get_xml_attr(session, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(session, 'lastViewedAt'), 'guid': helpers.get_xml_attr(session, 'guid'), 'directors': [], 'writers': [], 'actors': [], 'genres': [], 'labels': [], 'full_title': helpers.get_xml_attr(session, 'title'), 'container': helpers.get_xml_attr(stream_media_info, 'container') or helpers.get_xml_attr(stream_media_parts_info, 'container'), 'bitrate': helpers.get_xml_attr(stream_media_info, 'bitrate'), 'height': helpers.get_xml_attr(stream_media_info, 'height'), 'width': helpers.get_xml_attr(stream_media_info, 'width'), 'aspect_ratio': helpers.get_xml_attr(stream_media_info, 'aspectRatio'), 'video_codec': helpers.get_xml_attr(stream_media_info, 'videoCodec'), 'video_resolution': helpers.get_xml_attr(stream_media_info, 'videoResolution').lower(), 'video_full_resolution': helpers.get_xml_attr(stream_media_info, 'videoResolution').lower(), 'video_framerate': helpers.get_xml_attr(stream_media_info, 'videoFrameRate'), 'video_profile': helpers.get_xml_attr(stream_media_info, 'videoProfile'), 'audio_codec': helpers.get_xml_attr(stream_media_info, 'audioCodec'), 'audio_channels': audio_channels, 'audio_channel_layout': common.AUDIO_CHANNELS.get(audio_channels, audio_channels), 'audio_profile': helpers.get_xml_attr(stream_media_info, 'audioProfile'), 'channel_icon': helpers.get_xml_attr(session, 'sourceIcon'), 'channel_title': helpers.get_xml_attr(session, 'sourceTitle'), 'extra_type': helpers.get_xml_attr(session, 'extraType'), 'sub_type': helpers.get_xml_attr(session, 'subtype')}\n    else:\n        channel_stream = 0\n        media_id = helpers.get_xml_attr(stream_media_info, 'id')\n        part_id = helpers.get_xml_attr(stream_media_parts_info, 'id')\n        metadata_details = self.get_metadata_details(rating_key=rating_key, skip_cache=skip_cache, cache_key=session_key)\n        source_medias = metadata_details.pop('media_info', [])\n        source_media_details = next((m for m in source_medias if m['id'] == media_id), next((m for m in source_medias), {}))\n        source_media_parts = source_media_details.pop('parts', [])\n        source_media_part_details = next((p for p in source_media_parts if p['id'] == part_id), next((p for p in source_media_parts), {}))\n        source_media_part_streams = source_media_part_details.pop('streams', [])\n        source_video_details = {'id': '', 'type': '', 'video_codec': '', 'video_codec_level': '', 'video_bitrate': '', 'video_bit_depth': '', 'video_chroma_subsampling': '', 'video_color_primaries': '', 'video_color_range': '', 'video_color_space': '', 'video_color_trc': '', 'video_dynamic_range': '', 'video_frame_rate': '', 'video_ref_frames': '', 'video_height': '', 'video_width': '', 'video_language': '', 'video_language_code': '', 'video_scan_type': '', 'video_profile': ''}\n        source_audio_details = {'id': '', 'type': '', 'audio_codec': '', 'audio_bitrate': '', 'audio_bitrate_mode': '', 'audio_channels': '', 'audio_channel_layout': '', 'audio_sample_rate': '', 'audio_language': '', 'audio_language_code': '', 'audio_profile': ''}\n        source_subtitle_details = {'id': '', 'type': '', 'subtitle_codec': '', 'subtitle_container': '', 'subtitle_format': '', 'subtitle_forced': 0, 'subtitle_location': '', 'subtitle_language': '', 'subtitle_language_code': ''}\n        if video_id:\n            source_video_details = next((p for p in source_media_part_streams if p['id'] == video_id), next((p for p in source_media_part_streams if p['type'] == '1'), source_video_details))\n        if audio_id:\n            source_audio_details = next((p for p in source_media_part_streams if p['id'] == audio_id), next((p for p in source_media_part_streams if p['type'] == '2'), source_audio_details))\n        if subtitle_id:\n            source_subtitle_details = next((p for p in source_media_part_streams if p['id'] == subtitle_id), next((p for p in source_media_part_streams if p['type'] == '3'), source_subtitle_details))\n    if media_type == 'clip' and metadata_details.get('extra_type') and metadata_details['art']:\n        metadata_details['thumb'] = metadata_details['art'].replace('/art', '/thumb')\n    if stream_details['live'] and transcode_session:\n        stream_details['stream_container_decision'] = 'transcode'\n        stream_details['stream_container'] = transcode_details['transcode_container']\n        video_details['stream_video_decision'] = transcode_details['video_decision']\n        video_details['stream_video_codec'] = transcode_details['transcode_video_codec']\n        audio_details['stream_audio_decision'] = transcode_details['audio_decision']\n        audio_details['stream_audio_codec'] = transcode_details['transcode_audio_codec']\n        audio_details['stream_audio_channels'] = transcode_details['transcode_audio_channels']\n        audio_details['stream_audio_channel_layout'] = common.AUDIO_CHANNELS.get(transcode_details['transcode_audio_channels'], transcode_details['transcode_audio_channels'])\n    if video_details['stream_video_decision'] == 'transcode' or audio_details['stream_audio_decision'] == 'transcode':\n        transcode_decision = 'transcode'\n    elif video_details['stream_video_decision'] == 'copy' or audio_details['stream_audio_decision'] == 'copy':\n        transcode_decision = 'copy'\n    else:\n        transcode_decision = 'direct play'\n    stream_details['transcode_decision'] = transcode_decision\n    stream_details['container_decision'] = stream_details['stream_container_decision']\n    if audio_details['stream_audio_codec'] == '*':\n        audio_details['stream_audio_codec'] = source_audio_details.get('audio_codec', '')\n    if transcode_details['transcode_audio_codec'] == '*':\n        transcode_details['transcode_audio_codec'] = source_audio_details.get('audio_codec', '')\n    if video_details['stream_video_codec'] == '*':\n        video_details['stream_video_codec'] = source_video_details.get('video_codec', '')\n    if transcode_details['transcode_video_codec'] == '*':\n        transcode_details['transcode_video_codec'] = source_video_details.get('video_codec', '')\n    if media_type in ('movie', 'episode', 'clip'):\n        stream_details['stream_video_full_resolution'] = common.VIDEO_RESOLUTION_OVERRIDES.get(stream_details['stream_video_resolution'], stream_details['stream_video_resolution'] + (video_details['stream_video_scan_type'][:1] or 'p'))\n    if media_type in ('movie', 'episode', 'clip') and 'stream_bitrate' in stream_details:\n        if video_details['stream_video_decision'] == 'transcode':\n            synced_version_profile = ''\n            stream_bitrate = helpers.cast_to_int(stream_details['stream_bitrate'])\n            source_bitrate = helpers.cast_to_int(source_media_details.get('bitrate'))\n            try:\n                quailtiy_bitrate = min((b for b in common.VIDEO_QUALITY_PROFILES if stream_bitrate <= b <= source_bitrate))\n                quality_profile = common.VIDEO_QUALITY_PROFILES[quailtiy_bitrate]\n            except ValueError:\n                quality_profile = 'Original'\n        else:\n            synced_version_profile = ''\n            quality_profile = 'Original'\n        if stream_details['optimized_version']:\n            source_bitrate = helpers.cast_to_int(source_media_details.get('bitrate'))\n            optimized_version_profile = '{} Mbps {}'.format(round(source_bitrate / 1000.0, 1), source_media_details.get('video_full_resolution'))\n        else:\n            optimized_version_profile = ''\n    elif media_type == 'track' and 'stream_bitrate' in stream_details:\n        synced_version_profile = ''\n        stream_bitrate = helpers.cast_to_int(stream_details['stream_bitrate'])\n        source_bitrate = helpers.cast_to_int(source_media_details.get('bitrate'))\n        try:\n            quailtiy_bitrate = min((b for b in common.AUDIO_QUALITY_PROFILES if stream_bitrate <= b <= source_bitrate))\n            quality_profile = common.AUDIO_QUALITY_PROFILES[quailtiy_bitrate]\n        except ValueError:\n            quality_profile = 'Original'\n        optimized_version_profile = ''\n    elif media_type == 'photo':\n        quality_profile = 'Original'\n        synced_version_profile = ''\n        optimized_version_profile = ''\n    else:\n        quality_profile = 'Unknown'\n        synced_version_profile = ''\n        optimized_version_profile = ''\n    session_output = {'session_key': session_key, 'media_type': media_type, 'view_offset': view_offset, 'progress_percent': str(helpers.get_percent(view_offset, stream_details['stream_duration'])), 'quality_profile': quality_profile, 'synced_version_profile': synced_version_profile, 'optimized_version_profile': optimized_version_profile, 'user': user_details['username'], 'channel_stream': channel_stream}\n    session_output.update(metadata_details)\n    session_output.update(source_media_details)\n    session_output.update(source_media_part_details)\n    session_output.update(source_video_details)\n    session_output.update(source_audio_details)\n    session_output.update(source_subtitle_details)\n    session_output.update(user_details)\n    session_output.update(player_details)\n    session_output.update(session_details)\n    session_output.update(transcode_details)\n    session_output.update(stream_details)\n    session_output.update(video_details)\n    session_output.update(audio_details)\n    session_output.update(subtitle_details)\n    return session_output",
            "def get_session_each(self, session=None, skip_cache=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Return selected data from current sessions.\\n        This function processes and validates session data\\n\\n        Parameters required:    session { the session dictionary }\\n        Output: dict\\n        '\n    media_type = helpers.get_xml_attr(session, 'type')\n    rating_key = helpers.get_xml_attr(session, 'ratingKey')\n    session_key = helpers.get_xml_attr(session, 'sessionKey')\n    user_info = session.getElementsByTagName('User')[0]\n    user_id = helpers.get_xml_attr(user_info, 'id')\n    if user_id == '1':\n        user_details = users.Users().get_details(user=helpers.get_xml_attr(user_info, 'title'))\n    else:\n        user_details = users.Users().get_details(user_id=user_id)\n    player_info = session.getElementsByTagName('Player')[0]\n    platform = helpers.get_xml_attr(player_info, 'platform')\n    platform = common.PLATFORM_NAME_OVERRIDES.get(platform, platform)\n    if not platform and helpers.get_xml_attr(player_info, 'product') == 'DLNA':\n        platform = 'DLNA'\n    platform_name = next((v for (k, v) in common.PLATFORM_NAMES.items() if k in platform.lower()), 'default')\n    player_details = {'ip_address': helpers.get_xml_attr(player_info, 'address').split('::ffff:')[-1], 'ip_address_public': helpers.get_xml_attr(player_info, 'remotePublicAddress').split('::ffff:')[-1], 'device': helpers.get_xml_attr(player_info, 'device'), 'platform': platform, 'platform_name': platform_name, 'platform_version': helpers.get_xml_attr(player_info, 'platformVersion'), 'product': helpers.get_xml_attr(player_info, 'product'), 'product_version': helpers.get_xml_attr(player_info, 'version'), 'profile': helpers.get_xml_attr(player_info, 'profile'), 'player': helpers.get_xml_attr(player_info, 'title') or helpers.get_xml_attr(player_info, 'product'), 'machine_id': helpers.get_xml_attr(player_info, 'machineIdentifier'), 'state': helpers.get_xml_attr(player_info, 'state'), 'local': int(helpers.get_xml_attr(player_info, 'local') == '1'), 'relayed': helpers.get_xml_attr(player_info, 'relayed', default_return=None), 'secure': helpers.get_xml_attr(player_info, 'secure', default_return=None)}\n    if session.getElementsByTagName('Session'):\n        session_info = session.getElementsByTagName('Session')[0]\n        session_details = {'session_id': helpers.get_xml_attr(session_info, 'id'), 'bandwidth': helpers.get_xml_attr(session_info, 'bandwidth'), 'location': helpers.get_xml_attr(session_info, 'location')}\n    else:\n        session_details = {'session_id': '', 'bandwidth': '', 'location': 'lan' if player_details['local'] else 'wan'}\n    if player_details['relayed'] is None:\n        player_details['relayed'] = int(session_details['location'] != 'lan' and player_details['ip_address_public'] == '127.0.0.1')\n    else:\n        player_details['relayed'] = helpers.cast_to_int(player_details['relayed'])\n    if player_details['secure'] is not None:\n        player_details['secure'] = int(player_details['secure'] == '1')\n    if session.getElementsByTagName('TranscodeSession'):\n        transcode_session = True\n        transcode_info = session.getElementsByTagName('TranscodeSession')[0]\n        transcode_progress = helpers.get_xml_attr(transcode_info, 'progress')\n        transcode_speed = helpers.get_xml_attr(transcode_info, 'speed')\n        transcode_min_offset = helpers.get_xml_attr(transcode_info, 'minOffsetAvailable')\n        transcode_max_offset = helpers.get_xml_attr(transcode_info, 'maxOffsetAvailable')\n        transcode_details = {'transcode_key': helpers.get_xml_attr(transcode_info, 'key'), 'transcode_throttled': int(helpers.get_xml_attr(transcode_info, 'throttled') == '1'), 'transcode_progress': int(round(helpers.cast_to_float(transcode_progress), 0)), 'transcode_speed': str(round(helpers.cast_to_float(transcode_speed), 1)), 'transcode_audio_channels': helpers.get_xml_attr(transcode_info, 'audioChannels'), 'transcode_audio_codec': helpers.get_xml_attr(transcode_info, 'audioCodec'), 'transcode_video_codec': helpers.get_xml_attr(transcode_info, 'videoCodec'), 'transcode_width': helpers.get_xml_attr(transcode_info, 'width'), 'transcode_height': helpers.get_xml_attr(transcode_info, 'height'), 'transcode_container': helpers.get_xml_attr(transcode_info, 'container'), 'transcode_protocol': helpers.get_xml_attr(transcode_info, 'protocol'), 'transcode_min_offset_available': int(round(helpers.cast_to_float(transcode_min_offset), 0)), 'transcode_max_offset_available': int(round(helpers.cast_to_float(transcode_max_offset), 0)), 'transcode_hw_requested': int(helpers.get_xml_attr(transcode_info, 'transcodeHwRequested') == '1'), 'transcode_hw_decode': helpers.get_xml_attr(transcode_info, 'transcodeHwDecoding'), 'transcode_hw_decode_title': helpers.get_xml_attr(transcode_info, 'transcodeHwDecodingTitle'), 'transcode_hw_encode': helpers.get_xml_attr(transcode_info, 'transcodeHwEncoding'), 'transcode_hw_encode_title': helpers.get_xml_attr(transcode_info, 'transcodeHwEncodingTitle'), 'transcode_hw_full_pipeline': int(helpers.get_xml_attr(transcode_info, 'transcodeHwFullPipeline') == '1'), 'audio_decision': helpers.get_xml_attr(transcode_info, 'audioDecision'), 'video_decision': helpers.get_xml_attr(transcode_info, 'videoDecision'), 'subtitle_decision': helpers.get_xml_attr(transcode_info, 'subtitleDecision'), 'throttled': '1' if helpers.get_xml_attr(transcode_info, 'throttled') == '1' else '0'}\n    else:\n        transcode_session = False\n        transcode_details = {'transcode_key': '', 'transcode_throttled': 0, 'transcode_progress': 0, 'transcode_speed': '', 'transcode_audio_channels': '', 'transcode_audio_codec': '', 'transcode_video_codec': '', 'transcode_width': '', 'transcode_height': '', 'transcode_container': '', 'transcode_protocol': '', 'transcode_min_offset_available': 0, 'transcode_max_offset_available': 0, 'transcode_hw_requested': 0, 'transcode_hw_decode': '', 'transcode_hw_decode_title': '', 'transcode_hw_encode': '', 'transcode_hw_encode_title': '', 'transcode_hw_full_pipeline': 0, 'audio_decision': 'direct play', 'video_decision': 'direct play', 'subtitle_decision': '', 'throttled': '0'}\n    transcode_details['transcode_hw_decoding'] = int(transcode_details['transcode_hw_decode'].lower() in common.HW_DECODERS)\n    transcode_details['transcode_hw_encoding'] = int(transcode_details['transcode_hw_encode'].lower() in common.HW_ENCODERS)\n    media_info_all = session.getElementsByTagName('Media')\n    stream_media_info = next((m for m in media_info_all if helpers.get_xml_attr(m, 'selected') == '1'), media_info_all[0])\n    part_info_all = stream_media_info.getElementsByTagName('Part')\n    stream_media_parts_info = next((p for p in part_info_all if helpers.get_xml_attr(p, 'selected') == '1'), part_info_all[0])\n    video_stream_info = audio_stream_info = subtitle_stream_info = None\n    for stream in stream_media_parts_info.getElementsByTagName('Stream'):\n        if helpers.get_xml_attr(stream, 'streamType') == '1':\n            if video_stream_info is None or helpers.get_xml_attr(stream, 'selected') == '1':\n                video_stream_info = stream\n        elif helpers.get_xml_attr(stream, 'streamType') == '2':\n            if audio_stream_info is None or helpers.get_xml_attr(stream, 'selected') == '1':\n                audio_stream_info = stream\n        elif helpers.get_xml_attr(stream, 'streamType') == '3':\n            if subtitle_stream_info is None or helpers.get_xml_attr(stream, 'selected') == '1':\n                subtitle_stream_info = stream\n    video_id = audio_id = subtitle_id = None\n    if video_stream_info:\n        video_id = helpers.get_xml_attr(video_stream_info, 'id')\n        video_details = {'stream_video_bitrate': helpers.get_xml_attr(video_stream_info, 'bitrate'), 'stream_video_bit_depth': helpers.get_xml_attr(video_stream_info, 'bitDepth'), 'stream_video_chroma_subsampling': helpers.get_xml_attr(video_stream_info, 'chromaSubsampling'), 'stream_video_codec': helpers.get_xml_attr(video_stream_info, 'codec'), 'stream_video_codec_level': helpers.get_xml_attr(video_stream_info, 'level'), 'stream_video_color_primaries': helpers.get_xml_attr(video_stream_info, 'colorPrimaries'), 'stream_video_color_range': helpers.get_xml_attr(video_stream_info, 'colorRange'), 'stream_video_color_space': helpers.get_xml_attr(video_stream_info, 'colorSpace'), 'stream_video_color_trc': helpers.get_xml_attr(video_stream_info, 'colorTrc'), 'stream_video_dynamic_range': self.get_dynamic_range(video_stream_info), 'stream_video_height': helpers.get_xml_attr(video_stream_info, 'height'), 'stream_video_width': helpers.get_xml_attr(video_stream_info, 'width'), 'stream_video_ref_frames': helpers.get_xml_attr(video_stream_info, 'refFrames'), 'stream_video_language': helpers.get_xml_attr(video_stream_info, 'language'), 'stream_video_language_code': helpers.get_xml_attr(video_stream_info, 'languageCode'), 'stream_video_scan_type': helpers.get_xml_attr(video_stream_info, 'scanType'), 'stream_video_decision': helpers.get_xml_attr(video_stream_info, 'decision') or 'direct play'}\n    else:\n        video_details = {'stream_video_bitrate': '', 'stream_video_bit_depth': '', 'stream_video_chroma_subsampling': '', 'stream_video_codec': '', 'stream_video_codec_level': '', 'stream_video_color_primaries': '', 'stream_video_color_range': '', 'stream_video_color_space': '', 'stream_video_color_trc': '', 'stream_video_dynamic_range': '', 'stream_video_height': '', 'stream_video_width': '', 'stream_video_ref_frames': '', 'stream_video_language': '', 'stream_video_language_code': '', 'stream_video_scan_type': '', 'stream_video_decision': ''}\n    if audio_stream_info:\n        audio_id = helpers.get_xml_attr(audio_stream_info, 'id')\n        stream_audio_channels = helpers.get_xml_attr(audio_stream_info, 'channels')\n        stream_audio_channel_layouts_ = helpers.get_xml_attr(audio_stream_info, 'audioChannelLayout')\n        audio_details = {'stream_audio_bitrate': helpers.get_xml_attr(audio_stream_info, 'bitrate'), 'stream_audio_bitrate_mode': helpers.get_xml_attr(audio_stream_info, 'bitrateMode'), 'stream_audio_channels': stream_audio_channels, 'stream_audio_channel_layout': stream_audio_channel_layouts_ or common.AUDIO_CHANNELS.get(stream_audio_channels, stream_audio_channels), 'stream_audio_codec': helpers.get_xml_attr(audio_stream_info, 'codec'), 'stream_audio_sample_rate': helpers.get_xml_attr(audio_stream_info, 'samplingRate'), 'stream_audio_channel_layout_': stream_audio_channel_layouts_, 'stream_audio_language': helpers.get_xml_attr(audio_stream_info, 'language'), 'stream_audio_language_code': helpers.get_xml_attr(audio_stream_info, 'languageCode'), 'stream_audio_decision': helpers.get_xml_attr(audio_stream_info, 'decision') or 'direct play'}\n    else:\n        audio_details = {'stream_audio_bitrate': '', 'stream_audio_bitrate_mode': '', 'stream_audio_channels': '', 'stream_audio_channel_layout': '', 'stream_audio_codec': '', 'stream_audio_sample_rate': '', 'stream_audio_channel_layout_': '', 'stream_audio_language': '', 'stream_audio_language_code': '', 'stream_audio_decision': ''}\n    if subtitle_stream_info:\n        subtitle_id = helpers.get_xml_attr(subtitle_stream_info, 'id')\n        subtitle_selected = helpers.get_xml_attr(subtitle_stream_info, 'selected')\n        subtitle_details = {'stream_subtitle_codec': helpers.get_xml_attr(subtitle_stream_info, 'codec'), 'stream_subtitle_container': helpers.get_xml_attr(subtitle_stream_info, 'container'), 'stream_subtitle_format': helpers.get_xml_attr(subtitle_stream_info, 'format'), 'stream_subtitle_forced': int(helpers.get_xml_attr(subtitle_stream_info, 'forced') == '1'), 'stream_subtitle_location': helpers.get_xml_attr(subtitle_stream_info, 'location'), 'stream_subtitle_language': helpers.get_xml_attr(subtitle_stream_info, 'language'), 'stream_subtitle_language_code': helpers.get_xml_attr(subtitle_stream_info, 'languageCode'), 'stream_subtitle_decision': helpers.get_xml_attr(subtitle_stream_info, 'decision') or transcode_details['subtitle_decision'], 'stream_subtitle_transient': int(helpers.get_xml_attr(subtitle_stream_info, 'transient') == '1')}\n    else:\n        subtitle_selected = None\n        subtitle_details = {'stream_subtitle_codec': '', 'stream_subtitle_container': '', 'stream_subtitle_format': '', 'stream_subtitle_forced': 0, 'stream_subtitle_location': '', 'stream_subtitle_language': '', 'stream_subtitle_language_code': '', 'stream_subtitle_decision': '', 'stream_subtitle_transient': 0}\n    indexes = helpers.get_xml_attr(stream_media_parts_info, 'indexes')\n    view_offset = helpers.get_xml_attr(session, 'viewOffset')\n    if indexes == 'sd':\n        part_id = helpers.get_xml_attr(stream_media_parts_info, 'id')\n        bif_thumb = '/library/parts/{part_id}/indexes/sd/{view_offset}'.format(part_id=part_id, view_offset=view_offset)\n    else:\n        bif_thumb = ''\n    if helpers.cast_to_int(video_details['stream_video_width']) >= 3840:\n        stream_video_resolution = '4k'\n    else:\n        stream_video_resolution = helpers.get_xml_attr(stream_media_info, 'videoResolution').lower().rstrip('ip')\n    stream_details = {'stream_container': helpers.get_xml_attr(stream_media_info, 'container'), 'stream_bitrate': helpers.get_xml_attr(stream_media_info, 'bitrate'), 'stream_aspect_ratio': helpers.get_xml_attr(stream_media_info, 'aspectRatio'), 'stream_video_framerate': helpers.get_xml_attr(stream_media_info, 'videoFrameRate'), 'stream_video_resolution': stream_video_resolution, 'stream_duration': helpers.get_xml_attr(stream_media_info, 'duration') or helpers.get_xml_attr(session, 'duration'), 'stream_container_decision': helpers.get_xml_attr(stream_media_parts_info, 'decision').replace('directplay', 'direct play'), 'optimized_version': int(helpers.get_xml_attr(stream_media_info, 'proxyType') == '42'), 'optimized_version_title': helpers.get_xml_attr(stream_media_info, 'title'), 'synced_version': 0, 'live': int(helpers.get_xml_attr(session, 'live') == '1'), 'live_uuid': helpers.get_xml_attr(stream_media_info, 'uuid'), 'indexes': int(indexes == 'sd'), 'bif_thumb': bif_thumb, 'subtitles': 1 if subtitle_id and subtitle_selected else 0}\n    source_media_details = source_media_part_details = source_video_details = source_audio_details = source_subtitle_details = {}\n    if not helpers.get_xml_attr(session, 'ratingKey').isdigit():\n        channel_stream = 1\n        audio_channels = helpers.get_xml_attr(stream_media_info, 'audioChannels')\n        metadata_details = {'media_type': media_type, 'section_id': helpers.get_xml_attr(session, 'librarySectionID'), 'library_name': helpers.get_xml_attr(session, 'librarySectionTitle'), 'rating_key': helpers.get_xml_attr(session, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(session, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(session, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(session, 'title'), 'parent_title': helpers.get_xml_attr(session, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(session, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(session, 'originalTitle'), 'sort_title': helpers.get_xml_attr(session, 'titleSort'), 'media_index': helpers.get_xml_attr(session, 'index'), 'parent_media_index': helpers.get_xml_attr(session, 'parentIndex'), 'studio': helpers.get_xml_attr(session, 'studio'), 'content_rating': helpers.get_xml_attr(session, 'contentRating'), 'summary': helpers.get_xml_attr(session, 'summary'), 'tagline': helpers.get_xml_attr(session, 'tagline'), 'rating': helpers.get_xml_attr(session, 'rating'), 'rating_image': helpers.get_xml_attr(session, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(session, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(session, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(session, 'userRating'), 'duration': helpers.get_xml_attr(session, 'duration'), 'year': helpers.get_xml_attr(session, 'year'), 'thumb': helpers.get_xml_attr(session, 'thumb'), 'parent_thumb': helpers.get_xml_attr(session, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(session, 'grandparentThumb'), 'art': helpers.get_xml_attr(session, 'art'), 'banner': helpers.get_xml_attr(session, 'banner'), 'originally_available_at': helpers.get_xml_attr(session, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(session, 'addedAt'), 'updated_at': helpers.get_xml_attr(session, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(session, 'lastViewedAt'), 'guid': helpers.get_xml_attr(session, 'guid'), 'directors': [], 'writers': [], 'actors': [], 'genres': [], 'labels': [], 'full_title': helpers.get_xml_attr(session, 'title'), 'container': helpers.get_xml_attr(stream_media_info, 'container') or helpers.get_xml_attr(stream_media_parts_info, 'container'), 'bitrate': helpers.get_xml_attr(stream_media_info, 'bitrate'), 'height': helpers.get_xml_attr(stream_media_info, 'height'), 'width': helpers.get_xml_attr(stream_media_info, 'width'), 'aspect_ratio': helpers.get_xml_attr(stream_media_info, 'aspectRatio'), 'video_codec': helpers.get_xml_attr(stream_media_info, 'videoCodec'), 'video_resolution': helpers.get_xml_attr(stream_media_info, 'videoResolution').lower(), 'video_full_resolution': helpers.get_xml_attr(stream_media_info, 'videoResolution').lower(), 'video_framerate': helpers.get_xml_attr(stream_media_info, 'videoFrameRate'), 'video_profile': helpers.get_xml_attr(stream_media_info, 'videoProfile'), 'audio_codec': helpers.get_xml_attr(stream_media_info, 'audioCodec'), 'audio_channels': audio_channels, 'audio_channel_layout': common.AUDIO_CHANNELS.get(audio_channels, audio_channels), 'audio_profile': helpers.get_xml_attr(stream_media_info, 'audioProfile'), 'channel_icon': helpers.get_xml_attr(session, 'sourceIcon'), 'channel_title': helpers.get_xml_attr(session, 'sourceTitle'), 'extra_type': helpers.get_xml_attr(session, 'extraType'), 'sub_type': helpers.get_xml_attr(session, 'subtype')}\n    else:\n        channel_stream = 0\n        media_id = helpers.get_xml_attr(stream_media_info, 'id')\n        part_id = helpers.get_xml_attr(stream_media_parts_info, 'id')\n        metadata_details = self.get_metadata_details(rating_key=rating_key, skip_cache=skip_cache, cache_key=session_key)\n        source_medias = metadata_details.pop('media_info', [])\n        source_media_details = next((m for m in source_medias if m['id'] == media_id), next((m for m in source_medias), {}))\n        source_media_parts = source_media_details.pop('parts', [])\n        source_media_part_details = next((p for p in source_media_parts if p['id'] == part_id), next((p for p in source_media_parts), {}))\n        source_media_part_streams = source_media_part_details.pop('streams', [])\n        source_video_details = {'id': '', 'type': '', 'video_codec': '', 'video_codec_level': '', 'video_bitrate': '', 'video_bit_depth': '', 'video_chroma_subsampling': '', 'video_color_primaries': '', 'video_color_range': '', 'video_color_space': '', 'video_color_trc': '', 'video_dynamic_range': '', 'video_frame_rate': '', 'video_ref_frames': '', 'video_height': '', 'video_width': '', 'video_language': '', 'video_language_code': '', 'video_scan_type': '', 'video_profile': ''}\n        source_audio_details = {'id': '', 'type': '', 'audio_codec': '', 'audio_bitrate': '', 'audio_bitrate_mode': '', 'audio_channels': '', 'audio_channel_layout': '', 'audio_sample_rate': '', 'audio_language': '', 'audio_language_code': '', 'audio_profile': ''}\n        source_subtitle_details = {'id': '', 'type': '', 'subtitle_codec': '', 'subtitle_container': '', 'subtitle_format': '', 'subtitle_forced': 0, 'subtitle_location': '', 'subtitle_language': '', 'subtitle_language_code': ''}\n        if video_id:\n            source_video_details = next((p for p in source_media_part_streams if p['id'] == video_id), next((p for p in source_media_part_streams if p['type'] == '1'), source_video_details))\n        if audio_id:\n            source_audio_details = next((p for p in source_media_part_streams if p['id'] == audio_id), next((p for p in source_media_part_streams if p['type'] == '2'), source_audio_details))\n        if subtitle_id:\n            source_subtitle_details = next((p for p in source_media_part_streams if p['id'] == subtitle_id), next((p for p in source_media_part_streams if p['type'] == '3'), source_subtitle_details))\n    if media_type == 'clip' and metadata_details.get('extra_type') and metadata_details['art']:\n        metadata_details['thumb'] = metadata_details['art'].replace('/art', '/thumb')\n    if stream_details['live'] and transcode_session:\n        stream_details['stream_container_decision'] = 'transcode'\n        stream_details['stream_container'] = transcode_details['transcode_container']\n        video_details['stream_video_decision'] = transcode_details['video_decision']\n        video_details['stream_video_codec'] = transcode_details['transcode_video_codec']\n        audio_details['stream_audio_decision'] = transcode_details['audio_decision']\n        audio_details['stream_audio_codec'] = transcode_details['transcode_audio_codec']\n        audio_details['stream_audio_channels'] = transcode_details['transcode_audio_channels']\n        audio_details['stream_audio_channel_layout'] = common.AUDIO_CHANNELS.get(transcode_details['transcode_audio_channels'], transcode_details['transcode_audio_channels'])\n    if video_details['stream_video_decision'] == 'transcode' or audio_details['stream_audio_decision'] == 'transcode':\n        transcode_decision = 'transcode'\n    elif video_details['stream_video_decision'] == 'copy' or audio_details['stream_audio_decision'] == 'copy':\n        transcode_decision = 'copy'\n    else:\n        transcode_decision = 'direct play'\n    stream_details['transcode_decision'] = transcode_decision\n    stream_details['container_decision'] = stream_details['stream_container_decision']\n    if audio_details['stream_audio_codec'] == '*':\n        audio_details['stream_audio_codec'] = source_audio_details.get('audio_codec', '')\n    if transcode_details['transcode_audio_codec'] == '*':\n        transcode_details['transcode_audio_codec'] = source_audio_details.get('audio_codec', '')\n    if video_details['stream_video_codec'] == '*':\n        video_details['stream_video_codec'] = source_video_details.get('video_codec', '')\n    if transcode_details['transcode_video_codec'] == '*':\n        transcode_details['transcode_video_codec'] = source_video_details.get('video_codec', '')\n    if media_type in ('movie', 'episode', 'clip'):\n        stream_details['stream_video_full_resolution'] = common.VIDEO_RESOLUTION_OVERRIDES.get(stream_details['stream_video_resolution'], stream_details['stream_video_resolution'] + (video_details['stream_video_scan_type'][:1] or 'p'))\n    if media_type in ('movie', 'episode', 'clip') and 'stream_bitrate' in stream_details:\n        if video_details['stream_video_decision'] == 'transcode':\n            synced_version_profile = ''\n            stream_bitrate = helpers.cast_to_int(stream_details['stream_bitrate'])\n            source_bitrate = helpers.cast_to_int(source_media_details.get('bitrate'))\n            try:\n                quailtiy_bitrate = min((b for b in common.VIDEO_QUALITY_PROFILES if stream_bitrate <= b <= source_bitrate))\n                quality_profile = common.VIDEO_QUALITY_PROFILES[quailtiy_bitrate]\n            except ValueError:\n                quality_profile = 'Original'\n        else:\n            synced_version_profile = ''\n            quality_profile = 'Original'\n        if stream_details['optimized_version']:\n            source_bitrate = helpers.cast_to_int(source_media_details.get('bitrate'))\n            optimized_version_profile = '{} Mbps {}'.format(round(source_bitrate / 1000.0, 1), source_media_details.get('video_full_resolution'))\n        else:\n            optimized_version_profile = ''\n    elif media_type == 'track' and 'stream_bitrate' in stream_details:\n        synced_version_profile = ''\n        stream_bitrate = helpers.cast_to_int(stream_details['stream_bitrate'])\n        source_bitrate = helpers.cast_to_int(source_media_details.get('bitrate'))\n        try:\n            quailtiy_bitrate = min((b for b in common.AUDIO_QUALITY_PROFILES if stream_bitrate <= b <= source_bitrate))\n            quality_profile = common.AUDIO_QUALITY_PROFILES[quailtiy_bitrate]\n        except ValueError:\n            quality_profile = 'Original'\n        optimized_version_profile = ''\n    elif media_type == 'photo':\n        quality_profile = 'Original'\n        synced_version_profile = ''\n        optimized_version_profile = ''\n    else:\n        quality_profile = 'Unknown'\n        synced_version_profile = ''\n        optimized_version_profile = ''\n    session_output = {'session_key': session_key, 'media_type': media_type, 'view_offset': view_offset, 'progress_percent': str(helpers.get_percent(view_offset, stream_details['stream_duration'])), 'quality_profile': quality_profile, 'synced_version_profile': synced_version_profile, 'optimized_version_profile': optimized_version_profile, 'user': user_details['username'], 'channel_stream': channel_stream}\n    session_output.update(metadata_details)\n    session_output.update(source_media_details)\n    session_output.update(source_media_part_details)\n    session_output.update(source_video_details)\n    session_output.update(source_audio_details)\n    session_output.update(source_subtitle_details)\n    session_output.update(user_details)\n    session_output.update(player_details)\n    session_output.update(session_details)\n    session_output.update(transcode_details)\n    session_output.update(stream_details)\n    session_output.update(video_details)\n    session_output.update(audio_details)\n    session_output.update(subtitle_details)\n    return session_output"
        ]
    },
    {
        "func_name": "terminate_session",
        "original": "def terminate_session(self, session_key='', session_id='', message=''):\n    \"\"\"\n        Terminates a streaming session.\n        \"\"\"\n    plex_tv = plextv.PlexTV()\n    if not plex_tv.get_plexpass_status():\n        msg = 'No Plex Pass subscription'\n        logger.warn('Tautulli Pmsconnect :: Failed to terminate session: %s.' % msg)\n        return msg\n    message = message.encode('utf-8') or 'The server owner has ended the stream.'\n    ap = activity_processor.ActivityProcessor()\n    if session_key:\n        session = ap.get_session_by_key(session_key=session_key)\n        if session and (not session_id):\n            session_id = session['session_id']\n    elif session_id:\n        session = ap.get_session_by_id(session_id=session_id)\n        if session and (not session_key):\n            session_key = session['session_key']\n    else:\n        session = session_key = session_id = None\n    if not session:\n        msg = 'Invalid session_key (%s) or session_id (%s)' % (session_key, session_id)\n        logger.warn('Tautulli Pmsconnect :: Failed to terminate session: %s.' % msg)\n        return msg\n    if session_id:\n        logger.info('Tautulli Pmsconnect :: Terminating session %s (session_id %s).' % (session_key, session_id))\n        response = self.get_sessions_terminate(session_id=session_id, reason=message)\n        return response.ok\n    else:\n        msg = 'Missing session_id'\n        logger.warn('Tautulli Pmsconnect :: Failed to terminate session: %s.' % msg)\n        return msg",
        "mutated": [
            "def terminate_session(self, session_key='', session_id='', message=''):\n    if False:\n        i = 10\n    '\\n        Terminates a streaming session.\\n        '\n    plex_tv = plextv.PlexTV()\n    if not plex_tv.get_plexpass_status():\n        msg = 'No Plex Pass subscription'\n        logger.warn('Tautulli Pmsconnect :: Failed to terminate session: %s.' % msg)\n        return msg\n    message = message.encode('utf-8') or 'The server owner has ended the stream.'\n    ap = activity_processor.ActivityProcessor()\n    if session_key:\n        session = ap.get_session_by_key(session_key=session_key)\n        if session and (not session_id):\n            session_id = session['session_id']\n    elif session_id:\n        session = ap.get_session_by_id(session_id=session_id)\n        if session and (not session_key):\n            session_key = session['session_key']\n    else:\n        session = session_key = session_id = None\n    if not session:\n        msg = 'Invalid session_key (%s) or session_id (%s)' % (session_key, session_id)\n        logger.warn('Tautulli Pmsconnect :: Failed to terminate session: %s.' % msg)\n        return msg\n    if session_id:\n        logger.info('Tautulli Pmsconnect :: Terminating session %s (session_id %s).' % (session_key, session_id))\n        response = self.get_sessions_terminate(session_id=session_id, reason=message)\n        return response.ok\n    else:\n        msg = 'Missing session_id'\n        logger.warn('Tautulli Pmsconnect :: Failed to terminate session: %s.' % msg)\n        return msg",
            "def terminate_session(self, session_key='', session_id='', message=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Terminates a streaming session.\\n        '\n    plex_tv = plextv.PlexTV()\n    if not plex_tv.get_plexpass_status():\n        msg = 'No Plex Pass subscription'\n        logger.warn('Tautulli Pmsconnect :: Failed to terminate session: %s.' % msg)\n        return msg\n    message = message.encode('utf-8') or 'The server owner has ended the stream.'\n    ap = activity_processor.ActivityProcessor()\n    if session_key:\n        session = ap.get_session_by_key(session_key=session_key)\n        if session and (not session_id):\n            session_id = session['session_id']\n    elif session_id:\n        session = ap.get_session_by_id(session_id=session_id)\n        if session and (not session_key):\n            session_key = session['session_key']\n    else:\n        session = session_key = session_id = None\n    if not session:\n        msg = 'Invalid session_key (%s) or session_id (%s)' % (session_key, session_id)\n        logger.warn('Tautulli Pmsconnect :: Failed to terminate session: %s.' % msg)\n        return msg\n    if session_id:\n        logger.info('Tautulli Pmsconnect :: Terminating session %s (session_id %s).' % (session_key, session_id))\n        response = self.get_sessions_terminate(session_id=session_id, reason=message)\n        return response.ok\n    else:\n        msg = 'Missing session_id'\n        logger.warn('Tautulli Pmsconnect :: Failed to terminate session: %s.' % msg)\n        return msg",
            "def terminate_session(self, session_key='', session_id='', message=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Terminates a streaming session.\\n        '\n    plex_tv = plextv.PlexTV()\n    if not plex_tv.get_plexpass_status():\n        msg = 'No Plex Pass subscription'\n        logger.warn('Tautulli Pmsconnect :: Failed to terminate session: %s.' % msg)\n        return msg\n    message = message.encode('utf-8') or 'The server owner has ended the stream.'\n    ap = activity_processor.ActivityProcessor()\n    if session_key:\n        session = ap.get_session_by_key(session_key=session_key)\n        if session and (not session_id):\n            session_id = session['session_id']\n    elif session_id:\n        session = ap.get_session_by_id(session_id=session_id)\n        if session and (not session_key):\n            session_key = session['session_key']\n    else:\n        session = session_key = session_id = None\n    if not session:\n        msg = 'Invalid session_key (%s) or session_id (%s)' % (session_key, session_id)\n        logger.warn('Tautulli Pmsconnect :: Failed to terminate session: %s.' % msg)\n        return msg\n    if session_id:\n        logger.info('Tautulli Pmsconnect :: Terminating session %s (session_id %s).' % (session_key, session_id))\n        response = self.get_sessions_terminate(session_id=session_id, reason=message)\n        return response.ok\n    else:\n        msg = 'Missing session_id'\n        logger.warn('Tautulli Pmsconnect :: Failed to terminate session: %s.' % msg)\n        return msg",
            "def terminate_session(self, session_key='', session_id='', message=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Terminates a streaming session.\\n        '\n    plex_tv = plextv.PlexTV()\n    if not plex_tv.get_plexpass_status():\n        msg = 'No Plex Pass subscription'\n        logger.warn('Tautulli Pmsconnect :: Failed to terminate session: %s.' % msg)\n        return msg\n    message = message.encode('utf-8') or 'The server owner has ended the stream.'\n    ap = activity_processor.ActivityProcessor()\n    if session_key:\n        session = ap.get_session_by_key(session_key=session_key)\n        if session and (not session_id):\n            session_id = session['session_id']\n    elif session_id:\n        session = ap.get_session_by_id(session_id=session_id)\n        if session and (not session_key):\n            session_key = session['session_key']\n    else:\n        session = session_key = session_id = None\n    if not session:\n        msg = 'Invalid session_key (%s) or session_id (%s)' % (session_key, session_id)\n        logger.warn('Tautulli Pmsconnect :: Failed to terminate session: %s.' % msg)\n        return msg\n    if session_id:\n        logger.info('Tautulli Pmsconnect :: Terminating session %s (session_id %s).' % (session_key, session_id))\n        response = self.get_sessions_terminate(session_id=session_id, reason=message)\n        return response.ok\n    else:\n        msg = 'Missing session_id'\n        logger.warn('Tautulli Pmsconnect :: Failed to terminate session: %s.' % msg)\n        return msg",
            "def terminate_session(self, session_key='', session_id='', message=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Terminates a streaming session.\\n        '\n    plex_tv = plextv.PlexTV()\n    if not plex_tv.get_plexpass_status():\n        msg = 'No Plex Pass subscription'\n        logger.warn('Tautulli Pmsconnect :: Failed to terminate session: %s.' % msg)\n        return msg\n    message = message.encode('utf-8') or 'The server owner has ended the stream.'\n    ap = activity_processor.ActivityProcessor()\n    if session_key:\n        session = ap.get_session_by_key(session_key=session_key)\n        if session and (not session_id):\n            session_id = session['session_id']\n    elif session_id:\n        session = ap.get_session_by_id(session_id=session_id)\n        if session and (not session_key):\n            session_key = session['session_key']\n    else:\n        session = session_key = session_id = None\n    if not session:\n        msg = 'Invalid session_key (%s) or session_id (%s)' % (session_key, session_id)\n        logger.warn('Tautulli Pmsconnect :: Failed to terminate session: %s.' % msg)\n        return msg\n    if session_id:\n        logger.info('Tautulli Pmsconnect :: Terminating session %s (session_id %s).' % (session_key, session_id))\n        response = self.get_sessions_terminate(session_id=session_id, reason=message)\n        return response.ok\n    else:\n        msg = 'Missing session_id'\n        logger.warn('Tautulli Pmsconnect :: Failed to terminate session: %s.' % msg)\n        return msg"
        ]
    },
    {
        "func_name": "get_item_children",
        "original": "def get_item_children(self, rating_key='', media_type=None, get_grandchildren=False):\n    \"\"\"\n        Return processed and validated children list.\n\n        Output: array\n        \"\"\"\n    default_return = {'children_count': 0, 'children_list': []}\n    xml_head = []\n    if media_type == 'playlist':\n        children_data = self.get_playlist_items(rating_key, output_format='xml')\n    elif media_type == 'collection':\n        children_data = self.get_metadata_children(rating_key, collection=True, output_format='xml')\n    elif get_grandchildren:\n        children_data = self.get_metadata_grandchildren(rating_key, output_format='xml')\n    elif media_type == 'artist':\n        artist_metadata = self.get_metadata_details(rating_key)\n        section_id = artist_metadata['section_id']\n        sort_type = '&artist.id={}&type=9'.format(rating_key)\n        xml_head = self.fetch_library_list(section_id=str(section_id), sort_type=sort_type, output_format='xml')\n    else:\n        children_data = self.get_metadata_children(rating_key, output_format='xml')\n    if not xml_head:\n        try:\n            xml_head = children_data.getElementsByTagName('MediaContainer')\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_item_children: %s.' % e)\n            return default_return\n    children_list = []\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                logger.debug('Tautulli Pmsconnect :: No children data.')\n                return default_return\n        result_data = []\n        for x in a.childNodes:\n            if x.nodeType == Node.ELEMENT_NODE and x.tagName in ('Directory', 'Video', 'Track', 'Photo'):\n                result_data.append(x)\n        if result_data:\n            for m in result_data:\n                directors = []\n                writers = []\n                actors = []\n                genres = []\n                labels = []\n                collections = []\n                if m.getElementsByTagName('Director'):\n                    for director in m.getElementsByTagName('Director'):\n                        directors.append(helpers.get_xml_attr(director, 'tag'))\n                if m.getElementsByTagName('Writer'):\n                    for writer in m.getElementsByTagName('Writer'):\n                        writers.append(helpers.get_xml_attr(writer, 'tag'))\n                if m.getElementsByTagName('Role'):\n                    for actor in m.getElementsByTagName('Role'):\n                        actors.append(helpers.get_xml_attr(actor, 'tag'))\n                if m.getElementsByTagName('Genre'):\n                    for genre in m.getElementsByTagName('Genre'):\n                        genres.append(helpers.get_xml_attr(genre, 'tag'))\n                if m.getElementsByTagName('Label'):\n                    for label in m.getElementsByTagName('Label'):\n                        labels.append(helpers.get_xml_attr(label, 'tag'))\n                if m.getElementsByTagName('Collection'):\n                    for collection in m.getElementsByTagName('Collection'):\n                        collections.append(helpers.get_xml_attr(collection, 'tag'))\n                media_type = helpers.get_xml_attr(m, 'type')\n                if m.nodeName == 'Directory' and media_type == 'photo':\n                    media_type = 'photo_album'\n                children_output = {'media_type': media_type, 'section_id': helpers.get_xml_attr(a, 'librarySectionID'), 'library_name': helpers.get_xml_attr(a, 'librarySectionTitle'), 'rating_key': helpers.get_xml_attr(m, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(m, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(m, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(m, 'title'), 'parent_title': helpers.get_xml_attr(m, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(m, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(m, 'originalTitle'), 'sort_title': helpers.get_xml_attr(m, 'titleSort'), 'media_index': helpers.get_xml_attr(m, 'index'), 'parent_media_index': helpers.get_xml_attr(m, 'parentIndex'), 'studio': helpers.get_xml_attr(m, 'studio'), 'content_rating': helpers.get_xml_attr(m, 'contentRating'), 'summary': helpers.get_xml_attr(m, 'summary'), 'tagline': helpers.get_xml_attr(m, 'tagline'), 'rating': helpers.get_xml_attr(m, 'rating'), 'rating_image': helpers.get_xml_attr(m, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(m, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(m, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(m, 'userRating'), 'duration': helpers.get_xml_attr(m, 'duration'), 'year': helpers.get_xml_attr(m, 'year'), 'thumb': helpers.get_xml_attr(m, 'thumb'), 'parent_thumb': helpers.get_xml_attr(m, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(m, 'grandparentThumb'), 'art': helpers.get_xml_attr(m, 'art'), 'banner': helpers.get_xml_attr(m, 'banner'), 'originally_available_at': helpers.get_xml_attr(m, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(m, 'addedAt'), 'updated_at': helpers.get_xml_attr(m, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(m, 'lastViewedAt'), 'guid': helpers.get_xml_attr(m, 'guid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'full_title': helpers.get_xml_attr(m, 'title')}\n                children_list.append(children_output)\n    output = {'children_count': helpers.cast_to_int(helpers.get_xml_attr(xml_head[0], 'size')), 'children_type': helpers.get_xml_attr(xml_head[0], 'viewGroup') or (children_list[0]['media_type'] if children_list else ''), 'title': helpers.get_xml_attr(xml_head[0], 'title2'), 'children_list': children_list}\n    return output",
        "mutated": [
            "def get_item_children(self, rating_key='', media_type=None, get_grandchildren=False):\n    if False:\n        i = 10\n    '\\n        Return processed and validated children list.\\n\\n        Output: array\\n        '\n    default_return = {'children_count': 0, 'children_list': []}\n    xml_head = []\n    if media_type == 'playlist':\n        children_data = self.get_playlist_items(rating_key, output_format='xml')\n    elif media_type == 'collection':\n        children_data = self.get_metadata_children(rating_key, collection=True, output_format='xml')\n    elif get_grandchildren:\n        children_data = self.get_metadata_grandchildren(rating_key, output_format='xml')\n    elif media_type == 'artist':\n        artist_metadata = self.get_metadata_details(rating_key)\n        section_id = artist_metadata['section_id']\n        sort_type = '&artist.id={}&type=9'.format(rating_key)\n        xml_head = self.fetch_library_list(section_id=str(section_id), sort_type=sort_type, output_format='xml')\n    else:\n        children_data = self.get_metadata_children(rating_key, output_format='xml')\n    if not xml_head:\n        try:\n            xml_head = children_data.getElementsByTagName('MediaContainer')\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_item_children: %s.' % e)\n            return default_return\n    children_list = []\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                logger.debug('Tautulli Pmsconnect :: No children data.')\n                return default_return\n        result_data = []\n        for x in a.childNodes:\n            if x.nodeType == Node.ELEMENT_NODE and x.tagName in ('Directory', 'Video', 'Track', 'Photo'):\n                result_data.append(x)\n        if result_data:\n            for m in result_data:\n                directors = []\n                writers = []\n                actors = []\n                genres = []\n                labels = []\n                collections = []\n                if m.getElementsByTagName('Director'):\n                    for director in m.getElementsByTagName('Director'):\n                        directors.append(helpers.get_xml_attr(director, 'tag'))\n                if m.getElementsByTagName('Writer'):\n                    for writer in m.getElementsByTagName('Writer'):\n                        writers.append(helpers.get_xml_attr(writer, 'tag'))\n                if m.getElementsByTagName('Role'):\n                    for actor in m.getElementsByTagName('Role'):\n                        actors.append(helpers.get_xml_attr(actor, 'tag'))\n                if m.getElementsByTagName('Genre'):\n                    for genre in m.getElementsByTagName('Genre'):\n                        genres.append(helpers.get_xml_attr(genre, 'tag'))\n                if m.getElementsByTagName('Label'):\n                    for label in m.getElementsByTagName('Label'):\n                        labels.append(helpers.get_xml_attr(label, 'tag'))\n                if m.getElementsByTagName('Collection'):\n                    for collection in m.getElementsByTagName('Collection'):\n                        collections.append(helpers.get_xml_attr(collection, 'tag'))\n                media_type = helpers.get_xml_attr(m, 'type')\n                if m.nodeName == 'Directory' and media_type == 'photo':\n                    media_type = 'photo_album'\n                children_output = {'media_type': media_type, 'section_id': helpers.get_xml_attr(a, 'librarySectionID'), 'library_name': helpers.get_xml_attr(a, 'librarySectionTitle'), 'rating_key': helpers.get_xml_attr(m, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(m, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(m, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(m, 'title'), 'parent_title': helpers.get_xml_attr(m, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(m, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(m, 'originalTitle'), 'sort_title': helpers.get_xml_attr(m, 'titleSort'), 'media_index': helpers.get_xml_attr(m, 'index'), 'parent_media_index': helpers.get_xml_attr(m, 'parentIndex'), 'studio': helpers.get_xml_attr(m, 'studio'), 'content_rating': helpers.get_xml_attr(m, 'contentRating'), 'summary': helpers.get_xml_attr(m, 'summary'), 'tagline': helpers.get_xml_attr(m, 'tagline'), 'rating': helpers.get_xml_attr(m, 'rating'), 'rating_image': helpers.get_xml_attr(m, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(m, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(m, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(m, 'userRating'), 'duration': helpers.get_xml_attr(m, 'duration'), 'year': helpers.get_xml_attr(m, 'year'), 'thumb': helpers.get_xml_attr(m, 'thumb'), 'parent_thumb': helpers.get_xml_attr(m, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(m, 'grandparentThumb'), 'art': helpers.get_xml_attr(m, 'art'), 'banner': helpers.get_xml_attr(m, 'banner'), 'originally_available_at': helpers.get_xml_attr(m, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(m, 'addedAt'), 'updated_at': helpers.get_xml_attr(m, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(m, 'lastViewedAt'), 'guid': helpers.get_xml_attr(m, 'guid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'full_title': helpers.get_xml_attr(m, 'title')}\n                children_list.append(children_output)\n    output = {'children_count': helpers.cast_to_int(helpers.get_xml_attr(xml_head[0], 'size')), 'children_type': helpers.get_xml_attr(xml_head[0], 'viewGroup') or (children_list[0]['media_type'] if children_list else ''), 'title': helpers.get_xml_attr(xml_head[0], 'title2'), 'children_list': children_list}\n    return output",
            "def get_item_children(self, rating_key='', media_type=None, get_grandchildren=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Return processed and validated children list.\\n\\n        Output: array\\n        '\n    default_return = {'children_count': 0, 'children_list': []}\n    xml_head = []\n    if media_type == 'playlist':\n        children_data = self.get_playlist_items(rating_key, output_format='xml')\n    elif media_type == 'collection':\n        children_data = self.get_metadata_children(rating_key, collection=True, output_format='xml')\n    elif get_grandchildren:\n        children_data = self.get_metadata_grandchildren(rating_key, output_format='xml')\n    elif media_type == 'artist':\n        artist_metadata = self.get_metadata_details(rating_key)\n        section_id = artist_metadata['section_id']\n        sort_type = '&artist.id={}&type=9'.format(rating_key)\n        xml_head = self.fetch_library_list(section_id=str(section_id), sort_type=sort_type, output_format='xml')\n    else:\n        children_data = self.get_metadata_children(rating_key, output_format='xml')\n    if not xml_head:\n        try:\n            xml_head = children_data.getElementsByTagName('MediaContainer')\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_item_children: %s.' % e)\n            return default_return\n    children_list = []\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                logger.debug('Tautulli Pmsconnect :: No children data.')\n                return default_return\n        result_data = []\n        for x in a.childNodes:\n            if x.nodeType == Node.ELEMENT_NODE and x.tagName in ('Directory', 'Video', 'Track', 'Photo'):\n                result_data.append(x)\n        if result_data:\n            for m in result_data:\n                directors = []\n                writers = []\n                actors = []\n                genres = []\n                labels = []\n                collections = []\n                if m.getElementsByTagName('Director'):\n                    for director in m.getElementsByTagName('Director'):\n                        directors.append(helpers.get_xml_attr(director, 'tag'))\n                if m.getElementsByTagName('Writer'):\n                    for writer in m.getElementsByTagName('Writer'):\n                        writers.append(helpers.get_xml_attr(writer, 'tag'))\n                if m.getElementsByTagName('Role'):\n                    for actor in m.getElementsByTagName('Role'):\n                        actors.append(helpers.get_xml_attr(actor, 'tag'))\n                if m.getElementsByTagName('Genre'):\n                    for genre in m.getElementsByTagName('Genre'):\n                        genres.append(helpers.get_xml_attr(genre, 'tag'))\n                if m.getElementsByTagName('Label'):\n                    for label in m.getElementsByTagName('Label'):\n                        labels.append(helpers.get_xml_attr(label, 'tag'))\n                if m.getElementsByTagName('Collection'):\n                    for collection in m.getElementsByTagName('Collection'):\n                        collections.append(helpers.get_xml_attr(collection, 'tag'))\n                media_type = helpers.get_xml_attr(m, 'type')\n                if m.nodeName == 'Directory' and media_type == 'photo':\n                    media_type = 'photo_album'\n                children_output = {'media_type': media_type, 'section_id': helpers.get_xml_attr(a, 'librarySectionID'), 'library_name': helpers.get_xml_attr(a, 'librarySectionTitle'), 'rating_key': helpers.get_xml_attr(m, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(m, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(m, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(m, 'title'), 'parent_title': helpers.get_xml_attr(m, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(m, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(m, 'originalTitle'), 'sort_title': helpers.get_xml_attr(m, 'titleSort'), 'media_index': helpers.get_xml_attr(m, 'index'), 'parent_media_index': helpers.get_xml_attr(m, 'parentIndex'), 'studio': helpers.get_xml_attr(m, 'studio'), 'content_rating': helpers.get_xml_attr(m, 'contentRating'), 'summary': helpers.get_xml_attr(m, 'summary'), 'tagline': helpers.get_xml_attr(m, 'tagline'), 'rating': helpers.get_xml_attr(m, 'rating'), 'rating_image': helpers.get_xml_attr(m, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(m, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(m, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(m, 'userRating'), 'duration': helpers.get_xml_attr(m, 'duration'), 'year': helpers.get_xml_attr(m, 'year'), 'thumb': helpers.get_xml_attr(m, 'thumb'), 'parent_thumb': helpers.get_xml_attr(m, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(m, 'grandparentThumb'), 'art': helpers.get_xml_attr(m, 'art'), 'banner': helpers.get_xml_attr(m, 'banner'), 'originally_available_at': helpers.get_xml_attr(m, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(m, 'addedAt'), 'updated_at': helpers.get_xml_attr(m, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(m, 'lastViewedAt'), 'guid': helpers.get_xml_attr(m, 'guid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'full_title': helpers.get_xml_attr(m, 'title')}\n                children_list.append(children_output)\n    output = {'children_count': helpers.cast_to_int(helpers.get_xml_attr(xml_head[0], 'size')), 'children_type': helpers.get_xml_attr(xml_head[0], 'viewGroup') or (children_list[0]['media_type'] if children_list else ''), 'title': helpers.get_xml_attr(xml_head[0], 'title2'), 'children_list': children_list}\n    return output",
            "def get_item_children(self, rating_key='', media_type=None, get_grandchildren=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Return processed and validated children list.\\n\\n        Output: array\\n        '\n    default_return = {'children_count': 0, 'children_list': []}\n    xml_head = []\n    if media_type == 'playlist':\n        children_data = self.get_playlist_items(rating_key, output_format='xml')\n    elif media_type == 'collection':\n        children_data = self.get_metadata_children(rating_key, collection=True, output_format='xml')\n    elif get_grandchildren:\n        children_data = self.get_metadata_grandchildren(rating_key, output_format='xml')\n    elif media_type == 'artist':\n        artist_metadata = self.get_metadata_details(rating_key)\n        section_id = artist_metadata['section_id']\n        sort_type = '&artist.id={}&type=9'.format(rating_key)\n        xml_head = self.fetch_library_list(section_id=str(section_id), sort_type=sort_type, output_format='xml')\n    else:\n        children_data = self.get_metadata_children(rating_key, output_format='xml')\n    if not xml_head:\n        try:\n            xml_head = children_data.getElementsByTagName('MediaContainer')\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_item_children: %s.' % e)\n            return default_return\n    children_list = []\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                logger.debug('Tautulli Pmsconnect :: No children data.')\n                return default_return\n        result_data = []\n        for x in a.childNodes:\n            if x.nodeType == Node.ELEMENT_NODE and x.tagName in ('Directory', 'Video', 'Track', 'Photo'):\n                result_data.append(x)\n        if result_data:\n            for m in result_data:\n                directors = []\n                writers = []\n                actors = []\n                genres = []\n                labels = []\n                collections = []\n                if m.getElementsByTagName('Director'):\n                    for director in m.getElementsByTagName('Director'):\n                        directors.append(helpers.get_xml_attr(director, 'tag'))\n                if m.getElementsByTagName('Writer'):\n                    for writer in m.getElementsByTagName('Writer'):\n                        writers.append(helpers.get_xml_attr(writer, 'tag'))\n                if m.getElementsByTagName('Role'):\n                    for actor in m.getElementsByTagName('Role'):\n                        actors.append(helpers.get_xml_attr(actor, 'tag'))\n                if m.getElementsByTagName('Genre'):\n                    for genre in m.getElementsByTagName('Genre'):\n                        genres.append(helpers.get_xml_attr(genre, 'tag'))\n                if m.getElementsByTagName('Label'):\n                    for label in m.getElementsByTagName('Label'):\n                        labels.append(helpers.get_xml_attr(label, 'tag'))\n                if m.getElementsByTagName('Collection'):\n                    for collection in m.getElementsByTagName('Collection'):\n                        collections.append(helpers.get_xml_attr(collection, 'tag'))\n                media_type = helpers.get_xml_attr(m, 'type')\n                if m.nodeName == 'Directory' and media_type == 'photo':\n                    media_type = 'photo_album'\n                children_output = {'media_type': media_type, 'section_id': helpers.get_xml_attr(a, 'librarySectionID'), 'library_name': helpers.get_xml_attr(a, 'librarySectionTitle'), 'rating_key': helpers.get_xml_attr(m, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(m, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(m, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(m, 'title'), 'parent_title': helpers.get_xml_attr(m, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(m, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(m, 'originalTitle'), 'sort_title': helpers.get_xml_attr(m, 'titleSort'), 'media_index': helpers.get_xml_attr(m, 'index'), 'parent_media_index': helpers.get_xml_attr(m, 'parentIndex'), 'studio': helpers.get_xml_attr(m, 'studio'), 'content_rating': helpers.get_xml_attr(m, 'contentRating'), 'summary': helpers.get_xml_attr(m, 'summary'), 'tagline': helpers.get_xml_attr(m, 'tagline'), 'rating': helpers.get_xml_attr(m, 'rating'), 'rating_image': helpers.get_xml_attr(m, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(m, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(m, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(m, 'userRating'), 'duration': helpers.get_xml_attr(m, 'duration'), 'year': helpers.get_xml_attr(m, 'year'), 'thumb': helpers.get_xml_attr(m, 'thumb'), 'parent_thumb': helpers.get_xml_attr(m, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(m, 'grandparentThumb'), 'art': helpers.get_xml_attr(m, 'art'), 'banner': helpers.get_xml_attr(m, 'banner'), 'originally_available_at': helpers.get_xml_attr(m, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(m, 'addedAt'), 'updated_at': helpers.get_xml_attr(m, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(m, 'lastViewedAt'), 'guid': helpers.get_xml_attr(m, 'guid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'full_title': helpers.get_xml_attr(m, 'title')}\n                children_list.append(children_output)\n    output = {'children_count': helpers.cast_to_int(helpers.get_xml_attr(xml_head[0], 'size')), 'children_type': helpers.get_xml_attr(xml_head[0], 'viewGroup') or (children_list[0]['media_type'] if children_list else ''), 'title': helpers.get_xml_attr(xml_head[0], 'title2'), 'children_list': children_list}\n    return output",
            "def get_item_children(self, rating_key='', media_type=None, get_grandchildren=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Return processed and validated children list.\\n\\n        Output: array\\n        '\n    default_return = {'children_count': 0, 'children_list': []}\n    xml_head = []\n    if media_type == 'playlist':\n        children_data = self.get_playlist_items(rating_key, output_format='xml')\n    elif media_type == 'collection':\n        children_data = self.get_metadata_children(rating_key, collection=True, output_format='xml')\n    elif get_grandchildren:\n        children_data = self.get_metadata_grandchildren(rating_key, output_format='xml')\n    elif media_type == 'artist':\n        artist_metadata = self.get_metadata_details(rating_key)\n        section_id = artist_metadata['section_id']\n        sort_type = '&artist.id={}&type=9'.format(rating_key)\n        xml_head = self.fetch_library_list(section_id=str(section_id), sort_type=sort_type, output_format='xml')\n    else:\n        children_data = self.get_metadata_children(rating_key, output_format='xml')\n    if not xml_head:\n        try:\n            xml_head = children_data.getElementsByTagName('MediaContainer')\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_item_children: %s.' % e)\n            return default_return\n    children_list = []\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                logger.debug('Tautulli Pmsconnect :: No children data.')\n                return default_return\n        result_data = []\n        for x in a.childNodes:\n            if x.nodeType == Node.ELEMENT_NODE and x.tagName in ('Directory', 'Video', 'Track', 'Photo'):\n                result_data.append(x)\n        if result_data:\n            for m in result_data:\n                directors = []\n                writers = []\n                actors = []\n                genres = []\n                labels = []\n                collections = []\n                if m.getElementsByTagName('Director'):\n                    for director in m.getElementsByTagName('Director'):\n                        directors.append(helpers.get_xml_attr(director, 'tag'))\n                if m.getElementsByTagName('Writer'):\n                    for writer in m.getElementsByTagName('Writer'):\n                        writers.append(helpers.get_xml_attr(writer, 'tag'))\n                if m.getElementsByTagName('Role'):\n                    for actor in m.getElementsByTagName('Role'):\n                        actors.append(helpers.get_xml_attr(actor, 'tag'))\n                if m.getElementsByTagName('Genre'):\n                    for genre in m.getElementsByTagName('Genre'):\n                        genres.append(helpers.get_xml_attr(genre, 'tag'))\n                if m.getElementsByTagName('Label'):\n                    for label in m.getElementsByTagName('Label'):\n                        labels.append(helpers.get_xml_attr(label, 'tag'))\n                if m.getElementsByTagName('Collection'):\n                    for collection in m.getElementsByTagName('Collection'):\n                        collections.append(helpers.get_xml_attr(collection, 'tag'))\n                media_type = helpers.get_xml_attr(m, 'type')\n                if m.nodeName == 'Directory' and media_type == 'photo':\n                    media_type = 'photo_album'\n                children_output = {'media_type': media_type, 'section_id': helpers.get_xml_attr(a, 'librarySectionID'), 'library_name': helpers.get_xml_attr(a, 'librarySectionTitle'), 'rating_key': helpers.get_xml_attr(m, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(m, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(m, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(m, 'title'), 'parent_title': helpers.get_xml_attr(m, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(m, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(m, 'originalTitle'), 'sort_title': helpers.get_xml_attr(m, 'titleSort'), 'media_index': helpers.get_xml_attr(m, 'index'), 'parent_media_index': helpers.get_xml_attr(m, 'parentIndex'), 'studio': helpers.get_xml_attr(m, 'studio'), 'content_rating': helpers.get_xml_attr(m, 'contentRating'), 'summary': helpers.get_xml_attr(m, 'summary'), 'tagline': helpers.get_xml_attr(m, 'tagline'), 'rating': helpers.get_xml_attr(m, 'rating'), 'rating_image': helpers.get_xml_attr(m, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(m, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(m, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(m, 'userRating'), 'duration': helpers.get_xml_attr(m, 'duration'), 'year': helpers.get_xml_attr(m, 'year'), 'thumb': helpers.get_xml_attr(m, 'thumb'), 'parent_thumb': helpers.get_xml_attr(m, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(m, 'grandparentThumb'), 'art': helpers.get_xml_attr(m, 'art'), 'banner': helpers.get_xml_attr(m, 'banner'), 'originally_available_at': helpers.get_xml_attr(m, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(m, 'addedAt'), 'updated_at': helpers.get_xml_attr(m, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(m, 'lastViewedAt'), 'guid': helpers.get_xml_attr(m, 'guid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'full_title': helpers.get_xml_attr(m, 'title')}\n                children_list.append(children_output)\n    output = {'children_count': helpers.cast_to_int(helpers.get_xml_attr(xml_head[0], 'size')), 'children_type': helpers.get_xml_attr(xml_head[0], 'viewGroup') or (children_list[0]['media_type'] if children_list else ''), 'title': helpers.get_xml_attr(xml_head[0], 'title2'), 'children_list': children_list}\n    return output",
            "def get_item_children(self, rating_key='', media_type=None, get_grandchildren=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Return processed and validated children list.\\n\\n        Output: array\\n        '\n    default_return = {'children_count': 0, 'children_list': []}\n    xml_head = []\n    if media_type == 'playlist':\n        children_data = self.get_playlist_items(rating_key, output_format='xml')\n    elif media_type == 'collection':\n        children_data = self.get_metadata_children(rating_key, collection=True, output_format='xml')\n    elif get_grandchildren:\n        children_data = self.get_metadata_grandchildren(rating_key, output_format='xml')\n    elif media_type == 'artist':\n        artist_metadata = self.get_metadata_details(rating_key)\n        section_id = artist_metadata['section_id']\n        sort_type = '&artist.id={}&type=9'.format(rating_key)\n        xml_head = self.fetch_library_list(section_id=str(section_id), sort_type=sort_type, output_format='xml')\n    else:\n        children_data = self.get_metadata_children(rating_key, output_format='xml')\n    if not xml_head:\n        try:\n            xml_head = children_data.getElementsByTagName('MediaContainer')\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_item_children: %s.' % e)\n            return default_return\n    children_list = []\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                logger.debug('Tautulli Pmsconnect :: No children data.')\n                return default_return\n        result_data = []\n        for x in a.childNodes:\n            if x.nodeType == Node.ELEMENT_NODE and x.tagName in ('Directory', 'Video', 'Track', 'Photo'):\n                result_data.append(x)\n        if result_data:\n            for m in result_data:\n                directors = []\n                writers = []\n                actors = []\n                genres = []\n                labels = []\n                collections = []\n                if m.getElementsByTagName('Director'):\n                    for director in m.getElementsByTagName('Director'):\n                        directors.append(helpers.get_xml_attr(director, 'tag'))\n                if m.getElementsByTagName('Writer'):\n                    for writer in m.getElementsByTagName('Writer'):\n                        writers.append(helpers.get_xml_attr(writer, 'tag'))\n                if m.getElementsByTagName('Role'):\n                    for actor in m.getElementsByTagName('Role'):\n                        actors.append(helpers.get_xml_attr(actor, 'tag'))\n                if m.getElementsByTagName('Genre'):\n                    for genre in m.getElementsByTagName('Genre'):\n                        genres.append(helpers.get_xml_attr(genre, 'tag'))\n                if m.getElementsByTagName('Label'):\n                    for label in m.getElementsByTagName('Label'):\n                        labels.append(helpers.get_xml_attr(label, 'tag'))\n                if m.getElementsByTagName('Collection'):\n                    for collection in m.getElementsByTagName('Collection'):\n                        collections.append(helpers.get_xml_attr(collection, 'tag'))\n                media_type = helpers.get_xml_attr(m, 'type')\n                if m.nodeName == 'Directory' and media_type == 'photo':\n                    media_type = 'photo_album'\n                children_output = {'media_type': media_type, 'section_id': helpers.get_xml_attr(a, 'librarySectionID'), 'library_name': helpers.get_xml_attr(a, 'librarySectionTitle'), 'rating_key': helpers.get_xml_attr(m, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(m, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(m, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(m, 'title'), 'parent_title': helpers.get_xml_attr(m, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(m, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(m, 'originalTitle'), 'sort_title': helpers.get_xml_attr(m, 'titleSort'), 'media_index': helpers.get_xml_attr(m, 'index'), 'parent_media_index': helpers.get_xml_attr(m, 'parentIndex'), 'studio': helpers.get_xml_attr(m, 'studio'), 'content_rating': helpers.get_xml_attr(m, 'contentRating'), 'summary': helpers.get_xml_attr(m, 'summary'), 'tagline': helpers.get_xml_attr(m, 'tagline'), 'rating': helpers.get_xml_attr(m, 'rating'), 'rating_image': helpers.get_xml_attr(m, 'ratingImage'), 'audience_rating': helpers.get_xml_attr(m, 'audienceRating'), 'audience_rating_image': helpers.get_xml_attr(m, 'audienceRatingImage'), 'user_rating': helpers.get_xml_attr(m, 'userRating'), 'duration': helpers.get_xml_attr(m, 'duration'), 'year': helpers.get_xml_attr(m, 'year'), 'thumb': helpers.get_xml_attr(m, 'thumb'), 'parent_thumb': helpers.get_xml_attr(m, 'parentThumb'), 'grandparent_thumb': helpers.get_xml_attr(m, 'grandparentThumb'), 'art': helpers.get_xml_attr(m, 'art'), 'banner': helpers.get_xml_attr(m, 'banner'), 'originally_available_at': helpers.get_xml_attr(m, 'originallyAvailableAt'), 'added_at': helpers.get_xml_attr(m, 'addedAt'), 'updated_at': helpers.get_xml_attr(m, 'updatedAt'), 'last_viewed_at': helpers.get_xml_attr(m, 'lastViewedAt'), 'guid': helpers.get_xml_attr(m, 'guid'), 'directors': directors, 'writers': writers, 'actors': actors, 'genres': genres, 'labels': labels, 'collections': collections, 'full_title': helpers.get_xml_attr(m, 'title')}\n                children_list.append(children_output)\n    output = {'children_count': helpers.cast_to_int(helpers.get_xml_attr(xml_head[0], 'size')), 'children_type': helpers.get_xml_attr(xml_head[0], 'viewGroup') or (children_list[0]['media_type'] if children_list else ''), 'title': helpers.get_xml_attr(xml_head[0], 'title2'), 'children_list': children_list}\n    return output"
        ]
    },
    {
        "func_name": "get_item_children_related",
        "original": "def get_item_children_related(self, rating_key=''):\n    \"\"\"\n        Return processed and validated children list.\n\n        Output: array\n        \"\"\"\n    children_data = self.get_children_list_related(rating_key, output_format='xml')\n    try:\n        xml_head = children_data.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_item_children_related: %s.' % e)\n        return []\n    children_results_list = {'movie': [], 'show': [], 'season': [], 'episode': [], 'artist': [], 'album': [], 'track': []}\n    for a in xml_head:\n        section_id = helpers.get_xml_attr(a, 'librarySectionID')\n        hubs = a.getElementsByTagName('Hub')\n        for h in hubs:\n            size = helpers.get_xml_attr(h, 'size')\n            media_type = helpers.get_xml_attr(h, 'type')\n            title = helpers.get_xml_attr(h, 'title')\n            hub_identifier = helpers.get_xml_attr(h, 'hubIdentifier')\n            if size == '0' or not hub_identifier.startswith('collection.related') or media_type not in children_results_list:\n                continue\n            result_data = []\n            if h.getElementsByTagName('Video'):\n                result_data = h.getElementsByTagName('Video')\n            if h.getElementsByTagName('Directory'):\n                result_data = h.getElementsByTagName('Directory')\n            if h.getElementsByTagName('Track'):\n                result_data = h.getElementsByTagName('Track')\n            for result in result_data:\n                children_output = {'section_id': section_id, 'rating_key': helpers.get_xml_attr(result, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(result, 'parentRatingKey'), 'media_index': helpers.get_xml_attr(result, 'index'), 'title': helpers.get_xml_attr(result, 'title'), 'parent_title': helpers.get_xml_attr(result, 'parentTitle'), 'year': helpers.get_xml_attr(result, 'year'), 'thumb': helpers.get_xml_attr(result, 'thumb'), 'parent_thumb': helpers.get_xml_attr(a, 'thumb'), 'duration': helpers.get_xml_attr(result, 'duration')}\n                children_results_list[media_type].append(children_output)\n        output = {'results_count': sum((len(v) for (k, v) in children_results_list.items())), 'results_list': children_results_list}\n        return output",
        "mutated": [
            "def get_item_children_related(self, rating_key=''):\n    if False:\n        i = 10\n    '\\n        Return processed and validated children list.\\n\\n        Output: array\\n        '\n    children_data = self.get_children_list_related(rating_key, output_format='xml')\n    try:\n        xml_head = children_data.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_item_children_related: %s.' % e)\n        return []\n    children_results_list = {'movie': [], 'show': [], 'season': [], 'episode': [], 'artist': [], 'album': [], 'track': []}\n    for a in xml_head:\n        section_id = helpers.get_xml_attr(a, 'librarySectionID')\n        hubs = a.getElementsByTagName('Hub')\n        for h in hubs:\n            size = helpers.get_xml_attr(h, 'size')\n            media_type = helpers.get_xml_attr(h, 'type')\n            title = helpers.get_xml_attr(h, 'title')\n            hub_identifier = helpers.get_xml_attr(h, 'hubIdentifier')\n            if size == '0' or not hub_identifier.startswith('collection.related') or media_type not in children_results_list:\n                continue\n            result_data = []\n            if h.getElementsByTagName('Video'):\n                result_data = h.getElementsByTagName('Video')\n            if h.getElementsByTagName('Directory'):\n                result_data = h.getElementsByTagName('Directory')\n            if h.getElementsByTagName('Track'):\n                result_data = h.getElementsByTagName('Track')\n            for result in result_data:\n                children_output = {'section_id': section_id, 'rating_key': helpers.get_xml_attr(result, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(result, 'parentRatingKey'), 'media_index': helpers.get_xml_attr(result, 'index'), 'title': helpers.get_xml_attr(result, 'title'), 'parent_title': helpers.get_xml_attr(result, 'parentTitle'), 'year': helpers.get_xml_attr(result, 'year'), 'thumb': helpers.get_xml_attr(result, 'thumb'), 'parent_thumb': helpers.get_xml_attr(a, 'thumb'), 'duration': helpers.get_xml_attr(result, 'duration')}\n                children_results_list[media_type].append(children_output)\n        output = {'results_count': sum((len(v) for (k, v) in children_results_list.items())), 'results_list': children_results_list}\n        return output",
            "def get_item_children_related(self, rating_key=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Return processed and validated children list.\\n\\n        Output: array\\n        '\n    children_data = self.get_children_list_related(rating_key, output_format='xml')\n    try:\n        xml_head = children_data.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_item_children_related: %s.' % e)\n        return []\n    children_results_list = {'movie': [], 'show': [], 'season': [], 'episode': [], 'artist': [], 'album': [], 'track': []}\n    for a in xml_head:\n        section_id = helpers.get_xml_attr(a, 'librarySectionID')\n        hubs = a.getElementsByTagName('Hub')\n        for h in hubs:\n            size = helpers.get_xml_attr(h, 'size')\n            media_type = helpers.get_xml_attr(h, 'type')\n            title = helpers.get_xml_attr(h, 'title')\n            hub_identifier = helpers.get_xml_attr(h, 'hubIdentifier')\n            if size == '0' or not hub_identifier.startswith('collection.related') or media_type not in children_results_list:\n                continue\n            result_data = []\n            if h.getElementsByTagName('Video'):\n                result_data = h.getElementsByTagName('Video')\n            if h.getElementsByTagName('Directory'):\n                result_data = h.getElementsByTagName('Directory')\n            if h.getElementsByTagName('Track'):\n                result_data = h.getElementsByTagName('Track')\n            for result in result_data:\n                children_output = {'section_id': section_id, 'rating_key': helpers.get_xml_attr(result, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(result, 'parentRatingKey'), 'media_index': helpers.get_xml_attr(result, 'index'), 'title': helpers.get_xml_attr(result, 'title'), 'parent_title': helpers.get_xml_attr(result, 'parentTitle'), 'year': helpers.get_xml_attr(result, 'year'), 'thumb': helpers.get_xml_attr(result, 'thumb'), 'parent_thumb': helpers.get_xml_attr(a, 'thumb'), 'duration': helpers.get_xml_attr(result, 'duration')}\n                children_results_list[media_type].append(children_output)\n        output = {'results_count': sum((len(v) for (k, v) in children_results_list.items())), 'results_list': children_results_list}\n        return output",
            "def get_item_children_related(self, rating_key=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Return processed and validated children list.\\n\\n        Output: array\\n        '\n    children_data = self.get_children_list_related(rating_key, output_format='xml')\n    try:\n        xml_head = children_data.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_item_children_related: %s.' % e)\n        return []\n    children_results_list = {'movie': [], 'show': [], 'season': [], 'episode': [], 'artist': [], 'album': [], 'track': []}\n    for a in xml_head:\n        section_id = helpers.get_xml_attr(a, 'librarySectionID')\n        hubs = a.getElementsByTagName('Hub')\n        for h in hubs:\n            size = helpers.get_xml_attr(h, 'size')\n            media_type = helpers.get_xml_attr(h, 'type')\n            title = helpers.get_xml_attr(h, 'title')\n            hub_identifier = helpers.get_xml_attr(h, 'hubIdentifier')\n            if size == '0' or not hub_identifier.startswith('collection.related') or media_type not in children_results_list:\n                continue\n            result_data = []\n            if h.getElementsByTagName('Video'):\n                result_data = h.getElementsByTagName('Video')\n            if h.getElementsByTagName('Directory'):\n                result_data = h.getElementsByTagName('Directory')\n            if h.getElementsByTagName('Track'):\n                result_data = h.getElementsByTagName('Track')\n            for result in result_data:\n                children_output = {'section_id': section_id, 'rating_key': helpers.get_xml_attr(result, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(result, 'parentRatingKey'), 'media_index': helpers.get_xml_attr(result, 'index'), 'title': helpers.get_xml_attr(result, 'title'), 'parent_title': helpers.get_xml_attr(result, 'parentTitle'), 'year': helpers.get_xml_attr(result, 'year'), 'thumb': helpers.get_xml_attr(result, 'thumb'), 'parent_thumb': helpers.get_xml_attr(a, 'thumb'), 'duration': helpers.get_xml_attr(result, 'duration')}\n                children_results_list[media_type].append(children_output)\n        output = {'results_count': sum((len(v) for (k, v) in children_results_list.items())), 'results_list': children_results_list}\n        return output",
            "def get_item_children_related(self, rating_key=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Return processed and validated children list.\\n\\n        Output: array\\n        '\n    children_data = self.get_children_list_related(rating_key, output_format='xml')\n    try:\n        xml_head = children_data.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_item_children_related: %s.' % e)\n        return []\n    children_results_list = {'movie': [], 'show': [], 'season': [], 'episode': [], 'artist': [], 'album': [], 'track': []}\n    for a in xml_head:\n        section_id = helpers.get_xml_attr(a, 'librarySectionID')\n        hubs = a.getElementsByTagName('Hub')\n        for h in hubs:\n            size = helpers.get_xml_attr(h, 'size')\n            media_type = helpers.get_xml_attr(h, 'type')\n            title = helpers.get_xml_attr(h, 'title')\n            hub_identifier = helpers.get_xml_attr(h, 'hubIdentifier')\n            if size == '0' or not hub_identifier.startswith('collection.related') or media_type not in children_results_list:\n                continue\n            result_data = []\n            if h.getElementsByTagName('Video'):\n                result_data = h.getElementsByTagName('Video')\n            if h.getElementsByTagName('Directory'):\n                result_data = h.getElementsByTagName('Directory')\n            if h.getElementsByTagName('Track'):\n                result_data = h.getElementsByTagName('Track')\n            for result in result_data:\n                children_output = {'section_id': section_id, 'rating_key': helpers.get_xml_attr(result, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(result, 'parentRatingKey'), 'media_index': helpers.get_xml_attr(result, 'index'), 'title': helpers.get_xml_attr(result, 'title'), 'parent_title': helpers.get_xml_attr(result, 'parentTitle'), 'year': helpers.get_xml_attr(result, 'year'), 'thumb': helpers.get_xml_attr(result, 'thumb'), 'parent_thumb': helpers.get_xml_attr(a, 'thumb'), 'duration': helpers.get_xml_attr(result, 'duration')}\n                children_results_list[media_type].append(children_output)\n        output = {'results_count': sum((len(v) for (k, v) in children_results_list.items())), 'results_list': children_results_list}\n        return output",
            "def get_item_children_related(self, rating_key=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Return processed and validated children list.\\n\\n        Output: array\\n        '\n    children_data = self.get_children_list_related(rating_key, output_format='xml')\n    try:\n        xml_head = children_data.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_item_children_related: %s.' % e)\n        return []\n    children_results_list = {'movie': [], 'show': [], 'season': [], 'episode': [], 'artist': [], 'album': [], 'track': []}\n    for a in xml_head:\n        section_id = helpers.get_xml_attr(a, 'librarySectionID')\n        hubs = a.getElementsByTagName('Hub')\n        for h in hubs:\n            size = helpers.get_xml_attr(h, 'size')\n            media_type = helpers.get_xml_attr(h, 'type')\n            title = helpers.get_xml_attr(h, 'title')\n            hub_identifier = helpers.get_xml_attr(h, 'hubIdentifier')\n            if size == '0' or not hub_identifier.startswith('collection.related') or media_type not in children_results_list:\n                continue\n            result_data = []\n            if h.getElementsByTagName('Video'):\n                result_data = h.getElementsByTagName('Video')\n            if h.getElementsByTagName('Directory'):\n                result_data = h.getElementsByTagName('Directory')\n            if h.getElementsByTagName('Track'):\n                result_data = h.getElementsByTagName('Track')\n            for result in result_data:\n                children_output = {'section_id': section_id, 'rating_key': helpers.get_xml_attr(result, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(result, 'parentRatingKey'), 'media_index': helpers.get_xml_attr(result, 'index'), 'title': helpers.get_xml_attr(result, 'title'), 'parent_title': helpers.get_xml_attr(result, 'parentTitle'), 'year': helpers.get_xml_attr(result, 'year'), 'thumb': helpers.get_xml_attr(result, 'thumb'), 'parent_thumb': helpers.get_xml_attr(a, 'thumb'), 'duration': helpers.get_xml_attr(result, 'duration')}\n                children_results_list[media_type].append(children_output)\n        output = {'results_count': sum((len(v) for (k, v) in children_results_list.items())), 'results_list': children_results_list}\n        return output"
        ]
    },
    {
        "func_name": "get_servers_info",
        "original": "def get_servers_info(self):\n    \"\"\"\n        Return the list of local servers.\n\n        Output: array\n        \"\"\"\n    recent = self.get_server_list(output_format='xml')\n    try:\n        xml_head = recent.getElementsByTagName('Server')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_server_list: %s.' % e)\n        return []\n    server_info = []\n    for a in xml_head:\n        output = {'name': helpers.get_xml_attr(a, 'name'), 'machine_identifier': helpers.get_xml_attr(a, 'machineIdentifier'), 'host': helpers.get_xml_attr(a, 'host'), 'port': helpers.get_xml_attr(a, 'port'), 'version': helpers.get_xml_attr(a, 'version')}\n        server_info.append(output)\n    return server_info",
        "mutated": [
            "def get_servers_info(self):\n    if False:\n        i = 10\n    '\\n        Return the list of local servers.\\n\\n        Output: array\\n        '\n    recent = self.get_server_list(output_format='xml')\n    try:\n        xml_head = recent.getElementsByTagName('Server')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_server_list: %s.' % e)\n        return []\n    server_info = []\n    for a in xml_head:\n        output = {'name': helpers.get_xml_attr(a, 'name'), 'machine_identifier': helpers.get_xml_attr(a, 'machineIdentifier'), 'host': helpers.get_xml_attr(a, 'host'), 'port': helpers.get_xml_attr(a, 'port'), 'version': helpers.get_xml_attr(a, 'version')}\n        server_info.append(output)\n    return server_info",
            "def get_servers_info(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Return the list of local servers.\\n\\n        Output: array\\n        '\n    recent = self.get_server_list(output_format='xml')\n    try:\n        xml_head = recent.getElementsByTagName('Server')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_server_list: %s.' % e)\n        return []\n    server_info = []\n    for a in xml_head:\n        output = {'name': helpers.get_xml_attr(a, 'name'), 'machine_identifier': helpers.get_xml_attr(a, 'machineIdentifier'), 'host': helpers.get_xml_attr(a, 'host'), 'port': helpers.get_xml_attr(a, 'port'), 'version': helpers.get_xml_attr(a, 'version')}\n        server_info.append(output)\n    return server_info",
            "def get_servers_info(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Return the list of local servers.\\n\\n        Output: array\\n        '\n    recent = self.get_server_list(output_format='xml')\n    try:\n        xml_head = recent.getElementsByTagName('Server')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_server_list: %s.' % e)\n        return []\n    server_info = []\n    for a in xml_head:\n        output = {'name': helpers.get_xml_attr(a, 'name'), 'machine_identifier': helpers.get_xml_attr(a, 'machineIdentifier'), 'host': helpers.get_xml_attr(a, 'host'), 'port': helpers.get_xml_attr(a, 'port'), 'version': helpers.get_xml_attr(a, 'version')}\n        server_info.append(output)\n    return server_info",
            "def get_servers_info(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Return the list of local servers.\\n\\n        Output: array\\n        '\n    recent = self.get_server_list(output_format='xml')\n    try:\n        xml_head = recent.getElementsByTagName('Server')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_server_list: %s.' % e)\n        return []\n    server_info = []\n    for a in xml_head:\n        output = {'name': helpers.get_xml_attr(a, 'name'), 'machine_identifier': helpers.get_xml_attr(a, 'machineIdentifier'), 'host': helpers.get_xml_attr(a, 'host'), 'port': helpers.get_xml_attr(a, 'port'), 'version': helpers.get_xml_attr(a, 'version')}\n        server_info.append(output)\n    return server_info",
            "def get_servers_info(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Return the list of local servers.\\n\\n        Output: array\\n        '\n    recent = self.get_server_list(output_format='xml')\n    try:\n        xml_head = recent.getElementsByTagName('Server')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_server_list: %s.' % e)\n        return []\n    server_info = []\n    for a in xml_head:\n        output = {'name': helpers.get_xml_attr(a, 'name'), 'machine_identifier': helpers.get_xml_attr(a, 'machineIdentifier'), 'host': helpers.get_xml_attr(a, 'host'), 'port': helpers.get_xml_attr(a, 'port'), 'version': helpers.get_xml_attr(a, 'version')}\n        server_info.append(output)\n    return server_info"
        ]
    },
    {
        "func_name": "get_server_identity",
        "original": "def get_server_identity(self):\n    \"\"\"\n        Return the local machine identity.\n\n        Output: dict\n        \"\"\"\n    identity = self.get_local_server_identity(output_format='xml')\n    try:\n        xml_head = identity.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_local_server_identity: %s.' % e)\n        return {}\n    server_identity = {}\n    for a in xml_head:\n        server_identity = {'machine_identifier': helpers.get_xml_attr(a, 'machineIdentifier'), 'version': helpers.get_xml_attr(a, 'version')}\n    return server_identity",
        "mutated": [
            "def get_server_identity(self):\n    if False:\n        i = 10\n    '\\n        Return the local machine identity.\\n\\n        Output: dict\\n        '\n    identity = self.get_local_server_identity(output_format='xml')\n    try:\n        xml_head = identity.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_local_server_identity: %s.' % e)\n        return {}\n    server_identity = {}\n    for a in xml_head:\n        server_identity = {'machine_identifier': helpers.get_xml_attr(a, 'machineIdentifier'), 'version': helpers.get_xml_attr(a, 'version')}\n    return server_identity",
            "def get_server_identity(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Return the local machine identity.\\n\\n        Output: dict\\n        '\n    identity = self.get_local_server_identity(output_format='xml')\n    try:\n        xml_head = identity.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_local_server_identity: %s.' % e)\n        return {}\n    server_identity = {}\n    for a in xml_head:\n        server_identity = {'machine_identifier': helpers.get_xml_attr(a, 'machineIdentifier'), 'version': helpers.get_xml_attr(a, 'version')}\n    return server_identity",
            "def get_server_identity(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Return the local machine identity.\\n\\n        Output: dict\\n        '\n    identity = self.get_local_server_identity(output_format='xml')\n    try:\n        xml_head = identity.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_local_server_identity: %s.' % e)\n        return {}\n    server_identity = {}\n    for a in xml_head:\n        server_identity = {'machine_identifier': helpers.get_xml_attr(a, 'machineIdentifier'), 'version': helpers.get_xml_attr(a, 'version')}\n    return server_identity",
            "def get_server_identity(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Return the local machine identity.\\n\\n        Output: dict\\n        '\n    identity = self.get_local_server_identity(output_format='xml')\n    try:\n        xml_head = identity.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_local_server_identity: %s.' % e)\n        return {}\n    server_identity = {}\n    for a in xml_head:\n        server_identity = {'machine_identifier': helpers.get_xml_attr(a, 'machineIdentifier'), 'version': helpers.get_xml_attr(a, 'version')}\n    return server_identity",
            "def get_server_identity(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Return the local machine identity.\\n\\n        Output: dict\\n        '\n    identity = self.get_local_server_identity(output_format='xml')\n    try:\n        xml_head = identity.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_local_server_identity: %s.' % e)\n        return {}\n    server_identity = {}\n    for a in xml_head:\n        server_identity = {'machine_identifier': helpers.get_xml_attr(a, 'machineIdentifier'), 'version': helpers.get_xml_attr(a, 'version')}\n    return server_identity"
        ]
    },
    {
        "func_name": "get_server_pref",
        "original": "def get_server_pref(self, pref=None):\n    \"\"\"\n        Return a specified server preference.\n\n        Parameters required:    pref { name of preference }\n\n        Output: string\n        \"\"\"\n    if pref:\n        prefs = self.get_server_prefs(output_format='xml')\n        try:\n            xml_head = prefs.getElementsByTagName('Setting')\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_local_server_name: %s.' % e)\n            return ''\n        pref_value = 'None'\n        for a in xml_head:\n            if helpers.get_xml_attr(a, 'id') == pref:\n                pref_value = helpers.get_xml_attr(a, 'value')\n                break\n        return pref_value\n    else:\n        logger.debug('Tautulli Pmsconnect :: Server preferences queried but no parameter received.')\n        return None",
        "mutated": [
            "def get_server_pref(self, pref=None):\n    if False:\n        i = 10\n    '\\n        Return a specified server preference.\\n\\n        Parameters required:    pref { name of preference }\\n\\n        Output: string\\n        '\n    if pref:\n        prefs = self.get_server_prefs(output_format='xml')\n        try:\n            xml_head = prefs.getElementsByTagName('Setting')\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_local_server_name: %s.' % e)\n            return ''\n        pref_value = 'None'\n        for a in xml_head:\n            if helpers.get_xml_attr(a, 'id') == pref:\n                pref_value = helpers.get_xml_attr(a, 'value')\n                break\n        return pref_value\n    else:\n        logger.debug('Tautulli Pmsconnect :: Server preferences queried but no parameter received.')\n        return None",
            "def get_server_pref(self, pref=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Return a specified server preference.\\n\\n        Parameters required:    pref { name of preference }\\n\\n        Output: string\\n        '\n    if pref:\n        prefs = self.get_server_prefs(output_format='xml')\n        try:\n            xml_head = prefs.getElementsByTagName('Setting')\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_local_server_name: %s.' % e)\n            return ''\n        pref_value = 'None'\n        for a in xml_head:\n            if helpers.get_xml_attr(a, 'id') == pref:\n                pref_value = helpers.get_xml_attr(a, 'value')\n                break\n        return pref_value\n    else:\n        logger.debug('Tautulli Pmsconnect :: Server preferences queried but no parameter received.')\n        return None",
            "def get_server_pref(self, pref=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Return a specified server preference.\\n\\n        Parameters required:    pref { name of preference }\\n\\n        Output: string\\n        '\n    if pref:\n        prefs = self.get_server_prefs(output_format='xml')\n        try:\n            xml_head = prefs.getElementsByTagName('Setting')\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_local_server_name: %s.' % e)\n            return ''\n        pref_value = 'None'\n        for a in xml_head:\n            if helpers.get_xml_attr(a, 'id') == pref:\n                pref_value = helpers.get_xml_attr(a, 'value')\n                break\n        return pref_value\n    else:\n        logger.debug('Tautulli Pmsconnect :: Server preferences queried but no parameter received.')\n        return None",
            "def get_server_pref(self, pref=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Return a specified server preference.\\n\\n        Parameters required:    pref { name of preference }\\n\\n        Output: string\\n        '\n    if pref:\n        prefs = self.get_server_prefs(output_format='xml')\n        try:\n            xml_head = prefs.getElementsByTagName('Setting')\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_local_server_name: %s.' % e)\n            return ''\n        pref_value = 'None'\n        for a in xml_head:\n            if helpers.get_xml_attr(a, 'id') == pref:\n                pref_value = helpers.get_xml_attr(a, 'value')\n                break\n        return pref_value\n    else:\n        logger.debug('Tautulli Pmsconnect :: Server preferences queried but no parameter received.')\n        return None",
            "def get_server_pref(self, pref=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Return a specified server preference.\\n\\n        Parameters required:    pref { name of preference }\\n\\n        Output: string\\n        '\n    if pref:\n        prefs = self.get_server_prefs(output_format='xml')\n        try:\n            xml_head = prefs.getElementsByTagName('Setting')\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_local_server_name: %s.' % e)\n            return ''\n        pref_value = 'None'\n        for a in xml_head:\n            if helpers.get_xml_attr(a, 'id') == pref:\n                pref_value = helpers.get_xml_attr(a, 'value')\n                break\n        return pref_value\n    else:\n        logger.debug('Tautulli Pmsconnect :: Server preferences queried but no parameter received.')\n        return None"
        ]
    },
    {
        "func_name": "get_server_children",
        "original": "def get_server_children(self):\n    \"\"\"\n        Return processed and validated server libraries list.\n\n        Output: array\n        \"\"\"\n    libraries_data = self.get_libraries_list(output_format='xml')\n    try:\n        xml_head = libraries_data.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_libraries_list: %s.' % e)\n        return []\n    libraries_list = []\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                logger.debug('Tautulli Pmsconnect :: No libraries data.')\n                libraries_list = {'libraries_count': '0', 'libraries_list': []}\n                return libraries_list\n        if a.getElementsByTagName('Directory'):\n            result_data = a.getElementsByTagName('Directory')\n            for result in result_data:\n                libraries_output = {'section_id': helpers.get_xml_attr(result, 'key'), 'section_type': helpers.get_xml_attr(result, 'type'), 'section_name': helpers.get_xml_attr(result, 'title'), 'agent': helpers.get_xml_attr(result, 'agent'), 'thumb': helpers.get_xml_attr(result, 'thumb'), 'art': helpers.get_xml_attr(result, 'art')}\n                libraries_list.append(libraries_output)\n    output = {'libraries_count': helpers.get_xml_attr(xml_head[0], 'size'), 'title': helpers.get_xml_attr(xml_head[0], 'title1'), 'libraries_list': libraries_list}\n    return output",
        "mutated": [
            "def get_server_children(self):\n    if False:\n        i = 10\n    '\\n        Return processed and validated server libraries list.\\n\\n        Output: array\\n        '\n    libraries_data = self.get_libraries_list(output_format='xml')\n    try:\n        xml_head = libraries_data.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_libraries_list: %s.' % e)\n        return []\n    libraries_list = []\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                logger.debug('Tautulli Pmsconnect :: No libraries data.')\n                libraries_list = {'libraries_count': '0', 'libraries_list': []}\n                return libraries_list\n        if a.getElementsByTagName('Directory'):\n            result_data = a.getElementsByTagName('Directory')\n            for result in result_data:\n                libraries_output = {'section_id': helpers.get_xml_attr(result, 'key'), 'section_type': helpers.get_xml_attr(result, 'type'), 'section_name': helpers.get_xml_attr(result, 'title'), 'agent': helpers.get_xml_attr(result, 'agent'), 'thumb': helpers.get_xml_attr(result, 'thumb'), 'art': helpers.get_xml_attr(result, 'art')}\n                libraries_list.append(libraries_output)\n    output = {'libraries_count': helpers.get_xml_attr(xml_head[0], 'size'), 'title': helpers.get_xml_attr(xml_head[0], 'title1'), 'libraries_list': libraries_list}\n    return output",
            "def get_server_children(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Return processed and validated server libraries list.\\n\\n        Output: array\\n        '\n    libraries_data = self.get_libraries_list(output_format='xml')\n    try:\n        xml_head = libraries_data.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_libraries_list: %s.' % e)\n        return []\n    libraries_list = []\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                logger.debug('Tautulli Pmsconnect :: No libraries data.')\n                libraries_list = {'libraries_count': '0', 'libraries_list': []}\n                return libraries_list\n        if a.getElementsByTagName('Directory'):\n            result_data = a.getElementsByTagName('Directory')\n            for result in result_data:\n                libraries_output = {'section_id': helpers.get_xml_attr(result, 'key'), 'section_type': helpers.get_xml_attr(result, 'type'), 'section_name': helpers.get_xml_attr(result, 'title'), 'agent': helpers.get_xml_attr(result, 'agent'), 'thumb': helpers.get_xml_attr(result, 'thumb'), 'art': helpers.get_xml_attr(result, 'art')}\n                libraries_list.append(libraries_output)\n    output = {'libraries_count': helpers.get_xml_attr(xml_head[0], 'size'), 'title': helpers.get_xml_attr(xml_head[0], 'title1'), 'libraries_list': libraries_list}\n    return output",
            "def get_server_children(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Return processed and validated server libraries list.\\n\\n        Output: array\\n        '\n    libraries_data = self.get_libraries_list(output_format='xml')\n    try:\n        xml_head = libraries_data.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_libraries_list: %s.' % e)\n        return []\n    libraries_list = []\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                logger.debug('Tautulli Pmsconnect :: No libraries data.')\n                libraries_list = {'libraries_count': '0', 'libraries_list': []}\n                return libraries_list\n        if a.getElementsByTagName('Directory'):\n            result_data = a.getElementsByTagName('Directory')\n            for result in result_data:\n                libraries_output = {'section_id': helpers.get_xml_attr(result, 'key'), 'section_type': helpers.get_xml_attr(result, 'type'), 'section_name': helpers.get_xml_attr(result, 'title'), 'agent': helpers.get_xml_attr(result, 'agent'), 'thumb': helpers.get_xml_attr(result, 'thumb'), 'art': helpers.get_xml_attr(result, 'art')}\n                libraries_list.append(libraries_output)\n    output = {'libraries_count': helpers.get_xml_attr(xml_head[0], 'size'), 'title': helpers.get_xml_attr(xml_head[0], 'title1'), 'libraries_list': libraries_list}\n    return output",
            "def get_server_children(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Return processed and validated server libraries list.\\n\\n        Output: array\\n        '\n    libraries_data = self.get_libraries_list(output_format='xml')\n    try:\n        xml_head = libraries_data.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_libraries_list: %s.' % e)\n        return []\n    libraries_list = []\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                logger.debug('Tautulli Pmsconnect :: No libraries data.')\n                libraries_list = {'libraries_count': '0', 'libraries_list': []}\n                return libraries_list\n        if a.getElementsByTagName('Directory'):\n            result_data = a.getElementsByTagName('Directory')\n            for result in result_data:\n                libraries_output = {'section_id': helpers.get_xml_attr(result, 'key'), 'section_type': helpers.get_xml_attr(result, 'type'), 'section_name': helpers.get_xml_attr(result, 'title'), 'agent': helpers.get_xml_attr(result, 'agent'), 'thumb': helpers.get_xml_attr(result, 'thumb'), 'art': helpers.get_xml_attr(result, 'art')}\n                libraries_list.append(libraries_output)\n    output = {'libraries_count': helpers.get_xml_attr(xml_head[0], 'size'), 'title': helpers.get_xml_attr(xml_head[0], 'title1'), 'libraries_list': libraries_list}\n    return output",
            "def get_server_children(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Return processed and validated server libraries list.\\n\\n        Output: array\\n        '\n    libraries_data = self.get_libraries_list(output_format='xml')\n    try:\n        xml_head = libraries_data.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_libraries_list: %s.' % e)\n        return []\n    libraries_list = []\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                logger.debug('Tautulli Pmsconnect :: No libraries data.')\n                libraries_list = {'libraries_count': '0', 'libraries_list': []}\n                return libraries_list\n        if a.getElementsByTagName('Directory'):\n            result_data = a.getElementsByTagName('Directory')\n            for result in result_data:\n                libraries_output = {'section_id': helpers.get_xml_attr(result, 'key'), 'section_type': helpers.get_xml_attr(result, 'type'), 'section_name': helpers.get_xml_attr(result, 'title'), 'agent': helpers.get_xml_attr(result, 'agent'), 'thumb': helpers.get_xml_attr(result, 'thumb'), 'art': helpers.get_xml_attr(result, 'art')}\n                libraries_list.append(libraries_output)\n    output = {'libraries_count': helpers.get_xml_attr(xml_head[0], 'size'), 'title': helpers.get_xml_attr(xml_head[0], 'title1'), 'libraries_list': libraries_list}\n    return output"
        ]
    },
    {
        "func_name": "get_library_children_details",
        "original": "def get_library_children_details(self, section_id='', section_type='', list_type='all', count='', rating_key='', label_key='', get_media_info=False):\n    \"\"\"\n        Return processed and validated server library items list.\n\n        Parameters required:    section_type { movie, show, episode, artist }\n                                section_id { unique library key }\n\n        Output: array\n        \"\"\"\n    if section_type == 'movie':\n        sort_type = '&type=1'\n    elif section_type == 'show':\n        sort_type = '&type=2'\n    elif section_type == 'season':\n        sort_type = '&type=3'\n    elif section_type == 'episode':\n        sort_type = '&type=4'\n    elif section_type == 'artist':\n        sort_type = '&type=8'\n    elif section_type == 'album':\n        sort_type = '&type=9'\n    elif section_type == 'track':\n        sort_type = '&type=10'\n    elif section_type == 'photo':\n        sort_type = ''\n    elif section_type == 'photo_album':\n        sort_type = '&type=14'\n    elif section_type == 'picture':\n        sort_type = '&type=13&clusterZoomLevel=1'\n    elif section_type == 'clip':\n        sort_type = '&type=12&clusterZoomLevel=1'\n    else:\n        sort_type = ''\n    if str(rating_key).isdigit() and section_type != 'album':\n        library_data = self.get_metadata_children(str(rating_key), output_format='xml')\n        try:\n            xml_head = library_data.getElementsByTagName('MediaContainer')\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_library_children_details: %s.' % e)\n            return []\n    elif str(section_id).isdigit() or section_type == 'album':\n        if section_type == 'album' and rating_key:\n            sort_type += '&artist.id=' + str(rating_key)\n        xml_head = self.fetch_library_list(section_id=str(section_id), list_type=list_type, count=count, sort_type=sort_type, label_key=label_key, output_format='xml')\n    else:\n        logger.warn('Tautulli Pmsconnect :: get_library_children called by invalid section_id or rating_key provided.')\n        return []\n    library_count = '0'\n    children_list = []\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                logger.debug('Tautulli Pmsconnect :: No library data.')\n                children_list = {'library_count': '0', 'children_list': []}\n                return children_list\n        if rating_key:\n            library_count = helpers.get_xml_attr(xml_head[0], 'size')\n        else:\n            library_count = helpers.get_xml_attr(xml_head[0], 'totalSize')\n        item_main = []\n        if a.getElementsByTagName('Directory'):\n            dir_main = a.getElementsByTagName('Directory')\n            item_main += [d for d in dir_main if helpers.get_xml_attr(d, 'ratingKey')]\n        if a.getElementsByTagName('Video'):\n            item_main += a.getElementsByTagName('Video')\n        if a.getElementsByTagName('Track'):\n            item_main += a.getElementsByTagName('Track')\n        if a.getElementsByTagName('Photo'):\n            item_main += a.getElementsByTagName('Photo')\n        for item in item_main:\n            media_type = helpers.get_xml_attr(item, 'type')\n            if item.nodeName == 'Directory' and media_type == 'photo':\n                media_type = 'photo_album'\n            item_info = {'section_id': helpers.get_xml_attr(a, 'librarySectionID'), 'media_type': media_type, 'rating_key': helpers.get_xml_attr(item, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(item, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(item, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(item, 'title'), 'parent_title': helpers.get_xml_attr(item, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(item, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(item, 'originalTitle'), 'sort_title': helpers.get_xml_attr(item, 'titleSort'), 'media_index': helpers.get_xml_attr(item, 'index'), 'parent_media_index': helpers.get_xml_attr(item, 'parentIndex'), 'year': helpers.get_xml_attr(item, 'year'), 'thumb': helpers.get_xml_attr(item, 'thumb'), 'parent_thumb': helpers.get_xml_attr(item, 'thumb'), 'grandparent_thumb': helpers.get_xml_attr(item, 'grandparentThumb'), 'added_at': helpers.get_xml_attr(item, 'addedAt')}\n            if get_media_info:\n                item_media = item.getElementsByTagName('Media')\n                for media in item_media:\n                    media_info = {'container': helpers.get_xml_attr(media, 'container'), 'bitrate': helpers.get_xml_attr(media, 'bitrate'), 'video_codec': helpers.get_xml_attr(media, 'videoCodec'), 'video_resolution': helpers.get_xml_attr(media, 'videoResolution').lower(), 'video_framerate': helpers.get_xml_attr(media, 'videoFrameRate'), 'audio_codec': helpers.get_xml_attr(media, 'audioCodec'), 'audio_channels': helpers.get_xml_attr(media, 'audioChannels'), 'file': helpers.get_xml_attr(media.getElementsByTagName('Part')[0], 'file'), 'file_size': helpers.get_xml_attr(media.getElementsByTagName('Part')[0], 'size')}\n                    item_info.update(media_info)\n            children_list.append(item_info)\n    output = {'library_count': library_count, 'children_list': children_list}\n    return output",
        "mutated": [
            "def get_library_children_details(self, section_id='', section_type='', list_type='all', count='', rating_key='', label_key='', get_media_info=False):\n    if False:\n        i = 10\n    '\\n        Return processed and validated server library items list.\\n\\n        Parameters required:    section_type { movie, show, episode, artist }\\n                                section_id { unique library key }\\n\\n        Output: array\\n        '\n    if section_type == 'movie':\n        sort_type = '&type=1'\n    elif section_type == 'show':\n        sort_type = '&type=2'\n    elif section_type == 'season':\n        sort_type = '&type=3'\n    elif section_type == 'episode':\n        sort_type = '&type=4'\n    elif section_type == 'artist':\n        sort_type = '&type=8'\n    elif section_type == 'album':\n        sort_type = '&type=9'\n    elif section_type == 'track':\n        sort_type = '&type=10'\n    elif section_type == 'photo':\n        sort_type = ''\n    elif section_type == 'photo_album':\n        sort_type = '&type=14'\n    elif section_type == 'picture':\n        sort_type = '&type=13&clusterZoomLevel=1'\n    elif section_type == 'clip':\n        sort_type = '&type=12&clusterZoomLevel=1'\n    else:\n        sort_type = ''\n    if str(rating_key).isdigit() and section_type != 'album':\n        library_data = self.get_metadata_children(str(rating_key), output_format='xml')\n        try:\n            xml_head = library_data.getElementsByTagName('MediaContainer')\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_library_children_details: %s.' % e)\n            return []\n    elif str(section_id).isdigit() or section_type == 'album':\n        if section_type == 'album' and rating_key:\n            sort_type += '&artist.id=' + str(rating_key)\n        xml_head = self.fetch_library_list(section_id=str(section_id), list_type=list_type, count=count, sort_type=sort_type, label_key=label_key, output_format='xml')\n    else:\n        logger.warn('Tautulli Pmsconnect :: get_library_children called by invalid section_id or rating_key provided.')\n        return []\n    library_count = '0'\n    children_list = []\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                logger.debug('Tautulli Pmsconnect :: No library data.')\n                children_list = {'library_count': '0', 'children_list': []}\n                return children_list\n        if rating_key:\n            library_count = helpers.get_xml_attr(xml_head[0], 'size')\n        else:\n            library_count = helpers.get_xml_attr(xml_head[0], 'totalSize')\n        item_main = []\n        if a.getElementsByTagName('Directory'):\n            dir_main = a.getElementsByTagName('Directory')\n            item_main += [d for d in dir_main if helpers.get_xml_attr(d, 'ratingKey')]\n        if a.getElementsByTagName('Video'):\n            item_main += a.getElementsByTagName('Video')\n        if a.getElementsByTagName('Track'):\n            item_main += a.getElementsByTagName('Track')\n        if a.getElementsByTagName('Photo'):\n            item_main += a.getElementsByTagName('Photo')\n        for item in item_main:\n            media_type = helpers.get_xml_attr(item, 'type')\n            if item.nodeName == 'Directory' and media_type == 'photo':\n                media_type = 'photo_album'\n            item_info = {'section_id': helpers.get_xml_attr(a, 'librarySectionID'), 'media_type': media_type, 'rating_key': helpers.get_xml_attr(item, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(item, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(item, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(item, 'title'), 'parent_title': helpers.get_xml_attr(item, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(item, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(item, 'originalTitle'), 'sort_title': helpers.get_xml_attr(item, 'titleSort'), 'media_index': helpers.get_xml_attr(item, 'index'), 'parent_media_index': helpers.get_xml_attr(item, 'parentIndex'), 'year': helpers.get_xml_attr(item, 'year'), 'thumb': helpers.get_xml_attr(item, 'thumb'), 'parent_thumb': helpers.get_xml_attr(item, 'thumb'), 'grandparent_thumb': helpers.get_xml_attr(item, 'grandparentThumb'), 'added_at': helpers.get_xml_attr(item, 'addedAt')}\n            if get_media_info:\n                item_media = item.getElementsByTagName('Media')\n                for media in item_media:\n                    media_info = {'container': helpers.get_xml_attr(media, 'container'), 'bitrate': helpers.get_xml_attr(media, 'bitrate'), 'video_codec': helpers.get_xml_attr(media, 'videoCodec'), 'video_resolution': helpers.get_xml_attr(media, 'videoResolution').lower(), 'video_framerate': helpers.get_xml_attr(media, 'videoFrameRate'), 'audio_codec': helpers.get_xml_attr(media, 'audioCodec'), 'audio_channels': helpers.get_xml_attr(media, 'audioChannels'), 'file': helpers.get_xml_attr(media.getElementsByTagName('Part')[0], 'file'), 'file_size': helpers.get_xml_attr(media.getElementsByTagName('Part')[0], 'size')}\n                    item_info.update(media_info)\n            children_list.append(item_info)\n    output = {'library_count': library_count, 'children_list': children_list}\n    return output",
            "def get_library_children_details(self, section_id='', section_type='', list_type='all', count='', rating_key='', label_key='', get_media_info=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Return processed and validated server library items list.\\n\\n        Parameters required:    section_type { movie, show, episode, artist }\\n                                section_id { unique library key }\\n\\n        Output: array\\n        '\n    if section_type == 'movie':\n        sort_type = '&type=1'\n    elif section_type == 'show':\n        sort_type = '&type=2'\n    elif section_type == 'season':\n        sort_type = '&type=3'\n    elif section_type == 'episode':\n        sort_type = '&type=4'\n    elif section_type == 'artist':\n        sort_type = '&type=8'\n    elif section_type == 'album':\n        sort_type = '&type=9'\n    elif section_type == 'track':\n        sort_type = '&type=10'\n    elif section_type == 'photo':\n        sort_type = ''\n    elif section_type == 'photo_album':\n        sort_type = '&type=14'\n    elif section_type == 'picture':\n        sort_type = '&type=13&clusterZoomLevel=1'\n    elif section_type == 'clip':\n        sort_type = '&type=12&clusterZoomLevel=1'\n    else:\n        sort_type = ''\n    if str(rating_key).isdigit() and section_type != 'album':\n        library_data = self.get_metadata_children(str(rating_key), output_format='xml')\n        try:\n            xml_head = library_data.getElementsByTagName('MediaContainer')\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_library_children_details: %s.' % e)\n            return []\n    elif str(section_id).isdigit() or section_type == 'album':\n        if section_type == 'album' and rating_key:\n            sort_type += '&artist.id=' + str(rating_key)\n        xml_head = self.fetch_library_list(section_id=str(section_id), list_type=list_type, count=count, sort_type=sort_type, label_key=label_key, output_format='xml')\n    else:\n        logger.warn('Tautulli Pmsconnect :: get_library_children called by invalid section_id or rating_key provided.')\n        return []\n    library_count = '0'\n    children_list = []\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                logger.debug('Tautulli Pmsconnect :: No library data.')\n                children_list = {'library_count': '0', 'children_list': []}\n                return children_list\n        if rating_key:\n            library_count = helpers.get_xml_attr(xml_head[0], 'size')\n        else:\n            library_count = helpers.get_xml_attr(xml_head[0], 'totalSize')\n        item_main = []\n        if a.getElementsByTagName('Directory'):\n            dir_main = a.getElementsByTagName('Directory')\n            item_main += [d for d in dir_main if helpers.get_xml_attr(d, 'ratingKey')]\n        if a.getElementsByTagName('Video'):\n            item_main += a.getElementsByTagName('Video')\n        if a.getElementsByTagName('Track'):\n            item_main += a.getElementsByTagName('Track')\n        if a.getElementsByTagName('Photo'):\n            item_main += a.getElementsByTagName('Photo')\n        for item in item_main:\n            media_type = helpers.get_xml_attr(item, 'type')\n            if item.nodeName == 'Directory' and media_type == 'photo':\n                media_type = 'photo_album'\n            item_info = {'section_id': helpers.get_xml_attr(a, 'librarySectionID'), 'media_type': media_type, 'rating_key': helpers.get_xml_attr(item, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(item, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(item, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(item, 'title'), 'parent_title': helpers.get_xml_attr(item, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(item, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(item, 'originalTitle'), 'sort_title': helpers.get_xml_attr(item, 'titleSort'), 'media_index': helpers.get_xml_attr(item, 'index'), 'parent_media_index': helpers.get_xml_attr(item, 'parentIndex'), 'year': helpers.get_xml_attr(item, 'year'), 'thumb': helpers.get_xml_attr(item, 'thumb'), 'parent_thumb': helpers.get_xml_attr(item, 'thumb'), 'grandparent_thumb': helpers.get_xml_attr(item, 'grandparentThumb'), 'added_at': helpers.get_xml_attr(item, 'addedAt')}\n            if get_media_info:\n                item_media = item.getElementsByTagName('Media')\n                for media in item_media:\n                    media_info = {'container': helpers.get_xml_attr(media, 'container'), 'bitrate': helpers.get_xml_attr(media, 'bitrate'), 'video_codec': helpers.get_xml_attr(media, 'videoCodec'), 'video_resolution': helpers.get_xml_attr(media, 'videoResolution').lower(), 'video_framerate': helpers.get_xml_attr(media, 'videoFrameRate'), 'audio_codec': helpers.get_xml_attr(media, 'audioCodec'), 'audio_channels': helpers.get_xml_attr(media, 'audioChannels'), 'file': helpers.get_xml_attr(media.getElementsByTagName('Part')[0], 'file'), 'file_size': helpers.get_xml_attr(media.getElementsByTagName('Part')[0], 'size')}\n                    item_info.update(media_info)\n            children_list.append(item_info)\n    output = {'library_count': library_count, 'children_list': children_list}\n    return output",
            "def get_library_children_details(self, section_id='', section_type='', list_type='all', count='', rating_key='', label_key='', get_media_info=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Return processed and validated server library items list.\\n\\n        Parameters required:    section_type { movie, show, episode, artist }\\n                                section_id { unique library key }\\n\\n        Output: array\\n        '\n    if section_type == 'movie':\n        sort_type = '&type=1'\n    elif section_type == 'show':\n        sort_type = '&type=2'\n    elif section_type == 'season':\n        sort_type = '&type=3'\n    elif section_type == 'episode':\n        sort_type = '&type=4'\n    elif section_type == 'artist':\n        sort_type = '&type=8'\n    elif section_type == 'album':\n        sort_type = '&type=9'\n    elif section_type == 'track':\n        sort_type = '&type=10'\n    elif section_type == 'photo':\n        sort_type = ''\n    elif section_type == 'photo_album':\n        sort_type = '&type=14'\n    elif section_type == 'picture':\n        sort_type = '&type=13&clusterZoomLevel=1'\n    elif section_type == 'clip':\n        sort_type = '&type=12&clusterZoomLevel=1'\n    else:\n        sort_type = ''\n    if str(rating_key).isdigit() and section_type != 'album':\n        library_data = self.get_metadata_children(str(rating_key), output_format='xml')\n        try:\n            xml_head = library_data.getElementsByTagName('MediaContainer')\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_library_children_details: %s.' % e)\n            return []\n    elif str(section_id).isdigit() or section_type == 'album':\n        if section_type == 'album' and rating_key:\n            sort_type += '&artist.id=' + str(rating_key)\n        xml_head = self.fetch_library_list(section_id=str(section_id), list_type=list_type, count=count, sort_type=sort_type, label_key=label_key, output_format='xml')\n    else:\n        logger.warn('Tautulli Pmsconnect :: get_library_children called by invalid section_id or rating_key provided.')\n        return []\n    library_count = '0'\n    children_list = []\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                logger.debug('Tautulli Pmsconnect :: No library data.')\n                children_list = {'library_count': '0', 'children_list': []}\n                return children_list\n        if rating_key:\n            library_count = helpers.get_xml_attr(xml_head[0], 'size')\n        else:\n            library_count = helpers.get_xml_attr(xml_head[0], 'totalSize')\n        item_main = []\n        if a.getElementsByTagName('Directory'):\n            dir_main = a.getElementsByTagName('Directory')\n            item_main += [d for d in dir_main if helpers.get_xml_attr(d, 'ratingKey')]\n        if a.getElementsByTagName('Video'):\n            item_main += a.getElementsByTagName('Video')\n        if a.getElementsByTagName('Track'):\n            item_main += a.getElementsByTagName('Track')\n        if a.getElementsByTagName('Photo'):\n            item_main += a.getElementsByTagName('Photo')\n        for item in item_main:\n            media_type = helpers.get_xml_attr(item, 'type')\n            if item.nodeName == 'Directory' and media_type == 'photo':\n                media_type = 'photo_album'\n            item_info = {'section_id': helpers.get_xml_attr(a, 'librarySectionID'), 'media_type': media_type, 'rating_key': helpers.get_xml_attr(item, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(item, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(item, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(item, 'title'), 'parent_title': helpers.get_xml_attr(item, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(item, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(item, 'originalTitle'), 'sort_title': helpers.get_xml_attr(item, 'titleSort'), 'media_index': helpers.get_xml_attr(item, 'index'), 'parent_media_index': helpers.get_xml_attr(item, 'parentIndex'), 'year': helpers.get_xml_attr(item, 'year'), 'thumb': helpers.get_xml_attr(item, 'thumb'), 'parent_thumb': helpers.get_xml_attr(item, 'thumb'), 'grandparent_thumb': helpers.get_xml_attr(item, 'grandparentThumb'), 'added_at': helpers.get_xml_attr(item, 'addedAt')}\n            if get_media_info:\n                item_media = item.getElementsByTagName('Media')\n                for media in item_media:\n                    media_info = {'container': helpers.get_xml_attr(media, 'container'), 'bitrate': helpers.get_xml_attr(media, 'bitrate'), 'video_codec': helpers.get_xml_attr(media, 'videoCodec'), 'video_resolution': helpers.get_xml_attr(media, 'videoResolution').lower(), 'video_framerate': helpers.get_xml_attr(media, 'videoFrameRate'), 'audio_codec': helpers.get_xml_attr(media, 'audioCodec'), 'audio_channels': helpers.get_xml_attr(media, 'audioChannels'), 'file': helpers.get_xml_attr(media.getElementsByTagName('Part')[0], 'file'), 'file_size': helpers.get_xml_attr(media.getElementsByTagName('Part')[0], 'size')}\n                    item_info.update(media_info)\n            children_list.append(item_info)\n    output = {'library_count': library_count, 'children_list': children_list}\n    return output",
            "def get_library_children_details(self, section_id='', section_type='', list_type='all', count='', rating_key='', label_key='', get_media_info=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Return processed and validated server library items list.\\n\\n        Parameters required:    section_type { movie, show, episode, artist }\\n                                section_id { unique library key }\\n\\n        Output: array\\n        '\n    if section_type == 'movie':\n        sort_type = '&type=1'\n    elif section_type == 'show':\n        sort_type = '&type=2'\n    elif section_type == 'season':\n        sort_type = '&type=3'\n    elif section_type == 'episode':\n        sort_type = '&type=4'\n    elif section_type == 'artist':\n        sort_type = '&type=8'\n    elif section_type == 'album':\n        sort_type = '&type=9'\n    elif section_type == 'track':\n        sort_type = '&type=10'\n    elif section_type == 'photo':\n        sort_type = ''\n    elif section_type == 'photo_album':\n        sort_type = '&type=14'\n    elif section_type == 'picture':\n        sort_type = '&type=13&clusterZoomLevel=1'\n    elif section_type == 'clip':\n        sort_type = '&type=12&clusterZoomLevel=1'\n    else:\n        sort_type = ''\n    if str(rating_key).isdigit() and section_type != 'album':\n        library_data = self.get_metadata_children(str(rating_key), output_format='xml')\n        try:\n            xml_head = library_data.getElementsByTagName('MediaContainer')\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_library_children_details: %s.' % e)\n            return []\n    elif str(section_id).isdigit() or section_type == 'album':\n        if section_type == 'album' and rating_key:\n            sort_type += '&artist.id=' + str(rating_key)\n        xml_head = self.fetch_library_list(section_id=str(section_id), list_type=list_type, count=count, sort_type=sort_type, label_key=label_key, output_format='xml')\n    else:\n        logger.warn('Tautulli Pmsconnect :: get_library_children called by invalid section_id or rating_key provided.')\n        return []\n    library_count = '0'\n    children_list = []\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                logger.debug('Tautulli Pmsconnect :: No library data.')\n                children_list = {'library_count': '0', 'children_list': []}\n                return children_list\n        if rating_key:\n            library_count = helpers.get_xml_attr(xml_head[0], 'size')\n        else:\n            library_count = helpers.get_xml_attr(xml_head[0], 'totalSize')\n        item_main = []\n        if a.getElementsByTagName('Directory'):\n            dir_main = a.getElementsByTagName('Directory')\n            item_main += [d for d in dir_main if helpers.get_xml_attr(d, 'ratingKey')]\n        if a.getElementsByTagName('Video'):\n            item_main += a.getElementsByTagName('Video')\n        if a.getElementsByTagName('Track'):\n            item_main += a.getElementsByTagName('Track')\n        if a.getElementsByTagName('Photo'):\n            item_main += a.getElementsByTagName('Photo')\n        for item in item_main:\n            media_type = helpers.get_xml_attr(item, 'type')\n            if item.nodeName == 'Directory' and media_type == 'photo':\n                media_type = 'photo_album'\n            item_info = {'section_id': helpers.get_xml_attr(a, 'librarySectionID'), 'media_type': media_type, 'rating_key': helpers.get_xml_attr(item, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(item, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(item, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(item, 'title'), 'parent_title': helpers.get_xml_attr(item, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(item, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(item, 'originalTitle'), 'sort_title': helpers.get_xml_attr(item, 'titleSort'), 'media_index': helpers.get_xml_attr(item, 'index'), 'parent_media_index': helpers.get_xml_attr(item, 'parentIndex'), 'year': helpers.get_xml_attr(item, 'year'), 'thumb': helpers.get_xml_attr(item, 'thumb'), 'parent_thumb': helpers.get_xml_attr(item, 'thumb'), 'grandparent_thumb': helpers.get_xml_attr(item, 'grandparentThumb'), 'added_at': helpers.get_xml_attr(item, 'addedAt')}\n            if get_media_info:\n                item_media = item.getElementsByTagName('Media')\n                for media in item_media:\n                    media_info = {'container': helpers.get_xml_attr(media, 'container'), 'bitrate': helpers.get_xml_attr(media, 'bitrate'), 'video_codec': helpers.get_xml_attr(media, 'videoCodec'), 'video_resolution': helpers.get_xml_attr(media, 'videoResolution').lower(), 'video_framerate': helpers.get_xml_attr(media, 'videoFrameRate'), 'audio_codec': helpers.get_xml_attr(media, 'audioCodec'), 'audio_channels': helpers.get_xml_attr(media, 'audioChannels'), 'file': helpers.get_xml_attr(media.getElementsByTagName('Part')[0], 'file'), 'file_size': helpers.get_xml_attr(media.getElementsByTagName('Part')[0], 'size')}\n                    item_info.update(media_info)\n            children_list.append(item_info)\n    output = {'library_count': library_count, 'children_list': children_list}\n    return output",
            "def get_library_children_details(self, section_id='', section_type='', list_type='all', count='', rating_key='', label_key='', get_media_info=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Return processed and validated server library items list.\\n\\n        Parameters required:    section_type { movie, show, episode, artist }\\n                                section_id { unique library key }\\n\\n        Output: array\\n        '\n    if section_type == 'movie':\n        sort_type = '&type=1'\n    elif section_type == 'show':\n        sort_type = '&type=2'\n    elif section_type == 'season':\n        sort_type = '&type=3'\n    elif section_type == 'episode':\n        sort_type = '&type=4'\n    elif section_type == 'artist':\n        sort_type = '&type=8'\n    elif section_type == 'album':\n        sort_type = '&type=9'\n    elif section_type == 'track':\n        sort_type = '&type=10'\n    elif section_type == 'photo':\n        sort_type = ''\n    elif section_type == 'photo_album':\n        sort_type = '&type=14'\n    elif section_type == 'picture':\n        sort_type = '&type=13&clusterZoomLevel=1'\n    elif section_type == 'clip':\n        sort_type = '&type=12&clusterZoomLevel=1'\n    else:\n        sort_type = ''\n    if str(rating_key).isdigit() and section_type != 'album':\n        library_data = self.get_metadata_children(str(rating_key), output_format='xml')\n        try:\n            xml_head = library_data.getElementsByTagName('MediaContainer')\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_library_children_details: %s.' % e)\n            return []\n    elif str(section_id).isdigit() or section_type == 'album':\n        if section_type == 'album' and rating_key:\n            sort_type += '&artist.id=' + str(rating_key)\n        xml_head = self.fetch_library_list(section_id=str(section_id), list_type=list_type, count=count, sort_type=sort_type, label_key=label_key, output_format='xml')\n    else:\n        logger.warn('Tautulli Pmsconnect :: get_library_children called by invalid section_id or rating_key provided.')\n        return []\n    library_count = '0'\n    children_list = []\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                logger.debug('Tautulli Pmsconnect :: No library data.')\n                children_list = {'library_count': '0', 'children_list': []}\n                return children_list\n        if rating_key:\n            library_count = helpers.get_xml_attr(xml_head[0], 'size')\n        else:\n            library_count = helpers.get_xml_attr(xml_head[0], 'totalSize')\n        item_main = []\n        if a.getElementsByTagName('Directory'):\n            dir_main = a.getElementsByTagName('Directory')\n            item_main += [d for d in dir_main if helpers.get_xml_attr(d, 'ratingKey')]\n        if a.getElementsByTagName('Video'):\n            item_main += a.getElementsByTagName('Video')\n        if a.getElementsByTagName('Track'):\n            item_main += a.getElementsByTagName('Track')\n        if a.getElementsByTagName('Photo'):\n            item_main += a.getElementsByTagName('Photo')\n        for item in item_main:\n            media_type = helpers.get_xml_attr(item, 'type')\n            if item.nodeName == 'Directory' and media_type == 'photo':\n                media_type = 'photo_album'\n            item_info = {'section_id': helpers.get_xml_attr(a, 'librarySectionID'), 'media_type': media_type, 'rating_key': helpers.get_xml_attr(item, 'ratingKey'), 'parent_rating_key': helpers.get_xml_attr(item, 'parentRatingKey'), 'grandparent_rating_key': helpers.get_xml_attr(item, 'grandparentRatingKey'), 'title': helpers.get_xml_attr(item, 'title'), 'parent_title': helpers.get_xml_attr(item, 'parentTitle'), 'grandparent_title': helpers.get_xml_attr(item, 'grandparentTitle'), 'original_title': helpers.get_xml_attr(item, 'originalTitle'), 'sort_title': helpers.get_xml_attr(item, 'titleSort'), 'media_index': helpers.get_xml_attr(item, 'index'), 'parent_media_index': helpers.get_xml_attr(item, 'parentIndex'), 'year': helpers.get_xml_attr(item, 'year'), 'thumb': helpers.get_xml_attr(item, 'thumb'), 'parent_thumb': helpers.get_xml_attr(item, 'thumb'), 'grandparent_thumb': helpers.get_xml_attr(item, 'grandparentThumb'), 'added_at': helpers.get_xml_attr(item, 'addedAt')}\n            if get_media_info:\n                item_media = item.getElementsByTagName('Media')\n                for media in item_media:\n                    media_info = {'container': helpers.get_xml_attr(media, 'container'), 'bitrate': helpers.get_xml_attr(media, 'bitrate'), 'video_codec': helpers.get_xml_attr(media, 'videoCodec'), 'video_resolution': helpers.get_xml_attr(media, 'videoResolution').lower(), 'video_framerate': helpers.get_xml_attr(media, 'videoFrameRate'), 'audio_codec': helpers.get_xml_attr(media, 'audioCodec'), 'audio_channels': helpers.get_xml_attr(media, 'audioChannels'), 'file': helpers.get_xml_attr(media.getElementsByTagName('Part')[0], 'file'), 'file_size': helpers.get_xml_attr(media.getElementsByTagName('Part')[0], 'size')}\n                    item_info.update(media_info)\n            children_list.append(item_info)\n    output = {'library_count': library_count, 'children_list': children_list}\n    return output"
        ]
    },
    {
        "func_name": "get_library_details",
        "original": "def get_library_details(self):\n    \"\"\"\n        Return processed and validated library statistics.\n\n        Output: array\n        \"\"\"\n    server_libraries = self.get_server_children()\n    server_library_stats = []\n    if server_libraries and server_libraries['libraries_count'] != '0':\n        libraries_list = server_libraries['libraries_list']\n        for library in libraries_list:\n            section_type = library['section_type']\n            section_id = library['section_id']\n            children_list = self.get_library_children_details(section_id=section_id, section_type=section_type, count='1')\n            if children_list:\n                library_stats = {'section_id': section_id, 'section_name': library['section_name'], 'section_type': section_type, 'agent': library['agent'], 'thumb': library['thumb'], 'art': library['art'], 'count': children_list['library_count'], 'is_active': 1}\n                if section_type == 'show':\n                    parent_list = self.get_library_children_details(section_id=section_id, section_type='season', count='1')\n                    if parent_list:\n                        parent_stats = {'parent_count': parent_list['library_count']}\n                        library_stats.update(parent_stats)\n                    child_list = self.get_library_children_details(section_id=section_id, section_type='episode', count='1')\n                    if child_list:\n                        child_stats = {'child_count': child_list['library_count']}\n                        library_stats.update(child_stats)\n                if section_type == 'artist':\n                    parent_list = self.get_library_children_details(section_id=section_id, section_type='album', count='1')\n                    if parent_list:\n                        parent_stats = {'parent_count': parent_list['library_count']}\n                        library_stats.update(parent_stats)\n                    child_list = self.get_library_children_details(section_id=section_id, section_type='track', count='1')\n                    if child_list:\n                        child_stats = {'child_count': child_list['library_count']}\n                        library_stats.update(child_stats)\n                if section_type == 'photo':\n                    parent_list = self.get_library_children_details(section_id=section_id, section_type='picture', count='1')\n                    if parent_list:\n                        parent_stats = {'parent_count': parent_list['library_count']}\n                        library_stats.update(parent_stats)\n                    child_list = self.get_library_children_details(section_id=section_id, section_type='clip', count='1')\n                    if child_list:\n                        child_stats = {'child_count': child_list['library_count']}\n                        library_stats.update(child_stats)\n                server_library_stats.append(library_stats)\n    return server_library_stats",
        "mutated": [
            "def get_library_details(self):\n    if False:\n        i = 10\n    '\\n        Return processed and validated library statistics.\\n\\n        Output: array\\n        '\n    server_libraries = self.get_server_children()\n    server_library_stats = []\n    if server_libraries and server_libraries['libraries_count'] != '0':\n        libraries_list = server_libraries['libraries_list']\n        for library in libraries_list:\n            section_type = library['section_type']\n            section_id = library['section_id']\n            children_list = self.get_library_children_details(section_id=section_id, section_type=section_type, count='1')\n            if children_list:\n                library_stats = {'section_id': section_id, 'section_name': library['section_name'], 'section_type': section_type, 'agent': library['agent'], 'thumb': library['thumb'], 'art': library['art'], 'count': children_list['library_count'], 'is_active': 1}\n                if section_type == 'show':\n                    parent_list = self.get_library_children_details(section_id=section_id, section_type='season', count='1')\n                    if parent_list:\n                        parent_stats = {'parent_count': parent_list['library_count']}\n                        library_stats.update(parent_stats)\n                    child_list = self.get_library_children_details(section_id=section_id, section_type='episode', count='1')\n                    if child_list:\n                        child_stats = {'child_count': child_list['library_count']}\n                        library_stats.update(child_stats)\n                if section_type == 'artist':\n                    parent_list = self.get_library_children_details(section_id=section_id, section_type='album', count='1')\n                    if parent_list:\n                        parent_stats = {'parent_count': parent_list['library_count']}\n                        library_stats.update(parent_stats)\n                    child_list = self.get_library_children_details(section_id=section_id, section_type='track', count='1')\n                    if child_list:\n                        child_stats = {'child_count': child_list['library_count']}\n                        library_stats.update(child_stats)\n                if section_type == 'photo':\n                    parent_list = self.get_library_children_details(section_id=section_id, section_type='picture', count='1')\n                    if parent_list:\n                        parent_stats = {'parent_count': parent_list['library_count']}\n                        library_stats.update(parent_stats)\n                    child_list = self.get_library_children_details(section_id=section_id, section_type='clip', count='1')\n                    if child_list:\n                        child_stats = {'child_count': child_list['library_count']}\n                        library_stats.update(child_stats)\n                server_library_stats.append(library_stats)\n    return server_library_stats",
            "def get_library_details(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Return processed and validated library statistics.\\n\\n        Output: array\\n        '\n    server_libraries = self.get_server_children()\n    server_library_stats = []\n    if server_libraries and server_libraries['libraries_count'] != '0':\n        libraries_list = server_libraries['libraries_list']\n        for library in libraries_list:\n            section_type = library['section_type']\n            section_id = library['section_id']\n            children_list = self.get_library_children_details(section_id=section_id, section_type=section_type, count='1')\n            if children_list:\n                library_stats = {'section_id': section_id, 'section_name': library['section_name'], 'section_type': section_type, 'agent': library['agent'], 'thumb': library['thumb'], 'art': library['art'], 'count': children_list['library_count'], 'is_active': 1}\n                if section_type == 'show':\n                    parent_list = self.get_library_children_details(section_id=section_id, section_type='season', count='1')\n                    if parent_list:\n                        parent_stats = {'parent_count': parent_list['library_count']}\n                        library_stats.update(parent_stats)\n                    child_list = self.get_library_children_details(section_id=section_id, section_type='episode', count='1')\n                    if child_list:\n                        child_stats = {'child_count': child_list['library_count']}\n                        library_stats.update(child_stats)\n                if section_type == 'artist':\n                    parent_list = self.get_library_children_details(section_id=section_id, section_type='album', count='1')\n                    if parent_list:\n                        parent_stats = {'parent_count': parent_list['library_count']}\n                        library_stats.update(parent_stats)\n                    child_list = self.get_library_children_details(section_id=section_id, section_type='track', count='1')\n                    if child_list:\n                        child_stats = {'child_count': child_list['library_count']}\n                        library_stats.update(child_stats)\n                if section_type == 'photo':\n                    parent_list = self.get_library_children_details(section_id=section_id, section_type='picture', count='1')\n                    if parent_list:\n                        parent_stats = {'parent_count': parent_list['library_count']}\n                        library_stats.update(parent_stats)\n                    child_list = self.get_library_children_details(section_id=section_id, section_type='clip', count='1')\n                    if child_list:\n                        child_stats = {'child_count': child_list['library_count']}\n                        library_stats.update(child_stats)\n                server_library_stats.append(library_stats)\n    return server_library_stats",
            "def get_library_details(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Return processed and validated library statistics.\\n\\n        Output: array\\n        '\n    server_libraries = self.get_server_children()\n    server_library_stats = []\n    if server_libraries and server_libraries['libraries_count'] != '0':\n        libraries_list = server_libraries['libraries_list']\n        for library in libraries_list:\n            section_type = library['section_type']\n            section_id = library['section_id']\n            children_list = self.get_library_children_details(section_id=section_id, section_type=section_type, count='1')\n            if children_list:\n                library_stats = {'section_id': section_id, 'section_name': library['section_name'], 'section_type': section_type, 'agent': library['agent'], 'thumb': library['thumb'], 'art': library['art'], 'count': children_list['library_count'], 'is_active': 1}\n                if section_type == 'show':\n                    parent_list = self.get_library_children_details(section_id=section_id, section_type='season', count='1')\n                    if parent_list:\n                        parent_stats = {'parent_count': parent_list['library_count']}\n                        library_stats.update(parent_stats)\n                    child_list = self.get_library_children_details(section_id=section_id, section_type='episode', count='1')\n                    if child_list:\n                        child_stats = {'child_count': child_list['library_count']}\n                        library_stats.update(child_stats)\n                if section_type == 'artist':\n                    parent_list = self.get_library_children_details(section_id=section_id, section_type='album', count='1')\n                    if parent_list:\n                        parent_stats = {'parent_count': parent_list['library_count']}\n                        library_stats.update(parent_stats)\n                    child_list = self.get_library_children_details(section_id=section_id, section_type='track', count='1')\n                    if child_list:\n                        child_stats = {'child_count': child_list['library_count']}\n                        library_stats.update(child_stats)\n                if section_type == 'photo':\n                    parent_list = self.get_library_children_details(section_id=section_id, section_type='picture', count='1')\n                    if parent_list:\n                        parent_stats = {'parent_count': parent_list['library_count']}\n                        library_stats.update(parent_stats)\n                    child_list = self.get_library_children_details(section_id=section_id, section_type='clip', count='1')\n                    if child_list:\n                        child_stats = {'child_count': child_list['library_count']}\n                        library_stats.update(child_stats)\n                server_library_stats.append(library_stats)\n    return server_library_stats",
            "def get_library_details(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Return processed and validated library statistics.\\n\\n        Output: array\\n        '\n    server_libraries = self.get_server_children()\n    server_library_stats = []\n    if server_libraries and server_libraries['libraries_count'] != '0':\n        libraries_list = server_libraries['libraries_list']\n        for library in libraries_list:\n            section_type = library['section_type']\n            section_id = library['section_id']\n            children_list = self.get_library_children_details(section_id=section_id, section_type=section_type, count='1')\n            if children_list:\n                library_stats = {'section_id': section_id, 'section_name': library['section_name'], 'section_type': section_type, 'agent': library['agent'], 'thumb': library['thumb'], 'art': library['art'], 'count': children_list['library_count'], 'is_active': 1}\n                if section_type == 'show':\n                    parent_list = self.get_library_children_details(section_id=section_id, section_type='season', count='1')\n                    if parent_list:\n                        parent_stats = {'parent_count': parent_list['library_count']}\n                        library_stats.update(parent_stats)\n                    child_list = self.get_library_children_details(section_id=section_id, section_type='episode', count='1')\n                    if child_list:\n                        child_stats = {'child_count': child_list['library_count']}\n                        library_stats.update(child_stats)\n                if section_type == 'artist':\n                    parent_list = self.get_library_children_details(section_id=section_id, section_type='album', count='1')\n                    if parent_list:\n                        parent_stats = {'parent_count': parent_list['library_count']}\n                        library_stats.update(parent_stats)\n                    child_list = self.get_library_children_details(section_id=section_id, section_type='track', count='1')\n                    if child_list:\n                        child_stats = {'child_count': child_list['library_count']}\n                        library_stats.update(child_stats)\n                if section_type == 'photo':\n                    parent_list = self.get_library_children_details(section_id=section_id, section_type='picture', count='1')\n                    if parent_list:\n                        parent_stats = {'parent_count': parent_list['library_count']}\n                        library_stats.update(parent_stats)\n                    child_list = self.get_library_children_details(section_id=section_id, section_type='clip', count='1')\n                    if child_list:\n                        child_stats = {'child_count': child_list['library_count']}\n                        library_stats.update(child_stats)\n                server_library_stats.append(library_stats)\n    return server_library_stats",
            "def get_library_details(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Return processed and validated library statistics.\\n\\n        Output: array\\n        '\n    server_libraries = self.get_server_children()\n    server_library_stats = []\n    if server_libraries and server_libraries['libraries_count'] != '0':\n        libraries_list = server_libraries['libraries_list']\n        for library in libraries_list:\n            section_type = library['section_type']\n            section_id = library['section_id']\n            children_list = self.get_library_children_details(section_id=section_id, section_type=section_type, count='1')\n            if children_list:\n                library_stats = {'section_id': section_id, 'section_name': library['section_name'], 'section_type': section_type, 'agent': library['agent'], 'thumb': library['thumb'], 'art': library['art'], 'count': children_list['library_count'], 'is_active': 1}\n                if section_type == 'show':\n                    parent_list = self.get_library_children_details(section_id=section_id, section_type='season', count='1')\n                    if parent_list:\n                        parent_stats = {'parent_count': parent_list['library_count']}\n                        library_stats.update(parent_stats)\n                    child_list = self.get_library_children_details(section_id=section_id, section_type='episode', count='1')\n                    if child_list:\n                        child_stats = {'child_count': child_list['library_count']}\n                        library_stats.update(child_stats)\n                if section_type == 'artist':\n                    parent_list = self.get_library_children_details(section_id=section_id, section_type='album', count='1')\n                    if parent_list:\n                        parent_stats = {'parent_count': parent_list['library_count']}\n                        library_stats.update(parent_stats)\n                    child_list = self.get_library_children_details(section_id=section_id, section_type='track', count='1')\n                    if child_list:\n                        child_stats = {'child_count': child_list['library_count']}\n                        library_stats.update(child_stats)\n                if section_type == 'photo':\n                    parent_list = self.get_library_children_details(section_id=section_id, section_type='picture', count='1')\n                    if parent_list:\n                        parent_stats = {'parent_count': parent_list['library_count']}\n                        library_stats.update(parent_stats)\n                    child_list = self.get_library_children_details(section_id=section_id, section_type='clip', count='1')\n                    if child_list:\n                        child_stats = {'child_count': child_list['library_count']}\n                        library_stats.update(child_stats)\n                server_library_stats.append(library_stats)\n    return server_library_stats"
        ]
    },
    {
        "func_name": "get_library_label_details",
        "original": "def get_library_label_details(self, section_id=''):\n    labels_data = self.get_library_labels(section_id=str(section_id), output_format='xml')\n    try:\n        xml_head = labels_data.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_library_label_details: %s.' % e)\n        return None\n    labels_list = []\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                logger.debug('Tautulli Pmsconnect :: No labels data.')\n                return labels_list\n        if a.getElementsByTagName('Directory'):\n            labels_main = a.getElementsByTagName('Directory')\n            for item in labels_main:\n                label = {'label_key': helpers.get_xml_attr(item, 'key'), 'label_title': helpers.get_xml_attr(item, 'title')}\n                labels_list.append(label)\n    return labels_list",
        "mutated": [
            "def get_library_label_details(self, section_id=''):\n    if False:\n        i = 10\n    labels_data = self.get_library_labels(section_id=str(section_id), output_format='xml')\n    try:\n        xml_head = labels_data.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_library_label_details: %s.' % e)\n        return None\n    labels_list = []\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                logger.debug('Tautulli Pmsconnect :: No labels data.')\n                return labels_list\n        if a.getElementsByTagName('Directory'):\n            labels_main = a.getElementsByTagName('Directory')\n            for item in labels_main:\n                label = {'label_key': helpers.get_xml_attr(item, 'key'), 'label_title': helpers.get_xml_attr(item, 'title')}\n                labels_list.append(label)\n    return labels_list",
            "def get_library_label_details(self, section_id=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    labels_data = self.get_library_labels(section_id=str(section_id), output_format='xml')\n    try:\n        xml_head = labels_data.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_library_label_details: %s.' % e)\n        return None\n    labels_list = []\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                logger.debug('Tautulli Pmsconnect :: No labels data.')\n                return labels_list\n        if a.getElementsByTagName('Directory'):\n            labels_main = a.getElementsByTagName('Directory')\n            for item in labels_main:\n                label = {'label_key': helpers.get_xml_attr(item, 'key'), 'label_title': helpers.get_xml_attr(item, 'title')}\n                labels_list.append(label)\n    return labels_list",
            "def get_library_label_details(self, section_id=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    labels_data = self.get_library_labels(section_id=str(section_id), output_format='xml')\n    try:\n        xml_head = labels_data.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_library_label_details: %s.' % e)\n        return None\n    labels_list = []\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                logger.debug('Tautulli Pmsconnect :: No labels data.')\n                return labels_list\n        if a.getElementsByTagName('Directory'):\n            labels_main = a.getElementsByTagName('Directory')\n            for item in labels_main:\n                label = {'label_key': helpers.get_xml_attr(item, 'key'), 'label_title': helpers.get_xml_attr(item, 'title')}\n                labels_list.append(label)\n    return labels_list",
            "def get_library_label_details(self, section_id=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    labels_data = self.get_library_labels(section_id=str(section_id), output_format='xml')\n    try:\n        xml_head = labels_data.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_library_label_details: %s.' % e)\n        return None\n    labels_list = []\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                logger.debug('Tautulli Pmsconnect :: No labels data.')\n                return labels_list\n        if a.getElementsByTagName('Directory'):\n            labels_main = a.getElementsByTagName('Directory')\n            for item in labels_main:\n                label = {'label_key': helpers.get_xml_attr(item, 'key'), 'label_title': helpers.get_xml_attr(item, 'title')}\n                labels_list.append(label)\n    return labels_list",
            "def get_library_label_details(self, section_id=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    labels_data = self.get_library_labels(section_id=str(section_id), output_format='xml')\n    try:\n        xml_head = labels_data.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_library_label_details: %s.' % e)\n        return None\n    labels_list = []\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                logger.debug('Tautulli Pmsconnect :: No labels data.')\n                return labels_list\n        if a.getElementsByTagName('Directory'):\n            labels_main = a.getElementsByTagName('Directory')\n            for item in labels_main:\n                label = {'label_key': helpers.get_xml_attr(item, 'key'), 'label_title': helpers.get_xml_attr(item, 'title')}\n                labels_list.append(label)\n    return labels_list"
        ]
    },
    {
        "func_name": "get_image",
        "original": "def get_image(self, img=None, width=1000, height=1500, opacity=None, background=None, blur=None, img_format='png', clip=False, refresh=False, **kwargs):\n    \"\"\"\n        Return image data as array.\n        Array contains the image content type and image binary\n\n        Parameters required:    img { Plex image location }\n        Optional parameters:    width { the image width }\n                                height { the image height }\n                                opacity { the image opacity 0-100 }\n                                background { the image background HEX }\n                                blur { the image blur 0-100 }\n        Output: array\n        \"\"\"\n    width = width or 1000\n    height = height or 1500\n    if img:\n        web_img = img.startswith('http')\n        resource_img = img.startswith('/:/resources')\n        if 'collection' in img and 'composite' in img:\n            img = img.replace('composite', 'thumb')\n        if refresh and (not web_img) and (not resource_img):\n            img_split = img.split('/')\n            if img_split[-1].isdigit():\n                img = '/'.join(img_split[:-1])\n            img = '{}/{}'.format(img.rstrip('/'), helpers.timestamp())\n        if web_img:\n            params = {'url': '%s' % img}\n        elif clip:\n            params = {'url': '%s&%s' % (img, urlencode({'X-Plex-Token': self.token}))}\n        else:\n            params = {'url': 'http://127.0.0.1:32400%s?%s' % (img, urlencode({'X-Plex-Token': self.token}))}\n        params['width'] = width\n        params['height'] = height\n        params['format'] = img_format\n        if opacity:\n            params['opacity'] = opacity\n        if background:\n            params['background'] = background\n        if blur:\n            params['blur'] = blur\n        uri = '/photo/:/transcode?%s' % urlencode(params)\n        result = self.request_handler.make_request(uri=uri, request_type='GET', return_type=True)\n        if result is None:\n            return\n        else:\n            return (result[0], result[1])\n    else:\n        logger.error('Tautulli Pmsconnect :: Image proxy queried but no input received.')",
        "mutated": [
            "def get_image(self, img=None, width=1000, height=1500, opacity=None, background=None, blur=None, img_format='png', clip=False, refresh=False, **kwargs):\n    if False:\n        i = 10\n    '\\n        Return image data as array.\\n        Array contains the image content type and image binary\\n\\n        Parameters required:    img { Plex image location }\\n        Optional parameters:    width { the image width }\\n                                height { the image height }\\n                                opacity { the image opacity 0-100 }\\n                                background { the image background HEX }\\n                                blur { the image blur 0-100 }\\n        Output: array\\n        '\n    width = width or 1000\n    height = height or 1500\n    if img:\n        web_img = img.startswith('http')\n        resource_img = img.startswith('/:/resources')\n        if 'collection' in img and 'composite' in img:\n            img = img.replace('composite', 'thumb')\n        if refresh and (not web_img) and (not resource_img):\n            img_split = img.split('/')\n            if img_split[-1].isdigit():\n                img = '/'.join(img_split[:-1])\n            img = '{}/{}'.format(img.rstrip('/'), helpers.timestamp())\n        if web_img:\n            params = {'url': '%s' % img}\n        elif clip:\n            params = {'url': '%s&%s' % (img, urlencode({'X-Plex-Token': self.token}))}\n        else:\n            params = {'url': 'http://127.0.0.1:32400%s?%s' % (img, urlencode({'X-Plex-Token': self.token}))}\n        params['width'] = width\n        params['height'] = height\n        params['format'] = img_format\n        if opacity:\n            params['opacity'] = opacity\n        if background:\n            params['background'] = background\n        if blur:\n            params['blur'] = blur\n        uri = '/photo/:/transcode?%s' % urlencode(params)\n        result = self.request_handler.make_request(uri=uri, request_type='GET', return_type=True)\n        if result is None:\n            return\n        else:\n            return (result[0], result[1])\n    else:\n        logger.error('Tautulli Pmsconnect :: Image proxy queried but no input received.')",
            "def get_image(self, img=None, width=1000, height=1500, opacity=None, background=None, blur=None, img_format='png', clip=False, refresh=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Return image data as array.\\n        Array contains the image content type and image binary\\n\\n        Parameters required:    img { Plex image location }\\n        Optional parameters:    width { the image width }\\n                                height { the image height }\\n                                opacity { the image opacity 0-100 }\\n                                background { the image background HEX }\\n                                blur { the image blur 0-100 }\\n        Output: array\\n        '\n    width = width or 1000\n    height = height or 1500\n    if img:\n        web_img = img.startswith('http')\n        resource_img = img.startswith('/:/resources')\n        if 'collection' in img and 'composite' in img:\n            img = img.replace('composite', 'thumb')\n        if refresh and (not web_img) and (not resource_img):\n            img_split = img.split('/')\n            if img_split[-1].isdigit():\n                img = '/'.join(img_split[:-1])\n            img = '{}/{}'.format(img.rstrip('/'), helpers.timestamp())\n        if web_img:\n            params = {'url': '%s' % img}\n        elif clip:\n            params = {'url': '%s&%s' % (img, urlencode({'X-Plex-Token': self.token}))}\n        else:\n            params = {'url': 'http://127.0.0.1:32400%s?%s' % (img, urlencode({'X-Plex-Token': self.token}))}\n        params['width'] = width\n        params['height'] = height\n        params['format'] = img_format\n        if opacity:\n            params['opacity'] = opacity\n        if background:\n            params['background'] = background\n        if blur:\n            params['blur'] = blur\n        uri = '/photo/:/transcode?%s' % urlencode(params)\n        result = self.request_handler.make_request(uri=uri, request_type='GET', return_type=True)\n        if result is None:\n            return\n        else:\n            return (result[0], result[1])\n    else:\n        logger.error('Tautulli Pmsconnect :: Image proxy queried but no input received.')",
            "def get_image(self, img=None, width=1000, height=1500, opacity=None, background=None, blur=None, img_format='png', clip=False, refresh=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Return image data as array.\\n        Array contains the image content type and image binary\\n\\n        Parameters required:    img { Plex image location }\\n        Optional parameters:    width { the image width }\\n                                height { the image height }\\n                                opacity { the image opacity 0-100 }\\n                                background { the image background HEX }\\n                                blur { the image blur 0-100 }\\n        Output: array\\n        '\n    width = width or 1000\n    height = height or 1500\n    if img:\n        web_img = img.startswith('http')\n        resource_img = img.startswith('/:/resources')\n        if 'collection' in img and 'composite' in img:\n            img = img.replace('composite', 'thumb')\n        if refresh and (not web_img) and (not resource_img):\n            img_split = img.split('/')\n            if img_split[-1].isdigit():\n                img = '/'.join(img_split[:-1])\n            img = '{}/{}'.format(img.rstrip('/'), helpers.timestamp())\n        if web_img:\n            params = {'url': '%s' % img}\n        elif clip:\n            params = {'url': '%s&%s' % (img, urlencode({'X-Plex-Token': self.token}))}\n        else:\n            params = {'url': 'http://127.0.0.1:32400%s?%s' % (img, urlencode({'X-Plex-Token': self.token}))}\n        params['width'] = width\n        params['height'] = height\n        params['format'] = img_format\n        if opacity:\n            params['opacity'] = opacity\n        if background:\n            params['background'] = background\n        if blur:\n            params['blur'] = blur\n        uri = '/photo/:/transcode?%s' % urlencode(params)\n        result = self.request_handler.make_request(uri=uri, request_type='GET', return_type=True)\n        if result is None:\n            return\n        else:\n            return (result[0], result[1])\n    else:\n        logger.error('Tautulli Pmsconnect :: Image proxy queried but no input received.')",
            "def get_image(self, img=None, width=1000, height=1500, opacity=None, background=None, blur=None, img_format='png', clip=False, refresh=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Return image data as array.\\n        Array contains the image content type and image binary\\n\\n        Parameters required:    img { Plex image location }\\n        Optional parameters:    width { the image width }\\n                                height { the image height }\\n                                opacity { the image opacity 0-100 }\\n                                background { the image background HEX }\\n                                blur { the image blur 0-100 }\\n        Output: array\\n        '\n    width = width or 1000\n    height = height or 1500\n    if img:\n        web_img = img.startswith('http')\n        resource_img = img.startswith('/:/resources')\n        if 'collection' in img and 'composite' in img:\n            img = img.replace('composite', 'thumb')\n        if refresh and (not web_img) and (not resource_img):\n            img_split = img.split('/')\n            if img_split[-1].isdigit():\n                img = '/'.join(img_split[:-1])\n            img = '{}/{}'.format(img.rstrip('/'), helpers.timestamp())\n        if web_img:\n            params = {'url': '%s' % img}\n        elif clip:\n            params = {'url': '%s&%s' % (img, urlencode({'X-Plex-Token': self.token}))}\n        else:\n            params = {'url': 'http://127.0.0.1:32400%s?%s' % (img, urlencode({'X-Plex-Token': self.token}))}\n        params['width'] = width\n        params['height'] = height\n        params['format'] = img_format\n        if opacity:\n            params['opacity'] = opacity\n        if background:\n            params['background'] = background\n        if blur:\n            params['blur'] = blur\n        uri = '/photo/:/transcode?%s' % urlencode(params)\n        result = self.request_handler.make_request(uri=uri, request_type='GET', return_type=True)\n        if result is None:\n            return\n        else:\n            return (result[0], result[1])\n    else:\n        logger.error('Tautulli Pmsconnect :: Image proxy queried but no input received.')",
            "def get_image(self, img=None, width=1000, height=1500, opacity=None, background=None, blur=None, img_format='png', clip=False, refresh=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Return image data as array.\\n        Array contains the image content type and image binary\\n\\n        Parameters required:    img { Plex image location }\\n        Optional parameters:    width { the image width }\\n                                height { the image height }\\n                                opacity { the image opacity 0-100 }\\n                                background { the image background HEX }\\n                                blur { the image blur 0-100 }\\n        Output: array\\n        '\n    width = width or 1000\n    height = height or 1500\n    if img:\n        web_img = img.startswith('http')\n        resource_img = img.startswith('/:/resources')\n        if 'collection' in img and 'composite' in img:\n            img = img.replace('composite', 'thumb')\n        if refresh and (not web_img) and (not resource_img):\n            img_split = img.split('/')\n            if img_split[-1].isdigit():\n                img = '/'.join(img_split[:-1])\n            img = '{}/{}'.format(img.rstrip('/'), helpers.timestamp())\n        if web_img:\n            params = {'url': '%s' % img}\n        elif clip:\n            params = {'url': '%s&%s' % (img, urlencode({'X-Plex-Token': self.token}))}\n        else:\n            params = {'url': 'http://127.0.0.1:32400%s?%s' % (img, urlencode({'X-Plex-Token': self.token}))}\n        params['width'] = width\n        params['height'] = height\n        params['format'] = img_format\n        if opacity:\n            params['opacity'] = opacity\n        if background:\n            params['background'] = background\n        if blur:\n            params['blur'] = blur\n        uri = '/photo/:/transcode?%s' % urlencode(params)\n        result = self.request_handler.make_request(uri=uri, request_type='GET', return_type=True)\n        if result is None:\n            return\n        else:\n            return (result[0], result[1])\n    else:\n        logger.error('Tautulli Pmsconnect :: Image proxy queried but no input received.')"
        ]
    },
    {
        "func_name": "get_search_results",
        "original": "def get_search_results(self, query='', limit=''):\n    \"\"\"\n        Return processed list of search results.\n\n        Output: array\n        \"\"\"\n    search_results = self.get_search(query=query, limit=limit, output_format='xml')\n    try:\n        xml_head = search_results.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_search_result: %s.' % e)\n        return []\n    search_results_list = {'movie': [], 'show': [], 'season': [], 'episode': [], 'artist': [], 'album': [], 'track': [], 'collection': []}\n    for a in xml_head:\n        hubs = a.getElementsByTagName('Hub')\n        for h in hubs:\n            if helpers.get_xml_attr(h, 'size') == '0' or helpers.get_xml_attr(h, 'type') not in search_results_list:\n                continue\n            if h.getElementsByTagName('Video'):\n                result_data = h.getElementsByTagName('Video')\n                for result in result_data:\n                    rating_key = helpers.get_xml_attr(result, 'ratingKey')\n                    metadata = self.get_metadata_details(rating_key=rating_key)\n                    search_results_list[metadata['media_type']].append(metadata)\n            if h.getElementsByTagName('Directory'):\n                result_data = h.getElementsByTagName('Directory')\n                for result in result_data:\n                    rating_key = helpers.get_xml_attr(result, 'ratingKey')\n                    metadata = self.get_metadata_details(rating_key=rating_key)\n                    search_results_list[metadata['media_type']].append(metadata)\n                    if metadata['media_type'] == 'show':\n                        show_seasons = self.get_item_children(rating_key=metadata['rating_key'])\n                        if show_seasons['children_count'] != 0:\n                            for season in show_seasons['children_list']:\n                                if season['rating_key']:\n                                    metadata = self.get_metadata_details(rating_key=season['rating_key'])\n                                    search_results_list['season'].append(metadata)\n            if h.getElementsByTagName('Track'):\n                result_data = h.getElementsByTagName('Track')\n                for result in result_data:\n                    rating_key = helpers.get_xml_attr(result, 'ratingKey')\n                    metadata = self.get_metadata_details(rating_key=rating_key)\n                    search_results_list[metadata['media_type']].append(metadata)\n    output = {'results_count': sum((len(s) for s in search_results_list.values())), 'results_list': search_results_list}\n    return output",
        "mutated": [
            "def get_search_results(self, query='', limit=''):\n    if False:\n        i = 10\n    '\\n        Return processed list of search results.\\n\\n        Output: array\\n        '\n    search_results = self.get_search(query=query, limit=limit, output_format='xml')\n    try:\n        xml_head = search_results.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_search_result: %s.' % e)\n        return []\n    search_results_list = {'movie': [], 'show': [], 'season': [], 'episode': [], 'artist': [], 'album': [], 'track': [], 'collection': []}\n    for a in xml_head:\n        hubs = a.getElementsByTagName('Hub')\n        for h in hubs:\n            if helpers.get_xml_attr(h, 'size') == '0' or helpers.get_xml_attr(h, 'type') not in search_results_list:\n                continue\n            if h.getElementsByTagName('Video'):\n                result_data = h.getElementsByTagName('Video')\n                for result in result_data:\n                    rating_key = helpers.get_xml_attr(result, 'ratingKey')\n                    metadata = self.get_metadata_details(rating_key=rating_key)\n                    search_results_list[metadata['media_type']].append(metadata)\n            if h.getElementsByTagName('Directory'):\n                result_data = h.getElementsByTagName('Directory')\n                for result in result_data:\n                    rating_key = helpers.get_xml_attr(result, 'ratingKey')\n                    metadata = self.get_metadata_details(rating_key=rating_key)\n                    search_results_list[metadata['media_type']].append(metadata)\n                    if metadata['media_type'] == 'show':\n                        show_seasons = self.get_item_children(rating_key=metadata['rating_key'])\n                        if show_seasons['children_count'] != 0:\n                            for season in show_seasons['children_list']:\n                                if season['rating_key']:\n                                    metadata = self.get_metadata_details(rating_key=season['rating_key'])\n                                    search_results_list['season'].append(metadata)\n            if h.getElementsByTagName('Track'):\n                result_data = h.getElementsByTagName('Track')\n                for result in result_data:\n                    rating_key = helpers.get_xml_attr(result, 'ratingKey')\n                    metadata = self.get_metadata_details(rating_key=rating_key)\n                    search_results_list[metadata['media_type']].append(metadata)\n    output = {'results_count': sum((len(s) for s in search_results_list.values())), 'results_list': search_results_list}\n    return output",
            "def get_search_results(self, query='', limit=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Return processed list of search results.\\n\\n        Output: array\\n        '\n    search_results = self.get_search(query=query, limit=limit, output_format='xml')\n    try:\n        xml_head = search_results.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_search_result: %s.' % e)\n        return []\n    search_results_list = {'movie': [], 'show': [], 'season': [], 'episode': [], 'artist': [], 'album': [], 'track': [], 'collection': []}\n    for a in xml_head:\n        hubs = a.getElementsByTagName('Hub')\n        for h in hubs:\n            if helpers.get_xml_attr(h, 'size') == '0' or helpers.get_xml_attr(h, 'type') not in search_results_list:\n                continue\n            if h.getElementsByTagName('Video'):\n                result_data = h.getElementsByTagName('Video')\n                for result in result_data:\n                    rating_key = helpers.get_xml_attr(result, 'ratingKey')\n                    metadata = self.get_metadata_details(rating_key=rating_key)\n                    search_results_list[metadata['media_type']].append(metadata)\n            if h.getElementsByTagName('Directory'):\n                result_data = h.getElementsByTagName('Directory')\n                for result in result_data:\n                    rating_key = helpers.get_xml_attr(result, 'ratingKey')\n                    metadata = self.get_metadata_details(rating_key=rating_key)\n                    search_results_list[metadata['media_type']].append(metadata)\n                    if metadata['media_type'] == 'show':\n                        show_seasons = self.get_item_children(rating_key=metadata['rating_key'])\n                        if show_seasons['children_count'] != 0:\n                            for season in show_seasons['children_list']:\n                                if season['rating_key']:\n                                    metadata = self.get_metadata_details(rating_key=season['rating_key'])\n                                    search_results_list['season'].append(metadata)\n            if h.getElementsByTagName('Track'):\n                result_data = h.getElementsByTagName('Track')\n                for result in result_data:\n                    rating_key = helpers.get_xml_attr(result, 'ratingKey')\n                    metadata = self.get_metadata_details(rating_key=rating_key)\n                    search_results_list[metadata['media_type']].append(metadata)\n    output = {'results_count': sum((len(s) for s in search_results_list.values())), 'results_list': search_results_list}\n    return output",
            "def get_search_results(self, query='', limit=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Return processed list of search results.\\n\\n        Output: array\\n        '\n    search_results = self.get_search(query=query, limit=limit, output_format='xml')\n    try:\n        xml_head = search_results.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_search_result: %s.' % e)\n        return []\n    search_results_list = {'movie': [], 'show': [], 'season': [], 'episode': [], 'artist': [], 'album': [], 'track': [], 'collection': []}\n    for a in xml_head:\n        hubs = a.getElementsByTagName('Hub')\n        for h in hubs:\n            if helpers.get_xml_attr(h, 'size') == '0' or helpers.get_xml_attr(h, 'type') not in search_results_list:\n                continue\n            if h.getElementsByTagName('Video'):\n                result_data = h.getElementsByTagName('Video')\n                for result in result_data:\n                    rating_key = helpers.get_xml_attr(result, 'ratingKey')\n                    metadata = self.get_metadata_details(rating_key=rating_key)\n                    search_results_list[metadata['media_type']].append(metadata)\n            if h.getElementsByTagName('Directory'):\n                result_data = h.getElementsByTagName('Directory')\n                for result in result_data:\n                    rating_key = helpers.get_xml_attr(result, 'ratingKey')\n                    metadata = self.get_metadata_details(rating_key=rating_key)\n                    search_results_list[metadata['media_type']].append(metadata)\n                    if metadata['media_type'] == 'show':\n                        show_seasons = self.get_item_children(rating_key=metadata['rating_key'])\n                        if show_seasons['children_count'] != 0:\n                            for season in show_seasons['children_list']:\n                                if season['rating_key']:\n                                    metadata = self.get_metadata_details(rating_key=season['rating_key'])\n                                    search_results_list['season'].append(metadata)\n            if h.getElementsByTagName('Track'):\n                result_data = h.getElementsByTagName('Track')\n                for result in result_data:\n                    rating_key = helpers.get_xml_attr(result, 'ratingKey')\n                    metadata = self.get_metadata_details(rating_key=rating_key)\n                    search_results_list[metadata['media_type']].append(metadata)\n    output = {'results_count': sum((len(s) for s in search_results_list.values())), 'results_list': search_results_list}\n    return output",
            "def get_search_results(self, query='', limit=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Return processed list of search results.\\n\\n        Output: array\\n        '\n    search_results = self.get_search(query=query, limit=limit, output_format='xml')\n    try:\n        xml_head = search_results.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_search_result: %s.' % e)\n        return []\n    search_results_list = {'movie': [], 'show': [], 'season': [], 'episode': [], 'artist': [], 'album': [], 'track': [], 'collection': []}\n    for a in xml_head:\n        hubs = a.getElementsByTagName('Hub')\n        for h in hubs:\n            if helpers.get_xml_attr(h, 'size') == '0' or helpers.get_xml_attr(h, 'type') not in search_results_list:\n                continue\n            if h.getElementsByTagName('Video'):\n                result_data = h.getElementsByTagName('Video')\n                for result in result_data:\n                    rating_key = helpers.get_xml_attr(result, 'ratingKey')\n                    metadata = self.get_metadata_details(rating_key=rating_key)\n                    search_results_list[metadata['media_type']].append(metadata)\n            if h.getElementsByTagName('Directory'):\n                result_data = h.getElementsByTagName('Directory')\n                for result in result_data:\n                    rating_key = helpers.get_xml_attr(result, 'ratingKey')\n                    metadata = self.get_metadata_details(rating_key=rating_key)\n                    search_results_list[metadata['media_type']].append(metadata)\n                    if metadata['media_type'] == 'show':\n                        show_seasons = self.get_item_children(rating_key=metadata['rating_key'])\n                        if show_seasons['children_count'] != 0:\n                            for season in show_seasons['children_list']:\n                                if season['rating_key']:\n                                    metadata = self.get_metadata_details(rating_key=season['rating_key'])\n                                    search_results_list['season'].append(metadata)\n            if h.getElementsByTagName('Track'):\n                result_data = h.getElementsByTagName('Track')\n                for result in result_data:\n                    rating_key = helpers.get_xml_attr(result, 'ratingKey')\n                    metadata = self.get_metadata_details(rating_key=rating_key)\n                    search_results_list[metadata['media_type']].append(metadata)\n    output = {'results_count': sum((len(s) for s in search_results_list.values())), 'results_list': search_results_list}\n    return output",
            "def get_search_results(self, query='', limit=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Return processed list of search results.\\n\\n        Output: array\\n        '\n    search_results = self.get_search(query=query, limit=limit, output_format='xml')\n    try:\n        xml_head = search_results.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_search_result: %s.' % e)\n        return []\n    search_results_list = {'movie': [], 'show': [], 'season': [], 'episode': [], 'artist': [], 'album': [], 'track': [], 'collection': []}\n    for a in xml_head:\n        hubs = a.getElementsByTagName('Hub')\n        for h in hubs:\n            if helpers.get_xml_attr(h, 'size') == '0' or helpers.get_xml_attr(h, 'type') not in search_results_list:\n                continue\n            if h.getElementsByTagName('Video'):\n                result_data = h.getElementsByTagName('Video')\n                for result in result_data:\n                    rating_key = helpers.get_xml_attr(result, 'ratingKey')\n                    metadata = self.get_metadata_details(rating_key=rating_key)\n                    search_results_list[metadata['media_type']].append(metadata)\n            if h.getElementsByTagName('Directory'):\n                result_data = h.getElementsByTagName('Directory')\n                for result in result_data:\n                    rating_key = helpers.get_xml_attr(result, 'ratingKey')\n                    metadata = self.get_metadata_details(rating_key=rating_key)\n                    search_results_list[metadata['media_type']].append(metadata)\n                    if metadata['media_type'] == 'show':\n                        show_seasons = self.get_item_children(rating_key=metadata['rating_key'])\n                        if show_seasons['children_count'] != 0:\n                            for season in show_seasons['children_list']:\n                                if season['rating_key']:\n                                    metadata = self.get_metadata_details(rating_key=season['rating_key'])\n                                    search_results_list['season'].append(metadata)\n            if h.getElementsByTagName('Track'):\n                result_data = h.getElementsByTagName('Track')\n                for result in result_data:\n                    rating_key = helpers.get_xml_attr(result, 'ratingKey')\n                    metadata = self.get_metadata_details(rating_key=rating_key)\n                    search_results_list[metadata['media_type']].append(metadata)\n    output = {'results_count': sum((len(s) for s in search_results_list.values())), 'results_list': search_results_list}\n    return output"
        ]
    },
    {
        "func_name": "get_rating_keys_list",
        "original": "def get_rating_keys_list(self, rating_key='', media_type=''):\n    \"\"\"\n        Return processed list of grandparent/parent/child rating keys.\n\n        Output: array\n        \"\"\"\n    if media_type == 'movie':\n        key_list = {0: {'rating_key': int(rating_key)}}\n        return key_list\n    if media_type == 'artist' or media_type == 'album' or media_type == 'track':\n        match_type = 'title'\n    else:\n        match_type = 'index'\n    section_id = None\n    library_name = None\n    if media_type == 'season' or media_type == 'album':\n        try:\n            metadata = self.get_metadata_details(rating_key=rating_key)\n            rating_key = metadata['parent_rating_key']\n            section_id = metadata['section_id']\n            library_name = metadata['library_name']\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to get parent_rating_key for get_rating_keys_list: %s.' % e)\n            return {}\n    elif media_type == 'episode' or media_type == 'track':\n        try:\n            metadata = self.get_metadata_details(rating_key=rating_key)\n            rating_key = metadata['grandparent_rating_key']\n            section_id = metadata['section_id']\n            library_name = metadata['library_name']\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to get grandparent_rating_key for get_rating_keys_list: %s.' % e)\n            return {}\n    elif media_type == 'artist':\n        try:\n            metadata = self.get_metadata_details(rating_key=rating_key)\n            section_id = metadata['section_id']\n            library_name = metadata['library_name']\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to get grandparent_rating_key for get_rating_keys_list: %s.' % e)\n            return {}\n    if media_type in ('artist', 'album', 'track'):\n        sort_type = '&artist.id={}&type=9'.format(rating_key)\n        xml_head = self.fetch_library_list(section_id=str(section_id), sort_type=sort_type, output_format='xml')\n    else:\n        metadata = self.get_metadata_children(str(rating_key), output_format='xml')\n        try:\n            xml_head = metadata.getElementsByTagName('MediaContainer')\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_rating_keys_list: %s.' % e)\n            return {}\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                return {}\n        title = helpers.get_xml_attr(a, 'title2')\n        if a.getElementsByTagName('Directory'):\n            parents_metadata = a.getElementsByTagName('Directory')\n        else:\n            parents_metadata = []\n        parents = {}\n        for item in parents_metadata:\n            parent_rating_key = helpers.get_xml_attr(item, 'ratingKey')\n            parent_index = helpers.get_xml_attr(item, 'index')\n            parent_title = helpers.get_xml_attr(item, 'title')\n            if parent_rating_key:\n                metadata = self.get_metadata_children(str(parent_rating_key), output_format='xml')\n                try:\n                    xml_head = metadata.getElementsByTagName('MediaContainer')\n                except Exception as e:\n                    logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_rating_keys_list: %s.' % e)\n                    return {}\n                for a in xml_head:\n                    if a.getAttribute('size'):\n                        if a.getAttribute('size') == '0':\n                            return {}\n                    if a.getElementsByTagName('Video'):\n                        children_metadata = a.getElementsByTagName('Video')\n                    elif a.getElementsByTagName('Track'):\n                        children_metadata = a.getElementsByTagName('Track')\n                    else:\n                        children_metadata = []\n                    children = {}\n                    for item in children_metadata:\n                        child_rating_key = helpers.get_xml_attr(item, 'ratingKey')\n                        child_index = helpers.get_xml_attr(item, 'index')\n                        child_title = helpers.get_xml_attr(item, 'title')\n                        if child_rating_key:\n                            key = int(child_index) if child_index else child_title\n                            children.update({key: {'rating_key': int(child_rating_key)}})\n                key = int(parent_index) if match_type == 'index' else str(parent_title).lower()\n                parents.update({key: {'rating_key': int(parent_rating_key), 'children': children}})\n    key = 0 if match_type == 'index' else str(title).lower()\n    key_list = {key: {'rating_key': int(rating_key), 'children': parents}, 'section_id': section_id, 'library_name': library_name}\n    return key_list",
        "mutated": [
            "def get_rating_keys_list(self, rating_key='', media_type=''):\n    if False:\n        i = 10\n    '\\n        Return processed list of grandparent/parent/child rating keys.\\n\\n        Output: array\\n        '\n    if media_type == 'movie':\n        key_list = {0: {'rating_key': int(rating_key)}}\n        return key_list\n    if media_type == 'artist' or media_type == 'album' or media_type == 'track':\n        match_type = 'title'\n    else:\n        match_type = 'index'\n    section_id = None\n    library_name = None\n    if media_type == 'season' or media_type == 'album':\n        try:\n            metadata = self.get_metadata_details(rating_key=rating_key)\n            rating_key = metadata['parent_rating_key']\n            section_id = metadata['section_id']\n            library_name = metadata['library_name']\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to get parent_rating_key for get_rating_keys_list: %s.' % e)\n            return {}\n    elif media_type == 'episode' or media_type == 'track':\n        try:\n            metadata = self.get_metadata_details(rating_key=rating_key)\n            rating_key = metadata['grandparent_rating_key']\n            section_id = metadata['section_id']\n            library_name = metadata['library_name']\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to get grandparent_rating_key for get_rating_keys_list: %s.' % e)\n            return {}\n    elif media_type == 'artist':\n        try:\n            metadata = self.get_metadata_details(rating_key=rating_key)\n            section_id = metadata['section_id']\n            library_name = metadata['library_name']\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to get grandparent_rating_key for get_rating_keys_list: %s.' % e)\n            return {}\n    if media_type in ('artist', 'album', 'track'):\n        sort_type = '&artist.id={}&type=9'.format(rating_key)\n        xml_head = self.fetch_library_list(section_id=str(section_id), sort_type=sort_type, output_format='xml')\n    else:\n        metadata = self.get_metadata_children(str(rating_key), output_format='xml')\n        try:\n            xml_head = metadata.getElementsByTagName('MediaContainer')\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_rating_keys_list: %s.' % e)\n            return {}\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                return {}\n        title = helpers.get_xml_attr(a, 'title2')\n        if a.getElementsByTagName('Directory'):\n            parents_metadata = a.getElementsByTagName('Directory')\n        else:\n            parents_metadata = []\n        parents = {}\n        for item in parents_metadata:\n            parent_rating_key = helpers.get_xml_attr(item, 'ratingKey')\n            parent_index = helpers.get_xml_attr(item, 'index')\n            parent_title = helpers.get_xml_attr(item, 'title')\n            if parent_rating_key:\n                metadata = self.get_metadata_children(str(parent_rating_key), output_format='xml')\n                try:\n                    xml_head = metadata.getElementsByTagName('MediaContainer')\n                except Exception as e:\n                    logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_rating_keys_list: %s.' % e)\n                    return {}\n                for a in xml_head:\n                    if a.getAttribute('size'):\n                        if a.getAttribute('size') == '0':\n                            return {}\n                    if a.getElementsByTagName('Video'):\n                        children_metadata = a.getElementsByTagName('Video')\n                    elif a.getElementsByTagName('Track'):\n                        children_metadata = a.getElementsByTagName('Track')\n                    else:\n                        children_metadata = []\n                    children = {}\n                    for item in children_metadata:\n                        child_rating_key = helpers.get_xml_attr(item, 'ratingKey')\n                        child_index = helpers.get_xml_attr(item, 'index')\n                        child_title = helpers.get_xml_attr(item, 'title')\n                        if child_rating_key:\n                            key = int(child_index) if child_index else child_title\n                            children.update({key: {'rating_key': int(child_rating_key)}})\n                key = int(parent_index) if match_type == 'index' else str(parent_title).lower()\n                parents.update({key: {'rating_key': int(parent_rating_key), 'children': children}})\n    key = 0 if match_type == 'index' else str(title).lower()\n    key_list = {key: {'rating_key': int(rating_key), 'children': parents}, 'section_id': section_id, 'library_name': library_name}\n    return key_list",
            "def get_rating_keys_list(self, rating_key='', media_type=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Return processed list of grandparent/parent/child rating keys.\\n\\n        Output: array\\n        '\n    if media_type == 'movie':\n        key_list = {0: {'rating_key': int(rating_key)}}\n        return key_list\n    if media_type == 'artist' or media_type == 'album' or media_type == 'track':\n        match_type = 'title'\n    else:\n        match_type = 'index'\n    section_id = None\n    library_name = None\n    if media_type == 'season' or media_type == 'album':\n        try:\n            metadata = self.get_metadata_details(rating_key=rating_key)\n            rating_key = metadata['parent_rating_key']\n            section_id = metadata['section_id']\n            library_name = metadata['library_name']\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to get parent_rating_key for get_rating_keys_list: %s.' % e)\n            return {}\n    elif media_type == 'episode' or media_type == 'track':\n        try:\n            metadata = self.get_metadata_details(rating_key=rating_key)\n            rating_key = metadata['grandparent_rating_key']\n            section_id = metadata['section_id']\n            library_name = metadata['library_name']\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to get grandparent_rating_key for get_rating_keys_list: %s.' % e)\n            return {}\n    elif media_type == 'artist':\n        try:\n            metadata = self.get_metadata_details(rating_key=rating_key)\n            section_id = metadata['section_id']\n            library_name = metadata['library_name']\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to get grandparent_rating_key for get_rating_keys_list: %s.' % e)\n            return {}\n    if media_type in ('artist', 'album', 'track'):\n        sort_type = '&artist.id={}&type=9'.format(rating_key)\n        xml_head = self.fetch_library_list(section_id=str(section_id), sort_type=sort_type, output_format='xml')\n    else:\n        metadata = self.get_metadata_children(str(rating_key), output_format='xml')\n        try:\n            xml_head = metadata.getElementsByTagName('MediaContainer')\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_rating_keys_list: %s.' % e)\n            return {}\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                return {}\n        title = helpers.get_xml_attr(a, 'title2')\n        if a.getElementsByTagName('Directory'):\n            parents_metadata = a.getElementsByTagName('Directory')\n        else:\n            parents_metadata = []\n        parents = {}\n        for item in parents_metadata:\n            parent_rating_key = helpers.get_xml_attr(item, 'ratingKey')\n            parent_index = helpers.get_xml_attr(item, 'index')\n            parent_title = helpers.get_xml_attr(item, 'title')\n            if parent_rating_key:\n                metadata = self.get_metadata_children(str(parent_rating_key), output_format='xml')\n                try:\n                    xml_head = metadata.getElementsByTagName('MediaContainer')\n                except Exception as e:\n                    logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_rating_keys_list: %s.' % e)\n                    return {}\n                for a in xml_head:\n                    if a.getAttribute('size'):\n                        if a.getAttribute('size') == '0':\n                            return {}\n                    if a.getElementsByTagName('Video'):\n                        children_metadata = a.getElementsByTagName('Video')\n                    elif a.getElementsByTagName('Track'):\n                        children_metadata = a.getElementsByTagName('Track')\n                    else:\n                        children_metadata = []\n                    children = {}\n                    for item in children_metadata:\n                        child_rating_key = helpers.get_xml_attr(item, 'ratingKey')\n                        child_index = helpers.get_xml_attr(item, 'index')\n                        child_title = helpers.get_xml_attr(item, 'title')\n                        if child_rating_key:\n                            key = int(child_index) if child_index else child_title\n                            children.update({key: {'rating_key': int(child_rating_key)}})\n                key = int(parent_index) if match_type == 'index' else str(parent_title).lower()\n                parents.update({key: {'rating_key': int(parent_rating_key), 'children': children}})\n    key = 0 if match_type == 'index' else str(title).lower()\n    key_list = {key: {'rating_key': int(rating_key), 'children': parents}, 'section_id': section_id, 'library_name': library_name}\n    return key_list",
            "def get_rating_keys_list(self, rating_key='', media_type=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Return processed list of grandparent/parent/child rating keys.\\n\\n        Output: array\\n        '\n    if media_type == 'movie':\n        key_list = {0: {'rating_key': int(rating_key)}}\n        return key_list\n    if media_type == 'artist' or media_type == 'album' or media_type == 'track':\n        match_type = 'title'\n    else:\n        match_type = 'index'\n    section_id = None\n    library_name = None\n    if media_type == 'season' or media_type == 'album':\n        try:\n            metadata = self.get_metadata_details(rating_key=rating_key)\n            rating_key = metadata['parent_rating_key']\n            section_id = metadata['section_id']\n            library_name = metadata['library_name']\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to get parent_rating_key for get_rating_keys_list: %s.' % e)\n            return {}\n    elif media_type == 'episode' or media_type == 'track':\n        try:\n            metadata = self.get_metadata_details(rating_key=rating_key)\n            rating_key = metadata['grandparent_rating_key']\n            section_id = metadata['section_id']\n            library_name = metadata['library_name']\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to get grandparent_rating_key for get_rating_keys_list: %s.' % e)\n            return {}\n    elif media_type == 'artist':\n        try:\n            metadata = self.get_metadata_details(rating_key=rating_key)\n            section_id = metadata['section_id']\n            library_name = metadata['library_name']\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to get grandparent_rating_key for get_rating_keys_list: %s.' % e)\n            return {}\n    if media_type in ('artist', 'album', 'track'):\n        sort_type = '&artist.id={}&type=9'.format(rating_key)\n        xml_head = self.fetch_library_list(section_id=str(section_id), sort_type=sort_type, output_format='xml')\n    else:\n        metadata = self.get_metadata_children(str(rating_key), output_format='xml')\n        try:\n            xml_head = metadata.getElementsByTagName('MediaContainer')\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_rating_keys_list: %s.' % e)\n            return {}\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                return {}\n        title = helpers.get_xml_attr(a, 'title2')\n        if a.getElementsByTagName('Directory'):\n            parents_metadata = a.getElementsByTagName('Directory')\n        else:\n            parents_metadata = []\n        parents = {}\n        for item in parents_metadata:\n            parent_rating_key = helpers.get_xml_attr(item, 'ratingKey')\n            parent_index = helpers.get_xml_attr(item, 'index')\n            parent_title = helpers.get_xml_attr(item, 'title')\n            if parent_rating_key:\n                metadata = self.get_metadata_children(str(parent_rating_key), output_format='xml')\n                try:\n                    xml_head = metadata.getElementsByTagName('MediaContainer')\n                except Exception as e:\n                    logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_rating_keys_list: %s.' % e)\n                    return {}\n                for a in xml_head:\n                    if a.getAttribute('size'):\n                        if a.getAttribute('size') == '0':\n                            return {}\n                    if a.getElementsByTagName('Video'):\n                        children_metadata = a.getElementsByTagName('Video')\n                    elif a.getElementsByTagName('Track'):\n                        children_metadata = a.getElementsByTagName('Track')\n                    else:\n                        children_metadata = []\n                    children = {}\n                    for item in children_metadata:\n                        child_rating_key = helpers.get_xml_attr(item, 'ratingKey')\n                        child_index = helpers.get_xml_attr(item, 'index')\n                        child_title = helpers.get_xml_attr(item, 'title')\n                        if child_rating_key:\n                            key = int(child_index) if child_index else child_title\n                            children.update({key: {'rating_key': int(child_rating_key)}})\n                key = int(parent_index) if match_type == 'index' else str(parent_title).lower()\n                parents.update({key: {'rating_key': int(parent_rating_key), 'children': children}})\n    key = 0 if match_type == 'index' else str(title).lower()\n    key_list = {key: {'rating_key': int(rating_key), 'children': parents}, 'section_id': section_id, 'library_name': library_name}\n    return key_list",
            "def get_rating_keys_list(self, rating_key='', media_type=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Return processed list of grandparent/parent/child rating keys.\\n\\n        Output: array\\n        '\n    if media_type == 'movie':\n        key_list = {0: {'rating_key': int(rating_key)}}\n        return key_list\n    if media_type == 'artist' or media_type == 'album' or media_type == 'track':\n        match_type = 'title'\n    else:\n        match_type = 'index'\n    section_id = None\n    library_name = None\n    if media_type == 'season' or media_type == 'album':\n        try:\n            metadata = self.get_metadata_details(rating_key=rating_key)\n            rating_key = metadata['parent_rating_key']\n            section_id = metadata['section_id']\n            library_name = metadata['library_name']\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to get parent_rating_key for get_rating_keys_list: %s.' % e)\n            return {}\n    elif media_type == 'episode' or media_type == 'track':\n        try:\n            metadata = self.get_metadata_details(rating_key=rating_key)\n            rating_key = metadata['grandparent_rating_key']\n            section_id = metadata['section_id']\n            library_name = metadata['library_name']\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to get grandparent_rating_key for get_rating_keys_list: %s.' % e)\n            return {}\n    elif media_type == 'artist':\n        try:\n            metadata = self.get_metadata_details(rating_key=rating_key)\n            section_id = metadata['section_id']\n            library_name = metadata['library_name']\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to get grandparent_rating_key for get_rating_keys_list: %s.' % e)\n            return {}\n    if media_type in ('artist', 'album', 'track'):\n        sort_type = '&artist.id={}&type=9'.format(rating_key)\n        xml_head = self.fetch_library_list(section_id=str(section_id), sort_type=sort_type, output_format='xml')\n    else:\n        metadata = self.get_metadata_children(str(rating_key), output_format='xml')\n        try:\n            xml_head = metadata.getElementsByTagName('MediaContainer')\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_rating_keys_list: %s.' % e)\n            return {}\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                return {}\n        title = helpers.get_xml_attr(a, 'title2')\n        if a.getElementsByTagName('Directory'):\n            parents_metadata = a.getElementsByTagName('Directory')\n        else:\n            parents_metadata = []\n        parents = {}\n        for item in parents_metadata:\n            parent_rating_key = helpers.get_xml_attr(item, 'ratingKey')\n            parent_index = helpers.get_xml_attr(item, 'index')\n            parent_title = helpers.get_xml_attr(item, 'title')\n            if parent_rating_key:\n                metadata = self.get_metadata_children(str(parent_rating_key), output_format='xml')\n                try:\n                    xml_head = metadata.getElementsByTagName('MediaContainer')\n                except Exception as e:\n                    logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_rating_keys_list: %s.' % e)\n                    return {}\n                for a in xml_head:\n                    if a.getAttribute('size'):\n                        if a.getAttribute('size') == '0':\n                            return {}\n                    if a.getElementsByTagName('Video'):\n                        children_metadata = a.getElementsByTagName('Video')\n                    elif a.getElementsByTagName('Track'):\n                        children_metadata = a.getElementsByTagName('Track')\n                    else:\n                        children_metadata = []\n                    children = {}\n                    for item in children_metadata:\n                        child_rating_key = helpers.get_xml_attr(item, 'ratingKey')\n                        child_index = helpers.get_xml_attr(item, 'index')\n                        child_title = helpers.get_xml_attr(item, 'title')\n                        if child_rating_key:\n                            key = int(child_index) if child_index else child_title\n                            children.update({key: {'rating_key': int(child_rating_key)}})\n                key = int(parent_index) if match_type == 'index' else str(parent_title).lower()\n                parents.update({key: {'rating_key': int(parent_rating_key), 'children': children}})\n    key = 0 if match_type == 'index' else str(title).lower()\n    key_list = {key: {'rating_key': int(rating_key), 'children': parents}, 'section_id': section_id, 'library_name': library_name}\n    return key_list",
            "def get_rating_keys_list(self, rating_key='', media_type=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Return processed list of grandparent/parent/child rating keys.\\n\\n        Output: array\\n        '\n    if media_type == 'movie':\n        key_list = {0: {'rating_key': int(rating_key)}}\n        return key_list\n    if media_type == 'artist' or media_type == 'album' or media_type == 'track':\n        match_type = 'title'\n    else:\n        match_type = 'index'\n    section_id = None\n    library_name = None\n    if media_type == 'season' or media_type == 'album':\n        try:\n            metadata = self.get_metadata_details(rating_key=rating_key)\n            rating_key = metadata['parent_rating_key']\n            section_id = metadata['section_id']\n            library_name = metadata['library_name']\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to get parent_rating_key for get_rating_keys_list: %s.' % e)\n            return {}\n    elif media_type == 'episode' or media_type == 'track':\n        try:\n            metadata = self.get_metadata_details(rating_key=rating_key)\n            rating_key = metadata['grandparent_rating_key']\n            section_id = metadata['section_id']\n            library_name = metadata['library_name']\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to get grandparent_rating_key for get_rating_keys_list: %s.' % e)\n            return {}\n    elif media_type == 'artist':\n        try:\n            metadata = self.get_metadata_details(rating_key=rating_key)\n            section_id = metadata['section_id']\n            library_name = metadata['library_name']\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to get grandparent_rating_key for get_rating_keys_list: %s.' % e)\n            return {}\n    if media_type in ('artist', 'album', 'track'):\n        sort_type = '&artist.id={}&type=9'.format(rating_key)\n        xml_head = self.fetch_library_list(section_id=str(section_id), sort_type=sort_type, output_format='xml')\n    else:\n        metadata = self.get_metadata_children(str(rating_key), output_format='xml')\n        try:\n            xml_head = metadata.getElementsByTagName('MediaContainer')\n        except Exception as e:\n            logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_rating_keys_list: %s.' % e)\n            return {}\n    for a in xml_head:\n        if a.getAttribute('size'):\n            if a.getAttribute('size') == '0':\n                return {}\n        title = helpers.get_xml_attr(a, 'title2')\n        if a.getElementsByTagName('Directory'):\n            parents_metadata = a.getElementsByTagName('Directory')\n        else:\n            parents_metadata = []\n        parents = {}\n        for item in parents_metadata:\n            parent_rating_key = helpers.get_xml_attr(item, 'ratingKey')\n            parent_index = helpers.get_xml_attr(item, 'index')\n            parent_title = helpers.get_xml_attr(item, 'title')\n            if parent_rating_key:\n                metadata = self.get_metadata_children(str(parent_rating_key), output_format='xml')\n                try:\n                    xml_head = metadata.getElementsByTagName('MediaContainer')\n                except Exception as e:\n                    logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_rating_keys_list: %s.' % e)\n                    return {}\n                for a in xml_head:\n                    if a.getAttribute('size'):\n                        if a.getAttribute('size') == '0':\n                            return {}\n                    if a.getElementsByTagName('Video'):\n                        children_metadata = a.getElementsByTagName('Video')\n                    elif a.getElementsByTagName('Track'):\n                        children_metadata = a.getElementsByTagName('Track')\n                    else:\n                        children_metadata = []\n                    children = {}\n                    for item in children_metadata:\n                        child_rating_key = helpers.get_xml_attr(item, 'ratingKey')\n                        child_index = helpers.get_xml_attr(item, 'index')\n                        child_title = helpers.get_xml_attr(item, 'title')\n                        if child_rating_key:\n                            key = int(child_index) if child_index else child_title\n                            children.update({key: {'rating_key': int(child_rating_key)}})\n                key = int(parent_index) if match_type == 'index' else str(parent_title).lower()\n                parents.update({key: {'rating_key': int(parent_rating_key), 'children': children}})\n    key = 0 if match_type == 'index' else str(title).lower()\n    key_list = {key: {'rating_key': int(rating_key), 'children': parents}, 'section_id': section_id, 'library_name': library_name}\n    return key_list"
        ]
    },
    {
        "func_name": "get_server_response",
        "original": "def get_server_response(self):\n    account_data = self.get_account(output_format='xml')\n    try:\n        xml_head = account_data.getElementsByTagName('MyPlex')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_server_response: %s.' % e)\n        return None\n    server_response = {}\n    for a in xml_head:\n        server_response = {'mapping_state': helpers.get_xml_attr(a, 'mappingState'), 'mapping_error': helpers.get_xml_attr(a, 'mappingError'), 'sign_in_state': helpers.get_xml_attr(a, 'signInState'), 'public_address': helpers.get_xml_attr(a, 'publicAddress'), 'public_port': helpers.get_xml_attr(a, 'publicPort'), 'private_address': helpers.get_xml_attr(a, 'privateAddress'), 'private_port': helpers.get_xml_attr(a, 'privatePort')}\n        if server_response['mapping_state'] == 'unknown':\n            server_response['reason'] = 'Plex remote access port mapping unknown'\n        elif server_response['mapping_state'] not in ('mapped', 'waiting'):\n            server_response['reason'] = 'Plex remote access port not mapped'\n        elif server_response['mapping_error'] == 'unreachable':\n            server_response['reason'] = 'Plex remote access port mapped, but the port is unreachable from Plex.tv'\n        elif server_response['mapping_error'] == 'publisherror':\n            server_response['reason'] = 'Plex remote access port mapped, but failed to publish the port to Plex.tv'\n        else:\n            server_response['reason'] = ''\n    return server_response",
        "mutated": [
            "def get_server_response(self):\n    if False:\n        i = 10\n    account_data = self.get_account(output_format='xml')\n    try:\n        xml_head = account_data.getElementsByTagName('MyPlex')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_server_response: %s.' % e)\n        return None\n    server_response = {}\n    for a in xml_head:\n        server_response = {'mapping_state': helpers.get_xml_attr(a, 'mappingState'), 'mapping_error': helpers.get_xml_attr(a, 'mappingError'), 'sign_in_state': helpers.get_xml_attr(a, 'signInState'), 'public_address': helpers.get_xml_attr(a, 'publicAddress'), 'public_port': helpers.get_xml_attr(a, 'publicPort'), 'private_address': helpers.get_xml_attr(a, 'privateAddress'), 'private_port': helpers.get_xml_attr(a, 'privatePort')}\n        if server_response['mapping_state'] == 'unknown':\n            server_response['reason'] = 'Plex remote access port mapping unknown'\n        elif server_response['mapping_state'] not in ('mapped', 'waiting'):\n            server_response['reason'] = 'Plex remote access port not mapped'\n        elif server_response['mapping_error'] == 'unreachable':\n            server_response['reason'] = 'Plex remote access port mapped, but the port is unreachable from Plex.tv'\n        elif server_response['mapping_error'] == 'publisherror':\n            server_response['reason'] = 'Plex remote access port mapped, but failed to publish the port to Plex.tv'\n        else:\n            server_response['reason'] = ''\n    return server_response",
            "def get_server_response(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    account_data = self.get_account(output_format='xml')\n    try:\n        xml_head = account_data.getElementsByTagName('MyPlex')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_server_response: %s.' % e)\n        return None\n    server_response = {}\n    for a in xml_head:\n        server_response = {'mapping_state': helpers.get_xml_attr(a, 'mappingState'), 'mapping_error': helpers.get_xml_attr(a, 'mappingError'), 'sign_in_state': helpers.get_xml_attr(a, 'signInState'), 'public_address': helpers.get_xml_attr(a, 'publicAddress'), 'public_port': helpers.get_xml_attr(a, 'publicPort'), 'private_address': helpers.get_xml_attr(a, 'privateAddress'), 'private_port': helpers.get_xml_attr(a, 'privatePort')}\n        if server_response['mapping_state'] == 'unknown':\n            server_response['reason'] = 'Plex remote access port mapping unknown'\n        elif server_response['mapping_state'] not in ('mapped', 'waiting'):\n            server_response['reason'] = 'Plex remote access port not mapped'\n        elif server_response['mapping_error'] == 'unreachable':\n            server_response['reason'] = 'Plex remote access port mapped, but the port is unreachable from Plex.tv'\n        elif server_response['mapping_error'] == 'publisherror':\n            server_response['reason'] = 'Plex remote access port mapped, but failed to publish the port to Plex.tv'\n        else:\n            server_response['reason'] = ''\n    return server_response",
            "def get_server_response(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    account_data = self.get_account(output_format='xml')\n    try:\n        xml_head = account_data.getElementsByTagName('MyPlex')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_server_response: %s.' % e)\n        return None\n    server_response = {}\n    for a in xml_head:\n        server_response = {'mapping_state': helpers.get_xml_attr(a, 'mappingState'), 'mapping_error': helpers.get_xml_attr(a, 'mappingError'), 'sign_in_state': helpers.get_xml_attr(a, 'signInState'), 'public_address': helpers.get_xml_attr(a, 'publicAddress'), 'public_port': helpers.get_xml_attr(a, 'publicPort'), 'private_address': helpers.get_xml_attr(a, 'privateAddress'), 'private_port': helpers.get_xml_attr(a, 'privatePort')}\n        if server_response['mapping_state'] == 'unknown':\n            server_response['reason'] = 'Plex remote access port mapping unknown'\n        elif server_response['mapping_state'] not in ('mapped', 'waiting'):\n            server_response['reason'] = 'Plex remote access port not mapped'\n        elif server_response['mapping_error'] == 'unreachable':\n            server_response['reason'] = 'Plex remote access port mapped, but the port is unreachable from Plex.tv'\n        elif server_response['mapping_error'] == 'publisherror':\n            server_response['reason'] = 'Plex remote access port mapped, but failed to publish the port to Plex.tv'\n        else:\n            server_response['reason'] = ''\n    return server_response",
            "def get_server_response(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    account_data = self.get_account(output_format='xml')\n    try:\n        xml_head = account_data.getElementsByTagName('MyPlex')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_server_response: %s.' % e)\n        return None\n    server_response = {}\n    for a in xml_head:\n        server_response = {'mapping_state': helpers.get_xml_attr(a, 'mappingState'), 'mapping_error': helpers.get_xml_attr(a, 'mappingError'), 'sign_in_state': helpers.get_xml_attr(a, 'signInState'), 'public_address': helpers.get_xml_attr(a, 'publicAddress'), 'public_port': helpers.get_xml_attr(a, 'publicPort'), 'private_address': helpers.get_xml_attr(a, 'privateAddress'), 'private_port': helpers.get_xml_attr(a, 'privatePort')}\n        if server_response['mapping_state'] == 'unknown':\n            server_response['reason'] = 'Plex remote access port mapping unknown'\n        elif server_response['mapping_state'] not in ('mapped', 'waiting'):\n            server_response['reason'] = 'Plex remote access port not mapped'\n        elif server_response['mapping_error'] == 'unreachable':\n            server_response['reason'] = 'Plex remote access port mapped, but the port is unreachable from Plex.tv'\n        elif server_response['mapping_error'] == 'publisherror':\n            server_response['reason'] = 'Plex remote access port mapped, but failed to publish the port to Plex.tv'\n        else:\n            server_response['reason'] = ''\n    return server_response",
            "def get_server_response(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    account_data = self.get_account(output_format='xml')\n    try:\n        xml_head = account_data.getElementsByTagName('MyPlex')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_server_response: %s.' % e)\n        return None\n    server_response = {}\n    for a in xml_head:\n        server_response = {'mapping_state': helpers.get_xml_attr(a, 'mappingState'), 'mapping_error': helpers.get_xml_attr(a, 'mappingError'), 'sign_in_state': helpers.get_xml_attr(a, 'signInState'), 'public_address': helpers.get_xml_attr(a, 'publicAddress'), 'public_port': helpers.get_xml_attr(a, 'publicPort'), 'private_address': helpers.get_xml_attr(a, 'privateAddress'), 'private_port': helpers.get_xml_attr(a, 'privatePort')}\n        if server_response['mapping_state'] == 'unknown':\n            server_response['reason'] = 'Plex remote access port mapping unknown'\n        elif server_response['mapping_state'] not in ('mapped', 'waiting'):\n            server_response['reason'] = 'Plex remote access port not mapped'\n        elif server_response['mapping_error'] == 'unreachable':\n            server_response['reason'] = 'Plex remote access port mapped, but the port is unreachable from Plex.tv'\n        elif server_response['mapping_error'] == 'publisherror':\n            server_response['reason'] = 'Plex remote access port mapped, but failed to publish the port to Plex.tv'\n        else:\n            server_response['reason'] = ''\n    return server_response"
        ]
    },
    {
        "func_name": "get_update_staus",
        "original": "def get_update_staus(self):\n    self.put_updater()\n    updater_status = self.get_updater(output_format='xml')\n    try:\n        xml_head = updater_status.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_update_staus: %s.' % e)\n        if updater_status == []:\n            logger.warn('Plex API updater XML is broken on the current PMS version. Please update your PMS manually.')\n            logger.info('Tautulli is unable to check for Plex updates. Disabling check for Plex updates.')\n            plexpy.CONFIG.MONITOR_PMS_UPDATES = 0\n            plexpy.initialize_scheduler()\n            plexpy.CONFIG.write()\n        return {}\n    updater_info = {}\n    for a in xml_head:\n        if a.getElementsByTagName('Release'):\n            release = a.getElementsByTagName('Release')\n            for item in release:\n                updater_info = {'can_install': helpers.get_xml_attr(a, 'canInstall'), 'download_url': helpers.get_xml_attr(a, 'downloadURL'), 'version': helpers.get_xml_attr(item, 'version'), 'state': helpers.get_xml_attr(item, 'state'), 'changelog': helpers.get_xml_attr(item, 'fixed')}\n    return updater_info",
        "mutated": [
            "def get_update_staus(self):\n    if False:\n        i = 10\n    self.put_updater()\n    updater_status = self.get_updater(output_format='xml')\n    try:\n        xml_head = updater_status.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_update_staus: %s.' % e)\n        if updater_status == []:\n            logger.warn('Plex API updater XML is broken on the current PMS version. Please update your PMS manually.')\n            logger.info('Tautulli is unable to check for Plex updates. Disabling check for Plex updates.')\n            plexpy.CONFIG.MONITOR_PMS_UPDATES = 0\n            plexpy.initialize_scheduler()\n            plexpy.CONFIG.write()\n        return {}\n    updater_info = {}\n    for a in xml_head:\n        if a.getElementsByTagName('Release'):\n            release = a.getElementsByTagName('Release')\n            for item in release:\n                updater_info = {'can_install': helpers.get_xml_attr(a, 'canInstall'), 'download_url': helpers.get_xml_attr(a, 'downloadURL'), 'version': helpers.get_xml_attr(item, 'version'), 'state': helpers.get_xml_attr(item, 'state'), 'changelog': helpers.get_xml_attr(item, 'fixed')}\n    return updater_info",
            "def get_update_staus(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.put_updater()\n    updater_status = self.get_updater(output_format='xml')\n    try:\n        xml_head = updater_status.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_update_staus: %s.' % e)\n        if updater_status == []:\n            logger.warn('Plex API updater XML is broken on the current PMS version. Please update your PMS manually.')\n            logger.info('Tautulli is unable to check for Plex updates. Disabling check for Plex updates.')\n            plexpy.CONFIG.MONITOR_PMS_UPDATES = 0\n            plexpy.initialize_scheduler()\n            plexpy.CONFIG.write()\n        return {}\n    updater_info = {}\n    for a in xml_head:\n        if a.getElementsByTagName('Release'):\n            release = a.getElementsByTagName('Release')\n            for item in release:\n                updater_info = {'can_install': helpers.get_xml_attr(a, 'canInstall'), 'download_url': helpers.get_xml_attr(a, 'downloadURL'), 'version': helpers.get_xml_attr(item, 'version'), 'state': helpers.get_xml_attr(item, 'state'), 'changelog': helpers.get_xml_attr(item, 'fixed')}\n    return updater_info",
            "def get_update_staus(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.put_updater()\n    updater_status = self.get_updater(output_format='xml')\n    try:\n        xml_head = updater_status.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_update_staus: %s.' % e)\n        if updater_status == []:\n            logger.warn('Plex API updater XML is broken on the current PMS version. Please update your PMS manually.')\n            logger.info('Tautulli is unable to check for Plex updates. Disabling check for Plex updates.')\n            plexpy.CONFIG.MONITOR_PMS_UPDATES = 0\n            plexpy.initialize_scheduler()\n            plexpy.CONFIG.write()\n        return {}\n    updater_info = {}\n    for a in xml_head:\n        if a.getElementsByTagName('Release'):\n            release = a.getElementsByTagName('Release')\n            for item in release:\n                updater_info = {'can_install': helpers.get_xml_attr(a, 'canInstall'), 'download_url': helpers.get_xml_attr(a, 'downloadURL'), 'version': helpers.get_xml_attr(item, 'version'), 'state': helpers.get_xml_attr(item, 'state'), 'changelog': helpers.get_xml_attr(item, 'fixed')}\n    return updater_info",
            "def get_update_staus(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.put_updater()\n    updater_status = self.get_updater(output_format='xml')\n    try:\n        xml_head = updater_status.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_update_staus: %s.' % e)\n        if updater_status == []:\n            logger.warn('Plex API updater XML is broken on the current PMS version. Please update your PMS manually.')\n            logger.info('Tautulli is unable to check for Plex updates. Disabling check for Plex updates.')\n            plexpy.CONFIG.MONITOR_PMS_UPDATES = 0\n            plexpy.initialize_scheduler()\n            plexpy.CONFIG.write()\n        return {}\n    updater_info = {}\n    for a in xml_head:\n        if a.getElementsByTagName('Release'):\n            release = a.getElementsByTagName('Release')\n            for item in release:\n                updater_info = {'can_install': helpers.get_xml_attr(a, 'canInstall'), 'download_url': helpers.get_xml_attr(a, 'downloadURL'), 'version': helpers.get_xml_attr(item, 'version'), 'state': helpers.get_xml_attr(item, 'state'), 'changelog': helpers.get_xml_attr(item, 'fixed')}\n    return updater_info",
            "def get_update_staus(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.put_updater()\n    updater_status = self.get_updater(output_format='xml')\n    try:\n        xml_head = updater_status.getElementsByTagName('MediaContainer')\n    except Exception as e:\n        logger.warn('Tautulli Pmsconnect :: Unable to parse XML for get_update_staus: %s.' % e)\n        if updater_status == []:\n            logger.warn('Plex API updater XML is broken on the current PMS version. Please update your PMS manually.')\n            logger.info('Tautulli is unable to check for Plex updates. Disabling check for Plex updates.')\n            plexpy.CONFIG.MONITOR_PMS_UPDATES = 0\n            plexpy.initialize_scheduler()\n            plexpy.CONFIG.write()\n        return {}\n    updater_info = {}\n    for a in xml_head:\n        if a.getElementsByTagName('Release'):\n            release = a.getElementsByTagName('Release')\n            for item in release:\n                updater_info = {'can_install': helpers.get_xml_attr(a, 'canInstall'), 'download_url': helpers.get_xml_attr(a, 'downloadURL'), 'version': helpers.get_xml_attr(item, 'version'), 'state': helpers.get_xml_attr(item, 'state'), 'changelog': helpers.get_xml_attr(item, 'fixed')}\n    return updater_info"
        ]
    },
    {
        "func_name": "set_server_version",
        "original": "def set_server_version(self):\n    identity = self.get_server_identity()\n    version = identity.get('version', plexpy.CONFIG.PMS_VERSION)\n    plexpy.CONFIG.__setattr__('PMS_VERSION', version)\n    plexpy.CONFIG.write()",
        "mutated": [
            "def set_server_version(self):\n    if False:\n        i = 10\n    identity = self.get_server_identity()\n    version = identity.get('version', plexpy.CONFIG.PMS_VERSION)\n    plexpy.CONFIG.__setattr__('PMS_VERSION', version)\n    plexpy.CONFIG.write()",
            "def set_server_version(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    identity = self.get_server_identity()\n    version = identity.get('version', plexpy.CONFIG.PMS_VERSION)\n    plexpy.CONFIG.__setattr__('PMS_VERSION', version)\n    plexpy.CONFIG.write()",
            "def set_server_version(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    identity = self.get_server_identity()\n    version = identity.get('version', plexpy.CONFIG.PMS_VERSION)\n    plexpy.CONFIG.__setattr__('PMS_VERSION', version)\n    plexpy.CONFIG.write()",
            "def set_server_version(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    identity = self.get_server_identity()\n    version = identity.get('version', plexpy.CONFIG.PMS_VERSION)\n    plexpy.CONFIG.__setattr__('PMS_VERSION', version)\n    plexpy.CONFIG.write()",
            "def set_server_version(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    identity = self.get_server_identity()\n    version = identity.get('version', plexpy.CONFIG.PMS_VERSION)\n    plexpy.CONFIG.__setattr__('PMS_VERSION', version)\n    plexpy.CONFIG.write()"
        ]
    },
    {
        "func_name": "get_server_update_channel",
        "original": "def get_server_update_channel(self):\n    if plexpy.CONFIG.PMS_UPDATE_CHANNEL == 'plex':\n        update_channel_value = self.get_server_pref('ButlerUpdateChannel')\n        if update_channel_value == '8':\n            return 'beta'\n        else:\n            return 'public'\n    return plexpy.CONFIG.PMS_UPDATE_CHANNEL",
        "mutated": [
            "def get_server_update_channel(self):\n    if False:\n        i = 10\n    if plexpy.CONFIG.PMS_UPDATE_CHANNEL == 'plex':\n        update_channel_value = self.get_server_pref('ButlerUpdateChannel')\n        if update_channel_value == '8':\n            return 'beta'\n        else:\n            return 'public'\n    return plexpy.CONFIG.PMS_UPDATE_CHANNEL",
            "def get_server_update_channel(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if plexpy.CONFIG.PMS_UPDATE_CHANNEL == 'plex':\n        update_channel_value = self.get_server_pref('ButlerUpdateChannel')\n        if update_channel_value == '8':\n            return 'beta'\n        else:\n            return 'public'\n    return plexpy.CONFIG.PMS_UPDATE_CHANNEL",
            "def get_server_update_channel(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if plexpy.CONFIG.PMS_UPDATE_CHANNEL == 'plex':\n        update_channel_value = self.get_server_pref('ButlerUpdateChannel')\n        if update_channel_value == '8':\n            return 'beta'\n        else:\n            return 'public'\n    return plexpy.CONFIG.PMS_UPDATE_CHANNEL",
            "def get_server_update_channel(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if plexpy.CONFIG.PMS_UPDATE_CHANNEL == 'plex':\n        update_channel_value = self.get_server_pref('ButlerUpdateChannel')\n        if update_channel_value == '8':\n            return 'beta'\n        else:\n            return 'public'\n    return plexpy.CONFIG.PMS_UPDATE_CHANNEL",
            "def get_server_update_channel(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if plexpy.CONFIG.PMS_UPDATE_CHANNEL == 'plex':\n        update_channel_value = self.get_server_pref('ButlerUpdateChannel')\n        if update_channel_value == '8':\n            return 'beta'\n        else:\n            return 'public'\n    return plexpy.CONFIG.PMS_UPDATE_CHANNEL"
        ]
    },
    {
        "func_name": "get_dynamic_range",
        "original": "@staticmethod\ndef get_dynamic_range(stream):\n    extended_display_title = helpers.get_xml_attr(stream, 'extendedDisplayTitle')\n    bit_depth = helpers.cast_to_int(helpers.get_xml_attr(stream, 'bitDepth'))\n    color_space = helpers.get_xml_attr(stream, 'colorSpace')\n    DOVI_profile = helpers.get_xml_attr(stream, 'DOVIProfile')\n    HDR = bool(bit_depth > 8 and 'bt2020' in color_space)\n    DV = bool(DOVI_profile)\n    if not HDR and (not DV):\n        return 'SDR'\n    video_dynamic_range = []\n    if helpers.version_to_tuple(plexpy.CONFIG.PMS_VERSION) >= helpers.version_to_tuple('1.25.6.5545'):\n        if 'Dolby Vision' in extended_display_title or 'DoVi' in extended_display_title:\n            video_dynamic_range.append('Dolby Vision')\n        if 'HLG' in extended_display_title:\n            video_dynamic_range.append('HLG')\n        if 'HDR10' in extended_display_title:\n            video_dynamic_range.append('HDR10')\n        elif 'HDR' in extended_display_title:\n            video_dynamic_range.append('HDR')\n    elif DV:\n        video_dynamic_range.append('Dolby Vision')\n    elif HDR:\n        video_dynamic_range.append('HDR')\n    if not video_dynamic_range:\n        return 'SDR'\n    return '/'.join(video_dynamic_range)",
        "mutated": [
            "@staticmethod\ndef get_dynamic_range(stream):\n    if False:\n        i = 10\n    extended_display_title = helpers.get_xml_attr(stream, 'extendedDisplayTitle')\n    bit_depth = helpers.cast_to_int(helpers.get_xml_attr(stream, 'bitDepth'))\n    color_space = helpers.get_xml_attr(stream, 'colorSpace')\n    DOVI_profile = helpers.get_xml_attr(stream, 'DOVIProfile')\n    HDR = bool(bit_depth > 8 and 'bt2020' in color_space)\n    DV = bool(DOVI_profile)\n    if not HDR and (not DV):\n        return 'SDR'\n    video_dynamic_range = []\n    if helpers.version_to_tuple(plexpy.CONFIG.PMS_VERSION) >= helpers.version_to_tuple('1.25.6.5545'):\n        if 'Dolby Vision' in extended_display_title or 'DoVi' in extended_display_title:\n            video_dynamic_range.append('Dolby Vision')\n        if 'HLG' in extended_display_title:\n            video_dynamic_range.append('HLG')\n        if 'HDR10' in extended_display_title:\n            video_dynamic_range.append('HDR10')\n        elif 'HDR' in extended_display_title:\n            video_dynamic_range.append('HDR')\n    elif DV:\n        video_dynamic_range.append('Dolby Vision')\n    elif HDR:\n        video_dynamic_range.append('HDR')\n    if not video_dynamic_range:\n        return 'SDR'\n    return '/'.join(video_dynamic_range)",
            "@staticmethod\ndef get_dynamic_range(stream):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    extended_display_title = helpers.get_xml_attr(stream, 'extendedDisplayTitle')\n    bit_depth = helpers.cast_to_int(helpers.get_xml_attr(stream, 'bitDepth'))\n    color_space = helpers.get_xml_attr(stream, 'colorSpace')\n    DOVI_profile = helpers.get_xml_attr(stream, 'DOVIProfile')\n    HDR = bool(bit_depth > 8 and 'bt2020' in color_space)\n    DV = bool(DOVI_profile)\n    if not HDR and (not DV):\n        return 'SDR'\n    video_dynamic_range = []\n    if helpers.version_to_tuple(plexpy.CONFIG.PMS_VERSION) >= helpers.version_to_tuple('1.25.6.5545'):\n        if 'Dolby Vision' in extended_display_title or 'DoVi' in extended_display_title:\n            video_dynamic_range.append('Dolby Vision')\n        if 'HLG' in extended_display_title:\n            video_dynamic_range.append('HLG')\n        if 'HDR10' in extended_display_title:\n            video_dynamic_range.append('HDR10')\n        elif 'HDR' in extended_display_title:\n            video_dynamic_range.append('HDR')\n    elif DV:\n        video_dynamic_range.append('Dolby Vision')\n    elif HDR:\n        video_dynamic_range.append('HDR')\n    if not video_dynamic_range:\n        return 'SDR'\n    return '/'.join(video_dynamic_range)",
            "@staticmethod\ndef get_dynamic_range(stream):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    extended_display_title = helpers.get_xml_attr(stream, 'extendedDisplayTitle')\n    bit_depth = helpers.cast_to_int(helpers.get_xml_attr(stream, 'bitDepth'))\n    color_space = helpers.get_xml_attr(stream, 'colorSpace')\n    DOVI_profile = helpers.get_xml_attr(stream, 'DOVIProfile')\n    HDR = bool(bit_depth > 8 and 'bt2020' in color_space)\n    DV = bool(DOVI_profile)\n    if not HDR and (not DV):\n        return 'SDR'\n    video_dynamic_range = []\n    if helpers.version_to_tuple(plexpy.CONFIG.PMS_VERSION) >= helpers.version_to_tuple('1.25.6.5545'):\n        if 'Dolby Vision' in extended_display_title or 'DoVi' in extended_display_title:\n            video_dynamic_range.append('Dolby Vision')\n        if 'HLG' in extended_display_title:\n            video_dynamic_range.append('HLG')\n        if 'HDR10' in extended_display_title:\n            video_dynamic_range.append('HDR10')\n        elif 'HDR' in extended_display_title:\n            video_dynamic_range.append('HDR')\n    elif DV:\n        video_dynamic_range.append('Dolby Vision')\n    elif HDR:\n        video_dynamic_range.append('HDR')\n    if not video_dynamic_range:\n        return 'SDR'\n    return '/'.join(video_dynamic_range)",
            "@staticmethod\ndef get_dynamic_range(stream):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    extended_display_title = helpers.get_xml_attr(stream, 'extendedDisplayTitle')\n    bit_depth = helpers.cast_to_int(helpers.get_xml_attr(stream, 'bitDepth'))\n    color_space = helpers.get_xml_attr(stream, 'colorSpace')\n    DOVI_profile = helpers.get_xml_attr(stream, 'DOVIProfile')\n    HDR = bool(bit_depth > 8 and 'bt2020' in color_space)\n    DV = bool(DOVI_profile)\n    if not HDR and (not DV):\n        return 'SDR'\n    video_dynamic_range = []\n    if helpers.version_to_tuple(plexpy.CONFIG.PMS_VERSION) >= helpers.version_to_tuple('1.25.6.5545'):\n        if 'Dolby Vision' in extended_display_title or 'DoVi' in extended_display_title:\n            video_dynamic_range.append('Dolby Vision')\n        if 'HLG' in extended_display_title:\n            video_dynamic_range.append('HLG')\n        if 'HDR10' in extended_display_title:\n            video_dynamic_range.append('HDR10')\n        elif 'HDR' in extended_display_title:\n            video_dynamic_range.append('HDR')\n    elif DV:\n        video_dynamic_range.append('Dolby Vision')\n    elif HDR:\n        video_dynamic_range.append('HDR')\n    if not video_dynamic_range:\n        return 'SDR'\n    return '/'.join(video_dynamic_range)",
            "@staticmethod\ndef get_dynamic_range(stream):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    extended_display_title = helpers.get_xml_attr(stream, 'extendedDisplayTitle')\n    bit_depth = helpers.cast_to_int(helpers.get_xml_attr(stream, 'bitDepth'))\n    color_space = helpers.get_xml_attr(stream, 'colorSpace')\n    DOVI_profile = helpers.get_xml_attr(stream, 'DOVIProfile')\n    HDR = bool(bit_depth > 8 and 'bt2020' in color_space)\n    DV = bool(DOVI_profile)\n    if not HDR and (not DV):\n        return 'SDR'\n    video_dynamic_range = []\n    if helpers.version_to_tuple(plexpy.CONFIG.PMS_VERSION) >= helpers.version_to_tuple('1.25.6.5545'):\n        if 'Dolby Vision' in extended_display_title or 'DoVi' in extended_display_title:\n            video_dynamic_range.append('Dolby Vision')\n        if 'HLG' in extended_display_title:\n            video_dynamic_range.append('HLG')\n        if 'HDR10' in extended_display_title:\n            video_dynamic_range.append('HDR10')\n        elif 'HDR' in extended_display_title:\n            video_dynamic_range.append('HDR')\n    elif DV:\n        video_dynamic_range.append('Dolby Vision')\n    elif HDR:\n        video_dynamic_range.append('HDR')\n    if not video_dynamic_range:\n        return 'SDR'\n    return '/'.join(video_dynamic_range)"
        ]
    }
]