[
    {
        "func_name": "metric_accessors",
        "original": "def metric_accessors():\n    cars = h2o.import_file(path=pyunit_utils.locate('smalldata/junit/cars_20mpg.csv'))\n    r = cars[0].runif()\n    train = cars[r > 0.2]\n    valid = cars[r <= 0.2]\n    response_col = 'economy'\n    distribution = 'gaussian'\n    predictors = ['displacement', 'power', 'weight', 'acceleration', 'year']\n    gbm = H2OGradientBoostingEstimator(nfolds=3, distribution=distribution, fold_assignment='Random')\n    gbm.train(x=predictors, y=response_col, training_frame=train, validation_frame=valid)\n    for metric in ['r2', 'mse', 'rmse', 'rmsle', 'mae']:\n        val = getattr(gbm, metric)()\n        assert isinstance(val, float), 'expected a float for metric {} but got {}'.format(metric, val)\n    mse1 = gbm.mse(train=True, valid=False, xval=False)\n    assert isinstance(mse1, float)\n    mse2 = gbm.mse(train=False, valid=True, xval=False)\n    assert isinstance(mse2, float)\n    mse3 = gbm.mse(train=False, valid=False, xval=True)\n    assert isinstance(mse3, float)\n    mse = gbm.mse(train=True, valid=True, xval=False)\n    assert 'train' in list(mse.keys()) and 'valid' in list(mse.keys()), 'expected training and validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert len(mse) == 2, 'expected only training and validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert isinstance(mse['train'], float) and isinstance(mse['valid'], float), 'expected training and validation metrics to be floats, but got {0} and {1}'.format(type(mse['train']), type(mse['valid']))\n    assert mse['valid'] == mse2\n    mse = gbm.mse(train=True, valid=False, xval=True)\n    assert 'train' in list(mse.keys()) and 'xval' in list(mse.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert len(mse) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert isinstance(mse['train'], float) and isinstance(mse['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(mse['train']), type(mse['xval']))\n    assert mse['xval'] == mse3\n    mse = gbm.mse(train=True, valid=True, xval=True)\n    assert 'train' in list(mse.keys()) and 'valid' in list(mse.keys()) and ('xval' in list(mse.keys())), 'expected training, validation, and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert len(mse) == 3, 'expected training, validation and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert isinstance(mse['train'], float) and isinstance(mse['valid'], float) and isinstance(mse['xval'], float), 'expected training, validation, and cross validation metrics to be floats, but got {0}, {1}, and {2}'.format(type(mse['train']), type(mse['valid']), type(mse['xval']))\n    mse = gbm.mse(train=False, valid=False, xval=False)\n    assert isinstance(mse, float)\n    assert mse == mse1\n    mse = gbm.mse(train=False, valid=True, xval=True)\n    assert 'valid' in list(mse.keys()) and 'xval' in list(mse.keys()), 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert len(mse) == 2, 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert isinstance(mse['valid'], float) and isinstance(mse['xval'], float), 'validation and cross validation metrics to be floats, but got {0} and {1}'.format(type(mse['valid']), type(mse['xval']))\n    mean_residual_deviance1 = gbm.mean_residual_deviance(train=True, valid=False, xval=False)\n    assert isinstance(mean_residual_deviance1, float)\n    mean_residual_deviance2 = gbm.mean_residual_deviance(train=False, valid=True, xval=False)\n    assert isinstance(mean_residual_deviance2, float)\n    mean_residual_deviance3 = gbm.mean_residual_deviance(train=False, valid=False, xval=True)\n    assert isinstance(mean_residual_deviance3, float)\n    mean_residual_deviance = gbm.mean_residual_deviance(train=True, valid=True, xval=False)\n    assert 'train' in list(mean_residual_deviance.keys()) and 'valid' in list(mean_residual_deviance.keys()), 'expected training and validation metrics to be returned, but got {0}'.format(list(mean_residual_deviance.keys()))\n    assert len(mean_residual_deviance) == 2, 'expected only training and validation metrics to be returned, but got {0}'.format(list(mean_residual_deviance.keys()))\n    assert isinstance(mean_residual_deviance['train'], float) and isinstance(mean_residual_deviance['valid'], float), 'expected training and validation metrics to be floats, but got {0} and {1}'.format(type(mean_residual_deviance['train']), type(mean_residual_deviance['valid']))\n    assert mean_residual_deviance['valid'] == mean_residual_deviance2\n    mean_residual_deviance = gbm.mean_residual_deviance(train=True, valid=False, xval=True)\n    assert 'train' in list(mean_residual_deviance.keys()) and 'xval' in list(mean_residual_deviance.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(mean_residual_deviance.keys()))\n    assert len(mean_residual_deviance) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(mean_residual_deviance.keys()))\n    assert isinstance(mean_residual_deviance['train'], float) and isinstance(mean_residual_deviance['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(mean_residual_deviance['train']), type(mean_residual_deviance['xval']))\n    assert mean_residual_deviance['xval'] == mean_residual_deviance3\n    mean_residual_deviance = gbm.mean_residual_deviance(train=True, valid=True, xval=True)\n    assert 'train' in list(mean_residual_deviance.keys()) and 'valid' in list(mean_residual_deviance.keys()) and ('xval' in list(mean_residual_deviance.keys())), 'expected training, validation, and cross validation metrics to be returned, but got {0}'.format(list(mean_residual_deviance.keys()))\n    assert len(mean_residual_deviance) == 3, 'expected training, validation and cross validation metrics to be returned, but got {0}'.format(list(mean_residual_deviance.keys()))\n    assert isinstance(mean_residual_deviance['train'], float) and isinstance(mean_residual_deviance['valid'], float) and isinstance(mean_residual_deviance['xval'], float), 'expected training, validation, and cross validation metrics to be floats, but got {0}, {1}, and {2}'.format(type(mean_residual_deviance['train']), type(mean_residual_deviance['valid']), type(mean_residual_deviance['xval']))\n    mean_residual_deviance = gbm.mean_residual_deviance(train=False, valid=False, xval=False)\n    assert isinstance(mean_residual_deviance, float)\n    assert mean_residual_deviance == mean_residual_deviance1\n    mean_residual_deviance = gbm.mean_residual_deviance(train=False, valid=True, xval=True)\n    assert 'valid' in list(mean_residual_deviance.keys()) and 'xval' in list(mean_residual_deviance.keys()), 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(mean_residual_deviance.keys()))\n    assert len(mean_residual_deviance) == 2, 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(mean_residual_deviance.keys()))\n    assert isinstance(mean_residual_deviance['valid'], float) and isinstance(mean_residual_deviance['xval'], float), 'validation and cross validation metrics to be floats, but got {0} and {1}'.format(type(mean_residual_deviance['valid']), type(mean_residual_deviance['xval']))\n    cars = h2o.import_file(path=pyunit_utils.locate('smalldata/junit/cars_20mpg.csv'))\n    cars['economy_20mpg'] = cars['economy_20mpg'].asfactor()\n    r = cars[0].runif()\n    train = cars[r > 0.2]\n    valid = cars[r <= 0.2]\n    response_col = 'economy_20mpg'\n    distribution = 'bernoulli'\n    predictors = ['displacement', 'power', 'weight', 'acceleration', 'year']\n    gbm = H2OGradientBoostingEstimator(nfolds=3, distribution=distribution, fold_assignment='Random')\n    gbm.train(y=response_col, x=predictors, validation_frame=valid, training_frame=train)\n    for metric in ['gini', 'logloss', 'auc', 'aucpr', 'mse', 'rmse']:\n        val = getattr(gbm, metric)()\n        assert isinstance(val, float), 'expected a float for metric {} but got {}'.format(metric, val)\n    for metric in ['mcc', 'F1', 'F0point5', 'F2', 'accuracy', 'mean_per_class_error']:\n        val = getattr(gbm, metric)()[0][1]\n        assert isinstance(val, float), 'expected a float for metric {} but got {}'.format(metric, val)\n    auc1 = gbm.auc(train=True, valid=False, xval=False)\n    assert isinstance(auc1, float)\n    auc2 = gbm.auc(train=False, valid=True, xval=False)\n    assert isinstance(auc2, float)\n    auc3 = gbm.auc(train=False, valid=False, xval=True)\n    assert isinstance(auc3, float)\n    auc = gbm.auc(train=True, valid=True, xval=False)\n    assert 'train' in list(auc.keys()) and 'valid' in list(auc.keys()), 'expected training and validation metrics to be returned, but got {0}'.format(list(auc.keys()))\n    assert len(auc) == 2, 'expected only training and validation metrics to be returned, but got {0}'.format(list(auc.keys()))\n    assert isinstance(auc['train'], float) and isinstance(auc['valid'], float), 'expected training and validation metrics to be floats, but got {0} and {1}'.format(type(auc['train']), type(auc['valid']))\n    assert auc['valid'] == auc2\n    auc = gbm.auc(train=True, valid=False, xval=True)\n    assert 'train' in list(auc.keys()) and 'xval' in list(auc.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(auc.keys()))\n    assert len(auc) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(auc.keys()))\n    assert isinstance(auc['train'], float) and isinstance(auc['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(auc['train']), type(auc['xval']))\n    assert auc['xval'] == auc3\n    auc = gbm.auc(train=True, valid=True, xval=True)\n    assert 'train' in list(auc.keys()) and 'valid' in list(auc.keys()) and ('xval' in list(auc.keys())), 'expected training, validation, and cross validation metrics to be returned, but got {0}'.format(list(auc.keys()))\n    assert len(auc) == 3, 'expected training, validation and cross validation metrics to be returned, but got {0}'.format(list(auc.keys()))\n    assert isinstance(auc['train'], float) and isinstance(auc['valid'], float) and isinstance(auc['xval'], float), 'expected training, validation, and cross validation metrics to be floats, but got {0}, {1}, and {2}'.format(type(auc['train']), type(auc['valid']), type(auc['xval']))\n    auc = gbm.auc(train=False, valid=False, xval=False)\n    assert isinstance(auc, float)\n    assert auc == auc1\n    auc = gbm.auc(train=False, valid=True, xval=True)\n    assert 'valid' in list(auc.keys()) and 'xval' in list(auc.keys()), 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(auc.keys()))\n    assert len(auc) == 2, 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(auc.keys()))\n    assert isinstance(auc['valid'], float) and isinstance(auc['xval'], float), 'validation and cross validation metrics to be floats, but got {0} and {1}'.format(type(auc['valid']), type(auc['xval']))\n    (fprs1, tprs1) = gbm.roc(train=True, valid=False, xval=False)\n    assert isinstance(fprs1, list)\n    assert isinstance(tprs1, list)\n    (fprs2, tprs2) = gbm.roc(train=False, valid=True, xval=False)\n    assert isinstance(fprs2, list)\n    assert isinstance(tprs2, list)\n    (fprs3, tprs3) = gbm.roc(train=False, valid=False, xval=True)\n    assert isinstance(fprs3, list)\n    assert isinstance(tprs3, list)\n    roc = gbm.roc(train=True, valid=True, xval=False)\n    assert 'train' in list(roc.keys()) and 'valid' in list(roc.keys()), 'expected training and validation metrics to be returned, but got {0}'.format(list(roc.keys()))\n    assert len(roc) == 2, 'expected only training and validation metrics to be returned, but got {0}'.format(list(roc.keys()))\n    assert isinstance(roc['train'], tuple) and isinstance(roc['valid'], tuple), 'expected training and validation metrics to be tuples, but got {0} and {1}'.format(type(roc['train']), type(roc['valid']))\n    assert roc['valid'][0] == fprs2\n    assert roc['valid'][1] == tprs2\n    roc = gbm.roc(train=True, valid=False, xval=True)\n    assert 'train' in list(roc.keys()) and 'xval' in list(roc.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(roc.keys()))\n    assert len(roc) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(roc.keys()))\n    assert isinstance(roc['train'], tuple) and isinstance(roc['xval'], tuple), 'expected training and cross validation metrics to be tuples, but got {0} and {1}'.format(type(roc['train']), type(roc['xval']))\n    assert roc['xval'][0] == fprs3\n    assert roc['xval'][1] == tprs3\n    roc = gbm.roc(train=True, valid=True, xval=True)\n    assert 'train' in list(roc.keys()) and 'valid' in list(roc.keys()) and ('xval' in list(roc.keys())), 'expected training, validation, and cross validation metrics to be returned, but got {0}'.format(list(roc.keys()))\n    assert len(roc) == 3, 'expected training, validation and cross validation metrics to be returned, but got {0}'.format(list(roc.keys()))\n    assert isinstance(roc['train'], tuple) and isinstance(roc['valid'], tuple) and isinstance(roc['xval'], tuple), 'expected training, validation, and cross validation metrics to be tuples, but got {0}, {1}, and {2}'.format(type(roc['train']), type(roc['valid']), type(roc['xval']))\n    (fprs, tprs) = gbm.roc(train=False, valid=False, xval=False)\n    assert isinstance(fprs, list)\n    assert isinstance(tprs, list)\n    assert fprs == fprs1\n    assert tprs == tprs1\n    roc = gbm.roc(train=False, valid=True, xval=True)\n    assert 'valid' in list(roc.keys()) and 'xval' in list(roc.keys()), 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(roc.keys()))\n    assert len(roc) == 2, 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(roc.keys()))\n    assert isinstance(roc['valid'], tuple) and isinstance(roc['xval'], tuple), 'validation and cross validation metrics to be tuples, but got {0} and {1}'.format(type(roc['valid']), type(roc['xval']))\n    logloss1 = gbm.logloss(train=True, valid=False, xval=False)\n    assert isinstance(logloss1, float)\n    logloss2 = gbm.logloss(train=False, valid=True, xval=False)\n    assert isinstance(logloss2, float)\n    logloss3 = gbm.logloss(train=False, valid=False, xval=True)\n    assert isinstance(logloss3, float)\n    logloss = gbm.logloss(train=True, valid=True, xval=False)\n    assert 'train' in list(logloss.keys()) and 'valid' in list(logloss.keys()), 'expected training and validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert len(logloss) == 2, 'expected only training and validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert isinstance(logloss['train'], float) and isinstance(logloss['valid'], float), 'expected training and validation metrics to be floats, but got {0} and {1}'.format(type(logloss['train']), type(logloss['valid']))\n    assert logloss['valid'] == logloss2\n    logloss = gbm.logloss(train=True, valid=False, xval=True)\n    assert 'train' in list(logloss.keys()) and 'xval' in list(logloss.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert len(logloss) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert isinstance(logloss['train'], float) and isinstance(logloss['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(logloss['train']), type(logloss['xval']))\n    assert logloss['xval'] == logloss3\n    logloss = gbm.logloss(train=True, valid=True, xval=True)\n    assert 'train' in list(logloss.keys()) and 'valid' in list(logloss.keys()) and ('xval' in list(logloss.keys())), 'expected training, validation, and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert len(logloss) == 3, 'expected training, validation and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert isinstance(logloss['train'], float) and isinstance(logloss['valid'], float) and isinstance(logloss['xval'], float), 'expected training, validation, and cross validation metrics to be floats, but got {0}, {1}, and {2}'.format(type(logloss['train']), type(logloss['valid']), type(logloss['xval']))\n    logloss = gbm.logloss(train=False, valid=False, xval=False)\n    assert isinstance(logloss, float)\n    assert logloss == logloss1\n    logloss = gbm.logloss(train=False, valid=True, xval=True)\n    assert 'valid' in list(logloss.keys()) and 'xval' in list(logloss.keys()), 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert len(logloss) == 2, 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert isinstance(logloss['valid'], float) and isinstance(logloss['xval'], float), 'validation and cross validation metrics to be floats, but got {0} and {1}'.format(type(logloss['valid']), type(logloss['xval']))\n    gini1 = gbm.gini(train=True, valid=False, xval=False)\n    assert isinstance(gini1, float)\n    gini2 = gbm.gini(train=False, valid=True, xval=False)\n    assert isinstance(gini2, float)\n    gini3 = gbm.gini(train=False, valid=False, xval=True)\n    assert isinstance(gini3, float)\n    gini = gbm.gini(train=True, valid=True, xval=False)\n    assert 'train' in list(gini.keys()) and 'valid' in list(gini.keys()), 'expected training and validation metrics to be returned, but got {0}'.format(list(gini.keys()))\n    assert len(gini) == 2, 'expected only training and validation metrics to be returned, but got {0}'.format(list(gini.keys()))\n    assert isinstance(gini['train'], float) and isinstance(gini['valid'], float), 'expected training and validation metrics to be floats, but got {0} and {1}'.format(type(gini['train']), type(gini['valid']))\n    assert gini['valid'] == gini2\n    gini = gbm.gini(train=True, valid=False, xval=True)\n    assert 'train' in list(gini.keys()) and 'xval' in list(gini.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(gini.keys()))\n    assert len(gini) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(gini.keys()))\n    assert isinstance(gini['train'], float) and isinstance(gini['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(gini['train']), type(gini['xval']))\n    assert gini['xval'] == gini3\n    gini = gbm.gini(train=True, valid=True, xval=True)\n    assert 'train' in list(gini.keys()) and 'valid' in list(gini.keys()) and ('xval' in list(gini.keys())), 'expected training, validation, and cross validation metrics to be returned, but got {0}'.format(list(gini.keys()))\n    assert len(gini) == 3, 'expected training, validation and cross validation metrics to be returned, but got {0}'.format(list(gini.keys()))\n    assert isinstance(gini['train'], float) and isinstance(gini['valid'], float) and isinstance(gini['xval'], float), 'expected training, validation, and cross validation metrics to be floats, but got {0}, {1}, and {2}'.format(type(gini['train']), type(gini['valid']), type(gini['xval']))\n    gini = gbm.gini(train=False, valid=False, xval=False)\n    assert isinstance(gini, float)\n    assert gini == gini1\n    gini = gbm.gini(train=False, valid=True, xval=True)\n    assert 'valid' in list(gini.keys()) and 'xval' in list(gini.keys()), 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(gini.keys()))\n    assert len(gini) == 2, 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(gini.keys()))\n    assert isinstance(gini['valid'], float) and isinstance(gini['xval'], float), 'validation and cross validation metrics to be floats, but got {0} and {1}'.format(type(gini['valid']), type(gini['xval']))\n    F11 = gbm.F1(train=True, valid=False, xval=False)\n    F12 = gbm.F1(train=False, valid=True, xval=False)\n    F13 = gbm.F1(train=False, valid=False, xval=True)\n    F1 = gbm.F1(train=True, valid=True, xval=False)\n    F1 = gbm.F1(train=True, valid=False, xval=True)\n    F1 = gbm.F1(train=True, valid=True, xval=True)\n    F1 = gbm.F1(train=False, valid=False, xval=False)\n    F1 = gbm.F1(train=False, valid=True, xval=True)\n    F0point51 = gbm.F0point5(train=True, valid=False, xval=False)\n    F0point52 = gbm.F0point5(train=False, valid=True, xval=False)\n    F0point53 = gbm.F0point5(train=False, valid=False, xval=True)\n    F0point5 = gbm.F0point5(train=True, valid=True, xval=False)\n    F0point5 = gbm.F0point5(train=True, valid=False, xval=True)\n    F0point5 = gbm.F0point5(train=True, valid=True, xval=True)\n    F0point5 = gbm.F0point5(train=False, valid=False, xval=False)\n    F0point5 = gbm.F0point5(train=False, valid=True, xval=True)\n    F21 = gbm.F2(train=True, valid=False, xval=False)\n    F22 = gbm.F2(train=False, valid=True, xval=False)\n    F23 = gbm.F2(train=False, valid=False, xval=True)\n    F2 = gbm.F2(train=True, valid=True, xval=False)\n    F2 = gbm.F2(train=True, valid=False, xval=True)\n    F2 = gbm.F2(train=True, valid=True, xval=True)\n    F2 = gbm.F2(train=False, valid=False, xval=False)\n    F2 = gbm.F2(train=False, valid=True, xval=True)\n    accuracy1 = gbm.accuracy(train=True, valid=False, xval=False)\n    accuracy2 = gbm.accuracy(train=False, valid=True, xval=False)\n    accuracy3 = gbm.accuracy(train=False, valid=False, xval=True)\n    accuracy = gbm.accuracy(train=True, valid=True, xval=False)\n    accuracy = gbm.accuracy(train=True, valid=False, xval=True)\n    accuracy = gbm.accuracy(train=True, valid=True, xval=True)\n    accuracy = gbm.accuracy(train=False, valid=False, xval=False)\n    accuracy = gbm.accuracy(train=False, valid=True, xval=True)\n    error1 = gbm.error(train=True, valid=False, xval=False)\n    error2 = gbm.error(train=False, valid=True, xval=False)\n    error3 = gbm.error(train=False, valid=False, xval=True)\n    error = gbm.error(train=True, valid=True, xval=False)\n    error = gbm.error(train=True, valid=False, xval=True)\n    error = gbm.error(train=True, valid=True, xval=True)\n    error = gbm.error(train=False, valid=False, xval=False)\n    error = gbm.error(train=False, valid=True, xval=True)\n    precision1 = gbm.precision(train=True, valid=False, xval=False)\n    precision2 = gbm.precision(train=False, valid=True, xval=False)\n    precision3 = gbm.precision(train=False, valid=False, xval=True)\n    precision = gbm.precision(train=True, valid=True, xval=False)\n    precision = gbm.precision(train=True, valid=False, xval=True)\n    precision = gbm.precision(train=True, valid=True, xval=True)\n    precision = gbm.precision(train=False, valid=False, xval=False)\n    precision = gbm.precision(train=False, valid=True, xval=True)\n    mcc1 = gbm.mcc(train=True, valid=False, xval=False)\n    mcc2 = gbm.mcc(train=False, valid=True, xval=False)\n    mcc3 = gbm.mcc(train=False, valid=False, xval=True)\n    mcc = gbm.mcc(train=True, valid=True, xval=False)\n    mcc = gbm.mcc(train=True, valid=False, xval=True)\n    mcc = gbm.mcc(train=True, valid=True, xval=True)\n    mcc = gbm.mcc(train=False, valid=False, xval=False)\n    mcc = gbm.mcc(train=False, valid=True, xval=True)\n    max_per_class_error1 = gbm.max_per_class_error(train=True, valid=False, xval=False)\n    max_per_class_error2 = gbm.max_per_class_error(train=False, valid=True, xval=False)\n    max_per_class_error3 = gbm.max_per_class_error(train=False, valid=False, xval=True)\n    max_per_class_error = gbm.max_per_class_error(train=True, valid=True, xval=False)\n    max_per_class_error = gbm.max_per_class_error(train=True, valid=False, xval=True)\n    max_per_class_error = gbm.max_per_class_error(train=True, valid=True, xval=True)\n    max_per_class_error = gbm.max_per_class_error(train=False, valid=False, xval=False)\n    max_per_class_error = gbm.max_per_class_error(train=False, valid=True, xval=True)\n    mean_per_class_error1 = gbm.mean_per_class_error(train=True, valid=False, xval=False)\n    mean_per_class_error2 = gbm.mean_per_class_error(train=False, valid=True, xval=False)\n    mean_per_class_error3 = gbm.mean_per_class_error(train=False, valid=False, xval=True)\n    mean_per_class_error = gbm.mean_per_class_error(train=True, valid=True, xval=False)\n    mean_per_class_error = gbm.mean_per_class_error(train=True, valid=False, xval=True)\n    mean_per_class_error = gbm.mean_per_class_error(train=True, valid=True, xval=True)\n    mean_per_class_error = gbm.mean_per_class_error(train=False, valid=False, xval=False)\n    mean_per_class_error = gbm.mean_per_class_error(train=False, valid=True, xval=True)\n    confusion_matrix1 = gbm.confusion_matrix(train=True, valid=False, xval=False)\n    confusion_matrix2 = gbm.confusion_matrix(train=False, valid=True, xval=False)\n    confusion_matrix3 = gbm.confusion_matrix(train=False, valid=False, xval=True)\n    confusion_matrix = gbm.confusion_matrix(train=True, valid=True, xval=False)\n    confusion_matrix = gbm.confusion_matrix(train=True, valid=False, xval=True)\n    confusion_matrix = gbm.confusion_matrix(train=True, valid=True, xval=True)\n    confusion_matrix = gbm.confusion_matrix(train=False, valid=False, xval=False)\n    confusion_matrix = gbm.confusion_matrix(train=False, valid=True, xval=True)\n    tpr1 = gbm.tpr(train=True, valid=False, xval=False)\n    tpr2 = gbm.tpr(train=False, valid=True, xval=False)\n    tpr3 = gbm.tpr(train=False, valid=False, xval=True)\n    tpr = gbm.tpr(train=True, valid=True, xval=False)\n    tpr = gbm.tpr(train=True, valid=False, xval=True)\n    tpr = gbm.tpr(train=True, valid=True, xval=True)\n    tpr = gbm.tpr(train=False, valid=False, xval=False)\n    tpr = gbm.tpr(train=False, valid=True, xval=True)\n    tnr1 = gbm.tnr(train=True, valid=False, xval=False)\n    tnr2 = gbm.tnr(train=False, valid=True, xval=False)\n    tnr3 = gbm.tnr(train=False, valid=False, xval=True)\n    tnr = gbm.tnr(train=True, valid=True, xval=False)\n    tnr = gbm.tnr(train=True, valid=False, xval=True)\n    tnr = gbm.tnr(train=True, valid=True, xval=True)\n    tnr = gbm.tnr(train=False, valid=False, xval=False)\n    tnr = gbm.tnr(train=False, valid=True, xval=True)\n    fnr1 = gbm.fnr(train=True, valid=False, xval=False)\n    fnr2 = gbm.fnr(train=False, valid=True, xval=False)\n    fnr3 = gbm.fnr(train=False, valid=False, xval=True)\n    fnr = gbm.fnr(train=True, valid=True, xval=False)\n    fnr = gbm.fnr(train=True, valid=False, xval=True)\n    fnr = gbm.fnr(train=True, valid=True, xval=True)\n    fnr = gbm.fnr(train=False, valid=False, xval=False)\n    fnr = gbm.fnr(train=False, valid=True, xval=True)\n    fpr1 = gbm.fpr(train=True, valid=False, xval=False)\n    fpr2 = gbm.fpr(train=False, valid=True, xval=False)\n    fpr3 = gbm.fpr(train=False, valid=False, xval=True)\n    fpr = gbm.fpr(train=True, valid=True, xval=False)\n    fpr = gbm.fpr(train=True, valid=False, xval=True)\n    fpr = gbm.fpr(train=True, valid=True, xval=True)\n    fpr = gbm.fpr(train=False, valid=False, xval=False)\n    fpr = gbm.fpr(train=False, valid=True, xval=True)\n    cars = h2o.import_file(path=pyunit_utils.locate('smalldata/junit/cars_20mpg.csv'))\n    cars['cylinders'] = cars['cylinders'].asfactor()\n    r = cars[0].runif()\n    train = cars[r > 0.2]\n    valid = cars[r <= 0.2]\n    response_col = 'cylinders'\n    distribution = 'multinomial'\n    predictors = ['displacement', 'power', 'weight', 'acceleration', 'year']\n    gbm = H2OGradientBoostingEstimator(nfolds=3, distribution=distribution, fold_assignment='Random')\n    gbm.train(x=predictors, y=response_col, training_frame=train, validation_frame=valid)\n    for metric in ['logloss', 'mse', 'rmse', 'mean_per_class_error']:\n        val = getattr(gbm, metric)()\n        assert isinstance(val, float), 'expected a float for metric {} but got {}'.format(metric, val)\n    mse1 = gbm.mse(train=True, valid=False, xval=False)\n    assert isinstance(mse1, float)\n    mse2 = gbm.mse(train=False, valid=True, xval=False)\n    assert isinstance(mse2, float)\n    mse3 = gbm.mse(train=False, valid=False, xval=True)\n    assert isinstance(mse3, float)\n    mse = gbm.mse(train=True, valid=True, xval=False)\n    assert 'train' in list(mse.keys()) and 'valid' in list(mse.keys()), 'expected training and validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert len(mse) == 2, 'expected only training and validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert isinstance(mse['train'], float) and isinstance(mse['valid'], float), 'expected training and validation metrics to be floats, but got {0} and {1}'.format(type(mse['train']), type(mse['valid']))\n    assert mse['valid'] == mse2\n    mse = gbm.mse(train=True, valid=False, xval=True)\n    assert 'train' in list(mse.keys()) and 'xval' in list(mse.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert len(mse) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert isinstance(mse['train'], float) and isinstance(mse['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(mse['train']), type(mse['xval']))\n    assert mse['xval'] == mse3\n    mse = gbm.mse(train=True, valid=True, xval=True)\n    assert 'train' in list(mse.keys()) and 'valid' in list(mse.keys()) and ('xval' in list(mse.keys())), 'expected training, validation, and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert len(mse) == 3, 'expected training, validation and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert isinstance(mse['train'], float) and isinstance(mse['valid'], float) and isinstance(mse['xval'], float), 'expected training, validation, and cross validation metrics to be floats, but got {0}, {1}, and {2}'.format(type(mse['train']), type(mse['valid']), type(mse['xval']))\n    mse = gbm.mse(train=False, valid=False, xval=False)\n    assert isinstance(mse, float)\n    assert mse == mse1\n    mse = gbm.mse(train=False, valid=True, xval=True)\n    assert 'valid' in list(mse.keys()) and 'xval' in list(mse.keys()), 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert len(mse) == 2, 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert isinstance(mse['valid'], float) and isinstance(mse['xval'], float), 'validation and cross validation metrics to be floats, but got {0} and {1}'.format(type(mse['valid']), type(mse['xval']))\n    logloss1 = gbm.logloss(train=True, valid=False, xval=False)\n    assert isinstance(logloss1, float)\n    logloss2 = gbm.logloss(train=False, valid=True, xval=False)\n    assert isinstance(logloss2, float)\n    logloss3 = gbm.logloss(train=False, valid=False, xval=True)\n    assert isinstance(logloss3, float)\n    logloss = gbm.logloss(train=True, valid=True, xval=False)\n    assert 'train' in list(logloss.keys()) and 'valid' in list(logloss.keys()), 'expected training and validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert len(logloss) == 2, 'expected only training and validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert isinstance(logloss['train'], float) and isinstance(logloss['valid'], float), 'expected training and validation metrics to be floats, but got {0} and {1}'.format(type(logloss['train']), type(logloss['valid']))\n    assert logloss['valid'] == logloss2\n    logloss = gbm.logloss(train=True, valid=False, xval=True)\n    assert 'train' in list(logloss.keys()) and 'xval' in list(logloss.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert len(logloss) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert isinstance(logloss['train'], float) and isinstance(logloss['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(logloss['train']), type(logloss['xval']))\n    assert logloss['xval'] == logloss3\n    logloss = gbm.logloss(train=True, valid=True, xval=True)\n    assert 'train' in list(logloss.keys()) and 'valid' in list(logloss.keys()) and ('xval' in list(logloss.keys())), 'expected training, validation, and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert len(logloss) == 3, 'expected training, validation and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert isinstance(logloss['train'], float) and isinstance(logloss['valid'], float) and isinstance(logloss['xval'], float), 'expected training, validation, and cross validation metrics to be floats, but got {0}, {1}, and {2}'.format(type(logloss['train']), type(logloss['valid']), type(logloss['xval']))\n    logloss = gbm.logloss(train=False, valid=False, xval=False)\n    assert isinstance(logloss, float)\n    assert logloss == logloss1\n    logloss = gbm.logloss(train=False, valid=True, xval=True)\n    assert 'valid' in list(logloss.keys()) and 'xval' in list(logloss.keys()), 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert len(logloss) == 2, 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert isinstance(logloss['valid'], float) and isinstance(logloss['xval'], float), 'validation and cross validation metrics to be floats, but got {0} and {1}'.format(type(logloss['valid']), type(logloss['xval']))\n    hit_ratio_table1 = gbm.hit_ratio_table(train=True, valid=False, xval=False)\n    hit_ratio_table2 = gbm.hit_ratio_table(train=False, valid=True, xval=False)\n    hit_ratio_table3 = gbm.hit_ratio_table(train=False, valid=False, xval=True)\n    hit_ratio_table = gbm.hit_ratio_table(train=True, valid=True, xval=False)\n    hit_ratio_table = gbm.hit_ratio_table(train=True, valid=False, xval=True)\n    hit_ratio_table = gbm.hit_ratio_table(train=True, valid=True, xval=True)\n    hit_ratio_table = gbm.hit_ratio_table(train=False, valid=False, xval=False)\n    hit_ratio_table = gbm.hit_ratio_table(train=False, valid=True, xval=True)\n    mean_per_class_error1 = gbm.mean_per_class_error(train=True, valid=False, xval=False)\n    mean_per_class_error2 = gbm.mean_per_class_error(train=False, valid=True, xval=False)\n    mean_per_class_error3 = gbm.mean_per_class_error(train=False, valid=False, xval=True)\n    mean_per_class_error = gbm.mean_per_class_error(train=True, valid=True, xval=False)\n    mean_per_class_error = gbm.mean_per_class_error(train=True, valid=False, xval=True)\n    mean_per_class_error = gbm.mean_per_class_error(train=True, valid=True, xval=True)\n    mean_per_class_error = gbm.mean_per_class_error(train=False, valid=False, xval=False)\n    mean_per_class_error = gbm.mean_per_class_error(train=False, valid=True, xval=True)\n    iris = h2o.import_file(path=pyunit_utils.locate('smalldata/iris/iris.csv'))\n    from h2o.estimators.kmeans import H2OKMeansEstimator\n    km = H2OKMeansEstimator(k=3, nfolds=3)\n    km.train(x=list(range(4)), training_frame=iris)\n    betweenss1 = km.betweenss(train=True, valid=False, xval=False)\n    assert isinstance(betweenss1, float)\n    betweenss3 = km.betweenss(train=False, valid=False, xval=True)\n    assert isinstance(betweenss3, float)\n    betweenss = km.betweenss(train=True, valid=False, xval=True)\n    assert 'train' in list(betweenss.keys()) and 'xval' in list(betweenss.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(betweenss.keys()))\n    assert len(betweenss) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(betweenss.keys()))\n    assert isinstance(betweenss['train'], float) and isinstance(betweenss['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(betweenss['train']), type(betweenss['xval']))\n    assert betweenss['xval'] == betweenss3\n    betweenss = km.betweenss(train=False, valid=False, xval=False)\n    assert isinstance(betweenss, float)\n    assert betweenss == betweenss1\n    totss1 = km.totss(train=True, valid=False, xval=False)\n    assert isinstance(totss1, float)\n    totss3 = km.totss(train=False, valid=False, xval=True)\n    assert isinstance(totss3, float)\n    totss = km.totss(train=True, valid=False, xval=True)\n    assert 'train' in list(totss.keys()) and 'xval' in list(totss.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(totss.keys()))\n    assert len(totss) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(totss.keys()))\n    assert isinstance(totss['train'], float) and isinstance(totss['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(totss['train']), type(totss['xval']))\n    assert totss['xval'] == totss3\n    totss = km.totss(train=False, valid=False, xval=False)\n    assert isinstance(totss, float)\n    assert totss == totss1\n    tot_withinss1 = km.tot_withinss(train=True, valid=False, xval=False)\n    assert isinstance(tot_withinss1, float)\n    tot_withinss3 = km.tot_withinss(train=False, valid=False, xval=True)\n    assert isinstance(tot_withinss3, float)\n    tot_withinss = km.tot_withinss(train=True, valid=False, xval=True)\n    assert 'train' in list(tot_withinss.keys()) and 'xval' in list(tot_withinss.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(tot_withinss.keys()))\n    assert len(tot_withinss) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(tot_withinss.keys()))\n    assert isinstance(tot_withinss['train'], float) and isinstance(tot_withinss['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(tot_withinss['train']), type(tot_withinss['xval']))\n    assert tot_withinss['xval'] == tot_withinss3\n    tot_withinss = km.tot_withinss(train=False, valid=False, xval=False)\n    assert isinstance(tot_withinss, float)\n    assert tot_withinss == tot_withinss1\n    withinss1 = km.withinss(train=True, valid=False)\n    withinss2 = km.withinss(train=True, valid=True)\n    withinss3 = km.withinss(train=False, valid=False)\n    assert withinss1 == withinss3\n    assert withinss1 != withinss2\n    centroid_stats1 = km.centroid_stats(train=True, valid=False)\n    centroid_stats2 = km.centroid_stats(train=True, valid=True)\n    centroid_stats3 = km.centroid_stats(train=False, valid=False)\n    assert centroid_stats1 == centroid_stats3\n    assert centroid_stats1 != centroid_stats2\n    size1 = km.size(train=True, valid=False)\n    size2 = km.size(train=True, valid=True)\n    size3 = km.size(train=False, valid=False)\n    assert size1 == size3\n    assert size1 != size2",
        "mutated": [
            "def metric_accessors():\n    if False:\n        i = 10\n    cars = h2o.import_file(path=pyunit_utils.locate('smalldata/junit/cars_20mpg.csv'))\n    r = cars[0].runif()\n    train = cars[r > 0.2]\n    valid = cars[r <= 0.2]\n    response_col = 'economy'\n    distribution = 'gaussian'\n    predictors = ['displacement', 'power', 'weight', 'acceleration', 'year']\n    gbm = H2OGradientBoostingEstimator(nfolds=3, distribution=distribution, fold_assignment='Random')\n    gbm.train(x=predictors, y=response_col, training_frame=train, validation_frame=valid)\n    for metric in ['r2', 'mse', 'rmse', 'rmsle', 'mae']:\n        val = getattr(gbm, metric)()\n        assert isinstance(val, float), 'expected a float for metric {} but got {}'.format(metric, val)\n    mse1 = gbm.mse(train=True, valid=False, xval=False)\n    assert isinstance(mse1, float)\n    mse2 = gbm.mse(train=False, valid=True, xval=False)\n    assert isinstance(mse2, float)\n    mse3 = gbm.mse(train=False, valid=False, xval=True)\n    assert isinstance(mse3, float)\n    mse = gbm.mse(train=True, valid=True, xval=False)\n    assert 'train' in list(mse.keys()) and 'valid' in list(mse.keys()), 'expected training and validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert len(mse) == 2, 'expected only training and validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert isinstance(mse['train'], float) and isinstance(mse['valid'], float), 'expected training and validation metrics to be floats, but got {0} and {1}'.format(type(mse['train']), type(mse['valid']))\n    assert mse['valid'] == mse2\n    mse = gbm.mse(train=True, valid=False, xval=True)\n    assert 'train' in list(mse.keys()) and 'xval' in list(mse.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert len(mse) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert isinstance(mse['train'], float) and isinstance(mse['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(mse['train']), type(mse['xval']))\n    assert mse['xval'] == mse3\n    mse = gbm.mse(train=True, valid=True, xval=True)\n    assert 'train' in list(mse.keys()) and 'valid' in list(mse.keys()) and ('xval' in list(mse.keys())), 'expected training, validation, and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert len(mse) == 3, 'expected training, validation and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert isinstance(mse['train'], float) and isinstance(mse['valid'], float) and isinstance(mse['xval'], float), 'expected training, validation, and cross validation metrics to be floats, but got {0}, {1}, and {2}'.format(type(mse['train']), type(mse['valid']), type(mse['xval']))\n    mse = gbm.mse(train=False, valid=False, xval=False)\n    assert isinstance(mse, float)\n    assert mse == mse1\n    mse = gbm.mse(train=False, valid=True, xval=True)\n    assert 'valid' in list(mse.keys()) and 'xval' in list(mse.keys()), 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert len(mse) == 2, 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert isinstance(mse['valid'], float) and isinstance(mse['xval'], float), 'validation and cross validation metrics to be floats, but got {0} and {1}'.format(type(mse['valid']), type(mse['xval']))\n    mean_residual_deviance1 = gbm.mean_residual_deviance(train=True, valid=False, xval=False)\n    assert isinstance(mean_residual_deviance1, float)\n    mean_residual_deviance2 = gbm.mean_residual_deviance(train=False, valid=True, xval=False)\n    assert isinstance(mean_residual_deviance2, float)\n    mean_residual_deviance3 = gbm.mean_residual_deviance(train=False, valid=False, xval=True)\n    assert isinstance(mean_residual_deviance3, float)\n    mean_residual_deviance = gbm.mean_residual_deviance(train=True, valid=True, xval=False)\n    assert 'train' in list(mean_residual_deviance.keys()) and 'valid' in list(mean_residual_deviance.keys()), 'expected training and validation metrics to be returned, but got {0}'.format(list(mean_residual_deviance.keys()))\n    assert len(mean_residual_deviance) == 2, 'expected only training and validation metrics to be returned, but got {0}'.format(list(mean_residual_deviance.keys()))\n    assert isinstance(mean_residual_deviance['train'], float) and isinstance(mean_residual_deviance['valid'], float), 'expected training and validation metrics to be floats, but got {0} and {1}'.format(type(mean_residual_deviance['train']), type(mean_residual_deviance['valid']))\n    assert mean_residual_deviance['valid'] == mean_residual_deviance2\n    mean_residual_deviance = gbm.mean_residual_deviance(train=True, valid=False, xval=True)\n    assert 'train' in list(mean_residual_deviance.keys()) and 'xval' in list(mean_residual_deviance.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(mean_residual_deviance.keys()))\n    assert len(mean_residual_deviance) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(mean_residual_deviance.keys()))\n    assert isinstance(mean_residual_deviance['train'], float) and isinstance(mean_residual_deviance['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(mean_residual_deviance['train']), type(mean_residual_deviance['xval']))\n    assert mean_residual_deviance['xval'] == mean_residual_deviance3\n    mean_residual_deviance = gbm.mean_residual_deviance(train=True, valid=True, xval=True)\n    assert 'train' in list(mean_residual_deviance.keys()) and 'valid' in list(mean_residual_deviance.keys()) and ('xval' in list(mean_residual_deviance.keys())), 'expected training, validation, and cross validation metrics to be returned, but got {0}'.format(list(mean_residual_deviance.keys()))\n    assert len(mean_residual_deviance) == 3, 'expected training, validation and cross validation metrics to be returned, but got {0}'.format(list(mean_residual_deviance.keys()))\n    assert isinstance(mean_residual_deviance['train'], float) and isinstance(mean_residual_deviance['valid'], float) and isinstance(mean_residual_deviance['xval'], float), 'expected training, validation, and cross validation metrics to be floats, but got {0}, {1}, and {2}'.format(type(mean_residual_deviance['train']), type(mean_residual_deviance['valid']), type(mean_residual_deviance['xval']))\n    mean_residual_deviance = gbm.mean_residual_deviance(train=False, valid=False, xval=False)\n    assert isinstance(mean_residual_deviance, float)\n    assert mean_residual_deviance == mean_residual_deviance1\n    mean_residual_deviance = gbm.mean_residual_deviance(train=False, valid=True, xval=True)\n    assert 'valid' in list(mean_residual_deviance.keys()) and 'xval' in list(mean_residual_deviance.keys()), 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(mean_residual_deviance.keys()))\n    assert len(mean_residual_deviance) == 2, 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(mean_residual_deviance.keys()))\n    assert isinstance(mean_residual_deviance['valid'], float) and isinstance(mean_residual_deviance['xval'], float), 'validation and cross validation metrics to be floats, but got {0} and {1}'.format(type(mean_residual_deviance['valid']), type(mean_residual_deviance['xval']))\n    cars = h2o.import_file(path=pyunit_utils.locate('smalldata/junit/cars_20mpg.csv'))\n    cars['economy_20mpg'] = cars['economy_20mpg'].asfactor()\n    r = cars[0].runif()\n    train = cars[r > 0.2]\n    valid = cars[r <= 0.2]\n    response_col = 'economy_20mpg'\n    distribution = 'bernoulli'\n    predictors = ['displacement', 'power', 'weight', 'acceleration', 'year']\n    gbm = H2OGradientBoostingEstimator(nfolds=3, distribution=distribution, fold_assignment='Random')\n    gbm.train(y=response_col, x=predictors, validation_frame=valid, training_frame=train)\n    for metric in ['gini', 'logloss', 'auc', 'aucpr', 'mse', 'rmse']:\n        val = getattr(gbm, metric)()\n        assert isinstance(val, float), 'expected a float for metric {} but got {}'.format(metric, val)\n    for metric in ['mcc', 'F1', 'F0point5', 'F2', 'accuracy', 'mean_per_class_error']:\n        val = getattr(gbm, metric)()[0][1]\n        assert isinstance(val, float), 'expected a float for metric {} but got {}'.format(metric, val)\n    auc1 = gbm.auc(train=True, valid=False, xval=False)\n    assert isinstance(auc1, float)\n    auc2 = gbm.auc(train=False, valid=True, xval=False)\n    assert isinstance(auc2, float)\n    auc3 = gbm.auc(train=False, valid=False, xval=True)\n    assert isinstance(auc3, float)\n    auc = gbm.auc(train=True, valid=True, xval=False)\n    assert 'train' in list(auc.keys()) and 'valid' in list(auc.keys()), 'expected training and validation metrics to be returned, but got {0}'.format(list(auc.keys()))\n    assert len(auc) == 2, 'expected only training and validation metrics to be returned, but got {0}'.format(list(auc.keys()))\n    assert isinstance(auc['train'], float) and isinstance(auc['valid'], float), 'expected training and validation metrics to be floats, but got {0} and {1}'.format(type(auc['train']), type(auc['valid']))\n    assert auc['valid'] == auc2\n    auc = gbm.auc(train=True, valid=False, xval=True)\n    assert 'train' in list(auc.keys()) and 'xval' in list(auc.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(auc.keys()))\n    assert len(auc) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(auc.keys()))\n    assert isinstance(auc['train'], float) and isinstance(auc['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(auc['train']), type(auc['xval']))\n    assert auc['xval'] == auc3\n    auc = gbm.auc(train=True, valid=True, xval=True)\n    assert 'train' in list(auc.keys()) and 'valid' in list(auc.keys()) and ('xval' in list(auc.keys())), 'expected training, validation, and cross validation metrics to be returned, but got {0}'.format(list(auc.keys()))\n    assert len(auc) == 3, 'expected training, validation and cross validation metrics to be returned, but got {0}'.format(list(auc.keys()))\n    assert isinstance(auc['train'], float) and isinstance(auc['valid'], float) and isinstance(auc['xval'], float), 'expected training, validation, and cross validation metrics to be floats, but got {0}, {1}, and {2}'.format(type(auc['train']), type(auc['valid']), type(auc['xval']))\n    auc = gbm.auc(train=False, valid=False, xval=False)\n    assert isinstance(auc, float)\n    assert auc == auc1\n    auc = gbm.auc(train=False, valid=True, xval=True)\n    assert 'valid' in list(auc.keys()) and 'xval' in list(auc.keys()), 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(auc.keys()))\n    assert len(auc) == 2, 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(auc.keys()))\n    assert isinstance(auc['valid'], float) and isinstance(auc['xval'], float), 'validation and cross validation metrics to be floats, but got {0} and {1}'.format(type(auc['valid']), type(auc['xval']))\n    (fprs1, tprs1) = gbm.roc(train=True, valid=False, xval=False)\n    assert isinstance(fprs1, list)\n    assert isinstance(tprs1, list)\n    (fprs2, tprs2) = gbm.roc(train=False, valid=True, xval=False)\n    assert isinstance(fprs2, list)\n    assert isinstance(tprs2, list)\n    (fprs3, tprs3) = gbm.roc(train=False, valid=False, xval=True)\n    assert isinstance(fprs3, list)\n    assert isinstance(tprs3, list)\n    roc = gbm.roc(train=True, valid=True, xval=False)\n    assert 'train' in list(roc.keys()) and 'valid' in list(roc.keys()), 'expected training and validation metrics to be returned, but got {0}'.format(list(roc.keys()))\n    assert len(roc) == 2, 'expected only training and validation metrics to be returned, but got {0}'.format(list(roc.keys()))\n    assert isinstance(roc['train'], tuple) and isinstance(roc['valid'], tuple), 'expected training and validation metrics to be tuples, but got {0} and {1}'.format(type(roc['train']), type(roc['valid']))\n    assert roc['valid'][0] == fprs2\n    assert roc['valid'][1] == tprs2\n    roc = gbm.roc(train=True, valid=False, xval=True)\n    assert 'train' in list(roc.keys()) and 'xval' in list(roc.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(roc.keys()))\n    assert len(roc) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(roc.keys()))\n    assert isinstance(roc['train'], tuple) and isinstance(roc['xval'], tuple), 'expected training and cross validation metrics to be tuples, but got {0} and {1}'.format(type(roc['train']), type(roc['xval']))\n    assert roc['xval'][0] == fprs3\n    assert roc['xval'][1] == tprs3\n    roc = gbm.roc(train=True, valid=True, xval=True)\n    assert 'train' in list(roc.keys()) and 'valid' in list(roc.keys()) and ('xval' in list(roc.keys())), 'expected training, validation, and cross validation metrics to be returned, but got {0}'.format(list(roc.keys()))\n    assert len(roc) == 3, 'expected training, validation and cross validation metrics to be returned, but got {0}'.format(list(roc.keys()))\n    assert isinstance(roc['train'], tuple) and isinstance(roc['valid'], tuple) and isinstance(roc['xval'], tuple), 'expected training, validation, and cross validation metrics to be tuples, but got {0}, {1}, and {2}'.format(type(roc['train']), type(roc['valid']), type(roc['xval']))\n    (fprs, tprs) = gbm.roc(train=False, valid=False, xval=False)\n    assert isinstance(fprs, list)\n    assert isinstance(tprs, list)\n    assert fprs == fprs1\n    assert tprs == tprs1\n    roc = gbm.roc(train=False, valid=True, xval=True)\n    assert 'valid' in list(roc.keys()) and 'xval' in list(roc.keys()), 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(roc.keys()))\n    assert len(roc) == 2, 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(roc.keys()))\n    assert isinstance(roc['valid'], tuple) and isinstance(roc['xval'], tuple), 'validation and cross validation metrics to be tuples, but got {0} and {1}'.format(type(roc['valid']), type(roc['xval']))\n    logloss1 = gbm.logloss(train=True, valid=False, xval=False)\n    assert isinstance(logloss1, float)\n    logloss2 = gbm.logloss(train=False, valid=True, xval=False)\n    assert isinstance(logloss2, float)\n    logloss3 = gbm.logloss(train=False, valid=False, xval=True)\n    assert isinstance(logloss3, float)\n    logloss = gbm.logloss(train=True, valid=True, xval=False)\n    assert 'train' in list(logloss.keys()) and 'valid' in list(logloss.keys()), 'expected training and validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert len(logloss) == 2, 'expected only training and validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert isinstance(logloss['train'], float) and isinstance(logloss['valid'], float), 'expected training and validation metrics to be floats, but got {0} and {1}'.format(type(logloss['train']), type(logloss['valid']))\n    assert logloss['valid'] == logloss2\n    logloss = gbm.logloss(train=True, valid=False, xval=True)\n    assert 'train' in list(logloss.keys()) and 'xval' in list(logloss.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert len(logloss) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert isinstance(logloss['train'], float) and isinstance(logloss['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(logloss['train']), type(logloss['xval']))\n    assert logloss['xval'] == logloss3\n    logloss = gbm.logloss(train=True, valid=True, xval=True)\n    assert 'train' in list(logloss.keys()) and 'valid' in list(logloss.keys()) and ('xval' in list(logloss.keys())), 'expected training, validation, and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert len(logloss) == 3, 'expected training, validation and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert isinstance(logloss['train'], float) and isinstance(logloss['valid'], float) and isinstance(logloss['xval'], float), 'expected training, validation, and cross validation metrics to be floats, but got {0}, {1}, and {2}'.format(type(logloss['train']), type(logloss['valid']), type(logloss['xval']))\n    logloss = gbm.logloss(train=False, valid=False, xval=False)\n    assert isinstance(logloss, float)\n    assert logloss == logloss1\n    logloss = gbm.logloss(train=False, valid=True, xval=True)\n    assert 'valid' in list(logloss.keys()) and 'xval' in list(logloss.keys()), 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert len(logloss) == 2, 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert isinstance(logloss['valid'], float) and isinstance(logloss['xval'], float), 'validation and cross validation metrics to be floats, but got {0} and {1}'.format(type(logloss['valid']), type(logloss['xval']))\n    gini1 = gbm.gini(train=True, valid=False, xval=False)\n    assert isinstance(gini1, float)\n    gini2 = gbm.gini(train=False, valid=True, xval=False)\n    assert isinstance(gini2, float)\n    gini3 = gbm.gini(train=False, valid=False, xval=True)\n    assert isinstance(gini3, float)\n    gini = gbm.gini(train=True, valid=True, xval=False)\n    assert 'train' in list(gini.keys()) and 'valid' in list(gini.keys()), 'expected training and validation metrics to be returned, but got {0}'.format(list(gini.keys()))\n    assert len(gini) == 2, 'expected only training and validation metrics to be returned, but got {0}'.format(list(gini.keys()))\n    assert isinstance(gini['train'], float) and isinstance(gini['valid'], float), 'expected training and validation metrics to be floats, but got {0} and {1}'.format(type(gini['train']), type(gini['valid']))\n    assert gini['valid'] == gini2\n    gini = gbm.gini(train=True, valid=False, xval=True)\n    assert 'train' in list(gini.keys()) and 'xval' in list(gini.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(gini.keys()))\n    assert len(gini) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(gini.keys()))\n    assert isinstance(gini['train'], float) and isinstance(gini['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(gini['train']), type(gini['xval']))\n    assert gini['xval'] == gini3\n    gini = gbm.gini(train=True, valid=True, xval=True)\n    assert 'train' in list(gini.keys()) and 'valid' in list(gini.keys()) and ('xval' in list(gini.keys())), 'expected training, validation, and cross validation metrics to be returned, but got {0}'.format(list(gini.keys()))\n    assert len(gini) == 3, 'expected training, validation and cross validation metrics to be returned, but got {0}'.format(list(gini.keys()))\n    assert isinstance(gini['train'], float) and isinstance(gini['valid'], float) and isinstance(gini['xval'], float), 'expected training, validation, and cross validation metrics to be floats, but got {0}, {1}, and {2}'.format(type(gini['train']), type(gini['valid']), type(gini['xval']))\n    gini = gbm.gini(train=False, valid=False, xval=False)\n    assert isinstance(gini, float)\n    assert gini == gini1\n    gini = gbm.gini(train=False, valid=True, xval=True)\n    assert 'valid' in list(gini.keys()) and 'xval' in list(gini.keys()), 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(gini.keys()))\n    assert len(gini) == 2, 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(gini.keys()))\n    assert isinstance(gini['valid'], float) and isinstance(gini['xval'], float), 'validation and cross validation metrics to be floats, but got {0} and {1}'.format(type(gini['valid']), type(gini['xval']))\n    F11 = gbm.F1(train=True, valid=False, xval=False)\n    F12 = gbm.F1(train=False, valid=True, xval=False)\n    F13 = gbm.F1(train=False, valid=False, xval=True)\n    F1 = gbm.F1(train=True, valid=True, xval=False)\n    F1 = gbm.F1(train=True, valid=False, xval=True)\n    F1 = gbm.F1(train=True, valid=True, xval=True)\n    F1 = gbm.F1(train=False, valid=False, xval=False)\n    F1 = gbm.F1(train=False, valid=True, xval=True)\n    F0point51 = gbm.F0point5(train=True, valid=False, xval=False)\n    F0point52 = gbm.F0point5(train=False, valid=True, xval=False)\n    F0point53 = gbm.F0point5(train=False, valid=False, xval=True)\n    F0point5 = gbm.F0point5(train=True, valid=True, xval=False)\n    F0point5 = gbm.F0point5(train=True, valid=False, xval=True)\n    F0point5 = gbm.F0point5(train=True, valid=True, xval=True)\n    F0point5 = gbm.F0point5(train=False, valid=False, xval=False)\n    F0point5 = gbm.F0point5(train=False, valid=True, xval=True)\n    F21 = gbm.F2(train=True, valid=False, xval=False)\n    F22 = gbm.F2(train=False, valid=True, xval=False)\n    F23 = gbm.F2(train=False, valid=False, xval=True)\n    F2 = gbm.F2(train=True, valid=True, xval=False)\n    F2 = gbm.F2(train=True, valid=False, xval=True)\n    F2 = gbm.F2(train=True, valid=True, xval=True)\n    F2 = gbm.F2(train=False, valid=False, xval=False)\n    F2 = gbm.F2(train=False, valid=True, xval=True)\n    accuracy1 = gbm.accuracy(train=True, valid=False, xval=False)\n    accuracy2 = gbm.accuracy(train=False, valid=True, xval=False)\n    accuracy3 = gbm.accuracy(train=False, valid=False, xval=True)\n    accuracy = gbm.accuracy(train=True, valid=True, xval=False)\n    accuracy = gbm.accuracy(train=True, valid=False, xval=True)\n    accuracy = gbm.accuracy(train=True, valid=True, xval=True)\n    accuracy = gbm.accuracy(train=False, valid=False, xval=False)\n    accuracy = gbm.accuracy(train=False, valid=True, xval=True)\n    error1 = gbm.error(train=True, valid=False, xval=False)\n    error2 = gbm.error(train=False, valid=True, xval=False)\n    error3 = gbm.error(train=False, valid=False, xval=True)\n    error = gbm.error(train=True, valid=True, xval=False)\n    error = gbm.error(train=True, valid=False, xval=True)\n    error = gbm.error(train=True, valid=True, xval=True)\n    error = gbm.error(train=False, valid=False, xval=False)\n    error = gbm.error(train=False, valid=True, xval=True)\n    precision1 = gbm.precision(train=True, valid=False, xval=False)\n    precision2 = gbm.precision(train=False, valid=True, xval=False)\n    precision3 = gbm.precision(train=False, valid=False, xval=True)\n    precision = gbm.precision(train=True, valid=True, xval=False)\n    precision = gbm.precision(train=True, valid=False, xval=True)\n    precision = gbm.precision(train=True, valid=True, xval=True)\n    precision = gbm.precision(train=False, valid=False, xval=False)\n    precision = gbm.precision(train=False, valid=True, xval=True)\n    mcc1 = gbm.mcc(train=True, valid=False, xval=False)\n    mcc2 = gbm.mcc(train=False, valid=True, xval=False)\n    mcc3 = gbm.mcc(train=False, valid=False, xval=True)\n    mcc = gbm.mcc(train=True, valid=True, xval=False)\n    mcc = gbm.mcc(train=True, valid=False, xval=True)\n    mcc = gbm.mcc(train=True, valid=True, xval=True)\n    mcc = gbm.mcc(train=False, valid=False, xval=False)\n    mcc = gbm.mcc(train=False, valid=True, xval=True)\n    max_per_class_error1 = gbm.max_per_class_error(train=True, valid=False, xval=False)\n    max_per_class_error2 = gbm.max_per_class_error(train=False, valid=True, xval=False)\n    max_per_class_error3 = gbm.max_per_class_error(train=False, valid=False, xval=True)\n    max_per_class_error = gbm.max_per_class_error(train=True, valid=True, xval=False)\n    max_per_class_error = gbm.max_per_class_error(train=True, valid=False, xval=True)\n    max_per_class_error = gbm.max_per_class_error(train=True, valid=True, xval=True)\n    max_per_class_error = gbm.max_per_class_error(train=False, valid=False, xval=False)\n    max_per_class_error = gbm.max_per_class_error(train=False, valid=True, xval=True)\n    mean_per_class_error1 = gbm.mean_per_class_error(train=True, valid=False, xval=False)\n    mean_per_class_error2 = gbm.mean_per_class_error(train=False, valid=True, xval=False)\n    mean_per_class_error3 = gbm.mean_per_class_error(train=False, valid=False, xval=True)\n    mean_per_class_error = gbm.mean_per_class_error(train=True, valid=True, xval=False)\n    mean_per_class_error = gbm.mean_per_class_error(train=True, valid=False, xval=True)\n    mean_per_class_error = gbm.mean_per_class_error(train=True, valid=True, xval=True)\n    mean_per_class_error = gbm.mean_per_class_error(train=False, valid=False, xval=False)\n    mean_per_class_error = gbm.mean_per_class_error(train=False, valid=True, xval=True)\n    confusion_matrix1 = gbm.confusion_matrix(train=True, valid=False, xval=False)\n    confusion_matrix2 = gbm.confusion_matrix(train=False, valid=True, xval=False)\n    confusion_matrix3 = gbm.confusion_matrix(train=False, valid=False, xval=True)\n    confusion_matrix = gbm.confusion_matrix(train=True, valid=True, xval=False)\n    confusion_matrix = gbm.confusion_matrix(train=True, valid=False, xval=True)\n    confusion_matrix = gbm.confusion_matrix(train=True, valid=True, xval=True)\n    confusion_matrix = gbm.confusion_matrix(train=False, valid=False, xval=False)\n    confusion_matrix = gbm.confusion_matrix(train=False, valid=True, xval=True)\n    tpr1 = gbm.tpr(train=True, valid=False, xval=False)\n    tpr2 = gbm.tpr(train=False, valid=True, xval=False)\n    tpr3 = gbm.tpr(train=False, valid=False, xval=True)\n    tpr = gbm.tpr(train=True, valid=True, xval=False)\n    tpr = gbm.tpr(train=True, valid=False, xval=True)\n    tpr = gbm.tpr(train=True, valid=True, xval=True)\n    tpr = gbm.tpr(train=False, valid=False, xval=False)\n    tpr = gbm.tpr(train=False, valid=True, xval=True)\n    tnr1 = gbm.tnr(train=True, valid=False, xval=False)\n    tnr2 = gbm.tnr(train=False, valid=True, xval=False)\n    tnr3 = gbm.tnr(train=False, valid=False, xval=True)\n    tnr = gbm.tnr(train=True, valid=True, xval=False)\n    tnr = gbm.tnr(train=True, valid=False, xval=True)\n    tnr = gbm.tnr(train=True, valid=True, xval=True)\n    tnr = gbm.tnr(train=False, valid=False, xval=False)\n    tnr = gbm.tnr(train=False, valid=True, xval=True)\n    fnr1 = gbm.fnr(train=True, valid=False, xval=False)\n    fnr2 = gbm.fnr(train=False, valid=True, xval=False)\n    fnr3 = gbm.fnr(train=False, valid=False, xval=True)\n    fnr = gbm.fnr(train=True, valid=True, xval=False)\n    fnr = gbm.fnr(train=True, valid=False, xval=True)\n    fnr = gbm.fnr(train=True, valid=True, xval=True)\n    fnr = gbm.fnr(train=False, valid=False, xval=False)\n    fnr = gbm.fnr(train=False, valid=True, xval=True)\n    fpr1 = gbm.fpr(train=True, valid=False, xval=False)\n    fpr2 = gbm.fpr(train=False, valid=True, xval=False)\n    fpr3 = gbm.fpr(train=False, valid=False, xval=True)\n    fpr = gbm.fpr(train=True, valid=True, xval=False)\n    fpr = gbm.fpr(train=True, valid=False, xval=True)\n    fpr = gbm.fpr(train=True, valid=True, xval=True)\n    fpr = gbm.fpr(train=False, valid=False, xval=False)\n    fpr = gbm.fpr(train=False, valid=True, xval=True)\n    cars = h2o.import_file(path=pyunit_utils.locate('smalldata/junit/cars_20mpg.csv'))\n    cars['cylinders'] = cars['cylinders'].asfactor()\n    r = cars[0].runif()\n    train = cars[r > 0.2]\n    valid = cars[r <= 0.2]\n    response_col = 'cylinders'\n    distribution = 'multinomial'\n    predictors = ['displacement', 'power', 'weight', 'acceleration', 'year']\n    gbm = H2OGradientBoostingEstimator(nfolds=3, distribution=distribution, fold_assignment='Random')\n    gbm.train(x=predictors, y=response_col, training_frame=train, validation_frame=valid)\n    for metric in ['logloss', 'mse', 'rmse', 'mean_per_class_error']:\n        val = getattr(gbm, metric)()\n        assert isinstance(val, float), 'expected a float for metric {} but got {}'.format(metric, val)\n    mse1 = gbm.mse(train=True, valid=False, xval=False)\n    assert isinstance(mse1, float)\n    mse2 = gbm.mse(train=False, valid=True, xval=False)\n    assert isinstance(mse2, float)\n    mse3 = gbm.mse(train=False, valid=False, xval=True)\n    assert isinstance(mse3, float)\n    mse = gbm.mse(train=True, valid=True, xval=False)\n    assert 'train' in list(mse.keys()) and 'valid' in list(mse.keys()), 'expected training and validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert len(mse) == 2, 'expected only training and validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert isinstance(mse['train'], float) and isinstance(mse['valid'], float), 'expected training and validation metrics to be floats, but got {0} and {1}'.format(type(mse['train']), type(mse['valid']))\n    assert mse['valid'] == mse2\n    mse = gbm.mse(train=True, valid=False, xval=True)\n    assert 'train' in list(mse.keys()) and 'xval' in list(mse.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert len(mse) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert isinstance(mse['train'], float) and isinstance(mse['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(mse['train']), type(mse['xval']))\n    assert mse['xval'] == mse3\n    mse = gbm.mse(train=True, valid=True, xval=True)\n    assert 'train' in list(mse.keys()) and 'valid' in list(mse.keys()) and ('xval' in list(mse.keys())), 'expected training, validation, and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert len(mse) == 3, 'expected training, validation and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert isinstance(mse['train'], float) and isinstance(mse['valid'], float) and isinstance(mse['xval'], float), 'expected training, validation, and cross validation metrics to be floats, but got {0}, {1}, and {2}'.format(type(mse['train']), type(mse['valid']), type(mse['xval']))\n    mse = gbm.mse(train=False, valid=False, xval=False)\n    assert isinstance(mse, float)\n    assert mse == mse1\n    mse = gbm.mse(train=False, valid=True, xval=True)\n    assert 'valid' in list(mse.keys()) and 'xval' in list(mse.keys()), 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert len(mse) == 2, 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert isinstance(mse['valid'], float) and isinstance(mse['xval'], float), 'validation and cross validation metrics to be floats, but got {0} and {1}'.format(type(mse['valid']), type(mse['xval']))\n    logloss1 = gbm.logloss(train=True, valid=False, xval=False)\n    assert isinstance(logloss1, float)\n    logloss2 = gbm.logloss(train=False, valid=True, xval=False)\n    assert isinstance(logloss2, float)\n    logloss3 = gbm.logloss(train=False, valid=False, xval=True)\n    assert isinstance(logloss3, float)\n    logloss = gbm.logloss(train=True, valid=True, xval=False)\n    assert 'train' in list(logloss.keys()) and 'valid' in list(logloss.keys()), 'expected training and validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert len(logloss) == 2, 'expected only training and validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert isinstance(logloss['train'], float) and isinstance(logloss['valid'], float), 'expected training and validation metrics to be floats, but got {0} and {1}'.format(type(logloss['train']), type(logloss['valid']))\n    assert logloss['valid'] == logloss2\n    logloss = gbm.logloss(train=True, valid=False, xval=True)\n    assert 'train' in list(logloss.keys()) and 'xval' in list(logloss.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert len(logloss) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert isinstance(logloss['train'], float) and isinstance(logloss['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(logloss['train']), type(logloss['xval']))\n    assert logloss['xval'] == logloss3\n    logloss = gbm.logloss(train=True, valid=True, xval=True)\n    assert 'train' in list(logloss.keys()) and 'valid' in list(logloss.keys()) and ('xval' in list(logloss.keys())), 'expected training, validation, and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert len(logloss) == 3, 'expected training, validation and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert isinstance(logloss['train'], float) and isinstance(logloss['valid'], float) and isinstance(logloss['xval'], float), 'expected training, validation, and cross validation metrics to be floats, but got {0}, {1}, and {2}'.format(type(logloss['train']), type(logloss['valid']), type(logloss['xval']))\n    logloss = gbm.logloss(train=False, valid=False, xval=False)\n    assert isinstance(logloss, float)\n    assert logloss == logloss1\n    logloss = gbm.logloss(train=False, valid=True, xval=True)\n    assert 'valid' in list(logloss.keys()) and 'xval' in list(logloss.keys()), 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert len(logloss) == 2, 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert isinstance(logloss['valid'], float) and isinstance(logloss['xval'], float), 'validation and cross validation metrics to be floats, but got {0} and {1}'.format(type(logloss['valid']), type(logloss['xval']))\n    hit_ratio_table1 = gbm.hit_ratio_table(train=True, valid=False, xval=False)\n    hit_ratio_table2 = gbm.hit_ratio_table(train=False, valid=True, xval=False)\n    hit_ratio_table3 = gbm.hit_ratio_table(train=False, valid=False, xval=True)\n    hit_ratio_table = gbm.hit_ratio_table(train=True, valid=True, xval=False)\n    hit_ratio_table = gbm.hit_ratio_table(train=True, valid=False, xval=True)\n    hit_ratio_table = gbm.hit_ratio_table(train=True, valid=True, xval=True)\n    hit_ratio_table = gbm.hit_ratio_table(train=False, valid=False, xval=False)\n    hit_ratio_table = gbm.hit_ratio_table(train=False, valid=True, xval=True)\n    mean_per_class_error1 = gbm.mean_per_class_error(train=True, valid=False, xval=False)\n    mean_per_class_error2 = gbm.mean_per_class_error(train=False, valid=True, xval=False)\n    mean_per_class_error3 = gbm.mean_per_class_error(train=False, valid=False, xval=True)\n    mean_per_class_error = gbm.mean_per_class_error(train=True, valid=True, xval=False)\n    mean_per_class_error = gbm.mean_per_class_error(train=True, valid=False, xval=True)\n    mean_per_class_error = gbm.mean_per_class_error(train=True, valid=True, xval=True)\n    mean_per_class_error = gbm.mean_per_class_error(train=False, valid=False, xval=False)\n    mean_per_class_error = gbm.mean_per_class_error(train=False, valid=True, xval=True)\n    iris = h2o.import_file(path=pyunit_utils.locate('smalldata/iris/iris.csv'))\n    from h2o.estimators.kmeans import H2OKMeansEstimator\n    km = H2OKMeansEstimator(k=3, nfolds=3)\n    km.train(x=list(range(4)), training_frame=iris)\n    betweenss1 = km.betweenss(train=True, valid=False, xval=False)\n    assert isinstance(betweenss1, float)\n    betweenss3 = km.betweenss(train=False, valid=False, xval=True)\n    assert isinstance(betweenss3, float)\n    betweenss = km.betweenss(train=True, valid=False, xval=True)\n    assert 'train' in list(betweenss.keys()) and 'xval' in list(betweenss.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(betweenss.keys()))\n    assert len(betweenss) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(betweenss.keys()))\n    assert isinstance(betweenss['train'], float) and isinstance(betweenss['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(betweenss['train']), type(betweenss['xval']))\n    assert betweenss['xval'] == betweenss3\n    betweenss = km.betweenss(train=False, valid=False, xval=False)\n    assert isinstance(betweenss, float)\n    assert betweenss == betweenss1\n    totss1 = km.totss(train=True, valid=False, xval=False)\n    assert isinstance(totss1, float)\n    totss3 = km.totss(train=False, valid=False, xval=True)\n    assert isinstance(totss3, float)\n    totss = km.totss(train=True, valid=False, xval=True)\n    assert 'train' in list(totss.keys()) and 'xval' in list(totss.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(totss.keys()))\n    assert len(totss) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(totss.keys()))\n    assert isinstance(totss['train'], float) and isinstance(totss['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(totss['train']), type(totss['xval']))\n    assert totss['xval'] == totss3\n    totss = km.totss(train=False, valid=False, xval=False)\n    assert isinstance(totss, float)\n    assert totss == totss1\n    tot_withinss1 = km.tot_withinss(train=True, valid=False, xval=False)\n    assert isinstance(tot_withinss1, float)\n    tot_withinss3 = km.tot_withinss(train=False, valid=False, xval=True)\n    assert isinstance(tot_withinss3, float)\n    tot_withinss = km.tot_withinss(train=True, valid=False, xval=True)\n    assert 'train' in list(tot_withinss.keys()) and 'xval' in list(tot_withinss.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(tot_withinss.keys()))\n    assert len(tot_withinss) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(tot_withinss.keys()))\n    assert isinstance(tot_withinss['train'], float) and isinstance(tot_withinss['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(tot_withinss['train']), type(tot_withinss['xval']))\n    assert tot_withinss['xval'] == tot_withinss3\n    tot_withinss = km.tot_withinss(train=False, valid=False, xval=False)\n    assert isinstance(tot_withinss, float)\n    assert tot_withinss == tot_withinss1\n    withinss1 = km.withinss(train=True, valid=False)\n    withinss2 = km.withinss(train=True, valid=True)\n    withinss3 = km.withinss(train=False, valid=False)\n    assert withinss1 == withinss3\n    assert withinss1 != withinss2\n    centroid_stats1 = km.centroid_stats(train=True, valid=False)\n    centroid_stats2 = km.centroid_stats(train=True, valid=True)\n    centroid_stats3 = km.centroid_stats(train=False, valid=False)\n    assert centroid_stats1 == centroid_stats3\n    assert centroid_stats1 != centroid_stats2\n    size1 = km.size(train=True, valid=False)\n    size2 = km.size(train=True, valid=True)\n    size3 = km.size(train=False, valid=False)\n    assert size1 == size3\n    assert size1 != size2",
            "def metric_accessors():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    cars = h2o.import_file(path=pyunit_utils.locate('smalldata/junit/cars_20mpg.csv'))\n    r = cars[0].runif()\n    train = cars[r > 0.2]\n    valid = cars[r <= 0.2]\n    response_col = 'economy'\n    distribution = 'gaussian'\n    predictors = ['displacement', 'power', 'weight', 'acceleration', 'year']\n    gbm = H2OGradientBoostingEstimator(nfolds=3, distribution=distribution, fold_assignment='Random')\n    gbm.train(x=predictors, y=response_col, training_frame=train, validation_frame=valid)\n    for metric in ['r2', 'mse', 'rmse', 'rmsle', 'mae']:\n        val = getattr(gbm, metric)()\n        assert isinstance(val, float), 'expected a float for metric {} but got {}'.format(metric, val)\n    mse1 = gbm.mse(train=True, valid=False, xval=False)\n    assert isinstance(mse1, float)\n    mse2 = gbm.mse(train=False, valid=True, xval=False)\n    assert isinstance(mse2, float)\n    mse3 = gbm.mse(train=False, valid=False, xval=True)\n    assert isinstance(mse3, float)\n    mse = gbm.mse(train=True, valid=True, xval=False)\n    assert 'train' in list(mse.keys()) and 'valid' in list(mse.keys()), 'expected training and validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert len(mse) == 2, 'expected only training and validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert isinstance(mse['train'], float) and isinstance(mse['valid'], float), 'expected training and validation metrics to be floats, but got {0} and {1}'.format(type(mse['train']), type(mse['valid']))\n    assert mse['valid'] == mse2\n    mse = gbm.mse(train=True, valid=False, xval=True)\n    assert 'train' in list(mse.keys()) and 'xval' in list(mse.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert len(mse) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert isinstance(mse['train'], float) and isinstance(mse['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(mse['train']), type(mse['xval']))\n    assert mse['xval'] == mse3\n    mse = gbm.mse(train=True, valid=True, xval=True)\n    assert 'train' in list(mse.keys()) and 'valid' in list(mse.keys()) and ('xval' in list(mse.keys())), 'expected training, validation, and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert len(mse) == 3, 'expected training, validation and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert isinstance(mse['train'], float) and isinstance(mse['valid'], float) and isinstance(mse['xval'], float), 'expected training, validation, and cross validation metrics to be floats, but got {0}, {1}, and {2}'.format(type(mse['train']), type(mse['valid']), type(mse['xval']))\n    mse = gbm.mse(train=False, valid=False, xval=False)\n    assert isinstance(mse, float)\n    assert mse == mse1\n    mse = gbm.mse(train=False, valid=True, xval=True)\n    assert 'valid' in list(mse.keys()) and 'xval' in list(mse.keys()), 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert len(mse) == 2, 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert isinstance(mse['valid'], float) and isinstance(mse['xval'], float), 'validation and cross validation metrics to be floats, but got {0} and {1}'.format(type(mse['valid']), type(mse['xval']))\n    mean_residual_deviance1 = gbm.mean_residual_deviance(train=True, valid=False, xval=False)\n    assert isinstance(mean_residual_deviance1, float)\n    mean_residual_deviance2 = gbm.mean_residual_deviance(train=False, valid=True, xval=False)\n    assert isinstance(mean_residual_deviance2, float)\n    mean_residual_deviance3 = gbm.mean_residual_deviance(train=False, valid=False, xval=True)\n    assert isinstance(mean_residual_deviance3, float)\n    mean_residual_deviance = gbm.mean_residual_deviance(train=True, valid=True, xval=False)\n    assert 'train' in list(mean_residual_deviance.keys()) and 'valid' in list(mean_residual_deviance.keys()), 'expected training and validation metrics to be returned, but got {0}'.format(list(mean_residual_deviance.keys()))\n    assert len(mean_residual_deviance) == 2, 'expected only training and validation metrics to be returned, but got {0}'.format(list(mean_residual_deviance.keys()))\n    assert isinstance(mean_residual_deviance['train'], float) and isinstance(mean_residual_deviance['valid'], float), 'expected training and validation metrics to be floats, but got {0} and {1}'.format(type(mean_residual_deviance['train']), type(mean_residual_deviance['valid']))\n    assert mean_residual_deviance['valid'] == mean_residual_deviance2\n    mean_residual_deviance = gbm.mean_residual_deviance(train=True, valid=False, xval=True)\n    assert 'train' in list(mean_residual_deviance.keys()) and 'xval' in list(mean_residual_deviance.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(mean_residual_deviance.keys()))\n    assert len(mean_residual_deviance) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(mean_residual_deviance.keys()))\n    assert isinstance(mean_residual_deviance['train'], float) and isinstance(mean_residual_deviance['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(mean_residual_deviance['train']), type(mean_residual_deviance['xval']))\n    assert mean_residual_deviance['xval'] == mean_residual_deviance3\n    mean_residual_deviance = gbm.mean_residual_deviance(train=True, valid=True, xval=True)\n    assert 'train' in list(mean_residual_deviance.keys()) and 'valid' in list(mean_residual_deviance.keys()) and ('xval' in list(mean_residual_deviance.keys())), 'expected training, validation, and cross validation metrics to be returned, but got {0}'.format(list(mean_residual_deviance.keys()))\n    assert len(mean_residual_deviance) == 3, 'expected training, validation and cross validation metrics to be returned, but got {0}'.format(list(mean_residual_deviance.keys()))\n    assert isinstance(mean_residual_deviance['train'], float) and isinstance(mean_residual_deviance['valid'], float) and isinstance(mean_residual_deviance['xval'], float), 'expected training, validation, and cross validation metrics to be floats, but got {0}, {1}, and {2}'.format(type(mean_residual_deviance['train']), type(mean_residual_deviance['valid']), type(mean_residual_deviance['xval']))\n    mean_residual_deviance = gbm.mean_residual_deviance(train=False, valid=False, xval=False)\n    assert isinstance(mean_residual_deviance, float)\n    assert mean_residual_deviance == mean_residual_deviance1\n    mean_residual_deviance = gbm.mean_residual_deviance(train=False, valid=True, xval=True)\n    assert 'valid' in list(mean_residual_deviance.keys()) and 'xval' in list(mean_residual_deviance.keys()), 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(mean_residual_deviance.keys()))\n    assert len(mean_residual_deviance) == 2, 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(mean_residual_deviance.keys()))\n    assert isinstance(mean_residual_deviance['valid'], float) and isinstance(mean_residual_deviance['xval'], float), 'validation and cross validation metrics to be floats, but got {0} and {1}'.format(type(mean_residual_deviance['valid']), type(mean_residual_deviance['xval']))\n    cars = h2o.import_file(path=pyunit_utils.locate('smalldata/junit/cars_20mpg.csv'))\n    cars['economy_20mpg'] = cars['economy_20mpg'].asfactor()\n    r = cars[0].runif()\n    train = cars[r > 0.2]\n    valid = cars[r <= 0.2]\n    response_col = 'economy_20mpg'\n    distribution = 'bernoulli'\n    predictors = ['displacement', 'power', 'weight', 'acceleration', 'year']\n    gbm = H2OGradientBoostingEstimator(nfolds=3, distribution=distribution, fold_assignment='Random')\n    gbm.train(y=response_col, x=predictors, validation_frame=valid, training_frame=train)\n    for metric in ['gini', 'logloss', 'auc', 'aucpr', 'mse', 'rmse']:\n        val = getattr(gbm, metric)()\n        assert isinstance(val, float), 'expected a float for metric {} but got {}'.format(metric, val)\n    for metric in ['mcc', 'F1', 'F0point5', 'F2', 'accuracy', 'mean_per_class_error']:\n        val = getattr(gbm, metric)()[0][1]\n        assert isinstance(val, float), 'expected a float for metric {} but got {}'.format(metric, val)\n    auc1 = gbm.auc(train=True, valid=False, xval=False)\n    assert isinstance(auc1, float)\n    auc2 = gbm.auc(train=False, valid=True, xval=False)\n    assert isinstance(auc2, float)\n    auc3 = gbm.auc(train=False, valid=False, xval=True)\n    assert isinstance(auc3, float)\n    auc = gbm.auc(train=True, valid=True, xval=False)\n    assert 'train' in list(auc.keys()) and 'valid' in list(auc.keys()), 'expected training and validation metrics to be returned, but got {0}'.format(list(auc.keys()))\n    assert len(auc) == 2, 'expected only training and validation metrics to be returned, but got {0}'.format(list(auc.keys()))\n    assert isinstance(auc['train'], float) and isinstance(auc['valid'], float), 'expected training and validation metrics to be floats, but got {0} and {1}'.format(type(auc['train']), type(auc['valid']))\n    assert auc['valid'] == auc2\n    auc = gbm.auc(train=True, valid=False, xval=True)\n    assert 'train' in list(auc.keys()) and 'xval' in list(auc.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(auc.keys()))\n    assert len(auc) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(auc.keys()))\n    assert isinstance(auc['train'], float) and isinstance(auc['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(auc['train']), type(auc['xval']))\n    assert auc['xval'] == auc3\n    auc = gbm.auc(train=True, valid=True, xval=True)\n    assert 'train' in list(auc.keys()) and 'valid' in list(auc.keys()) and ('xval' in list(auc.keys())), 'expected training, validation, and cross validation metrics to be returned, but got {0}'.format(list(auc.keys()))\n    assert len(auc) == 3, 'expected training, validation and cross validation metrics to be returned, but got {0}'.format(list(auc.keys()))\n    assert isinstance(auc['train'], float) and isinstance(auc['valid'], float) and isinstance(auc['xval'], float), 'expected training, validation, and cross validation metrics to be floats, but got {0}, {1}, and {2}'.format(type(auc['train']), type(auc['valid']), type(auc['xval']))\n    auc = gbm.auc(train=False, valid=False, xval=False)\n    assert isinstance(auc, float)\n    assert auc == auc1\n    auc = gbm.auc(train=False, valid=True, xval=True)\n    assert 'valid' in list(auc.keys()) and 'xval' in list(auc.keys()), 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(auc.keys()))\n    assert len(auc) == 2, 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(auc.keys()))\n    assert isinstance(auc['valid'], float) and isinstance(auc['xval'], float), 'validation and cross validation metrics to be floats, but got {0} and {1}'.format(type(auc['valid']), type(auc['xval']))\n    (fprs1, tprs1) = gbm.roc(train=True, valid=False, xval=False)\n    assert isinstance(fprs1, list)\n    assert isinstance(tprs1, list)\n    (fprs2, tprs2) = gbm.roc(train=False, valid=True, xval=False)\n    assert isinstance(fprs2, list)\n    assert isinstance(tprs2, list)\n    (fprs3, tprs3) = gbm.roc(train=False, valid=False, xval=True)\n    assert isinstance(fprs3, list)\n    assert isinstance(tprs3, list)\n    roc = gbm.roc(train=True, valid=True, xval=False)\n    assert 'train' in list(roc.keys()) and 'valid' in list(roc.keys()), 'expected training and validation metrics to be returned, but got {0}'.format(list(roc.keys()))\n    assert len(roc) == 2, 'expected only training and validation metrics to be returned, but got {0}'.format(list(roc.keys()))\n    assert isinstance(roc['train'], tuple) and isinstance(roc['valid'], tuple), 'expected training and validation metrics to be tuples, but got {0} and {1}'.format(type(roc['train']), type(roc['valid']))\n    assert roc['valid'][0] == fprs2\n    assert roc['valid'][1] == tprs2\n    roc = gbm.roc(train=True, valid=False, xval=True)\n    assert 'train' in list(roc.keys()) and 'xval' in list(roc.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(roc.keys()))\n    assert len(roc) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(roc.keys()))\n    assert isinstance(roc['train'], tuple) and isinstance(roc['xval'], tuple), 'expected training and cross validation metrics to be tuples, but got {0} and {1}'.format(type(roc['train']), type(roc['xval']))\n    assert roc['xval'][0] == fprs3\n    assert roc['xval'][1] == tprs3\n    roc = gbm.roc(train=True, valid=True, xval=True)\n    assert 'train' in list(roc.keys()) and 'valid' in list(roc.keys()) and ('xval' in list(roc.keys())), 'expected training, validation, and cross validation metrics to be returned, but got {0}'.format(list(roc.keys()))\n    assert len(roc) == 3, 'expected training, validation and cross validation metrics to be returned, but got {0}'.format(list(roc.keys()))\n    assert isinstance(roc['train'], tuple) and isinstance(roc['valid'], tuple) and isinstance(roc['xval'], tuple), 'expected training, validation, and cross validation metrics to be tuples, but got {0}, {1}, and {2}'.format(type(roc['train']), type(roc['valid']), type(roc['xval']))\n    (fprs, tprs) = gbm.roc(train=False, valid=False, xval=False)\n    assert isinstance(fprs, list)\n    assert isinstance(tprs, list)\n    assert fprs == fprs1\n    assert tprs == tprs1\n    roc = gbm.roc(train=False, valid=True, xval=True)\n    assert 'valid' in list(roc.keys()) and 'xval' in list(roc.keys()), 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(roc.keys()))\n    assert len(roc) == 2, 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(roc.keys()))\n    assert isinstance(roc['valid'], tuple) and isinstance(roc['xval'], tuple), 'validation and cross validation metrics to be tuples, but got {0} and {1}'.format(type(roc['valid']), type(roc['xval']))\n    logloss1 = gbm.logloss(train=True, valid=False, xval=False)\n    assert isinstance(logloss1, float)\n    logloss2 = gbm.logloss(train=False, valid=True, xval=False)\n    assert isinstance(logloss2, float)\n    logloss3 = gbm.logloss(train=False, valid=False, xval=True)\n    assert isinstance(logloss3, float)\n    logloss = gbm.logloss(train=True, valid=True, xval=False)\n    assert 'train' in list(logloss.keys()) and 'valid' in list(logloss.keys()), 'expected training and validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert len(logloss) == 2, 'expected only training and validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert isinstance(logloss['train'], float) and isinstance(logloss['valid'], float), 'expected training and validation metrics to be floats, but got {0} and {1}'.format(type(logloss['train']), type(logloss['valid']))\n    assert logloss['valid'] == logloss2\n    logloss = gbm.logloss(train=True, valid=False, xval=True)\n    assert 'train' in list(logloss.keys()) and 'xval' in list(logloss.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert len(logloss) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert isinstance(logloss['train'], float) and isinstance(logloss['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(logloss['train']), type(logloss['xval']))\n    assert logloss['xval'] == logloss3\n    logloss = gbm.logloss(train=True, valid=True, xval=True)\n    assert 'train' in list(logloss.keys()) and 'valid' in list(logloss.keys()) and ('xval' in list(logloss.keys())), 'expected training, validation, and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert len(logloss) == 3, 'expected training, validation and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert isinstance(logloss['train'], float) and isinstance(logloss['valid'], float) and isinstance(logloss['xval'], float), 'expected training, validation, and cross validation metrics to be floats, but got {0}, {1}, and {2}'.format(type(logloss['train']), type(logloss['valid']), type(logloss['xval']))\n    logloss = gbm.logloss(train=False, valid=False, xval=False)\n    assert isinstance(logloss, float)\n    assert logloss == logloss1\n    logloss = gbm.logloss(train=False, valid=True, xval=True)\n    assert 'valid' in list(logloss.keys()) and 'xval' in list(logloss.keys()), 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert len(logloss) == 2, 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert isinstance(logloss['valid'], float) and isinstance(logloss['xval'], float), 'validation and cross validation metrics to be floats, but got {0} and {1}'.format(type(logloss['valid']), type(logloss['xval']))\n    gini1 = gbm.gini(train=True, valid=False, xval=False)\n    assert isinstance(gini1, float)\n    gini2 = gbm.gini(train=False, valid=True, xval=False)\n    assert isinstance(gini2, float)\n    gini3 = gbm.gini(train=False, valid=False, xval=True)\n    assert isinstance(gini3, float)\n    gini = gbm.gini(train=True, valid=True, xval=False)\n    assert 'train' in list(gini.keys()) and 'valid' in list(gini.keys()), 'expected training and validation metrics to be returned, but got {0}'.format(list(gini.keys()))\n    assert len(gini) == 2, 'expected only training and validation metrics to be returned, but got {0}'.format(list(gini.keys()))\n    assert isinstance(gini['train'], float) and isinstance(gini['valid'], float), 'expected training and validation metrics to be floats, but got {0} and {1}'.format(type(gini['train']), type(gini['valid']))\n    assert gini['valid'] == gini2\n    gini = gbm.gini(train=True, valid=False, xval=True)\n    assert 'train' in list(gini.keys()) and 'xval' in list(gini.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(gini.keys()))\n    assert len(gini) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(gini.keys()))\n    assert isinstance(gini['train'], float) and isinstance(gini['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(gini['train']), type(gini['xval']))\n    assert gini['xval'] == gini3\n    gini = gbm.gini(train=True, valid=True, xval=True)\n    assert 'train' in list(gini.keys()) and 'valid' in list(gini.keys()) and ('xval' in list(gini.keys())), 'expected training, validation, and cross validation metrics to be returned, but got {0}'.format(list(gini.keys()))\n    assert len(gini) == 3, 'expected training, validation and cross validation metrics to be returned, but got {0}'.format(list(gini.keys()))\n    assert isinstance(gini['train'], float) and isinstance(gini['valid'], float) and isinstance(gini['xval'], float), 'expected training, validation, and cross validation metrics to be floats, but got {0}, {1}, and {2}'.format(type(gini['train']), type(gini['valid']), type(gini['xval']))\n    gini = gbm.gini(train=False, valid=False, xval=False)\n    assert isinstance(gini, float)\n    assert gini == gini1\n    gini = gbm.gini(train=False, valid=True, xval=True)\n    assert 'valid' in list(gini.keys()) and 'xval' in list(gini.keys()), 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(gini.keys()))\n    assert len(gini) == 2, 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(gini.keys()))\n    assert isinstance(gini['valid'], float) and isinstance(gini['xval'], float), 'validation and cross validation metrics to be floats, but got {0} and {1}'.format(type(gini['valid']), type(gini['xval']))\n    F11 = gbm.F1(train=True, valid=False, xval=False)\n    F12 = gbm.F1(train=False, valid=True, xval=False)\n    F13 = gbm.F1(train=False, valid=False, xval=True)\n    F1 = gbm.F1(train=True, valid=True, xval=False)\n    F1 = gbm.F1(train=True, valid=False, xval=True)\n    F1 = gbm.F1(train=True, valid=True, xval=True)\n    F1 = gbm.F1(train=False, valid=False, xval=False)\n    F1 = gbm.F1(train=False, valid=True, xval=True)\n    F0point51 = gbm.F0point5(train=True, valid=False, xval=False)\n    F0point52 = gbm.F0point5(train=False, valid=True, xval=False)\n    F0point53 = gbm.F0point5(train=False, valid=False, xval=True)\n    F0point5 = gbm.F0point5(train=True, valid=True, xval=False)\n    F0point5 = gbm.F0point5(train=True, valid=False, xval=True)\n    F0point5 = gbm.F0point5(train=True, valid=True, xval=True)\n    F0point5 = gbm.F0point5(train=False, valid=False, xval=False)\n    F0point5 = gbm.F0point5(train=False, valid=True, xval=True)\n    F21 = gbm.F2(train=True, valid=False, xval=False)\n    F22 = gbm.F2(train=False, valid=True, xval=False)\n    F23 = gbm.F2(train=False, valid=False, xval=True)\n    F2 = gbm.F2(train=True, valid=True, xval=False)\n    F2 = gbm.F2(train=True, valid=False, xval=True)\n    F2 = gbm.F2(train=True, valid=True, xval=True)\n    F2 = gbm.F2(train=False, valid=False, xval=False)\n    F2 = gbm.F2(train=False, valid=True, xval=True)\n    accuracy1 = gbm.accuracy(train=True, valid=False, xval=False)\n    accuracy2 = gbm.accuracy(train=False, valid=True, xval=False)\n    accuracy3 = gbm.accuracy(train=False, valid=False, xval=True)\n    accuracy = gbm.accuracy(train=True, valid=True, xval=False)\n    accuracy = gbm.accuracy(train=True, valid=False, xval=True)\n    accuracy = gbm.accuracy(train=True, valid=True, xval=True)\n    accuracy = gbm.accuracy(train=False, valid=False, xval=False)\n    accuracy = gbm.accuracy(train=False, valid=True, xval=True)\n    error1 = gbm.error(train=True, valid=False, xval=False)\n    error2 = gbm.error(train=False, valid=True, xval=False)\n    error3 = gbm.error(train=False, valid=False, xval=True)\n    error = gbm.error(train=True, valid=True, xval=False)\n    error = gbm.error(train=True, valid=False, xval=True)\n    error = gbm.error(train=True, valid=True, xval=True)\n    error = gbm.error(train=False, valid=False, xval=False)\n    error = gbm.error(train=False, valid=True, xval=True)\n    precision1 = gbm.precision(train=True, valid=False, xval=False)\n    precision2 = gbm.precision(train=False, valid=True, xval=False)\n    precision3 = gbm.precision(train=False, valid=False, xval=True)\n    precision = gbm.precision(train=True, valid=True, xval=False)\n    precision = gbm.precision(train=True, valid=False, xval=True)\n    precision = gbm.precision(train=True, valid=True, xval=True)\n    precision = gbm.precision(train=False, valid=False, xval=False)\n    precision = gbm.precision(train=False, valid=True, xval=True)\n    mcc1 = gbm.mcc(train=True, valid=False, xval=False)\n    mcc2 = gbm.mcc(train=False, valid=True, xval=False)\n    mcc3 = gbm.mcc(train=False, valid=False, xval=True)\n    mcc = gbm.mcc(train=True, valid=True, xval=False)\n    mcc = gbm.mcc(train=True, valid=False, xval=True)\n    mcc = gbm.mcc(train=True, valid=True, xval=True)\n    mcc = gbm.mcc(train=False, valid=False, xval=False)\n    mcc = gbm.mcc(train=False, valid=True, xval=True)\n    max_per_class_error1 = gbm.max_per_class_error(train=True, valid=False, xval=False)\n    max_per_class_error2 = gbm.max_per_class_error(train=False, valid=True, xval=False)\n    max_per_class_error3 = gbm.max_per_class_error(train=False, valid=False, xval=True)\n    max_per_class_error = gbm.max_per_class_error(train=True, valid=True, xval=False)\n    max_per_class_error = gbm.max_per_class_error(train=True, valid=False, xval=True)\n    max_per_class_error = gbm.max_per_class_error(train=True, valid=True, xval=True)\n    max_per_class_error = gbm.max_per_class_error(train=False, valid=False, xval=False)\n    max_per_class_error = gbm.max_per_class_error(train=False, valid=True, xval=True)\n    mean_per_class_error1 = gbm.mean_per_class_error(train=True, valid=False, xval=False)\n    mean_per_class_error2 = gbm.mean_per_class_error(train=False, valid=True, xval=False)\n    mean_per_class_error3 = gbm.mean_per_class_error(train=False, valid=False, xval=True)\n    mean_per_class_error = gbm.mean_per_class_error(train=True, valid=True, xval=False)\n    mean_per_class_error = gbm.mean_per_class_error(train=True, valid=False, xval=True)\n    mean_per_class_error = gbm.mean_per_class_error(train=True, valid=True, xval=True)\n    mean_per_class_error = gbm.mean_per_class_error(train=False, valid=False, xval=False)\n    mean_per_class_error = gbm.mean_per_class_error(train=False, valid=True, xval=True)\n    confusion_matrix1 = gbm.confusion_matrix(train=True, valid=False, xval=False)\n    confusion_matrix2 = gbm.confusion_matrix(train=False, valid=True, xval=False)\n    confusion_matrix3 = gbm.confusion_matrix(train=False, valid=False, xval=True)\n    confusion_matrix = gbm.confusion_matrix(train=True, valid=True, xval=False)\n    confusion_matrix = gbm.confusion_matrix(train=True, valid=False, xval=True)\n    confusion_matrix = gbm.confusion_matrix(train=True, valid=True, xval=True)\n    confusion_matrix = gbm.confusion_matrix(train=False, valid=False, xval=False)\n    confusion_matrix = gbm.confusion_matrix(train=False, valid=True, xval=True)\n    tpr1 = gbm.tpr(train=True, valid=False, xval=False)\n    tpr2 = gbm.tpr(train=False, valid=True, xval=False)\n    tpr3 = gbm.tpr(train=False, valid=False, xval=True)\n    tpr = gbm.tpr(train=True, valid=True, xval=False)\n    tpr = gbm.tpr(train=True, valid=False, xval=True)\n    tpr = gbm.tpr(train=True, valid=True, xval=True)\n    tpr = gbm.tpr(train=False, valid=False, xval=False)\n    tpr = gbm.tpr(train=False, valid=True, xval=True)\n    tnr1 = gbm.tnr(train=True, valid=False, xval=False)\n    tnr2 = gbm.tnr(train=False, valid=True, xval=False)\n    tnr3 = gbm.tnr(train=False, valid=False, xval=True)\n    tnr = gbm.tnr(train=True, valid=True, xval=False)\n    tnr = gbm.tnr(train=True, valid=False, xval=True)\n    tnr = gbm.tnr(train=True, valid=True, xval=True)\n    tnr = gbm.tnr(train=False, valid=False, xval=False)\n    tnr = gbm.tnr(train=False, valid=True, xval=True)\n    fnr1 = gbm.fnr(train=True, valid=False, xval=False)\n    fnr2 = gbm.fnr(train=False, valid=True, xval=False)\n    fnr3 = gbm.fnr(train=False, valid=False, xval=True)\n    fnr = gbm.fnr(train=True, valid=True, xval=False)\n    fnr = gbm.fnr(train=True, valid=False, xval=True)\n    fnr = gbm.fnr(train=True, valid=True, xval=True)\n    fnr = gbm.fnr(train=False, valid=False, xval=False)\n    fnr = gbm.fnr(train=False, valid=True, xval=True)\n    fpr1 = gbm.fpr(train=True, valid=False, xval=False)\n    fpr2 = gbm.fpr(train=False, valid=True, xval=False)\n    fpr3 = gbm.fpr(train=False, valid=False, xval=True)\n    fpr = gbm.fpr(train=True, valid=True, xval=False)\n    fpr = gbm.fpr(train=True, valid=False, xval=True)\n    fpr = gbm.fpr(train=True, valid=True, xval=True)\n    fpr = gbm.fpr(train=False, valid=False, xval=False)\n    fpr = gbm.fpr(train=False, valid=True, xval=True)\n    cars = h2o.import_file(path=pyunit_utils.locate('smalldata/junit/cars_20mpg.csv'))\n    cars['cylinders'] = cars['cylinders'].asfactor()\n    r = cars[0].runif()\n    train = cars[r > 0.2]\n    valid = cars[r <= 0.2]\n    response_col = 'cylinders'\n    distribution = 'multinomial'\n    predictors = ['displacement', 'power', 'weight', 'acceleration', 'year']\n    gbm = H2OGradientBoostingEstimator(nfolds=3, distribution=distribution, fold_assignment='Random')\n    gbm.train(x=predictors, y=response_col, training_frame=train, validation_frame=valid)\n    for metric in ['logloss', 'mse', 'rmse', 'mean_per_class_error']:\n        val = getattr(gbm, metric)()\n        assert isinstance(val, float), 'expected a float for metric {} but got {}'.format(metric, val)\n    mse1 = gbm.mse(train=True, valid=False, xval=False)\n    assert isinstance(mse1, float)\n    mse2 = gbm.mse(train=False, valid=True, xval=False)\n    assert isinstance(mse2, float)\n    mse3 = gbm.mse(train=False, valid=False, xval=True)\n    assert isinstance(mse3, float)\n    mse = gbm.mse(train=True, valid=True, xval=False)\n    assert 'train' in list(mse.keys()) and 'valid' in list(mse.keys()), 'expected training and validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert len(mse) == 2, 'expected only training and validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert isinstance(mse['train'], float) and isinstance(mse['valid'], float), 'expected training and validation metrics to be floats, but got {0} and {1}'.format(type(mse['train']), type(mse['valid']))\n    assert mse['valid'] == mse2\n    mse = gbm.mse(train=True, valid=False, xval=True)\n    assert 'train' in list(mse.keys()) and 'xval' in list(mse.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert len(mse) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert isinstance(mse['train'], float) and isinstance(mse['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(mse['train']), type(mse['xval']))\n    assert mse['xval'] == mse3\n    mse = gbm.mse(train=True, valid=True, xval=True)\n    assert 'train' in list(mse.keys()) and 'valid' in list(mse.keys()) and ('xval' in list(mse.keys())), 'expected training, validation, and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert len(mse) == 3, 'expected training, validation and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert isinstance(mse['train'], float) and isinstance(mse['valid'], float) and isinstance(mse['xval'], float), 'expected training, validation, and cross validation metrics to be floats, but got {0}, {1}, and {2}'.format(type(mse['train']), type(mse['valid']), type(mse['xval']))\n    mse = gbm.mse(train=False, valid=False, xval=False)\n    assert isinstance(mse, float)\n    assert mse == mse1\n    mse = gbm.mse(train=False, valid=True, xval=True)\n    assert 'valid' in list(mse.keys()) and 'xval' in list(mse.keys()), 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert len(mse) == 2, 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert isinstance(mse['valid'], float) and isinstance(mse['xval'], float), 'validation and cross validation metrics to be floats, but got {0} and {1}'.format(type(mse['valid']), type(mse['xval']))\n    logloss1 = gbm.logloss(train=True, valid=False, xval=False)\n    assert isinstance(logloss1, float)\n    logloss2 = gbm.logloss(train=False, valid=True, xval=False)\n    assert isinstance(logloss2, float)\n    logloss3 = gbm.logloss(train=False, valid=False, xval=True)\n    assert isinstance(logloss3, float)\n    logloss = gbm.logloss(train=True, valid=True, xval=False)\n    assert 'train' in list(logloss.keys()) and 'valid' in list(logloss.keys()), 'expected training and validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert len(logloss) == 2, 'expected only training and validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert isinstance(logloss['train'], float) and isinstance(logloss['valid'], float), 'expected training and validation metrics to be floats, but got {0} and {1}'.format(type(logloss['train']), type(logloss['valid']))\n    assert logloss['valid'] == logloss2\n    logloss = gbm.logloss(train=True, valid=False, xval=True)\n    assert 'train' in list(logloss.keys()) and 'xval' in list(logloss.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert len(logloss) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert isinstance(logloss['train'], float) and isinstance(logloss['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(logloss['train']), type(logloss['xval']))\n    assert logloss['xval'] == logloss3\n    logloss = gbm.logloss(train=True, valid=True, xval=True)\n    assert 'train' in list(logloss.keys()) and 'valid' in list(logloss.keys()) and ('xval' in list(logloss.keys())), 'expected training, validation, and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert len(logloss) == 3, 'expected training, validation and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert isinstance(logloss['train'], float) and isinstance(logloss['valid'], float) and isinstance(logloss['xval'], float), 'expected training, validation, and cross validation metrics to be floats, but got {0}, {1}, and {2}'.format(type(logloss['train']), type(logloss['valid']), type(logloss['xval']))\n    logloss = gbm.logloss(train=False, valid=False, xval=False)\n    assert isinstance(logloss, float)\n    assert logloss == logloss1\n    logloss = gbm.logloss(train=False, valid=True, xval=True)\n    assert 'valid' in list(logloss.keys()) and 'xval' in list(logloss.keys()), 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert len(logloss) == 2, 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert isinstance(logloss['valid'], float) and isinstance(logloss['xval'], float), 'validation and cross validation metrics to be floats, but got {0} and {1}'.format(type(logloss['valid']), type(logloss['xval']))\n    hit_ratio_table1 = gbm.hit_ratio_table(train=True, valid=False, xval=False)\n    hit_ratio_table2 = gbm.hit_ratio_table(train=False, valid=True, xval=False)\n    hit_ratio_table3 = gbm.hit_ratio_table(train=False, valid=False, xval=True)\n    hit_ratio_table = gbm.hit_ratio_table(train=True, valid=True, xval=False)\n    hit_ratio_table = gbm.hit_ratio_table(train=True, valid=False, xval=True)\n    hit_ratio_table = gbm.hit_ratio_table(train=True, valid=True, xval=True)\n    hit_ratio_table = gbm.hit_ratio_table(train=False, valid=False, xval=False)\n    hit_ratio_table = gbm.hit_ratio_table(train=False, valid=True, xval=True)\n    mean_per_class_error1 = gbm.mean_per_class_error(train=True, valid=False, xval=False)\n    mean_per_class_error2 = gbm.mean_per_class_error(train=False, valid=True, xval=False)\n    mean_per_class_error3 = gbm.mean_per_class_error(train=False, valid=False, xval=True)\n    mean_per_class_error = gbm.mean_per_class_error(train=True, valid=True, xval=False)\n    mean_per_class_error = gbm.mean_per_class_error(train=True, valid=False, xval=True)\n    mean_per_class_error = gbm.mean_per_class_error(train=True, valid=True, xval=True)\n    mean_per_class_error = gbm.mean_per_class_error(train=False, valid=False, xval=False)\n    mean_per_class_error = gbm.mean_per_class_error(train=False, valid=True, xval=True)\n    iris = h2o.import_file(path=pyunit_utils.locate('smalldata/iris/iris.csv'))\n    from h2o.estimators.kmeans import H2OKMeansEstimator\n    km = H2OKMeansEstimator(k=3, nfolds=3)\n    km.train(x=list(range(4)), training_frame=iris)\n    betweenss1 = km.betweenss(train=True, valid=False, xval=False)\n    assert isinstance(betweenss1, float)\n    betweenss3 = km.betweenss(train=False, valid=False, xval=True)\n    assert isinstance(betweenss3, float)\n    betweenss = km.betweenss(train=True, valid=False, xval=True)\n    assert 'train' in list(betweenss.keys()) and 'xval' in list(betweenss.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(betweenss.keys()))\n    assert len(betweenss) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(betweenss.keys()))\n    assert isinstance(betweenss['train'], float) and isinstance(betweenss['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(betweenss['train']), type(betweenss['xval']))\n    assert betweenss['xval'] == betweenss3\n    betweenss = km.betweenss(train=False, valid=False, xval=False)\n    assert isinstance(betweenss, float)\n    assert betweenss == betweenss1\n    totss1 = km.totss(train=True, valid=False, xval=False)\n    assert isinstance(totss1, float)\n    totss3 = km.totss(train=False, valid=False, xval=True)\n    assert isinstance(totss3, float)\n    totss = km.totss(train=True, valid=False, xval=True)\n    assert 'train' in list(totss.keys()) and 'xval' in list(totss.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(totss.keys()))\n    assert len(totss) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(totss.keys()))\n    assert isinstance(totss['train'], float) and isinstance(totss['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(totss['train']), type(totss['xval']))\n    assert totss['xval'] == totss3\n    totss = km.totss(train=False, valid=False, xval=False)\n    assert isinstance(totss, float)\n    assert totss == totss1\n    tot_withinss1 = km.tot_withinss(train=True, valid=False, xval=False)\n    assert isinstance(tot_withinss1, float)\n    tot_withinss3 = km.tot_withinss(train=False, valid=False, xval=True)\n    assert isinstance(tot_withinss3, float)\n    tot_withinss = km.tot_withinss(train=True, valid=False, xval=True)\n    assert 'train' in list(tot_withinss.keys()) and 'xval' in list(tot_withinss.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(tot_withinss.keys()))\n    assert len(tot_withinss) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(tot_withinss.keys()))\n    assert isinstance(tot_withinss['train'], float) and isinstance(tot_withinss['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(tot_withinss['train']), type(tot_withinss['xval']))\n    assert tot_withinss['xval'] == tot_withinss3\n    tot_withinss = km.tot_withinss(train=False, valid=False, xval=False)\n    assert isinstance(tot_withinss, float)\n    assert tot_withinss == tot_withinss1\n    withinss1 = km.withinss(train=True, valid=False)\n    withinss2 = km.withinss(train=True, valid=True)\n    withinss3 = km.withinss(train=False, valid=False)\n    assert withinss1 == withinss3\n    assert withinss1 != withinss2\n    centroid_stats1 = km.centroid_stats(train=True, valid=False)\n    centroid_stats2 = km.centroid_stats(train=True, valid=True)\n    centroid_stats3 = km.centroid_stats(train=False, valid=False)\n    assert centroid_stats1 == centroid_stats3\n    assert centroid_stats1 != centroid_stats2\n    size1 = km.size(train=True, valid=False)\n    size2 = km.size(train=True, valid=True)\n    size3 = km.size(train=False, valid=False)\n    assert size1 == size3\n    assert size1 != size2",
            "def metric_accessors():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    cars = h2o.import_file(path=pyunit_utils.locate('smalldata/junit/cars_20mpg.csv'))\n    r = cars[0].runif()\n    train = cars[r > 0.2]\n    valid = cars[r <= 0.2]\n    response_col = 'economy'\n    distribution = 'gaussian'\n    predictors = ['displacement', 'power', 'weight', 'acceleration', 'year']\n    gbm = H2OGradientBoostingEstimator(nfolds=3, distribution=distribution, fold_assignment='Random')\n    gbm.train(x=predictors, y=response_col, training_frame=train, validation_frame=valid)\n    for metric in ['r2', 'mse', 'rmse', 'rmsle', 'mae']:\n        val = getattr(gbm, metric)()\n        assert isinstance(val, float), 'expected a float for metric {} but got {}'.format(metric, val)\n    mse1 = gbm.mse(train=True, valid=False, xval=False)\n    assert isinstance(mse1, float)\n    mse2 = gbm.mse(train=False, valid=True, xval=False)\n    assert isinstance(mse2, float)\n    mse3 = gbm.mse(train=False, valid=False, xval=True)\n    assert isinstance(mse3, float)\n    mse = gbm.mse(train=True, valid=True, xval=False)\n    assert 'train' in list(mse.keys()) and 'valid' in list(mse.keys()), 'expected training and validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert len(mse) == 2, 'expected only training and validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert isinstance(mse['train'], float) and isinstance(mse['valid'], float), 'expected training and validation metrics to be floats, but got {0} and {1}'.format(type(mse['train']), type(mse['valid']))\n    assert mse['valid'] == mse2\n    mse = gbm.mse(train=True, valid=False, xval=True)\n    assert 'train' in list(mse.keys()) and 'xval' in list(mse.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert len(mse) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert isinstance(mse['train'], float) and isinstance(mse['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(mse['train']), type(mse['xval']))\n    assert mse['xval'] == mse3\n    mse = gbm.mse(train=True, valid=True, xval=True)\n    assert 'train' in list(mse.keys()) and 'valid' in list(mse.keys()) and ('xval' in list(mse.keys())), 'expected training, validation, and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert len(mse) == 3, 'expected training, validation and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert isinstance(mse['train'], float) and isinstance(mse['valid'], float) and isinstance(mse['xval'], float), 'expected training, validation, and cross validation metrics to be floats, but got {0}, {1}, and {2}'.format(type(mse['train']), type(mse['valid']), type(mse['xval']))\n    mse = gbm.mse(train=False, valid=False, xval=False)\n    assert isinstance(mse, float)\n    assert mse == mse1\n    mse = gbm.mse(train=False, valid=True, xval=True)\n    assert 'valid' in list(mse.keys()) and 'xval' in list(mse.keys()), 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert len(mse) == 2, 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert isinstance(mse['valid'], float) and isinstance(mse['xval'], float), 'validation and cross validation metrics to be floats, but got {0} and {1}'.format(type(mse['valid']), type(mse['xval']))\n    mean_residual_deviance1 = gbm.mean_residual_deviance(train=True, valid=False, xval=False)\n    assert isinstance(mean_residual_deviance1, float)\n    mean_residual_deviance2 = gbm.mean_residual_deviance(train=False, valid=True, xval=False)\n    assert isinstance(mean_residual_deviance2, float)\n    mean_residual_deviance3 = gbm.mean_residual_deviance(train=False, valid=False, xval=True)\n    assert isinstance(mean_residual_deviance3, float)\n    mean_residual_deviance = gbm.mean_residual_deviance(train=True, valid=True, xval=False)\n    assert 'train' in list(mean_residual_deviance.keys()) and 'valid' in list(mean_residual_deviance.keys()), 'expected training and validation metrics to be returned, but got {0}'.format(list(mean_residual_deviance.keys()))\n    assert len(mean_residual_deviance) == 2, 'expected only training and validation metrics to be returned, but got {0}'.format(list(mean_residual_deviance.keys()))\n    assert isinstance(mean_residual_deviance['train'], float) and isinstance(mean_residual_deviance['valid'], float), 'expected training and validation metrics to be floats, but got {0} and {1}'.format(type(mean_residual_deviance['train']), type(mean_residual_deviance['valid']))\n    assert mean_residual_deviance['valid'] == mean_residual_deviance2\n    mean_residual_deviance = gbm.mean_residual_deviance(train=True, valid=False, xval=True)\n    assert 'train' in list(mean_residual_deviance.keys()) and 'xval' in list(mean_residual_deviance.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(mean_residual_deviance.keys()))\n    assert len(mean_residual_deviance) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(mean_residual_deviance.keys()))\n    assert isinstance(mean_residual_deviance['train'], float) and isinstance(mean_residual_deviance['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(mean_residual_deviance['train']), type(mean_residual_deviance['xval']))\n    assert mean_residual_deviance['xval'] == mean_residual_deviance3\n    mean_residual_deviance = gbm.mean_residual_deviance(train=True, valid=True, xval=True)\n    assert 'train' in list(mean_residual_deviance.keys()) and 'valid' in list(mean_residual_deviance.keys()) and ('xval' in list(mean_residual_deviance.keys())), 'expected training, validation, and cross validation metrics to be returned, but got {0}'.format(list(mean_residual_deviance.keys()))\n    assert len(mean_residual_deviance) == 3, 'expected training, validation and cross validation metrics to be returned, but got {0}'.format(list(mean_residual_deviance.keys()))\n    assert isinstance(mean_residual_deviance['train'], float) and isinstance(mean_residual_deviance['valid'], float) and isinstance(mean_residual_deviance['xval'], float), 'expected training, validation, and cross validation metrics to be floats, but got {0}, {1}, and {2}'.format(type(mean_residual_deviance['train']), type(mean_residual_deviance['valid']), type(mean_residual_deviance['xval']))\n    mean_residual_deviance = gbm.mean_residual_deviance(train=False, valid=False, xval=False)\n    assert isinstance(mean_residual_deviance, float)\n    assert mean_residual_deviance == mean_residual_deviance1\n    mean_residual_deviance = gbm.mean_residual_deviance(train=False, valid=True, xval=True)\n    assert 'valid' in list(mean_residual_deviance.keys()) and 'xval' in list(mean_residual_deviance.keys()), 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(mean_residual_deviance.keys()))\n    assert len(mean_residual_deviance) == 2, 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(mean_residual_deviance.keys()))\n    assert isinstance(mean_residual_deviance['valid'], float) and isinstance(mean_residual_deviance['xval'], float), 'validation and cross validation metrics to be floats, but got {0} and {1}'.format(type(mean_residual_deviance['valid']), type(mean_residual_deviance['xval']))\n    cars = h2o.import_file(path=pyunit_utils.locate('smalldata/junit/cars_20mpg.csv'))\n    cars['economy_20mpg'] = cars['economy_20mpg'].asfactor()\n    r = cars[0].runif()\n    train = cars[r > 0.2]\n    valid = cars[r <= 0.2]\n    response_col = 'economy_20mpg'\n    distribution = 'bernoulli'\n    predictors = ['displacement', 'power', 'weight', 'acceleration', 'year']\n    gbm = H2OGradientBoostingEstimator(nfolds=3, distribution=distribution, fold_assignment='Random')\n    gbm.train(y=response_col, x=predictors, validation_frame=valid, training_frame=train)\n    for metric in ['gini', 'logloss', 'auc', 'aucpr', 'mse', 'rmse']:\n        val = getattr(gbm, metric)()\n        assert isinstance(val, float), 'expected a float for metric {} but got {}'.format(metric, val)\n    for metric in ['mcc', 'F1', 'F0point5', 'F2', 'accuracy', 'mean_per_class_error']:\n        val = getattr(gbm, metric)()[0][1]\n        assert isinstance(val, float), 'expected a float for metric {} but got {}'.format(metric, val)\n    auc1 = gbm.auc(train=True, valid=False, xval=False)\n    assert isinstance(auc1, float)\n    auc2 = gbm.auc(train=False, valid=True, xval=False)\n    assert isinstance(auc2, float)\n    auc3 = gbm.auc(train=False, valid=False, xval=True)\n    assert isinstance(auc3, float)\n    auc = gbm.auc(train=True, valid=True, xval=False)\n    assert 'train' in list(auc.keys()) and 'valid' in list(auc.keys()), 'expected training and validation metrics to be returned, but got {0}'.format(list(auc.keys()))\n    assert len(auc) == 2, 'expected only training and validation metrics to be returned, but got {0}'.format(list(auc.keys()))\n    assert isinstance(auc['train'], float) and isinstance(auc['valid'], float), 'expected training and validation metrics to be floats, but got {0} and {1}'.format(type(auc['train']), type(auc['valid']))\n    assert auc['valid'] == auc2\n    auc = gbm.auc(train=True, valid=False, xval=True)\n    assert 'train' in list(auc.keys()) and 'xval' in list(auc.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(auc.keys()))\n    assert len(auc) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(auc.keys()))\n    assert isinstance(auc['train'], float) and isinstance(auc['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(auc['train']), type(auc['xval']))\n    assert auc['xval'] == auc3\n    auc = gbm.auc(train=True, valid=True, xval=True)\n    assert 'train' in list(auc.keys()) and 'valid' in list(auc.keys()) and ('xval' in list(auc.keys())), 'expected training, validation, and cross validation metrics to be returned, but got {0}'.format(list(auc.keys()))\n    assert len(auc) == 3, 'expected training, validation and cross validation metrics to be returned, but got {0}'.format(list(auc.keys()))\n    assert isinstance(auc['train'], float) and isinstance(auc['valid'], float) and isinstance(auc['xval'], float), 'expected training, validation, and cross validation metrics to be floats, but got {0}, {1}, and {2}'.format(type(auc['train']), type(auc['valid']), type(auc['xval']))\n    auc = gbm.auc(train=False, valid=False, xval=False)\n    assert isinstance(auc, float)\n    assert auc == auc1\n    auc = gbm.auc(train=False, valid=True, xval=True)\n    assert 'valid' in list(auc.keys()) and 'xval' in list(auc.keys()), 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(auc.keys()))\n    assert len(auc) == 2, 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(auc.keys()))\n    assert isinstance(auc['valid'], float) and isinstance(auc['xval'], float), 'validation and cross validation metrics to be floats, but got {0} and {1}'.format(type(auc['valid']), type(auc['xval']))\n    (fprs1, tprs1) = gbm.roc(train=True, valid=False, xval=False)\n    assert isinstance(fprs1, list)\n    assert isinstance(tprs1, list)\n    (fprs2, tprs2) = gbm.roc(train=False, valid=True, xval=False)\n    assert isinstance(fprs2, list)\n    assert isinstance(tprs2, list)\n    (fprs3, tprs3) = gbm.roc(train=False, valid=False, xval=True)\n    assert isinstance(fprs3, list)\n    assert isinstance(tprs3, list)\n    roc = gbm.roc(train=True, valid=True, xval=False)\n    assert 'train' in list(roc.keys()) and 'valid' in list(roc.keys()), 'expected training and validation metrics to be returned, but got {0}'.format(list(roc.keys()))\n    assert len(roc) == 2, 'expected only training and validation metrics to be returned, but got {0}'.format(list(roc.keys()))\n    assert isinstance(roc['train'], tuple) and isinstance(roc['valid'], tuple), 'expected training and validation metrics to be tuples, but got {0} and {1}'.format(type(roc['train']), type(roc['valid']))\n    assert roc['valid'][0] == fprs2\n    assert roc['valid'][1] == tprs2\n    roc = gbm.roc(train=True, valid=False, xval=True)\n    assert 'train' in list(roc.keys()) and 'xval' in list(roc.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(roc.keys()))\n    assert len(roc) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(roc.keys()))\n    assert isinstance(roc['train'], tuple) and isinstance(roc['xval'], tuple), 'expected training and cross validation metrics to be tuples, but got {0} and {1}'.format(type(roc['train']), type(roc['xval']))\n    assert roc['xval'][0] == fprs3\n    assert roc['xval'][1] == tprs3\n    roc = gbm.roc(train=True, valid=True, xval=True)\n    assert 'train' in list(roc.keys()) and 'valid' in list(roc.keys()) and ('xval' in list(roc.keys())), 'expected training, validation, and cross validation metrics to be returned, but got {0}'.format(list(roc.keys()))\n    assert len(roc) == 3, 'expected training, validation and cross validation metrics to be returned, but got {0}'.format(list(roc.keys()))\n    assert isinstance(roc['train'], tuple) and isinstance(roc['valid'], tuple) and isinstance(roc['xval'], tuple), 'expected training, validation, and cross validation metrics to be tuples, but got {0}, {1}, and {2}'.format(type(roc['train']), type(roc['valid']), type(roc['xval']))\n    (fprs, tprs) = gbm.roc(train=False, valid=False, xval=False)\n    assert isinstance(fprs, list)\n    assert isinstance(tprs, list)\n    assert fprs == fprs1\n    assert tprs == tprs1\n    roc = gbm.roc(train=False, valid=True, xval=True)\n    assert 'valid' in list(roc.keys()) and 'xval' in list(roc.keys()), 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(roc.keys()))\n    assert len(roc) == 2, 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(roc.keys()))\n    assert isinstance(roc['valid'], tuple) and isinstance(roc['xval'], tuple), 'validation and cross validation metrics to be tuples, but got {0} and {1}'.format(type(roc['valid']), type(roc['xval']))\n    logloss1 = gbm.logloss(train=True, valid=False, xval=False)\n    assert isinstance(logloss1, float)\n    logloss2 = gbm.logloss(train=False, valid=True, xval=False)\n    assert isinstance(logloss2, float)\n    logloss3 = gbm.logloss(train=False, valid=False, xval=True)\n    assert isinstance(logloss3, float)\n    logloss = gbm.logloss(train=True, valid=True, xval=False)\n    assert 'train' in list(logloss.keys()) and 'valid' in list(logloss.keys()), 'expected training and validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert len(logloss) == 2, 'expected only training and validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert isinstance(logloss['train'], float) and isinstance(logloss['valid'], float), 'expected training and validation metrics to be floats, but got {0} and {1}'.format(type(logloss['train']), type(logloss['valid']))\n    assert logloss['valid'] == logloss2\n    logloss = gbm.logloss(train=True, valid=False, xval=True)\n    assert 'train' in list(logloss.keys()) and 'xval' in list(logloss.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert len(logloss) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert isinstance(logloss['train'], float) and isinstance(logloss['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(logloss['train']), type(logloss['xval']))\n    assert logloss['xval'] == logloss3\n    logloss = gbm.logloss(train=True, valid=True, xval=True)\n    assert 'train' in list(logloss.keys()) and 'valid' in list(logloss.keys()) and ('xval' in list(logloss.keys())), 'expected training, validation, and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert len(logloss) == 3, 'expected training, validation and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert isinstance(logloss['train'], float) and isinstance(logloss['valid'], float) and isinstance(logloss['xval'], float), 'expected training, validation, and cross validation metrics to be floats, but got {0}, {1}, and {2}'.format(type(logloss['train']), type(logloss['valid']), type(logloss['xval']))\n    logloss = gbm.logloss(train=False, valid=False, xval=False)\n    assert isinstance(logloss, float)\n    assert logloss == logloss1\n    logloss = gbm.logloss(train=False, valid=True, xval=True)\n    assert 'valid' in list(logloss.keys()) and 'xval' in list(logloss.keys()), 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert len(logloss) == 2, 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert isinstance(logloss['valid'], float) and isinstance(logloss['xval'], float), 'validation and cross validation metrics to be floats, but got {0} and {1}'.format(type(logloss['valid']), type(logloss['xval']))\n    gini1 = gbm.gini(train=True, valid=False, xval=False)\n    assert isinstance(gini1, float)\n    gini2 = gbm.gini(train=False, valid=True, xval=False)\n    assert isinstance(gini2, float)\n    gini3 = gbm.gini(train=False, valid=False, xval=True)\n    assert isinstance(gini3, float)\n    gini = gbm.gini(train=True, valid=True, xval=False)\n    assert 'train' in list(gini.keys()) and 'valid' in list(gini.keys()), 'expected training and validation metrics to be returned, but got {0}'.format(list(gini.keys()))\n    assert len(gini) == 2, 'expected only training and validation metrics to be returned, but got {0}'.format(list(gini.keys()))\n    assert isinstance(gini['train'], float) and isinstance(gini['valid'], float), 'expected training and validation metrics to be floats, but got {0} and {1}'.format(type(gini['train']), type(gini['valid']))\n    assert gini['valid'] == gini2\n    gini = gbm.gini(train=True, valid=False, xval=True)\n    assert 'train' in list(gini.keys()) and 'xval' in list(gini.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(gini.keys()))\n    assert len(gini) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(gini.keys()))\n    assert isinstance(gini['train'], float) and isinstance(gini['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(gini['train']), type(gini['xval']))\n    assert gini['xval'] == gini3\n    gini = gbm.gini(train=True, valid=True, xval=True)\n    assert 'train' in list(gini.keys()) and 'valid' in list(gini.keys()) and ('xval' in list(gini.keys())), 'expected training, validation, and cross validation metrics to be returned, but got {0}'.format(list(gini.keys()))\n    assert len(gini) == 3, 'expected training, validation and cross validation metrics to be returned, but got {0}'.format(list(gini.keys()))\n    assert isinstance(gini['train'], float) and isinstance(gini['valid'], float) and isinstance(gini['xval'], float), 'expected training, validation, and cross validation metrics to be floats, but got {0}, {1}, and {2}'.format(type(gini['train']), type(gini['valid']), type(gini['xval']))\n    gini = gbm.gini(train=False, valid=False, xval=False)\n    assert isinstance(gini, float)\n    assert gini == gini1\n    gini = gbm.gini(train=False, valid=True, xval=True)\n    assert 'valid' in list(gini.keys()) and 'xval' in list(gini.keys()), 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(gini.keys()))\n    assert len(gini) == 2, 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(gini.keys()))\n    assert isinstance(gini['valid'], float) and isinstance(gini['xval'], float), 'validation and cross validation metrics to be floats, but got {0} and {1}'.format(type(gini['valid']), type(gini['xval']))\n    F11 = gbm.F1(train=True, valid=False, xval=False)\n    F12 = gbm.F1(train=False, valid=True, xval=False)\n    F13 = gbm.F1(train=False, valid=False, xval=True)\n    F1 = gbm.F1(train=True, valid=True, xval=False)\n    F1 = gbm.F1(train=True, valid=False, xval=True)\n    F1 = gbm.F1(train=True, valid=True, xval=True)\n    F1 = gbm.F1(train=False, valid=False, xval=False)\n    F1 = gbm.F1(train=False, valid=True, xval=True)\n    F0point51 = gbm.F0point5(train=True, valid=False, xval=False)\n    F0point52 = gbm.F0point5(train=False, valid=True, xval=False)\n    F0point53 = gbm.F0point5(train=False, valid=False, xval=True)\n    F0point5 = gbm.F0point5(train=True, valid=True, xval=False)\n    F0point5 = gbm.F0point5(train=True, valid=False, xval=True)\n    F0point5 = gbm.F0point5(train=True, valid=True, xval=True)\n    F0point5 = gbm.F0point5(train=False, valid=False, xval=False)\n    F0point5 = gbm.F0point5(train=False, valid=True, xval=True)\n    F21 = gbm.F2(train=True, valid=False, xval=False)\n    F22 = gbm.F2(train=False, valid=True, xval=False)\n    F23 = gbm.F2(train=False, valid=False, xval=True)\n    F2 = gbm.F2(train=True, valid=True, xval=False)\n    F2 = gbm.F2(train=True, valid=False, xval=True)\n    F2 = gbm.F2(train=True, valid=True, xval=True)\n    F2 = gbm.F2(train=False, valid=False, xval=False)\n    F2 = gbm.F2(train=False, valid=True, xval=True)\n    accuracy1 = gbm.accuracy(train=True, valid=False, xval=False)\n    accuracy2 = gbm.accuracy(train=False, valid=True, xval=False)\n    accuracy3 = gbm.accuracy(train=False, valid=False, xval=True)\n    accuracy = gbm.accuracy(train=True, valid=True, xval=False)\n    accuracy = gbm.accuracy(train=True, valid=False, xval=True)\n    accuracy = gbm.accuracy(train=True, valid=True, xval=True)\n    accuracy = gbm.accuracy(train=False, valid=False, xval=False)\n    accuracy = gbm.accuracy(train=False, valid=True, xval=True)\n    error1 = gbm.error(train=True, valid=False, xval=False)\n    error2 = gbm.error(train=False, valid=True, xval=False)\n    error3 = gbm.error(train=False, valid=False, xval=True)\n    error = gbm.error(train=True, valid=True, xval=False)\n    error = gbm.error(train=True, valid=False, xval=True)\n    error = gbm.error(train=True, valid=True, xval=True)\n    error = gbm.error(train=False, valid=False, xval=False)\n    error = gbm.error(train=False, valid=True, xval=True)\n    precision1 = gbm.precision(train=True, valid=False, xval=False)\n    precision2 = gbm.precision(train=False, valid=True, xval=False)\n    precision3 = gbm.precision(train=False, valid=False, xval=True)\n    precision = gbm.precision(train=True, valid=True, xval=False)\n    precision = gbm.precision(train=True, valid=False, xval=True)\n    precision = gbm.precision(train=True, valid=True, xval=True)\n    precision = gbm.precision(train=False, valid=False, xval=False)\n    precision = gbm.precision(train=False, valid=True, xval=True)\n    mcc1 = gbm.mcc(train=True, valid=False, xval=False)\n    mcc2 = gbm.mcc(train=False, valid=True, xval=False)\n    mcc3 = gbm.mcc(train=False, valid=False, xval=True)\n    mcc = gbm.mcc(train=True, valid=True, xval=False)\n    mcc = gbm.mcc(train=True, valid=False, xval=True)\n    mcc = gbm.mcc(train=True, valid=True, xval=True)\n    mcc = gbm.mcc(train=False, valid=False, xval=False)\n    mcc = gbm.mcc(train=False, valid=True, xval=True)\n    max_per_class_error1 = gbm.max_per_class_error(train=True, valid=False, xval=False)\n    max_per_class_error2 = gbm.max_per_class_error(train=False, valid=True, xval=False)\n    max_per_class_error3 = gbm.max_per_class_error(train=False, valid=False, xval=True)\n    max_per_class_error = gbm.max_per_class_error(train=True, valid=True, xval=False)\n    max_per_class_error = gbm.max_per_class_error(train=True, valid=False, xval=True)\n    max_per_class_error = gbm.max_per_class_error(train=True, valid=True, xval=True)\n    max_per_class_error = gbm.max_per_class_error(train=False, valid=False, xval=False)\n    max_per_class_error = gbm.max_per_class_error(train=False, valid=True, xval=True)\n    mean_per_class_error1 = gbm.mean_per_class_error(train=True, valid=False, xval=False)\n    mean_per_class_error2 = gbm.mean_per_class_error(train=False, valid=True, xval=False)\n    mean_per_class_error3 = gbm.mean_per_class_error(train=False, valid=False, xval=True)\n    mean_per_class_error = gbm.mean_per_class_error(train=True, valid=True, xval=False)\n    mean_per_class_error = gbm.mean_per_class_error(train=True, valid=False, xval=True)\n    mean_per_class_error = gbm.mean_per_class_error(train=True, valid=True, xval=True)\n    mean_per_class_error = gbm.mean_per_class_error(train=False, valid=False, xval=False)\n    mean_per_class_error = gbm.mean_per_class_error(train=False, valid=True, xval=True)\n    confusion_matrix1 = gbm.confusion_matrix(train=True, valid=False, xval=False)\n    confusion_matrix2 = gbm.confusion_matrix(train=False, valid=True, xval=False)\n    confusion_matrix3 = gbm.confusion_matrix(train=False, valid=False, xval=True)\n    confusion_matrix = gbm.confusion_matrix(train=True, valid=True, xval=False)\n    confusion_matrix = gbm.confusion_matrix(train=True, valid=False, xval=True)\n    confusion_matrix = gbm.confusion_matrix(train=True, valid=True, xval=True)\n    confusion_matrix = gbm.confusion_matrix(train=False, valid=False, xval=False)\n    confusion_matrix = gbm.confusion_matrix(train=False, valid=True, xval=True)\n    tpr1 = gbm.tpr(train=True, valid=False, xval=False)\n    tpr2 = gbm.tpr(train=False, valid=True, xval=False)\n    tpr3 = gbm.tpr(train=False, valid=False, xval=True)\n    tpr = gbm.tpr(train=True, valid=True, xval=False)\n    tpr = gbm.tpr(train=True, valid=False, xval=True)\n    tpr = gbm.tpr(train=True, valid=True, xval=True)\n    tpr = gbm.tpr(train=False, valid=False, xval=False)\n    tpr = gbm.tpr(train=False, valid=True, xval=True)\n    tnr1 = gbm.tnr(train=True, valid=False, xval=False)\n    tnr2 = gbm.tnr(train=False, valid=True, xval=False)\n    tnr3 = gbm.tnr(train=False, valid=False, xval=True)\n    tnr = gbm.tnr(train=True, valid=True, xval=False)\n    tnr = gbm.tnr(train=True, valid=False, xval=True)\n    tnr = gbm.tnr(train=True, valid=True, xval=True)\n    tnr = gbm.tnr(train=False, valid=False, xval=False)\n    tnr = gbm.tnr(train=False, valid=True, xval=True)\n    fnr1 = gbm.fnr(train=True, valid=False, xval=False)\n    fnr2 = gbm.fnr(train=False, valid=True, xval=False)\n    fnr3 = gbm.fnr(train=False, valid=False, xval=True)\n    fnr = gbm.fnr(train=True, valid=True, xval=False)\n    fnr = gbm.fnr(train=True, valid=False, xval=True)\n    fnr = gbm.fnr(train=True, valid=True, xval=True)\n    fnr = gbm.fnr(train=False, valid=False, xval=False)\n    fnr = gbm.fnr(train=False, valid=True, xval=True)\n    fpr1 = gbm.fpr(train=True, valid=False, xval=False)\n    fpr2 = gbm.fpr(train=False, valid=True, xval=False)\n    fpr3 = gbm.fpr(train=False, valid=False, xval=True)\n    fpr = gbm.fpr(train=True, valid=True, xval=False)\n    fpr = gbm.fpr(train=True, valid=False, xval=True)\n    fpr = gbm.fpr(train=True, valid=True, xval=True)\n    fpr = gbm.fpr(train=False, valid=False, xval=False)\n    fpr = gbm.fpr(train=False, valid=True, xval=True)\n    cars = h2o.import_file(path=pyunit_utils.locate('smalldata/junit/cars_20mpg.csv'))\n    cars['cylinders'] = cars['cylinders'].asfactor()\n    r = cars[0].runif()\n    train = cars[r > 0.2]\n    valid = cars[r <= 0.2]\n    response_col = 'cylinders'\n    distribution = 'multinomial'\n    predictors = ['displacement', 'power', 'weight', 'acceleration', 'year']\n    gbm = H2OGradientBoostingEstimator(nfolds=3, distribution=distribution, fold_assignment='Random')\n    gbm.train(x=predictors, y=response_col, training_frame=train, validation_frame=valid)\n    for metric in ['logloss', 'mse', 'rmse', 'mean_per_class_error']:\n        val = getattr(gbm, metric)()\n        assert isinstance(val, float), 'expected a float for metric {} but got {}'.format(metric, val)\n    mse1 = gbm.mse(train=True, valid=False, xval=False)\n    assert isinstance(mse1, float)\n    mse2 = gbm.mse(train=False, valid=True, xval=False)\n    assert isinstance(mse2, float)\n    mse3 = gbm.mse(train=False, valid=False, xval=True)\n    assert isinstance(mse3, float)\n    mse = gbm.mse(train=True, valid=True, xval=False)\n    assert 'train' in list(mse.keys()) and 'valid' in list(mse.keys()), 'expected training and validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert len(mse) == 2, 'expected only training and validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert isinstance(mse['train'], float) and isinstance(mse['valid'], float), 'expected training and validation metrics to be floats, but got {0} and {1}'.format(type(mse['train']), type(mse['valid']))\n    assert mse['valid'] == mse2\n    mse = gbm.mse(train=True, valid=False, xval=True)\n    assert 'train' in list(mse.keys()) and 'xval' in list(mse.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert len(mse) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert isinstance(mse['train'], float) and isinstance(mse['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(mse['train']), type(mse['xval']))\n    assert mse['xval'] == mse3\n    mse = gbm.mse(train=True, valid=True, xval=True)\n    assert 'train' in list(mse.keys()) and 'valid' in list(mse.keys()) and ('xval' in list(mse.keys())), 'expected training, validation, and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert len(mse) == 3, 'expected training, validation and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert isinstance(mse['train'], float) and isinstance(mse['valid'], float) and isinstance(mse['xval'], float), 'expected training, validation, and cross validation metrics to be floats, but got {0}, {1}, and {2}'.format(type(mse['train']), type(mse['valid']), type(mse['xval']))\n    mse = gbm.mse(train=False, valid=False, xval=False)\n    assert isinstance(mse, float)\n    assert mse == mse1\n    mse = gbm.mse(train=False, valid=True, xval=True)\n    assert 'valid' in list(mse.keys()) and 'xval' in list(mse.keys()), 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert len(mse) == 2, 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert isinstance(mse['valid'], float) and isinstance(mse['xval'], float), 'validation and cross validation metrics to be floats, but got {0} and {1}'.format(type(mse['valid']), type(mse['xval']))\n    logloss1 = gbm.logloss(train=True, valid=False, xval=False)\n    assert isinstance(logloss1, float)\n    logloss2 = gbm.logloss(train=False, valid=True, xval=False)\n    assert isinstance(logloss2, float)\n    logloss3 = gbm.logloss(train=False, valid=False, xval=True)\n    assert isinstance(logloss3, float)\n    logloss = gbm.logloss(train=True, valid=True, xval=False)\n    assert 'train' in list(logloss.keys()) and 'valid' in list(logloss.keys()), 'expected training and validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert len(logloss) == 2, 'expected only training and validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert isinstance(logloss['train'], float) and isinstance(logloss['valid'], float), 'expected training and validation metrics to be floats, but got {0} and {1}'.format(type(logloss['train']), type(logloss['valid']))\n    assert logloss['valid'] == logloss2\n    logloss = gbm.logloss(train=True, valid=False, xval=True)\n    assert 'train' in list(logloss.keys()) and 'xval' in list(logloss.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert len(logloss) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert isinstance(logloss['train'], float) and isinstance(logloss['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(logloss['train']), type(logloss['xval']))\n    assert logloss['xval'] == logloss3\n    logloss = gbm.logloss(train=True, valid=True, xval=True)\n    assert 'train' in list(logloss.keys()) and 'valid' in list(logloss.keys()) and ('xval' in list(logloss.keys())), 'expected training, validation, and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert len(logloss) == 3, 'expected training, validation and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert isinstance(logloss['train'], float) and isinstance(logloss['valid'], float) and isinstance(logloss['xval'], float), 'expected training, validation, and cross validation metrics to be floats, but got {0}, {1}, and {2}'.format(type(logloss['train']), type(logloss['valid']), type(logloss['xval']))\n    logloss = gbm.logloss(train=False, valid=False, xval=False)\n    assert isinstance(logloss, float)\n    assert logloss == logloss1\n    logloss = gbm.logloss(train=False, valid=True, xval=True)\n    assert 'valid' in list(logloss.keys()) and 'xval' in list(logloss.keys()), 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert len(logloss) == 2, 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert isinstance(logloss['valid'], float) and isinstance(logloss['xval'], float), 'validation and cross validation metrics to be floats, but got {0} and {1}'.format(type(logloss['valid']), type(logloss['xval']))\n    hit_ratio_table1 = gbm.hit_ratio_table(train=True, valid=False, xval=False)\n    hit_ratio_table2 = gbm.hit_ratio_table(train=False, valid=True, xval=False)\n    hit_ratio_table3 = gbm.hit_ratio_table(train=False, valid=False, xval=True)\n    hit_ratio_table = gbm.hit_ratio_table(train=True, valid=True, xval=False)\n    hit_ratio_table = gbm.hit_ratio_table(train=True, valid=False, xval=True)\n    hit_ratio_table = gbm.hit_ratio_table(train=True, valid=True, xval=True)\n    hit_ratio_table = gbm.hit_ratio_table(train=False, valid=False, xval=False)\n    hit_ratio_table = gbm.hit_ratio_table(train=False, valid=True, xval=True)\n    mean_per_class_error1 = gbm.mean_per_class_error(train=True, valid=False, xval=False)\n    mean_per_class_error2 = gbm.mean_per_class_error(train=False, valid=True, xval=False)\n    mean_per_class_error3 = gbm.mean_per_class_error(train=False, valid=False, xval=True)\n    mean_per_class_error = gbm.mean_per_class_error(train=True, valid=True, xval=False)\n    mean_per_class_error = gbm.mean_per_class_error(train=True, valid=False, xval=True)\n    mean_per_class_error = gbm.mean_per_class_error(train=True, valid=True, xval=True)\n    mean_per_class_error = gbm.mean_per_class_error(train=False, valid=False, xval=False)\n    mean_per_class_error = gbm.mean_per_class_error(train=False, valid=True, xval=True)\n    iris = h2o.import_file(path=pyunit_utils.locate('smalldata/iris/iris.csv'))\n    from h2o.estimators.kmeans import H2OKMeansEstimator\n    km = H2OKMeansEstimator(k=3, nfolds=3)\n    km.train(x=list(range(4)), training_frame=iris)\n    betweenss1 = km.betweenss(train=True, valid=False, xval=False)\n    assert isinstance(betweenss1, float)\n    betweenss3 = km.betweenss(train=False, valid=False, xval=True)\n    assert isinstance(betweenss3, float)\n    betweenss = km.betweenss(train=True, valid=False, xval=True)\n    assert 'train' in list(betweenss.keys()) and 'xval' in list(betweenss.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(betweenss.keys()))\n    assert len(betweenss) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(betweenss.keys()))\n    assert isinstance(betweenss['train'], float) and isinstance(betweenss['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(betweenss['train']), type(betweenss['xval']))\n    assert betweenss['xval'] == betweenss3\n    betweenss = km.betweenss(train=False, valid=False, xval=False)\n    assert isinstance(betweenss, float)\n    assert betweenss == betweenss1\n    totss1 = km.totss(train=True, valid=False, xval=False)\n    assert isinstance(totss1, float)\n    totss3 = km.totss(train=False, valid=False, xval=True)\n    assert isinstance(totss3, float)\n    totss = km.totss(train=True, valid=False, xval=True)\n    assert 'train' in list(totss.keys()) and 'xval' in list(totss.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(totss.keys()))\n    assert len(totss) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(totss.keys()))\n    assert isinstance(totss['train'], float) and isinstance(totss['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(totss['train']), type(totss['xval']))\n    assert totss['xval'] == totss3\n    totss = km.totss(train=False, valid=False, xval=False)\n    assert isinstance(totss, float)\n    assert totss == totss1\n    tot_withinss1 = km.tot_withinss(train=True, valid=False, xval=False)\n    assert isinstance(tot_withinss1, float)\n    tot_withinss3 = km.tot_withinss(train=False, valid=False, xval=True)\n    assert isinstance(tot_withinss3, float)\n    tot_withinss = km.tot_withinss(train=True, valid=False, xval=True)\n    assert 'train' in list(tot_withinss.keys()) and 'xval' in list(tot_withinss.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(tot_withinss.keys()))\n    assert len(tot_withinss) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(tot_withinss.keys()))\n    assert isinstance(tot_withinss['train'], float) and isinstance(tot_withinss['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(tot_withinss['train']), type(tot_withinss['xval']))\n    assert tot_withinss['xval'] == tot_withinss3\n    tot_withinss = km.tot_withinss(train=False, valid=False, xval=False)\n    assert isinstance(tot_withinss, float)\n    assert tot_withinss == tot_withinss1\n    withinss1 = km.withinss(train=True, valid=False)\n    withinss2 = km.withinss(train=True, valid=True)\n    withinss3 = km.withinss(train=False, valid=False)\n    assert withinss1 == withinss3\n    assert withinss1 != withinss2\n    centroid_stats1 = km.centroid_stats(train=True, valid=False)\n    centroid_stats2 = km.centroid_stats(train=True, valid=True)\n    centroid_stats3 = km.centroid_stats(train=False, valid=False)\n    assert centroid_stats1 == centroid_stats3\n    assert centroid_stats1 != centroid_stats2\n    size1 = km.size(train=True, valid=False)\n    size2 = km.size(train=True, valid=True)\n    size3 = km.size(train=False, valid=False)\n    assert size1 == size3\n    assert size1 != size2",
            "def metric_accessors():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    cars = h2o.import_file(path=pyunit_utils.locate('smalldata/junit/cars_20mpg.csv'))\n    r = cars[0].runif()\n    train = cars[r > 0.2]\n    valid = cars[r <= 0.2]\n    response_col = 'economy'\n    distribution = 'gaussian'\n    predictors = ['displacement', 'power', 'weight', 'acceleration', 'year']\n    gbm = H2OGradientBoostingEstimator(nfolds=3, distribution=distribution, fold_assignment='Random')\n    gbm.train(x=predictors, y=response_col, training_frame=train, validation_frame=valid)\n    for metric in ['r2', 'mse', 'rmse', 'rmsle', 'mae']:\n        val = getattr(gbm, metric)()\n        assert isinstance(val, float), 'expected a float for metric {} but got {}'.format(metric, val)\n    mse1 = gbm.mse(train=True, valid=False, xval=False)\n    assert isinstance(mse1, float)\n    mse2 = gbm.mse(train=False, valid=True, xval=False)\n    assert isinstance(mse2, float)\n    mse3 = gbm.mse(train=False, valid=False, xval=True)\n    assert isinstance(mse3, float)\n    mse = gbm.mse(train=True, valid=True, xval=False)\n    assert 'train' in list(mse.keys()) and 'valid' in list(mse.keys()), 'expected training and validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert len(mse) == 2, 'expected only training and validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert isinstance(mse['train'], float) and isinstance(mse['valid'], float), 'expected training and validation metrics to be floats, but got {0} and {1}'.format(type(mse['train']), type(mse['valid']))\n    assert mse['valid'] == mse2\n    mse = gbm.mse(train=True, valid=False, xval=True)\n    assert 'train' in list(mse.keys()) and 'xval' in list(mse.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert len(mse) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert isinstance(mse['train'], float) and isinstance(mse['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(mse['train']), type(mse['xval']))\n    assert mse['xval'] == mse3\n    mse = gbm.mse(train=True, valid=True, xval=True)\n    assert 'train' in list(mse.keys()) and 'valid' in list(mse.keys()) and ('xval' in list(mse.keys())), 'expected training, validation, and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert len(mse) == 3, 'expected training, validation and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert isinstance(mse['train'], float) and isinstance(mse['valid'], float) and isinstance(mse['xval'], float), 'expected training, validation, and cross validation metrics to be floats, but got {0}, {1}, and {2}'.format(type(mse['train']), type(mse['valid']), type(mse['xval']))\n    mse = gbm.mse(train=False, valid=False, xval=False)\n    assert isinstance(mse, float)\n    assert mse == mse1\n    mse = gbm.mse(train=False, valid=True, xval=True)\n    assert 'valid' in list(mse.keys()) and 'xval' in list(mse.keys()), 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert len(mse) == 2, 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert isinstance(mse['valid'], float) and isinstance(mse['xval'], float), 'validation and cross validation metrics to be floats, but got {0} and {1}'.format(type(mse['valid']), type(mse['xval']))\n    mean_residual_deviance1 = gbm.mean_residual_deviance(train=True, valid=False, xval=False)\n    assert isinstance(mean_residual_deviance1, float)\n    mean_residual_deviance2 = gbm.mean_residual_deviance(train=False, valid=True, xval=False)\n    assert isinstance(mean_residual_deviance2, float)\n    mean_residual_deviance3 = gbm.mean_residual_deviance(train=False, valid=False, xval=True)\n    assert isinstance(mean_residual_deviance3, float)\n    mean_residual_deviance = gbm.mean_residual_deviance(train=True, valid=True, xval=False)\n    assert 'train' in list(mean_residual_deviance.keys()) and 'valid' in list(mean_residual_deviance.keys()), 'expected training and validation metrics to be returned, but got {0}'.format(list(mean_residual_deviance.keys()))\n    assert len(mean_residual_deviance) == 2, 'expected only training and validation metrics to be returned, but got {0}'.format(list(mean_residual_deviance.keys()))\n    assert isinstance(mean_residual_deviance['train'], float) and isinstance(mean_residual_deviance['valid'], float), 'expected training and validation metrics to be floats, but got {0} and {1}'.format(type(mean_residual_deviance['train']), type(mean_residual_deviance['valid']))\n    assert mean_residual_deviance['valid'] == mean_residual_deviance2\n    mean_residual_deviance = gbm.mean_residual_deviance(train=True, valid=False, xval=True)\n    assert 'train' in list(mean_residual_deviance.keys()) and 'xval' in list(mean_residual_deviance.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(mean_residual_deviance.keys()))\n    assert len(mean_residual_deviance) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(mean_residual_deviance.keys()))\n    assert isinstance(mean_residual_deviance['train'], float) and isinstance(mean_residual_deviance['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(mean_residual_deviance['train']), type(mean_residual_deviance['xval']))\n    assert mean_residual_deviance['xval'] == mean_residual_deviance3\n    mean_residual_deviance = gbm.mean_residual_deviance(train=True, valid=True, xval=True)\n    assert 'train' in list(mean_residual_deviance.keys()) and 'valid' in list(mean_residual_deviance.keys()) and ('xval' in list(mean_residual_deviance.keys())), 'expected training, validation, and cross validation metrics to be returned, but got {0}'.format(list(mean_residual_deviance.keys()))\n    assert len(mean_residual_deviance) == 3, 'expected training, validation and cross validation metrics to be returned, but got {0}'.format(list(mean_residual_deviance.keys()))\n    assert isinstance(mean_residual_deviance['train'], float) and isinstance(mean_residual_deviance['valid'], float) and isinstance(mean_residual_deviance['xval'], float), 'expected training, validation, and cross validation metrics to be floats, but got {0}, {1}, and {2}'.format(type(mean_residual_deviance['train']), type(mean_residual_deviance['valid']), type(mean_residual_deviance['xval']))\n    mean_residual_deviance = gbm.mean_residual_deviance(train=False, valid=False, xval=False)\n    assert isinstance(mean_residual_deviance, float)\n    assert mean_residual_deviance == mean_residual_deviance1\n    mean_residual_deviance = gbm.mean_residual_deviance(train=False, valid=True, xval=True)\n    assert 'valid' in list(mean_residual_deviance.keys()) and 'xval' in list(mean_residual_deviance.keys()), 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(mean_residual_deviance.keys()))\n    assert len(mean_residual_deviance) == 2, 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(mean_residual_deviance.keys()))\n    assert isinstance(mean_residual_deviance['valid'], float) and isinstance(mean_residual_deviance['xval'], float), 'validation and cross validation metrics to be floats, but got {0} and {1}'.format(type(mean_residual_deviance['valid']), type(mean_residual_deviance['xval']))\n    cars = h2o.import_file(path=pyunit_utils.locate('smalldata/junit/cars_20mpg.csv'))\n    cars['economy_20mpg'] = cars['economy_20mpg'].asfactor()\n    r = cars[0].runif()\n    train = cars[r > 0.2]\n    valid = cars[r <= 0.2]\n    response_col = 'economy_20mpg'\n    distribution = 'bernoulli'\n    predictors = ['displacement', 'power', 'weight', 'acceleration', 'year']\n    gbm = H2OGradientBoostingEstimator(nfolds=3, distribution=distribution, fold_assignment='Random')\n    gbm.train(y=response_col, x=predictors, validation_frame=valid, training_frame=train)\n    for metric in ['gini', 'logloss', 'auc', 'aucpr', 'mse', 'rmse']:\n        val = getattr(gbm, metric)()\n        assert isinstance(val, float), 'expected a float for metric {} but got {}'.format(metric, val)\n    for metric in ['mcc', 'F1', 'F0point5', 'F2', 'accuracy', 'mean_per_class_error']:\n        val = getattr(gbm, metric)()[0][1]\n        assert isinstance(val, float), 'expected a float for metric {} but got {}'.format(metric, val)\n    auc1 = gbm.auc(train=True, valid=False, xval=False)\n    assert isinstance(auc1, float)\n    auc2 = gbm.auc(train=False, valid=True, xval=False)\n    assert isinstance(auc2, float)\n    auc3 = gbm.auc(train=False, valid=False, xval=True)\n    assert isinstance(auc3, float)\n    auc = gbm.auc(train=True, valid=True, xval=False)\n    assert 'train' in list(auc.keys()) and 'valid' in list(auc.keys()), 'expected training and validation metrics to be returned, but got {0}'.format(list(auc.keys()))\n    assert len(auc) == 2, 'expected only training and validation metrics to be returned, but got {0}'.format(list(auc.keys()))\n    assert isinstance(auc['train'], float) and isinstance(auc['valid'], float), 'expected training and validation metrics to be floats, but got {0} and {1}'.format(type(auc['train']), type(auc['valid']))\n    assert auc['valid'] == auc2\n    auc = gbm.auc(train=True, valid=False, xval=True)\n    assert 'train' in list(auc.keys()) and 'xval' in list(auc.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(auc.keys()))\n    assert len(auc) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(auc.keys()))\n    assert isinstance(auc['train'], float) and isinstance(auc['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(auc['train']), type(auc['xval']))\n    assert auc['xval'] == auc3\n    auc = gbm.auc(train=True, valid=True, xval=True)\n    assert 'train' in list(auc.keys()) and 'valid' in list(auc.keys()) and ('xval' in list(auc.keys())), 'expected training, validation, and cross validation metrics to be returned, but got {0}'.format(list(auc.keys()))\n    assert len(auc) == 3, 'expected training, validation and cross validation metrics to be returned, but got {0}'.format(list(auc.keys()))\n    assert isinstance(auc['train'], float) and isinstance(auc['valid'], float) and isinstance(auc['xval'], float), 'expected training, validation, and cross validation metrics to be floats, but got {0}, {1}, and {2}'.format(type(auc['train']), type(auc['valid']), type(auc['xval']))\n    auc = gbm.auc(train=False, valid=False, xval=False)\n    assert isinstance(auc, float)\n    assert auc == auc1\n    auc = gbm.auc(train=False, valid=True, xval=True)\n    assert 'valid' in list(auc.keys()) and 'xval' in list(auc.keys()), 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(auc.keys()))\n    assert len(auc) == 2, 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(auc.keys()))\n    assert isinstance(auc['valid'], float) and isinstance(auc['xval'], float), 'validation and cross validation metrics to be floats, but got {0} and {1}'.format(type(auc['valid']), type(auc['xval']))\n    (fprs1, tprs1) = gbm.roc(train=True, valid=False, xval=False)\n    assert isinstance(fprs1, list)\n    assert isinstance(tprs1, list)\n    (fprs2, tprs2) = gbm.roc(train=False, valid=True, xval=False)\n    assert isinstance(fprs2, list)\n    assert isinstance(tprs2, list)\n    (fprs3, tprs3) = gbm.roc(train=False, valid=False, xval=True)\n    assert isinstance(fprs3, list)\n    assert isinstance(tprs3, list)\n    roc = gbm.roc(train=True, valid=True, xval=False)\n    assert 'train' in list(roc.keys()) and 'valid' in list(roc.keys()), 'expected training and validation metrics to be returned, but got {0}'.format(list(roc.keys()))\n    assert len(roc) == 2, 'expected only training and validation metrics to be returned, but got {0}'.format(list(roc.keys()))\n    assert isinstance(roc['train'], tuple) and isinstance(roc['valid'], tuple), 'expected training and validation metrics to be tuples, but got {0} and {1}'.format(type(roc['train']), type(roc['valid']))\n    assert roc['valid'][0] == fprs2\n    assert roc['valid'][1] == tprs2\n    roc = gbm.roc(train=True, valid=False, xval=True)\n    assert 'train' in list(roc.keys()) and 'xval' in list(roc.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(roc.keys()))\n    assert len(roc) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(roc.keys()))\n    assert isinstance(roc['train'], tuple) and isinstance(roc['xval'], tuple), 'expected training and cross validation metrics to be tuples, but got {0} and {1}'.format(type(roc['train']), type(roc['xval']))\n    assert roc['xval'][0] == fprs3\n    assert roc['xval'][1] == tprs3\n    roc = gbm.roc(train=True, valid=True, xval=True)\n    assert 'train' in list(roc.keys()) and 'valid' in list(roc.keys()) and ('xval' in list(roc.keys())), 'expected training, validation, and cross validation metrics to be returned, but got {0}'.format(list(roc.keys()))\n    assert len(roc) == 3, 'expected training, validation and cross validation metrics to be returned, but got {0}'.format(list(roc.keys()))\n    assert isinstance(roc['train'], tuple) and isinstance(roc['valid'], tuple) and isinstance(roc['xval'], tuple), 'expected training, validation, and cross validation metrics to be tuples, but got {0}, {1}, and {2}'.format(type(roc['train']), type(roc['valid']), type(roc['xval']))\n    (fprs, tprs) = gbm.roc(train=False, valid=False, xval=False)\n    assert isinstance(fprs, list)\n    assert isinstance(tprs, list)\n    assert fprs == fprs1\n    assert tprs == tprs1\n    roc = gbm.roc(train=False, valid=True, xval=True)\n    assert 'valid' in list(roc.keys()) and 'xval' in list(roc.keys()), 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(roc.keys()))\n    assert len(roc) == 2, 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(roc.keys()))\n    assert isinstance(roc['valid'], tuple) and isinstance(roc['xval'], tuple), 'validation and cross validation metrics to be tuples, but got {0} and {1}'.format(type(roc['valid']), type(roc['xval']))\n    logloss1 = gbm.logloss(train=True, valid=False, xval=False)\n    assert isinstance(logloss1, float)\n    logloss2 = gbm.logloss(train=False, valid=True, xval=False)\n    assert isinstance(logloss2, float)\n    logloss3 = gbm.logloss(train=False, valid=False, xval=True)\n    assert isinstance(logloss3, float)\n    logloss = gbm.logloss(train=True, valid=True, xval=False)\n    assert 'train' in list(logloss.keys()) and 'valid' in list(logloss.keys()), 'expected training and validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert len(logloss) == 2, 'expected only training and validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert isinstance(logloss['train'], float) and isinstance(logloss['valid'], float), 'expected training and validation metrics to be floats, but got {0} and {1}'.format(type(logloss['train']), type(logloss['valid']))\n    assert logloss['valid'] == logloss2\n    logloss = gbm.logloss(train=True, valid=False, xval=True)\n    assert 'train' in list(logloss.keys()) and 'xval' in list(logloss.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert len(logloss) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert isinstance(logloss['train'], float) and isinstance(logloss['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(logloss['train']), type(logloss['xval']))\n    assert logloss['xval'] == logloss3\n    logloss = gbm.logloss(train=True, valid=True, xval=True)\n    assert 'train' in list(logloss.keys()) and 'valid' in list(logloss.keys()) and ('xval' in list(logloss.keys())), 'expected training, validation, and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert len(logloss) == 3, 'expected training, validation and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert isinstance(logloss['train'], float) and isinstance(logloss['valid'], float) and isinstance(logloss['xval'], float), 'expected training, validation, and cross validation metrics to be floats, but got {0}, {1}, and {2}'.format(type(logloss['train']), type(logloss['valid']), type(logloss['xval']))\n    logloss = gbm.logloss(train=False, valid=False, xval=False)\n    assert isinstance(logloss, float)\n    assert logloss == logloss1\n    logloss = gbm.logloss(train=False, valid=True, xval=True)\n    assert 'valid' in list(logloss.keys()) and 'xval' in list(logloss.keys()), 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert len(logloss) == 2, 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert isinstance(logloss['valid'], float) and isinstance(logloss['xval'], float), 'validation and cross validation metrics to be floats, but got {0} and {1}'.format(type(logloss['valid']), type(logloss['xval']))\n    gini1 = gbm.gini(train=True, valid=False, xval=False)\n    assert isinstance(gini1, float)\n    gini2 = gbm.gini(train=False, valid=True, xval=False)\n    assert isinstance(gini2, float)\n    gini3 = gbm.gini(train=False, valid=False, xval=True)\n    assert isinstance(gini3, float)\n    gini = gbm.gini(train=True, valid=True, xval=False)\n    assert 'train' in list(gini.keys()) and 'valid' in list(gini.keys()), 'expected training and validation metrics to be returned, but got {0}'.format(list(gini.keys()))\n    assert len(gini) == 2, 'expected only training and validation metrics to be returned, but got {0}'.format(list(gini.keys()))\n    assert isinstance(gini['train'], float) and isinstance(gini['valid'], float), 'expected training and validation metrics to be floats, but got {0} and {1}'.format(type(gini['train']), type(gini['valid']))\n    assert gini['valid'] == gini2\n    gini = gbm.gini(train=True, valid=False, xval=True)\n    assert 'train' in list(gini.keys()) and 'xval' in list(gini.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(gini.keys()))\n    assert len(gini) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(gini.keys()))\n    assert isinstance(gini['train'], float) and isinstance(gini['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(gini['train']), type(gini['xval']))\n    assert gini['xval'] == gini3\n    gini = gbm.gini(train=True, valid=True, xval=True)\n    assert 'train' in list(gini.keys()) and 'valid' in list(gini.keys()) and ('xval' in list(gini.keys())), 'expected training, validation, and cross validation metrics to be returned, but got {0}'.format(list(gini.keys()))\n    assert len(gini) == 3, 'expected training, validation and cross validation metrics to be returned, but got {0}'.format(list(gini.keys()))\n    assert isinstance(gini['train'], float) and isinstance(gini['valid'], float) and isinstance(gini['xval'], float), 'expected training, validation, and cross validation metrics to be floats, but got {0}, {1}, and {2}'.format(type(gini['train']), type(gini['valid']), type(gini['xval']))\n    gini = gbm.gini(train=False, valid=False, xval=False)\n    assert isinstance(gini, float)\n    assert gini == gini1\n    gini = gbm.gini(train=False, valid=True, xval=True)\n    assert 'valid' in list(gini.keys()) and 'xval' in list(gini.keys()), 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(gini.keys()))\n    assert len(gini) == 2, 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(gini.keys()))\n    assert isinstance(gini['valid'], float) and isinstance(gini['xval'], float), 'validation and cross validation metrics to be floats, but got {0} and {1}'.format(type(gini['valid']), type(gini['xval']))\n    F11 = gbm.F1(train=True, valid=False, xval=False)\n    F12 = gbm.F1(train=False, valid=True, xval=False)\n    F13 = gbm.F1(train=False, valid=False, xval=True)\n    F1 = gbm.F1(train=True, valid=True, xval=False)\n    F1 = gbm.F1(train=True, valid=False, xval=True)\n    F1 = gbm.F1(train=True, valid=True, xval=True)\n    F1 = gbm.F1(train=False, valid=False, xval=False)\n    F1 = gbm.F1(train=False, valid=True, xval=True)\n    F0point51 = gbm.F0point5(train=True, valid=False, xval=False)\n    F0point52 = gbm.F0point5(train=False, valid=True, xval=False)\n    F0point53 = gbm.F0point5(train=False, valid=False, xval=True)\n    F0point5 = gbm.F0point5(train=True, valid=True, xval=False)\n    F0point5 = gbm.F0point5(train=True, valid=False, xval=True)\n    F0point5 = gbm.F0point5(train=True, valid=True, xval=True)\n    F0point5 = gbm.F0point5(train=False, valid=False, xval=False)\n    F0point5 = gbm.F0point5(train=False, valid=True, xval=True)\n    F21 = gbm.F2(train=True, valid=False, xval=False)\n    F22 = gbm.F2(train=False, valid=True, xval=False)\n    F23 = gbm.F2(train=False, valid=False, xval=True)\n    F2 = gbm.F2(train=True, valid=True, xval=False)\n    F2 = gbm.F2(train=True, valid=False, xval=True)\n    F2 = gbm.F2(train=True, valid=True, xval=True)\n    F2 = gbm.F2(train=False, valid=False, xval=False)\n    F2 = gbm.F2(train=False, valid=True, xval=True)\n    accuracy1 = gbm.accuracy(train=True, valid=False, xval=False)\n    accuracy2 = gbm.accuracy(train=False, valid=True, xval=False)\n    accuracy3 = gbm.accuracy(train=False, valid=False, xval=True)\n    accuracy = gbm.accuracy(train=True, valid=True, xval=False)\n    accuracy = gbm.accuracy(train=True, valid=False, xval=True)\n    accuracy = gbm.accuracy(train=True, valid=True, xval=True)\n    accuracy = gbm.accuracy(train=False, valid=False, xval=False)\n    accuracy = gbm.accuracy(train=False, valid=True, xval=True)\n    error1 = gbm.error(train=True, valid=False, xval=False)\n    error2 = gbm.error(train=False, valid=True, xval=False)\n    error3 = gbm.error(train=False, valid=False, xval=True)\n    error = gbm.error(train=True, valid=True, xval=False)\n    error = gbm.error(train=True, valid=False, xval=True)\n    error = gbm.error(train=True, valid=True, xval=True)\n    error = gbm.error(train=False, valid=False, xval=False)\n    error = gbm.error(train=False, valid=True, xval=True)\n    precision1 = gbm.precision(train=True, valid=False, xval=False)\n    precision2 = gbm.precision(train=False, valid=True, xval=False)\n    precision3 = gbm.precision(train=False, valid=False, xval=True)\n    precision = gbm.precision(train=True, valid=True, xval=False)\n    precision = gbm.precision(train=True, valid=False, xval=True)\n    precision = gbm.precision(train=True, valid=True, xval=True)\n    precision = gbm.precision(train=False, valid=False, xval=False)\n    precision = gbm.precision(train=False, valid=True, xval=True)\n    mcc1 = gbm.mcc(train=True, valid=False, xval=False)\n    mcc2 = gbm.mcc(train=False, valid=True, xval=False)\n    mcc3 = gbm.mcc(train=False, valid=False, xval=True)\n    mcc = gbm.mcc(train=True, valid=True, xval=False)\n    mcc = gbm.mcc(train=True, valid=False, xval=True)\n    mcc = gbm.mcc(train=True, valid=True, xval=True)\n    mcc = gbm.mcc(train=False, valid=False, xval=False)\n    mcc = gbm.mcc(train=False, valid=True, xval=True)\n    max_per_class_error1 = gbm.max_per_class_error(train=True, valid=False, xval=False)\n    max_per_class_error2 = gbm.max_per_class_error(train=False, valid=True, xval=False)\n    max_per_class_error3 = gbm.max_per_class_error(train=False, valid=False, xval=True)\n    max_per_class_error = gbm.max_per_class_error(train=True, valid=True, xval=False)\n    max_per_class_error = gbm.max_per_class_error(train=True, valid=False, xval=True)\n    max_per_class_error = gbm.max_per_class_error(train=True, valid=True, xval=True)\n    max_per_class_error = gbm.max_per_class_error(train=False, valid=False, xval=False)\n    max_per_class_error = gbm.max_per_class_error(train=False, valid=True, xval=True)\n    mean_per_class_error1 = gbm.mean_per_class_error(train=True, valid=False, xval=False)\n    mean_per_class_error2 = gbm.mean_per_class_error(train=False, valid=True, xval=False)\n    mean_per_class_error3 = gbm.mean_per_class_error(train=False, valid=False, xval=True)\n    mean_per_class_error = gbm.mean_per_class_error(train=True, valid=True, xval=False)\n    mean_per_class_error = gbm.mean_per_class_error(train=True, valid=False, xval=True)\n    mean_per_class_error = gbm.mean_per_class_error(train=True, valid=True, xval=True)\n    mean_per_class_error = gbm.mean_per_class_error(train=False, valid=False, xval=False)\n    mean_per_class_error = gbm.mean_per_class_error(train=False, valid=True, xval=True)\n    confusion_matrix1 = gbm.confusion_matrix(train=True, valid=False, xval=False)\n    confusion_matrix2 = gbm.confusion_matrix(train=False, valid=True, xval=False)\n    confusion_matrix3 = gbm.confusion_matrix(train=False, valid=False, xval=True)\n    confusion_matrix = gbm.confusion_matrix(train=True, valid=True, xval=False)\n    confusion_matrix = gbm.confusion_matrix(train=True, valid=False, xval=True)\n    confusion_matrix = gbm.confusion_matrix(train=True, valid=True, xval=True)\n    confusion_matrix = gbm.confusion_matrix(train=False, valid=False, xval=False)\n    confusion_matrix = gbm.confusion_matrix(train=False, valid=True, xval=True)\n    tpr1 = gbm.tpr(train=True, valid=False, xval=False)\n    tpr2 = gbm.tpr(train=False, valid=True, xval=False)\n    tpr3 = gbm.tpr(train=False, valid=False, xval=True)\n    tpr = gbm.tpr(train=True, valid=True, xval=False)\n    tpr = gbm.tpr(train=True, valid=False, xval=True)\n    tpr = gbm.tpr(train=True, valid=True, xval=True)\n    tpr = gbm.tpr(train=False, valid=False, xval=False)\n    tpr = gbm.tpr(train=False, valid=True, xval=True)\n    tnr1 = gbm.tnr(train=True, valid=False, xval=False)\n    tnr2 = gbm.tnr(train=False, valid=True, xval=False)\n    tnr3 = gbm.tnr(train=False, valid=False, xval=True)\n    tnr = gbm.tnr(train=True, valid=True, xval=False)\n    tnr = gbm.tnr(train=True, valid=False, xval=True)\n    tnr = gbm.tnr(train=True, valid=True, xval=True)\n    tnr = gbm.tnr(train=False, valid=False, xval=False)\n    tnr = gbm.tnr(train=False, valid=True, xval=True)\n    fnr1 = gbm.fnr(train=True, valid=False, xval=False)\n    fnr2 = gbm.fnr(train=False, valid=True, xval=False)\n    fnr3 = gbm.fnr(train=False, valid=False, xval=True)\n    fnr = gbm.fnr(train=True, valid=True, xval=False)\n    fnr = gbm.fnr(train=True, valid=False, xval=True)\n    fnr = gbm.fnr(train=True, valid=True, xval=True)\n    fnr = gbm.fnr(train=False, valid=False, xval=False)\n    fnr = gbm.fnr(train=False, valid=True, xval=True)\n    fpr1 = gbm.fpr(train=True, valid=False, xval=False)\n    fpr2 = gbm.fpr(train=False, valid=True, xval=False)\n    fpr3 = gbm.fpr(train=False, valid=False, xval=True)\n    fpr = gbm.fpr(train=True, valid=True, xval=False)\n    fpr = gbm.fpr(train=True, valid=False, xval=True)\n    fpr = gbm.fpr(train=True, valid=True, xval=True)\n    fpr = gbm.fpr(train=False, valid=False, xval=False)\n    fpr = gbm.fpr(train=False, valid=True, xval=True)\n    cars = h2o.import_file(path=pyunit_utils.locate('smalldata/junit/cars_20mpg.csv'))\n    cars['cylinders'] = cars['cylinders'].asfactor()\n    r = cars[0].runif()\n    train = cars[r > 0.2]\n    valid = cars[r <= 0.2]\n    response_col = 'cylinders'\n    distribution = 'multinomial'\n    predictors = ['displacement', 'power', 'weight', 'acceleration', 'year']\n    gbm = H2OGradientBoostingEstimator(nfolds=3, distribution=distribution, fold_assignment='Random')\n    gbm.train(x=predictors, y=response_col, training_frame=train, validation_frame=valid)\n    for metric in ['logloss', 'mse', 'rmse', 'mean_per_class_error']:\n        val = getattr(gbm, metric)()\n        assert isinstance(val, float), 'expected a float for metric {} but got {}'.format(metric, val)\n    mse1 = gbm.mse(train=True, valid=False, xval=False)\n    assert isinstance(mse1, float)\n    mse2 = gbm.mse(train=False, valid=True, xval=False)\n    assert isinstance(mse2, float)\n    mse3 = gbm.mse(train=False, valid=False, xval=True)\n    assert isinstance(mse3, float)\n    mse = gbm.mse(train=True, valid=True, xval=False)\n    assert 'train' in list(mse.keys()) and 'valid' in list(mse.keys()), 'expected training and validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert len(mse) == 2, 'expected only training and validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert isinstance(mse['train'], float) and isinstance(mse['valid'], float), 'expected training and validation metrics to be floats, but got {0} and {1}'.format(type(mse['train']), type(mse['valid']))\n    assert mse['valid'] == mse2\n    mse = gbm.mse(train=True, valid=False, xval=True)\n    assert 'train' in list(mse.keys()) and 'xval' in list(mse.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert len(mse) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert isinstance(mse['train'], float) and isinstance(mse['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(mse['train']), type(mse['xval']))\n    assert mse['xval'] == mse3\n    mse = gbm.mse(train=True, valid=True, xval=True)\n    assert 'train' in list(mse.keys()) and 'valid' in list(mse.keys()) and ('xval' in list(mse.keys())), 'expected training, validation, and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert len(mse) == 3, 'expected training, validation and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert isinstance(mse['train'], float) and isinstance(mse['valid'], float) and isinstance(mse['xval'], float), 'expected training, validation, and cross validation metrics to be floats, but got {0}, {1}, and {2}'.format(type(mse['train']), type(mse['valid']), type(mse['xval']))\n    mse = gbm.mse(train=False, valid=False, xval=False)\n    assert isinstance(mse, float)\n    assert mse == mse1\n    mse = gbm.mse(train=False, valid=True, xval=True)\n    assert 'valid' in list(mse.keys()) and 'xval' in list(mse.keys()), 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert len(mse) == 2, 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert isinstance(mse['valid'], float) and isinstance(mse['xval'], float), 'validation and cross validation metrics to be floats, but got {0} and {1}'.format(type(mse['valid']), type(mse['xval']))\n    logloss1 = gbm.logloss(train=True, valid=False, xval=False)\n    assert isinstance(logloss1, float)\n    logloss2 = gbm.logloss(train=False, valid=True, xval=False)\n    assert isinstance(logloss2, float)\n    logloss3 = gbm.logloss(train=False, valid=False, xval=True)\n    assert isinstance(logloss3, float)\n    logloss = gbm.logloss(train=True, valid=True, xval=False)\n    assert 'train' in list(logloss.keys()) and 'valid' in list(logloss.keys()), 'expected training and validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert len(logloss) == 2, 'expected only training and validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert isinstance(logloss['train'], float) and isinstance(logloss['valid'], float), 'expected training and validation metrics to be floats, but got {0} and {1}'.format(type(logloss['train']), type(logloss['valid']))\n    assert logloss['valid'] == logloss2\n    logloss = gbm.logloss(train=True, valid=False, xval=True)\n    assert 'train' in list(logloss.keys()) and 'xval' in list(logloss.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert len(logloss) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert isinstance(logloss['train'], float) and isinstance(logloss['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(logloss['train']), type(logloss['xval']))\n    assert logloss['xval'] == logloss3\n    logloss = gbm.logloss(train=True, valid=True, xval=True)\n    assert 'train' in list(logloss.keys()) and 'valid' in list(logloss.keys()) and ('xval' in list(logloss.keys())), 'expected training, validation, and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert len(logloss) == 3, 'expected training, validation and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert isinstance(logloss['train'], float) and isinstance(logloss['valid'], float) and isinstance(logloss['xval'], float), 'expected training, validation, and cross validation metrics to be floats, but got {0}, {1}, and {2}'.format(type(logloss['train']), type(logloss['valid']), type(logloss['xval']))\n    logloss = gbm.logloss(train=False, valid=False, xval=False)\n    assert isinstance(logloss, float)\n    assert logloss == logloss1\n    logloss = gbm.logloss(train=False, valid=True, xval=True)\n    assert 'valid' in list(logloss.keys()) and 'xval' in list(logloss.keys()), 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert len(logloss) == 2, 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert isinstance(logloss['valid'], float) and isinstance(logloss['xval'], float), 'validation and cross validation metrics to be floats, but got {0} and {1}'.format(type(logloss['valid']), type(logloss['xval']))\n    hit_ratio_table1 = gbm.hit_ratio_table(train=True, valid=False, xval=False)\n    hit_ratio_table2 = gbm.hit_ratio_table(train=False, valid=True, xval=False)\n    hit_ratio_table3 = gbm.hit_ratio_table(train=False, valid=False, xval=True)\n    hit_ratio_table = gbm.hit_ratio_table(train=True, valid=True, xval=False)\n    hit_ratio_table = gbm.hit_ratio_table(train=True, valid=False, xval=True)\n    hit_ratio_table = gbm.hit_ratio_table(train=True, valid=True, xval=True)\n    hit_ratio_table = gbm.hit_ratio_table(train=False, valid=False, xval=False)\n    hit_ratio_table = gbm.hit_ratio_table(train=False, valid=True, xval=True)\n    mean_per_class_error1 = gbm.mean_per_class_error(train=True, valid=False, xval=False)\n    mean_per_class_error2 = gbm.mean_per_class_error(train=False, valid=True, xval=False)\n    mean_per_class_error3 = gbm.mean_per_class_error(train=False, valid=False, xval=True)\n    mean_per_class_error = gbm.mean_per_class_error(train=True, valid=True, xval=False)\n    mean_per_class_error = gbm.mean_per_class_error(train=True, valid=False, xval=True)\n    mean_per_class_error = gbm.mean_per_class_error(train=True, valid=True, xval=True)\n    mean_per_class_error = gbm.mean_per_class_error(train=False, valid=False, xval=False)\n    mean_per_class_error = gbm.mean_per_class_error(train=False, valid=True, xval=True)\n    iris = h2o.import_file(path=pyunit_utils.locate('smalldata/iris/iris.csv'))\n    from h2o.estimators.kmeans import H2OKMeansEstimator\n    km = H2OKMeansEstimator(k=3, nfolds=3)\n    km.train(x=list(range(4)), training_frame=iris)\n    betweenss1 = km.betweenss(train=True, valid=False, xval=False)\n    assert isinstance(betweenss1, float)\n    betweenss3 = km.betweenss(train=False, valid=False, xval=True)\n    assert isinstance(betweenss3, float)\n    betweenss = km.betweenss(train=True, valid=False, xval=True)\n    assert 'train' in list(betweenss.keys()) and 'xval' in list(betweenss.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(betweenss.keys()))\n    assert len(betweenss) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(betweenss.keys()))\n    assert isinstance(betweenss['train'], float) and isinstance(betweenss['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(betweenss['train']), type(betweenss['xval']))\n    assert betweenss['xval'] == betweenss3\n    betweenss = km.betweenss(train=False, valid=False, xval=False)\n    assert isinstance(betweenss, float)\n    assert betweenss == betweenss1\n    totss1 = km.totss(train=True, valid=False, xval=False)\n    assert isinstance(totss1, float)\n    totss3 = km.totss(train=False, valid=False, xval=True)\n    assert isinstance(totss3, float)\n    totss = km.totss(train=True, valid=False, xval=True)\n    assert 'train' in list(totss.keys()) and 'xval' in list(totss.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(totss.keys()))\n    assert len(totss) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(totss.keys()))\n    assert isinstance(totss['train'], float) and isinstance(totss['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(totss['train']), type(totss['xval']))\n    assert totss['xval'] == totss3\n    totss = km.totss(train=False, valid=False, xval=False)\n    assert isinstance(totss, float)\n    assert totss == totss1\n    tot_withinss1 = km.tot_withinss(train=True, valid=False, xval=False)\n    assert isinstance(tot_withinss1, float)\n    tot_withinss3 = km.tot_withinss(train=False, valid=False, xval=True)\n    assert isinstance(tot_withinss3, float)\n    tot_withinss = km.tot_withinss(train=True, valid=False, xval=True)\n    assert 'train' in list(tot_withinss.keys()) and 'xval' in list(tot_withinss.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(tot_withinss.keys()))\n    assert len(tot_withinss) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(tot_withinss.keys()))\n    assert isinstance(tot_withinss['train'], float) and isinstance(tot_withinss['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(tot_withinss['train']), type(tot_withinss['xval']))\n    assert tot_withinss['xval'] == tot_withinss3\n    tot_withinss = km.tot_withinss(train=False, valid=False, xval=False)\n    assert isinstance(tot_withinss, float)\n    assert tot_withinss == tot_withinss1\n    withinss1 = km.withinss(train=True, valid=False)\n    withinss2 = km.withinss(train=True, valid=True)\n    withinss3 = km.withinss(train=False, valid=False)\n    assert withinss1 == withinss3\n    assert withinss1 != withinss2\n    centroid_stats1 = km.centroid_stats(train=True, valid=False)\n    centroid_stats2 = km.centroid_stats(train=True, valid=True)\n    centroid_stats3 = km.centroid_stats(train=False, valid=False)\n    assert centroid_stats1 == centroid_stats3\n    assert centroid_stats1 != centroid_stats2\n    size1 = km.size(train=True, valid=False)\n    size2 = km.size(train=True, valid=True)\n    size3 = km.size(train=False, valid=False)\n    assert size1 == size3\n    assert size1 != size2",
            "def metric_accessors():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    cars = h2o.import_file(path=pyunit_utils.locate('smalldata/junit/cars_20mpg.csv'))\n    r = cars[0].runif()\n    train = cars[r > 0.2]\n    valid = cars[r <= 0.2]\n    response_col = 'economy'\n    distribution = 'gaussian'\n    predictors = ['displacement', 'power', 'weight', 'acceleration', 'year']\n    gbm = H2OGradientBoostingEstimator(nfolds=3, distribution=distribution, fold_assignment='Random')\n    gbm.train(x=predictors, y=response_col, training_frame=train, validation_frame=valid)\n    for metric in ['r2', 'mse', 'rmse', 'rmsle', 'mae']:\n        val = getattr(gbm, metric)()\n        assert isinstance(val, float), 'expected a float for metric {} but got {}'.format(metric, val)\n    mse1 = gbm.mse(train=True, valid=False, xval=False)\n    assert isinstance(mse1, float)\n    mse2 = gbm.mse(train=False, valid=True, xval=False)\n    assert isinstance(mse2, float)\n    mse3 = gbm.mse(train=False, valid=False, xval=True)\n    assert isinstance(mse3, float)\n    mse = gbm.mse(train=True, valid=True, xval=False)\n    assert 'train' in list(mse.keys()) and 'valid' in list(mse.keys()), 'expected training and validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert len(mse) == 2, 'expected only training and validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert isinstance(mse['train'], float) and isinstance(mse['valid'], float), 'expected training and validation metrics to be floats, but got {0} and {1}'.format(type(mse['train']), type(mse['valid']))\n    assert mse['valid'] == mse2\n    mse = gbm.mse(train=True, valid=False, xval=True)\n    assert 'train' in list(mse.keys()) and 'xval' in list(mse.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert len(mse) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert isinstance(mse['train'], float) and isinstance(mse['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(mse['train']), type(mse['xval']))\n    assert mse['xval'] == mse3\n    mse = gbm.mse(train=True, valid=True, xval=True)\n    assert 'train' in list(mse.keys()) and 'valid' in list(mse.keys()) and ('xval' in list(mse.keys())), 'expected training, validation, and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert len(mse) == 3, 'expected training, validation and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert isinstance(mse['train'], float) and isinstance(mse['valid'], float) and isinstance(mse['xval'], float), 'expected training, validation, and cross validation metrics to be floats, but got {0}, {1}, and {2}'.format(type(mse['train']), type(mse['valid']), type(mse['xval']))\n    mse = gbm.mse(train=False, valid=False, xval=False)\n    assert isinstance(mse, float)\n    assert mse == mse1\n    mse = gbm.mse(train=False, valid=True, xval=True)\n    assert 'valid' in list(mse.keys()) and 'xval' in list(mse.keys()), 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert len(mse) == 2, 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert isinstance(mse['valid'], float) and isinstance(mse['xval'], float), 'validation and cross validation metrics to be floats, but got {0} and {1}'.format(type(mse['valid']), type(mse['xval']))\n    mean_residual_deviance1 = gbm.mean_residual_deviance(train=True, valid=False, xval=False)\n    assert isinstance(mean_residual_deviance1, float)\n    mean_residual_deviance2 = gbm.mean_residual_deviance(train=False, valid=True, xval=False)\n    assert isinstance(mean_residual_deviance2, float)\n    mean_residual_deviance3 = gbm.mean_residual_deviance(train=False, valid=False, xval=True)\n    assert isinstance(mean_residual_deviance3, float)\n    mean_residual_deviance = gbm.mean_residual_deviance(train=True, valid=True, xval=False)\n    assert 'train' in list(mean_residual_deviance.keys()) and 'valid' in list(mean_residual_deviance.keys()), 'expected training and validation metrics to be returned, but got {0}'.format(list(mean_residual_deviance.keys()))\n    assert len(mean_residual_deviance) == 2, 'expected only training and validation metrics to be returned, but got {0}'.format(list(mean_residual_deviance.keys()))\n    assert isinstance(mean_residual_deviance['train'], float) and isinstance(mean_residual_deviance['valid'], float), 'expected training and validation metrics to be floats, but got {0} and {1}'.format(type(mean_residual_deviance['train']), type(mean_residual_deviance['valid']))\n    assert mean_residual_deviance['valid'] == mean_residual_deviance2\n    mean_residual_deviance = gbm.mean_residual_deviance(train=True, valid=False, xval=True)\n    assert 'train' in list(mean_residual_deviance.keys()) and 'xval' in list(mean_residual_deviance.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(mean_residual_deviance.keys()))\n    assert len(mean_residual_deviance) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(mean_residual_deviance.keys()))\n    assert isinstance(mean_residual_deviance['train'], float) and isinstance(mean_residual_deviance['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(mean_residual_deviance['train']), type(mean_residual_deviance['xval']))\n    assert mean_residual_deviance['xval'] == mean_residual_deviance3\n    mean_residual_deviance = gbm.mean_residual_deviance(train=True, valid=True, xval=True)\n    assert 'train' in list(mean_residual_deviance.keys()) and 'valid' in list(mean_residual_deviance.keys()) and ('xval' in list(mean_residual_deviance.keys())), 'expected training, validation, and cross validation metrics to be returned, but got {0}'.format(list(mean_residual_deviance.keys()))\n    assert len(mean_residual_deviance) == 3, 'expected training, validation and cross validation metrics to be returned, but got {0}'.format(list(mean_residual_deviance.keys()))\n    assert isinstance(mean_residual_deviance['train'], float) and isinstance(mean_residual_deviance['valid'], float) and isinstance(mean_residual_deviance['xval'], float), 'expected training, validation, and cross validation metrics to be floats, but got {0}, {1}, and {2}'.format(type(mean_residual_deviance['train']), type(mean_residual_deviance['valid']), type(mean_residual_deviance['xval']))\n    mean_residual_deviance = gbm.mean_residual_deviance(train=False, valid=False, xval=False)\n    assert isinstance(mean_residual_deviance, float)\n    assert mean_residual_deviance == mean_residual_deviance1\n    mean_residual_deviance = gbm.mean_residual_deviance(train=False, valid=True, xval=True)\n    assert 'valid' in list(mean_residual_deviance.keys()) and 'xval' in list(mean_residual_deviance.keys()), 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(mean_residual_deviance.keys()))\n    assert len(mean_residual_deviance) == 2, 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(mean_residual_deviance.keys()))\n    assert isinstance(mean_residual_deviance['valid'], float) and isinstance(mean_residual_deviance['xval'], float), 'validation and cross validation metrics to be floats, but got {0} and {1}'.format(type(mean_residual_deviance['valid']), type(mean_residual_deviance['xval']))\n    cars = h2o.import_file(path=pyunit_utils.locate('smalldata/junit/cars_20mpg.csv'))\n    cars['economy_20mpg'] = cars['economy_20mpg'].asfactor()\n    r = cars[0].runif()\n    train = cars[r > 0.2]\n    valid = cars[r <= 0.2]\n    response_col = 'economy_20mpg'\n    distribution = 'bernoulli'\n    predictors = ['displacement', 'power', 'weight', 'acceleration', 'year']\n    gbm = H2OGradientBoostingEstimator(nfolds=3, distribution=distribution, fold_assignment='Random')\n    gbm.train(y=response_col, x=predictors, validation_frame=valid, training_frame=train)\n    for metric in ['gini', 'logloss', 'auc', 'aucpr', 'mse', 'rmse']:\n        val = getattr(gbm, metric)()\n        assert isinstance(val, float), 'expected a float for metric {} but got {}'.format(metric, val)\n    for metric in ['mcc', 'F1', 'F0point5', 'F2', 'accuracy', 'mean_per_class_error']:\n        val = getattr(gbm, metric)()[0][1]\n        assert isinstance(val, float), 'expected a float for metric {} but got {}'.format(metric, val)\n    auc1 = gbm.auc(train=True, valid=False, xval=False)\n    assert isinstance(auc1, float)\n    auc2 = gbm.auc(train=False, valid=True, xval=False)\n    assert isinstance(auc2, float)\n    auc3 = gbm.auc(train=False, valid=False, xval=True)\n    assert isinstance(auc3, float)\n    auc = gbm.auc(train=True, valid=True, xval=False)\n    assert 'train' in list(auc.keys()) and 'valid' in list(auc.keys()), 'expected training and validation metrics to be returned, but got {0}'.format(list(auc.keys()))\n    assert len(auc) == 2, 'expected only training and validation metrics to be returned, but got {0}'.format(list(auc.keys()))\n    assert isinstance(auc['train'], float) and isinstance(auc['valid'], float), 'expected training and validation metrics to be floats, but got {0} and {1}'.format(type(auc['train']), type(auc['valid']))\n    assert auc['valid'] == auc2\n    auc = gbm.auc(train=True, valid=False, xval=True)\n    assert 'train' in list(auc.keys()) and 'xval' in list(auc.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(auc.keys()))\n    assert len(auc) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(auc.keys()))\n    assert isinstance(auc['train'], float) and isinstance(auc['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(auc['train']), type(auc['xval']))\n    assert auc['xval'] == auc3\n    auc = gbm.auc(train=True, valid=True, xval=True)\n    assert 'train' in list(auc.keys()) and 'valid' in list(auc.keys()) and ('xval' in list(auc.keys())), 'expected training, validation, and cross validation metrics to be returned, but got {0}'.format(list(auc.keys()))\n    assert len(auc) == 3, 'expected training, validation and cross validation metrics to be returned, but got {0}'.format(list(auc.keys()))\n    assert isinstance(auc['train'], float) and isinstance(auc['valid'], float) and isinstance(auc['xval'], float), 'expected training, validation, and cross validation metrics to be floats, but got {0}, {1}, and {2}'.format(type(auc['train']), type(auc['valid']), type(auc['xval']))\n    auc = gbm.auc(train=False, valid=False, xval=False)\n    assert isinstance(auc, float)\n    assert auc == auc1\n    auc = gbm.auc(train=False, valid=True, xval=True)\n    assert 'valid' in list(auc.keys()) and 'xval' in list(auc.keys()), 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(auc.keys()))\n    assert len(auc) == 2, 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(auc.keys()))\n    assert isinstance(auc['valid'], float) and isinstance(auc['xval'], float), 'validation and cross validation metrics to be floats, but got {0} and {1}'.format(type(auc['valid']), type(auc['xval']))\n    (fprs1, tprs1) = gbm.roc(train=True, valid=False, xval=False)\n    assert isinstance(fprs1, list)\n    assert isinstance(tprs1, list)\n    (fprs2, tprs2) = gbm.roc(train=False, valid=True, xval=False)\n    assert isinstance(fprs2, list)\n    assert isinstance(tprs2, list)\n    (fprs3, tprs3) = gbm.roc(train=False, valid=False, xval=True)\n    assert isinstance(fprs3, list)\n    assert isinstance(tprs3, list)\n    roc = gbm.roc(train=True, valid=True, xval=False)\n    assert 'train' in list(roc.keys()) and 'valid' in list(roc.keys()), 'expected training and validation metrics to be returned, but got {0}'.format(list(roc.keys()))\n    assert len(roc) == 2, 'expected only training and validation metrics to be returned, but got {0}'.format(list(roc.keys()))\n    assert isinstance(roc['train'], tuple) and isinstance(roc['valid'], tuple), 'expected training and validation metrics to be tuples, but got {0} and {1}'.format(type(roc['train']), type(roc['valid']))\n    assert roc['valid'][0] == fprs2\n    assert roc['valid'][1] == tprs2\n    roc = gbm.roc(train=True, valid=False, xval=True)\n    assert 'train' in list(roc.keys()) and 'xval' in list(roc.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(roc.keys()))\n    assert len(roc) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(roc.keys()))\n    assert isinstance(roc['train'], tuple) and isinstance(roc['xval'], tuple), 'expected training and cross validation metrics to be tuples, but got {0} and {1}'.format(type(roc['train']), type(roc['xval']))\n    assert roc['xval'][0] == fprs3\n    assert roc['xval'][1] == tprs3\n    roc = gbm.roc(train=True, valid=True, xval=True)\n    assert 'train' in list(roc.keys()) and 'valid' in list(roc.keys()) and ('xval' in list(roc.keys())), 'expected training, validation, and cross validation metrics to be returned, but got {0}'.format(list(roc.keys()))\n    assert len(roc) == 3, 'expected training, validation and cross validation metrics to be returned, but got {0}'.format(list(roc.keys()))\n    assert isinstance(roc['train'], tuple) and isinstance(roc['valid'], tuple) and isinstance(roc['xval'], tuple), 'expected training, validation, and cross validation metrics to be tuples, but got {0}, {1}, and {2}'.format(type(roc['train']), type(roc['valid']), type(roc['xval']))\n    (fprs, tprs) = gbm.roc(train=False, valid=False, xval=False)\n    assert isinstance(fprs, list)\n    assert isinstance(tprs, list)\n    assert fprs == fprs1\n    assert tprs == tprs1\n    roc = gbm.roc(train=False, valid=True, xval=True)\n    assert 'valid' in list(roc.keys()) and 'xval' in list(roc.keys()), 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(roc.keys()))\n    assert len(roc) == 2, 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(roc.keys()))\n    assert isinstance(roc['valid'], tuple) and isinstance(roc['xval'], tuple), 'validation and cross validation metrics to be tuples, but got {0} and {1}'.format(type(roc['valid']), type(roc['xval']))\n    logloss1 = gbm.logloss(train=True, valid=False, xval=False)\n    assert isinstance(logloss1, float)\n    logloss2 = gbm.logloss(train=False, valid=True, xval=False)\n    assert isinstance(logloss2, float)\n    logloss3 = gbm.logloss(train=False, valid=False, xval=True)\n    assert isinstance(logloss3, float)\n    logloss = gbm.logloss(train=True, valid=True, xval=False)\n    assert 'train' in list(logloss.keys()) and 'valid' in list(logloss.keys()), 'expected training and validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert len(logloss) == 2, 'expected only training and validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert isinstance(logloss['train'], float) and isinstance(logloss['valid'], float), 'expected training and validation metrics to be floats, but got {0} and {1}'.format(type(logloss['train']), type(logloss['valid']))\n    assert logloss['valid'] == logloss2\n    logloss = gbm.logloss(train=True, valid=False, xval=True)\n    assert 'train' in list(logloss.keys()) and 'xval' in list(logloss.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert len(logloss) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert isinstance(logloss['train'], float) and isinstance(logloss['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(logloss['train']), type(logloss['xval']))\n    assert logloss['xval'] == logloss3\n    logloss = gbm.logloss(train=True, valid=True, xval=True)\n    assert 'train' in list(logloss.keys()) and 'valid' in list(logloss.keys()) and ('xval' in list(logloss.keys())), 'expected training, validation, and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert len(logloss) == 3, 'expected training, validation and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert isinstance(logloss['train'], float) and isinstance(logloss['valid'], float) and isinstance(logloss['xval'], float), 'expected training, validation, and cross validation metrics to be floats, but got {0}, {1}, and {2}'.format(type(logloss['train']), type(logloss['valid']), type(logloss['xval']))\n    logloss = gbm.logloss(train=False, valid=False, xval=False)\n    assert isinstance(logloss, float)\n    assert logloss == logloss1\n    logloss = gbm.logloss(train=False, valid=True, xval=True)\n    assert 'valid' in list(logloss.keys()) and 'xval' in list(logloss.keys()), 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert len(logloss) == 2, 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert isinstance(logloss['valid'], float) and isinstance(logloss['xval'], float), 'validation and cross validation metrics to be floats, but got {0} and {1}'.format(type(logloss['valid']), type(logloss['xval']))\n    gini1 = gbm.gini(train=True, valid=False, xval=False)\n    assert isinstance(gini1, float)\n    gini2 = gbm.gini(train=False, valid=True, xval=False)\n    assert isinstance(gini2, float)\n    gini3 = gbm.gini(train=False, valid=False, xval=True)\n    assert isinstance(gini3, float)\n    gini = gbm.gini(train=True, valid=True, xval=False)\n    assert 'train' in list(gini.keys()) and 'valid' in list(gini.keys()), 'expected training and validation metrics to be returned, but got {0}'.format(list(gini.keys()))\n    assert len(gini) == 2, 'expected only training and validation metrics to be returned, but got {0}'.format(list(gini.keys()))\n    assert isinstance(gini['train'], float) and isinstance(gini['valid'], float), 'expected training and validation metrics to be floats, but got {0} and {1}'.format(type(gini['train']), type(gini['valid']))\n    assert gini['valid'] == gini2\n    gini = gbm.gini(train=True, valid=False, xval=True)\n    assert 'train' in list(gini.keys()) and 'xval' in list(gini.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(gini.keys()))\n    assert len(gini) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(gini.keys()))\n    assert isinstance(gini['train'], float) and isinstance(gini['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(gini['train']), type(gini['xval']))\n    assert gini['xval'] == gini3\n    gini = gbm.gini(train=True, valid=True, xval=True)\n    assert 'train' in list(gini.keys()) and 'valid' in list(gini.keys()) and ('xval' in list(gini.keys())), 'expected training, validation, and cross validation metrics to be returned, but got {0}'.format(list(gini.keys()))\n    assert len(gini) == 3, 'expected training, validation and cross validation metrics to be returned, but got {0}'.format(list(gini.keys()))\n    assert isinstance(gini['train'], float) and isinstance(gini['valid'], float) and isinstance(gini['xval'], float), 'expected training, validation, and cross validation metrics to be floats, but got {0}, {1}, and {2}'.format(type(gini['train']), type(gini['valid']), type(gini['xval']))\n    gini = gbm.gini(train=False, valid=False, xval=False)\n    assert isinstance(gini, float)\n    assert gini == gini1\n    gini = gbm.gini(train=False, valid=True, xval=True)\n    assert 'valid' in list(gini.keys()) and 'xval' in list(gini.keys()), 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(gini.keys()))\n    assert len(gini) == 2, 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(gini.keys()))\n    assert isinstance(gini['valid'], float) and isinstance(gini['xval'], float), 'validation and cross validation metrics to be floats, but got {0} and {1}'.format(type(gini['valid']), type(gini['xval']))\n    F11 = gbm.F1(train=True, valid=False, xval=False)\n    F12 = gbm.F1(train=False, valid=True, xval=False)\n    F13 = gbm.F1(train=False, valid=False, xval=True)\n    F1 = gbm.F1(train=True, valid=True, xval=False)\n    F1 = gbm.F1(train=True, valid=False, xval=True)\n    F1 = gbm.F1(train=True, valid=True, xval=True)\n    F1 = gbm.F1(train=False, valid=False, xval=False)\n    F1 = gbm.F1(train=False, valid=True, xval=True)\n    F0point51 = gbm.F0point5(train=True, valid=False, xval=False)\n    F0point52 = gbm.F0point5(train=False, valid=True, xval=False)\n    F0point53 = gbm.F0point5(train=False, valid=False, xval=True)\n    F0point5 = gbm.F0point5(train=True, valid=True, xval=False)\n    F0point5 = gbm.F0point5(train=True, valid=False, xval=True)\n    F0point5 = gbm.F0point5(train=True, valid=True, xval=True)\n    F0point5 = gbm.F0point5(train=False, valid=False, xval=False)\n    F0point5 = gbm.F0point5(train=False, valid=True, xval=True)\n    F21 = gbm.F2(train=True, valid=False, xval=False)\n    F22 = gbm.F2(train=False, valid=True, xval=False)\n    F23 = gbm.F2(train=False, valid=False, xval=True)\n    F2 = gbm.F2(train=True, valid=True, xval=False)\n    F2 = gbm.F2(train=True, valid=False, xval=True)\n    F2 = gbm.F2(train=True, valid=True, xval=True)\n    F2 = gbm.F2(train=False, valid=False, xval=False)\n    F2 = gbm.F2(train=False, valid=True, xval=True)\n    accuracy1 = gbm.accuracy(train=True, valid=False, xval=False)\n    accuracy2 = gbm.accuracy(train=False, valid=True, xval=False)\n    accuracy3 = gbm.accuracy(train=False, valid=False, xval=True)\n    accuracy = gbm.accuracy(train=True, valid=True, xval=False)\n    accuracy = gbm.accuracy(train=True, valid=False, xval=True)\n    accuracy = gbm.accuracy(train=True, valid=True, xval=True)\n    accuracy = gbm.accuracy(train=False, valid=False, xval=False)\n    accuracy = gbm.accuracy(train=False, valid=True, xval=True)\n    error1 = gbm.error(train=True, valid=False, xval=False)\n    error2 = gbm.error(train=False, valid=True, xval=False)\n    error3 = gbm.error(train=False, valid=False, xval=True)\n    error = gbm.error(train=True, valid=True, xval=False)\n    error = gbm.error(train=True, valid=False, xval=True)\n    error = gbm.error(train=True, valid=True, xval=True)\n    error = gbm.error(train=False, valid=False, xval=False)\n    error = gbm.error(train=False, valid=True, xval=True)\n    precision1 = gbm.precision(train=True, valid=False, xval=False)\n    precision2 = gbm.precision(train=False, valid=True, xval=False)\n    precision3 = gbm.precision(train=False, valid=False, xval=True)\n    precision = gbm.precision(train=True, valid=True, xval=False)\n    precision = gbm.precision(train=True, valid=False, xval=True)\n    precision = gbm.precision(train=True, valid=True, xval=True)\n    precision = gbm.precision(train=False, valid=False, xval=False)\n    precision = gbm.precision(train=False, valid=True, xval=True)\n    mcc1 = gbm.mcc(train=True, valid=False, xval=False)\n    mcc2 = gbm.mcc(train=False, valid=True, xval=False)\n    mcc3 = gbm.mcc(train=False, valid=False, xval=True)\n    mcc = gbm.mcc(train=True, valid=True, xval=False)\n    mcc = gbm.mcc(train=True, valid=False, xval=True)\n    mcc = gbm.mcc(train=True, valid=True, xval=True)\n    mcc = gbm.mcc(train=False, valid=False, xval=False)\n    mcc = gbm.mcc(train=False, valid=True, xval=True)\n    max_per_class_error1 = gbm.max_per_class_error(train=True, valid=False, xval=False)\n    max_per_class_error2 = gbm.max_per_class_error(train=False, valid=True, xval=False)\n    max_per_class_error3 = gbm.max_per_class_error(train=False, valid=False, xval=True)\n    max_per_class_error = gbm.max_per_class_error(train=True, valid=True, xval=False)\n    max_per_class_error = gbm.max_per_class_error(train=True, valid=False, xval=True)\n    max_per_class_error = gbm.max_per_class_error(train=True, valid=True, xval=True)\n    max_per_class_error = gbm.max_per_class_error(train=False, valid=False, xval=False)\n    max_per_class_error = gbm.max_per_class_error(train=False, valid=True, xval=True)\n    mean_per_class_error1 = gbm.mean_per_class_error(train=True, valid=False, xval=False)\n    mean_per_class_error2 = gbm.mean_per_class_error(train=False, valid=True, xval=False)\n    mean_per_class_error3 = gbm.mean_per_class_error(train=False, valid=False, xval=True)\n    mean_per_class_error = gbm.mean_per_class_error(train=True, valid=True, xval=False)\n    mean_per_class_error = gbm.mean_per_class_error(train=True, valid=False, xval=True)\n    mean_per_class_error = gbm.mean_per_class_error(train=True, valid=True, xval=True)\n    mean_per_class_error = gbm.mean_per_class_error(train=False, valid=False, xval=False)\n    mean_per_class_error = gbm.mean_per_class_error(train=False, valid=True, xval=True)\n    confusion_matrix1 = gbm.confusion_matrix(train=True, valid=False, xval=False)\n    confusion_matrix2 = gbm.confusion_matrix(train=False, valid=True, xval=False)\n    confusion_matrix3 = gbm.confusion_matrix(train=False, valid=False, xval=True)\n    confusion_matrix = gbm.confusion_matrix(train=True, valid=True, xval=False)\n    confusion_matrix = gbm.confusion_matrix(train=True, valid=False, xval=True)\n    confusion_matrix = gbm.confusion_matrix(train=True, valid=True, xval=True)\n    confusion_matrix = gbm.confusion_matrix(train=False, valid=False, xval=False)\n    confusion_matrix = gbm.confusion_matrix(train=False, valid=True, xval=True)\n    tpr1 = gbm.tpr(train=True, valid=False, xval=False)\n    tpr2 = gbm.tpr(train=False, valid=True, xval=False)\n    tpr3 = gbm.tpr(train=False, valid=False, xval=True)\n    tpr = gbm.tpr(train=True, valid=True, xval=False)\n    tpr = gbm.tpr(train=True, valid=False, xval=True)\n    tpr = gbm.tpr(train=True, valid=True, xval=True)\n    tpr = gbm.tpr(train=False, valid=False, xval=False)\n    tpr = gbm.tpr(train=False, valid=True, xval=True)\n    tnr1 = gbm.tnr(train=True, valid=False, xval=False)\n    tnr2 = gbm.tnr(train=False, valid=True, xval=False)\n    tnr3 = gbm.tnr(train=False, valid=False, xval=True)\n    tnr = gbm.tnr(train=True, valid=True, xval=False)\n    tnr = gbm.tnr(train=True, valid=False, xval=True)\n    tnr = gbm.tnr(train=True, valid=True, xval=True)\n    tnr = gbm.tnr(train=False, valid=False, xval=False)\n    tnr = gbm.tnr(train=False, valid=True, xval=True)\n    fnr1 = gbm.fnr(train=True, valid=False, xval=False)\n    fnr2 = gbm.fnr(train=False, valid=True, xval=False)\n    fnr3 = gbm.fnr(train=False, valid=False, xval=True)\n    fnr = gbm.fnr(train=True, valid=True, xval=False)\n    fnr = gbm.fnr(train=True, valid=False, xval=True)\n    fnr = gbm.fnr(train=True, valid=True, xval=True)\n    fnr = gbm.fnr(train=False, valid=False, xval=False)\n    fnr = gbm.fnr(train=False, valid=True, xval=True)\n    fpr1 = gbm.fpr(train=True, valid=False, xval=False)\n    fpr2 = gbm.fpr(train=False, valid=True, xval=False)\n    fpr3 = gbm.fpr(train=False, valid=False, xval=True)\n    fpr = gbm.fpr(train=True, valid=True, xval=False)\n    fpr = gbm.fpr(train=True, valid=False, xval=True)\n    fpr = gbm.fpr(train=True, valid=True, xval=True)\n    fpr = gbm.fpr(train=False, valid=False, xval=False)\n    fpr = gbm.fpr(train=False, valid=True, xval=True)\n    cars = h2o.import_file(path=pyunit_utils.locate('smalldata/junit/cars_20mpg.csv'))\n    cars['cylinders'] = cars['cylinders'].asfactor()\n    r = cars[0].runif()\n    train = cars[r > 0.2]\n    valid = cars[r <= 0.2]\n    response_col = 'cylinders'\n    distribution = 'multinomial'\n    predictors = ['displacement', 'power', 'weight', 'acceleration', 'year']\n    gbm = H2OGradientBoostingEstimator(nfolds=3, distribution=distribution, fold_assignment='Random')\n    gbm.train(x=predictors, y=response_col, training_frame=train, validation_frame=valid)\n    for metric in ['logloss', 'mse', 'rmse', 'mean_per_class_error']:\n        val = getattr(gbm, metric)()\n        assert isinstance(val, float), 'expected a float for metric {} but got {}'.format(metric, val)\n    mse1 = gbm.mse(train=True, valid=False, xval=False)\n    assert isinstance(mse1, float)\n    mse2 = gbm.mse(train=False, valid=True, xval=False)\n    assert isinstance(mse2, float)\n    mse3 = gbm.mse(train=False, valid=False, xval=True)\n    assert isinstance(mse3, float)\n    mse = gbm.mse(train=True, valid=True, xval=False)\n    assert 'train' in list(mse.keys()) and 'valid' in list(mse.keys()), 'expected training and validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert len(mse) == 2, 'expected only training and validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert isinstance(mse['train'], float) and isinstance(mse['valid'], float), 'expected training and validation metrics to be floats, but got {0} and {1}'.format(type(mse['train']), type(mse['valid']))\n    assert mse['valid'] == mse2\n    mse = gbm.mse(train=True, valid=False, xval=True)\n    assert 'train' in list(mse.keys()) and 'xval' in list(mse.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert len(mse) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert isinstance(mse['train'], float) and isinstance(mse['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(mse['train']), type(mse['xval']))\n    assert mse['xval'] == mse3\n    mse = gbm.mse(train=True, valid=True, xval=True)\n    assert 'train' in list(mse.keys()) and 'valid' in list(mse.keys()) and ('xval' in list(mse.keys())), 'expected training, validation, and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert len(mse) == 3, 'expected training, validation and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert isinstance(mse['train'], float) and isinstance(mse['valid'], float) and isinstance(mse['xval'], float), 'expected training, validation, and cross validation metrics to be floats, but got {0}, {1}, and {2}'.format(type(mse['train']), type(mse['valid']), type(mse['xval']))\n    mse = gbm.mse(train=False, valid=False, xval=False)\n    assert isinstance(mse, float)\n    assert mse == mse1\n    mse = gbm.mse(train=False, valid=True, xval=True)\n    assert 'valid' in list(mse.keys()) and 'xval' in list(mse.keys()), 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert len(mse) == 2, 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(mse.keys()))\n    assert isinstance(mse['valid'], float) and isinstance(mse['xval'], float), 'validation and cross validation metrics to be floats, but got {0} and {1}'.format(type(mse['valid']), type(mse['xval']))\n    logloss1 = gbm.logloss(train=True, valid=False, xval=False)\n    assert isinstance(logloss1, float)\n    logloss2 = gbm.logloss(train=False, valid=True, xval=False)\n    assert isinstance(logloss2, float)\n    logloss3 = gbm.logloss(train=False, valid=False, xval=True)\n    assert isinstance(logloss3, float)\n    logloss = gbm.logloss(train=True, valid=True, xval=False)\n    assert 'train' in list(logloss.keys()) and 'valid' in list(logloss.keys()), 'expected training and validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert len(logloss) == 2, 'expected only training and validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert isinstance(logloss['train'], float) and isinstance(logloss['valid'], float), 'expected training and validation metrics to be floats, but got {0} and {1}'.format(type(logloss['train']), type(logloss['valid']))\n    assert logloss['valid'] == logloss2\n    logloss = gbm.logloss(train=True, valid=False, xval=True)\n    assert 'train' in list(logloss.keys()) and 'xval' in list(logloss.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert len(logloss) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert isinstance(logloss['train'], float) and isinstance(logloss['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(logloss['train']), type(logloss['xval']))\n    assert logloss['xval'] == logloss3\n    logloss = gbm.logloss(train=True, valid=True, xval=True)\n    assert 'train' in list(logloss.keys()) and 'valid' in list(logloss.keys()) and ('xval' in list(logloss.keys())), 'expected training, validation, and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert len(logloss) == 3, 'expected training, validation and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert isinstance(logloss['train'], float) and isinstance(logloss['valid'], float) and isinstance(logloss['xval'], float), 'expected training, validation, and cross validation metrics to be floats, but got {0}, {1}, and {2}'.format(type(logloss['train']), type(logloss['valid']), type(logloss['xval']))\n    logloss = gbm.logloss(train=False, valid=False, xval=False)\n    assert isinstance(logloss, float)\n    assert logloss == logloss1\n    logloss = gbm.logloss(train=False, valid=True, xval=True)\n    assert 'valid' in list(logloss.keys()) and 'xval' in list(logloss.keys()), 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert len(logloss) == 2, 'expected validation and cross validation metrics to be returned, but got {0}'.format(list(logloss.keys()))\n    assert isinstance(logloss['valid'], float) and isinstance(logloss['xval'], float), 'validation and cross validation metrics to be floats, but got {0} and {1}'.format(type(logloss['valid']), type(logloss['xval']))\n    hit_ratio_table1 = gbm.hit_ratio_table(train=True, valid=False, xval=False)\n    hit_ratio_table2 = gbm.hit_ratio_table(train=False, valid=True, xval=False)\n    hit_ratio_table3 = gbm.hit_ratio_table(train=False, valid=False, xval=True)\n    hit_ratio_table = gbm.hit_ratio_table(train=True, valid=True, xval=False)\n    hit_ratio_table = gbm.hit_ratio_table(train=True, valid=False, xval=True)\n    hit_ratio_table = gbm.hit_ratio_table(train=True, valid=True, xval=True)\n    hit_ratio_table = gbm.hit_ratio_table(train=False, valid=False, xval=False)\n    hit_ratio_table = gbm.hit_ratio_table(train=False, valid=True, xval=True)\n    mean_per_class_error1 = gbm.mean_per_class_error(train=True, valid=False, xval=False)\n    mean_per_class_error2 = gbm.mean_per_class_error(train=False, valid=True, xval=False)\n    mean_per_class_error3 = gbm.mean_per_class_error(train=False, valid=False, xval=True)\n    mean_per_class_error = gbm.mean_per_class_error(train=True, valid=True, xval=False)\n    mean_per_class_error = gbm.mean_per_class_error(train=True, valid=False, xval=True)\n    mean_per_class_error = gbm.mean_per_class_error(train=True, valid=True, xval=True)\n    mean_per_class_error = gbm.mean_per_class_error(train=False, valid=False, xval=False)\n    mean_per_class_error = gbm.mean_per_class_error(train=False, valid=True, xval=True)\n    iris = h2o.import_file(path=pyunit_utils.locate('smalldata/iris/iris.csv'))\n    from h2o.estimators.kmeans import H2OKMeansEstimator\n    km = H2OKMeansEstimator(k=3, nfolds=3)\n    km.train(x=list(range(4)), training_frame=iris)\n    betweenss1 = km.betweenss(train=True, valid=False, xval=False)\n    assert isinstance(betweenss1, float)\n    betweenss3 = km.betweenss(train=False, valid=False, xval=True)\n    assert isinstance(betweenss3, float)\n    betweenss = km.betweenss(train=True, valid=False, xval=True)\n    assert 'train' in list(betweenss.keys()) and 'xval' in list(betweenss.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(betweenss.keys()))\n    assert len(betweenss) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(betweenss.keys()))\n    assert isinstance(betweenss['train'], float) and isinstance(betweenss['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(betweenss['train']), type(betweenss['xval']))\n    assert betweenss['xval'] == betweenss3\n    betweenss = km.betweenss(train=False, valid=False, xval=False)\n    assert isinstance(betweenss, float)\n    assert betweenss == betweenss1\n    totss1 = km.totss(train=True, valid=False, xval=False)\n    assert isinstance(totss1, float)\n    totss3 = km.totss(train=False, valid=False, xval=True)\n    assert isinstance(totss3, float)\n    totss = km.totss(train=True, valid=False, xval=True)\n    assert 'train' in list(totss.keys()) and 'xval' in list(totss.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(totss.keys()))\n    assert len(totss) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(totss.keys()))\n    assert isinstance(totss['train'], float) and isinstance(totss['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(totss['train']), type(totss['xval']))\n    assert totss['xval'] == totss3\n    totss = km.totss(train=False, valid=False, xval=False)\n    assert isinstance(totss, float)\n    assert totss == totss1\n    tot_withinss1 = km.tot_withinss(train=True, valid=False, xval=False)\n    assert isinstance(tot_withinss1, float)\n    tot_withinss3 = km.tot_withinss(train=False, valid=False, xval=True)\n    assert isinstance(tot_withinss3, float)\n    tot_withinss = km.tot_withinss(train=True, valid=False, xval=True)\n    assert 'train' in list(tot_withinss.keys()) and 'xval' in list(tot_withinss.keys()), 'expected training and cross validation metrics to be returned, but got {0}'.format(list(tot_withinss.keys()))\n    assert len(tot_withinss) == 2, 'expected only training and cross validation metrics to be returned, but got {0}'.format(list(tot_withinss.keys()))\n    assert isinstance(tot_withinss['train'], float) and isinstance(tot_withinss['xval'], float), 'expected training and cross validation metrics to be floats, but got {0} and {1}'.format(type(tot_withinss['train']), type(tot_withinss['xval']))\n    assert tot_withinss['xval'] == tot_withinss3\n    tot_withinss = km.tot_withinss(train=False, valid=False, xval=False)\n    assert isinstance(tot_withinss, float)\n    assert tot_withinss == tot_withinss1\n    withinss1 = km.withinss(train=True, valid=False)\n    withinss2 = km.withinss(train=True, valid=True)\n    withinss3 = km.withinss(train=False, valid=False)\n    assert withinss1 == withinss3\n    assert withinss1 != withinss2\n    centroid_stats1 = km.centroid_stats(train=True, valid=False)\n    centroid_stats2 = km.centroid_stats(train=True, valid=True)\n    centroid_stats3 = km.centroid_stats(train=False, valid=False)\n    assert centroid_stats1 == centroid_stats3\n    assert centroid_stats1 != centroid_stats2\n    size1 = km.size(train=True, valid=False)\n    size2 = km.size(train=True, valid=True)\n    size3 = km.size(train=False, valid=False)\n    assert size1 == size3\n    assert size1 != size2"
        ]
    }
]