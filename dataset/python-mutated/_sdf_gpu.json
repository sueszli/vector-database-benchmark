[
    {
        "func_name": "__init__",
        "original": "def __init__(self):\n    self.program_seed = Program(vert_seed, frag_seed)\n    self.program_flood = Program(vert, frag_flood)\n    self.program_insert = Program(vert, frag_insert)\n    self.programs = [self.program_seed, self.program_flood, self.program_insert]\n    self.fbo_to = [FrameBuffer(), FrameBuffer(), FrameBuffer()]\n    vtype = np.dtype([('a_position', np.float32, 2), ('a_texcoord', np.float32, 2)])\n    vertices = np.zeros(4, dtype=vtype)\n    vertices['a_position'] = [[-1.0, -1.0], [-1.0, 1.0], [1.0, -1.0], [1.0, 1.0]]\n    vertices['a_texcoord'] = [[0.0, 0.0], [0.0, 1.0], [1.0, 0.0], [1.0, 1.0]]\n    vertices = VertexBuffer(vertices)\n    self.program_insert['u_step'] = 1.0\n    for program in self.programs:\n        program.bind(vertices)",
        "mutated": [
            "def __init__(self):\n    if False:\n        i = 10\n    self.program_seed = Program(vert_seed, frag_seed)\n    self.program_flood = Program(vert, frag_flood)\n    self.program_insert = Program(vert, frag_insert)\n    self.programs = [self.program_seed, self.program_flood, self.program_insert]\n    self.fbo_to = [FrameBuffer(), FrameBuffer(), FrameBuffer()]\n    vtype = np.dtype([('a_position', np.float32, 2), ('a_texcoord', np.float32, 2)])\n    vertices = np.zeros(4, dtype=vtype)\n    vertices['a_position'] = [[-1.0, -1.0], [-1.0, 1.0], [1.0, -1.0], [1.0, 1.0]]\n    vertices['a_texcoord'] = [[0.0, 0.0], [0.0, 1.0], [1.0, 0.0], [1.0, 1.0]]\n    vertices = VertexBuffer(vertices)\n    self.program_insert['u_step'] = 1.0\n    for program in self.programs:\n        program.bind(vertices)",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.program_seed = Program(vert_seed, frag_seed)\n    self.program_flood = Program(vert, frag_flood)\n    self.program_insert = Program(vert, frag_insert)\n    self.programs = [self.program_seed, self.program_flood, self.program_insert]\n    self.fbo_to = [FrameBuffer(), FrameBuffer(), FrameBuffer()]\n    vtype = np.dtype([('a_position', np.float32, 2), ('a_texcoord', np.float32, 2)])\n    vertices = np.zeros(4, dtype=vtype)\n    vertices['a_position'] = [[-1.0, -1.0], [-1.0, 1.0], [1.0, -1.0], [1.0, 1.0]]\n    vertices['a_texcoord'] = [[0.0, 0.0], [0.0, 1.0], [1.0, 0.0], [1.0, 1.0]]\n    vertices = VertexBuffer(vertices)\n    self.program_insert['u_step'] = 1.0\n    for program in self.programs:\n        program.bind(vertices)",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.program_seed = Program(vert_seed, frag_seed)\n    self.program_flood = Program(vert, frag_flood)\n    self.program_insert = Program(vert, frag_insert)\n    self.programs = [self.program_seed, self.program_flood, self.program_insert]\n    self.fbo_to = [FrameBuffer(), FrameBuffer(), FrameBuffer()]\n    vtype = np.dtype([('a_position', np.float32, 2), ('a_texcoord', np.float32, 2)])\n    vertices = np.zeros(4, dtype=vtype)\n    vertices['a_position'] = [[-1.0, -1.0], [-1.0, 1.0], [1.0, -1.0], [1.0, 1.0]]\n    vertices['a_texcoord'] = [[0.0, 0.0], [0.0, 1.0], [1.0, 0.0], [1.0, 1.0]]\n    vertices = VertexBuffer(vertices)\n    self.program_insert['u_step'] = 1.0\n    for program in self.programs:\n        program.bind(vertices)",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.program_seed = Program(vert_seed, frag_seed)\n    self.program_flood = Program(vert, frag_flood)\n    self.program_insert = Program(vert, frag_insert)\n    self.programs = [self.program_seed, self.program_flood, self.program_insert]\n    self.fbo_to = [FrameBuffer(), FrameBuffer(), FrameBuffer()]\n    vtype = np.dtype([('a_position', np.float32, 2), ('a_texcoord', np.float32, 2)])\n    vertices = np.zeros(4, dtype=vtype)\n    vertices['a_position'] = [[-1.0, -1.0], [-1.0, 1.0], [1.0, -1.0], [1.0, 1.0]]\n    vertices['a_texcoord'] = [[0.0, 0.0], [0.0, 1.0], [1.0, 0.0], [1.0, 1.0]]\n    vertices = VertexBuffer(vertices)\n    self.program_insert['u_step'] = 1.0\n    for program in self.programs:\n        program.bind(vertices)",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.program_seed = Program(vert_seed, frag_seed)\n    self.program_flood = Program(vert, frag_flood)\n    self.program_insert = Program(vert, frag_insert)\n    self.programs = [self.program_seed, self.program_flood, self.program_insert]\n    self.fbo_to = [FrameBuffer(), FrameBuffer(), FrameBuffer()]\n    vtype = np.dtype([('a_position', np.float32, 2), ('a_texcoord', np.float32, 2)])\n    vertices = np.zeros(4, dtype=vtype)\n    vertices['a_position'] = [[-1.0, -1.0], [-1.0, 1.0], [1.0, -1.0], [1.0, 1.0]]\n    vertices['a_texcoord'] = [[0.0, 0.0], [0.0, 1.0], [1.0, 0.0], [1.0, 1.0]]\n    vertices = VertexBuffer(vertices)\n    self.program_insert['u_step'] = 1.0\n    for program in self.programs:\n        program.bind(vertices)"
        ]
    },
    {
        "func_name": "render_to_texture",
        "original": "def render_to_texture(self, data, texture, offset, size):\n    \"\"\"Render a SDF to a texture at a given offset and size\n\n        Parameters\n        ----------\n        data : array\n            Must be 2D with type np.ubyte.\n        texture : instance of Texture2D\n            The texture to render to.\n        offset : tuple of int\n            Offset (x, y) to render to inside the texture.\n        size : tuple of int\n            Size (w, h) to render inside the texture.\n        \"\"\"\n    assert isinstance(texture, Texture2D)\n    set_state(blend=False, depth_test=False)\n    orig_tex = Texture2D(255 - data, format='luminance', wrapping='clamp_to_edge', interpolation='nearest')\n    edf_neg_tex = self._render_edf(orig_tex)\n    orig_tex[:, :, 0] = data\n    edf_pos_tex = self._render_edf(orig_tex)\n    self.program_insert['u_texture'] = orig_tex\n    self.program_insert['u_pos_texture'] = edf_pos_tex\n    self.program_insert['u_neg_texture'] = edf_neg_tex\n    self.fbo_to[-1].color_buffer = texture\n    with self.fbo_to[-1]:\n        set_viewport(tuple(offset) + tuple(size))\n        self.program_insert.draw('triangle_strip')",
        "mutated": [
            "def render_to_texture(self, data, texture, offset, size):\n    if False:\n        i = 10\n    'Render a SDF to a texture at a given offset and size\\n\\n        Parameters\\n        ----------\\n        data : array\\n            Must be 2D with type np.ubyte.\\n        texture : instance of Texture2D\\n            The texture to render to.\\n        offset : tuple of int\\n            Offset (x, y) to render to inside the texture.\\n        size : tuple of int\\n            Size (w, h) to render inside the texture.\\n        '\n    assert isinstance(texture, Texture2D)\n    set_state(blend=False, depth_test=False)\n    orig_tex = Texture2D(255 - data, format='luminance', wrapping='clamp_to_edge', interpolation='nearest')\n    edf_neg_tex = self._render_edf(orig_tex)\n    orig_tex[:, :, 0] = data\n    edf_pos_tex = self._render_edf(orig_tex)\n    self.program_insert['u_texture'] = orig_tex\n    self.program_insert['u_pos_texture'] = edf_pos_tex\n    self.program_insert['u_neg_texture'] = edf_neg_tex\n    self.fbo_to[-1].color_buffer = texture\n    with self.fbo_to[-1]:\n        set_viewport(tuple(offset) + tuple(size))\n        self.program_insert.draw('triangle_strip')",
            "def render_to_texture(self, data, texture, offset, size):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Render a SDF to a texture at a given offset and size\\n\\n        Parameters\\n        ----------\\n        data : array\\n            Must be 2D with type np.ubyte.\\n        texture : instance of Texture2D\\n            The texture to render to.\\n        offset : tuple of int\\n            Offset (x, y) to render to inside the texture.\\n        size : tuple of int\\n            Size (w, h) to render inside the texture.\\n        '\n    assert isinstance(texture, Texture2D)\n    set_state(blend=False, depth_test=False)\n    orig_tex = Texture2D(255 - data, format='luminance', wrapping='clamp_to_edge', interpolation='nearest')\n    edf_neg_tex = self._render_edf(orig_tex)\n    orig_tex[:, :, 0] = data\n    edf_pos_tex = self._render_edf(orig_tex)\n    self.program_insert['u_texture'] = orig_tex\n    self.program_insert['u_pos_texture'] = edf_pos_tex\n    self.program_insert['u_neg_texture'] = edf_neg_tex\n    self.fbo_to[-1].color_buffer = texture\n    with self.fbo_to[-1]:\n        set_viewport(tuple(offset) + tuple(size))\n        self.program_insert.draw('triangle_strip')",
            "def render_to_texture(self, data, texture, offset, size):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Render a SDF to a texture at a given offset and size\\n\\n        Parameters\\n        ----------\\n        data : array\\n            Must be 2D with type np.ubyte.\\n        texture : instance of Texture2D\\n            The texture to render to.\\n        offset : tuple of int\\n            Offset (x, y) to render to inside the texture.\\n        size : tuple of int\\n            Size (w, h) to render inside the texture.\\n        '\n    assert isinstance(texture, Texture2D)\n    set_state(blend=False, depth_test=False)\n    orig_tex = Texture2D(255 - data, format='luminance', wrapping='clamp_to_edge', interpolation='nearest')\n    edf_neg_tex = self._render_edf(orig_tex)\n    orig_tex[:, :, 0] = data\n    edf_pos_tex = self._render_edf(orig_tex)\n    self.program_insert['u_texture'] = orig_tex\n    self.program_insert['u_pos_texture'] = edf_pos_tex\n    self.program_insert['u_neg_texture'] = edf_neg_tex\n    self.fbo_to[-1].color_buffer = texture\n    with self.fbo_to[-1]:\n        set_viewport(tuple(offset) + tuple(size))\n        self.program_insert.draw('triangle_strip')",
            "def render_to_texture(self, data, texture, offset, size):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Render a SDF to a texture at a given offset and size\\n\\n        Parameters\\n        ----------\\n        data : array\\n            Must be 2D with type np.ubyte.\\n        texture : instance of Texture2D\\n            The texture to render to.\\n        offset : tuple of int\\n            Offset (x, y) to render to inside the texture.\\n        size : tuple of int\\n            Size (w, h) to render inside the texture.\\n        '\n    assert isinstance(texture, Texture2D)\n    set_state(blend=False, depth_test=False)\n    orig_tex = Texture2D(255 - data, format='luminance', wrapping='clamp_to_edge', interpolation='nearest')\n    edf_neg_tex = self._render_edf(orig_tex)\n    orig_tex[:, :, 0] = data\n    edf_pos_tex = self._render_edf(orig_tex)\n    self.program_insert['u_texture'] = orig_tex\n    self.program_insert['u_pos_texture'] = edf_pos_tex\n    self.program_insert['u_neg_texture'] = edf_neg_tex\n    self.fbo_to[-1].color_buffer = texture\n    with self.fbo_to[-1]:\n        set_viewport(tuple(offset) + tuple(size))\n        self.program_insert.draw('triangle_strip')",
            "def render_to_texture(self, data, texture, offset, size):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Render a SDF to a texture at a given offset and size\\n\\n        Parameters\\n        ----------\\n        data : array\\n            Must be 2D with type np.ubyte.\\n        texture : instance of Texture2D\\n            The texture to render to.\\n        offset : tuple of int\\n            Offset (x, y) to render to inside the texture.\\n        size : tuple of int\\n            Size (w, h) to render inside the texture.\\n        '\n    assert isinstance(texture, Texture2D)\n    set_state(blend=False, depth_test=False)\n    orig_tex = Texture2D(255 - data, format='luminance', wrapping='clamp_to_edge', interpolation='nearest')\n    edf_neg_tex = self._render_edf(orig_tex)\n    orig_tex[:, :, 0] = data\n    edf_pos_tex = self._render_edf(orig_tex)\n    self.program_insert['u_texture'] = orig_tex\n    self.program_insert['u_pos_texture'] = edf_pos_tex\n    self.program_insert['u_neg_texture'] = edf_neg_tex\n    self.fbo_to[-1].color_buffer = texture\n    with self.fbo_to[-1]:\n        set_viewport(tuple(offset) + tuple(size))\n        self.program_insert.draw('triangle_strip')"
        ]
    },
    {
        "func_name": "_render_edf",
        "original": "def _render_edf(self, orig_tex):\n    \"\"\"Render an EDF to a texture\"\"\"\n    sdf_size = orig_tex.shape[:2]\n    comp_texs = []\n    for _ in range(2):\n        tex = Texture2D(sdf_size + (4,), format='rgba', interpolation='nearest', wrapping='clamp_to_edge')\n        comp_texs.append(tex)\n    self.fbo_to[0].color_buffer = comp_texs[0]\n    self.fbo_to[1].color_buffer = comp_texs[1]\n    for program in self.programs[1:]:\n        (program['u_texh'], program['u_texw']) = sdf_size\n    last_rend = 0\n    with self.fbo_to[last_rend]:\n        set_viewport(0, 0, sdf_size[1], sdf_size[0])\n        self.program_seed['u_texture'] = orig_tex\n        self.program_seed.draw('triangle_strip')\n    stepsize = (np.array(sdf_size) // 2).max()\n    while stepsize > 0:\n        self.program_flood['u_step'] = stepsize\n        self.program_flood['u_texture'] = comp_texs[last_rend]\n        last_rend = 1 if last_rend == 0 else 0\n        with self.fbo_to[last_rend]:\n            set_viewport(0, 0, sdf_size[1], sdf_size[0])\n            self.program_flood.draw('triangle_strip')\n        stepsize //= 2\n    return comp_texs[last_rend]",
        "mutated": [
            "def _render_edf(self, orig_tex):\n    if False:\n        i = 10\n    'Render an EDF to a texture'\n    sdf_size = orig_tex.shape[:2]\n    comp_texs = []\n    for _ in range(2):\n        tex = Texture2D(sdf_size + (4,), format='rgba', interpolation='nearest', wrapping='clamp_to_edge')\n        comp_texs.append(tex)\n    self.fbo_to[0].color_buffer = comp_texs[0]\n    self.fbo_to[1].color_buffer = comp_texs[1]\n    for program in self.programs[1:]:\n        (program['u_texh'], program['u_texw']) = sdf_size\n    last_rend = 0\n    with self.fbo_to[last_rend]:\n        set_viewport(0, 0, sdf_size[1], sdf_size[0])\n        self.program_seed['u_texture'] = orig_tex\n        self.program_seed.draw('triangle_strip')\n    stepsize = (np.array(sdf_size) // 2).max()\n    while stepsize > 0:\n        self.program_flood['u_step'] = stepsize\n        self.program_flood['u_texture'] = comp_texs[last_rend]\n        last_rend = 1 if last_rend == 0 else 0\n        with self.fbo_to[last_rend]:\n            set_viewport(0, 0, sdf_size[1], sdf_size[0])\n            self.program_flood.draw('triangle_strip')\n        stepsize //= 2\n    return comp_texs[last_rend]",
            "def _render_edf(self, orig_tex):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Render an EDF to a texture'\n    sdf_size = orig_tex.shape[:2]\n    comp_texs = []\n    for _ in range(2):\n        tex = Texture2D(sdf_size + (4,), format='rgba', interpolation='nearest', wrapping='clamp_to_edge')\n        comp_texs.append(tex)\n    self.fbo_to[0].color_buffer = comp_texs[0]\n    self.fbo_to[1].color_buffer = comp_texs[1]\n    for program in self.programs[1:]:\n        (program['u_texh'], program['u_texw']) = sdf_size\n    last_rend = 0\n    with self.fbo_to[last_rend]:\n        set_viewport(0, 0, sdf_size[1], sdf_size[0])\n        self.program_seed['u_texture'] = orig_tex\n        self.program_seed.draw('triangle_strip')\n    stepsize = (np.array(sdf_size) // 2).max()\n    while stepsize > 0:\n        self.program_flood['u_step'] = stepsize\n        self.program_flood['u_texture'] = comp_texs[last_rend]\n        last_rend = 1 if last_rend == 0 else 0\n        with self.fbo_to[last_rend]:\n            set_viewport(0, 0, sdf_size[1], sdf_size[0])\n            self.program_flood.draw('triangle_strip')\n        stepsize //= 2\n    return comp_texs[last_rend]",
            "def _render_edf(self, orig_tex):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Render an EDF to a texture'\n    sdf_size = orig_tex.shape[:2]\n    comp_texs = []\n    for _ in range(2):\n        tex = Texture2D(sdf_size + (4,), format='rgba', interpolation='nearest', wrapping='clamp_to_edge')\n        comp_texs.append(tex)\n    self.fbo_to[0].color_buffer = comp_texs[0]\n    self.fbo_to[1].color_buffer = comp_texs[1]\n    for program in self.programs[1:]:\n        (program['u_texh'], program['u_texw']) = sdf_size\n    last_rend = 0\n    with self.fbo_to[last_rend]:\n        set_viewport(0, 0, sdf_size[1], sdf_size[0])\n        self.program_seed['u_texture'] = orig_tex\n        self.program_seed.draw('triangle_strip')\n    stepsize = (np.array(sdf_size) // 2).max()\n    while stepsize > 0:\n        self.program_flood['u_step'] = stepsize\n        self.program_flood['u_texture'] = comp_texs[last_rend]\n        last_rend = 1 if last_rend == 0 else 0\n        with self.fbo_to[last_rend]:\n            set_viewport(0, 0, sdf_size[1], sdf_size[0])\n            self.program_flood.draw('triangle_strip')\n        stepsize //= 2\n    return comp_texs[last_rend]",
            "def _render_edf(self, orig_tex):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Render an EDF to a texture'\n    sdf_size = orig_tex.shape[:2]\n    comp_texs = []\n    for _ in range(2):\n        tex = Texture2D(sdf_size + (4,), format='rgba', interpolation='nearest', wrapping='clamp_to_edge')\n        comp_texs.append(tex)\n    self.fbo_to[0].color_buffer = comp_texs[0]\n    self.fbo_to[1].color_buffer = comp_texs[1]\n    for program in self.programs[1:]:\n        (program['u_texh'], program['u_texw']) = sdf_size\n    last_rend = 0\n    with self.fbo_to[last_rend]:\n        set_viewport(0, 0, sdf_size[1], sdf_size[0])\n        self.program_seed['u_texture'] = orig_tex\n        self.program_seed.draw('triangle_strip')\n    stepsize = (np.array(sdf_size) // 2).max()\n    while stepsize > 0:\n        self.program_flood['u_step'] = stepsize\n        self.program_flood['u_texture'] = comp_texs[last_rend]\n        last_rend = 1 if last_rend == 0 else 0\n        with self.fbo_to[last_rend]:\n            set_viewport(0, 0, sdf_size[1], sdf_size[0])\n            self.program_flood.draw('triangle_strip')\n        stepsize //= 2\n    return comp_texs[last_rend]",
            "def _render_edf(self, orig_tex):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Render an EDF to a texture'\n    sdf_size = orig_tex.shape[:2]\n    comp_texs = []\n    for _ in range(2):\n        tex = Texture2D(sdf_size + (4,), format='rgba', interpolation='nearest', wrapping='clamp_to_edge')\n        comp_texs.append(tex)\n    self.fbo_to[0].color_buffer = comp_texs[0]\n    self.fbo_to[1].color_buffer = comp_texs[1]\n    for program in self.programs[1:]:\n        (program['u_texh'], program['u_texw']) = sdf_size\n    last_rend = 0\n    with self.fbo_to[last_rend]:\n        set_viewport(0, 0, sdf_size[1], sdf_size[0])\n        self.program_seed['u_texture'] = orig_tex\n        self.program_seed.draw('triangle_strip')\n    stepsize = (np.array(sdf_size) // 2).max()\n    while stepsize > 0:\n        self.program_flood['u_step'] = stepsize\n        self.program_flood['u_texture'] = comp_texs[last_rend]\n        last_rend = 1 if last_rend == 0 else 0\n        with self.fbo_to[last_rend]:\n            set_viewport(0, 0, sdf_size[1], sdf_size[0])\n            self.program_flood.draw('triangle_strip')\n        stepsize //= 2\n    return comp_texs[last_rend]"
        ]
    }
]