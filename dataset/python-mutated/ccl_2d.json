[
    {
        "func_name": "ccl_2d",
        "original": "def ccl_2d(data_2d):\n    \"\"\" \n    2D connected component labelling, original code from https://github.com/DanielPlayne/playne-equivalence-algorithm\n    Args:\n        [in]param data_2d: binary two-dimensional vector\n            type data_2d: jittor array\n\n    Returns:\n        [out]result: labeled two-dimensional vector\n\n    Example:\n    >>> import jittor as jt\n    >>> jt.flags.use_cuda = 1\n    >>> import cv2\n    >>> import numpy as np\n    >>> img = cv2.imread('testImg.png', 0)\n    >>> a = img.mean()\n    >>> img[img <= a] = 0\n    >>> img[img > a] = 1\n    >>> img = jt.Var(img)\n\n    >>> result = ccl_2d(img)\n    >>> print(jt.unique(result, return_counts=True, return_inverse=True)[0], jt.unique(result, return_counts=True, return_inverse=True)[2])\n    >>> cv2.imwrite('testImg_result.png', result.numpy().astype(np.uint8) * 50)\n    \"\"\"\n    data_2d = data_2d.astype(jt.uint32)\n    cY = data_2d.shape[0]\n    cX = data_2d.shape[1]\n    data_2d_copy = data_2d.clone()\n    changed = jt.ones([1], dtype=jt.uint32)\n    data_2d = data_2d.reshape(cX * cY)\n    result = jt.code(data_2d.shape, data_2d.dtype, [data_2d, changed], cuda_header='\\n                    @alias(g_image, in0)\\n                    @alias(g_labels, out)\\n                    ', cuda_src='\\n                    __global__ void init_labels(@ARGS_DEF, const int cX, const int cY) {\\n                        @PRECALC\\n                        // Calculate index\\n                        const unsigned int ix = (blockIdx.x * blockDim.x) + threadIdx.x;\\n                        const unsigned int iy = (blockIdx.y * blockDim.y) + threadIdx.y;\\n                        @g_labels(iy*cX + ix) = iy*cX + ix;\\n                    }\\n\\n                    __device__ __inline__ unsigned int find_root(@ARGS_DEF, unsigned int label) {\\n                        // Resolve Label\\n                        unsigned int next = @g_labels(label);\\n\\n                        // Follow chain\\n                        while(label != next) {\\n                            // Move to next\\n                            label = next;\\n                            next = @g_labels(label);\\n                        }\\n\\n                        // Return label\\n                        return label;\\n                    }\\n\\n                    __global__ void resolve_labels(@ARGS_DEF, const int cX, const int cY) {\\n                        @PRECALC\\n                        // Calculate index\\n                        const unsigned int id = ((blockIdx.y * blockDim.y) + threadIdx.y) * cX +\\n                                                ((blockIdx.x * blockDim.x) + threadIdx.x);\\n                        \\n                        // Check Thread Range\\n                        if(id < cX*cY) {\\n                            // Resolve Label\\n                            @g_labels(id) = find_root(@ARGS, @g_labels(id));\\n                        }\\n                    }\\n\\n                    __global__ void label_equivalence(@ARGS_DEF, const int cX, const int cY) {\\n                        @PRECALC\\n                        // Calculate index\\n                        const unsigned int ix = (blockIdx.x * blockDim.x) + threadIdx.x;\\n                        const unsigned int iy = (blockIdx.y * blockDim.y) + threadIdx.y;\\n\\n                        // Check Thread Range\\n                        if((ix < cX) && (iy < cY)) {\\n                            // Get image and label values\\n                            const unsigned char cyx   = @g_image( iy*cX + ix);\\n                            \\n                            // Get neighbour labels\\n                            const unsigned int lym1x = (iy > 0)    ? @g_labels((iy-1)*cX +   ix) : 0;\\n                            const unsigned int lyxm1 = (ix > 0)    ? @g_labels(iy    *cX + ix-1) : 0;\\n                            const unsigned int lyx   =               @g_labels(iy    *cX +   ix);\\n                            const unsigned int lyxp1 = (ix < cX-1) ? @g_labels(iy    *cX + ix+1) : 0;\\n                            const unsigned int lyp1x = (iy < cY-1) ? @g_labels((iy+1)*cX +   ix) : 0;\\n\\n                            const unsigned int lym1xm1 = (iy > 0    && ix > 0   )    ? @g_labels((iy-1)*cX +   ix-1) : 0;\\n                            const unsigned int lym1xp1 = (iy > 0    && ix < cX-1)    ? @g_labels((iy-1)*cX +   ix+1) : 0;\\n                            const unsigned int lyp1xm1 = (iy < cY-1 && ix > 0   )    ? @g_labels((iy+1)*cX +   ix-1) : 0;\\n                            const unsigned int lyp1xp1 = (iy < cY-1 && ix < cX-1)    ? @g_labels((iy+1)*cX +   ix+1) : 0;\\n\\n                            const bool nym1x = (iy > 0)    ? (cyx == (@g_image((iy-1)*cX +   ix))) : false;\\n                            const bool nyxm1 = (ix > 0)    ? (cyx == (@g_image(iy    *cX + ix-1))) : false;\\n                            const bool nyxp1 = (ix < cX-1) ? (cyx == (@g_image(iy    *cX + ix+1))) : false;\\n                            const bool nyp1x = (iy > cY-1) ? (cyx == (@g_image((iy+1)*cX +   ix))) : false;\\n\\n                            const bool nym1xm1 = (iy > 0    && ix > 0   )    ? (cyx == (@g_image((iy-1)*cX +   ix-1))) : false;\\n                            const bool nym1xp1 = (iy > 0    && ix < cX-1)    ? (cyx == (@g_image((iy-1)*cX +   ix+1))) : false;\\n                            const bool nyp1xm1 = (iy < cY-1 && ix > 0   )    ? (cyx == (@g_image((iy+1)*cX +   ix-1))) : false;\\n                            const bool nyp1xp1 = (iy < cY-1 && ix < cX-1)    ? (cyx == (@g_image((iy+1)*cX +   ix+1))) : false;\\n\\n                            // Lowest label\\n                            unsigned int label = lyx;\\n\\n                            // Find lowest neighbouring label\\n                            label = ((nym1x) && (lym1x < label)) ? lym1x : label;\\n                            label = ((nyxm1) && (lyxm1 < label)) ? lyxm1 : label;\\n                            label = ((nyxp1) && (lyxp1 < label)) ? lyxp1 : label;\\n                            label = ((nyp1x) && (lyp1x < label)) ? lyp1x : label;\\n\\n                            label = ((nym1xm1) && (lym1xm1 < label)) ? lym1xm1 : label;\\n                            label = ((nym1xp1) && (lym1xp1 < label)) ? lym1xp1 : label;\\n                            label = ((nyp1xm1) && (lyp1xm1 < label)) ? lyp1xm1 : label;\\n                            label = ((nyp1xp1) && (lyp1xp1 < label)) ? lyp1xp1 : label;\\n\\n                            // If labels are different, resolve them\\n                            if(label < lyx) {\\n                                // Update label\\n                                // Nonatomic write may overwrite another label but on average seems to give faster results\\n                                @g_labels(lyx) = label;\\n\\n                                // Record the change\\n                                @in1(0) = 1;\\n                            }\\n                        }\\n                    }\\n                    ' + f'\\n                    dim3 block(32, 32);\\n                    const int cX= {cX};\\n                    const int cY= {cY};' + '\\n                    dim3 grid(ceil(cX/(float)block.x), ceil(cY/(float)block.y));\\n                    dim3 resolve_block(32, 32);\\n                    dim3 resolve_grid(ceil(cX/(float)resolve_block.x), ceil(cY/(float)resolve_block.y));\\n                    \\n                    // Initialise labels\\n                    init_labels <<< grid, block >>>(@ARGS, cX, cY);\\n                    \\n                    // Resolve the labels\\n                    resolve_labels <<< resolve_grid, resolve_block >>>(@ARGS, cX, cY);\\n\\n                    // Changed Flag\\n                    int32 changed = 1;\\n                    \\n                    // While labels have changed\\n                    while(changed) {\\n                        // Copy changed to device\\n                        cudaMemsetAsync(in1_p, 0, 4);\\n                        \\n                        // Label image\\n                        label_equivalence <<< grid, block >>>(@ARGS, cX, cY);\\n\\n                        // Copy changed flag to host\\n                        cudaMemcpy(&changed, in1_p, sizeof(int32), cudaMemcpyDeviceToHost);\\n                        \\n                        // Resolve the labels\\n                        resolve_labels <<< resolve_grid, resolve_block>>>(@ARGS, cX, cY);\\n                    }\\n                    ')\n    result = result.reshape((cY, cX)) * data_2d_copy\n    value = jt.unique(result)\n    value = value[value != 0]\n    map_result = jt.zeros(int(value.max().numpy()[0]) + 1, dtype=jt.uint32)\n    map_result[value] = jt.index(value.shape)[0] + 1\n    result = map_result[result]\n    return result",
        "mutated": [
            "def ccl_2d(data_2d):\n    if False:\n        i = 10\n    \" \\n    2D connected component labelling, original code from https://github.com/DanielPlayne/playne-equivalence-algorithm\\n    Args:\\n        [in]param data_2d: binary two-dimensional vector\\n            type data_2d: jittor array\\n\\n    Returns:\\n        [out]result: labeled two-dimensional vector\\n\\n    Example:\\n    >>> import jittor as jt\\n    >>> jt.flags.use_cuda = 1\\n    >>> import cv2\\n    >>> import numpy as np\\n    >>> img = cv2.imread('testImg.png', 0)\\n    >>> a = img.mean()\\n    >>> img[img <= a] = 0\\n    >>> img[img > a] = 1\\n    >>> img = jt.Var(img)\\n\\n    >>> result = ccl_2d(img)\\n    >>> print(jt.unique(result, return_counts=True, return_inverse=True)[0], jt.unique(result, return_counts=True, return_inverse=True)[2])\\n    >>> cv2.imwrite('testImg_result.png', result.numpy().astype(np.uint8) * 50)\\n    \"\n    data_2d = data_2d.astype(jt.uint32)\n    cY = data_2d.shape[0]\n    cX = data_2d.shape[1]\n    data_2d_copy = data_2d.clone()\n    changed = jt.ones([1], dtype=jt.uint32)\n    data_2d = data_2d.reshape(cX * cY)\n    result = jt.code(data_2d.shape, data_2d.dtype, [data_2d, changed], cuda_header='\\n                    @alias(g_image, in0)\\n                    @alias(g_labels, out)\\n                    ', cuda_src='\\n                    __global__ void init_labels(@ARGS_DEF, const int cX, const int cY) {\\n                        @PRECALC\\n                        // Calculate index\\n                        const unsigned int ix = (blockIdx.x * blockDim.x) + threadIdx.x;\\n                        const unsigned int iy = (blockIdx.y * blockDim.y) + threadIdx.y;\\n                        @g_labels(iy*cX + ix) = iy*cX + ix;\\n                    }\\n\\n                    __device__ __inline__ unsigned int find_root(@ARGS_DEF, unsigned int label) {\\n                        // Resolve Label\\n                        unsigned int next = @g_labels(label);\\n\\n                        // Follow chain\\n                        while(label != next) {\\n                            // Move to next\\n                            label = next;\\n                            next = @g_labels(label);\\n                        }\\n\\n                        // Return label\\n                        return label;\\n                    }\\n\\n                    __global__ void resolve_labels(@ARGS_DEF, const int cX, const int cY) {\\n                        @PRECALC\\n                        // Calculate index\\n                        const unsigned int id = ((blockIdx.y * blockDim.y) + threadIdx.y) * cX +\\n                                                ((blockIdx.x * blockDim.x) + threadIdx.x);\\n                        \\n                        // Check Thread Range\\n                        if(id < cX*cY) {\\n                            // Resolve Label\\n                            @g_labels(id) = find_root(@ARGS, @g_labels(id));\\n                        }\\n                    }\\n\\n                    __global__ void label_equivalence(@ARGS_DEF, const int cX, const int cY) {\\n                        @PRECALC\\n                        // Calculate index\\n                        const unsigned int ix = (blockIdx.x * blockDim.x) + threadIdx.x;\\n                        const unsigned int iy = (blockIdx.y * blockDim.y) + threadIdx.y;\\n\\n                        // Check Thread Range\\n                        if((ix < cX) && (iy < cY)) {\\n                            // Get image and label values\\n                            const unsigned char cyx   = @g_image( iy*cX + ix);\\n                            \\n                            // Get neighbour labels\\n                            const unsigned int lym1x = (iy > 0)    ? @g_labels((iy-1)*cX +   ix) : 0;\\n                            const unsigned int lyxm1 = (ix > 0)    ? @g_labels(iy    *cX + ix-1) : 0;\\n                            const unsigned int lyx   =               @g_labels(iy    *cX +   ix);\\n                            const unsigned int lyxp1 = (ix < cX-1) ? @g_labels(iy    *cX + ix+1) : 0;\\n                            const unsigned int lyp1x = (iy < cY-1) ? @g_labels((iy+1)*cX +   ix) : 0;\\n\\n                            const unsigned int lym1xm1 = (iy > 0    && ix > 0   )    ? @g_labels((iy-1)*cX +   ix-1) : 0;\\n                            const unsigned int lym1xp1 = (iy > 0    && ix < cX-1)    ? @g_labels((iy-1)*cX +   ix+1) : 0;\\n                            const unsigned int lyp1xm1 = (iy < cY-1 && ix > 0   )    ? @g_labels((iy+1)*cX +   ix-1) : 0;\\n                            const unsigned int lyp1xp1 = (iy < cY-1 && ix < cX-1)    ? @g_labels((iy+1)*cX +   ix+1) : 0;\\n\\n                            const bool nym1x = (iy > 0)    ? (cyx == (@g_image((iy-1)*cX +   ix))) : false;\\n                            const bool nyxm1 = (ix > 0)    ? (cyx == (@g_image(iy    *cX + ix-1))) : false;\\n                            const bool nyxp1 = (ix < cX-1) ? (cyx == (@g_image(iy    *cX + ix+1))) : false;\\n                            const bool nyp1x = (iy > cY-1) ? (cyx == (@g_image((iy+1)*cX +   ix))) : false;\\n\\n                            const bool nym1xm1 = (iy > 0    && ix > 0   )    ? (cyx == (@g_image((iy-1)*cX +   ix-1))) : false;\\n                            const bool nym1xp1 = (iy > 0    && ix < cX-1)    ? (cyx == (@g_image((iy-1)*cX +   ix+1))) : false;\\n                            const bool nyp1xm1 = (iy < cY-1 && ix > 0   )    ? (cyx == (@g_image((iy+1)*cX +   ix-1))) : false;\\n                            const bool nyp1xp1 = (iy < cY-1 && ix < cX-1)    ? (cyx == (@g_image((iy+1)*cX +   ix+1))) : false;\\n\\n                            // Lowest label\\n                            unsigned int label = lyx;\\n\\n                            // Find lowest neighbouring label\\n                            label = ((nym1x) && (lym1x < label)) ? lym1x : label;\\n                            label = ((nyxm1) && (lyxm1 < label)) ? lyxm1 : label;\\n                            label = ((nyxp1) && (lyxp1 < label)) ? lyxp1 : label;\\n                            label = ((nyp1x) && (lyp1x < label)) ? lyp1x : label;\\n\\n                            label = ((nym1xm1) && (lym1xm1 < label)) ? lym1xm1 : label;\\n                            label = ((nym1xp1) && (lym1xp1 < label)) ? lym1xp1 : label;\\n                            label = ((nyp1xm1) && (lyp1xm1 < label)) ? lyp1xm1 : label;\\n                            label = ((nyp1xp1) && (lyp1xp1 < label)) ? lyp1xp1 : label;\\n\\n                            // If labels are different, resolve them\\n                            if(label < lyx) {\\n                                // Update label\\n                                // Nonatomic write may overwrite another label but on average seems to give faster results\\n                                @g_labels(lyx) = label;\\n\\n                                // Record the change\\n                                @in1(0) = 1;\\n                            }\\n                        }\\n                    }\\n                    ' + f'\\n                    dim3 block(32, 32);\\n                    const int cX= {cX};\\n                    const int cY= {cY};' + '\\n                    dim3 grid(ceil(cX/(float)block.x), ceil(cY/(float)block.y));\\n                    dim3 resolve_block(32, 32);\\n                    dim3 resolve_grid(ceil(cX/(float)resolve_block.x), ceil(cY/(float)resolve_block.y));\\n                    \\n                    // Initialise labels\\n                    init_labels <<< grid, block >>>(@ARGS, cX, cY);\\n                    \\n                    // Resolve the labels\\n                    resolve_labels <<< resolve_grid, resolve_block >>>(@ARGS, cX, cY);\\n\\n                    // Changed Flag\\n                    int32 changed = 1;\\n                    \\n                    // While labels have changed\\n                    while(changed) {\\n                        // Copy changed to device\\n                        cudaMemsetAsync(in1_p, 0, 4);\\n                        \\n                        // Label image\\n                        label_equivalence <<< grid, block >>>(@ARGS, cX, cY);\\n\\n                        // Copy changed flag to host\\n                        cudaMemcpy(&changed, in1_p, sizeof(int32), cudaMemcpyDeviceToHost);\\n                        \\n                        // Resolve the labels\\n                        resolve_labels <<< resolve_grid, resolve_block>>>(@ARGS, cX, cY);\\n                    }\\n                    ')\n    result = result.reshape((cY, cX)) * data_2d_copy\n    value = jt.unique(result)\n    value = value[value != 0]\n    map_result = jt.zeros(int(value.max().numpy()[0]) + 1, dtype=jt.uint32)\n    map_result[value] = jt.index(value.shape)[0] + 1\n    result = map_result[result]\n    return result",
            "def ccl_2d(data_2d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \" \\n    2D connected component labelling, original code from https://github.com/DanielPlayne/playne-equivalence-algorithm\\n    Args:\\n        [in]param data_2d: binary two-dimensional vector\\n            type data_2d: jittor array\\n\\n    Returns:\\n        [out]result: labeled two-dimensional vector\\n\\n    Example:\\n    >>> import jittor as jt\\n    >>> jt.flags.use_cuda = 1\\n    >>> import cv2\\n    >>> import numpy as np\\n    >>> img = cv2.imread('testImg.png', 0)\\n    >>> a = img.mean()\\n    >>> img[img <= a] = 0\\n    >>> img[img > a] = 1\\n    >>> img = jt.Var(img)\\n\\n    >>> result = ccl_2d(img)\\n    >>> print(jt.unique(result, return_counts=True, return_inverse=True)[0], jt.unique(result, return_counts=True, return_inverse=True)[2])\\n    >>> cv2.imwrite('testImg_result.png', result.numpy().astype(np.uint8) * 50)\\n    \"\n    data_2d = data_2d.astype(jt.uint32)\n    cY = data_2d.shape[0]\n    cX = data_2d.shape[1]\n    data_2d_copy = data_2d.clone()\n    changed = jt.ones([1], dtype=jt.uint32)\n    data_2d = data_2d.reshape(cX * cY)\n    result = jt.code(data_2d.shape, data_2d.dtype, [data_2d, changed], cuda_header='\\n                    @alias(g_image, in0)\\n                    @alias(g_labels, out)\\n                    ', cuda_src='\\n                    __global__ void init_labels(@ARGS_DEF, const int cX, const int cY) {\\n                        @PRECALC\\n                        // Calculate index\\n                        const unsigned int ix = (blockIdx.x * blockDim.x) + threadIdx.x;\\n                        const unsigned int iy = (blockIdx.y * blockDim.y) + threadIdx.y;\\n                        @g_labels(iy*cX + ix) = iy*cX + ix;\\n                    }\\n\\n                    __device__ __inline__ unsigned int find_root(@ARGS_DEF, unsigned int label) {\\n                        // Resolve Label\\n                        unsigned int next = @g_labels(label);\\n\\n                        // Follow chain\\n                        while(label != next) {\\n                            // Move to next\\n                            label = next;\\n                            next = @g_labels(label);\\n                        }\\n\\n                        // Return label\\n                        return label;\\n                    }\\n\\n                    __global__ void resolve_labels(@ARGS_DEF, const int cX, const int cY) {\\n                        @PRECALC\\n                        // Calculate index\\n                        const unsigned int id = ((blockIdx.y * blockDim.y) + threadIdx.y) * cX +\\n                                                ((blockIdx.x * blockDim.x) + threadIdx.x);\\n                        \\n                        // Check Thread Range\\n                        if(id < cX*cY) {\\n                            // Resolve Label\\n                            @g_labels(id) = find_root(@ARGS, @g_labels(id));\\n                        }\\n                    }\\n\\n                    __global__ void label_equivalence(@ARGS_DEF, const int cX, const int cY) {\\n                        @PRECALC\\n                        // Calculate index\\n                        const unsigned int ix = (blockIdx.x * blockDim.x) + threadIdx.x;\\n                        const unsigned int iy = (blockIdx.y * blockDim.y) + threadIdx.y;\\n\\n                        // Check Thread Range\\n                        if((ix < cX) && (iy < cY)) {\\n                            // Get image and label values\\n                            const unsigned char cyx   = @g_image( iy*cX + ix);\\n                            \\n                            // Get neighbour labels\\n                            const unsigned int lym1x = (iy > 0)    ? @g_labels((iy-1)*cX +   ix) : 0;\\n                            const unsigned int lyxm1 = (ix > 0)    ? @g_labels(iy    *cX + ix-1) : 0;\\n                            const unsigned int lyx   =               @g_labels(iy    *cX +   ix);\\n                            const unsigned int lyxp1 = (ix < cX-1) ? @g_labels(iy    *cX + ix+1) : 0;\\n                            const unsigned int lyp1x = (iy < cY-1) ? @g_labels((iy+1)*cX +   ix) : 0;\\n\\n                            const unsigned int lym1xm1 = (iy > 0    && ix > 0   )    ? @g_labels((iy-1)*cX +   ix-1) : 0;\\n                            const unsigned int lym1xp1 = (iy > 0    && ix < cX-1)    ? @g_labels((iy-1)*cX +   ix+1) : 0;\\n                            const unsigned int lyp1xm1 = (iy < cY-1 && ix > 0   )    ? @g_labels((iy+1)*cX +   ix-1) : 0;\\n                            const unsigned int lyp1xp1 = (iy < cY-1 && ix < cX-1)    ? @g_labels((iy+1)*cX +   ix+1) : 0;\\n\\n                            const bool nym1x = (iy > 0)    ? (cyx == (@g_image((iy-1)*cX +   ix))) : false;\\n                            const bool nyxm1 = (ix > 0)    ? (cyx == (@g_image(iy    *cX + ix-1))) : false;\\n                            const bool nyxp1 = (ix < cX-1) ? (cyx == (@g_image(iy    *cX + ix+1))) : false;\\n                            const bool nyp1x = (iy > cY-1) ? (cyx == (@g_image((iy+1)*cX +   ix))) : false;\\n\\n                            const bool nym1xm1 = (iy > 0    && ix > 0   )    ? (cyx == (@g_image((iy-1)*cX +   ix-1))) : false;\\n                            const bool nym1xp1 = (iy > 0    && ix < cX-1)    ? (cyx == (@g_image((iy-1)*cX +   ix+1))) : false;\\n                            const bool nyp1xm1 = (iy < cY-1 && ix > 0   )    ? (cyx == (@g_image((iy+1)*cX +   ix-1))) : false;\\n                            const bool nyp1xp1 = (iy < cY-1 && ix < cX-1)    ? (cyx == (@g_image((iy+1)*cX +   ix+1))) : false;\\n\\n                            // Lowest label\\n                            unsigned int label = lyx;\\n\\n                            // Find lowest neighbouring label\\n                            label = ((nym1x) && (lym1x < label)) ? lym1x : label;\\n                            label = ((nyxm1) && (lyxm1 < label)) ? lyxm1 : label;\\n                            label = ((nyxp1) && (lyxp1 < label)) ? lyxp1 : label;\\n                            label = ((nyp1x) && (lyp1x < label)) ? lyp1x : label;\\n\\n                            label = ((nym1xm1) && (lym1xm1 < label)) ? lym1xm1 : label;\\n                            label = ((nym1xp1) && (lym1xp1 < label)) ? lym1xp1 : label;\\n                            label = ((nyp1xm1) && (lyp1xm1 < label)) ? lyp1xm1 : label;\\n                            label = ((nyp1xp1) && (lyp1xp1 < label)) ? lyp1xp1 : label;\\n\\n                            // If labels are different, resolve them\\n                            if(label < lyx) {\\n                                // Update label\\n                                // Nonatomic write may overwrite another label but on average seems to give faster results\\n                                @g_labels(lyx) = label;\\n\\n                                // Record the change\\n                                @in1(0) = 1;\\n                            }\\n                        }\\n                    }\\n                    ' + f'\\n                    dim3 block(32, 32);\\n                    const int cX= {cX};\\n                    const int cY= {cY};' + '\\n                    dim3 grid(ceil(cX/(float)block.x), ceil(cY/(float)block.y));\\n                    dim3 resolve_block(32, 32);\\n                    dim3 resolve_grid(ceil(cX/(float)resolve_block.x), ceil(cY/(float)resolve_block.y));\\n                    \\n                    // Initialise labels\\n                    init_labels <<< grid, block >>>(@ARGS, cX, cY);\\n                    \\n                    // Resolve the labels\\n                    resolve_labels <<< resolve_grid, resolve_block >>>(@ARGS, cX, cY);\\n\\n                    // Changed Flag\\n                    int32 changed = 1;\\n                    \\n                    // While labels have changed\\n                    while(changed) {\\n                        // Copy changed to device\\n                        cudaMemsetAsync(in1_p, 0, 4);\\n                        \\n                        // Label image\\n                        label_equivalence <<< grid, block >>>(@ARGS, cX, cY);\\n\\n                        // Copy changed flag to host\\n                        cudaMemcpy(&changed, in1_p, sizeof(int32), cudaMemcpyDeviceToHost);\\n                        \\n                        // Resolve the labels\\n                        resolve_labels <<< resolve_grid, resolve_block>>>(@ARGS, cX, cY);\\n                    }\\n                    ')\n    result = result.reshape((cY, cX)) * data_2d_copy\n    value = jt.unique(result)\n    value = value[value != 0]\n    map_result = jt.zeros(int(value.max().numpy()[0]) + 1, dtype=jt.uint32)\n    map_result[value] = jt.index(value.shape)[0] + 1\n    result = map_result[result]\n    return result",
            "def ccl_2d(data_2d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \" \\n    2D connected component labelling, original code from https://github.com/DanielPlayne/playne-equivalence-algorithm\\n    Args:\\n        [in]param data_2d: binary two-dimensional vector\\n            type data_2d: jittor array\\n\\n    Returns:\\n        [out]result: labeled two-dimensional vector\\n\\n    Example:\\n    >>> import jittor as jt\\n    >>> jt.flags.use_cuda = 1\\n    >>> import cv2\\n    >>> import numpy as np\\n    >>> img = cv2.imread('testImg.png', 0)\\n    >>> a = img.mean()\\n    >>> img[img <= a] = 0\\n    >>> img[img > a] = 1\\n    >>> img = jt.Var(img)\\n\\n    >>> result = ccl_2d(img)\\n    >>> print(jt.unique(result, return_counts=True, return_inverse=True)[0], jt.unique(result, return_counts=True, return_inverse=True)[2])\\n    >>> cv2.imwrite('testImg_result.png', result.numpy().astype(np.uint8) * 50)\\n    \"\n    data_2d = data_2d.astype(jt.uint32)\n    cY = data_2d.shape[0]\n    cX = data_2d.shape[1]\n    data_2d_copy = data_2d.clone()\n    changed = jt.ones([1], dtype=jt.uint32)\n    data_2d = data_2d.reshape(cX * cY)\n    result = jt.code(data_2d.shape, data_2d.dtype, [data_2d, changed], cuda_header='\\n                    @alias(g_image, in0)\\n                    @alias(g_labels, out)\\n                    ', cuda_src='\\n                    __global__ void init_labels(@ARGS_DEF, const int cX, const int cY) {\\n                        @PRECALC\\n                        // Calculate index\\n                        const unsigned int ix = (blockIdx.x * blockDim.x) + threadIdx.x;\\n                        const unsigned int iy = (blockIdx.y * blockDim.y) + threadIdx.y;\\n                        @g_labels(iy*cX + ix) = iy*cX + ix;\\n                    }\\n\\n                    __device__ __inline__ unsigned int find_root(@ARGS_DEF, unsigned int label) {\\n                        // Resolve Label\\n                        unsigned int next = @g_labels(label);\\n\\n                        // Follow chain\\n                        while(label != next) {\\n                            // Move to next\\n                            label = next;\\n                            next = @g_labels(label);\\n                        }\\n\\n                        // Return label\\n                        return label;\\n                    }\\n\\n                    __global__ void resolve_labels(@ARGS_DEF, const int cX, const int cY) {\\n                        @PRECALC\\n                        // Calculate index\\n                        const unsigned int id = ((blockIdx.y * blockDim.y) + threadIdx.y) * cX +\\n                                                ((blockIdx.x * blockDim.x) + threadIdx.x);\\n                        \\n                        // Check Thread Range\\n                        if(id < cX*cY) {\\n                            // Resolve Label\\n                            @g_labels(id) = find_root(@ARGS, @g_labels(id));\\n                        }\\n                    }\\n\\n                    __global__ void label_equivalence(@ARGS_DEF, const int cX, const int cY) {\\n                        @PRECALC\\n                        // Calculate index\\n                        const unsigned int ix = (blockIdx.x * blockDim.x) + threadIdx.x;\\n                        const unsigned int iy = (blockIdx.y * blockDim.y) + threadIdx.y;\\n\\n                        // Check Thread Range\\n                        if((ix < cX) && (iy < cY)) {\\n                            // Get image and label values\\n                            const unsigned char cyx   = @g_image( iy*cX + ix);\\n                            \\n                            // Get neighbour labels\\n                            const unsigned int lym1x = (iy > 0)    ? @g_labels((iy-1)*cX +   ix) : 0;\\n                            const unsigned int lyxm1 = (ix > 0)    ? @g_labels(iy    *cX + ix-1) : 0;\\n                            const unsigned int lyx   =               @g_labels(iy    *cX +   ix);\\n                            const unsigned int lyxp1 = (ix < cX-1) ? @g_labels(iy    *cX + ix+1) : 0;\\n                            const unsigned int lyp1x = (iy < cY-1) ? @g_labels((iy+1)*cX +   ix) : 0;\\n\\n                            const unsigned int lym1xm1 = (iy > 0    && ix > 0   )    ? @g_labels((iy-1)*cX +   ix-1) : 0;\\n                            const unsigned int lym1xp1 = (iy > 0    && ix < cX-1)    ? @g_labels((iy-1)*cX +   ix+1) : 0;\\n                            const unsigned int lyp1xm1 = (iy < cY-1 && ix > 0   )    ? @g_labels((iy+1)*cX +   ix-1) : 0;\\n                            const unsigned int lyp1xp1 = (iy < cY-1 && ix < cX-1)    ? @g_labels((iy+1)*cX +   ix+1) : 0;\\n\\n                            const bool nym1x = (iy > 0)    ? (cyx == (@g_image((iy-1)*cX +   ix))) : false;\\n                            const bool nyxm1 = (ix > 0)    ? (cyx == (@g_image(iy    *cX + ix-1))) : false;\\n                            const bool nyxp1 = (ix < cX-1) ? (cyx == (@g_image(iy    *cX + ix+1))) : false;\\n                            const bool nyp1x = (iy > cY-1) ? (cyx == (@g_image((iy+1)*cX +   ix))) : false;\\n\\n                            const bool nym1xm1 = (iy > 0    && ix > 0   )    ? (cyx == (@g_image((iy-1)*cX +   ix-1))) : false;\\n                            const bool nym1xp1 = (iy > 0    && ix < cX-1)    ? (cyx == (@g_image((iy-1)*cX +   ix+1))) : false;\\n                            const bool nyp1xm1 = (iy < cY-1 && ix > 0   )    ? (cyx == (@g_image((iy+1)*cX +   ix-1))) : false;\\n                            const bool nyp1xp1 = (iy < cY-1 && ix < cX-1)    ? (cyx == (@g_image((iy+1)*cX +   ix+1))) : false;\\n\\n                            // Lowest label\\n                            unsigned int label = lyx;\\n\\n                            // Find lowest neighbouring label\\n                            label = ((nym1x) && (lym1x < label)) ? lym1x : label;\\n                            label = ((nyxm1) && (lyxm1 < label)) ? lyxm1 : label;\\n                            label = ((nyxp1) && (lyxp1 < label)) ? lyxp1 : label;\\n                            label = ((nyp1x) && (lyp1x < label)) ? lyp1x : label;\\n\\n                            label = ((nym1xm1) && (lym1xm1 < label)) ? lym1xm1 : label;\\n                            label = ((nym1xp1) && (lym1xp1 < label)) ? lym1xp1 : label;\\n                            label = ((nyp1xm1) && (lyp1xm1 < label)) ? lyp1xm1 : label;\\n                            label = ((nyp1xp1) && (lyp1xp1 < label)) ? lyp1xp1 : label;\\n\\n                            // If labels are different, resolve them\\n                            if(label < lyx) {\\n                                // Update label\\n                                // Nonatomic write may overwrite another label but on average seems to give faster results\\n                                @g_labels(lyx) = label;\\n\\n                                // Record the change\\n                                @in1(0) = 1;\\n                            }\\n                        }\\n                    }\\n                    ' + f'\\n                    dim3 block(32, 32);\\n                    const int cX= {cX};\\n                    const int cY= {cY};' + '\\n                    dim3 grid(ceil(cX/(float)block.x), ceil(cY/(float)block.y));\\n                    dim3 resolve_block(32, 32);\\n                    dim3 resolve_grid(ceil(cX/(float)resolve_block.x), ceil(cY/(float)resolve_block.y));\\n                    \\n                    // Initialise labels\\n                    init_labels <<< grid, block >>>(@ARGS, cX, cY);\\n                    \\n                    // Resolve the labels\\n                    resolve_labels <<< resolve_grid, resolve_block >>>(@ARGS, cX, cY);\\n\\n                    // Changed Flag\\n                    int32 changed = 1;\\n                    \\n                    // While labels have changed\\n                    while(changed) {\\n                        // Copy changed to device\\n                        cudaMemsetAsync(in1_p, 0, 4);\\n                        \\n                        // Label image\\n                        label_equivalence <<< grid, block >>>(@ARGS, cX, cY);\\n\\n                        // Copy changed flag to host\\n                        cudaMemcpy(&changed, in1_p, sizeof(int32), cudaMemcpyDeviceToHost);\\n                        \\n                        // Resolve the labels\\n                        resolve_labels <<< resolve_grid, resolve_block>>>(@ARGS, cX, cY);\\n                    }\\n                    ')\n    result = result.reshape((cY, cX)) * data_2d_copy\n    value = jt.unique(result)\n    value = value[value != 0]\n    map_result = jt.zeros(int(value.max().numpy()[0]) + 1, dtype=jt.uint32)\n    map_result[value] = jt.index(value.shape)[0] + 1\n    result = map_result[result]\n    return result",
            "def ccl_2d(data_2d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \" \\n    2D connected component labelling, original code from https://github.com/DanielPlayne/playne-equivalence-algorithm\\n    Args:\\n        [in]param data_2d: binary two-dimensional vector\\n            type data_2d: jittor array\\n\\n    Returns:\\n        [out]result: labeled two-dimensional vector\\n\\n    Example:\\n    >>> import jittor as jt\\n    >>> jt.flags.use_cuda = 1\\n    >>> import cv2\\n    >>> import numpy as np\\n    >>> img = cv2.imread('testImg.png', 0)\\n    >>> a = img.mean()\\n    >>> img[img <= a] = 0\\n    >>> img[img > a] = 1\\n    >>> img = jt.Var(img)\\n\\n    >>> result = ccl_2d(img)\\n    >>> print(jt.unique(result, return_counts=True, return_inverse=True)[0], jt.unique(result, return_counts=True, return_inverse=True)[2])\\n    >>> cv2.imwrite('testImg_result.png', result.numpy().astype(np.uint8) * 50)\\n    \"\n    data_2d = data_2d.astype(jt.uint32)\n    cY = data_2d.shape[0]\n    cX = data_2d.shape[1]\n    data_2d_copy = data_2d.clone()\n    changed = jt.ones([1], dtype=jt.uint32)\n    data_2d = data_2d.reshape(cX * cY)\n    result = jt.code(data_2d.shape, data_2d.dtype, [data_2d, changed], cuda_header='\\n                    @alias(g_image, in0)\\n                    @alias(g_labels, out)\\n                    ', cuda_src='\\n                    __global__ void init_labels(@ARGS_DEF, const int cX, const int cY) {\\n                        @PRECALC\\n                        // Calculate index\\n                        const unsigned int ix = (blockIdx.x * blockDim.x) + threadIdx.x;\\n                        const unsigned int iy = (blockIdx.y * blockDim.y) + threadIdx.y;\\n                        @g_labels(iy*cX + ix) = iy*cX + ix;\\n                    }\\n\\n                    __device__ __inline__ unsigned int find_root(@ARGS_DEF, unsigned int label) {\\n                        // Resolve Label\\n                        unsigned int next = @g_labels(label);\\n\\n                        // Follow chain\\n                        while(label != next) {\\n                            // Move to next\\n                            label = next;\\n                            next = @g_labels(label);\\n                        }\\n\\n                        // Return label\\n                        return label;\\n                    }\\n\\n                    __global__ void resolve_labels(@ARGS_DEF, const int cX, const int cY) {\\n                        @PRECALC\\n                        // Calculate index\\n                        const unsigned int id = ((blockIdx.y * blockDim.y) + threadIdx.y) * cX +\\n                                                ((blockIdx.x * blockDim.x) + threadIdx.x);\\n                        \\n                        // Check Thread Range\\n                        if(id < cX*cY) {\\n                            // Resolve Label\\n                            @g_labels(id) = find_root(@ARGS, @g_labels(id));\\n                        }\\n                    }\\n\\n                    __global__ void label_equivalence(@ARGS_DEF, const int cX, const int cY) {\\n                        @PRECALC\\n                        // Calculate index\\n                        const unsigned int ix = (blockIdx.x * blockDim.x) + threadIdx.x;\\n                        const unsigned int iy = (blockIdx.y * blockDim.y) + threadIdx.y;\\n\\n                        // Check Thread Range\\n                        if((ix < cX) && (iy < cY)) {\\n                            // Get image and label values\\n                            const unsigned char cyx   = @g_image( iy*cX + ix);\\n                            \\n                            // Get neighbour labels\\n                            const unsigned int lym1x = (iy > 0)    ? @g_labels((iy-1)*cX +   ix) : 0;\\n                            const unsigned int lyxm1 = (ix > 0)    ? @g_labels(iy    *cX + ix-1) : 0;\\n                            const unsigned int lyx   =               @g_labels(iy    *cX +   ix);\\n                            const unsigned int lyxp1 = (ix < cX-1) ? @g_labels(iy    *cX + ix+1) : 0;\\n                            const unsigned int lyp1x = (iy < cY-1) ? @g_labels((iy+1)*cX +   ix) : 0;\\n\\n                            const unsigned int lym1xm1 = (iy > 0    && ix > 0   )    ? @g_labels((iy-1)*cX +   ix-1) : 0;\\n                            const unsigned int lym1xp1 = (iy > 0    && ix < cX-1)    ? @g_labels((iy-1)*cX +   ix+1) : 0;\\n                            const unsigned int lyp1xm1 = (iy < cY-1 && ix > 0   )    ? @g_labels((iy+1)*cX +   ix-1) : 0;\\n                            const unsigned int lyp1xp1 = (iy < cY-1 && ix < cX-1)    ? @g_labels((iy+1)*cX +   ix+1) : 0;\\n\\n                            const bool nym1x = (iy > 0)    ? (cyx == (@g_image((iy-1)*cX +   ix))) : false;\\n                            const bool nyxm1 = (ix > 0)    ? (cyx == (@g_image(iy    *cX + ix-1))) : false;\\n                            const bool nyxp1 = (ix < cX-1) ? (cyx == (@g_image(iy    *cX + ix+1))) : false;\\n                            const bool nyp1x = (iy > cY-1) ? (cyx == (@g_image((iy+1)*cX +   ix))) : false;\\n\\n                            const bool nym1xm1 = (iy > 0    && ix > 0   )    ? (cyx == (@g_image((iy-1)*cX +   ix-1))) : false;\\n                            const bool nym1xp1 = (iy > 0    && ix < cX-1)    ? (cyx == (@g_image((iy-1)*cX +   ix+1))) : false;\\n                            const bool nyp1xm1 = (iy < cY-1 && ix > 0   )    ? (cyx == (@g_image((iy+1)*cX +   ix-1))) : false;\\n                            const bool nyp1xp1 = (iy < cY-1 && ix < cX-1)    ? (cyx == (@g_image((iy+1)*cX +   ix+1))) : false;\\n\\n                            // Lowest label\\n                            unsigned int label = lyx;\\n\\n                            // Find lowest neighbouring label\\n                            label = ((nym1x) && (lym1x < label)) ? lym1x : label;\\n                            label = ((nyxm1) && (lyxm1 < label)) ? lyxm1 : label;\\n                            label = ((nyxp1) && (lyxp1 < label)) ? lyxp1 : label;\\n                            label = ((nyp1x) && (lyp1x < label)) ? lyp1x : label;\\n\\n                            label = ((nym1xm1) && (lym1xm1 < label)) ? lym1xm1 : label;\\n                            label = ((nym1xp1) && (lym1xp1 < label)) ? lym1xp1 : label;\\n                            label = ((nyp1xm1) && (lyp1xm1 < label)) ? lyp1xm1 : label;\\n                            label = ((nyp1xp1) && (lyp1xp1 < label)) ? lyp1xp1 : label;\\n\\n                            // If labels are different, resolve them\\n                            if(label < lyx) {\\n                                // Update label\\n                                // Nonatomic write may overwrite another label but on average seems to give faster results\\n                                @g_labels(lyx) = label;\\n\\n                                // Record the change\\n                                @in1(0) = 1;\\n                            }\\n                        }\\n                    }\\n                    ' + f'\\n                    dim3 block(32, 32);\\n                    const int cX= {cX};\\n                    const int cY= {cY};' + '\\n                    dim3 grid(ceil(cX/(float)block.x), ceil(cY/(float)block.y));\\n                    dim3 resolve_block(32, 32);\\n                    dim3 resolve_grid(ceil(cX/(float)resolve_block.x), ceil(cY/(float)resolve_block.y));\\n                    \\n                    // Initialise labels\\n                    init_labels <<< grid, block >>>(@ARGS, cX, cY);\\n                    \\n                    // Resolve the labels\\n                    resolve_labels <<< resolve_grid, resolve_block >>>(@ARGS, cX, cY);\\n\\n                    // Changed Flag\\n                    int32 changed = 1;\\n                    \\n                    // While labels have changed\\n                    while(changed) {\\n                        // Copy changed to device\\n                        cudaMemsetAsync(in1_p, 0, 4);\\n                        \\n                        // Label image\\n                        label_equivalence <<< grid, block >>>(@ARGS, cX, cY);\\n\\n                        // Copy changed flag to host\\n                        cudaMemcpy(&changed, in1_p, sizeof(int32), cudaMemcpyDeviceToHost);\\n                        \\n                        // Resolve the labels\\n                        resolve_labels <<< resolve_grid, resolve_block>>>(@ARGS, cX, cY);\\n                    }\\n                    ')\n    result = result.reshape((cY, cX)) * data_2d_copy\n    value = jt.unique(result)\n    value = value[value != 0]\n    map_result = jt.zeros(int(value.max().numpy()[0]) + 1, dtype=jt.uint32)\n    map_result[value] = jt.index(value.shape)[0] + 1\n    result = map_result[result]\n    return result",
            "def ccl_2d(data_2d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \" \\n    2D connected component labelling, original code from https://github.com/DanielPlayne/playne-equivalence-algorithm\\n    Args:\\n        [in]param data_2d: binary two-dimensional vector\\n            type data_2d: jittor array\\n\\n    Returns:\\n        [out]result: labeled two-dimensional vector\\n\\n    Example:\\n    >>> import jittor as jt\\n    >>> jt.flags.use_cuda = 1\\n    >>> import cv2\\n    >>> import numpy as np\\n    >>> img = cv2.imread('testImg.png', 0)\\n    >>> a = img.mean()\\n    >>> img[img <= a] = 0\\n    >>> img[img > a] = 1\\n    >>> img = jt.Var(img)\\n\\n    >>> result = ccl_2d(img)\\n    >>> print(jt.unique(result, return_counts=True, return_inverse=True)[0], jt.unique(result, return_counts=True, return_inverse=True)[2])\\n    >>> cv2.imwrite('testImg_result.png', result.numpy().astype(np.uint8) * 50)\\n    \"\n    data_2d = data_2d.astype(jt.uint32)\n    cY = data_2d.shape[0]\n    cX = data_2d.shape[1]\n    data_2d_copy = data_2d.clone()\n    changed = jt.ones([1], dtype=jt.uint32)\n    data_2d = data_2d.reshape(cX * cY)\n    result = jt.code(data_2d.shape, data_2d.dtype, [data_2d, changed], cuda_header='\\n                    @alias(g_image, in0)\\n                    @alias(g_labels, out)\\n                    ', cuda_src='\\n                    __global__ void init_labels(@ARGS_DEF, const int cX, const int cY) {\\n                        @PRECALC\\n                        // Calculate index\\n                        const unsigned int ix = (blockIdx.x * blockDim.x) + threadIdx.x;\\n                        const unsigned int iy = (blockIdx.y * blockDim.y) + threadIdx.y;\\n                        @g_labels(iy*cX + ix) = iy*cX + ix;\\n                    }\\n\\n                    __device__ __inline__ unsigned int find_root(@ARGS_DEF, unsigned int label) {\\n                        // Resolve Label\\n                        unsigned int next = @g_labels(label);\\n\\n                        // Follow chain\\n                        while(label != next) {\\n                            // Move to next\\n                            label = next;\\n                            next = @g_labels(label);\\n                        }\\n\\n                        // Return label\\n                        return label;\\n                    }\\n\\n                    __global__ void resolve_labels(@ARGS_DEF, const int cX, const int cY) {\\n                        @PRECALC\\n                        // Calculate index\\n                        const unsigned int id = ((blockIdx.y * blockDim.y) + threadIdx.y) * cX +\\n                                                ((blockIdx.x * blockDim.x) + threadIdx.x);\\n                        \\n                        // Check Thread Range\\n                        if(id < cX*cY) {\\n                            // Resolve Label\\n                            @g_labels(id) = find_root(@ARGS, @g_labels(id));\\n                        }\\n                    }\\n\\n                    __global__ void label_equivalence(@ARGS_DEF, const int cX, const int cY) {\\n                        @PRECALC\\n                        // Calculate index\\n                        const unsigned int ix = (blockIdx.x * blockDim.x) + threadIdx.x;\\n                        const unsigned int iy = (blockIdx.y * blockDim.y) + threadIdx.y;\\n\\n                        // Check Thread Range\\n                        if((ix < cX) && (iy < cY)) {\\n                            // Get image and label values\\n                            const unsigned char cyx   = @g_image( iy*cX + ix);\\n                            \\n                            // Get neighbour labels\\n                            const unsigned int lym1x = (iy > 0)    ? @g_labels((iy-1)*cX +   ix) : 0;\\n                            const unsigned int lyxm1 = (ix > 0)    ? @g_labels(iy    *cX + ix-1) : 0;\\n                            const unsigned int lyx   =               @g_labels(iy    *cX +   ix);\\n                            const unsigned int lyxp1 = (ix < cX-1) ? @g_labels(iy    *cX + ix+1) : 0;\\n                            const unsigned int lyp1x = (iy < cY-1) ? @g_labels((iy+1)*cX +   ix) : 0;\\n\\n                            const unsigned int lym1xm1 = (iy > 0    && ix > 0   )    ? @g_labels((iy-1)*cX +   ix-1) : 0;\\n                            const unsigned int lym1xp1 = (iy > 0    && ix < cX-1)    ? @g_labels((iy-1)*cX +   ix+1) : 0;\\n                            const unsigned int lyp1xm1 = (iy < cY-1 && ix > 0   )    ? @g_labels((iy+1)*cX +   ix-1) : 0;\\n                            const unsigned int lyp1xp1 = (iy < cY-1 && ix < cX-1)    ? @g_labels((iy+1)*cX +   ix+1) : 0;\\n\\n                            const bool nym1x = (iy > 0)    ? (cyx == (@g_image((iy-1)*cX +   ix))) : false;\\n                            const bool nyxm1 = (ix > 0)    ? (cyx == (@g_image(iy    *cX + ix-1))) : false;\\n                            const bool nyxp1 = (ix < cX-1) ? (cyx == (@g_image(iy    *cX + ix+1))) : false;\\n                            const bool nyp1x = (iy > cY-1) ? (cyx == (@g_image((iy+1)*cX +   ix))) : false;\\n\\n                            const bool nym1xm1 = (iy > 0    && ix > 0   )    ? (cyx == (@g_image((iy-1)*cX +   ix-1))) : false;\\n                            const bool nym1xp1 = (iy > 0    && ix < cX-1)    ? (cyx == (@g_image((iy-1)*cX +   ix+1))) : false;\\n                            const bool nyp1xm1 = (iy < cY-1 && ix > 0   )    ? (cyx == (@g_image((iy+1)*cX +   ix-1))) : false;\\n                            const bool nyp1xp1 = (iy < cY-1 && ix < cX-1)    ? (cyx == (@g_image((iy+1)*cX +   ix+1))) : false;\\n\\n                            // Lowest label\\n                            unsigned int label = lyx;\\n\\n                            // Find lowest neighbouring label\\n                            label = ((nym1x) && (lym1x < label)) ? lym1x : label;\\n                            label = ((nyxm1) && (lyxm1 < label)) ? lyxm1 : label;\\n                            label = ((nyxp1) && (lyxp1 < label)) ? lyxp1 : label;\\n                            label = ((nyp1x) && (lyp1x < label)) ? lyp1x : label;\\n\\n                            label = ((nym1xm1) && (lym1xm1 < label)) ? lym1xm1 : label;\\n                            label = ((nym1xp1) && (lym1xp1 < label)) ? lym1xp1 : label;\\n                            label = ((nyp1xm1) && (lyp1xm1 < label)) ? lyp1xm1 : label;\\n                            label = ((nyp1xp1) && (lyp1xp1 < label)) ? lyp1xp1 : label;\\n\\n                            // If labels are different, resolve them\\n                            if(label < lyx) {\\n                                // Update label\\n                                // Nonatomic write may overwrite another label but on average seems to give faster results\\n                                @g_labels(lyx) = label;\\n\\n                                // Record the change\\n                                @in1(0) = 1;\\n                            }\\n                        }\\n                    }\\n                    ' + f'\\n                    dim3 block(32, 32);\\n                    const int cX= {cX};\\n                    const int cY= {cY};' + '\\n                    dim3 grid(ceil(cX/(float)block.x), ceil(cY/(float)block.y));\\n                    dim3 resolve_block(32, 32);\\n                    dim3 resolve_grid(ceil(cX/(float)resolve_block.x), ceil(cY/(float)resolve_block.y));\\n                    \\n                    // Initialise labels\\n                    init_labels <<< grid, block >>>(@ARGS, cX, cY);\\n                    \\n                    // Resolve the labels\\n                    resolve_labels <<< resolve_grid, resolve_block >>>(@ARGS, cX, cY);\\n\\n                    // Changed Flag\\n                    int32 changed = 1;\\n                    \\n                    // While labels have changed\\n                    while(changed) {\\n                        // Copy changed to device\\n                        cudaMemsetAsync(in1_p, 0, 4);\\n                        \\n                        // Label image\\n                        label_equivalence <<< grid, block >>>(@ARGS, cX, cY);\\n\\n                        // Copy changed flag to host\\n                        cudaMemcpy(&changed, in1_p, sizeof(int32), cudaMemcpyDeviceToHost);\\n                        \\n                        // Resolve the labels\\n                        resolve_labels <<< resolve_grid, resolve_block>>>(@ARGS, cX, cY);\\n                    }\\n                    ')\n    result = result.reshape((cY, cX)) * data_2d_copy\n    value = jt.unique(result)\n    value = value[value != 0]\n    map_result = jt.zeros(int(value.max().numpy()[0]) + 1, dtype=jt.uint32)\n    map_result[value] = jt.index(value.shape)[0] + 1\n    result = map_result[result]\n    return result"
        ]
    }
]