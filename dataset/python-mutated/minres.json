[
    {
        "func_name": "minres",
        "original": "@_deprecate_positional_args(version='1.14.0')\ndef minres(A, b, x0=None, *, shift=0.0, tol=1e-05, maxiter=None, M=None, callback=None, show=False, check=False):\n    \"\"\"\n    Use MINimum RESidual iteration to solve Ax=b\n\n    MINRES minimizes norm(Ax - b) for a real symmetric matrix A.  Unlike\n    the Conjugate Gradient method, A can be indefinite or singular.\n\n    If shift != 0 then the method solves (A - shift*I)x = b\n\n    Parameters\n    ----------\n    A : {sparse matrix, ndarray, LinearOperator}\n        The real symmetric N-by-N matrix of the linear system\n        Alternatively, ``A`` can be a linear operator which can\n        produce ``Ax`` using, e.g.,\n        ``scipy.sparse.linalg.LinearOperator``.\n    b : ndarray\n        Right hand side of the linear system. Has shape (N,) or (N,1).\n\n    Returns\n    -------\n    x : ndarray\n        The converged solution.\n    info : integer\n        Provides convergence information:\n            0  : successful exit\n            >0 : convergence to tolerance not achieved, number of iterations\n            <0 : illegal input or breakdown\n\n    Other Parameters\n    ----------------\n    x0 : ndarray\n        Starting guess for the solution.\n    shift : float\n        Value to apply to the system ``(A - shift * I)x = b``. Default is 0.\n    tol : float\n        Tolerance to achieve. The algorithm terminates when the relative\n        residual is below `tol`.\n    maxiter : integer\n        Maximum number of iterations.  Iteration will stop after maxiter\n        steps even if the specified tolerance has not been achieved.\n    M : {sparse matrix, ndarray, LinearOperator}\n        Preconditioner for A.  The preconditioner should approximate the\n        inverse of A.  Effective preconditioning dramatically improves the\n        rate of convergence, which implies that fewer iterations are needed\n        to reach a given error tolerance.\n    callback : function\n        User-supplied function to call after each iteration.  It is called\n        as callback(xk), where xk is the current solution vector.\n    show : bool\n        If ``True``, print out a summary and metrics related to the solution\n        during iterations. Default is ``False``.\n    check : bool\n        If ``True``, run additional input validation to check that `A` and\n        `M` (if specified) are symmetric. Default is ``False``.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from scipy.sparse import csc_matrix\n    >>> from scipy.sparse.linalg import minres\n    >>> A = csc_matrix([[3, 2, 0], [1, -1, 0], [0, 5, 1]], dtype=float)\n    >>> A = A + A.T\n    >>> b = np.array([2, 4, -1], dtype=float)\n    >>> x, exitCode = minres(A, b)\n    >>> print(exitCode)            # 0 indicates successful convergence\n    0\n    >>> np.allclose(A.dot(x), b)\n    True\n\n    References\n    ----------\n    Solution of sparse indefinite systems of linear equations,\n        C. C. Paige and M. A. Saunders (1975),\n        SIAM J. Numer. Anal. 12(4), pp. 617-629.\n        https://web.stanford.edu/group/SOL/software/minres/\n\n    This file is a translation of the following MATLAB implementation:\n        https://web.stanford.edu/group/SOL/software/minres/minres-matlab.zip\n\n    \"\"\"\n    (A, M, x, b, postprocess) = make_system(A, M, x0, b)\n    matvec = A.matvec\n    psolve = M.matvec\n    first = 'Enter minres.   '\n    last = 'Exit  minres.   '\n    n = A.shape[0]\n    if maxiter is None:\n        maxiter = 5 * n\n    msg = [' beta2 = 0.  If M = I, b and x are eigenvectors    ', ' beta1 = 0.  The exact solution is x0          ', ' A solution to Ax = b was found, given rtol        ', ' A least-squares solution was found, given rtol    ', ' Reasonable accuracy achieved, given eps           ', ' x has converged to an eigenvector                 ', ' acond has exceeded 0.1/eps                        ', ' The iteration limit was reached                   ', ' A  does not define a symmetric matrix             ', ' M  does not define a symmetric matrix             ', ' M  does not define a pos-def preconditioner       ']\n    if show:\n        print(first + 'Solution of symmetric Ax = b')\n        print(first + f'n      =  {n:3g}     shift  =  {shift:23.14e}')\n        print(first + f'itnlim =  {maxiter:3g}     rtol   =  {tol:11.2e}')\n        print()\n    istop = 0\n    itn = 0\n    Anorm = 0\n    Acond = 0\n    rnorm = 0\n    ynorm = 0\n    xtype = x.dtype\n    eps = finfo(xtype).eps\n    if x0 is None:\n        r1 = b.copy()\n    else:\n        r1 = b - A @ x\n    y = psolve(r1)\n    beta1 = inner(r1, y)\n    if beta1 < 0:\n        raise ValueError('indefinite preconditioner')\n    elif beta1 == 0:\n        return (postprocess(x), 0)\n    bnorm = norm(b)\n    if bnorm == 0:\n        x = b\n        return (postprocess(x), 0)\n    beta1 = sqrt(beta1)\n    if check:\n        w = matvec(y)\n        r2 = matvec(w)\n        s = inner(w, w)\n        t = inner(y, r2)\n        z = abs(s - t)\n        epsa = (s + eps) * eps ** (1.0 / 3.0)\n        if z > epsa:\n            raise ValueError('non-symmetric matrix')\n        r2 = psolve(y)\n        s = inner(y, y)\n        t = inner(r1, r2)\n        z = abs(s - t)\n        epsa = (s + eps) * eps ** (1.0 / 3.0)\n        if z > epsa:\n            raise ValueError('non-symmetric preconditioner')\n    oldb = 0\n    beta = beta1\n    dbar = 0\n    epsln = 0\n    qrnorm = beta1\n    phibar = beta1\n    rhs1 = beta1\n    rhs2 = 0\n    tnorm2 = 0\n    gmax = 0\n    gmin = finfo(xtype).max\n    cs = -1\n    sn = 0\n    w = zeros(n, dtype=xtype)\n    w2 = zeros(n, dtype=xtype)\n    r2 = r1\n    if show:\n        print()\n        print()\n        print('   Itn     x(1)     Compatible    LS       norm(A)  cond(A) gbar/|A|')\n    while itn < maxiter:\n        itn += 1\n        s = 1.0 / beta\n        v = s * y\n        y = matvec(v)\n        y = y - shift * v\n        if itn >= 2:\n            y = y - beta / oldb * r1\n        alfa = inner(v, y)\n        y = y - alfa / beta * r2\n        r1 = r2\n        r2 = y\n        y = psolve(r2)\n        oldb = beta\n        beta = inner(r2, y)\n        if beta < 0:\n            raise ValueError('non-symmetric matrix')\n        beta = sqrt(beta)\n        tnorm2 += alfa ** 2 + oldb ** 2 + beta ** 2\n        if itn == 1:\n            if beta / beta1 <= 10 * eps:\n                istop = -1\n        oldeps = epsln\n        delta = cs * dbar + sn * alfa\n        gbar = sn * dbar - cs * alfa\n        epsln = sn * beta\n        dbar = -cs * beta\n        root = norm([gbar, dbar])\n        Arnorm = phibar * root\n        gamma = norm([gbar, beta])\n        gamma = max(gamma, eps)\n        cs = gbar / gamma\n        sn = beta / gamma\n        phi = cs * phibar\n        phibar = sn * phibar\n        denom = 1.0 / gamma\n        w1 = w2\n        w2 = w\n        w = (v - oldeps * w1 - delta * w2) * denom\n        x = x + phi * w\n        gmax = max(gmax, gamma)\n        gmin = min(gmin, gamma)\n        z = rhs1 / gamma\n        rhs1 = rhs2 - delta * z\n        rhs2 = -epsln * z\n        Anorm = sqrt(tnorm2)\n        ynorm = norm(x)\n        epsa = Anorm * eps\n        epsx = Anorm * ynorm * eps\n        epsr = Anorm * ynorm * tol\n        diag = gbar\n        if diag == 0:\n            diag = epsa\n        qrnorm = phibar\n        rnorm = qrnorm\n        if ynorm == 0 or Anorm == 0:\n            test1 = inf\n        else:\n            test1 = rnorm / (Anorm * ynorm)\n        if Anorm == 0:\n            test2 = inf\n        else:\n            test2 = root / Anorm\n        Acond = gmax / gmin\n        if istop == 0:\n            t1 = 1 + test1\n            t2 = 1 + test2\n            if t2 <= 1:\n                istop = 2\n            if t1 <= 1:\n                istop = 1\n            if itn >= maxiter:\n                istop = 6\n            if Acond >= 0.1 / eps:\n                istop = 4\n            if epsx >= beta1:\n                istop = 3\n            if test2 <= tol:\n                istop = 2\n            if test1 <= tol:\n                istop = 1\n        prnt = False\n        if n <= 40:\n            prnt = True\n        if itn <= 10:\n            prnt = True\n        if itn >= maxiter - 10:\n            prnt = True\n        if itn % 10 == 0:\n            prnt = True\n        if qrnorm <= 10 * epsx:\n            prnt = True\n        if qrnorm <= 10 * epsr:\n            prnt = True\n        if Acond <= 0.01 / eps:\n            prnt = True\n        if istop != 0:\n            prnt = True\n        if show and prnt:\n            str1 = f'{itn:6g} {x[0]:12.5e} {test1:10.3e}'\n            str2 = f' {test2:10.3e}'\n            str3 = f' {Anorm:8.1e} {Acond:8.1e} {gbar / Anorm:8.1e}'\n            print(str1 + str2 + str3)\n            if itn % 10 == 0:\n                print()\n        if callback is not None:\n            callback(x)\n        if istop != 0:\n            break\n    if show:\n        print()\n        print(last + f' istop   =  {istop:3g}               itn   ={itn:5g}')\n        print(last + f' Anorm   =  {Anorm:12.4e}      Acond =  {Acond:12.4e}')\n        print(last + f' rnorm   =  {rnorm:12.4e}      ynorm =  {ynorm:12.4e}')\n        print(last + f' Arnorm  =  {Arnorm:12.4e}')\n        print(last + msg[istop + 1])\n    if istop == 6:\n        info = maxiter\n    else:\n        info = 0\n    return (postprocess(x), info)",
        "mutated": [
            "@_deprecate_positional_args(version='1.14.0')\ndef minres(A, b, x0=None, *, shift=0.0, tol=1e-05, maxiter=None, M=None, callback=None, show=False, check=False):\n    if False:\n        i = 10\n    '\\n    Use MINimum RESidual iteration to solve Ax=b\\n\\n    MINRES minimizes norm(Ax - b) for a real symmetric matrix A.  Unlike\\n    the Conjugate Gradient method, A can be indefinite or singular.\\n\\n    If shift != 0 then the method solves (A - shift*I)x = b\\n\\n    Parameters\\n    ----------\\n    A : {sparse matrix, ndarray, LinearOperator}\\n        The real symmetric N-by-N matrix of the linear system\\n        Alternatively, ``A`` can be a linear operator which can\\n        produce ``Ax`` using, e.g.,\\n        ``scipy.sparse.linalg.LinearOperator``.\\n    b : ndarray\\n        Right hand side of the linear system. Has shape (N,) or (N,1).\\n\\n    Returns\\n    -------\\n    x : ndarray\\n        The converged solution.\\n    info : integer\\n        Provides convergence information:\\n            0  : successful exit\\n            >0 : convergence to tolerance not achieved, number of iterations\\n            <0 : illegal input or breakdown\\n\\n    Other Parameters\\n    ----------------\\n    x0 : ndarray\\n        Starting guess for the solution.\\n    shift : float\\n        Value to apply to the system ``(A - shift * I)x = b``. Default is 0.\\n    tol : float\\n        Tolerance to achieve. The algorithm terminates when the relative\\n        residual is below `tol`.\\n    maxiter : integer\\n        Maximum number of iterations.  Iteration will stop after maxiter\\n        steps even if the specified tolerance has not been achieved.\\n    M : {sparse matrix, ndarray, LinearOperator}\\n        Preconditioner for A.  The preconditioner should approximate the\\n        inverse of A.  Effective preconditioning dramatically improves the\\n        rate of convergence, which implies that fewer iterations are needed\\n        to reach a given error tolerance.\\n    callback : function\\n        User-supplied function to call after each iteration.  It is called\\n        as callback(xk), where xk is the current solution vector.\\n    show : bool\\n        If ``True``, print out a summary and metrics related to the solution\\n        during iterations. Default is ``False``.\\n    check : bool\\n        If ``True``, run additional input validation to check that `A` and\\n        `M` (if specified) are symmetric. Default is ``False``.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from scipy.sparse import csc_matrix\\n    >>> from scipy.sparse.linalg import minres\\n    >>> A = csc_matrix([[3, 2, 0], [1, -1, 0], [0, 5, 1]], dtype=float)\\n    >>> A = A + A.T\\n    >>> b = np.array([2, 4, -1], dtype=float)\\n    >>> x, exitCode = minres(A, b)\\n    >>> print(exitCode)            # 0 indicates successful convergence\\n    0\\n    >>> np.allclose(A.dot(x), b)\\n    True\\n\\n    References\\n    ----------\\n    Solution of sparse indefinite systems of linear equations,\\n        C. C. Paige and M. A. Saunders (1975),\\n        SIAM J. Numer. Anal. 12(4), pp. 617-629.\\n        https://web.stanford.edu/group/SOL/software/minres/\\n\\n    This file is a translation of the following MATLAB implementation:\\n        https://web.stanford.edu/group/SOL/software/minres/minres-matlab.zip\\n\\n    '\n    (A, M, x, b, postprocess) = make_system(A, M, x0, b)\n    matvec = A.matvec\n    psolve = M.matvec\n    first = 'Enter minres.   '\n    last = 'Exit  minres.   '\n    n = A.shape[0]\n    if maxiter is None:\n        maxiter = 5 * n\n    msg = [' beta2 = 0.  If M = I, b and x are eigenvectors    ', ' beta1 = 0.  The exact solution is x0          ', ' A solution to Ax = b was found, given rtol        ', ' A least-squares solution was found, given rtol    ', ' Reasonable accuracy achieved, given eps           ', ' x has converged to an eigenvector                 ', ' acond has exceeded 0.1/eps                        ', ' The iteration limit was reached                   ', ' A  does not define a symmetric matrix             ', ' M  does not define a symmetric matrix             ', ' M  does not define a pos-def preconditioner       ']\n    if show:\n        print(first + 'Solution of symmetric Ax = b')\n        print(first + f'n      =  {n:3g}     shift  =  {shift:23.14e}')\n        print(first + f'itnlim =  {maxiter:3g}     rtol   =  {tol:11.2e}')\n        print()\n    istop = 0\n    itn = 0\n    Anorm = 0\n    Acond = 0\n    rnorm = 0\n    ynorm = 0\n    xtype = x.dtype\n    eps = finfo(xtype).eps\n    if x0 is None:\n        r1 = b.copy()\n    else:\n        r1 = b - A @ x\n    y = psolve(r1)\n    beta1 = inner(r1, y)\n    if beta1 < 0:\n        raise ValueError('indefinite preconditioner')\n    elif beta1 == 0:\n        return (postprocess(x), 0)\n    bnorm = norm(b)\n    if bnorm == 0:\n        x = b\n        return (postprocess(x), 0)\n    beta1 = sqrt(beta1)\n    if check:\n        w = matvec(y)\n        r2 = matvec(w)\n        s = inner(w, w)\n        t = inner(y, r2)\n        z = abs(s - t)\n        epsa = (s + eps) * eps ** (1.0 / 3.0)\n        if z > epsa:\n            raise ValueError('non-symmetric matrix')\n        r2 = psolve(y)\n        s = inner(y, y)\n        t = inner(r1, r2)\n        z = abs(s - t)\n        epsa = (s + eps) * eps ** (1.0 / 3.0)\n        if z > epsa:\n            raise ValueError('non-symmetric preconditioner')\n    oldb = 0\n    beta = beta1\n    dbar = 0\n    epsln = 0\n    qrnorm = beta1\n    phibar = beta1\n    rhs1 = beta1\n    rhs2 = 0\n    tnorm2 = 0\n    gmax = 0\n    gmin = finfo(xtype).max\n    cs = -1\n    sn = 0\n    w = zeros(n, dtype=xtype)\n    w2 = zeros(n, dtype=xtype)\n    r2 = r1\n    if show:\n        print()\n        print()\n        print('   Itn     x(1)     Compatible    LS       norm(A)  cond(A) gbar/|A|')\n    while itn < maxiter:\n        itn += 1\n        s = 1.0 / beta\n        v = s * y\n        y = matvec(v)\n        y = y - shift * v\n        if itn >= 2:\n            y = y - beta / oldb * r1\n        alfa = inner(v, y)\n        y = y - alfa / beta * r2\n        r1 = r2\n        r2 = y\n        y = psolve(r2)\n        oldb = beta\n        beta = inner(r2, y)\n        if beta < 0:\n            raise ValueError('non-symmetric matrix')\n        beta = sqrt(beta)\n        tnorm2 += alfa ** 2 + oldb ** 2 + beta ** 2\n        if itn == 1:\n            if beta / beta1 <= 10 * eps:\n                istop = -1\n        oldeps = epsln\n        delta = cs * dbar + sn * alfa\n        gbar = sn * dbar - cs * alfa\n        epsln = sn * beta\n        dbar = -cs * beta\n        root = norm([gbar, dbar])\n        Arnorm = phibar * root\n        gamma = norm([gbar, beta])\n        gamma = max(gamma, eps)\n        cs = gbar / gamma\n        sn = beta / gamma\n        phi = cs * phibar\n        phibar = sn * phibar\n        denom = 1.0 / gamma\n        w1 = w2\n        w2 = w\n        w = (v - oldeps * w1 - delta * w2) * denom\n        x = x + phi * w\n        gmax = max(gmax, gamma)\n        gmin = min(gmin, gamma)\n        z = rhs1 / gamma\n        rhs1 = rhs2 - delta * z\n        rhs2 = -epsln * z\n        Anorm = sqrt(tnorm2)\n        ynorm = norm(x)\n        epsa = Anorm * eps\n        epsx = Anorm * ynorm * eps\n        epsr = Anorm * ynorm * tol\n        diag = gbar\n        if diag == 0:\n            diag = epsa\n        qrnorm = phibar\n        rnorm = qrnorm\n        if ynorm == 0 or Anorm == 0:\n            test1 = inf\n        else:\n            test1 = rnorm / (Anorm * ynorm)\n        if Anorm == 0:\n            test2 = inf\n        else:\n            test2 = root / Anorm\n        Acond = gmax / gmin\n        if istop == 0:\n            t1 = 1 + test1\n            t2 = 1 + test2\n            if t2 <= 1:\n                istop = 2\n            if t1 <= 1:\n                istop = 1\n            if itn >= maxiter:\n                istop = 6\n            if Acond >= 0.1 / eps:\n                istop = 4\n            if epsx >= beta1:\n                istop = 3\n            if test2 <= tol:\n                istop = 2\n            if test1 <= tol:\n                istop = 1\n        prnt = False\n        if n <= 40:\n            prnt = True\n        if itn <= 10:\n            prnt = True\n        if itn >= maxiter - 10:\n            prnt = True\n        if itn % 10 == 0:\n            prnt = True\n        if qrnorm <= 10 * epsx:\n            prnt = True\n        if qrnorm <= 10 * epsr:\n            prnt = True\n        if Acond <= 0.01 / eps:\n            prnt = True\n        if istop != 0:\n            prnt = True\n        if show and prnt:\n            str1 = f'{itn:6g} {x[0]:12.5e} {test1:10.3e}'\n            str2 = f' {test2:10.3e}'\n            str3 = f' {Anorm:8.1e} {Acond:8.1e} {gbar / Anorm:8.1e}'\n            print(str1 + str2 + str3)\n            if itn % 10 == 0:\n                print()\n        if callback is not None:\n            callback(x)\n        if istop != 0:\n            break\n    if show:\n        print()\n        print(last + f' istop   =  {istop:3g}               itn   ={itn:5g}')\n        print(last + f' Anorm   =  {Anorm:12.4e}      Acond =  {Acond:12.4e}')\n        print(last + f' rnorm   =  {rnorm:12.4e}      ynorm =  {ynorm:12.4e}')\n        print(last + f' Arnorm  =  {Arnorm:12.4e}')\n        print(last + msg[istop + 1])\n    if istop == 6:\n        info = maxiter\n    else:\n        info = 0\n    return (postprocess(x), info)",
            "@_deprecate_positional_args(version='1.14.0')\ndef minres(A, b, x0=None, *, shift=0.0, tol=1e-05, maxiter=None, M=None, callback=None, show=False, check=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Use MINimum RESidual iteration to solve Ax=b\\n\\n    MINRES minimizes norm(Ax - b) for a real symmetric matrix A.  Unlike\\n    the Conjugate Gradient method, A can be indefinite or singular.\\n\\n    If shift != 0 then the method solves (A - shift*I)x = b\\n\\n    Parameters\\n    ----------\\n    A : {sparse matrix, ndarray, LinearOperator}\\n        The real symmetric N-by-N matrix of the linear system\\n        Alternatively, ``A`` can be a linear operator which can\\n        produce ``Ax`` using, e.g.,\\n        ``scipy.sparse.linalg.LinearOperator``.\\n    b : ndarray\\n        Right hand side of the linear system. Has shape (N,) or (N,1).\\n\\n    Returns\\n    -------\\n    x : ndarray\\n        The converged solution.\\n    info : integer\\n        Provides convergence information:\\n            0  : successful exit\\n            >0 : convergence to tolerance not achieved, number of iterations\\n            <0 : illegal input or breakdown\\n\\n    Other Parameters\\n    ----------------\\n    x0 : ndarray\\n        Starting guess for the solution.\\n    shift : float\\n        Value to apply to the system ``(A - shift * I)x = b``. Default is 0.\\n    tol : float\\n        Tolerance to achieve. The algorithm terminates when the relative\\n        residual is below `tol`.\\n    maxiter : integer\\n        Maximum number of iterations.  Iteration will stop after maxiter\\n        steps even if the specified tolerance has not been achieved.\\n    M : {sparse matrix, ndarray, LinearOperator}\\n        Preconditioner for A.  The preconditioner should approximate the\\n        inverse of A.  Effective preconditioning dramatically improves the\\n        rate of convergence, which implies that fewer iterations are needed\\n        to reach a given error tolerance.\\n    callback : function\\n        User-supplied function to call after each iteration.  It is called\\n        as callback(xk), where xk is the current solution vector.\\n    show : bool\\n        If ``True``, print out a summary and metrics related to the solution\\n        during iterations. Default is ``False``.\\n    check : bool\\n        If ``True``, run additional input validation to check that `A` and\\n        `M` (if specified) are symmetric. Default is ``False``.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from scipy.sparse import csc_matrix\\n    >>> from scipy.sparse.linalg import minres\\n    >>> A = csc_matrix([[3, 2, 0], [1, -1, 0], [0, 5, 1]], dtype=float)\\n    >>> A = A + A.T\\n    >>> b = np.array([2, 4, -1], dtype=float)\\n    >>> x, exitCode = minres(A, b)\\n    >>> print(exitCode)            # 0 indicates successful convergence\\n    0\\n    >>> np.allclose(A.dot(x), b)\\n    True\\n\\n    References\\n    ----------\\n    Solution of sparse indefinite systems of linear equations,\\n        C. C. Paige and M. A. Saunders (1975),\\n        SIAM J. Numer. Anal. 12(4), pp. 617-629.\\n        https://web.stanford.edu/group/SOL/software/minres/\\n\\n    This file is a translation of the following MATLAB implementation:\\n        https://web.stanford.edu/group/SOL/software/minres/minres-matlab.zip\\n\\n    '\n    (A, M, x, b, postprocess) = make_system(A, M, x0, b)\n    matvec = A.matvec\n    psolve = M.matvec\n    first = 'Enter minres.   '\n    last = 'Exit  minres.   '\n    n = A.shape[0]\n    if maxiter is None:\n        maxiter = 5 * n\n    msg = [' beta2 = 0.  If M = I, b and x are eigenvectors    ', ' beta1 = 0.  The exact solution is x0          ', ' A solution to Ax = b was found, given rtol        ', ' A least-squares solution was found, given rtol    ', ' Reasonable accuracy achieved, given eps           ', ' x has converged to an eigenvector                 ', ' acond has exceeded 0.1/eps                        ', ' The iteration limit was reached                   ', ' A  does not define a symmetric matrix             ', ' M  does not define a symmetric matrix             ', ' M  does not define a pos-def preconditioner       ']\n    if show:\n        print(first + 'Solution of symmetric Ax = b')\n        print(first + f'n      =  {n:3g}     shift  =  {shift:23.14e}')\n        print(first + f'itnlim =  {maxiter:3g}     rtol   =  {tol:11.2e}')\n        print()\n    istop = 0\n    itn = 0\n    Anorm = 0\n    Acond = 0\n    rnorm = 0\n    ynorm = 0\n    xtype = x.dtype\n    eps = finfo(xtype).eps\n    if x0 is None:\n        r1 = b.copy()\n    else:\n        r1 = b - A @ x\n    y = psolve(r1)\n    beta1 = inner(r1, y)\n    if beta1 < 0:\n        raise ValueError('indefinite preconditioner')\n    elif beta1 == 0:\n        return (postprocess(x), 0)\n    bnorm = norm(b)\n    if bnorm == 0:\n        x = b\n        return (postprocess(x), 0)\n    beta1 = sqrt(beta1)\n    if check:\n        w = matvec(y)\n        r2 = matvec(w)\n        s = inner(w, w)\n        t = inner(y, r2)\n        z = abs(s - t)\n        epsa = (s + eps) * eps ** (1.0 / 3.0)\n        if z > epsa:\n            raise ValueError('non-symmetric matrix')\n        r2 = psolve(y)\n        s = inner(y, y)\n        t = inner(r1, r2)\n        z = abs(s - t)\n        epsa = (s + eps) * eps ** (1.0 / 3.0)\n        if z > epsa:\n            raise ValueError('non-symmetric preconditioner')\n    oldb = 0\n    beta = beta1\n    dbar = 0\n    epsln = 0\n    qrnorm = beta1\n    phibar = beta1\n    rhs1 = beta1\n    rhs2 = 0\n    tnorm2 = 0\n    gmax = 0\n    gmin = finfo(xtype).max\n    cs = -1\n    sn = 0\n    w = zeros(n, dtype=xtype)\n    w2 = zeros(n, dtype=xtype)\n    r2 = r1\n    if show:\n        print()\n        print()\n        print('   Itn     x(1)     Compatible    LS       norm(A)  cond(A) gbar/|A|')\n    while itn < maxiter:\n        itn += 1\n        s = 1.0 / beta\n        v = s * y\n        y = matvec(v)\n        y = y - shift * v\n        if itn >= 2:\n            y = y - beta / oldb * r1\n        alfa = inner(v, y)\n        y = y - alfa / beta * r2\n        r1 = r2\n        r2 = y\n        y = psolve(r2)\n        oldb = beta\n        beta = inner(r2, y)\n        if beta < 0:\n            raise ValueError('non-symmetric matrix')\n        beta = sqrt(beta)\n        tnorm2 += alfa ** 2 + oldb ** 2 + beta ** 2\n        if itn == 1:\n            if beta / beta1 <= 10 * eps:\n                istop = -1\n        oldeps = epsln\n        delta = cs * dbar + sn * alfa\n        gbar = sn * dbar - cs * alfa\n        epsln = sn * beta\n        dbar = -cs * beta\n        root = norm([gbar, dbar])\n        Arnorm = phibar * root\n        gamma = norm([gbar, beta])\n        gamma = max(gamma, eps)\n        cs = gbar / gamma\n        sn = beta / gamma\n        phi = cs * phibar\n        phibar = sn * phibar\n        denom = 1.0 / gamma\n        w1 = w2\n        w2 = w\n        w = (v - oldeps * w1 - delta * w2) * denom\n        x = x + phi * w\n        gmax = max(gmax, gamma)\n        gmin = min(gmin, gamma)\n        z = rhs1 / gamma\n        rhs1 = rhs2 - delta * z\n        rhs2 = -epsln * z\n        Anorm = sqrt(tnorm2)\n        ynorm = norm(x)\n        epsa = Anorm * eps\n        epsx = Anorm * ynorm * eps\n        epsr = Anorm * ynorm * tol\n        diag = gbar\n        if diag == 0:\n            diag = epsa\n        qrnorm = phibar\n        rnorm = qrnorm\n        if ynorm == 0 or Anorm == 0:\n            test1 = inf\n        else:\n            test1 = rnorm / (Anorm * ynorm)\n        if Anorm == 0:\n            test2 = inf\n        else:\n            test2 = root / Anorm\n        Acond = gmax / gmin\n        if istop == 0:\n            t1 = 1 + test1\n            t2 = 1 + test2\n            if t2 <= 1:\n                istop = 2\n            if t1 <= 1:\n                istop = 1\n            if itn >= maxiter:\n                istop = 6\n            if Acond >= 0.1 / eps:\n                istop = 4\n            if epsx >= beta1:\n                istop = 3\n            if test2 <= tol:\n                istop = 2\n            if test1 <= tol:\n                istop = 1\n        prnt = False\n        if n <= 40:\n            prnt = True\n        if itn <= 10:\n            prnt = True\n        if itn >= maxiter - 10:\n            prnt = True\n        if itn % 10 == 0:\n            prnt = True\n        if qrnorm <= 10 * epsx:\n            prnt = True\n        if qrnorm <= 10 * epsr:\n            prnt = True\n        if Acond <= 0.01 / eps:\n            prnt = True\n        if istop != 0:\n            prnt = True\n        if show and prnt:\n            str1 = f'{itn:6g} {x[0]:12.5e} {test1:10.3e}'\n            str2 = f' {test2:10.3e}'\n            str3 = f' {Anorm:8.1e} {Acond:8.1e} {gbar / Anorm:8.1e}'\n            print(str1 + str2 + str3)\n            if itn % 10 == 0:\n                print()\n        if callback is not None:\n            callback(x)\n        if istop != 0:\n            break\n    if show:\n        print()\n        print(last + f' istop   =  {istop:3g}               itn   ={itn:5g}')\n        print(last + f' Anorm   =  {Anorm:12.4e}      Acond =  {Acond:12.4e}')\n        print(last + f' rnorm   =  {rnorm:12.4e}      ynorm =  {ynorm:12.4e}')\n        print(last + f' Arnorm  =  {Arnorm:12.4e}')\n        print(last + msg[istop + 1])\n    if istop == 6:\n        info = maxiter\n    else:\n        info = 0\n    return (postprocess(x), info)",
            "@_deprecate_positional_args(version='1.14.0')\ndef minres(A, b, x0=None, *, shift=0.0, tol=1e-05, maxiter=None, M=None, callback=None, show=False, check=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Use MINimum RESidual iteration to solve Ax=b\\n\\n    MINRES minimizes norm(Ax - b) for a real symmetric matrix A.  Unlike\\n    the Conjugate Gradient method, A can be indefinite or singular.\\n\\n    If shift != 0 then the method solves (A - shift*I)x = b\\n\\n    Parameters\\n    ----------\\n    A : {sparse matrix, ndarray, LinearOperator}\\n        The real symmetric N-by-N matrix of the linear system\\n        Alternatively, ``A`` can be a linear operator which can\\n        produce ``Ax`` using, e.g.,\\n        ``scipy.sparse.linalg.LinearOperator``.\\n    b : ndarray\\n        Right hand side of the linear system. Has shape (N,) or (N,1).\\n\\n    Returns\\n    -------\\n    x : ndarray\\n        The converged solution.\\n    info : integer\\n        Provides convergence information:\\n            0  : successful exit\\n            >0 : convergence to tolerance not achieved, number of iterations\\n            <0 : illegal input or breakdown\\n\\n    Other Parameters\\n    ----------------\\n    x0 : ndarray\\n        Starting guess for the solution.\\n    shift : float\\n        Value to apply to the system ``(A - shift * I)x = b``. Default is 0.\\n    tol : float\\n        Tolerance to achieve. The algorithm terminates when the relative\\n        residual is below `tol`.\\n    maxiter : integer\\n        Maximum number of iterations.  Iteration will stop after maxiter\\n        steps even if the specified tolerance has not been achieved.\\n    M : {sparse matrix, ndarray, LinearOperator}\\n        Preconditioner for A.  The preconditioner should approximate the\\n        inverse of A.  Effective preconditioning dramatically improves the\\n        rate of convergence, which implies that fewer iterations are needed\\n        to reach a given error tolerance.\\n    callback : function\\n        User-supplied function to call after each iteration.  It is called\\n        as callback(xk), where xk is the current solution vector.\\n    show : bool\\n        If ``True``, print out a summary and metrics related to the solution\\n        during iterations. Default is ``False``.\\n    check : bool\\n        If ``True``, run additional input validation to check that `A` and\\n        `M` (if specified) are symmetric. Default is ``False``.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from scipy.sparse import csc_matrix\\n    >>> from scipy.sparse.linalg import minres\\n    >>> A = csc_matrix([[3, 2, 0], [1, -1, 0], [0, 5, 1]], dtype=float)\\n    >>> A = A + A.T\\n    >>> b = np.array([2, 4, -1], dtype=float)\\n    >>> x, exitCode = minres(A, b)\\n    >>> print(exitCode)            # 0 indicates successful convergence\\n    0\\n    >>> np.allclose(A.dot(x), b)\\n    True\\n\\n    References\\n    ----------\\n    Solution of sparse indefinite systems of linear equations,\\n        C. C. Paige and M. A. Saunders (1975),\\n        SIAM J. Numer. Anal. 12(4), pp. 617-629.\\n        https://web.stanford.edu/group/SOL/software/minres/\\n\\n    This file is a translation of the following MATLAB implementation:\\n        https://web.stanford.edu/group/SOL/software/minres/minres-matlab.zip\\n\\n    '\n    (A, M, x, b, postprocess) = make_system(A, M, x0, b)\n    matvec = A.matvec\n    psolve = M.matvec\n    first = 'Enter minres.   '\n    last = 'Exit  minres.   '\n    n = A.shape[0]\n    if maxiter is None:\n        maxiter = 5 * n\n    msg = [' beta2 = 0.  If M = I, b and x are eigenvectors    ', ' beta1 = 0.  The exact solution is x0          ', ' A solution to Ax = b was found, given rtol        ', ' A least-squares solution was found, given rtol    ', ' Reasonable accuracy achieved, given eps           ', ' x has converged to an eigenvector                 ', ' acond has exceeded 0.1/eps                        ', ' The iteration limit was reached                   ', ' A  does not define a symmetric matrix             ', ' M  does not define a symmetric matrix             ', ' M  does not define a pos-def preconditioner       ']\n    if show:\n        print(first + 'Solution of symmetric Ax = b')\n        print(first + f'n      =  {n:3g}     shift  =  {shift:23.14e}')\n        print(first + f'itnlim =  {maxiter:3g}     rtol   =  {tol:11.2e}')\n        print()\n    istop = 0\n    itn = 0\n    Anorm = 0\n    Acond = 0\n    rnorm = 0\n    ynorm = 0\n    xtype = x.dtype\n    eps = finfo(xtype).eps\n    if x0 is None:\n        r1 = b.copy()\n    else:\n        r1 = b - A @ x\n    y = psolve(r1)\n    beta1 = inner(r1, y)\n    if beta1 < 0:\n        raise ValueError('indefinite preconditioner')\n    elif beta1 == 0:\n        return (postprocess(x), 0)\n    bnorm = norm(b)\n    if bnorm == 0:\n        x = b\n        return (postprocess(x), 0)\n    beta1 = sqrt(beta1)\n    if check:\n        w = matvec(y)\n        r2 = matvec(w)\n        s = inner(w, w)\n        t = inner(y, r2)\n        z = abs(s - t)\n        epsa = (s + eps) * eps ** (1.0 / 3.0)\n        if z > epsa:\n            raise ValueError('non-symmetric matrix')\n        r2 = psolve(y)\n        s = inner(y, y)\n        t = inner(r1, r2)\n        z = abs(s - t)\n        epsa = (s + eps) * eps ** (1.0 / 3.0)\n        if z > epsa:\n            raise ValueError('non-symmetric preconditioner')\n    oldb = 0\n    beta = beta1\n    dbar = 0\n    epsln = 0\n    qrnorm = beta1\n    phibar = beta1\n    rhs1 = beta1\n    rhs2 = 0\n    tnorm2 = 0\n    gmax = 0\n    gmin = finfo(xtype).max\n    cs = -1\n    sn = 0\n    w = zeros(n, dtype=xtype)\n    w2 = zeros(n, dtype=xtype)\n    r2 = r1\n    if show:\n        print()\n        print()\n        print('   Itn     x(1)     Compatible    LS       norm(A)  cond(A) gbar/|A|')\n    while itn < maxiter:\n        itn += 1\n        s = 1.0 / beta\n        v = s * y\n        y = matvec(v)\n        y = y - shift * v\n        if itn >= 2:\n            y = y - beta / oldb * r1\n        alfa = inner(v, y)\n        y = y - alfa / beta * r2\n        r1 = r2\n        r2 = y\n        y = psolve(r2)\n        oldb = beta\n        beta = inner(r2, y)\n        if beta < 0:\n            raise ValueError('non-symmetric matrix')\n        beta = sqrt(beta)\n        tnorm2 += alfa ** 2 + oldb ** 2 + beta ** 2\n        if itn == 1:\n            if beta / beta1 <= 10 * eps:\n                istop = -1\n        oldeps = epsln\n        delta = cs * dbar + sn * alfa\n        gbar = sn * dbar - cs * alfa\n        epsln = sn * beta\n        dbar = -cs * beta\n        root = norm([gbar, dbar])\n        Arnorm = phibar * root\n        gamma = norm([gbar, beta])\n        gamma = max(gamma, eps)\n        cs = gbar / gamma\n        sn = beta / gamma\n        phi = cs * phibar\n        phibar = sn * phibar\n        denom = 1.0 / gamma\n        w1 = w2\n        w2 = w\n        w = (v - oldeps * w1 - delta * w2) * denom\n        x = x + phi * w\n        gmax = max(gmax, gamma)\n        gmin = min(gmin, gamma)\n        z = rhs1 / gamma\n        rhs1 = rhs2 - delta * z\n        rhs2 = -epsln * z\n        Anorm = sqrt(tnorm2)\n        ynorm = norm(x)\n        epsa = Anorm * eps\n        epsx = Anorm * ynorm * eps\n        epsr = Anorm * ynorm * tol\n        diag = gbar\n        if diag == 0:\n            diag = epsa\n        qrnorm = phibar\n        rnorm = qrnorm\n        if ynorm == 0 or Anorm == 0:\n            test1 = inf\n        else:\n            test1 = rnorm / (Anorm * ynorm)\n        if Anorm == 0:\n            test2 = inf\n        else:\n            test2 = root / Anorm\n        Acond = gmax / gmin\n        if istop == 0:\n            t1 = 1 + test1\n            t2 = 1 + test2\n            if t2 <= 1:\n                istop = 2\n            if t1 <= 1:\n                istop = 1\n            if itn >= maxiter:\n                istop = 6\n            if Acond >= 0.1 / eps:\n                istop = 4\n            if epsx >= beta1:\n                istop = 3\n            if test2 <= tol:\n                istop = 2\n            if test1 <= tol:\n                istop = 1\n        prnt = False\n        if n <= 40:\n            prnt = True\n        if itn <= 10:\n            prnt = True\n        if itn >= maxiter - 10:\n            prnt = True\n        if itn % 10 == 0:\n            prnt = True\n        if qrnorm <= 10 * epsx:\n            prnt = True\n        if qrnorm <= 10 * epsr:\n            prnt = True\n        if Acond <= 0.01 / eps:\n            prnt = True\n        if istop != 0:\n            prnt = True\n        if show and prnt:\n            str1 = f'{itn:6g} {x[0]:12.5e} {test1:10.3e}'\n            str2 = f' {test2:10.3e}'\n            str3 = f' {Anorm:8.1e} {Acond:8.1e} {gbar / Anorm:8.1e}'\n            print(str1 + str2 + str3)\n            if itn % 10 == 0:\n                print()\n        if callback is not None:\n            callback(x)\n        if istop != 0:\n            break\n    if show:\n        print()\n        print(last + f' istop   =  {istop:3g}               itn   ={itn:5g}')\n        print(last + f' Anorm   =  {Anorm:12.4e}      Acond =  {Acond:12.4e}')\n        print(last + f' rnorm   =  {rnorm:12.4e}      ynorm =  {ynorm:12.4e}')\n        print(last + f' Arnorm  =  {Arnorm:12.4e}')\n        print(last + msg[istop + 1])\n    if istop == 6:\n        info = maxiter\n    else:\n        info = 0\n    return (postprocess(x), info)",
            "@_deprecate_positional_args(version='1.14.0')\ndef minres(A, b, x0=None, *, shift=0.0, tol=1e-05, maxiter=None, M=None, callback=None, show=False, check=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Use MINimum RESidual iteration to solve Ax=b\\n\\n    MINRES minimizes norm(Ax - b) for a real symmetric matrix A.  Unlike\\n    the Conjugate Gradient method, A can be indefinite or singular.\\n\\n    If shift != 0 then the method solves (A - shift*I)x = b\\n\\n    Parameters\\n    ----------\\n    A : {sparse matrix, ndarray, LinearOperator}\\n        The real symmetric N-by-N matrix of the linear system\\n        Alternatively, ``A`` can be a linear operator which can\\n        produce ``Ax`` using, e.g.,\\n        ``scipy.sparse.linalg.LinearOperator``.\\n    b : ndarray\\n        Right hand side of the linear system. Has shape (N,) or (N,1).\\n\\n    Returns\\n    -------\\n    x : ndarray\\n        The converged solution.\\n    info : integer\\n        Provides convergence information:\\n            0  : successful exit\\n            >0 : convergence to tolerance not achieved, number of iterations\\n            <0 : illegal input or breakdown\\n\\n    Other Parameters\\n    ----------------\\n    x0 : ndarray\\n        Starting guess for the solution.\\n    shift : float\\n        Value to apply to the system ``(A - shift * I)x = b``. Default is 0.\\n    tol : float\\n        Tolerance to achieve. The algorithm terminates when the relative\\n        residual is below `tol`.\\n    maxiter : integer\\n        Maximum number of iterations.  Iteration will stop after maxiter\\n        steps even if the specified tolerance has not been achieved.\\n    M : {sparse matrix, ndarray, LinearOperator}\\n        Preconditioner for A.  The preconditioner should approximate the\\n        inverse of A.  Effective preconditioning dramatically improves the\\n        rate of convergence, which implies that fewer iterations are needed\\n        to reach a given error tolerance.\\n    callback : function\\n        User-supplied function to call after each iteration.  It is called\\n        as callback(xk), where xk is the current solution vector.\\n    show : bool\\n        If ``True``, print out a summary and metrics related to the solution\\n        during iterations. Default is ``False``.\\n    check : bool\\n        If ``True``, run additional input validation to check that `A` and\\n        `M` (if specified) are symmetric. Default is ``False``.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from scipy.sparse import csc_matrix\\n    >>> from scipy.sparse.linalg import minres\\n    >>> A = csc_matrix([[3, 2, 0], [1, -1, 0], [0, 5, 1]], dtype=float)\\n    >>> A = A + A.T\\n    >>> b = np.array([2, 4, -1], dtype=float)\\n    >>> x, exitCode = minres(A, b)\\n    >>> print(exitCode)            # 0 indicates successful convergence\\n    0\\n    >>> np.allclose(A.dot(x), b)\\n    True\\n\\n    References\\n    ----------\\n    Solution of sparse indefinite systems of linear equations,\\n        C. C. Paige and M. A. Saunders (1975),\\n        SIAM J. Numer. Anal. 12(4), pp. 617-629.\\n        https://web.stanford.edu/group/SOL/software/minres/\\n\\n    This file is a translation of the following MATLAB implementation:\\n        https://web.stanford.edu/group/SOL/software/minres/minres-matlab.zip\\n\\n    '\n    (A, M, x, b, postprocess) = make_system(A, M, x0, b)\n    matvec = A.matvec\n    psolve = M.matvec\n    first = 'Enter minres.   '\n    last = 'Exit  minres.   '\n    n = A.shape[0]\n    if maxiter is None:\n        maxiter = 5 * n\n    msg = [' beta2 = 0.  If M = I, b and x are eigenvectors    ', ' beta1 = 0.  The exact solution is x0          ', ' A solution to Ax = b was found, given rtol        ', ' A least-squares solution was found, given rtol    ', ' Reasonable accuracy achieved, given eps           ', ' x has converged to an eigenvector                 ', ' acond has exceeded 0.1/eps                        ', ' The iteration limit was reached                   ', ' A  does not define a symmetric matrix             ', ' M  does not define a symmetric matrix             ', ' M  does not define a pos-def preconditioner       ']\n    if show:\n        print(first + 'Solution of symmetric Ax = b')\n        print(first + f'n      =  {n:3g}     shift  =  {shift:23.14e}')\n        print(first + f'itnlim =  {maxiter:3g}     rtol   =  {tol:11.2e}')\n        print()\n    istop = 0\n    itn = 0\n    Anorm = 0\n    Acond = 0\n    rnorm = 0\n    ynorm = 0\n    xtype = x.dtype\n    eps = finfo(xtype).eps\n    if x0 is None:\n        r1 = b.copy()\n    else:\n        r1 = b - A @ x\n    y = psolve(r1)\n    beta1 = inner(r1, y)\n    if beta1 < 0:\n        raise ValueError('indefinite preconditioner')\n    elif beta1 == 0:\n        return (postprocess(x), 0)\n    bnorm = norm(b)\n    if bnorm == 0:\n        x = b\n        return (postprocess(x), 0)\n    beta1 = sqrt(beta1)\n    if check:\n        w = matvec(y)\n        r2 = matvec(w)\n        s = inner(w, w)\n        t = inner(y, r2)\n        z = abs(s - t)\n        epsa = (s + eps) * eps ** (1.0 / 3.0)\n        if z > epsa:\n            raise ValueError('non-symmetric matrix')\n        r2 = psolve(y)\n        s = inner(y, y)\n        t = inner(r1, r2)\n        z = abs(s - t)\n        epsa = (s + eps) * eps ** (1.0 / 3.0)\n        if z > epsa:\n            raise ValueError('non-symmetric preconditioner')\n    oldb = 0\n    beta = beta1\n    dbar = 0\n    epsln = 0\n    qrnorm = beta1\n    phibar = beta1\n    rhs1 = beta1\n    rhs2 = 0\n    tnorm2 = 0\n    gmax = 0\n    gmin = finfo(xtype).max\n    cs = -1\n    sn = 0\n    w = zeros(n, dtype=xtype)\n    w2 = zeros(n, dtype=xtype)\n    r2 = r1\n    if show:\n        print()\n        print()\n        print('   Itn     x(1)     Compatible    LS       norm(A)  cond(A) gbar/|A|')\n    while itn < maxiter:\n        itn += 1\n        s = 1.0 / beta\n        v = s * y\n        y = matvec(v)\n        y = y - shift * v\n        if itn >= 2:\n            y = y - beta / oldb * r1\n        alfa = inner(v, y)\n        y = y - alfa / beta * r2\n        r1 = r2\n        r2 = y\n        y = psolve(r2)\n        oldb = beta\n        beta = inner(r2, y)\n        if beta < 0:\n            raise ValueError('non-symmetric matrix')\n        beta = sqrt(beta)\n        tnorm2 += alfa ** 2 + oldb ** 2 + beta ** 2\n        if itn == 1:\n            if beta / beta1 <= 10 * eps:\n                istop = -1\n        oldeps = epsln\n        delta = cs * dbar + sn * alfa\n        gbar = sn * dbar - cs * alfa\n        epsln = sn * beta\n        dbar = -cs * beta\n        root = norm([gbar, dbar])\n        Arnorm = phibar * root\n        gamma = norm([gbar, beta])\n        gamma = max(gamma, eps)\n        cs = gbar / gamma\n        sn = beta / gamma\n        phi = cs * phibar\n        phibar = sn * phibar\n        denom = 1.0 / gamma\n        w1 = w2\n        w2 = w\n        w = (v - oldeps * w1 - delta * w2) * denom\n        x = x + phi * w\n        gmax = max(gmax, gamma)\n        gmin = min(gmin, gamma)\n        z = rhs1 / gamma\n        rhs1 = rhs2 - delta * z\n        rhs2 = -epsln * z\n        Anorm = sqrt(tnorm2)\n        ynorm = norm(x)\n        epsa = Anorm * eps\n        epsx = Anorm * ynorm * eps\n        epsr = Anorm * ynorm * tol\n        diag = gbar\n        if diag == 0:\n            diag = epsa\n        qrnorm = phibar\n        rnorm = qrnorm\n        if ynorm == 0 or Anorm == 0:\n            test1 = inf\n        else:\n            test1 = rnorm / (Anorm * ynorm)\n        if Anorm == 0:\n            test2 = inf\n        else:\n            test2 = root / Anorm\n        Acond = gmax / gmin\n        if istop == 0:\n            t1 = 1 + test1\n            t2 = 1 + test2\n            if t2 <= 1:\n                istop = 2\n            if t1 <= 1:\n                istop = 1\n            if itn >= maxiter:\n                istop = 6\n            if Acond >= 0.1 / eps:\n                istop = 4\n            if epsx >= beta1:\n                istop = 3\n            if test2 <= tol:\n                istop = 2\n            if test1 <= tol:\n                istop = 1\n        prnt = False\n        if n <= 40:\n            prnt = True\n        if itn <= 10:\n            prnt = True\n        if itn >= maxiter - 10:\n            prnt = True\n        if itn % 10 == 0:\n            prnt = True\n        if qrnorm <= 10 * epsx:\n            prnt = True\n        if qrnorm <= 10 * epsr:\n            prnt = True\n        if Acond <= 0.01 / eps:\n            prnt = True\n        if istop != 0:\n            prnt = True\n        if show and prnt:\n            str1 = f'{itn:6g} {x[0]:12.5e} {test1:10.3e}'\n            str2 = f' {test2:10.3e}'\n            str3 = f' {Anorm:8.1e} {Acond:8.1e} {gbar / Anorm:8.1e}'\n            print(str1 + str2 + str3)\n            if itn % 10 == 0:\n                print()\n        if callback is not None:\n            callback(x)\n        if istop != 0:\n            break\n    if show:\n        print()\n        print(last + f' istop   =  {istop:3g}               itn   ={itn:5g}')\n        print(last + f' Anorm   =  {Anorm:12.4e}      Acond =  {Acond:12.4e}')\n        print(last + f' rnorm   =  {rnorm:12.4e}      ynorm =  {ynorm:12.4e}')\n        print(last + f' Arnorm  =  {Arnorm:12.4e}')\n        print(last + msg[istop + 1])\n    if istop == 6:\n        info = maxiter\n    else:\n        info = 0\n    return (postprocess(x), info)",
            "@_deprecate_positional_args(version='1.14.0')\ndef minres(A, b, x0=None, *, shift=0.0, tol=1e-05, maxiter=None, M=None, callback=None, show=False, check=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Use MINimum RESidual iteration to solve Ax=b\\n\\n    MINRES minimizes norm(Ax - b) for a real symmetric matrix A.  Unlike\\n    the Conjugate Gradient method, A can be indefinite or singular.\\n\\n    If shift != 0 then the method solves (A - shift*I)x = b\\n\\n    Parameters\\n    ----------\\n    A : {sparse matrix, ndarray, LinearOperator}\\n        The real symmetric N-by-N matrix of the linear system\\n        Alternatively, ``A`` can be a linear operator which can\\n        produce ``Ax`` using, e.g.,\\n        ``scipy.sparse.linalg.LinearOperator``.\\n    b : ndarray\\n        Right hand side of the linear system. Has shape (N,) or (N,1).\\n\\n    Returns\\n    -------\\n    x : ndarray\\n        The converged solution.\\n    info : integer\\n        Provides convergence information:\\n            0  : successful exit\\n            >0 : convergence to tolerance not achieved, number of iterations\\n            <0 : illegal input or breakdown\\n\\n    Other Parameters\\n    ----------------\\n    x0 : ndarray\\n        Starting guess for the solution.\\n    shift : float\\n        Value to apply to the system ``(A - shift * I)x = b``. Default is 0.\\n    tol : float\\n        Tolerance to achieve. The algorithm terminates when the relative\\n        residual is below `tol`.\\n    maxiter : integer\\n        Maximum number of iterations.  Iteration will stop after maxiter\\n        steps even if the specified tolerance has not been achieved.\\n    M : {sparse matrix, ndarray, LinearOperator}\\n        Preconditioner for A.  The preconditioner should approximate the\\n        inverse of A.  Effective preconditioning dramatically improves the\\n        rate of convergence, which implies that fewer iterations are needed\\n        to reach a given error tolerance.\\n    callback : function\\n        User-supplied function to call after each iteration.  It is called\\n        as callback(xk), where xk is the current solution vector.\\n    show : bool\\n        If ``True``, print out a summary and metrics related to the solution\\n        during iterations. Default is ``False``.\\n    check : bool\\n        If ``True``, run additional input validation to check that `A` and\\n        `M` (if specified) are symmetric. Default is ``False``.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from scipy.sparse import csc_matrix\\n    >>> from scipy.sparse.linalg import minres\\n    >>> A = csc_matrix([[3, 2, 0], [1, -1, 0], [0, 5, 1]], dtype=float)\\n    >>> A = A + A.T\\n    >>> b = np.array([2, 4, -1], dtype=float)\\n    >>> x, exitCode = minres(A, b)\\n    >>> print(exitCode)            # 0 indicates successful convergence\\n    0\\n    >>> np.allclose(A.dot(x), b)\\n    True\\n\\n    References\\n    ----------\\n    Solution of sparse indefinite systems of linear equations,\\n        C. C. Paige and M. A. Saunders (1975),\\n        SIAM J. Numer. Anal. 12(4), pp. 617-629.\\n        https://web.stanford.edu/group/SOL/software/minres/\\n\\n    This file is a translation of the following MATLAB implementation:\\n        https://web.stanford.edu/group/SOL/software/minres/minres-matlab.zip\\n\\n    '\n    (A, M, x, b, postprocess) = make_system(A, M, x0, b)\n    matvec = A.matvec\n    psolve = M.matvec\n    first = 'Enter minres.   '\n    last = 'Exit  minres.   '\n    n = A.shape[0]\n    if maxiter is None:\n        maxiter = 5 * n\n    msg = [' beta2 = 0.  If M = I, b and x are eigenvectors    ', ' beta1 = 0.  The exact solution is x0          ', ' A solution to Ax = b was found, given rtol        ', ' A least-squares solution was found, given rtol    ', ' Reasonable accuracy achieved, given eps           ', ' x has converged to an eigenvector                 ', ' acond has exceeded 0.1/eps                        ', ' The iteration limit was reached                   ', ' A  does not define a symmetric matrix             ', ' M  does not define a symmetric matrix             ', ' M  does not define a pos-def preconditioner       ']\n    if show:\n        print(first + 'Solution of symmetric Ax = b')\n        print(first + f'n      =  {n:3g}     shift  =  {shift:23.14e}')\n        print(first + f'itnlim =  {maxiter:3g}     rtol   =  {tol:11.2e}')\n        print()\n    istop = 0\n    itn = 0\n    Anorm = 0\n    Acond = 0\n    rnorm = 0\n    ynorm = 0\n    xtype = x.dtype\n    eps = finfo(xtype).eps\n    if x0 is None:\n        r1 = b.copy()\n    else:\n        r1 = b - A @ x\n    y = psolve(r1)\n    beta1 = inner(r1, y)\n    if beta1 < 0:\n        raise ValueError('indefinite preconditioner')\n    elif beta1 == 0:\n        return (postprocess(x), 0)\n    bnorm = norm(b)\n    if bnorm == 0:\n        x = b\n        return (postprocess(x), 0)\n    beta1 = sqrt(beta1)\n    if check:\n        w = matvec(y)\n        r2 = matvec(w)\n        s = inner(w, w)\n        t = inner(y, r2)\n        z = abs(s - t)\n        epsa = (s + eps) * eps ** (1.0 / 3.0)\n        if z > epsa:\n            raise ValueError('non-symmetric matrix')\n        r2 = psolve(y)\n        s = inner(y, y)\n        t = inner(r1, r2)\n        z = abs(s - t)\n        epsa = (s + eps) * eps ** (1.0 / 3.0)\n        if z > epsa:\n            raise ValueError('non-symmetric preconditioner')\n    oldb = 0\n    beta = beta1\n    dbar = 0\n    epsln = 0\n    qrnorm = beta1\n    phibar = beta1\n    rhs1 = beta1\n    rhs2 = 0\n    tnorm2 = 0\n    gmax = 0\n    gmin = finfo(xtype).max\n    cs = -1\n    sn = 0\n    w = zeros(n, dtype=xtype)\n    w2 = zeros(n, dtype=xtype)\n    r2 = r1\n    if show:\n        print()\n        print()\n        print('   Itn     x(1)     Compatible    LS       norm(A)  cond(A) gbar/|A|')\n    while itn < maxiter:\n        itn += 1\n        s = 1.0 / beta\n        v = s * y\n        y = matvec(v)\n        y = y - shift * v\n        if itn >= 2:\n            y = y - beta / oldb * r1\n        alfa = inner(v, y)\n        y = y - alfa / beta * r2\n        r1 = r2\n        r2 = y\n        y = psolve(r2)\n        oldb = beta\n        beta = inner(r2, y)\n        if beta < 0:\n            raise ValueError('non-symmetric matrix')\n        beta = sqrt(beta)\n        tnorm2 += alfa ** 2 + oldb ** 2 + beta ** 2\n        if itn == 1:\n            if beta / beta1 <= 10 * eps:\n                istop = -1\n        oldeps = epsln\n        delta = cs * dbar + sn * alfa\n        gbar = sn * dbar - cs * alfa\n        epsln = sn * beta\n        dbar = -cs * beta\n        root = norm([gbar, dbar])\n        Arnorm = phibar * root\n        gamma = norm([gbar, beta])\n        gamma = max(gamma, eps)\n        cs = gbar / gamma\n        sn = beta / gamma\n        phi = cs * phibar\n        phibar = sn * phibar\n        denom = 1.0 / gamma\n        w1 = w2\n        w2 = w\n        w = (v - oldeps * w1 - delta * w2) * denom\n        x = x + phi * w\n        gmax = max(gmax, gamma)\n        gmin = min(gmin, gamma)\n        z = rhs1 / gamma\n        rhs1 = rhs2 - delta * z\n        rhs2 = -epsln * z\n        Anorm = sqrt(tnorm2)\n        ynorm = norm(x)\n        epsa = Anorm * eps\n        epsx = Anorm * ynorm * eps\n        epsr = Anorm * ynorm * tol\n        diag = gbar\n        if diag == 0:\n            diag = epsa\n        qrnorm = phibar\n        rnorm = qrnorm\n        if ynorm == 0 or Anorm == 0:\n            test1 = inf\n        else:\n            test1 = rnorm / (Anorm * ynorm)\n        if Anorm == 0:\n            test2 = inf\n        else:\n            test2 = root / Anorm\n        Acond = gmax / gmin\n        if istop == 0:\n            t1 = 1 + test1\n            t2 = 1 + test2\n            if t2 <= 1:\n                istop = 2\n            if t1 <= 1:\n                istop = 1\n            if itn >= maxiter:\n                istop = 6\n            if Acond >= 0.1 / eps:\n                istop = 4\n            if epsx >= beta1:\n                istop = 3\n            if test2 <= tol:\n                istop = 2\n            if test1 <= tol:\n                istop = 1\n        prnt = False\n        if n <= 40:\n            prnt = True\n        if itn <= 10:\n            prnt = True\n        if itn >= maxiter - 10:\n            prnt = True\n        if itn % 10 == 0:\n            prnt = True\n        if qrnorm <= 10 * epsx:\n            prnt = True\n        if qrnorm <= 10 * epsr:\n            prnt = True\n        if Acond <= 0.01 / eps:\n            prnt = True\n        if istop != 0:\n            prnt = True\n        if show and prnt:\n            str1 = f'{itn:6g} {x[0]:12.5e} {test1:10.3e}'\n            str2 = f' {test2:10.3e}'\n            str3 = f' {Anorm:8.1e} {Acond:8.1e} {gbar / Anorm:8.1e}'\n            print(str1 + str2 + str3)\n            if itn % 10 == 0:\n                print()\n        if callback is not None:\n            callback(x)\n        if istop != 0:\n            break\n    if show:\n        print()\n        print(last + f' istop   =  {istop:3g}               itn   ={itn:5g}')\n        print(last + f' Anorm   =  {Anorm:12.4e}      Acond =  {Acond:12.4e}')\n        print(last + f' rnorm   =  {rnorm:12.4e}      ynorm =  {ynorm:12.4e}')\n        print(last + f' Arnorm  =  {Arnorm:12.4e}')\n        print(last + msg[istop + 1])\n    if istop == 6:\n        info = maxiter\n    else:\n        info = 0\n    return (postprocess(x), info)"
        ]
    }
]